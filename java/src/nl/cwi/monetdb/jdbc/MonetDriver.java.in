/*
 * The contents of this file are subject to the MonetDB Public License
 * Version 1.1 (the "License"); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 * http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
 *
 * Software distributed under the License is distributed on an "AS IS"
 * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
 * License for the specific language governing rights and limitations
 * under the License.
 *
 * The Original Code is the MonetDB Database System.
 *
 * The Initial Developer of the Original Code is CWI.
 * Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
 * Copyright August 2008-2011 MonetDB B.V.
 * All Rights Reserved.
 */

package nl.cwi.monetdb.jdbc;

import java.sql.*;
import java.util.*;
import java.net.*;

/**
 * A Driver suitable for the MonetDB database.
 * <br /><br />
 * This driver will be used by the DriverManager to determine if an URL
 * is to be handled by this driver, and if it does, then this driver
 * will supply a Connection suitable for MonetDB.
 * <br /><br />
 * This class has no explicit constructor, the default constructor
 * generated by the Java compiler will be sufficient since nothing has
 * to be set in order to use this driver.
 * <br /><br />
 * This Driver supports MonetDB database URLs. MonetDB URLs are defined
 * as:<br />
 * <tt>jdbc:monetdb://&lt;host&gt;[:&lt;port&gt;]/&lt;database&gt;</tt>
 * <br /> where [:&lt;port&gt;] denotes that a port is optional. If not
 * given the default (@JDBC_DEF_PORT@) will be used.
 *
 * @author Fabian Groffen <Fabian.Groffen@cwi.nl>
 * @version @JDBC_MAJOR@.@JDBC_MINOR@ (@JDBC_VER_SUFFIX@)
 */
final public class MonetDriver implements Driver {
	// the url kind will be jdbc:monetdb://<host>[:<port>]/<database>
	// Chapter 9.2.1 from Sun JDBC 3.0 specification
	/** The prefix of a MonetDB url */
	private static final String MONETURL = "jdbc:monetdb://";
	/** Major version of this driver */
	private static final int DRIVERMAJOR = @JDBC_MAJOR@;
	/** Minor version of this driver */
	private static final int DRIVERMINOR = @JDBC_MINOR@;
	/** Version suffix string */
	private static final String DRIVERVERSIONSUFFIX =
		"@JDBC_VER_SUFFIX@ based on MCL v@MCL_MAJOR@.@MCL_MINOR@";
	// We're not fully compliant, but what we support is compliant
	/** Whether this driver is JDBC compliant or not */
	private static final boolean MONETJDBCCOMPLIANT = false;

	/** MonetDB default port to connect to */
	private static final String PORT = "@JDBC_DEF_PORT@";


	// initialize this class: register it at the DriverManager
	// Chapter 9.2 from Sun JDBC 3.0 specification
	static {
		try {
			DriverManager.registerDriver(new MonetDriver());
 		} catch (SQLException e) {
			e.printStackTrace();
		}
	}

	//== methods of interface Driver

	/**
	 * Retrieves whether the driver thinks that it can open a connection to the
	 * given URL. Typically drivers will return true if they understand the
	 * subprotocol specified in the URL and false if they do not.
	 *
	 * @param url the URL of the database
	 * @return true if this driver understands the given URL; false otherwise
	 */
	public boolean acceptsURL(String url) {
		return(url != null && url.startsWith(MONETURL));
	}

	/**
	 * Attempts to make a database connection to the given URL. The driver
	 * should return "null" if it realizes it is the wrong kind of driver to
	 * connect to the given URL. This will be common, as when the JDBC driver
	 * manager is asked to connect to a given URL it passes the URL to each
	 * loaded driver in turn.
	 * <br /><br />
	 * The driver should throw an SQLException if it is the right driver to
	 * connect to the given URL but has trouble connecting to the database.
	 * <br /><br />
	 * The java.util.Properties argument can be used to pass arbitrary string
	 * tag/value pairs as connection arguments. Normally at least "user" and
	 * "password" properties should be included in the Properties object.
	 *
	 * @param url the URL of the database to which to connect
	 * @param info a list of arbitrary string tag/value pairs as connection
	 *        arguments. Normally at least a "user" and "password" property
	 *        should be included
	 * @return a Connection object that represents a connection to the URL
	 * @throws SQLException if a database access error occurs
	 */
	public Connection connect(String url, Properties info)
		throws SQLException
	{
		int tmp;
		Properties props = new Properties();
		// set the optional properties and their defaults here
		props.put("port", PORT);
		props.put("debug", "false");
		props.put("language", "sql");	// mal, sql, <future>

		props.putAll(info);
		info = props;

		// url should be of style jdbc:monetdb://<host>/<database>
		if (!acceptsURL(url)) return(null);

		// remove leading "jdbc:" so the rest is a valid hierarchical URI
		URI uri;
		try {
			uri = new URI(url.substring(5));
		} catch (URISyntaxException e) {
			throw new SQLException(e.toString());
		}

		if (uri.getHost() == null) throw
			new SQLException("Invalid URL: no hostname given or " +
					"unparsable in '" + url + "'");
		info.put("host", uri.getHost());
		if (uri.getPort() > 0) info.put("port", "" + uri.getPort());

		// check the database
		if (uri.getPath() != null && uri.getPath().length() != 0 &&
				!uri.getPath().substring(1).trim().equals(""))
		{
			info.put("database", uri.getPath().substring(1));
		}

		if (uri.getQuery() != null) {
			// handle additional arguments
			String args[] = uri.getQuery().split("&");
			for (int i = 0; i < args.length; i++) {
				tmp = args[i].indexOf("=");
				if (tmp > 0) info.put(args[i].substring(0, tmp), args[i].substring(tmp + 1));
			}
		}

		// finally return the Connection as requested
		return(new MonetConnection(info));
	}

	/**
	 * Retrieves the driver's major version number. Initially this should be 1.
	 *
	 * @return this driver's major version number
	 */
	public int getMajorVersion() {
		return(DRIVERMAJOR);
	}

	/**
	 * Gets the driver's minor version number. Initially this should be 0.
	 *
	 * @return this driver's minor version number
	 */
	public int getMinorVersion() {
		return(DRIVERMINOR);
	}

	/**
	 * Gets information about the possible properties for this driver.
	 * <br /><br />
	 * The getPropertyInfo method is intended to allow a generic GUI tool to
	 * discover what properties it should prompt a human for in order to get
	 * enough information to connect to a database. Note that depending on the
	 * values the human has supplied so far, additional values may become
	 * necessary, so it may be necessary to iterate though several calls to the
	 * getPropertyInfo method.
	 *
	 * @param url the URL of the database to which to connect
	 * @param info a proposed list of tag/value pairs that will be sent on
	 *        connect open
	 * @return an array of DriverPropertyInfo objects describing possible
	 *         properties. This array may be an empty array if no properties
	 *         are required.
	 */
	public DriverPropertyInfo[] getPropertyInfo(String url, Properties info) {
		if (!acceptsURL(url)) return(null);

		ArrayList props = new ArrayList();
		DriverPropertyInfo prop;

		prop = new DriverPropertyInfo("user", info.getProperty("user"));
		prop.required = true;
		prop.description = "The username to use when authenticating on the database";
		props.add(prop);

		prop = new DriverPropertyInfo("password", info.getProperty("password"));
		prop.required = true;
		prop.description = "The password to use when authenticating on the database";
		props.add(prop);

		prop = new DriverPropertyInfo("debug", "false");
		prop.required = false;
		prop.description = "Whether or not to create a log file for debugging purposes";
		props.add(prop);

		prop = new DriverPropertyInfo("logfile", "");
		prop.required = false;
		prop.description = "The filename to write the debug log to.  Only takes effect if debug is set to true.  If the file exists, an incrementing number is added, till the filename is unique.";
		props.add(prop);

		prop = new DriverPropertyInfo("language", "sql");
		prop.required = false;
		prop.description = "What language to use for MonetDB conversations (experts only)";
		props.add(prop);

		prop = new DriverPropertyInfo("hash", "");
		prop.required = false;
		prop.description = "Force the use of the given hash algorithm during challenge response (one of SHA1, MD5, plain)";
		props.add(prop);

		prop = new DriverPropertyInfo("java_prepared_statements", "false");
		prop.required = false;
		prop.description = "Whether Java emulated prepared statements (true) or a server side prepated statements (false) should be used";
		props.add(prop);

		prop = new DriverPropertyInfo("follow_redirects", "true");
		prop.required = false;
		prop.description = "Whether redirects issued by the server should be followed";
		props.add(prop);

		prop = new DriverPropertyInfo("treat_blob_as_binary", "false");
		prop.required = false;
		prop.description = "Whether BLOBs on the server should be treated as BINARY types, thus mapped to byte[]";
		props.add(prop);

		DriverPropertyInfo[] dpi = new DriverPropertyInfo[props.size()];
		return((DriverPropertyInfo[])props.toArray(dpi));
	}

	/**
	 * Reports whether this driver is a genuine JDBC Compliant&tm; driver. A
	 * driver may only report true here if it passes the JDBC compliance tests;
	 * otherwise it is required to return false.
	 * <br /><br />
	 * JDBC compliance requires full support for the JDBC API and full support
	 * for SQL 92 Entry Level. It is expected that JDBC compliant drivers will
	 * be available for all the major commercial databases.
	 * <br /><br />
	 * This method is not intended to encourage the development of non-JDBC
	 * compliant drivers, but is a recognition of the fact that some vendors are
	 * interested in using the JDBC API and framework for lightweight databases
	 * that do not support full database functionality, or for special databases
	 * such as document information retrieval where a SQL implementation may not
	 * be feasible.
	 *
	 * @return true if this driver is JDBC Compliant; false otherwise
	 */
	public boolean jdbcCompliant() {
		return(MONETJDBCCOMPLIANT);
	}

	//== end methods of interface driver

	/** A Map containing the mapping between MonetDB types and Java SQL types */
	static java.util.Map typeMap = new java.util.HashMap();
	static {
		// fill the typeMap once
		typeMap.put("bigint", new Integer(Types.BIGINT));
		typeMap.put("blob", new Integer(Types.BLOB));
		typeMap.put("boolean", new Integer(Types.BOOLEAN));
		typeMap.put("char", new Integer(Types.CHAR));
		typeMap.put("clob", new Integer(Types.CLOB));
		typeMap.put("date", new Integer(Types.DATE));
		typeMap.put("decimal", new Integer(Types.DECIMAL));
		typeMap.put("double", new Integer(Types.DOUBLE));
		typeMap.put("int", new Integer(Types.INTEGER));
		typeMap.put("month_interval", new Integer(Types.INTEGER));
		typeMap.put("oid", new Integer(Types.OTHER));
		typeMap.put("real", new Integer(Types.REAL));
		typeMap.put("sec_interval", new Integer(Types.BIGINT));
		typeMap.put("smallint", new Integer(Types.SMALLINT));
		typeMap.put("table", new Integer(Types.ARRAY));
		typeMap.put("time", new Integer(Types.TIME));
		typeMap.put("timestamp", new Integer(Types.TIMESTAMP));
		typeMap.put("timestamptz", new Integer(Types.TIMESTAMP));
		typeMap.put("timetz", new Integer(Types.TIME));
		typeMap.put("tinyint", new Integer(Types.TINYINT));
		typeMap.put("varchar", new Integer(Types.VARCHAR));
		typeMap.put("wrd", new Integer(Types.BIGINT));
	}

	/**
	 * Returns the java.sql.Types equivalent of the given MonetDB type.
	 *
	 * @param type the type as used by MonetDB
	 * @return the mathing java.sql.Types constant or java.sql.Types.OTHER if
	 *         nothing matched on the given string
	 */
	static int getJavaType(String type) {
		// match the column type on a java.sql.Types constant
		Integer tp;
		if ((tp = (Integer)(typeMap.get(type.toLowerCase()))) != null) {
			return(tp.intValue());
		} else {
			// this should not be able to happen
			// do not assert, since maybe future versions introduce
			// new types
			return(Types.OTHER);
		}
	}

	/**
	 * Returns a String usable in an SQL statement to map the server types
	 * to values of java.sql.Types using the global type map.  The returned
	 * string will be a SQL CASE x statement where the x is replaced with
	 * the given string.
	 *
	 * @param column a String representing the value that should be evaluated
	 *               in the SQL CASE statement
	 * @return a SQL CASE statement
	 */
	static String getSQLTypeMap(String column) {
		String ret = "CASE " + column + " ";
		Iterator it = typeMap.keySet().iterator();
		while (it.hasNext()) {
			String key = (String)it.next();
			ret += "WHEN '" + key + "' THEN " + typeMap.get(key).toString() + " ";
		}
		ret += "ELSE " + Types.OTHER + " END";
		
		return(ret);
	}

	/**
	 * Returns a touched up identifying version string of this driver.
	 *
	 * @return the version string
	 */
	public static String getDriverVersion() {
		return("" + DRIVERMAJOR + "." + DRIVERMINOR + " (" + DRIVERVERSIONSUFFIX + ")");
	}
}
