@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.monetdb.org/Legal/MonetDBLicense

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2011 MonetDB B.V.
All Rights Reserved.
@

@f sql

@c
/*
 * @t SQL Scenario implementation
 * @a M Kersten
 * @v 0
 * @* SQL support implementation
 * This module contains the wrappers around the SQL
 * multi-version-catalog and support routines copied
 * from the Version 4 code base.
 */
@mal
module batsql;
module sql;

pattern start():void 
address SQLsession
comment "Switch to processing SQL statements";

pattern start2():void
address SQLsession2
comment "Switch to processing precompiled sql statements";

pattern init():void
address SQLinitEnvironment
comment "Initialize the environment for MAL";

pattern mvc():int
address SQLmvc
comment "get the multiversion catalog context, needed for correct statement dependencies (ie sql.update, should be after sql.bind in concurrent execution)";

pattern trans(type:int,chain:int,name:str):void
address SQLtransaction
comment "a transaction statement (type can be commit,release,rollback or start)";

pattern transaction{unsafe}()
address SQLtransaction2
comment "Start an autocommit transaction";

pattern commit()
address SQLcommit
comment "Trigger the commit operation for a MAL block";

pattern catalog(type:int,sname:str,name:str,action:int):void
address SQLcatalog
comment "a catalog statement";

pattern catalog(type:int,sname:str,t:ptr,temp:int):void
address SQLcatalog
comment "a catalog statement";

pattern catalog(type:int,sname:str,t:ptr,restart:lng):void
address SQLcatalog
comment "a catalog statement";

pattern catalog(type:int,grantee:str,role:str):void
address SQLcatalog
comment "a grant/revoke role statement";

pattern catalog(type:int,user:str,passwd:str,enc:int,schema:str,fullname:str):void
address SQLcatalog
comment "a user catalog statement";

pattern catalog(type:int,tname:str,grantee:str,privs:int,cname:str,grant:int,grantor:int):void
address SQLcatalog
comment "a grant/revoke privileges statement";

pattern catalog(type:int,iname:str,itype:int,sname:str,tname:str...):void
address SQLcatalog
comment "a create index catalog statement";

pattern eval(cmd:str):void 
address SQLstatement
comment "Compile and execute a single sql statement";

pattern eval(cmd:str, output:bit):void 
address SQLstatement
comment "Compile and execute a single sql statement (and optionaly send output on the output stream)";

pattern include(fname:str):void 
address SQLinclude
comment "Compile and execute a sql statements on the file";

pattern ra(cmd:str, optimize:bit):void
address RAstatement
comment "Compile and execute a single 'relational algebra' statement";

pattern assert(b:bit,msg:str):void
address SQLassert
comment "Generate an exception when b==true";

pattern assert(b:int,msg:str):void
address SQLassertInt
comment "Generate an exception when b!=0";

pattern assert(b:wrd,msg:str):void
address SQLassertWrd
comment "Generate an exception when b!=0";

pattern assert(b:lng,msg:str):void
address SQLassertLng
comment "Generate an exception when b!=0";
# @- The SQL multi-version catalog
# This module also contains the definitions for managing an SQL database schema in
# version 5.  It is an adaptation of the original V4.3 code base.
# A main difference is that the global catalog is obtained from
# the client record, rather then lookup the variable in a context stack.
#
# The MAL operations below are used in the SQL->MAL compiler and
# can be (sparingly) used to inspect it from a MIL console.
# The 'mvc_' header is removed, because all commands are already
# prepended by the 'sql.' module name.
# The original code is retained, because it makes it
# easier to later re-use part of the catalog code in a separately.

pattern setVariable(mvc:int, varname:str, value:any_1 ):int
address setVariable
comment "Set the value of a session variable";

pattern getVariable(mvc:int, varname:str ):any_1
address getVariable
comment "Get the value of a session variable";

pattern logfile{unsafe}(filename:str):void 
address mvc_logfile
comment "Enable/disable saving the sql statement traces";

pattern next_value( sname:str, sequence:str ):lng
address mvc_next_value
comment "return the next value of the sequence";

pattern batsql.next_value( sname:bat[:oid,:str], sequence:str ) :bat[:oid,:lng]
address mvc_bat_next_value
comment "return the next value of the sequence";

pattern get_value( sname:str, sequence:str ):lng
address mvc_get_value
comment "return the current value of the sequence";

pattern restart{unsafe}( sname:str, sequence:str, start:lng ):lng
address mvc_restart_seq
comment "restart the sequence with value start";

pattern bind_dbat(mvc:int, schema:str, table:str, access:int):bat[:oid,:oid]
address mvc_bind_dbat_wrap
comment "Bind to 'schema.table' BAT with deleted objecs
and with specific access kind:
	0 - base table
	1 - inserts
	2 - updates";

pattern bind_idxbat(mvc:int, schema:str, table:str, index:str, access:int):bat[:oid,:any_1]
address mvc_bind_idxbat_wrap
comment "Bind the 'schema.table.index' BAT with access kind:
	0 - base table
	1 - inserts
	2 - updates";

pattern bind_idxbat(mvc:int, schema:str, table:str, index:str, access:int, low:oid, hgh:oid):bat[:oid,:any_1]
address mvc_bind_idxbat_wrap
comment "Bind the 'schema.table.index' BAT with access kind:
	0 - base table
	1 - inserts
	2 - updates";

pattern bind_idxbat(mvc:int, schema:str, table:str, index:str, access:int, part_nr:int, nr_parts:int):bat[:oid,:any_1]
address mvc_bind_idxbat_wrap
comment "Bind the 'schema.table.index' BAT with access kind:
	0 - base table
	1 - inserts
	2 - updates";

pattern bind(mvc:int, schema:str, table:str, column:str, access:int ):bat[:oid,:any_1]
address mvc_bind_wrap
comment "Bind the 'schema.table.column' BAT with access kind:
	0 - base table
	1 - inserts
	2 - updates";

pattern bind(mvc:int, schema:str, table:str, column:str, access:int, low:oid, hgh:oid ):bat[:oid,:any_1]
address mvc_bind_wrap
comment "Bind the 'schema.table.column' BAT partition with access kind:
	0 - base table
	1 - inserts
	2 - updates";

pattern bind(mvc:int, schema:str, table:str, column:str, access:int, part_nr:int, nr_parts:int ):bat[:oid,:any_1]
address mvc_bind_wrap
comment "Bind the 'schema.table.column' BAT partition with access kind:
	0 - base table
	1 - inserts
	2 - updates";

command bind_dbat(clientid:int, schema:str, table:str, access:int, oldversion:lng, version:lng):bat[:oid,:oid]
address mvc_diff_dbat_wrap
comment "Bind to 'schema.table' BAT with deleted objecs
and with specific access kind:
	0 - base table
	1 - inserts
	2 - updates";

command getVersion(clientid:int):lng
address mvc_getVersion
comment "Return the database version identifier for a client";

pattern append(mvc:int, sname:str, tname:str, cname:str, ins:any):int
address mvc_append_wrap
comment "Append b to the column tname.cname (possibly optimized to replace the insert bat of tname.cname (returns sequence number for order dependence)";

pattern update(mvc:int, sname:str, tname:str, cname:str, ins:any):int
address mvc_update_wrap
comment "Append b to the column tname.cname (possibly optimized to replace the insert bat of tname.cname (returns sequence number for order dependence)";

pattern clear_table{unsafe}(sname:str, tname:str) :wrd
address mvc_clear_table_wrap
comment "Clear table";

pattern delete{unsafe}(mvc:int, sname:str, tname:str, b:any):int
address mvc_delete_wrap
comment "delete from table";

command columnBind(b:bat[:str,:bat], nme:str) :bat[:oid,:any_1]
address mvc_bind_single_wrap
comment "Bind the column bat into the focus ";

# @-
# The Monet 5 code generator uses several SQL specific wrapper functions.
pattern resultSet{unsafe}( nr_cols:int, sep:str, rsep:str, ssep:str, ns:str, order:any_1 ) :int 
address mvc_result_file_wrap
comment "Prepare a file result set"; 

pattern resultSet{unsafe}( nr_cols:int, sep:str, rsep:str, ssep:str, ns:str, order:bat[:oid,:any_1] ) :int 
address mvc_result_file_wrap
comment "Prepare a file result set"; 

pattern resultSet{unsafe}( nr_cols:int, qtype:int, order:any_1 ) :int 
address mvc_result_row_wrap
comment "Prepare a row result set"; 

pattern resultSet{unsafe}( nr_cols:int, qtype:int, order:bat[:oid,:any_1] ) :int 
address mvc_result_table_wrap
comment "Prepare a table result set"; 

pattern rsColumn{unsafe}(rs:int, tname:str, name:str, typename:str, digits:int, scale:int, val:any_1 ) :void
address mvc_result_value_wrap
comment "Add the value to the row query result";

pattern rsColumn{unsafe}(rs:int, tname:str, name:str, typename:str, digits:int, scale:int, col:bat[:oid,:any_1] ) :void
address mvc_result_column_wrap
comment "Add the column to the table query result";

pattern declaredTable{unsafe}( name:str ) :int 
address mvc_declared_table_wrap
comment "Prepare a declared table"; 

pattern dtColumn{unsafe}(rs:int, tname:str, name:str, typename:str, digits:int, scale:int) :void
address mvc_declared_table_column_wrap;

pattern dropDeclaredTable{unsafe}( name:str ) :void 
address mvc_drop_declared_table_wrap
comment "drop a declared table"; 

pattern dropDeclaredTables{unsafe}( nr:int ) :void 
address mvc_drop_declared_tables_wrap
comment "drop top n declared tables"; 

pattern exportHead{unsafe}(s:streams, res_id:int) :void
address mvc_export_head_wrap
comment "Export a result (in order) to stream s"; 

pattern exportResult{unsafe}(s:streams, res_id:int) :void
address mvc_export_result_wrap
comment "Export a result (in order) to stream s"; 

pattern exportChunk{unsafe}(s:streams, res_id:int) :void
address mvc_export_chunk_wrap
comment "Export a chunk of the result set (in order) to stream s"; 

pattern exportChunk{unsafe}(s:streams, res_id:int, offset:int, nr:int) :void
address mvc_export_chunk_wrap
comment "Export a chunk of the result set (in order) to stream s"; 

pattern exportOperation{unsafe}(w:str) :void
address mvc_export_operation_wrap
comment "Export result of schema/transaction queries"; 

pattern affectedRows{unsafe}(mvc:int, nr:wrd, w:str) :int
address mvc_affected_rows_wrap
comment "export the number of affected rows by the current query";

pattern exportValue{unsafe}(qtype:int, tname:str, name:str, typename:str, digits:int, scale:int, eclass:int, val:any_1, w:str):void
address mvc_export_value_wrap 
comment "export a single value onto the stream s";

pattern importTable{unsafe}( s:bstream, sname:str, tname:str, 
	sep:str, rsep:str, ssep:str, ns:str, nr:lng, offset:lng, locked:int) :bat[:str,:bat]
address mvc_import_table_wrap
comment "Import a table from bstream s with the 
	given tuple and seperators (sep/rsep)";

function single(x:any_2):bat[:oid,:any_2];
	b := bat.new(0:oid, x);
	c := bat.append(b, x);
	return c;
end single;

function copy_from(
	sname:str,
	tname:str,
	tsep:str,
	rsep:str,
	ssep:str,
	ns:str,
	fname:str,
	nr:lng,
	offset:lng,
	locked:int
):bat[:str,:bat];
	cs := str.codeset();
	f  := str.iconv(fname, "UTF-8", cs);
	s  := streams.openRead(f);
	#bs := bstream.create(s, 1048576);
	#bs := bstream.create(s, 8388608);
	bs := bstream.create(s, 33554432);
	#bs := bstream.create(s, 67108864);

	res := sql.importTable(bs, sname, tname, tsep, rsep, ssep, ns, nr, offset, locked);
	bstream.destroy(bs);
	return res;
end copy_from;

function copyfrom(
	sname:str,
	tname:str,
	tsep:str,
	rsep:str,
	ssep:str,
	ns:str,
	nr:lng,
	offset:lng,
	locked:int
):bat[:str,:bat];
	in := io.stdin();
	res := sql.importTable(in, sname, tname, tsep, rsep, ssep, ns, nr, offset, locked);
	return res;
end copyfrom;

pattern importTable{unsafe}( sname:str, tname:str, fname:str... ) :bat[:str,:bat]
address mvc_bin_import_table_wrap
comment "Import a table from the files (fname)";


command zero_or_one( col:bat[:any_2,:any_1]) :any_1
address zero_or_one
comment "if col contains exactly one value return this. Incase of more raise an exception else return nil";

command not_unique( b:bat[:oid,:oid]) :bit 
address not_unique 
comment "check if the tail sorted bat b doesn't have unique tail values" ;

command not_uniques( b:bat[:oid,:oid]) :bat[:oid,:oid] 
address not_unique_oids 
comment "return not unique oids" ;

command not_uniques( b:bat[:oid,:wrd]) :bat[:oid,:oid] 
address not_unique_oids ;

function times(elaps:int,inblock:lng, oublock:lng):void;
	io.printf("#times %d ms",elaps);
	io.printf(" %d reads",inblock);
	io.printf(" %d writes\n",oublock);
end times;

factory times();
	elaps:= alarm.time();
	user := profiler.getUserTime();
	system := profiler.getSystemTime();
	inblocks := profiler.getDiskReads();
	oublocks := profiler.getDiskWrites();
barrier goon:=true;
	e1:= alarm.time();
	u1:= profiler.getUserTime();
	s1:= profiler.getSystemTime();
	i1 := profiler.getDiskReads();
	o1 := profiler.getDiskWrites();
	elaps:= e1-elaps;
	inblocks := i1-inblocks;
	oublocks := o1-oublocks;
	user := u1-user;
	system:= s1-system;
	io.printf("times %d ms",elaps);
	io.printf(" user %d ms",user);
	io.printf(" system %d ms",system);
	io.printf(" %d reads",inblocks);
	io.printf(" %d writes\n",oublocks);
	elaps := e1;
	user := u1;
	system:=s1;
	inblocks  := i1;
	oublocks  := o1;
	yield times;
	redo goon:=true;
exit goon;
end times;

pattern argRecord():str
address SQLargRecord
comment "Glue together the calling sequence";
pattern argRecord(a:any...):str
address SQLargRecord
comment "Glue together the calling sequence";

function sql_environment{inline}():bat[:str,:bat];
	b := bat.new(:str,:bat,2);
	e := inspect.getEnvironment();
	n := algebra.markT(e, 0:oid);
	r := bat.reverse(n);
	v := algebra.markH(e, 0:oid);
	b1:= bat.insert(b, "name", r);
	b2:= bat.insert(b1, "value", v);
	return sql_environment := b2;
end sql_environment;

function clients{inline}():bat[:str,:bat];
	b := bat.new(:str,:bat,5);
	u:= clients.getUsers();
	b1:= bat.insert(b,"user",u);
	l:= clients.getLogins();
	b2:= bat.insert(b1,"login",l);
	c:= clients.getLastCommand();
	b3:= bat.insert(b2,"lastcommand",c);
	a:= clients.getActions();
	b4:= bat.insert(b3,"actions",a);
	t:= clients.getTime();
	b5:= bat.insert(b4,"seconds",t);
	return clients := b5;
end clients;

function bbp{inline}():bat[:str,:bat];
	b := bat.new(:str,:bat,12);
	ns := bbp.getNames();
	ri := algebra.markT(ns, 0:oid);
	i := bat.reverse(ri);
	n := algebra.markH(ns, 0:oid);
	b1:= bat.insert(b, "id", i);
	b2:= bat.insert(b1, "name", n);
	iht := bbp.getHeadType();
	ht := algebra.markH(iht, 0:oid);
	b3:= bat.insert(b2, "htype", ht);
	itt := bbp.getTailType();
	tt := algebra.markH(itt, 0:oid);
	b4:= bat.insert(b3, "ttype", tt);
	icnt := bbp.getCount();
	cnt := algebra.markH(icnt, 0:oid);
	b5:= bat.insert(b4, "count", cnt);
	irefcnt := bbp.getRefCount();
	refcnt := algebra.markH(irefcnt, 0:oid);
	b6:= bat.insert(b5, "refcnt", refcnt);
	ilrefcnt := bbp.getLRefCount();
	lrefcnt := algebra.markH(ilrefcnt, 0:oid);
	b7:= bat.insert(b6, "lrefcnt", lrefcnt);
	ilocation := bbp.getLocation();
	location := algebra.markH(ilocation, 0:oid);
	b8:= bat.insert(b7, "location", location);
	iheat := bbp.getHeat();
	heat := algebra.markH(iheat, 0:oid);
	b9:= bat.insert(b8, "heat", heat);
	idirty := bbp.getDirty();
	dirty := algebra.markH(idirty, 0:oid);
	b10:= bat.insert(b9, "dirty", dirty);
	istatus := bbp.getStatus();
	status := algebra.markH(istatus, 0:oid);
	b11:= bat.insert(b10, "status", status);
	ikind := bbp.getKind();
	kind := algebra.markH(ikind, 0:oid);
	b12:= bat.insert(b11, "kind", kind);
	return bbp := b12;
end bbp;

pattern sql_variables():bat[:str,:bat]
address sql_variables
comment "return the table with session variables";

pattern db_users() :bat[:str,:bat]
address db_users_wrap
comment "return table of users with sql scenario";

pattern password(user:str) :str
address db_password_wrap
comment "return password hash of user";

pattern dump_cache() :bat[:str,:bat]
address dump_cache
comment "dump the content of the query cache";

pattern dump_opt_stats() :bat[:str,:bat]
address dump_opt_stats
comment "dump the optimizer rewrite statistics";

pattern dump_trace() :bat[:str,:bat]
address dump_trace
comment "dump the trace statistics";

pattern storage():bat[:str,:bat]
address sql_storage
comment "return a table with storage information ";

# @- SQL function aliases
# The code generate should identify the precise module
# target for all functions. This creates quite some
# administration overhead and analysis at many places.
# The alternative is to extend modules with an alias.
#
# The routine below are added to the calc module to
# ease code generation.
pattern calc.hash( v:any ) :wrd address MKEYhash; 
command batcalc.hash( b:bat[:oid,:any_1] ) :bat[:oid,:wrd] address MKEYbathash;
pattern calc.rotate_xor_hash(h:wrd, nbits:int, v:any_1) :wrd address MKEYrotate_xor_hash;
command batcalc.rotate_xor_hash(h:bat[:oid,:wrd], nbits:int, b:bat[:oid,:any_1]) :bat[:oid,:int] address MKEYbulk_rotate_xor_hash;

# @- SQL functions
# The SQL functions are all recognized by their module name.
# For some we need to provide a new implementation, others
# merely require a different address binding.
#
# The aggregate operations work on doubles by default.
# This calls for casting values around in the process.
@= mal_round
command sql.dec_round( v:@1, r:@1 ) :@1 
address @1_dec_round_wrap
comment "round off the value v to nearests multiple of r";

command sql.round( v:@1, d:int, s:int, r:bte) :@1
address @1_round_wrap
comment "round off the decimal v(d,s) to r digits behind the dot (if r < 0, before the dot)";

@
@mal
@:mal_round(bte)@
@:mal_round(sht)@
@:mal_round(int)@
@:mal_round(lng)@

@= mal_fround
command sql.dec_round( v:@1, r:@1 ) :@1 
address @1_dec_round_wrap
comment "round off the value v to nearests multiple of r";

command sql.round( v:@1, r:bte) :@1
address @1_round_wrap
comment "round off the floating point v to r digits behind the dot (if r < 0, before the dot)";

command sql.ms_trunc( v:@1, r:int) :@1
address @1_trunc_wrap
comment "truncate the floating point v to r digits behind the dot (if r < 0, before the dot)";

@
@mal
@:mal_fround(flt)@
@:mal_fround(dbl)@

command sql.alpha(dec:dbl, theta:dbl) :dbl
address SQLdbl_alpha
comment "Implementation of astronomy alpha function: expands the radius theta depending on the declination";

command batsql.alpha(dec:bat[:oid,:dbl], theta:dbl) :bat[:oid,:dbl]
address SQLbat_alpha
comment "BAT implementation of astronomy alpha function";

@= mal_cast
command calc.@1( v:str ) :@1 
address str_2_@1
comment "Cast to @1";
command calc.@1( v:str, digits:int ) :@1 
address str_2num_@1
comment "cast to @1 and check for overflow";
command calc.@1( v:str, digits:int, scale:int ) :@1 
address str_2dec_@1
comment "cast to dec(@1) and check for overflow";

command batcalc.@1( v:bat[:oid,:str] ) :bat[:oid,:@1] 
address batstr_2_@1
comment "Cast to @1";
command batcalc.@1( v:bat[:oid,:str], digits:int ) :bat[:oid,:@1] 
address batstr_2num_@1
comment "cast to @1 and check for overflow";
command batcalc.@1( v:bat[:oid,:str], digits:int, scale:int ) :bat[:oid,:@1] 
address batstr_2dec_@1
comment "cast to dec(@1) and check for overflow";
@
@mal
# @-
# address CALCstr2@1
# command calc.str( v:@1 ) :str
# address CALC@12str
# comment "Cast @1 to str";
@:mal_cast(bte)@
@:mal_cast(sht)@
@:mal_cast(int)@
@:mal_cast(lng)@

@= mal_castfromstr
command calc.@1( v:str ) :@1 
address str_2_@1
comment "cast to @1";
command batcalc.@1( v:bat[:oid,:str] ) :bat[:oid,:@1] 
address batstr_2_@1
comment "cast to @1";
command calc.str( v:@1 ) :str 
address SQL@1_2_str
comment "cast @1 to str";
@
@mal
@:mal_castfromstr(wrd)@
@:mal_castfromstr(flt)@
@:mal_castfromstr(dbl)@
@:mal_castfromstr(timestamp)@
@:mal_castfromstr(daytime)@
@:mal_castfromstr(date)@
@:mal_castfromstr(sqlblob)@

command calc.str( v:str) :str 
address CALCstr2str
comment "Idempotent cast of strings";

# @+ bit conversion (why?)
# command calc.str( v:bit) :str
# address CALCbit2str
# comment "Idempotent cast of strings";
#
# command calc.bte( v:bit) :bte
# address CALCbit2bte
# comment "Cast bit to bte ";
# command calc.sht( v:bit) :sht
# address CALCbit2sht
# comment "Cast bit to sht ";
# command calc.int( v:bit) :int
# address CALCbit2int
# comment "Cast bit to int ";
# command calc.lng( v:bit) :lng
# address CALCbit2lng
# comment "Cast bit to lng ";

pattern calc.str( eclass:int, d1:int, s1:int, has_tz:int, v:any_1, digits:int ) :str 
address SQLstr_cast
comment "cast to string and check for overflow";

pattern batcalc.str( eclass:int, d1:int, s1:int, has_tz:int, v:bat[:oid,:any_1], digits:int ) :bat[:oid,:str] 
address SQLbatstr_cast
comment "cast to string and check for overflow";

command calc.substring(s:str,offset:int):str
address STRsubstringTail;
command calc.substring(s:str,offset:int,count:int):str
address STRsubstring;

@= mal_cast_2dec
command calc.@1( v:@2) :@1 
address @2_2_@1
comment "cast @2 to @1";
command calc.@1( v:@2, digits:int, scale:int ) :@1 
address @2_num2dec_@1
comment "cast number to decimal(@1) and check for overflow";

command batcalc.@1( v:bat[:oid,:@2]) :bat[:oid,:@1]
address bat@2_2_@1
comment "cast @2 to @1";
command batcalc.@1( v:bat[:oid,:@2], digits:int, scale:int ) :bat[:oid,:@1] 
address bat@2_num2dec_@1
comment "cast number to decimal(@1) and check for overflow";
@
@mal
@:mal_cast_2dec(bte,flt)@
@:mal_cast_2dec(sht,flt)@
@:mal_cast_2dec(int,flt)@
@:mal_cast_2dec(wrd,flt)@
@:mal_cast_2dec(lng,flt)@
@:mal_cast_2dec(bte,dbl)@
@:mal_cast_2dec(sht,dbl)@
@:mal_cast_2dec(int,dbl)@
@:mal_cast_2dec(wrd,dbl)@
@:mal_cast_2dec(lng,dbl)@

@= mal_cast_dec2
command calc.@1( s1:int, v:@2) :@1 
address @2_dec2_@1
comment "cast decimal(@2) to @1 and check for overflow";
command calc.@1( s1:int, v:@2, d2:int, s2:int ) :@1 
address @2_dec2dec_@1
comment "cast decimal(@2) to decimal(@1) and check for overflow";

command batcalc.@1( s1:int, v:bat[:oid,:@2]) :bat[:oid,:@1]
address bat@2_dec2_@1
comment "cast decimal(@2) to @1 and check for overflow";
command batcalc.@1( s1:int, v:bat[:oid,:@2], d2:int, s2:int ) :bat[:oid,:@1] 
address bat@2_dec2dec_@1
comment "cast decimal(@2) to decimal(@1) and check for overflow";
@
@mal

@= mal_cast2
@:mal_cast_2dec(@1,@2)@
@:mal_cast_dec2(@1,@2)@
@
@mal
@:mal_cast2(bte,bte)@
@:mal_cast2(bte,sht)@
@:mal_cast2(bte,int)@
@:mal_cast2(bte,wrd)@
@:mal_cast2(bte,lng)@
@:mal_cast2(sht,bte)@
@:mal_cast2(sht,sht)@
@:mal_cast2(sht,int)@
@:mal_cast2(sht,wrd)@
@:mal_cast2(sht,lng)@
@:mal_cast2(int,bte)@
@:mal_cast2(int,sht)@
@:mal_cast2(int,int)@
@:mal_cast2(int,wrd)@
@:mal_cast2(int,lng)@
@:mal_cast2(wrd,bte)@
@:mal_cast2(wrd,sht)@
@:mal_cast2(wrd,int)@
@:mal_cast2(wrd,wrd)@
@:mal_cast2(lng,bte)@
@:mal_cast2(lng,sht)@
@:mal_cast2(lng,int)@
@:mal_cast2(lng,wrd)@
@:mal_cast2(lng,lng)@
@:mal_cast2(flt,bte)@
@:mal_cast2(flt,sht)@
@:mal_cast2(flt,int)@
@:mal_cast2(flt,wrd)@
@:mal_cast2(flt,lng)@
@:mal_cast2(dbl,bte)@
@:mal_cast2(dbl,sht)@
@:mal_cast2(dbl,int)@
@:mal_cast2(dbl,wrd)@
@:mal_cast2(dbl,lng)@

@= mal_interval
command calc.month_interval( v:@1, ek:int, sk:int ) :int
address month_interval_@1
comment "cast @1 to a month_interval and check for overflow";

command calc.second_interval( v:@1, ek:int, sk:int ) :lng
address second_interval_@1
comment "cast @1 to a second_interval and check for overflow";
@
@mal

@:mal_interval(str)@
@:mal_interval(bte)@
@:mal_interval(sht)@
@:mal_interval(int)@
@:mal_interval(wrd)@
@:mal_interval(lng)@

command calc.rowid(v:any_1, schema:str, table:str) :oid
address sql_rowid
comment "return the next rowid";

command sql.rank_grp(b:bat[:oid,:any_1], gp:bat[:oid,:oid], gpe:bat[:oid,:oid]) :bat[:oid,:int] 
address sql_rank_grp
comment "return the ranked groups";

command sql.rank(b:bat[:oid,:any_1]) :bat[:oid,:int] 
address sql_rank
comment "return the rank bat";

command sql.dense_rank_grp(b:bat[:oid,:any_1], gp:bat[:oid,:oid], gpe:bat[:oid,:oid]) :bat[:oid,:int] 
address sql_dense_rank_grp
comment "return the densely ranked groups";

command sql.dense_rank(b:bat[:oid,:any_1]) :bat[:oid,:int] 
address sql_dense_rank
comment "return the densely ranked bat";

command aggr.exist(b:bat[:any_1,:any_2], h:any_1):bit 
address ALGexist;

function batcalc.mark_grp{inline}( b:bat[:oid,:any_1], a:bat[:any_2,:any_3], g:bat[:oid,:oid]) :bat[:oid,:int]; 
	# order based on b
	bm := algebra.markT(b,0:oid);
	mb := bat.reverse(bm);
	ma := algebra.leftfetchjoin(mb, a);
	aa := bat.mirror(a);
	maa := algebra.leftfetchjoin(mb, aa);
	x := algebra.mark_grp(ma,g,1:oid);
	mg := batcalc.int(x);
	# restore the order based on a 
	aam := bat.reverse(maa);
	return mark_grp := algebra.leftfetchjoin(aam, mg);
end batcalc.mark_grp;

function batcalc.mark_grp{inline}( b:bat[:oid,:any_1] ) :bat[:oid,:int]; 
	x := algebra.markT(b,1:oid);
	return mark_grp:= batcalc.int(x);
end batcalc.mark_grp;

function batcalc.rank_grp{inline}( b:bat[:oid,:any_1], gp:bat[:oid,:oid], gpe:bat[:oid,:oid]) :bat[:oid,:int]; 
	o := bat.mirror(b);
	g := algebra.join(o, gp);
	return rank_grp:= sql.rank_grp(b, g, gpe);
end batcalc.rank_grp;

function batcalc.rank_grp{inline}( b:bat[:oid,:any_1]) :bat[:oid,:int]; 
	return rank_grp:= sql.rank(b);
end batcalc.rank_grp;

function batcalc.dense_rank_grp{inline}( b:bat[:oid,:any_1], gp:bat[:oid,:oid], gpe:bat[:oid,:oid]) :bat[:oid,:int]; 
	o := bat.mirror(b);
	g := algebra.join(o, gp);
	return dense_rank_grp:= sql.dense_rank_grp(b, g, gpe);
end batcalc.dense_rank_grp;

function batcalc.dense_rank_grp{inline}( b:bat[:oid,:any_1]) :bat[:oid,:int]; 
	return dense_rank_grp:= sql.dense_rank(b);
end batcalc.dense_rank_grp;

function sql.zero_or_one{inline}( b:bat[:oid,:any_1], gp:bat[:oid,:oid], gpe:bat[:oid,:oid]) :bat[:oid,:any_1];
	(e,g) := group.new(gp);
	m := aggr.max(e);
	c0 := calc.isnil(m);
	c01 := calc.not(c0);
	c1 := calc.>(m,1:wrd);
	c11 := calc.and(c01,c1);
	ms := calc.str(m); 
	msg := str.+("zero_or_one: cardinality violation (", ms);
	msg1 := str.+(msg, ">1)");
	sql.assert(c11, msg1);
	return zero_or_one := b;
end sql.zero_or_one;


function mmath.rand{inline}( v:int ) :int;
	x := mmath.rand();
	return rand := x;
end mmath.rand;

pattern cluster1(sch:str, tbl:str)
address SQLcluster1
comment "Cluster the columns of a table on the (first) primary key";

pattern cluster2(sch:str, tbl:str)
address SQLcluster2
comment "Cluster the columns of a table on the (first) primary key";

pattern shrink(sch:str, tbl:str)
address SQLshrink
comment "Consolidate the deletion table over all columns using shrinking";

pattern reuse(sch:str, tbl:str)
address SQLreuse
comment "Consolidate the deletion table over all columns reusing deleted slots";

pattern vacuum(sch:str, tbl:str)
address SQLvacuum
comment "Choose an approach to consolidate the deletions";

pattern drop_hash(sch:str, tbl:str)
address SQLdrop_hash
comment "Drop hash indices for the given table";

pattern newdictionary(sch:str, tbl:str):void
address SQLnewDictionary
comment "Perform dictionary compression on a table";
pattern dropdictionary(sch:str, tbl:str):void
address SQLdropDictionary
comment "Perform dictionary decompression on a table";

pattern gzcompress(sch:str, tbl:str):void
address SQLgzcompress
comment "Perform LZ compression on a table";
pattern gzdecompress(sch:str, tbl:str):void
address SQLgzdecompress
comment "Perform LZ decompression on a table";
pattern gztruncate(sch:str, tbl:str):void
address SQLtruncate
comment "Remove the tables when you have a compressed image";
pattern gzexpand(sch:str, tbl:str):void
address SQLexpand
comment "Remove the compressed image";

# @-
# The distributed processing of queries requires the SQL runtime
# system to be able to deliver portions of the BATs in an efficient
# way.
# It should be cast into a more efficient C procedure, which also
# takes care of NAS opportunities.
function octopus.bind(mvc:int, sch:str, tab:str,col:str,kind:int, 
low:oid, hgh:oid, version:int):bat[:oid,:any_1];
	b:bat[:oid,:any_1]:= sql.bind(mvc,sch,tab,col,kind,low,hgh);
	return bind:= b;
end bind;

function octopus.bind(mvc:int, sch:str, tab:str,col:str,kind:int, version:int):bat[:oid,:any_1];
	b:bat[:oid,:any_1]:= sql.bind(mvc,sch,tab,col,kind);
	return bind:= b;
end bind;

function octopus.bind(conn:str, sch:str, tab:str,col:str,kind:int, 
low:oid, hgh:oid, version:int):bat[:oid,:any_1];
	b:bat[:oid,:any_1] := nil:bat[:oid,:any_1];
	m := nil:int;
	rm := remote.put(conn,m);
	rm := remote.exec(conn,"sql","mvc");
	s := remote.put(conn,sch);
	t := remote.put(conn,tab);
	c := remote.put(conn,col);
	k := remote.put(conn,kind);
	v := remote.put(conn,version);
	l := remote.put(conn,low);
	h := remote.put(conn,hgh);
	rb:= remote.put(conn,b);
	rb:= remote.exec(conn,"sql","bind",rm,s,t,c,k,l,h);
	b:bat[:oid,:any_1]:= remote.get(conn,rb);
	return bind:= b;
end octopus.bind;

function octopus.bind(conn:str, sch:str, tab:str,col:str,kind:int, 
version:int):bat[:oid,:any_1];
	b:bat[:oid,:any_1] := nil:bat[:oid,:any_1];
	m := nil:int;
	rm := remote.put(conn,m);
	rm := remote.exec(conn,"sql","mvc");
	s := remote.put(conn,sch);
	t := remote.put(conn,tab);
	c := remote.put(conn,col);
	k := remote.put(conn,kind);
	bh:= remote.put(conn,b);
	bh:= remote.exec(conn,"sql","bind",rm,s,t,c,k);
	b:bat[:oid,:any_1]:= remote.get(conn,bh);
	return bind:= b;
end octopus.bind;

function octopus.bind_dbat(mvc:int, sch:str, tab:str,access:int, version:int):bat[:oid,:oid];
	b := sql.bind_dbat(mvc,sch,tab,access);
	return bind_dbat:= b;
end octopus.bind_dbat;

function octopus.bind_dbat(conn:str, sch:str, tab:str, access:int, version:int):bat[:oid,:oid];
	b:bat[:oid,:any_1] := nil:bat[:oid,:any_1];
	m := nil:int;
	rm := remote.put(conn,m);
	rm := remote.exec(conn,"sql","mvc");
	s := remote.put(conn,sch);
	t := remote.put(conn,tab);
	a := remote.put(conn,access);
	bh:= remote.put(conn,b);
	bh:= remote.exec(conn,"sql","bind_dbat",rm,s,t,a);
	b:bat[:oid,:oid]:= remote.get(conn,bh);
	return bind_dbat:= b;
end octopus.bind_dbat;

function octopus.bind_idxbat(mvc:int, sch:str, tab:str, index:str, access:int, version:int):bat[:oid,:oid];
	b := sql.bind_idxbat(mvc,sch,tab,index,access);
	return bind_idxbat:= b;
end octopus.bind_idxbat;

function octopus.bind_idxbat(conn:str, sch:str, tab:str, index:str, access:int, version:int):bat[:oid,:oid];
	b:bat[:oid,:oid] := nil:bat[:oid,:oid];
	m := nil:int;
	rm := remote.put(conn,m);
	rm := remote.exec(conn,"sql","mvc");
	s := remote.put(conn,sch);
	t := remote.put(conn,tab);
	i := remote.put(conn,index);
	a := remote.put(conn,access);
	bh:= remote.put(conn,b);
	bh:= remote.exec(conn,"sql","bind_idxbat",rm,s,t,i,a);
	b:bat[:oid,:oid]:= remote.get(conn,bh);
	return bind_idxbat:= b;
end octopus.bind_idxbat;

function octopus.bind_idxbat(conn:str, sch:str, tab:str, index:str, access:int, low:oid, hgh:oid, version:int):bat[:oid,:oid];
	b:bat[:oid,:oid] := nil:bat[:oid,:oid];
	m := nil:int;
	rm := remote.put(conn,m);
	rm := remote.exec(conn,"sql","mvc");
	s := remote.put(conn,sch);
	t := remote.put(conn,tab);
	i := remote.put(conn,index);
	a := remote.put(conn,access);
	l := remote.put(conn,low);
	h := remote.put(conn,hgh);
	bh:= remote.put(conn,b);
	bh:= remote.exec(conn,"sql","bind_idxbat",rm,s,t,i,a,l,h);
	b:bat[:oid,:oid]:= remote.get(conn,bh);
	return bind_idxbat:= b;
end octopus.bind_idxbat;
# @-
# Octopus.bind signatures adjusted to new mitosis sql.bind (part_nr, nr_parts)
function octopus.bind(mvc:int, sch:str, tab:str,col:str,kind:int,
		part_nr:int, nr_parts:int, version:int) :bat[:oid,:any_1];
	b:bat[:oid,:any_1]:= sql.bind(mvc,sch,tab,col,kind,part_nr,nr_parts);
	return bind:= b;
end bind;

function octopus.bind(conn:str, sch:str, tab:str,col:str,kind:int,
part_nr:int, nr_parts:int, version:int):bat[:oid,:any_1];
	b:bat[:oid,:any_1] := nil:bat[:oid,:any_1];
	m := nil:int;
	rm := remote.put(conn,m);
	rm := remote.exec(conn,"sql","mvc");
	s := remote.put(conn,sch);
	t := remote.put(conn,tab);
	c := remote.put(conn,col);
	k := remote.put(conn,kind);
	v := remote.put(conn,version);
	l := remote.put(conn,part_nr);
	h := remote.put(conn,nr_parts);
	rb:= remote.put(conn,b);
	rb:= remote.exec(conn,"sql","bind",rm,s,t,c,k,l,h);
	b:bat[:oid,:any_1]:= remote.get(conn,rb);
	return bind:= b;
end octopus.bind;

function octopus.bind_idxbat(conn:str, sch:str, tab:str, index:str, access:int, part_nr:int, nr_parts:int, version:int):bat[:oid,:oid];
	b:bat[:oid,:oid] := nil:bat[:oid,:oid];
	m := nil:int;
	rm := remote.put(conn,m);
	rm := remote.exec(conn,"sql","mvc");
	s := remote.put(conn,sch);
	t := remote.put(conn,tab);
	i := remote.put(conn,index);
	a := remote.put(conn,access);
	l := remote.put(conn,part_nr);
	h := remote.put(conn,nr_parts);
	bh:= remote.put(conn,b);
	bh:= remote.exec(conn,"sql","bind_idxbat",rm,s,t,i,a,l,h);
	b:bat[:oid,:oid]:= remote.get(conn,bh);
	return bind_idxbat:= b;
end octopus.bind_idxbat;

function octopus.getVariable(conn:str,name:str):any_1;
	s := remote.put(conn,name);
	bh:= remote.exec(conn,"sql","getVariable",s);
	b:any_1 := remote.get(conn,bh);
	return getVariable:= b;
end octopus.getVariable;

function octopus.getBid(dbname:str, fn:str, bidtype:sht):lng;
res:lng := -1:lng;
barrier remotewrk := calc.!=(dbname,"NOTworker");
	conn := octopus.connect(dbname);
	r_fn := remote.put(conn,fn);
	r_bt := remote.put(conn,bidtype);
	r_getBid := remote.put(conn,res);
	r_getBid := remote.exec(conn,"trader","makeBid",r_fn,r_bt);
	res:lng  := remote.get(conn,r_getBid);
	catch ANYexception:str;
 	   raise ANYexception:str ;
	exit ANYexception:str ;
exit remotewrk;
    return getBid:lng := res;
end getBid;

pattern rdfshred (location:str, gname:str, schema:str)
address SQLrdfShred
comment "Procedure that wraps around the shredder of the rdf module in MAL. 
Shredding an RDF data file from location results in 7 new tables (6 
permutations of SPO and a mapping) in the RDF schema and an entry to table 
rdf.graph We can then query with SQL queries the RDF triple storeby quering 
tables gid_spo, gid_pso etc., where gid is looked up in rdf.graph"

command prelude()
address SQLprelude;

command epilogue()
address SQLepilogue;

sql.prelude();

@h
#ifndef _SQL_H
#define _SQL_H

#include <sql_mem.h>

#ifdef WIN32
#ifndef LIBSQL
#define sql5_export extern __declspec(dllimport)
#else
#define sql5_export extern __declspec(dllexport)
#endif
#else
#define sql5_export extern
#endif

#include "sql_mvc.h"
#include <sql_backend.h>
#include <mal_session.h>

#include <mal_function.h>
#include <mal_stack.h>
#include <mal_interpreter.h>
#include <mal_session.h>
#include <tablet.h>
#include <streams.h>
#include <mtime.h>
#include <math.h>
#include <blob.h>
#include <mkey.h>
#include <str.h>
#include "sql_privileges.h"
#include "sql_semantic.h"
#include "sql_rel2bin.h"
#include <bin_optimizer.h>
#include "sql_decimal.h"
#include "sql_string.h"
#include "sql_qc.h"
#include "sql_env.h"
#include "sql_emptyset.h"

#include <bat/bat_storage.h>

/*
 * @-
 * The back-end structure collects the information needed to support
 * compilation and execution of the SQL code against the Monet Version 5
 * back end. Note that the back-end can be called upon by the front-end
 * to handle specific tasks, such as catalog management (sql_mvc)
 * and query execution (sql_qc). For this purpose, the front-end needs
 * access to operations defined in the back-end, in particular for
 * freeing the stack and code segment.
 * @-
 */
typedef struct backend {
	int console;
	char language;		/* 'S' or 's' or 'X' */
	mvc *mvc;
	stream *out;
	Client client;
	sql_schema *currSchema;
	sql_table *currTable;
	sql_column *currColumn;
	sql_key *currKey;
	sql_idx *currIndex;
	int 	mvc_var;	
	int	vtop;		/* top of the variable stack before the current function */
	cq *q;			/* pointer to the cached query */
} backend;

extern backend *backend_reset(backend *b);
extern backend *backend_create(mvc *m, Client c);
extern void backend_destroy(backend *b);

extern int sqlcleanup(mvc *c, int err);
extern stmt *sql_symbol2stmt(mvc *c, symbol *sym);

extern BAT *mvc_bind(mvc *m, char *sname, char *tname, char *cname, int access);
extern BAT *mvc_bind_dbat(mvc *m, char *sname, char *tname, int access);
extern BAT *mvc_bind_idxbat(mvc *m, char *sname, char *tname, char *iname, int access);

sql5_export str SQLmvc(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str SQLtransaction(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str SQLcommit(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str SQLtransaction2(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str SQLcatalog(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);

sql5_export str mvc_append_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str mvc_update_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str mvc_bind_single_wrap(int *ret, int *bid, str *name);
sql5_export str mvc_bind_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str mvc_bind_dbat_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str mvc_bind_idxbat_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str mvc_clear_table_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str mvc_delete_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str mvc_result_row_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str mvc_result_file_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str mvc_result_table_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str mvc_result_column_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str mvc_result_value_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);

sql5_export str mvc_declared_table_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str mvc_declared_table_column_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str mvc_drop_declared_table_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci );
sql5_export str mvc_drop_declared_tables_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci );

sql5_export str mvc_affected_rows_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str mvc_export_result_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str mvc_export_head_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str mvc_export_chunk_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str mvc_export_operation_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str mvc_export_value_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str mvc_import_table_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str mvc_bin_import_table_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str setVariable(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str getVariable(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str sql_variables(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str mvc_logfile(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str mvc_next_value(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str mvc_bat_next_value(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str mvc_get_value(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str mvc_diff_idxbat_wrap(bat *b, int *clientid, str *s, str *t, str *i, int *access, lng *oldversion, lng *version );
sql5_export str mvc_diff_dbat_wrap(bat *b, int *clientid, str *s, str *t, int *access, lng *oldversion, lng *version);
sql5_export str mvc_getVersion(lng *r, int *clientid);
sql5_export str mvc_restart_seq(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str zero_or_one(ptr ret, int *bid);
sql5_export str not_unique(bit *ret, int *bid);
sql5_export str not_unique_oids(bat *ret, bat *bid);
sql5_export str SQLcluster1(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str SQLcluster2(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str SQLshrink(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str SQLreuse(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str SQLvacuum(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str SQLdrop_hash(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str SQLnewDictionary(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str SQLdropDictionary(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str SQLgzcompress(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str SQLgzdecompress(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str SQLtruncate(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str SQLexpand(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str SQLoctopusBind(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str SQLoctopusBinddbat(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str SQLargRecord(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str SQLrdfShred(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str month_interval_str( int *ret, str *s, int *ek, int *sk );
sql5_export str second_interval_str( lng *res, str *s, int *ek, int *sk );
sql5_export str dump_cache(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str dump_opt_stats(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str dump_trace(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str sql_storage(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str sql_rowid(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str sql_rank_grp(bat *rid, bat *bid, bat *gid, bat *gpe);
sql5_export str sql_rank(bat *rid, bat *bid);
sql5_export str sql_dense_rank_grp(bat *rid, bat *bid, bat *gid, bat *gpe);
sql5_export str sql_dense_rank(bat *rid, bat *bid);
@= round_export
sql5_export str @1_dec_round_wrap( @1 *res, @1 *v, @1 *r );
sql5_export str @1_round_wrap( @1 *res, @1 *v, int *d, int *s, bte *r );
sql5_export str str_2dec_@1( @1 *res, str *val, int *d, int *sc );
sql5_export str str_2num_@1( @1 *res, str *v, int *len );
sql5_export str batstr_2dec_@1( int *res, int *val, int *d, int *sc );
sql5_export str batstr_2num_@1( int *res, int *v, int *len );
@
@h
@:round_export(bte)@
@:round_export(sht)@
@:round_export(int)@
@:round_export(wrd)@
@:round_export(lng)@
@= cast_export
sql5_export str str_2_@1( @3 *res, str *val );
sql5_export str batstr_2_@1( int *res, int *val );
sql5_export str SQL@1_2_str( str *res, @1 *val );
@
@h
@:cast_export(bit,bitToStr,bit)@
@:cast_export(oid,OIDtoStr,oid)@
@:cast_export(bte,bteToStr,bte)@
@:cast_export(sht,shtToStr,sht)@
@:cast_export(int,intToStr,int)@
@:cast_export(lng,lngToStr,lng)@
@:cast_export(wrd,wrdToStr,wrd)@
@:cast_export(flt,fltToStr,flt)@
@:cast_export(dbl,dblToStr,dbl)@
@:cast_export(timestamp,timestamp_tostr,timestamp)@
@:cast_export(daytime,daytime_tostr,daytime)@
@:cast_export(date,date_tostr,date)@
@:cast_export(sqlblob,sqlblob_tostr,sqlblob*)@
sql5_export str SQLstr_cast(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str SQLbatstr_cast(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
@= fround_export
sql5_export str @1_dec_round_wrap( @1 *res, @1 *v, @1 *r );
sql5_export str @1_round_wrap( @1 *res, @1 *v, bte *r );
sql5_export str @1_trunc_wrap( @1 *res, @1 *v, int *r );
@
@h
@:fround_export(flt)@
@:fround_export(dbl)@
#define radians(x)       ((x) * 3.14159265358979323846 /180.0 )
#define degrees(x)       ((x) * 180.0/3.14159265358979323846 )
sql5_export str SQLdbl_alpha(dbl *res, dbl *decl, dbl *theta);
sql5_export str SQLbat_alpha(bat *res, bat *decl, dbl *theta);
@= c_interval_export
sql5_export str month_interval_@1( int *ret, @1 *s, int *ek, int *sk );
sql5_export str second_interval_@1( lng *res, @1 *s, int *ek, int *sk );
@
@h
@:c_interval_export(bte)@
@:c_interval_export(sht)@
@:c_interval_export(int)@
@:c_interval_export(wrd)@
@:c_interval_export(lng)@
@:c_interval_export(daytime)@
@= simpleupcast_export
sql5_export str @2_2_@1( @1 *res, @2 *v );
sql5_export str bat@2_2_@1( int *res, int *v );
@= simpledowncast_export
sql5_export str @2_2_@1( @1 *res, @2 *v );
sql5_export str bat@2_2_@1( int *res, int *v );
@= numcastup_export
@:simpledowncast_export(@1,@2)@
sql5_export str @2_dec2_@1( @1 *res, int *s1, @2 *v );
sql5_export str @2_dec2dec_@1( @1 *res, int *S1, @2 *v, int *d2, int *S2 );
sql5_export str @2_num2dec_@1( @1 *res, @2 *v, int *d2, int *s2 );
sql5_export str bat@2_dec2_@1( int *res, int *s1, int *v );
sql5_export str bat@2_dec2dec_@1( int *res, int *S1, int *v, int *d2, int *S2 );
sql5_export str bat@2_num2dec_@1( int *res, int *v, int *d2, int *s2 );
@
@h
@:numcastup_export(bte,bte)@
@:numcastup_export(sht,bte)@
@:numcastup_export(sht,sht)@
@:numcastup_export(int,bte)@
@:numcastup_export(int,sht)@
@:numcastup_export(int,int)@
@:numcastup_export(wrd,bte)@
@:numcastup_export(wrd,sht)@
@:numcastup_export(wrd,int)@
@:numcastup_export(wrd,wrd)@
@:numcastup_export(lng,bte)@
@:numcastup_export(lng,sht)@
@:numcastup_export(lng,int)@
@:numcastup_export(lng,wrd)@
@:numcastup_export(lng,lng)@
@= fnumcastdown_export
@:simpledowncast_export(@1,@2)@
sql5_export str @2_num2dec_@1( @1 *res, @2 *v, int *d2, int *s2 );
sql5_export str bat@2_num2dec_@1( int *res, int *v, int *d2, int *s2 );
@
@h
@:fnumcastdown_export(bte,flt)@
@:fnumcastdown_export(sht,flt)@
@:fnumcastdown_export(int,flt)@
@:fnumcastdown_export(wrd,flt)@
@:fnumcastdown_export(lng,flt)@
@:fnumcastdown_export(bte,dbl)@
@:fnumcastdown_export(sht,dbl)@
@:fnumcastdown_export(int,dbl)@
@:fnumcastdown_export(wrd,dbl)@
@:fnumcastdown_export(lng,dbl)@
@= fnumcastup_export
@:simpleupcast_export(@1,@2)@
sql5_export str @2_dec2_@1( @1 *res, int *s1, @2 *v );
sql5_export str @2_dec2dec_@1( @1 *res, int *S1, @2 *v, int *d2, int *S2 );
sql5_export str @2_num2dec_@1( @1 *res, @2 *v, int *d2, int *s2 );
sql5_export str bat@2_dec2_@1( int *res, int *s1, int *v );
sql5_export str bat@2_dec2dec_@1( int *res, int *S1, int *v, int *d2, int *S2 );
sql5_export str bat@2_num2dec_@1( int *res, int *v, int *d2, int *s2 );
@
@h
@:fnumcastup_export(flt,bte)@
@:fnumcastup_export(flt,sht)@
@:fnumcastup_export(flt,int)@
@:fnumcastup_export(flt,wrd)@
@:fnumcastup_export(flt,lng)@
@:fnumcastup_export(dbl,bte)@
@:fnumcastup_export(dbl,sht)@
@:fnumcastup_export(dbl,int)@
@:fnumcastup_export(dbl,wrd)@
@:fnumcastup_export(dbl,lng)@
@= numcastdown_export
@:simpledowncast_export(@1,@2)@
sql5_export str @2_dec2_@1( @1 *res, int *s1, @2 *v );
sql5_export str @2_dec2dec_@1( @1 *res, int *S1, @2 *v, int *d2, int *S2 );
sql5_export str @2_num2dec_@1( @1 *res, @2 *v, int *d2, int *s2 );
sql5_export str bat@2_dec2_@1( int *res, int *s1, int *v );
sql5_export str bat@2_dec2dec_@1( int *res, int *S1, int *v, int *d2, int *S2 );
sql5_export str bat@2_num2dec_@1( int *res, int *v, int *d2, int *s2 );
@
@h
@:numcastdown_export(bte,sht)@
@:numcastdown_export(bte,int)@
@:numcastdown_export(bte,wrd)@
@:numcastdown_export(bte,lng)@
@:numcastdown_export(sht,int)@
@:numcastdown_export(sht,wrd)@
@:numcastdown_export(sht,lng)@
@:numcastdown_export(int,wrd)@
@:numcastdown_export(int,lng)@
@:numcastdown_export(wrd,lng)@

sql5_export str getContext(Client cntxt, MalBlkPtr mb, mvc **c, backend **b );

sql5_export void freeVariables(Client c, MalBlkPtr mb, MalStkPtr glb, int start);

#endif /* _SQL_H */

@c
/*
 * @-
 * First introduce the routines to be called by the front-end.
 */
#include "monetdb_config.h"
#include "sql.h"
#include "sql_result.h"
#include "sql_gencode.h"
#include <sql_storage.h>
#include <sql_scenario.h>
#include <store_sequence.h>
#include <sql_optimizer.h>
#include <sql_datetime.h>
#include <rel_optimizer.h>
#include <rel_select.h>
#include <rel_exp.h>
#include <rel_dump.h>
#include <rel_bin.h>
#include <math.h>
#include <bbp.h>
#include <cluster.h>
#include <opt_dictionary.h>
#ifdef HAVE_RAPTOR
# include <rdf.h>
#endif
#include "mal_instruction.h"

/* Windows doesn't have round or trunc, but it does have floor and ceil */
#ifndef HAVE_ROUND
static inline double
round(double val)
{
	/* round to nearest integer, away from zero */
	if (val < 0)
		return -floor(-val + 0.5);
	else
		return floor(val + 0.5);
}
#endif

#ifndef HAVE_TRUNC
static inline double
trunc(double val)
{
	/* round to integer, towards zero */
	if (val < 0)
		return ceil(val);
	else
		return floor(val);
}
#endif

backend *
backend_reset(backend *b)
{
	b->out = b->client->fdout;
	b->language = 0;

	b->currSchema = NULL;
	b->currTable = NULL;
	b->currColumn = NULL;
	b->currKey = NULL;
	b->currIndex = NULL;
	b->vtop = 0;
	b->q = NULL;
	b->mvc_var = 0;
	return b;
}

backend *
backend_create(mvc *m, Client c)
{
	backend *b = NEW(backend);

	b->console = isAdministrator(c);
	b->mvc = m;
	b->client = c;
	b->mvc_var = 0;
	return backend_reset(b);
}

void
backend_destroy(backend *b)
{
	_DELETE(b);
}

static int
rel_is_table( sql_rel *rel )
{
	if (!rel || is_base(rel->op))
		return 1;
	return 0;
}

static int
exp_is_point_select( sql_exp * e) 
{
	if (!e)
		return 1;
	if (e->type == e_cmp && !e->f && e->flag == (int)cmp_equal) {
		sql_exp *r = e->r;

		if (r->card <= CARD_AGGR) 
			return 1;
	}
	return 0;
}

static int
rel_is_point_query( sql_rel *rel)
{
	int is_point = 0;

	if (!rel)
		return 1;
	if (is_project(rel->op))
		return rel_is_point_query(rel->l);
	if (is_select(rel->op) && rel_is_table(rel->l) && rel->exps) {
/*
		node *n;
		is_point = 1;
		for (n=rel->exps->h; n && is_point; n = n->next) {
			if (!exp_is_point_select(n->data))
				is_point = 0;
		}
*/
		is_point = 0;
		/* just one point expression makes this a point query */
		if (rel->exps->h)
			if (exp_is_point_select(rel->exps->h->data))
				is_point = 1;
	}
	return is_point;
}

static int
rel_need_distinct_query( sql_rel *rel)
{
	int need_distinct = 0;

	while (!need_distinct && rel && is_project(rel->op) && !is_groupby(rel->op))
		rel = rel->l;
	if (!need_distinct && rel && is_groupby(rel->op) && rel->exps) {
		node *n, *m;
		for (n=rel->exps->h; n && !need_distinct; n = n->next) {
			sql_exp *e = n->data;
			if (e->type == e_aggr) {
				list *l = e->l;

				if (l) for(m = l->h; m && !need_distinct; m = m->next){
					sql_exp *a = m->data;
	
					if (need_distinct(a))
						need_distinct = 1;
				}
			}
		}
	}
	return need_distinct;
}


stmt *
sql_symbol2stmt(mvc *c, symbol *sym)
{
	stmt *s = NULL;
	int status;
	sql_rel *r;

	status = c->session->status;
	r = rel_semantic(c, sym);
	if (!r) {
		if (c->errstr[0]) {
			return NULL;
		} else {
			c->session->status = status;
			/*printf("# falling back to direct mode \n");*/
			s = output_semantic(c, sym);
		}
	} else {
		int pq;

		r = rel_optimizer(c, r);
		pq = rel_is_point_query(r);
		if (!pq)
			pq = rel_need_distinct_query(r);

		if (c->emode == m_plan) {
			rel_print(c, r, 0);
		} else {
			s = output_rel_bin(c, r);
		}
		rel_destroy(r);
		if (s) {
			/* only needed for delta tables */
			s = rel2bin(c, s); 	
			s = bin_optimizer(c, s);
			c->point_query = pq;
			return s;
		}
	}

	if (s) {
		s = rel2bin(c, s);
		s = bin_optimizer(c, s);
	}
	return s;
}

/*
 * @-
 * After the SQL statement has been executed, its data structures
 * should be garbage collected. For successful actions we have to finish
 * the transaction as well, e.g. commit or rollback.
 */
int
sqlcleanup(mvc *c, int err)
{
	sql_destroy_params(c);
	sql_destroy_args(c);

	if ((c->emod & mod_locked) == mod_locked) {
		/* here we should commit the transaction */
		if (!err) {
			sql_trans_commit(c->session->tr);
			/* write changes to disk */
			sql_trans_end(c->session);
			store_apply_deltas();
			sql_trans_begin(c->session);
		}
		store_unlock();
		c->emod = 0;
	}
	/* some statements dynamically disable caching */
	c->sym = NULL;
	if (c->sa) 
		c->sa = sa_reset(c->sa);
	if (err > 0)
		c->session->status = -err;
	if (err < 0)
		c->session->status = err;
	scanner_query_processed(&(c->scanner));
	return err;
}

/*
 * @-
 * The internal administration of the SQL compilation and execution state
 * is administered by a state descriptor accessible in each phase.
 * Failure to find the state descriptor aborts the session.
 */
str 
getContext(Client cntxt, MalBlkPtr mb, mvc **c, backend **b )
{
	(void)mb;
	if (cntxt == NULL ) 
		throw(SQL, "mvc","No client record");
	if (cntxt->state[MAL_SCENARIO_PARSER] == NULL || cntxt->state[MAL_SCENARIO_OPTIMIZE] == NULL)
		throw(SQL, "mvc","SQL module not initialized");
	if (c)
		*c = ((mvc *) cntxt ->state[MAL_SCENARIO_OPTIMIZE]); 
	if (c && *c == 0)
		throw(SQL, "mvc","SQL module not initialized, mvc struct missing");
	if (b)
		*b = ((backend*) cntxt->state[MAL_SCENARIO_PARSER]);
	if (b && *b == 0)
		throw(SQL, "mvc","SQL module not initialized, backend struct missing");
	return MAL_SUCCEED;
}

str
SQLmvc(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	mvc *sql = NULL;
	str msg = getContext(cntxt, mb, &sql, NULL);
	int *res = (int*) getArgReference(stk, pci, 0);

	if (msg)
		return msg;
	*res = 0;
	return MAL_SUCCEED;
}

str
SQLtransaction(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	mvc *sql = NULL;
	str msg = getContext(cntxt, mb, &sql, NULL);
	int type = *(int*) getArgReference(stk, pci, 1);
	int chain = *(int*) getArgReference(stk, pci, 2);
	str name = *(str*) getArgReference(stk, pci, 3);
	char buf[BUFSIZ];
	int ret = 0;

	if (msg)
		return msg;
	if (name && strcmp(name, str_nil) == 0)
		name = NULL;

	switch (type) {
	case DDL_RELEASE:
		if (sql->session->auto_commit == 1) 
			throw(SQL, "sql.trans", "RELEASE SAVEPOINT: not allowed in auto commit mode");
		ret = mvc_release(sql, name);
		if (ret < 0) {
			snprintf(buf, BUFSIZ, "RELEASE SAVEPOINT: (%s) failed", name);
			throw(SQL, "sql.trans", "%s", buf);
		}
		break;
	case DDL_COMMIT:
		if (sql->session->auto_commit == 1) {
			if (name)
				throw(SQL,"sql.trans", "SAVEPOINT: not allowed in auto commit mode");
			else
				throw(SQL,"sql.trans", "COMMIT: not allowed in auto commit mode");
		}
		ret = mvc_commit(sql, chain, name);
		if (ret < 0 && !name) 
			throw(SQL, "sql.trans", "COMMIT: failed");
		if (ret < 0 && name)
			throw(SQL, "sql.trans", "SAVEPOINT: (%s) failed", name);
		break;
	case DDL_ROLLBACK:
		if (sql->session->auto_commit == 1) 
			throw(SQL, "sql.trans", "ROLLBACK: not allowed in auto commit mode");
		ret = mvc_rollback(sql, chain, name);
		if (ret < 0 && name) {
			snprintf(buf, BUFSIZ, "ROLLBACK TO SAVEPOINT: (%s) failed", name);
			throw(SQL, "sql.trans", "%s", buf);
		}
		break;
	case DDL_TRANS:
		if (sql->session->auto_commit == 0) 
			throw(SQL, "sql.trans", "START TRANSACTION: cannot start a transaction within a transaction");
		if (sql->session->active)
			mvc_rollback(sql, 0, NULL);
		sql->session->auto_commit = 0;
		sql->session->ac_on_commit = 1;
		sql->session->level = chain;
		(void) mvc_trans(sql);
		break;
	default:
		throw(SQL, "sql.trans", "transaction unknown type");
	}
	return MAL_SUCCEED;
}

str
SQLcommit(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int ret;
	mvc *sql = NULL;
	str msg = getContext(cntxt, mb, &sql, NULL);
	(void) stk;
	(void) pci;

	if (sql->session->auto_commit != 0) 
		throw(SQL,"sql.trans", "COMMIT: not allowed in auto commit mode");
	ret = mvc_commit(sql, 0, 0);
	if (ret < 0 ) 
		throw(SQL, "sql.trans", "COMMIT: failed");
	return msg;
}

str
SQLtransaction2(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	mvc *sql = NULL;
	str msg = getContext(cntxt, mb, &sql, NULL);

	(void) stk;
	(void) pci;
	if (sql->session->auto_commit == 0) 
		throw(SQL, "sql.trans", "START TRANSACTION: cannot start a transaction within a transaction");
	if (sql->session->active)
		mvc_rollback(sql, 0, NULL);
	sql->session->auto_commit = 0;
	sql->session->ac_on_commit = 1;
	sql->session->level = 0;
	(void) mvc_trans(sql);
	return msg;
}

static str
create_table_or_view( mvc *sql, char *sname, sql_table *t, int temp)
{
	sql_schema *s = mvc_bind_schema(sql, sname);
	sql_table *nt = NULL;
	node *n;

	if (STORE_READONLY(active_store_type)) 
		return sql_error(sql, 06, "schema statements cannot be executed on a readonly database.");

	if (!s) 
		return sql_message("CREATE %s: schema '%s' doesn't exist", (t->query)?"TABLE":"VIEW", sname);

	if (mvc_bind_table(sql, s, t->base.name)) {
		char *cd = (temp == SQL_DECLARED_TABLE)?"DECLARE":"CREATE";
		return sql_message("%s TABLE: name '%s' already in use", cd, t->base.name);
	} else if (temp != SQL_DECLARED_TABLE &&!schema_privs(sql->role_id, s)){
		return sql_message("CREATE TABLE: insufficient privileges for user '%s' in schema '%s'", stack_get_string(sql, "current_user"), s->base.name);
	}

	/* first check default values */
	for (n = t->columns.set->h; n; n = n->next) {
		sql_column *c = n->data;

		if (c->def) {
			char buf[BUFSIZ];
			sql_rel *r = NULL;

			sql->sa = sa_create();
			snprintf(buf, BUFSIZ, "select %s;", c->def);
			r = rel_parse(sql, buf, m_deps); 
			if (!r || !is_project(r->op) || !r->exps || list_length(r->exps) != 1 || rel_check_type(sql, &c->type, r->exps->h->data, type_equal) == NULL) 
				throw(SQL, "sql.catalog", "%s", sql->errstr);
			rel_destroy(r);
			sa_destroy(sql->sa);
			sql->sa = NULL;
		}
	}

	nt = sql_trans_create_table(sql->session->tr, s, t->base.name, t->query, t->type, t->system, temp, t->commit_action, t->sz);

	for (n = t->columns.set->h; n; n = n->next) {
		sql_column *c = n->data;
		mvc_copy_column(sql, nt, c);
	}
	if (t->idxs.set) {
		for (n = t->idxs.set->h; n; n = n->next) {
			sql_idx *i = n->data;
			mvc_copy_idx(sql, nt, i);
		}
	}
	if (t->keys.set) {
		for (n = t->keys.set->h; n; n = n->next) {
			sql_key *k = n->data;

			mvc_copy_key(sql, nt, k);
		}
	}
	/* TODO copy triggers */
	/* also create dependencies */
	if (t->query) {
		sql_rel *r = NULL;
		sql->sa = sa_create();
		r = rel_parse(sql, t->query, m_deps); 
		rel_destroy(r);
		sa_destroy(sql->sa);
		sql->sa = NULL;
	}
	return MAL_SUCCEED;
}

static str
alter_table( mvc *sql, char *sname, sql_table *t)
{
	sql_schema *s = mvc_bind_schema(sql, sname);
	sql_table *nt = NULL;
	node *n;

	if (!s) 
		return sql_message("ALTER TABLE: no such schema '%s'", sname);

	if ((nt = mvc_bind_table(sql, s, t->base.name)) == NULL) {
		return sql_message("ALTER TABLE: no such table '%s'", t->base.name);

	} else if (!schema_privs(sql->role_id, s)){
		return sql_message("ALTER TABLE: insufficient privileges for user '%s' in schema '%s'", stack_get_string(sql, "current_user"), s->base.name);
	}

	/* First check if all the changes are allowed */
	if (t->idxs.set) {
		/* only one pkey */
		if (nt->pkey) {
			for (n = t->idxs.nelm; n; n = n->next) {
				sql_idx *i = n->data;
				if (i->key->type == pkey)
					return sql_message("CONSTRAINT PRIMARY KEY: a table can have only one PRIMARY KEY\n");
			}
		}
	}

	if (t->readonly != nt->readonly) 
		mvc_readonly( sql, nt, t->readonly);

	/* check for changes */
	if (t->tables.dset) for (n = t->tables.dset->h; n; n = n->next) {
		/* propagate alter table .. drop table */
		sql_table *at = n->data;
		sql_table *pt = mvc_bind_table(sql, nt->s, at->base.name);

		sql_trans_del_table(sql->session->tr, nt, pt, at->drop_action);
	}
	for (n = t->tables.nelm; n; n = n->next) {
		/* propagate alter table .. add table */
		sql_table *at = n->data;
 		sql_table *pt = mvc_bind_table(sql, nt->s, at->base.name);

		sql_trans_add_table(sql->session->tr, nt, pt);
	}

	/* check for changes */
	if (t->columns.dset) for (n = t->columns.dset->h; n; n = n->next) {
		/* propagate alter table .. drop column */
		sql_column *c = n->data;
 		sql_column *nc = mvc_bind_column(sql, nt, c->base.name);
		mvc_drop_column(sql, nt, nc, c->drop_action);
	}
	/* check for changes on current cols */
	for (n = t->columns.set->h; n != t->columns.nelm; n = n->next) {

		/* null or default value changes */
		sql_column *c = n->data;
 		sql_column *nc = mvc_bind_column(sql, nt, c->base.name);

		if (c->null != nc->null) {
			mvc_null(sql, nc, c->null);
			/* for non empty check for nulls */
			if (c->null == 0){
				BAT *b = store_funcs.bind_col(sql->session->tr, nc, 0);

				/* TODO also check updates and inserts */
				if (BATcount(b) && b->T->nonil != TRUE) {
					BUN bun = BUNfnd(BATmirror(b), ATOMnilptr(b->ttype));
					if (bun != BUN_NONE)
						return sql_message ("ALTER TABLE: NOT NULL constraint violated for column %s.%s", c->t->base.name, c->base.name );
				}
				BBPunfix(b->batCacheid);
			}
		}
		if (c->def != nc->def)
			mvc_default(sql, nc, c->def);
	}
	for (; n; n = n->next) {
		/* propagate alter table .. add column */
		sql_column *c = n->data;
		mvc_copy_column(sql, nt, c);
	}
	if (t->idxs.set) {
		/* alter drop index */
		if (t->idxs.dset) for (n = t->idxs.dset->h; n; n = n->next) {
			sql_idx *i = n->data;
 			sql_idx *ni = mvc_bind_idx(sql, s, i->base.name);
			mvc_drop_idx(sql, s, ni);
		}
		/* alter add index */
		for (n = t->idxs.nelm; n; n = n->next) {
			sql_idx *i = n->data;
			mvc_copy_idx(sql, nt, i);
		}
	}
	if (t->keys.set) {
		/* alter drop key */
		if (t->keys.dset) for (n = t->keys.dset->h; n; n = n->next) {
			sql_key *k = n->data;
 			sql_key *nk = mvc_bind_key(sql, s, k->base.name);
			mvc_drop_key(sql, s, nk, k->drop_action);
		}
		/* alter add key */
		for (n = t->keys.nelm; n; n = n->next) {
			sql_key *k = n->data;
			mvc_copy_key(sql, nt, k);
		}
	}

	/* TODO copy triggers */
	/* also create dependencies */
	return MAL_SUCCEED;
}



static char *
drop_table(mvc *sql, char *sname, char *tname, int drop_action)
{
	sql_schema *s = NULL;
	sql_table *t = NULL;
	node *n; 

	if (sname && !(s=mvc_bind_schema(sql, sname))) 
		return sql_message("DROP TABLE: no such schema '%s'", sname);
	if (!s)
		s = cur_schema(sql);
	t = mvc_bind_table(sql, s, tname);
	if (!t && !sname) {
		s = tmp_schema(sql);
		t = mvc_bind_table(sql, s, tname);
	}
	if (!t) { 
		return sql_message("DROP TABLE: no such table '%s'", tname);
	} else if (!isTable(t)) {
		return sql_message("DROP TABLE: cannot drop VIEW '%s'", tname);
	} else if (t->system) {
		return sql_message("DROP TABLE: cannot drop system table '%s'", tname);
	} else if (!schema_privs(sql->role_id, s)) {
		return sql_message("DROP TABLE: access denied for %s to schema ;'%s'", stack_get_string(sql, "current_user"), s->base.name);
	}
	if ( !drop_action && t->keys.set) {
		for (n = t->keys.set->h; n; n = n->next) {
			sql_key *k = n->data;

			if (k->type == ukey || k->type == pkey) {
				sql_ukey *uk = (sql_ukey *) k;

				if (uk->keys && list_length(uk->keys)) {
					node *l = uk->keys->h;

					for (; l; l = l->next) {
						k = l->data;
						/* make sure it is not a self referencing key */
						if (k->t != t) 
							return sql_message("DROP TABLE: FOREIGN KEY %s.%s depends on %s", k->t->base.name, k->base.name, tname);
					}
				}
			}
		}
	}

	if (!drop_action && mvc_check_dependency(sql, t->base.id, TABLE_DEPENDENCY, NULL))
		return sql_message("DROP TABLE: unable to drop table %s (there are database objects which depend on it)\n", t->base.name);
	
	mvc_drop_table(sql, s, t, drop_action);
	return MAL_SUCCEED;
}

static char *
drop_view(mvc *sql, char *sname, char *tname, int drop_action)
{
	sql_table *t = NULL;
	sql_schema *ss = NULL;

	if (sname != NULL && (ss = mvc_bind_schema(sql, sname)) == NULL)
		return sql_message("DROP VIEW: no such schema '%s'", sname);

	if (ss == NULL)
		ss = cur_schema(sql);

	t = mvc_bind_table(sql, ss, tname);

	if (!schema_privs(sql->role_id, ss)) {  
		return sql_message("DROP VIEW: access denied for %s to schema '%s'", stack_get_string(sql, "current_user"), ss->base.name);
	} else if (!t) {
		return sql_message("DROP VIEW: unknown view '%s'", tname);
	} else if (!isView(t)) {
		return sql_message("DROP VIEW: unable to drop view '%s': is a table", tname);
	} else if (t->system) {
		return sql_message("DROP VIEW: cannot drop system view '%s'", tname);
	} else if (! drop_action && mvc_check_dependency(sql, t->base.id, VIEW_DEPENDENCY, NULL)) {
			return sql_message("unable to drop view %s (there are database objects which depend on it)\n", t->base.name);
	} else {
		mvc_drop_table(sql, ss, t, drop_action);
		return MAL_SUCCEED;
	}
}

static str
drop_key( mvc *sql, char *sname, char *kname, int drop_action )
{
	sql_key *key;
	sql_schema *ss = NULL;

	if (sname != NULL && (ss = mvc_bind_schema(sql, sname)) == NULL)
		return sql_message("DROP VIEW: no such schema '%s'", sname);

	if (ss == NULL)
		ss = cur_schema(sql);

	if ((key = mvc_bind_key(sql, ss, kname )) == NULL) 
		return sql_message("ALTER TABLE: no such constraint '%s'", kname);
	if (!drop_action && mvc_check_dependency(sql, key->base.id, KEY_DEPENDENCY, NULL)) 
		return sql_message("ALTER TABLE: cannot drop constraint '%s': there are database objects which depend on it", key->base.name);
	mvc_drop_key(sql, ss, key, drop_action);
	return MAL_SUCCEED;
}

static str
create_index( mvc *sql, char *iname, int itype, char *sname, char *tname, MalStkPtr stk, InstrPtr pci) 
{
	sql_schema *s = NULL;
	sql_table *t = NULL;
	sql_idx *i = NULL;

	if (!(s = mvc_bind_schema(sql, sname)))
		return sql_message("CREATE INDEX: no such schema '%s'", sname);

	i = mvc_bind_idx(sql, s, iname);
	t = mvc_bind_table(sql, s, tname);
	if (i) {
		return sql_message("CREATE INDEX: name '%s' already in use", iname);
	} else if (!t) {
		return sql_message("CREATE INDEX: no such table '%s'", tname);
	} else if (isView(t)) {
		return sql_message("CREATE INDEX: cannot create index on view '%s'", tname);
	} else {
		int n;
		sql_idx *i = mvc_create_idx(sql, t, iname, (idx_type) itype);

		if (!i) 
			return sql_message("CREATE INDEX: failed to create index '%s'", iname);

		for (n=6; n<pci->argc; n++) {
			char *cname = *(str*)getArgReference(stk, pci, n);
			sql_column *c = mvc_bind_column(sql, t, cname);

			if (!c) {
				return sql_message("CREATE INDEX: no such column '%s'", cname);
			} else {
				mvc_create_ic(sql, i, c);
				mvc_create_dependency(sql, c->base.id, i->base.id, INDEX_DEPENDENCY);
			}
		}
	}
	return NULL;
}

static str
drop_index( mvc *sql, char *sname, char *iname)
{
	sql_schema *s = NULL;
	sql_idx *i = NULL;

	if (!(s=mvc_bind_schema(sql, sname))) 
		return sql_message("DROP INDEX: no such schema '%s'", sname);
 	i = mvc_bind_idx(sql, s, iname);
	if (!i) {
		return sql_message("DROP INDEX: no such index '%s'", iname);
	} else if (!schema_privs(sql->role_id, s)) {
		return sql_message("DROP INDEX: access denied for %s to schema ;'%s'", stack_get_string(sql, "current_user"), s->base.name);
	} else {
		mvc_drop_idx(sql, s, i);
	}
	return NULL;
}

static str
create_seq( mvc *sql, char *sname, sql_sequence *seq)
{
	sql_schema *s = NULL;

	if (sname && !(s = mvc_bind_schema(sql, sname)))
		return sql_message("CREATE SEQUENCE: no such schema '%s'", sname);
	if (s == NULL)
		s = cur_schema(sql);
	if (find_sql_sequence(s, seq->base.name)) {
		return sql_message("CREATE SEQUENCE: name '%s' already in use", seq->base.name);
	} else if (!schema_privs(sql->role_id, s)) {
		return sql_message( "CREATE SEQUENCE: insufficient privileges for '%s' in schema '%s'", stack_get_string(sql, "current_user"), s->base.name);
	}
	sql_trans_create_sequence(sql->session->tr, s, seq->base.name, seq->start, seq->minvalue, seq->maxvalue, seq->increment, seq->cacheinc, seq->cycle, seq->bedropped);
	return NULL;
}

static str
alter_seq( mvc *sql, char *sname, sql_sequence *seq, lng *val)
{
	sql_schema *s = NULL;
	sql_sequence *nseq = NULL;

	if (sname && !(s = mvc_bind_schema(sql, sname)))
		return sql_message("ALTER SEQUENCE: no such schema '%s'", sname);
	if (s == NULL)
		s = cur_schema(sql);
	if (!(nseq = find_sql_sequence(s, seq->base.name))) {
		return sql_message( "ALTER SEQUENCE: no such sequence '%s'", seq->base.name);
	} else if (!schema_privs(sql->role_id, s)) {
		return sql_message( "ALTER SEQUENCE: insufficient privileges for '%s' in schema '%s'", stack_get_string(sql, "current_user"), s->base.name);
	}

	/* first alter the known values */
	sql_trans_alter_sequence(sql->session->tr, nseq, seq->minvalue, seq->maxvalue, seq->increment, seq->cacheinc, seq->cycle);
	if (val)
		sql_trans_sequence_restart(sql->session->tr, nseq, *val);
	return MAL_SUCCEED;
}




static str
drop_seq(mvc *sql, char *sname, char *name)
{
	sql_schema *s = NULL;
	sql_sequence *seq = NULL;

	if (sname && !(s = mvc_bind_schema(sql, sname)))
		return sql_message("DROP SEQUENCE: no such schema '%s'", sname);
	if (!s)
		s = cur_schema(sql);
	if (!(seq = find_sql_sequence(s, name))) {
		return sql_message("DROP SEQUENCE: no such sequence '%s'", name);
	} else if (!schema_privs(sql->role_id, s)) {
		return sql_message("DROP SEQUENCE: insufficient privileges for '%s' in schema '%s'", stack_get_string(sql, "current_user"),  s->base.name);
	}
	if (mvc_check_dependency(sql, seq->base.id, BEDROPPED_DEPENDENCY, NULL))
		return sql_message("DROP SEQUENCE: unable to drop sequence %s (there are database objects which depend on it)\n", seq->base.name);

	sql_trans_drop_sequence(sql->session->tr, s, seq, 0);
	return NULL;
}


static char *
SaveArgReference(MalStkPtr stk, InstrPtr pci, int arg)
{
	char *val = *(str*)getArgReference(stk, pci, arg);

	if (val && strcmp(val, str_nil) == 0)
		val = NULL;
	return val;
}

str
SQLcatalog(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	mvc *sql = NULL;
	str msg = getContext(cntxt, mb, &sql, NULL);
	int type = *(int*) getArgReference(stk, pci, 1);
	str sname = *(str*) getArgReference(stk, pci, 2);

	if (msg)
		return msg;

	if (STORE_READONLY(active_store_type)) 
		return sql_message("SQLException:sql.catalog: schema statements cannot be executed on a readonly database.");

	switch (type) {
	case DDL_CREATE_SEQ:
	{
		sql_sequence *s = *(sql_sequence**) getArgReference(stk, pci, 3);
		msg = create_seq(sql, sname, s);
	} 	break;
	case DDL_ALTER_SEQ:
	{
		lng *val = NULL;
		sql_sequence *s = *(sql_sequence**) getArgReference(stk, pci, 3);
		if (getArgType(mb, pci, 4) == TYPE_lng) 
			val = getArgReference(stk, pci, 4);
		if (val == NULL || *val == lng_nil)
			msg = sql_message("ALTER SEQUENCE: cannot (re)start with NULL");
		else
			msg = alter_seq(sql, sname, s, val);
	} 	break;
	case DDL_DROP_SEQ: {
		str name = *(str*) getArgReference(stk, pci, 3);

		msg = drop_seq( sql, sname, name);
	} 	break;
	case DDL_CREATE_SCHEMA: {
		str name = SaveArgReference(stk, pci, 3);
		int auth_id = sql->role_id;

		if (name && (auth_id = sql_find_auth(sql, name)) < 0) {
			msg = sql_message("CREATE SCHEMA: no such authorization '%s'", name);
		}
		if (sql->user_id != USER_MONETDB && sql->role_id != ROLE_SYSADMIN) {
			msg = sql_message("CREATE SCHEMA: insufficient privileges for user '%s'", stack_get_string(sql, "current_user"));
		}
		if (mvc_bind_schema(sql, sname)) {
			msg = sql_message("CREATE SCHEMA: name '%s' already in use", sname);
		} else {
			(void)mvc_create_schema(sql, sname, auth_id, sql->user_id);
		}
	}	break;
	case DDL_DROP_SCHEMA: {
		int action = *(int*) getArgReference(stk, pci, 4);
		sql_schema *s = mvc_bind_schema(sql, sname);

		if (!s) {
			msg = sql_message("DROP SCHEMA: name %s does not exist", sname);
		} else if (!schema_privs(sql->role_id, s)) {
			msg = sql_message("DROP SCHEMA: access denied for %s to schema ;'%s'", stack_get_string(sql, "current_user"), s->base.name);
		} else if (s == cur_schema(sql)) {
			msg = sql_message("DROP SCHEMA: cannot drop current schema");
		} else if (strcmp(sname, "sys") == 0 || strcmp(sname, "tmp") == 0) {
			msg = sql_message("DROP SCHEMA: access denied for '%s'", sname);
		} else if (sql_schema_has_user(sql, s)) {
			msg = sql_message("DROP SCHEMA: unable to drop schema '%s' (there are database objects which depend on it", sname);
		} else {
			mvc_drop_schema(sql, s, action);
		}
	} 	break;
	case DDL_CREATE_TABLE: 
	case DDL_CREATE_VIEW: 
	{
		sql_table *t = *(sql_table**) getArgReference(stk, pci, 3);
		int temp = *(int*) getArgReference(stk, pci, 4);

		msg = create_table_or_view(sql, sname, t, temp);
	} 	break;
	case DDL_DROP_TABLE: {
		int action = *(int*) getArgReference(stk, pci, 4);
		str name = *(str*) getArgReference(stk, pci, 3);

		msg = drop_table( sql, sname, name, action);
	} 	break;
	case DDL_DROP_VIEW: {
		int action = *(int*) getArgReference(stk, pci, 4);
		str name = *(str*) getArgReference(stk, pci, 3);

		msg = drop_view( sql, sname, name, action);
	} 	break;
	case DDL_DROP_CONSTRAINT: {
		int action = *(int*) getArgReference(stk, pci, 4);
		str name = *(str*) getArgReference(stk, pci, 3);

		msg = drop_key( sql, sname, name, action);
	} 	break;
	case DDL_ALTER_TABLE: {
		sql_table *t = *(sql_table**) getArgReference(stk, pci, 3);
		msg = alter_table(sql, sname, t);
	} 	break;
	case DDL_CREATE_TYPE: {
		char *impl = *(str*) getArgReference(stk, pci, 3);
		if (!mvc_create_type(sql, sql->session->schema, sname, 0, 0, 0, impl)) 
			msg = sql_message("CREATE TYPE: unknown external type '%s'", impl);
	} 	break;
	case DDL_DROP_TYPE: {
		msg = sql_message("DROP TYPE: not implemented ('%s')", sname);
	} 	break;
	case DDL_GRANT_ROLES: {
		char *auth = SaveArgReference(stk, pci, 3);

		msg = sql_grant_role( sql, sname /*grantee */, auth);
	} 	break;
	case DDL_REVOKE_ROLES: {
		char *auth = SaveArgReference(stk, pci, 3);

		msg = sql_revoke_role( sql, sname /*grantee */, auth);
	} 	break;
	case DDL_GRANT: {
		char *grantee = *(str*)getArgReference(stk, pci, 3);
		int privs = *(int*)getArgReference(stk, pci, 4);
		char *cname = SaveArgReference(stk, pci, 5);
		int grant = *(int*)getArgReference(stk, pci, 6);
		int grantor = *(int*)getArgReference(stk, pci, 7);
		msg = sql_grant_table_privs( sql, grantee, privs, sname, cname, grant, grantor);
	} 	break;
	case DDL_REVOKE: {
		char *grantee = *(str*)getArgReference(stk, pci, 3);
		int privs = *(int*)getArgReference(stk, pci, 4);
		char *cname = SaveArgReference(stk, pci, 5);
		int grant = *(int*)getArgReference(stk, pci, 6);
		int grantor = *(int*)getArgReference(stk, pci, 7);
		msg = sql_revoke_table_privs( sql, grantee, privs, sname, cname, grant, grantor);
	} 	break;
	case DDL_CREATE_USER: {
		char *passwd = *(str*)getArgReference(stk, pci, 3);
		int enc = *(int*)getArgReference(stk, pci, 4);
		char *schema = SaveArgReference(stk, pci, 5);
		char *fullname = SaveArgReference(stk, pci, 6);
		msg = sql_create_user( sql, sname, passwd, enc, fullname, schema);
	}	break;
	case DDL_DROP_USER: {
		msg = sql_drop_user( sql, sname);
	}	break;
	case DDL_ALTER_USER: {
		char *passwd = SaveArgReference(stk, pci, 3);
		int enc = *(int*)getArgReference(stk, pci, 4);
		char *schema = SaveArgReference(stk, pci, 5);
		char *oldpasswd = SaveArgReference(stk, pci, 6);
		msg = sql_alter_user( sql, sname, passwd, enc, schema, oldpasswd);
	}	break;
	case DDL_RENAME_USER: {
		char *newuser = *(str*)getArgReference(stk, pci, 3);
		msg = sql_rename_user( sql, sname, newuser);
	}	break;
	case DDL_CREATE_ROLE: {
		char *role = sname;
		int grantor = *(int*)getArgReference(stk, pci, 4);
		msg = sql_create_role( sql, role, grantor);
	} 	break;
	case DDL_DROP_ROLE: {
		char *role = sname;
		msg = sql_drop_role( sql, role);
	} 	break;
	case DDL_CREATE_INDEX: {
		int itype = *(int*)getArgReference(stk, pci, 3);
		char *ssname = *(str*)getArgReference(stk, pci, 4);
		char *tname = *(str*)getArgReference(stk, pci, 5);
		msg = create_index( sql, sname, itype, ssname, tname, stk, pci);
	} 	break;
	case DDL_DROP_INDEX: {
		char *iname = *(str*)getArgReference(stk, pci, 3);
		msg = drop_index( sql, sname, iname );
	} 	break;
	default:
		throw(SQL, "sql.catalog", "catalog unknown type");
	}
	if (msg)
		throw(SQL, "sql.catalog", "%s", msg);
	return MAL_SUCCEED;
}

/* setVariable(int *ret, str *name, any value) */
str
setVariable(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int *res = (int*)getArgReference(stk, pci, 0);
	mvc *m = NULL;
	str msg = getContext(cntxt, mb, &m, NULL);
	str varname   = *(str *) getArgReference(stk, pci, 2);
	int mtype = getArgType(mb, pci, 3);
	ValRecord *src;
	char buf[BUFSIZ];

	*res = 0;
	if (mtype < 0 || mtype >= 255)
		throw(SQL, "sql.setVariable", "failed");
	if ( strcmp("optimizer",  varname)== 0) {
		msg = setOptimizers(*(str *) getArgReference(stk,pci,3));
		if ( msg != NULL && strcmp(msg,"default_pipe") == 0 )
			return MAL_SUCCEED;
		msg = SQLvalidatePipeline();
		if ( msg ){
			setOptimizers("default_pipe");
			return msg;
		}
	}
	src = &stk->stk[getArg(pci, 3)];
	if (stack_find_var(m, varname)) {
		stack_set_var(m, varname, src);
	} else {
		snprintf(buf, BUFSIZ, "variable '%s' unknown", varname);
		throw(SQL, "sql.setVariable", "%s", buf);
	}
	if ((msg = sql_update_var(m, varname)) != NULL) {
		snprintf(buf, BUFSIZ, "%s", msg);
		_DELETE(msg);
		throw(SQL, "sql.setVariable", "%s", buf);
	}
	return MAL_SUCCEED;
}

/* getVariable(int *ret, str *name) */
str
getVariable(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int mtype = getArgType(mb, pci, 0);
	mvc *m = NULL;
	str msg = getContext(cntxt, mb, &m, NULL);
	str varname   = *(str *) getArgReference(stk, pci, 2);
	ValRecord *dst, *src;

	if (msg)
		return msg;
	if (mtype < 0 || mtype >= 255)
		throw(SQL, "sql.getVariable", "failed");
	src = stack_get_var(m, varname);
	if (!src) {
		char buf[BUFSIZ];
		snprintf(buf, BUFSIZ, "variable '%s' unknown", varname);
		throw(SQL, "sql.getVariable", "%s", buf);
	}
	dst = &stk->stk[getArg(pci, 0)];
	VALcopy(dst,src);
	return MAL_SUCCEED;
}

str
sql_variables(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int i;
	mvc *m = NULL;
	BAT *vars, *r; 
	str msg = getContext(cntxt,mb, &m, NULL);
	int *res = (int *) getArgReference(stk, pci, 0);

	if (msg)
		return msg;

	vars = BATnew(TYPE_void,TYPE_str, m->topvars);
	if ( vars == NULL)
		throw(SQL, "sql.variables", MAL_MALLOC_FAIL);
	BATseqbase(vars, 0);
	for (i=0; i<m->topvars && m->vars[i].s; i++) 
		BUNappend(vars, m->vars[i].name, FALSE);
	r = BATnew(TYPE_str,TYPE_bat,1);
	if( r == NULL){
		BBPreleaseref(vars->batCacheid);
		throw(SQL, "sql.variables", MAL_MALLOC_FAIL);
	}
	BUNins(r, "name", &vars->batCacheid, FALSE);
	BBPunfix(vars->batCacheid);
	*res = r->batCacheid;
	BBPkeepref(r->batCacheid);
	return MAL_SUCCEED;
}

/* str mvc_logfile(int *d, str *filename); */
str
mvc_logfile(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	mvc *m = NULL;
	str msg = getContext(cntxt,mb, &m, NULL);
	int *res = (int *) getArgReference(stk, pci, 0);
	str filename = *(str *)getArgReference(stk, pci, 1);

	if (msg)
		return msg;
	if (m->scanner.log) {
		close_stream(m->scanner.log);
		m->scanner.log = NULL;
	}

	if (strcmp(filename, str_nil)) 
		m->scanner.log = open_wastream(filename);
	*res = 0;
	return MAL_SUCCEED;
}

/* str mvc_next_value(lng *res, str *sname, str *seqname); */
str
mvc_next_value(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	mvc *m = NULL;
	str msg = getContext(cntxt,mb, &m, NULL);
	sql_schema *s;
	lng *res  = (lng *) getArgReference(stk, pci, 0);
	str *sname  = (str *) getArgReference(stk, pci, 1);
	str *seqname  = (str *) getArgReference(stk, pci, 2);

	(void) cntxt;
	if (msg)
		return msg;
 	s = mvc_bind_schema(m, *sname);
	if (s) {
		sql_sequence *seq = find_sql_sequence(s, *seqname);

		if (seq && seq_next_value(seq, res)) {
			m->last_id = *res;
			stack_set_number(m, "last_id", m->last_id);
			return MAL_SUCCEED;
		}
	}
	throw(SQL, "sql.next_value", "error");
}

/* str mvc_bat_next_value(bat *res, int *sid, str *seqname); */
str
mvc_bat_next_value(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	mvc *m = NULL;
	str msg = getContext(cntxt,mb, &m, NULL);
	BAT *b, *r;
	BUN p,q;
	sql_schema *s = NULL;
	sql_sequence *seq = NULL;
	seqbulk *sb = NULL;
	BATiter bi;
	bat *res  = (bat *) getArgReference(stk, pci, 0);
	int *sid  = (int *) getArgReference(stk, pci, 1);
	str *seqname  = (str *) getArgReference(stk, pci, 2);

	(void) cntxt;
	if (msg)
		return msg;

	if( (b = BATdescriptor(*sid)) == NULL )
		throw(SQL, "sql.next_value", "Cannot access descriptor");

	r = BATnew(b->htype, TYPE_lng, BATcount(b));
	if (!r) {
		BBPunfix(b->batCacheid);
		throw(SQL, "sql.next_value", "Cannot create bat");
	}
	BATseqbase(r, b->hseqbase);

	if (!BATcount(b)) {
		BBPunfix(b->batCacheid);
		BBPkeepref(r->batCacheid);
		*res = r->batCacheid;
		return MAL_SUCCEED;
	}

	bi = bat_iterator(b);
	BATloop(b,p,q){
		str sname = BUNtail(bi,BUNfirst(b));
		lng l;

		if (!s || strcmp(s->base.name, sname) != 0) {
			if (sb)
				seqbulk_destroy(sb);
			s = mvc_bind_schema(m, sname);
			seq = NULL;
			if (!s || 
			    (seq = find_sql_sequence(s, *seqname)) == NULL ||
			    !(sb = seqbulk_create(seq, BATcount(b))) ) {
				BBPunfix(b->batCacheid);
				BBPunfix(r->batCacheid);
				throw(SQL, "sql.next_value", "error");
			}
		}
		if (!seqbulk_next_value(sb, &l)) {
			BBPunfix(b->batCacheid);
			BBPunfix(r->batCacheid);
			seqbulk_destroy(sb);
			throw(SQL, "sql.next_value", "error");
		}
		BUNins(r, BUNhead(bi,p), &l, FALSE);
	}
	if (sb) 
		seqbulk_destroy(sb);
	BBPunfix(b->batCacheid);
	BBPkeepref(r->batCacheid);
	*res = r->batCacheid;
	return MAL_SUCCEED;
}

/* str mvc_get_value(lng *res, str *sname, str *seqname); */
str
mvc_get_value(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	mvc *m = NULL;
	str msg = getContext(cntxt,mb, &m, NULL);
	sql_schema *s;
	lng *res  = (lng *) getArgReference(stk, pci, 0);
	str *sname  = (str *) getArgReference(stk, pci, 1);
	str *seqname  = (str *) getArgReference(stk, pci, 2);

	(void) cntxt;
	if (msg)
		return msg;
 	s = mvc_bind_schema(m, *sname);
	if (s) {
		sql_sequence *seq = find_sql_sequence(s, *seqname);

		if (seq && seq_get_value(seq, res))
			return MAL_SUCCEED;
	}
	throw(SQL, "sql.get_value", "error");
}

str
mvc_getVersion(lng *version, int *clientid)
{
	mvc *m = NULL;
	Client cntxt = MCgetClient(*clientid);
	str msg = getContext(cntxt, NULL, &m, NULL);

	if (msg)
		return msg;
	*version = -1;
	if (m->session->tr)
		*version = m->session->tr->stime;
	return MAL_SUCCEED;
}

/* str mvc_restart_seq(lng *res, str *sname, str *seqname, lng *start); */
str
mvc_restart_seq(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	mvc *m = NULL;
	str msg = getContext(cntxt,mb, &m, NULL);
	sql_schema *s;
	lng *res  = (lng *) getArgReference(stk, pci, 0);
	str *sname  = (str *) getArgReference(stk, pci, 1);
	str *seqname  = (str *) getArgReference(stk, pci, 2);
	lng *start  = (lng *) getArgReference(stk, pci, 3);

	(void) cntxt;
	if (msg)
		return msg;
	if (*start == lng_nil)
		throw(SQL, "sql.restart", "cannot (re)start with NULL");
 	s = mvc_bind_schema(m, *sname);
	if (s) {
		sql_sequence *seq = find_sql_sequence(s, *seqname);

		if (seq) {
			*res = sql_trans_sequence_restart(m->session->tr, seq, *start);
			return MAL_SUCCEED;
		}
	}
	throw(SQL, "sql.restart", "sequence %s not found", *sname);
}



BAT *
mvc_bind(mvc *m, char *sname, char *tname, char *cname, int access)
{
	sql_trans *tr = m->session->tr;
	BAT *b = NULL;
	sql_schema *s = NULL;
	sql_table *t = NULL;
	sql_column *c = NULL;

	s = mvc_bind_schema(m, sname);
	if ( s == NULL) 
		return NULL;
	t = mvc_bind_table(m, s, tname);
	if ( t == NULL) 
		return NULL;
	c = mvc_bind_column(m, t, cname);
	if ( c == NULL) 
		return NULL;

	b = store_funcs.bind_col(tr, c, access);
	return b;
}

BAT *
mvc_bind_dbat(mvc *m, char *sname, char *tname, int access)
{
	sql_trans *tr = m->session->tr;
	BAT *b = NULL;
	sql_schema *s = NULL;
	sql_table *t = NULL;
	s = mvc_bind_schema(m, sname);
	if ( s == NULL)
		return NULL;
	t = mvc_bind_table(m, s, tname);
	if ( t == NULL)
		return NULL;

	b = store_funcs.bind_del(tr, t, access);
	return b;
}

BAT *
mvc_bind_idxbat(mvc *m, char *sname, char *tname, char *iname, int access)
{
	sql_trans *tr = m->session->tr;
	BAT *b = NULL;
	sql_schema *s = mvc_bind_schema(m, sname);
	sql_idx *i = mvc_bind_idx(m, s, iname);

	(void) tname;
	b = store_funcs.bind_idx(tr, i, access);
	return b;
}

/* str mvc_bind_wrap(int *bid, str *sname, str *tname, str *cname, int *access); */
str
mvc_bind_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	BAT *b = NULL, *bn;
	int *bid = (int *)getArgReference(stk, pci, 0);
	mvc *m = NULL;
	str msg = getContext(cntxt,mb, &m, NULL);
	str *sname = (str *)getArgReference(stk, pci, 2);
	str *tname = (str *)getArgReference(stk, pci, 3);
	str *cname = (str *)getArgReference(stk, pci, 4);
	int *access = (int *)getArgReference(stk, pci, 5);
	oid lval,hval=0;

	if (msg)
		return msg;
	b = mvc_bind(m, *sname, *tname, *cname, *access);
	if (b) {
		if ( pci->argc == 8 && getArgType(mb,pci,6) == TYPE_oid){
			/* partitioned access */
			lval = *(oid *)getArgReference(stk, pci, 6);
			hval = *(oid *)getArgReference(stk, pci, 7);
			if (*access == 0) {
				bn =  BATslice(b, lval,hval);
				BATseqbase(bn, lval);
				BBPreleaseref(b->batCacheid);
			} else {
				bn = b;
			}
			BBPkeepref( *bid = bn->batCacheid);
			return MAL_SUCCEED;
		} else if ( pci->argc == 8 && getArgType(mb,pci,6) == TYPE_int){
			BUN cnt = BATcount(b), psz;
			/* partitioned access */
			int part_nr = *(int *)getArgReference(stk, pci, 6);
			int nr_parts = *(int *)getArgReference(stk, pci, 7);

			if (*access == 0) {
				psz = cnt?(cnt/nr_parts):0;
				bn =  BATslice(b, part_nr*psz, (part_nr+1==nr_parts)?cnt:((part_nr+1)*psz));
				BATseqbase(bn, part_nr*psz);
			} else {
				oid l, h;
				BAT *c = mvc_bind(m, *sname, *tname, *cname, 0);
				cnt = BATcount(c);
				psz = cnt?(cnt/nr_parts):0;
				l = part_nr*psz;
				h = (part_nr+1==nr_parts)?cnt:((part_nr+1)*psz);
				h--;
				bn = BATmirror(BATselect(BATmirror(b), &l, &h));
			
				BBPreleaseref(c->batCacheid);
			}
			BBPkeepref( *bid = bn->batCacheid);
			BBPreleaseref(b->batCacheid);
			return MAL_SUCCEED;
		}
		BBPkeepref( *bid = b->batCacheid);
		return MAL_SUCCEED;
	}
	throw(SQL, "sql.bind", "unable to find %s.%s(%s)", *sname, *tname, *cname);
}


/* str mvc_bind_idxbat_wrap(int *bid, str *sname, str *tname, str *iname, int *access); */
str
mvc_bind_idxbat_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	BAT *b = NULL,*bn;
	int *bid = (int *)getArgReference(stk, pci, 0);
	mvc *m = NULL;
	str msg = getContext(cntxt,mb, &m, NULL);
	str *sname = (str *)getArgReference(stk, pci, 2);
	str *tname = (str *)getArgReference(stk, pci, 3);
	str *iname = (str *)getArgReference(stk, pci, 4);
	int *access = (int *)getArgReference(stk, pci, 5);
	oid lval,hval=0;

	if (msg)
		return msg;
	b = mvc_bind_idxbat(m, *sname, *tname, *iname, *access);
	if (b) {
		if ( pci->argc == 8 && getArgType(mb,pci,6) == TYPE_oid){
			/* partitioned access, TODO fix update bats */
			lval = *(oid *)getArgReference(stk, pci, 6);
			hval = *(oid *)getArgReference(stk, pci, 7);
			if (*access == 0) {
				bn =  BATslice(b, lval,hval);
				BATseqbase(bn, lval);
				BBPreleaseref(b->batCacheid);
			} else {
				bn = b;
			}
			BBPkeepref( *bid = bn->batCacheid);
			return MAL_SUCCEED;
		} else if ( pci->argc == 8 && getArgType(mb,pci,6) == TYPE_int){
			BUN cnt = BATcount(b), psz;
			/* partitioned access */
			int part_nr = *(int *)getArgReference(stk, pci, 6);
			int nr_parts = *(int *)getArgReference(stk, pci, 7);

			if (*access == 0) {
				psz = cnt?(cnt/nr_parts):0;
				bn =  BATslice(b, part_nr*psz, (part_nr+1==nr_parts)?cnt:((part_nr+1)*psz));
				BATseqbase(bn, part_nr*psz);
			} else {
				oid l, h;
				BAT *c = mvc_bind_idxbat(m, *sname, *tname, *iname, 0);
				cnt = BATcount(c);
				psz = cnt?(cnt/nr_parts):0;
				l = part_nr*psz;
				h = (part_nr+1==nr_parts)?cnt:((part_nr+1)*psz);
				h--;
				bn = BATmirror(BATselect(BATmirror(b), &l, &h));
			
				BBPreleaseref(c->batCacheid);
			}
			BBPkeepref( *bid = bn->batCacheid);
			BBPreleaseref(b->batCacheid);
			return MAL_SUCCEED;
		}
		BBPkeepref( *bid = b->batCacheid);
		return MAL_SUCCEED;
	}
	throw(SQL, "sql.idxbind", "unable to find index %s for %s.%s",
			*iname, *sname, *tname);
}

str 
mvc_diff_idxbat_wrap(bat *bid, int *clientid, str *s, str *t, str *i, int *access, lng *oldversion, lng *version)
{
	mvc *m = NULL;
	Client cntxt = MCgetClient(*clientid);
	str msg = getContext(cntxt, NULL, &m, NULL);
	BAT *b;

	if (msg)
		return msg;
	(void)oldversion;
	(void)version;
	b = mvc_bind(m, *s, *t, *i, *access);
	if (b) {
		BBPkeepref( *bid = b->batCacheid);
		return MAL_SUCCEED;
	}
	throw(SQL, "sql.idxbind", "unable to find index %s for %s.%s", *i, *s, *t);
}

/*mvc_append_wrap(int *bid, str *sname, str *tname, str *cname, ptr d) */
str
mvc_append_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int *res = (int*)getArgReference(stk, pci, 0);
	mvc *m = NULL;
	str msg = getContext(cntxt,mb, &m, NULL);
	str sname = *(str *)getArgReference(stk, pci, 2);
	str tname = *(str *)getArgReference(stk, pci, 3);
	str cname = *(str *)getArgReference(stk, pci, 4);
	ptr ins = (ptr)getArgReference(stk, pci, 5);
	int tpe = getArgType(mb, pci, 5);
	sql_schema *s;
	sql_table *t;
	sql_column *c;

	*res = 0;
	if (msg)
		return msg;
	if (tpe > TYPE_any)
		tpe = TYPE_bat;
	if (tpe == TYPE_bat && (ins = BATdescriptor(*(int*)ins)) == NULL) 
		throw(SQL, "sql.append","Cannot access descriptor");
	if (ATOMextern(tpe)) 
		ins = *(ptr*)ins;
	s = mvc_bind_schema(m, sname);
	if ( s == NULL)
		throw(SQL,"sql.append","Schema missing");
	t = mvc_bind_table(m, s, tname);
	if ( t == NULL)
		throw(SQL,"sql.append","Table missing");
	if (tpe == TYPE_bat)
		BATaccessBegin((BAT*)ins, USE_ALL, MMAP_SEQUENTIAL);	
	if (cname[0] != '%' && (c = mvc_bind_column(m, t, cname)) != NULL) {
		store_funcs.append_col(m->session->tr, c, ins, tpe);
	} else if (cname[0] == '%') {
		sql_idx *i = mvc_bind_idx(m, s, cname+1);
		if (i)
			store_funcs.append_idx(m->session->tr, i, ins, tpe);
	}
	if (tpe == TYPE_bat) {
		BATaccessEnd((BAT*)ins, USE_ALL, MMAP_SEQUENTIAL);	
		BBPunfix(((BAT*)ins)->batCacheid);
	}
	return MAL_SUCCEED;
}

/*mvc_update_wrap(int *bid, str *sname, str *tname, str *cname, ptr d) */
str
mvc_update_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int *res = (int*)getArgReference(stk, pci, 0);
	mvc *m = NULL;
	str msg = getContext(cntxt,mb, &m, NULL);
	str sname = *(str *)getArgReference(stk, pci, 2);
	str tname = *(str *)getArgReference(stk, pci, 3);
	str cname = *(str *)getArgReference(stk, pci, 4);
	ptr ins = (ptr)getArgReference(stk, pci, 5);
	int tpe = getArgType(mb, pci, 5);
	sql_schema *s;
	sql_table *t;
	sql_column *c;

	*res = 0;
	if (msg)
		return msg;
	if (tpe > TYPE_any)
		tpe = TYPE_bat;
	if( tpe == TYPE_bat && (ins = BATdescriptor(*(int*)ins)) == NULL) 
		throw(SQL, "sql.update","Cannot access descriptor");
	if (ATOMextern(tpe)) 
		ins = *(ptr*)ins;
	s = mvc_bind_schema(m, sname);
	if ( s == NULL)
		throw(SQL,"sql.update","Schema missing");
	t = mvc_bind_table(m, s, tname);
	if ( t == NULL)
		throw(SQL,"sql.update","Table missing");
	if (tpe == TYPE_bat)
		BATaccessBegin((BAT*)ins, USE_ALL, MMAP_SEQUENTIAL);	
	if (cname[0] != '%' && (c = mvc_bind_column(m, t, cname)) != NULL) {
		store_funcs.update_col(m->session->tr, c, ins, tpe, 0);
	} else if (cname[0] == '%') {
 		sql_idx *i = mvc_bind_idx(m, s, cname+1);
		if (i)
			store_funcs.update_idx(m->session->tr, i, ins, tpe);
	}
	if (tpe == TYPE_bat) {
		BATaccessEnd((BAT*)ins, USE_ALL, MMAP_SEQUENTIAL);	
		BBPunfix(((BAT*)ins)->batCacheid);
	}
	return MAL_SUCCEED;
}

/*
 * @-
 * Monet 5 extension
 * @-
 * The Mx macro below is used in many places throughout the code base to
 * access the BAT descriptor.
 */
@= chkIdentifier
	/* generate exception if string is not an identifier */
	if( isIdentifier(@1))
		throw(SQL,  "@4","identifier expected");
@= Pseudo
	if (BBPindex("@1_@2_@3") <= 0)
		BATname(b, "@1_@2_@3");
	BATroles(b,"@1","@2");
	BATmode(b,TRANSIENT);
	BATfakeCommit(b);
	*ret = b->batCacheid;

@
@c

str
mvc_bind_single_wrap(int *ret, int *bid, str *name)
{
	BAT *b, *bn;
	int r;
	BUN p;
	BATiter bni;

	if( (bn= BATdescriptor(*bid)) == NULL)
		throw(SQL, "sql.bind","Cannot access descriptor");

	p = BUNfnd(bn, *name);
	bni = bat_iterator(bn);
	r = *(int *) BUNtail(bni, p);
	if( (b= BATdescriptor(r)) == NULL)
		throw(SQL, "sql.bind","Cannot access descriptor");
	BBPkeepref(*ret= b->batCacheid);
	BBPunfix( bn->batCacheid);
	return MAL_SUCCEED;
}

/* str mvc_bind_dbat_wrap(int *ret, str *sname, str *tname, int *access); */
str
mvc_bind_dbat_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	BAT *b;
	int *ret = (int *)getArgReference(stk, pci, 0);
	mvc *m = NULL;
	str msg = getContext(cntxt,mb, &m, NULL);
	str *sname = (str *)getArgReference(stk, pci, 2);
	str *tname = (str *)getArgReference(stk, pci, 3);
	int *access = (int*)getArgReference(stk, pci, 4);

	if (msg)
		return msg;
	b = mvc_bind_dbat(m, *sname, *tname, *access);
	if (b) {
		BBPkeepref( *ret = b->batCacheid);
		return MAL_SUCCEED;
	}
	throw(SQL, "mvc_bind_dbat_wrap", "error");
}

str 
mvc_diff_dbat_wrap(bat *bid, int *clientid, str *s, str *t, int *access, lng *oldversion, lng *version )
{
	mvc *m = NULL;
	Client cntxt = MCgetClient(*clientid);
	str msg = getContext(cntxt, NULL, &m, NULL);
	BAT *b;

	if (msg)
		return msg;
	(void)oldversion;
	(void)version;
	b = mvc_bind_dbat(m, *s, *t, *access);
	if (b) {
		BBPkeepref( *bid = b->batCacheid);
		return MAL_SUCCEED;
	}
	throw(SQL, "mvc_bind_dbat_wrap", "error");
}

/* str mvc_clear_table_wrap(wrd *res, str *sname, str *tname); */
str
mvc_clear_table_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	sql_schema *s;
	sql_table *t;
	mvc *m = NULL;
	str msg = getContext(cntxt,mb, &m, NULL);
	wrd *res = (wrd *)getArgReference(stk, pci, 0);
	str *sname = (str *)getArgReference(stk, pci, 1);
	str *tname = (str *)getArgReference(stk, pci, 2);

	(void) cntxt;
	if (msg)
		return msg;
	s = mvc_bind_schema(m, *sname);
	if ( s == NULL)
		throw(SQL,"sql.clear_table","Schema missing");
	t = mvc_bind_table(m, s, *tname);
	if ( t == NULL)
		throw(SQL,"sql.clear_table","Table missing");
	*res = mvc_clear_table(m, t);
	return MAL_SUCCEED;
}

/*mvc_delete_wrap(int *d, str *sname, str *tname, ptr d) */
str
mvc_delete_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int *res = (int*)getArgReference(stk, pci, 0);
	mvc *m = NULL;
	str msg = getContext(cntxt,mb, &m, NULL);
	str sname = *(str *)getArgReference(stk, pci, 2);
	str tname = *(str *)getArgReference(stk, pci, 3);
	ptr ins = (ptr)getArgReference(stk, pci, 4);
	int tpe = getArgType(mb, pci, 4);
	BAT *b = NULL;

	sql_schema *s;
	sql_table *t;

	*res = 0;
	if (msg)
		return msg;
	if (tpe > TYPE_any)
		tpe = TYPE_bat;
	if (tpe == TYPE_bat && (b = BATdescriptor(*(int*)ins)) == NULL) 
		throw(SQL, "sql.delete","Cannot access descriptor");
	if (tpe != TYPE_bat || (b->ttype != TYPE_oid && b->ttype != TYPE_void))
		throw(SQL, "sql.delete","Cannot access descriptor");
	s = mvc_bind_schema(m, sname);
	if ( s == NULL)
		throw(SQL,"sql.delete","Schema missing");
	t = mvc_bind_table(m, s, tname);
	if ( t == NULL)
		throw(SQL,"sql.delete","Table missing");
	store_funcs.delete_tab(m->session->tr, t, b, tpe);
	if (tpe == TYPE_bat)
		BBPunfix(((BAT*)ins)->batCacheid);
	return MAL_SUCCEED;
}

static int
mvc_result_row(mvc *m, int nr_cols, int qtype)
{
	m->results = res_table_create(m->session->tr, m->result_id++, nr_cols, qtype, m->results, NULL);
	return m->results->id;
}

/* str mvc_result_row_wrap(int *res_id, int *nr_cols, int *qtype, int *o); */
str
mvc_result_row_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	mvc *m = NULL;
	str msg = getContext(cntxt,mb, &m, NULL);
	int *res_id = (int *)getArgReference(stk, pci, 0);
	int *nr_cols = (int *)getArgReference(stk, pci, 1);
	int *qtype = (int *)getArgReference(stk, pci, 2);
	int *o = (int *)getArgReference(stk, pci, 3);

	(void) cntxt;
	if (msg)
		return msg;
	(void)o; /* dummy order */
	*res_id = mvc_result_row(m, *nr_cols, *qtype); 
	if (*res_id < 0)
		throw(SQL, "sql.resultSet", "failed");
	return MAL_SUCCEED;
}

/* str mvc_result_file_wrap(int *res_id, int *nr_cols, unsigned char* *T, unsigned char* *R, unsigned char* *S, unsigned char* *N, bat *order_bid); */
str 
mvc_result_file_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str res = MAL_SUCCEED;
	BAT *order = NULL;
	mvc *m = NULL;
	str msg = getContext(cntxt,mb, &m, NULL);
	res_table *t = NULL;
	unsigned char *tsep = NULL, *rsep = NULL, *ssep = NULL, *ns = NULL;
	ssize_t len;
	int *res_id = (int *)getArgReference(stk, pci, 0);
	int *nr_cols = (int *)getArgReference(stk, pci, 1);
	unsigned char **T = (unsigned char **)getArgReference(stk, pci, 2);
	unsigned char **R = (unsigned char **)getArgReference(stk, pci, 3);
	unsigned char **S = (unsigned char **)getArgReference(stk, pci, 4);
	unsigned char **N = (unsigned char **)getArgReference(stk, pci, 5);
	int mtype = getArgType(mb, pci, 6);

	(void) cntxt;
	if (msg)
		return msg;
	if (isaBatType(mtype)) {
		bat *order_bid = (bat *)getArgReference(stk, pci, 6);
		if ((order = BATdescriptor(*order_bid)) == NULL ) {
			throw(SQL, "sql.resultSet", "Cannot access descriptor");
		}
	}
	m->results = t = res_table_create(m->session->tr, m->result_id++, *nr_cols, Q_TABLE, m->results, order);
	len = strlen((char*)(*T));
	GDKstrFromStr(tsep=GDKmalloc(len+1), *T, len); len = 0;
	len = strlen((char*)(*R));
	GDKstrFromStr(rsep=GDKmalloc(len+1), *R, len); len = 0;
	len = strlen((char*)(*S));
	GDKstrFromStr(ssep=GDKmalloc(len+1), *S, len); len = 0;
	len = strlen((char*)(*N));
	GDKstrFromStr(ns=GDKmalloc(len+1), *N, len); len = 0;
	t->tsep = (char*)tsep;
	t->rsep = (char*)rsep;
	t->ssep = (char*)ssep;
	t->ns = (char*)ns;
	*res_id = t->id;
	if (*res_id < 0)
		res = createException(SQL, "sql.resultSet", "failed");
	if (order)
		BBPunfix(order->batCacheid);
	return res;
}

/* str mvc_result_table_wrap(int *res_id, int *nr_cols, int *qtype, bat *order_bid); */
str
mvc_result_table_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str res = MAL_SUCCEED;
	BAT *order;
	mvc *m = NULL;
	str msg = getContext(cntxt,mb, &m, NULL);
	int *res_id = (int *)getArgReference(stk, pci, 0);
	int *nr_cols = (int *)getArgReference(stk, pci, 1);
	int *qtype = (int *)getArgReference(stk, pci, 2);
	bat *order_bid = (bat *)getArgReference(stk, pci, 3);

	(void) cntxt;
	if (msg)
		return msg;
	if ((order = BATdescriptor(*order_bid)) == NULL ) {
		throw(SQL, "sql.resultSet", "Cannot access descriptor");
	}
	*res_id = mvc_result_table(m, *nr_cols, *qtype, order);
	if (*res_id < 0)
		res= createException(SQL, "sql.resultSet", "failed");
	BBPunfix(order->batCacheid);
	return res;
}

/* str mvc_result_column_wrap(int *ret, int *rs, str *tn, str *name, str *type, int *digits, int *scale, bat *bid); */
str
mvc_result_column_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str res = MAL_SUCCEED;
	BAT *b;
	mvc *m = NULL;
	str msg = getContext(cntxt,mb, &m, NULL);
	int *ret = (int *)getArgReference(stk, pci, 0);
	str *tn = (str *)getArgReference(stk, pci, 2);
	str *name = (str *)getArgReference(stk, pci, 3);
	str *type = (str *)getArgReference(stk, pci, 4);
	int *digits = (int *)getArgReference(stk, pci, 5);
	int *scale = (int *)getArgReference(stk, pci, 6);
	bat *bid = (bat *)getArgReference(stk, pci, 7);

	(void) cntxt;
	if (msg)
		return msg;
	if ((b = BATdescriptor(*bid)) == NULL)
		throw(SQL, "sql.rsColumn", "cannot access BAT descriptor");
	if (mvc_result_column(m, *tn, *name, *type, *digits, *scale, b)) 
		res = createException(SQL, "sql.rsColumn", "mvc_result_column failed");
	*ret = 0;
	BBPunfix(b->batCacheid);
	return res;
}

str
/*mvc_result_value_wrap(int *ret, int *rs, str *tn, str *name, str *type, int *digits, int *scale, ptr p, int mtype)*/
mvc_result_value_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int *ret  = (int *) getArgReference(stk, pci, 0);
	str *tn   = (str *) getArgReference(stk, pci, 2);
	str *cn   = (str *) getArgReference(stk, pci, 3);
	str *type = (str *) getArgReference(stk, pci, 4);
	int *digits = (int *) getArgReference(stk, pci, 5);
	int *scale = (int *) getArgReference(stk, pci, 6);
	ptr p =  (ptr) getArgReference(stk, pci, 7);
	int mtype = getArgType(mb, pci, 7);
	mvc *m = NULL;
	str msg = getContext(cntxt,mb, &m, NULL);

	(void) cntxt;
	if (msg)
		return msg;
	if (ATOMextern(mtype)) 
		p = *(ptr*)p;
	if (mvc_result_value(m, *tn, *cn, *type, *digits, *scale, p, mtype))
		throw(SQL, "sql.rsColumn", "failed");
	*ret = 0;
	return MAL_SUCCEED;
}

/* str mvc_declared_table_wrap(int *res_id, str *name); */
str
mvc_declared_table_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	mvc *m = NULL;
	str msg = getContext(cntxt,mb, &m, NULL);
	sql_schema *s = NULL;
	int *res_id = (int *) getArgReference(stk, pci, 0);
	str *name = (str *) getArgReference(stk, pci, 1);

	(void) cntxt;
	if (msg)
		return msg;
	s = mvc_bind_schema(m, dt_schema);
	if ( s == NULL)
		throw(SQL,"sql.declared_table","Schema missing");
	(void)mvc_create_table(m, s, *name, tt_table, TRUE, SQL_DECLARED_TABLE, CA_DROP, 0);
	*res_id = 0;
	return MAL_SUCCEED;
}

/* str mvc_declared_table_column_wrap(int *ret, int *rs, str *tname, str *name, str *type, int *digits, int *scale); */
str 
mvc_declared_table_column_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	mvc *m = NULL;
	str msg = getContext(cntxt,mb, &m, NULL);
	sql_schema *s = NULL;
	sql_table *t = NULL;
	sql_subtype tpe;
	int *ret  = (int *) getArgReference(stk, pci, 0);
	int *rs = (int *) getArgReference(stk, pci, 1);
	str *tname = (str *) getArgReference(stk, pci, 2);
	str *name = (str *) getArgReference(stk, pci, 3);
	str *type = (str *) getArgReference(stk, pci, 4);
	int *digits = (int *) getArgReference(stk, pci, 5);
	int *scale = (int *) getArgReference(stk, pci, 6);

	(void) cntxt;
	if (msg)
		return msg;
	if (*rs != 0)
		throw(SQL, "sql.dtColumn", "Cannot access declared table");
	if (!sql_find_subtype(&tpe, *type, *digits, *scale))
		throw(SQL, "sql.dtColumn", "Cannot find column type");
	s = mvc_bind_schema(m, dt_schema);
	if ( s == NULL)
		throw(SQL,"sql.declared_table_column","Schema missing");
	t = mvc_bind_table(m, s, *tname);
	if ( t == NULL)
		throw(SQL,"sql.declared_table_column","Table missing");
	(void)mvc_create_column(m, t, *name, &tpe); 
	*ret = 0;
	return MAL_SUCCEED;
}

str
mvc_drop_declared_table_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci )
{
	mvc *m = NULL;
	str *name = (str *) getArgReference(stk, pci, 1);
	str msg = getContext(cntxt, mb, &m, NULL);
	sql_schema *s = NULL;
	sql_table *t = NULL;

	if (msg)
		return msg;
	s = mvc_bind_schema(m, dt_schema);
	if ( s == NULL)
		throw(SQL,"sql.drop","Schema missing");
	t = mvc_bind_table(m, s, *name);
	if ( t == NULL)
		throw(SQL,"sql.drop","Table missing");
	(void)mvc_drop_table(m, s, t, 0);
	return MAL_SUCCEED;
}

str
mvc_drop_declared_tables_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci )
{
	mvc *m = NULL;
	int i = *(int *) getArgReference(stk, pci, 1);
	str msg = getContext(cntxt, mb, &m, NULL);
	sql_schema *s = NULL;
	sql_table *t = NULL;

	if (msg)
		return msg;
	s = mvc_bind_schema(m, dt_schema);
	if ( s == NULL)
		throw(SQL,"sql.drop","Schema missing");
	while(i && s->tables.set->t) {
		t = s->tables.set->t->data;
		(void)mvc_drop_table(m, s, t, 0);
		i--;
	}
	return MAL_SUCCEED;
}

/* str mvc_affected_rows_wrap(int *m, int m, wrd *nr, str *w); */
str
mvc_affected_rows_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	backend *b = NULL;
	mvc *m = NULL;
	str msg = getContext(cntxt, mb, &m, &b);
	int *res = (int*)getArgReference(stk, pci, 0);
#ifndef NDEBUG
	int mtype = getArgType(mb, pci, 2);
#endif
	wrd nr;
	str *w = (str *) getArgReference(stk, pci, 3);

	if (msg)
		return msg;
	*res = 0;
	assert (mtype == TYPE_wrd);
	nr = *(wrd *) getArgReference(stk, pci, 2);
	if (mvc_export_affrows(m, b->out, nr, *w)) 
		throw(SQL, "sql.affectedRows", "failed");
	return MAL_SUCCEED;
}

/* str mvc_export_head_wrap(int *ret, stream **s, int *res_id); */
str
mvc_export_head_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	backend *b = NULL;
	mvc *c = NULL;
	str msg = getContext(cntxt,mb, &c, &b);
	int *ret  = (int *) getArgReference(stk, pci, 0);
	stream **s  = (stream **) getArgReference(stk, pci, 1);
	int *res_id = (int *) getArgReference(stk, pci, 2);

	(void) cntxt;
	if (msg)
		return msg;
	if (mvc_export_head(c, *s, *res_id, FALSE)) {
		throw(SQL, "sql.exportHead", "failed");
	}
	(void)ret;
	return NULL;
}
/* str mvc_export_result_wrap(int *ret, stream **s, int *res_id); */
str
mvc_export_result_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	backend *b = NULL;
	mvc *c = NULL;
	str msg = getContext(cntxt,mb, &c, &b);
	int *ret  = (int *) getArgReference(stk, pci, 0);
	stream **s  = (stream **) getArgReference(stk, pci, 1);
	int *res_id = (int *) getArgReference(stk, pci, 2);

	(void) cntxt;
	if (msg)
		return msg;
	if (mvc_export_result(c, *s, *res_id)) {
		throw(SQL, "sql.exportResult", "failed");
	}
	(void)ret;
	return NULL;
}
/* str mvc_export_chunk_wrap(int *ret, stream **s, int *res_id, str *w); */
str
mvc_export_chunk_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	backend *b = NULL;
	mvc *c = NULL;
	str msg = getContext(cntxt,mb, &c, &b);
	int *ret  = (int *) getArgReference(stk, pci, 0);
	stream **s  = (stream **) getArgReference(stk, pci, 1);
	int *res_id = (int *) getArgReference(stk, pci, 2);
	BUN	offset = 0;
	BUN	nr = 0;

	if ( pci->argc == 5){
		offset = *(BUN *) getArgReference(stk,pci,3);
		nr = *(BUN *) getArgReference(stk,pci,4);
	} 

	(void) cntxt;
	if (msg)
		return msg;
	if (mvc_export_chunk(c, *s, *res_id, offset, nr)) {
		throw(SQL, "sql.exportChunk", "failed");
	}
	(void)ret;
	return NULL;
}

/* str mvc_export_operation_wrap(int *ret, str *w); */
str
mvc_export_operation_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	backend *b = NULL;
	mvc *c = NULL;
	str msg = getContext(cntxt,mb, &c, &b);
	int *ret  = (int *) getArgReference(stk, pci, 0);
	str *w = (str *) getArgReference(stk, pci, 1);

	(void) cntxt;
	if (msg)
		return msg;
	if (mvc_export_operation(c, b->out, *w)) {
		throw(SQL, "sql.exportOperation", "failed");
	}
	(void)ret;
	return NULL;
}


str
/*mvc_export_value_wrap(int *ret, int *qtype, str tn, str name, str type, int *digits, int *scale, int *eclass, ptr p, int mtype)*/
mvc_export_value_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int *qtype= (int *) getArgReference(stk, pci, 1);
	str *tn   = (str *) getArgReference(stk, pci, 2);
	str *cn   = (str *) getArgReference(stk, pci, 3);
	str *type = (str *) getArgReference(stk, pci, 4);
	int *digits = (int *) getArgReference(stk, pci, 5);
	int *scale = (int *) getArgReference(stk, pci, 6);
	int *eclass = (int *) getArgReference(stk, pci, 7);
	ptr p =  (ptr) getArgReference(stk, pci, 8);
	int mtype = getArgType(mb, pci, 8);
	str *w = (str *) getArgReference(stk, pci, 9);
	backend *b = NULL;
	mvc *c = NULL;
	str msg = getContext(cntxt,mb, &c, &b);

	(void) cntxt;
	if (msg)
		return msg;
	if (ATOMextern(mtype)) 
		p = *(ptr*)p;
	if (b->out == NULL ||
		mvc_export_value(c, b->out, *qtype, *tn, *cn, *type, *digits, *scale, *eclass, p, mtype, *w, "NULL") != SQL_OK)
		throw(SQL, "sql.exportValue", "failed");
	return MAL_SUCCEED;
}

/* str mvc_import_table_wrap(int *res, bstream **s, str *sname, str *tname, unsigned char* *T, unsigned char* *R, unsigned char* *S, unsigned char* *N, lng *sz, lng *offset); */
str
mvc_import_table_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	BAT *b;
	mvc *m = NULL;
	str msg = getContext(cntxt,mb, &m, NULL);
	unsigned char *tsep = NULL, *rsep = NULL, *ssep = NULL, *ns = NULL;
	ssize_t len = 0;
	int *res = (int *) getArgReference(stk, pci, 0);
	bstream **s = (bstream **) getArgReference(stk, pci, 1);
	str *sname = (str *) getArgReference(stk, pci, 2);
	str *tname = (str *) getArgReference(stk, pci, 3);
	unsigned char **T = (unsigned char **) getArgReference(stk, pci, 4);
	unsigned char **R = (unsigned char **) getArgReference(stk, pci, 5);
	unsigned char **S = (unsigned char **) getArgReference(stk, pci, 6);
	unsigned char **N = (unsigned char **) getArgReference(stk, pci, 7);
	lng *sz = (lng *) getArgReference(stk, pci, 8);
	lng *offset = (lng *) getArgReference(stk, pci, 9);
	int *locked = (int *) getArgReference(stk, pci, 10);

	if (msg)
		return msg;
	len = strlen((char*)(*T));
	GDKstrFromStr(tsep=GDKmalloc(len+1), *T, len); len = 0;
	len = strlen((char*)(*R));
	GDKstrFromStr(rsep=GDKmalloc(len+1), *R, len); len = 0;
	if (*S && strcmp(str_nil,*(char**)S)) {
		len = strlen((char*)(*S));
		GDKstrFromStr(ssep=GDKmalloc(len+1), *S, len); 
		len = 0;
	}
	len = strlen((char*)(*N));
	GDKstrFromStr(ns=GDKmalloc(len+1), *N, len); len = 0;
	b = mvc_import_table(cntxt, m, *s, *sname, *tname, (char*)tsep, (char*)rsep, (char*)ssep, (char*)ns, *sz, *offset, *locked);
	GDKfree(tsep);
	GDKfree(rsep);
	if(ssep)
		GDKfree(ssep);
	GDKfree(ns);
	if (!b)
		throw(SQL, "importTable", "%sfailed to import table", m->errstr);
	*res = b->batCacheid;
	BBPincref( *res, TRUE);
	BBPunfix(*res);
	return MAL_SUCCEED;
}

/* str mvc_bin_import_table_wrap(int *res, str *sname, str *tname, str *fname..); */
str
mvc_bin_import_table_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	BAT *b;
	mvc *m = NULL;
	str msg = getContext(cntxt, mb, &m, NULL);
	BUN cnt = 0;
	int i, *res = (int *) getArgReference(stk, pci, 0);
	str sname = *(str *) getArgReference(stk, pci, 1);
	str tname = *(str *) getArgReference(stk, pci, 2);
	sql_schema *s = mvc_bind_schema(m, sname);
	sql_table *t;
	node *n;

	if (msg)
		return msg;

	if ( s == NULL)
		throw(SQL,"sql.drop","Schema missing");
	t = mvc_bind_table(m, s, tname);
	if (!t) 
		throw(SQL,"sql", "table %s not found", tname);
	if (list_length(t->columns.set) != (pci->argc-3))
		throw(SQL,"sql", "Not enough columns in found");

	for (i = 3, n = t->columns.set->h; i<pci->argc && n; i++, n = n->next) {
		sql_column *col = n->data;

		if (ATOMvarsized(col->type.type->localtype )) 
			throw(SQL, "sql", "failed to attach file %s",
			      *(str*)getArgReference(stk, pci, i));
	}

	b = BATnew(TYPE_str, TYPE_bat, pci->argc-3);
	if( b == NULL)
		throw(SQL, "sql.import", MAL_MALLOC_FAIL);

	for (i = 3, n = t->columns.set->h; i<pci->argc && n; i++, n = n->next) {
		sql_column *col = n->data;
		BAT *c;

		c = BATattach(col->type.type->localtype, *(str*)getArgReference(stk, pci, i));
		if (c == NULL) {
			BBPunfix(b->batCacheid);
			throw(SQL, "sql", "failed to attach file %s",
			      *(str*)getArgReference(stk, pci, i));
		}

		BATsetaccess(c, BAT_READ);
		BATpropcheck(c, BATPROPS_ALL);
		BATpropcheck(BATmirror(c), BATPROPS_ALL);
		if (i!=3 && cnt != BATcount(c)) {
			BBPunfix(b->batCacheid);
			throw(SQL, "sql", "table %s not found", tname);
		}
		cnt = BATcount(c);
		BUNins(b, (ptr)col->base.name, (ptr)&c->batCacheid, FALSE);
		BBPunfix( c->batCacheid );
	}
	*res = b->batCacheid;
	BBPincref( *res, TRUE);
	BBPunfix(*res);
	return MAL_SUCCEED;
}


str
zero_or_one(ptr ret, int *bid) 
{
	BAT *b;
	BUN c, _s;
	ptr p;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(SQL, "zero_or_one", "Cannot access descriptor");
	}
	c = BATcount(b);
	if (c == 0) {
		p = ATOMnilptr(b->ttype);
	} else if (c == 1) {
		BATiter bi = bat_iterator(b);
		p = BUNtail(bi,BUNfirst(b));
	} else {
		char buf[BUFSIZ];

		p = NULL;
		snprintf(buf, BUFSIZ, "cardinality violation (" BUNFMT ">1)", c);
		throw(SQL, "zero_or_one", "%s", buf);
	}
	_s = ATOMsize(ATOMtype(b->ttype));
	if (ATOMextern(b->ttype)) {
		_s = ATOMlen(ATOMtype(b->ttype), p);
		memcpy(*(ptr*) ret=GDKmalloc(_s), p, _s);
	} else if (b->ttype == TYPE_bat) {
		bat bid = *(bat*)p;
		*(BAT**) ret = BATdescriptor(bid);
	} else if (_s == 4) {
		*(int*) ret = *(int*)p;
	} else if (_s == 1) {
		*(bte*) ret = *(bte*)p;
	} else if (_s == 2) {
		*(sht*) ret = *(sht*)p;
	} else if (_s == 8) {
		*(lng*) ret = *(lng*)p;
	} else {
		memcpy(ret, p, _s);
	}
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}

str not_unique(bit *ret, int* bid) 
{
	BAT *b;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(SQL, "not_unique", "Cannot access descriptor");
	}

	*ret = FALSE;
	if (BATtkey(b) || BATtdense(b) || BATcount(b) <= 1) {
		BBPunfix(b->batCacheid);
		return MAL_SUCCEED;
	} else if (b->tsorted&1) {
		BUN p,q;
		oid c = *(oid*)Tloc(b, BUNfirst(b)); 

		for(p=BUNfirst(b)+1, q=BUNlast(b);p<q;p++) {
			oid v = *(oid*)Tloc(b,p);
			if (v<=c) {
				*ret = TRUE;
				break;
			}
			c = v;
		}
	} else {
		BBPunfix(b->batCacheid);
		throw(SQL, "not_unique", "input should be sorted");
	}
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

/* later we could optimize this to start from current BUN 
   And only search the from the first if second is not found.
 */
static inline int 
HASHfndTwice(BAT *b, ptr v)
{
	BATiter bi = bat_iterator(b);
	BUN i = BUN_NONE;
	int first = 1;
	
	HASHloop( bi, b->H->hash, i, v) {
		if (!first)
			return 1;
		first = 0;
	}
	return 0;
}

str 
not_unique_oids(bat *ret, bat* bid) 
{
	BAT *b, *bn = NULL;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(SQL, "not_uniques", "Cannot access descriptor");
	}
	if (b->ttype != TYPE_oid && b->ttype != TYPE_wrd) {
		throw(SQL, "not_uniques", "Wrong types");
	}

	assert(b->htype == TYPE_oid);
	if (BATtkey(b) || BATtdense(b) || BATcount(b) <= 1) {
		bn = BATnew(TYPE_oid, TYPE_oid, 0);
		if( bn == NULL) {
			BBPreleaseref(b->batCacheid);
			throw(SQL, "sql.not_uniques", MAL_MALLOC_FAIL);
		}
	} else if (b->tsorted&1) { /* ugh handle both wrd and oid types */
		oid c = *(oid*)Tloc(b, BUNfirst(b)), *rf, *rh, *rt;
		oid *h = (oid*)Hloc(b,0), *vp, *ve;
		int first = 1;

		bn = BATnew(TYPE_oid, TYPE_oid, BATcount(b));
		if( bn == NULL){
			BBPreleaseref(b->batCacheid);
			throw(SQL, "sql.not_uniques", MAL_MALLOC_FAIL);
		}
		vp = (oid*)Tloc(b, BUNfirst(b));
		ve = vp + BATcount(b);
		rf = rh = (oid*)Hloc(bn, BUNfirst(bn));
		rt = (oid*)Tloc(bn, BUNfirst(bn));
		*rh++ = *h++; 
		*rt++ = *vp; 
		for(vp++; vp < ve; vp++, h++) {
			oid v = *vp;
			if (v == c) {
				first = 0;
				*rh++ = *h;
				*rt++ = v;
			} else if (!first) {
				first = 1;
				*rh++ = *h;
				*rt++ = v;
			} else {
				*rh = *h;
				*rt = v;
			}
			c = v;
		}
		if (first)
			rh--;
		BATsetcount(bn, (BUN)(rh - rf)); 
	} else {
		oid *rf, *rh, *rt;
		oid *h = (oid*)Hloc(b,0), *vp, *ve;
		BAT *bm = BATmirror(b);

		if (BATprepareHash(bm))
			throw(SQL, "not_uniques", "hash creation failed");
		bn = BATnew(TYPE_oid, TYPE_oid, BATcount(b));
		if( bn == NULL){
			BBPreleaseref(b->batCacheid);
			throw(SQL, "sql.unique_oids", MAL_MALLOC_FAIL);
		}
		vp = (oid*)Tloc(b, BUNfirst(b));
		ve = vp + BATcount(b);
		rf = rh = (oid*)Hloc(bn, BUNfirst(bn));
		rt = (oid*)Tloc(bn, BUNfirst(bn));
		for(; vp < ve; vp++, h++) {
			/* try to find value twice */
			if (HASHfndTwice(bm, vp)) {
				*rh++ = *h;
				*rt++ = *vp;
			}
		}
		BATsetcount(bn, (BUN)(rh - rf)); 
	}
	BBPunfix(b->batCacheid);
	BBPkeepref(*ret = bn->batCacheid);
	return MAL_SUCCEED;
}

lng scales[20] = {
	LL_CONSTANT(1),
	LL_CONSTANT(10),
	LL_CONSTANT(100),
	LL_CONSTANT(1000),
	LL_CONSTANT(10000),
	LL_CONSTANT(100000),
	LL_CONSTANT(1000000),
	LL_CONSTANT(10000000),
	LL_CONSTANT(100000000),
	LL_CONSTANT(1000000000),
	LL_CONSTANT(10000000000),
	LL_CONSTANT(100000000000),
	LL_CONSTANT(1000000000000),
	LL_CONSTANT(10000000000000),
	LL_CONSTANT(100000000000000),
	LL_CONSTANT(1000000000000000),
	LL_CONSTANT(10000000000000000),
	LL_CONSTANT(100000000000000000),
	LL_CONSTANT(1000000000000000000)
};

/*
 * @-
 * The core modules of Monet provide just a limited set of
 * mathematical operators. The extensions required to support
 * SQL-99 are shown below. At some point they also should be
 * moved to module code base.
 */
@= round
str 
@1_dec_round_wrap( @1 *res, @1 *v, @1 *r )
{
	@1 val = *v;
	@1 add = *r;

	/* shortcut nil */
	if (*v == @1_nil) {
		*res = @1_nil;
		return NULL;
	}

	add >>=1;
	if (val < 0) 
		add = -add;
	val += add; 
	val /= *r;
	*res = val;
	return NULL;
}

str 
@1_round_wrap( @1 *res, @1 *v, int *d, int *s, bte *r )
{
	/* shortcut nil */
	if (*v == @1_nil) {
		*res = @1_nil;
	} else if (-*r > *d) {
		*res = 0;
	} else if (*r > 0 && *r < *s) {
		int dff = *s - *r;
		lng rnd = scales[dff]>>1;
		lng lres;
		if (*v > 0)
			lres = (((*v + rnd)/scales[dff])*scales[dff]);
		else
			lres = (((*v - rnd)/scales[dff])*scales[dff]);
		assert((lng) GDK_@1_min < lres && lres <= (lng) GDK_@1_max);
		*res = (@1) lres;
	} else if (*r <= 0 && -*r + *s > 0) {
		int dff = -*r + *s;
		lng rnd = scales[dff]>>1;
		lng lres;
		if (*v > 0)
			lres = (((*v + rnd)/scales[dff])*scales[dff]);
		else
			lres = (((*v - rnd)/scales[dff])*scales[dff]);
		assert((lng) GDK_@1_min < lres && lres <= (lng) GDK_@1_max);
		*res = (@1) lres;
	} else {
		*res = *v;
	}
	return MAL_SUCCEED;
}

str
str_2dec_@1( @1 *res, str *val, int *d, int *sc )
{
	char *s = strip_extra_zeros(*val);
	char *dot = strchr(s, '.');
	int digits = _strlen(s) - 1;
	int scale = digits - (int) (dot-s);
	lng value = 0;

	if (!dot) {
		if (GDK_STRNIL(*val)) {
			*res = @1_nil;
			return MAL_SUCCEED;
		} else {
			throw(SQL, "@1", 
				"\"%s\" is no decimal value (doesn't contain a '.')", *val);
		}
	}
		
	value = decimal_from_str(s);
	if (*s == '+' || *s == '-')
		digits --;
	if (scale < *sc){
		/* the current scale is too small, increase it by adding 0's */
		int d = *sc - scale;	/* CANNOT be 0! */

		value *= scales[d];
		scale += d;
		digits += d;
	} else if (scale > *sc){
		/* the current scale is too big, decrease it by correctly rounding */
		int d = scale - *sc;	/* CANNOT be 0 */
		lng rnd = scales[d]>>1;

		value += rnd;
		value /= scales[d];
		scale -= d;
		digits -= d;
	}
	if (digits > *d) {
		throw(SQL,"@1", 
		     "decimal (%s) doesn't have format (%d.%d)", *val, *d, *sc);
	}
	*res = (@1) value;
	return MAL_SUCCEED;
}

str
str_2num_@1( @1 *res, str *v, int *len )
{
	int zero = 0;
	return str_2dec_@1( res, v, len, &zero );
}

str
batstr_2dec_@1( int *res, int *bid, int *d, int *sc )
{
	BAT *b, *dst;
	BATiter bi;
	BUN p,q;
	char *msg = NULL;

	if( (b = BATdescriptor(*bid)) == NULL ){
		throw(SQL, "batcalc.str_2dec_@1", "Cannot access descriptor");
	}
	bi = bat_iterator(b);
	dst = BATnew(b->htype, TYPE_@1, BATcount(b));
	if( dst == NULL){
		BBPreleaseref(b->batCacheid);
		throw(SQL, "sql.dec_@1", MAL_MALLOC_FAIL);
	}
	BATseqbase(dst, b->hseqbase);
	BATaccessBegin(b, USE_HEAD|USE_TAIL, MMAP_SEQUENTIAL);
	BATloop(b,p,q) {
		str v = (str)BUNtail(bi,p);
		@1 r;
		msg = str_2dec_@1( &r, &v, d, sc );
		if (msg)
			break;
		BUNins(dst, BUNhead(bi,p), &r, FALSE);
	}
	BATaccessEnd(b, USE_HEAD|USE_TAIL, MMAP_SEQUENTIAL);
	BBPkeepref( *res = dst->batCacheid);
	BBPunfix(b->batCacheid);
	return msg;
}

str
batstr_2num_@1( int *res, int *bid, int *len )
{
	BAT *b, *dst;
	BATiter bi;
	BUN p,q;
	char *msg = NULL;

	if( (b = BATdescriptor(*bid)) == NULL ){
		throw(SQL, "batcalc.str_2num_@1", "Cannot access descriptor");
	}
	bi = bat_iterator(b);
	dst = BATnew(b->htype, TYPE_@1, BATcount(b));
	if( dst == NULL){
		BBPreleaseref(b->batCacheid);
		throw(SQL, "sql.num_@1", MAL_MALLOC_FAIL);
	}
	BATseqbase(dst, b->hseqbase);
	BATaccessBegin(b, USE_HEAD|USE_TAIL, MMAP_SEQUENTIAL);
	BATloop(b,p,q) {
		str v = (str)BUNtail(bi,p);
		@1 r;
		msg = str_2num_@1( &r, &v, len );
		if (msg)
			break;
		BUNins(dst, BUNhead(bi,p), &r, FALSE);
	}
	BATaccessEnd(b, USE_HEAD|USE_TAIL, MMAP_SEQUENTIAL);
	BBPkeepref( *res = dst->batCacheid);
	BBPunfix(b->batCacheid);
	return msg;
}
@
@c

@:round(bte)@
@:round(sht)@
@:round(int)@
@:round(wrd)@
@:round(lng)@

@= fround
str 
@1_dec_round_wrap( @1 *res, @1 *v, @1 *r )
{
	@1 val = *v;

	/* not nil */
	if (ATOMcmp(TYPE_@1, v, ATOMnilptr(TYPE_@1)) != 0) {
		val /= *r;
	}
	*res = val;
	return MAL_SUCCEED;
}

str 
@1_round_wrap( @1 *res, @1 *v, bte *r )
{
	/* shortcut nil */
	if (*v == @1_nil) {
		*res = @1_nil;
	} else if (*r < 0) {
		int d = -*r;
		@1 rnd = (@1) (scales[d]>>1); 

		if (*v > 0)
			*res = (@1) (floor(((*v + rnd)/((@1)(scales[d]))))*scales[d]);
		else
			*res = (@1) (floor(((*v + rnd)/((@1)(scales[d]))))*scales[d]);
	} else if (*r > 0) {
		int d = *r;

		if (*v > 0)
			*res = (@1) (floor(*v*(@1)scales[d]+.5)/scales[d]);
		else
			*res = (@1) (floor(*v*(@1)scales[d]+.5)/scales[d]);
	} else {
		*res = (@1) round(*v); 
	}
	return MAL_SUCCEED;
}
str
@1_trunc_wrap( @1 *res, @1 *v, int *r )
{
	/* shortcut nil */
	if (*v == @1_nil) {
		*res = @1_nil;
	} else if (*r < 0) {
		int d = -*r;
		*res = (@1) (trunc((*v)/((@1)scales[d])) * scales[d]); 
	} else if (*r > 0) {
		int d = *r;
		*res = (@1) (trunc(*v * (@1)scales[d]) / ((@1)scales[d]));
	} else {
		*res = (@1) trunc(*v);
	}
	return MAL_SUCCEED;
}

@
@c
@:fround(flt)@
@:fround(dbl)@

str
SQLdbl_alpha(dbl *res, dbl *decl, dbl *theta)
{
	dbl s, c1, c2;
    char *msg = MAL_SUCCEED;
    if (*decl == dbl_nil || *theta == dbl_nil) {
        *res = dbl_nil;
    } else if ( fabs(*decl) + *theta > 89.9 ) {
        *res = (dbl) 180.0;
    } else {
		s = sin(radians(*theta));
		c1 = cos(radians(*decl - *theta));
		c2 = cos(radians(*decl + *theta));
	    *res = degrees(fabs(atan(s / sqrt(fabs(c1 * c2)))));
		/*		mnstr_printf(GDKout,"%f\n", *res); */
	}
    return msg;
}
str
SQLbat_alpha(bat *res, bat *decl, dbl *theta)
{
    BAT *b, *bn;
    BATiter bi;
    BUN p,q;
	dbl s, c1, c2, r;
    char *msg = NULL;

	if ( *theta == dbl_nil ){
        throw(SQL, "SQLbat_alpha", "Parameter theta should not be nil");
    }
    if( (b = BATdescriptor(*decl)) == NULL ){
        throw(SQL, "alpha", "Cannot access descriptor");
    }
    bi = bat_iterator(b);
    bn = BATnew(b->htype, TYPE_dbl, BATcount(b));
    if( bn == NULL){
        BBPreleaseref(b->batCacheid);
        throw(SQL, "sql.alpha", MAL_MALLOC_FAIL);
    }
    BATseqbase(bn, b->hseqbase);
    BATaccessBegin(b, USE_HEAD|USE_TAIL, MMAP_SEQUENTIAL);
	s = sin(radians(*theta));
    BATloop(b,p,q) {
        dbl d = *(dbl*)BUNtail(bi,p);
	    if (d == dbl_nil)
			r = dbl_nil;
	    else if ( fabs(d) + *theta > 89.9 )
			r = (dbl) 180.0;
		else {
			c1 = cos(radians(d - *theta));
			c2 = cos(radians(d + *theta));
		    r = degrees(fabs(atan(s / sqrt(fabs(c1 * c2)))));
        }
        BUNins(bn, BUNhead(bi,p), &r, FALSE);
    }
    BATaccessEnd(b, USE_HEAD|USE_TAIL, MMAP_SEQUENTIAL);
    BBPkeepref( *res = bn->batCacheid);
    BBPunfix(b->batCacheid);
    return msg;
}

#if SIZEOF_WRD == SIZEOF_INT
#define wrdToStr(sptr, lptr, p) intToStr(sptr, lptr, (int*)p)
#else
#define wrdToStr(sptr, lptr, p) lngToStr(sptr, lptr, (lng*)p)
#endif

@= cast
str
str_2_@1( @3 *res, str *val )
{
	ptr p = NULL;
	int len = 0;
	int e; 
	char buf[BUFSIZ];
	
	e = ATOMfromstr(TYPE_@1, &p, &len, *val);
	if (e < 0 || !p || 
	   (ATOMcmp(TYPE_@1, p, ATOMnilptr(TYPE_@1)) == 0 &&
	    ATOMcmp(TYPE_str, *val, ATOMnilptr(TYPE_str)) != 0))
	{
		if (p)
			GDKfree(p);
		snprintf(buf, BUFSIZ,"conversion of string '%s' failed",*val);
		throw(SQL, "@1", "%s", buf);
	}
	@4;
	if (!ATOMextern(TYPE_@1)) {
		if (p)
			GDKfree(p);
	}
	return MAL_SUCCEED;
}

str
SQL@1_2_str( str *res, @1 *val )
{
	char *p = NULL;
	int len = 0;
	@2( &p, &len, val);
	*res = p;
	return MAL_SUCCEED;
}

str
batstr_2_@1( int *res, int *bid )
{
	BAT *b, *dst;
	BATiter bi;
	BUN p,q;
	char *msg = NULL;

	if( (b = BATdescriptor(*bid)) == NULL ){
		throw(SQL, "batcalc.str_2_@1", "Cannot access descriptor");
	}
	bi = bat_iterator(b);
	dst = BATnew(b->htype, TYPE_@1, BATcount(b));
	if( dst == NULL){
		BBPreleaseref(b->batCacheid);
		throw(SQL, "sql.2_@1", MAL_MALLOC_FAIL);
	}
	BATseqbase(dst, b->hseqbase);
	BATaccessBegin(b, USE_HEAD|USE_TAIL, MMAP_SEQUENTIAL);
	BATloop(b,p,q) {
		str v = (str)BUNtail(bi,p);
		@3 r;
		msg = str_2_@1( &r, &v );
		if (msg)
			break;
		BUNins(dst, BUNhead(bi,p), @5 r, FALSE);
	}
	BATaccessEnd(b, USE_HEAD|USE_TAIL, MMAP_SEQUENTIAL);
	BBPkeepref( *res = dst->batCacheid);
	BBPunfix(b->batCacheid);
	return msg;
}
@
@c
@:cast(bit,bitToStr,bit, *res = *(bit*)p,&)@
@:cast(oid,OIDtoStr,oid, *res = *(oid*)p,&)@
@:cast(bte,bteToStr,bte, *res = *(bte*)p,&)@
@:cast(sht,shtToStr,sht, *res = *(sht*)p,&)@
@:cast(int,intToStr,int, *res = *(int*)p,&)@
@:cast(lng,lngToStr,lng, *res = *(lng*)p,&)@
@:cast(wrd,wrdToStr,wrd, *res = *(wrd*)p,&)@
@:cast(flt,fltToStr,flt, *res = *(flt*)p,&)@
@:cast(dbl,dblToStr,dbl, *res = *(dbl*)p,&)@
@:cast(timestamp,timestamp_tostr,timestamp, *res = *(timestamp*)p,&)@
@:cast(daytime,daytime_tostr,daytime, *res = *(daytime*)p,&)@
@:cast(date,date_tostr,date, *res = *(date*)p,&)@
@:cast(sqlblob,sqlblob_tostr,sqlblob*, *res = (sqlblob*)p,)@

static str
SQLstr_cast_(str *res, mvc *m, int eclass, int d, int s, int has_tz, ptr p, int tpe, int len)
{
	char *r = NULL;
	int sz = MAX(2,len + 1);	/* nil should fit */

	if (tpe != TYPE_str) {
		r = GDKmalloc(sz);
		sz = convert2str(m, eclass, d, s, has_tz, p, tpe, &r, sz);
	} else {
		str v = (str)p; 
		strLength(&sz, v);
		if (len == 0 || (sz >= 0 && sz <= len)) 
			r = GDKstrdup(v);
	}
	if ((len > 0 && sz > len) || sz < 0) {
		if (r) 
			GDKfree(r);
		if (ATOMcmp(TYPE_str, ATOMnilptr(TYPE_str), p) != 0) {
			throw(SQL, "str_cast", "value too long for type (var)char(%d)", len);
		} else {
			r = GDKstrdup(str_nil);
		}
	}
	*res = r;
	return MAL_SUCCEED;
}

str
SQLstr_cast(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str *res  = (str *) getArgReference(stk, pci, 0);
	int eclass = *(int*) getArgReference(stk, pci, 1);
	int d = *(int*) getArgReference(stk, pci, 2);
	int s = *(int*) getArgReference(stk, pci, 3);
	int has_tz = *(int*) getArgReference(stk, pci, 4);
	ptr p   = (ptr) getArgReference(stk, pci, 5);
	int tpe = getArgType(mb, pci, 5);
	int len   = *(int *) getArgReference(stk, pci, 6);
	mvc *m = NULL;
	str msg = getContext(cntxt,mb, &m, NULL);

	(void) cntxt;
	if (msg)
		return msg;
	if (ATOMextern(tpe)) 
		p = *(ptr*)p;
	return SQLstr_cast_(res, m, eclass, d, s, has_tz, p, tpe, len );
}

/* str SQLbatstr_cast(int *res, int *eclass, int *d1, int *s1, int *has_tz, int *bid, int *digits ); */
str 
SQLbatstr_cast(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	BAT *b, *dst;
	BATiter bi;
	BUN p,q;
	mvc *m = NULL;
	str msg = getContext(cntxt,mb, &m, NULL);
	char *r = NULL;
	int *res  = (int *) getArgReference(stk, pci, 0);
	int *eclass = (int*) getArgReference(stk, pci, 1);
	int *d1 = (int*) getArgReference(stk, pci, 2);
	int *s1 = (int*) getArgReference(stk, pci, 3);
	int *has_tz = (int*) getArgReference(stk, pci, 4);
	int *bid   = (int*) getArgReference(stk, pci, 5);
	int *digits   = (int *) getArgReference(stk, pci, 6);

	(void) cntxt;
	if (msg)
		return msg;
	if( (b = BATdescriptor(*bid)) == NULL ){
		throw(SQL, "batcalc.str_2dec_@1", "Cannot access descriptor");
	}
	bi = bat_iterator(b);
	dst = BATnew(b->htype, TYPE_str, BATcount(b));
	if( dst == NULL){
		BBPreleaseref(b->batCacheid);
		throw(SQL, "sql.str_cast", MAL_MALLOC_FAIL);
	}
	BATseqbase(dst, b->hseqbase);
	BATaccessBegin(b, USE_HEAD|USE_TAIL, MMAP_SEQUENTIAL);
	BATloop(b,p,q) {
		ptr v = (ptr)BUNtail(bi,p);
		msg = SQLstr_cast_( &r, m, *eclass, *d1, *s1, *has_tz, v, b->ttype, *digits);
		if (msg)
			break;
		BUNins(dst, BUNhead(bi,p), r, FALSE);
		GDKfree(r);
	}
	BATaccessEnd(b, USE_HEAD|USE_TAIL, MMAP_SEQUENTIAL);
	BBPkeepref( *res = dst->batCacheid);
	BBPunfix(b->batCacheid);
	return msg;
}

@= simpleupcast
str 
@2_2_@1( @1 *res, @2 *v )
{
	/* shortcut nil */
	if (*v == @2_nil) {
		*res = @1_nil;
		return(MAL_SUCCEED);
	}
	
	/* since the @1 type is bigger than or equal to the @2 type, it will
	   always fit */
	*res = (@1)*v;
	return(MAL_SUCCEED);
}

str bat@2_2_@1( int *res, int *bid )
{
	BAT *b, *bn;
	@2 *p,*q;
	@1 *o;

	if( (b = BATdescriptor(*bid)) == NULL ){
		throw(SQL, "batcalc.@2_2_@1", "Cannot access descriptor");
	}
	bn = BATnew(TYPE_void, TYPE_@1, BATcount(b));
	if( bn == NULL){
		BBPreleaseref(b->batCacheid);
		throw(SQL, "sql.@2_2_@1", MAL_MALLOC_FAIL);
	}
	bn->hsorted = b->hsorted;
	BATseqbase(bn, b->hseqbase);
	o = (@1*) Tloc(bn,BUNfirst(bn));
	p = (@2*) Tloc(b, BUNfirst(b));
	q = (@2*) Tloc(b, BUNlast(b));
	bn->T->nonil = 1;
	BATaccessBegin(b, USE_TAIL, MMAP_SEQUENTIAL);
	if ( b->T->nonil){
		for (; p<q; p++, o++)
			*o = (@1)*p;
	} else{
		for (; p<q; p++, o++)
		if (*p == @2_nil) {
			*o = @1_nil;
			bn->T->nonil= FALSE;
		} else
			*o = (@1)*p;
	}
	BATaccessEnd(b, USE_TAIL, MMAP_SEQUENTIAL);
	BATsetcount(bn, BATcount(b));
	bn->tsorted = 0;
	BATkey(BATmirror(bn),FALSE);

	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);

	if (b->htype != bn->htype) {
		BAT *r = VIEWcreate(b,bn);

		BBPkeepref(*res = r->batCacheid);
		BBPreleaseref(bn->batCacheid);
		BBPreleaseref(b->batCacheid);
		return MAL_SUCCEED;
	}
	BBPkeepref(*res = bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}
@
@c

@= simpledowncast
str @2_2_@1( @1 *res, @2 *v )
{
	@3 val = *v;

	/* shortcut nil */
	if (*v == @2_nil) {
		*res = @1_nil;
		return(MAL_SUCCEED);
	}
	
	/* see if the number fits in the data type */
	if ((@3)(@1)val > (@3) GDK_@1_min && 
	    val > (@3) GDK_@1_min && val <= (@3) GDK_@1_max)	{
		*res = (@1)val;
		return(MAL_SUCCEED);
	} else {
		throw(SQL, "convert",
			"value (" @4 ") exceeds limits of type @1", val);
	}
}

str bat@2_2_@1( int *res, int *bid )
{
	BAT *b, *bn;
	@2 *p,*q;
	char *msg = NULL;
	@1 *o;
	@3 val;

	if( (b = BATdescriptor(*bid)) == NULL ){
		throw(SQL, "batcalc.@2_2_@1", "Cannot access descriptor");
	}
	bn = BATnew(TYPE_void, TYPE_@1, BATcount(b));
	if( bn == NULL){
		BBPreleaseref(b->batCacheid);
		throw(SQL, "sql.@2_2_@1", MAL_MALLOC_FAIL);
	}
	BATseqbase(bn, b->hseqbase);
	bn->H->nonil = 1;
	bn->T->nonil = 1;
	o = (@1*) Tloc(bn,BUNfirst(bn));
	p = (@2*) Tloc(b, BUNfirst(b));
	q = (@2*) Tloc(b, BUNlast(b));
	BATaccessBegin(b, USE_TAIL, MMAP_SEQUENTIAL);
	if ( b->T->nonil){
		for (; p<q; p++, o++){
			val = *p;
			/* see if the number fits in the data type */
			if ((@3)(@1)val > (@3) GDK_@1_min && val > (@3) GDK_@1_min && val <= (@3) GDK_@1_max)	{
				*o = (@1)val;
			} else {
				msg= createException(SQL, "convert", "value (" @4 ") exceeds limits of type @1", val);
				break;
			}
		}
	} else {
		for (; p<q; p++, o++) {
			if (*p == @2_nil) {
				*o = @1_nil;
				bn->T->nonil= FALSE;
			} else {
				val = *p;
				/* see if the number fits in the data type */
				if ((@3)(@1)val > (@3) GDK_@1_min && val > (@3) GDK_@1_min && val <= (@3) GDK_@1_max)	{
					*o = (@1)val;
				} else {
					msg= createException(SQL, "convert", "value (" @4 ") exceeds limits of type @1", val);
					break;
				}
			}
		}
	}
	BATaccessEnd(b, USE_TAIL, MMAP_SEQUENTIAL);
	BATsetcount(bn, BATcount(b));
	bn->tsorted = 0;
	BATkey(BATmirror(bn),FALSE);

	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);

	if (b->htype != bn->htype) {
		BAT *r = VIEWcreate(b,bn);

		BBPkeepref(*res = r->batCacheid);
		BBPreleaseref(bn->batCacheid);
		BBPreleaseref(b->batCacheid);
		return msg;
	}
	BBPkeepref(*res = bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	return msg;
}
@
 * @-
 * The simple cast up operations in some cases
 * could re-use the storage space as well.
@= numcastup
@:simpleupcast(@1,@2)@

str @2_dec2_@1( @1 *res, int *s1, @2 *v )
{
	int scale = *s1;
	@1 r, h = (*v<0)?-5:5; 

	/* shortcut nil */
	if (*v == @2_nil) {
		*res = @1_nil;
		return(MAL_SUCCEED);
	}

	/* since the @1 type is bigger than or equal to the @2 type, it will
	   always fit */
	r = (@1)*v;
	if (scale) 
		r = (@1) ((r + h) / scales[scale]);
	*res = r;
	return(MAL_SUCCEED);
}

str 
@2_dec2dec_@1( @1 *res, int *S1, @2 *v, int *d2, int *S2 )
{
	int p = *d2, inlen = 1;
	@2 cpyval = *v;
	int s1 = *S1, s2 = *S2;
	@1 r, h = (*v<0)?-5:5; 

	/* shortcut nil */
	if (*v == @2_nil) {
		*res = @1_nil;
		return(MAL_SUCCEED);
	}
	
	/* count the number of digits in the input */
	while (cpyval /= 10)
		inlen++;

	/* rounding is allowed */
	inlen += (s2-s1);
	if (p && inlen > p) {
		throw(SQL, "convert",
			"too many digits (%d > %d)", inlen, p);
	}

	/* since the @1 type is bigger than or equal to the @2 type, it will
	   always fit */
	r = (@1)*v;
	if (s2 > s1) 
		r *= (@1) scales[s2 - s1];
	else if (s2 != s1) 
		r = (@1) ((r + h) / scales[s1 - s2]);
	*res = r;
	return(MAL_SUCCEED);
}

str 
@2_num2dec_@1( @1 *res, @2 *v, int *d2, int *s2 )
{
	int zero = 0;
	return @2_dec2dec_@1( res, &zero, v, d2, s2 );
}

str bat@2_dec2_@1( int *res, int *s1, int *bid )
{
	BAT *b, *bn;
	@2 *p,*q;
	char *msg = NULL;
	int scale = *s1;
	@1 *o;

	if( (b = BATdescriptor(*bid)) == NULL ){
		throw(SQL, "batcalc.@2_dec2_@1", "Cannot access descriptor");
	}
	bn = BATnew(TYPE_void, TYPE_@1, BATcount(b));
	if( bn == NULL){
		BBPreleaseref(b->batCacheid);
		throw(SQL, "sql.dec2_@1", MAL_MALLOC_FAIL);
	}
	bn->hsorted = b->hsorted;
	BATseqbase(bn, b->hseqbase);
	o = (@1*) Tloc(bn,BUNfirst(bn));
	p = (@2*) Tloc(b, BUNfirst(b));
	q = (@2*) Tloc(b, BUNlast(b));
	bn->T->nonil = 1;
	BATaccessBegin(b, USE_TAIL, MMAP_SEQUENTIAL);
	if ( b->T->nonil){
		if (scale)
			for (; p<q; p++, o++)
				*o = (@1) ((*p +  (*p<0)?-5:5) / scales[scale]);
		else
			for (; p<q; p++, o++)
				*o = (@1) (*p);
	} else {
		for (; p<q; p++, o++) {
			if (*p == @2_nil) {
				*o = @1_nil;
				bn->T->nonil= FALSE;
			} else if (scale) {
				*o = (@1) ((*p +  (*p<0)?-5:5) / scales[scale]);
			} else {
				*o = (@1) (*p);
			}
		}
	}
	BATaccessEnd(b, USE_TAIL, MMAP_SEQUENTIAL);
	BATsetcount(bn, BATcount(b));
	bn->tsorted = 0;
	BATkey(BATmirror(bn),FALSE);

	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);

	if (b->htype != bn->htype) {
		BAT *r = VIEWcreate(b,bn);

		BBPkeepref(*res = r->batCacheid);
		BBPreleaseref(bn->batCacheid);
		BBPreleaseref(b->batCacheid);
		return msg;
	}
	BBPkeepref(*res = bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	return msg;
}

str bat@2_dec2dec_@1( int *res, int *S1, int *bid, int *d2, int *S2 )
{
	BAT *b, *dst;
	BATiter bi;
	BUN p,q;
	char *msg = NULL;

	if( (b = BATdescriptor(*bid)) == NULL ){
		throw(SQL, "batcalc.@2_dec2dec_@1", "Cannot access descriptor");
	}
	bi = bat_iterator(b);
	dst = BATnew(b->htype, TYPE_@1, BATcount(b));
	if( dst == NULL){
		BBPreleaseref(b->batCacheid);
		throw(SQL, "sql.dec2dec_@1", MAL_MALLOC_FAIL);
	}
	BATseqbase(dst, b->hseqbase);
	BATaccessBegin(b, USE_TAIL, MMAP_SEQUENTIAL);
	BATloop(b,p,q) {
		@2 *v = (@2*)BUNtail(bi,p);
		@1 r;
		msg = @2_dec2dec_@1( &r, S1, v, d2, S2 );
		if (msg)
			break;
		BUNins(dst, BUNhead(bi,p), &r, FALSE);
	}
	BATaccessEnd(b, USE_TAIL, MMAP_SEQUENTIAL);
	BBPkeepref( *res = dst->batCacheid);
	BBPunfix(b->batCacheid);
	return msg;
}
str bat@2_num2dec_@1( int *res, int *bid, int *d2, int *s2 )
{
	BAT *b, *dst;
	BATiter bi;
	BUN p,q;
	char *msg = NULL;

	if( (b = BATdescriptor(*bid)) == NULL ){
		throw(SQL, "batcalc.@2_num2dec_@1", "Cannot access descriptor");
	}
	bi = bat_iterator(b);
	dst = BATnew(b->htype, TYPE_@1, BATcount(b));
	if( dst == NULL){
		BBPreleaseref(b->batCacheid);
		throw(SQL, "sql.num2dec_@1", MAL_MALLOC_FAIL);
	}
	BATseqbase(dst, b->hseqbase);
	BATaccessBegin(b, USE_TAIL, MMAP_SEQUENTIAL);
	BATloop(b,p,q) {
		@2 *v = (@2*)BUNtail(bi,p);
		@1 r;
		msg = @2_num2dec_@1( &r, v, d2, s2 );
		if (msg)
			break;
		BUNins(dst, BUNhead(bi,p), &r, FALSE);
	}
	BATaccessEnd(b, USE_TAIL, MMAP_SEQUENTIAL);
	BBPkeepref( *res = dst->batCacheid);
	BBPunfix(b->batCacheid);
	return msg;
}

@
@c
@:numcastup(bte,bte)@
@:numcastup(sht,bte)@
@:numcastup(sht,sht)@
@:numcastup(int,bte)@
@:numcastup(int,sht)@
@:numcastup(int,int)@
@:numcastup(wrd,bte)@
@:numcastup(wrd,sht)@
@:numcastup(wrd,int)@
@:numcastup(wrd,wrd)@
@:numcastup(lng,bte)@
@:numcastup(lng,sht)@
@:numcastup(lng,int)@
@:numcastup(lng,wrd)@
@:numcastup(lng,lng)@

@= fnumcastdown
@:simpledowncast(@1,@2,dbl,"%f")@

/* when casting a floating point to an decimal we like to preserve the 
 * precision.  This means we first scale the float before converting.
*/
str 
@2_num2dec_@1( @1 *res, @2 *v, int *d2, int *s2 )
{
	int p = *d2, inlen = 1, scale = *s2;
	@2 r;
	lng cpyval;

	/* shortcut nil */
	if (*v == @2_nil) {
		*res = @1_nil;
		return(MAL_SUCCEED);
	}
	
	/* since the @1 type is bigger than or equal to the @2 type, it will
	   always fit */
	r = (@2) *v;
	if (scale) 
		r *= scales[scale];
	cpyval = (lng) r;

	/* count the number of digits in the input */
	while (cpyval /= 10)
		inlen++;
	/* rounding is allowed */
	if (p && inlen > p) {
		throw(SQL, "convert",
			"too many digits (%d > %d)", inlen, p);
	}
	*res = (@1) r;
	return MAL_SUCCEED;
}
str 
bat@2_num2dec_@1( int *res, int *bid, int *d2, int *s2 )
{
	BAT *b, *dst;
	BATiter bi;
	BUN p,q;
	char *msg = NULL;

	if( (b = BATdescriptor(*bid)) == NULL ){
		throw(SQL, "batcalc.@2_num2dec_@1", "Cannot access descriptor");
	}
	bi = bat_iterator(b);
	dst = BATnew(b->htype, TYPE_@1, BATcount(b));
	if( dst == NULL){
		BBPreleaseref(b->batCacheid);
		throw(SQL, "sql.num2dec_@1", MAL_MALLOC_FAIL);
	}
	BATseqbase(dst, b->hseqbase);
	BATaccessBegin(b, USE_TAIL, MMAP_SEQUENTIAL);
	BATloop(b,p,q) {
		@2 *v = (@2*)BUNtail(bi,p);
		@1 r;
		msg = @2_num2dec_@1( &r, v, d2, s2 );
		if (msg)
			break;
		BUNins(dst, BUNhead(bi,p), &r, FALSE);
	}
	BATaccessEnd(b, USE_TAIL, MMAP_SEQUENTIAL);
	BBPkeepref( *res = dst->batCacheid);
	BBPunfix(b->batCacheid);
	return msg;
}

@
@c
@:fnumcastdown(bte,flt)@
@:fnumcastdown(sht,flt)@
@:fnumcastdown(int,flt)@
@:fnumcastdown(wrd,flt)@
@:fnumcastdown(lng,flt)@
@:fnumcastdown(bte,dbl)@
@:fnumcastdown(sht,dbl)@
@:fnumcastdown(int,dbl)@
@:fnumcastdown(wrd,dbl)@
@:fnumcastdown(lng,dbl)@

@= fnumcastup
@:simpleupcast(@1,@2)@

str 
@2_dec2_@1( @1 *res, int *s1, @2 *v )
{
	int scale = *s1;
	@1 r;

	/* shortcut nil */
	if (*v == @2_nil) {
		*res = @1_nil;
		return(MAL_SUCCEED);
	}
	
	/* since the @1 type is bigger than or equal to the @2 type, it will
	   always fit */
	r = (@1)*v;
	if (scale) 
		r /= scales[scale];
	*res = r;
	return MAL_SUCCEED;
}

str 
@2_dec2dec_@1( @1 *res, int *S1, @2 *v, int *d2, int *S2 )
{
	int p = *d2, inlen = 1;
	@2 cpyval = *v;
	int s1 = *S1, s2 = *S2;
	@1 r;

	/* shortcut nil */
	if (*v == @2_nil) {
		*res = @1_nil;
		return(MAL_SUCCEED);
	}
	
	/* count the number of digits in the input */
	while (cpyval /= 10)
		inlen++;
	/* rounding is allowed */
	inlen += (s2-s1);
	if (p && inlen > p) {
		throw(SQL, "convert",
			"too many digits (%d > %d)", inlen, p);
	}

	/* since the @1 type is bigger than or equal to the @2 type, it will
	   always fit */
	r = (@1)*v;
	if(s2 > s1) 
		r *= scales[s2-s1];
	else if (s2 != s1) 
		r /= scales[s1-s2];
	*res = r;
	return MAL_SUCCEED;
}

str 
@2_num2dec_@1( @1 *res, @2 *v, int *d2, int *s2 )
{
	int zero = 0;
	return @2_dec2dec_@1( res, &zero, v, d2, s2 );
}

str bat@2_dec2_@1( int *res, int *s1, int *bid )
{
	BAT *b, *bn;
	@2 *p,*q;
	char *msg = NULL;
	int scale = *s1;
	@1 *o;

	if( (b = BATdescriptor(*bid)) == NULL ){
		throw(SQL, "batcalc.@2_dec2_@1", "Cannot access descriptor");
	}
	bn = BATnew(TYPE_void, TYPE_@1, BATcount(b));
	if( bn == NULL){
		BBPreleaseref(b->batCacheid);
		throw(SQL, "sql.dec2_@1", MAL_MALLOC_FAIL);
	}
	bn->hsorted = b->hsorted;
	BATseqbase(bn, b->hseqbase);
	o = (@1*) Tloc(bn,BUNfirst(bn));
	p = (@2*) Tloc(b, BUNfirst(b));
	q = (@2*) Tloc(b, BUNlast(b));
	bn->T->nonil = 1;
	BATaccessBegin(b, USE_TAIL, MMAP_SEQUENTIAL);
	if ( b->T->nonil){
		for (; p<q; p++, o++) 
			*o = (((@1)*p)/scales[scale]);
	} else {
		for (; p<q; p++, o++) {
			if (*p == @2_nil) {
				*o = @1_nil;
				bn->T->nonil= FALSE;
			} else 
				*o = (((@1)*p)/scales[scale]);
		}
	}
	BATaccessEnd(b, USE_TAIL, MMAP_SEQUENTIAL);
	BATsetcount(bn, BATcount(b));
	bn->tsorted = 0;
	BATkey(BATmirror(bn),FALSE);

	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);

	if (b->htype != bn->htype) {
		BAT *r = VIEWcreate(b,bn);

		BBPkeepref(*res = r->batCacheid);
		BBPreleaseref(bn->batCacheid);
		BBPreleaseref(b->batCacheid);
		return msg;
	}
	BBPkeepref(*res = bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	return msg;
}

str bat@2_dec2dec_@1( int *res, int *S1, int *bid, int *d2, int *S2 )
{
	BAT *b, *dst;
	BATiter bi;
	BUN p,q;
	char *msg = NULL;

	if( (b = BATdescriptor(*bid)) == NULL ){
		throw(SQL, "batcalc.@2_dec2dec_@1", "Cannot access descriptor");
	}
	bi = bat_iterator(b);
	dst = BATnew(b->htype, TYPE_@1, BATcount(b));
	if( dst == NULL){
		BBPreleaseref(b->batCacheid);
		throw(SQL, "sql.dec2dec_@1", MAL_MALLOC_FAIL);
	}
	BATseqbase(dst, b->hseqbase);
	BATaccessBegin(b, USE_TAIL, MMAP_SEQUENTIAL);
	BATloop(b,p,q) {
		@2 *v = (@2*)BUNtail(bi,p);
		@1 r;
		msg = @2_dec2dec_@1( &r, S1, v, d2, S2 );
		if (msg)
			break;
		BUNins(dst, BUNhead(bi,p), &r, FALSE);
	}
	BATaccessEnd(b, USE_TAIL, MMAP_SEQUENTIAL);
	BBPkeepref( *res = dst->batCacheid);
	BBPunfix(b->batCacheid);
	return msg;
}

str bat@2_num2dec_@1( int *res, int *bid, int *d2, int *s2 )
{
	BAT *b, *dst;
	BATiter bi;
	BUN p,q;
	char *msg = NULL;

	if( (b = BATdescriptor(*bid)) == NULL ){
		throw(SQL, "batcalc.@2_num2dec_@1", "Cannot access descriptor");
	}
	bi = bat_iterator(b);
	dst = BATnew(b->htype, TYPE_@1, BATcount(b));
	if( dst == NULL){
		BBPreleaseref(b->batCacheid);
		throw(SQL, "sql.num2dec_@1", MAL_MALLOC_FAIL);
	}
	BATseqbase(dst, b->hseqbase);
	BATaccessBegin(b, USE_TAIL, MMAP_SEQUENTIAL);
	BATloop(b,p,q) {
		@2 *v = (@2*)BUNtail(bi,p);
		@1 r;
		msg = @2_num2dec_@1( &r, v, d2, s2 );
		if (msg)
			break;
		BUNins(dst, BUNhead(bi,p), &r, FALSE);
	}
	BATaccessEnd(b, USE_TAIL, MMAP_SEQUENTIAL);
	BBPkeepref( *res = dst->batCacheid);
	BBPunfix(b->batCacheid);
	return msg;
}


@
@c
@:fnumcastup(flt,bte)@
@:fnumcastup(flt,sht)@
@:fnumcastup(flt,int)@
@:fnumcastup(flt,wrd)@
@:fnumcastup(flt,lng)@
@:fnumcastup(dbl,bte)@
@:fnumcastup(dbl,sht)@
@:fnumcastup(dbl,int)@
@:fnumcastup(dbl,wrd)@
@:fnumcastup(dbl,lng)@

@= numcastdown
@:simpledowncast(@1,@2,lng,LLFMT)@

str 
@2_dec2_@1( @1 *res, int *s1, @2 *v )
{
	int scale = *s1;
	lng val = *v, h = (val<0)?-5:5;

	/* shortcut nil */
	if (*v == @2_nil) {
		*res = @1_nil;
		return(MAL_SUCCEED);
	}
	
	if (scale) 
		val = (val+h)/scales[scale];
	/* see if the number fits in the data type */
	if (val > GDK_@1_min && val <= GDK_@1_max)	{
		*res = (@1)val;
		return MAL_SUCCEED;
	} else {
		throw(SQL, "convert",
			"value (" LLFMT ") exceeds limits of type @1", val);
	}
}

str 
@2_dec2dec_@1( @1 *res, int *S1, @2 *v, int *d2, int *S2 )
{
	int p = *d2, inlen = 1;
	lng val = *v, cpyval = val, h = (val<0)?-5:5;
	int s1 = *S1, s2 = *S2;

	/* shortcut nil */
	if (*v == @2_nil) {
		*res = @1_nil;
		return(MAL_SUCCEED);
	}
	
	/* count the number of digits in the input */
	while (cpyval /= 10)
		inlen++;
	/* rounding is allowed */
	inlen += (s2-s1);
	if (p && inlen > p) {
		throw(SQL, "@2_2_@1",
			"too many digits (%d > %d)", inlen, p);
	}

	if(s2 > s1) 
		val *= scales[s2-s1];
	else if (s2 != s1) 
		val = (val+h)/scales[s1-s2];

	/* see if the number fits in the data type */
	if (val > GDK_@1_min && val <= GDK_@1_max)	{
		*res = (@1)val;
		return MAL_SUCCEED;
	} else {
		throw(SQL, "convert",
			"value (" LLFMT ") exceeds limits of type @1", val);
	}
}

str 
@2_num2dec_@1( @1 *res, @2 *v, int *d2, int *s2 )
{
	int zero = 0;
	return @2_dec2dec_@1( res, &zero, v, d2, s2 );
}

str bat@2_dec2_@1( int *res, int *s1, int *bid )
{
	BAT *b, *bn;
	@2 *p,*q;
	char *msg = NULL;
	int scale = *s1;
	@1 *o;
	@2 val;

	if( (b = BATdescriptor(*bid)) == NULL ){
		throw(SQL, "batcalc.@2_dec2_@1", "Cannot access descriptor");
	}
	bn = BATnew(TYPE_void, TYPE_@1, BATcount(b));
	if( bn == NULL){
		BBPreleaseref(b->batCacheid);
		throw(SQL, "sql.dec@2_2_@1", MAL_MALLOC_FAIL);
	}
	bn->hsorted = b->hsorted;
	BATseqbase(bn, b->hseqbase);
	o = (@1*) Tloc(bn,BUNfirst(bn));
	p = (@2*) Tloc(b, BUNfirst(b));
	q = (@2*) Tloc(b, BUNlast(b));
	bn->T->nonil = 1;
	BATaccessBegin(b, USE_TAIL, MMAP_SEQUENTIAL);
	if ( b->T->nonil){
		for (; p<q; p++, o++) {
			if (scale) 
				val = (@2) ((*p+ (*p<0)?-5:5)/scales[scale]);
			else
				val = (@2) (*p);
			/* see if the number fits in the data type */
			if (val > GDK_@1_min && val <= GDK_@1_max)
				*o = (@1)val;
			else {
				BATaccessEnd(b, USE_TAIL, MMAP_SEQUENTIAL);
				BBPreleaseref(b->batCacheid);
				BBPreleaseref(bn->batCacheid);
				throw(SQL, "convert", "value (" LLFMT ") exceeds limits of type @1", (lng) val);
			}
		}
	} else{
		for (; p<q; p++, o++) {
			if (*p == @2_nil) {
				*o = @1_nil;
				bn->T->nonil= FALSE;
			} else {
				if (scale)
					val = (@2) (( *p + ( *p<0)?-5:5)/scales[scale]);
				else
					val = (@2) (*p);
				/* see if the number fits in the data type */
				if (val > GDK_@1_min && val <= GDK_@1_max)
					*o = (@1)val;
				else {
					BATaccessEnd(b, USE_TAIL, MMAP_SEQUENTIAL);
					BBPreleaseref(b->batCacheid);
					BBPreleaseref(bn->batCacheid);
					throw(SQL, "convert", "value (" LLFMT ") exceeds limits of type @1", (lng) val);
				}
			}
		}
	}
	BATaccessEnd(b, USE_TAIL, MMAP_SEQUENTIAL);
	BATsetcount(bn, BATcount(b));
	bn->tsorted = 0;
	BATkey(BATmirror(bn),FALSE);

	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);

	if (b->htype != bn->htype) {
		BAT *r = VIEWcreate(b,bn);

		BBPkeepref(*res = r->batCacheid);
		BBPreleaseref(bn->batCacheid);
		BBPreleaseref(b->batCacheid);
		return msg;
	}
	BBPkeepref(*res = bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	return msg;
}

str bat@2_dec2dec_@1( int *res, int *S1, int *bid, int *d2, int *S2 )
{
	BAT *b, *dst;
	BATiter bi;
	BUN p,q;
	char *msg = NULL;

	if( (b = BATdescriptor(*bid)) == NULL ){
		throw(SQL, "batcalc.@2_dec2dec_@1", "Cannot access descriptor");
	}
	bi = bat_iterator(b);
	dst = BATnew(b->htype, TYPE_@1, BATcount(b));
	if( dst == NULL){
		BBPreleaseref(b->batCacheid);
		throw(SQL, "sql.dec2dec_@1", MAL_MALLOC_FAIL);
	}
	BATseqbase(dst, b->hseqbase);
	BATaccessBegin(b, USE_TAIL, MMAP_SEQUENTIAL);
	BATloop(b,p,q) {
		@2 *v = (@2*)BUNtail(bi,p);
		@1 r;
		msg = @2_dec2dec_@1( &r, S1, v, d2, S2 );
		if (msg)
			break;
		BUNins(dst, BUNhead(bi,p), &r, FALSE);
	}
	BATaccessEnd(b, USE_TAIL, MMAP_SEQUENTIAL);
	BBPkeepref( *res = dst->batCacheid);
	BBPunfix(b->batCacheid);
	return msg;
}

str bat@2_num2dec_@1( int *res, int *bid, int *d2, int *s2 )
{
	BAT *b, *dst;
	BATiter bi;
	BUN p,q;
	char *msg = NULL;

	if( (b = BATdescriptor(*bid)) == NULL ){
		throw(SQL, "batcalc.@2_num2dec_@1", "Cannot access descriptor");
	}
	bi = bat_iterator(b);
	dst = BATnew(b->htype, TYPE_@1, BATcount(b));
	if( dst == NULL){
		BBPreleaseref(b->batCacheid);
		throw(SQL, "sql.num2dec_@1", MAL_MALLOC_FAIL);
	}
	BATseqbase(dst, b->hseqbase);
	BATaccessBegin(b, USE_TAIL, MMAP_SEQUENTIAL);
	BATloop(b,p,q) {
		@2 *v = (@2*)BUNtail(bi,p);
		@1 r;
		msg = @2_num2dec_@1( &r, v, d2, s2 );
		if (msg)
			break;
		BUNins(dst, BUNhead(bi,p), &r, FALSE);
	}
	BATaccessEnd(b, USE_TAIL, MMAP_SEQUENTIAL);
	BBPkeepref( *res = dst->batCacheid);
	BBPunfix(b->batCacheid);
	return msg;
}


@
@c
@:numcastdown(bte,sht)@
@:numcastdown(bte,int)@
@:numcastdown(bte,wrd)@
@:numcastdown(bte,lng)@
@:numcastdown(sht,int)@
@:numcastdown(sht,wrd)@
@:numcastdown(sht,lng)@
@:numcastdown(int,wrd)@
@:numcastdown(int,lng)@
@:numcastdown(wrd,lng)@

str 
month_interval_str( int *ret, str *s, int *d, int *sk )
{
	lng res;

	(void)sk;
	if (interval_from_str( *s, *d, &res ) < 0)
		throw(SQL, "calc.month_interval",
			"wrong format (%s)", *s);
	assert((lng) GDK_int_min <= res && res <= (lng) GDK_int_max);
	*ret = (int) res;
	return MAL_SUCCEED;
}

str 
second_interval_str( lng *res, str *s, int *d, int *sk )
{
	(void)sk;
	if (interval_from_str( *s, *d, res ) < 0)
		throw(SQL, "calc.second_interval",
			"wrong format (%s)", *s);
	return MAL_SUCCEED;
}

@= c_interval
str
month_interval_@1( int *ret, @1 *s, int *d, int *sk ){
	int k = digits2sk(*d);
	int r = (int)*s;

	(void)sk;
	switch(k) {
	case iyear: 	
		r *= 12;
	case imonth:
		break;
	default:
		throw(ILLARG, "calc.month_interval","illegal argument");
	}
	*ret = r;
	return MAL_SUCCEED;
}
str
second_interval_@1( lng *res, @1 *s, int *d, int *sk ){
	int k = digits2sk(*d);
	lng r = *s;

	(void)sk;
	switch(k) {
	case iday: 	
		r *= 24;
	case ihour:
		r *= 60;
	case imin:
		r *= 60;
	case isec:
		break;
	default:
		throw(ILLARG, "calc.second_interval","illegal argument");
	}
	*res = r;
	return MAL_SUCCEED;
}
@
@c
@:c_interval(bte)@
@:c_interval(sht)@
@:c_interval(int)@
@:c_interval(wrd)@
@:c_interval(lng)@

@mal
command calc.second_interval( v:daytime, ek:int, sk:int ) :lng
address second_interval_daytime
comment "cast daytime to a second_interval and check for overflow";
@h
sql5_export str second_interval_daytime( lng *res, daytime *s, int *ek, int *sk );
@c
str
second_interval_daytime( lng *res, daytime *s, int *d, int *sk )
{
	int k = digits2sk(*d);
	lng r = *(int*)s;

	(void)sk;
	switch(k) {
	case isec:
		r /= 1000;
		break;
	case imin:
		r /= 60000;
		break;
	case ihour:
		r /= 3600000;
		break;
	case iday: 	
		r /= (24*3600000);
		break;
	default:
		throw(ILLARG, "calc.second_interval","illegal argument");
	}
	*res = r;
	return MAL_SUCCEED;
}

/* str dump_cache(int *r); */
str
dump_cache(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	mvc *m = NULL;
	str msg = getContext(cntxt,mb, &m, NULL);
	int cnt; 
	BAT *t, *query, *count;
	cq *q = NULL;
	int *r = (int *) getArgReference(stk, pci, 0);

	(void) cntxt;
	if (msg)
		return msg;
	cnt = m->qc->id; 
 	t = BATnew(TYPE_str, TYPE_bat, 1);
	if( t == NULL)
		throw(SQL, "sql.dumpcache", MAL_MALLOC_FAIL);
	query = BATnew(TYPE_void, TYPE_str, cnt);
	if( query == NULL){
		BBPreleaseref(t->batCacheid);
		throw(SQL, "sql.dumpcache", MAL_MALLOC_FAIL);
	}
	BATseqbase(query, 0);
	count = BATnew(TYPE_void, TYPE_int, cnt);
	if( count == NULL){
		BBPreleaseref(t->batCacheid);
		BBPreleaseref(query->batCacheid);
		throw(SQL, "sql.dumpcache", MAL_MALLOC_FAIL);
	}
	BATseqbase(count, 0);
	BUNins(t, "query", &query->batCacheid, FALSE);
	BUNins(t, "count", &count->batCacheid, FALSE);

	for(q = m->qc->q; q; q = q->next) {
		if (q->type != Q_PREPARE) {
			BUNappend(query, q->codestring, FALSE);
			BUNappend(count, &q->count, FALSE);
		}
	}

	BBPunfix(query->batCacheid);
	BBPunfix(count->batCacheid);
	*r = t->batCacheid;
	BBPkeepref(*r);
	return MAL_SUCCEED;
}

/* str dump_opt_stats(int *r); */
str
dump_opt_stats(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	mvc *m = NULL;
	str msg = getContext(cntxt,mb, &m, NULL);
	int cnt; 
	BAT *t, *rewrite, *count;
	int *r = (int *) getArgReference(stk, pci, 0);

	(void) cntxt;
	if (msg)
		return msg;
	cnt = m->qc->id; 
 	t = BATnew(TYPE_str, TYPE_bat, 1);
	if( t == NULL)
		throw(SQL, "sql.optstats", MAL_MALLOC_FAIL);
	rewrite = BATnew(TYPE_void, TYPE_str, cnt);
	if( rewrite == NULL)
		throw(SQL, "sql.optstats", MAL_MALLOC_FAIL);
	BATseqbase(rewrite, 0);
	count = BATnew(TYPE_void, TYPE_int, cnt);
	if( count == NULL){
		BBPreleaseref(t->batCacheid);
		throw(SQL, "sql.optstats", MAL_MALLOC_FAIL);
	}
	BATseqbase(count, 0);
	BUNins(t, "rewrite", &rewrite->batCacheid, FALSE);
	BUNins(t, "count", &count->batCacheid, FALSE);

	BUNappend(rewrite, "joinidx", FALSE);
	BUNappend(count, &m->opt_stats[0], FALSE);
	/* TODO add other rewrites */

	BBPunfix(rewrite->batCacheid);
	BBPunfix(count->batCacheid);
	*r = t->batCacheid;
	BBPkeepref(*r);
	return MAL_SUCCEED;
}

/* str dump_opt_stats(int *r); */
str
dump_trace(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	mvc *m = NULL;
	str msg = getContext(cntxt,mb, &m, NULL);
	BAT *t;
	int *r = (int *) getArgReference(stk, pci, 0);

	if (msg)
		return msg;
	t= TRACEtable();
	*r = t->batCacheid;
	BBPkeepref(*r);
	return MAL_SUCCEED;
}


/* str sql_rowid(oid *rid, ptr v, str *sname, str *tname); */
str 
sql_rowid(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	BAT *b;
	mvc *m = NULL;
	str msg = getContext(cntxt,mb, &m, NULL);
	sql_schema *s = NULL;
	sql_table *t = NULL;
	sql_column *c = NULL;
	sql_delta *d;
	oid *rid = (oid *) getArgReference(stk, pci, 0);
	str *sname = (str *) getArgReference(stk, pci, 2);
	str *tname = (str *) getArgReference(stk, pci, 3);

	(void) cntxt;
	if (msg)
		return msg;
	s = mvc_bind_schema(m, *sname);
	if ( s == NULL)
		throw(SQL,"sql.rowid","Schema missing");
	t = mvc_bind_table(m, s, *tname);
	if ( s == NULL)
		throw(SQL,"sql.rowid","Table missing");
	if (!s || !t || !t->columns.set->h)
		throw(SQL, "calc.rowid", "Cannot find column");
	c = t->columns.set->h->data;
	/* HACK, get insert bat */
	b = store_funcs.bind_col(m->session->tr, c, RD_INS);
	/* UGH (move into storage backends!!) */
	d = c->data;
	*rid = d->ibase + BATcount(b);
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

@= rnk
str 
sql_@1rank_grp(bat *rid, bat *bid, bat *gid, bat *gpe)
{
	BAT *r, *b, *g;
	BUN p, q;
	BATiter bi, gi;
	int (*ocmp)(ptr, ptr), (*gcmp)(ptr, ptr);
	ptr oc, gc;
	int rank = 1, nrank = @3;

	if( (b = BATdescriptor(*bid)) == NULL )
		throw(SQL, "sql.@1rank_grp", "Cannot access descriptor");
	if( (g = BATdescriptor(*gid)) == NULL ){
		BBPreleaseref(b->batCacheid);
		throw(SQL, "sql.@1rank_grp", "Cannot access descriptor");
	}
	(void)gpe;
	bi = bat_iterator(b);
	gi = bat_iterator(g);
	ocmp = BATatoms[b->ttype].atomCmp;
	gcmp = BATatoms[g->ttype].atomCmp;
	oc = BUNtail(bi, BUNfirst(b));
	gc = BUNtail(gi, BUNfirst(g));
	if (!ALIGNsynced(b, g))
		throw(SQL, "sql.@1rank_grp", "bats not aligned");
	if (BATtordered(b) != GDK_SORTED)
		throw(SQL, "sql.@1rank_grp", "bat not sorted");
	r = BATnew(TYPE_oid, TYPE_int, BATcount(b));
	if (r == NULL){
		BBPreleaseref(b->batCacheid);
		BBPreleaseref(g->batCacheid);
		throw(SQL, "sql.@1rank_grp", "cannot allocate result bat");
	}
	BATloop(b, p, q) {
		ptr on = BUNtail(bi, p);
		ptr gn = BUNtail(gi, p);
		int c = 0;

		if ((c = ocmp(on, oc)) != 0) 
			rank = nrank;
		if (gcmp(gn, gc) != 0) 
			c = rank = nrank = 1;  
		oc = on;
		gc = gn;
		BUNins(r, BUNhead(bi,p), &rank, FALSE);
		@2;
	}
	BBPunfix(b->batCacheid);
	BBPunfix(g->batCacheid);
	BBPkeepref(*rid = r->batCacheid);
	return MAL_SUCCEED;
}

str
sql_@1rank(bat *rid, bat *bid)
{ 
	BAT *r, *b;
	BATiter bi;
	int (*cmp)(ptr, ptr);
	ptr cur;
	BUN p, q;
	int rank = 1, nrank = @3;

	if( (b = BATdescriptor(*bid)) == NULL )
		throw(SQL, "sql.@1rank", "Cannot access descriptor");
	if (!(BATtordered(b) & GDK_SORTED) && !(BATtordered(b) & GDK_SORTED_REV))
		throw(SQL, "sql.@1rank", "bat not sorted");

	bi = bat_iterator(b);
	cmp = BATatoms[b->ttype].atomCmp;
	cur = BUNtail(bi, BUNfirst(b));
	r = BATnew(TYPE_oid, TYPE_int, BATcount(b));
	if (r == NULL){
		BBPreleaseref(b->batCacheid);
		throw(SQL, "sql.@1rank", "cannot allocate result bat");
	}
	if (BATtdense(b)) {
		BATloop(b, p, q) {
			BUNins(r, BUNhead(bi,p), &rank, FALSE);
			rank++;
		}
	} else {
		BATloop(b, p, q) {
			ptr n = BUNtail(bi, p);
			int c = 0;
	
			if ((c = cmp(n, cur)) != 0) 
				rank = nrank; 
			cur = n;
			BUNins(r, BUNhead(bi,p), &rank, FALSE);
			@2;
		}
	}
	BBPunfix(b->batCacheid);
	BBPkeepref(*rid = r->batCacheid);
	return MAL_SUCCEED;
}
@
@c
@:rnk(,(void)c;nrank++,1)@
@:rnk(dense_,nrank+=(c?1:0),2)@

str SQLargRecord(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	str s, t, *ret;

	(void) cntxt;
	ret= (str *) getArgReference(stk,pci,0);
	s = instruction2str(mb,stk,getInstrPtr(mb,0),LIST_MAL_VALUE | LIST_MAPI);
	t= strchr(s,' ');
	*ret = GDKstrdup(t ? t+1: s);
	GDKfree(s);
	return MAL_SUCCEED;
}

/*
 * @-
 * The table is searched for all columns and they are
 * re-clustered on the hash value over the  primary key.
 * Initially the first column
 */

str SQLcluster1(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	str *sch = (str *) getArgReference(stk,pci,1);
	str *tbl = (str *) getArgReference(stk,pci,2);
	sql_trans	*tr;
	sql_schema	*s;
	sql_table 	*t;
	sql_column	*c;
	mvc *m = NULL;
	str msg = getContext(cntxt,mb, &m, NULL);
	int first=1;
	bat mid, hid, bid;
	BAT *map= NULL, *b;
	node *o;

	if (msg)
		return msg;
   	s = mvc_bind_schema(m, *sch);
	if ( s == NULL)
		throw(SQL,"sql.cluster","Schema missing");
	t = mvc_bind_table(m, s, *tbl);
	if ( t == NULL)
		throw(SQL,"sql.cluster","Table missing");
	tr = m->session->tr;
	t->base.wtime = s->base.wtime = tr->wtime = tr->stime;
	t->base.rtime = s->base.rtime = tr->rtime = tr->stime;

	/* actually build the hash on the multi-column primary key */

	for (o = t->columns.set->h; o; o = o->next) {
		sql_delta *d;
		c = o->data;
		if (first) {
			first = 0;
			b = store_funcs.bind_col(tr, c, 0);
			msg = CLUSTER_key(&hid, &b->batCacheid);
			BBPreleaseref(b->batCacheid);
			if (msg)
				return msg;
			msg = CLUSTER_map(&mid,&hid);
			BBPdecref(hid, TRUE);
			if (msg)
				return msg;
			map = BATdescriptor(mid);
			if (map== NULL)
				throw(SQL,"sql.cluster","Can not access descriptor");
		}

		b = store_funcs.bind_col(tr, c, 0);
		if (b == NULL)
			throw(SQL,"sql.cluster","Can not access descriptor");
		msg = CLUSTER_apply(&bid, b, map);
		BBPreleaseref(b->batCacheid);
		if (msg){
			BBPreleaseref(map->batCacheid);
			return msg;
		}
		BBPdecref(b->batCacheid, TRUE);
		d = c->data;
		d->bid = 0;
		d->ibase = 0;
		d->ibid = bid; /* use the insert bat */
		c->base.wtime = c->base.rtime = tr->stime;
	}
	/* bat was cleared */
	t->cleared = 1;
	if (map) {
		BBPreleaseref(map->batCacheid);
		BBPdecref(mid, TRUE);
	}
	return MAL_SUCCEED;
}

str 
SQLcluster2(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str *sch = (str *) getArgReference(stk,pci,1);
	str *tbl = (str *) getArgReference(stk,pci,2);
	sql_trans	*tr;
	sql_schema	*s;
	sql_table 	*t;
	sql_column	*c;
	mvc *m = NULL;
	str msg = getContext(cntxt,mb, &m, NULL);
	int first=1;
	bat mid, hid, bid;
	BAT *b;
	node *o;

	if (msg)
		return msg;
   	s = mvc_bind_schema(m, *sch);
	if ( s == NULL)
		throw(SQL,"sql.cluster","Schema missing");
	t = mvc_bind_table(m, s, *tbl);
	if ( t == NULL)
		throw(SQL,"sql.cluster","Table missing");
	tr = m->session->tr;

	t->base.wtime = s->base.wtime = tr->wtime = tr->stime;
	t->base.rtime = s->base.rtime = tr->rtime = tr->stime;
	for (o = t->columns.set->h; o; o = o->next) {
		sql_delta *d;
		c = o->data;
		if (first) {
			bat psum;
			unsigned int bits = 10, off = 0;
			first = 0;
			b = store_funcs.bind_col(tr, c, 0);
			msg = MKEYbathash(&hid, &b->batCacheid);
			BBPreleaseref(b->batCacheid);
			if (msg)
				return msg;
			msg = CLS_create_wrd(&psum, &mid, &hid, &bits, &off);
			BBPdecref(hid, TRUE);
			BBPdecref(psum, TRUE);
			if (msg)
				return msg;
		}

		b = store_funcs.bind_col(tr, c, 0);
		if (b == NULL)
			throw(SQL,"sql.cluster","Can not access descriptor");
		msg = CLS_map(&bid,&mid,&b->batCacheid);
		BBPreleaseref(b->batCacheid);
		if (msg){
			BBPreleaseref(bid);
			return msg;
		}
		BBPdecref(b->batCacheid, TRUE);

		d = c->data;
		/* its probably an empty bat which we shouldn't free 
		BBPdecref(d->ibid, TRUE);*/
		d->bid = 0;	
		d->ibase = 0;
		d->ibid = bid; /* use the insert bat */

		c->base.wtime = c->base.rtime = tr->stime;
	}
	/* bat was cleared */
	t->cleared = 1;
	return MAL_SUCCEED;
}
/*
 * @- Vacuum cleaning tables
 * Shrinking and re-using space to vacuum clean the holes in the relations.
 */
@= vacuum
str
SQL@1(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str *sch = (str *) getArgReference(stk,pci,1);
	str *tbl = (str *) getArgReference(stk,pci,2);
	sql_trans	*tr;
	sql_schema	*s;
	sql_table 	*t;
	sql_column	*c;
	mvc *m = NULL;
	str msg = getContext(cntxt,mb, &m, NULL);
	bat bid;
	BAT *b, *del;
	node *o;
	int i,bids[2049];

	if (msg)
		return msg;
   	s = mvc_bind_schema(m, *sch);
	if ( s == NULL)
		throw(SQL,"sql.@1","Schema missing");
	t = mvc_bind_table(m, s, *tbl);
	if ( t == NULL)
		throw(SQL,"sql.@1","Table missing");

	if (m->user_id != USER_MONETDB)
		throw(SQL,"sql.@1","insufficient privileges");
	if ((!list_empty(t->idxs.set) || !list_empty(t->keys.set)))
		throw(SQL,"sql.@1","@1 not allowed on tables with indices");
	if (has_snapshots(m->session->tr)) 
		throw(SQL,"sql.@1","@1 not allowed on snapshots");
	if (!m->session->auto_commit) 
		throw(SQL,"sql.@1","@1 only allowed in auto commit mode");

	/* lock the store, for single user/transaction */
	store_lock();
	while (store_nr_active > 1) {
		store_unlock();
		MT_sleep_ms(100);
		store_lock();

		/* flush old changes to disk */
		sql_trans_end(m->session);
		store_apply_deltas();
		sql_trans_begin(m->session);
	}

	tr = m->session->tr;
	t->base.wtime = s->base.wtime = tr->wtime = tr->stime;
	t->base.rtime = s->base.rtime = tr->rtime = tr->stime;

	/* get the deletions BAT*/
	del = mvc_bind_dbat(m, *sch, *tbl, RD_INS);

	/* this code is insecure, because something may 
	   go wrong while we compress the columns.
	   A two-phase action reduces the risks, but not all.
	   e.g. a crash during update of the catalog. */
	i=0;
	bids[i]=0;
	for (o = t->columns.set->h; o; o = o->next,i++) {
		c = o->data;
		b = store_funcs.bind_col(tr, c, 0);
		if (b == NULL || 
		    (msg = BKC@1BAT(&bid, &(b->batCacheid), &(del->batCacheid))) != NULL) {
			for( i--; i>=0; i--)
				BBPreleaseref(bids[i]);
			store_unlock();
			if (!msg)
				throw(SQL,"sql.@1","Can not access descriptor");
			return msg;
		}
		BBPreleaseref(b->batCacheid);
		if (i < 2048){
			bids[i]= bid;
			bids[i+1]=0;
		}
	}
	if ( i == 2048 ) {
		for( i--; i>=0; i--)
			BBPreleaseref(bids[i]);
		store_unlock();
		throw(SQL,"sql.@1","Too many columns to handle, use copy instead");
	}

	i=0;
	for (o = t->columns.set->h; o; o = o->next, i++) {
		sql_delta *d;
		c = o->data;
		b = store_funcs.bind_col(tr, c, 0);
		/* based on previous loop, BAT should be accessible */
		if (b)
			BBPdecref(b->batCacheid, TRUE);
		d = c->data;
		d->bid = 0;
		d->ibase = 0;
		d->ibid = bids[i]; /* use the insert bat */
		c->base.wtime = c->base.rtime = tr->stime;
	}
	BATclear(del);
	BBPreleaseref(del->batCacheid);
	/* bat was cleared */
	t->cleared = 1;

	sql_trans_commit(m->session->tr);
	/* write changes to disk */
	sql_trans_end(m->session);
	store_apply_deltas();
	sql_trans_begin(m->session);
	store_unlock();

	return MAL_SUCCEED;
}
@
@c
@:vacuum(shrink)@
@:vacuum(reuse)@

/*
 * @-
 * The vacuum operation inspects the table for ordered properties and will keep them.
 * To avoid expensive shuffles, the reorganisation is balanced by the number of outstanding deletions.
 */
str
SQLvacuum(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str *sch = (str *) getArgReference(stk,pci,1);
	str *tbl = (str *) getArgReference(stk,pci,2);
	sql_trans	*tr;
	sql_schema	*s;
	sql_table 	*t;
	sql_column	*c;
	mvc *m = NULL;
	str msg = getContext(cntxt,mb, &m, NULL);
	BAT *b, *del;
	node *o;
	int ordered = 0;
	BUN cnt=0;

	if (msg)
		return msg;
   	s = mvc_bind_schema(m, *sch);
	if ( s == NULL)
		throw(SQL,"sql.@1","Schema missing");
	t = mvc_bind_table(m, s, *tbl);
	if ( t == NULL)
		throw(SQL,"sql.@1","Table missing");

	if (m->user_id != USER_MONETDB)
		throw(SQL,"sql.@1","insufficient privileges");
	if ((!list_empty(t->idxs.set) || !list_empty(t->keys.set)))
		throw(SQL,"sql.@1","vacuum not allowed on tables with indices");
	if (has_snapshots(m->session->tr)) 
		throw(SQL,"sql.@1","vacuum not allowed on snapshots");

	tr = m->session->tr;

	/* get the deletions BAT*/
	del = mvc_bind_dbat(m, *sch, *tbl, RD_INS);

	for (o = t->columns.set->h; o && ordered == 0; o = o->next) {
		c = o->data;
		b = store_funcs.bind_col(tr, c, 0);
		if (b == NULL) 
			throw(SQL,"sql.@1","Can not access descriptor");
		ordered |= BATtordered(b);
		cnt = BATcount(b);
		BBPreleaseref(b->batCacheid);
		if (msg){
			BBPreleaseref(b->batCacheid);
			return msg;
		}
		BBPdecref(b->batCacheid, TRUE);
	}
	/* now decide on the algorithm */
	if ( ordered ){
		if( BATcount(del) > cnt/20 )
			SQLshrink(cntxt,mb,stk,pci);
	} else
		SQLreuse(cntxt,mb,stk,pci);

	return MAL_SUCCEED;
}
/*
 * @-
 * The drop_hash operation cleans up any hash indices on any of the tables columns.
 */
str
SQLdrop_hash(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str *sch = (str *) getArgReference(stk,pci,1);
	str *tbl = (str *) getArgReference(stk,pci,2);
	sql_schema	*s;
	sql_table 	*t;
	sql_column	*c;
	mvc *m = NULL;
	str msg = getContext(cntxt,mb, &m, NULL);
	BAT *b;
	node *o;

	if (msg)
		return msg;
   	s = mvc_bind_schema(m, *sch);
	if ( s == NULL)
		throw(SQL,"sql.drop_hash","Schema missing");
	t = mvc_bind_table(m, s, *tbl);
	if ( t == NULL)
		throw(SQL,"sql.drop_hash","Table missing");

	for (o = t->columns.set->h; o; o = o->next) {
		c = o->data;
		b = store_funcs.bind_col(m->session->tr, c, RDONLY);
		if (b == NULL) 
			throw(SQL,"sql.drop_hash","Can not access descriptor");
		HASHremove(b);
		HASHremove(BATmirror(b));
		BBPreleaseref(b->batCacheid);
	}
	return MAL_SUCCEED;
}

/*
 * @-
 * Take a SQL table and compress its columns using the dictionary compression scheme.
 */
@= compression
	str *sch = (str *) getArgReference(stk,pci,1);
	str *tbl = (str *) getArgReference(stk,pci,2);
	sql_schema	*s;
	sql_table 	*t;
	mvc *m = NULL;
	str msg = getContext(cntxt,mb, &m, NULL);
	sql_trans *tr = m->session->tr;
	node *o;
	char buf[BUFSIZ], *nme= buf;
	int ret;

	if (msg)
		return msg;
   	s = mvc_bind_schema(m, *sch);
	if ( s == NULL)
		throw(SQL,"sql.cluster","Schema missing");
	t = mvc_bind_table(m, s, *tbl);
	if ( t == NULL)
		throw(SQL,"sql.cluster","Table missing");

	/* actually build the hash on the multi-column primary key */

	for (o = t->columns.set->h; msg == MAL_SUCCEED && o; o = o->next) {
		BAT *b, *e;
		sql_delta *d;
		sql_column	*c = o->data;

		b = store_funcs.bind_col(tr, c, 0);
		if (b == NULL)
			throw(SQL,"sql.compress","Can not access descriptor");
		e = BATnew(b->htype, b->ttype, 0);
		if( e == NULL){
			BBPreleaseref(b->batCacheid);
			throw(SQL, "sql.compression", MAL_MALLOC_FAIL);
		}
		BATsetaccess(e, BAT_READ);
		d = c->data;
		d->bid = 0;
		d->ibase = 0;
		d->ibid = e->batCacheid; /* use the insert bat */
		c->base.wtime = c->base.rtime = tr->stime;
		snprintf(buf,BUFSIZ,"%s/%s/%s/0", *sch, *tbl, c->base.name);
		msg = @1;
		BBPkeepref(e->batCacheid);
		BBPreleaseref(b->batCacheid);
		BBPdecref(b->batCacheid, TRUE);
	}
	/* bat was cleared */
	t->cleared = 1;
	t->base.wtime = s->base.wtime = tr->wtime = tr->stime;
	t->base.rtime = s->base.rtime = tr->rtime = tr->stime;
	return msg;
@
@c
str SQLnewDictionary(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	@:compression(DICTcompress(&ret, &nme, &b->batCacheid))@
}
str SQLdropDictionary(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	@:compression(DICTdecompress(&ret, &nme))@
}
/*
 * @-
 * LZ compression is inherited from the underlying stream implementation.
 */
@= gzcompression
	str *sch = (str *) getArgReference(stk,pci,1);
	str *tbl = (str *) getArgReference(stk,pci,2);
	sql_schema	*s;
	sql_table 	*t;
	mvc *m = NULL;
	str msg = getContext(cntxt,mb, &m, NULL);
	sql_trans *tr = m->session->tr;
	node *o;
	int ret,i;
	char buf[PATHLENGTH], *sbuf= buf;

	if (msg)
		return msg;
   	s = mvc_bind_schema(m, *sch);
	if ( s == NULL)
		throw(SQL,"sql.@2","Schema missing");
	t = mvc_bind_table(m, s, *tbl);
	if ( t == NULL)
		throw(SQL,"sql.@2","Table missing");

	/* actually build the hash on the multi-column primary key */

	for (o = t->columns.set->h; msg == MAL_SUCCEED && o; o = o->next) {
		BAT *b;
		sql_column	*c = o->data;

		for ( i= 0; i<3; i++) {
			b = store_funcs.bind_col(tr, c, i);
			if (b == NULL)
				throw(SQL,"sql.@2","Can not access descriptor");
			snprintf(buf,PATHLENGTH,"%s_%s_%s_%d", *sch, *tbl, c->base.name,i);
			msg = @1;
			BBPreleaseref(b->batCacheid);
		}
	}
	return msg;
@
@c
str SQLgzcompress(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	@:gzcompression(CMDbbpcompress(&ret, &b->batCacheid,&sbuf),gzcompress)@
}
str SQLgzdecompress(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	@:gzcompression(CMDbbpdecompress(&ret, &b->batCacheid,&sbuf),gzdecompress)@
}
str SQLtruncate(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	@:gzcompression(CMDbbptruncate(&ret, &b->batCacheid,&sbuf),truncate)@
}
str SQLexpand(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	@:gzcompression(CMDbbpexpand(&ret, &b->batCacheid,&sbuf),expand)@
}
/*
 * @- Shredding RDF documents through SQL
 * Wrapper around the RDF shredder of the rdf module of M5.
 *
 * An rdf file can be now shredded with SQL command:
 * CALL rdf_shred('/path/to/location','graph name');
 *
 * The table rdf.graph will be updated with an entry of the form:
 * [graph name, graph id] -> [gname,gid].
 *
 * In addition all permutation of SPO for the specific rdf document will be
 * created. The name of the triple tables are rdf.pso$gid$, rdf.spo$gid$ etc.
 * For example if gid = 3 then rdf.spo3 is the triple table ordered on subject,
 * property, object. Finally, there is one more table called rdf.map$gid$ that
 * maps oids to strings (i.e., the lexical representation).
 */
@= crt_tbl
sprintf(buff, "@2%d", @1);
@2_tbl = mvc_create_table(m, sch, buff, tt_table, 0, SQL_PERSIST, 0, 3);
mvc_create_column(m, @2_tbl, "@3", &tpe);
mvc_create_column(m, @2_tbl, "@4", &tpe);
mvc_create_column(m, @2_tbl, "@5", &tpe);

@= crt_col
s = BATdescriptor(g[@2]);
p = BATdescriptor(g[@3]);
o = BATdescriptor(g[@4]);
store_funcs.append_col(m->session->tr, mvc_bind_column(m, @1, "subject"),
		s, TYPE_bat);
store_funcs.append_col(m->session->tr, mvc_bind_column(m, @1, "property"),
		p, TYPE_bat);
store_funcs.append_col(m->session->tr, mvc_bind_column(m, @1, "object"),
		o, TYPE_bat);
BBPunfix(s->batCacheid);
BBPunfix(p->batCacheid);
BBPunfix(o->batCacheid);


@
@c
str
SQLrdfShred(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
#ifdef HAVE_RAPTOR
	bat docbats;
	BAT *graph = NULL;
	BAT *p, *s, *o;
	bat *g;
	sql_schema *sch;
	sql_table *g_tbl;
	sql_column *gname, *gid;
#if STORE == TRIPLE_STORE
	sql_table *spo_tbl, *sop_tbl, *pso_tbl, *pos_tbl, *osp_tbl, *ops_tbl;
#elif STORE == MLA_STORE
	sql_table *spo_tbl;
#endif /* STORE */
	sql_table *map_tbl;
	sql_subtype tpe;
	str *location = (str *) getArgReference(stk,pci,1);
	str *name = (str *) getArgReference(stk,pci,2);
	str *schema = (str *) getArgReference(stk,pci,3);
	char buff[24];
	mvc *m = NULL;
	int id = 0;
	oid rid = oid_nil;
	str msg;

	rethrow("sql.rdfShred", msg, getContext(cntxt, mb, &m, NULL));

	if ((sch = mvc_bind_schema(m, *schema)) == NULL)
		throw(SQL, "sql.rdfShred", "schema missing");

	g_tbl = mvc_bind_table(m, sch, "graph");
	gname = mvc_bind_column(m, g_tbl, "gname");
	gid = mvc_bind_column(m, g_tbl, "gid");

	rid = table_funcs.column_find_row(m->session->tr, gname, *name, NULL);
	if (rid != oid_nil)
		throw(SQL, "sql.rdfShred", "graph name already exists in rdf.graph");

	id = (int) store_funcs.count_col(gname);
	store_funcs.append_col(m->session->tr, gname, *name, TYPE_str);
	store_funcs.append_col(m->session->tr, gid, &id, TYPE_int);

	rethrow("sql.rdfShred", msg, RDFParser(&docbats, location, name, schema));

	if (sizeof(oid) == 8) {
		sql_find_subtype(&tpe, "oid", 31, 0);
		/* todo for niels: if use int/bigint the @0 is serialized */
		/* sql_find_subtype(&tpe, "bigint", 64, 0); */
	} else {
		sql_find_subtype(&tpe, "oid", 31, 0);
		/* sql_find_subtype(&tpe, "int", 32, 0); */
	}
#if STORE == TRIPLE_STORE
	@:crt_tbl(id,spo,subject,property,object)@
	@:crt_tbl(id,sop,subject,object,property)@
	@:crt_tbl(id,pso,property,subject,object)@
	@:crt_tbl(id,pos,property,object,subject)@
	@:crt_tbl(id,osp,object,subject,property)@
	@:crt_tbl(id,ops,object,property,subject)@
#elif STORE == MLA_STORE
	@:crt_tbl(id,spo,subject,property,object)@
#endif /* STORE */

	sprintf(buff, "map%d", id);
	map_tbl = mvc_create_table(m, sch, buff, tt_table, 0, SQL_PERSIST, 0, 2);
	mvc_create_column(m, map_tbl, "sid", &tpe);
	sql_find_subtype(&tpe, "varchar", 1024, 0);
	mvc_create_column(m, map_tbl, "lexical", &tpe);

	if ((graph = BATdescriptor(docbats)) == NULL)
		throw(SQL, "sql.rdfShred", "docbat is missing");

	g = (bat *) Tloc(graph, BUNfirst(graph));

	if ((s =  BATdescriptor(g[MAP_LEX])) == NULL) {
		BBPreleaseref(graph->batCacheid);
		throw(SQL, "sql.rdfShred", "map_lex is missing");
	}

	store_funcs.append_col(m->session->tr,
			mvc_bind_column(m, map_tbl, "lexical"),
			BATmirror(BATmark(BATmirror(s),0)), TYPE_bat);
	store_funcs.append_col(m->session->tr,
			mvc_bind_column(m, map_tbl, "sid"),
			BATmirror(BATmark(s, 0)),
			TYPE_bat);
	BBPunfix(s->batCacheid);

#if STORE == TRIPLE_STORE
	@:crt_col(spo_tbl,S_sort,P_PO,O_PO)@
	@:crt_col(sop_tbl,S_sort,P_OP,O_OP)@
	@:crt_col(pso_tbl,S_SO,P_sort,O_SO)@
	@:crt_col(pos_tbl,S_OS,P_sort,O_OS)@
	@:crt_col(osp_tbl,S_SP,P_SP,O_sort)@
	@:crt_col(ops_tbl,S_PS,P_PS,O_sort)@
#elif STORE == MLA_STORE
	@:crt_col(spo_tbl,S_sort,P_sort,O_sort)@
#endif /* STORE */

	/* unfix graph */
	BBPunfix(graph->batCacheid);

	return MAL_SUCCEED;
#else
	(void) cntxt; (void) mb; (void) stk; (void) pci;
	throw(SQL, "sql.rdfShred", "RDF support is missing from MonetDB5");
#endif /* RDF */
}

/*
 * @-
 * Inspection of the actual storage footprint is a recurring question of users.
 * This is modelled as a generic SQL table producing function.
 * create function storage()
 * returns table ("schema" string, "table" string, "column" string, location string, "count" bigint, capacity bigint, width int, size bigint, hashsize bigint)
 * external name sql.storage;
 */
str
sql_storage(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int *res = (int*) getArgReference(stk,pci,0);
	BAT *sch, *tab, *col, *loc, *cnt, *cap, *atom, *size, *aux, *r;
	mvc *m = NULL;
	str msg = getContext(cntxt,mb, &m, NULL);
	sql_trans *tr = m->session->tr;
	node *nsch, *ntab, *ncol;
	int w;

	if (msg)
		return msg;

	sch = BATnew(TYPE_void,TYPE_str, 0);
	BATseqbase(sch, 0);
	tab = BATnew(TYPE_void,TYPE_str, 0);
	BATseqbase(tab, 0);
	col = BATnew(TYPE_void,TYPE_str, 0);
	BATseqbase(col, 0);
	loc = BATnew(TYPE_void,TYPE_str, 0);
	BATseqbase(loc, 0);
	cnt = BATnew(TYPE_void,TYPE_lng, 0);
	BATseqbase(cnt, 0);
	cap = BATnew(TYPE_void,TYPE_lng, 0);
	BATseqbase(cap, 0);
	atom = BATnew(TYPE_void,TYPE_int, 0);
	BATseqbase(atom, 0);
	size = BATnew(TYPE_void,TYPE_lng, 0);
	BATseqbase(size, 0);
	aux = BATnew(TYPE_void,TYPE_lng, 0);
	BATseqbase(aux, 0);
	if ( sch == NULL || tab == NULL || col == NULL || loc == NULL ||
		 cnt == NULL || cap == NULL || atom == NULL || size == NULL || aux == NULL){
		if ( sch ) BBPreleaseref(sch->batCacheid);
		if ( tab ) BBPreleaseref(tab->batCacheid);
		if ( col ) BBPreleaseref(col->batCacheid);
		if ( loc ) BBPreleaseref(loc->batCacheid);
		if ( cnt ) BBPreleaseref(cnt->batCacheid);
		if ( cap ) BBPreleaseref(cap->batCacheid);
		if ( atom ) BBPreleaseref(atom->batCacheid);
		if ( size ) BBPreleaseref(size->batCacheid);
		if ( aux ) BBPreleaseref(aux->batCacheid);
		throw(SQL,"sql.storage", MAL_MALLOC_FAIL);
	}
	for( nsch= tr->schemas.set->h; nsch; nsch= nsch->next){
		sql_base *b= nsch->data;
		sql_schema *s= (sql_schema*) nsch->data;
		if ( isalpha((int)b->name[0]) )
		for(ntab= (s)->tables.set->h ;ntab; ntab= ntab->next){
			sql_base *bt= ntab->data;
			sql_table *t= (sql_table*) bt;
			if (isTable(t))
			for (ncol= (t)->columns.set->h; ncol; ncol= ncol->next){
				sql_base *bc = ncol->data;
				sql_column *c= (sql_column *) ncol->data;
				BAT *bn = store_funcs.bind_col(tr, c, 0);
				BUN sz;

				/*printf("schema %s.%s.%s" , b->name, bt->name, bc->name);*/
				sch = BUNappend(sch, b->name, FALSE);
				tab = BUNappend(tab, bt->name, FALSE);
				col = BUNappend(col, bc->name, FALSE);

				/*printf(" cnt "BUNFMT, BATcount(bn));*/
				sz= BATcount(bn);
				cnt = BUNappend(cnt, &sz, FALSE);
				/*printf(" cap "BUNFMT, BATcapacity(bn));*/
				sz= BATcapacity(bn);
				cap = BUNappend(cap, &sz, FALSE);

				/*printf(" loc %s", BBP_physical(bn->batCacheid));*/
				loc = BUNappend(loc, BBP_physical(bn->batCacheid), FALSE);
				/*printf(" width %d", bn->T->width);*/
				w= bn->T->width;
				atom = BUNappend(atom, &w, FALSE);
				/*printf(" size "BUNFMT, tailsize(bn,BATcount(bn)) + (bn->T->vheap? bn->T->vheap->size:0));*/
				sz = tailsize(bn,BATcapacity(bn)) + (bn->T->vheap? bn->T->vheap->size:0);
				sz += headsize(bn,BATcapacity(bn)) + (bn->H->vheap? bn->H->vheap->size:0);
				size = BUNappend(size, &sz, FALSE);
				
				sz =  bn->T->hash?bn->T->hash->heap->size:0;
				sz += bn->H->hash?bn->H->hash->heap->size:0;
				aux = BUNappend(aux, &sz, FALSE);
				/*printf(" auxsize "BUNFMT, bn->T->hash?bn->T->hash->heap->size:0);*/
				/*printf("\n");*/
				BBPunfix(bn->batCacheid);
			}

			if (isTable(t))
				if(t->idxs.set)
					for (ncol= (t)->idxs.set->h; ncol; ncol= ncol->next){
						sql_base *bc = ncol->data;
						sql_idx *c= (sql_idx *) ncol->data;
						if(c->type != no_idx){
							BAT *bn = store_funcs.bind_idx(tr, c, 0);
							BUN sz;
			
							/*printf("schema %s.%s.%s" , b->name, bt->name, bc->name);*/
							sch = BUNappend(sch, b->name, FALSE);
							tab = BUNappend(tab, bt->name, FALSE);
							col = BUNappend(col, bc->name, FALSE);
			
							/*printf(" cnt "BUNFMT, BATcount(bn));*/
							sz= BATcount(bn);
							cnt = BUNappend(cnt, &sz, FALSE);
							/*printf(" cap "BUNFMT, BATcapacity(bn));*/
							sz= BATcapacity(bn);
							cap = BUNappend(cap, &sz, FALSE);
			
							/*printf(" loc %s", BBP_physical(bn->batCacheid));*/
							loc = BUNappend(loc, BBP_physical(bn->batCacheid), FALSE);
							/*printf(" width %d", bn->T->width);*/
							w= bn->T->width;
							atom = BUNappend(atom, &w, FALSE);
							/*printf(" size "BUNFMT, tailsize(bn,BATcount(bn)) + (bn->T->vheap? bn->T->vheap->size:0));*/
							sz = tailsize(bn,BATcapacity(bn)) + (bn->T->vheap? bn->T->vheap->size:0);
							sz += headsize(bn,BATcapacity(bn)) + (bn->H->vheap? bn->H->vheap->size:0);
							size = BUNappend(size, &sz, FALSE);
							
							sz =  bn->T->hash?bn->T->hash->heap->size:0;
							sz += bn->H->hash?bn->H->hash->heap->size:0;
							aux = BUNappend(aux, &sz, FALSE);
							/*printf(" auxsize "BUNFMT, bn->T->hash?bn->T->hash->heap->size:0);*/
							/*printf("\n");*/
							BBPunfix(bn->batCacheid);
						}
					}
		
		}
	}

	r = BATnew(TYPE_str,TYPE_bat,1);
	if( r == NULL){
		BBPreleaseref(sch->batCacheid);
		BBPreleaseref(tab->batCacheid);
		BBPreleaseref(col->batCacheid);
		BBPreleaseref(loc->batCacheid);
		BBPreleaseref(cnt->batCacheid);
		BBPreleaseref(cap->batCacheid);
		BBPreleaseref(atom->batCacheid);
		BBPreleaseref(size->batCacheid);
		BBPreleaseref(aux->batCacheid);
		throw(SQL, "sql.storage", MAL_MALLOC_FAIL);
	}
	BUNins(r, "schema", &sch->batCacheid, FALSE);
	BUNins(r, "table", &tab->batCacheid, FALSE);
	BUNins(r, "column", &col->batCacheid, FALSE);
	BUNins(r, "location", &loc->batCacheid, FALSE);
	BUNins(r, "count", &cnt->batCacheid, FALSE);
	BUNins(r, "capacity", &cap->batCacheid, FALSE);
	BUNins(r, "width", &atom->batCacheid, FALSE);
	BUNins(r, "size", &size->batCacheid, FALSE);
	BUNins(r, "hashsize", &aux->batCacheid, FALSE);
	BBPunfix(sch->batCacheid);
	BBPunfix(tab->batCacheid);
	BBPunfix(col->batCacheid);
	BBPunfix(loc->batCacheid);
	BBPunfix(cnt->batCacheid);
	BBPunfix(cap->batCacheid);
	BBPunfix(atom->batCacheid);
	BBPunfix(size->batCacheid);
	BBPunfix(aux->batCacheid);
	BBPkeepref(*res = r->batCacheid);
	return MAL_SUCCEED;
}

str 
RAstatement(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int pos = 0;
	str *expr = (str*) getArgReference(stk, pci, 1);
	bit *opt = (bit*) getArgReference(stk, pci, 2);
	backend *b = NULL;
	mvc *m = NULL;
	str msg = getContext(cntxt, mb, &m, &b);
	sql_rel *rel;

	m->sa = sa_create();
 	rel = rel_read(m, *expr, &pos);
	if (rel) {
		int oldvtop = cntxt->curprg->def->vtop;
		int oldstop = cntxt->curprg->def->stop;
		stmt *s;
		char *msg;

		rel_print(m, rel, 0);
		s = output_rel_bin(m, rel);
		if (*opt) { 
			rel = rel_optimizer(m, rel);
			rel_print(m, rel, 0);
		}
		rel_destroy(rel);
		s = rel2bin(m, s); 	
		s = bin_optimizer(m, s);

		MSinitClientPrg(cntxt, "user", "test"); 

		/* generate MAL code */
		backend_callinline(b, cntxt, s );
		addQueryToCache(cntxt); 

		msg = (str) runMAL(cntxt, cntxt->curprg->def, 1, 0, 0, 0);
		if (!msg) { 
			resetMalBlk(cntxt->curprg->def, oldstop);
			freeVariables(cntxt,cntxt->curprg->def, cntxt->glb, oldvtop);
		}
	}
	return msg;
}

void
freeVariables(Client c, MalBlkPtr mb, MalStkPtr glb, int start)
{
	int i, j;

	for (i = start; i < mb->vtop;) {
		if (glb) {
			if (isVarCleanup(mb,i))
				garbageElement(c,&glb->stk[i]);
			/* clean stack entry */
			glb->stk[i].vtype = TYPE_int;
			glb->stk[i].val.ival = 0;
			glb->stk[i].len = 0;
		}
		clearVariable(mb, i);
		i++;
	}
	mb->vtop = start;
	for (i = j = 0; i < mb->ptop; i++) {
		if (mb->prps[i].var < start) {
			if (i > j)
				mb->prps[j] = mb->prps[i];
			j++;
		}
	}
	mb->ptop = j;
}

