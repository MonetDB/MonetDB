stdout of test 'simple_plans` in directory 'sql/test/miscellaneous` itself:


# 21:22:10 >  
# 21:22:10 >  "mclient" "-lsql" "-ftest" "-tnone" "-Eutf-8" "-i" "-e" "--host=/var/tmp/mtest-857522" "--port=34649"
# 21:22:10 >  

#start transaction;
#create table myy (col1 int, col2 int);
#insert into myy values (1, 1), (2, 0), (3,3), (4,2);
[ 4	]
#select distinct col1 + col2 from myy order by col1 + col2;
% sys.%2 # table_name
% %2 # name
% bigint # type
% 1 # length
[ 2	]
[ 6	]
#plan select distinct col1 + col2 from myy order by col1 + col2;
% .plan # table_name
% rel # name
% clob # type
% 110 # length
project (
| group by (
| | project (
| | | table(sys.myy) [ "myy"."col1", "myy"."col2" ] COUNT 
| | ) [ sys.sql_add(bigint["myy"."col1"] as "myy"."col1", bigint["myy"."col2"] as "myy"."col2") as "%2"."%2" ]
| ) [ "%2"."%2" ] [ "%2"."%2" ]
) [ "%2"."%2" ] [ "%2"."%2" ASC ]
#create table myx (x uuid, y uuid);
#plan select * from myx where x in ('1aea00e5db6e0810b554fde31d961965') or y = '1aea00e5db6e0810b554fde31d961965';
% .plan # table_name
% rel # name
% clob # type
% 138 # length
project (
| select (
| | table(sys.myx) [ "myx"."x", "myx"."y" ] COUNT 
| ) [ ("myx"."x" = uuid[char(32) "1aea00e5db6e0810b554fde31d961965"]) or ("myx"."y" = uuid[char(32) "1aea00e5db6e0810b554fde31d961965"]) ]
) [ "myx"."x", "myx"."y" ]
#plan select * from myx where x in ('1aea00e5db6e0810b554fde31d961965') or y is null;
% .plan # table_name
% rel # name
% clob # type
% 102 # length
project (
| select (
| | table(sys.myx) [ "myx"."x", "myx"."y" ] COUNT 
| ) [ ("myx"."x" = uuid[char(32) "1aea00e5db6e0810b554fde31d961965"]) or ("myx"."y" * = uuid "NULL") ]
) [ "myx"."x", "myx"."y" ]
#plan select * from myx where x in ('1aea00e5db6e0810b554fde31d961965', '1aea00e5db6e0810b554fde31d961966') or y = '1aea00e5db6e0810b554fde31d961967';
% .plan # table_name
% rel # name
% clob # type
% 192 # length
project (
| select (
| | table(sys.myx) [ "myx"."x", "myx"."y" ] COUNT 
| ) [ ("myx"."x" in (uuid[char(32) "1aea00e5db6e0810b554fde31d961965"], uuid[char(32) "1aea00e5db6e0810b554fde31d961966"])) or ("myx"."y" = uuid[char(32) "1aea00e5db6e0810b554fde31d961967"]) ]
) [ "myx"."x", "myx"."y" ]
#insert into myx values ('1aea00e5db6e0810b554fde31d961965', '1aea00e5db6e0810b554fde31d961967');
[ 1	]
#select * from myx where x in ('1aea00e5db6e0810b554fde31d961966') or y is not null;
% sys.myx,	sys.myx # table_name
% x,	y # name
% uuid,	uuid # type
% 36,	36 # length
[ 1aea00e5-db6e-0810-b554-fde31d961965,	1aea00e5-db6e-0810-b554-fde31d961967	]
#select * from myx where x in ('1aea00e5db6e0810b554fde31d961966') or y is null;
% sys.myx,	sys.myx # table_name
% x,	y # name
% uuid,	uuid # type
% 36,	36 # length
#CREATE TABLE tbl_ProductSales (ColID int, Product_Category  varchar(64), Product_Name  varchar(64), TotalSales int); 
#INSERT INTO tbl_ProductSales VALUES (1,'Game','Mobo Game',200),(2,'Game','PKO Game',400),(3,'Fashion','Shirt',500),(4,'Fashion','Shorts',100);
[ 4	]
#CREATE TABLE another_T (col1 INT, col2 INT, col3 INT, col4 INT, col5 INT, col6 INT, col7 INT, col8 INT);
#INSERT INTO another_T VALUES (1,2,3,4,5,6,7,8), (11,22,33,44,55,66,77,88), (111,222,333,444,555,666,777,888), (1111,2222,3333,4444,5555,6666,7777,8888);
[ 4	]
#EXPLAIN SELECT 1 FROM another_t t1 INNER JOIN another_t t2 ON t1.col1 BETWEEN t2.col1 AND t2.col1;
% .explain # table_name
% mal # name
% clob # type
% 175 # length
function user.s20_0():void;
    X_2:void := querylog.define("explain select 1 from another_t t1 inner join another_t t2 on t1.col1 between t2.col1 and t2.col1;":str, "default_pipe":str, 23:int);
    X_32:bat[:str] := bat.pack(".%3":str);
    X_33:bat[:str] := bat.pack("%3":str);
    X_34:bat[:str] := bat.pack("tinyint":str);
    X_35:bat[:int] := bat.pack(1:int);
    X_36:bat[:int] := bat.pack(0:int);
    X_5:int := sql.mvc();
    C_6:bat[:oid] := sql.tid(X_5:int, "sys":str, "another_t":str);
    X_12:bat[:int] := sql.bind(X_5:int, "sys":str, "another_t":str, "col1":str, 0:int);
    X_16:bat[:int] := algebra.projection(C_6:bat[:oid], X_12:bat[:int]);
    (X_18:bat[:oid], X_19:bat[:oid]) := algebra.rangejoin(X_16:bat[:int], X_16:bat[:int], X_16:bat[:int], nil:BAT, nil:BAT, true:bit, true:bit, false:bit, false:bit, nil:lng);
    X_27:bat[:int] := algebra.projection(X_18:bat[:oid], X_16:bat[:int]);
    X_30:bat[:bte] := algebra.project(X_27:bat[:int], 1:bte);
    sql.resultSet(X_32:bat[:str], X_33:bat[:str], X_34:bat[:str], X_35:bat[:int], X_36:bat[:int], X_30:bat[:bte]);
end user.s20_0;
#inline               actions= 0 time=0 usec 
#remap                actions= 0 time=1 usec 
#costmodel            actions= 1 time=1 usec 
#coercion             actions= 0 time=1 usec 
#aliases              actions= 1 time=6 usec 
#evaluate             actions= 0 time=5 usec 
#emptybind            actions= 0 time=0 usec 
#pushselect           actions= 0 time=11 usec 
#aliases              actions= 0 time=1 usec 
#mitosis              actions=4 time=28 usec 
#mergetable           actions= 5 time=65 usec 
#deadcode             actions= 9 time=15 usec 
#aliases              actions= 0 time=0 usec 
#constants            actions= 5 time=7 usec 
#commonTerms          actions= 0 time=12 usec 
#projectionpath       actions= 0 time=6 usec 
#deadcode             actions= 0 time=10 usec 
#reorder              actions= 1 time=31 usec 
#matpack              actions= 1 time=11 usec 
#dataflow             actions= 1 time=28 usec 
#multiplex            actions= 0 time=2 usec 
#profiler             actions= 1 time=2 usec 
#candidates           actions= 1 time=2 usec 
#deadcode             actions= 0 time=12 usec 
#postfix              actions= 0 time=9 usec 
#wlc                  actions= 0 time=0 usec 
#garbagecollector     actions= 1 time=46 usec 
#total                actions=29 time=407 usec 
#EXPLAIN SELECT 1 FROM another_t t1 INNER JOIN another_t t2 ON t1.col1 BETWEEN t2.col1 - 1 AND t2.col1 + 1;
% .explain # table_name
% mal # name
% clob # type
% 175 # length
function user.s22_0():void;
    X_4:void := querylog.define("explain select 1 from another_t t1 inner join another_t t2 on t1.col1 between t2.col1 - 1 and t2.col1 + 1;":str, "default_pipe":str, 35:int);
    X_49:bat[:str] := bat.pack(".%12":str);
    X_50:bat[:str] := bat.pack("%12":str);
    X_51:bat[:str] := bat.pack("tinyint":str);
    X_52:bat[:int] := bat.pack(1:int);
    X_53:bat[:int] := bat.pack(0:int);
    X_7:int := sql.mvc();
    C_8:bat[:oid] := sql.tid(X_7:int, "sys":str, "another_t":str);
    X_14:bat[:int] := sql.bind(X_7:int, "sys":str, "another_t":str, "col1":str, 0:int);
    X_15:bat[:int] := algebra.projection(C_8:bat[:oid], X_14:bat[:int]);
    X_16:bat[:lng] := batcalc.lng(X_15:bat[:int]);
    X_24:bat[:lng] := batcalc.-(X_16:bat[:lng], 1:lng, nil:BAT);
    X_30:bat[:lng] := batcalc.+(X_16:bat[:lng], 1:lng, nil:BAT);
    (X_32:bat[:oid], X_33:bat[:oid]) := algebra.rangejoin(X_16:bat[:lng], X_24:bat[:lng], X_30:bat[:lng], nil:BAT, nil:BAT, true:bit, true:bit, false:bit, false:bit, nil:lng);
    X_41:bat[:int] := algebra.projection(X_32:bat[:oid], X_15:bat[:int]);
    X_47:bat[:bte] := algebra.project(X_41:bat[:int], 1:bte);
    sql.resultSet(X_49:bat[:str], X_50:bat[:str], X_51:bat[:str], X_52:bat[:int], X_53:bat[:int], X_47:bat[:bte]);
end user.s22_0;
#inline               actions= 0 time=2 usec 
#remap                actions= 2 time=53 usec 
#costmodel            actions= 1 time=2 usec 
#coercion             actions= 0 time=2 usec 
#aliases              actions= 3 time=7 usec 
#evaluate             actions= 2 time=20 usec 
#emptybind            actions= 0 time=0 usec 
#pushselect           actions= 0 time=13 usec 
#aliases              actions= 2 time=6 usec 
#mitosis              actions=4 time=30 usec 
#mergetable           actions= 9 time=135 usec 
#deadcode             actions=21 time=18 usec 
#aliases              actions= 0 time=1 usec 
#constants            actions=11 time=9 usec 
#commonTerms          actions= 1 time=18 usec 
#projectionpath       actions= 0 time=6 usec 
#deadcode             actions= 1 time=11 usec 
#reorder              actions= 1 time=36 usec 
#matpack              actions= 1 time=12 usec 
#dataflow             actions= 1 time=31 usec 
#multiplex            actions= 0 time=2 usec 
#profiler             actions= 1 time=2 usec 
#candidates           actions= 1 time=2 usec 
#deadcode             actions= 0 time=13 usec 
#postfix              actions= 0 time=10 usec 
#wlc                  actions= 0 time=0 usec 
#garbagecollector     actions= 1 time=77 usec 
#total                actions=29 time=620 usec 
#EXPLAIN SELECT 1 FROM another_t t1 INNER JOIN another_t t2 ON t1.col1 BETWEEN t2.col1 AND 2;
% .explain # table_name
% mal # name
% clob # type
% 175 # length
function user.s24_0():void;
    X_3:void := querylog.define("explain select 1 from another_t t1 inner join another_t t2 on t1.col1 between t2.col1 and 2;":str, "default_pipe":str, 26:int);
    X_36:bat[:str] := bat.pack(".%3":str);
    X_37:bat[:str] := bat.pack("%3":str);
    X_38:bat[:str] := bat.pack("tinyint":str);
    X_39:bat[:int] := bat.pack(1:int);
    X_40:bat[:int] := bat.pack(0:int);
    X_6:int := sql.mvc();
    C_7:bat[:oid] := sql.tid(X_6:int, "sys":str, "another_t":str);
    X_13:bat[:int] := sql.bind(X_6:int, "sys":str, "another_t":str, "col1":str, 0:int);
    X_17:bat[:int] := algebra.projection(C_7:bat[:oid], X_13:bat[:int]);
    X_21:bat[:int] := algebra.project(X_17:bat[:int], 2:int);
    (X_22:bat[:oid], X_23:bat[:oid]) := algebra.rangejoin(X_17:bat[:int], X_17:bat[:int], X_21:bat[:int], nil:BAT, nil:BAT, true:bit, true:bit, false:bit, false:bit, nil:lng);
    X_31:bat[:int] := algebra.projection(X_22:bat[:oid], X_17:bat[:int]);
    X_34:bat[:bte] := algebra.project(X_31:bat[:int], 1:bte);
    sql.resultSet(X_36:bat[:str], X_37:bat[:str], X_38:bat[:str], X_39:bat[:int], X_40:bat[:int], X_34:bat[:bte]);
end user.s24_0;
#inline               actions= 0 time=1 usec 
#remap                actions= 0 time=2 usec 
#costmodel            actions= 1 time=1 usec 
#coercion             actions= 0 time=2 usec 
#aliases              actions= 2 time=6 usec 
#evaluate             actions= 1 time=16 usec 
#emptybind            actions= 0 time=0 usec 
#pushselect           actions= 0 time=12 usec 
#aliases              actions= 1 time=5 usec 
#mitosis              actions=4 time=39 usec 
#mergetable           actions= 5 time=78 usec 
#deadcode             actions= 9 time=19 usec 
#aliases              actions= 0 time=0 usec 
#constants            actions= 6 time=8 usec 
#commonTerms          actions= 0 time=13 usec 
#projectionpath       actions= 0 time=6 usec 
#deadcode             actions= 0 time=11 usec 
#reorder              actions= 1 time=32 usec 
#matpack              actions= 1 time=10 usec 
#dataflow             actions= 1 time=47 usec 
#multiplex            actions= 0 time=2 usec 
#profiler             actions= 1 time=2 usec 
#candidates           actions= 1 time=2 usec 
#deadcode             actions= 0 time=12 usec 
#postfix              actions= 0 time=8 usec 
#wlc                  actions= 0 time=0 usec 
#garbagecollector     actions= 1 time=49 usec 
#total                actions=29 time=470 usec 
#EXPLAIN SELECT 1 FROM tbl_productsales t1 INNER JOIN tbl_productsales t2 ON t1.product_category LIKE t2.product_category;
% .explain # table_name
% mal # name
% clob # type
% 189 # length
function user.s26_0():void;
    X_2:void := querylog.define("explain select 1 from tbl_productsales t1 inner join tbl_productsales t2 on t1.product_category like t2.product_category;":str, "default_pipe":str, 24:int);
    X_31:bat[:str] := bat.pack(".%3":str);
    X_32:bat[:str] := bat.pack("%3":str);
    X_33:bat[:str] := bat.pack("tinyint":str);
    X_34:bat[:int] := bat.pack(1:int);
    X_35:bat[:int] := bat.pack(0:int);
    X_5:int := sql.mvc();
    C_6:bat[:oid] := sql.tid(X_5:int, "sys":str, "tbl_productsales":str);
    X_12:bat[:str] := sql.bind(X_5:int, "sys":str, "tbl_productsales":str, "product_category":str, 0:int);
    X_16:bat[:str] := algebra.projection(C_6:bat[:oid], X_12:bat[:str]);
    (X_20:bat[:oid], X_21:bat[:oid]) := algebra.likejoin(X_16:bat[:str], X_16:bat[:str], "":str, nil:BAT, nil:BAT, true:bit, nil:lng);
    X_26:bat[:str] := algebra.projection(X_20:bat[:oid], X_16:bat[:str]);
    X_29:bat[:bte] := algebra.project(X_26:bat[:str], 1:bte);
    sql.resultSet(X_31:bat[:str], X_32:bat[:str], X_33:bat[:str], X_34:bat[:int], X_35:bat[:int], X_29:bat[:bte]);
end user.s26_0;
#inline               actions= 0 time=2 usec 
#remap                actions= 0 time=3 usec 
#costmodel            actions= 1 time=6 usec 
#coercion             actions= 1 time=6 usec 
#aliases              actions= 2 time=7 usec 
#evaluate             actions= 0 time=8 usec 
#emptybind            actions= 0 time=0 usec 
#pushselect           actions= 0 time=16 usec 
#aliases              actions= 0 time=0 usec 
#mitosis              actions=4 time=41 usec 
#mergetable           actions= 1 time=64 usec 
#deadcode             actions= 6 time=18 usec 
#aliases              actions= 0 time=1 usec 
#constants            actions= 3 time=8 usec 
#commonTerms          actions= 0 time=13 usec 
#projectionpath       actions= 0 time=4 usec 
#deadcode             actions= 0 time=12 usec 
#reorder              actions= 1 time=49 usec 
#matpack              actions= 1 time=13 usec 
#dataflow             actions= 1 time=31 usec 
#multiplex            actions= 0 time=3 usec 
#profiler             actions= 1 time=2 usec 
#candidates           actions= 1 time=2 usec 
#deadcode             actions= 0 time=9 usec 
#postfix              actions= 0 time=6 usec 
#wlc                  actions= 0 time=1 usec 
#garbagecollector     actions= 1 time=45 usec 
#total                actions=29 time=478 usec 
#EXPLAIN SELECT 1 FROM another_t t1 INNER JOIN another_t t2 ON t1.col1 > t2.col1;
% .explain # table_name
% mal # name
% clob # type
% 148 # length
function user.s28_0():void;
    X_2:void := querylog.define("explain select 1 from another_t t1 inner join another_t t2 on t1.col1 > t2.col1;":str, "default_pipe":str, 23:int);
    X_30:bat[:str] := bat.pack(".%3":str);
    X_31:bat[:str] := bat.pack("%3":str);
    X_32:bat[:str] := bat.pack("tinyint":str);
    X_33:bat[:int] := bat.pack(1:int);
    X_34:bat[:int] := bat.pack(0:int);
    X_5:int := sql.mvc();
    C_6:bat[:oid] := sql.tid(X_5:int, "sys":str, "another_t":str);
    X_12:bat[:int] := sql.bind(X_5:int, "sys":str, "another_t":str, "col1":str, 0:int);
    X_16:bat[:int] := algebra.projection(C_6:bat[:oid], X_12:bat[:int]);
    (X_18:bat[:oid], X_19:bat[:oid]) := algebra.thetajoin(X_16:bat[:int], X_16:bat[:int], nil:BAT, nil:BAT, 1:int, true:bit, nil:lng);
    X_25:bat[:int] := algebra.projection(X_18:bat[:oid], X_16:bat[:int]);
    X_28:bat[:bte] := algebra.project(X_25:bat[:int], 1:bte);
    sql.resultSet(X_30:bat[:str], X_31:bat[:str], X_32:bat[:str], X_33:bat[:int], X_34:bat[:int], X_28:bat[:bte]);
end user.s28_0;
#inline               actions= 0 time=2 usec 
#remap                actions= 0 time=2 usec 
#costmodel            actions= 1 time=3 usec 
#coercion             actions= 0 time=2 usec 
#aliases              actions= 1 time=6 usec 
#evaluate             actions= 0 time=6 usec 
#emptybind            actions= 0 time=1 usec 
#pushselect           actions= 0 time=13 usec 
#aliases              actions= 0 time=0 usec 
#mitosis              actions=4 time=36 usec 
#mergetable           actions= 5 time=95 usec 
#deadcode             actions= 9 time=16 usec 
#aliases              actions= 0 time=1 usec 
#constants            actions= 3 time=7 usec 
#commonTerms          actions= 0 time=13 usec 
#projectionpath       actions= 0 time=6 usec 
#deadcode             actions= 0 time=10 usec 
#reorder              actions= 1 time=36 usec 
#matpack              actions= 1 time=36 usec 
#dataflow             actions= 1 time=32 usec 
#multiplex            actions= 0 time=3 usec 
#profiler             actions= 1 time=3 usec 
#candidates           actions= 1 time=3 usec 
#deadcode             actions= 0 time=14 usec 
#postfix              actions= 0 time=8 usec 
#wlc                  actions= 0 time=1 usec 
#garbagecollector     actions= 1 time=56 usec 
#total                actions=29 time=515 usec 
#rollback;

# 11:57:38 >  
# 11:57:38 >  "Done."
# 11:57:38 >  

