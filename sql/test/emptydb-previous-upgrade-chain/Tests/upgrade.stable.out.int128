Running database upgrade commands to update system tables.

Running database upgrade commands:
create function sys.generate_series(first hugeint, "limit" hugeint)
returns table (value hugeint)
external name generator.series;
create function sys.generate_series(first hugeint, "limit" hugeint, stepsize hugeint)
returns table (value hugeint)
external name generator.series;
create aggregate stddev_samp(val HUGEINT) returns DOUBLE
 external name "aggr"."stdev";
GRANT EXECUTE ON AGGREGATE stddev_samp(HUGEINT) TO PUBLIC;
create window stddev_samp(val HUGEINT) returns DOUBLE
 external name "sql"."stdev";
GRANT EXECUTE ON WINDOW stddev_samp(HUGEINT) TO PUBLIC;
create aggregate stddev_pop(val HUGEINT) returns DOUBLE
 external name "aggr"."stdevp";
GRANT EXECUTE ON AGGREGATE stddev_pop(HUGEINT) TO PUBLIC;
create window stddev_pop(val HUGEINT) returns DOUBLE
 external name "sql"."stdevp";
GRANT EXECUTE ON WINDOW stddev_pop(HUGEINT) TO PUBLIC;
create aggregate var_samp(val HUGEINT) returns DOUBLE
 external name "aggr"."variance";
GRANT EXECUTE ON AGGREGATE var_samp(HUGEINT) TO PUBLIC;
create window var_samp(val HUGEINT) returns DOUBLE
 external name "sql"."variance";
GRANT EXECUTE ON WINDOW var_samp(HUGEINT) TO PUBLIC;
create aggregate covar_samp(e1 HUGEINT, e2 HUGEINT) returns DOUBLE
 external name "aggr"."covariance";
GRANT EXECUTE ON AGGREGATE covar_samp(HUGEINT, HUGEINT) TO PUBLIC;
create window covar_samp(e1 HUGEINT, e2 HUGEINT) returns DOUBLE
 external name "sql"."covariance";
GRANT EXECUTE ON WINDOW covar_samp(HUGEINT, HUGEINT) TO PUBLIC;
create aggregate var_pop(val HUGEINT) returns DOUBLE
 external name "aggr"."variancep";
GRANT EXECUTE ON AGGREGATE var_pop(HUGEINT) TO PUBLIC;
create window var_pop(val HUGEINT) returns DOUBLE
 external name "sql"."variancep";
GRANT EXECUTE ON WINDOW var_pop(HUGEINT) TO PUBLIC;
create aggregate covar_pop(e1 HUGEINT, e2 HUGEINT) returns DOUBLE
 external name "aggr"."covariancep";
GRANT EXECUTE ON AGGREGATE covar_pop(HUGEINT, HUGEINT) TO PUBLIC;
create window covar_pop(e1 HUGEINT, e2 HUGEINT) returns DOUBLE
 external name "sql"."covariancep";
GRANT EXECUTE ON WINDOW covar_pop(HUGEINT, HUGEINT) TO PUBLIC;
create aggregate median(val HUGEINT) returns HUGEINT
 external name "aggr"."median";
GRANT EXECUTE ON AGGREGATE median(HUGEINT) TO PUBLIC;
create aggregate quantile(val HUGEINT, q DOUBLE) returns HUGEINT
 external name "aggr"."quantile";
GRANT EXECUTE ON AGGREGATE quantile(HUGEINT, DOUBLE) TO PUBLIC;
create aggregate median_avg(val HUGEINT) returns DOUBLE
 external name "aggr"."median_avg";
GRANT EXECUTE ON AGGREGATE median_avg(HUGEINT) TO PUBLIC;
create aggregate quantile_avg(val HUGEINT, q DOUBLE) returns DOUBLE
 external name "aggr"."quantile_avg";
GRANT EXECUTE ON AGGREGATE quantile_avg(HUGEINT, DOUBLE) TO PUBLIC;
create aggregate corr(e1 HUGEINT, e2 HUGEINT) returns DOUBLE
 external name "aggr"."corr";
GRANT EXECUTE ON AGGREGATE corr(HUGEINT, HUGEINT) TO PUBLIC;
create window corr(e1 HUGEINT, e2 HUGEINT) returns DOUBLE
 external name "sql"."corr";
GRANT EXECUTE ON WINDOW corr(HUGEINT, HUGEINT) TO PUBLIC;
create function json.filter(js json, name hugeint)
returns json external name json.filter;
GRANT EXECUTE ON FUNCTION json.filter(json, hugeint) TO PUBLIC;
update sys.functions set system = true where system <> true and name in ('generate_series') and schema_id = (select id from sys.schemas where name = 'sys') and type = 5;
update sys.functions set system = true where system <> true and name in ('stddev_samp', 'stddev_pop', 'var_samp', 'covar_samp', 'var_pop', 'covar_pop', 'median', 'median_avg', 'quantile', 'quantile_avg', 'corr') and schema_id = (select id from sys.schemas where name = 'sys') and type = 3;
update sys.functions set system = true where system <> true and name in ('stddev_samp', 'stddev_pop', 'var_samp', 'covar_samp', 'var_pop', 'covar_pop', 'corr') and schema_id = (select id from sys.schemas where name = 'sys') and type = 6;
update sys.functions set system = true where system <> true and name = 'filter' and schema_id = (select id from sys.schemas where name = 'json') and type = 1;

Running database upgrade commands:
drop procedure if exists SHPattach(string) cascade;
drop procedure if exists SHPload(integer) cascade;
drop procedure if exists SHPload(integer, geometry) cascade;

Running database upgrade commands:
create procedure SHPLoad(fname string, schemaname string, tablename string) external name shp.load;
create procedure SHPLoad(fname string, tablename string) external name shp.load;
update sys.functions set system = true where schema_id = 2000 and name in ('shpload');
Running database upgrade commands:
drop function if exists sys.st_intersects(geometry, geometry) cascade;
drop function if exists sys.st_dwithin(geometry, geometry, double) cascade;
drop view if exists sys.geometry_columns cascade;
drop function if exists sys.st_collect(geometry, geometry) cascade;
drop aggregate if exists sys.st_collect(geometry) cascade;
drop aggregate if exists sys.st_makeline(geometry) cascade;
create view sys.geometry_columns as
 select cast(null as varchar(1)) as f_table_catalog,
  s.name as f_table_schema,
  t.name as f_table_name,
  c.name as f_geometry_column,
  cast(has_z(c.type_digits) + has_m(c.type_digits) +2 as integer) as coord_dimension,
  c.type_scale as srid,
  get_type(c.type_digits, 0) as geometry_type
 from sys.columns c, sys.tables t, sys.schemas s
 where c.table_id = t.id and t.schema_id = s.id
  and c.type in (select sqlname from sys.types where systemname in ('wkb', 'wkba'));
GRANT SELECT ON sys.geometry_columns TO PUBLIC;
CREATE FUNCTION ST_Collect(geom1 Geometry, geom2 Geometry) RETURNS Geometry EXTERNAL NAME geom."Collect";
GRANT EXECUTE ON FUNCTION ST_Collect(Geometry, Geometry) TO PUBLIC;
CREATE AGGREGATE ST_Collect(geom Geometry) RETURNS Geometry external name aggr."Collect";
GRANT EXECUTE ON AGGREGATE ST_Collect(Geometry) TO PUBLIC;
CREATE FUNCTION ST_DistanceGeographic(geom1 Geometry, geom2 Geometry) RETURNS double EXTERNAL NAME geom."DistanceGeographic";
GRANT EXECUTE ON FUNCTION ST_DistanceGeographic(Geometry, Geometry) TO PUBLIC;
CREATE FILTER FUNCTION ST_DWithinGeographic(geom1 Geometry, geom2 Geometry, distance double) EXTERNAL NAME geom."DWithinGeographic";
GRANT EXECUTE ON FILTER ST_DWithinGeographic(Geometry, Geometry, double) TO PUBLIC;
CREATE FILTER FUNCTION ST_DWithin(geom1 Geometry, geom2 Geometry, distance double) EXTERNAL NAME rtree."DWithin";
GRANT EXECUTE ON FILTER ST_DWithin(Geometry, Geometry, double) TO PUBLIC;
CREATE FILTER FUNCTION ST_DWithin_NoIndex(geom1 Geometry, geom2 Geometry, distance double) EXTERNAL NAME geom."DWithin_noindex";
GRANT EXECUTE ON FILTER ST_DWithin_NoIndex(Geometry, Geometry, double) TO PUBLIC;
CREATE FUNCTION ST_DWithin2(geom1 Geometry, geom2 Geometry, bbox1 mbr, bbox2 mbr, dst double) RETURNS boolean EXTERNAL NAME geom."DWithin2";
GRANT EXECUTE ON FUNCTION ST_DWithin2(Geometry, Geometry, mbr, mbr, double) TO PUBLIC;
CREATE FILTER FUNCTION ST_IntersectsGeographic(geom1 Geometry, geom2 Geometry) EXTERNAL NAME geom."IntersectsGeographic";
GRANT EXECUTE ON FILTER ST_IntersectsGeographic(Geometry, Geometry) TO PUBLIC;
CREATE FILTER FUNCTION ST_Intersects(geom1 Geometry, geom2 Geometry) EXTERNAL NAME rtree."Intersects";
GRANT EXECUTE ON FILTER ST_Intersects(Geometry, Geometry) TO PUBLIC;
CREATE FILTER FUNCTION ST_Intersects_NoIndex(geom1 Geometry, geom2 Geometry) EXTERNAL NAME geom."Intersects_noindex";
GRANT EXECUTE ON FILTER ST_Intersects_NoIndex(Geometry, Geometry) TO PUBLIC;
CREATE AGGREGATE ST_MakeLine(geom Geometry) RETURNS Geometry external name aggr."MakeLine";
GRANT EXECUTE ON AGGREGATE ST_MakeLine(Geometry) TO PUBLIC;
update sys.functions set system = true where system <> true and schema_id = 2000 and name in ('st_collect', 'st_distancegeographic', 'st_dwithingeographic', 'st_dwithin', 'st_dwithin_noindex', 'st_dwithin2', 'st_intersectsgeographic', 'st_intersects', 'st_intersects_noindex', 'st_makeline');
update sys._tables set system = true where system <> true and schema_id = 2000 and name = 'geometry_columns';

Running database upgrade commands:
drop function sys.similarity(string, string) cascade;

Running database upgrade commands:
CREATE VIEW sys.describe_accessible_tables AS
 SELECT
 schemas.name AS schema,
 tables.name  AS table,
 tt.table_type_name AS table_type,
 pc.privilege_code_name AS privs,
 p.privileges AS privs_code
 FROM privileges p
 JOIN sys.roles ON p.auth_id = roles.id
 JOIN sys.tables ON p.obj_id = tables.id
 JOIN sys.table_types tt ON tables.type = tt.table_type_id
 JOIN sys.schemas ON tables.schema_id = schemas.id
 JOIN sys.privilege_codes pc ON p.privileges = pc.privilege_code_id
 WHERE roles.name = current_role;
GRANT SELECT ON sys.describe_accessible_tables TO PUBLIC;
update sys._tables set system = true where system <> true and schema_id = 2000 and name = 'describe_accessible_tables';
alter table sys.function_languages set read write;
delete from sys.function_languages where language_keyword like 'PYTHON%_MAP';
update sys.functions set language = language - 1 where language in (7, 11);
update sys.functions set mod = 'pyapi3' where mod in ('pyapi', 'pyapi3map');
commit;

Running database upgrade commands:
alter table sys.function_languages set read only;

Running database upgrade commands:
DROP FUNCTION IF EXISTS sys.dump_database(BOOLEAN) CASCADE;
DROP VIEW IF EXISTS sys.dump_comments CASCADE;
DROP VIEW IF EXISTS sys.describe_comments CASCADE;
CREATE VIEW sys.describe_comments AS
	SELECT o.id AS id, o.tpe AS tpe, o.nme AS fqn, cm.remark AS rem
	FROM (
		SELECT id, 'SCHEMA', sys.DQ(name) FROM sys.schemas WHERE NOT system
		UNION ALL
		SELECT t.id, ifthenelse(ts.table_type_name = 'VIEW', 'VIEW', 'TABLE'), sys.FQN(s.name, t.name)
		  FROM sys.schemas s JOIN sys._tables t ON s.id = t.schema_id JOIN sys.table_types ts ON t.type = ts.table_type_id
		 WHERE NOT t.system
		UNION ALL
		SELECT c.id, 'COLUMN', sys.FQN(s.name, t.name) || '.' || sys.DQ(c.name) FROM sys.columns c, sys._tables t, sys.schemas s WHERE NOT t.system AND c.table_id = t.id AND t.schema_id = s.id
		UNION ALL
		SELECT idx.id, 'INDEX', sys.FQN(s.name, idx.name) FROM sys.idxs idx, sys._tables t, sys.schemas s WHERE NOT t.system AND idx.table_id = t.id AND t.schema_id = s.id
		UNION ALL
		SELECT seq.id, 'SEQUENCE', sys.FQN(s.name, seq.name) FROM sys.sequences seq, sys.schemas s WHERE seq.schema_id = s.id
		UNION ALL
		SELECT f.id, ft.function_type_keyword, qf.nme FROM sys.functions f, sys.function_types ft, sys.schemas s, sys.fully_qualified_functions qf
		 WHERE NOT f.system AND f.type = ft.function_type_id AND f.schema_id = s.id AND qf.id = f.id
		) AS o(id, tpe, nme)
	JOIN sys.comments cm ON cm.id = o.id;
GRANT SELECT ON sys.describe_comments TO PUBLIC;
CREATE VIEW sys.dump_comments AS
  SELECT 'COMMENT ON ' || c.tpe || ' ' || c.fqn || ' IS ' || sys.SQ(c.rem) || ';' stmt FROM sys.describe_comments c;
CREATE FUNCTION sys.dump_database(describe BOOLEAN) RETURNS TABLE(o int, stmt STRING)
BEGIN
  SET SCHEMA sys;
  TRUNCATE sys.dump_statements;
  INSERT INTO sys.dump_statements VALUES (1, 'START TRANSACTION;');
  INSERT INTO sys.dump_statements VALUES (2, 'SET SCHEMA "sys";');
  INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_create_roles;
  INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_create_users;
  INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_create_schemas;
  INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_user_defined_types;
  INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_add_schemas_to_users;
  INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_grant_user_privileges;
  INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_sequences;
  --functions and table-likes can be interdependent. They should be inserted in the order of their catalogue id.
  INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(ORDER BY stmts.o), stmts.s
				    FROM (
				      SELECT f.o, f.stmt FROM sys.dump_functions f
				       UNION ALL
				      SELECT t.o, t.stmt FROM sys.dump_tables t
				    ) AS stmts(o, s);
  IF NOT DESCRIBE THEN
    CALL sys.dump_table_data();
  END IF;
  INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_start_sequences;
  INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_column_defaults;
  INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_table_constraint_type;
  INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_indices;
  INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_foreign_keys;
  INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_partition_tables;
  INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_triggers;
  INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_comments;
  INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_table_grants;
  INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_column_grants;
  INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_function_grants;
  INSERT INTO sys.dump_statements VALUES ((SELECT COUNT(*) FROM sys.dump_statements) + 1, 'COMMIT;');
  RETURN sys.dump_statements;
END;
update sys._tables set system = true where schema_id = 2000 and name in ('describe_comments','dump_comments');
update sys.functions set system = true where system <> true and schema_id = 2000 and name = 'dump_database' and type = 5;

Running database upgrade commands:
CREATE FUNCTION sys.sql_datatype(mtype varchar(999), digits integer, tscale integer, nameonly boolean, shortname boolean)
  RETURNS varchar(1024)
BEGIN
  RETURN
    CASE mtype
    WHEN 'char' THEN sys.ifthenelse(nameonly OR digits <= 1, sys.ifthenelse(shortname, 'CHAR', 'CHARACTER'), sys.ifthenelse(shortname, 'CHAR(', 'CHARACTER(') || digits || ')')
    WHEN 'varchar' THEN sys.ifthenelse(nameonly OR digits = 0, sys.ifthenelse(shortname, 'VARCHAR', 'CHARACTER VARYING'), sys.ifthenelse(shortname, 'VARCHAR(', 'CHARACTER VARYING(') || digits || ')')
    WHEN 'clob' THEN sys.ifthenelse(nameonly OR digits = 0, sys.ifthenelse(shortname, 'CLOB', 'CHARACTER LARGE OBJECT'), sys.ifthenelse(shortname, 'CLOB(', 'CHARACTER LARGE OBJECT(') || digits || ')')
    WHEN 'blob' THEN sys.ifthenelse(nameonly OR digits = 0, sys.ifthenelse(shortname, 'BLOB', 'BINARY LARGE OBJECT'), sys.ifthenelse(shortname, 'BLOB(', 'BINARY LARGE OBJECT(') || digits || ')')
    WHEN 'int' THEN 'INTEGER'
    WHEN 'bigint' THEN 'BIGINT'
    WHEN 'smallint' THEN 'SMALLINT'
    WHEN 'tinyint' THEN 'TINYINT'
    WHEN 'hugeint' THEN 'HUGEINT'
    WHEN 'boolean' THEN 'BOOLEAN'
    WHEN 'date' THEN 'DATE'
    WHEN 'time' THEN sys.ifthenelse(nameonly OR digits = 1, 'TIME', 'TIME(' || (digits -1) || ')')
    WHEN 'timestamp' THEN sys.ifthenelse(nameonly OR digits = 7, 'TIMESTAMP', 'TIMESTAMP(' || (digits -1) || ')')
    WHEN 'timestamptz' THEN sys.ifthenelse(nameonly OR digits = 7, 'TIMESTAMP WITH TIME ZONE', 'TIMESTAMP(' || (digits -1) || ') WITH TIME ZONE')
    WHEN 'timetz' THEN sys.ifthenelse(nameonly OR digits = 1, 'TIME WITH TIME ZONE', 'TIME(' || (digits -1) || ') WITH TIME ZONE')
    WHEN 'decimal' THEN sys.ifthenelse(nameonly OR digits = 0, 'DECIMAL', 'DECIMAL(' || digits || sys.ifthenelse(tscale = 0, '', ',' || tscale) || ')')
    WHEN 'double' THEN sys.ifthenelse(nameonly OR (digits = 53 AND tscale = 0), sys.ifthenelse(shortname, 'DOUBLE', 'DOUBLE PRECISION'), 'FLOAT(' || digits || ')')
    WHEN 'real' THEN sys.ifthenelse(nameonly OR (digits = 24 AND tscale = 0), 'REAL', 'FLOAT(' || digits || ')')
    WHEN 'day_interval' THEN 'INTERVAL DAY'
    WHEN 'month_interval' THEN CASE digits WHEN 1 THEN 'INTERVAL YEAR' WHEN 2 THEN 'INTERVAL YEAR TO MONTH' WHEN 3 THEN 'INTERVAL MONTH' END
    WHEN 'sec_interval' THEN
	CASE digits
	WHEN 4 THEN 'INTERVAL DAY'
	WHEN 5 THEN 'INTERVAL DAY TO HOUR'
	WHEN 6 THEN 'INTERVAL DAY TO MINUTE'
	WHEN 7 THEN 'INTERVAL DAY TO SECOND'
	WHEN 8 THEN 'INTERVAL HOUR'
	WHEN 9 THEN 'INTERVAL HOUR TO MINUTE'
	WHEN 10 THEN 'INTERVAL HOUR TO SECOND'
	WHEN 11 THEN 'INTERVAL MINUTE'
	WHEN 12 THEN 'INTERVAL MINUTE TO SECOND'
	WHEN 13 THEN 'INTERVAL SECOND'
	END
    WHEN 'oid' THEN 'OID'
    WHEN 'json' THEN sys.ifthenelse(nameonly OR digits = 0, 'JSON', 'JSON(' || digits || ')')
    WHEN 'url' THEN sys.ifthenelse(nameonly OR digits = 0, 'URL', 'URL(' || digits || ')')
    WHEN 'xml' THEN sys.ifthenelse(nameonly OR digits = 0, 'XML', 'XML(' || digits || ')')
    WHEN 'geometry' THEN
	sys.ifthenelse(nameonly, 'GEOMETRY',
	CASE digits
	WHEN 4 THEN 'GEOMETRY(POINT' || sys.ifthenelse(tscale = 0, ')', ',' || tscale || ')')
	WHEN 8 THEN 'GEOMETRY(LINESTRING' || sys.ifthenelse(tscale = 0, ')', ',' || tscale || ')')
	WHEN 16 THEN 'GEOMETRY(POLYGON' || sys.ifthenelse(tscale = 0, ')', ',' || tscale || ')')
	WHEN 20 THEN 'GEOMETRY(MULTIPOINT' || sys.ifthenelse(tscale = 0, ')', ',' || tscale || ')')
	WHEN 24 THEN 'GEOMETRY(MULTILINESTRING' || sys.ifthenelse(tscale = 0, ')', ',' || tscale || ')')
	WHEN 28 THEN 'GEOMETRY(MULTIPOLYGON' || sys.ifthenelse(tscale = 0, ')', ',' || tscale || ')')
	WHEN 32 THEN 'GEOMETRY(GEOMETRYCOLLECTION' || sys.ifthenelse(tscale = 0, ')', ',' || tscale || ')')
	ELSE 'GEOMETRY'
        END)
    ELSE sys.ifthenelse(mtype = lower(mtype), upper(mtype), '"' || mtype || '"') || sys.ifthenelse(nameonly OR digits = 0, '', '(' || digits || sys.ifthenelse(tscale = 0, '', ',' || tscale) || ')')
    END;
END;
GRANT EXECUTE ON FUNCTION sys.sql_datatype(varchar(999), integer, integer, boolean, boolean) TO PUBLIC;
update sys.functions set system = true where system <> true and schema_id = 2000 and name = 'sql_datatype' and type = 1 and language = 2;

Running database upgrade commands:
CREATE SCHEMA INFORMATION_SCHEMA;
COMMENT ON SCHEMA INFORMATION_SCHEMA IS 'ISO/IEC 9075-11 SQL/Schemata';
update sys.schemas set system = true where name = 'information_schema';
CREATE VIEW INFORMATION_SCHEMA.CHARACTER_SETS AS SELECT
  cast(NULL AS varchar(1)) AS CHARACTER_SET_CATALOG,
  cast(NULL AS varchar(1)) AS CHARACTER_SET_SCHEMA,
  cast('UTF-8' AS varchar(16)) AS CHARACTER_SET_NAME,
  cast('ISO/IEC 10646:2021' AS varchar(20)) AS CHARACTER_REPERTOIRE,
  cast('UTF-8' AS varchar(16)) AS FORM_OF_USE,
  cast(NULL AS varchar(1)) AS DEFAULT_COLLATE_CATALOG,
  cast(NULL AS varchar(1)) AS DEFAULT_COLLATE_SCHEMA,
  cast(NULL AS varchar(1)) AS DEFAULT_COLLATE_NAME;
GRANT SELECT ON TABLE INFORMATION_SCHEMA.CHARACTER_SETS TO PUBLIC WITH GRANT OPTION;
CREATE VIEW INFORMATION_SCHEMA.SCHEMATA AS SELECT
  cast(NULL AS varchar(1)) AS CATALOG_NAME,
  s."name" AS SCHEMA_NAME,
  a."name" AS SCHEMA_OWNER,
  cast(NULL AS varchar(1)) AS DEFAULT_CHARACTER_SET_CATALOG,
  cast(NULL AS varchar(1)) AS DEFAULT_CHARACTER_SET_SCHEMA,
  cast('UTF-8' AS varchar(16)) AS DEFAULT_CHARACTER_SET_NAME,
  cast(NULL AS varchar(1)) AS SQL_PATH,
  s."id" AS schema_id,
  s."system" AS is_system,
  cm."remark" AS comments
 FROM sys."schemas" s
 INNER JOIN sys."auths" a ON s."owner" = a."id"
 LEFT OUTER JOIN sys."comments" cm ON s."id" = cm."id"
 ORDER BY s."name";
GRANT SELECT ON TABLE INFORMATION_SCHEMA.SCHEMATA TO PUBLIC WITH GRANT OPTION;
CREATE VIEW INFORMATION_SCHEMA.TABLES AS SELECT
  cast(NULL AS varchar(1)) AS TABLE_CATALOG,
  s."name" AS TABLE_SCHEMA,
  t."name" AS TABLE_NAME,
  tt."table_type_name" AS TABLE_TYPE,
  cast(NULL AS varchar(1)) AS SELF_REFERENCING_COLUMN_NAME,
  cast(NULL AS varchar(1)) AS REFERENCE_GENERATION,
  cast(NULL AS varchar(1)) AS USER_DEFINED_TYPE_CATALOG,
  cast(NULL AS varchar(1)) AS USER_DEFINED_TYPE_SCHEMA,
  cast(NULL AS varchar(1)) AS USER_DEFINED_TYPE_NAME,
  cast(sys.ifthenelse((t."type" IN (0, 3, 7, 20, 30) AND t."access" IN (0, 2)), 'YES', 'NO') AS varchar(3)) AS IS_INSERTABLE_INTO,
  cast('NO' AS varchar(3)) AS IS_TYPED,
  cast((CASE t."commit_action" WHEN 1 THEN 'DELETE' WHEN 2 THEN 'PRESERVE' WHEN 3 THEN 'DROP' ELSE NULL END) AS varchar(10)) AS COMMIT_ACTION,
  t."schema_id" AS schema_id,
  t."id" AS table_id,
  t."type" AS table_type_id,
  st."count" AS row_count,
  t."system" AS is_system,
  sys.ifthenelse(t."type" IN (1, 11), TRUE, FALSE) AS is_view,
  t."query" AS query_def,
  cm."remark" AS comments
 FROM sys."tables" t
 INNER JOIN sys."schemas" s ON t."schema_id" = s."id"
 INNER JOIN sys."table_types" tt ON t."type" = tt."table_type_id"
 LEFT OUTER JOIN sys."comments" cm ON t."id" = cm."id"
 LEFT OUTER JOIN (SELECT DISTINCT "schema", "table", "count" FROM sys."statistics"()) st ON (s."name" = st."schema" AND t."name" = st."table")
 ORDER BY s."name", t."name";
GRANT SELECT ON TABLE INFORMATION_SCHEMA.TABLES TO PUBLIC WITH GRANT OPTION;
CREATE VIEW INFORMATION_SCHEMA.VIEWS AS SELECT
  cast(NULL AS varchar(1)) AS TABLE_CATALOG,
  s."name" AS TABLE_SCHEMA,
  t."name" AS TABLE_NAME,
  t."query" AS VIEW_DEFINITION,
  cast('NONE' AS varchar(10)) AS CHECK_OPTION,
  cast('NO' AS varchar(3)) AS IS_UPDATABLE,
  cast('NO' AS varchar(3)) AS INSERTABLE_INTO,
  cast('NO' AS varchar(3)) AS IS_TRIGGER_UPDATABLE,
  cast('NO' AS varchar(3)) AS IS_TRIGGER_DELETABLE,
  cast('NO' AS varchar(3)) AS IS_TRIGGER_INSERTABLE_INTO,
  t."schema_id" AS schema_id,
  t."id" AS table_id,
  cast(sys.ifthenelse(t."system", t."type" + 10 , t."type") AS smallint) AS table_type_id,
  t."system" AS is_system,
  cm."remark" AS comments
 FROM sys."_tables" t
 INNER JOIN sys."schemas" s ON t."schema_id" = s."id"
 LEFT OUTER JOIN sys."comments" cm ON t."id" = cm."id"
 WHERE t."type" = 1
 ORDER BY s."name", t."name";
GRANT SELECT ON TABLE INFORMATION_SCHEMA.VIEWS TO PUBLIC WITH GRANT OPTION;
CREATE VIEW INFORMATION_SCHEMA.COLUMNS AS SELECT
  cast(NULL AS varchar(1)) AS TABLE_CATALOG,
  s."name" AS TABLE_SCHEMA,
  t."name" AS TABLE_NAME,
  c."name" AS COLUMN_NAME,
  cast(1 + c."number" AS int) AS ORDINAL_POSITION,
  c."default" AS COLUMN_DEFAULT,
  cast(sys.ifthenelse(c."null", 'YES', 'NO') AS varchar(3)) AS IS_NULLABLE,
  cast(sys."sql_datatype"(c."type", c."type_digits", c."type_scale", true, true) AS varchar(1024)) AS DATA_TYPE,
  cast(sys.ifthenelse(c."type" IN ('varchar','clob','char','json','url','xml') AND c."type_digits" > 0, c."type_digits", NULL) AS int) AS CHARACTER_MAXIMUM_LENGTH,
  cast(sys.ifthenelse(c."type" IN ('varchar','clob','char','json','url','xml') AND c."type_digits" > 0, 4 * cast(c."type_digits" as bigint), NULL) AS bigint) AS CHARACTER_OCTET_LENGTH,
  cast(sys.ifthenelse(c."type" IN ('int','smallint','tinyint','bigint','hugeint','float','real','double','decimal','numeric','oid'), c."type_digits", NULL) AS int) AS NUMERIC_PRECISION,
  cast(sys.ifthenelse(c."type" IN ('int','smallint','tinyint','bigint','hugeint','float','real','double','oid'), 2, sys.ifthenelse(c."type" IN ('decimal','numeric'), 10, NULL)) AS int) AS NUMERIC_PRECISION_RADIX,
  cast(sys.ifthenelse(c."type" IN ('int','smallint','tinyint','bigint','hugeint','float','real','double','decimal','numeric','oid'), c."type_scale", NULL) AS int) AS NUMERIC_SCALE,
  cast(sys.ifthenelse(c."type" IN ('date','timestamp','timestamptz','time','timetz'), sys.ifthenelse(c."type_scale" > 0, c."type_scale" -1, 0), NULL) AS int) AS DATETIME_PRECISION,
  cast(sys.ifthenelse(c."type" IN ('day_interval','month_interval','sec_interval'), sys."sql_datatype"(c."type", c."type_digits", c."type_scale", true, true), NULL) AS varchar(40)) AS INTERVAL_TYPE,
  cast(CASE c."type" WHEN 'day_interval' THEN 0 WHEN 'month_interval' THEN 0 WHEN 'sec_interval' THEN (sys.ifthenelse(c."type_digits" IN (7, 10, 12, 13), sys.ifthenelse(c."type_scale" > 0, c."type_scale", 3), 0)) ELSE NULL END AS int) AS INTERVAL_PRECISION,
  cast(NULL AS varchar(1)) AS CHARACTER_SET_CATALOG,
  cast(NULL AS varchar(1)) AS CHARACTER_SET_SCHEMA,
  cast(sys.ifthenelse(c."type" IN ('varchar','clob','char','json','url','xml'), 'UTF-8', NULL) AS varchar(16)) AS CHARACTER_SET_NAME,
  cast(NULL AS varchar(1)) AS COLLATION_CATALOG,
  cast(NULL AS varchar(1)) AS COLLATION_SCHEMA,
  cast(NULL AS varchar(1)) AS COLLATION_NAME,
  cast(NULL AS varchar(1)) AS DOMAIN_CATALOG,
  cast(NULL AS varchar(1)) AS DOMAIN_SCHEMA,
  cast(NULL AS varchar(1)) AS DOMAIN_NAME,
  cast(NULL AS varchar(1)) AS UDT_CATALOG,
  cast(NULL AS varchar(1)) AS UDT_SCHEMA,
  cast(NULL AS varchar(1)) AS UDT_NAME,
  cast(NULL AS varchar(1)) AS SCOPE_CATALOG,
  cast(NULL AS varchar(1)) AS SCOPE_SCHEMA,
  cast(NULL AS varchar(1)) AS SCOPE_NAME,
  cast(NULL AS int) AS MAXIMUM_CARDINALITY,
  cast(NULL AS varchar(1)) AS DTD_IDENTIFIER,
  cast('NO' AS varchar(3)) AS IS_SELF_REFERENCING,
  cast(sys.ifthenelse(seq."name" IS NULL OR c."null", 'NO', 'YES') AS varchar(3)) AS IS_IDENTITY,
  seq."name" AS IDENTITY_GENERATION,
  seq."start" AS IDENTITY_START,
  seq."increment" AS IDENTITY_INCREMENT,
  seq."maxvalue" AS IDENTITY_MAXIMUM,
  seq."minvalue" AS IDENTITY_MINIMUM,
  cast(sys.ifthenelse(seq."name" IS NULL, NULL, sys.ifthenelse(seq."cycle", 'YES', 'NO')) AS varchar(3)) AS IDENTITY_CYCLE,
  cast(sys.ifthenelse(seq."name" IS NULL, 'NO', 'YES') AS varchar(3)) AS IS_GENERATED,
  cast(sys.ifthenelse(seq."name" IS NULL, NULL, c."default") AS varchar(1024)) AS GENERATION_EXPRESSION,
  cast('NO' AS varchar(3)) AS IS_SYSTEM_TIME_PERIOD_START,
  cast('NO' AS varchar(3)) AS IS_SYSTEM_TIME_PERIOD_END,
  cast('NO' AS varchar(3)) AS SYSTEM_TIME_PERIOD_TIMESTAMP_GENERATION,
  cast(sys.ifthenelse(t."type" IN (0,3,7,20,30), 'YES', 'NO') AS varchar(3)) AS IS_UPDATABLE,
  cast(NULL AS varchar(1)) AS DECLARED_DATA_TYPE,
  cast(NULL AS int) AS DECLARED_NUMERIC_PRECISION,
  cast(NULL AS int) AS DECLARED_NUMERIC_SCALE,
  t."schema_id" AS schema_id,
  c."table_id" AS table_id,
  c."id" AS column_id,
  seq."id" AS sequence_id,
  t."system" AS is_system,
  cm."remark" AS comments
 FROM sys."columns" c
 INNER JOIN sys."tables" t ON c."table_id" = t."id"
 INNER JOIN sys."schemas" s ON t."schema_id" = s."id"
 LEFT OUTER JOIN sys."comments" cm ON c."id" = cm."id"
 LEFT OUTER JOIN sys."sequences" seq ON ((seq."name"||'"') = substring(c."default", 3 + sys."locate"('"."seq_',c."default",14)))
 ORDER BY s."name", t."name", c."number";
GRANT SELECT ON TABLE INFORMATION_SCHEMA.COLUMNS TO PUBLIC WITH GRANT OPTION;
CREATE VIEW INFORMATION_SCHEMA.CHECK_CONSTRAINTS AS SELECT
  cast(NULL AS varchar(1)) AS CONSTRAINT_CATALOG,
  cast(NULL AS varchar(1024)) AS CONSTRAINT_SCHEMA,
  cast(NULL AS varchar(1024)) AS CONSTRAINT_NAME,
  cast(NULL AS varchar(1024)) AS CHECK_CLAUSE
 WHERE 1=0;
GRANT SELECT ON TABLE INFORMATION_SCHEMA.CHECK_CONSTRAINTS TO PUBLIC WITH GRANT OPTION;
CREATE VIEW INFORMATION_SCHEMA.TABLE_CONSTRAINTS AS SELECT
  cast(NULL AS varchar(1)) AS CONSTRAINT_CATALOG,
  s."name" AS CONSTRAINT_SCHEMA,
  k."name" AS CONSTRAINT_NAME,
  cast(NULL AS varchar(1)) AS TABLE_CATALOG,
  s."name" AS TABLE_SCHEMA,
  t."name" AS TABLE_NAME,
  cast(CASE k."type" WHEN 0 THEN 'PRIMARY KEY' WHEN 1 THEN 'UNIQUE' WHEN 2 THEN 'FOREIGN KEY' ELSE NULL END AS varchar(16)) AS CONSTRAINT_TYPE,
  cast('NO' AS varchar(3)) AS IS_DEFERRABLE,
  cast('NO' AS varchar(3)) AS INITIALLY_DEFERRED,
  cast('YES' AS varchar(3)) AS ENFORCED,
  t."schema_id" AS schema_id,
  t."id" AS table_id,
  k."id" AS key_id,
  k."type" AS key_type,
  t."system" AS is_system
 FROM (SELECT sk."id", sk."table_id", sk."name", sk."type" FROM sys."keys" sk UNION ALL SELECT tk."id", tk."table_id", tk."name", tk."type" FROM tmp."keys" tk) k
 INNER JOIN (SELECT st."id", st."schema_id", st."name", st."system" FROM sys."_tables" st UNION ALL SELECT tt."id", tt."schema_id", tt."name", tt."system" FROM tmp."_tables" tt) t ON k."table_id" = t."id"
 INNER JOIN sys."schemas" s ON t."schema_id" = s."id"
 ORDER BY s."name", t."name", k."name";
GRANT SELECT ON TABLE INFORMATION_SCHEMA.TABLE_CONSTRAINTS TO PUBLIC WITH GRANT OPTION;
CREATE VIEW INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS AS SELECT
  cast(NULL AS varchar(1)) AS CONSTRAINT_CATALOG,
  s."name" AS CONSTRAINT_SCHEMA,
  fk."name" AS CONSTRAINT_NAME,
  cast(NULL AS varchar(1)) AS UNIQUE_CONSTRAINT_CATALOG,
  uks."name" AS UNIQUE_CONSTRAINT_SCHEMA,
  uk."name" AS UNIQUE_CONSTRAINT_NAME,
  cast('FULL' AS varchar(7)) AS MATCH_OPTION,
  fk."update_action" AS UPDATE_RULE,
  fk."delete_action" AS DELETE_RULE,
  t."schema_id" AS fk_schema_id,
  t."id" AS fk_table_id,
  t."name" AS fk_table_name,
  fk."id" AS fk_key_id,
  ukt."schema_id" AS uc_schema_id,
  uk."table_id" AS uc_table_id,
  ukt."name" AS uc_table_name,
  uk."id" AS uc_key_id
 FROM sys."fkeys" fk
 INNER JOIN sys."tables" t ON t."id" = fk."table_id"
 INNER JOIN sys."schemas" s ON s."id" = t."schema_id"
 LEFT OUTER JOIN sys."keys" uk ON uk."id" = fk."rkey"
 LEFT OUTER JOIN sys."tables" ukt ON ukt."id" = uk."table_id"
 LEFT OUTER JOIN sys."schemas" uks ON uks."id" = ukt."schema_id"
 ORDER BY s."name", t."name", fk."name";
GRANT SELECT ON TABLE INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS TO PUBLIC WITH GRANT OPTION;
CREATE VIEW INFORMATION_SCHEMA.ROUTINES AS SELECT
  cast(NULL AS varchar(1)) AS SPECIFIC_CATALOG,
  s."name" AS SPECIFIC_SCHEMA,
  cast(f."name"||'('||f."id"||')' AS varchar(270)) AS SPECIFIC_NAME,
  cast(NULL AS varchar(1)) AS ROUTINE_CATALOG,
  s."name" AS ROUTINE_SCHEMA,
  f."name" AS ROUTINE_NAME,
  ft."function_type_keyword" AS ROUTINE_TYPE,
  cast(NULL AS varchar(1)) AS MODULE_CATALOG,
  cast(NULL AS varchar(1)) AS MODULE_SCHEMA,
  cast(f."mod" AS varchar(128)) AS MODULE_NAME,
  cast(NULL AS varchar(1)) AS UDT_CATALOG,
  cast(NULL AS varchar(1)) AS UDT_SCHEMA,
  cast(NULL AS varchar(1)) AS UDT_NAME,
  cast(CASE f."type" WHEN 1 THEN sys."sql_datatype"(a."type", a."type_digits", a."type_scale", true, true) WHEN 2 THEN NULL WHEN 5 THEN 'TABLE' WHEN 7 THEN 'TABLE' ELSE NULL END AS varchar(1024)) AS DATA_TYPE,
  cast(sys.ifthenelse(a."type" IN ('varchar','clob','char','json','url','xml') AND a."type_digits" > 0, a."type_digits", NULL) AS int) AS CHARACTER_MAXIMUM_LENGTH,
  cast(sys.ifthenelse(a."type" IN ('varchar','clob','char','json','url','xml') AND a."type_digits" > 0, 4 * cast(a."type_digits" as bigint), NULL) AS bigint) AS CHARACTER_OCTET_LENGTH,
  cast(NULL AS varchar(1)) AS CHARACTER_SET_CATALOG,
  cast(NULL AS varchar(1)) AS CHARACTER_SET_SCHEMA,
  'UTF-8' AS CHARACTER_SET_NAME,
  cast(NULL AS varchar(1)) AS COLLATION_CATALOG,
  cast(NULL AS varchar(1)) AS COLLATION_SCHEMA,
  cast(NULL AS varchar(1)) AS COLLATION_NAME,
  cast(sys.ifthenelse(a."type" IN ('int','smallint','tinyint','bigint','hugeint','float','real','double','decimal','numeric','oid'), a."type_digits", NULL) AS int) AS NUMERIC_PRECISION,
  cast(sys.ifthenelse(a."type" IN ('int','smallint','tinyint','bigint','hugeint','float','real','double','oid'), 2, sys.ifthenelse(a."type" IN ('decimal','numeric'), 10, NULL)) AS int) AS NUMERIC_PRECISION_RADIX,
  cast(sys.ifthenelse(a."type" IN ('int','smallint','tinyint','bigint','hugeint','float','real','double','decimal','numeric','oid'), a."type_scale", NULL) AS int) AS NUMERIC_SCALE,
  cast(sys.ifthenelse(a."type" IN ('date','timestamp','timestamptz','time','timetz'), a."type_scale" -1, NULL) AS int) AS DATETIME_PRECISION,
  cast(sys.ifthenelse(a."type" IN ('day_interval','month_interval','sec_interval'), sys."sql_datatype"(a."type", a."type_digits", a."type_scale", true, true), NULL) AS varchar(40)) AS INTERVAL_TYPE,
  cast(CASE a."type" WHEN 'day_interval' THEN 0 WHEN 'month_interval' THEN 0 WHEN 'sec_interval' THEN (sys.ifthenelse(a."type_digits" IN (7, 10, 12, 13), sys.ifthenelse(a."type_scale" > 0, a."type_scale", 3), 0)) ELSE NULL END AS int) AS INTERVAL_PRECISION,
  cast(NULL AS varchar(1)) AS TYPE_UDT_CATALOG,
  cast(NULL AS varchar(1)) AS TYPE_UDT_SCHEMA,
  cast(NULL AS varchar(1)) AS TYPE_UDT_NAME,
  cast(NULL AS varchar(1)) AS SCOPE_CATALOG,
  cast(NULL AS varchar(1)) AS SCOPE_SCHEMA,
  cast(NULL AS varchar(1)) AS SCOPE_NAME,
  cast(NULL AS int) AS MAXIMUM_CARDINALITY,
  cast(NULL AS int) AS DTD_IDENTIFIER,
  cast(sys."ifthenelse"(sys."locate"('begin',f."func") > 0, sys."ifthenelse"(sys."endswith"(f."func",';'), sys."substring"(f."func", sys."locate"('begin',f."func"), sys."length"(sys."substring"(f."func", sys."locate"('begin',f."func")))-1), sys."substring"(f."func", sys."locate"('begin',f."func"))), NULL) AS varchar(8196)) AS ROUTINE_BODY,
  f."func" AS ROUTINE_DEFINITION,
  cast(sys."ifthenelse"(sys."locate"('external name',f."func") > 0, sys."ifthenelse"(sys."endswith"(f."func",';'), sys."substring"(f."func", 14 + sys."locate"('external name',f."func"), sys."length"(sys."substring"(f."func", 14 + sys."locate"('external name',f."func")))-1), sys."substring"(f."func", 14 + sys."locate"('external name',f."func"))), NULL) AS varchar(1024)) AS EXTERNAL_NAME,
  fl."language_keyword" AS EXTERNAL_LANGUAGE,
  'GENERAL' AS PARAMETER_STYLE,
  'YES' AS IS_DETERMINISTIC,
  cast(sys.ifthenelse(f."side_effect", 'MODIFIES', 'READ') AS varchar(10)) AS SQL_DATA_ACCESS,
  cast(CASE f."type" WHEN 2 THEN NULL ELSE 'NO' END AS varchar(3)) AS IS_NULL_CALL,
  cast(NULL AS varchar(1)) AS SQL_PATH,
  cast(NULL AS varchar(1)) AS SCHEMA_LEVEL_ROUTINE,
  cast(NULL AS int) AS MAX_DYNAMIC_RESULT_SETS,
  cast(NULL AS varchar(1)) AS IS_USER_DEFINED_CAST,
  cast(NULL AS varchar(1)) AS IS_IMPLICITLY_INVOCABLE,
  cast(NULL AS varchar(1)) AS SECURITY_TYPE,
  cast(NULL AS varchar(1)) AS TO_SQL_SPECIFIC_CATALOG,
  cast(NULL AS varchar(1)) AS TO_SQL_SPECIFIC_SCHEMA,
  cast(NULL AS varchar(1)) AS TO_SQL_SPECIFIC_NAME,
  cast(NULL AS varchar(1)) AS AS_LOCATOR,
  cast(NULL AS timestamp) AS CREATED,
  cast(NULL AS timestamp) AS LAST_ALTERED,
  cast(NULL AS varchar(1)) AS NEW_SAVEPOINT_LEVEL,
  cast(NULL AS varchar(1)) AS IS_UDT_DEPENDENT,
  cast(NULL AS varchar(1)) AS RESULT_CAST_FROM_DATA_TYPE,
  cast(NULL AS varchar(1)) AS RESULT_CAST_AS_LOCATOR,
  cast(NULL AS int) AS RESULT_CAST_CHAR_MAX_LENGTH,
  cast(NULL AS int) AS RESULT_CAST_CHAR_OCTET_LENGTH,
  cast(NULL AS varchar(1)) AS RESULT_CAST_CHAR_SET_CATALOG,
  cast(NULL AS varchar(1)) AS RESULT_CAST_CHAR_SET_SCHEMA,
  cast(NULL AS varchar(1)) AS RESULT_CAST_CHARACTER_SET_NAME,
  cast(NULL AS varchar(1)) AS RESULT_CAST_COLLATION_CATALOG,
  cast(NULL AS varchar(1)) AS RESULT_CAST_COLLATION_SCHEMA,
  cast(NULL AS varchar(1)) AS RESULT_CAST_COLLATION_NAME,
  cast(NULL AS int) AS RESULT_CAST_NUMERIC_PRECISION,
  cast(NULL AS int) AS RESULT_CAST_NUMERIC_RADIX,
  cast(NULL AS int) AS RESULT_CAST_NUMERIC_SCALE,
  cast(NULL AS int) AS RESULT_CAST_DATETIME_PRECISION,
  cast(NULL AS varchar(1)) AS RESULT_CAST_INTERVAL_TYPE,
  cast(NULL AS int) AS RESULT_CAST_INTERVAL_PRECISION,
  cast(NULL AS varchar(1)) AS RESULT_CAST_TYPE_UDT_CATALOG,
  cast(NULL AS varchar(1)) AS RESULT_CAST_TYPE_UDT_SCHEMA,
  cast(NULL AS varchar(1)) AS RESULT_CAST_TYPE_UDT_NAME,
  cast(NULL AS varchar(1)) AS RESULT_CAST_SCOPE_CATALOG,
  cast(NULL AS varchar(1)) AS RESULT_CAST_SCOPE_SCHEMA,
  cast(NULL AS varchar(1)) AS RESULT_CAST_SCOPE_NAME,
  cast(NULL AS int) AS RESULT_CAST_MAX_CARDINALITY,
  cast(NULL AS varchar(1)) AS RESULT_CAST_DTD_IDENTIFIER,
  cast(NULL AS varchar(1)) AS DECLARED_DATA_TYPE,
  cast(NULL AS int) AS DECLARED_NUMERIC_PRECISION,
  cast(NULL AS int) AS DECLARED_NUMERIC_SCALE,
  cast(NULL AS varchar(1)) AS RESULT_CAST_FROM_DECLARED_DATA_TYPE,
  cast(NULL AS int) AS RESULT_CAST_DECLARED_NUMERIC_PRECISION,
  cast(NULL AS int) AS RESULT_CAST_DECLARED_NUMERIC_SCALE,
  f."schema_id" AS schema_id,
  f."id" AS function_id,
  f."type" AS function_type,
  f."language" AS function_language,
  f."system" AS is_system,
  cm."remark" AS comments
 FROM sys."functions" f
 INNER JOIN sys."schemas" s ON s."id" = f."schema_id"
 INNER JOIN sys."function_types" ft ON ft."function_type_id" = f."type"
 INNER JOIN sys."function_languages" fl ON fl."language_id" = f."language"
 LEFT OUTER JOIN sys."args" a ON a."func_id" = f."id" and a."inout" = 0 and a."number" = 0
 LEFT OUTER JOIN sys."comments" cm ON cm."id" = f."id"
 WHERE f."type" in (1, 2, 5, 7)
 ORDER BY s."name", f."name";
GRANT SELECT ON TABLE INFORMATION_SCHEMA.ROUTINES TO PUBLIC WITH GRANT OPTION;
CREATE VIEW INFORMATION_SCHEMA.PARAMETERS AS SELECT
  cast(NULL AS varchar(1)) AS SPECIFIC_CATALOG,
  s."name" AS SPECIFIC_SCHEMA,
  cast(f."name"||'('||f."id"||')' AS varchar(270)) AS SPECIFIC_NAME,
  cast(sys.ifthenelse((a."inout" = 0 OR f."type" = 2), 1 + a."number", sys.ifthenelse(f."type" = 1, a."number", (1 + a."number" - f.count_out_cols))) AS int) AS ORDINAL_POSITION,
  cast(sys.ifthenelse(a."inout" = 0, 'OUT', sys.ifthenelse(a."inout" = 1, 'IN', 'INOUT')) as varchar(5)) AS PARAMETER_MODE,
  cast(sys.ifthenelse(a."inout" = 0, 'YES', 'NO') as varchar(3)) AS IS_RESULT,
  cast(NULL AS varchar(1)) AS AS_LOCATOR,
  a."name" AS PARAMETER_NAME,
  cast(NULL AS varchar(1)) AS FROM_SQL_SPECIFIC_CATALOG,
  cast(NULL AS varchar(1)) AS FROM_SQL_SPECIFIC_SCHEMA,
  cast(NULL AS varchar(1)) AS FROM_SQL_SPECIFIC_NAME,
  cast(NULL AS varchar(1)) AS TO_SQL_SPECIFIC_CATALOG,
  cast(NULL AS varchar(1)) AS TO_SQL_SPECIFIC_SCHEMA,
  cast(NULL AS varchar(1)) AS TO_SQL_SPECIFIC_NAME,
  cast(sys."sql_datatype"(a."type", a."type_digits", a."type_scale", true, true) AS varchar(1024)) AS DATA_TYPE,
  cast(sys.ifthenelse(a."type" IN ('varchar','clob','char','json','url','xml') AND a."type_digits" > 0, a."type_digits", NULL) AS int) AS CHARACTER_MAXIMUM_LENGTH,
  cast(sys.ifthenelse(a."type" IN ('varchar','clob','char','json','url','xml') AND a."type_digits" > 0, 4 * cast(a."type_digits" as bigint), NULL) AS bigint) AS CHARACTER_OCTET_LENGTH,
  cast(NULL AS varchar(1)) AS CHARACTER_SET_CATALOG,
  cast(NULL AS varchar(1)) AS CHARACTER_SET_SCHEMA,
  cast(sys.ifthenelse(a."type" IN ('varchar','clob','char','json','url','xml'), 'UTF-8', NULL) AS varchar(16)) AS CHARACTER_SET_NAME,
  cast(NULL AS varchar(1)) AS COLLATION_CATALOG,
  cast(NULL AS varchar(1)) AS COLLATION_SCHEMA,
  cast(NULL AS varchar(1)) AS COLLATION_NAME,
  cast(sys.ifthenelse(a."type" IN ('int','smallint','tinyint','bigint','hugeint','float','real','double','decimal','numeric','oid'), a."type_digits", NULL) AS int) AS NUMERIC_PRECISION,
  cast(sys.ifthenelse(a."type" IN ('int','smallint','tinyint','bigint','hugeint','float','real','double','oid'), 2, sys.ifthenelse(a."type" IN ('decimal','numeric'), 10, NULL)) AS int) AS NUMERIC_PRECISION_RADIX,
  cast(sys.ifthenelse(a."type" IN ('int','smallint','tinyint','bigint','hugeint','float','real','double','decimal','numeric','oid'), a."type_scale", NULL) AS int) AS NUMERIC_SCALE,
  cast(sys.ifthenelse(a."type" IN ('date','timestamp','timestamptz','time','timetz'), sys.ifthenelse(a."type_scale" > 0, a."type_scale" -1, 0), NULL) AS int) AS DATETIME_PRECISION,
  cast(sys.ifthenelse(a."type" IN ('day_interval','month_interval','sec_interval'), sys."sql_datatype"(a."type", a."type_digits", a."type_scale", true, true), NULL) AS varchar(40)) AS INTERVAL_TYPE,
  cast(CASE a."type" WHEN 'day_interval' THEN 0 WHEN 'month_interval' THEN 0 WHEN 'sec_interval' THEN (sys.ifthenelse(a."type_digits" IN (7, 10, 12, 13), sys.ifthenelse(a."type_scale" > 0, a."type_scale", 3), 0)) ELSE NULL END AS int) AS INTERVAL_PRECISION,
  cast(NULL AS varchar(1)) AS UDT_CATALOG,
  cast(NULL AS varchar(1)) AS UDT_SCHEMA,
  cast(NULL AS varchar(1)) AS UDT_NAME,
  cast(NULL AS varchar(1)) AS SCOPE_CATALOG,
  cast(NULL AS varchar(1)) AS SCOPE_SCHEMA,
  cast(NULL AS varchar(1)) AS SCOPE_NAME,
  cast(NULL AS int) AS MAXIMUM_CARDINALITY,
  cast(NULL AS varchar(1)) AS DTD_IDENTIFIER,
  cast(NULL AS varchar(1)) AS DECLARED_DATA_TYPE,
  cast(NULL AS int) AS DECLARED_NUMERIC_PRECISION,
  cast(NULL AS int) AS DECLARED_NUMERIC_SCALE,
  cast(NULL AS varchar(1)) AS PARAMETER_DEFAULT,
  f."schema_id" AS schema_id,
  f."id" AS function_id,
  a."id" AS arg_id,
  f."name" AS function_name,
  f."type" AS function_type,
  f."system" AS is_system
 FROM sys."args" a
 INNER JOIN (SELECT fun.*, (select count(*) from sys.args a0 where a0.inout = 0 and a0.func_id = fun.id) as count_out_cols FROM sys."functions" fun WHERE fun."type" in (1, 2, 5, 7)) f ON f."id" = a."func_id"
 INNER JOIN sys."schemas" s ON s."id" = f."schema_id"
 ORDER BY s."name", f."name", f."id", a."inout" DESC, a."number";
GRANT SELECT ON TABLE INFORMATION_SCHEMA.PARAMETERS TO PUBLIC WITH GRANT OPTION;
CREATE VIEW INFORMATION_SCHEMA.SEQUENCES AS SELECT
  cast(NULL AS varchar(1)) AS SEQUENCE_CATALOG,
  s."name" AS SEQUENCE_SCHEMA,
  sq."name" AS SEQUENCE_NAME,
  cast('BIGINT' AS varchar(16)) AS DATA_TYPE,
  cast(64 AS SMALLINT) AS NUMERIC_PRECISION,
  cast(2 AS SMALLINT) AS NUMERIC_PRECISION_RADIX,
  cast(0 AS SMALLINT) AS NUMERIC_SCALE,
  sq."start" AS START_VALUE,
  sq."minvalue" AS MINIMUM_VALUE,
  sq."maxvalue" AS MAXIMUM_VALUE,
  sq."increment" AS INCREMENT,
  cast(sys.ifthenelse(sq."cycle", 'YES', 'NO') AS varchar(3)) AS CYCLE_OPTION,
  cast(NULL AS varchar(16)) AS DECLARED_DATA_TYPE,
  cast(NULL AS SMALLINT) AS DECLARED_NUMERIC_PRECISION,
  cast(NULL AS SMALLINT) AS DECLARED_NUMERIC_SCALE,
  sq."schema_id" AS schema_id,
  sq."id" AS sequence_id,
  get_value_for(s."name", sq."name") AS current_value,
  sq."cacheinc" AS cacheinc,
  cm."remark" AS comments
 FROM sys."sequences" sq
 INNER JOIN sys."schemas" s ON sq."schema_id" = s."id"
 LEFT OUTER JOIN sys."comments" cm ON sq."id" = cm."id"
 ORDER BY s."name", sq."name";
GRANT SELECT ON TABLE INFORMATION_SCHEMA.SEQUENCES TO PUBLIC WITH GRANT OPTION;

update sys._tables set system = true where system <> true
 and schema_id = (select s.id from sys.schemas s where s.name = 'information_schema')
 and name in ('character_sets','check_constraints','columns','parameters','routines','schemata','sequences','referential_constraints','table_constraints','tables','views');

Running database upgrade commands:
CREATE FUNCTION sys.persist_unlogged(sname STRING, tname STRING)
RETURNS TABLE("table" STRING, "table_id" INT, "rowcount" BIGINT)
EXTERNAL NAME sql.persist_unlogged;
GRANT EXECUTE ON FUNCTION sys.persist_unlogged(string, string) TO PUBLIC;
UPDATE sys.functions SET system = true WHERE system <> true AND
name = 'persist_unlogged' AND schema_id = 2000 AND type = 5 AND language = 1;

Running database upgrade commands:
drop function json.isvalid(json);
create function json.isvalid(js json)
returns bool begin return case when js is NULL then NULL else true end; end;
GRANT EXECUTE ON FUNCTION json.isvalid(json) TO PUBLIC;
update sys.functions set system = true where system <> true and name = 'isvalid' and schema_id = (select id from sys.schemas where name = 'json');

