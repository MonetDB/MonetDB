statement ok
CREATE SEQUENCE "information_schema sequences.test"

query TTTTIIIIIIITTII rowsort
SELECT
  SEQUENCE_CATALOG,
  SEQUENCE_SCHEMA,
  SEQUENCE_NAME,
  DATA_TYPE,
  NUMERIC_PRECISION,
  NUMERIC_PRECISION_RADIX,
  NUMERIC_SCALE,
  START_VALUE,
  MINIMUM_VALUE,
  MAXIMUM_VALUE,
  INCREMENT,
  CYCLE_OPTION,
  DECLARED_DATA_TYPE,
  DECLARED_NUMERIC_PRECISION,
  DECLARED_NUMERIC_SCALE
FROM INFORMATION_SCHEMA.SEQUENCES
WHERE SEQUENCE_SCHEMA = CURRENT_SCHEMA AND SEQUENCE_NAME = 'information_schema sequences.test'
----
NULL
sys
information_schema sequences.test
BIGINT
64
2
0
1
0
9223372036854775807
1
NO
NULL
NULL
NULL

-- check for NULL and empty string value violations on NOT NULL columns
query TTTTIIIIIIITTIIIIIIT rowsort
SELECT
  SEQUENCE_CATALOG,
  SEQUENCE_SCHEMA,
  SEQUENCE_NAME,
  DATA_TYPE,
  NUMERIC_PRECISION,
  NUMERIC_PRECISION_RADIX,
  NUMERIC_SCALE,
  START_VALUE,
  MINIMUM_VALUE,
  MAXIMUM_VALUE,
  INCREMENT,
  CYCLE_OPTION,
  DECLARED_DATA_TYPE,
  DECLARED_NUMERIC_PRECISION,
  DECLARED_NUMERIC_SCALE,
  schema_id,
  sequence_id,
  current_value,
  cacheinc,
  comments
FROM INFORMATION_SCHEMA.SEQUENCES
WHERE SEQUENCE_SCHEMA IS NULL
   OR SEQUENCE_SCHEMA = ''
   OR SEQUENCE_NAME IS NULL
   OR SEQUENCE_NAME = ''
   OR DATA_TYPE IS NULL
   OR DATA_TYPE = ''
   OR schema_id IS NULL
   OR sequence_id IS NULL
----

-- entity integrity checks
query ITTT rowsort
SELECT COUNT(*) AS duplicates, SEQUENCE_CATALOG, SEQUENCE_SCHEMA, SEQUENCE_NAME
 FROM INFORMATION_SCHEMA.SEQUENCES
 GROUP BY SEQUENCE_CATALOG, SEQUENCE_SCHEMA, SEQUENCE_NAME
 HAVING COUNT(*) > 1
----

-- as SEQUENCE_CATALOG is always NULL the SEQUENCE_SCHEMA, SEQUENCE_NAME combo should be unique also
query ITT rowsort
SELECT COUNT(*) AS duplicates, SEQUENCE_SCHEMA, SEQUENCE_NAME
 FROM INFORMATION_SCHEMA.SEQUENCES
 GROUP BY SEQUENCE_SCHEMA, SEQUENCE_NAME
 HAVING COUNT(*) > 1
----

-- it should also be unique when using schema_id instead of SEQUENCE_SCHEMA
query IIT rowsort
SELECT COUNT(*) AS duplicates, schema_id, SEQUENCE_NAME
 FROM INFORMATION_SCHEMA.SEQUENCES
 GROUP BY schema_id, SEQUENCE_NAME
 HAVING COUNT(*) > 1
----

-- sequence_id alone should be unique also
query II rowsort
SELECT COUNT(*) AS duplicates, sequence_id
 FROM INFORMATION_SCHEMA.SEQUENCES
 GROUP BY sequence_id
 HAVING COUNT(*) > 1
----

-- referential integrity checks
query TTT rowsort
SELECT SEQUENCE_CATALOG, SEQUENCE_SCHEMA, SEQUENCE_NAME
 FROM INFORMATION_SCHEMA.SEQUENCES
 WHERE (SEQUENCE_CATALOG, SEQUENCE_SCHEMA)
 NOT IN (SELECT CATALOG_NAME, SCHEMA_NAME FROM INFORMATION_SCHEMA.SCHEMATA)
----

-- as TABLE_CATALOG is always NULL leave it out of the check
query TT rowsort
SELECT SEQUENCE_SCHEMA, SEQUENCE_NAME
 FROM INFORMATION_SCHEMA.SEQUENCES
 WHERE (SEQUENCE_SCHEMA)
 NOT IN (SELECT SCHEMA_NAME FROM INFORMATION_SCHEMA.SCHEMATA)
----

-- it should also be correct when using schema_id instead of TABLE_SCHEMA
query ITT rowsort
SELECT schema_id, SEQUENCE_SCHEMA, SEQUENCE_NAME
 FROM INFORMATION_SCHEMA.SEQUENCES
 WHERE (schema_id)
 NOT IN (SELECT schema_id FROM INFORMATION_SCHEMA.SCHEMATA)
----

-- check schema_id reference
query TTI rowsort
SELECT SEQUENCE_SCHEMA, SEQUENCE_NAME, schema_id
 FROM INFORMATION_SCHEMA.SEQUENCES
 WHERE (schema_id) NOT IN (SELECT id FROM sys.schemas)
----

-- check sequence_id reference
query TTI rowsort
SELECT SEQUENCE_SCHEMA, SEQUENCE_NAME, sequence_id
 FROM INFORMATION_SCHEMA.SEQUENCES
 WHERE (sequence_id) NOT IN (SELECT id FROM sys.sequences)
----

-- check CYCLE_OPTION allowed values
query TTT rowsort
SELECT SEQUENCE_SCHEMA, SEQUENCE_NAME, CYCLE_OPTION
 FROM INFORMATION_SCHEMA.SEQUENCES
 WHERE (CYCLE_OPTION) NOT IN ('NO', 'YES')
----

statement ok
DROP sequence "information_schema sequences.test"

