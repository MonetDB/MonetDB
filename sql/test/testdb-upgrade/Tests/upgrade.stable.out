Running database upgrade commands:
create type inet4 external name inet4;
create type inet6 external name inet6;
create function contains(ip1 inet4, ip2 inet4, netmask tinyint)
 returns bool external name "inet46"."inet4containsinet4";
create function contains(ip1 inet4, netmask1 tinyint, ip2 inet4, netmask2 tinyint)
 returns bool external name "inet46"."inet4containsinet4";
create function containsorequal(ip1 inet4, ip2 inet4, netmask tinyint)
 returns bool external name "inet46"."inet4containsorequalinet4";
create function containsorequal(ip1 inet4, netmask1 tinyint, ip2 inet4, netmask2 tinyint)
 returns bool external name "inet46"."inet4containsorequalinet4";
create function containssymmetric(ip1 inet4, netmask1 tinyint, ip2 inet4, netmask2 tinyint)
 returns bool external name "inet46"."inet4containssymmetricinet4";
create function contains(ip1 inet6, ip2 inet6, netmask smallint)
 returns bool external name "inet46"."inet6containsinet6";
create function contains(ip1 inet6, netmask1 smallint, ip2 inet6, netmask2 smallint)
 returns bool external name "inet46"."inet6containsinet6";
create function containsorequal(ip1 inet6, ip2 inet6, netmask smallint)
 returns bool external name "inet46"."inet6containsorequalinet6";
create function containsorequal(ip1 inet6, netmask1 smallint, ip2 inet6, netmask2 smallint)
 returns bool external name "inet46"."inet6containsorequalinet6";
create function containssymmetric(ip1 inet6, netmask1 smallint, ip2 inet6, netmask2 smallint)
 returns bool external name "inet46"."inet6containssymmetricinet6";
create function bit_not(ip1 inet4)
 returns inet4 external name "calc"."not";
create function bit_and(ip1 inet4, ip2 inet4)
 returns inet4 external name "calc"."and";
create function bit_or(ip1 inet4, ip2 inet4)
 returns inet4 external name "calc"."or";
create function bit_xor(ip1 inet4, ip2 inet4)
 returns inet4 external name "calc"."xor";
create function bit_not(ip1 inet6)
 returns inet6 external name "calc"."not";
create function bit_and(ip1 inet6, ip2 inet6)
 returns inet6 external name "calc"."and";
create function bit_or(ip1 inet6, ip2 inet6)
 returns inet6 external name "calc"."or";
create function bit_xor(ip1 inet6, ip2 inet6)
 returns inet6 external name "calc"."xor";
grant execute on function contains(inet4, inet4, tinyint) to public;
grant execute on function contains(inet4, tinyint, inet4, tinyint) to public;
grant execute on function containsorequal(inet4, inet4, tinyint) to public;
grant execute on function containsorequal(inet4, tinyint, inet4, tinyint) to public;
grant execute on function containssymmetric(inet4, tinyint, inet4, tinyint) to public;
grant execute on function contains(inet6, inet6, smallint) to public;
grant execute on function contains(inet6, smallint, inet6, smallint) to public;
grant execute on function containsorequal(inet6, inet6, smallint) to public;
grant execute on function containsorequal(inet6, smallint, inet6, smallint) to public;
grant execute on function containssymmetric(inet6, smallint, inet6, smallint) to public;
grant execute on function bit_not(inet4) to public;
grant execute on function bit_and(inet4, inet4) to public;
grant execute on function bit_or(inet4, inet4) to public;
grant execute on function bit_xor(inet4, inet4) to public;
grant execute on function bit_not(inet6) to public;
grant execute on function bit_and(inet6, inet6) to public;
grant execute on function bit_or(inet6, inet6) to public;
grant execute on function bit_xor(inet6, inet6) to public;
drop view sys.dependencies_vw cascade;
drop view sys.ids cascade;
CREATE VIEW sys.ids (id, name, schema_id, table_id, table_name, obj_type, sys_table, system) AS
SELECT id, name, cast(null as int) as schema_id, cast(null as int) as table_id, cast(null as varchar(124)) as table_name, 'author' AS obj_type, 'sys.auths' AS sys_table, (name in ('public','sysadmin','monetdb','.snapshot')) AS system FROM sys.auths UNION ALL
SELECT id, name, cast(null as int) as schema_id, cast(null as int) as table_id, cast(null as varchar(124)) as table_name, ifthenelse(system, 'system schema', 'schema'), 'sys.schemas', system FROM sys.schemas UNION ALL
SELECT t.id, name, t.schema_id, t.id as table_id, t.name as table_name, cast(lower(tt.table_type_name) as varchar(40)), 'sys.tables', t.system FROM sys.tables t left outer join sys.table_types tt on t.type = tt.table_type_id UNION ALL
SELECT c.id, c.name, t.schema_id, c.table_id, t.name as table_name, ifthenelse(t.system, 'system column', 'column'), 'sys._columns', t.system FROM sys._columns c JOIN sys._tables t ON c.table_id = t.id UNION ALL
SELECT c.id, c.name, t.schema_id, c.table_id, t.name as table_name, 'column', 'tmp._columns', t.system FROM tmp._columns c JOIN tmp._tables t ON c.table_id = t.id UNION ALL
SELECT k.id, k.name, t.schema_id, k.table_id, t.name as table_name, ifthenelse(t.system, 'system key', 'key'), 'sys.keys', t.system FROM sys.keys k JOIN sys._tables t ON k.table_id = t.id UNION ALL
SELECT k.id, k.name, t.schema_id, k.table_id, t.name as table_name, 'key', 'tmp.keys', t.system FROM tmp.keys k JOIN tmp._tables t ON k.table_id = t.id UNION ALL
SELECT i.id, i.name, t.schema_id, i.table_id, t.name as table_name, ifthenelse(t.system, 'system index', 'index'), 'sys.idxs', t.system FROM sys.idxs i JOIN sys._tables t ON i.table_id = t.id UNION ALL
SELECT i.id, i.name, t.schema_id, i.table_id, t.name as table_name, 'index' , 'tmp.idxs', t.system FROM tmp.idxs i JOIN tmp._tables t ON i.table_id = t.id UNION ALL
SELECT g.id, g.name, t.schema_id, g.table_id, t.name as table_name, ifthenelse(t.system, 'system trigger', 'trigger'), 'sys.triggers', t.system FROM sys.triggers g JOIN sys._tables t ON g.table_id = t.id UNION ALL
SELECT g.id, g.name, t.schema_id, g.table_id, t.name as table_name, 'trigger', 'tmp.triggers', t.system FROM tmp.triggers g JOIN tmp._tables t ON g.table_id = t.id UNION ALL
SELECT f.id, f.name, f.schema_id, cast(null as int) as table_id, cast(null as varchar(124)) as table_name, cast(ifthenelse(f.system, 'system ', '') || lower(ft.function_type_keyword) as varchar(40)), 'sys.functions', f.system FROM sys.functions f left outer join sys.function_types ft on f.type = ft.function_type_id UNION ALL
SELECT a.id, a.name, f.schema_id, a.func_id as table_id, f.name as table_name, cast(ifthenelse(f.system, 'system ', '') || lower(ft.function_type_keyword) || ' arg' as varchar(44)), 'sys.args', f.system FROM sys.args a JOIN sys.functions f ON a.func_id = f.id left outer join sys.function_types ft on f.type = ft.function_type_id UNION ALL
SELECT id, name, schema_id, cast(null as int) as table_id, cast(null as varchar(124)) as table_name, 'sequence', 'sys.sequences', false FROM sys.sequences UNION ALL
SELECT o.id, o.name, pt.schema_id, pt.id, pt.name, 'partition of merge table', 'sys.objects', false FROM sys.objects o JOIN sys._tables pt ON o.sub = pt.id JOIN sys._tables mt ON o.nr = mt.id WHERE mt.type = 3 UNION ALL
SELECT id, sqlname, schema_id, cast(null as int) as table_id, cast(null as varchar(124)) as table_name, 'type', 'sys.types', (sqlname in ('inet','json','url','uuid','inet4','inet6')) FROM sys.types
 ORDER BY id;
CREATE VIEW sys.dependencies_vw AS
SELECT d.id, i1.obj_type, i1.name,
 d.depend_id as used_by_id, i2.obj_type as used_by_obj_type, i2.name as used_by_name,
 d.depend_type, dt.dependency_type_name
 FROM sys.dependencies d
 JOIN sys.ids i1 ON d.id = i1.id
 JOIN sys.ids i2 ON d.depend_id = i2.id
 JOIN sys.dependency_types dt ON d.depend_type = dt.dependency_type_id
 ORDER BY id, depend_id;
GRANT SELECT ON sys.ids TO PUBLIC;
GRANT SELECT ON sys.dependencies_vw TO PUBLIC;
drop function sys.dump_database cascade;
drop view sys.dump_user_defined_types cascade;
drop view sys.describe_user_defined_types cascade;
CREATE VIEW sys.describe_user_defined_types AS
 SELECT
 s.name sch,
 t.sqlname sql_tpe,
 t.systemname ext_tpe
 FROM sys.types t JOIN sys.schemas s ON t.schema_id = s.id
 WHERE
 t.eclass = 18 AND
 (
 (s.name = 'sys' AND t.sqlname not in ('geometrya', 'mbr', 'url', 'inet', 'json', 'uuid', 'xml', 'inet4', 'inet6')) OR
 (s.name <> 'sys')
 );
GRANT SELECT ON sys.describe_user_defined_types TO PUBLIC;
CREATE VIEW sys.dump_user_defined_types AS
 SELECT 'CREATE TYPE ' || sys.FQN(sch, sql_tpe) || ' EXTERNAL NAME ' || sys.DQ(ext_tpe) || ';' stmt,
 sch schema_name,
 sql_tpe type_name
 FROM sys.describe_user_defined_types;
CREATE FUNCTION sys.dump_database(describe BOOLEAN) RETURNS TABLE(o int, stmt STRING)
BEGIN
 SET SCHEMA sys;
 TRUNCATE sys.dump_statements;
 INSERT INTO sys.dump_statements VALUES (1, 'START TRANSACTION;');
 INSERT INTO sys.dump_statements VALUES (2, 'SET SCHEMA "sys";');
 INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_create_roles;
 INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_create_users;
 INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_create_schemas;
 INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_user_defined_types;
 INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_add_schemas_to_users;
 INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_grant_user_privileges;
 INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_sequences;
 --functions and table-likes can be interdependent. They should be inserted in the order of their catalogue id.
 INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(ORDER BY stmts.o), stmts.s
 FROM (
 SELECT f.o, f.stmt FROM sys.dump_functions f
 UNION ALL
 SELECT t.o, t.stmt FROM sys.dump_tables t
 ) AS stmts(o, s);
 -- dump table data before adding constraints and fixing sequences
 IF NOT DESCRIBE THEN
 CALL sys.dump_table_data();
 END IF;
 INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_start_sequences;
 INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_column_defaults;
 INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_table_constraint_type;
 INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_indices;
 INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_foreign_keys;
 INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_partition_tables;
 INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_triggers;
 INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_comments;
 INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_table_grants;
 INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_column_grants;
 INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_function_grants;
 --TODO Improve performance of dump_table_data.
 --TODO loaders, procedures, window and filter sys.functions.
 --TODO look into order dependent group_concat
 INSERT INTO sys.dump_statements VALUES ((SELECT COUNT(*) FROM sys.dump_statements) + 1, 'COMMIT;');
 RETURN sys.dump_statements;
END;
drop view sys.storagemodel cascade;
drop view sys.tablestoragemodel cascade;
drop function sys.columnsize cascade;
create function sys.columnsize(tpe varchar(1024), count bigint)
returns bigint
begin
 -- for fixed size types: typewidth_inbytes * count
 if tpe in ('tinyint', 'boolean')
 then return count;
 end if;
 if tpe = 'smallint'
 then return 2 * count;
 end if;
 if tpe in ('int', 'real', 'date', 'time', 'timetz', 'sec_interval', 'day_interval', 'month_interval', 'inet4')
 then return 4 * count;
 end if;
 if tpe in ('bigint', 'double', 'timestamp', 'timestamptz', 'inet', 'oid')
 then return 8 * count;
 end if;
 if tpe in ('hugeint', 'decimal', 'uuid', 'mbr', 'inet6')
 then return 16 * count;
 end if;

 -- for variable size types we compute the columnsize as refs (assume 4 bytes each for char strings) to the heap, excluding data in the var heap
 if tpe in ('varchar', 'char', 'clob', 'json', 'url')
 then return 4 * count;
 end if;
 if tpe in ('blob', 'geometry', 'geometrya')
 then return 8 * count;
 end if;

 return 8 * count;
end;
create view sys.storagemodel as
select "schema", "table", "column", "type", "count",
 sys.columnsize("type", "count") as columnsize,
 sys.heapsize("type", "count", "distinct", "atomwidth") as heapsize,
 sys.hashsize("reference", "count") as hashsize,
 case when isacolumn then sys.imprintsize("type", "count") else 0 end as imprintsize,
 case when (isacolumn and not sorted) then cast(8 * "count" as bigint) else 0 end as orderidxsize,
 sorted, "unique", isacolumn
 from sys.storagemodelinput
order by "schema", "table", "column";
create view sys.tablestoragemodel as
select "schema", "table",
 max("count") as "rowcount",
 count(*) as "storages",
 sum(sys.columnsize("type", "count")) as columnsize,
 sum(sys.heapsize("type", "count", "distinct", "atomwidth")) as heapsize,
 sum(sys.hashsize("reference", "count")) as hashsize,
 sum(case when isacolumn then sys.imprintsize("type", "count") else 0 end) as imprintsize,
 sum(case when (isacolumn and not sorted) then cast(8 * "count" as bigint) else 0 end) as orderidxsize
 from sys.storagemodelinput
group by "schema", "table"
order by "schema", "table";
update sys.functions set system = true where not system and schema_id = 2000 and name in ('contains', 'containsorequal', 'containssymmetric', 'bit_not', 'bit_and', 'bit_or', 'bit_xor', 'dump_database', 'columnsize');
update sys._tables set system = true where not system and schema_id = 2000 and name in ('ids', 'dependencies_vw', 'describe_user_defined_types', 'dump_user_defined_types', 'storagemodel', 'tablestoragemodel');

Running database upgrade commands:
drop function sys.optimizer_stats cascade;

Running database upgrade commands:
drop procedure profiler.start cascade;
drop procedure profiler.stop cascade;
drop procedure profiler.setlimit cascade;
drop function profiler.getlimit cascade;

