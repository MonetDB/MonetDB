stdout of test 'upgrade` in directory 'sql/test/testdb-upgrade` itself:


# 21:49:40 >  
# 21:49:40 >  "mserver5" "--debug=10" "--set" "gdk_nr_threads=0" "--set" "mapi_open=true" "--set" "mapi_port=30515" "--set" "mapi_usock=/var/tmp/mtest-14642/.s.monetdb.30515" "--set" "monet_prompt=" "--forcemito" "--set" "mal_listing=2" "--dbpath=/ufs/sjoerd/Monet-devel/var/MonetDB/mTests_sql_test_testdb-upgrade" "--set" "mal_listing=0"
# 21:49:40 >  

# MonetDB 5 server v11.16.0 (hg id: fd9db07674cf+)
# This is an unreleased version
# Serving database 'mTests_sql_test_testdb-upgrade', using 8 threads
# Compiled for x86_64-unknown-linux-gnu/64bit with 64bit OIDs dynamically linked
# Found 15.591 GiB available main-memory.
# Copyright (c) 1993-July 2008 CWI.
# Copyright (c) August 2008-2015 MonetDB B.V., all rights reserved
# Visit http://www.monetdb.org/ for further information


Ready.
Running database upgrade commands:
set schema "sys";
create function sys.fuse(one bigint, two bigint)
returns hugeint
external name udf.fuse;
create function sys.generate_series(first hugeint, last hugeint)
returns table (value hugeint)
external name generator.series;
create function sys.generate_series(first hugeint, last hugeint, stepsize hugeint)
returns table (value hugeint)
external name generator.series;
create aggregate sys.stddev_samp(val hugeint)
returns double
external name aggr.stdev;
create aggregate sys.stddev_pop(val hugeint)
returns double
external name aggr.stdevp;
create aggregate sys.var_samp(val hugeint)
returns double
external name aggr.variance;
create aggregate sys.var_pop(val hugeint)
returns double
external name aggr.variancep;
create aggregate sys.median(val hugeint)
returns hugeint
external name aggr.median;
create aggregate sys.quantile(val hugeint, q double)
returns hugeint
external name aggr.quantile;
create aggregate sys.corr(e1 hugeint, e2 hugeint)
returns hugeint
external name aggr.corr;
create function json.filter(js json, name hugeint)
returns json
external name json.filter;
drop view sys.tablestoragemodel;
create view sys.tablestoragemodel
as select "schema","table",max(count) as "count",
	sum(columnsize) as columnsize,
	sum(heapsize) as heapsize,
	sum(hashes) as hashes,
	sum(imprints) as imprints,
	sum(case when sorted = false then 8 * count else 0 end) as auxiliary
from sys.storagemodel() group by "schema","table";
insert into sys.systemfunctions (select id from sys.functions where name in ('fuse', 'generate_series', 'stddev_samp', 'stddev_pop', 'var_samp', 'var_pop', 'median', 'quantile', 'corr') and schema_id = (select id from sys.schemas where name = 'sys') and id not in (select function_id from sys.systemfunctions));
insert into sys.systemfunctions (select id from sys.functions where name = 'filter' and schema_id = (select id from sys.schemas where name = 'json') and id not in (select function_id from sys.systemfunctions));
update sys._tables set system = true where name = 'tablestoragemodel' and schema_id = (select id from sys.schemas where name = 'sys');
insert into sys.types values(6873, 'hge', 'hugeint', 128, 1, 2, 6, 0);
insert into sys.types values(6874, 'hge', 'decimal', 39, 1, 10, 8, 0);
update sys.types set digits = 18 where systemname = 'lng' and sqlname = 'decimal';
set schema "testschema";

Running database upgrade commands:
set schema "sys";
drop filter function sys."like";
create filter function sys."like"(val string, pat string, esc string) external name algebra."like";
create filter function sys."like"(val string, pat string) external name algebra."like";
drop filter function sys."ilike";
create filter function sys."ilike"(val string, pat string, esc string) external name algebra."ilike";
create filter function sys."ilike"(val string, pat string) external name algebra."ilike";
create function sys."epoch"(ts TIMESTAMP WITH TIME ZONE) returns INT external name timestamp."epoch";
CREATE TABLE sys.keywords (
    keyword VARCHAR(40) NOT NULL PRIMARY KEY);

INSERT INTO sys.keywords (keyword) VALUES
('ADMIN'), ('AFTER'), ('AGGREGATE'), ('ALWAYS'), ('ASYMMETRIC'), ('ATOMIC'), ('AUTO_INCREMENT'),
('BEFORE'), ('BIGINT'), ('BIGSERIAL'), ('BINARY'), ('BLOB'),
('CALL'), ('CHAIN'), ('CLOB'), ('COMMITTED'), ('COPY'), ('CORR'), ('CUME_DIST'), ('CURRENT_ROLE'), ('CYCLE'),
('DATABASE'), ('DELIMITERS'), ('DENSE_RANK'), ('DO'),
('EACH'), ('ELSEIF'), ('ENCRYPTED'), ('EVERY'), ('EXCLUDE'),
('FOLLOWING'), ('FUNCTION'),
('GENERATED'),
('IF'), ('ILIKE'), ('INCREMENT'),
('LAG'), ('LEAD'), ('LIMIT'), ('LOCALTIME'), ('LOCALTIMESTAMP'), ('LOCKED'),
('MAXVALUE'), ('MEDIAN'), ('MEDIUMINT'), ('MERGE'), ('MINVALUE'),
('NEW'), ('NOCYCLE'), ('NOMAXVALUE'), ('NOMINVALUE'), ('NOW'),
('OFFSET'), ('OLD'), ('OTHERS'), ('OVER'),
('PARTITION'), ('PERCENT_RANK'), ('PLAN'), ('PRECEDING'), ('PROD'),
('QUANTILE'),
('RANGE'), ('RANK'), ('RECORDS'), ('REFERENCING'), ('REMOTE'), ('RENAME'), ('REPEATABLE'), ('REPLICA'),
('RESTART'), ('RETURN'), ('RETURNS'), ('ROWS'), ('ROW_NUMBER'),
('SAMPLE'), ('SAVEPOINT'), ('SCHEMA'), ('SEQUENCE'), ('SERIAL'), ('SERIALIZABLE'), ('SIMPLE'),
('START'), ('STATEMENT'), ('STDIN'), ('STDOUT'), ('STREAM'), ('STRING'), ('SYMMETRIC'),
('TIES'), ('TINYINT'), ('TRIGGER'),
('UNBOUNDED'), ('UNCOMMITTED'), ('UNENCRYPTED'),
('WHILE'),
('XMLAGG'), ('XMLATTRIBUTES'), ('XMLCOMMENT'), ('XMLCONCAT'), ('XMLDOCUMENT'), ('XMLELEMENT'), ('XMLFOREST'),
('XMLNAMESPACES'), ('XMLPARSE'), ('XMLPI'), ('XMLQUERY'), ('XMLSCHEMA'), ('XMLTEXT'), ('XMLVALIDATE');


CREATE TABLE sys.table_types (
    table_type_id   SMALLINT NOT NULL PRIMARY KEY,
    table_type_name VARCHAR(25) NOT NULL UNIQUE);

INSERT INTO sys.table_types (table_type_id, table_type_name) VALUES
-- values from sys._tables.type:  0=Table, 1=View, 2=Generated, 3=Merge, etc.
  (0, 'TABLE'), (1, 'VIEW'), /* (2, 'GENERATED'), */ (3, 'MERGE TABLE'), (4, 'STREAM TABLE'), (5, 'REMOTE TABLE'), (6, 'REPLICA TABLE'),
-- synthetically constructed system obj variants (added 10 to sys._tables.type value when sys._tables.system is true).
  (10, 'SYSTEM TABLE'), (11, 'SYSTEM VIEW'),
-- synthetically constructed temporary variants (added 20 or 30 to sys._tables.type value depending on values of temporary and commit_action).
  (20, 'GLOBAL TEMPORARY TABLE'),
  (30, 'LOCAL TEMPORARY TABLE');


CREATE TABLE sys.dependency_types (
    dependency_type_id   SMALLINT NOT NULL PRIMARY KEY,
    dependency_type_name VARCHAR(15) NOT NULL UNIQUE);

INSERT INTO sys.dependency_types (dependency_type_id, dependency_type_name) VALUES
-- values taken from sql_catalog.h
  (1, 'SCHEMA'), (2, 'TABLE'), (3, 'COLUMN'), (4, 'KEY'), (5, 'VIEW'), (6, 'USER'), (7, 'FUNCTION'), (8, 'TRIGGER'),
  (9, 'OWNER'), (10, 'INDEX'), (11, 'FKEY'), (12, 'SEQUENCE'), (13, 'PROCEDURE'), (14, 'BE_DROPPED');
drop view sys.tables;
create view sys.tables as SELECT * FROM (SELECT p.*, 0 AS "temporary", CAST(CASE WHEN system THEN type + 10 /* system table/view */ ELSE (CASE WHEN commit_action = 0 THEN type /* table/view */ ELSE type + 20 /* global temp table */ END) END AS SMALLINT) AS table_type FROM "sys"."_tables" AS p UNION ALL SELECT t.*, 1 AS "temporary", CAST(type + 30 /* local temp table */ AS SMALLINT) AS table_type FROM "tmp"."_tables" AS t) AS tables where tables.type <> 2;
drop view sys.storagemodel;
drop view sys.tablestoragemodel;
drop view sys.storage;
drop function sys.storagemodel;
drop function sys.imprintsize;
drop function sys.columnsize;
drop function sys.storage;
create function sys.storage()
returns table ("schema" string, "table" string, "column" string, "type" string, location string, "count" bigint, typewidth int, columnsize bigint, heapsize bigint, hashes bigint, imprints bigint, sorted boolean)
external name sql.storage;
create view sys.storage as select * from sys.storage();
create function sys.columnsize(nme string, i bigint, d bigint)
returns bigint
begin
	case
	when nme = 'boolean' then return i;
	when nme = 'char' then return 2*i;
	when nme = 'smallint' then return 2 * i;
	when nme = 'int' then return 4 * i;
	when nme = 'bigint' then return 8 * i;
	when nme = 'hugeint' then return 16 * i;
	when nme = 'timestamp' then return 8 * i;
	when  nme = 'varchar' then
		case
		when cast(d as bigint) << 8 then return i;
		when cast(d as bigint) << 16 then return 2 * i;
		when cast(d as bigint) << 32 then return 4 * i;
		else return 8 * i;
		end case;
	else return 8 * i;
	end case;
end;
create function sys.imprintsize(i bigint, nme string)
returns bigint
begin
	if nme = 'boolean'
		or nme = 'tinyint'
		or nme = 'smallint'
		or nme = 'int'
		or nme = 'bigint'
		or nme = 'hugeint'
		or nme = 'decimal'
		or nme = 'date'
		or nme = 'timestamp'
		or nme = 'real'
		or nme = 'double'
	then
		return cast( i * 0.12 as bigint);
	end if;
	return 0;
end;
create function sys.storagemodel()
returns table (
	"schema" string,
	"table" string,
	"column" string,
	"type" string,
	"count" bigint,
	columnsize bigint,
	heapsize bigint,
	hashes bigint,
	imprints bigint,
	sorted boolean)
begin
	return select I."schema", I."table", I."column", I."type", I."count",
	columnsize(I."type", I.count, I."distinct"),
	heapsize(I."type", I."distinct", I."atomwidth"),
	hashsize(I."reference", I."count"),
	imprintsize(I."count",I."type"),
	I.sorted
	from sys.storagemodelinput I;
end;
create view sys.storagemodel as select * from sys.storagemodel();
create view sys.tablestoragemodel
as select "schema","table",max(count) as "count",
	sum(columnsize) as columnsize,
	sum(heapsize) as heapsize,
	sum(hashes) as hashes,
	sum(imprints) as imprints,
	sum(case when sorted = false then 8 * count else 0 end) as auxiliary
from sys.storagemodel() group by "schema","table";
drop table sys.statistics;
create table sys.statistics(
	"column_id" integer,
	"type" string,
	width integer,
	stamp timestamp,
	"sample" bigint,
	"count" bigint,
	"unique" bigint,
	"nils" bigint,
	minval string,
	maxval string,
	sorted boolean);
drop all procedure sys.analyze;
create procedure analyze(minmax int, "sample" bigint)
external name sql.analyze;
create procedure analyze(minmax int, "sample" bigint,sch string)
external name sql.analyze;
create procedure analyze(minmax int, "sample" bigint,sch string, tbl string)
external name sql.analyze;
create procedure analyze(minmax int, "sample" bigint,sch string, tbl string, col string)
external name sql.analyze;
drop view sys.querylog_history;
drop view sys.querylog_calls;
drop function sys.querylog_calls;
create function sys.querylog_calls()
returns table(
    id oid,
    "start" timestamp,
    "stop" timestamp,
    arguments string,
    tuples wrd,
    run bigint,
    ship bigint,
    cpu int,
    io int
) external name sql.querylog_calls;
create view sys.querylog_calls as select * from sys.querylog_calls();
create view sys.querylog_history as
select qd.*, ql."start",ql."stop", ql.arguments, ql.tuples, ql.run, ql.ship, ql.cpu, ql.io
from sys.querylog_catalog() qd, sys.querylog_calls() ql
where qd.id = ql.id and qd.owner = user;
drop view sys.tracelog;
drop function sys.tracelog;
create function sys.tracelog()
returns table (
	event integer,
	clk varchar(20),
	pc varchar(50),
	thread int,
	ticks bigint,
	rrsMB bigint,
	vmMB bigint,
	reads bigint,
	writes bigint,
	minflt bigint,
	majflt bigint,
	nvcsw bigint,
	stmt string
	) external name sql.dump_trace;
create view sys.tracelog as select * from sys.tracelog();
insert into sys.systemfunctions (select id from sys.functions where name in ('columnsize', 'epoch', 'ilike', 'imprintsize', 'like', 'querylog_calls', 'storage', 'storagemodel', 'tracelog') and schema_id = (select id from sys.schemas where name = 'sys') and id not in (select function_id from sys.systemfunctions));
delete from systemfunctions where function_id not in (select id from functions);
update sys._tables set system = true where name in ('dependency_types', 'keywords', 'querylog_calls', 'querylog_history', 'statistics', 'storage', 'storagemodel', 'tables', 'tablestoragemodel', 'table_types', 'tracelog') and schema_id = (select id from sys.schemas where name = 'sys');
drop procedure sys.cluster1;
drop procedure sys.cluster2;
set schema "testschema";


# 11:43:08 >  
# 11:43:08 >  "/usr/bin/python2" "upgrade.SQL.py" "upgrade"
# 11:43:08 >  

#select count(*) from testschema.smallstring;
% testschema.L1 # table_name
% L1 # name
% wrd # type
% 2 # length
[ 66	]

# 21:49:42 >  
# 21:49:42 >  "Done."
# 21:49:42 >  

