stdout of test 'opr_sanity` in directory 'sql/test/pg_regress` itself:


# 17:11:18 >  
# 17:11:18 >  "mserver5" "--debug=10" "--set" "gdk_nr_threads=0" "--set" "mapi_open=true" "--set" "mapi_port=38959" "--set" "mapi_usock=/var/tmp/mtest-1142/.s.monetdb.38959" "--set" "monet_prompt=" "--forcemito" "--set" "mal_listing=2" "--dbpath=/ufs/dinther/INSTALL/var/MonetDB/mTests_sql_test_pg_regress" "--set" "mal_listing=0"
# 17:11:18 >  

# MonetDB 5 server v11.18.0
# This is an unreleased version
# Serving database 'mTests_sql_test_pg_regress', using 8 threads
# Compiled for x86_64-unknown-linux-gnu/64bit with 64bit OIDs dynamically linked
# Found 15.356 GiB available main-memory.
# Copyright (c) 1993-July 2008 CWI.
# Copyright (c) August 2008-2015 MonetDB B.V., all rights reserved
# Visit http://www.monetdb.org/ for further information
# Listening for connection requests on mapi:monetdb://uwakai.da.cwi.nl:38959/
# Listening for UNIX domain connection requests on mapi:monetdb:///var/tmp/mtest-1142/.s.monetdb.38959
# MonetDB/GIS module loaded
# MonetDB/SQL module loaded

Ready.

# 17:11:19 >  
# 17:11:19 >  "mclient" "-lsql" "-ftest" "-Eutf-8" "-i" "-e" "--host=/var/tmp/mtest-1142" "--port=38959"
# 17:11:19 >  

= ! Correct / expected output still needs to be provided / verified / approved ! =

#--
#-- OPR_SANITY
#-- Sanity checks for common errors in making operator/procedure system tables:
#-- pg_operator, pg_proc, pg_cast, pg_aggregate, pg_am, pg_amop, pg_amproc, pg_opclass.
#--
#-- None of the SELECTs here should ever find any matching entries,
#-- so the expected output is easy to maintain ;-).
#-- A test failure indicates someone messed up an entry in the system tables.
#--
#-- NB: we assume the oidjoins test will have caught any dangling links,
#-- that is OID or REGPROC fields that are not zero and do not match some
#-- row in the linked-to table.  However, if we want to enforce that a link
#-- field can't be 0, we have to check it here.
#--
#-- NB: run this test earlier than the create_operator test, because
#-- that test creates some bogus operators...
#-- Helper functions to deal with cases where binary-coercible matches are
#-- allowed.
#-- This should match IsBinaryCoercible() in parse_coerce.c.
#create function binary_coercible(oid, oid) returns bool as
#'SELECT ($1 = $2) OR
# EXISTS(select 1 from pg_cast where
#        castsource = $1 and casttarget = $2 and
#        castfunc = 0 and castcontext = ''i'')'
#language sql;
#-- This one ignores castcontext, so it considers only physical equivalence
#-- and not whether the coercion can be invoked implicitly.
#create function physically_coercible(oid, oid) returns bool as
#'SELECT ($1 = $2) OR
# EXISTS(select 1 from pg_cast where
#        castsource = $1 and casttarget = $2 and
#        castfunc = 0)'
#language sql;
#-- **************** pg_proc ****************
#-- Look for illegal values in pg_proc fields.
#-- NOTE: in reality pronargs could be more than 10, but I'm too lazy to put
#-- a larger number of proargtypes check clauses in here.  If we ever have
#-- more-than-10-arg functions in the standard catalogs, extend this query.
#SELECT p1.oid, p1.proname
#FROM pg_proc as p1
#WHERE p1.prolang = 0 OR p1.prorettype = 0 OR
#       p1.pronargs < 0 OR p1.pronargs > 10 OR
#       (p1.proargtypes[0] = 0 AND p1.pronargs > 0) OR
#       (p1.proargtypes[1] = 0 AND p1.pronargs > 1) OR
#       (p1.proargtypes[2] = 0 AND p1.pronargs > 2) OR
#       (p1.proargtypes[3] = 0 AND p1.pronargs > 3) OR
#       (p1.proargtypes[4] = 0 AND p1.pronargs > 4) OR
#       (p1.proargtypes[5] = 0 AND p1.pronargs > 5) OR
#       (p1.proargtypes[6] = 0 AND p1.pronargs > 6) OR
#       (p1.proargtypes[7] = 0 AND p1.pronargs > 7) OR
#       (p1.proargtypes[8] = 0 AND p1.pronargs > 8) OR
#       (p1.proargtypes[9] = 0 AND p1.pronargs > 9);
% sys.L0,	sys.L0 # table_name
% oid,	proname # name
% ?,	? # type
% ?,	? # length

#-- Look for conflicting proc definitions (same names and input datatypes).
#-- (This test should be dead code now that we have the unique index
#-- pg_proc_proname_narg_type_index, but I'll leave it in anyway.)
#SELECT p1.oid, p1.proname, p2.oid, p2.proname
#FROM pg_proc AS p1, pg_proc AS p2
#WHERE p1.oid != p2.oid AND
#    p1.proname = p2.proname AND
#    p1.pronargs = p2.pronargs AND
#    p1.proargtypes = p2.proargtypes;
% sys.L0,	sys.L0,	sys.L0,	sys.L0 # table_name
% oid,	proname,	oid,	proname # name
% ?,	?,	?,	? # type
% ?,	?,	?,	? # length

#-- Considering only built-in procs (prolang = 12), look for multiple uses
#-- of the same internal function (ie, matching prosrc fields).  It's OK to
#-- have several entries with different pronames for the same internal function,
#-- but conflicts in the number of arguments and other critical items should
#-- be complained of.
#SELECT p1.oid, p1.proname, p2.oid, p2.proname
#FROM pg_proc AS p1, pg_proc AS p2
#WHERE p1.oid != p2.oid AND
#    p1.prosrc = p2.prosrc AND
#    p1.prolang = 12 AND p2.prolang = 12 AND
#    (p1.prolang != p2.prolang OR
#     p1.proisagg != p2.proisagg OR
#     p1.prosecdef != p2.prosecdef OR
#     p1.proisstrict != p2.proisstrict OR
#     p1.proretset != p2.proretset OR
#     p1.provolatile != p2.provolatile OR
#     p1.pronargs != p2.pronargs);
% sys.L0,	sys.L0,	sys.L0,	sys.L0 # table_name
% oid,	proname,	oid,	proname # name
% ?,	?,	?,	? # type
% ?,	?,	?,	? # length

#-- Look for uses of different type OIDs in the argument/result type fields
#-- for different aliases of the same built-in function.
#-- This indicates that the types are being presumed to be binary-equivalent,
#-- or that the built-in function is prepared to deal with different types.
#-- That's not wrong, necessarily, but we make lists of all the types being
#-- so treated.  Note that the expected output of this part of the test will
#-- need to be modified whenever new pairs of types are made binary-equivalent,
#-- or when new polymorphic built-in functions are added!
#-- Note: ignore aggregate functions here, since they all string to the same
#-- dummy built-in function.
#SELECT DISTINCT p1.prorettype, p2.prorettype
#FROM pg_proc AS p1, pg_proc AS p2
#WHERE p1.oid != p2.oid AND
#    p1.prosrc = p2.prosrc AND
#    p1.prolang = 12 AND p2.prolang = 12 AND
#    NOT p1.proisagg AND NOT p2.proisagg AND
#    (p1.prorettype < p2.prorettype);
% sys.L0,	sys.L0 # table_name
% prorettype,	prorettype # name
% ?,	? # type
% ?,	? # length
[ 25,	1043 ]
[ 1114,	1184 ]

#SELECT DISTINCT p1.proargtypes[0], p2.proargtypes[0]
#FROM pg_proc AS p1, pg_proc AS p2
#WHERE p1.oid != p2.oid AND
#    p1.prosrc = p2.prosrc AND
#    p1.prolang = 12 AND p2.prolang = 12 AND
#    NOT p1.proisagg AND NOT p2.proisagg AND
#    (p1.proargtypes[0] < p2.proargtypes[0]);
% sys.L0,	sys.L0 # table_name
% proargtypes,	proargtypes # name
% ?,	? # type
% ?,	? # length
[ 25,	1042 ]
[ 25,	1043 ]
[ 1114,	1184 ]
[ 1560,	1562 ]
[ 2277,	2283 ]

#SELECT DISTINCT p1.proargtypes[1], p2.proargtypes[1]
#FROM pg_proc AS p1, pg_proc AS p2
#WHERE p1.oid != p2.oid AND
#    p1.prosrc = p2.prosrc AND
#    p1.prolang = 12 AND p2.prolang = 12 AND
#    NOT p1.proisagg AND NOT p2.proisagg AND
#    (p1.proargtypes[1] < p2.proargtypes[1]);
% sys.L0,	sys.L0 # table_name
% proargtypes,	proargtypes # name
% ?,	? # type
% ?,	? # length
[ 23,	28 ]
[ 25,	1042 ]
[ 1114,	1184 ]
[ 1560,	1562 ]
[ 2277,	2283 ]

#SELECT DISTINCT p1.proargtypes[2], p2.proargtypes[2]
#FROM pg_proc AS p1, pg_proc AS p2
#WHERE p1.oid != p2.oid AND
#    p1.prosrc = p2.prosrc AND
#    p1.prolang = 12 AND p2.prolang = 12 AND
#    NOT p1.proisagg AND NOT p2.proisagg AND
#    (p1.proargtypes[2] < p2.proargtypes[2]);
% sys.L0,	sys.L0 # table_name
% proargtypes,	proargtypes # name
% ?,	? # type
% ?,	? # length
[ 1114,	1184 ]

#SELECT DISTINCT p1.proargtypes[3], p2.proargtypes[3]
#FROM pg_proc AS p1, pg_proc AS p2
#WHERE p1.oid != p2.oid AND
#    p1.prosrc = p2.prosrc AND
#    p1.prolang = 12 AND p2.prolang = 12 AND
#    NOT p1.proisagg AND NOT p2.proisagg AND
#    (p1.proargtypes[3] < p2.proargtypes[3]);
% sys.L0,	sys.L0 # table_name
% proargtypes,	proargtypes # name
% ?,	? # type
% ?,	? # length
[ 1114,	1184 ]

#SELECT DISTINCT p1.proargtypes[4], p2.proargtypes[4]
#FROM pg_proc AS p1, pg_proc AS p2
#WHERE p1.oid != p2.oid AND
#    p1.prosrc = p2.prosrc AND
#    p1.prolang = 12 AND p2.prolang = 12 AND
#    NOT p1.proisagg AND NOT p2.proisagg AND
#    (p1.proargtypes[4] < p2.proargtypes[4]);
% sys.L0,	sys.L0 # table_name
% proargtypes,	proargtypes # name
% ?,	? # type
% ?,	? # length

#SELECT DISTINCT p1.proargtypes[5], p2.proargtypes[5]
#FROM pg_proc AS p1, pg_proc AS p2
#WHERE p1.oid != p2.oid AND
#    p1.prosrc = p2.prosrc AND
#    p1.prolang = 12 AND p2.prolang = 12 AND
#    NOT p1.proisagg AND NOT p2.proisagg AND
#    (p1.proargtypes[5] < p2.proargtypes[5]);
% sys.L0,	sys.L0 # table_name
% proargtypes,	proargtypes # name
% ?,	? # type
% ?,	? # length

#SELECT DISTINCT p1.proargtypes[6], p2.proargtypes[6]
#FROM pg_proc AS p1, pg_proc AS p2
#WHERE p1.oid != p2.oid AND
#    p1.prosrc = p2.prosrc AND
#    p1.prolang = 12 AND p2.prolang = 12 AND
#    NOT p1.proisagg AND NOT p2.proisagg AND
#    (p1.proargtypes[6] < p2.proargtypes[6]);
% sys.L0,	sys.L0 # table_name
% proargtypes,	proargtypes # name
% ?,	? # type
% ?,	? # length

#SELECT DISTINCT p1.proargtypes[7], p2.proargtypes[7]
#FROM pg_proc AS p1, pg_proc AS p2
#WHERE p1.oid != p2.oid AND
#    p1.prosrc = p2.prosrc AND
#    p1.prolang = 12 AND p2.prolang = 12 AND
#    NOT p1.proisagg AND NOT p2.proisagg AND
#    (p1.proargtypes[7] < p2.proargtypes[7]);
% sys.L0,	sys.L0 # table_name
% proargtypes,	proargtypes # name
% ?,	? # type
% ?,	? # length

#-- Look for functions that return type "internal" and do not have any
#-- "internal" argument.  Such a function would be a security hole since
#-- it might be used to call an internal function from an SQL command.
#-- As of 7.3 this query should find only internal_in.
#SELECT p1.oid, p1.proname
#FROM pg_proc as p1
#WHERE p1.prorettype = 'internal'::regtype AND NOT
#    ('(' || oidvectortypes(p1.proargtypes) || ')') ~ '[^a-z0-9_]internal[^a-z0-9_]';
% sys.L0,	sys.L0 # table_name
% oid,	proname # name
% ?,	? # type
% ?,	? # length
[ 2304,	"internal_in" ]

#-- **************** pg_cast ****************
#-- Catch bogus values in pg_cast columns (other than cases detected by
#-- oidjoins test).
#SELECT *
#FROM pg_cast c
#WHERE castsource = 0 OR casttarget = 0 OR castcontext NOT IN ('e', 'a', 'i');
% sys.L0,	sys.L0,	sys.L0,	sys.L0 # table_name
% castsource,	casttarget,	castfunc,	castcontext # name
% ?,	?,	?,	? # type
% ?,	?,	?,	? # length

#-- Look for casts to/from the same type that aren't length coercion functions.
#-- (We assume they are length coercions if they take multiple arguments.)
#-- Such entries are not necessarily harmful, but they are useless.
#SELECT *
#FROM pg_cast c
#WHERE castsource = casttarget AND castfunc = 0;
% sys.L0,	sys.L0,	sys.L0,	sys.L0 # table_name
% castsource,	casttarget,	castfunc,	castcontext # name
% ?,	?,	?,	? # type
% ?,	?,	?,	? # length

#SELECT c.*
#FROM pg_cast c, pg_proc p
#WHERE c.castfunc = p.oid AND p.pronargs < 2 AND castsource = casttarget;
% sys.L0,	sys.L0,	sys.L0,	sys.L0 # table_name
% castsource,	casttarget,	castfunc,	castcontext # name
% ?,	?,	?,	? # type
% ?,	?,	?,	? # length

#-- Look for cast functions that don't have the right signature.  The
#-- argument and result types in pg_proc must be the same as, or binary
#-- compatible with, what it says in pg_cast.
#-- As a special case, we allow casts from CHAR(n) that use functions
#-- declared to take TEXT.  This does not pass the binary-coercibility test
#-- because CHAR(n)-to-TEXT normally invokes rtrim().  However, the results
#-- are the same, so long as the function is one that ignores trailing blanks.
#SELECT c.*
#FROM pg_cast c, pg_proc p
#WHERE c.castfunc = p.oid AND
#    (p.pronargs < 1 OR p.pronargs > 3
#     OR NOT (binary_coercible(c.castsource, p.proargtypes[0])
#             OR (c.castsource = 'character'::regtype AND
#                 p.proargtypes[0] = 'text'::regtype))
#     OR NOT binary_coercible(p.prorettype, c.casttarget));
% sys.L0,	sys.L0,	sys.L0,	sys.L0 # table_name
% castsource,	casttarget,	castfunc,	castcontext # name
% ?,	?,	?,	? # type
% ?,	?,	?,	? # length

#SELECT c.*
#FROM pg_cast c, pg_proc p
#WHERE c.castfunc = p.oid AND
#    ((p.pronargs > 1 AND p.proargtypes[1] != 'integer'::regtype) OR
#     (p.pronargs > 2 AND p.proargtypes[2] != 'bool'::regtype));
% sys.L0,	sys.L0,	sys.L0,	sys.L0 # table_name
% castsource,	casttarget,	castfunc,	castcontext # name
% ?,	?,	?,	? # type
% ?,	?,	?,	? # length

#-- Look for binary compatible casts that do not have the reverse
#-- direction registered as well, or where the reverse direction is not
#-- also binary compatible.  This is legal, but usually not intended.
#-- As of 7.4, this finds the casts from text and varchar to bpchar, because
#-- those are binary-compatible while the reverse way goes through rtrim().
#SELECT *
#FROM pg_cast c
#WHERE c.castfunc = 0 AND
#    NOT EXISTS (SELECT 1 FROM pg_cast k
#                WHERE k.castfunc = 0 AND
#                    k.castsource = c.casttarget AND
#                    k.casttarget = c.castsource);
% sys.L0,	sys.L0,	sys.L0,	sys.L0 # table_name
% castsource,	casttarget,	castfunc,	castcontext # name
% ?,	?,	?,	? # type
% ?,	?,	?,	? # length
[ 25,	1042,	0,	"i" ]
[ 1043,	1042,	0,	"i" ]

#-- **************** pg_operator ****************
#-- Look for illegal values in pg_operator fields.
#SELECT p1.oid, p1.oprname
#FROM pg_operator as p1
#WHERE (p1.oprkind != 'b' AND p1.oprkind != 'l' AND p1.oprkind != 'r') OR
#    p1.oprresult = 0 OR p1.oprcode = 0;
% sys.L0,	sys.L0 # table_name
% oid,	oprname # name
% ?,	? # type
% ?,	? # length

#-- Look for missing or unwanted operand types
#SELECT p1.oid, p1.oprname
#FROM pg_operator as p1
#WHERE (p1.oprleft = 0 and p1.oprkind != 'l') OR
#    (p1.oprleft != 0 and p1.oprkind = 'l') OR
#    (p1.oprright = 0 and p1.oprkind != 'r') OR
#    (p1.oprright != 0 and p1.oprkind = 'r');
% sys.L0,	sys.L0 # table_name
% oid,	oprname # name
% ?,	? # type
% ?,	? # length

#-- Look for conflicting operator definitions (same names and input datatypes).
#SELECT p1.oid, p1.oprcode, p2.oid, p2.oprcode
#FROM pg_operator AS p1, pg_operator AS p2
#WHERE p1.oid != p2.oid AND
#    p1.oprname = p2.oprname AND
#    p1.oprkind = p2.oprkind AND
#    p1.oprleft = p2.oprleft AND
#    p1.oprright = p2.oprright;
% sys.L0,	sys.L0,	sys.L0,	sys.L0 # table_name
% oid,	oprcode,	oid,	oprcode # name
% ?,	?,	?,	? # type
% ?,	?,	?,	? # length

#-- Look for commutative operators that don't commute.
#-- DEFINITIONAL NOTE: If A.oprcom = B, then x A y has the same result as y B x.
#-- We expect that B will always say that B.oprcom = A as well; that's not
#-- inherently essential, but it would be inefficient not to mark it so.
#SELECT p1.oid, p1.oprcode, p2.oid, p2.oprcode
#FROM pg_operator AS p1, pg_operator AS p2
#WHERE p1.oprcom = p2.oid AND
#    (p1.oprkind != 'b' OR
#     p1.oprleft != p2.oprright OR
#     p1.oprright != p2.oprleft OR
#     p1.oprresult != p2.oprresult OR
#     p1.oid != p2.oprcom);
% sys.L0,	sys.L0,	sys.L0,	sys.L0 # table_name
% oid,	oprcode,	oid,	oprcode # name
% ?,	?,	?,	? # type
% ?,	?,	?,	? # length

#-- Look for negatory operators that don't agree.
#-- DEFINITIONAL NOTE: If A.oprnegate = B, then both A and B must yield
#-- boolean results, and (x A y) == ! (x B y), or the equivalent for
#-- single-operand operators.
#-- We expect that B will always say that B.oprnegate = A as well; that's not
#-- inherently essential, but it would be inefficient not to mark it so.
#-- Also, A and B had better not be the same operator.
#SELECT p1.oid, p1.oprcode, p2.oid, p2.oprcode
#FROM pg_operator AS p1, pg_operator AS p2
#WHERE p1.oprnegate = p2.oid AND
#    (p1.oprkind != p2.oprkind OR
#     p1.oprleft != p2.oprleft OR
#     p1.oprright != p2.oprright OR
#     p1.oprresult != 'bool'::regtype OR
#     p2.oprresult != 'bool'::regtype OR
#     p1.oid != p2.oprnegate OR
#     p1.oid = p2.oid);
% sys.L0,	sys.L0,	sys.L0,	sys.L0 # table_name
% oid,	oprcode,	oid,	oprcode # name
% ?,	?,	?,	? # type
% ?,	?,	?,	? # length

#-- Look for mergejoin operators that don't match their links.
#-- An lsortop/rsortop link leads from an '=' operator to the
#-- sort operator ('<' operator) that's appropriate for
#-- its left-side or right-side data type.
#-- An ltcmpop/gtcmpop link leads from an '=' operator to the
#-- '<' or '>' operator of the same input datatypes.
#-- (If the '=' operator has identical L and R input datatypes,
#-- then lsortop, rsortop, and ltcmpop are all the same operator.)
#SELECT p1.oid, p1.oprcode, p2.oid, p2.oprcode
#FROM pg_operator AS p1, pg_operator AS p2
#WHERE p1.oprlsortop = p2.oid AND
#    (p1.oprname NOT IN ('=', '~=~') OR p2.oprname NOT IN ('<', '~<~') OR
#     p1.oprkind != 'b' OR p2.oprkind != 'b' OR
#     p1.oprleft != p2.oprleft OR
#     p1.oprleft != p2.oprright OR
#     p1.oprresult != 'bool'::regtype OR
#     p2.oprresult != 'bool'::regtype);
% sys.L0,	sys.L0,	sys.L0,	sys.L0 # table_name
% oid,	oprcode,	oid,	oprcode # name
% ?,	?,	?,	? # type
% ?,	?,	?,	? # length

#SELECT p1.oid, p1.oprcode, p2.oid, p2.oprcode
#FROM pg_operator AS p1, pg_operator AS p2
#WHERE p1.oprrsortop = p2.oid AND
#    (p1.oprname NOT IN ('=', '~=~') OR p2.oprname NOT IN ('<', '~<~') OR
#     p1.oprkind != 'b' OR p2.oprkind != 'b' OR
#     p1.oprright != p2.oprleft OR
#     p1.oprright != p2.oprright OR
#     p1.oprresult != 'bool'::regtype OR
#     p2.oprresult != 'bool'::regtype);
% sys.L0,	sys.L0,	sys.L0,	sys.L0 # table_name
% oid,	oprcode,	oid,	oprcode # name
% ?,	?,	?,	? # type
% ?,	?,	?,	? # length

#SELECT p1.oid, p1.oprcode, p2.oid, p2.oprcode
#FROM pg_operator AS p1, pg_operator AS p2
#WHERE p1.oprltcmpop = p2.oid AND
#    (p1.oprname NOT IN ('=', '~=~') OR p2.oprname NOT IN ('<', '~<~') OR
#     p1.oprkind != 'b' OR p2.oprkind != 'b' OR
#     p1.oprleft != p2.oprleft OR
#     p1.oprright != p2.oprright OR
#     p1.oprresult != 'bool'::regtype OR
#     p2.oprresult != 'bool'::regtype);
% sys.L0,	sys.L0,	sys.L0,	sys.L0 # table_name
% oid,	oprcode,	oid,	oprcode # name
% ?,	?,	?,	? # type
% ?,	?,	?,	? # length

#SELECT p1.oid, p1.oprcode, p2.oid, p2.oprcode
#FROM pg_operator AS p1, pg_operator AS p2
#WHERE p1.oprgtcmpop = p2.oid AND
#    (p1.oprname NOT IN ('=', '~=~') OR p2.oprname NOT IN ('>', '~>~') OR
#     p1.oprkind != 'b' OR p2.oprkind != 'b' OR
#     p1.oprleft != p2.oprleft OR
#     p1.oprright != p2.oprright OR
#     p1.oprresult != 'bool'::regtype OR
#     p2.oprresult != 'bool'::regtype);
% sys.L0,	sys.L0,	sys.L0,	sys.L0 # table_name
% oid,	oprcode,	oid,	oprcode # name
% ?,	?,	?,	? # type
% ?,	?,	?,	? # length

#-- Make sure all four links are specified if any are.
#SELECT p1.oid, p1.oprcode
#FROM pg_operator AS p1
#WHERE NOT ((oprlsortop = 0 AND oprrsortop = 0 AND
#            oprltcmpop = 0 AND oprgtcmpop = 0) OR
#           (oprlsortop != 0 AND oprrsortop != 0 AND
#            oprltcmpop != 0 AND oprgtcmpop != 0));
% sys.L0,	sys.L0 # table_name
% oid,	oprcode # name
% ?,	? # type
% ?,	? # length

#-- A mergejoinable = operator must have a commutator (usually itself).
#SELECT p1.oid, p1.oprname FROM pg_operator AS p1
#WHERE p1.oprlsortop != 0 AND
#      p1.oprcom = 0;
% sys.L0,	sys.L0 # table_name
% oid,	oprname # name
% ?,	? # type
% ?,	? # length

#-- Mergejoinable operators across datatypes must come in closed sets, that
#-- is if you provide smallint = integer and integer = bigint then you must also provide
#-- smallint = bigint (and commutators of all these).  This is necessary because
#-- the planner tries to deduce additional qual clauses from transitivity
#-- of mergejoinable operators.  If there are clauses int2var = int4var and
#-- int4var = int8var, the planner will deduce int2var = int8var ... and it
#-- had better have a way to represent it.
#SELECT p1.oid, p2.oid FROM pg_operator AS p1, pg_operator AS p2
#WHERE p1.oprlsortop != p1.oprrsortop AND
#      p1.oprrsortop = p2.oprlsortop AND
#      p2.oprlsortop != p2.oprrsortop AND
#      NOT EXISTS (SELECT 1 FROM pg_operator p3 WHERE
#      p3.oprlsortop = p1.oprlsortop AND p3.oprrsortop = p2.oprrsortop);
% sys.L0,	sys.L0 # table_name
% oid,	oid # name
% ?,	? # type
% ?,	? # length

#-- Hashing only works on simple equality operators "type = sametype",
#-- since the hash itself depends on the bitwise representation of the type.
#-- Check that allegedly hashable operators look like they might be "=".
#SELECT p1.oid, p1.oprname
#FROM pg_operator AS p1
#WHERE p1.oprcanhash AND NOT
#    (p1.oprkind = 'b' AND p1.oprresult = 'bool'::regtype AND
#     p1.oprleft = p1.oprright AND p1.oprname IN ('=', '~=~') AND
#     p1.oprcom = p1.oid);
% sys.L0,	sys.L0 # table_name
% oid,	oprname # name
% ?,	? # type
% ?,	? # length

#-- In 6.5 we accepted hashable array equality operators when the array element
#-- type is hashable.  However, what we actually need to make hashjoin work on
#-- an array is a hashable element type *and* no padding between elements in
#-- the array storage (or, perhaps, guaranteed-zero padding).  Currently,
#-- since the padding code in arrayfuncs.c is pretty bogus, it seems safest
#-- to just forbid hashjoin on array equality ops.
#-- This should be reconsidered someday.
#-- -- Look for array equality operators that are hashable when the underlying
#-- -- type is not, or vice versa.  This is presumably bogus.
#-- 
#-- SELECT p1.oid, p1.oprcanhash, p2.oid, p2.oprcanhash, t1.typname, t2.typname
#-- FROM pg_operator AS p1, pg_operator AS p2, pg_type AS t1, pg_type AS t2
#-- WHERE p1.oprname = '=' AND p1.oprleft = p1.oprright AND 
#--     p2.oprname = '=' AND p2.oprleft = p2.oprright AND
#--     p1.oprleft = t1.oid AND p2.oprleft = t2.oid AND t1.typelem = t2.oid AND
#--     p1.oprcanhash != p2.oprcanhash;
#-- Substitute check: forbid hashable array ops, period.
#SELECT p1.oid, p1.oprname
#FROM pg_operator AS p1, pg_proc AS p2
#WHERE p1.oprcanhash AND p1.oprcode = p2.oid AND p2.proname = 'array_eq';
% sys.L0,	sys.L0 # table_name
% oid,	oprname # name
% ?,	? # type
% ?,	? # length

#-- Hashable operators should appear as members of hash index opclasses.
#SELECT p1.oid, p1.oprname
#FROM pg_operator AS p1
#WHERE p1.oprcanhash AND NOT EXISTS
#  (SELECT 1 FROM pg_opclass op JOIN pg_amop p ON op.oid = amopclaid
#   WHERE opcamid = (SELECT oid FROM pg_am WHERE amname = 'hash') AND
#         amopopr = p1.oid);
% sys.L0,	sys.L0 # table_name
% oid,	oprname # name
% ?,	? # type
% ?,	? # length

#-- And the converse.
#SELECT p1.oid, p1.oprname, op.opcname
#FROM pg_operator AS p1, pg_opclass op, pg_amop p
#WHERE amopopr = p1.oid AND amopclaid = op.oid
#  AND opcamid = (SELECT oid FROM pg_am WHERE amname = 'hash')
#  AND NOT p1.oprcanhash;
% sys.L0,	sys.L0,	sys.L0 # table_name
% oid,	oprname,	opcname # name
% ?,	?,	? # type
% ?,	?,	? # length

#-- Check that each operator defined in pg_operator matches its oprcode entry
#-- in pg_proc.  Easiest to do this separately for each oprkind.
#SELECT p1.oid, p1.oprname, p2.oid, p2.proname
#FROM pg_operator AS p1, pg_proc AS p2
#WHERE p1.oprcode = p2.oid AND
#    p1.oprkind = 'b' AND
#    (p2.pronargs != 2
#     OR NOT binary_coercible(p2.prorettype, p1.oprresult)
#     OR NOT binary_coercible(p1.oprleft, p2.proargtypes[0])
#     OR NOT binary_coercible(p1.oprright, p2.proargtypes[1]));
% sys.L0,	sys.L0,	sys.L0,	sys.L0 # table_name
% oid,	oprname,	oid,	proname # name
% ?,	?,	?,	? # type
% ?,	?,	?,	? # length

#SELECT p1.oid, p1.oprname, p2.oid, p2.proname
#FROM pg_operator AS p1, pg_proc AS p2
#WHERE p1.oprcode = p2.oid AND
#    p1.oprkind = 'l' AND
#    (p2.pronargs != 1
#     OR NOT binary_coercible(p2.prorettype, p1.oprresult)
#     OR NOT binary_coercible(p1.oprright, p2.proargtypes[0])
#     OR p1.oprleft != 0);
% sys.L0,	sys.L0,	sys.L0,	sys.L0 # table_name
% oid,	oprname,	oid,	proname # name
% ?,	?,	?,	? # type
% ?,	?,	?,	? # length

#SELECT p1.oid, p1.oprname, p2.oid, p2.proname
#FROM pg_operator AS p1, pg_proc AS p2
#WHERE p1.oprcode = p2.oid AND
#    p1.oprkind = 'r' AND
#    (p2.pronargs != 1
#     OR NOT binary_coercible(p2.prorettype, p1.oprresult)
#     OR NOT binary_coercible(p1.oprleft, p2.proargtypes[0])
#     OR p1.oprright != 0);
% sys.L0,	sys.L0,	sys.L0,	sys.L0 # table_name
% oid,	oprname,	oid,	proname # name
% ?,	?,	?,	? # type
% ?,	?,	?,	? # length

#-- If the operator is mergejoinable or hashjoinable, its underlying function
#-- should not be volatile.
#SELECT p1.oid, p1.oprname, p2.oid, p2.proname
#FROM pg_operator AS p1, pg_proc AS p2
#WHERE p1.oprcode = p2.oid AND
#    (p1.oprlsortop != 0 OR p1.oprcanhash) AND
#    p2.provolatile = 'v';
% sys.L0,	sys.L0,	sys.L0,	sys.L0 # table_name
% oid,	oprname,	oid,	proname # name
% ?,	?,	?,	? # type
% ?,	?,	?,	? # length

#-- If oprrest is set, the operator must return boolean,
#-- and it must link to a proc with the right signature
#-- to be a restriction selectivity estimator.
#-- The proc signature we want is: double proc(internal, oid, internal, integer)
#SELECT p1.oid, p1.oprname, p2.oid, p2.proname
#FROM pg_operator AS p1, pg_proc AS p2
#WHERE p1.oprrest = p2.oid AND
#    (p1.oprresult != 'bool'::regtype OR
#     p2.prorettype != 'double'::regtype OR p2.proretset OR
#     p2.pronargs != 4 OR
#     p2.proargtypes[0] != 'internal'::regtype OR
#     p2.proargtypes[1] != 'oid'::regtype OR
#     p2.proargtypes[2] != 'internal'::regtype OR
#     p2.proargtypes[3] != 'integer'::regtype);
% sys.L0,	sys.L0,	sys.L0,	sys.L0 # table_name
% oid,	oprname,	oid,	proname # name
% ?,	?,	?,	? # type
% ?,	?,	?,	? # length

#-- If oprjoin is set, the operator must be a binary boolean op,
#-- and it must link to a proc with the right signature
#-- to be a join selectivity estimator.
#-- The proc signature we want is: double proc(internal, oid, internal, smallint)
#SELECT p1.oid, p1.oprname, p2.oid, p2.proname
#FROM pg_operator AS p1, pg_proc AS p2
#WHERE p1.oprjoin = p2.oid AND
#    (p1.oprkind != 'b' OR p1.oprresult != 'bool'::regtype OR
#     p2.prorettype != 'double'::regtype OR p2.proretset OR
#     p2.pronargs != 4 OR
#     p2.proargtypes[0] != 'internal'::regtype OR
#     p2.proargtypes[1] != 'oid'::regtype OR
#     p2.proargtypes[2] != 'internal'::regtype OR
#     p2.proargtypes[3] != 'smallint'::regtype);
% sys.L0,	sys.L0,	sys.L0,	sys.L0 # table_name
% oid,	oprname,	oid,	proname # name
% ?,	?,	?,	? # type
% ?,	?,	?,	? # length

#-- **************** pg_aggregate ****************
#-- Look for illegal values in pg_aggregate fields.
#SELECT ctid, aggfnoid::oid
#FROM pg_aggregate as p1
#WHERE aggfnoid = 0 OR aggtransfn = 0 OR aggtranstype = 0;
% sys.L0,	sys.L0 # table_name
% ctid,	aggfnoid # name
% ?,	? # type
% ?,	? # length

#-- Make sure the matching pg_proc entry is sensible, too.
#SELECT a.aggfnoid::oid, p.proname
#FROM pg_aggregate as a, pg_proc as p
#WHERE a.aggfnoid = p.oid AND
#    (NOT p.proisagg OR p.pronargs != 1 OR p.proretset);
% sys.L0,	sys.L0 # table_name
% aggfnoid,	proname # name
% ?,	? # type
% ?,	? # length

#-- Make sure there are no proisagg pg_proc entries without matches.
#SELECT oid, proname
#FROM pg_proc as p
#WHERE p.proisagg AND
#    NOT EXISTS (SELECT 1 FROM pg_aggregate a WHERE a.aggfnoid = p.oid);
% sys.L0,	sys.L0 # table_name
% oid,	proname # name
% ?,	? # type
% ?,	? # length

#-- If there is no finalfn then the output type must be the transtype.
#SELECT a.aggfnoid::oid, p.proname
#FROM pg_aggregate as a, pg_proc as p
#WHERE a.aggfnoid = p.oid AND
#    a.aggfinalfn = 0 AND p.prorettype != a.aggtranstype;
% sys.L0,	sys.L0 # table_name
% aggfnoid,	proname # name
% ?,	? # type
% ?,	? # length

#-- Cross-check transfn against its entry in pg_proc.
#-- NOTE: use physically_coercible here, not binary_coercible, because
#-- max and min on abstime are implemented using int4larger/int4smaller.
#SELECT a.aggfnoid::oid, p.proname, ptr.oid, ptr.proname
#FROM pg_aggregate AS a, pg_proc AS p, pg_proc AS ptr
#WHERE a.aggfnoid = p.oid AND
#    a.aggtransfn = ptr.oid AND
#    (ptr.proretset
#     OR NOT physically_coercible(ptr.prorettype, a.aggtranstype)
#     OR NOT physically_coercible(a.aggtranstype, ptr.proargtypes[0])
#     OR NOT ((ptr.pronargs = 2 AND
#              physically_coercible(p.proargtypes[0], ptr.proargtypes[1]))
#             OR
#             (ptr.pronargs = 1 AND
#              p.proargtypes[0] = '"any"'::regtype)));
% sys.L0,	sys.L0,	sys.L0,	sys.L0 # table_name
% aggfnoid,	proname,	oid,	proname # name
% ?,	?,	?,	? # type
% ?,	?,	?,	? # length

#-- Cross-check finalfn (if present) against its entry in pg_proc.
#SELECT a.aggfnoid::oid, p.proname, pfn.oid, pfn.proname
#FROM pg_aggregate AS a, pg_proc AS p, pg_proc AS pfn
#WHERE a.aggfnoid = p.oid AND
#    a.aggfinalfn = pfn.oid AND
#    (pfn.proretset
#     OR NOT binary_coercible(pfn.prorettype, p.prorettype)
#     OR pfn.pronargs != 1
#     OR NOT binary_coercible(a.aggtranstype, pfn.proargtypes[0]));
% sys.L0,	sys.L0,	sys.L0,	sys.L0 # table_name
% aggfnoid,	proname,	oid,	proname # name
% ?,	?,	?,	? # type
% ?,	?,	?,	? # length

#-- If transfn is strict then either initval should be non-NULL, or
#-- input type should match transtype so that the first non-null input
#-- can be assigned as the state value.
#SELECT a.aggfnoid::oid, p.proname, ptr.oid, ptr.proname
#FROM pg_aggregate AS a, pg_proc AS p, pg_proc AS ptr
#WHERE a.aggfnoid = p.oid AND
#    a.aggtransfn = ptr.oid AND ptr.proisstrict AND
#    a.agginitval IS NULL AND
#    NOT binary_coercible(p.proargtypes[0], a.aggtranstype);
% sys.L0,	sys.L0,	sys.L0,	sys.L0 # table_name
% aggfnoid,	proname,	oid,	proname # name
% ?,	?,	?,	? # type
% ?,	?,	?,	? # length

#-- **************** pg_opclass ****************
#-- Look for illegal values in pg_opclass fields
#SELECT p1.oid
#FROM pg_opclass as p1
#WHERE p1.opcamid = 0 OR p1.opcintype = 0;
% sys.L0 # table_name
% oid # name
% ? # type
% ? # length

#-- There should not be multiple entries in pg_opclass with opcdefault true
#-- and the same opcamid/opcintype combination.
#SELECT p1.oid, p2.oid
#FROM pg_opclass AS p1, pg_opclass AS p2
#WHERE p1.oid != p2.oid AND
#    p1.opcamid = p2.opcamid AND p1.opcintype = p2.opcintype AND
#    p1.opcdefault AND p2.opcdefault;
% sys.L0,	sys.L0 # table_name
% oid,	oid # name
% ?,	? # type
% ?,	? # length

#-- **************** pg_amop ****************
#-- Look for illegal values in pg_amop fields
#SELECT p1.amopclaid, p1.amopstrategy
#FROM pg_amop as p1
#WHERE p1.amopclaid = 0 OR p1.amopstrategy <= 0 OR p1.amopopr = 0;
% sys.L0,	sys.L0 # table_name
% amopclaid,	amopstrategy # name
% ?,	? # type
% ?,	? # length

#-- Cross-check amopstrategy index against parent AM
#SELECT p1.amopclaid, p1.amopopr, p2.oid, p2.amname
#FROM pg_amop AS p1, pg_am AS p2, pg_opclass AS p3
#WHERE p1.amopclaid = p3.oid AND p3.opcamid = p2.oid AND
#    p1.amopstrategy > p2.amstrategies;
% sys.L0,	sys.L0,	sys.L0,	sys.L0 # table_name
% amopclaid,	amopopr,	oid,	amname # name
% ?,	?,	?,	? # type
% ?,	?,	?,	? # length

#-- Detect missing pg_amop entries: should have as many strategy operators
#-- as AM expects for each opclass for the AM.  When nondefault subtypes are
#-- present, enforce condition separately for each subtype.
#SELECT p1.oid, p1.amname, p2.oid, p2.opcname, p3.amopsubtype
#FROM pg_am AS p1, pg_opclass AS p2, pg_amop AS p3
#WHERE p2.opcamid = p1.oid AND p3.amopclaid = p2.oid AND
#    p1.amstrategies != (SELECT count(*) FROM pg_amop AS p4
#                        WHERE p4.amopclaid = p2.oid AND
#                              p4.amopsubtype = p3.amopsubtype);
% sys.L0,	sys.L0,	sys.L0,	sys.L0,	sys.L0 # table_name
% oid,	amname,	oid,	opcname,	amopsubtype # name
% ?,	?,	?,	?,	? # type
% ?,	?,	?,	?,	? # length

#-- Check that amopopr points at a reasonable-looking operator, ie a binary
#-- operator yielding boolean.
#SELECT p1.amopclaid, p1.amopopr, p2.oid, p2.oprname
#FROM pg_amop AS p1, pg_operator AS p2
#WHERE p1.amopopr = p2.oid AND
#    (p2.oprkind != 'b' OR p2.oprresult != 'bool'::regtype);
% sys.L0,	sys.L0,	sys.L0,	sys.L0 # table_name
% amopclaid,	amopopr,	oid,	oprname # name
% ?,	?,	?,	? # type
% ?,	?,	?,	? # length

#-- Make a list of all the distinct operator names being used in particular
#-- strategy slots.  This is a bit hokey, since the list might need to change
#-- in future releases, but it's an effective way of spotting mistakes such as
#-- swapping two operators within a class.
#SELECT DISTINCT opcamid, amopstrategy, oprname
#FROM pg_amop p1 LEFT JOIN pg_opclass p2 ON amopclaid = p2.oid
#                LEFT JOIN pg_operator p3 ON amopopr = p3.oid
#ORDER BY 1, 2, 3;
% sys.L0,	sys.L0,	sys.L0 # table_name
% opcamid,	amopstrategy,	oprname # name
% ?,	?,	? # type
% ?,	?,	? # length
[ 402,	1,	"<<" ]
[ 402,	2,	"&<" ]
[ 402,	3,	"&&" ]
[ 402,	4,	"&>" ]
[ 402,	5,	">>" ]
[ 402,	6,	"~=" ]
[ 402,	7,	"~" ]
[ 402,	8,	"@" ]
[ 403,	1,	"<" ]
[ 403,	1,	"~<~" ]
[ 403,	2,	"<=" ]
[ 403,	2,	"~<=~" ]
[ 403,	3,	"=" ]
[ 403,	3,	"~=~" ]
[ 403,	4,	">=" ]
[ 403,	4,	"~>=~" ]
[ 403,	5,	">" ]
[ 403,	5,	"~>~" ]
[ 405,	1,	"=" ]
[ 405,	1,	"~=~" ]

#-- Check that all operators linked to by opclass entries have selectivity
#-- estimators.  This is not absolutely required, but it seems a reasonable
#-- thing to insist on for all standard datatypes.
#SELECT p1.amopclaid, p1.amopopr, p2.oid, p2.oprname
#FROM pg_amop AS p1, pg_operator AS p2
#WHERE p1.amopopr = p2.oid AND
#    (p2.oprrest = 0 OR p2.oprjoin = 0);
% sys.L0,	sys.L0,	sys.L0,	sys.L0 # table_name
% amopclaid,	amopopr,	oid,	oprname # name
% ?,	?,	?,	? # type
% ?,	?,	?,	? # length

#-- Check that operator input types match the opclass
#-- For 8.0, we require that oprleft match opcintype (possibly by coercion).
#-- When amopsubtype is zero (default), oprright must equal oprleft;
#-- when amopsubtype is not zero, oprright must equal amopsubtype.
#SELECT p1.amopclaid, p1.amopopr, p2.oid, p2.oprname, p3.opcname
#FROM pg_amop AS p1, pg_operator AS p2, pg_opclass AS p3
#WHERE p1.amopopr = p2.oid AND p1.amopclaid = p3.oid AND
#    NOT binary_coercible(p3.opcintype, p2.oprleft);
% sys.L0,	sys.L0,	sys.L0,	sys.L0,	sys.L0 # table_name
% amopclaid,	amopopr,	oid,	oprname,	opcname # name
% ?,	?,	?,	?,	? # type
% ?,	?,	?,	?,	? # length

#SELECT p1.amopclaid, p1.amopopr, p2.oid, p2.oprname, p3.opcname
#FROM pg_amop AS p1, pg_operator AS p2, pg_opclass AS p3
#WHERE p1.amopopr = p2.oid AND p1.amopclaid = p3.oid AND
#    p1.amopsubtype = 0 AND
#    p2.oprleft != p2.oprright;
% sys.L0,	sys.L0,	sys.L0,	sys.L0,	sys.L0 # table_name
% amopclaid,	amopopr,	oid,	oprname,	opcname # name
% ?,	?,	?,	?,	? # type
% ?,	?,	?,	?,	? # length

#SELECT p1.amopclaid, p1.amopopr, p2.oid, p2.oprname, p3.opcname
#FROM pg_amop AS p1, pg_operator AS p2, pg_opclass AS p3
#WHERE p1.amopopr = p2.oid AND p1.amopclaid = p3.oid AND
#    p1.amopsubtype != 0 AND
#    p1.amopsubtype != p2.oprright;
% sys.L0,	sys.L0,	sys.L0,	sys.L0,	sys.L0 # table_name
% amopclaid,	amopopr,	oid,	oprname,	opcname # name
% ?,	?,	?,	?,	? # type
% ?,	?,	?,	?,	? # length

#-- Operators that are primary members of opclasses must be immutable (else
#-- it suggests that the index ordering isn't fixed).  Operators that are
#-- cross-type members need only be stable, since they are just shorthands
#-- for index probe queries.
#SELECT p1.amopclaid, p1.amopopr, p2.oprname, p3.prosrc
#FROM pg_amop AS p1, pg_operator AS p2, pg_proc AS p3
#WHERE p1.amopopr = p2.oid AND p2.oprcode = p3.oid AND
#    p1.amopsubtype = 0 AND
#    p3.provolatile != 'i';
% sys.L0,	sys.L0,	sys.L0,	sys.L0 # table_name
% amopclaid,	amopopr,	oprname,	prosrc # name
% ?,	?,	?,	? # type
% ?,	?,	?,	? # length

#SELECT p1.amopclaid, p1.amopopr, p2.oprname, p3.prosrc
#FROM pg_amop AS p1, pg_operator AS p2, pg_proc AS p3
#WHERE p1.amopopr = p2.oid AND p2.oprcode = p3.oid AND
#    p1.amopsubtype != 0 AND
#    p3.provolatile = 'v';
% sys.L0,	sys.L0,	sys.L0,	sys.L0 # table_name
% amopclaid,	amopopr,	oprname,	prosrc # name
% ?,	?,	?,	? # type
% ?,	?,	?,	? # length

#-- **************** pg_amproc ****************
#-- Look for illegal values in pg_amproc fields
#SELECT p1.amopclaid, p1.amprocnum
#FROM pg_amproc as p1
#WHERE p1.amopclaid = 0 OR p1.amprocnum <= 0 OR p1.amproc = 0;
% sys.L0,	sys.L0 # table_name
% amopclaid,	amprocnum # name
% ?,	? # type
% ?,	? # length

#-- Cross-check amprocnum index against parent AM
#SELECT p1.amopclaid, p1.amprocnum, p2.oid, p2.amname
#FROM pg_amproc AS p1, pg_am AS p2, pg_opclass AS p3
#WHERE p1.amopclaid = p3.oid AND p3.opcamid = p2.oid AND
#    p1.amprocnum > p2.amsupport;
% sys.L0,	sys.L0,	sys.L0,	sys.L0 # table_name
% amopclaid,	amprocnum,	oid,	amname # name
% ?,	?,	?,	? # type
% ?,	?,	?,	? # length

#-- Detect missing pg_amproc entries: should have as many support functions
#-- as AM expects for each opclass for the AM.  When nondefault subtypes are
#-- present, enforce condition separately for each subtype.
#SELECT p1.oid, p1.amname, p2.oid, p2.opcname, p3.amprocsubtype
#FROM pg_am AS p1, pg_opclass AS p2, pg_amproc AS p3
#WHERE p2.opcamid = p1.oid AND p3.amopclaid = p2.oid AND
#    p1.amsupport != (SELECT count(*) FROM pg_amproc AS p4
#                     WHERE p4.amopclaid = p2.oid AND
#                           p4.amprocsubtype = p3.amprocsubtype);
% sys.L0,	sys.L0,	sys.L0,	sys.L0,	sys.L0 # table_name
% oid,	amname,	oid,	opcname,	amprocsubtype # name
% ?,	?,	?,	?,	? # type
% ?,	?,	?,	?,	? # length

#-- Unfortunately, we can't check the amproc link very well because the
#-- signature of the function may be different for different support routines
#-- or different base data types.
#-- We can check that all the referenced instances of the same support
#-- routine number take the same number of parameters, but that's about it
#-- for a general check...
#SELECT p1.amopclaid, p1.amprocnum,
#	p2.oid, p2.proname,
#	p3.opcname,
#	p4.amopclaid, p4.amprocnum,
#	p5.oid, p5.proname,
#	p6.opcname
#FROM pg_amproc AS p1, pg_proc AS p2, pg_opclass AS p3,
#     pg_amproc AS p4, pg_proc AS p5, pg_opclass AS p6
#WHERE p1.amopclaid = p3.oid AND p4.amopclaid = p6.oid AND
#    p3.opcamid = p6.opcamid AND p1.amprocnum = p4.amprocnum AND
#    p1.amproc = p2.oid AND p4.amproc = p5.oid AND
#    (p2.proretset OR p5.proretset OR p2.pronargs != p5.pronargs);
% sys.L0,	sys.L0,	sys.L0,	sys.L0,	sys.L0,	sys.L0,	sys.L0,	sys.L0,	sys.L0,	sys.L0 # table_name
% amopclaid,	amprocnum,	oid,	proname,	opcname,	amopclaid,	amprocnum,	oid,	proname,	opcname # name
% ?,	?,	?,	?,	?,	?,	?,	?,	?,	? # type
% ?,	?,	?,	?,	?,	?,	?,	?,	?,	? # length

#-- For btree, though, we can do better since we know the support routines
#-- must be of the form cmp(input, input) returns integer in the default case
#-- (subtype = 0), and cmp(input, subtype) returns integer when subtype != 0.
#SELECT p1.amopclaid, p1.amprocnum,
#	p2.oid, p2.proname,
#	p3.opcname
#FROM pg_amproc AS p1, pg_proc AS p2, pg_opclass AS p3
#WHERE p3.opcamid = (SELECT oid FROM pg_am WHERE amname = 'btree')
#    AND p1.amopclaid = p3.oid AND p1.amproc = p2.oid AND
#    amprocsubtype = 0 AND
#    (opckeytype != 0
#     OR amprocnum != 1
#     OR proretset
#     OR prorettype != 23
#     OR pronargs != 2
#     OR NOT binary_coercible(opcintype, proargtypes[0])
#     OR proargtypes[0] != proargtypes[1]);
% sys.L0,	sys.L0,	sys.L0,	sys.L0,	sys.L0 # table_name
% amopclaid,	amprocnum,	oid,	proname,	opcname # name
% ?,	?,	?,	?,	? # type
% ?,	?,	?,	?,	? # length

#SELECT p1.amopclaid, p1.amprocnum,
#	p2.oid, p2.proname,
#	p3.opcname
#FROM pg_amproc AS p1, pg_proc AS p2, pg_opclass AS p3
#WHERE p3.opcamid = (SELECT oid FROM pg_am WHERE amname = 'btree')
#    AND p1.amopclaid = p3.oid AND p1.amproc = p2.oid AND
#    amprocsubtype != 0 AND
#    (opckeytype != 0
#     OR amprocnum != 1
#     OR proretset
#     OR prorettype != 23
#     OR pronargs != 2
#     OR NOT binary_coercible(opcintype, proargtypes[0])
#     OR proargtypes[1] != amprocsubtype);
% sys.L0,	sys.L0,	sys.L0,	sys.L0,	sys.L0 # table_name
% amopclaid,	amprocnum,	oid,	proname,	opcname # name
% ?,	?,	?,	?,	? # type
% ?,	?,	?,	?,	? # length

#-- For hash we can also do a little better: the support routines must be
#-- of the form hash(something) returns integer.  Ideally we'd check that the
#-- opcintype is binary-coercible to the function's input, but there are
#-- enough cases where that fails that I'll just leave out the check for now.
#SELECT p1.amopclaid, p1.amprocnum,
#	p2.oid, p2.proname,
#	p3.opcname
#FROM pg_amproc AS p1, pg_proc AS p2, pg_opclass AS p3
#WHERE p3.opcamid = (SELECT oid FROM pg_am WHERE amname = 'hash')
#    AND p1.amopclaid = p3.oid AND p1.amproc = p2.oid AND
#    (opckeytype != 0
#     OR amprocnum != 1
#     OR proretset
#     OR prorettype != 23
#     OR pronargs != 1
#);
% sys.L0,	sys.L0,	sys.L0,	sys.L0,	sys.L0 # table_name
% amopclaid,	amprocnum,	oid,	proname,	opcname # name
% ?,	?,	?,	?,	? # type
% ?,	?,	?,	?,	? # length

#-- Support routines that are primary members of opclasses must be immutable
#-- (else it suggests that the index ordering isn't fixed).  But cross-type
#-- members need only be stable, since they are just shorthands
#-- for index probe queries.
#SELECT p1.amopclaid, p1.amproc, p2.prosrc
#FROM pg_amproc AS p1, pg_proc AS p2
#WHERE p1.amproc = p2.oid AND
#    p1.amprocsubtype = 0 AND
#    p2.provolatile != 'i';
% sys.L0,	sys.L0,	sys.L0 # table_name
% amopclaid,	amproc,	prosrc # name
% ?,	?,	? # type
% ?,	?,	? # length

#SELECT p1.amopclaid, p1.amproc, p2.prosrc
#FROM pg_amproc AS p1, pg_proc AS p2
#WHERE p1.amproc = p2.oid AND
#    p1.amprocsubtype != 0 AND
#    p2.provolatile = 'v';
% sys.L0,	sys.L0,	sys.L0 # table_name
% amopclaid,	amproc,	prosrc # name
% ?,	?,	? # type
% ?,	?,	? # length


= ! Correct / expected output still needs to be provided / verified / approved ! =

# 17:11:19 >  
# 17:11:19 >  "Done."
# 17:11:19 >  

