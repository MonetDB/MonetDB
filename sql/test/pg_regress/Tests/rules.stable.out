stdout of test 'rules` in directory 'sql/test/pg_regress` itself:


# 17:11:18 >  
# 17:11:18 >  "mserver5" "--debug=10" "--set" "gdk_nr_threads=0" "--set" "mapi_open=true" "--set" "mapi_port=38959" "--set" "mapi_usock=/var/tmp/mtest-1142/.s.monetdb.38959" "--set" "monet_prompt=" "--forcemito" "--set" "mal_listing=2" "--dbpath=/ufs/dinther/INSTALL/var/MonetDB/mTests_sql_test_pg_regress" "--set" "mal_listing=0"
# 17:11:18 >  

# MonetDB 5 server v11.18.0
# This is an unreleased version
# Serving database 'mTests_sql_test_pg_regress', using 8 threads
# Compiled for x86_64-unknown-linux-gnu/64bit with 64bit OIDs dynamically linked
# Found 15.356 GiB available main-memory.
# Copyright (c) 1993-July 2008 CWI.
# Copyright (c) August 2008-2015 MonetDB B.V., all rights reserved
# Visit http://www.monetdb.org/ for further information
# Listening for connection requests on mapi:monetdb://uwakai.da.cwi.nl:38959/
# Listening for UNIX domain connection requests on mapi:monetdb:///var/tmp/mtest-1142/.s.monetdb.38959
# MonetDB/GIS module loaded
# MonetDB/SQL module loaded


# 17:11:19 >  
# 17:11:19 >  "mclient" "-lsql" "-ftest" "-Eutf-8" "-i" "-e" "--host=/var/tmp/mtest-1142" "--port=38959"
# 17:11:19 >  

= ! Correct / expected output still needs to be provided / verified / approved ! =

#--
#-- RULES
#-- From Jan's original setup_ruletest.sql and run_ruletest.sql
#-- - thomas 1998-09-13
#--
#--
#-- Tables and rules for the view test
#--
#create table rtest_t1 (a integer, b integer);
#create table rtest_t2 (a integer, b integer);
#create table rtest_t3 (a integer, b integer);
#create view rtest_v1 as select * from rtest_t1;
#create rule rtest_v1_ins as on insert to rtest_v1 do instead
#	insert into rtest_t1 values (new.a, new.b);
[ 1 ]
#create rule rtest_v1_upd as on update to rtest_v1 do instead
#	update rtest_t1 set a = new.a, b = new.b
#	where a = old.a;
#create rule rtest_v1_del as on delete to rtest_v1 do instead
#	delete from rtest_t1 where a = old.a;
#-- Test comments
#--
#-- Tables and rules for the constraint update/delete test
#--
#-- Note:
#-- 	Now that we have multiple action rule support, we check
#-- 	both possible syntaxes to define them (The last action
#--  can but must not have a semicolon at the end).
#--
#create table rtest_system (sysname text, sysdesc text);
#create table rtest_interface (sysname text, ifname text);
#create table rtest_person (pname text, pdesc text);
#create table rtest_admin (pname text, sysname text);
#create rule rtest_sys_upd as on update to rtest_system do also (
#	update rtest_interface set sysname = new.sysname 
#		where sysname = old.sysname;
#	update rtest_admin set sysname = new.sysname 
#		where sysname = old.sysname
#	);
#create rule rtest_sys_del as on delete to rtest_system do also (
#	delete from rtest_interface where sysname = old.sysname;
	delete from rtest_admin where sysname = old.sysname;
	);
#create rule rtest_pers_upd as on update to rtest_person do also
#	update rtest_admin set pname = new.pname where pname = old.pname;
#create rule rtest_pers_del as on delete to rtest_person do also
#	delete from rtest_admin where pname = old.pname;
#--
#-- Tables and rules for the logging test
#--
#create table rtest_emp (ename char(20), salary money);
#create table rtest_emplog (ename char(20), who string, action char(10), newsal money, oldsal money);
#create table rtest_empmass (ename char(20), salary money);
#create rule rtest_emp_ins as on insert to rtest_emp do
#	insert into rtest_emplog values (new.ename, current_user,
#			'hired', new.salary, '0.00');
[ 1 ]
#create rule rtest_emp_upd as on update to rtest_emp where new.salary != old.salary do
#	insert into rtest_emplog values (new.ename, current_user,
#			'honored', new.salary, old.salary);
[ 1 ]
#create rule rtest_emp_del as on delete to rtest_emp do
#	insert into rtest_emplog values (old.ename, current_user,
#			'fired', '0.00', old.salary);
[ 1 ]
#--
#-- Tables and rules for the multiple cascaded qualified instead
#-- rule test 
#--
#create table rtest_t4 (a integer, b text);
#create table rtest_t5 (a integer, b text);
#create table rtest_t6 (a integer, b text);
#create table rtest_t7 (a integer, b text);
#create table rtest_t8 (a integer, b text);
#create table rtest_t9 (a integer, b text);
#create rule rtest_t4_ins1 as on insert to rtest_t4
#		where new.a >= 10 and new.a < 20 do instead
#	insert into rtest_t5 values (new.a, new.b);
[ 1 ]
#create rule rtest_t4_ins2 as on insert to rtest_t4
#		where new.a >= 20 and new.a < 30 do
#	insert into rtest_t6 values (new.a, new.b);
[ 1 ]
#create rule rtest_t5_ins as on insert to rtest_t5
#		where new.a > 15 do
#	insert into rtest_t7 values (new.a, new.b);
[ 1 ]
#create rule rtest_t6_ins as on insert to rtest_t6
#		where new.a > 25 do instead
#	insert into rtest_t8 values (new.a, new.b);
[ 1 ]
#--
#-- Tables and rules for the rule fire order test
#--
#-- As of PG 7.3, the rules should fire in order by string, regardless
#-- of INSTEAD attributes or creation order.
#--
#create table rtest_order1 (a integer);
#create table rtest_order2 (a integer, b integer, c text);
#create sequence rtest_seq;
#create rule rtest_order_r3 as on insert to rtest_order1 do instead
#	insert into rtest_order2 values (new.a, nextval('rtest_seq'),
#		'rule 3 - this should run 3rd');
[ 1 ]
#create rule rtest_order_r4 as on insert to rtest_order1
#		where a < 100 do instead
#	insert into rtest_order2 values (new.a, nextval('rtest_seq'),
#		'rule 4 - this should run 4th');
[ 1 ]
#create rule rtest_order_r2 as on insert to rtest_order1 do
#	insert into rtest_order2 values (new.a, nextval('rtest_seq'),
#		'rule 2 - this should run 2nd');
[ 1 ]
#create rule rtest_order_r1 as on insert to rtest_order1 do instead
#	insert into rtest_order2 values (new.a, nextval('rtest_seq'),
#		'rule 1 - this should run 1st');
[ 1 ]
#--
#-- Tables and rules for the instead nothing test
#--
#create table rtest_nothn1 (a integer, b text);
#create table rtest_nothn2 (a integer, b text);
#create table rtest_nothn3 (a integer, b text);
#create table rtest_nothn4 (a integer, b text);
#create rule rtest_nothn_r1 as on insert to rtest_nothn1
#	where new.a >= 10 and new.a < 20 do instead nothing;
#create rule rtest_nothn_r2 as on insert to rtest_nothn1
#	where new.a >= 30 and new.a < 40 do instead nothing;
#create rule rtest_nothn_r3 as on insert to rtest_nothn2
#	where new.a >= 100 do instead
#	insert into rtest_nothn3 values (new.a, new.b);
[ 1 ]
#create rule rtest_nothn_r4 as on insert to rtest_nothn2
#	do instead nothing;
#--
#-- Tests on a view that is select * of a table
#-- and has insert/update/delete instead rules to
#-- behave close like the real table.
#--
#--
#-- We need test date later
#--
#insert into rtest_t2 values (1, 21);
[ 1 ]
#insert into rtest_t2 values (2, 22);
[ 1 ]
#insert into rtest_t2 values (3, 23);
[ 1 ]
#insert into rtest_t3 values (1, 31);
[ 1 ]
#insert into rtest_t3 values (2, 32);
[ 1 ]
#insert into rtest_t3 values (3, 33);
[ 1 ]
#insert into rtest_t3 values (4, 34);
[ 1 ]
#insert into rtest_t3 values (5, 35);
[ 1 ]
#-- insert values
#insert into rtest_v1 values (1, 11);
[ 1 ]
#insert into rtest_v1 values (2, 12);
[ 1 ]
#select * from rtest_v1;
% sys.L0,	sys.L0 # table_name
% a,	b # name
% ?,	? # type
% ?,	? # length
[ 1,	11 ]
[ 2,	12 ]

#-- delete with constant expression
delete from rtest_v1 where a = 1;
#select * from rtest_v1;
% sys.L0,	sys.L0 # table_name
% a,	b # name
% ?,	? # type
% ?,	? # length
[ 2,	12 ]

#insert into rtest_v1 values (1, 11);
[ 1 ]
delete from rtest_v1 where b = 12;
#select * from rtest_v1;
% sys.L0,	sys.L0 # table_name
% a,	b # name
% ?,	? # type
% ?,	? # length
[ 1,	11 ]

#insert into rtest_v1 values (2, 12);
[ 1 ]
#insert into rtest_v1 values (2, 13);
[ 1 ]
#select * from rtest_v1;
% sys.L0,	sys.L0 # table_name
% a,	b # name
% ?,	? # type
% ?,	? # length
[ 1,	11 ]
[ 2,	12 ]
[ 2,	13 ]

** Remember the delete rule on rtest_v1: It says
** DO INSTEAD DELETE FROM rtest_t1 WHERE a = old.a
** So this time both rows with a = 2 must get deleted
\p
** Remember the delete rule on rtest_v1: It says
** DO INSTEAD DELETE FROM rtest_t1 WHERE a = old.a
** So this time both rows with a = 2 must get deleted
\r
delete from rtest_v1 where b = 12;
#select * from rtest_v1;
% sys.L0,	sys.L0 # table_name
% a,	b # name
% ?,	? # type
% ?,	? # length
[ 1,	11 ]

delete from rtest_v1;
#-- insert select
#insert into rtest_v1 select * from rtest_t2;
[ 1 ]
#select * from rtest_v1;
% sys.L0,	sys.L0 # table_name
% a,	b # name
% ?,	? # type
% ?,	? # length
[ 1,	21 ]
[ 2,	22 ]
[ 3,	23 ]

delete from rtest_v1;
#-- same with swapped targetlist
#insert into rtest_v1 (b, a) select b, a from rtest_t2;
[ 1 ]
#select * from rtest_v1;
% sys.L0,	sys.L0 # table_name
% a,	b # name
% ?,	? # type
% ?,	? # length
[ 1,	21 ]
[ 2,	22 ]
[ 3,	23 ]

#-- now with only one target attribute
#insert into rtest_v1 (a) select a from rtest_t3;
[ 1 ]
#select * from rtest_v1;
% sys.L0,	sys.L0 # table_name
% a,	b # name
% ?,	? # type
% ?,	? # length
[ 1,	21 ]
[ 2,	22 ]
[ 3,	23 ]
[ 1,	"" ]
[ 2,	"" ]
[ 3,	"" ]
[ 4,	"" ]
[ 5,	"" ]

#select * from rtest_v1 where b isnull;
% sys.L0,	sys.L0 # table_name
% a,	b # name
% ?,	? # type
% ?,	? # length
[ 1,	"" ]
[ 2,	"" ]
[ 3,	"" ]
[ 4,	"" ]
[ 5,	"" ]

#-- let attribute a differ (must be done on rtest_t1 - see above)
#update rtest_t1 set a = a + 10 where b isnull;
delete from rtest_v1 where b isnull;
#select * from rtest_v1;
% sys.L0,	sys.L0 # table_name
% a,	b # name
% ?,	? # type
% ?,	? # length
[ 1,	21 ]
[ 2,	22 ]
[ 3,	23 ]

#-- now updates with constant expression
#update rtest_v1 set b = 42 where a = 2;
#select * from rtest_v1;
% sys.L0,	sys.L0 # table_name
% a,	b # name
% ?,	? # type
% ?,	? # length
[ 1,	21 ]
[ 3,	23 ]
[ 2,	42 ]

#update rtest_v1 set b = 99 where b = 42;
#select * from rtest_v1;
% sys.L0,	sys.L0 # table_name
% a,	b # name
% ?,	? # type
% ?,	? # length
[ 1,	21 ]
[ 3,	23 ]
[ 2,	99 ]

#update rtest_v1 set b = 88 where b < 50;
#select * from rtest_v1;
% sys.L0,	sys.L0 # table_name
% a,	b # name
% ?,	? # type
% ?,	? # length
[ 2,	99 ]
[ 1,	88 ]
[ 3,	88 ]

delete from rtest_v1;
#insert into rtest_v1 select rtest_t2.a, rtest_t3.b where rtest_t2.a = rtest_t3.a;
[ 1 ]
#select * from rtest_v1;
% sys.L0,	sys.L0 # table_name
% a,	b # name
% ?,	? # type
% ?,	? # length
[ 1,	31 ]
[ 2,	32 ]
[ 3,	33 ]

#-- updates in a mergejoin
#update rtest_v1 set b = rtest_t2.b where a = rtest_t2.a;
#select * from rtest_v1;
% sys.L0,	sys.L0 # table_name
% a,	b # name
% ?,	? # type
% ?,	? # length
[ 1,	21 ]
[ 2,	22 ]
[ 3,	23 ]

#insert into rtest_v1 select * from rtest_t3;
[ 1 ]
#select * from rtest_v1;
% sys.L0,	sys.L0 # table_name
% a,	b # name
% ?,	? # type
% ?,	? # length
[ 1,	21 ]
[ 2,	22 ]
[ 3,	23 ]
[ 1,	31 ]
[ 2,	32 ]
[ 3,	33 ]
[ 4,	34 ]
[ 5,	35 ]

#update rtest_t1 set a = a + 10 where b > 30;
#select * from rtest_v1;
% sys.L0,	sys.L0 # table_name
% a,	b # name
% ?,	? # type
% ?,	? # length
[ 1,	21 ]
[ 2,	22 ]
[ 3,	23 ]
[ 11,	31 ]
[ 12,	32 ]
[ 13,	33 ]
[ 14,	34 ]
[ 15,	35 ]

#update rtest_v1 set a = rtest_t3.a + 20 where b = rtest_t3.b;
#select * from rtest_v1;
% sys.L0,	sys.L0 # table_name
% a,	b # name
% ?,	? # type
% ?,	? # length
[ 1,	21 ]
[ 2,	22 ]
[ 3,	23 ]
[ 21,	31 ]
[ 22,	32 ]
[ 23,	33 ]
[ 24,	34 ]
[ 25,	35 ]

#--
#-- Test for constraint updates/deletes
#--
#insert into rtest_system values ('orion', 'Linux Jan Wieck');
[ 1 ]
#insert into rtest_system values ('notjw', 'WinNT Jan Wieck (notebook)');
[ 1 ]
#insert into rtest_system values ('neptun', 'Fileserver');
[ 1 ]
#insert into rtest_interface values ('orion', 'eth0');
[ 1 ]
#insert into rtest_interface values ('orion', 'eth1');
[ 1 ]
#insert into rtest_interface values ('notjw', 'eth0');
[ 1 ]
#insert into rtest_interface values ('neptun', 'eth0');
[ 1 ]
#insert into rtest_person values ('jw', 'Jan Wieck');
[ 1 ]
#insert into rtest_person values ('bm', 'Bruce Momjian');
[ 1 ]
#insert into rtest_admin values ('jw', 'orion');
[ 1 ]
#insert into rtest_admin values ('jw', 'notjw');
[ 1 ]
#insert into rtest_admin values ('bm', 'neptun');
[ 1 ]
#update rtest_system set sysname = 'pluto' where sysname = 'neptun';
#select * from rtest_interface;
% sys.L0,	sys.L0 # table_name
% sysname,	ifname # name
% ?,	? # type
% ?,	? # length
[ "orion",	"eth0" ]
[ "orion",	"eth1" ]
[ "notjw",	"eth0" ]
[ "pluto",	"eth0" ]

#select * from rtest_admin;
% sys.L0,	sys.L0 # table_name
% pname,	sysname # name
% ?,	? # type
% ?,	? # length
[ "jw",	"orion" ]
[ "jw",	"notjw" ]
[ "bm",	"pluto" ]

#update rtest_person set pname = 'jwieck' where pdesc = 'Jan Wieck';
#-- Note: use ORDER BY here to ensure consistent output across all systems.
#-- The above UPDATE affects two rows with equal keys, so they could be
#-- updated in either order depending on the whim of the local qsort().
#select * from rtest_admin order by pname, sysname;
% sys.L0,	sys.L0 # table_name
% pname,	sysname # name
% ?,	? # type
% ?,	? # length
[ "bm",	"pluto" ]
[ "jwieck",	"notjw" ]
[ "jwieck",	"orion" ]

delete from rtest_system where sysname = 'orion';
#select * from rtest_interface;
% sys.L0,	sys.L0 # table_name
% sysname,	ifname # name
% ?,	? # type
% ?,	? # length
[ "notjw",	"eth0" ]
[ "pluto",	"eth0" ]

#select * from rtest_admin;
% sys.L0,	sys.L0 # table_name
% pname,	sysname # name
% ?,	? # type
% ?,	? # length
[ "bm",	"pluto" ]
[ "jwieck",	"notjw" ]

#--
#-- Rule qualification test
#--
#insert into rtest_emp values ('wiech', '5000.00');
[ 1 ]
#insert into rtest_emp values ('gates', '80000.00');
[ 1 ]
#update rtest_emp set ename = 'wiecx' where ename = 'wiech';
#update rtest_emp set ename = 'wieck', salary = '6000.00' where ename = 'wiecx';
#update rtest_emp set salary = '7000.00' where ename = 'wieck';
delete from rtest_emp where ename = 'gates';
#select ename, who = current_user as "matches user", action, newsal, oldsal from rtest_emplog order by ename, action, newsal;
% sys.L0,	sys.L0,	sys.L0,	sys.L0,	sys.L0 # table_name
% ename,	matches user,	action,	newsal,	oldsal # name
% ?,	?,	?,	?,	? # type
% ?,	?,	?,	?,	? # length
[ "gates",	"t",	"fired",	"$0.00",	"$80,000.00" ]
[ "gates",	"t",	"hired",	"$80,000.00",	"$0.00" ]
[ "wiech",	"t",	"hired",	"$5,000.00",	"$0.00" ]
[ "wieck",	"t",	"honored",	"$6,000.00",	"$5,000.00" ]
[ "wieck",	"t",	"honored",	"$7,000.00",	"$6,000.00" ]

#insert into rtest_empmass values ('meyer', '4000.00');
[ 1 ]
#insert into rtest_empmass values ('maier', '5000.00');
[ 1 ]
#insert into rtest_empmass values ('mayr', '6000.00');
[ 1 ]
#insert into rtest_emp select * from rtest_empmass;
[ 1 ]
#select ename, who = current_user as "matches user", action, newsal, oldsal from rtest_emplog order by ename, action, newsal;
% sys.L0,	sys.L0,	sys.L0,	sys.L0,	sys.L0 # table_name
% ename,	matches user,	action,	newsal,	oldsal # name
% ?,	?,	?,	?,	? # type
% ?,	?,	?,	?,	? # length
[ "gates",	"t",	"fired",	"$0.00",	"$80,000.00" ]
[ "gates",	"t",	"hired",	"$80,000.00",	"$0.00" ]
[ "maier",	"t",	"hired",	"$5,000.00",	"$0.00" ]
[ "mayr",	"t",	"hired",	"$6,000.00",	"$0.00" ]
[ "meyer",	"t",	"hired",	"$4,000.00",	"$0.00" ]
[ "wiech",	"t",	"hired",	"$5,000.00",	"$0.00" ]
[ "wieck",	"t",	"honored",	"$6,000.00",	"$5,000.00" ]
[ "wieck",	"t",	"honored",	"$7,000.00",	"$6,000.00" ]

#update rtest_empmass set salary = salary + '1000.00';
#update rtest_emp set salary = rtest_empmass.salary where ename = rtest_empmass.ename;
#select ename, who = current_user as "matches user", action, newsal, oldsal from rtest_emplog order by ename, action, newsal;
% sys.L0,	sys.L0,	sys.L0,	sys.L0,	sys.L0 # table_name
% ename,	matches user,	action,	newsal,	oldsal # name
% ?,	?,	?,	?,	? # type
% ?,	?,	?,	?,	? # length
[ "gates",	"t",	"fired",	"$0.00",	"$80,000.00" ]
[ "gates",	"t",	"hired",	"$80,000.00",	"$0.00" ]
[ "maier",	"t",	"hired",	"$5,000.00",	"$0.00" ]
[ "maier",	"t",	"honored",	"$6,000.00",	"$5,000.00" ]
[ "mayr",	"t",	"hired",	"$6,000.00",	"$0.00" ]
[ "mayr",	"t",	"honored",	"$7,000.00",	"$6,000.00" ]
[ "meyer",	"t",	"hired",	"$4,000.00",	"$0.00" ]
[ "meyer",	"t",	"honored",	"$5,000.00",	"$4,000.00" ]
[ "wiech",	"t",	"hired",	"$5,000.00",	"$0.00" ]
[ "wieck",	"t",	"honored",	"$6,000.00",	"$5,000.00" ]
[ "wieck",	"t",	"honored",	"$7,000.00",	"$6,000.00" ]

delete from rtest_emp where ename = rtest_empmass.ename;
#select ename, who = current_user as "matches user", action, newsal, oldsal from rtest_emplog order by ename, action, newsal;
% sys.L0,	sys.L0,	sys.L0,	sys.L0,	sys.L0 # table_name
% ename,	matches user,	action,	newsal,	oldsal # name
% ?,	?,	?,	?,	? # type
% ?,	?,	?,	?,	? # length
[ "gates",	"t",	"fired",	"$0.00",	"$80,000.00" ]
[ "gates",	"t",	"hired",	"$80,000.00",	"$0.00" ]
[ "maier",	"t",	"fired",	"$0.00",	"$6,000.00" ]
[ "maier",	"t",	"hired",	"$5,000.00",	"$0.00" ]
[ "maier",	"t",	"honored",	"$6,000.00",	"$5,000.00" ]
[ "mayr",	"t",	"fired",	"$0.00",	"$7,000.00" ]
[ "mayr",	"t",	"hired",	"$6,000.00",	"$0.00" ]
[ "mayr",	"t",	"honored",	"$7,000.00",	"$6,000.00" ]
[ "meyer",	"t",	"fired",	"$0.00",	"$5,000.00" ]
[ "meyer",	"t",	"hired",	"$4,000.00",	"$0.00" ]
[ "meyer",	"t",	"honored",	"$5,000.00",	"$4,000.00" ]
[ "wiech",	"t",	"hired",	"$5,000.00",	"$0.00" ]
[ "wieck",	"t",	"honored",	"$6,000.00",	"$5,000.00" ]
[ "wieck",	"t",	"honored",	"$7,000.00",	"$6,000.00" ]

#--
#-- Multiple cascaded qualified instead rule test
#--
#insert into rtest_t4 values (1, 'Record should go to rtest_t4');
[ 1 ]
#insert into rtest_t4 values (2, 'Record should go to rtest_t4');
[ 1 ]
#insert into rtest_t4 values (10, 'Record should go to rtest_t5');
[ 1 ]
#insert into rtest_t4 values (15, 'Record should go to rtest_t5');
[ 1 ]
#insert into rtest_t4 values (19, 'Record should go to rtest_t5 and t7');
[ 1 ]
#insert into rtest_t4 values (20, 'Record should go to rtest_t4 and t6');
[ 1 ]
#insert into rtest_t4 values (26, 'Record should go to rtest_t4 and t8');
[ 1 ]
#insert into rtest_t4 values (28, 'Record should go to rtest_t4 and t8');
[ 1 ]
#insert into rtest_t4 values (30, 'Record should go to rtest_t4');
[ 1 ]
#insert into rtest_t4 values (40, 'Record should go to rtest_t4');
[ 1 ]
#select * from rtest_t4;
% sys.L0,	sys.L0 # table_name
% a,	b # name
% ?,	? # type
% ?,	? # length
[ 1,	"Record should go to rtest_t4" ]
[ 2,	"Record should go to rtest_t4" ]
[ 20,	"Record should go to rtest_t4 and t6" ]
[ 26,	"Record should go to rtest_t4 and t8" ]
[ 28,	"Record should go to rtest_t4 and t8" ]
[ 30,	"Record should go to rtest_t4" ]
[ 40,	"Record should go to rtest_t4" ]

#select * from rtest_t5;
% sys.L0,	sys.L0 # table_name
% a,	b # name
% ?,	? # type
% ?,	? # length
[ 10,	"Record should go to rtest_t5" ]
[ 15,	"Record should go to rtest_t5" ]
[ 19,	"Record should go to rtest_t5 and t7" ]

#select * from rtest_t6;
% sys.L0,	sys.L0 # table_name
% a,	b # name
% ?,	? # type
% ?,	? # length
[ 20,	"Record should go to rtest_t4 and t6" ]

#select * from rtest_t7;
% sys.L0,	sys.L0 # table_name
% a,	b # name
% ?,	? # type
% ?,	? # length
[ 19,	"Record should go to rtest_t5 and t7" ]

#select * from rtest_t8;
% sys.L0,	sys.L0 # table_name
% a,	b # name
% ?,	? # type
% ?,	? # length
[ 26,	"Record should go to rtest_t4 and t8" ]
[ 28,	"Record should go to rtest_t4 and t8" ]

delete from rtest_t4;
delete from rtest_t5;
delete from rtest_t6;
delete from rtest_t7;
delete from rtest_t8;
#insert into rtest_t9 values (1, 'Record should go to rtest_t4');
[ 1 ]
#insert into rtest_t9 values (2, 'Record should go to rtest_t4');
[ 1 ]
#insert into rtest_t9 values (10, 'Record should go to rtest_t5');
[ 1 ]
#insert into rtest_t9 values (15, 'Record should go to rtest_t5');
[ 1 ]
#insert into rtest_t9 values (19, 'Record should go to rtest_t5 and t7');
[ 1 ]
#insert into rtest_t9 values (20, 'Record should go to rtest_t4 and t6');
[ 1 ]
#insert into rtest_t9 values (26, 'Record should go to rtest_t4 and t8');
[ 1 ]
#insert into rtest_t9 values (28, 'Record should go to rtest_t4 and t8');
[ 1 ]
#insert into rtest_t9 values (30, 'Record should go to rtest_t4');
[ 1 ]
#insert into rtest_t9 values (40, 'Record should go to rtest_t4');
[ 1 ]
#insert into rtest_t4 select * from rtest_t9 where a < 20;
[ 1 ]
#select * from rtest_t4;
% sys.L0,	sys.L0 # table_name
% a,	b # name
% ?,	? # type
% ?,	? # length
[ 1,	"Record should go to rtest_t4" ]
[ 2,	"Record should go to rtest_t4" ]

#select * from rtest_t5;
% sys.L0,	sys.L0 # table_name
% a,	b # name
% ?,	? # type
% ?,	? # length
[ 10,	"Record should go to rtest_t5" ]
[ 15,	"Record should go to rtest_t5" ]
[ 19,	"Record should go to rtest_t5 and t7" ]

#select * from rtest_t6;
% sys.L0,	sys.L0 # table_name
% a,	b # name
% ?,	? # type
% ?,	? # length

#select * from rtest_t7;
% sys.L0,	sys.L0 # table_name
% a,	b # name
% ?,	? # type
% ?,	? # length
[ 19,	"Record should go to rtest_t5 and t7" ]

#select * from rtest_t8;
% sys.L0,	sys.L0 # table_name
% a,	b # name
% ?,	? # type
% ?,	? # length

#insert into rtest_t4 select * from rtest_t9 where b ~ 'and t8';
[ 1 ]
#select * from rtest_t4;
% sys.L0,	sys.L0 # table_name
% a,	b # name
% ?,	? # type
% ?,	? # length
[ 1,	"Record should go to rtest_t4" ]
[ 2,	"Record should go to rtest_t4" ]
[ 26,	"Record should go to rtest_t4 and t8" ]
[ 28,	"Record should go to rtest_t4 and t8" ]

#select * from rtest_t5;
% sys.L0,	sys.L0 # table_name
% a,	b # name
% ?,	? # type
% ?,	? # length
[ 10,	"Record should go to rtest_t5" ]
[ 15,	"Record should go to rtest_t5" ]
[ 19,	"Record should go to rtest_t5 and t7" ]

#select * from rtest_t6;
% sys.L0,	sys.L0 # table_name
% a,	b # name
% ?,	? # type
% ?,	? # length

#select * from rtest_t7;
% sys.L0,	sys.L0 # table_name
% a,	b # name
% ?,	? # type
% ?,	? # length
[ 19,	"Record should go to rtest_t5 and t7" ]

#select * from rtest_t8;
% sys.L0,	sys.L0 # table_name
% a,	b # name
% ?,	? # type
% ?,	? # length
[ 26,	"Record should go to rtest_t4 and t8" ]
[ 28,	"Record should go to rtest_t4 and t8" ]

#insert into rtest_t4 select a + 1, b from rtest_t9 where a in (20, 30, 40);
[ 1 ]
#select * from rtest_t4;
% sys.L0,	sys.L0 # table_name
% a,	b # name
% ?,	? # type
% ?,	? # length
[ 1,	"Record should go to rtest_t4" ]
[ 2,	"Record should go to rtest_t4" ]
[ 26,	"Record should go to rtest_t4 and t8" ]
[ 28,	"Record should go to rtest_t4 and t8" ]
[ 21,	"Record should go to rtest_t4 and t6" ]
[ 31,	"Record should go to rtest_t4" ]
[ 41,	"Record should go to rtest_t4" ]

#select * from rtest_t5;
% sys.L0,	sys.L0 # table_name
% a,	b # name
% ?,	? # type
% ?,	? # length
[ 10,	"Record should go to rtest_t5" ]
[ 15,	"Record should go to rtest_t5" ]
[ 19,	"Record should go to rtest_t5 and t7" ]

#select * from rtest_t6;
% sys.L0,	sys.L0 # table_name
% a,	b # name
% ?,	? # type
% ?,	? # length
[ 21,	"Record should go to rtest_t4 and t6" ]

#select * from rtest_t7;
% sys.L0,	sys.L0 # table_name
% a,	b # name
% ?,	? # type
% ?,	? # length
[ 19,	"Record should go to rtest_t5 and t7" ]

#select * from rtest_t8;
% sys.L0,	sys.L0 # table_name
% a,	b # name
% ?,	? # type
% ?,	? # length
[ 26,	"Record should go to rtest_t4 and t8" ]
[ 28,	"Record should go to rtest_t4 and t8" ]

#--
#-- Check that the ordering of rules fired is correct
#--
#insert into rtest_order1 values (1);
[ 1 ]
#select * from rtest_order2;
% sys.L0,	sys.L0,	sys.L0 # table_name
% a,	b,	c # name
% ?,	?,	? # type
% ?,	?,	? # length
[ 1,	1,	"rule 1 - this should run 1st" ]
[ 1,	2,	"rule 2 - this should run 2nd" ]
[ 1,	3,	"rule 3 - this should run 3rd" ]
[ 1,	4,	"rule 4 - this should run 4th" ]

#--
#-- Check if instead nothing w/without qualification works
#--
#insert into rtest_nothn1 values (1, 'want this');
[ 1 ]
#insert into rtest_nothn1 values (2, 'want this');
[ 1 ]
#insert into rtest_nothn1 values (10, 'don''t want this');
[ 1 ]
#insert into rtest_nothn1 values (19, 'don''t want this');
[ 1 ]
#insert into rtest_nothn1 values (20, 'want this');
[ 1 ]
#insert into rtest_nothn1 values (29, 'want this');
[ 1 ]
#insert into rtest_nothn1 values (30, 'don''t want this');
[ 1 ]
#insert into rtest_nothn1 values (39, 'don''t want this');
[ 1 ]
#insert into rtest_nothn1 values (40, 'want this');
[ 1 ]
#insert into rtest_nothn1 values (50, 'want this');
[ 1 ]
#insert into rtest_nothn1 values (60, 'want this');
[ 1 ]
#select * from rtest_nothn1;
% sys.L0,	sys.L0 # table_name
% a,	b # name
% ?,	? # type
% ?,	? # length
[ 1,	"want this" ]
[ 2,	"want this" ]
[ 20,	"want this" ]
[ 29,	"want this" ]
[ 40,	"want this" ]
[ 50,	"want this" ]
[ 60,	"want this" ]

#insert into rtest_nothn2 values (10, 'too small');
[ 1 ]
#insert into rtest_nothn2 values (50, 'too small');
[ 1 ]
#insert into rtest_nothn2 values (100, 'OK');
[ 1 ]
#insert into rtest_nothn2 values (200, 'OK');
[ 1 ]
#select * from rtest_nothn2;
% sys.L0,	sys.L0 # table_name
% a,	b # name
% ?,	? # type
% ?,	? # length

#select * from rtest_nothn3;
% sys.L0,	sys.L0 # table_name
% a,	b # name
% ?,	? # type
% ?,	? # length
[ 100,	"OK" ]
[ 200,	"OK" ]

delete from rtest_nothn1;
delete from rtest_nothn2;
delete from rtest_nothn3;
#insert into rtest_nothn4 values (1, 'want this');
[ 1 ]
#insert into rtest_nothn4 values (2, 'want this');
[ 1 ]
#insert into rtest_nothn4 values (10, 'don''t want this');
[ 1 ]
#insert into rtest_nothn4 values (19, 'don''t want this');
[ 1 ]
#insert into rtest_nothn4 values (20, 'want this');
[ 1 ]
#insert into rtest_nothn4 values (29, 'want this');
[ 1 ]
#insert into rtest_nothn4 values (30, 'don''t want this');
[ 1 ]
#insert into rtest_nothn4 values (39, 'don''t want this');
[ 1 ]
#insert into rtest_nothn4 values (40, 'want this');
[ 1 ]
#insert into rtest_nothn4 values (50, 'want this');
[ 1 ]
#insert into rtest_nothn4 values (60, 'want this');
[ 1 ]
#insert into rtest_nothn1 select * from rtest_nothn4;
[ 1 ]
#select * from rtest_nothn1;
% sys.L0,	sys.L0 # table_name
% a,	b # name
% ?,	? # type
% ?,	? # length
[ 1,	"want this" ]
[ 2,	"want this" ]
[ 20,	"want this" ]
[ 29,	"want this" ]
[ 40,	"want this" ]
[ 50,	"want this" ]
[ 60,	"want this" ]

delete from rtest_nothn4;
#insert into rtest_nothn4 values (10, 'too small');
[ 1 ]
#insert into rtest_nothn4 values (50, 'too small');
[ 1 ]
#insert into rtest_nothn4 values (100, 'OK');
[ 1 ]
#insert into rtest_nothn4 values (200, 'OK');
[ 1 ]
#insert into rtest_nothn2 select * from rtest_nothn4;
[ 1 ]
#select * from rtest_nothn2;
% sys.L0,	sys.L0 # table_name
% a,	b # name
% ?,	? # type
% ?,	? # length

#select * from rtest_nothn3;
% sys.L0,	sys.L0 # table_name
% a,	b # name
% ?,	? # type
% ?,	? # length
[ 100,	"OK" ]
[ 200,	"OK" ]

#create table rtest_view1 (a integer, b text, v bool);
#create table rtest_view2 (a integer);
#create table rtest_view3 (a integer, b text);
#create table rtest_view4 (a integer, b text, c integer);
#create view rtest_vview1 as select a, b from rtest_view1 X 
#	where 0 < (select count(*) from rtest_view2 Y where Y.a = X.a);
#create view rtest_vview2 as select a, b from rtest_view1 where v;
#create view rtest_vview3 as select a, b from rtest_vview2 X
#	where 0 < (select count(*) from rtest_view2 Y where Y.a = X.a);
#create view rtest_vview4 as select X.a, X.b, count(Y.a) as refcount
#	from rtest_view1 X, rtest_view2 Y
#	where X.a = Y.a
#	group by X.a, X.b;
#create function rtest_viewfunc1(integer) returns integer as
#	'select count(*)::integer from rtest_view2 where a = $1'
#	language 'sql';
#create view rtest_vview5 as select a, b, rtest_viewfunc1(a) as refcount
#	from rtest_view1;
#insert into rtest_view1 values (1, 'item 1', 't');
[ 1 ]
#insert into rtest_view1 values (2, 'item 2', 't');
[ 1 ]
#insert into rtest_view1 values (3, 'item 3', 't');
[ 1 ]
#insert into rtest_view1 values (4, 'item 4', 'f');
[ 1 ]
#insert into rtest_view1 values (5, 'item 5', 't');
[ 1 ]
#insert into rtest_view1 values (6, 'item 6', 'f');
[ 1 ]
#insert into rtest_view1 values (7, 'item 7', 't');
[ 1 ]
#insert into rtest_view1 values (8, 'item 8', 't');
[ 1 ]
#insert into rtest_view2 values (2);
[ 1 ]
#insert into rtest_view2 values (2);
[ 1 ]
#insert into rtest_view2 values (4);
[ 1 ]
#insert into rtest_view2 values (5);
[ 1 ]
#insert into rtest_view2 values (7);
[ 1 ]
#insert into rtest_view2 values (7);
[ 1 ]
#insert into rtest_view2 values (7);
[ 1 ]
#insert into rtest_view2 values (7);
[ 1 ]
#select * from rtest_vview1;
% sys.L0,	sys.L0 # table_name
% a,	b # name
% ?,	? # type
% ?,	? # length
[ 2,	"item 2" ]
[ 4,	"item 4" ]
[ 5,	"item 5" ]
[ 7,	"item 7" ]

#select * from rtest_vview2;
% sys.L0,	sys.L0 # table_name
% a,	b # name
% ?,	? # type
% ?,	? # length
[ 1,	"item 1" ]
[ 2,	"item 2" ]
[ 3,	"item 3" ]
[ 5,	"item 5" ]
[ 7,	"item 7" ]
[ 8,	"item 8" ]

#select * from rtest_vview3;
% sys.L0,	sys.L0 # table_name
% a,	b # name
% ?,	? # type
% ?,	? # length
[ 2,	"item 2" ]
[ 5,	"item 5" ]
[ 7,	"item 7" ]

#select * from rtest_vview4 order by a, b;
% sys.L0,	sys.L0,	sys.L0 # table_name
% a,	b,	refcount # name
% ?,	?,	? # type
% ?,	?,	? # length
[ 2,	"item 2",	2 ]
[ 4,	"item 4",	1 ]
[ 5,	"item 5",	1 ]
[ 7,	"item 7",	4 ]

#select * from rtest_vview5;
% sys.L0,	sys.L0,	sys.L0 # table_name
% a,	b,	refcount # name
% ?,	?,	? # type
% ?,	?,	? # length
[ 1,	"item 1",	0 ]
[ 2,	"item 2",	2 ]
[ 3,	"item 3",	0 ]
[ 4,	"item 4",	1 ]
[ 5,	"item 5",	1 ]
[ 6,	"item 6",	0 ]
[ 7,	"item 7",	4 ]
[ 8,	"item 8",	0 ]

#insert into rtest_view3 select * from rtest_vview1 where a < 7;
[ 1 ]
#select * from rtest_view3;
% sys.L0,	sys.L0 # table_name
% a,	b # name
% ?,	? # type
% ?,	? # length
[ 2,	"item 2" ]
[ 4,	"item 4" ]
[ 5,	"item 5" ]

delete from rtest_view3;
#insert into rtest_view3 select * from rtest_vview2 where a != 5 and b !~ '2';
[ 1 ]
#select * from rtest_view3;
% sys.L0,	sys.L0 # table_name
% a,	b # name
% ?,	? # type
% ?,	? # length
[ 1,	"item 1" ]
[ 3,	"item 3" ]
[ 7,	"item 7" ]
[ 8,	"item 8" ]

delete from rtest_view3;
#insert into rtest_view3 select * from rtest_vview3;
[ 1 ]
#select * from rtest_view3;
% sys.L0,	sys.L0 # table_name
% a,	b # name
% ?,	? # type
% ?,	? # length
[ 2,	"item 2" ]
[ 5,	"item 5" ]
[ 7,	"item 7" ]

delete from rtest_view3;
#insert into rtest_view4 select * from rtest_vview4 where 3 > refcount;
[ 1 ]
#select * from rtest_view4 order by a, b;
% sys.L0,	sys.L0,	sys.L0 # table_name
% a,	b,	c # name
% ?,	?,	? # type
% ?,	?,	? # length
[ 2,	"item 2",	2 ]
[ 4,	"item 4",	1 ]
[ 5,	"item 5",	1 ]

delete from rtest_view4;
#insert into rtest_view4 select * from rtest_vview5 where a > 2 and refcount = 0;
[ 1 ]
#select * from rtest_view4;
% sys.L0,	sys.L0,	sys.L0 # table_name
% a,	b,	c # name
% ?,	?,	? # type
% ?,	?,	? # length
[ 3,	"item 3",	0 ]
[ 6,	"item 6",	0 ]
[ 8,	"item 8",	0 ]

delete from rtest_view4;
#--
#-- Test for computations in views
#--
#create table rtest_comp (
#	part	text,
#	unit	char(4),
#	size	float
#);
#create table rtest_unitfact (
#	unit	char(4),
#	factor	float
#);
#create view rtest_vcomp as 
#	select X.part, (X.size * Y.factor) as size_in_cm
#			from rtest_comp X, rtest_unitfact Y
#			where X.unit = Y.unit;
#insert into rtest_unitfact values ('m', 100.0);
[ 1 ]
#insert into rtest_unitfact values ('cm', 1.0);
[ 1 ]
#insert into rtest_unitfact values ('inch', 2.54);
[ 1 ]
#insert into rtest_comp values ('p1', 'm', 5.0);
[ 1 ]
#insert into rtest_comp values ('p2', 'm', 3.0);
[ 1 ]
#insert into rtest_comp values ('p3', 'cm', 5.0);
[ 1 ]
#insert into rtest_comp values ('p4', 'cm', 15.0);
[ 1 ]
#insert into rtest_comp values ('p5', 'inch', 7.0);
[ 1 ]
#insert into rtest_comp values ('p6', 'inch', 4.4);
[ 1 ]
#select * from rtest_vcomp order by part;
% sys.L0,	sys.L0 # table_name
% part,	size_in_cm # name
% ?,	? # type
% ?,	? # length
[ "p1",	500 ]
[ "p2",	300 ]
[ "p3",	5 ]
[ "p4",	15 ]
[ "p5",	17.78 ]
[ "p6",	11.176 ]

#select * from rtest_vcomp where size_in_cm > 10.0 order by size_in_cm using >;
% sys.L0,	sys.L0 # table_name
% part,	size_in_cm # name
% ?,	? # type
% ?,	? # length
[ "p1",	500 ]
[ "p2",	300 ]
[ "p5",	17.78 ]
[ "p4",	15 ]
[ "p6",	11.176 ]

#--
#-- In addition run the (slightly modified) queries from the
#-- programmers manual section on the rule system.
#--
#CREATE TABLE shoe_data (
#	shoename   char(10),      -- primary key
#	sh_avail   integer,       -- available # of pairs
#	slcolor    char(10),      -- preferred shoelace color
#	slminlen   float,         -- miminum shoelace length
#	slmaxlen   float,         -- maximum shoelace length
#	slunit     char(8)        -- length unit
#);
#CREATE TABLE shoelace_data (
#	sl_name    char(10),      -- primary key
#	sl_avail   integer,       -- available # of pairs
#	sl_color   char(10),      -- shoelace color
#	sl_len     float,         -- shoelace length
#	sl_unit    char(8)        -- length unit
#);
#CREATE TABLE unit (
#	un_name    char(8),       -- the primary key
#	un_fact    float          -- factor to transform to cm
#);
#CREATE VIEW shoe AS
#	SELECT sh.shoename,
#		   sh.sh_avail,
#		   sh.slcolor,
#		   sh.slminlen,
#		   sh.slminlen * un.un_fact AS slminlen_cm,
#		   sh.slmaxlen,
#		   sh.slmaxlen * un.un_fact AS slmaxlen_cm,
#		   sh.slunit
#	  FROM shoe_data sh, unit un
#	 WHERE sh.slunit = un.un_name;
#CREATE VIEW shoelace AS
#	SELECT s.sl_name,
#		   s.sl_avail,
#		   s.sl_color,
#		   s.sl_len,
#		   s.sl_unit,
#		   s.sl_len * u.un_fact AS sl_len_cm
#	  FROM shoelace_data s, unit u
#	 WHERE s.sl_unit = u.un_name;
#CREATE VIEW shoe_ready AS
#	SELECT rsh.shoename,
#		   rsh.sh_avail,
#		   rsl.sl_name,
#		   rsl.sl_avail,
#		   int4smaller(rsh.sh_avail, rsl.sl_avail) AS total_avail
#	  FROM shoe rsh, shoelace rsl
#	 WHERE rsl.sl_color = rsh.slcolor
#	   AND rsl.sl_len_cm >= rsh.slminlen_cm
#	   AND rsl.sl_len_cm <= rsh.slmaxlen_cm;
#INSERT INTO unit VALUES ('cm', 1.0);
[ 1 ]
#INSERT INTO unit VALUES ('m', 100.0);
[ 1 ]
#INSERT INTO unit VALUES ('inch', 2.54);
[ 1 ]
#INSERT INTO shoe_data VALUES ('sh1', 2, 'black', 70.0, 90.0, 'cm');
[ 1 ]
#INSERT INTO shoe_data VALUES ('sh2', 0, 'black', 30.0, 40.0, 'inch');
[ 1 ]
#INSERT INTO shoe_data VALUES ('sh3', 4, 'brown', 50.0, 65.0, 'cm');
[ 1 ]
#INSERT INTO shoe_data VALUES ('sh4', 3, 'brown', 40.0, 50.0, 'inch');
[ 1 ]
#INSERT INTO shoelace_data VALUES ('sl1', 5, 'black', 80.0, 'cm');
[ 1 ]
#INSERT INTO shoelace_data VALUES ('sl2', 6, 'black', 100.0, 'cm');
[ 1 ]
#INSERT INTO shoelace_data VALUES ('sl3', 0, 'black', 35.0 , 'inch');
[ 1 ]
#INSERT INTO shoelace_data VALUES ('sl4', 8, 'black', 40.0 , 'inch');
[ 1 ]
#INSERT INTO shoelace_data VALUES ('sl5', 4, 'brown', 1.0 , 'm');
[ 1 ]
#INSERT INTO shoelace_data VALUES ('sl6', 0, 'brown', 0.9 , 'm');
[ 1 ]
#INSERT INTO shoelace_data VALUES ('sl7', 7, 'brown', 60 , 'cm');
[ 1 ]
#INSERT INTO shoelace_data VALUES ('sl8', 1, 'brown', 40 , 'inch');
[ 1 ]
#-- SELECTs in doc
#SELECT * FROM shoelace ORDER BY sl_name;
% sys.L0,	sys.L0,	sys.L0,	sys.L0,	sys.L0,	sys.L0 # table_name
% sl_name,	sl_avail,	sl_color,	sl_len,	sl_unit,	sl_len_cm # name
% ?,	?,	?,	?,	?,	? # type
% ?,	?,	?,	?,	?,	? # length
[ "sl1",	5,	"black",	80,	"cm",	80 ]
[ "sl2",	6,	"black",	100,	"cm",	100 ]
[ "sl3",	0,	"black",	35,	"inch",	88.9 ]
[ "sl4",	8,	"black",	40,	"inch",	101.6 ]
[ "sl5",	4,	"brown",	1,	"m",	100 ]
[ "sl6",	0,	"brown",	0.9,	"m",	90 ]
[ "sl7",	7,	"brown",	60,	"cm",	60 ]
[ "sl8",	1,	"brown",	40,	"inch",	101.6 ]

#SELECT * FROM shoe_ready WHERE total_avail >= 2 ORDER BY 1;
% sys.L0,	sys.L0,	sys.L0,	sys.L0,	sys.L0 # table_name
% shoename,	sh_avail,	sl_name,	sl_avail,	total_avail # name
% ?,	?,	?,	?,	? # type
% ?,	?,	?,	?,	? # length
[ "sh1",	2,	"sl1",	5,	2 ]
[ "sh3",	4,	"sl7",	7,	4 ]

#    CREATE TABLE shoelace_log (
#        sl_name    char(10),      -- shoelace changed
#        sl_avail   integer,       -- new available value
#        log_who    string,          -- who did it
#        log_when   timestamp      -- when
#    );
#-- Want "log_who" to be CURRENT_USER,
#-- but that is non-portable for the regression test
#-- - thomas 1999-02-21
#    CREATE RULE log_shoelace AS ON UPDATE TO shoelace_data
#        WHERE NEW.sl_avail != OLD.sl_avail
#        DO INSERT INTO shoelace_log VALUES (
#                                        NEW.sl_name,
#                                        NEW.sl_avail,
#                                        'Al Bundy',
#                                        'epoch'
#                                    );
#UPDATE shoelace_data SET sl_avail = 6 WHERE  sl_name = 'sl7';
#SELECT * FROM shoelace_log;
% sys.L0,	sys.L0,	sys.L0,	sys.L0 # table_name
% sl_name,	sl_avail,	log_who,	log_when # name
% ?,	?,	?,	? # type
% ?,	?,	?,	? # length
[ "sl7",	6,	"Al Bundy",	"Thu Jan 01 00:00:00 1970" ]

#    CREATE RULE shoelace_ins AS ON INSERT TO shoelace
#        DO INSTEAD
#        INSERT INTO shoelace_data VALUES (
#               NEW.sl_name,
#               NEW.sl_avail,
#               NEW.sl_color,
#               NEW.sl_len,
#               NEW.sl_unit);
[ 1 ]
#    CREATE RULE shoelace_upd AS ON UPDATE TO shoelace
#        DO INSTEAD
#        UPDATE shoelace_data SET
#               sl_name = NEW.sl_name,
#               sl_avail = NEW.sl_avail,
#               sl_color = NEW.sl_color,
#               sl_len = NEW.sl_len,
#               sl_unit = NEW.sl_unit
#         WHERE sl_name = OLD.sl_name;
#    CREATE RULE shoelace_del AS ON DELETE TO shoelace
#        DO INSTEAD
#        DELETE FROM shoelace_data
#         WHERE sl_name = OLD.sl_name;
#    CREATE TABLE shoelace_arrive (
#        arr_name    char(10),
#        arr_quant   integer
#    );
#    CREATE TABLE shoelace_ok (
#        ok_name     char(10),
#        ok_quant    integer
#    );
#    CREATE RULE shoelace_ok_ins AS ON INSERT TO shoelace_ok
#        DO INSTEAD
#        UPDATE shoelace SET
#               sl_avail = sl_avail + NEW.ok_quant
#         WHERE sl_name = NEW.ok_name;
#INSERT INTO shoelace_arrive VALUES ('sl3', 10);
[ 1 ]
#INSERT INTO shoelace_arrive VALUES ('sl6', 20);
[ 1 ]
#INSERT INTO shoelace_arrive VALUES ('sl8', 20);
[ 1 ]
#SELECT * FROM shoelace ORDER BY sl_name;
% sys.L0,	sys.L0,	sys.L0,	sys.L0,	sys.L0,	sys.L0 # table_name
% sl_name,	sl_avail,	sl_color,	sl_len,	sl_unit,	sl_len_cm # name
% ?,	?,	?,	?,	?,	? # type
% ?,	?,	?,	?,	?,	? # length
[ "sl1",	5,	"black",	80,	"cm",	80 ]
[ "sl2",	6,	"black",	100,	"cm",	100 ]
[ "sl3",	0,	"black",	35,	"inch",	88.9 ]
[ "sl4",	8,	"black",	40,	"inch",	101.6 ]
[ "sl5",	4,	"brown",	1,	"m",	100 ]
[ "sl6",	0,	"brown",	0.9,	"m",	90 ]
[ "sl7",	6,	"brown",	60,	"cm",	60 ]
[ "sl8",	1,	"brown",	40,	"inch",	101.6 ]

#insert into shoelace_ok select * from shoelace_arrive;
[ 1 ]
#SELECT * FROM shoelace ORDER BY sl_name;
% sys.L0,	sys.L0,	sys.L0,	sys.L0,	sys.L0,	sys.L0 # table_name
% sl_name,	sl_avail,	sl_color,	sl_len,	sl_unit,	sl_len_cm # name
% ?,	?,	?,	?,	?,	? # type
% ?,	?,	?,	?,	?,	? # length
[ "sl1",	5,	"black",	80,	"cm",	80 ]
[ "sl2",	6,	"black",	100,	"cm",	100 ]
[ "sl3",	10,	"black",	35,	"inch",	88.9 ]
[ "sl4",	8,	"black",	40,	"inch",	101.6 ]
[ "sl5",	4,	"brown",	1,	"m",	100 ]
[ "sl6",	20,	"brown",	0.9,	"m",	90 ]
[ "sl7",	6,	"brown",	60,	"cm",	60 ]
[ "sl8",	21,	"brown",	40,	"inch",	101.6 ]

#SELECT * FROM shoelace_log ORDER BY sl_name;
% sys.L0,	sys.L0,	sys.L0,	sys.L0 # table_name
% sl_name,	sl_avail,	log_who,	log_when # name
% ?,	?,	?,	? # type
% ?,	?,	?,	? # length
[ "sl3",	10,	"Al Bundy",	"Thu Jan 01 00:00:00 1970" ]
[ "sl6",	20,	"Al Bundy",	"Thu Jan 01 00:00:00 1970" ]
[ "sl7",	6,	"Al Bundy",	"Thu Jan 01 00:00:00 1970" ]
[ "sl8",	21,	"Al Bundy",	"Thu Jan 01 00:00:00 1970" ]

#    CREATE VIEW shoelace_obsolete AS
#	SELECT * FROM shoelace WHERE NOT EXISTS
#	    (SELECT shoename FROM shoe WHERE slcolor = sl_color);
#    CREATE VIEW shoelace_candelete AS
#	SELECT * FROM shoelace_obsolete WHERE sl_avail = 0;
#insert into shoelace values ('sl9', 0, 'pink', 35.0, 'inch', 0.0);
[ 1 ]
#insert into shoelace values ('sl10', 1000, 'magenta', 40.0, 'inch', 0.0);
[ 1 ]
#SELECT * FROM shoelace_obsolete;
% sys.L0,	sys.L0,	sys.L0,	sys.L0,	sys.L0,	sys.L0 # table_name
% sl_name,	sl_avail,	sl_color,	sl_len,	sl_unit,	sl_len_cm # name
% ?,	?,	?,	?,	?,	? # type
% ?,	?,	?,	?,	?,	? # length
[ "sl10",	1000,	"magenta",	40,	"inch",	101.6 ]
[ "sl9",	0,	"pink",	35,	"inch",	88.9 ]

#SELECT * FROM shoelace_candelete;
% sys.L0,	sys.L0,	sys.L0,	sys.L0,	sys.L0,	sys.L0 # table_name
% sl_name,	sl_avail,	sl_color,	sl_len,	sl_unit,	sl_len_cm # name
% ?,	?,	?,	?,	?,	? # type
% ?,	?,	?,	?,	?,	? # length
[ "sl9",	0,	"pink",	35,	"inch",	88.9 ]

DELETE FROM shoelace WHERE EXISTS
    (SELECT * FROM shoelace_candelete
             WHERE sl_name = shoelace.sl_name);
#SELECT * FROM shoelace ORDER BY sl_name;
% sys.L0,	sys.L0,	sys.L0,	sys.L0,	sys.L0,	sys.L0 # table_name
% sl_name,	sl_avail,	sl_color,	sl_len,	sl_unit,	sl_len_cm # name
% ?,	?,	?,	?,	?,	? # type
% ?,	?,	?,	?,	?,	? # length
[ "sl1",	5,	"black",	80,	"cm",	80 ]
[ "sl10",	1000,	"magenta",	40,	"inch",	101.6 ]
[ "sl2",	6,	"black",	100,	"cm",	100 ]
[ "sl3",	10,	"black",	35,	"inch",	88.9 ]
[ "sl4",	8,	"black",	40,	"inch",	101.6 ]
[ "sl5",	4,	"brown",	1,	"m",	100 ]
[ "sl6",	20,	"brown",	0.9,	"m",	90 ]
[ "sl7",	6,	"brown",	60,	"cm",	60 ]
[ "sl8",	21,	"brown",	40,	"inch",	101.6 ]

#SELECT * FROM shoe ORDER BY shoename;
% sys.L0,	sys.L0,	sys.L0,	sys.L0,	sys.L0,	sys.L0,	sys.L0,	sys.L0 # table_name
% shoename,	sh_avail,	slcolor,	slminlen,	slminlen_cm,	slmaxlen,	slmaxlen_cm,	slunit # name
% ?,	?,	?,	?,	?,	?,	?,	? # type
% ?,	?,	?,	?,	?,	?,	?,	? # length
[ "sh1",	2,	"black",	70,	70,	90,	90,	"cm" ]
[ "sh2",	0,	"black",	30,	76.2,	40,	101.6,	"inch" ]
[ "sh3",	4,	"brown",	50,	50,	65,	65,	"cm" ]
[ "sh4",	3,	"brown",	40,	101.6,	50,	127,	"inch" ]

#SELECT count(*) FROM shoe;
% sys.L0 # table_name
% count # name
% ? # type
% ? # length
[ 4 ]

#--
#-- Simple test of qualified ON INSERT ... this did not work in 7.0 ...
#--
#create table foo (f1 int);
#create table foo2 (f1 int);
#create rule foorule as on insert to foo where f1 < 100
#do instead nothing;
#insert into foo values(1);
[ 1 ]
#insert into foo values(1001);
[ 1 ]
#select * from foo;
% sys.L0 # table_name
% f1 # name
% ? # type
% ? # length
[ 1001 ]

#drop rule foorule on foo;
#-- this should fail because f1 is not exposed for unqualified reference:
#
#-- this is the correct way:
#create rule foorule as on insert to foo where f1 < 100
#do instead insert into foo2 values (new.f1);
#insert into foo values(2);
[ 1 ]
#insert into foo values(100);
[ 1 ]
#select * from foo;
% sys.L0 # table_name
% f1 # name
% ? # type
% ? # length
[ 1001 ]
[ 100 ]

#select * from foo2;
% sys.L0 # table_name
% f1 # name
% ? # type
% ? # length
[ 2 ]

#drop rule foorule on foo;
#drop table foo;
#drop table foo2;
#--
#-- Test rules containing INSERT ... SELECT, which is a very ugly special
#-- case as of 7.1.  Example is based on bug report from Joel Burton.
#--
#create table pparent (pid int, txt text);
#insert into pparent values (1,'parent1');
[ 1 ]
#insert into pparent values (2,'parent2');
[ 1 ]
#create table cchild (pid int, descrip text);
#insert into cchild values (1,'descrip1');
[ 1 ]
#create view vview as
#  select pparent.pid, txt, descrip from
#    pparent left join cchild using (pid);
#create rule rrule as
#  on update to vview do instead
#(
#  insert into cchild (pid, descrip)
#    select old.pid, new.descrip where old.descrip isnull; 
[ 1 ]
#  update cchild set descrip = new.descrip where cchild.pid = old.pid;
);
#select * from vview;
% sys.L0,	sys.L0,	sys.L0 # table_name
% pid,	txt,	descrip # name
% ?,	?,	? # type
% ?,	?,	? # length
[ 1,	"parent1",	"descrip1" ]
[ 2,	"parent2",	"" ]

#update vview set descrip='test1' where pid=1;
#select * from vview;
% sys.L0,	sys.L0,	sys.L0 # table_name
% pid,	txt,	descrip # name
% ?,	?,	? # type
% ?,	?,	? # length
[ 1,	"parent1",	"test1" ]
[ 2,	"parent2",	"" ]

#update vview set descrip='test2' where pid=2;
#select * from vview;
% sys.L0,	sys.L0,	sys.L0 # table_name
% pid,	txt,	descrip # name
% ?,	?,	? # type
% ?,	?,	? # length
[ 1,	"parent1",	"test1" ]
[ 2,	"parent2",	"test2" ]

#update vview set descrip='test3' where pid=3;
#select * from vview;
% sys.L0,	sys.L0,	sys.L0 # table_name
% pid,	txt,	descrip # name
% ?,	?,	? # type
% ?,	?,	? # length
[ 1,	"parent1",	"test1" ]
[ 2,	"parent2",	"test2" ]

#select * from cchild;
% sys.L0,	sys.L0 # table_name
% pid,	descrip # name
% ?,	? # type
% ?,	? # length
[ 1,	"test1" ]
[ 2,	"test2" ]

#drop rule rrule on vview;
#drop view vview;
#drop table pparent;
#drop table cchild;
#--
#-- Check that ruleutils are working
#--
#SELECT viewname, definition FROM pg_views WHERE schemaname <> 'information_schema' ORDER BY viewname;
% sys.L0,	sys.L0 # table_name
% viewname,	definition # name
% ?,	? # type
% ?,	? # length
[ "iexit",	"SELECT ih.string, ih.thepath, interpt_pp(ih.thepath, r.thepath) AS exit FROM ihighway ih, ramp r WHERE (ih.thepath ## r.thepath);" ]
[ "pg_indexes",	"SELECT n.nspname AS schemaname, c.relname AS tablename, i.relname AS indexname, t.spcname AS "tablespace", pg_get_indexdef(i.oid) AS indexdef FROM ((((pg_index x JOIN pg_class c ON ((c.oid = x.indrelid))) JOIN pg_class i ON ((i.oid = x.indexrelid))) LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace))) LEFT JOIN pg_tablespace t ON ((t.oid = i.reltablespace))) WHERE ((c.relkind = 'r'::"char") AND (i.relkind = 'i'::"char"));" ]
[ "pg_locks",	"SELECT l.relation, l."database", l."transaction", l.pid, l."mode", l.granted FROM pg_lock_status() l(relation oid, "database" oid, "transaction" xid, pid integer, "mode" text, granted boolean);" ]
[ "pg_rules",	"SELECT n.nspname AS schemaname, c.relname AS tablename, r.rulename, pg_get_ruledef(r.oid) AS definition FROM ((pg_rewrite r JOIN pg_class c ON ((c.oid = r.ev_class))) LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace))) WHERE (r.rulename <> '_RETURN'::name);" ]
[ "pg_settings",	"SELECT a.string, a.setting, a.category, a.short_desc, a.extra_desc, a.context, a.vartype, a.source, a.min_val, a.max_val FROM pg_show_all_settings() a(name text, setting text, category text, short_desc text, extra_desc text, context text, vartype text, source text, min_val text, max_val text);" ]
[ "pg_stat_activity",	"SELECT d.oid AS datid, d.datname, pg_stat_get_backend_pid(s.backendid) AS procpid, pg_stat_get_backend_userid(s.backendid) AS usesysid, u.usename, pg_stat_get_backend_activity(s.backendid) AS current_query, pg_stat_get_backend_activity_start(s.backendid) AS query_start FROM pg_database d, (SELECT pg_stat_get_backend_idset() AS backendid) s, pg_shadow u WHERE ((pg_stat_get_backend_dbid(s.backendid) = d.oid) AND (pg_stat_get_backend_userid(s.backendid) = u.usesysid));" ]
[ "pg_stat_all_indexes",	"SELECT c.oid AS relid, i.oid AS indexrelid, n.nspname AS schemaname, c.relname, i.relname AS indexrelname, pg_stat_get_numscans(i.oid) AS idx_scan, pg_stat_get_tuples_returned(i.oid) AS idx_tup_read, pg_stat_get_tuples_fetched(i.oid) AS idx_tup_fetch FROM (((pg_class c JOIN pg_index x ON ((c.oid = x.indrelid))) JOIN pg_class i ON ((i.oid = x.indexrelid))) LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace))) WHERE (c.relkind = 'r'::"char");" ]
[ "pg_stat_all_tables",	"SELECT c.oid AS relid, n.nspname AS schemaname, c.relname, pg_stat_get_numscans(c.oid) AS seq_scan, pg_stat_get_tuples_returned(c.oid) AS seq_tup_read, sum(pg_stat_get_numscans(i.indexrelid)) AS idx_scan, sum(pg_stat_get_tuples_fetched(i.indexrelid)) AS idx_tup_fetch, pg_stat_get_tuples_inserted(c.oid) AS n_tup_ins, pg_stat_get_tuples_updated(c.oid) AS n_tup_upd, pg_stat_get_tuples_deleted(c.oid) AS n_tup_del FROM ((pg_class c LEFT JOIN pg_index i ON ((c.oid = i.indrelid))) LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace))) WHERE (c.relkind = 'r'::"char") GROUP BY c.oid, n.nspname, c.relname;" ]
[ "pg_stat_database",	"SELECT d.oid AS datid, d.datname, pg_stat_get_db_numbackends(d.oid) AS numbackends, pg_stat_get_db_xact_commit(d.oid) AS xact_commit, pg_stat_get_db_xact_rollback(d.oid) AS xact_rollback, (pg_stat_get_db_blocks_fetched(d.oid) - pg_stat_get_db_blocks_hit(d.oid)) AS blks_read, pg_stat_get_db_blocks_hit(d.oid) AS blks_hit FROM pg_database d;" ]
[ "pg_stat_sys_indexes",	"SELECT pg_stat_all_indexes.relid, pg_stat_all_indexes.indexrelid, pg_stat_all_indexes.schemaname, pg_stat_all_indexes.relname, pg_stat_all_indexes.indexrelname, pg_stat_all_indexes.idx_scan, pg_stat_all_indexes.idx_tup_read, pg_stat_all_indexes.idx_tup_fetch FROM pg_stat_all_indexes WHERE (((pg_stat_all_indexes.schemaname = 'pg_catalog'::name) OR (pg_stat_all_indexes.schemaname = 'pg_toast'::name)) OR (pg_stat_all_indexes.schemaname = 'information_schema'::name));" ]
[ "pg_stat_sys_tables",	"SELECT pg_stat_all_tables.relid, pg_stat_all_tables.schemaname, pg_stat_all_tables.relname, pg_stat_all_tables.seq_scan, pg_stat_all_tables.seq_tup_read, pg_stat_all_tables.idx_scan, pg_stat_all_tables.idx_tup_fetch, pg_stat_all_tables.n_tup_ins, pg_stat_all_tables.n_tup_upd, pg_stat_all_tables.n_tup_del FROM pg_stat_all_tables WHERE (((pg_stat_all_tables.schemaname = 'pg_catalog'::name) OR (pg_stat_all_tables.schemaname = 'pg_toast'::name)) OR (pg_stat_all_tables.schemaname = 'information_schema'::name));" ]
[ "pg_stat_user_indexes",	"SELECT pg_stat_all_indexes.relid, pg_stat_all_indexes.indexrelid, pg_stat_all_indexes.schemaname, pg_stat_all_indexes.relname, pg_stat_all_indexes.indexrelname, pg_stat_all_indexes.idx_scan, pg_stat_all_indexes.idx_tup_read, pg_stat_all_indexes.idx_tup_fetch FROM pg_stat_all_indexes WHERE (((pg_stat_all_indexes.schemaname <> 'pg_catalog'::name) AND (pg_stat_all_indexes.schemaname <> 'pg_toast'::name)) AND (pg_stat_all_indexes.schemaname <> 'information_schema'::name));" ]
[ "pg_stat_user_tables",	"SELECT pg_stat_all_tables.relid, pg_stat_all_tables.schemaname, pg_stat_all_tables.relname, pg_stat_all_tables.seq_scan, pg_stat_all_tables.seq_tup_read, pg_stat_all_tables.idx_scan, pg_stat_all_tables.idx_tup_fetch, pg_stat_all_tables.n_tup_ins, pg_stat_all_tables.n_tup_upd, pg_stat_all_tables.n_tup_del FROM pg_stat_all_tables WHERE (((pg_stat_all_tables.schemaname <> 'pg_catalog'::name) AND (pg_stat_all_tables.schemaname <> 'pg_toast'::name)) AND (pg_stat_all_tables.schemaname <> 'information_schema'::name));" ]
[ "pg_statio_all_indexes",	"SELECT c.oid AS relid, i.oid AS indexrelid, n.nspname AS schemaname, c.relname, i.relname AS indexrelname, (pg_stat_get_blocks_fetched(i.oid) - pg_stat_get_blocks_hit(i.oid)) AS idx_blks_read, pg_stat_get_blocks_hit(i.oid) AS idx_blks_hit FROM (((pg_class c JOIN pg_index x ON ((c.oid = x.indrelid))) JOIN pg_class i ON ((i.oid = x.indexrelid))) LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace))) WHERE (c.relkind = 'r'::"char");" ]
[ "pg_statio_all_sequences",	"SELECT c.oid AS relid, n.nspname AS schemaname, c.relname, (pg_stat_get_blocks_fetched(c.oid) - pg_stat_get_blocks_hit(c.oid)) AS blks_read, pg_stat_get_blocks_hit(c.oid) AS blks_hit FROM (pg_class c LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace))) WHERE (c.relkind = 'S'::"char");" ]
[ "pg_statio_all_tables",	"SELECT c.oid AS relid, n.nspname AS schemaname, c.relname, (pg_stat_get_blocks_fetched(c.oid) - pg_stat_get_blocks_hit(c.oid)) AS heap_blks_read, pg_stat_get_blocks_hit(c.oid) AS heap_blks_hit, sum((pg_stat_get_blocks_fetched(i.indexrelid) - pg_stat_get_blocks_hit(i.indexrelid))) AS idx_blks_read, sum(pg_stat_get_blocks_hit(i.indexrelid)) AS idx_blks_hit, (pg_stat_get_blocks_fetched(t.oid) - pg_stat_get_blocks_hit(t.oid)) AS toast_blks_read, pg_stat_get_blocks_hit(t.oid) AS toast_blks_hit, (pg_stat_get_blocks_fetched(x.oid) - pg_stat_get_blocks_hit(x.oid)) AS tidx_blks_read, pg_stat_get_blocks_hit(x.oid) AS tidx_blks_hit FROM ((((pg_class c LEFT JOIN pg_index i ON ((c.oid = i.indrelid))) LEFT JOIN pg_class t ON ((c.reltoastrelid = t.oid))) LEFT JOIN pg_class x ON ((t.reltoastidxid = x.oid))) LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace))) WHERE (c.relkind = 'r'::"char") GROUP BY c.oid, n.nspname, c.relname, t.oid, x.oid;" ]
[ "pg_statio_sys_indexes",	"SELECT pg_statio_all_indexes.relid, pg_statio_all_indexes.indexrelid, pg_statio_all_indexes.schemaname, pg_statio_all_indexes.relname, pg_statio_all_indexes.indexrelname, pg_statio_all_indexes.idx_blks_read, pg_statio_all_indexes.idx_blks_hit FROM pg_statio_all_indexes WHERE (((pg_statio_all_indexes.schemaname = 'pg_catalog'::name) OR (pg_statio_all_indexes.schemaname = 'pg_toast'::name)) OR (pg_statio_all_indexes.schemaname = 'information_schema'::name));" ]
[ "pg_statio_sys_sequences",	"SELECT pg_statio_all_sequences.relid, pg_statio_all_sequences.schemaname, pg_statio_all_sequences.relname, pg_statio_all_sequences.blks_read, pg_statio_all_sequences.blks_hit FROM pg_statio_all_sequences WHERE (((pg_statio_all_sequences.schemaname = 'pg_catalog'::name) OR (pg_statio_all_sequences.schemaname = 'pg_toast'::name)) OR (pg_statio_all_sequences.schemaname = 'information_schema'::name));" ]
[ "pg_statio_sys_tables",	"SELECT pg_statio_all_tables.relid, pg_statio_all_tables.schemaname, pg_statio_all_tables.relname, pg_statio_all_tables.heap_blks_read, pg_statio_all_tables.heap_blks_hit, pg_statio_all_tables.idx_blks_read, pg_statio_all_tables.idx_blks_hit, pg_statio_all_tables.toast_blks_read, pg_statio_all_tables.toast_blks_hit, pg_statio_all_tables.tidx_blks_read, pg_statio_all_tables.tidx_blks_hit FROM pg_statio_all_tables WHERE (((pg_statio_all_tables.schemaname = 'pg_catalog'::name) OR (pg_statio_all_tables.schemaname = 'pg_toast'::name)) OR (pg_statio_all_tables.schemaname = 'information_schema'::name));" ]
[ "pg_statio_user_indexes",	"SELECT pg_statio_all_indexes.relid, pg_statio_all_indexes.indexrelid, pg_statio_all_indexes.schemaname, pg_statio_all_indexes.relname, pg_statio_all_indexes.indexrelname, pg_statio_all_indexes.idx_blks_read, pg_statio_all_indexes.idx_blks_hit FROM pg_statio_all_indexes WHERE (((pg_statio_all_indexes.schemaname <> 'pg_catalog'::name) AND (pg_statio_all_indexes.schemaname <> 'pg_toast'::name)) AND (pg_statio_all_indexes.schemaname <> 'information_schema'::name));" ]
[ "pg_statio_user_sequences",	"SELECT pg_statio_all_sequences.relid, pg_statio_all_sequences.schemaname, pg_statio_all_sequences.relname, pg_statio_all_sequences.blks_read, pg_statio_all_sequences.blks_hit FROM pg_statio_all_sequences WHERE (((pg_statio_all_sequences.schemaname <> 'pg_catalog'::name) AND (pg_statio_all_sequences.schemaname <> 'pg_toast'::name)) AND (pg_statio_all_sequences.schemaname <> 'information_schema'::name));" ]
[ "pg_statio_user_tables",	"SELECT pg_statio_all_tables.relid, pg_statio_all_tables.schemaname, pg_statio_all_tables.relname, pg_statio_all_tables.heap_blks_read, pg_statio_all_tables.heap_blks_hit, pg_statio_all_tables.idx_blks_read, pg_statio_all_tables.idx_blks_hit, pg_statio_all_tables.toast_blks_read, pg_statio_all_tables.toast_blks_hit, pg_statio_all_tables.tidx_blks_read, pg_statio_all_tables.tidx_blks_hit FROM pg_statio_all_tables WHERE (((pg_statio_all_tables.schemaname <> 'pg_catalog'::name) AND (pg_statio_all_tables.schemaname <> 'pg_toast'::name)) AND (pg_statio_all_tables.schemaname <> 'information_schema'::name));" ]
[ "pg_stats",	"SELECT n.nspname AS schemaname, c.relname AS tablename, a.attname, s.stanullfrac AS null_frac, s.stawidth AS avg_width, s.stadistinct AS n_distinct, CASE 1 WHEN s.stakind1 THEN s.stavalues1 WHEN s.stakind2 THEN s.stavalues2 WHEN s.stakind3 THEN s.stavalues3 WHEN s.stakind4 THEN s.stavalues4 ELSE NULL::"unknown" END AS most_common_vals, CASE 1 WHEN s.stakind1 THEN s.stanumbers1 WHEN s.stakind2 THEN s.stanumbers2 WHEN s.stakind3 THEN s.stanumbers3 WHEN s.stakind4 THEN s.stanumbers4 ELSE NULL::real[] END AS most_common_freqs, CASE 2 WHEN s.stakind1 THEN s.stavalues1 WHEN s.stakind2 THEN s.stavalues2 WHEN s.stakind3 THEN s.stavalues3 WHEN s.stakind4 THEN s.stavalues4 ELSE NULL::"unknown" END AS histogram_bounds, CASE 3 WHEN s.stakind1 THEN s.stanumbers1[1] WHEN s.stakind2 THEN s.stanumbers2[1] WHEN s.stakind3 THEN s.stanumbers3[1] WHEN s.stakind4 THEN s.stanumbers4[1] ELSE NULL::real END AS correlation FROM (((pg_statistic s JOIN pg_class c ON ((c.oid = s.starelid))) JOIN pg_attribute a ON (((c.oid = a.attrelid) AND (a.attnum = s.staattnum)))) LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace))) WHERE has_table_privilege(c.oid, 'select'::text);" ]
[ "pg_tables",	"SELECT n.nspname AS schemaname, c.relname AS tablename, pg_get_userbyid(c.relowner) AS tableowner, t.spcname AS "tablespace", c.relhasindex AS hasindexes, c.relhasrules AS hasrules, (c.reltriggers > 0) AS hastriggers FROM ((pg_class c LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace))) LEFT JOIN pg_tablespace t ON ((t.oid = c.reltablespace))) WHERE (c.relkind = 'r'::"char");" ]
[ "pg_user",	"SELECT pg_shadow.usename, pg_shadow.usesysid, pg_shadow.usecreatedb, pg_shadow.usesuper, pg_shadow.usecatupd, '********'::text AS passwd, pg_shadow.valuntil, pg_shadow.useconfig FROM pg_shadow;" ]
[ "pg_views",	"SELECT n.nspname AS schemaname, c.relname AS viewname, pg_get_userbyid(c.relowner) AS viewowner, pg_get_viewdef(c.oid) AS definition FROM (pg_class c LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace))) WHERE (c.relkind = 'v'::"char");" ]
[ "rtest_v1",	"SELECT rtest_t1.a, rtest_t1.b FROM rtest_t1;" ]
[ "rtest_vcomp",	"SELECT x.part, (x.size * y.factor) AS size_in_cm FROM rtest_comp x, rtest_unitfact y WHERE (x.unit = y.unit);" ]
[ "rtest_vview1",	"SELECT x.a, x.b FROM rtest_view1 x WHERE (0 < (SELECT count(*) AS count FROM rtest_view2 y WHERE (y.a = x.a)));" ]
[ "rtest_vview2",	"SELECT rtest_view1.a, rtest_view1.b FROM rtest_view1 WHERE rtest_view1.v;" ]
[ "rtest_vview3",	"SELECT x.a, x.b FROM rtest_vview2 x WHERE (0 < (SELECT count(*) AS count FROM rtest_view2 y WHERE (y.a = x.a)));" ]
[ "rtest_vview4",	"SELECT x.a, x.b, count(y.a) AS refcount FROM rtest_view1 x, rtest_view2 y WHERE (x.a = y.a) GROUP BY x.a, x.b;" ]
[ "rtest_vview5",	"SELECT rtest_view1.a, rtest_view1.b, rtest_viewfunc1(rtest_view1.a) AS refcount FROM rtest_view1;" ]
[ "shoe",	"SELECT sh.shoename, sh.sh_avail, sh.slcolor, sh.slminlen, (sh.slminlen * un.un_fact) AS slminlen_cm, sh.slmaxlen, (sh.slmaxlen * un.un_fact) AS slmaxlen_cm, sh.slunit FROM shoe_data sh, unit un WHERE (sh.slunit = un.un_name);" ]
[ "shoe_ready",	"SELECT rsh.shoename, rsh.sh_avail, rsl.sl_name, rsl.sl_avail, int4smaller(rsh.sh_avail, rsl.sl_avail) AS total_avail FROM shoe rsh, shoelace rsl WHERE (((rsl.sl_color = rsh.slcolor) AND (rsl.sl_len_cm >= rsh.slminlen_cm)) AND (rsl.sl_len_cm <= rsh.slmaxlen_cm));" ]
[ "shoelace",	"SELECT s.sl_name, s.sl_avail, s.sl_color, s.sl_len, s.sl_unit, (s.sl_len * u.un_fact) AS sl_len_cm FROM shoelace_data s, unit u WHERE (s.sl_unit = u.un_name);" ]
[ "shoelace_candelete",	"SELECT shoelace_obsolete.sl_name, shoelace_obsolete.sl_avail, shoelace_obsolete.sl_color, shoelace_obsolete.sl_len, shoelace_obsolete.sl_unit, shoelace_obsolete.sl_len_cm FROM shoelace_obsolete WHERE (shoelace_obsolete.sl_avail = 0);" ]
[ "shoelace_obsolete",	"SELECT shoelace.sl_name, shoelace.sl_avail, shoelace.sl_color, shoelace.sl_len, shoelace.sl_unit, shoelace.sl_len_cm FROM shoelace WHERE (NOT (EXISTS (SELECT shoe.shoename FROM shoe WHERE (shoe.slcolor = shoelace.sl_color))));" ]
[ "street",	"SELECT r.string, r.thepath, c.cname  FROM road r, real_city c WHERE (c.outline ## r.thepath);" ]
[ "toyemp",	"SELECT emp.string, emp.age, emp."location", (12 * emp.salary) AS annualsal FROM emp;" ]

#SELECT tablename, rulename, definition FROM pg_rules 
#	ORDER BY tablename, rulename;
% sys.L0,	sys.L0,	sys.L0 # table_name
% tablename,	rulename,	definition # name
% ?,	?,	? # type
% ?,	?,	? # length
[ "pg_settings",	"pg_settings_n",	"CREATE RULE pg_settings_n AS ON UPDATE TO pg_settings DO INSTEAD NOTHING;" ]
[ "pg_settings",	"pg_settings_u",	"CREATE RULE pg_settings_u AS ON UPDATE TO pg_settings WHERE (new.name = old.name) DO SELECT set_config(old.string, new.setting, false) AS set_config;" ]
[ "rtest_emp",	"rtest_emp_del",	"CREATE RULE rtest_emp_del AS ON DELETE TO rtest_emp DO INSERT INTO rtest_emplog (ename, who, "action", newsal, oldsal) VALUES (old.ename, "current_user"(), 'fired'::bpchar, '$0.00'::money, old.salary);" ]
[ "rtest_emp",	"rtest_emp_ins",	"CREATE RULE rtest_emp_ins AS ON INSERT TO rtest_emp DO INSERT INTO rtest_emplog (ename, who, "action", newsal, oldsal) VALUES (new.ename, "current_user"(), 'hired'::bpchar, new.salary, '$0.00'::money);" ]
[ "rtest_emp",	"rtest_emp_upd",	"CREATE RULE rtest_emp_upd AS ON UPDATE TO rtest_emp WHERE (new.salary <> old.salary) DO INSERT INTO rtest_emplog (ename, who, "action", newsal, oldsal) VALUES (new.ename, "current_user"(), 'honored'::bpchar, new.salary, old.salary);" ]
[ "rtest_nothn1",	"rtest_nothn_r1",	"CREATE RULE rtest_nothn_r1 AS ON INSERT TO rtest_nothn1 WHERE ((new.a >= 10) AND (new.a < 20)) DO INSTEAD NOTHING;" ]
[ "rtest_nothn1",	"rtest_nothn_r2",	"CREATE RULE rtest_nothn_r2 AS ON INSERT TO rtest_nothn1 WHERE ((new.a >= 30) AND (new.a < 40)) DO INSTEAD NOTHING;" ]
[ "rtest_nothn2",	"rtest_nothn_r3",	"CREATE RULE rtest_nothn_r3 AS ON INSERT TO rtest_nothn2 WHERE (new.a >= 100) DO INSTEAD INSERT INTO rtest_nothn3 (a, b) VALUES (new.a, new.b);" ]
[ "rtest_nothn2",	"rtest_nothn_r4",	"CREATE RULE rtest_nothn_r4 AS ON INSERT TO rtest_nothn2 DO INSTEAD NOTHING;" ]
[ "rtest_order1",	"rtest_order_r1",	"CREATE RULE rtest_order_r1 AS ON INSERT TO rtest_order1 DO INSTEAD INSERT INTO rtest_order2 (a, b, c) VALUES (new.a, nextval('rtest_seq'::text), 'rule 1 - this should run 1st'::text);" ]
[ "rtest_order1",	"rtest_order_r2",	"CREATE RULE rtest_order_r2 AS ON INSERT TO rtest_order1 DO INSERT INTO rtest_order2 (a, b, c) VALUES (new.a, nextval('rtest_seq'::text), 'rule 2 - this should run 2nd'::text);" ]
[ "rtest_order1",	"rtest_order_r3",	"CREATE RULE rtest_order_r3 AS ON INSERT TO rtest_order1 DO INSTEAD INSERT INTO rtest_order2 (a, b, c) VALUES (new.a, nextval('rtest_seq'::text), 'rule 3 - this should run 3rd'::text);" ]
[ "rtest_order1",	"rtest_order_r4",	"CREATE RULE rtest_order_r4 AS ON INSERT TO rtest_order1 WHERE (new.a < 100) DO INSTEAD INSERT INTO rtest_order2 (a, b, c) VALUES (new.a, nextval('rtest_seq'::text), 'rule 4 - this should run 4th'::text);" ]
[ "rtest_person",	"rtest_pers_del",	"CREATE RULE rtest_pers_del AS ON DELETE TO rtest_person DO DELETE FROM rtest_admin WHERE (rtest_admin.pname = old.pname);" ]
[ "rtest_person",	"rtest_pers_upd",	"CREATE RULE rtest_pers_upd AS ON UPDATE TO rtest_person DO UPDATE rtest_admin SET pname = new.pname WHERE (rtest_admin.pname = old.pname);" ]
[ "rtest_system",	"rtest_sys_del",	"CREATE RULE rtest_sys_del AS ON DELETE TO rtest_system DO (DELETE FROM rtest_interface WHERE (rtest_interface.sysname = old.sysname); DELETE FROM rtest_admin WHERE (rtest_admin.sysname = old.sysname); );" ]
[ "rtest_system",	"rtest_sys_upd",	"CREATE RULE rtest_sys_upd AS ON UPDATE TO rtest_system DO (UPDATE rtest_interface SET sysname = new.sysname WHERE (rtest_interface.sysname = old.sysname); UPDATE rtest_admin SET sysname = new.sysname WHERE (rtest_admin.sysname = old.sysname); );" ]
[ "rtest_t4",	"rtest_t4_ins1",	"CREATE RULE rtest_t4_ins1 AS ON INSERT TO rtest_t4 WHERE ((new.a >= 10) AND (new.a < 20)) DO INSTEAD INSERT INTO rtest_t5 (a, b) VALUES (new.a, new.b);" ]
[ "rtest_t4",	"rtest_t4_ins2",	"CREATE RULE rtest_t4_ins2 AS ON INSERT TO rtest_t4 WHERE ((new.a >= 20) AND (new.a < 30)) DO INSERT INTO rtest_t6 (a, b) VALUES (new.a, new.b);" ]
[ "rtest_t5",	"rtest_t5_ins",	"CREATE RULE rtest_t5_ins AS ON INSERT TO rtest_t5 WHERE (new.a > 15) DO INSERT INTO rtest_t7 (a, b) VALUES (new.a, new.b);" ]
[ "rtest_t6",	"rtest_t6_ins",	"CREATE RULE rtest_t6_ins AS ON INSERT TO rtest_t6 WHERE (new.a > 25) DO INSTEAD INSERT INTO rtest_t8 (a, b) VALUES (new.a, new.b);" ]
[ "rtest_v1",	"rtest_v1_del",	"CREATE RULE rtest_v1_del AS ON DELETE TO rtest_v1 DO INSTEAD DELETE FROM rtest_t1 WHERE (rtest_t1.a = old.a);" ]
[ "rtest_v1",	"rtest_v1_ins",	"CREATE RULE rtest_v1_ins AS ON INSERT TO rtest_v1 DO INSTEAD INSERT INTO rtest_t1 (a, b) VALUES (new.a, new.b);" ]
[ "rtest_v1",	"rtest_v1_upd",	"CREATE RULE rtest_v1_upd AS ON UPDATE TO rtest_v1 DO INSTEAD UPDATE rtest_t1 SET a = new.a, b = new.b WHERE (rtest_t1.a = old.a);" ]
[ "shoelace",	"shoelace_del",	"CREATE RULE shoelace_del AS ON DELETE TO shoelace DO INSTEAD DELETE FROM shoelace_data WHERE (shoelace_data.sl_name = old.sl_name);" ]
[ "shoelace",	"shoelace_ins",	"CREATE RULE shoelace_ins AS ON INSERT TO shoelace DO INSTEAD INSERT INTO shoelace_data (sl_name, sl_avail, sl_color, sl_len, sl_unit) VALUES (new.sl_name, new.sl_avail, new.sl_color, new.sl_len, new.sl_unit);" ]
[ "shoelace",	"shoelace_upd",	"CREATE RULE shoelace_upd AS ON UPDATE TO shoelace DO INSTEAD UPDATE shoelace_data SET sl_name = new.sl_name, sl_avail = new.sl_avail, sl_color = new.sl_color, sl_len = new.sl_len, sl_unit = new.sl_unit WHERE (shoelace_data.sl_name = old.sl_name);" ]
[ "shoelace_data",	"log_shoelace",	"CREATE RULE log_shoelace AS ON UPDATE TO shoelace_data WHERE (new.sl_avail <> old.sl_avail) DO INSERT INTO shoelace_log (sl_name, sl_avail, log_who, log_when) VALUES (new.sl_name, new.sl_avail, 'Al Bundy'::string, 'Thu Jan 01 00:00:00 1970'::timestamp without time zone);" ]
[ "shoelace_ok",	"shoelace_ok_ins",	"CREATE RULE shoelace_ok_ins AS ON INSERT TO shoelace_ok DO INSTEAD UPDATE shoelace SET sl_avail = (shoelace.sl_avail + new.ok_quant) WHERE (shoelace.sl_name = new.ok_name);" ]

#--
#-- CREATE OR REPLACE RULE
#--
#CREATE TABLE ruletest_tbl (a int, b int);
#CREATE TABLE ruletest_tbl2 (a int, b int);
#CREATE OR REPLACE RULE myrule AS ON INSERT TO ruletest_tbl
#	DO INSTEAD INSERT INTO ruletest_tbl2 VALUES (10, 10);
#INSERT INTO ruletest_tbl VALUES (99, 99);
[ 1 ]
#CREATE OR REPLACE RULE myrule AS ON INSERT TO ruletest_tbl
#	DO INSTEAD INSERT INTO ruletest_tbl2 VALUES (1000, 1000);
#INSERT INTO ruletest_tbl VALUES (99, 99);
[ 1 ]
#SELECT * FROM ruletest_tbl2;
% sys.L0,	sys.L0 # table_name
% a,	b # name
% ?,	? # type
% ?,	? # length
[ 10,	10 ]
[ 1000,	1000 ]

#-- Check that rewrite rules splitting one INSERT into multiple
#-- conditional statements does not disable FK checking.
#create table rule_and_refint_t1 (
#	id1a integer,
#	id1b integer,
#	
#	primary key (id1a, id1b)
#);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "rule_and_refint_t1_pkey" for table "rule_and_refint_t1"
#create table rule_and_refint_t2 (
#	id2a integer,
#	id2c integer,
#	
#	primary key (id2a, id2c)
#);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "rule_and_refint_t2_pkey" for table "rule_and_refint_t2"
#create table rule_and_refint_t3 (
#	id3a integer,
#	id3b integer,
#	id3c integer,
#	data text,
#	primary key (id3a, id3b, id3c),
#	foreign key (id3a, id3b) references rule_and_refint_t1 (id1a, id1b),
#	foreign key (id3a, id3c) references rule_and_refint_t2 (id2a, id2c)
#);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "rule_and_refint_t3_pkey" for table "rule_and_refint_t3"
#insert into rule_and_refint_t1 values (1, 11);
[ 1 ]
#insert into rule_and_refint_t1 values (1, 12);
[ 1 ]
#insert into rule_and_refint_t1 values (2, 21);
[ 1 ]
#insert into rule_and_refint_t1 values (2, 22);
[ 1 ]
#insert into rule_and_refint_t2 values (1, 11);
[ 1 ]
#insert into rule_and_refint_t2 values (1, 12);
[ 1 ]
#insert into rule_and_refint_t2 values (2, 21);
[ 1 ]
#insert into rule_and_refint_t2 values (2, 22);
[ 1 ]
#insert into rule_and_refint_t3 values (1, 11, 11, 'row1');
[ 1 ]
#insert into rule_and_refint_t3 values (1, 11, 12, 'row2');
[ 1 ]
#insert into rule_and_refint_t3 values (1, 12, 11, 'row3');
[ 1 ]
#insert into rule_and_refint_t3 values (1, 12, 12, 'row4');
[ 1 ]
#create rule rule_and_refint_t3_ins as on insert to rule_and_refint_t3
#	where (exists (select 1 from rule_and_refint_t3
#			where (((rule_and_refint_t3.id3a = new.id3a)
#			and (rule_and_refint_t3.id3b = new.id3b))
#			and (rule_and_refint_t3.id3c = new.id3c))))
#	do instead update rule_and_refint_t3 set data = new.data
#	where (((rule_and_refint_t3.id3a = new.id3a)
#	and (rule_and_refint_t3.id3b = new.id3b))
#	and (rule_and_refint_t3.id3c = new.id3c));
#--
#-- check for planner problems with complex inherited UPDATES
#--
#create table id (id serial primary key, name text);
NOTICE:  CREATE TABLE will create implicit sequence "id_id_seq" for serial column "id.id"
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "id_pkey" for table "id"
#-- currently, must respecify PKEY for each inherited subtable
#create table test_1 (id integer primary key); -- inherits (id)
NOTICE:  merging column "id" with inherited definition
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "test_1_pkey" for table "test_1"
#create table test_2 (id integer primary key); -- inherits (id)
NOTICE:  merging column "id" with inherited definition
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "test_2_pkey" for table "test_2"
#create table test_3 (id integer primary key); -- inherits (id)
NOTICE:  merging column "id" with inherited definition
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "test_3_pkey" for table "test_3"
#insert into test_1 (name) values ('Test 1');
[ 1 ]
#insert into test_1 (name) values ('Test 2');
[ 1 ]
#insert into test_2 (name) values ('Test 3');
[ 1 ]
#insert into test_2 (name) values ('Test 4');
[ 1 ]
#insert into test_3 (name) values ('Test 5');
[ 1 ]
#insert into test_3 (name) values ('Test 6');
[ 1 ]
#create view id_ordered as select * from id order by id;
#create rule update_id_ordered as on update to id_ordered
#	do instead update id set name = new.name where id = old.id;
#select * from id_ordered;
% sys.L0,	sys.L0 # table_name
% id,	name # name
% ?,	? # type
% ?,	? # length
[ 1,	"Test 1" ]
[ 2,	"Test 2" ]
[ 3,	"Test 3" ]
[ 4,	"Test 4" ]
[ 5,	"Test 5" ]
[ 6,	"Test 6" ]

#update id_ordered set name = 'update 2' where id = 2;
#update id_ordered set name = 'update 4' where id = 4;
#update id_ordered set name = 'update 5' where id = 5;
#select * from id_ordered;
% sys.L0,	sys.L0 # table_name
% id,	name # name
% ?,	? # type
% ?,	? # length
[ 1,	"Test 1" ]
[ 2,	"update 2" ]
[ 3,	"Test 3" ]
[ 4,	"update 4" ]
[ 5,	"update 5" ]
[ 6,	"Test 6" ]

set client_min_messages to warning; -- suppress cascade notices
#drop table id cascade;

= ! Correct / expected output still needs to be provided / verified / approved ! =

# 17:11:19 >  
# 17:11:19 >  "Done."
# 17:11:19 >  

