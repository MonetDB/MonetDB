Running database upgrade commands to update system tables.

Running database upgrade commands:
create function sys.generate_series(first hugeint, "limit" hugeint)
returns table (value hugeint)
external name generator.series;
create function sys.generate_series(first hugeint, "limit" hugeint, stepsize hugeint)
returns table (value hugeint)
external name generator.series;
create aggregate stddev_samp(val HUGEINT) returns DOUBLE
 external name "aggr"."stdev";
GRANT EXECUTE ON AGGREGATE stddev_samp(HUGEINT) TO PUBLIC;
create window stddev_samp(val HUGEINT) returns DOUBLE
 external name "sql"."stdev";
GRANT EXECUTE ON WINDOW stddev_samp(HUGEINT) TO PUBLIC;
create aggregate stddev_pop(val HUGEINT) returns DOUBLE
 external name "aggr"."stdevp";
GRANT EXECUTE ON AGGREGATE stddev_pop(HUGEINT) TO PUBLIC;
create window stddev_pop(val HUGEINT) returns DOUBLE
 external name "sql"."stdevp";
GRANT EXECUTE ON WINDOW stddev_pop(HUGEINT) TO PUBLIC;
create aggregate var_samp(val HUGEINT) returns DOUBLE
 external name "aggr"."variance";
GRANT EXECUTE ON AGGREGATE var_samp(HUGEINT) TO PUBLIC;
create window var_samp(val HUGEINT) returns DOUBLE
 external name "sql"."variance";
GRANT EXECUTE ON WINDOW var_samp(HUGEINT) TO PUBLIC;
create aggregate covar_samp(e1 HUGEINT, e2 HUGEINT) returns DOUBLE
 external name "aggr"."covariance";
GRANT EXECUTE ON AGGREGATE covar_samp(HUGEINT, HUGEINT) TO PUBLIC;
create window covar_samp(e1 HUGEINT, e2 HUGEINT) returns DOUBLE
 external name "sql"."covariance";
GRANT EXECUTE ON WINDOW covar_samp(HUGEINT, HUGEINT) TO PUBLIC;
create aggregate var_pop(val HUGEINT) returns DOUBLE
 external name "aggr"."variancep";
GRANT EXECUTE ON AGGREGATE var_pop(HUGEINT) TO PUBLIC;
create window var_pop(val HUGEINT) returns DOUBLE
 external name "sql"."variancep";
GRANT EXECUTE ON WINDOW var_pop(HUGEINT) TO PUBLIC;
create aggregate covar_pop(e1 HUGEINT, e2 HUGEINT) returns DOUBLE
 external name "aggr"."covariancep";
GRANT EXECUTE ON AGGREGATE covar_pop(HUGEINT, HUGEINT) TO PUBLIC;
create window covar_pop(e1 HUGEINT, e2 HUGEINT) returns DOUBLE
 external name "sql"."covariancep";
GRANT EXECUTE ON WINDOW covar_pop(HUGEINT, HUGEINT) TO PUBLIC;
create aggregate median(val HUGEINT) returns HUGEINT
 external name "aggr"."median";
GRANT EXECUTE ON AGGREGATE median(HUGEINT) TO PUBLIC;
create aggregate quantile(val HUGEINT, q DOUBLE) returns HUGEINT
 external name "aggr"."quantile";
GRANT EXECUTE ON AGGREGATE quantile(HUGEINT, DOUBLE) TO PUBLIC;
create aggregate median_avg(val HUGEINT) returns DOUBLE
 external name "aggr"."median_avg";
GRANT EXECUTE ON AGGREGATE median_avg(HUGEINT) TO PUBLIC;
create aggregate quantile_avg(val HUGEINT, q DOUBLE) returns DOUBLE
 external name "aggr"."quantile_avg";
GRANT EXECUTE ON AGGREGATE quantile_avg(HUGEINT, DOUBLE) TO PUBLIC;
create aggregate corr(e1 HUGEINT, e2 HUGEINT) returns DOUBLE
 external name "aggr"."corr";
GRANT EXECUTE ON AGGREGATE corr(HUGEINT, HUGEINT) TO PUBLIC;
create window corr(e1 HUGEINT, e2 HUGEINT) returns DOUBLE
 external name "sql"."corr";
GRANT EXECUTE ON WINDOW corr(HUGEINT, HUGEINT) TO PUBLIC;
create function json.filter(js json, name hugeint)
returns json external name json.filter;
GRANT EXECUTE ON FUNCTION json.filter(json, hugeint) TO PUBLIC;
update sys.functions set system = true where system <> true and name in ('generate_series') and schema_id = (select id from sys.schemas where name = 'sys') and type = 5;
update sys.functions set system = true where system <> true and name in ('stddev_samp', 'stddev_pop', 'var_samp', 'covar_samp', 'var_pop', 'covar_pop', 'median', 'median_avg', 'quantile', 'quantile_avg', 'corr') and schema_id = (select id from sys.schemas where name = 'sys') and type = 3;
update sys.functions set system = true where system <> true and name in ('stddev_samp', 'stddev_pop', 'var_samp', 'covar_samp', 'var_pop', 'covar_pop', 'corr') and schema_id = (select id from sys.schemas where name = 'sys') and type = 6;
update sys.functions set system = true where system <> true and name = 'filter' and schema_id = (select id from sys.schemas where name = 'json') and type = 1;

Running database upgrade commands:
drop procedure if exists SHPattach(string) cascade;
drop procedure if exists SHPload(integer) cascade;
drop procedure if exists SHPload(integer, geometry) cascade;

Running database upgrade commands:
create procedure SHPLoad(fname string, schemaname string, tablename string) external name shp.load;
create procedure SHPLoad(fname string, tablename string) external name shp.load;
update sys.functions set system = true where schema_id = 2000 and name in ('shpload');
Running database upgrade commands:
drop function if exists sys.st_intersects(geometry, geometry) cascade;
drop function if exists sys.st_dwithin(geometry, geometry, double) cascade;
drop view if exists sys.geometry_columns cascade;
drop function if exists sys.st_collect(geometry, geometry) cascade;
drop aggregate if exists sys.st_collect(geometry) cascade;
drop aggregate if exists sys.st_makeline(geometry) cascade;
create view sys.geometry_columns as
 select cast(null as varchar(1)) as f_table_catalog,
  s.name as f_table_schema,
  t.name as f_table_name,
  c.name as f_geometry_column,
  cast(has_z(c.type_digits) + has_m(c.type_digits) +2 as integer) as coord_dimension,
  c.type_scale as srid,
  get_type(c.type_digits, 0) as geometry_type
 from sys.columns c, sys.tables t, sys.schemas s
 where c.table_id = t.id and t.schema_id = s.id
  and c.type in (select sqlname from sys.types where systemname in ('wkb', 'wkba'));
GRANT SELECT ON sys.geometry_columns TO PUBLIC;
CREATE FUNCTION ST_Collect(geom1 Geometry, geom2 Geometry) RETURNS Geometry EXTERNAL NAME geom."Collect";
GRANT EXECUTE ON FUNCTION ST_Collect(Geometry, Geometry) TO PUBLIC;
CREATE AGGREGATE ST_Collect(geom Geometry) RETURNS Geometry external name aggr."Collect";
GRANT EXECUTE ON AGGREGATE ST_Collect(Geometry) TO PUBLIC;
CREATE FUNCTION ST_DistanceGeographic(geom1 Geometry, geom2 Geometry) RETURNS double EXTERNAL NAME geom."DistanceGeographic";
GRANT EXECUTE ON FUNCTION ST_DistanceGeographic(Geometry, Geometry) TO PUBLIC;
CREATE FILTER FUNCTION ST_DWithinGeographic(geom1 Geometry, geom2 Geometry, distance double) EXTERNAL NAME geom."DWithinGeographic";
GRANT EXECUTE ON FILTER ST_DWithinGeographic(Geometry, Geometry, double) TO PUBLIC;
CREATE FILTER FUNCTION ST_DWithin(geom1 Geometry, geom2 Geometry, distance double) EXTERNAL NAME rtree."DWithin";
GRANT EXECUTE ON FILTER ST_DWithin(Geometry, Geometry, double) TO PUBLIC;
CREATE FILTER FUNCTION ST_DWithin_NoIndex(geom1 Geometry, geom2 Geometry, distance double) EXTERNAL NAME geom."DWithin_noindex";
GRANT EXECUTE ON FILTER ST_DWithin_NoIndex(Geometry, Geometry, double) TO PUBLIC;
CREATE FUNCTION ST_DWithin2(geom1 Geometry, geom2 Geometry, bbox1 mbr, bbox2 mbr, dst double) RETURNS boolean EXTERNAL NAME geom."DWithin2";
GRANT EXECUTE ON FUNCTION ST_DWithin2(Geometry, Geometry, mbr, mbr, double) TO PUBLIC;
CREATE FILTER FUNCTION ST_IntersectsGeographic(geom1 Geometry, geom2 Geometry) EXTERNAL NAME geom."IntersectsGeographic";
GRANT EXECUTE ON FILTER ST_IntersectsGeographic(Geometry, Geometry) TO PUBLIC;
CREATE FILTER FUNCTION ST_Intersects(geom1 Geometry, geom2 Geometry) EXTERNAL NAME rtree."Intersects";
GRANT EXECUTE ON FILTER ST_Intersects(Geometry, Geometry) TO PUBLIC;
CREATE FILTER FUNCTION ST_Intersects_NoIndex(geom1 Geometry, geom2 Geometry) EXTERNAL NAME geom."Intersects_noindex";
GRANT EXECUTE ON FILTER ST_Intersects_NoIndex(Geometry, Geometry) TO PUBLIC;
CREATE AGGREGATE ST_MakeLine(geom Geometry) RETURNS Geometry external name aggr."MakeLine";
GRANT EXECUTE ON AGGREGATE ST_MakeLine(Geometry) TO PUBLIC;
update sys.functions set system = true where system <> true and schema_id = 2000 and name in ('st_collect', 'st_distancegeographic', 'st_dwithingeographic', 'st_dwithin', 'st_dwithin_noindex', 'st_dwithin2', 'st_intersectsgeographic', 'st_intersects', 'st_intersects_noindex', 'st_makeline');
update sys._tables set system = true where system <> true and schema_id = 2000 and name = 'geometry_columns';

Running database upgrade commands:
drop function sys.similarity(string, string) cascade;

Running database upgrade commands:
CREATE VIEW sys.describe_accessible_tables AS
 SELECT
 schemas.name AS schema,
 tables.name  AS table,
 tt.table_type_name AS table_type,
 pc.privilege_code_name AS privs,
 p.privileges AS privs_code
 FROM privileges p
 JOIN sys.roles ON p.auth_id = roles.id
 JOIN sys.tables ON p.obj_id = tables.id
 JOIN sys.table_types tt ON tables.type = tt.table_type_id
 JOIN sys.schemas ON tables.schema_id = schemas.id
 JOIN sys.privilege_codes pc ON p.privileges = pc.privilege_code_id
 WHERE roles.name = current_role;
GRANT SELECT ON sys.describe_accessible_tables TO PUBLIC;
update sys._tables set system = true where system <> true and schema_id = 2000 and name = 'describe_accessible_tables';
alter table sys.function_languages set read write;
delete from sys.function_languages where language_keyword like 'PYTHON%_MAP';
update sys.functions set language = language - 1 where language in (7, 11);
update sys.functions set mod = 'pyapi3' where mod in ('pyapi', 'pyapi3map');
commit;

Running database upgrade commands:
alter table sys.function_languages set read only;

Running database upgrade commands:
DROP FUNCTION IF EXISTS sys.dump_database(BOOLEAN) CASCADE;
DROP VIEW IF EXISTS sys.dump_comments CASCADE;
DROP VIEW IF EXISTS sys.describe_comments CASCADE;
CREATE VIEW sys.describe_comments AS
	SELECT o.id AS id, o.tpe AS tpe, o.nme AS fqn, cm.remark AS rem
	FROM (
		SELECT id, 'SCHEMA', sys.DQ(name) FROM sys.schemas WHERE NOT system
		UNION ALL
		SELECT t.id, ifthenelse(ts.table_type_name = 'VIEW', 'VIEW', 'TABLE'), sys.FQN(s.name, t.name)
		  FROM sys.schemas s JOIN sys._tables t ON s.id = t.schema_id JOIN sys.table_types ts ON t.type = ts.table_type_id
		 WHERE NOT t.system
		UNION ALL
		SELECT c.id, 'COLUMN', sys.FQN(s.name, t.name) || '.' || sys.DQ(c.name) FROM sys.columns c, sys._tables t, sys.schemas s WHERE NOT t.system AND c.table_id = t.id AND t.schema_id = s.id
		UNION ALL
		SELECT idx.id, 'INDEX', sys.FQN(s.name, idx.name) FROM sys.idxs idx, sys._tables t, sys.schemas s WHERE NOT t.system AND idx.table_id = t.id AND t.schema_id = s.id
		UNION ALL
		SELECT seq.id, 'SEQUENCE', sys.FQN(s.name, seq.name) FROM sys.sequences seq, sys.schemas s WHERE seq.schema_id = s.id
		UNION ALL
		SELECT f.id, ft.function_type_keyword, qf.nme FROM sys.functions f, sys.function_types ft, sys.schemas s, sys.fully_qualified_functions qf
		 WHERE NOT f.system AND f.type = ft.function_type_id AND f.schema_id = s.id AND qf.id = f.id
		) AS o(id, tpe, nme)
	JOIN sys.comments cm ON cm.id = o.id;
GRANT SELECT ON sys.describe_comments TO PUBLIC;
CREATE VIEW sys.dump_comments AS
  SELECT 'COMMENT ON ' || c.tpe || ' ' || c.fqn || ' IS ' || sys.SQ(c.rem) || ';' stmt FROM sys.describe_comments c;
CREATE FUNCTION sys.dump_database(describe BOOLEAN) RETURNS TABLE(o int, stmt STRING)
BEGIN
  SET SCHEMA sys;
  TRUNCATE sys.dump_statements;
  INSERT INTO sys.dump_statements VALUES (1, 'START TRANSACTION;');
  INSERT INTO sys.dump_statements VALUES (2, 'SET SCHEMA "sys";');
  INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_create_roles;
  INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_create_users;
  INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_create_schemas;
  INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_user_defined_types;
  INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_add_schemas_to_users;
  INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_grant_user_privileges;
  INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_sequences;
  --functions and table-likes can be interdependent. They should be inserted in the order of their catalogue id.
  INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(ORDER BY stmts.o), stmts.s
				    FROM (
				      SELECT f.o, f.stmt FROM sys.dump_functions f
				       UNION ALL
				      SELECT t.o, t.stmt FROM sys.dump_tables t
				    ) AS stmts(o, s);
  IF NOT DESCRIBE THEN
    CALL sys.dump_table_data();
  END IF;
  INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_start_sequences;
  INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_column_defaults;
  INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_table_constraint_type;
  INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_indices;
  INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_foreign_keys;
  INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_partition_tables;
  INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_triggers;
  INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_comments;
  INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_table_grants;
  INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_column_grants;
  INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_function_grants;
  INSERT INTO sys.dump_statements VALUES ((SELECT COUNT(*) FROM sys.dump_statements) + 1, 'COMMIT;');
  RETURN sys.dump_statements;
END;
update sys._tables set system = true where schema_id = 2000 and name in ('describe_comments','dump_comments');
update sys.functions set system = true where system <> true and schema_id = 2000 and name = 'dump_database' and type = 5;

Running database upgrade commands:
CREATE FUNCTION sys.sql_datatype(mtype varchar(999), digits integer, tscale integer, nameonly boolean, shortname boolean)
  RETURNS varchar(1024)
BEGIN
  RETURN
    CASE mtype
    WHEN 'char' THEN sys.ifthenelse(nameonly OR digits <= 1, sys.ifthenelse(shortname, 'CHAR', 'CHARACTER'), sys.ifthenelse(shortname, 'CHAR(', 'CHARACTER(') || digits || ')')
    WHEN 'varchar' THEN sys.ifthenelse(nameonly OR digits = 0, sys.ifthenelse(shortname, 'VARCHAR', 'CHARACTER VARYING'), sys.ifthenelse(shortname, 'VARCHAR(', 'CHARACTER VARYING(') || digits || ')')
    WHEN 'clob' THEN sys.ifthenelse(nameonly OR digits = 0, sys.ifthenelse(shortname, 'CLOB', 'CHARACTER LARGE OBJECT'), sys.ifthenelse(shortname, 'CLOB(', 'CHARACTER LARGE OBJECT(') || digits || ')')
    WHEN 'blob' THEN sys.ifthenelse(nameonly OR digits = 0, sys.ifthenelse(shortname, 'BLOB', 'BINARY LARGE OBJECT'), sys.ifthenelse(shortname, 'BLOB(', 'BINARY LARGE OBJECT(') || digits || ')')
    WHEN 'int' THEN 'INTEGER'
    WHEN 'bigint' THEN 'BIGINT'
    WHEN 'smallint' THEN 'SMALLINT'
    WHEN 'tinyint' THEN 'TINYINT'
    WHEN 'hugeint' THEN 'HUGEINT'
    WHEN 'boolean' THEN 'BOOLEAN'
    WHEN 'date' THEN 'DATE'
    WHEN 'time' THEN sys.ifthenelse(nameonly OR digits = 1, 'TIME', 'TIME(' || (digits -1) || ')')
    WHEN 'timestamp' THEN sys.ifthenelse(nameonly OR digits = 7, 'TIMESTAMP', 'TIMESTAMP(' || (digits -1) || ')')
    WHEN 'timestamptz' THEN sys.ifthenelse(nameonly OR digits = 7, 'TIMESTAMP WITH TIME ZONE', 'TIMESTAMP(' || (digits -1) || ') WITH TIME ZONE')
    WHEN 'timetz' THEN sys.ifthenelse(nameonly OR digits = 1, 'TIME WITH TIME ZONE', 'TIME(' || (digits -1) || ') WITH TIME ZONE')
    WHEN 'decimal' THEN sys.ifthenelse(nameonly OR digits = 0, 'DECIMAL', 'DECIMAL(' || digits || sys.ifthenelse(tscale = 0, '', ',' || tscale) || ')')
    WHEN 'double' THEN sys.ifthenelse(nameonly OR (digits = 53 AND tscale = 0), sys.ifthenelse(shortname, 'DOUBLE', 'DOUBLE PRECISION'), 'FLOAT(' || digits || ')')
    WHEN 'real' THEN sys.ifthenelse(nameonly OR (digits = 24 AND tscale = 0), 'REAL', 'FLOAT(' || digits || ')')
    WHEN 'day_interval' THEN 'INTERVAL DAY'
    WHEN 'month_interval' THEN CASE digits WHEN 1 THEN 'INTERVAL YEAR' WHEN 2 THEN 'INTERVAL YEAR TO MONTH' WHEN 3 THEN 'INTERVAL MONTH' END
    WHEN 'sec_interval' THEN
	CASE digits
	WHEN 4 THEN 'INTERVAL DAY'
	WHEN 5 THEN 'INTERVAL DAY TO HOUR'
	WHEN 6 THEN 'INTERVAL DAY TO MINUTE'
	WHEN 7 THEN 'INTERVAL DAY TO SECOND'
	WHEN 8 THEN 'INTERVAL HOUR'
	WHEN 9 THEN 'INTERVAL HOUR TO MINUTE'
	WHEN 10 THEN 'INTERVAL HOUR TO SECOND'
	WHEN 11 THEN 'INTERVAL MINUTE'
	WHEN 12 THEN 'INTERVAL MINUTE TO SECOND'
	WHEN 13 THEN 'INTERVAL SECOND'
	END
    WHEN 'oid' THEN 'OID'
    WHEN 'json' THEN sys.ifthenelse(nameonly OR digits = 0, 'JSON', 'JSON(' || digits || ')')
    WHEN 'url' THEN sys.ifthenelse(nameonly OR digits = 0, 'URL', 'URL(' || digits || ')')
    WHEN 'xml' THEN sys.ifthenelse(nameonly OR digits = 0, 'XML', 'XML(' || digits || ')')
    WHEN 'geometry' THEN
	sys.ifthenelse(nameonly, 'GEOMETRY',
	CASE digits
	WHEN 4 THEN 'GEOMETRY(POINT' || sys.ifthenelse(tscale = 0, ')', ',' || tscale || ')')
	WHEN 8 THEN 'GEOMETRY(LINESTRING' || sys.ifthenelse(tscale = 0, ')', ',' || tscale || ')')
	WHEN 16 THEN 'GEOMETRY(POLYGON' || sys.ifthenelse(tscale = 0, ')', ',' || tscale || ')')
	WHEN 20 THEN 'GEOMETRY(MULTIPOINT' || sys.ifthenelse(tscale = 0, ')', ',' || tscale || ')')
	WHEN 24 THEN 'GEOMETRY(MULTILINESTRING' || sys.ifthenelse(tscale = 0, ')', ',' || tscale || ')')
	WHEN 28 THEN 'GEOMETRY(MULTIPOLYGON' || sys.ifthenelse(tscale = 0, ')', ',' || tscale || ')')
	WHEN 32 THEN 'GEOMETRY(GEOMETRYCOLLECTION' || sys.ifthenelse(tscale = 0, ')', ',' || tscale || ')')
	ELSE 'GEOMETRY'
        END)
    ELSE sys.ifthenelse(mtype = lower(mtype), upper(mtype), '"' || mtype || '"') || sys.ifthenelse(nameonly OR digits = 0, '', '(' || digits || sys.ifthenelse(tscale = 0, '', ',' || tscale) || ')')
    END;
END;
GRANT EXECUTE ON FUNCTION sys.sql_datatype(varchar(999), integer, integer, boolean, boolean) TO PUBLIC;
update sys.functions set system = true where system <> true and schema_id = 2000 and name = 'sql_datatype' and type = 1 and language = 2;

Running database upgrade commands:
CREATE SCHEMA INFORMATION_SCHEMA;
COMMENT ON SCHEMA INFORMATION_SCHEMA IS 'ISO/IEC 9075-11 SQL/Schemata';
update sys.schemas set system = true where name = 'information_schema';
CREATE VIEW INFORMATION_SCHEMA.CHARACTER_SETS AS SELECT
  cast(NULL AS varchar(1)) AS CHARACTER_SET_CATALOG,
  cast(NULL AS varchar(1)) AS CHARACTER_SET_SCHEMA,
  cast('UTF-8' AS varchar(16)) AS CHARACTER_SET_NAME,
  cast('ISO/IEC 10646:2021' AS varchar(20)) AS CHARACTER_REPERTOIRE,
  cast('UTF-8' AS varchar(16)) AS FORM_OF_USE,
  cast(NULL AS varchar(1)) AS DEFAULT_COLLATE_CATALOG,
  cast(NULL AS varchar(1)) AS DEFAULT_COLLATE_SCHEMA,
  cast(NULL AS varchar(1)) AS DEFAULT_COLLATE_NAME;
GRANT SELECT ON TABLE INFORMATION_SCHEMA.CHARACTER_SETS TO PUBLIC WITH GRANT OPTION;
CREATE VIEW INFORMATION_SCHEMA.SCHEMATA AS SELECT
  cast(NULL AS varchar(1)) AS CATALOG_NAME,
  s."name" AS SCHEMA_NAME,
  a."name" AS SCHEMA_OWNER,
  cast(NULL AS varchar(1)) AS DEFAULT_CHARACTER_SET_CATALOG,
  cast(NULL AS varchar(1)) AS DEFAULT_CHARACTER_SET_SCHEMA,
  cast('UTF-8' AS varchar(16)) AS DEFAULT_CHARACTER_SET_NAME,
  cast(NULL AS varchar(1)) AS SQL_PATH,
  s."id" AS schema_id,
  s."system" AS is_system,
  cm."remark" AS comments
 FROM sys."schemas" s
 INNER JOIN sys."auths" a ON s."owner" = a."id"
 LEFT OUTER JOIN sys."comments" cm ON s."id" = cm."id"
 ORDER BY s."name";
GRANT SELECT ON TABLE INFORMATION_SCHEMA.SCHEMATA TO PUBLIC WITH GRANT OPTION;
CREATE VIEW INFORMATION_SCHEMA.TABLES AS SELECT
  cast(NULL AS varchar(1)) AS TABLE_CATALOG,
  s."name" AS TABLE_SCHEMA,
  t."name" AS TABLE_NAME,
  tt."table_type_name" AS TABLE_TYPE,
  cast(NULL AS varchar(1)) AS SELF_REFERENCING_COLUMN_NAME,
  cast(NULL AS varchar(1)) AS REFERENCE_GENERATION,
  cast(NULL AS varchar(1)) AS USER_DEFINED_TYPE_CATALOG,
  cast(NULL AS varchar(1)) AS USER_DEFINED_TYPE_SCHEMA,
  cast(NULL AS varchar(1)) AS USER_DEFINED_TYPE_NAME,
  cast(sys.ifthenelse((t."type" IN (0, 3, 7, 20, 30) AND t."access" IN (0, 2)), 'YES', 'NO') AS varchar(3)) AS IS_INSERTABLE_INTO,
  cast('NO' AS varchar(3)) AS IS_TYPED,
  cast((CASE t."commit_action" WHEN 1 THEN 'DELETE' WHEN 2 THEN 'PRESERVE' WHEN 3 THEN 'DROP' ELSE NULL END) AS varchar(10)) AS COMMIT_ACTION,
  t."schema_id" AS schema_id,
  t."id" AS table_id,
  t."type" AS table_type_id,
  st."count" AS row_count,
  t."system" AS is_system,
  sys.ifthenelse(t."type" IN (1, 11), TRUE, FALSE) AS is_view,
  t."query" AS query_def,
  cm."remark" AS comments
 FROM sys."tables" t
 INNER JOIN sys."schemas" s ON t."schema_id" = s."id"
 INNER JOIN sys."table_types" tt ON t."type" = tt."table_type_id"
 LEFT OUTER JOIN sys."comments" cm ON t."id" = cm."id"
 LEFT OUTER JOIN (SELECT DISTINCT "schema", "table", "count" FROM sys."statistics"()) st ON (s."name" = st."schema" AND t."name" = st."table")
 ORDER BY s."name", t."name";
GRANT SELECT ON TABLE INFORMATION_SCHEMA.TABLES TO PUBLIC WITH GRANT OPTION;
CREATE VIEW INFORMATION_SCHEMA.VIEWS AS SELECT
  cast(NULL AS varchar(1)) AS TABLE_CATALOG,
  s."name" AS TABLE_SCHEMA,
  t."name" AS TABLE_NAME,
  t."query" AS VIEW_DEFINITION,
  cast('NONE' AS varchar(10)) AS CHECK_OPTION,
  cast('NO' AS varchar(3)) AS IS_UPDATABLE,
  cast('NO' AS varchar(3)) AS INSERTABLE_INTO,
  cast('NO' AS varchar(3)) AS IS_TRIGGER_UPDATABLE,
  cast('NO' AS varchar(3)) AS IS_TRIGGER_DELETABLE,
  cast('NO' AS varchar(3)) AS IS_TRIGGER_INSERTABLE_INTO,
  t."schema_id" AS schema_id,
  t."id" AS table_id,
  cast(sys.ifthenelse(t."system", t."type" + 10 , t."type") AS smallint) AS table_type_id,
  t."system" AS is_system,
  cm."remark" AS comments
 FROM sys."_tables" t
 INNER JOIN sys."schemas" s ON t."schema_id" = s."id"
 LEFT OUTER JOIN sys."comments" cm ON t."id" = cm."id"
 WHERE t."type" = 1
 ORDER BY s."name", t."name";
GRANT SELECT ON TABLE INFORMATION_SCHEMA.VIEWS TO PUBLIC WITH GRANT OPTION;
CREATE VIEW INFORMATION_SCHEMA.COLUMNS AS SELECT
  cast(NULL AS varchar(1)) AS TABLE_CATALOG,
  s."name" AS TABLE_SCHEMA,
  t."name" AS TABLE_NAME,
  c."name" AS COLUMN_NAME,
  cast(1 + c."number" AS int) AS ORDINAL_POSITION,
  c."default" AS COLUMN_DEFAULT,
  cast(sys.ifthenelse(c."null", 'YES', 'NO') AS varchar(3)) AS IS_NULLABLE,
  cast(sys."sql_datatype"(c."type", c."type_digits", c."type_scale", true, true) AS varchar(1024)) AS DATA_TYPE,
  cast(sys.ifthenelse(c."type" IN ('varchar','clob','char','json','url','xml') AND c."type_digits" > 0, c."type_digits", NULL) AS int) AS CHARACTER_MAXIMUM_LENGTH,
  cast(sys.ifthenelse(c."type" IN ('varchar','clob','char','json','url','xml') AND c."type_digits" > 0, 4 * cast(c."type_digits" as bigint), NULL) AS bigint) AS CHARACTER_OCTET_LENGTH,
  cast(sys.ifthenelse(c."type" IN ('int','smallint','tinyint','bigint','hugeint','float','real','double','decimal','numeric','oid'), c."type_digits", NULL) AS int) AS NUMERIC_PRECISION,
  cast(sys.ifthenelse(c."type" IN ('int','smallint','tinyint','bigint','hugeint','float','real','double','oid'), 2, sys.ifthenelse(c."type" IN ('decimal','numeric'), 10, NULL)) AS int) AS NUMERIC_PRECISION_RADIX,
  cast(sys.ifthenelse(c."type" IN ('int','smallint','tinyint','bigint','hugeint','float','real','double','decimal','numeric','oid'), c."type_scale", NULL) AS int) AS NUMERIC_SCALE,
  cast(sys.ifthenelse(c."type" IN ('date','timestamp','timestamptz','time','timetz'), sys.ifthenelse(c."type_scale" > 0, c."type_scale" -1, 0), NULL) AS int) AS DATETIME_PRECISION,
  cast(sys.ifthenelse(c."type" IN ('day_interval','month_interval','sec_interval'), sys."sql_datatype"(c."type", c."type_digits", c."type_scale", true, true), NULL) AS varchar(40)) AS INTERVAL_TYPE,
  cast(CASE c."type" WHEN 'day_interval' THEN 0 WHEN 'month_interval' THEN 0 WHEN 'sec_interval' THEN (sys.ifthenelse(c."type_digits" IN (7, 10, 12, 13), sys.ifthenelse(c."type_scale" > 0, c."type_scale", 3), 0)) ELSE NULL END AS int) AS INTERVAL_PRECISION,
  cast(NULL AS varchar(1)) AS CHARACTER_SET_CATALOG,
  cast(NULL AS varchar(1)) AS CHARACTER_SET_SCHEMA,
  cast(sys.ifthenelse(c."type" IN ('varchar','clob','char','json','url','xml'), 'UTF-8', NULL) AS varchar(16)) AS CHARACTER_SET_NAME,
  cast(NULL AS varchar(1)) AS COLLATION_CATALOG,
  cast(NULL AS varchar(1)) AS COLLATION_SCHEMA,
  cast(NULL AS varchar(1)) AS COLLATION_NAME,
  cast(NULL AS varchar(1)) AS DOMAIN_CATALOG,
  cast(NULL AS varchar(1)) AS DOMAIN_SCHEMA,
  cast(NULL AS varchar(1)) AS DOMAIN_NAME,
  cast(NULL AS varchar(1)) AS UDT_CATALOG,
  cast(NULL AS varchar(1)) AS UDT_SCHEMA,
  cast(NULL AS varchar(1)) AS UDT_NAME,
  cast(NULL AS varchar(1)) AS SCOPE_CATALOG,
  cast(NULL AS varchar(1)) AS SCOPE_SCHEMA,
  cast(NULL AS varchar(1)) AS SCOPE_NAME,
  cast(NULL AS int) AS MAXIMUM_CARDINALITY,
  cast(NULL AS varchar(1)) AS DTD_IDENTIFIER,
  cast('NO' AS varchar(3)) AS IS_SELF_REFERENCING,
  cast(sys.ifthenelse(seq."name" IS NULL OR c."null", 'NO', 'YES') AS varchar(3)) AS IS_IDENTITY,
  seq."name" AS IDENTITY_GENERATION,
  seq."start" AS IDENTITY_START,
  seq."increment" AS IDENTITY_INCREMENT,
  seq."maxvalue" AS IDENTITY_MAXIMUM,
  seq."minvalue" AS IDENTITY_MINIMUM,
  cast(sys.ifthenelse(seq."name" IS NULL, NULL, sys.ifthenelse(seq."cycle", 'YES', 'NO')) AS varchar(3)) AS IDENTITY_CYCLE,
  cast(sys.ifthenelse(seq."name" IS NULL, 'NO', 'YES') AS varchar(3)) AS IS_GENERATED,
  cast(sys.ifthenelse(seq."name" IS NULL, NULL, c."default") AS varchar(1024)) AS GENERATION_EXPRESSION,
  cast('NO' AS varchar(3)) AS IS_SYSTEM_TIME_PERIOD_START,
  cast('NO' AS varchar(3)) AS IS_SYSTEM_TIME_PERIOD_END,
  cast('NO' AS varchar(3)) AS SYSTEM_TIME_PERIOD_TIMESTAMP_GENERATION,
  cast(sys.ifthenelse(t."type" IN (0,3,7,20,30), 'YES', 'NO') AS varchar(3)) AS IS_UPDATABLE,
  cast(NULL AS varchar(1)) AS DECLARED_DATA_TYPE,
  cast(NULL AS int) AS DECLARED_NUMERIC_PRECISION,
  cast(NULL AS int) AS DECLARED_NUMERIC_SCALE,
  t."schema_id" AS schema_id,
  c."table_id" AS table_id,
  c."id" AS column_id,
  seq."id" AS sequence_id,
  t."system" AS is_system,
  cm."remark" AS comments
 FROM sys."columns" c
 INNER JOIN sys."tables" t ON c."table_id" = t."id"
 INNER JOIN sys."schemas" s ON t."schema_id" = s."id"
 LEFT OUTER JOIN sys."comments" cm ON c."id" = cm."id"
 LEFT OUTER JOIN sys."sequences" seq ON ((seq."name"||'"') = substring(c."default", 3 + sys."locate"('"."seq_',c."default",14)))
 ORDER BY s."name", t."name", c."number";
GRANT SELECT ON TABLE INFORMATION_SCHEMA.COLUMNS TO PUBLIC WITH GRANT OPTION;
CREATE VIEW INFORMATION_SCHEMA.CHECK_CONSTRAINTS AS SELECT
  cast(NULL AS varchar(1)) AS CONSTRAINT_CATALOG,
  cast(NULL AS varchar(1024)) AS CONSTRAINT_SCHEMA,
  cast(NULL AS varchar(1024)) AS CONSTRAINT_NAME,
  cast(NULL AS varchar(1024)) AS CHECK_CLAUSE
 WHERE 1=0;
GRANT SELECT ON TABLE INFORMATION_SCHEMA.CHECK_CONSTRAINTS TO PUBLIC WITH GRANT OPTION;
CREATE VIEW INFORMATION_SCHEMA.TABLE_CONSTRAINTS AS SELECT
  cast(NULL AS varchar(1)) AS CONSTRAINT_CATALOG,
  s."name" AS CONSTRAINT_SCHEMA,
  k."name" AS CONSTRAINT_NAME,
  cast(NULL AS varchar(1)) AS TABLE_CATALOG,
  s."name" AS TABLE_SCHEMA,
  t."name" AS TABLE_NAME,
  cast(CASE k."type" WHEN 0 THEN 'PRIMARY KEY' WHEN 1 THEN 'UNIQUE' WHEN 2 THEN 'FOREIGN KEY' ELSE NULL END AS varchar(16)) AS CONSTRAINT_TYPE,
  cast('NO' AS varchar(3)) AS IS_DEFERRABLE,
  cast('NO' AS varchar(3)) AS INITIALLY_DEFERRED,
  cast('YES' AS varchar(3)) AS ENFORCED,
  t."schema_id" AS schema_id,
  t."id" AS table_id,
  k."id" AS key_id,
  k."type" AS key_type,
  t."system" AS is_system
 FROM (SELECT sk."id", sk."table_id", sk."name", sk."type" FROM sys."keys" sk UNION ALL SELECT tk."id", tk."table_id", tk."name", tk."type" FROM tmp."keys" tk) k
 INNER JOIN (SELECT st."id", st."schema_id", st."name", st."system" FROM sys."_tables" st UNION ALL SELECT tt."id", tt."schema_id", tt."name", tt."system" FROM tmp."_tables" tt) t ON k."table_id" = t."id"
 INNER JOIN sys."schemas" s ON t."schema_id" = s."id"
 ORDER BY s."name", t."name", k."name";
GRANT SELECT ON TABLE INFORMATION_SCHEMA.TABLE_CONSTRAINTS TO PUBLIC WITH GRANT OPTION;
CREATE VIEW INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS AS SELECT
  cast(NULL AS varchar(1)) AS CONSTRAINT_CATALOG,
  s."name" AS CONSTRAINT_SCHEMA,
  fk."name" AS CONSTRAINT_NAME,
  cast(NULL AS varchar(1)) AS UNIQUE_CONSTRAINT_CATALOG,
  uks."name" AS UNIQUE_CONSTRAINT_SCHEMA,
  uk."name" AS UNIQUE_CONSTRAINT_NAME,
  cast('FULL' AS varchar(7)) AS MATCH_OPTION,
  fk."update_action" AS UPDATE_RULE,
  fk."delete_action" AS DELETE_RULE,
  t."schema_id" AS fk_schema_id,
  t."id" AS fk_table_id,
  t."name" AS fk_table_name,
  fk."id" AS fk_key_id,
  ukt."schema_id" AS uc_schema_id,
  uk."table_id" AS uc_table_id,
  ukt."name" AS uc_table_name,
  uk."id" AS uc_key_id
 FROM sys."fkeys" fk
 INNER JOIN sys."tables" t ON t."id" = fk."table_id"
 INNER JOIN sys."schemas" s ON s."id" = t."schema_id"
 LEFT OUTER JOIN sys."keys" uk ON uk."id" = fk."rkey"
 LEFT OUTER JOIN sys."tables" ukt ON ukt."id" = uk."table_id"
 LEFT OUTER JOIN sys."schemas" uks ON uks."id" = ukt."schema_id"
 ORDER BY s."name", t."name", fk."name";
GRANT SELECT ON TABLE INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS TO PUBLIC WITH GRANT OPTION;
CREATE VIEW INFORMATION_SCHEMA.ROUTINES AS SELECT
  cast(NULL AS varchar(1)) AS SPECIFIC_CATALOG,
  s."name" AS SPECIFIC_SCHEMA,
  cast(f."name"||'('||f."id"||')' AS varchar(270)) AS SPECIFIC_NAME,
  cast(NULL AS varchar(1)) AS ROUTINE_CATALOG,
  s."name" AS ROUTINE_SCHEMA,
  f."name" AS ROUTINE_NAME,
  ft."function_type_keyword" AS ROUTINE_TYPE,
  cast(NULL AS varchar(1)) AS MODULE_CATALOG,
  cast(NULL AS varchar(1)) AS MODULE_SCHEMA,
  cast(f."mod" AS varchar(128)) AS MODULE_NAME,
  cast(NULL AS varchar(1)) AS UDT_CATALOG,
  cast(NULL AS varchar(1)) AS UDT_SCHEMA,
  cast(NULL AS varchar(1)) AS UDT_NAME,
  cast(CASE f."type" WHEN 1 THEN sys."sql_datatype"(a."type", a."type_digits", a."type_scale", true, true) WHEN 2 THEN NULL WHEN 5 THEN 'TABLE' WHEN 7 THEN 'TABLE' ELSE NULL END AS varchar(1024)) AS DATA_TYPE,
  cast(sys.ifthenelse(a."type" IN ('varchar','clob','char','json','url','xml') AND a."type_digits" > 0, a."type_digits", NULL) AS int) AS CHARACTER_MAXIMUM_LENGTH,
  cast(sys.ifthenelse(a."type" IN ('varchar','clob','char','json','url','xml') AND a."type_digits" > 0, 4 * cast(a."type_digits" as bigint), NULL) AS bigint) AS CHARACTER_OCTET_LENGTH,
  cast(NULL AS varchar(1)) AS CHARACTER_SET_CATALOG,
  cast(NULL AS varchar(1)) AS CHARACTER_SET_SCHEMA,
  'UTF-8' AS CHARACTER_SET_NAME,
  cast(NULL AS varchar(1)) AS COLLATION_CATALOG,
  cast(NULL AS varchar(1)) AS COLLATION_SCHEMA,
  cast(NULL AS varchar(1)) AS COLLATION_NAME,
  cast(sys.ifthenelse(a."type" IN ('int','smallint','tinyint','bigint','hugeint','float','real','double','decimal','numeric','oid'), a."type_digits", NULL) AS int) AS NUMERIC_PRECISION,
  cast(sys.ifthenelse(a."type" IN ('int','smallint','tinyint','bigint','hugeint','float','real','double','oid'), 2, sys.ifthenelse(a."type" IN ('decimal','numeric'), 10, NULL)) AS int) AS NUMERIC_PRECISION_RADIX,
  cast(sys.ifthenelse(a."type" IN ('int','smallint','tinyint','bigint','hugeint','float','real','double','decimal','numeric','oid'), a."type_scale", NULL) AS int) AS NUMERIC_SCALE,
  cast(sys.ifthenelse(a."type" IN ('date','timestamp','timestamptz','time','timetz'), a."type_scale" -1, NULL) AS int) AS DATETIME_PRECISION,
  cast(sys.ifthenelse(a."type" IN ('day_interval','month_interval','sec_interval'), sys."sql_datatype"(a."type", a."type_digits", a."type_scale", true, true), NULL) AS varchar(40)) AS INTERVAL_TYPE,
  cast(CASE a."type" WHEN 'day_interval' THEN 0 WHEN 'month_interval' THEN 0 WHEN 'sec_interval' THEN (sys.ifthenelse(a."type_digits" IN (7, 10, 12, 13), sys.ifthenelse(a."type_scale" > 0, a."type_scale", 3), 0)) ELSE NULL END AS int) AS INTERVAL_PRECISION,
  cast(NULL AS varchar(1)) AS TYPE_UDT_CATALOG,
  cast(NULL AS varchar(1)) AS TYPE_UDT_SCHEMA,
  cast(NULL AS varchar(1)) AS TYPE_UDT_NAME,
  cast(NULL AS varchar(1)) AS SCOPE_CATALOG,
  cast(NULL AS varchar(1)) AS SCOPE_SCHEMA,
  cast(NULL AS varchar(1)) AS SCOPE_NAME,
  cast(NULL AS int) AS MAXIMUM_CARDINALITY,
  cast(NULL AS int) AS DTD_IDENTIFIER,
  cast(sys."ifthenelse"(sys."locate"('begin',f."func") > 0, sys."ifthenelse"(sys."endswith"(f."func",';'), sys."substring"(f."func", sys."locate"('begin',f."func"), sys."length"(sys."substring"(f."func", sys."locate"('begin',f."func")))-1), sys."substring"(f."func", sys."locate"('begin',f."func"))), NULL) AS varchar(8196)) AS ROUTINE_BODY,
  f."func" AS ROUTINE_DEFINITION,
  cast(sys."ifthenelse"(sys."locate"('external name',f."func") > 0, sys."ifthenelse"(sys."endswith"(f."func",';'), sys."substring"(f."func", 14 + sys."locate"('external name',f."func"), sys."length"(sys."substring"(f."func", 14 + sys."locate"('external name',f."func")))-1), sys."substring"(f."func", 14 + sys."locate"('external name',f."func"))), NULL) AS varchar(1024)) AS EXTERNAL_NAME,
  fl."language_keyword" AS EXTERNAL_LANGUAGE,
  'GENERAL' AS PARAMETER_STYLE,
  'YES' AS IS_DETERMINISTIC,
  cast(sys.ifthenelse(f."side_effect", 'MODIFIES', 'READ') AS varchar(10)) AS SQL_DATA_ACCESS,
  cast(CASE f."type" WHEN 2 THEN NULL ELSE 'NO' END AS varchar(3)) AS IS_NULL_CALL,
  cast(NULL AS varchar(1)) AS SQL_PATH,
  cast(NULL AS varchar(1)) AS SCHEMA_LEVEL_ROUTINE,
  cast(NULL AS int) AS MAX_DYNAMIC_RESULT_SETS,
  cast(NULL AS varchar(1)) AS IS_USER_DEFINED_CAST,
  cast(NULL AS varchar(1)) AS IS_IMPLICITLY_INVOCABLE,
  cast(NULL AS varchar(1)) AS SECURITY_TYPE,
  cast(NULL AS varchar(1)) AS TO_SQL_SPECIFIC_CATALOG,
  cast(NULL AS varchar(1)) AS TO_SQL_SPECIFIC_SCHEMA,
  cast(NULL AS varchar(1)) AS TO_SQL_SPECIFIC_NAME,
  cast(NULL AS varchar(1)) AS AS_LOCATOR,
  cast(NULL AS timestamp) AS CREATED,
  cast(NULL AS timestamp) AS LAST_ALTERED,
  cast(NULL AS varchar(1)) AS NEW_SAVEPOINT_LEVEL,
  cast(NULL AS varchar(1)) AS IS_UDT_DEPENDENT,
  cast(NULL AS varchar(1)) AS RESULT_CAST_FROM_DATA_TYPE,
  cast(NULL AS varchar(1)) AS RESULT_CAST_AS_LOCATOR,
  cast(NULL AS int) AS RESULT_CAST_CHAR_MAX_LENGTH,
  cast(NULL AS int) AS RESULT_CAST_CHAR_OCTET_LENGTH,
  cast(NULL AS varchar(1)) AS RESULT_CAST_CHAR_SET_CATALOG,
  cast(NULL AS varchar(1)) AS RESULT_CAST_CHAR_SET_SCHEMA,
  cast(NULL AS varchar(1)) AS RESULT_CAST_CHARACTER_SET_NAME,
  cast(NULL AS varchar(1)) AS RESULT_CAST_COLLATION_CATALOG,
  cast(NULL AS varchar(1)) AS RESULT_CAST_COLLATION_SCHEMA,
  cast(NULL AS varchar(1)) AS RESULT_CAST_COLLATION_NAME,
  cast(NULL AS int) AS RESULT_CAST_NUMERIC_PRECISION,
  cast(NULL AS int) AS RESULT_CAST_NUMERIC_RADIX,
  cast(NULL AS int) AS RESULT_CAST_NUMERIC_SCALE,
  cast(NULL AS int) AS RESULT_CAST_DATETIME_PRECISION,
  cast(NULL AS varchar(1)) AS RESULT_CAST_INTERVAL_TYPE,
  cast(NULL AS int) AS RESULT_CAST_INTERVAL_PRECISION,
  cast(NULL AS varchar(1)) AS RESULT_CAST_TYPE_UDT_CATALOG,
  cast(NULL AS varchar(1)) AS RESULT_CAST_TYPE_UDT_SCHEMA,
  cast(NULL AS varchar(1)) AS RESULT_CAST_TYPE_UDT_NAME,
  cast(NULL AS varchar(1)) AS RESULT_CAST_SCOPE_CATALOG,
  cast(NULL AS varchar(1)) AS RESULT_CAST_SCOPE_SCHEMA,
  cast(NULL AS varchar(1)) AS RESULT_CAST_SCOPE_NAME,
  cast(NULL AS int) AS RESULT_CAST_MAX_CARDINALITY,
  cast(NULL AS varchar(1)) AS RESULT_CAST_DTD_IDENTIFIER,
  cast(NULL AS varchar(1)) AS DECLARED_DATA_TYPE,
  cast(NULL AS int) AS DECLARED_NUMERIC_PRECISION,
  cast(NULL AS int) AS DECLARED_NUMERIC_SCALE,
  cast(NULL AS varchar(1)) AS RESULT_CAST_FROM_DECLARED_DATA_TYPE,
  cast(NULL AS int) AS RESULT_CAST_DECLARED_NUMERIC_PRECISION,
  cast(NULL AS int) AS RESULT_CAST_DECLARED_NUMERIC_SCALE,
  f."schema_id" AS schema_id,
  f."id" AS function_id,
  f."type" AS function_type,
  f."language" AS function_language,
  f."system" AS is_system,
  cm."remark" AS comments
 FROM sys."functions" f
 INNER JOIN sys."schemas" s ON s."id" = f."schema_id"
 INNER JOIN sys."function_types" ft ON ft."function_type_id" = f."type"
 INNER JOIN sys."function_languages" fl ON fl."language_id" = f."language"
 LEFT OUTER JOIN sys."args" a ON a."func_id" = f."id" and a."inout" = 0 and a."number" = 0
 LEFT OUTER JOIN sys."comments" cm ON cm."id" = f."id"
 WHERE f."type" in (1, 2, 5, 7)
 ORDER BY s."name", f."name";
GRANT SELECT ON TABLE INFORMATION_SCHEMA.ROUTINES TO PUBLIC WITH GRANT OPTION;
CREATE VIEW INFORMATION_SCHEMA.PARAMETERS AS SELECT
  cast(NULL AS varchar(1)) AS SPECIFIC_CATALOG,
  s."name" AS SPECIFIC_SCHEMA,
  cast(f."name"||'('||f."id"||')' AS varchar(270)) AS SPECIFIC_NAME,
  cast(sys.ifthenelse((a."inout" = 0 OR f."type" = 2), 1 + a."number", sys.ifthenelse(f."type" = 1, a."number", (1 + a."number" - f.count_out_cols))) AS int) AS ORDINAL_POSITION,
  cast(sys.ifthenelse(a."inout" = 0, 'OUT', sys.ifthenelse(a."inout" = 1, 'IN', 'INOUT')) as varchar(5)) AS PARAMETER_MODE,
  cast(sys.ifthenelse(a."inout" = 0, 'YES', 'NO') as varchar(3)) AS IS_RESULT,
  cast(NULL AS varchar(1)) AS AS_LOCATOR,
  a."name" AS PARAMETER_NAME,
  cast(NULL AS varchar(1)) AS FROM_SQL_SPECIFIC_CATALOG,
  cast(NULL AS varchar(1)) AS FROM_SQL_SPECIFIC_SCHEMA,
  cast(NULL AS varchar(1)) AS FROM_SQL_SPECIFIC_NAME,
  cast(NULL AS varchar(1)) AS TO_SQL_SPECIFIC_CATALOG,
  cast(NULL AS varchar(1)) AS TO_SQL_SPECIFIC_SCHEMA,
  cast(NULL AS varchar(1)) AS TO_SQL_SPECIFIC_NAME,
  cast(sys."sql_datatype"(a."type", a."type_digits", a."type_scale", true, true) AS varchar(1024)) AS DATA_TYPE,
  cast(sys.ifthenelse(a."type" IN ('varchar','clob','char','json','url','xml') AND a."type_digits" > 0, a."type_digits", NULL) AS int) AS CHARACTER_MAXIMUM_LENGTH,
  cast(sys.ifthenelse(a."type" IN ('varchar','clob','char','json','url','xml') AND a."type_digits" > 0, 4 * cast(a."type_digits" as bigint), NULL) AS bigint) AS CHARACTER_OCTET_LENGTH,
  cast(NULL AS varchar(1)) AS CHARACTER_SET_CATALOG,
  cast(NULL AS varchar(1)) AS CHARACTER_SET_SCHEMA,
  cast(sys.ifthenelse(a."type" IN ('varchar','clob','char','json','url','xml'), 'UTF-8', NULL) AS varchar(16)) AS CHARACTER_SET_NAME,
  cast(NULL AS varchar(1)) AS COLLATION_CATALOG,
  cast(NULL AS varchar(1)) AS COLLATION_SCHEMA,
  cast(NULL AS varchar(1)) AS COLLATION_NAME,
  cast(sys.ifthenelse(a."type" IN ('int','smallint','tinyint','bigint','hugeint','float','real','double','decimal','numeric','oid'), a."type_digits", NULL) AS int) AS NUMERIC_PRECISION,
  cast(sys.ifthenelse(a."type" IN ('int','smallint','tinyint','bigint','hugeint','float','real','double','oid'), 2, sys.ifthenelse(a."type" IN ('decimal','numeric'), 10, NULL)) AS int) AS NUMERIC_PRECISION_RADIX,
  cast(sys.ifthenelse(a."type" IN ('int','smallint','tinyint','bigint','hugeint','float','real','double','decimal','numeric','oid'), a."type_scale", NULL) AS int) AS NUMERIC_SCALE,
  cast(sys.ifthenelse(a."type" IN ('date','timestamp','timestamptz','time','timetz'), sys.ifthenelse(a."type_scale" > 0, a."type_scale" -1, 0), NULL) AS int) AS DATETIME_PRECISION,
  cast(sys.ifthenelse(a."type" IN ('day_interval','month_interval','sec_interval'), sys."sql_datatype"(a."type", a."type_digits", a."type_scale", true, true), NULL) AS varchar(40)) AS INTERVAL_TYPE,
  cast(CASE a."type" WHEN 'day_interval' THEN 0 WHEN 'month_interval' THEN 0 WHEN 'sec_interval' THEN (sys.ifthenelse(a."type_digits" IN (7, 10, 12, 13), sys.ifthenelse(a."type_scale" > 0, a."type_scale", 3), 0)) ELSE NULL END AS int) AS INTERVAL_PRECISION,
  cast(NULL AS varchar(1)) AS UDT_CATALOG,
  cast(NULL AS varchar(1)) AS UDT_SCHEMA,
  cast(NULL AS varchar(1)) AS UDT_NAME,
  cast(NULL AS varchar(1)) AS SCOPE_CATALOG,
  cast(NULL AS varchar(1)) AS SCOPE_SCHEMA,
  cast(NULL AS varchar(1)) AS SCOPE_NAME,
  cast(NULL AS int) AS MAXIMUM_CARDINALITY,
  cast(NULL AS varchar(1)) AS DTD_IDENTIFIER,
  cast(NULL AS varchar(1)) AS DECLARED_DATA_TYPE,
  cast(NULL AS int) AS DECLARED_NUMERIC_PRECISION,
  cast(NULL AS int) AS DECLARED_NUMERIC_SCALE,
  cast(NULL AS varchar(1)) AS PARAMETER_DEFAULT,
  f."schema_id" AS schema_id,
  f."id" AS function_id,
  a."id" AS arg_id,
  f."name" AS function_name,
  f."type" AS function_type,
  f."system" AS is_system
 FROM sys."args" a
 INNER JOIN (SELECT fun.*, (select count(*) from sys.args a0 where a0.inout = 0 and a0.func_id = fun.id) as count_out_cols FROM sys."functions" fun WHERE fun."type" in (1, 2, 5, 7)) f ON f."id" = a."func_id"
 INNER JOIN sys."schemas" s ON s."id" = f."schema_id"
 ORDER BY s."name", f."name", f."id", a."inout" DESC, a."number";
GRANT SELECT ON TABLE INFORMATION_SCHEMA.PARAMETERS TO PUBLIC WITH GRANT OPTION;
CREATE VIEW INFORMATION_SCHEMA.SEQUENCES AS SELECT
  cast(NULL AS varchar(1)) AS SEQUENCE_CATALOG,
  s."name" AS SEQUENCE_SCHEMA,
  sq."name" AS SEQUENCE_NAME,
  cast('BIGINT' AS varchar(16)) AS DATA_TYPE,
  cast(64 AS SMALLINT) AS NUMERIC_PRECISION,
  cast(2 AS SMALLINT) AS NUMERIC_PRECISION_RADIX,
  cast(0 AS SMALLINT) AS NUMERIC_SCALE,
  sq."start" AS START_VALUE,
  sq."minvalue" AS MINIMUM_VALUE,
  sq."maxvalue" AS MAXIMUM_VALUE,
  sq."increment" AS INCREMENT,
  cast(sys.ifthenelse(sq."cycle", 'YES', 'NO') AS varchar(3)) AS CYCLE_OPTION,
  cast(NULL AS varchar(16)) AS DECLARED_DATA_TYPE,
  cast(NULL AS SMALLINT) AS DECLARED_NUMERIC_PRECISION,
  cast(NULL AS SMALLINT) AS DECLARED_NUMERIC_SCALE,
  sq."schema_id" AS schema_id,
  sq."id" AS sequence_id,
  get_value_for(s."name", sq."name") AS current_value,
  sq."cacheinc" AS cacheinc,
  cm."remark" AS comments
 FROM sys."sequences" sq
 INNER JOIN sys."schemas" s ON sq."schema_id" = s."id"
 LEFT OUTER JOIN sys."comments" cm ON sq."id" = cm."id"
 ORDER BY s."name", sq."name";
GRANT SELECT ON TABLE INFORMATION_SCHEMA.SEQUENCES TO PUBLIC WITH GRANT OPTION;

update sys._tables set system = true where system <> true
 and schema_id = (select s.id from sys.schemas s where s.name = 'information_schema')
 and name in ('character_sets','check_constraints','columns','parameters','routines','schemata','sequences','referential_constraints','table_constraints','tables','views');

Running database upgrade commands:
CREATE FUNCTION sys.persist_unlogged(sname STRING, tname STRING)
RETURNS TABLE("table" STRING, "table_id" INT, "rowcount" BIGINT)
EXTERNAL NAME sql.persist_unlogged;
GRANT EXECUTE ON FUNCTION sys.persist_unlogged(string, string) TO PUBLIC;
UPDATE sys.functions SET system = true WHERE system <> true AND
name = 'persist_unlogged' AND schema_id = 2000 AND type = 5 AND language = 1;

Running database upgrade commands:
drop function json.isvalid(json);
create function json.isvalid(js json)
returns bool begin return case when js is NULL then NULL else true end; end;
GRANT EXECUTE ON FUNCTION json.isvalid(json) TO PUBLIC;
update sys.functions set system = true where system <> true and name = 'isvalid' and schema_id = (select id from sys.schemas where name = 'json');

Running database upgrade commands:
delete from sys.dependencies where (id, depend_id) in (select c.id, f.id from sys.functions f, sys._tables t, sys._columns c, sys.dependencies d where c.table_id = t.id and f.id = d.depend_id and c.id = d.id and f.schema_id = 2000 and t.schema_id = 2000 and (f.name, t.name, c.name) in (values ('describe_columns', '_columns', 'storage'), ('describe_function', 'function_languages', 'language_name'), ('describe_function', 'function_types', 'function_type_name'), ('describe_function', 'functions', 'func'), ('describe_function', 'functions', 'mod'), ('describe_function', 'functions', 'semantics'), ('describe_function', 'functions', 'side_effect'), ('describe_function', 'functions', 'system'), ('describe_function', 'functions', 'vararg'), ('describe_function', 'functions', 'varres'), ('describe_function', 'schemas', 'authorization'), ('describe_function', 'schemas', 'owner'), ('describe_function', 'schemas', 'system'), ('describe_table', '_tables', 'access'), ('describe_table', '_tables', 'commit_action'), ('describe_table', '_tables', 'system')));
delete from sys.dependencies where (id, depend_id) in (select c.id, v.id from sys._tables v, sys._tables t, sys._columns c, sys.dependencies d where c.table_id = t.id and v.id = d.depend_id and c.id = d.id and v.schema_id = 2000 and t.schema_id = 2000 and (v.name, t.name, c.name) in (values ('dependency_columns_on_indexes', '_columns', 'name'), ('dependency_columns_on_indexes', '_columns', 'number'), ('dependency_columns_on_indexes', '_columns', 'storage'), ('dependency_columns_on_indexes', '_columns', 'table_id'), ('dependency_columns_on_indexes', '_columns', 'type_digits'), ('dependency_columns_on_indexes', 'keys', 'id'), ('dependency_columns_on_indexes', 'triggers', 'name'), ('dependency_columns_on_indexes', 'triggers', 'orientation'), ('dependency_columns_on_indexes', 'triggers', 'table_id'), ('dependency_columns_on_indexes', 'triggers', 'time'), ('dependency_columns_on_keys', '_columns', 'name'), ('dependency_columns_on_keys', '_columns', 'table_id'), ('dependency_columns_on_keys', '_columns', 'type'), ('dependency_columns_on_keys', '_columns', 'type_digits'), ('dependency_columns_on_keys', '_columns', 'type_scale'), ('dependency_columns_on_keys', 'triggers', 'name'), ('dependency_columns_on_keys', 'triggers', 'orientation'), ('dependency_columns_on_keys', 'triggers', 'table_id'), ('dependency_columns_on_keys', 'triggers', 'time'), ('dependency_columns_on_triggers', 'keys', 'name'), ('dependency_columns_on_triggers', 'keys', 'rkey'), ('dependency_columns_on_triggers', 'keys', 'type'), ('dependency_functions_on_triggers', 'keys', 'action'), ('dependency_functions_on_triggers', 'keys', 'name'), ('dependency_functions_on_triggers', 'keys', 'rkey'), ('dependency_functions_on_triggers', 'keys', 'type'), ('dependency_keys_on_foreignkeys', '_columns', 'default'), ('dependency_keys_on_foreignkeys', '_columns', 'name'), ('dependency_keys_on_foreignkeys', '_columns', 'table_id'), ('dependency_keys_on_foreignkeys', '_columns', 'type'), ('dependency_keys_on_foreignkeys', '_columns', 'type_digits'), ('dependency_keys_on_foreignkeys', '_columns', 'type_scale'), ('dependency_tables_on_foreignkeys', '_columns', 'default'), ('dependency_tables_on_foreignkeys', '_columns', 'name'), ('dependency_tables_on_foreignkeys', '_columns', 'table_id'), ('dependency_tables_on_foreignkeys', '_columns', 'type'), ('dependency_tables_on_foreignkeys', '_columns', 'type_digits'), ('dependency_tables_on_foreignkeys', '_columns', 'type_scale'), ('dependency_tables_on_indexes', '_columns', 'name'), ('dependency_tables_on_indexes', '_columns', 'number'), ('dependency_tables_on_indexes', '_columns', 'storage'), ('dependency_tables_on_indexes', '_columns', 'table_id'), ('dependency_tables_on_indexes', '_columns', 'type_digits'), ('dependency_tables_on_indexes', 'keys', 'id'), ('dependency_tables_on_triggers', 'keys', 'action'), ('dependency_tables_on_triggers', 'keys', 'name'), ('dependency_tables_on_triggers', 'keys', 'rkey'), ('dependency_tables_on_triggers', 'keys', 'type')));

Running database upgrade commands:
update sys._columns set type_digits = 7 where type = 'tinyint' and type_digits <> 7;
update sys._columns set type_digits = 15 where type = 'smallint' and type_digits <> 15;
update sys._columns set type_digits = 31 where type = 'int' and type_digits <> 31;
update sys._columns set type_digits = 63 where type = 'bigint' and type_digits <> 63;
update sys._columns set type_digits = 127 where type = 'hugeint' and type_digits <> 127;
update sys._columns set type = 'varchar' where type in ('clob', 'char') and table_id in (select id from sys._tables where system and name <> 'netcdf_files');
update sys.args set type_digits = 7 where type = 'tinyint' and type_digits <> 7;
update sys.args set type_digits = 15 where type = 'smallint' and type_digits <> 15;
update sys.args set type_digits = 31 where type = 'int' and type_digits <> 31;
update sys.args set type_digits = 63 where type = 'bigint' and type_digits <> 63;
update sys.args set type_digits = 127 where type = 'hugeint' and type_digits <> 127;
update sys.args set type = 'varchar' where type in ('clob', 'char');
drop aggregate median(decimal);
drop aggregate median_avg(decimal);
drop aggregate quantile(decimal, double);
drop aggregate quantile_avg(decimal, double);
create aggregate median(val DECIMAL(2)) returns DECIMAL(2)
 external name "aggr"."median";
GRANT EXECUTE ON AGGREGATE median(DECIMAL(2)) TO PUBLIC;
create aggregate median(val DECIMAL(4)) returns DECIMAL(4)
 external name "aggr"."median";
GRANT EXECUTE ON AGGREGATE median(DECIMAL(4)) TO PUBLIC;
create aggregate median(val DECIMAL(9)) returns DECIMAL(9)
 external name "aggr"."median";
GRANT EXECUTE ON AGGREGATE median(DECIMAL(9)) TO PUBLIC;
create aggregate median(val DECIMAL(18)) returns DECIMAL(18)
 external name "aggr"."median";
GRANT EXECUTE ON AGGREGATE median(DECIMAL(18)) TO PUBLIC;
create aggregate median(val DECIMAL(38)) returns DECIMAL(38)
 external name "aggr"."median";
GRANT EXECUTE ON AGGREGATE median(DECIMAL(38)) TO PUBLIC;
create aggregate median_avg(val DECIMAL(2)) returns DOUBLE
 external name "aggr"."median_avg";
GRANT EXECUTE ON AGGREGATE median_avg(DECIMAL(2)) TO PUBLIC;
create aggregate median_avg(val DECIMAL(4)) returns DOUBLE
 external name "aggr"."median_avg";
GRANT EXECUTE ON AGGREGATE median_avg(DECIMAL(4)) TO PUBLIC;
create aggregate median_avg(val DECIMAL(9)) returns DOUBLE
 external name "aggr"."median_avg";
GRANT EXECUTE ON AGGREGATE median_avg(DECIMAL(9)) TO PUBLIC;
create aggregate median_avg(val DECIMAL(18)) returns DOUBLE
 external name "aggr"."median_avg";
GRANT EXECUTE ON AGGREGATE median_avg(DECIMAL(18)) TO PUBLIC;
create aggregate median_avg(val DECIMAL(38)) returns DOUBLE
 external name "aggr"."median_avg";
GRANT EXECUTE ON AGGREGATE median_avg(DECIMAL(38)) TO PUBLIC;
create aggregate quantile(val DECIMAL(2), q DOUBLE) returns DECIMAL(2)
 external name "aggr"."quantile";
GRANT EXECUTE ON AGGREGATE quantile(DECIMAL(2), DOUBLE) TO PUBLIC;
create aggregate quantile(val DECIMAL(4), q DOUBLE) returns DECIMAL(4)
 external name "aggr"."quantile";
GRANT EXECUTE ON AGGREGATE quantile(DECIMAL(4), DOUBLE) TO PUBLIC;
create aggregate quantile(val DECIMAL(9), q DOUBLE) returns DECIMAL(9)
 external name "aggr"."quantile";
GRANT EXECUTE ON AGGREGATE quantile(DECIMAL(9), DOUBLE) TO PUBLIC;
create aggregate quantile(val DECIMAL(18), q DOUBLE) returns DECIMAL(18)
 external name "aggr"."quantile";
GRANT EXECUTE ON AGGREGATE quantile(DECIMAL(18), DOUBLE) TO PUBLIC;
create aggregate quantile(val DECIMAL(38), q DOUBLE) returns DECIMAL(38)
 external name "aggr"."quantile";
GRANT EXECUTE ON AGGREGATE quantile(DECIMAL(38), DOUBLE) TO PUBLIC;
create aggregate quantile_avg(val DECIMAL(2), q DOUBLE) returns DOUBLE
 external name "aggr"."quantile_avg";
GRANT EXECUTE ON AGGREGATE quantile_avg(DECIMAL(2), DOUBLE) TO PUBLIC;
create aggregate quantile_avg(val DECIMAL(4), q DOUBLE) returns DOUBLE
 external name "aggr"."quantile_avg";
GRANT EXECUTE ON AGGREGATE quantile_avg(DECIMAL(4), DOUBLE) TO PUBLIC;
create aggregate quantile_avg(val DECIMAL(9), q DOUBLE) returns DOUBLE
 external name "aggr"."quantile_avg";
GRANT EXECUTE ON AGGREGATE quantile_avg(DECIMAL(9), DOUBLE) TO PUBLIC;
create aggregate quantile_avg(val DECIMAL(18), q DOUBLE) returns DOUBLE
 external name "aggr"."quantile_avg";
GRANT EXECUTE ON AGGREGATE quantile_avg(DECIMAL(18), DOUBLE) TO PUBLIC;
create aggregate quantile_avg(val DECIMAL(38), q DOUBLE) returns DOUBLE
 external name "aggr"."quantile_avg";
GRANT EXECUTE ON AGGREGATE quantile_avg(DECIMAL(38), DOUBLE) TO PUBLIC;
drop function if exists sys.time_to_str(time with time zone, string) cascade;
drop function if exists sys.timestamp_to_str(timestamp with time zone, string) cascade;
create function time_to_str(d time, format string) returns string
 external name mtime."time_to_str";
create function time_to_str(d time with time zone, format string) returns string
 external name mtime."timetz_to_str";
create function timestamp_to_str(d timestamp with time zone, format string) returns string
 external name mtime."timestamptz_to_str";
grant execute on function time_to_str(time, string) to public;
grant execute on function time_to_str(time with time zone, string) to public;
grant execute on function timestamp_to_str(timestamp with time zone, string) to public;
update sys.functions set system = true where not system and schema_id = 2000 and name in ('time_to_str', 'timestamp_to_str', 'median', 'median_avg', 'quantile', 'quantile_avg');
drop function if exists sys.dump_database(boolean) cascade;
drop view sys.dump_comments;
drop view sys.dump_tables;
drop view sys.dump_functions;
drop view sys.dump_function_grants;
drop function if exists sys.describe_columns(string, string) cascade;
drop view sys.describe_functions;
drop view sys.describe_privileges;
drop view sys.describe_comments;
drop view sys.fully_qualified_functions;
drop view sys.describe_tables;
drop function if exists sys.describe_type(string, integer, integer) cascade;
CREATE FUNCTION sys.describe_type(ctype string, digits integer, tscale integer)
 RETURNS string
BEGIN
 RETURN sys.sql_datatype(ctype, digits, tscale, false, false);
END;
CREATE VIEW sys.describe_tables AS
 SELECT
 t.id o,
 s.name sch,
 t.name tab,
 ts.table_type_name typ,
 (SELECT
 ' (' ||
 GROUP_CONCAT(
 sys.DQ(c.name) || ' ' ||
 sys.describe_type(c.type, c.type_digits, c.type_scale) ||
 ifthenelse(c."null" = 'false', ' NOT NULL', '')
 , ', ') || ')'
 FROM sys._columns c
 WHERE c.table_id = t.id) col,
 CASE ts.table_type_name
 WHEN 'REMOTE TABLE' THEN
 sys.get_remote_table_expressions(s.name, t.name)
 WHEN 'MERGE TABLE' THEN
 sys.get_merge_table_partition_expressions(t.id)
 WHEN 'VIEW' THEN
 sys.schema_guard(s.name, t.name, t.query)
 ELSE
 ''
 END opt
 FROM sys.schemas s, sys.table_types ts, sys.tables t
 WHERE ts.table_type_name IN ('TABLE', 'VIEW', 'MERGE TABLE', 'REMOTE TABLE', 'REPLICA TABLE', 'UNLOGGED TABLE')
 AND t.system = FALSE
 AND s.id = t.schema_id
 AND ts.table_type_id = t.type
 AND s.name <> 'tmp';
CREATE VIEW sys.fully_qualified_functions AS
 WITH fqn(id, tpe, sig, num) AS
 (
 SELECT
 f.id,
 ft.function_type_keyword,
 CASE WHEN a.type IS NULL THEN
 sys.fqn(s.name, f.name) || '()'
 ELSE
 sys.fqn(s.name, f.name) || '(' || group_concat(sys.describe_type(a.type, a.type_digits, a.type_scale), ',') OVER (PARTITION BY f.id ORDER BY a.number)  || ')'
 END,
 a.number
 FROM sys.schemas s, sys.function_types ft, sys.functions f LEFT JOIN sys.args a ON f.id = a.func_id
 WHERE s.id= f.schema_id AND f.type = ft.function_type_id
 )
 SELECT
 fqn1.id id,
 fqn1.tpe tpe,
 fqn1.sig nme
 FROM
 fqn fqn1 JOIN (SELECT id, max(num) FROM fqn GROUP BY id)  fqn2(id, num)
 ON fqn1.id = fqn2.id AND (fqn1.num = fqn2.num OR fqn1.num IS NULL AND fqn2.num is NULL);
CREATE VIEW sys.describe_comments AS
 SELECT o.id AS id, o.tpe AS tpe, o.nme AS fqn, cm.remark AS rem
 FROM (
 SELECT id, 'SCHEMA', sys.DQ(name) FROM sys.schemas WHERE NOT system
 UNION ALL
 SELECT t.id, ifthenelse(ts.table_type_name = 'VIEW', 'VIEW', 'TABLE'), sys.FQN(s.name, t.name)
 FROM sys.schemas s JOIN sys._tables t ON s.id = t.schema_id JOIN sys.table_types ts ON t.type = ts.table_type_id
 WHERE NOT t.system
 UNION ALL
 SELECT c.id, 'COLUMN', sys.FQN(s.name, t.name) || '.' || sys.DQ(c.name) FROM sys.columns c, sys._tables t, sys.schemas s WHERE NOT t.system AND c.table_id = t.id AND t.schema_id = s.id
 UNION ALL
 SELECT idx.id, 'INDEX', sys.FQN(s.name, idx.name) FROM sys.idxs idx, sys._tables t, sys.schemas s WHERE NOT t.system AND idx.table_id = t.id AND t.schema_id = s.id
 UNION ALL
 SELECT seq.id, 'SEQUENCE', sys.FQN(s.name, seq.name) FROM sys.sequences seq, sys.schemas s WHERE seq.schema_id = s.id
 UNION ALL
 SELECT f.id, ft.function_type_keyword, qf.nme FROM sys.functions f, sys.function_types ft, sys.schemas s, sys.fully_qualified_functions qf
 WHERE NOT f.system AND f.type = ft.function_type_id AND f.schema_id = s.id AND qf.id = f.id
 ) AS o(id, tpe, nme)
 JOIN sys.comments cm ON cm.id = o.id;
CREATE VIEW sys.describe_privileges AS
 SELECT
 CASE
 WHEN o.tpe IS NULL AND pc.privilege_code_name = 'SELECT' THEN --GLOBAL privileges: SELECT maps to COPY FROM
 'COPY FROM'
 WHEN o.tpe IS NULL AND pc.privilege_code_name = 'UPDATE' THEN --GLOBAL privileges: UPDATE maps to COPY INTO
 'COPY INTO'
 ELSE
 o.nme
 END o_nme,
 coalesce(o.tpe, 'GLOBAL') o_tpe,
 pc.privilege_code_name p_nme,
 a.name a_nme,
 g.name g_nme,
 p.grantable grantable
 FROM
 sys.privileges p LEFT JOIN
 (
 SELECT t.id, s.name || '.' || t.name , 'TABLE'
 from sys.schemas s, sys.tables t where s.id = t.schema_id
 UNION ALL
 SELECT c.id, s.name || '.' || t.name || '.' || c.name, 'COLUMN'
 FROM sys.schemas s, sys.tables t, sys.columns c where s.id = t.schema_id AND t.id = c.table_id
 UNION ALL
 SELECT f.id, f.nme, f.tpe
 FROM sys.fully_qualified_functions f
 ) o(id, nme, tpe) ON o.id = p.obj_id,
 sys.privilege_codes pc,
 auths a, auths g
 WHERE
 p.privileges = pc.privilege_code_id AND
 p.auth_id = a.id AND
 p.grantor = g.id;
CREATE VIEW sys.describe_functions AS
 WITH func_args_all(func_id, number, max_number, func_arg) AS
 (
 SELECT
 func_id,
 number,
 max(number) OVER (PARTITION BY func_id ORDER BY number DESC),
 group_concat(sys.dq(name) || ' ' || sys.describe_type(type, type_digits, type_scale),', ') OVER (PARTITION BY func_id ORDER BY number)
 FROM sys.args
 WHERE inout = 1
 ),
 func_args(func_id, func_arg) AS
 (
 SELECT func_id, func_arg
 FROM func_args_all
 WHERE number = max_number
 ),
 func_rets_all(func_id, number, max_number, func_ret, func_ret_type) AS
 (
 SELECT
 func_id,
 number,
 max(number) OVER (PARTITION BY func_id ORDER BY number DESC),
 group_concat(sys.dq(name) || ' ' || sys.describe_type(type, type_digits, type_scale),', ') OVER (PARTITION BY func_id ORDER BY number),
 group_concat(sys.describe_type(type, type_digits, type_scale),', ') OVER (PARTITION BY func_id ORDER BY number)
 FROM sys.args
 WHERE inout = 0
 ),
 func_rets(func_id, func_ret, func_ret_type) AS
 (
 SELECT
 func_id,
 func_ret,
 func_ret_type
 FROM func_rets_all
 WHERE number = max_number
 )
 SELECT
 f.id o,
 s.name sch,
 f.name fun,
 CASE WHEN f.language IN (1, 2) THEN f.func ELSE 'CREATE ' || ft.function_type_keyword || ' ' || sys.FQN(s.name, f.name) || '(' || coalesce(fa.func_arg, '') || ')' || CASE WHEN f.type = 5 THEN ' RETURNS TABLE (' || coalesce(fr.func_ret, '') || ')' WHEN f.type IN (1,3) THEN ' RETURNS ' || fr.func_ret_type ELSE '' END || CASE WHEN fl.language_keyword IS NULL THEN '' ELSE ' LANGUAGE ' || fl.language_keyword END || ' ' || f.func END def
 FROM sys.functions f
 LEFT OUTER JOIN func_args fa ON fa.func_id = f.id
 LEFT OUTER JOIN func_rets fr ON fr.func_id = f.id
 JOIN sys.schemas s ON f.schema_id = s.id
 JOIN sys.function_types ft ON f.type = ft.function_type_id
 LEFT OUTER JOIN sys.function_languages fl ON f.language = fl.language_id
 WHERE s.name <> 'tmp' AND NOT f.system;
CREATE FUNCTION sys.describe_columns(schemaName string, tableName string)
 RETURNS TABLE(name string, type string, digits integer, scale integer, Nulls boolean, cDefault string, number integer, sqltype string, remark string)
BEGIN
 RETURN SELECT c.name, c."type", c.type_digits, c.type_scale, c."null", c."default", c.number, sys.describe_type(c."type", c.type_digits, c.type_scale), com.remark
 FROM sys._tables t, sys.schemas s, sys._columns c
 LEFT OUTER JOIN sys.comments com ON c.id = com.id
 WHERE c.table_id = t.id
 AND t.name = tableName
 AND t.schema_id = s.id
 AND s.name = schemaName
 ORDER BY c.number;
END;
CREATE VIEW sys.dump_function_grants AS
 WITH func_args_all(func_id, number, max_number, func_arg) AS
 (SELECT a.func_id,
 a.number,
 max(a.number) OVER (PARTITION BY a.func_id ORDER BY a.number DESC),
 group_concat(sys.describe_type(a.type, a.type_digits, a.type_scale), ', ') OVER (PARTITION BY a.func_id ORDER BY a.number)
 FROM sys.args a
 WHERE a.inout = 1),
 func_args(func_id, func_arg) AS
 (SELECT func_id, func_arg FROM func_args_all WHERE number = max_number)
 SELECT
 'GRANT ' || pc.privilege_code_name || ' ON ' || ft.function_type_keyword || ' '
 || sys.FQN(s.name, f.name) || '(' || coalesce(fa.func_arg, '') || ') TO '
 || ifthenelse(a.name = 'public', 'PUBLIC', sys.dq(a.name))
 || CASE WHEN p.grantable = 1 THEN ' WITH GRANT OPTION' ELSE '' END || ';' stmt,
 s.name schema_name,
 f.name function_name,
 a.name grantee
 FROM sys.schemas s,
 sys.functions f LEFT OUTER JOIN func_args fa ON f.id = fa.func_id,
 sys.auths a,
 sys.privileges p,
 sys.auths g,
 sys.function_types ft,
 sys.privilege_codes pc
 WHERE s.id = f.schema_id
 AND f.id = p.obj_id
 AND p.auth_id = a.id
 AND p.grantor = g.id
 AND p.privileges = pc.privilege_code_id
 AND f.type = ft.function_type_id
 AND NOT f.system
 ORDER BY s.name, f.name, a.name, g.name, p.grantable;
CREATE VIEW sys.dump_functions AS
 SELECT f.o o, sys.schema_guard(f.sch, f.fun, f.def) stmt,
 f.sch schema_name,
 f.fun function_name
 FROM sys.describe_functions f;
CREATE VIEW sys.dump_tables AS
 SELECT
 t.o o,
 CASE
 WHEN t.typ <> 'VIEW' THEN
 'CREATE ' || t.typ || ' ' || sys.FQN(t.sch, t.tab) || t.col || t.opt || ';'
 ELSE
 t.opt
 END stmt,
 t.sch schema_name,
 t.tab table_name
 FROM sys.describe_tables t;
CREATE VIEW sys.dump_comments AS
 SELECT 'COMMENT ON ' || c.tpe || ' ' || c.fqn || ' IS ' || sys.SQ(c.rem) || ';' stmt FROM sys.describe_comments c;
CREATE FUNCTION sys.dump_database(describe BOOLEAN) RETURNS TABLE(o int, stmt STRING)
BEGIN
 SET SCHEMA sys;
 TRUNCATE sys.dump_statements;
 INSERT INTO sys.dump_statements VALUES (1, 'START TRANSACTION;');
 INSERT INTO sys.dump_statements VALUES (2, 'SET SCHEMA "sys";');
 INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_create_roles;
 INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_create_users;
 INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_create_schemas;
 INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_user_defined_types;
 INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_add_schemas_to_users;
 INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_grant_user_privileges;
 INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_sequences;

 --functions and table-likes can be interdependent. They should be inserted in the order of their catalogue id.
 INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(ORDER BY stmts.o), stmts.s
 FROM (
 SELECT f.o, f.stmt FROM sys.dump_functions f
 UNION ALL
 SELECT t.o, t.stmt FROM sys.dump_tables t
 ) AS stmts(o, s);

 -- dump table data before adding constraints and fixing sequences
 IF NOT DESCRIBE THEN
 CALL sys.dump_table_data();
 END IF;

 INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_start_sequences;
 INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_column_defaults;
 INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_table_constraint_type;
 INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_indices;
 INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_foreign_keys;
 INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_partition_tables;
 INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_triggers;
 INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_comments;
 INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_table_grants;
 INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_column_grants;
 INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_function_grants;

 --TODO Improve performance of dump_table_data.
 --TODO loaders, procedures, window and filter sys.functions.
 --TODO look into order dependent group_concat

 INSERT INTO sys.dump_statements VALUES ((SELECT COUNT(*) FROM sys.dump_statements) + 1, 'COMMIT;');

 RETURN sys.dump_statements;
END;
GRANT SELECT ON sys.describe_tables TO PUBLIC;
GRANT SELECT ON sys.describe_comments TO PUBLIC;
GRANT SELECT ON sys.fully_qualified_functions TO PUBLIC;
GRANT SELECT ON sys.describe_privileges TO PUBLIC;
GRANT SELECT ON sys.describe_functions TO PUBLIC;
update sys.functions set system = true where not system and schema_id = 2000 and name in ('dump_database', 'describe_columns', 'describe_type');
update sys._tables set system = true where not system and schema_id = 2000 and name in ('dump_comments', 'dump_tables', 'dump_functions', 'dump_function_grants', 'describe_functions', 'describe_privileges', 'describe_comments', 'fully_qualified_functions', 'describe_tables');

