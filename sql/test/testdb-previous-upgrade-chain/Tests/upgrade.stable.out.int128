Running database upgrade commands to update system tables.

Running database upgrade commands:
create function sys.generate_series(first hugeint, "limit" hugeint)
returns table (value hugeint)
external name generator.series;
create function sys.generate_series(first hugeint, "limit" hugeint, stepsize hugeint)
returns table (value hugeint)
external name generator.series;
create aggregate stddev_samp(val HUGEINT) returns DOUBLE
 external name "aggr"."stdev";
GRANT EXECUTE ON AGGREGATE stddev_samp(HUGEINT) TO PUBLIC;
create window stddev_samp(val HUGEINT) returns DOUBLE
 external name "sql"."stdev";
GRANT EXECUTE ON WINDOW stddev_samp(HUGEINT) TO PUBLIC;
create aggregate stddev_pop(val HUGEINT) returns DOUBLE
 external name "aggr"."stdevp";
GRANT EXECUTE ON AGGREGATE stddev_pop(HUGEINT) TO PUBLIC;
create window stddev_pop(val HUGEINT) returns DOUBLE
 external name "sql"."stdevp";
GRANT EXECUTE ON WINDOW stddev_pop(HUGEINT) TO PUBLIC;
create aggregate var_samp(val HUGEINT) returns DOUBLE
 external name "aggr"."variance";
GRANT EXECUTE ON AGGREGATE var_samp(HUGEINT) TO PUBLIC;
create window var_samp(val HUGEINT) returns DOUBLE
 external name "sql"."variance";
GRANT EXECUTE ON WINDOW var_samp(HUGEINT) TO PUBLIC;
create aggregate covar_samp(e1 HUGEINT, e2 HUGEINT) returns DOUBLE
 external name "aggr"."covariance";
GRANT EXECUTE ON AGGREGATE covar_samp(HUGEINT, HUGEINT) TO PUBLIC;
create window covar_samp(e1 HUGEINT, e2 HUGEINT) returns DOUBLE
 external name "sql"."covariance";
GRANT EXECUTE ON WINDOW covar_samp(HUGEINT, HUGEINT) TO PUBLIC;
create aggregate var_pop(val HUGEINT) returns DOUBLE
 external name "aggr"."variancep";
GRANT EXECUTE ON AGGREGATE var_pop(HUGEINT) TO PUBLIC;
create window var_pop(val HUGEINT) returns DOUBLE
 external name "sql"."variancep";
GRANT EXECUTE ON WINDOW var_pop(HUGEINT) TO PUBLIC;
create aggregate covar_pop(e1 HUGEINT, e2 HUGEINT) returns DOUBLE
 external name "aggr"."covariancep";
GRANT EXECUTE ON AGGREGATE covar_pop(HUGEINT, HUGEINT) TO PUBLIC;
create window covar_pop(e1 HUGEINT, e2 HUGEINT) returns DOUBLE
 external name "sql"."covariancep";
GRANT EXECUTE ON WINDOW covar_pop(HUGEINT, HUGEINT) TO PUBLIC;
create aggregate median(val HUGEINT) returns HUGEINT
 external name "aggr"."median";
GRANT EXECUTE ON AGGREGATE median(HUGEINT) TO PUBLIC;
create aggregate quantile(val HUGEINT, q DOUBLE) returns HUGEINT
 external name "aggr"."quantile";
GRANT EXECUTE ON AGGREGATE quantile(HUGEINT, DOUBLE) TO PUBLIC;
create aggregate median_avg(val HUGEINT) returns DOUBLE
 external name "aggr"."median_avg";
GRANT EXECUTE ON AGGREGATE median_avg(HUGEINT) TO PUBLIC;
create aggregate quantile_avg(val HUGEINT, q DOUBLE) returns DOUBLE
 external name "aggr"."quantile_avg";
GRANT EXECUTE ON AGGREGATE quantile_avg(HUGEINT, DOUBLE) TO PUBLIC;
create aggregate corr(e1 HUGEINT, e2 HUGEINT) returns DOUBLE
 external name "aggr"."corr";
GRANT EXECUTE ON AGGREGATE corr(HUGEINT, HUGEINT) TO PUBLIC;
create window corr(e1 HUGEINT, e2 HUGEINT) returns DOUBLE
 external name "sql"."corr";
GRANT EXECUTE ON WINDOW corr(HUGEINT, HUGEINT) TO PUBLIC;
create function json.filter(js json, name hugeint)
returns json external name json.filter;
GRANT EXECUTE ON FUNCTION json.filter(json, hugeint) TO PUBLIC;
update sys.functions set system = true where system <> true and name in ('generate_series') and schema_id = (select id from sys.schemas where name = 'sys') and type = 5;
update sys.functions set system = true where system <> true and name in ('stddev_samp', 'stddev_pop', 'var_samp', 'covar_samp', 'var_pop', 'covar_pop', 'median', 'median_avg', 'quantile', 'quantile_avg', 'corr') and schema_id = (select id from sys.schemas where name = 'sys') and type = 3;
update sys.functions set system = true where system <> true and name in ('stddev_samp', 'stddev_pop', 'var_samp', 'covar_samp', 'var_pop', 'covar_pop', 'corr') and schema_id = (select id from sys.schemas where name = 'sys') and type = 6;
update sys.functions set system = true where system <> true and name = 'filter' and schema_id = (select id from sys.schemas where name = 'json') and type = 1;

Running database upgrade commands:
drop procedure if exists wlc.master() cascade;
drop procedure if exists wlc.master(string) cascade;
drop procedure if exists wlc.stop() cascade;
drop procedure if exists wlc.flush() cascade;
drop procedure if exists wlc.beat(int) cascade;
drop function if exists wlc.clock() cascade;
drop function if exists wlc.tick() cascade;
drop procedure if exists wlr.master(string) cascade;
drop procedure if exists wlr.stop() cascade;
drop procedure if exists wlr.accept() cascade;
drop procedure if exists wlr.replicate() cascade;
drop procedure if exists wlr.replicate(timestamp) cascade;
drop procedure if exists wlr.replicate(tinyint) cascade;
drop procedure if exists wlr.replicate(smallint) cascade;
drop procedure if exists wlr.replicate(integer) cascade;
drop procedure if exists wlr.replicate(bigint) cascade;
drop procedure if exists wlr.beat(integer) cascade;
drop function if exists wlr.clock() cascade;
drop function if exists wlr.tick() cascade;
drop schema if exists wlc cascade;
drop schema if exists wlr cascade;

Running database upgrade commands:
create function sys.regexp_replace(ori string, pat string, rep string, flg string)
returns string external name pcre.replace;
grant execute on function regexp_replace(string, string, string, string) to public;
create function sys.regexp_replace(ori string, pat string, rep string)
returns string
begin
 return sys.regexp_replace(ori, pat, rep, '');
end;
grant execute on function regexp_replace(string, string, string) to public;
update sys.functions set system = true where system <> true and name = 'regexp_replace' and schema_id = 2000 and type = 1;

Running database upgrade commands:
drop function if exists sys.dump_database(boolean) cascade;
drop procedure if exists sys.dump_table_data() cascade;
drop procedure if exists sys.dump_table_data(string, string) cascade;
drop view if exists sys.dump_tables cascade;
drop view if exists sys.dump_comments cascade;
drop function if exists sys.prepare_esc(string, string) cascade;
drop view if exists sys.dump_partition_tables cascade;
drop view if exists sys.dump_create_users cascade;
drop view if exists sys.describe_tables cascade;
drop function if exists sys.get_remote_table_expressions(string, string) cascade;
drop function if exists sys.remote_table_credentials(string) cascade;
drop function if exists sys.sq(string) cascade;
create table sys.remote_user_info (table_id int, username varchar(1024), password varchar(256));
create function sys.decypher (cypher string) returns string external name sql.decypher;
update sys.functions set system = true where system <> true and name = 'decypher' and schema_id = 2000 and type = 1;
update sys._tables set system = true where system <> true and name = 'remote_user_info' and schema_id = 2000;
CREATE FUNCTION sys.SQ (s STRING) RETURNS STRING BEGIN RETURN '''' || sys.replace(s,'''','''''') || ''''; END;
CREATE FUNCTION sys.get_remote_table_expressions(s STRING, t STRING) RETURNS STRING BEGIN
 RETURN SELECT ' ON ' || sys.SQ(tt.query) || ' WITH USER ' || sys.SQ(username) || ' ENCRYPTED PASSWORD ' || sys.SQ(sys.decypher("password")) FROM sys.remote_user_info r, sys._tables tt, sys.schemas ss where tt.name = t and ss.name = s and tt.schema_id = ss.id and r.table_id = tt.id;
END;
CREATE VIEW sys.describe_tables AS
 SELECT
 t.id o,
 s.name sch,
 t.name tab,
 ts.table_type_name typ,
 (SELECT
 ' (' ||
 GROUP_CONCAT(
 sys.DQ(c.name) || ' ' ||
 sys.describe_type(c.type, c.type_digits, c.type_scale) ||
 ifthenelse(c."null" = 'false', ' NOT NULL', '')
 , ', ') || ')'
 FROM sys._columns c
 WHERE c.table_id = t.id) col,
 CASE ts.table_type_name
 WHEN 'REMOTE TABLE' THEN
 sys.get_remote_table_expressions(s.name, t.name)
 WHEN 'MERGE TABLE' THEN
 sys.get_merge_table_partition_expressions(t.id)
 WHEN 'VIEW' THEN
 sys.schema_guard(s.name, t.name, t.query)
 ELSE
 ''
 END opt
 FROM sys.schemas s, sys.table_types ts, sys.tables t
 WHERE ts.table_type_name IN ('TABLE', 'VIEW', 'MERGE TABLE', 'REMOTE TABLE', 'REPLICA TABLE', 'UNLOGGED TABLE')
 AND t.system = FALSE
 AND s.id = t.schema_id
 AND ts.table_type_id = t.type
 AND s.name <> 'tmp';
CREATE VIEW sys.dump_create_users AS
 SELECT
 'CREATE USER ' || sys.dq(ui.name) || ' WITH ENCRYPTED PASSWORD ' ||
 sys.sq(sys.password_hash(ui.name)) ||
 ' NAME ' || sys.sq(ui.fullname) || ' SCHEMA sys' || ifthenelse(ui.schema_path = '"sys"', '', ' SCHEMA PATH ' || sys.sq(ui.schema_path)) || ';' stmt,
 ui.name user_name
 FROM sys.db_user_info ui, sys.schemas s
 WHERE ui.default_schema = s.id
 AND ui.name <> 'monetdb'
 AND ui.name <> '.snapshot';
CREATE VIEW sys.dump_partition_tables AS
 SELECT
 'ALTER TABLE ' || sys.FQN(m_sch, m_tbl) || ' ADD TABLE ' || sys.FQN(p_sch, p_tbl) ||
 CASE
 WHEN tpe = 'VALUES' THEN ' AS PARTITION IN (' || pvalues || ')'
 WHEN tpe = 'RANGE' THEN ' AS PARTITION FROM ' || ifthenelse(minimum IS NOT NULL, sys.SQ(minimum), 'RANGE MINVALUE') || ' TO ' || ifthenelse(maximum IS NOT NULL, sys.SQ(maximum), 'RANGE MAXVALUE')
 WHEN tpe = 'FOR NULLS' THEN ' AS PARTITION FOR NULL VALUES'
 ELSE '' --'READ ONLY'
 END ||
 CASE WHEN tpe in ('VALUES', 'RANGE') AND with_nulls THEN ' WITH NULL VALUES' ELSE '' END ||
 ';' stmt,
 m_sch merge_schema_name,
 m_tbl merge_table_name,
 p_sch partition_schema_name,
 p_tbl partition_table_name
 FROM sys.describe_partition_tables;
CREATE VIEW sys.dump_tables AS
 SELECT
 t.o o,
 CASE
 WHEN t.typ <> 'VIEW' THEN
 'CREATE ' || t.typ || ' ' || sys.FQN(t.sch, t.tab) || t.col || t.opt || ';'
 ELSE
 t.opt
 END stmt,
 t.sch schema_name,
 t.tab table_name
 FROM sys.describe_tables t;
CREATE VIEW sys.dump_comments AS
 SELECT 'COMMENT ON ' || c.tpe || ' ' || c.fqn || ' IS ' || sys.SQ(c.rem) || ';' stmt FROM sys.describe_comments c;
CREATE FUNCTION sys.prepare_esc(s STRING, t STRING) RETURNS STRING
BEGIN
 RETURN
 CASE
 WHEN (t = 'varchar' OR t ='char' OR t = 'clob' OR t = 'json' OR t = 'geometry' OR t = 'url') THEN
 'CASE WHEN ' || sys.DQ(s) || ' IS NULL THEN ''null'' ELSE ' || 'sys.esc(' || sys.DQ(s) || ')' || ' END'
 ELSE
 'CASE WHEN ' || sys.DQ(s) || ' IS NULL THEN ''null'' ELSE CAST(' || sys.DQ(s) || ' AS STRING) END'
 END;
END;
CREATE PROCEDURE sys.dump_table_data(sch STRING, tbl STRING)
BEGIN
 DECLARE tid INT;
 SET tid = (SELECT MIN(t.id) FROM sys.tables t, sys.schemas s WHERE t.name = tbl AND t.schema_id = s.id AND s.name = sch);
 IF tid IS NOT NULL THEN
 DECLARE k INT;
 DECLARE m INT;
 SET k = (SELECT MIN(c.id) FROM sys.columns c WHERE c.table_id = tid);
 SET m = (SELECT MAX(c.id) FROM sys.columns c WHERE c.table_id = tid);
 IF k IS NOT NULL AND m IS NOT NULL THEN
 DECLARE cname STRING;
 DECLARE ctype STRING;
 DECLARE _cnt INT;
 SET cname = (SELECT c.name FROM sys.columns c WHERE c.id = k);
 SET ctype = (SELECT c.type FROM sys.columns c WHERE c.id = k);
 SET _cnt = (SELECT count FROM sys.storage(sch, tbl, cname));
 IF _cnt > 0 THEN
 DECLARE COPY_INTO_STMT STRING;
 DECLARE SELECT_DATA_STMT STRING;
 SET COPY_INTO_STMT = 'COPY ' || _cnt || ' RECORDS INTO ' || sys.FQN(sch, tbl) || '(' || sys.DQ(cname);
 SET SELECT_DATA_STMT = 'SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), ' || sys.prepare_esc(cname, ctype);
 WHILE (k < m) DO
 SET k = (SELECT MIN(c.id) FROM sys.columns c WHERE c.table_id = tid AND c.id > k);
 SET cname = (SELECT c.name FROM sys.columns c WHERE c.id = k);
 SET ctype = (SELECT c.type FROM sys.columns c WHERE c.id = k);
 SET COPY_INTO_STMT = (COPY_INTO_STMT || ', ' || sys.DQ(cname));
 SET SELECT_DATA_STMT = (SELECT_DATA_STMT || '|| ''|'' || ' || sys.prepare_esc(cname, ctype));
 END WHILE;
 SET COPY_INTO_STMT = (COPY_INTO_STMT || R') FROM STDIN USING DELIMITERS ''|'',E''\n'',''"'';');
 SET SELECT_DATA_STMT = (SELECT_DATA_STMT || ' FROM ' || sys.FQN(sch, tbl));
 INSERT INTO sys.dump_statements VALUES ((SELECT COUNT(*) FROM sys.dump_statements) + 1, COPY_INTO_STMT);
 CALL sys.EVAL('INSERT INTO sys.dump_statements ' || SELECT_DATA_STMT || ';');
 END IF;
 END IF;
 END IF;
 END;
CREATE PROCEDURE sys.dump_table_data()
BEGIN
 DECLARE i INT;
 SET i = (SELECT MIN(t.id) FROM sys.tables t, sys.table_types ts WHERE t.type = ts.table_type_id AND ts.table_type_name = 'TABLE' AND NOT t.system);
 IF i IS NOT NULL THEN
 DECLARE M INT;
 SET M = (SELECT MAX(t.id) FROM sys.tables t, sys.table_types ts WHERE t.type = ts.table_type_id AND ts.table_type_name = 'TABLE' AND NOT t.system);
 DECLARE sch STRING;
 DECLARE tbl STRING;
 WHILE i IS NOT NULL AND i <= M DO
 SET sch = (SELECT s.name FROM sys.tables t, sys.schemas s WHERE s.id = t.schema_id AND t.id = i);
 SET tbl = (SELECT t.name FROM sys.tables t, sys.schemas s WHERE s.id = t.schema_id AND t.id = i);
 CALL sys.dump_table_data(sch, tbl);
 SET i = (SELECT MIN(t.id) FROM sys.tables t, sys.table_types ts WHERE t.type = ts.table_type_id AND ts.table_type_name = 'TABLE' AND NOT t.system AND t.id > i);
 END WHILE;
 END IF;
END;
CREATE FUNCTION sys.dump_database(describe BOOLEAN) RETURNS TABLE(o int, stmt STRING)
BEGIN
 SET SCHEMA sys;
 TRUNCATE sys.dump_statements;
 INSERT INTO sys.dump_statements VALUES (1, 'START TRANSACTION;');
 INSERT INTO sys.dump_statements VALUES (2, 'SET SCHEMA "sys";');
 INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_create_roles;
 INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_create_users;
 INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_create_schemas;
 INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_user_defined_types;
 INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_add_schemas_to_users;
 INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_grant_user_privileges;
 INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_sequences;
 --functions and table-likes can be interdependent. They should be inserted in the order of their catalogue id.
 INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(ORDER BY stmts.o), stmts.s
 FROM (
 SELECT f.o, f.stmt FROM sys.dump_functions f
 UNION ALL
 SELECT t.o, t.stmt FROM sys.dump_tables t
 ) AS stmts(o, s);
 -- dump table data before adding constraints and fixing sequences
 IF NOT DESCRIBE THEN
 CALL sys.dump_table_data();
 END IF;
 INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_start_sequences;
 INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_column_defaults;
 INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_table_constraint_type;
 INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_indices;
 INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_foreign_keys;
 INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_partition_tables;
 INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_triggers;
 INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_comments;
 INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_table_grants;
 INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_column_grants;
 INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_function_grants;
 --TODO Improve performance of dump_table_data.
 --TODO loaders ,procedures, window and filter sys.functions.
 --TODO look into order dependent group_concat
 INSERT INTO sys.dump_statements VALUES ((SELECT COUNT(*) FROM sys.dump_statements) + 1, 'COMMIT;');
 RETURN sys.dump_statements;
END;
update sys.functions set system = true where system <> true and name in ('sq', 'get_remote_table_expressions', 'prepare_esc') and schema_id = 2000 and type = 1;
update sys._tables set system = true where system <> true and name in ('describe_tables', 'dump_create_users', 'dump_partition_tables', 'dump_comments', 'dump_tables') and schema_id = 2000;
update sys.functions set system = true where system <> true and name = 'dump_table_data' and schema_id = 2000 and type = 2;
update sys.functions set system = true where system <> true and name = 'dump_database' and schema_id = 2000 and type = 5;
GRANT SELECT ON sys.describe_tables TO PUBLIC;

Running database upgrade commands:
drop view if exists sys.dependency_tables_on_functions cascade;
drop view if exists sys.dependency_views_on_functions cascade;
CREATE VIEW sys.dependency_tables_on_functions AS
SELECT t.schema_id AS table_schema_id, t.id AS table_id, t.name AS table_name, f.id AS function_id, f.name AS function_name, f.type AS function_type, dep.depend_type AS depend_type
  FROM sys.functions AS f, sys.tables AS t, sys.dependencies AS dep
 WHERE t.id = dep.id AND f.id = dep.depend_id
   AND dep.depend_type = 7 AND f.type <> 2 AND t.type NOT IN (1, 11)
 ORDER BY t.name, t.schema_id, f.name, f.id;
GRANT SELECT ON sys.dependency_tables_on_functions TO PUBLIC;
CREATE VIEW sys.dependency_views_on_functions AS
SELECT v.schema_id AS view_schema_id, v.id AS view_id, v.name AS view_name, f.id AS function_id, f.name AS function_name, f.type AS function_type, dep.depend_type AS depend_type
  FROM sys.functions AS f, sys.tables AS v, sys.dependencies AS dep
 WHERE v.id = dep.id AND f.id = dep.depend_id
   AND dep.depend_type = 7 AND f.type <> 2 AND v.type IN (1, 11)
 ORDER BY v.name, v.schema_id, f.name, f.id;
GRANT SELECT ON sys.dependency_views_on_functions TO PUBLIC;
update sys._tables set system = true where system <> true and name in ('dependency_tables_on_functions','dependency_views_on_functions') and schema_id = 2000;

Running database upgrade commands:
create function sys.database ()
returns string
external name inspect."getDatabaseName";
grant execute on function sys.database() to public;
update sys.functions set system = true where system <> true and name = 'database' and schema_id = 2000 and type = 1;

Running database upgrade commands:
create function sys.queue(username string) returns table("tag" bigint, "sessionid" int, "username" string, "started" timestamp, "status" string, "query" string, "finished" timestamp, "maxworkers" int, "footprint" int) external name sysmon.queue;
create procedure sys.pause(tag bigint, username string) external name sysmon.pause;
create procedure sys.resume(tag bigint, username string) external name sysmon.resume;
create procedure sys.stop(tag bigint, username string) external name sysmon.stop;
update sys.functions set system = true where system <> true and mod = 'sysmon' and name in ('stop', 'pause', 'resume', 'queue');

Running database upgrade commands:
drop procedure sys.settimeout(bigint) cascade;
drop procedure sys.settimeout(bigint, bigint) cascade;
drop procedure sys.setsession(bigint) cascade;

Running database upgrade commands:
create function sys.levenshtein(x string, y string)
returns int external name txtsim.levenshtein;
grant execute on function levenshtein(string, string) to public;
create function sys.levenshtein(x string, y string, insdel int, rep int)
returns int external name txtsim.levenshtein;
grant execute on function levenshtein(string, string, int, int) to public;
create function sys.levenshtein(x string, y string, insdel int, rep int, trans int)
returns int external name txtsim.levenshtein;
grant execute on function levenshtein(string, string, int, int, int) to public;
create filter function sys.maxlevenshtein(x string, y string, k int)
external name txtsim.maxlevenshtein;
grant execute on filter function maxlevenshtein(string, string, int) to public;
create filter function sys.maxlevenshtein(x string, y string, k int, insdel int, rep int)
external name txtsim.maxlevenshtein;
grant execute on filter function maxlevenshtein(string, string, int, int, int) to public;
create function sys.jarowinkler(x string, y string)
returns double external name txtsim.jarowinkler;
grant execute on function jarowinkler(string, string) to public;
create filter function minjarowinkler(x string, y string, threshold double)
external name txtsim.minjarowinkler;
grant execute on filter function minjarowinkler(string, string, double) to public;
create function sys.dameraulevenshtein(x string, y string)
returns int external name txtsim.dameraulevenshtein;
grant execute on function dameraulevenshtein(string, string) to public;
create function sys.dameraulevenshtein(x string, y string, insdel int, rep int, trans int)
returns int external name txtsim.dameraulevenshtein;
grant execute on function dameraulevenshtein(string, string, int, int, int) to public;
create function sys.editdistance(x string, y string)
returns int external name txtsim.editdistance;
grant execute on function editdistance(string, string) to public;
create function sys.editdistance2(x string, y string)
returns int external name txtsim.editdistance2;
grant execute on function editdistance2(string, string) to public;
create function sys.soundex(x string)
returns string external name txtsim.soundex;
grant execute on function soundex(string) to public;
create function sys.difference(x string, y string)
returns int external name txtsim.stringdiff;
grant execute on function difference(string, string) to public;
create function sys.qgramnormalize(x string)
returns string external name txtsim.qgramnormalize;
grant execute on function qgramnormalize(string) to public;
create function asciify(x string)
returns string external name str.asciify;
grant execute on function asciify(string) to public;
create function sys.startswith(x string, y string)
returns boolean external name str.startswith;
grant execute on function startswith(string, string) to public;
create function sys.startswith(x string, y string, icase boolean)
returns boolean external name str.startswith;
grant execute on function startswith(string, string, boolean) to public;
create filter function sys.startswith(x string, y string)
external name str.startswith;
grant execute on filter function startswith(string, string) to public;
create filter function sys.startswith(x string, y string, icase boolean)
external name str.startswith;
grant execute on filter function startswith(string, string, boolean) to public;
create function sys.endswith(x string, y string)
returns boolean external name str.endswith;
grant execute on function endswith(string, string) to public;
create function sys.endswith(x string, y string, icase boolean)
returns boolean external name str.endswith;
grant execute on function endswith(string, string, boolean) to public;
create filter function sys.endswith(x string, y string)
external name str.endswith;
grant execute on filter function endswith(string, string) to public;
create filter function sys.endswith(x string, y string, icase boolean)
external name str.endswith;
grant execute on filter function endswith(string, string, boolean) to public;
create function sys.contains(x string, y string)
returns boolean external name str.contains;
grant execute on function contains(string, string) to public;
create function sys.contains(x string, y string, icase boolean)
returns boolean external name str.contains;
grant execute on function contains(string, string, boolean) to public;
create filter function sys.contains(x string, y string)
external name str.contains;
grant execute on filter function contains(string, string) to public;
create filter function sys.contains(x string, y string, icase boolean)
external name str.contains;
grant execute on filter function contains(string, string, boolean) to public;
update sys.functions set system = true where system <> true and name in ('levenshtein', 'dameraulevenshtein', 'jarowinkler', 'editdistance', 'editdistance2', 'soundex', 'difference', 'qgramnormalize') and schema_id = 2000 and type = 1;
update sys.functions set system = true where system <> true and name in ('maxlevenshtein', 'minjarowinkler') and schema_id = 2000 and type = 4;
update sys.functions set system = true where system <> true and name in ('asciify', 'startswith', 'endswith', 'contains') and schema_id = 2000 and type = 1;
update sys.functions set system = true where system <> true and name in ('startswith', 'endswith', 'contains') and schema_id = 2000 and type = 4;
delete from sys.triggers where name = 'system_update_tables' and table_id = 2067;

Running database upgrade commands:
drop procedure if exists SHPattach(string) cascade;
drop procedure if exists SHPload(integer) cascade;
drop procedure if exists SHPload(integer, geometry) cascade;

Running database upgrade commands:
create procedure SHPLoad(fname string, schemaname string, tablename string) external name shp.load;
create procedure SHPLoad(fname string, tablename string) external name shp.load;
update sys.functions set system = true where schema_id = 2000 and name in ('shpload');
Running database upgrade commands:
drop function if exists sys.st_intersects(geometry, geometry) cascade;
drop function if exists sys.st_dwithin(geometry, geometry, double) cascade;
drop view if exists sys.geometry_columns cascade;
drop function if exists sys.st_collect(geometry, geometry) cascade;
drop aggregate if exists sys.st_collect(geometry) cascade;
drop aggregate if exists sys.st_makeline(geometry) cascade;
create view sys.geometry_columns as
 select cast(null as varchar(1)) as f_table_catalog,
  s.name as f_table_schema,
  t.name as f_table_name,
  c.name as f_geometry_column,
  cast(has_z(c.type_digits) + has_m(c.type_digits) +2 as integer) as coord_dimension,
  c.type_scale as srid,
  get_type(c.type_digits, 0) as geometry_type
 from sys.columns c, sys.tables t, sys.schemas s
 where c.table_id = t.id and t.schema_id = s.id
  and c.type in (select sqlname from sys.types where systemname in ('wkb', 'wkba'));
GRANT SELECT ON sys.geometry_columns TO PUBLIC;
CREATE FUNCTION ST_Collect(geom1 Geometry, geom2 Geometry) RETURNS Geometry EXTERNAL NAME geom."Collect";
GRANT EXECUTE ON FUNCTION ST_Collect(Geometry, Geometry) TO PUBLIC;
CREATE AGGREGATE ST_Collect(geom Geometry) RETURNS Geometry external name aggr."Collect";
GRANT EXECUTE ON AGGREGATE ST_Collect(Geometry) TO PUBLIC;
CREATE FUNCTION ST_DistanceGeographic(geom1 Geometry, geom2 Geometry) RETURNS double EXTERNAL NAME geom."DistanceGeographic";
GRANT EXECUTE ON FUNCTION ST_DistanceGeographic(Geometry, Geometry) TO PUBLIC;
CREATE FILTER FUNCTION ST_DWithinGeographic(geom1 Geometry, geom2 Geometry, distance double) EXTERNAL NAME geom."DWithinGeographic";
GRANT EXECUTE ON FILTER ST_DWithinGeographic(Geometry, Geometry, double) TO PUBLIC;
CREATE FILTER FUNCTION ST_DWithin(geom1 Geometry, geom2 Geometry, distance double) EXTERNAL NAME rtree."DWithin";
GRANT EXECUTE ON FILTER ST_DWithin(Geometry, Geometry, double) TO PUBLIC;
CREATE FILTER FUNCTION ST_DWithin_NoIndex(geom1 Geometry, geom2 Geometry, distance double) EXTERNAL NAME geom."DWithin_noindex";
GRANT EXECUTE ON FILTER ST_DWithin_NoIndex(Geometry, Geometry, double) TO PUBLIC;
CREATE FUNCTION ST_DWithin2(geom1 Geometry, geom2 Geometry, bbox1 mbr, bbox2 mbr, dst double) RETURNS boolean EXTERNAL NAME geom."DWithin2";
GRANT EXECUTE ON FUNCTION ST_DWithin2(Geometry, Geometry, mbr, mbr, double) TO PUBLIC;
CREATE FILTER FUNCTION ST_IntersectsGeographic(geom1 Geometry, geom2 Geometry) EXTERNAL NAME geom."IntersectsGeographic";
GRANT EXECUTE ON FILTER ST_IntersectsGeographic(Geometry, Geometry) TO PUBLIC;
CREATE FILTER FUNCTION ST_Intersects(geom1 Geometry, geom2 Geometry) EXTERNAL NAME rtree."Intersects";
GRANT EXECUTE ON FILTER ST_Intersects(Geometry, Geometry) TO PUBLIC;
CREATE FILTER FUNCTION ST_Intersects_NoIndex(geom1 Geometry, geom2 Geometry) EXTERNAL NAME geom."Intersects_noindex";
GRANT EXECUTE ON FILTER ST_Intersects_NoIndex(Geometry, Geometry) TO PUBLIC;
CREATE AGGREGATE ST_MakeLine(geom Geometry) RETURNS Geometry external name aggr."MakeLine";
GRANT EXECUTE ON AGGREGATE ST_MakeLine(Geometry) TO PUBLIC;
update sys.functions set system = true where system <> true and schema_id = 2000 and name in ('st_collect', 'st_distancegeographic', 'st_dwithingeographic', 'st_dwithin', 'st_dwithin_noindex', 'st_dwithin2', 'st_intersectsgeographic', 'st_intersects', 'st_intersects_noindex', 'st_makeline');
update sys._tables set system = true where system <> true and schema_id = 2000 and name = 'geometry_columns';

Running database upgrade commands:
CREATE VIEW sys.describe_accessible_tables AS
 SELECT
 schemas.name AS schema,
 tables.name  AS table,
 tt.table_type_name AS table_type,
 pc.privilege_code_name AS privs,
 p.privileges AS privs_code
 FROM privileges p
 JOIN sys.roles ON p.auth_id = roles.id
 JOIN sys.tables ON p.obj_id = tables.id
 JOIN sys.table_types tt ON tables.type = tt.table_type_id
 JOIN sys.schemas ON tables.schema_id = schemas.id
 JOIN sys.privilege_codes pc ON p.privileges = pc.privilege_code_id
 WHERE roles.name = current_role;
GRANT SELECT ON sys.describe_accessible_tables TO PUBLIC;
update sys._tables set system = true where system <> true and schema_id = 2000 and name = 'describe_accessible_tables';
alter table sys.function_languages set read write;
delete from sys.function_languages where language_keyword like 'PYTHON%_MAP';
update sys.functions set language = language - 1 where language in (7, 11);
update sys.functions set mod = 'pyapi3' where mod in ('pyapi', 'pyapi3map');
commit;

Running database upgrade commands:
alter table sys.function_languages set read only;

Running database upgrade commands:
DROP FUNCTION IF EXISTS sys.dump_database(BOOLEAN) CASCADE;
DROP VIEW IF EXISTS sys.dump_comments CASCADE;
DROP VIEW IF EXISTS sys.describe_comments CASCADE;
CREATE VIEW sys.describe_comments AS
	SELECT o.id AS id, o.tpe AS tpe, o.nme AS fqn, cm.remark AS rem
	FROM (
		SELECT id, 'SCHEMA', sys.DQ(name) FROM sys.schemas WHERE NOT system
		UNION ALL
		SELECT t.id, ifthenelse(ts.table_type_name = 'VIEW', 'VIEW', 'TABLE'), sys.FQN(s.name, t.name)
		  FROM sys.schemas s JOIN sys._tables t ON s.id = t.schema_id JOIN sys.table_types ts ON t.type = ts.table_type_id
		 WHERE NOT t.system
		UNION ALL
		SELECT c.id, 'COLUMN', sys.FQN(s.name, t.name) || '.' || sys.DQ(c.name) FROM sys.columns c, sys._tables t, sys.schemas s WHERE NOT t.system AND c.table_id = t.id AND t.schema_id = s.id
		UNION ALL
		SELECT idx.id, 'INDEX', sys.FQN(s.name, idx.name) FROM sys.idxs idx, sys._tables t, sys.schemas s WHERE NOT t.system AND idx.table_id = t.id AND t.schema_id = s.id
		UNION ALL
		SELECT seq.id, 'SEQUENCE', sys.FQN(s.name, seq.name) FROM sys.sequences seq, sys.schemas s WHERE seq.schema_id = s.id
		UNION ALL
		SELECT f.id, ft.function_type_keyword, qf.nme FROM sys.functions f, sys.function_types ft, sys.schemas s, sys.fully_qualified_functions qf
		 WHERE NOT f.system AND f.type = ft.function_type_id AND f.schema_id = s.id AND qf.id = f.id
		) AS o(id, tpe, nme)
	JOIN sys.comments cm ON cm.id = o.id;
GRANT SELECT ON sys.describe_comments TO PUBLIC;
CREATE VIEW sys.dump_comments AS
  SELECT 'COMMENT ON ' || c.tpe || ' ' || c.fqn || ' IS ' || sys.SQ(c.rem) || ';' stmt FROM sys.describe_comments c;
CREATE FUNCTION sys.dump_database(describe BOOLEAN) RETURNS TABLE(o int, stmt STRING)
BEGIN
  SET SCHEMA sys;
  TRUNCATE sys.dump_statements;
  INSERT INTO sys.dump_statements VALUES (1, 'START TRANSACTION;');
  INSERT INTO sys.dump_statements VALUES (2, 'SET SCHEMA "sys";');
  INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_create_roles;
  INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_create_users;
  INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_create_schemas;
  INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_user_defined_types;
  INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_add_schemas_to_users;
  INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_grant_user_privileges;
  INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_sequences;
  --functions and table-likes can be interdependent. They should be inserted in the order of their catalogue id.
  INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(ORDER BY stmts.o), stmts.s
				    FROM (
				      SELECT f.o, f.stmt FROM sys.dump_functions f
				       UNION ALL
				      SELECT t.o, t.stmt FROM sys.dump_tables t
				    ) AS stmts(o, s);
  IF NOT DESCRIBE THEN
    CALL sys.dump_table_data();
  END IF;
  INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_start_sequences;
  INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_column_defaults;
  INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_table_constraint_type;
  INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_indices;
  INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_foreign_keys;
  INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_partition_tables;
  INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_triggers;
  INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_comments;
  INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_table_grants;
  INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_column_grants;
  INSERT INTO sys.dump_statements SELECT (SELECT COUNT(*) FROM sys.dump_statements) + RANK() OVER(), stmt FROM sys.dump_function_grants;
  INSERT INTO sys.dump_statements VALUES ((SELECT COUNT(*) FROM sys.dump_statements) + 1, 'COMMIT;');
  RETURN sys.dump_statements;
END;
update sys._tables set system = true where schema_id = 2000 and name in ('describe_comments','dump_comments');
update sys.functions set system = true where system <> true and schema_id = 2000 and name = 'dump_database' and type = 5;

Running database upgrade commands:
CREATE SCHEMA INFORMATION_SCHEMA;
COMMENT ON SCHEMA INFORMATION_SCHEMA IS 'ISO/IEC 9075-11 SQL/Schemata';
update sys.schemas set system = true where name = 'information_schema';
CREATE VIEW INFORMATION_SCHEMA.CHARACTER_SETS AS SELECT
  cast(NULL AS varchar(1)) AS CHARACTER_SET_CATALOG,
  cast(NULL AS varchar(1)) AS CHARACTER_SET_SCHEMA,
  cast('UTF-8' AS varchar(16)) AS CHARACTER_SET_NAME,
  cast('ISO/IEC 10646:2021' AS varchar(20)) AS CHARACTER_REPERTOIRE,
  cast('UTF-8' AS varchar(16)) AS FORM_OF_USE,
  cast(NULL AS varchar(1)) AS DEFAULT_COLLATE_CATALOG,
  cast(NULL AS varchar(1)) AS DEFAULT_COLLATE_SCHEMA,
  cast(NULL AS varchar(1)) AS DEFAULT_COLLATE_NAME;
GRANT SELECT ON TABLE INFORMATION_SCHEMA.CHARACTER_SETS TO PUBLIC WITH GRANT OPTION;
CREATE VIEW INFORMATION_SCHEMA.SCHEMATA AS SELECT
  cast(NULL AS varchar(1)) AS CATALOG_NAME,
  s."name" AS SCHEMA_NAME,
  a."name" AS SCHEMA_OWNER,
  cast(NULL AS varchar(1)) AS DEFAULT_CHARACTER_SET_CATALOG,
  cast(NULL AS varchar(1)) AS DEFAULT_CHARACTER_SET_SCHEMA,
  cast('UTF-8' AS varchar(16)) AS DEFAULT_CHARACTER_SET_NAME,
  cast(NULL AS varchar(1)) AS SQL_PATH,
  -- MonetDB column extensions
  s."id" AS schema_id,
  s."system" AS is_system,
  cm."remark" AS comments
 FROM sys."schemas" s
 INNER JOIN sys."auths" a ON s."owner" = a."id"
 LEFT OUTER JOIN sys."comments" cm ON s."id" = cm."id"
 ORDER BY s."name";
GRANT SELECT ON TABLE INFORMATION_SCHEMA.SCHEMATA TO PUBLIC WITH GRANT OPTION;
CREATE VIEW INFORMATION_SCHEMA.TABLES AS SELECT
  cast(NULL AS varchar(1)) AS TABLE_CATALOG,
  s."name" AS TABLE_SCHEMA,
  t."name" AS TABLE_NAME,
  tt."table_type_name" AS TABLE_TYPE,
  cast(NULL AS varchar(1)) AS SELF_REFERENCING_COLUMN_NAME,
  cast(NULL AS varchar(1)) AS REFERENCE_GENERATION,
  cast(NULL AS varchar(1)) AS USER_DEFINED_TYPE_CATALOG,
  cast(NULL AS varchar(1)) AS USER_DEFINED_TYPE_SCHEMA,
  cast(NULL AS varchar(1)) AS USER_DEFINED_TYPE_NAME,
  cast(sys.ifthenelse((t."type" IN (0, 3, 7, 20, 30) AND t."access" IN (0, 2)), 'YES', 'NO') AS varchar(3)) AS IS_INSERTABLE_INTO,
  cast('NO' AS varchar(3)) AS IS_TYPED,
  cast((CASE t."commit_action" WHEN 1 THEN 'DELETE' WHEN 2 THEN 'PRESERVE' WHEN 3 THEN 'DROP' ELSE NULL END) AS varchar(10)) AS COMMIT_ACTION,
  -- MonetDB column extensions
  t."schema_id" AS schema_id,
  t."id" AS table_id,
  t."type" AS table_type_id,
  st."count" AS row_count,
  t."system" AS is_system,
  sys.ifthenelse(t."type" IN (1, 11), TRUE, FALSE) AS is_view,
  t."query" AS query_def,
  cm."remark" AS comments
 FROM sys."tables" t
 INNER JOIN sys."schemas" s ON t."schema_id" = s."id"
 INNER JOIN sys."table_types" tt ON t."type" = tt."table_type_id"
 LEFT OUTER JOIN sys."comments" cm ON t."id" = cm."id"
 LEFT OUTER JOIN (SELECT DISTINCT "schema", "table", "count" FROM sys."statistics"()) st ON (s."name" = st."schema" AND t."name" = st."table")
 ORDER BY s."name", t."name";
GRANT SELECT ON TABLE INFORMATION_SCHEMA.TABLES TO PUBLIC WITH GRANT OPTION;
CREATE VIEW INFORMATION_SCHEMA.VIEWS AS SELECT
  cast(NULL AS varchar(1)) AS TABLE_CATALOG,
  s."name" AS TABLE_SCHEMA,
  t."name" AS TABLE_NAME,
  t."query" AS VIEW_DEFINITION,
  cast('NONE' AS varchar(10)) AS CHECK_OPTION,
  cast('NO' AS varchar(3)) AS IS_UPDATABLE,
  cast('NO' AS varchar(3)) AS INSERTABLE_INTO,
  cast('NO' AS varchar(3)) AS IS_TRIGGER_UPDATABLE,
  cast('NO' AS varchar(3)) AS IS_TRIGGER_DELETABLE,
  cast('NO' AS varchar(3)) AS IS_TRIGGER_INSERTABLE_INTO,
  -- MonetDB column extensions
  t."schema_id" AS schema_id,
  t."id" AS table_id,
  cast(sys.ifthenelse(t."system", t."type" + 10 , t."type") AS smallint) AS table_type_id,
  t."system" AS is_system,
  cm."remark" AS comments
 FROM sys."_tables" t
 INNER JOIN sys."schemas" s ON t."schema_id" = s."id"
 LEFT OUTER JOIN sys."comments" cm ON t."id" = cm."id"
 WHERE t."type" = 1
 ORDER BY s."name", t."name";
GRANT SELECT ON TABLE INFORMATION_SCHEMA.VIEWS TO PUBLIC WITH GRANT OPTION;
CREATE VIEW INFORMATION_SCHEMA.COLUMNS AS SELECT
  cast(NULL AS varchar(1)) AS TABLE_CATALOG,
  s."name" AS TABLE_SCHEMA,
  t."name" AS TABLE_NAME,
  c."name" AS COLUMN_NAME,
  cast(1 + c."number" AS int) AS ORDINAL_POSITION,
  c."default" AS COLUMN_DEFAULT,
  cast(sys.ifthenelse(c."null", 'YES', 'NO') AS varchar(3)) AS IS_NULLABLE,
  cast(sys."describe_type"(c."type", c."type_digits", c."type_scale") AS varchar(1024)) AS DATA_TYPE,
  cast(sys.ifthenelse(c."type" IN ('varchar','clob','char','json','url','xml') AND c."type_digits" > 0, c."type_digits", NULL) AS int) AS CHARACTER_MAXIMUM_LENGTH,
  cast(sys.ifthenelse(c."type" IN ('varchar','clob','char','json','url','xml') AND c."type_digits" > 0, c."type_digits" * 4, NULL) AS int) AS CHARACTER_OCTET_LENGTH,
  cast(sys.ifthenelse(c."type" IN ('int','smallint','tinyint','bigint','hugeint','float','real','double','decimal','numeric','oid'), c."type_digits", NULL) AS int) AS NUMERIC_PRECISION,
  cast(sys.ifthenelse(c."type" IN ('int','smallint','tinyint','bigint','hugeint','float','real','double','oid'), 2, sys.ifthenelse(c."type" IN ('decimal','numeric'), 10, NULL)) AS int) AS NUMERIC_PRECISION_RADIX,
  cast(sys.ifthenelse(c."type" IN ('int','smallint','tinyint','bigint','hugeint','float','real','double','decimal','numeric','oid'), c."type_scale", NULL) AS int) AS NUMERIC_SCALE,
  cast(sys.ifthenelse(c."type" IN ('date','timestamp','timestamptz','time','timetz'), c."type_scale" -1, NULL) AS int) AS DATETIME_PRECISION,
  cast(CASE c."type" WHEN 'day_interval' THEN 'interval day' WHEN 'month_interval' THEN (CASE c."type_digits" WHEN 1 THEN 'interval year' WHEN 2 THEN 'interval year to month' WHEN 3 THEN 'interval month' ELSE NULL END) WHEN 'sec_interval' THEN (CASE c."type_digits" WHEN 5 THEN 'interval day to hour' WHEN 6 THEN 'interval day to minute' WHEN 7 THEN 'interval day to second' WHEN 8 THEN 'interval hour' WHEN 9 THEN 'interval hour to minute' WHEN 10 THEN 'interval hour to second' WHEN 11 THEN 'interval minute' WHEN 12 THEN 'interval minute to second' WHEN 13 THEN 'interval second' ELSE NULL END) ELSE NULL END AS varchar(40)) AS INTERVAL_TYPE,
  cast(CASE c."type" WHEN 'day_interval' THEN 0 WHEN 'month_interval' THEN 0 WHEN 'sec_interval' THEN (sys.ifthenelse(c."type_digits" IN (7, 10, 12, 13), sys.ifthenelse(c."type_scale" > 0, c."type_scale", 3), 0)) ELSE NULL END AS int) AS INTERVAL_PRECISION,
  cast(NULL AS varchar(1)) AS CHARACTER_SET_CATALOG,
  cast(NULL AS varchar(1)) AS CHARACTER_SET_SCHEMA,
  cast(sys.ifthenelse(c."type" IN ('varchar','clob','char','json','url','xml'), 'UTF-8', NULL) AS varchar(16)) AS CHARACTER_SET_NAME,
  cast(NULL AS varchar(1)) AS COLLATION_CATALOG,
  cast(NULL AS varchar(1)) AS COLLATION_SCHEMA,
  cast(NULL AS varchar(1)) AS COLLATION_NAME,
  cast(NULL AS varchar(1)) AS DOMAIN_CATALOG,
  cast(NULL AS varchar(1)) AS DOMAIN_SCHEMA,
  cast(NULL AS varchar(1)) AS DOMAIN_NAME,
  cast(NULL AS varchar(1)) AS UDT_CATALOG,
  cast(NULL AS varchar(1)) AS UDT_SCHEMA,
  cast(NULL AS varchar(1)) AS UDT_NAME,
  cast(NULL AS varchar(1)) AS SCOPE_CATALOG,
  cast(NULL AS varchar(1)) AS SCOPE_SCHEMA,
  cast(NULL AS varchar(1)) AS SCOPE_NAME,
  cast(NULL AS int) AS MAXIMUM_CARDINALITY,
  cast(NULL AS varchar(1)) AS DTD_IDENTIFIER,
  cast('NO' AS varchar(3)) AS IS_SELF_REFERENCING,
  cast(CASE WHEN c."default" LIKE 'next value for %' THEN 'YES' ELSE 'NO' END AS varchar(3)) AS IS_IDENTITY,
  cast(NULL AS varchar(10)) AS IDENTITY_GENERATION,
  cast(NULL AS int) AS IDENTITY_START,
  cast(NULL AS int) AS IDENTITY_INCREMENT,
  cast(NULL AS int) AS IDENTITY_MAXIMUM,
  cast(NULL AS int) AS IDENTITY_MINIMUM,
  cast(NULL AS varchar(3)) AS IDENTITY_CYCLE,
  cast('NO' AS varchar(3)) AS IS_GENERATED,
  cast(NULL AS varchar(1)) AS GENERATION_EXPRESSION,
  cast('NO' AS varchar(3)) AS IS_SYSTEM_TIME_PERIOD_START,
  cast('NO' AS varchar(3)) AS IS_SYSTEM_TIME_PERIOD_END,
  cast('NO' AS varchar(3)) AS SYSTEM_TIME_PERIOD_TIMESTAMP_GENERATION,
  cast(sys.ifthenelse(t."type" IN (0,3,7,20,30), 'YES', 'NO') AS varchar(3)) AS IS_UPDATABLE,
  cast(NULL AS varchar(1)) AS DECLARED_DATA_TYPE,
  cast(NULL AS int) AS DECLARED_NUMERIC_PRECISION,
  cast(NULL AS int) AS DECLARED_NUMERIC_SCALE,
  -- MonetDB column extensions
  t."schema_id" AS schema_id,
  c."table_id" AS table_id,
  c."id" AS column_id,
  t."system" AS is_system,
  cm."remark" AS comments
 FROM sys."columns" c
 INNER JOIN sys."tables" t ON c."table_id" = t."id"
 INNER JOIN sys."schemas" s ON t."schema_id" = s."id"
 LEFT OUTER JOIN sys."comments" cm ON c."id" = cm."id"
 ORDER BY s."name", t."name", c."number";
GRANT SELECT ON TABLE INFORMATION_SCHEMA.COLUMNS TO PUBLIC WITH GRANT OPTION;
CREATE VIEW INFORMATION_SCHEMA.CHECK_CONSTRAINTS AS SELECT
  cast(NULL AS varchar(1)) AS CONSTRAINT_CATALOG,
  cast(NULL AS varchar(1024)) AS CONSTRAINT_SCHEMA,
  cast(NULL AS varchar(1024)) AS CONSTRAINT_NAME,
  cast(NULL AS varchar(1024)) AS CHECK_CLAUSE
 WHERE 1=0;
GRANT SELECT ON TABLE INFORMATION_SCHEMA.CHECK_CONSTRAINTS TO PUBLIC WITH GRANT OPTION;
CREATE VIEW INFORMATION_SCHEMA.TABLE_CONSTRAINTS AS SELECT
  cast(NULL AS varchar(1)) AS CONSTRAINT_CATALOG,
  s."name" AS CONSTRAINT_SCHEMA,
  k."name" AS CONSTRAINT_NAME,
  cast(NULL AS varchar(1)) AS TABLE_CATALOG,
  s."name" AS TABLE_SCHEMA,
  t."name" AS TABLE_NAME,
  cast(CASE k."type" WHEN 0 THEN 'PRIMARY KEY' WHEN 1 THEN 'UNIQUE' WHEN 2 THEN 'FOREIGN KEY' ELSE NULL END AS varchar(16)) AS CONSTRAINT_TYPE,
  cast('NO' AS varchar(3)) AS IS_DEFERRABLE,
  cast('NO' AS varchar(3)) AS INITIALLY_DEFERRED,
  cast('YES' AS varchar(3)) AS ENFORCED,
  -- MonetDB column extensions
  t."schema_id" AS schema_id,
  t."id" AS table_id,
  k."id" AS key_id,
  k."type" AS key_type,
  t."system" AS is_system
 FROM (SELECT sk."id", sk."table_id", sk."name", sk."type" FROM sys."keys" sk UNION ALL SELECT tk."id", tk."table_id", tk."name", tk."type" FROM tmp."keys" tk) k
 INNER JOIN (SELECT st."id", st."schema_id", st."name", st."system" FROM sys."_tables" st UNION ALL SELECT tt."id", tt."schema_id", tt."name", tt."system" FROM tmp."_tables" tt) t ON k."table_id" = t."id"
 INNER JOIN sys."schemas" s ON t."schema_id" = s."id"
 ORDER BY s."name", t."name", k."name";
GRANT SELECT ON TABLE INFORMATION_SCHEMA.TABLE_CONSTRAINTS TO PUBLIC WITH GRANT OPTION;
CREATE VIEW INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS AS SELECT
  cast(NULL AS varchar(1)) AS CONSTRAINT_CATALOG,
  s."name" AS CONSTRAINT_SCHEMA,
  fk."name" AS CONSTRAINT_NAME,
  cast(NULL AS varchar(1)) AS UNIQUE_CONSTRAINT_CATALOG,
  uks."name" AS UNIQUE_CONSTRAINT_SCHEMA,
  uk."name" AS UNIQUE_CONSTRAINT_NAME,
  cast('FULL' AS varchar(7)) AS MATCH_OPTION,
  fk."update_action" AS UPDATE_RULE,
  fk."delete_action" AS DELETE_RULE,
  -- MonetDB column extensions
  t."schema_id" AS fk_schema_id,
  t."id" AS fk_table_id,
  t."name" AS fk_table_name,
  fk."id" AS fk_key_id,
  ukt."schema_id" AS uc_schema_id,
  uk."table_id" AS uc_table_id,
  ukt."name" AS uc_table_name,
  uk."id" AS uc_key_id
 FROM sys."fkeys" fk
 INNER JOIN sys."tables" t ON t."id" = fk."table_id"
 INNER JOIN sys."schemas" s ON s."id" = t."schema_id"
 LEFT OUTER JOIN sys."keys" uk ON uk."id" = fk."rkey"
 LEFT OUTER JOIN sys."tables" ukt ON ukt."id" = uk."table_id"
 LEFT OUTER JOIN sys."schemas" uks ON uks."id" = ukt."schema_id"
 ORDER BY s."name", t."name", fk."name";
GRANT SELECT ON TABLE INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS TO PUBLIC WITH GRANT OPTION;
CREATE VIEW INFORMATION_SCHEMA.ROUTINES AS SELECT
  cast(NULL AS varchar(1)) AS SPECIFIC_CATALOG,
  s."name" AS SPECIFIC_SCHEMA,
  cast(f."id" as varchar(10)) AS SPECIFIC_NAME,
  cast(NULL AS varchar(1)) AS ROUTINE_CATALOG,
  s."name" AS ROUTINE_SCHEMA,
  f."name" AS ROUTINE_NAME,
  ft."function_type_keyword" AS ROUTINE_TYPE,
  cast(NULL AS varchar(1)) AS MODULE_CATALOG,
  cast(NULL AS varchar(1)) AS MODULE_SCHEMA,
  cast(f."mod" AS varchar(128)) AS MODULE_NAME,
  cast(NULL AS varchar(1)) AS UDT_CATALOG,
  cast(NULL AS varchar(1)) AS UDT_SCHEMA,
  cast(NULL AS varchar(1)) AS UDT_NAME,
  cast(CASE f."type" WHEN 1 THEN sys."describe_type"(a."type", a."type_digits", a."type_scale") WHEN 2 THEN NULL WHEN 5 THEN 'TABLE' WHEN 7 THEN 'TABLE' ELSE NULL END AS varchar(1024)) AS DATA_TYPE,
  cast(sys.ifthenelse(a."type" IN ('varchar','clob','char','json','url','xml') AND a."type_digits" > 0, a."type_digits", NULL) AS int) AS CHARACTER_MAXIMUM_LENGTH,
  cast(sys.ifthenelse(a."type" IN ('varchar','clob','char','json','url','xml') AND a."type_digits" > 0, a."type_digits" * 4, NULL) AS int) AS CHARACTER_OCTET_LENGTH,
  cast(NULL AS varchar(1)) AS CHARACTER_SET_CATALOG,
  cast(NULL AS varchar(1)) AS CHARACTER_SET_SCHEMA,
  'UTF-8' AS CHARACTER_SET_NAME,
  cast(NULL AS varchar(1)) AS COLLATION_CATALOG,
  cast(NULL AS varchar(1)) AS COLLATION_SCHEMA,
  cast(NULL AS varchar(1)) AS COLLATION_NAME,
  cast(sys.ifthenelse(a."type" IN ('int','smallint','tinyint','bigint','hugeint','float','real','double','decimal','numeric','oid'), a."type_digits", NULL) AS int) AS NUMERIC_PRECISION,
  cast(sys.ifthenelse(a."type" IN ('int','smallint','tinyint','bigint','hugeint','float','real','double','oid'), 2, sys.ifthenelse(a."type" IN ('decimal','numeric'), 10, NULL)) AS int) AS NUMERIC_PRECISION_RADIX,
  cast(sys.ifthenelse(a."type" IN ('int','smallint','tinyint','bigint','hugeint','float','real','double','decimal','numeric','oid'), a."type_scale", NULL) AS int) AS NUMERIC_SCALE,
  cast(sys.ifthenelse(a."type" IN ('date','timestamp','timestamptz','time','timetz'), a."type_scale" -1, NULL) AS int) AS DATETIME_PRECISION,
  cast(sys.ifthenelse(a."type" IN ('day_interval','month_interval','sec_interval'), sys."describe_type"(a."type", a."type_digits", a."type_scale"), NULL) AS varchar(40)) AS INTERVAL_TYPE,
  cast(CASE a."type" WHEN 'day_interval' THEN 0 WHEN 'month_interval' THEN 0 WHEN 'sec_interval' THEN (sys.ifthenelse(a."type_digits" IN (7, 10, 12, 13), sys.ifthenelse(a."type_scale" > 0, a."type_scale", 3), 0)) ELSE NULL END AS int) AS INTERVAL_PRECISION,
  cast(NULL AS varchar(1)) AS TYPE_UDT_CATALOG,
  cast(NULL AS varchar(1)) AS TYPE_UDT_SCHEMA,
  cast(NULL AS varchar(1)) AS TYPE_UDT_NAME,
  cast(NULL AS varchar(1)) AS SCOPE_CATALOG,
  cast(NULL AS varchar(1)) AS SCOPE_SCHEMA,
  cast(NULL AS varchar(1)) AS SCOPE_NAME,
  cast(NULL AS int) AS MAXIMUM_CARDINALITY,
  cast(NULL AS int) AS DTD_IDENTIFIER,
  cast(sys."ifthenelse"(sys."locate"('begin',f."func") > 0, sys."ifthenelse"(sys."endswith"(f."func",';'), sys."substring"(f."func", sys."locate"('begin',f."func"), sys."length"(sys."substring"(f."func", sys."locate"('begin',f."func")))-1), sys."substring"(f."func", sys."locate"('begin',f."func"))), NULL) AS varchar(8196)) AS ROUTINE_BODY,
  f."func" AS ROUTINE_DEFINITION,
  cast(sys."ifthenelse"(sys."locate"('external name',f."func") > 0, sys."ifthenelse"(sys."endswith"(f."func",';'), sys."substring"(f."func", 14 + sys."locate"('external name',f."func"), sys."length"(sys."substring"(f."func", 14 + sys."locate"('external name',f."func")))-1), sys."substring"(f."func", 14 + sys."locate"('external name',f."func"))), NULL) AS varchar(1024)) AS EXTERNAL_NAME,
  fl."language_keyword" AS EXTERNAL_LANGUAGE,
  'GENERAL' AS PARAMETER_STYLE,
  'YES' AS IS_DETERMINISTIC,
  cast(sys.ifthenelse(f."side_effect", 'MODIFIES', 'READ') AS varchar(10)) AS SQL_DATA_ACCESS,
  cast(CASE f."type" WHEN 2 THEN NULL ELSE 'NO' END AS varchar(3)) AS IS_NULL_CALL,
  cast(NULL AS varchar(1)) AS SQL_PATH,
  cast(NULL AS varchar(1)) AS SCHEMA_LEVEL_ROUTINE,
  cast(NULL AS int) AS MAX_DYNAMIC_RESULT_SETS,
  cast(NULL AS varchar(1)) AS IS_USER_DEFINED_CAST,
  cast(NULL AS varchar(1)) AS IS_IMPLICITLY_INVOCABLE,
  cast(NULL AS varchar(1)) AS SECURITY_TYPE,
  cast(NULL AS varchar(1)) AS TO_SQL_SPECIFIC_CATALOG,
  cast(NULL AS varchar(1)) AS TO_SQL_SPECIFIC_SCHEMA,
  cast(NULL AS varchar(1)) AS TO_SQL_SPECIFIC_NAME,
  cast(NULL AS varchar(1)) AS AS_LOCATOR,
  cast(NULL AS timestamp) AS CREATED,
  cast(NULL AS timestamp) AS LAST_ALTERED,
  cast(NULL AS varchar(1)) AS NEW_SAVEPOINT_LEVEL,
  cast(NULL AS varchar(1)) AS IS_UDT_DEPENDENT,
  cast(NULL AS varchar(1)) AS RESULT_CAST_FROM_DATA_TYPE,
  cast(NULL AS varchar(1)) AS RESULT_CAST_AS_LOCATOR,
  cast(NULL AS int) AS RESULT_CAST_CHAR_MAX_LENGTH,
  cast(NULL AS int) AS RESULT_CAST_CHAR_OCTET_LENGTH,
  cast(NULL AS varchar(1)) AS RESULT_CAST_CHAR_SET_CATALOG,
  cast(NULL AS varchar(1)) AS RESULT_CAST_CHAR_SET_SCHEMA,
  cast(NULL AS varchar(1)) AS RESULT_CAST_CHARACTER_SET_NAME,
  cast(NULL AS varchar(1)) AS RESULT_CAST_COLLATION_CATALOG,
  cast(NULL AS varchar(1)) AS RESULT_CAST_COLLATION_SCHEMA,
  cast(NULL AS varchar(1)) AS RESULT_CAST_COLLATION_NAME,
  cast(NULL AS int) AS RESULT_CAST_NUMERIC_PRECISION,
  cast(NULL AS int) AS RESULT_CAST_NUMERIC_RADIX,
  cast(NULL AS int) AS RESULT_CAST_NUMERIC_SCALE,
  cast(NULL AS int) AS RESULT_CAST_DATETIME_PRECISION,
  cast(NULL AS varchar(1)) AS RESULT_CAST_INTERVAL_TYPE,
  cast(NULL AS int) AS RESULT_CAST_INTERVAL_PRECISION,
  cast(NULL AS varchar(1)) AS RESULT_CAST_TYPE_UDT_CATALOG,
  cast(NULL AS varchar(1)) AS RESULT_CAST_TYPE_UDT_SCHEMA,
  cast(NULL AS varchar(1)) AS RESULT_CAST_TYPE_UDT_NAME,
  cast(NULL AS varchar(1)) AS RESULT_CAST_SCOPE_CATALOG,
  cast(NULL AS varchar(1)) AS RESULT_CAST_SCOPE_SCHEMA,
  cast(NULL AS varchar(1)) AS RESULT_CAST_SCOPE_NAME,
  cast(NULL AS int) AS RESULT_CAST_MAX_CARDINALITY,
  cast(NULL AS varchar(1)) AS RESULT_CAST_DTD_IDENTIFIER,
  cast(NULL AS varchar(1)) AS DECLARED_DATA_TYPE,
  cast(NULL AS int) AS DECLARED_NUMERIC_PRECISION,
  cast(NULL AS int) AS DECLARED_NUMERIC_SCALE,
  cast(NULL AS varchar(1)) AS RESULT_CAST_FROM_DECLARED_DATA_TYPE,
  cast(NULL AS int) AS RESULT_CAST_DECLARED_NUMERIC_PRECISION,
  cast(NULL AS int) AS RESULT_CAST_DECLARED_NUMERIC_SCALE,
  -- MonetDB column extensions
  f."schema_id" AS schema_id,
  f."id" AS function_id,
  f."type" AS function_type,
  f."language" AS function_language,
  f."system" AS is_system,
  cm."remark" AS comments
 FROM sys."functions" f
 INNER JOIN sys."schemas" s ON s."id" = f."schema_id"
 INNER JOIN sys."function_types" ft ON ft."function_type_id" = f."type"
 INNER JOIN sys."function_languages" fl ON fl."language_id" = f."language"
 LEFT OUTER JOIN sys."args" a ON a."func_id" = f."id" and a."inout" = 0 and a."number" = 0
 LEFT OUTER JOIN sys."comments" cm ON cm."id" = f."id"
 WHERE f."type" in (1, 2, 5, 7)
 ORDER BY s."name", f."name";
GRANT SELECT ON TABLE INFORMATION_SCHEMA.ROUTINES TO PUBLIC WITH GRANT OPTION;
CREATE VIEW INFORMATION_SCHEMA.SEQUENCES AS SELECT
  cast(NULL AS varchar(1)) AS SEQUENCE_CATALOG,
  s."name" AS SEQUENCE_SCHEMA,
  sq."name" AS SEQUENCE_NAME,
  cast('BIGINT' AS varchar(16)) AS DATA_TYPE,
  cast(64 AS SMALLINT) AS NUMERIC_PRECISION,
  cast(2 AS SMALLINT) AS NUMERIC_PRECISION_RADIX,
  cast(0 AS SMALLINT) AS NUMERIC_SCALE,
  sq."start" AS START_VALUE,
  sq."minvalue" AS MINIMUM_VALUE,
  sq."maxvalue" AS MAXIMUM_VALUE,
  sq."increment" AS INCREMENT,
  cast(sys.ifthenelse(sq."cycle", 'YES', 'NO') AS varchar(3)) AS CYCLE_OPTION,
  cast(NULL AS varchar(16)) AS DECLARED_DATA_TYPE,
  cast(NULL AS SMALLINT) AS DECLARED_NUMERIC_PRECISION,
  cast(NULL AS SMALLINT) AS DECLARED_NUMERIC_SCALE,
  -- MonetDB column extensions
  sq."schema_id" AS schema_id,
  sq."id" AS sequence_id,
  get_value_for(s."name", sq."name") AS current_value,
  sq."cacheinc" AS cacheinc,
  cm."remark" AS comments
 FROM sys."sequences" sq
 INNER JOIN sys."schemas" s ON sq."schema_id" = s."id"
 LEFT OUTER JOIN sys."comments" cm ON sq."id" = cm."id"
 ORDER BY s."name", sq."name";
GRANT SELECT ON TABLE INFORMATION_SCHEMA.SEQUENCES TO PUBLIC WITH GRANT OPTION;

update sys._tables set system = true where system <> true
 and schema_id = (select s.id from sys.schemas s where s.name = 'information_schema')
 and name in ('character_sets','check_constraints','columns','routines','schemata','sequences','referential_constraints','table_constraints','tables','views');

Running database upgrade commands:
CREATE FUNCTION sys.persist_unlogged()
RETURNS TABLE("table" STRING, "table_id" INT, "rowcount" BIGINT)
EXTERNAL NAME sql.persist_unlogged;
CREATE FUNCTION sys.persist_unlogged(sname STRING)
RETURNS TABLE("table" STRING, "table_id" INT, "rowcount" BIGINT)
EXTERNAL NAME sql.persist_unlogged;
CREATE FUNCTION sys.persist_unlogged(sname STRING, tname STRING)
RETURNS TABLE("table" STRING, "table_id" INT, "rowcount" BIGINT)
EXTERNAL NAME sql.persist_unlogged;
GRANT EXECUTE ON FUNCTION sys.persist_unlogged() TO PUBLIC;
GRANT EXECUTE ON FUNCTION sys.persist_unlogged(string) TO PUBLIC;
GRANT EXECUTE ON FUNCTION sys.persist_unlogged(string, string) TO PUBLIC;
UPDATE sys.functions SET system = true WHERE system <> true AND
name = 'persist_unlogged' AND schema_id = 2000;

Running database upgrade commands:
CREATE FUNCTION timestamp_to_str(d TIMESTAMP, format STRING) RETURNS STRING EXTERNAL NAME mtime."timestamp_to_str";
GRANT EXECUTE ON FUNCTION timestamp_to_str(TIMESTAMP, STRING) TO PUBLIC;
UPDATE sys.functions SET system = true WHERE system <> true AND name = 'timestamp_to_str' AND schema_id = 2000 and type = 1;

