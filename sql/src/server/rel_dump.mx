@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f rel_dump
@a N.J. Nes
@* 

@h
#ifndef _REL_DUMP_H_
#define _REL_DUMP_H_

#include "rel_semantic.h"

extern void rel_print(mvc *sql, sql_rel *rel, int depth);

#endif /*_REL_DUMP_H_*/
@c
#define LINESIZE 80

#include "rel_dump.h"

static void
print_indent( mvc *sql, int depth)
{
	char buf[LINESIZE+1];
	int i;

	(void)sql;
	depth *= 4; /* tab stop 4 */
	if (depth > LINESIZE)
		depth = LINESIZE;
	for(i=0; i<depth; i++){
		buf[i] = ' ';
	}
	buf[i] = 0;
	printf("\n%s", buf);
}

static void
cmp_print(mvc *sql, int cmp) 
{
	char *r;

	(void)sql;
	switch(cmp) {
	case cmp_gt: 		r = ">"; break;
	case cmp_gte: 		r = ">="; break;
	case cmp_lte: 		r = "<="; break;
	case cmp_lt: 		r = "<"; break;
	case cmp_equal: 	r = "="; break;
	case cmp_notequal: 	r = "!="; break;
	case cmp_notlike: 	r = "notlike"; break;
	case cmp_like: 		r = "like"; break;
	case cmp_all: 		r = "all"; break;
	default:
		r = "";
	}
	printf(" %s ", r);
}

static void exps_print(mvc *sql, list *exps, int depth, int alias);

static void
exp_print(mvc *sql, sql_exp *e, int depth, int comma, int alias) 
{
	(void)sql;
	if (!e)
		return;
	switch(e->type) {
	case e_exp: 
		exp_print(sql, e->l, depth, 0, 0);
		printf(", ");
		exp_print(sql, e->r, depth, 0, 0);
	 	break;
	case e_atom: {
		if (e->l) {
			atom *a = e->l;
			char *s = atom2string(a);
			if (a->tpe->type->localtype == TYPE_str)
				printf("'%s'", s);
			else
				printf("%s", s);
			_DELETE(s);
		} else {
			printf("A%d", e->flag);
		}
	} 	break;
	case e_func: {
		sql_subfunc *f = e->f;
		printf("'%s' ", f->func->base.name );
		exps_print( sql, e->l, depth, alias);
	} 	break;
	case e_aggr: {
		sql_subaggr *a = e->f;
		printf("'%s' ", a->aggr->base.name );
		if (e->flag)
			printf("unique ");
		exps_print( sql, e->l, depth, alias);
	} 	break;
	case e_relation: 
		rel_print(sql, e->l, depth);
	 	break;
	case e_column: 
		if (e->l)
			printf("%s.", (char*)e->l);
		printf("%s", (char*)e->r);
	 	break;
	case e_cmp: 
		exp_print(sql, e->l, depth+1, 0, 0);
		cmp_print(sql, e->flag );
		exp_print(sql, e->r, depth+1, 0, 0);
	 	break;
	default:
		;
	}
	if (e->name && alias)
		printf(" as %s", e->name);
	if (comma)
		printf(", ");
}

static void
exps_print(mvc *sql, list *exps, int depth, int alias) 
{
	node *en;

	if (!exps)
		return;

	printf(" [ ");
	for( en = exps->h; en; en = en->next ) 
		exp_print(sql, en->data, depth+1, (en->next!=NULL), alias);
	printf(" ]");
}

void
rel_print(mvc *sql, sql_rel *rel, int depth) 
{
	char *r = NULL;

	if (!rel)
		return;
	switch (rel->op) {
	case op_basetable:
		if (rel->name) {
			sql_table *t = rel->l;
			print_indent(sql, depth);
			printf("table(%s.%s) as %s", 
				t->s->base.name,
				t->base.name,
				rel->name);
		}
		break;
	case op_join: 
	case op_left: 
	case op_right: 
	case op_full: 
	case op_union: 
	case op_inter: 
	case op_except: 
		r = "join";
		if (rel->op == op_left)
			r = "left outer join";
		if (rel->op == op_right)
			r = "right outer join";
		if (rel->op == op_full)
			r = "full outer join";
		else if (rel->op == op_union)
			r = "union";
		else if (rel->op == op_inter)
			r = "intersect";
		else if (rel->op == op_except)
			r = "except";
		else if (!rel->exps && rel->op == op_join)
			r = "crossproduct";
		print_indent(sql, depth);
		printf("%s (", r);
		rel_print(sql, rel->l, depth+1);
		printf(",");
		rel_print(sql, rel->r, depth+1);
		print_indent(sql, depth);
		printf(")");
		exps_print(sql, rel->exps, depth, 0);
		break;
	case op_project:
	case op_select: 
	case op_groupby: 
	case op_orderby: 
	case op_topn: 
		r = "project";
		if (rel->op == op_project && rel->r)
			r = "distinct";
		if (rel->op == op_select)
			r = "select";
		if (rel->op == op_groupby)
			r = "group by";
		if (rel->op == op_orderby)
			r = "order by";
		if (rel->op == op_topn)
			r = "top N";
		if (rel->l) {
			print_indent(sql, depth);
			printf("%s (", r);
			rel_print(sql, rel->l, depth+1);
			print_indent(sql, depth);
			printf(")");
		}
		exps_print(sql, rel->exps, depth, 1);
		if (rel->r && rel->op == op_groupby) { /* group by aggrs */
			exps_print(sql, rel->r, depth, 1);
		}
		if (rel->name)
			printf(" as %s", rel->name);
		break;
	default:
		printf("todo: print %d\n", rel->op);
	}
}
