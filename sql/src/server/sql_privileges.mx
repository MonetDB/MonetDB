@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at 
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2002 CWI.  
@' All Rights Reserved.
@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold <Stefan.Manegold@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>

@f sql_privileges
@a N.J. Nes
@* Privileges

Sql has a simple access control schema. There are two types of authorization,
users and roles. Each user may be part of several roles.
For each authorization identity a set of privileges is administrated.
These are administrated on multiple levels where lower levels (ie.
table or column level) overwrite privileges on higher levels.

@h
#ifndef _SQL_PRIV_H_
#define _SQL_PRIV_H_

/* privileges */
#include <sql_mvc.h>

#define PRIV_SELECT 1
#define PRIV_UPDATE 2
#define PRIV_INSERT 4
#define PRIV_DELETE 8
#define PRIV_EXECUTE 16
#define PRIV_GRANT 32

extern int table_privs( mvc *m, sql_table *t, int privs );

extern int sql_privilege( mvc *m, int auth_id, int obj_id, int privs, int sub );
extern int sql_grantable( mvc *m, int grantorid, int obj_id, int privs, int sub );
extern int sql_find_auth( mvc *m, str auth );
extern int sql_find_schema( mvc *m, str schema );

sql_export int sql_create_role(mvc *m,  str auth, int grantor ) ;
sql_export int sql_drop_role( mvc *m, str auth );
sql_export int sql_grant_role( mvc *m, str grantee, str auth );
sql_export int sql_revoke_role( mvc *m, str grantee, str auth );
sql_export int sql_create_user( mvc *m, str user, str passwd,str  fullname, str schema_name,int grantor );
sql_export int sql_drop_user(mvc *m,  str user);

#endif /*_SQL_PRIV_H_ */
@c
#include <gdk.h>
/*#include <monet_context.h>*/
#include "sql_privileges.h"
#include "sql_bm.h"
/*#include <algebra.h>*/

/** broken !!, need to use the sys_* versions from mvc */
static BAT *desc(char *bname)
{
	BAT *res = NULL;
	bat bid = BBPindex(bname);
	if (bid){
		res = BATdescriptor(bid);
	}
	assert(res);
	return res;
}

static INLINE
ptr bun_find(BAT *b, ptr v){
	BUN p = BUNfnd(b,v);
	if (p)
		return BUNtail(b,p);
	return NULL;
}

@-
The remainder has been taken over from the sql_server mil document.
The code below provides abstractions to manage the priviliges.
@= accessRight
	p = BUNfnd(BATmirror(auth_name), @1);
	if(!p) return FALSE;
@= accessId
	@1 = bun_find(BATmirror(auth_name),@2);
@c
int sql_create_role(mvc *m,  str auth, int grantor ) 
{ BAT *auth_id, *auth_name, *auth_grantor;
  int zero = 0;
  oid onil =oid_nil;
  ptr p;
	auth_id = mvc_bind( m, "sys", "auths", "id", 1); 
	auth_name = mvc_bind( m, "sys", "auths", "name", 1);
	auth_grantor = mvc_bind( m, "sys", "auths", "grantor", 1);
	
	p = BUNfnd(BATmirror(auth_name), auth);
	if (p){
		return FALSE;
	}
	if (BATcount(auth_id) > 0) {
		int ma = 0;
		/*BATmax(auth_id,&ma);*/
		ma++;
		BUNins(auth_id, &onil, &ma);
	} else {
		BUNins(auth_id, &onil, &zero);
	}
	BUNins(auth_name, &onil, auth);
	BUNins(auth_grantor, &onil, &grantor);
	bat_destroy(auth_id);
	bat_destroy(auth_name);
	bat_destroy(auth_grantor);
	return TRUE;
} 

int sql_drop_role( mvc *m, str auth )
{ BAT *auth_id, *auth_name, *auth_grantor, *D_auth;
  ptr id, p;
  oid onil =oid_nil;
	auth_id = mvc_bind( m, "sys", "auths", "id", 1);
	auth_name = mvc_bind( m, "sys", "auths", "name", 1);
	auth_grantor = mvc_bind( m, "sys", "auths", "grantor", 1);
	D_auth = mvc_bind_dbat( m, "sys", "auths", 1);
	
	@:accessRight(auth)@
	@:accessId(id,auth)@
	BUNins(auth_id,&id, &int_nil);
	BUNins(auth_name,&id, &str_nil);
	BUNins(auth_grantor,&id, &int_nil);
	BUNins(D_auth,&onil,id);

	bat_destroy(auth_id);
	bat_destroy(auth_name);
	bat_destroy(auth_grantor);
	bat_destroy(D_auth);
	return TRUE;
} 

int sql_grant_role( mvc *m, str grantee, str auth )
{ BAT *auth_ids, *auth_name, *login_id, *role_id;
  ptr auth_id, grantee_id, p;
  oid onil = oid_nil;
	auth_ids = mvc_bind( m, "sys", "auths", "id", 1);
	auth_name = mvc_bind( m, "sys", "auths", "id", 1);
	login_id = mvc_bind( m, "sys", "user_role", "login_id", 1);
	role_id = mvc_bind( m, "sys", "user_role", "role_id", 1);

	@:accessRight(grantee)@
	@:accessRight(auth)@

	@:accessId(auth_id,auth)@
	@:accessId(grantee_id,grantee)@
	
	BUNins(login_id, &onil,grantee_id);
	BUNins(role_id, &onil,auth_id);

	bat_destroy(auth_ids);
	bat_destroy(auth_name);
	bat_destroy(login_id);
	bat_destroy(role_id);
	return TRUE;
} 

int sql_revoke_role( mvc *m, str grantee, str auth ) 
/* grantee no longer belongs the role (auth) */ 
{ BAT *auth_ids, *auth_name, *login_id, *role_id, *D_user_role;
  BAT *role, *logins;
  ptr id, auth_id, grantee_id, p;
  oid onil =oid_nil;
	auth_ids = mvc_bind( m, "sys", "auths", "id", 1);
	auth_name = mvc_bind( m, "sys", "auths", "id", 1);
	login_id = mvc_bind( m, "sys", "user_role", "login_id", 1);
	role_id = mvc_bind( m, "sys", "user_role", "role_id", 1);
	D_user_role = mvc_bind_dbat( m, "sys", "user_role", 1);

	@:accessRight(grantee)@
	@:accessRight(auth)@

	@:accessId(auth_id,auth)@
	@:accessId(grantee_id,grantee)@
	
	role = BATselect(role_id, &auth_id, &auth_id);

	logins = BATsemijoin(login_id,role);
	p = BUNfnd(BATmirror(logins), grantee_id);
	if (!p)
		return FALSE;
	id = bun_find(BATmirror(logins),grantee_id);
	BUNreplace(login_id,id,&int_nil);
	BUNreplace(role_id,id,&int_nil);
	BUNins(D_user_role, &onil,id);
	bat_destroy(auth_ids);
	bat_destroy(auth_name);
	bat_destroy(logins);
	bat_destroy(login_id);
	bat_destroy(role_id);
	bat_destroy(D_user_role);
	return TRUE;
} 

int sql_find_auth( mvc *m, str auth )
{
	int res = -1;
	BAT *auth_name = mvc_bind( m, "sys", "auths", "name", 0);
	BAT *auth_id = mvc_bind( m, "sys", "auths", "id", 0);
	BUN p = BUNfnd(BATmirror(auth_name), auth);
	
	if (p){
		oid id = *(oid*)BUNhead(auth_name, p);
		res = *(int*)BUNtail(auth_id, BUNfnd(auth_id, &id));
	}

	bat_destroy(auth_name);
	bat_destroy(auth_id);
	return res;
}

int sql_find_schema( mvc *m, str schema )
{
	BAT *schema_ids = mvc_bind( m, "sys", "schemas", "id", 1);
	BAT *schema_names = mvc_bind( m, "sys", "schemas", "name", 1);
	BUN p;
	int schema_id = -1;

	p = BUNfnd(BATmirror(schema_names), schema);
	if (p) {
		oid id = *(oid*)BUNhead(schema_names, p);
		schema_id = *(int*)BUNtail(schema_ids, BUNfnd(schema_ids, &id));
	}
	
	bat_destroy(schema_ids);
	bat_destroy(schema_names);
	return schema_id;
}

int sql_create_user( mvc *m, str user, str passwd, str fullname, str schema_name,int grantor )
{ 
	BAT *user_name, *user_passwd, *user_fullname, *user_dschema;
  	BAT *schema_ids, *schema_names;
  	ptr schema_id;
  	oid onil =oid_nil;
	if (!(sql_create_role( m, user, grantor )))
		return FALSE; 

	user_name = mvc_bind( m, "sys", "users", "name", 1);
	user_passwd = mvc_bind( m, "sys", "users", "passwd", 1);
	user_fullname = mvc_bind( m, "sys", "users", "fullname", 1);
	user_dschema = mvc_bind( m, "sys", "users", "default_schema", 1);

	schema_ids = mvc_bind( m, "sys", "schemas", "id", 1);
	schema_names = mvc_bind( m, "sys", "schemas", "name", 1);

	schema_id = bun_find(schema_ids, bun_find(BATmirror(schema_names),schema_name));

	BUNins(user_name, &onil, user);
	BUNins(user_passwd, &onil, passwd);
	BUNins(user_fullname, &onil, fullname);
	BUNins(user_dschema, &onil, schema_id);

	bat_destroy(user_name);
	bat_destroy(user_passwd);
	bat_destroy(user_fullname);
	bat_destroy(user_dschema);
	bat_destroy(schema_ids);
	bat_destroy(schema_names);
	return TRUE;
} 

int sql_drop_user(mvc *m,  str user) 
{ BAT *user_name, *user_passwd, *user_fullname, *user_dschema, *D_user;
  ptr id, p;
  oid onil = oid_nil;
	user_name = mvc_bind( m, "sys", "users", "name", 1);
	user_passwd = mvc_bind( m, "sys", "users", "passwd", 1);
	user_fullname = mvc_bind( m, "sys", "users", "fullname", 1);
	user_dschema = mvc_bind( m, "sys", "users", "default_schema", 1);
	D_user = mvc_bind_dbat( m, "sys", "users", 1);

	p = BUNfnd(BATmirror(user_name), user);
	if (!p)
		return FALSE;
	sql_drop_role( m, user );

	id = bun_find(BATmirror(user_name),user);
	BUNreplace(user_name, id, &str_nil);
	BUNreplace(user_passwd,id, &str_nil);
	BUNreplace(user_fullname,id,&str_nil);
	BUNreplace(user_dschema,id,&int_nil);
	BUNins(D_user, &onil,id);
	bat_destroy(user_name);
	bat_destroy(user_passwd);
	bat_destroy(user_fullname);
	bat_destroy(user_dschema);
	bat_destroy(D_user);
	return TRUE;
}

int sql_privilege_( mvc *m, int auth_id, int obj_id, int priv, int sub )
{
 	BAT *priv_obj = mvc_bind( m, "sys", "privileges", "obj_id", 1);
 	BAT *priv_auth = mvc_bind( m, "sys", "privileges", "auth_id", 1);
 	BAT *priv_priv = mvc_bind( m, "sys", "privileges", "privileges", 1);
 	BAT *priv_hier = mvc_bind( m, "sys", "privileges", "hierarchy", 1);
	int res = 0;
	
	BAT *b1,*b2 = BATselect(priv_obj, &obj_id, &obj_id );

	b1 = BATsemijoin(priv_auth, b2);
	bat_destroy(b2);
	b2 = BATselect( b1, &auth_id, &auth_id );
	bat_destroy(b1);
	b1 = BATsemijoin(priv_priv, b2);
	bat_destroy(b2);
	b2 = BATselect(b1, &priv, &priv);
	bat_destroy(b1);

	if (BATcount(b2) == 1){
		if (sub){
			oid id = *(oid*)BUNhead(b2,BUNfirst(b2));
			int hier = *(int*)BUNtail(priv_hier, 
						BUNfnd(priv_hier, &id));
			if (hier)
				res = priv;
		} else {
			res = priv;
		}
	}
	bat_destroy(b2);

	bat_destroy(priv_obj);
	bat_destroy(priv_auth);
	bat_destroy(priv_priv);
	bat_destroy(priv_hier);
	return res;
}

int sql_privilege( mvc *m, int auth_id, int obj_id, int priv, int sub )
{
	if (m->user_id == 0)
		return 1;
	return sql_privilege_(m, auth_id, obj_id, priv, sub);
	
}

int table_privs( mvc *m, sql_table *t, int priv )
{
	if (sql_privilege( m, m->user_id, t->base.id, priv, 0 ) == 0 ||
	    sql_privilege( m, m->role_id, t->base.id, priv, 0 ) == 0 ||
	    sql_privilege( m, 1, t->base.id, priv, 0 ) == 0) {
		return 0;
	}
	return 1;
}

int sql_grantable_( mvc *m, int grantorid, int obj_id, int privs, int sub )
{
	BUN p,q;
 	BAT *priv_obj = mvc_bind( m, "sys", "privileges", "obj_id", 1);
 	BAT *priv_auth = mvc_bind( m, "sys", "privileges", "auth_id", 1);
 	BAT *priv_priv = mvc_bind( m, "sys", "privileges", "privileges", 1);
 	BAT *priv_allowed = mvc_bind( m, "sys", "privileges", "grantable", 1);
 	BAT *priv_hier = mvc_bind( m, "sys", "privileges", "hierarchy", 1);
	
	BAT *b1,*b2 = BATselect(priv_obj, &obj_id, &obj_id );

	b1 = BATsemijoin(priv_auth, b2);
	bat_destroy(b2);
	b2 = BATselect( b1, &grantorid, &grantorid );
	bat_destroy(b1);
	b1 = BATsemijoin(priv_priv, b2);
	bat_destroy(b2);

	BATloop(b1, p, q) {
		oid id = *(oid*)BUNhead(b1,p);
		int priv = *(int*)BUNtail(b1,p);
		int allowed = *(int*)BUNtail(priv_allowed, 
						BUNfnd(priv_allowed, &id));
		/* switch of priv bit */
		if (allowed && !sub)
			privs = (privs & ~priv); 
		if (sub && allowed){
			int hier = *(int*)BUNtail(priv_hier, 
						BUNfnd(priv_hier, &id));
			if (hier)
				privs = (privs & ~priv); 
		}
	}
	bat_destroy(b1);

	bat_destroy(priv_obj);
	bat_destroy(priv_auth);
	bat_destroy(priv_priv);
	bat_destroy(priv_allowed);
	bat_destroy(priv_hier);
	if (privs != 0)
		return 0;
	return 1;
}

int sql_grantable( mvc *m, int grantorid, int obj_id, int privs, int sub )
{
	if (m->user_id == 0)
		return 1;
	return sql_grantable_(m, grantorid, obj_id, privs, sub);
	
}
