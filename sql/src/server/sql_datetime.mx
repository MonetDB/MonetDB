@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f sql_datetime
@a N.J. Nes
@* 

@h
#ifndef _SQL_DATETIME_H_
#define _SQL_DATETIME_H_

#include "sql_mvc.h"
#include "sql_symbol.h"

typedef enum inttype {
	iyear,
	imonth,
	iday,
	ihour,
	imin,
	isec
} itype;

int parse_interval_qualifier(mvc *sql, struct dlist *pers, int *sk, int *ek);

/* returns 0 for month intervals, 
 *         1 for sec intervals, 
 * 	   in both cases sk/ek contain the start and end qualifiers 
 *         <0 for errors */
int parse_interval(mvc *sql, int sign, char *str, struct dlist *pers, int *val);

/* returns 0 for month intervals and value in val, 
 *         1 for sec intervals and value in val, 
 *         <0 for errors */

char *datetime_field(itype field);

#endif /*_SQL_DATETIME_H_*/

@c
#include "sql_datetime.h"
#include "sql_string.h"
#include <stdlib.h>

int
parse_interval_qualifier(mvc *sql, struct dlist *pers, int *sk, int *ek)
{
	*sk = iyear;
	*ek = isec;

	if (pers) {
		dlist *s = pers->h->data.lval;

		*ek = *sk = s->h->data.ival;

		if (dlist_length(pers) == 2) {
			dlist *e = pers->h->next->data.lval;

			*ek = e->h->data.ival;
		}
	}
	if (*sk > *ek) {
		snprintf(sql->errstr, ERRSIZE, _("End interval field is larger than the start field\n"));
		return -1;
	}
	if ((*sk == iyear || *sk == imonth) && *ek > imonth) {
		snprintf(sql->errstr, ERRSIZE, _("Correct interval ranges are year-month or day-seconds\n"));
		return -1;
	}
	if (*sk == iyear || *sk == imonth)
		return 0;
	return 1;
}

int
parse_interval_intern(mvc *sql, int sign, char *str, int sk, int ek, int *i)
{
	char *n = NULL;
	int val = 0;
	char sep = ':';
	int type;
	int mul;

	if (*str == '-') {
		sign *= -1; 
		str++;
	}
	mul = sign;
		
	switch (sk) {
	case iyear:
		mul *= 12;
	case imonth:
		sep = '-';
		type = 0;
		break;

	case iday:
		mul *= 24;
		sep = ' ';
	case ihour:
		mul *= 60;
	case imin:
		mul *= 60;
	case isec:
		type = 1;
		break;

	default:
		snprintf(sql->errstr, ERRSIZE, _("Internal error: parse_interval_internal: bad value for sk (%d)\n"), sk);
		return -1;
	}

	val = strtol(str, &n, 10);
	val *= mul;
	*i += val;
	if (ek != sk) {
		if (*n != sep) {
			snprintf(sql->errstr, ERRSIZE, _("Interval field seperator \'%c\' missing\n"), sep);
			return -1;
		}
		return parse_interval_intern(sql, sign, n + 1, sk + 1, ek, i);
	} else {
		return type;
	}
}

int
parse_interval(mvc *sql, int sign, char *str, struct dlist *pers, int *val)
{

	int sk = iyear, ek = isec;

	if (parse_interval_qualifier(sql, pers, &sk, &ek) < 0)
		return -1;

	*val = 0;
	return parse_interval_intern(sql, sign, str, sk, ek, val);
}


char *
datetime_field(itype f)
{
	switch (f) {
	case iyear:
		return "year";
	case imonth:
		return "month";
	case iday:
		return "day";
	case ihour:
		return "hour";
	case imin:
		return "minute";
	case isec:
		return "second";
	}
	return "year";
}
