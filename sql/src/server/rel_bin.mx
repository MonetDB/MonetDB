@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f rel_bin
@a N.J. Nes
@* 

@h
#ifndef _REL_BIN_H_
#define _REL_BIN_H_

#include "rel_semantic.h"
#include "sql_statement.h"

extern stmt * rel_bin(mvc *sql, sql_rel *rel);

#endif /*_REL_BIN_H_*/
@c
#define LINESIZE 80

#include "rel_bin.h"

static stmt * subrel_bin(mvc *sql, sql_rel *rel);

static stmt *
bin_find_column( stmt *sub, char *rname, char *name ) 
{
	node *n;

	if (rname) {
		for (n = sub->op1.lval->h; n; n = n->next) {
			char *rnme = table_name(n->data);
			char *nme = column_name(n->data);

			if (strcmp(rnme, rname) == 0 && strcmp(nme, name) == 0) 
				return stmt_dup(n->data);
		}
	} else {
		for (n = sub->op1.lval->h; n; n = n->next) {
			char *nme = column_name(n->data);

			if (strcmp(nme, name) == 0) 
				return stmt_dup(n->data);
		}
	}
	return NULL;
}

static stmt *
bin_first_column( stmt *sub ) 
{
	node *n = sub->op1.lval->h;

	return stmt_dup(n->data);
}

static stmt *
exp_bin(mvc *sql, sql_exp *e, stmt *left, stmt *right, group *grp) 
{
	stmt *s = NULL;

	if (!e)
		return NULL;

	switch(e->type) {
	case e_atom: {
		if (e->l) {
			atom *a = e->l;
			s = stmt_atom(atom_dup(a));
		} else {
			s = stmt_varnr(e->flag, sql_dup_subtype(e->f));
		}
	}	break;
	case e_convert: {
		stmt *l = exp_bin(sql, e->l, left, right, grp);
		list *tps = e->r;
		sql_subtype *from = tps->h->data;
		sql_subtype *to = tps->h->next->data;
		if (!l) 
			return NULL;
		s = stmt_convert(l, sql_dup_subtype(from), sql_dup_subtype(to));
	} 	break;
	case e_func: {
		node *en;
		list *l = create_stmt_list(), *exps = e->l;
		sql_subfunc *f = e->f;

		if (exps) {
			for (en = exps->h; en; en = en->next) {
				stmt *es;

				es = exp_bin(sql, en->data, left, right, grp);
				if (!es) {
					list_destroy(l);
					return NULL;
				}
				list_append(l,es);
			}
		}
		s = stmt_Nop(stmt_list(l), sql_dup_func(f)); 
	} 	break;
	case e_aggr: {
		list *attr = e->l; 
		stmt *as = NULL;
		sql_subaggr *a = e->f;
		group *g = grp;

		if (attr) { 
			as = exp_bin(sql, attr->h->data, left, right, NULL);
		} else {
			/* count(*) may need the default group (relation) and
			   and/or an attribute to count */
			if (g)
				as = stmt_dup(grp->grp);
			else
				as = bin_first_column(left);
		}
		if (!as) 
			return NULL;	
		if (e->flag){ /* distinct */
			if (g)
				as = stmt_unique(as, grp_dup(grp));
			else
				as = stmt_unique(as, NULL);
		}
		if (g) 
			g = grp_dup(g);
		s = stmt_aggr(as, g, sql_dup_aggr(a) );
	} 	break;
	case e_relation: 
		s = subrel_bin(sql, e->l );
	 	break;
	case e_column: {
		if (left) /* check relation names */
			s = bin_find_column(left, e->l, e->r);
		if (!s && right) 
			s = bin_find_column(right, e->l, e->r);
		if (s && grp)
			s = stmt_join(stmt_dup(grp->ext), s, cmp_equal);
	 }	break;
	case e_cmp: {
		stmt *l = exp_bin(sql, e->l, left, NULL, grp);
		stmt *r;
		int swapped = 0;

		if (!l) {
			l = exp_bin(sql, e->l, right, NULL, grp);
			swapped = 1;
		}
		/* the escape charachter of like is in the right expression */
		if (e->flag == cmp_notlike || e->flag == cmp_like) {
			stmt *escape = NULL;
			sql_exp *re = e->r;

			if (re->type == e_exp) {
 				r = exp_bin(sql, re->l, left, right, grp);
 				escape = exp_bin(sql, re->r, left, right, grp);
			} else {
 				r = exp_bin(sql, e->r, left, right, grp);
				escape = stmt_atom_string(_strdup(""));
			}
			if (!l || !r || !escape) {
				if (l) stmt_destroy(l);
				if (r) stmt_destroy(r);
				if (escape) stmt_destroy(escape);
				return NULL;
			}
			return stmt_likeselect(l, r, escape, e->flag);
		}
		if (swapped || !right)
 			r = exp_bin(sql, e->r, left, NULL, grp);
		else
 			r = exp_bin(sql, e->r, right, NULL, grp);
		if (!l || !r) {
			if (l) stmt_destroy(l);
			if (r) stmt_destroy(r);
			return NULL;
		}
		if (left && right) {
			if (swapped)
				s = stmt_join(r, stmt_reverse(l), e->flag);
			else
				s = stmt_join(l, stmt_reverse(r), e->flag);
		} else {
			s = stmt_select(l, r, e->flag);
		}
	 }	break;
	default:
		;
	}
	return s;
}


static stmt *
stmt_rename( sql_rel *rel, sql_exp *exp, stmt *s )
{
	if (rel->name || exp->name) {
		char *name = exp->name;
		char *rname = rel->name;

		if (!name)
			name = column_name(s);
		if (!rname)
			rname = table_name(s);
		name = _strdup(name);
		rname = (rname)?_strdup(rname):NULL;
		s = stmt_alias(s, rname, name);
	}
	return s;
}

static stmt *
rel2bin_basetable( mvc *sql, sql_rel *rel )
{
	list *l; 
	stmt *ts;
	sql_table *t = rel->l;
	node *n;
			
	(void)sql;
	l = create_stmt_list();
	ts = stmt_basetable(t, (rel->name)?rel->name:t->base.name);
	for (n = t->columns.set->h; n; n = n->next) {
		sql_column *c = n->data;

		stmt *sc = stmt_cbat(c, stmt_dup(ts), RDONLY, st_bat);
		list_append(l, sc);
	}
	stmt_destroy(ts);
	return stmt_list(l);
}

char *compare_func( comp_type t )
{
	switch(t) {
	case cmp_equal:
		return "=";
	case cmp_lt:
		return "<";
	case cmp_lte:
		return "<=";
	case cmp_gte:
		return ">=";
	case cmp_gt:
		return ">";
	default:
		return NULL;
	}
	return NULL;
}

static stmt *
rel2bin_join( mvc *sql, sql_rel *rel )
{
	list *l; 
	node *en, *n;
	stmt *left = NULL, *right = NULL, *join = NULL, *jl, *jr;

	if (rel->l) /* first construct the left sub relation */
		left = subrel_bin(sql, rel->l);
	if (rel->r) /* first construct the right sub relation */
		right = subrel_bin(sql, rel->r);
	if (!left || !right) { 
		if (left) stmt_destroy(left);
		if (right) stmt_destroy(right);
		return NULL;	
	}
	if (rel->exps) {
		for( en = rel->exps->h; en; en = en->next ) {
			stmt *s = exp_bin(sql, en->data, left, right, NULL);

			if (!s) {
				stmt_destroy(left);
				stmt_destroy(right);
				if (join)
					stmt_destroy(join);
				return NULL;
			}
			if (!join) {
				join = s;
			} else {
				/* break column join */
				stmt *l = stmt_mark(stmt_reverse(join), 4);
				stmt *r = stmt_mark(stmt_dup(join), 4);
				stmt *ld = stmt_dup(s->op1.stval);
				stmt *rd = stmt_reverse(stmt_dup(s->op2.stval));
				stmt *le = stmt_join(l, ld, cmp_equal);
				stmt *re = stmt_join(r, rd, cmp_equal);

				sql_subfunc *f = sql_bind_func(sql->trans->module, compare_func(s->flag), tail_type(le), tail_type(le));
				stmt * cmp;

				assert(f);


				cmp = stmt_binop(le, re, f);

				cmp = stmt_uselect(cmp, stmt_bool(1), cmp_equal);

				l = stmt_semijoin(stmt_dup(l), stmt_dup(cmp));
				r = stmt_semijoin(stmt_dup(r), cmp);
				join = stmt_join(stmt_reverse(l), r, cmp_equal);
				stmt_destroy(s);
			}
		}
	} else {
		join = stmt_join(
			bin_first_column(left), 
			stmt_reverse(bin_first_column(right)), cmp_all); 
		
	}
/*
	// handle all outerjoin types (left,right and full)
	//if (rel->type == op_left)
		// add rest of the left outer join
*/

	/* construct relation */
	l = create_stmt_list();
	jl = stmt_reverse(stmt_mark_tail(stmt_dup(join),0));
	for( n = left->op1.lval->h; n; n = n->next ) {
		stmt *c = n->data;
		char *rnme = table_name(c);
		char *nme = column_name(c);
		stmt *s = stmt_join(stmt_dup(jl), stmt_dup(c), cmp_equal);

		s = stmt_alias(s, _strdup(rnme), _strdup(nme));
		list_append(l, s);
	}
	stmt_destroy(jl);
	stmt_destroy(left);
	jr = stmt_reverse(stmt_mark_tail(stmt_reverse(join),0));
	for( n = right->op1.lval->h; n; n = n->next ) {
		stmt *c = n->data;
		char *rnme = table_name(c);
		char *nme = column_name(c);
		stmt *s = stmt_join(stmt_dup(jr), stmt_dup(c), cmp_equal);

		s = stmt_alias(s, _strdup(rnme), _strdup(nme));
		list_append(l, s);
	}
	stmt_destroy(jr);
	stmt_destroy(right);
	return stmt_list(l);
}

static stmt *
rel2bin_union( mvc *sql, sql_rel *rel )
{
	list *l; 
	node *n, *m;
	stmt *left = NULL, *right = NULL;

	if (rel->l) /* first construct the left sub relation */
		left = subrel_bin(sql, rel->l);
	if (rel->r) /* first construct the right sub relation */
		right = subrel_bin(sql, rel->r);
	if (!left || !right) { 
		if (left) stmt_destroy(left);
		if (right) stmt_destroy(right);
		return NULL;	
	}

	/* construct relation */
	l = create_stmt_list();
	for( n = left->op1.lval->h, m = right->op1.lval->h; n && m; 
		n = n->next, m = m->next ) {
		stmt *c1 = n->data;
		stmt *c2 = m->data;
		char *rnme = table_name(c1);
		char *nme = column_name(c1);
		stmt *s = stmt_append(stmt_dup(c1), stmt_dup(c2));

		s = stmt_alias(s, _strdup(rnme), _strdup(nme));
		list_append(l, s);
	}
	stmt_destroy(left);
	stmt_destroy(right);
	return stmt_list(l);
}

static stmt *
rel2bin_distinct(stmt *s)
{
	node *n;
	group *grp = NULL;
	list *rl = create_stmt_list();

	for (n = s->op1.lval->h; n; n = n->next) {
		stmt *t = n->data;

		grp = grp_create(stmt_dup(t), grp, NULL);
	}

	for (n = s->op1.lval->h; n; n = n->next) {
		stmt *t = n->data;

		list_append(rl, stmt_join(stmt_dup(grp->ext), stmt_dup(t), cmp_equal));
	}

	if (grp)
		grp_destroy(grp);
	stmt_destroy(s);
	s = stmt_list(rl);
	return s;
}

static stmt *
rel2bin_project( mvc *sql, sql_rel *rel )
{
	list *l; 
	node *en;
	stmt *sub = NULL;

	if (!rel->exps)
		return NULL;

	if (rel->l) { /* first construct the sub relation */
		sub = subrel_bin(sql, rel->l);
		if (!sub) 
			return NULL;	
	}
	l = create_stmt_list();
	for( en = rel->exps->h; en; en = en->next ) {
		sql_exp *exp = en->data;
		stmt *s = exp_bin(sql, exp, sub, NULL, NULL);

		if (!s) {
			list_destroy(l);
			if (sub) stmt_destroy(sub);
			return NULL;
		}
		if (sub && sub->nrcols >= 1 && s->nrcols == 0)
			s = stmt_const(bin_first_column(sub), s);
			
		s = stmt_rename(rel, exp, s);
		list_append(l, s);
	}
	if (sub) 
		stmt_destroy(sub);
	sub = stmt_list(l);
	if (rel->r)  /* distinct */
		sub = rel2bin_distinct(sub);
	return sub;
}

static stmt *
rel2bin_predicate(void) 
{
	stmt *t = NULL;
	sql_subtype *bt = sql_bind_localtype("bit");
	t = stmt_temp(sql_dup_subtype(bt));
	t = stmt_append(t, stmt_bool(1));
	return t;
}

static stmt *
rel2bin_select( mvc *sql, sql_rel *rel )
{
	list *l; 
	node *en, *n;
	stmt *sub = NULL, *sel = NULL;
	stmt *predicate = NULL;

	if (!rel->exps)
		return NULL;

	if (rel->l) { /* first construct the sub relation */
		sub = subrel_bin(sql, rel->l);
		if (!sub) 
			return NULL;	
	} else {
		predicate = rel2bin_predicate();
	}
	for( en = rel->exps->h; en; en = en->next ) {
		stmt *s = exp_bin(sql, en->data, sub, NULL, NULL);

		if (!s) {
			if (sub) stmt_destroy(sub);
			if (predicate) stmt_destroy(predicate);
			if (sel) stmt_destroy(sel);
			return NULL;
		}
		if (s->nrcols == 0){ 
			if (!predicate) 
				predicate = rel2bin_predicate();
			predicate = stmt_select(predicate, s, cmp_equal);
		} else if (sel) {
			sel = stmt_semijoin(sel, s);
		} else {
			sel = s;
		}
	}

	if (predicate && sel) 
		sel = stmt_join(sel, stmt_dup(predicate), cmp_all);
	/* construct relation */
	l = create_stmt_list();
	if (sub && sel) {
		sel = stmt_mark(stmt_reverse(sel),0);
		for( n = sub->op1.lval->h; n; n = n->next ) {
			list_append(l, stmt_join(stmt_dup(sel), stmt_dup(n->data), cmp_equal));
		}
	} else if (sub && predicate) {
		predicate = stmt_mark(stmt_reverse(predicate),0);
		for( n = sub->op1.lval->h; n; n = n->next ) {
			list_append(l, stmt_join(stmt_dup(predicate), stmt_dup(n->data), cmp_all));
		}
	} else if (predicate) {
		list_append(l, stmt_dup(predicate));
	}
	if (predicate) stmt_destroy(predicate);
	if (sub) stmt_destroy(sub);
	if (sel) stmt_destroy(sel);
	return stmt_list(l);
}

static stmt *
rel2bin_groupby( mvc *sql, sql_rel *rel )
{
	list *l, *aggrs;
	node *n, *en;
	stmt *sub = NULL;
	group *groupby = NULL;


	if (rel->l) /* first construct the sub relation */
		sub = subrel_bin(sql, rel->l);
	if (!sub) 
		return NULL;	

	if (rel->exps) {
		for( en = rel->exps->h; en; en = en->next ) {
			sql_exp *e = en->data; 
			stmt *groupbycol = exp_bin(sql, e, sub, NULL, NULL); 

			if (!groupbycol) {
				stmt_destroy(sub);
				if (groupby) 
					grp_destroy(groupby);
				return NULL;
			}
			groupby = grp_create(groupbycol, groupby, NULL);
		}
	}
	/* now aggregate */
	l = create_stmt_list();
	aggrs = rel->r;
	for( n = aggrs->h; n; n = n->next ) {
		sql_exp *aggrexp = n->data;
		stmt *aggrstmt = exp_bin(sql, aggrexp, sub, NULL, groupby); 

		if (!aggrstmt) {
			list_destroy(l);
			stmt_destroy(sub);
			if (groupby) grp_destroy(groupby);
			return NULL;
		}

		aggrstmt = stmt_rename(rel, aggrexp, aggrstmt);
		list_append(l, aggrstmt);
	}
	stmt_destroy(sub);
	if (groupby) grp_destroy(groupby);
	return stmt_list(l);
}

static stmt *
rel2bin_orderby( mvc *sql, sql_rel *rel )
{
	node *en;
	stmt *sub = NULL, *orderby = NULL;

	if (!rel->exps)
		return NULL;

	if (rel->l) /* first construct the sub relation */
		sub = subrel_bin(sql, rel->l);
	if (!sub) 
		return NULL;	

	for( en = rel->exps->h; en; en = en->next->next ) {
		sql_exp *orderbycole = en->data; 
		stmt *orderbycols = exp_bin(sql, orderbycole, sub, NULL, NULL); 
		sql_exp *directione = en->next->data;
		atom *dir = directione->l;

		if (!orderbycols) {
			stmt_destroy(sub);
			if (orderby) 
				stmt_destroy(orderby);
			return NULL;
		}
		if (orderby)
			orderby = stmt_reorder(orderby, orderbycols, dir->data.val.ival);
		else
			orderby = stmt_order(orderbycols, dir->data.val.ival);
	}
	return stmt_ordered(orderby, sub);
}

static stmt *
rel2bin_topn( mvc *sql, sql_rel *rel )
{
	list *newl;
	int l = -1,o = 0;
	stmt *sub = NULL, *order = NULL;
	node *n;

	if (rel->l) /* first construct the sub relation */
		sub = subrel_bin(sql, rel->l);
	if (!sub) 
		return NULL;	

	if (rel->exps) {
		sql_exp *limit = rel->exps->h->data;
		atom *a = limit->l;

		l = a->data.val.ival;
		if (list_length(rel->exps) > 1) {
			sql_exp *offset = rel->exps->h->next->data;

			a = offset->l;
			o = a->data.val.ival;
		}
	}

	if (sub->type == st_ordered) {
		stmt *s = stmt_dup(sub->op2.stval);
		order = stmt_dup(sub->op1.stval);
		stmt_destroy(sub);
		sub = s;
	}
	n = sub->op1.lval->h;
	newl = create_stmt_list();


	if (n) {
		stmt *limit = NULL;

		if (order) {
		 	order = stmt_limit(order, o, l, 0);
			limit = order;
		} else {
			limit = stmt_limit(stmt_dup(n->data), o, l, 0);
			n = n->next;
			list_append(newl, limit);
		}

		for ( ; n; n = n->next) {
			stmt *s;
	
			s = stmt_semijoin(stmt_dup(n->data), stmt_dup(limit));
			list_append(newl, s);
		}
	}
	stmt_destroy(sub);
	sub = stmt_list(newl);
	if (order) 
		return stmt_ordered(order, sub);
	return sub;
}


static stmt *
subrel_bin(mvc *sql, sql_rel *rel ) 
{
	stmt *s = NULL;
	char *r = NULL;

	if (!rel)
		return s;
	switch (rel->op) {
	case op_basetable:
		s = rel2bin_basetable(sql, rel);
		break;
	case op_join: 
	case op_left: 
	case op_right: 
	case op_full: 
		s = rel2bin_join(sql, rel);
		break;
	case op_union: 
		s = rel2bin_union(sql, rel);
		break;
	case op_inter: 
	case op_except: 
		r = "union";
		if (rel->op == op_inter)
			r = "intersect";
		else if (rel->op == op_except)
			r = "minus";
		printf("todo %s\n", r);
		subrel_bin(sql, rel->r);
		break;
	case op_project:
		s = rel2bin_project(sql, rel);
		break;
	case op_select: 
		s = rel2bin_select(sql, rel);
		break;
	case op_orderby: 
		s = rel2bin_orderby(sql, rel);
		break;
	case op_groupby: 
		s = rel2bin_groupby(sql, rel);
		break;
	case op_topn: 
		s = rel2bin_topn(sql, rel);
		break;
	default:
		printf("todo: print %d\n", rel->op);
	}
	return s;
}

stmt *
rel_bin(mvc *sql, sql_rel *rel ) 
{
	stmt *s = subrel_bin( sql, rel);
	if (s) {
		s = stmt_output(s);
		sql->type = Q_TABLE;
	}
	return s;
}
