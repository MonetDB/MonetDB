@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2008 CWI.
@' All Rights Reserved.

@f rel_select
@a N.J. Nes
@* 

@h
#ifndef _REL_SELECT_H_
#define _REL_SELECT_H_

#include "rel_semantic.h"
#include "sql_semantic.h"

extern sql_rel *rel_selects(mvc *sql, symbol *sym);
extern sql_rel *rel_view(mvc *sql, dlist *qname, dlist *column_spec, symbol *query, int check, int persistent);

extern void rel_select_add_exp(sql_rel *l, sql_exp *e);
extern sql_rel *rel_select(sql_rel *l, sql_exp *e);

extern sql_exp *rel_bind_column( mvc *sql, sql_rel *rel, char *cname );
extern sql_exp *rel_bind_column2( mvc *sql, sql_rel *rel, char *tname, char *cname );

extern sql_exp * rel_value_exp(mvc *sql, sql_rel **rel, symbol *se, int f, exp_kind ek);
extern sql_rel *rel_crossproduct(sql_rel *l, sql_rel *r, operator_type join);
extern void rel_join_add_exp( sql_rel *rel, sql_exp *e);

extern sql_rel *rel_push_select(sql_rel *rel, sql_exp *ls, sql_exp *e);
extern sql_rel *rel_push_join(sql_rel *rel, sql_exp *ls, sql_exp *rs, sql_exp *e);
/* TODO rename to exp_check_type + move to rel_exp.mx */
extern sql_exp *rel_check_type(mvc *sql, sql_subtype *t, sql_exp *exp, int tpe);
extern sql_exp *rel_unop_(mvc *sql, sql_exp *e, sql_schema *s, char *fname);
extern sql_exp *rel_binop_(mvc *sql, sql_exp *l, sql_exp *r, sql_schema *s, char *fname);
extern sql_exp *rel_nop_(mvc *sql, sql_exp *l, sql_exp *r, sql_exp *r2, sql_exp *r3, sql_schema *s, char *fname);


extern sql_rel *rel_dup(sql_rel *r);
extern void rel_destroy(sql_rel *rel);

#define new_rel_list() list_create((fdestroy)NULL)

extern void rel_set_name( sql_rel *rel, char *name );

#endif /*_REL_SELECT_H_*/
@c

#include "sql_config.h"
#include "rel_select.h"
#include "sql_semantic.h" 	/* TODO this dependency should be removed, move
				   the dependend code into sql_mvc */
#include "sql_privileges.h"
#include "sql_sequence.h"
#include "sql_env.h"
#include "rel_exp.h"
#include "rel_xml.h"
#include "rel_bin.h"
#include "rel_dump.h"

#define rel_groupby_gbe(r,e) rel_groupby(r, append(new_exp_list(), e))

static str
number2name(str s, int len, int i)
{
	s[--len] = 0;
	while(i>0) {
		s[--len] = '0' + (i & 7);
		i >>= 3;
	}
	s[--len] = 'L';
	return s + len;
}

sql_rel *
rel_dup(sql_rel *r) 
{
	sql_ref_inc(&r->ref);
	return r;
}

static void 
rel_destroy_(sql_rel *rel)
{
	if (!rel) 
		return;
	if (rel->name) 
		_DELETE(rel->name);
	if (rel->exps)
		list_destroy(rel->exps);
	if (is_join(rel->op) || is_select(rel->op) || 
	    is_set(rel->op) || rel->op == op_topn) {
		if (rel->l)
			rel_destroy(rel->l);
		if (rel->r)
			rel_destroy(rel->r);
	} else if (is_project(rel->op)) {
		if (rel->l)
			rel_destroy(rel->l);
		if (rel->r)
			list_destroy(rel->r);
	} else if (rel->op == op_table) {
		if (rel->l)
			exp_destroy(rel->l);
	}
}

void 
rel_destroy(sql_rel *rel)
{
	if (!rel) 
		return;
	if (sql_ref_dec(&rel->ref) > 0)
		return;
	rel_destroy_(rel);
	_DELETE(rel);
}

static sql_rel*
rel_create()
{
	sql_rel *r = NEW(sql_rel);

	sql_ref_init(&r->ref);
	r->name = NULL;
	r->l = r->r = NULL;
	r->exps = NULL;
	r->nrcols = 0;
	r->flag = 0;
	r->card = CARD_ATOM;
	r->processed = 0;
	r->subquery = 0;
	r->p = NULL;
	return r;
}

static void
rel_setsubquery(sql_rel*r) 
{
	if (r->l && !is_base(r->op))
		rel_setsubquery(r->l);
	if (r->r && is_join(r->op)) 
		rel_setsubquery(r->r);
	set_subquery(r);
}

static sql_subtype *
rel_subtype( sql_rel *r )
{
	if (is_project(r->op)) {
		list *exps = r->exps;
		if (exps && list_length(exps) >= 1) 
			return exp_subtype(exps->t->data);
	} else if (r->op == op_union) {
		return rel_subtype(r->l);
	}
	return NULL;
}

static void
rel_label( sql_rel *r, int nr)
{
	char name[16], *nme;

	nme = number2name(name, 16, nr);
	assert(r->name == NULL);
	r->name = _strdup(nme);
}

static sql_exp * 
exp_alias_or_copy( mvc *sql, char *tname, char *cname, sql_rel *orel, sql_exp *old, int settname) 
{
	if (settname && !tname && old->type == e_column)
		tname = old->l;

	if (!cname) {
		char name[16], *nme;
		nme = number2name(name, 16, ++sql->label);

		exp_setname(old, NULL, nme);
		return exp_column(tname, nme, exp_subtype(old), orel->card);
	} else if (cname && !old->name) {
		exp_setname(old, tname, cname);
	}
	return exp_column(tname, cname, exp_subtype(old), orel->card);
}

static sql_exp *
basetable_bind_column( sql_rel *rel, char *cname ) 
{
	node *cn;
	sql_table *t = rel->l;
	sql_exp *e = NULL;

	if (rel->exps) /* list of aliases */
		e = exps_bind_column(rel->exps, cname);
	if (e) 
		return exp_column(NULL, cname, exp_subtype(e), rel->card);
	for (cn = t->columns.set->h; cn; cn = cn->next) {
		sql_column *c = cn->data;
		if (strcmp(c->base.name, cname) == 0)
			return exp_column(rel->name, cname, &c->type, CARD_MULTI );
	}
	return NULL;
}

static sql_rel *
rel_bind_table( sql_rel **p, sql_rel *rel, char *tname ) 
{
	sql_rel *r;

	if (rel->name && strcmp(rel->name, tname) == 0) 
		return rel; 
	switch(rel->op) {
	case op_join:
	case op_left:
	case op_right:
	case op_full:
		*p = rel;
		r = rel_bind_table( p,  rel->l, tname);
		if (r) 
			return r;
		*p = rel;
		return rel_bind_table( p, rel->r, tname);
	case op_semi:
	case op_anti:
	case op_project:
	case op_groupby:
	case op_select:
	case op_topn:
	case op_union:
	case op_except:
	case op_inter:
		*p = rel;
		return rel_bind_table( p, rel->l, tname);
	default:
		return NULL;
	}
	return NULL;
}

/* find the path to the relation containing the base of the expression 
	(e_column), in most cases this means go down the join tree and 
	find the base column. 
 */
static int
rel_bind_path_(sql_rel *rel, sql_exp *e, list *path )
{
	int found = 0;

	switch (rel->op) {
	case op_join:
	case op_left:
	case op_right:
	case op_full: 
		/* first right (possible subquery) */
		found = rel_bind_path_(rel->r, e, path);
		if (!found) 
			found = rel_bind_path_(rel->l, e, path);
		break;
	case op_semi:
	case op_anti:

	case op_select:
	case op_topn:
		found = rel_bind_path_(rel->l, e, path);
		break;

	case op_union:
	case op_inter:
	case op_except:
		if (!rel->exps) {
			found = rel_bind_path_(rel->l, e, path);
			assert(0);
			break;
		}
	case op_groupby: 
	case op_project:
		if (!rel->exps)
			break;
		if (rel->name && e->l) { /* both have relation names */
			if (strcmp(rel->name, e->l) != 0) 
				break;

			if (exps_bind_column(rel->exps, e->r))
				found = 1;
		}
		if (!found && e->l && exps_bind_column2(rel->exps, e->l, e->r)) 
			found = 1;
		if (!found && !e->l && exps_bind_column(rel->exps, e->r)) 
			found = 1;
		break;
	case op_table:
		if (e->l && rel->name && strcmp(e->l, rel->name) != 0)
			return 0;
		if (rel->exps && exps_bind_column(rel->exps, e->r)) 
			found = 1;
		break;
	case op_basetable: 
	    {
		node *cn;
		sql_table *t = rel->l;

		if (e->l) {
			if (rel->name && strcmp(e->l, rel->name) != 0)
				return 0;
			else if (!rel->name && strcmp(e->l, t->base.name) != 0)
				return 0;
		}
		if (rel->exps && exps_bind_column(rel->exps, e->r)) {
			found = 1;
			break;
		}
		for (cn = t->columns.set->h; cn; cn = cn->next) {
			sql_column *c = cn->data;
			if (strcmp(c->base.name, e->r) == 0) {
				found = 1;
				break;
			}
		}
	    }
	}
	if (found)
		list_prepend(path, rel);
	return found;
}

static list *
rel_bind_path(sql_rel *rel, sql_exp *e )
{
	list *path = new_rel_list(); 
	if (e->type == e_column) {
	
		if (rel) {
			if (!rel_bind_path_(rel, e, path)) {
				/* something is wrong */
				list_destroy(path); 
				return NULL;
			}
		}
		return path;
	}
	/* default the top relation */
	append(path, rel); 
	return path;
}


static list *
rel_projections(mvc *sql, sql_rel *rel, char *tname, int settname )
{
	list *rexps, *exps ;

	if (settname && !tname)
		tname = rel->name;

	if (is_subquery(rel))
		return list_create(NULL);

	switch(rel->op) {
	case op_join:
	case op_left:
	case op_right:
	case op_full:
		exps = rel_projections(sql, rel->l, tname, settname );
		rexps = rel_projections(sql, rel->r, tname, settname );
		exps = list_merge( exps, rexps, (fdup)&exp_dup);
		list_destroy(rexps);
		return exps;
	case op_groupby:
	case op_project:
	case op_table:
		if (rel->exps) {
			node *en;

			exps = new_exp_list();
			for (en = rel->exps->h; en; en = en->next) {
				sql_exp *e = en->data;
				append(exps, exp_alias_or_copy(sql, tname, exp_name(e), rel, e, settname));
			}
			return exps;
		}

	case op_union:
	case op_except:
	case op_inter:
		exps = rel_projections(sql, rel->l, tname, settname );
		if (exps) {
			node *en;
			for (en = exps->h; en; en = en->next) {
				sql_exp *e = en->data;
				e->card = rel->card;
			}
		}
		return exps;
	case op_semi:
	case op_anti:

	case op_select:
	case op_topn:
		return rel_projections(sql, rel->l, tname, settname );
	case op_basetable: 
	{
		node *cn;
		sql_table *t = rel->l;

		exps = new_exp_list();
		if (rel->exps) {
			node *en;
			for (en = rel->exps->h; en; en = en->next) {
				sql_exp *e = en->data;
				append(exps, exp_column(NULL, e->name, exp_subtype(e), rel->card));
			}
		} else {
			for (cn = t->columns.set->h; cn; cn = cn->next) {
				sql_column *c = cn->data;
				append(exps, exp_column(tname, c->base.name, &c->type, CARD_MULTI));
			}
		}
		return exps;
	} 
	default:
		return NULL;
	}
	return NULL;
}

static sql_rel *
rel_copy( sql_rel *i ) 
{
	sql_rel *rel = rel_create();

	rel->name = (i->name)?_strdup(i->name):NULL;
	rel->l = NULL;
	rel->r = NULL;
	rel->card = i->card;

	switch(i->op) {
	case op_basetable:
		rel->l = i->l;
		break;
	case op_table:
		rel->l = exp_dup(i->l); 
		break;
	case op_groupby:
		rel->l = rel_copy(i->l);
		if (i->r)
			rel->r = (i->r)?list_dup(i->r, (fdup)&exp_dup):NULL;
		break;
	case op_join:
	case op_left:
	case op_right:
	case op_full:
	case op_semi:
	case op_anti:
	case op_project:
	case op_select:
	default:
		if (i->l)
			rel->l = rel_copy(i->l);
		if (i->r)
			rel->r = rel_copy(i->r);
		break;
	}
	rel->op = i->op;
	rel->exps = (i->exps)?list_dup(i->exps, (fdup)&exp_dup):NULL;
	return rel;
}

static sql_rel *
rel_basetable(sql_table *t, char *tname) 
{
	sql_rel *rel = rel_create();

	assert(tname);
	rel->name = _strdup(tname);
	rel->l = t;
	rel->r = NULL;
	rel->op = op_basetable;
	rel->exps = NULL;
	rel->card = CARD_MULTI;
	rel->nrcols = list_length(t->columns.set);
	return rel;
}

static sql_rel *
rel_table_func(char *tname, sql_exp *f, list *exps) 
{
	sql_rel *rel = rel_create();

	rel->name = (tname)?_strdup(tname):NULL;
	rel->l = f;
	rel->r = NULL;
	rel->op = op_table;
	rel->exps = exps;
	rel->card = CARD_MULTI;
	rel->nrcols = list_length(exps);
	return rel;
}

static sql_rel *
rel_setop(sql_rel *l, sql_rel *r, operator_type setop)
{
	sql_rel *rel = rel_create();

	rel->l = l;
	rel->r = r;
	rel->op = setop;
	rel->exps = NULL;
	rel->card = CARD_MULTI;
	if (l && r) 
		rel->nrcols = l->nrcols + r->nrcols;
	return rel;
}

sql_rel *
rel_crossproduct(sql_rel *l, sql_rel *r, operator_type join)
{
	sql_rel *rel = rel_create();

	rel->l = l;
	rel->r = r;
	rel->op = join;
	rel->exps = NULL;
	rel->card = CARD_MULTI;
	rel->nrcols = l->nrcols + r->nrcols;
	return rel;
}

void 
rel_join_add_exp( sql_rel *rel, sql_exp *e)
{
	assert(is_join(rel->op));

	if (!rel->exps)
		rel->exps = new_exp_list();
	append(rel->exps, e);
	if (e->card > rel->card)
		rel->card = e->card;
}

void 
rel_join_add_exps( sql_rel *rel, list *exps)
{
	node *n;
	for(n = exps->h; n; n = n->next)
		rel_join_add_exp(rel, n->data);
}

static sql_rel *
rel_project(sql_rel *l, list *e)
{
	sql_rel *rel = rel_create();

	rel->l = l;
	rel->r = NULL;
	rel->op = op_project;
	rel->exps = e;
	rel->card = CARD_MULTI; 
	if (l) {
		rel->card = l->card;
		rel->nrcols = l->nrcols;
		assert (exps_card(rel->exps) <= rel->card); 
	}
	return rel;
}

static sql_rel*
rel_project_exp(sql_exp *e) 
{
	sql_rel *rel = rel_project(NULL, append(new_exp_list(), e));

	set_processed(rel);
	return rel;
}

static sql_rel *
rel_distinct(sql_rel *l) 
{
	if (l->card > CARD_ATOM)
		set_distinct(l);
	return l;
}


static sql_exp * exps_match(sql_exp *m, sql_exp *e);

static int
explists_match(list *m, list *e)
{
	node *nm,*ne;

	if (!m || !e)
		return (m==e);
	if (list_length(m) != list_length(e)) 
		return 0;
	for (nm = m->h, ne = e->h; nm && ne; nm = nm->next, ne = ne->next) {
		if (!exps_match(nm->data, ne->data))
			return 0;
	}
	return 1;
}

static sql_exp *
exps_match(sql_exp *m, sql_exp *e)
{
	if (m->type != e->type)
		return NULL;
	switch (m->type) {
	case e_column:
		if (strcmp(m->r, e->r) == 0) {
			if (m->l && e->l && (strcmp(m->l, e->l) == 0)) 
				return m;
			else if (!m->l && !e->l)
				return m;
		}
		break;
	case e_aggr:
		if (m->f == e->f && explists_match(m->l, e->l))
			return m;
		break;
	default:
		return NULL;
	}
	return NULL;
}

static sql_exp *
exps_find_match_exp(list *l, sql_exp *e)
{
	node *n;
	if (!l || !list_length(l))
		return NULL;

	for (n = l->h; n; n = n->next){
		sql_exp *m = n->data;
		if (exps_match(m,e))
			return m;
	}
	return NULL;
}

static sql_exp *rel_groupby_add_aggr(mvc *sql, sql_rel *rel, sql_exp *e)
{
	sql_exp *m = NULL;
	char name[16], *nme = NULL;
	char *tname = rel->name;

	if ((m=exps_find_match_exp(rel->exps, e)) == NULL) {
		if (!e->name) {
			nme = number2name(name, 16, ++sql->label);
			exp_setname(e, NULL, nme);
		}
		append(rel->exps, e);
		m = e;
	}
	if (!tname && e->type == e_column)
		tname = e->l;
	return exp_column(tname, m->name, exp_subtype(m), rel->card);
}

static void 
rel_project_add_exp( mvc *sql, sql_rel *rel, sql_exp *e)
{
	assert(is_project(rel->op));

	if (rel->op == op_project) {
		if (!rel->exps)
			rel->exps = new_exp_list();
		append(rel->exps, e);
	} else if (rel->op == op_groupby) {
		/* todo fix leak */
		(void) rel_groupby_add_aggr(sql, rel, e);
	}
}

static sql_rel*
rel_parent( sql_rel *rel )
{
	if (is_project(rel->op))
		return rel->l;
	return rel;
}

static sql_exp *
rel_lastexp(mvc *sql, sql_rel *rel ) 
{
	sql_exp *e;

	if (!is_processed(rel))
		rel = rel_parent(rel);
	assert(list_length(rel->exps));
	if (rel->op == op_project) 
		return exp_alias_or_copy(sql, rel->name, NULL, 
					 rel, rel->exps->t->data, 1); 
	assert(is_project(rel->op));
	e = rel->exps->t->data;
	return exp_column(rel->name, e->name, exp_subtype(e), e->card);
}

void
rel_select_add_exp(sql_rel *l, sql_exp *e)
{
	assert(l->op == op_select);
	append(l->exps, e);
}

sql_rel *
rel_select(sql_rel *l, sql_exp *e)
{
	sql_rel *rel = rel_create();
	
	assert(rel->op != op_select);
	rel->name = (l && l->name)?_strdup(l->name):NULL;
	rel->l = l;
	rel->r = NULL;
	rel->op = op_select;
	rel->exps = new_exp_list();
	if (e)
		append(rel->exps, e);
	rel->card = CARD_ATOM; /* no relation */
	if (l) {
		rel->card = l->card;
		rel->nrcols = l->nrcols;
	}
	return rel;
}

static sql_rel*
rel_project2groupby(mvc *sql, sql_rel **g)
{
	if ((*g)->op == op_project) { 
		node *en;
		sql_rel *r = *g;

		r->card = CARD_ATOM; /* no groupby expressions */
		r->op = op_groupby;
		r->r = new_exp_list(); /* add empty groupby column list */
		*g = r;
		
		for (en = r->exps->h; en; en = en->next) {
			sql_exp *e = en->data;

			if (e->card > r->card) {
				if (e->type == e_column && e->r) {
					return sql_error(sql, 02, "cannot use non GROUP BY column '%s' in query results without an aggregate function", e->r);
				} else {
					return sql_error(sql, 02, "cannot use non GROUP BY column in query results without an aggregate function");
				}
				return NULL;
			}
		}
		return rel_project(r, rel_projections(sql, r, NULL, 1));
	}
	return NULL;
}

static sql_rel *
rel_groupby(sql_rel *l, list *groupbyexps )
{
	sql_rel *rel = rel_create();
	list *aggrs = new_exp_list();
	node *en;

	rel->card = CARD_ATOM;
	if (groupbyexps) {
		rel->card = CARD_AGGR;
		for (en = groupbyexps->h; en; en = en->next) {
			/* TODO make a proper exp_copy (problem
			   is we refer to a groupby expression in this
			   relation and need to pass a long the same name) */
			sql_exp *e = exp_dup(en->data);

			/* after the group by the cardinality reduces */
			e->card = rel->card;
			append(aggrs, e);
		}
	}
	rel->l = l;
	rel->r = groupbyexps;
	rel->exps = aggrs;
	rel->nrcols = l->nrcols;
	rel->op = op_groupby;
	return rel;
}

static sql_rel *
rel_orderby(mvc *sql, sql_rel *l, list *orderbyexps )
{
	if (l->op != op_project) {
		sql_rel *rel = rel_create();

		rel->l = l;
		rel->r = orderbyexps;
		rel->op = op_project;	
		rel->exps = rel_projections(sql, rel, NULL, 1);
		rel->card = l->card;
		rel->nrcols = l->nrcols;
		return rel;
	}
	assert(l->op == op_project && !l->r);
	l->r = orderbyexps;
	return l;
}

static sql_rel *
rel_topn(sql_rel *l, list *exps )
{
	sql_rel *rel = rel_create();

	rel->l = l;
	rel->r = NULL;
	rel->op = op_topn;	
	rel->exps = exps;
	rel->card = l->card;
	rel->nrcols = l->nrcols;
	return rel;
}

void rel_set_name( sql_rel *rel, char *name )
{
	if (rel->name)
		_DELETE(rel->name);
	rel->name = _strdup(name);
}

static char * rel_get_name( sql_rel *rel )
{
	if (rel->name)
		return (rel->name);
	switch(rel->op) {
	case op_basetable:
	{
		sql_table *t = rel->l;
		return t->base.name;
	}
	default:
		return rel_get_name(rel->l);
	}
	assert(0);
	return NULL;
}

/* ls is the left expression of the select, rs is a simple atom, e is the
   select expression. 
 */
sql_rel *
rel_push_select(sql_rel *rel, sql_exp *ls, sql_exp *e)
{
	list *l = rel_bind_path(rel, ls);
	node *n;
	sql_rel *lrel = NULL, *p = NULL;

	if (!l) {
		/* expression has no clear parent relation, so filter current 
		   with it */
		if (rel && rel->op == op_select) { /* refine old select */
			rel_select_add_exp(rel, e);
			return rel;
		}
		return rel_select(rel, e);
	}

	for (n = l->h; n; n = n->next ) {
		lrel = n->data;
		
		/* push down as long as the operators allow this */
		if (lrel->op != op_select && lrel->op != op_join && 
		    lrel->op != op_left)
			break;
	        /* pushing through left head of a left join is allowed */
		if (lrel->op == op_left && (
			!n->next || lrel->l != n->next->data))
			break;
		p = lrel;
	}
	if (!lrel)
		return NULL;
	if (p && is_select(p->op)) { /* refine old select */
		rel_select_add_exp(p, e);
	} else {
		sql_rel *n = rel_select(lrel, e);

		if (p && p != lrel) {
			assert(p->op == op_join || p->op == op_left);
			if (p->l == lrel) {
				assert(p->l != n);
				p->l = n;
			} else {
				assert(p->op == op_join && p->r == lrel);
				assert(p->r != n);
				p->r = n;
			}
		} else {
			if (rel != lrel)
				assert(0);
			rel = n;
		}
	}
	return rel;
}


/* ls and rs are the left and right expression of the join, e is the
   join expression. 
 */
sql_rel *
rel_push_join(sql_rel *rel, sql_exp *ls, sql_exp *rs, sql_exp *e)
{
	list *l = rel_bind_path(rel, ls);
	list *r = rel_bind_path(rel, rs);
	node *ln, *rn;
	sql_rel *lrel = NULL, *rrel = NULL, *p = NULL;

	if (!l || !r) 
		return NULL;

	p = rel;
	for (ln = l->h, rn = r->h; ln && rn; ln = ln->next, rn = rn->next ) {
		lrel = ln->data;
		rrel = rn->data;
		
		/* push down as long as the operators allow this
			and the relation is equal.
		 */
		if (lrel != rrel || 
		   (lrel->op != op_select && lrel->op != op_join &&
		    lrel->op != op_left))
			break;
	        /* pushing through left head of a left join is allowed */
		if (lrel->op == op_left && (
			!ln->next || lrel->l != ln->next->data))
			break;
		p = lrel;
	}
	if (!lrel || !rrel)
		return NULL;

	/* filter on columns of this relation */
	if (lrel == rrel && lrel->op != op_join) {
		if (lrel->op == op_select) {
			rel_select_add_exp(lrel, e);
		} else if (p && p->op == op_select) {
			rel_select_add_exp(p, e);
		} else {
			sql_rel *n = rel_select(lrel, e);

			if (p && p != lrel) {
				if (p->l == lrel)
					p->l = n;
				else
					p->r = n;
			} else {
				rel = n;
			}
		}
		return rel;
	}

	rel_join_add_exp( p, e);
	return rel;
}

/* forward refs */
static sql_rel * rel_subquery(mvc *sql, sql_rel *rel, symbol *sq, exp_kind ek);
static sql_rel * rel_setquery(mvc *sql, sql_rel *rel, symbol *sq);
static sql_rel * rel_joinquery(mvc *sql, sql_rel *rel, symbol *sq);
static sql_rel * rel_crossquery(mvc *sql, sql_rel *rel, symbol *q);
static sql_rel * rel_unionjoinquery(mvc *sql, sql_rel *rel, symbol *sq);

static sql_rel *
rel_table_optname(mvc *sql, sql_rel *sq, symbol *optname)
{
	(void)sql;
	if (optname && optname->token == SQL_NAME) {
		dlist *columnrefs = NULL;
		char *tname = optname->data.lval->h->data.sval;

		if (tname)
			rel_set_name( sq, tname );
		columnrefs = optname->data.lval->h->next->data.lval;
		if (columnrefs && sq->exps) {
			dnode *d = columnrefs->h;
			node *ne = sq->exps->h;

			for (; d && ne; d = d->next, ne = ne->next) 
				exp_setname( ne->data, NULL, d->data.sval );
		}
	}
	return sq;
}

static sql_rel *
rel_subquery_optname(mvc *sql, sql_rel *rel, symbol *query)
{
	SelectNode *sn = (SelectNode *) query;
	exp_kind ek = {type_value, card_relation, TRUE};
	sql_rel *sq = rel_subquery(sql, rel, query, ek);

	if (!sq)
		return NULL;

	return rel_table_optname(sql, sq, sn->name);
}

static sql_rel *
query_exp_optname(mvc *sql, sql_rel *r, symbol *q)
{
	switch (q->token) {
	case SQL_UNION:
	case SQL_EXCEPT:
	case SQL_INTERSECT:
	{
		sql_rel *tq = rel_setquery(sql, r, q);

		if (!tq)
			return NULL;
		return rel_table_optname(sql, tq, q->data.lval->t->data.sym);
	}
	case SQL_JOIN:
	{
		sql_rel *tq = rel_joinquery(sql, r, q);

		if (!tq)
			return NULL;
		return rel_table_optname(sql, tq, q->data.lval->t->data.sym);
	}
	case SQL_CROSS:
	{
		sql_rel *tq = rel_crossquery(sql, r, q);

		if (!tq)
			return NULL;
		return rel_table_optname(sql, tq, q->data.lval->t->data.sym);
	}
	case SQL_UNIONJOIN:
	{
		sql_rel *tq = rel_unionjoinquery(sql, r, q);

		if (!tq)
			return NULL;
		return rel_table_optname(sql, tq, q->data.lval->t->data.sym);
	}
	default:
		(void) sql_error(sql, 02, "case %d %s\n", q->token, token2string(q->token));
	}
	return NULL;
}

static sql_rel *
rel_bind_column_(mvc *sql, sql_rel **p, sql_rel *rel, char *cname )
{
	sql_rel *l = NULL, *r = NULL;
	switch(rel->op) {
	case op_join:
	case op_left:
	case op_right:
	case op_full: {
		sql_rel *right = rel->r;

		*p = rel;
		r = rel_bind_column_(sql, p, rel->r, cname);

		if (!r || !is_subquery(right)) {
			*p = rel;
			l = rel_bind_column_(sql, p, rel->l, cname);
			if (l && r && !is_subquery(r)) {
				(void) sql_error(sql, 02, "SELECT: identifier '%s' unknown or ambiguous", cname);
				return NULL;
			}
		}
		if (l && !r)
			return l;
		return r;
	}
	case op_union:
	case op_except:
	case op_inter:
	case op_groupby:
	case op_project:
	case op_table:
		if (rel->exps && exps_bind_column(rel->exps, cname))
			return rel;
		*p = rel;
		if (is_processed(rel))
			return NULL;
		if (rel->l && rel->op != op_table)
			return rel_bind_column_(sql, p, rel->l, cname );
		break;
	case op_basetable:
	{
		node *cn;
		sql_table *t = rel->l;

		for (cn = t->columns.set->h; cn; cn = cn->next) {
			sql_column *c = cn->data;
			if (strcmp(c->base.name, cname) == 0)
				return rel;
		}
		break;
	} 
	case op_semi:
	case op_anti:

	case op_select:
	case op_topn:
		*p = rel;
		return rel_bind_column_(sql, p, rel->l, cname);
	default:
		return NULL;
	}
	return NULL;
}

static sql_exp *
rel_rename_column( mvc *sql, sql_rel *rel, char *cname )
{
	sql_exp *e = NULL;
	char name[16], *nme;
	nme = number2name(name, 16, ++sql->label);

	assert(rel->op == op_basetable);
	/* ambiguous names need fixing */
	e = basetable_bind_column(rel, cname); 
	if (!rel->exps)
		rel->exps = new_exp_list();
	append(rel->exps, e);
	exp_setname(e, NULL, nme);
	return exp_column(NULL, nme, exp_subtype(e), rel->card);
}

sql_exp *
rel_bind_column( mvc *sql, sql_rel *rel, char *cname )
{
	sql_rel *p = NULL;

	if (!rel || (rel = rel_bind_column_(sql, &p, rel, cname)) == NULL)
		return NULL;

	if (rel && is_subquery(rel) && p && is_join(p->op) && 
	    rel->op == op_basetable && (p->l == rel || p->r == rel)) {
		return rel_rename_column(sql, rel, cname);
	}

	if (is_project(rel->op) || rel->op == op_table) {
		if (rel->exps) {
			sql_exp *e = exps_bind_column(rel->exps, cname);
			if (e)
				return exp_alias_or_copy(sql, e->rname?e->rname:rel->name, cname, rel, e, 1);
		}
	} else if (rel->op == op_basetable) {
		return basetable_bind_column(rel, cname);
	}
	return NULL;
}

sql_exp *
rel_bind_column2( mvc *sql, sql_rel *rel, char *tname, char *cname )
{
	if (rel->exps) {
		sql_exp *e = NULL;

		if (rel->name && tname && strcmp(rel->name, tname) == 0)
			e = exps_bind_column(rel->exps, cname);
		else
			e = exps_bind_column2(rel->exps, tname, cname);
		if (e)
			return exp_alias_or_copy(sql, tname, cname, rel, e, 1);
	}
	if (is_project(rel->op)) {
		if (!is_processed(rel))
			return rel_bind_column2(sql, rel->l, tname, cname);
	} else if (is_join(rel->op)) {
		sql_exp *e = rel_bind_column2(sql, rel->l, tname, cname);
		if (!e)
			e = rel_bind_column2(sql, rel->r, tname, cname);
		return e;
	} else if (is_set(rel->op) || is_sort(rel) || is_select(rel->op)) {
		if (rel->l)
			return rel_bind_column2(sql, rel->l, tname, cname);
	} else if (rel->op == op_basetable && strcmp(rel->name, tname) == 0) {
		node *cn;
		sql_table *t = rel->l;

		for (cn = t->columns.set->h; cn; cn = cn->next) {
			sql_column *c = cn->data;
			if (strcmp(c->base.name, cname) == 0)
				return exp_column(rel->name, cname, &c->type, CARD_MULTI);
		}
	}
	return NULL;
}


static sql_rel *
rel_table_func_named(mvc *sql, sql_rel *rel, symbol *query)
{
	list *exps = NULL;
	sql_subtype *st = NULL;
	node *m;
	exp_kind ek = {type_value, card_relation, TRUE};
	sql_exp *e = rel_value_exp(sql, &rel, query->data.lval->h->data.sym, sql_from, ek);
	char *tname = NULL;
	if (!e)
		return NULL;

	if (query->data.lval->h->next->data.sym)
		tname = query->data.lval->h->next->data.sym->data.lval->h->data.sval;

	/* colum or table function */
	st = exp_subtype(e);
	if (!st->comp_type) {
		(void) sql_error(sql, 02, "SELECT: '%s' does not return a table", tname);
		return NULL;
	}

	/* foreach column add column name */
	exps = new_exp_list();
	for (m = st->comp_type->columns.set->h; m; m = m->next) {
		sql_column *c = m->data;
		append(exps, exp_column(NULL, c->base.name, &c->type, CARD_MULTI));
	}
	return rel_table_func(tname, e, exps);
}

static sql_rel *
table_ref(mvc *sql, sql_rel *rel, symbol *tableref)
{
	char *tname = NULL;
	sql_table *t = NULL;

	(void)rel;
	if (tableref->token == SQL_NAME) {
		char *sname = qname_schema(tableref->data.lval->h->data.lval);
		sql_schema *s = NULL;
		tname = qname_table(tableref->data.lval->h->data.lval);

		if (sname && !(s=mvc_bind_schema(sql,sname))) 
			return sql_error(sql, 02, "SELECT: no such schema '%s'", sname);
		if (!s)
			s = cur_schema(sql);
		t = mvc_bind_table(sql, s, tname);
		/* TODO: search path */
		if (!t && !sname) {
			s = tmp_schema(sql);
			t = mvc_bind_table(sql, s, tname);
		}
		if (!t) {
			return sql_error(sql, 02, "SELECT: no such table '%s'", tname);
		} else if (!table_privs(sql, t, PRIV_SELECT)) {
			return sql_error(sql, 02, "User is not allowed to select from table %s", tname);
		}
		if (tableref->data.lval->h->next->data.sym) {	/* AS */
			tname = tableref->data.lval->h->next->data.sym->data.lval->h->data.sval;
		}
		if (isView(t) && sql->mode != m_execute) { 
		   	/* instantiate base view */
			node *n,*m;
			sql_rel *rel = rel_parse(sql, t->query, m_execute);

			if (!rel)
				return rel;

			/* Direct renaming of rel_parse relation */
			assert(is_project(rel->op));
			for (n = t->columns.set->h, m = rel->exps->h; n && m; n = n->next, m = m->next) {
				sql_column *c = n->data;
				sql_exp *e = m->data;

				exp_setname(e, NULL, c->base.name);
				if (e->card == CARD_AGGR)
					e->card = CARD_MULTI;
			}
			rel_set_name(rel, tname);
			return rel;
		}
		return rel_basetable(t, tname);
	} else if (tableref->token == SQL_TABLE) {
		return rel_table_func_named(sql, rel, tableref);
	} else if (tableref->token == SQL_SELECT) {
		return rel_subquery_optname(sql, rel, tableref);
	} else {
		return query_exp_optname(sql, rel, tableref);
	}
}

static sql_exp *
rel_var_ref(mvc *sql, char *name, int at)
{
	if (stack_find_var(sql, name) != NULL) {
		sql_subtype *tpe = stack_find_type(sql, name);
		int frame = stack_find_frame(sql, name);

		return exp_param(name, tpe, frame);
	} else if (at) {
		return sql_error(sql, 02, "SELECT: '@""%s' unknown", name);
	} else {
		return sql_error(sql, 02, "SELECT: identifier '%s' unknown", name);
	}
}

static sql_exp *
rel_column_ref(mvc *sql, sql_rel *rel, symbol *column_r)
{
	sql_exp *exp = NULL;
	dlist *l = column_r->data.lval;

	assert(column_r->token == SQL_COLUMN && column_r->type == type_list);
	if (dlist_length(l) == 1 && l->h->type == type_int) {
		int nr = l->h->data.ival;
		atom *a;
		if ((a = sql_bind_arg(sql, nr)) != NULL)
			return exp_atom_ref(nr, atom_type(a));
		return NULL;
	} else if (dlist_length(l) == 1) {
		char *name = l->h->data.sval;
		int var = (stack_find_var(sql, name) != NULL);
		
		exp = rel_bind_column(sql, rel, name);
		if (exp && var) 
			return sql_error(sql, 02, "SELECT: identifier '%s' ambiguous", name);
		if (!exp && var)
			return rel_var_ref(sql, name, 0);
		if (!exp && !var)
			return sql_error(sql, 02, "SELECT: identifier '%s' unknown", name);
		
	} else if (dlist_length(l) == 2) {
		char *tname = l->h->data.sval;
		char *cname = l->h->next->data.sval;

		exp = rel_bind_column2(sql, rel, tname, cname);
		if (!exp) {
			sql_rel *p, *r = rel_bind_table(&p, rel, tname);

			(void)p;
			if (r)
				exp = rel_bind_column(sql, r, cname);
		}
		if (!exp)
			return sql_error(sql, 02, "SELECT: no such column '%s.%s'", tname, cname);
	} else if (dlist_length(l) >= 3) {
		return sql_error(sql, 02, "TODO: column names of level >= 3");
	}
	return exp;
}

static lng
scale2value(int scale)
{
	lng val = 1;

	if (scale < 0)
		scale = -scale;
	for (; scale; scale--) {
		val = val * 10;
	}
	return val;
}

static sql_exp *
exp_fix_scale(mvc *sql, sql_subtype *ct, sql_exp *e, int both, int always)
{
	sql_subtype *et = exp_subtype(e);
	(void) sql;		/* Stefan: unused!? */

	if (ct->type->scale == SCALE_FIX && et->type->scale == SCALE_FIX) {
		int scale_diff = ((int) ct->scale - (int) et->scale);

		if (scale_diff) {
			sql_subtype *it = sql_bind_localtype(et->type->base.name);
			sql_subfunc *c = NULL;

			if (scale_diff < 0) {
				if (!both)
					return e;
				c = sql_bind_func(sql->session->schema, "scale_down", et, it);
			} else {
				c = sql_bind_func(sql->session->schema, "scale_up", et, it);
			}
			if (c) {
				lng val = scale2value(scale_diff);
				atom *a = atom_int(it, val);

				c->res.scale = (et->scale + scale_diff);
				return exp_binop(e, exp_atom(a), c);
			}
		}
	} else if (always && et->scale) {	/* scale down */
		int scale_diff = -(int) et->scale;
		sql_subtype *it = sql_bind_localtype(et->type->base.name);
		sql_subfunc *c = sql_bind_func(sql->session->schema, "scale_down", et, it);

		if (c) {
			lng val = scale2value(scale_diff);
			atom *a = atom_int(it, val);

			c->res.scale = 0;
			return exp_binop(e, exp_atom(a), c);
		} else {
			printf("scale_down mising (%s)\n", et->type->base.name);
		}
	}
	return e;
}

static int
rel_set_type_param(mvc *sql, sql_subtype *type, sql_exp *param)
{
	if (!type || !param || param->type != e_atom)
		return -1;

	if (set_type_param(sql, type, param->flag) == 0) {
		param->f = type;
		return 0;
	}
	return -1;
}

sql_exp * 
rel_check_type(mvc *sql, sql_subtype *t, sql_exp *exp, int tpe)
{
	sql_subtype *fromtype = exp_subtype(exp);
	
	if ((!fromtype || !fromtype->type) && rel_set_type_param(sql, t, exp) == 0)
		return exp;

	if (fromtype && subtype_cmp(t, fromtype) != 0) {
		int c = sql_type_convert(fromtype->type->eclass, t->type->eclass);
		if (!c || 
		   (c == 2 && tpe == type_set) || (c == 3 && tpe != type_cast)){
			exp_destroy(exp);
			exp = NULL;
		} else {
			exp = exp_convert(exp, fromtype, t);
		}
	}
	if (!exp) {
		sql_exp *res = sql_error(
			sql, 03,
			"types %s(%d,%d) (%s) and %s(%d,%d) (%s) are not equal",
			fromtype->type->sqlname,
			fromtype->digits,
			fromtype->scale,
			fromtype->type->base.name,
			t->type->sqlname,
			t->digits,
			t->scale,
			t->type->base.name
		);
		return res;
	}
	return exp;
}

static sql_exp *
exp_sum_scales(mvc *sql, sql_subfunc *f, sql_exp *l, sql_exp *r)
{
	if (strcmp(f->func->imp, "*") == 0 && 
	    f->func->res.type->scale == SCALE_FIX) {
		sql_subtype t;
		sql_subtype *lt = exp_subtype(l);
		sql_subtype *rt = exp_subtype(r);

		f->res.scale = lt->scale + rt->scale;
		f->res.digits = lt->digits + rt->digits;
		/* HACK alert: digits should be less then max */
		if (f->res.type->radix == 10 && f->res.digits > 19)
			f->res.digits = 19;
		if (f->res.type->radix == 2 && f->res.digits > 53)
			f->res.digits = 53;
		/* sum of digits may mean we need a bigger result type 
		 * as the function don't support this we need to
		 * make bigger input types!
		 */

		/* numeric types are fixed length */
		if (f->res.type->eclass == EC_NUM) {
			sql_find_numeric(&t, f->res.type->localtype, f->res.digits);
		} else {
			sql_find_subtype(&t, f->res.type->sqlname, f->res.digits, f->res.scale);
		}
		if (type_cmp(t.type, f->res.type) != 0) { 
			/* do we need to convert to the a larger localtype 
			   int * int may not fit in an int, so we need to 
			   convert to lng * int.
			 */
			sql_subtype nlt;

			sql_init_subtype(&nlt, t.type, f->res.digits, lt->scale);
			l = rel_check_type( sql, &nlt, l, type_equal );
		}
		f->res = t;
	}
	return l;
}

static sql_exp *
exp_scale_algebra(mvc *sql, sql_subfunc *f, sql_exp *l, sql_exp *r)
{
	sql_subtype *lt = exp_subtype(l);
	sql_subtype *rt = exp_subtype(r);

	/*
	 * Decimals are mapped on plain integers. This has impact on the
	 * implemantion of division. First the 'dividend' should be large 
	 * enough to prevent rounding errors. This is solved by a 
	 * multiplication with the 'scale' of the divisor.
	 * Second the result type of the division should be equal to the 
	 * 'dividend', with the maximum scale of the dividend and divisor.
	 *
	 * Example      1.0/0.1 mapped (int 1 dec(1,0) and int 1 dec(2,1))
	 *                              1 * 10 = 10 (scale of divisor)
	 *                              10/1 = 1 dec(1)
	 */

	if (lt->type->scale == SCALE_FIX && rt->scale && 
		strcmp(f->func->imp, "/") == 0) {
		int digits = rt->scale + lt->digits;
		sql_subtype nlt;

		/* HACK alert: digits should be less then max */
		if (f->res.type->radix == 10 && digits > 19)
			digits = 19;
		if (f->res.type->radix == 2 && digits > 53)
			digits = 53;

		/* scale fixing may require a larger type ! */
		sql_find_subtype(&nlt, lt->type->sqlname, digits, lt->scale+rt->scale);
		f->res.digits = digits;
		f->res.scale = lt->scale;
		
		l = rel_check_type( sql, &nlt, l, type_equal );

		sql_find_subtype(&f->res, lt->type->sqlname, f->res.digits, f->res.scale);
	}
	return l;
}

static int 
rel_convert_types(mvc *sql, sql_exp **L, sql_exp **R, int scale_fixing, int tpe)
{
	sql_exp *ls = *L;
	sql_exp *rs = *R;
	sql_subtype *lt = exp_subtype(ls);
	sql_subtype *rt = exp_subtype(rs);

	if (!rt && !lt) {
		sql_error(sql, 01, "Cannot have a parameter (?) on both sides of an expression");
		return -1;
	}
	if (rt && (!lt || !lt->type))
		 return rel_set_type_param(sql, rt, ls);
	if (lt && (!rt || !rt->type))
		 return rel_set_type_param(sql, lt, rs);

	if (rt && lt) {
		sql_subtype *i = lt;
		sql_subtype *r = rt;

		if (subtype_cmp(lt, rt) != 0) {
			sql_subtype super;

			supertype(&super, r, i);
			if (scale_fixing) {
				/* convert ls to super type */
				ls = rel_check_type(sql, &super, ls, tpe);
				/* convert rs to super type */
				rs = rel_check_type(sql, &super, rs, tpe);
			} else {
				/* convert ls to super type */
				super.scale = lt->scale;
				ls = rel_check_type(sql, &super, ls, tpe);
				/* convert rs to super type */
				super.scale = rt->scale;
				rs = rel_check_type(sql, &super, rs, tpe);
			}
		}
		*L = ls;
		*R = rs;
		if (!ls || !rs) {
			return -1;
		}
		return 0;
	}
	return -1;
}

static comp_type
compare_str2type( char *compare_op)
{
	comp_type type = cmp_equal;

	if (compare_op[0] == '=') {
		type = cmp_equal;
	} else if (compare_op[0] == '<') {
		type = cmp_lt;
		if (compare_op[1] != '\0') {
			if (compare_op[1] == '>') 
				type = cmp_notequal;
			else if (compare_op[1] == '=') 
				type = cmp_lte;
		}
	} else if (compare_op[0] == '>') {
		type = cmp_gt;
		if (compare_op[1] != '\0') 
			if (compare_op[1] == '=') 
				type = cmp_gte;
	} else if (compare_op[0] == 'l') {
		type = cmp_like;
	} else if (compare_op[0] == 'n') {
		type = cmp_notlike;
	}
	return type;
}

static int
is_atom( sql_exp *e )
{
	switch (e->type) {
	case e_atom:
		return 1;
	case e_convert:
		return is_atom(e->l);
	case e_func:
	case e_aggr:
	{	
		int r = 1;
		node *n;
		list *l = e->l;

		if (l)
			for (n = l->h; n; n = n->next) 
				r &= is_atom(n->data);
		return r;
	}
	case e_column:
	case e_cmp:
		return 0;
	}
	return 0;
}

static sql_rel *
rel_compare_exp(mvc *sql, sql_rel *rel, sql_exp *ls, sql_exp *rs, char *compare_op, sql_exp *esc, int f )
{
	sql_exp *L = ls, *R = rs, *e = NULL;
	comp_type type = cmp_equal;

	if (!ls || !rs)
		return NULL;

	if (rel_convert_types(sql, &ls, &rs, 1, type_equal) < 0) {
		if (ls)
			exp_destroy(ls);
		if (rs)
			exp_destroy(rs);
		return NULL;
	}
	if (!rel || f == sql_sel || (ls->card <= CARD_ATOM && rs->card <= CARD_ATOM)) {
		sql_exp *e;

		if (compare_op[0] == 'l') 
			compare_op = "like";
		if (compare_op[0] == 'n') 
			compare_op = "not_like";
		e = rel_binop_(sql, ls, rs, NULL, compare_op);

		if (!e)
			return NULL;
		if (f == sql_sel) {
			if (rel->op == op_project) { 
				append(rel->exps, e);
			} else {
				list *exps = new_exp_list();

				append(exps, e);
				return rel_project(rel, exps);
			}
		} else {
			return rel_select(rel, e);
		}
	}
	type = compare_str2type(compare_op);
	if (type != cmp_like && type != cmp_notlike) {
		if (ls->card < rs->card) {
			sql_exp *swap = ls;
	
			ls = rs;
			rs = swap;

			swap = L; 
			L = R; 
			R = swap;

			type = swap_compare(type);
		}
		e = exp_compare( ls, rs, type );
	} else {
		e = exp_like( ls, rs, esc, type );
	}

	/* atom or row => select */
	if (ls->card > rel->card)
		return sql_error(sql, 02, "SELECT: cannot use non GROUP BY column '%s' in query results without an aggregate function", ls->name);
	if (rs->card > rel->card) 
		return sql_error(sql, 02, "SELECT: cannot use non GROUP BY column '%s' in query results without an aggregate function", rs->name);
	if (rs->card <= CARD_ATOM && is_atom(rs)) {
		if (ls->card == rs->card)  /* bin compare op */
			return rel_select(rel, e);

		/* push select into the given relation */
		return rel_push_select(rel, L, e);
	} else { /* join */
		return rel_push_join(rel, L, R, e);
	}
	return rel;
}

static sql_rel *
rel_compare(mvc *sql, sql_rel *rel, symbol *lo, symbol *ro, char *compare_op, int f )
{
	sql_exp *rs = 0, *ls;
	exp_kind ek = {type_value, card_column, FALSE};

	if (lo->token == SQL_SELECT) { /* swap subquery to the right handside */
		symbol *tmp = lo;

		lo = ro;
		ro = tmp;

		if (compare_op[0] == '>')
			compare_op[0] = '<';
		else if (compare_op[0] == '<')
			compare_op[0] = '>';
	}

	ls = rel_value_exp(sql, &rel, lo, f, ek);
	if (!ls)
		return NULL;
	if (ro->token != SQL_SELECT) {
		rs = rel_value_exp(sql, &rel, ro, f, ek);
	} else {
		/* first try without current relation, too see if there
		   are correlations with the outer relation */
		sql_rel *r = rel_subquery(sql, NULL, ro, ek);

		if (!r) {
			/* reset error */
			sql->session->status = 0;
			sql->errstr[0] = 0;
			r = rel_subquery(sql, rel, ro, ek);

			/* get inner queries result value, ie
			   get last expression of r->r */
			if (r) {
				rs = rel_lastexp(sql, r->r);
				rel = r;
			}
		} else if (r) {
			rel_setsubquery(r);
			rs = rel_lastexp(sql, r);
			if (r->card > CARD_ATOM) {
				sql_subaggr *zero_or_one = sql_bind_aggr(sql->session->schema, "zero_or_one", exp_subtype(rs));

				rs = exp_aggr1(rs, zero_or_one, 0, 0, CARD_ATOM);
			}
			rel = rel_crossproduct(rel, r, op_join);
		}
	}
	if (!rs) {
		exp_destroy(ls);
		return NULL;
	}
	return rel_compare_exp(sql, rel, ls, rs, compare_op, NULL, f);
}

static sql_rel *
rel_or(mvc *sql, sql_rel *l, sql_rel *r, int f)
{
	sql_rel *rel;

	(void)f;
	rel = rel_setop(l, r, op_union);
	rel->exps = rel_projections(sql, rel, NULL, 1);
	return rel;
}

static sql_rel * rel_logical_exp(mvc *sql, sql_rel *rel, symbol *sc, int f);

static sql_exp *
rel_logical_value_exp(mvc *sql, sql_rel **rel, symbol *sc, int f)
{
	exp_kind ek = {type_value, card_column, FALSE};

	if (!sc)
		return NULL;
	//assert(f >= sql_sel);
	switch (sc->token) {
	case SQL_OR:
	case SQL_AND:
	{
		symbol *lo = sc->data.lval->h->data.sym;
		symbol *ro = sc->data.lval->h->next->data.sym;

		sql_exp *ls = rel_logical_value_exp(sql, rel, lo, f);
		sql_exp *rs = rel_logical_value_exp(sql, rel, ro, f);

		if (!ls || !rs)
			return NULL;
		if (sc->token == SQL_OR)
			return rel_binop_(sql, ls, rs, NULL, "or");
		else
			return rel_binop_(sql, ls, rs, NULL, "and");
	}
	case SQL_COMPARE:
	{
		symbol *lo = sc->data.lval->h->data.sym;
		symbol *ro = sc->data.lval->h->next->next->data.sym;
		char *compare_op = sc->data.lval->h->next->data.sval;

		/* currently we don't handle the (universial and existential) 
		   quantifiers (all and any/some) */

		sql_exp *rs, *ls = rel_value_exp(sql, rel, lo, f, ek);

		if (!ls)
			return NULL;

		if (ro->token != SQL_SELECT) {
			rs = rel_value_exp(sql, rel, ro, f, ek);
			if (!rs) 
				return NULL;
			if (rel_convert_types(sql, &ls, &rs, 1, type_equal) < 0) {
				exp_destroy(ls);
				exp_destroy(rs);
				return NULL;
			}
			return rel_binop_(sql, ls, rs, NULL, compare_op);
		} else {
			/* first try without current relation, too see if there
		   	are correlations with the outer relation */
			sql_rel *r = rel_subquery(sql, NULL, ro, ek);
	
			if (!r) { /* correlation, ie return new relation */
				sql_exp *e;

				/* reset error */
				sql->session->status = 0;
				sql->errstr[0] = 0;
				r = rel_subquery(sql, *rel, ro, ek);

				/* get inner queries result value, ie
				   get last expression of r->r */
				if (r) {
					rs = rel_lastexp(sql, r->r);
					*rel = r;
					e = exp_compare( ls, rs, compare_str2type(compare_op));
					if (f != sql_sel) 
						return e;
			
					/* For selection we need to convert back into booleans */
					ls = exp_dup(ls);
					rel_join_add_exp(r, e);
					ls = rel_unop_(sql, ls, NULL, "isnull");
					rs = exp_atom_bool(0);
					return rel_binop_(sql, ls, rs, NULL, "=");
				}
			} else if (r) { 
				rel_setsubquery(r);
				rs = rel_lastexp(sql, r);
				if (r->card > CARD_ATOM) {
					sql_subaggr *zero_or_one = sql_bind_aggr(sql->session->schema, "zero_or_one", exp_subtype(rs));

					rs = exp_aggr1(rs, zero_or_one, 0, 0, CARD_ATOM);
				}
				*rel = rel_crossproduct(*rel, r, op_join);
			}
			if (!rs) {
				exp_destroy(ls);
				return NULL;
			}
			if (rel_convert_types(sql, &ls, &rs, 1, type_equal) < 0) {
				if (ls)
					exp_destroy(ls);
				if (rs)
					exp_destroy(rs);
				return NULL;
			}
			return rel_binop_(sql, ls, rs, NULL, compare_op);
		}
	}
	/* Set Member ship */
	case SQL_IN:
	case SQL_NOT_IN:
	{
		dlist *dl = sc->data.lval;
		symbol *lo = dl->h->data.sym;
		dnode *n = dl->h->next;
		sql_exp *l = rel_value_exp(sql, rel, lo, f, ek);
		sql_rel *left = NULL, *right = NULL, *p = NULL;

		if (!l)
			return NULL;

		ek.card = card_set;

		/* we assume the selection case */
		if (f >= sql_sel) { 
			if (left && is_project(left->op)) {
				p = left;
				left = left->l;
			}
			if (left && is_groupby(left->op)) {
				p = left;
				left = left->l;
			}
		} 
		if (!left) 
			left = rel_project_exp(l);
		else 
			left = rel_dup(left);
		if (!p)
			p = *rel;
		l = exp_alias_or_copy(sql, NULL, NULL, left, l, 0);
		/* list of values or subqueries */

		/* single element could be a 'select' */
		if (n->type == type_list) {
			sql_subtype *st = exp_subtype(l);

			n = n->data.lval->h;
			for (; n; n = n->next) {
				symbol *sval = n->data.sym;
				/* without correlation first */
				sql_rel *z = NULL;
				sql_exp *r = rel_value_exp(sql, &z, sval, f, ek);
				sql_rel *rl;

				if (!r || !(r=rel_check_type(sql, st, r, type_equal))) {
					if (r)
						exp_destroy(r);
					exp_destroy(l);
					if (right)
						rel_destroy(right);
					return NULL;
				}
				if (z) {
					rl = z;
				} else {
 					rl = rel_project_exp(r);
				}
				if (right) {
					rl = rel_setop(right, rl, op_union);
					rl->exps = rel_projections(sql, rl, NULL, 0);
				}
				right = rl;
			}
			if (!right->name)
				rel_label(right, ++sql->label);
			right = rel_distinct(right);
		} else {
			return sql_error(sql, 02, "IN: missing inner query");
		}
		if (right) {
			sql_exp *r = NULL, *e;

			r = rel_lastexp(sql, right);
			rel_setsubquery(right);
			if (p)
				rel_destroy(p->l);
			if (rel_convert_types(sql, &l, &r, 1, type_equal) < 0) {
				exp_destroy(l);
				exp_destroy(r);
				return NULL;
			}
			left = p->l = rel_crossproduct(left, right, op_join);
			left->op = op_left;
			e = exp_compare( l, r, cmp_equal );
			rel_join_add_exp(left, e);
			l = rel_unop_(sql, l, NULL, "isnull");
			if (sc->token == SQL_NOT_IN) 
				r = exp_atom_bool(1);
			else
				r = exp_atom_bool(0);
			return rel_binop_(sql, l, r, NULL, "=");
		}
		return NULL;
	}
	case SQL_LIKE:
	case SQL_NOT_LIKE:
	{
		symbol *lo = sc->data.lval->h->data.sym;
		symbol *ro = sc->data.lval->h->next->data.sym;
		sql_subtype *st = sql_bind_localtype("str");
		sql_exp *le = rel_value_exp(sql, rel, lo, f, ek);
		sql_exp *re, *ee = NULL;

		if (!le)
			return NULL;

		if (!exp_subtype(le)) {
			exp_destroy(le);
			return sql_error(sql, 02, "No parameter allowed on left hand of LIKE statement");
		}

		lo = ro->data.lval->h->data.sym;
		/* like uses a single string pattern */
		ek.card = card_value;
		re = rel_value_exp(sql, rel, lo, f, ek);
		if (!re)
			return NULL;
		if (!exp_subtype(re)) {
			if (rel_set_type_param(sql, st, re) == -1) {
				exp_destroy(le);
				exp_destroy(re);
				return sql_error(sql, 02, "wrong type used with LIKE statement, should be string");
			}
		} else if ((re = rel_check_type(sql, st, re, type_equal)) == NULL) {
			return sql_error(sql, 02, "Wrong type used with LIKE statement, should be string");
		}
		/* Do we need to escape ? */
		if (dlist_length(ro->data.lval) == 2) {
			char *escape = ro->data.lval->h->next->data.sval;
			ee = exp_atom(atom_string(st, _strdup(escape), 1));
		}
		if (sc->token == SQL_LIKE) {
			if (ee)
				return rel_nop_(sql, le, re, ee, NULL, NULL, "like");
			return rel_binop_(sql, le, re, NULL, "like");
		} else {
			if (ee)
				return rel_nop_(sql, le, re, ee, NULL, NULL, "not_like");
			return rel_binop_(sql, le, re, NULL, "not_like");
		}
	}
	case SQL_BETWEEN:
	case SQL_NOT_BETWEEN:
	{
		symbol *lo = sc->data.lval->h->data.sym;
		int symmetric = sc->data.lval->h->next->data.ival;
		symbol *ro1 = sc->data.lval->h->next->next->data.sym;
		symbol *ro2 = sc->data.lval->h->next->next->next->data.sym;
		sql_exp *le = rel_value_exp(sql, rel, lo, f, ek);
		sql_exp *re1 = rel_value_exp(sql, rel, ro1, f, ek);
		sql_exp *re2 = rel_value_exp(sql, rel, ro2, f, ek);
		sql_exp *e1 = NULL, *e2 = NULL;
		sql_subtype *ct = NULL;

		if (!le || !re1 || !re2) {
			exp_destroy(le);
			exp_destroy(re1);
			exp_destroy(re2);
			return NULL;
		}
		ct = exp_subtype(le);
		re1 = rel_check_type(sql, ct, re1, type_equal);
		re2 = rel_check_type(sql, ct, re2, type_equal);

		if (!re1 || !re2) {
			exp_destroy(le);
			exp_destroy(re1);
			exp_destroy(re2);
			return NULL;
		}

		if (symmetric) {
			sql_exp *tmp = NULL;
			sql_subfunc *min = sql_bind_func(sql->session->schema, "min", exp_subtype(re1), exp_subtype(re2));
			sql_subfunc *max = sql_bind_func(sql->session->schema, "max", exp_subtype(re1), exp_subtype(re2));

			if (!min || !max) {
				return sql_error(sql, 02, "min or max operator on types %s %s missing", exp_subtype(re1)->type->sqlname, exp_subtype(re2)->type->sqlname);
			}
			tmp = exp_binop(re1, re2, min);
			re2 = exp_binop(exp_dup(re1), exp_dup(re2), max);
			re1 = tmp;
		}

		if (sc->token == SQL_NOT_BETWEEN) {
			e1 = rel_binop_(sql, le, re1, NULL, "<");
			e2 = rel_binop_(sql, exp_dup(le), re2, NULL, ">");
		} else {
			e1 = rel_binop_(sql, le, re1, NULL, ">=");
			e2 = rel_binop_(sql, exp_dup(le), re2, NULL, "<=");
		}
		if (!e1 || !e2)
			return NULL;
		return rel_binop_(sql, e1, e2, NULL, "and");
	}
	case SQL_NULL:
	case SQL_NOT_NULL:
	/* is (NOT) NULL */
	{
		sql_exp *le = rel_value_exp(sql, rel, sc->data.sym, f, ek);

		if (!le)
			return NULL;
		le = rel_unop_(sql, le, NULL, "isnull");
		if (sc->token != SQL_NULL) 
			le = rel_unop_(sql, le, NULL, "not");
		return le;
	}
	case SQL_NOT: { 
		sql_exp *le = rel_logical_value_exp(sql, rel, sc->data.sym, f);
		return rel_unop_(sql, le, NULL, "not");
	}
	case SQL_ATOM: {
		/* TRUE or FALSE */
		AtomNode *an = (AtomNode *) sc;

		if (!an || !an->a) {
			assert(0);
			return exp_atom(atom_general(sql_bind_localtype("str"), NULL, 0));
		} else {
			return exp_atom(atom_dup(an->a));
		}
	} 
	case SQL_COLUMN: 
		return rel_column_ref(sql, *rel, sc);
	case SQL_UNION:
	case SQL_EXCEPT:
	case SQL_INTERSECT: {
		*rel = rel_setquery(sql, *rel, sc);
		if (*rel)
			return rel_lastexp(sql, *rel);
		return NULL;
	} 
	default:
		return sql_error(sql, 02, "Predicate %s %d: time to implement some more", token2string(sc->token), sc->token);
	}
	return sql_error(sql, 02, "Predicate: time to implement some more");
}

static sql_rel *
rel_logical_exp(mvc *sql, sql_rel *rel, symbol *sc, int f)
{
	exp_kind ek = {type_value, card_column, FALSE};

	if (!sc)
		return NULL;
	switch (sc->token) {
	case SQL_OR:
	{
		symbol *lo = sc->data.lval->h->data.sym;
		symbol *ro = sc->data.lval->h->next->data.sym;
		sql_rel *ls = rel;
		sql_rel *rs = rel_copy(rel);

		ls = rel_logical_exp(sql, ls, lo, f);
		rs = rel_logical_exp(sql, rs, ro, f);

		if (!ls || !rs)
			return NULL;
		return rel_or(sql, ls, rs, f);
	}
	case SQL_AND:
	{
		symbol *lo = sc->data.lval->h->data.sym;
		symbol *ro = sc->data.lval->h->next->data.sym;

		rel = rel_logical_exp(sql, rel, lo, f);
		if (!rel)
			return NULL;
		return rel_logical_exp(sql, rel, ro, f);
	}
	case SQL_COMPARE:
	{
		symbol *lo = sc->data.lval->h->data.sym;
		symbol *ro = sc->data.lval->h->next->next->data.sym;
		char *compare_op = sc->data.lval->h->next->data.sval;
		/* currently we don't handle the (universial and existential) 
		   quantifiers (all and any/some) */
		return rel_compare(sql, rel, lo, ro, compare_op, f);
	}
		break;
	/* Set Member ship */
	case SQL_IN:
	case SQL_NOT_IN:
	{
		dlist *dl = sc->data.lval;
		symbol *lo = dl->h->data.sym;
		dnode *n = dl->h->next;
		sql_exp *l = rel_value_exp(sql, &rel, lo, f, ek), *e;
		sql_rel *left = rel, *right = NULL;

		if (!l)
			return NULL;

		ek.card = card_set;
		/* first remove the NULLs, TODO optimize for not null exprs */
		/* TODO use exp_compare with 2 arguments */
		if (l->card != CARD_ATOM) {
			e = rel_unop_(sql, exp_dup(l), NULL, "isnull");
			e = exp_compare( e, exp_atom_bool(0), cmp_equal);
			if (!is_select(rel->op))
				left = rel = rel_select(rel, e);
			else
				rel_select_add_exp(rel, e);
		}
		/* list of values or subqueries */

		/* single element could be a 'select' */
		if (n->type == type_list) {
			sql_subtype *st = exp_subtype(l);

			n = n->data.lval->h;
			for (; n; n = n->next) {
				symbol *sval = n->data.sym;
				/* without correlation first */
				sql_rel *z = NULL;
				sql_exp *r = rel_value_exp(sql, &z, sval, f, ek);
				sql_rel *rl;

				if (!r || !(r=rel_check_type(sql, st, r, type_equal))) {
					if (r)
						exp_destroy(r);
					exp_destroy(l);
					if (right)
						rel_destroy(right);
					return NULL;
				}
				if (z) {
					rl = z;
				} else {
 					rl = rel_project_exp(r);
				}
				if (right) {
					rl = rel_setop(right, rl, op_union);
					rl->exps = rel_projections(sql, rl, NULL, 0);
				}
				right = rl;
			}
			rel_label(right, ++sql->label);
			right = rel_distinct(right);
		} else {
			return sql_error(sql, 02, "IN: missing inner query");
		}
		/* right is a relation without correlations */
		if (right) {
			sql_exp *r = NULL;

			r = rel_lastexp(sql, right);
			rel_setsubquery(right);
			rel = rel_crossproduct(left, right, op_join);
			if (rel_convert_types(sql, &l, &r, 1, type_equal) < 0) {
				exp_destroy(l);
				exp_destroy(r);
				return NULL;
			}
			e = exp_compare( l, r, cmp_equal );
			rel_join_add_exp(rel, e);
			if (sc->token == SQL_NOT_IN) {
				rel->op = op_left;
				e = rel_unop_(sql, exp_dup(r), NULL, "isnull");
				r = exp_atom_bool(1);
				e = exp_compare( e, r, cmp_equal);
				rel = rel_select(rel, e);
			}
			return rel;
		}
		return right;
	}
	case SQL_EXISTS:
	case SQL_NOT_EXISTS:
	{
		symbol *lo = sc->data.sym;
		sql_rel *r;

		ek.card = card_set;
		r = rel_subquery(sql, NULL, lo, ek);
		if (!r) {
			/* reset error */
			sql->session->status = 0;
			sql->errstr[0] = '\0';

			r = rel = rel_subquery(sql, rel, lo, ek);
			if (!rel)
				return NULL;
			/* remove extra projection */
			if (!is_join(r->op)) {
				sql_rel *p = r;

				assert(is_project(r->op));
				rel = r = rel_dup(r->l);
				rel_destroy(p);
			}
			assert(r->op == op_join);
		} else { 	/* no correlation */
			r = rel = rel_crossproduct(rel, r, op_join);
		}
		if (sc->token == SQL_EXISTS) {
			r->op = op_semi;
		} else {	
			r->op = op_anti;
		}
		return rel;
	}
	case SQL_LIKE:
	case SQL_NOT_LIKE:
	{
		symbol *lo = sc->data.lval->h->data.sym;
		symbol *ro = sc->data.lval->h->next->data.sym;
		sql_subtype *st = sql_bind_localtype("str");
		sql_exp *le = rel_value_exp(sql, &rel, lo, f, ek);
		sql_exp *re, *ee = NULL;

		if (!le)
			return NULL;

		if (!exp_subtype(le)) {
			exp_destroy(le);
			return sql_error(sql, 02, "SELECT: parameter not allowed on left hand of LIKE operator");
		}

		/* Do we need to escape ? */
		if (dlist_length(ro->data.lval) == 2) {
			char *escape = ro->data.lval->h->next->data.sval;
			ee = exp_atom(atom_string(st, _strdup(escape), 1));
		}
		ro = ro->data.lval->h->data.sym;
		re = rel_value_exp(sql, &rel, ro, f, ek);
		if (!re)
			return NULL;
		if (!exp_subtype(re)) {
			if (rel_set_type_param(sql, st, re) == -1) {
				exp_destroy(le);
				exp_destroy(re);
				return sql_error(sql, 02, "LIKE: wrong type, should be string");
			}
		} else if ((re = rel_check_type(sql, st, re, type_equal)) == NULL) {
			return sql_error(sql, 02, "LIKE: wrong type, should be string");
		}
		if ((le = rel_check_type(sql, st, le, type_equal)) == NULL) {
			exp_destroy(le);
			exp_destroy(re);
			return sql_error(sql, 02, "LIKE: wrong type, should be string");
		}
		if (sc->token == SQL_LIKE) 
			return rel_compare_exp(sql, rel, le, re, "l", ee, f);
		return rel_compare_exp(sql, rel, le, re, "n", ee, f);
	}
	case SQL_BETWEEN:
	case SQL_NOT_BETWEEN:
	{
		symbol *lo = sc->data.lval->h->data.sym;
		int symmetric = sc->data.lval->h->next->data.ival;
		symbol *ro1 = sc->data.lval->h->next->next->data.sym;
		symbol *ro2 = sc->data.lval->h->next->next->next->data.sym;
		sql_exp *le = rel_value_exp(sql, &rel, lo, f, ek);
		sql_exp *re1 = rel_value_exp(sql, &rel, ro1, f, ek);
		sql_exp *re2 = rel_value_exp(sql, &rel, ro2, f, ek);
		sql_subtype *ct = NULL;

		if (!le || !re1 || !re2) {
			exp_destroy(le);
			exp_destroy(re1);
			exp_destroy(re2);
			return NULL;
		}
		ct = exp_subtype(le);
		re1 = rel_check_type(sql, ct, re1, type_equal);
		re2 = rel_check_type(sql, ct, re2, type_equal);

		if (!re1 || !re2) {
			exp_destroy(le);
			exp_destroy(re1);
			exp_destroy(re2);
			return NULL;
		}

		if (symmetric) {
			sql_exp *tmp = NULL;
			sql_subfunc *min = sql_bind_func(sql->session->schema, "min", exp_subtype(re1), exp_subtype(re2));
			sql_subfunc *max = sql_bind_func(sql->session->schema, "max", exp_subtype(re1), exp_subtype(re2));

			if (!min || !max) {
				return sql_error(sql, 02, "min or max operator on types %s %s missing", exp_subtype(re1)->type->sqlname, exp_subtype(re2)->type->sqlname);
			}
			tmp = exp_binop(re1, re2, min);
			re2 = exp_binop(exp_dup(re1), exp_dup(re2), max);
			re1 = tmp;
		}

		if (sc->token == SQL_NOT_BETWEEN) {
			rel = rel_compare_exp(sql, rel, le, re1, "<", NULL, f);
			rel = rel_compare_exp(sql, rel, exp_dup(le), re2, ">", NULL, f);
		} else {
			rel = rel_compare_exp(sql, rel, le, re1, ">=", NULL, f);
			rel = rel_compare_exp(sql, rel, exp_dup(le), re2, "<=", NULL, f);
		}
		return rel;
	}
	case SQL_NULL:
	case SQL_NOT_NULL:
	/* is (NOT) NULL */
	{
		sql_exp *re, *le = rel_value_exp(sql, &rel, sc->data.sym, f, ek);

		if (!le)
			return NULL;
		le = rel_unop_(sql, le, NULL, "isnull");
		re = exp_atom_bool(1);
		if (sc->token == SQL_NULL) 
			le = exp_compare( le, re, cmp_equal);
		else
			le = exp_compare( le, re, cmp_notequal);
		return rel_select(rel, le);
	}
	case SQL_NOT: { 
		sql_exp *re, *le = rel_value_exp(sql, &rel, sc->data.sym, f, ek);

		if (!le)
			return NULL;
		le = rel_unop_(sql, le, NULL, "not");
		re = exp_atom_bool(1);
		le = exp_compare( le, re, cmp_equal);
		return rel_select(rel, le);
	}
	case SQL_ATOM: {
		/* TRUE or FALSE */
		AtomNode *an = (AtomNode *) sc;
		sql_exp *e = exp_atom(atom_dup(an->a));
		return rel_select(rel, e);
	} 
	case SQL_COLUMN: {
		sql_subtype bt; 
		sql_exp *e = rel_column_ref(sql, rel, sc);

		sql_find_subtype(&bt, "boolean", 0, 0);
		e = rel_check_type(sql, &bt, e, type_equal);
		if (!e)
			return NULL;
		return rel_select(rel, e);
	}
	case SQL_UNION:
	case SQL_EXCEPT:
	case SQL_INTERSECT: 
		return rel_setquery(sql, rel, sc);
	default:
		return sql_error(sql, 02, "Predicate %s %d: time to implement some more", token2string(sc->token), sc->token);
	}
	return sql_error(sql, 02, "Predicate: time to implement some more");
}

static sql_exp *
rel_op(mvc *sql, symbol *se )
{
	dnode *l = se->data.lval->h;
	sql_subfunc *f = NULL;
	char *fname = qname_fname(l->data.lval); 
	char *sname = qname_schema(l->data.lval);
	sql_schema *s = sql->session->schema;

	if (sname) 
		s = mvc_bind_schema(sql, sname);
	f = sql_bind_func(s, fname, NULL, NULL);
	if (f) {
		return exp_op(NULL, f);
	} else {
		return sql_error(sql, 02, 
			"SELECT: no such operator '%s'", fname);
	}
	return NULL;
}

sql_exp *
rel_unop_(mvc *sql, sql_exp *e, sql_schema *s, char *fname)
{
	sql_subfunc *f = NULL;
	sql_subtype *t = NULL;

	if (!s)
		s = sql->session->schema;
	t = exp_subtype(e);
	f = sql_bind_func(s, fname, t, NULL);
	/* try to find the function without a type, and convert
	 * the value to the type needed by this function!
	 */
	if (!f && (f = sql_find_func(s, fname, 1)) != NULL) {
		sql_arg *a = f->func->ops->h->data;

		e = rel_check_type(sql, &a->type, e, type_equal);
		if (!e) {
			sql_subfunc_destroy(f);
			f = NULL;
		}
	}
	if (f) {
		if (f->func->res.scale == INOUT) {
			f->res.digits = t->digits;
			f->res.scale = t->scale;
		}
		return exp_unop(e, f);
	} else if (e) {
		char *type = exp_subtype(e)->type->sqlname;

		exp_destroy(e);
		return sql_error(sql, 02, "SELECT: no such unary operator '%s(%s)'", fname, type);
	}
	return NULL;
}

static sql_exp *
rel_unop(mvc *sql, sql_rel **rel, symbol *se, int fs)
{
	dnode *l = se->data.lval->h;
	char *fname = qname_fname(l->data.lval); 
	char *sname = qname_schema(l->data.lval);
	sql_schema *s = sql->session->schema;
	exp_kind ek = {type_value, card_column, FALSE};
	sql_exp *e = rel_value_exp(sql, rel, l->next->data.sym, fs, ek);

	if (!e)
		return NULL;
	if (sname) 
		s = mvc_bind_schema(sql, sname);
	return rel_unop_(sql, e, s, fname);
}


sql_exp *
rel_binop_(mvc *sql, sql_exp *l, sql_exp *r, sql_schema *s, char *fname)
{
	sql_exp *res = NULL;
	sql_subtype *t1, *t2;
	sql_subfunc *f = NULL;

	t1 = exp_subtype(l);
	t2 = exp_subtype(r);

	if (!s)
		s = sql->session->schema;
	f = sql_bind_func(s, fname, t1, t2);
	if (!f && is_commutative(fname)) {
		f = sql_bind_func(s, fname, t2, t1);
		if (f) {
			sql_subtype *tmp = t1;
			t1 = t2;	
			t2 = tmp;
			res = l;		
			l = r;
			r = res;
		}
	}
	if (f) {
		if (f->func->res.scale == SCALE_FIX) {
			l = exp_fix_scale(sql, t2, l, 0, 0);
			r = exp_fix_scale(sql, t1, r, 0, 0);
		} else if (f->func->res.scale == SCALE_SUB) {
			l = exp_scale_algebra(sql, f, l, r);
		} else if (f->func->res.scale == SCALE_ADD) {
			l = exp_sum_scales(sql, f, l, r);
		} else if (f->func->res.scale == DIGITS_ADD) {
			f->res.digits = t1->digits + t2->digits;
		}
		return exp_binop(l, r, f);
	} else {
		int digits = t1->digits + t2->digits;
		sql_exp *ol = exp_dup(l);
		sql_exp *or = exp_dup(r);

		if ((f = sql_bind_member(s, fname, t1, 2)) != NULL) {
			/* try finding function based on first argument */
			node *m = f->func->ops->h;
			sql_arg *a = m->data;

			l = rel_check_type(sql, &a->type, l, type_equal);
			a = m->next->data;
			r = rel_check_type(sql, &a->type, r, type_equal);
			if (l && r) {
				exp_destroy(ol);
				exp_destroy(or);
				return exp_binop(l, r, f);
			}
		}
		/* reset error */
		sql->session->status = 0;
		sql->errstr[0] = '\0';

		if (l)
			exp_destroy(l);
		if (r)
			exp_destroy(r);
		l = ol;
		r = or;
		ol = exp_dup(l);
		or = exp_dup(r);
		/* try finding function based on both arguments */
		if (rel_convert_types(sql, &l, &r, 1/*fix scale*/, type_equal) >= 0){
			/* try operators */
			t1 = exp_subtype(l);
			t2 = exp_subtype(r);
			f = sql_bind_func(s, fname, t1, t2);
			if (f) {
				if (f->func->res.scale == SCALE_FIX) {
					l = exp_fix_scale(sql, t2, l, 0, 0);
					r = exp_fix_scale(sql, t1, r, 0, 0);
				} else if (f->func->res.scale == SCALE_SUB) {
					l = exp_scale_algebra(sql, f, l, r);
				} else if (f->func->res.scale == SCALE_ADD) {
					l = exp_sum_scales(sql, f, l, r);
				} else if (f->func->res.scale == DIGITS_ADD) {
					f->res.digits = digits;
				}
				exp_destroy(ol);
				exp_destroy(or);
				return exp_binop(l, r, f);
			}
		}
		/* reset error */
		sql->session->status = 0;
		sql->errstr[0] = '\0';

		if (l)
			exp_destroy(l);
		if (r)
			exp_destroy(r);
		l = ol;
		r = or;
		ol = exp_dup(l);
		or = exp_dup(r);

		/* everything failed, fall back to bind on function name only */
		if ((f = sql_find_func(s, fname, 2)) != NULL) {
			node *m = f->func->ops->h;
			sql_arg *a = m->data;

			l = rel_check_type(sql, &a->type, l, type_equal);
			a = m->next->data;
			r = rel_check_type(sql, &a->type, r, type_equal);
			if (l && r) 
				return exp_binop(l, r, f);
		}
	}
	if (r && l)
		res = sql_error(sql, 02, "SELECT: no such binary operator '%s(%s,%s)'", fname, exp_subtype(l)->type->sqlname, exp_subtype(r)->type->sqlname);
	if (l)
		exp_destroy(l);
	if (r)
		exp_destroy(r);
	return res;
}

#define SQLMAXDEPTH ((THREAD_STACK_SIZE/4096))

static sql_exp *
rel_binop(mvc *sql, sql_rel **rel, symbol *se, int f)
{
	dnode *dl = se->data.lval->h;
	sql_exp *l, *r;
	char *fname = qname_fname(dl->data.lval); 
	char *sname = qname_schema(dl->data.lval);
	sql_schema *s = sql->session->schema;
	exp_kind ek = {type_value, card_column, FALSE};

 	l = rel_value_exp(sql, rel, dl->next->data.sym, f, ek);
	r = rel_value_exp(sql, rel, dl->next->next->data.sym, f, ek);

	if (!l || !r) {
		if (l)
			exp_destroy(l);
		if (r)
			exp_destroy(r);
		return NULL;
	}

	if (sname) 
		s = mvc_bind_schema(sql, sname);
	return rel_binop_(sql, l, r, s, fname);
}

sql_exp *
rel_nop_(mvc *sql, sql_exp *a1, sql_exp *a2, sql_exp *a3, sql_exp *a4, sql_schema *s, char *fname)
{
	list *tl = list_create(NULL);
	sql_subfunc *f = NULL;

	append(tl, exp_subtype(a1));
	append(tl, exp_subtype(a2));
	append(tl, exp_subtype(a3));
	if (a4)
		append(tl, exp_subtype(a4));

	if (!s)
		s = sql->session->schema;
	f = sql_bind_func_(s, fname, tl);
	list_destroy(tl);
	if (f && !a4)
		return exp_op3(a1,a2,a3,f);
	if (f && a4)
		return exp_op4(a1,a2,a3,a4,f);
	return sql_error(sql, 02, "SELECT: no such operator '%s'", fname);
}

static sql_exp *
rel_nop(mvc *sql, sql_rel **rel, symbol *se, int fs)
{
	int nr_args = 0;
	dnode *l = se->data.lval->h;
	dnode *ops = l->next->data.lval->h;
	list *exps = new_exp_list();
	list *tl = list_create(NULL);
	sql_subfunc *f = NULL;
	sql_subtype *obj_type = NULL;
	char *fname = qname_fname(l->data.lval); 
	char *sname = qname_schema(l->data.lval);
	sql_schema *s = sql->session->schema;
	exp_kind ek = {type_value, card_column, FALSE};

	for (; ops; ops = ops->next, nr_args++) {
		sql_exp *e = rel_value_exp(sql, rel, ops->data.sym, fs, ek);
		sql_subtype *tpe;

		if (!e) {
			list_destroy(exps);
			return NULL;
		}
		append(exps, e);
		tpe = exp_subtype(e);
		if (!nr_args)
			obj_type = tpe;
		append(tl, tpe);
	}
	if (sname) 
		s = mvc_bind_schema(sql, sname);
	f = sql_bind_func_(s, fname, tl);
	list_destroy(tl);
	if (f) {
		return exp_op(exps, f);
	} else if ((f = sql_bind_member(s, fname, obj_type, nr_args)) != NULL ||
		   (f = sql_find_func(s, fname, nr_args)) != NULL) {
		node *n, *m;
		list *nexps = new_exp_list();

		for (n = exps->h, m = f->func->ops->h; n && m; 
				  n = n->next, m = m->next) {
			sql_arg *a = m->data;
			sql_exp *e = exp_dup(n->data);

			e = rel_check_type(sql, &a->type, e, type_equal);
			if (!e) {
				list_destroy(nexps);
				nexps = NULL;
				break;
			}
			append(nexps, e);
		}
		if (nexps) {
			list_destroy(exps);
			return exp_op(nexps, f);
		}
	}
	list_destroy(exps);
	return sql_error(sql, 02, "SELECT: no such operator '%s'", fname);
}

static sql_exp *
rel_aggr(mvc *sql, sql_rel **rel, symbol *se, int f)
{
	dlist *l = se->data.lval;
	sql_subaggr *a = NULL;
	int distinct = l->h->next->data.ival;
	char *aggrstr = l->h->data.sval;
	sql_exp *e = NULL, *exp = NULL;
	sql_rel *groupby, *old;
	int no_nil = 0;

	groupby = *rel;

	if (groupby->l && groupby->op == op_project) {
		sql_rel *r = groupby->l;	
		if (r->op == op_groupby) {
			groupby = r;
		} else if (r->op == op_select && r->l) {  
			/* a having after a groupby */
			r = r->l;
			if (r->op == op_groupby)
				groupby = r;
		}
	}

	if (groupby->op != op_groupby)   	/* implicite groupby */
		*rel = rel_project2groupby(sql, &groupby);
 	old = *rel; 
	if (!old)
		return NULL;

	if (f == sql_where && !groupby) 
		return sql_error(sql, 02, "%s: not allowed in WHERE clause", toUpper(alloca(strlen(aggrstr) + 1), aggrstr));
	
	if (!l->h->next->next->data.sym) {	/* count(*) case */

		if (strcmp(aggrstr, "count") != 0) {
			return sql_error(sql, 02, "%s: unable to perform '%s(*)'", toUpper(alloca(strlen(aggrstr) + 1), aggrstr), aggrstr);
		}
		a = sql_bind_aggr(sql->session->schema, aggrstr, NULL);
		/* add aggr expression to the groupby, and return a 
			column expression */
		e = exp_aggr(NULL, a, distinct, 0, groupby->card);
		if (*rel == groupby && f == sql_sel) /* selection */ 
			return e;
		return rel_groupby_add_aggr(sql, groupby, e);
	} else {
		exp_kind ek = {type_value, card_column, FALSE};

		/* use cnt as nils shouldn't be counted */
		sql_rel *gr = groupby->l;

		no_nil = 1;
		e = rel_value_exp(sql, &gr, l->h->next->next->data.sym, f, ek);
		groupby->l = gr;
	}

	if (!e)
		return NULL;
	a = sql_bind_aggr(sql->session->schema, aggrstr, exp_subtype(e));
	if (a) {
		/* type may have changed, ie. need to fix_scale */
		sql_subtype *t = exp_subtype(e);

		e = exp_aggr1(e, a, distinct, no_nil, groupby->card);
		exp = e;
		if (*rel != old)
			exp = rel_groupby_add_aggr(sql, *rel, exp);
		else if (*rel != groupby || f != sql_sel) /* selection */ 
			exp = rel_groupby_add_aggr(sql, groupby, exp);
		return exp_fix_scale(sql, t, exp, 1, 
					(t->type->scale == SCALE_FIX));
	} else {
		char *type = exp_subtype(e)->type->sqlname;

		exp_destroy(e);
		return sql_error(sql, 02, "%s: no such operator '%s(%s)'", toUpper(alloca(strlen(aggrstr) + 1), aggrstr), aggrstr, type);
	}
	return NULL;
}

static sql_exp *
rel_case(mvc *sql, sql_rel **rel, int token, symbol *opt_cond, dlist *when_search_list, symbol *opt_else, int f)
{
	sql_subtype *tpe = NULL;
	list *conds = new_exp_list();
	list *results = new_exp_list();
	dnode *dn = when_search_list->h;
	sql_subtype *restype = NULL, rtype;
	sql_exp *res = NULL, *else_exp = NULL;
	node *n, *m;
	exp_kind ek = {type_value, card_column, FALSE};

	if (dn) {
		sql_exp *cond = NULL, *result = NULL;

		/* NULLIF(e1,e2) == CASE WHEN e1=e2 THEN NULL ELSE e1 END */
		if (token == SQL_NULLIF) {
			sql_exp *e1, *e2;

			e1 = rel_value_exp(sql, rel, dn->data.sym, f, ek);
			e2 = rel_value_exp(sql, rel, dn->next->data.sym, f, ek);
			if (e1 && e2) {
				cond = rel_binop_(sql, exp_dup(e1), e2, NULL, "=");
				result = exp_atom(atom_general(exp_subtype(e1), NULL, 0));
				else_exp = e1;	/* ELSE case */
			} else {
				if (e1)
					exp_destroy(e1);
				if (e2)
					exp_destroy(e2);
			}
			/* COALESCE(e1,e2) == CASE WHEN e1 
			   IS NOT NULL THEN e1 ELSE e2 END */
		} else if (token == SQL_COALESCE) {
			cond = rel_value_exp(sql, rel, dn->data.sym, f, ek);

			if (cond) {
				result = exp_dup(cond);
				cond = rel_unop_(sql, rel_unop_(sql, cond, NULL, "isnull"), NULL, "not");
			}
		} else {
			dlist *when = dn->data.sym->data.lval;

			if (opt_cond) {
				sql_exp *l = rel_value_exp(sql, rel, opt_cond, f, ek);
				sql_exp *r = rel_value_exp(sql, rel, when->h->data.sym, f, ek);
				if (!l || !r || rel_convert_types(sql, &l, &r, 1, type_equal) < 0) {
					exp_destroy(l);
					exp_destroy(r);
					return NULL;
				}
				cond = rel_binop_(sql, l, r, NULL, "=");
			} else {
				cond = rel_logical_value_exp(sql, rel, when->h->data.sym, sql_sel);
			}
			result = rel_value_exp(sql, rel, when->h->next->data.sym, f, ek);
		}
		if (!cond || !result) {
			list_destroy(conds);
			list_destroy(results);
			return NULL;
		}
		list_prepend(conds, cond);
		list_prepend(results, result);

		restype = exp_subtype(result);

		if (token == SQL_NULLIF)
			dn = NULL;
		else
			dn = dn->next;
	}
	if (!restype) {
		list_destroy(conds);
		list_destroy(results);
		return sql_error(sql, 02, "result type missing");
	}
	/* for COALESCE we skip the last (else part) */
	for (; dn && (token != SQL_COALESCE || dn->next); dn = dn->next) {
		sql_exp *cond = NULL, *result = NULL;

		if (token == SQL_COALESCE) {
			cond = rel_value_exp(sql, rel, dn->data.sym, f, ek);

			if (cond) {
				result = exp_dup(cond);
				cond = rel_unop_(sql, rel_unop_(sql, cond, NULL, "isnull"), NULL, "not");
			}
		} else {
			dlist *when = dn->data.sym->data.lval;

			if (opt_cond) {
				sql_exp *l = rel_value_exp(sql, rel, opt_cond, f, ek);
				sql_exp *r = rel_value_exp(sql, rel, when->h->data.sym, f, ek);
				if (!l || !r || rel_convert_types(sql, &l, &r, 1, type_equal) < 0) {
					exp_destroy(l);
					exp_destroy(r);
					return NULL;
				}
				cond = rel_binop_(sql, l, r, NULL, "=");
			} else {
				cond = rel_logical_value_exp(sql, rel, when->h->data.sym, sql_sel);
			}
			result = rel_value_exp(sql, rel, when->h->next->data.sym, sql_sel, ek);
		}
		if (!cond || !result) {
			list_destroy(conds);
			list_destroy(results);
			return NULL;
		}
		list_prepend(conds, cond);
		list_prepend(results, result);

		tpe = exp_subtype(result);
		if (!tpe) {
			list_destroy(conds);
			list_destroy(results);
			return sql_error(sql, 02, "result type missing");
		}
		supertype(&rtype, restype, tpe);
		if (!tpe) {
			list_destroy(conds);
			list_destroy(results);
			return sql_error(sql, 02, "result types %s,%s of case are not compatible", restype->type->sqlname, tpe->type->sqlname);
		}
		restype = &rtype;
	}
	if (opt_else || else_exp) {
		sql_exp *result = else_exp;

		if (!result)
			result = rel_value_exp(sql, rel, opt_else, f, ek);

		tpe = exp_subtype(result);
		if (tpe && restype) {
			supertype(&rtype, restype, tpe);
			tpe = &rtype;
		}
		restype = tpe;

		if (!result || !(result = rel_check_type(sql, restype, result, type_equal))) {
			list_destroy(conds);
			list_destroy(results);
			return NULL;
		}

		if (res)
			exp_destroy(res);
		res = result;

		if (!res) {
			list_destroy(conds);
			list_destroy(results);
			return NULL;
		}
	} else {
		sql_exp *a = exp_atom(atom_general(restype, NULL, 0));

		res = a;
	}

	for (n = conds->h, m = results->h; n && m; n = n->next, m = m->next) {
		sql_exp *cond = exp_dup(n->data);
		sql_exp *result = exp_dup(m->data);

		if (!(result = rel_check_type(sql, restype, result, type_equal))) {
			list_destroy(conds);
			list_destroy(results);
			exp_destroy(res);
			return NULL;
		}

		res = rel_nop_(sql, cond, result, res, NULL, NULL, "ifthenelse" );
		if (!res) { 
			list_destroy(conds);
			list_destroy(results);
			exp_destroy(res);
			return NULL;
		}
	}
	list_destroy(conds);
	list_destroy(results);
	return res;
}

static sql_exp *
rel_case_exp(mvc *sql, sql_rel **rel, symbol *se, int f)
{
	dlist *l = se->data.lval;

	if (se->token == SQL_COALESCE) {
		symbol *opt_else = l->t->data.sym;

		return rel_case(sql, rel, se->token, NULL, l, opt_else, f);
	} else if (se->token == SQL_NULLIF) {
		return rel_case(sql, rel, se->token, NULL, l, NULL, f);
	} else if (l->h->type == type_list) {
		dlist *when_search_list = l->h->data.lval;
		symbol *opt_else = l->h->next->data.sym;

		return rel_case(sql, rel, SQL_CASE, NULL, when_search_list, opt_else, f);
	} else {
		symbol *scalar_exp = l->h->data.sym;
		dlist *when_value_list = l->h->next->data.lval;
		symbol *opt_else = l->h->next->next->data.sym;

		return rel_case(sql, rel, SQL_CASE, scalar_exp, when_value_list, opt_else, f);
	}
}

static sql_exp *
rel_cast(mvc *sql, sql_rel **rel, symbol *se, int f)
{

	dlist *dl = se->data.lval;
	symbol *s = dl->h->data.sym;
	sql_subtype *tpe = &dl->h->next->data.typeval;
	exp_kind ek = {type_value, card_column, FALSE};
	sql_exp *e = rel_value_exp(sql, rel, s, f, ek);

	if (!e)
		return NULL;
	/* strings may need too be truncated */
	if (tpe ->type ->localtype == TYPE_str) { 
		if (tpe->digits > 0) {
			sql_subtype *et = exp_subtype(e);
			sql_subtype *it = sql_bind_localtype("int");
			sql_subfunc *c = sql_bind_func(sql->session->schema, "truncate", et, it);
			if (c)
				e = exp_binop(e, exp_atom_int(tpe->digits), c);
		}
	}
	if (e)
		return rel_check_type(sql, tpe, e, type_cast);
	return NULL;
}

static sql_exp *
rel_next_value_for( mvc *sql, symbol *se )
{
	char *seq = qname_table(se->data.lval);
	char *sname = qname_schema(se->data.lval);
	sql_schema *s = NULL;
	sql_subtype t;
	sql_subfunc *f;

	if (sname && !(s = mvc_bind_schema(sql, sname)))
		return sql_error(sql, 02, 
			"NEXT VALUE FOR: no such schema '%s'", sname);
	if (!s)
		s = sql->session->schema;

	if (!find_sql_sequence(s, seq)) 
		return sql_error(sql, 02, "NEXT VALUE FOR: "
			"no such sequence '%s'.'%s'", s->base.name, seq);
        sql_find_subtype(&t, "varchar", 0, 0);
	f = sql_bind_func(s, "next_value_for", &t, &t);
	assert(f);
	return exp_binop(exp_atom_str(s->base.name, &t), 
			 exp_atom_str(seq, &t), f);
} 

static sql_exp *
rel_table_func_exp(mvc *sql, sql_rel **rel, symbol *sym, exp_kind ek ) 
{
	*rel = rel_subquery(sql, *rel, sym, ek);

	if (*rel)
		return rel_lastexp(sql, *rel);
	return NULL;
}

/* some users like to use aliases allready in the groupby */
sql_exp *
rel_selection_ref(mvc *sql, sql_rel *rel, symbol *grp, dlist *selection )
{
	dnode *n;
	dlist *gl = grp->data.lval;
	char *name = NULL;
	exp_kind ek = {type_value, card_column, FALSE};

	if (dlist_length(gl) > 1)
		return NULL;
	if (!selection)
		return NULL;

	name = gl->h->data.sval;
	for (n = selection->h; n; n = n->next) {
		/* we only look for columns */
		if (n->data.sym->token == SQL_COLUMN) {
			dlist *l = n->data.sym->data.lval;
			/* AS name */ 
			if (l->h->next->data.sval &&
			    strcmp(l->h->next->data.sval, name) == 0){
				sql_exp *ve = rel_value_exp(sql, &rel, l->h->data.sym, sql_sel, ek);
				if (ve) {
					dlist *l = dlist_create(sql->sa);
					symbol *sym;
					exp_setname(ve, NULL, name);
					/* now we should rewrite the selection
					   such that it uses the new group
					   by column 
					*/
					dlist_append_string(sql->sa, l,  
						sa_strdup(sql->sa, name));
					sym = symbol_create_list(sql->sa, SQL_COLUMN, l);
					l = dlist_create(sql->sa);
					dlist_append_symbol(sql->sa, l, sym);
					/* no alias */
					dlist_append_symbol(sql->sa, l, NULL);
					n->data.sym = symbol_create_list(sql->sa, SQL_COLUMN, l);
				
				}
				return ve;
			}
		}
	}
	return NULL;
}

static list *
rel_group_by(mvc *sql, sql_rel *rel, symbol *groupby, dlist *selection )
{
	dnode *o = groupby->data.lval->h;
	list *exps = new_exp_list();

	for (; o; o = o->next) {
		symbol *grp = o->data.sym;
		sql_exp *e = rel_column_ref(sql, rel, grp);

		if (!e) {
			/* reset error */
			sql->session->status = 0;
			sql->errstr[0] = '\0';

			e = rel_selection_ref(sql, rel, grp, selection);
			if (!e) {
				list_destroy(exps);
				return NULL;
			}
		}
		append(exps, e);
	}
	return exps;
}

/* find selection expressions matching the order by column expression */

/* first limit to simple columns only */
static sql_exp *
rel_order_by_column_exp(mvc *sql, sql_rel *r, symbol *column_r)
{
	dlist *l = column_r->data.lval;

	assert(column_r->token == SQL_COLUMN && column_r->type == type_list);

	assert(is_project(r->op));
	r = r->l;
	if (dlist_length(l) == 1) {
		char *name = l->h->data.sval;
		return rel_bind_column(sql, r, name);
	}
	if (dlist_length(l) == 2) {
		char *tname = l->h->data.sval;
		char *name = l->h->next->data.sval;

		return rel_bind_column2(sql, r, tname, name);
	}
	return sql_error(sql, 02, "ORDER BY: absolute column names not supported");
}

static list *
rel_order_by(mvc *sql, sql_rel *rel, symbol *orderby )
{
	list *exps = new_exp_list();
	dnode *o = orderby->data.lval->h;

	for (; o; o = o->next) {
		symbol *order = o->data.sym;

		if (order->token == SQL_COLUMN) {
			symbol *col = order->data.lval->h->data.sym;
			int direction = order->data.lval->h->next->data.ival;
			sql_exp *e = rel_column_ref(sql, rel, col);

			if (!e) {
				/* reset error */
				sql->session->status = 0;
				sql->errstr[0] = '\0';

				e = rel_order_by_column_exp(sql, rel, col);
			}

			if (!e) {
				list_destroy(exps);
				return NULL;
			}
			set_direction(e, direction);
			append(exps, e);
		} else {
			return sql_error(sql, 02, "order not of type SQL_COLUMN\n");
		}
	}
	return exps;
}

/* window functions */
static sql_exp *
rel_rankop(mvc *sql, sql_rel **rel, symbol *se, int f)
{
	dlist *l = se->data.lval;
	symbol *window_function = l->h->data.sym;
	dlist *window_specification = l->h->next->data.lval;
	char *aggrstr = NULL;
	sql_subfunc *wf = NULL;
	sql_exp *e = NULL;
	sql_rel *r = *rel;
	list *gbe = NULL, *obe = NULL;
	sql_subtype *idtype = sql_bind_localtype("oid");
	
	if (window_function->token == SQL_RANK) {
		aggrstr = window_function->data.sval;
	} else { /* window aggr function */
		aggrstr = window_function->data.lval->h->data.sval;
	}

	if (f == sql_where) 
		return sql_error(sql, 02, "%s: not allowed in WHERE clause", toUpper(alloca(strlen(aggrstr) + 1), aggrstr));

	/* window operations are only allowed in the projection */
	if (r->op != op_project)
		return sql_error(sql, 02, "OVER: only possible within the selection");

	/* Partition By */
	if (window_specification->h->data.sym) {
		gbe = rel_group_by(sql, r, window_specification->h->data.sym, NULL /* cannot use (selection) column references, as this result is a selection column */ );
		if (!gbe)
			return NULL;
	}
	/* Order By */
	if (window_specification->h->next->data.sym) {
		obe = rel_order_by(sql, r, window_specification->h->next->data.sym);
		if (!obe)
			return NULL;
	}
	wf = sql_bind_func(sql->session->schema, aggrstr, idtype, NULL);
	if (!wf)
		return sql_error(sql, 02, "SELECT: function '%s' not found", aggrstr );
	/* now we need the gbe and obe lists */
	e = exp_op(gbe, wf);
	if (obe) 
		e->r = obe;
	else 	/* e->r specifies window expression */
		e->r = obe = new_exp_list(); 
	return e;
}


sql_exp *
rel_value_exp(mvc *sql, sql_rel **rel, symbol *se, int f, exp_kind ek)
{
	if (!se)
		return NULL;

	switch (se->token) {
	case SQL_OP:
		return rel_op(sql, se );
	case SQL_UNOP:
		return rel_unop(sql, rel, se, f);
	case SQL_BINOP:
		return rel_binop(sql, rel, se, f);
	case SQL_NOP:
		return rel_nop(sql, rel, se, f);
	case SQL_AGGR:
		return rel_aggr(sql, rel, se, f);
	case SQL_RANK:
		return rel_rankop(sql, rel, se, f);
	case SQL_COLUMN:
		return rel_column_ref(sql, *rel, se );
	case SQL_NAME:
		return rel_var_ref(sql, se->data.sval, 1);
	case SQL_SELECT: {
		sql_rel *r;

		r = rel_subquery(sql, NULL, se, ek);
		if (r) {
			sql_exp *e;

			rel_setsubquery(r);
			e = rel_lastexp(sql, r); 

			/* group by needed ?? */
			if (e->card > CARD_ATOM) {
				sql_subaggr *zero_or_one = sql_bind_aggr(sql->session->schema, "zero_or_one", exp_subtype(e));

				e = exp_aggr1(e, zero_or_one, 0, 0, CARD_ATOM);
			}
			if (*rel) {
				/* current projection list */
				list *pre_proj = rel_projections(sql, *rel, NULL, 1);
				sql_rel *p = rel_dup((*rel)->l);

				rel_destroy(*rel);
				*rel = rel_crossproduct(p, r, op_join);
				*rel = rel_project(*rel, pre_proj);
				return rel_lastexp(sql, r);
			} else {
				*rel = r;
			}
			return e;
		}
		if (!r) {
			if (!*rel)
				return NULL;

			/* reset error */
			sql->session->status = 0;
			sql->errstr[0] = '\0';

			*rel = r = rel_subquery(sql, *rel, se, ek);
		}
		if (!r)
			return NULL;
		return rel_lastexp(sql, *rel);
	}
	case SQL_TABLE:  
		/* turn a subquery into a tabular result */
		return rel_table_func_exp(sql, rel, se->data.sym, ek);
	case SQL_PARAMETER:{
		if (sql->mode != m_prepare) 
			return sql_error(sql, 02, "SELECT: parameters ('?') not allowed in normal queries, use PREPARE");
		return exp_atom_ref(se->data.ival, NULL);
	}
	case SQL_NULL:
		return exp_atom(atom_general(sql_bind_localtype("str"), NULL, 0));
	case SQL_ATOM:{
		AtomNode *an = (AtomNode *) se;

		if (!an || !an->a) {
			return exp_atom(atom_general(sql_bind_localtype("str"), NULL, 0));
		} else {
			return exp_atom(atom_dup(an->a));
		}
	}
		break;
	case SQL_NEXT:
		return rel_next_value_for(sql, se);
	case SQL_CAST:
		return rel_cast(sql, rel, se, f);
	case SQL_CASE:
	case SQL_COALESCE:
	case SQL_NULLIF:
		return rel_case_exp(sql, rel, se, f);
	case SQL_XMLELEMENT:
	case SQL_XMLFOREST:
	case SQL_XMLCOMMENT:
	case SQL_XMLATTRIBUTE:
	case SQL_XMLCONCAT:
	case SQL_XMLDOCUMENT:
	case SQL_XMLPI:
	case SQL_XMLTEXT:
		return rel_xml(sql, rel, se, f, ek);
	default: 
		return rel_logical_value_exp(sql, rel, se, f);
	}
	return NULL;
}

static sql_exp *
column_exp(mvc *sql, sql_rel **rel, symbol *column_e, int f)
{
	dlist *l = column_e->data.lval;
	exp_kind ek = {type_value, card_column, FALSE};
	sql_exp *ve = rel_value_exp(sql, rel, l->h->data.sym, f, ek);

	if (!ve)
		return NULL;
	/* AS name */
	if (ve && l->h->next->data.sval) 
		exp_setname(ve, NULL, l->h->next->data.sval);
	return ve;
}

static list *
rel_table_exp(mvc *sql, sql_rel *rel, symbol *column_e )
{
	if (column_e->token == SQL_TABLE) {
		char *tname = column_e->data.lval->h->data.sval;
		sql_rel *p, *r = rel_bind_table(&p, rel, tname);

		(void)p;
		if (r) 
			return rel_projections(sql, r, tname, 1 );
		return sql_error(sql, 02, 
			"Column expression Table '%s' unknown", tname);
	}
	return NULL;
}

static sql_exp *
rel_column_exp(mvc *sql, sql_rel **rel, symbol *column_e, int f)
{
	if (column_e->token == SQL_COLUMN) {
		return column_exp(sql, rel, column_e, f);
	}
	return NULL;
}

static sql_rel *
rel_simple_select(mvc *sql, sql_rel *rel, symbol *where, dlist *selection)
{
	dnode *n = selection->h;

	(void) where;
	if (where) {
		sql_rel *r = rel_logical_exp(sql, rel, where, sql_where);
		if (!r)
			return NULL;
		rel = r;
	}
	if (!rel || rel->op != op_project)
		rel = rel_project(rel, new_exp_list());
	for (; n; n = n->next ) {
		/* Here we could get real column expressions (including single
		 * atoms) but also table results. Therefor we try both
		 * rel_column_exp and rel_table_exp.
		 */
		list *te = NULL; 
		sql_exp *ce = rel_column_exp(sql, &rel, n->data.sym, sql_sel);

		if (ce && exp_subtype(ce)) {
			/* new relational, we need to rewrite */
			rel_project_add_exp(sql, rel, ce);
			continue;
		} else if (!ce) {
			te = rel_table_exp(sql, rel, n->data.sym );
		} else {
			exp_destroy(ce);
			ce = NULL;
		}
		if (!ce && !te) 
			return sql_error(sql, 02, "SELECT: subquery result missing");
		/* here we should merge the column expressions we obtained
		 * sofar with the table expression, ie t1.* or a subquery 
		 */
		if (te) {
			list_merge( rel->exps, te, (fdup)&exp_dup);
			list_destroy(te);
		}
	}
	if (rel)
		set_processed(rel);
	return rel;
}

static sql_rel *
join_on_column_name(mvc *sql, sql_rel *rel, sql_rel *t1, sql_rel *t2, int all)
{
	int found = 0;
	list *exps = rel_projections(sql, t1, NULL, 1);
	list *outexps = new_exp_list();
	node *n;

	if (!exps)
		return NULL;
	for (n = exps->h; n; n = n->next) {
		sql_exp *lc = n->data;
		char *nm = lc->name;
		sql_exp *rc = rel_bind_column(sql, t2, nm);

		if (rc) {
			sql_exp *cond;
			found = 1;
			rel = rel_compare_exp(sql, rel, exp_dup(lc), exp_dup(rc), "=", NULL, sql_where);
			cond = rel_unop_(sql, exp_dup(lc), NULL, "isnull");
			lc = rel_nop_(sql, cond, exp_dup(rc), exp_dup(lc), NULL, NULL, "ifthenelse");
			exp_setname(lc, NULL, nm);
			append(outexps, lc);
		} else if (all) {
			found = 0;
			break;
		}
	}
	list_destroy(exps);
	if (!found) {
		list_destroy(outexps);
		sql_error(sql, 02, "JOIN: no columns of tables '%s' and '%s' match", rel_get_name(t1)?rel_get_name(t1):"", rel_get_name(t2)?rel_get_name(t2):"");
		rel_destroy(rel);
		return NULL;
	}
	return rel_project(rel, outexps);
}


sql_rel *exp_top_relation(sql_exp *e )
{
	switch(e->type) {	
	case e_atom:
		return NULL;
	case e_convert: 
	case e_cmp:
		if (e->l)
			return exp_top_relation(e->l);
		break;
	case e_column:
	default:
		return NULL;
	}
	return NULL;
}

static int
check_correlation_exps( list *exps )
{
	node *n;

	for (n = exps->h; n; n = n->next) {
		sql_exp *e = n->data;
		if (e->type != e_cmp || e->flag != cmp_equal)
			return -1;
	}
	return 0;
}

static sql_rel *
rel_select_exp(mvc *sql, sql_rel *rel, sql_rel *outer, SelectNode *sn, exp_kind ek)
{
	int aggr = 0;
	list *jexps = NULL;
	list *pre_prj = NULL;
	list *outer_gbexps = NULL;
	sql_rel *inner = NULL;
	int decorrelated = 0;

	if (!sn->from)
		return rel_simple_select(sql, rel, sn->where, sn->selection);

	/* if within the selection, keep the current projections */
	if (outer && is_project(outer->op) && !is_processed(outer)) {
		assert(rel->l == outer);
		pre_prj = rel_projections(sql, outer, NULL, 1);
		rel->l = rel_dup(outer->l);
		rel_destroy(outer);
		outer = rel->l;
	}

	if (sn->where) {
		sql_rel *r = rel_logical_exp(sql, rel, sn->where, sql_where);
		if (!r) 
			return sql_error(sql, 02, "Subquery result missing");
		rel = r;
	}

	if (rel) {
		if (rel && sn->groupby) {
			list *gbe = rel_group_by(sql, rel, sn->groupby,sn->selection);

			if (!gbe) 
				return NULL;
			rel = rel_groupby(rel, gbe);
			aggr = 1;
		}

		/* decorrelate if possible */

		/* TODO if ek.card == card_set (IN/EXISTS etc), we could do 
			something less expensive as group by's ! */
		if (outer && rel->op == op_join && rel->l == outer) {
			node *n;
			/* correlation expressions */
			list *ce = list_select(rel->exps, rel, (fcmp) &exp_is_correlation, (fdup)&exp_dup);

			if (!ce || list_length(ce) == 0 || check_correlation_exps(ce) != 0) {
				list_destroy(ce);
				if (ek.card != card_set) {
					node *n;
					/* group by on identity */
					sql_exp *e;

					outer_gbexps = rel_projections(sql, outer, NULL, 1);
					if (!is_project(outer->op)) 
						rel->l = outer = rel_project(outer, rel_projections(sql, outer, NULL, 1));
 					e = rel_unop_(sql, exp_dup(outer->exps->h->data), NULL, "identity");
					rel_project_add_exp(sql, outer, e);
					set_processed(outer);
					e = rel_lastexp(sql, outer);

					assert(pre_prj != NULL); 
					for(n = pre_prj->h; n; n = n->next) {
						sql_exp *e = n->data;
						e->card = CARD_AGGR;
					}
					rel = rel_groupby_gbe(rel, e); 
				}
			} else {
				list *gbexps = new_exp_list();

				decorrelated = 1;
				jexps = new_exp_list();
				for (n = ce->h; n; n = n->next) {
					sql_exp *e = n->data;
		
					/* add right expressions to the 
				   	group by exps */
					append(gbexps, exp_dup(e->r));
				}
	
				/* now create a groupby on the inner */
				inner = rel_groupby(rel_dup(rel->r), gbexps);
				rel_label(inner, ++sql->label);
				for (n = ce->h; n; n = n->next) {
					sql_exp *e = n->data;
					sql_exp *re = e->r;
	
					assert(e->type == e_cmp);
					assert(re->type == e_column);
					re = exp_column(inner->name, re->r, exp_subtype(re), inner->card);
					e = exp_compare( exp_dup(e->l), re, e->flag);
					append(jexps, e);
				}
				outer = rel_dup(outer);
				rel_destroy(rel);
				rel = inner;
				inner = NULL;
				list_destroy(ce);
			}
		}
	}

	if (sn->having) {
		/* having implies group by, ie if not supplied do a group by */
		if (rel->op != op_groupby) 
			rel = rel_groupby( rel, NULL);

		inner = rel;
		aggr = 1;
		rel = rel_logical_exp(sql, rel, sn->having, sql_having);

		if (!rel) 
			return NULL;
		if (rel -> exps && exps_card(rel->exps) > CARD_AGGR) {
			/* clean up missing */
			return sql_error(sql, 02, "SELECT: cannot compare sets with values, probably an aggregate function missing");
		}
	}

	if (sn->selection) {
		dnode *n = sn->selection->h;

		if (!outer || (!decorrelated && ek.card == card_set)) {
			if (outer) /* for non decorrelated or card_set sub
				      queries we project all of the outer */
				rel = rel_project(rel, 
					rel_projections(sql, outer, NULL, 1));
			else
				rel = rel_project(rel, new_exp_list());
		}
		/* when we have a 'having clause' we need to lift  the 
		   group by expressions and aggregates to the outer project */
		if (!inner)
			inner = rel;
		for (; n; n = n->next) {
			/* Here we could get real column expressions 
			 * (including single atoms) but also table results. 
			 * Therefor we try both rel_column_exp 
			 * and rel_table_exp.

			 * TODO 
				the rel_table_exp should simply return a new 
				relation
		 	 */
			list *te = NULL; 
			sql_rel *o_inner = inner;
			sql_exp *ce = rel_column_exp(sql, &inner, n->data.sym, sql_sel);

			if (inner != o_inner) /* relation got rewritten */
				rel = inner;
			if (ce && exp_subtype(ce)) {
				if (rel->card < ce->card) {
					/* This doesn't work without de-correlations, ie in that case it should be done later */
					if (outer) {
						sql_subaggr *zero_or_one = sql_bind_aggr(sql->session->schema, "zero_or_one", exp_subtype(ce));

						ce = exp_aggr1(ce, zero_or_one, 0, 0, rel->card);
				
					} else if (ce->name) {
						return sql_error(sql, 02, "SELECT: cannot use non GROUP BY column '%s' in query results without an aggregate function", ce->name);
					} else {
						return sql_error(sql, 02, "SELECT: cannot use non GROUP BY column in query results without an aggregate function");
					}
				}
				if (sn->having) {
					ce = rel_groupby_add_aggr(sql, inner, ce);
					rel_project_add_exp(sql, rel, ce);
				} else {
					/* 
					   because of the selection, the inner
					   relation may change.
					   We try hard to keep a projection
					   around this inner relation.
					*/
					rel_project_add_exp(sql, inner, ce);
					rel = inner;
				}
				continue;
			} else if (!ce) {
				te = rel_table_exp(sql, rel, n->data.sym);
			} else {
				exp_destroy(ce);
				ce = NULL;
			}
			if (!ce && !te) 
				return sql_error(sql, 02, "SELECT: subquery result missing");
			/* here we should merge the column expressions we 
			 * obtained sofar with the table expression, ie 
			 * t1.* or a subquery.
		 	 */
			list_merge( rel->exps, te, (fdup)&exp_dup);
			list_destroy(te);
		}
	} else {
		/* select * from tables */
		if (aggr) {
			rel_destroy(rel);
			return sql_error(sql, 02, "SELECT: cannot combine '*' with GROUP BY");
		}

		if (!outer && !is_project(rel->op)) {
			rel = rel_project(rel, rel_projections(sql, rel, NULL, 1));
		} else {
			/* 
			 * subquery can only return one column
			 */
		}
	}

	if (rel)
		set_processed(rel);

	if (rel && sn->distinct) 
		rel = rel_distinct(rel);

	if (outer && jexps) {
		rel = rel_crossproduct(outer, rel, op_join);
		rel_join_add_exps(rel, jexps );
		if (pre_prj) {
			list *exps = rel_projections(sql, outer, NULL, 1);
			sql_exp *e = rel_lastexp(sql, rel->r);

			rel = rel_project(rel, exps);
			rel_project_add_exp(sql, rel, e);
			set_processed(rel);
		}
	}

	/* Joins within the selection should recreate the projection 
	   and use an outer join */
	if (outer && pre_prj) {
		sql_rel *l;
		node *n;

		if (outer_gbexps) {
			assert(is_groupby(rel->op));

			/* merge the expressions of the correlated outer, ie
		   	   first prepend the identity then append 
		    	   the result expression.  */ 
			for (n=rel->exps->h; n && n->next; n = n->next) 
				list_prepend(outer_gbexps, exp_dup(n->data));
			list_append(outer_gbexps, exp_dup(n->data));
			list_destroy(rel->exps);
			rel->exps = outer_gbexps;
		}
		l = rel = rel_project(rel, pre_prj);
		while(l && l->op != op_join) 
			l = l->l;
		if (l && l->op == op_join && l->l == outer)
			l->op = op_left;
	}

	if (rel && sn->orderby) {
		list *obe = rel_order_by(sql, rel, sn->orderby);

		if (!obe)
			return NULL;
		rel = rel_orderby(sql, rel, obe);
	}
	if (!rel) 
		return NULL;

	if (sn->limit > 0 || sn->offset > 0) {
		list *exps = new_exp_list();

		append(exps, exp_atom_int(sn->limit));
		if (sn->offset > 0)
			append(exps, exp_atom_int(sn->offset));
		rel = rel_topn(rel, exps);
	}
	return rel;
}


sql_rel *
rel_query(mvc *sql, sql_rel *rel, symbol *sq, int toplevel, exp_kind ek)
{
	sql_rel *res = NULL;
	SelectNode *sn = (SelectNode *) sq;

	if (sn->s.token != SQL_SELECT)
		return table_ref(sql, rel, sq);
	assert(sn->s.token == SQL_SELECT);

	if ((ek.card != card_relation && sn->limit >= 0) && 
	    (ek.card == card_value && sn->limit != 1))
		return sql_error(sql, 01, "SELECT: LIMIT only allowed on outermost SELECT");

	if (ek.card != card_relation && sn->orderby)
		return sql_error(sql, 01, "SELECT: ORDER BY only allowed on outermost SELECT");


	if (sn->from) {		/* keep variable list with tables and names */
		dlist *fl = sn->from->data.lval;
		dnode *n = NULL;
		sql_rel *fnd = NULL;

		for (n = fl->h; n ; n = n->next) {
			fnd = table_ref(sql, rel, n->data.sym);

			if (!fnd)
				break;
			if (res) 
				res = rel_crossproduct(res, fnd, op_join);
			else 
				res = fnd;
		}
		if (rel /*&& !toplevel */) {
			rel_setsubquery(res);
			res = rel_crossproduct(rel, res, op_join);
		}
		if (!fnd) {
			if (res)
				rel_destroy(res);
			return NULL;
		}

	} else if (toplevel) {	/* only on top level query */
		return rel_simple_select(sql, rel, sn->where, sn->selection);
	}
	if (res)
		rel = rel_select_exp(sql, res, rel, sn, ek);
	return rel;
}

static sql_rel *
rel_setquery_(mvc *sql, sql_rel *l, sql_rel *r, dlist *cols, int op )
{
	sql_rel *rel;

	if (!cols) {
		node *n, *m;
		int changes = 0;

		list *ls = rel_projections(sql, l, NULL, 1);
		list *rs = rel_projections(sql, r, NULL, 1);
		list *nls = new_exp_list();
		list *nrs = new_exp_list();

		for (n = ls->h, m = rs->h; n && m; n = n->next, m = m->next) {
			sql_exp *le = exp_dup(n->data), *lb = le;
			sql_exp *re = exp_dup(m->data), *rb = re;

			if ((rel_convert_types(sql, &le, &re, 1, type_set) < 0)) {
				if (le)
					exp_destroy(le);
				if (re)
					exp_destroy(re);
				return NULL;
			}
			if (le != lb || re != rb)
				changes = 1;
			append(nls, le); 
			append(nrs, re); 
		}
		if (changes) {
			l = rel_project(l, nls);
			r = rel_project(r, nrs);
			set_processed(l);
			set_processed(r);
		} else {
			list_destroy(nls);
			list_destroy(nrs);
		}
	}
	rel = rel_setop(l, r, (operator_type)op);
	rel->exps = rel_projections(sql, rel, NULL, 0);
	set_processed(rel);
	return rel;
}


static sql_rel *
rel_setquery(mvc *sql, sql_rel *rel, symbol *q)
{
	sql_rel *res = NULL;
	dnode *n = q->data.lval->h;
	symbol *tab_ref1 = n->data.sym;
	int dist = n->next->data.ival;
	dlist *corresponding = n->next->next->data.lval;
	symbol *tab_ref2 = n->next->next->next->data.sym;

	sql_rel *t1 = table_ref(sql, NULL, tab_ref1);
	sql_rel *t2 = table_ref(sql, NULL, tab_ref2);

	(void)rel; /* TODO coorelated unions */
	if (!t1 || !t2) 
		return NULL;

	if (list_length(t1->exps) != list_length(t2->exps)) {
		char *op = "UNION";
		if (q->token == SQL_EXCEPT)
			op = "EXCEPT";
		else if (q->token == SQL_INTERSECT)
			op = "INTERSECT";
		return sql_error(sql, 02, "%s: column counts (%d and %d) do not match", op, t1->nrcols, t2->nrcols);
	}
	if (t1 && dist) 
		t1 = rel_distinct(t1);
	if ( q->token == SQL_UNION)
		if (t2 && dist) 
			t2 = rel_distinct(t2);
		res = rel_setquery_(sql, t1, t2, corresponding, op_union );
		if (res && dist) 
			res = rel_distinct(res);
	if ( q->token == SQL_EXCEPT)
		res = rel_setquery_(sql, t1, t2, corresponding, op_except );
	if ( q->token == SQL_INTERSECT)
		res = rel_setquery_(sql, t1, t2, corresponding, op_inter );
	return res;
}



static sql_rel *
rel_joinquery_(mvc *sql, sql_rel *rel, symbol *tab1, int natural, jt jointype, symbol *tab2, symbol *js)
{
	operator_type op = op_join;
	sql_rel *t1, *t2, *inner;

	t1 = table_ref(sql, rel, tab1);
	t2 = table_ref(sql, rel, tab2);

	if (!t1 || !t2)
		return NULL;

	if (t1->name && t2->name && strcmp(t1->name, t2->name) == 0) { 
		sql_error(sql, 02, "SELECT: '%s' on both sides of the JOIN expression;", t1->name);
		rel_destroy(t1);
		rel_destroy(t2);
		return NULL;
	}

	switch(jointype) {
	case jt_inner: op = op_join;
		break;
	case jt_left: op = op_left;
		break;
	case jt_right: op = op_right;
		break;
	case jt_full: op = op_full;
		break;
	case jt_union:
		/* fool compiler */
		return NULL;
	}
	inner = rel = rel_crossproduct(t1, t2, op_join);

	if (js && natural) {
		return sql_error(sql, 02, "SELECT: cannot have a NATURAL JOIN with a join specification (ON or USING);");
	}
	if (!js && !natural) {
		return sql_error(sql, 02, "SELECT: must have NATURAL JOIN or a JOIN with a join specification (ON or USING);");
	}

	if (js && js->token != SQL_USING) {	/* On sql_logical_exp */
		rel = rel_logical_exp(sql, rel, js, sql_where);
	} else if (js) {	/* using */
		char rname[16], *rnme;
		dnode *n = js->data.lval->h;
		list *outexps = new_exp_list(), *exps;
		node *m;

		rnme = number2name(rname, 16, ++sql->label);
		for (; n; n = n->next) {
			char *nm = n->data.sval;
			sql_exp *cond;
			sql_exp *ls = rel_bind_column(sql, t1, nm);
			sql_exp *rs = rel_bind_column(sql, t2, nm);

			if (!ls || !rs) {
				sql_error(sql, 02, "JOIN: tables '%s' and '%s' do not have a matching column '%s'\n", rel_get_name(t1)?rel_get_name(t1):"", rel_get_name(t2)?rel_get_name(t2):"", nm);
				list_destroy(outexps);
				rel_destroy(rel);
				return NULL;
			}
			rel = rel_compare_exp(sql, rel, exp_dup(ls), exp_dup(rs), "=", NULL, sql_where);
			cond = rel_unop_(sql, exp_dup(ls), NULL, "isnull");
			ls = rel_nop_(sql, cond, exp_dup(rs), exp_dup(ls), NULL, NULL, "ifthenelse");
			exp_setname(ls, rnme, nm);
			append(outexps, ls);
			if (!rel) {
				list_destroy(outexps);
				return NULL;
			}
		}
		exps = rel_projections(sql, t1, NULL, 1);
		for (m = exps->h; m; m = m->next) {
			char *nm = exp_name(m->data);
			int fnd = 0;

			for (n = js->data.lval->h; n; n = n->next) {
				if (strcmp(nm, n->data.sval) == 0) {
					fnd = 1;
					break;
				}
			}
			if (!fnd)
				append(outexps, exp_dup(m->data));
		}
		list_destroy(exps);
		exps = rel_projections(sql, t2, NULL, 1);
		for (m = exps->h; m; m = m->next) {
			char *nm = exp_name(m->data);
			int fnd = 0;

			for (n = js->data.lval->h; n; n = n->next) {
				if (strcmp(nm, n->data.sval) == 0) {
					fnd = 1;
					break;
				}
			}
			if (!fnd)
				append(outexps, exp_dup(m->data));
		}
		list_destroy(exps);
		rel = rel_project(rel, outexps);
	} else {		/* ! js -> natural join */
		rel = join_on_column_name(sql, rel, t1, t2, 0);
		/* As the natural join only returns a new relation with 
		   join columns, we should rename this relation too beable
		   to uniquely describe a column of this relation again
		   (not refering to the lower relation columns).
		 */
		if (!rel->name)
			rel_label(rel, ++sql->label);
	}
	if (!rel)
		return NULL;
	inner->op = op; 
	return rel;
}

static sql_rel *
rel_joinquery(mvc *sql, sql_rel *rel, symbol *q)
{

	dnode *n = q->data.lval->h;
	symbol *tab_ref1 = n->data.sym;
	int natural = n->next->data.ival;
	jt jointype = (jt) n->next->next->data.ival;
	symbol *tab_ref2 = n->next->next->next->data.sym;
	symbol *joinspec = n->next->next->next->next->data.sym;

	return rel_joinquery_(sql, rel, tab_ref1, natural, jointype, tab_ref2, joinspec);
}

static sql_rel *
rel_crossquery(mvc *sql, sql_rel *rel, symbol *q)
{
	dnode *n = q->data.lval->h;
	symbol *tab1 = n->data.sym;
	symbol *tab2 = n->next->data.sym;
	sql_rel *t1 = table_ref(sql, rel, tab1);
	sql_rel *t2 = table_ref(sql, rel, tab2);

	if (!t1 || !t2)
		return NULL;

	rel = rel_crossproduct(t1, t2, op_join);
	return rel;
}
	
static sql_rel *
rel_unionjoinquery(mvc *sql, sql_rel *rel, symbol *q)
{
	dnode *n = q->data.lval->h;
	sql_rel *lv = table_ref(sql, rel, n->data.sym);
	sql_rel *rv = table_ref(sql, rel, n->next->next->data.sym);
	int all = n->next->data.ival; 
	list *lexps, *rexps;
	node *m;
	int found = 0;

	if (!lv || !rv)
		return NULL;

 	lexps = rel_projections(sql, lv, NULL, 1);
	/* find the matching columns (all should match?)
	 * union these 
	 * if !all do a distinct operation at the end 
	 */
	/* join all result columns ie join(lh,rh) on column_name */
	rexps = new_exp_list();
	for (m = lexps->h; m; m = m->next) {
		sql_exp *lc = m->data;
		sql_exp *rc = rel_bind_column(sql, rv, lc->name);
			
		if (!rc && all) 
			break;
		if (rc) {
			found = 1;
			append(rexps, rc);
		}
	}
	if (!found) {
		list_destroy(lexps);
		list_destroy(rexps);
		rel_destroy(rel);
		return NULL;
	}
	lv = rel_project(lv, lexps);
	rv = rel_project(rv, rexps);
	rel = rel_setop(lv, rv, op_union);
	rel->exps = rel_projections(sql, rel, NULL, 0);
	if (!all)
		rel = rel_distinct(rel);
	return rel;
}

static sql_rel *
rel_subquery(mvc *sql, sql_rel *rel, symbol *sq, exp_kind ek)
{
	int toplevel = 0;

	if (!rel || (rel->op == op_project && 
		(!rel->exps || list_length(rel->exps) == 0)))
		toplevel = 1;

	return rel_query(sql, rel, sq, toplevel, ek);
}

static void
as_subquery( mvc *sql, sql_table *t, sql_rel *sq, dlist *column_spec )
{
	if (column_spec) {
		dnode *n = column_spec->h;
		node *m = sq->exps->h;

		for (; n; n = n->next, m = m->next) {
			char *cname = n->data.sval;
			sql_exp *e = m->data;
			sql_subtype *tp = exp_subtype(e);

			mvc_create_column(sql, t, cname, tp);
		}
	} else {
		node *m;

		for (m = sq->exps->h; m; m = m->next) {
			sql_exp *e = m->data;
			char *cname = exp_name(e);
			sql_subtype *tp = exp_subtype(e);

			mvc_create_column(sql, t, cname, tp);
		}
	}
}

sql_rel *
rel_view(mvc *sql, dlist *qname, dlist *column_spec, symbol *query, int check, int persistent)
{
	char *name = qname_table(qname);
	char *sname = qname_schema(qname);
	sql_schema *s = NULL;
	sql_table *t = NULL;
	int instantiate = (sql->mode == m_execute || !persistent);
	modes_t mode = sql->mode;

	(void) check;		/* Stefan: unused!? */
	(void)column_spec;

	if (sname && !(s = mvc_bind_schema(sql, sname)))
		return sql_error(sql, 02, "CREATE VIEW: no such schema '%s'", sname);
	if (s == NULL)
		s = cur_schema(sql);

	if ((t = mvc_bind_table(sql, s, name)) != NULL && !instantiate) {
		return sql_error(sql, 02, "CREATE VIEW: name '%s' already in use", name);
	} else if (!instantiate && !schema_privs(sql->role_id, s)) {
		return sql_error(sql, 02, "CREATE VIEW: access denied for %s to schema ;'%s'", stack_get_string(sql, "current_user"), s->base.name);
	} else if (query) {
		exp_kind ek = {type_value, card_relation, TRUE};
		sql_rel *sq = NULL;
		char *q = QUERY(sql->scanner);

		if (query->token == SQL_SELECT) {
			SelectNode *sn = (SelectNode *) query;

			if (sn->limit >= 0)
				return sql_error(sql, 01, "CREATE VIEW: LIMIT not supported");
			if (sn->orderby)
				return sql_error(sql, 01, "CREATE VIEW: ORDER BY not supported");
		}

		if (!instantiate)
			sql->mode = m_execute;
		sq = rel_subquery(sql, NULL, query, ek);
		sql->mode = mode;
		if (!sq)
			return NULL;

		if (!instantiate) {
			t = mvc_create_view(sql, s, name, q, 0);
			as_subquery( sql, t, sq, column_spec );
		}
/* todo 
		if (!persistent && column_spec) 
			sq = view_rename_columns( name, sq, column_spec);
*/
		if (!instantiate && sq && persistent) {
			stmt *sqs = rel_bin(sql, sq);
			list *view_id_l = stmt_list_dependencies(sqs, VIEW_DEPENDENCY);
			list *id_l = stmt_list_dependencies(sqs, COLUMN_DEPENDENCY);
			list *func_id_l = stmt_list_dependencies(sqs, FUNC_DEPENDENCY);
			mvc_create_dependencies(sql, id_l, t->base.id, VIEW_DEPENDENCY);
			mvc_create_dependencies(sql, view_id_l, t->base.id, VIEW_DEPENDENCY);
			mvc_create_dependencies(sql, func_id_l, t->base.id, VIEW_DEPENDENCY);
			list_destroy(id_l);
			list_destroy(view_id_l);
			list_destroy(func_id_l);
			stmt_destroy(sqs);
			rel_destroy(sq);
			return rel_project(NULL, NULL);
		}
		return sq;
	}
	return NULL;
}

sql_rel *
rel_selects(mvc *sql, symbol *s)
{
	sql_rel *ret = NULL;

	switch (s->token) {
	case SQL_SELECT: {
		exp_kind ek = {type_value, card_relation, TRUE};
		ret = rel_subquery(sql, NULL, s, ek);
		sql->type = Q_TABLE;
	}	break;
	case SQL_JOIN:
		ret = rel_joinquery(sql, NULL, s);
		sql->type = Q_TABLE;
		break;
	case SQL_CROSS:
		ret = rel_crossquery(sql, NULL, s);
		sql->type = Q_TABLE;
		break;
	case SQL_UNION:
	case SQL_EXCEPT:
	case SQL_INTERSECT:
		ret = rel_setquery(sql, NULL, s);
		sql->type = Q_TABLE;
		break;
	default:
		return NULL;
	}
	if (mvc_debug_on(sql,32768)) {
		rel_print(sql, ret, 0);
		printf("\n");
	}
	if (!ret && sql->errstr[0] == 0)
		(void) sql_error(sql, 02, "relational query without result");
	return ret;
}
