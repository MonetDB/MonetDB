@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f rel_select
@a N.J. Nes
@* 

@h
#ifndef _REL_SELECT_H_
#define _REL_SELECT_H_

#include "rel_semantic.h"

#define sql_from 0
#define sql_where 1
/* special search fase which is used within the selection fase */
#define sql_search 2
#define sql_sel   3

extern sql_rel *rel_selects(mvc *sql, symbol *sym);

#endif /*_REL_SELECT_H_*/
@c

#include "rel_select.h"
#include "sql_semantic.h" 	/* TODO this dependency should be removed */
#include "rel_dump.h"
#include "sql_privileges.h"
#include "sql_env.h"

#define new_exp_list() list_create((fdestroy)&exp_destroy)
#define new_subtype_list() list_create((fdestroy)&sql_subtype_destroy)

static void rel_destroy(sql_rel *rel);

static sql_exp *rel_binop_(mvc *sql, sql_exp *l, sql_exp *r, char *fname);

static void 
rel_destroy_(sql_rel *rel)
{
	if (rel->name) 
		_DELETE(rel->name);
	if (rel->exps)
		list_destroy(rel->exps);
	if (rel->op != op_basetable && rel->op != op_groupby) {
		if (rel->l)
			rel_destroy(rel->l);
		if (rel->r)
			rel_destroy(rel->r);
	} else if (rel->op == op_groupby) {
		if (rel->l)
			rel_destroy(rel->l);
		if (rel->r)
			list_destroy(rel->r);
	}
}

static void 
rel_destroy(sql_rel *rel)
{
	if (!rel) 
		return;
	rel_destroy_(rel);
	_DELETE(rel);
}

static void 
exp_destroy(sql_exp *exp)
{
	if (!exp) 
		return;
	if (sql_ref_dec(&exp->ref) > 0)
		return;
	if (exp->name) 
		_DELETE(exp->name);
	switch(exp->type){
	case e_atom:
		if (exp->l) 
			atom_destroy(exp->l);
		break;
	case e_exp:
		exp_destroy(exp->l);
		exp_destroy(exp->r);
		break;
	case e_relation:
		if (exp->l)
			rel_destroy(exp->l);
		break;
	case e_column:
		if (exp->l)
			_DELETE(exp->l);
		_DELETE(exp->r);
		break;
	case e_cmp:
		exp_destroy(exp->l);
		exp_destroy(exp->r);
		break;
	case e_convert:
		exp_destroy(exp->l);
		list_destroy(exp->r);
		break;
	case e_aggr:
		sql_subaggr_destroy(exp->f);
		if (exp->l) list_destroy(exp->l);
		break;
	case e_func:
		sql_subfunc_destroy(exp->f);
		if (exp->l) list_destroy(exp->l);
		break;
	default:
		printf("TODO: exp_destroy %d\n", exp->type);
	}
	_DELETE(exp);
}

static sql_exp *
exp_dup(sql_exp *exp)
{
	sql_ref_inc(&exp->ref);
	return exp;
}

static sql_subtype *
exp_subtype( sql_exp *e )
{
	switch(e->type) {
	case e_atom: {
		if (e->l) {
			atom *a = e->l;
			return a->tpe;
		} else { /* atom reference */
			return e->f;
		}
	}
	case e_exp:
	case e_convert:
	case e_column:
		return e->f;
	case e_aggr: {
		sql_subaggr *a = e->f;
		return a->res;
	}
	case e_func: {
		sql_subfunc *f = e->f;
		return f->res;
	}
	case e_cmp:
		/* return bit */
	case e_relation:
		/* return rel? */
	default:
		return NULL;
	}
}


static sql_exp * exp_create( int type ) 
{
	sql_exp *e = NEW(sql_exp);
	sql_ref_init(&e->ref);
	e->name = NULL;
	e->card = 0;
	e->flag = 0;
	e->l = e->r = NULL;
	e->type = type;
	e->f = NULL;
	return e;
}

static sql_exp * exp_atom( atom *a) 
{
	sql_exp *e = exp_create(e_atom);
	e->card = CARD_ATOM;
	e->l = a;
	return e;
}

static sql_exp * exp_atom_ref(int i, sql_subtype *tpe) 
{
	sql_exp *e = exp_create(e_atom);
	e->card = CARD_ATOM;
	e->flag = i;
	e->f = tpe;
	return e;
}


static sql_exp *
exp_atom_int(int i) {
	sql_subtype *it = sql_bind_subtype("int", 9, 0);

	return exp_atom(atom_int(sql_dup_subtype(it), i ));
}

static sql_exp * exp_relation( sql_rel *r) 
{
	sql_exp *e = exp_create(e_relation);
	e->card = r->card;
	e->l = r;
	return e;
}

static sql_exp * 
exp_column( char *tname, char *cname, sql_subtype *t) 
{
	sql_exp *e = exp_create(e_column);
	e->name = _strdup(cname);
	e->card = CARD_MULTI;
	e->l = (tname)?_strdup(tname):NULL;
	e->r = _strdup(cname);
	e->f = t;
	return e;
}

static sql_exp * 
exp_alias( char *tname, char *cname, sql_exp *old) 
{
	sql_exp *e = exp_create(e_column);
	e->name = _strdup(cname);
	e->card = old->card;
	e->l = (tname)?_strdup(tname):NULL;
	e->r = _strdup(cname);
	e->f = exp_subtype(old);
	return e;
}


static sql_exp * 
exp_exp( sql_exp *l, sql_exp *r ) 
{
	sql_exp *e = exp_create(e_exp);
	e->card = l->card;
	e->l = l;
	e->r = r;
	return e;
}

static sql_exp * 
exp_like( sql_exp *l, sql_exp *r, sql_exp *esc, int like) 
{
	sql_exp *e = exp_create(e_cmp);
	e->card = l->card;
	e->l = l;
	e->r = r;
	if (esc)
		e->r = exp_exp(r,esc);
	e->flag = like;
	return e;
}

static sql_exp * 
exp_compare( sql_exp *l, sql_exp *r, int cmptype) 
{
	sql_exp *e = exp_create(e_cmp);
	e->card = l->card;
	e->l = l;
	e->r = r;
	e->flag = cmptype;
	return e;
}

#define exp_unop(l,f) \
	exp_op(list_append(new_exp_list(),l), f)
#define exp_binop(l,r,f) \
	exp_op(list_append(list_append(new_exp_list(),l),r), f)

static int
exps_card( list *l ) 
{
	node *n;
	int card = 0;

	if (l) for(n = l->h; n; n = n->next) {
		sql_exp *e = n->data;

		if (card < e->card)
			card = e->card;
	}
	return card;
}
	
static sql_exp * 
exp_op( list *l, sql_subfunc *f )
{
	sql_exp *e = exp_create(e_func);
	e->card = exps_card(l);
	if (!l || list_length(l) == 0)
		e->card = CARD_ATOM; /* unop returns a single atom */
	e->l = l;
	e->f = f; 
	return e;
}

static sql_exp * 
exp_convert( sql_exp *exp, sql_subtype *fromtype, sql_subtype *totype )
{
	sql_exp *e = exp_create(e_convert);
	e->card = exp->card;
	e->l = exp;
	e->r = list_append(list_append(new_subtype_list(),fromtype),totype);
	e->f = totype;
	return e;
}

static sql_exp * 
exp_aggr( list *l, sql_subaggr *a, int distinct )
{
	sql_exp *e = exp_create(e_aggr);
	e->card = CARD_AGGR;
	e->l = l;
	e->f = a; 
	e->flag = distinct;
	return e;
}

static void exp_set_name( sql_exp *e, char *name )
{
	if (e->name)
		_DELETE(e->name);
	e->name = _strdup(name);
}

static sql_exp *
exps_bind_column( list *exps, char *cname ) 
{
	node *en;

	for (en = exps->h; en; en = en->next ) {
		sql_exp *e = en->data;
		if (e->name && strcmp(e->name, cname) == 0)
			return e;
	}
	return NULL;
}

static sql_exp *
exp_find_column( sql_exp *e )
{
	while(e && e->type != e_column) {
		if (e->type == e_atom || e->type == e_exp || e->type == e_cmp)
			return NULL;
		if (e->type == e_aggr || e->type == e_func) {
			list *l = e->l;
			e = l->h->data;
		}
		if (e->type == e_convert) 
			e = e->l;
	}
	return e;
}

static sql_exp *
exps_bind_column2( list *exps, char *tname, char *cname ) 
{
	node *en;

	for (en = exps->h; en; en = en->next ) {
		sql_exp *e = exp_find_column(en->data);
		
		if (e->type == e_column && e->name && e->l && strcmp(e->name, cname) == 0 && strcmp(e->l, tname) == 0)
			return e;
		if (e->type == e_column && e->l && e->r && strcmp(e->r, cname) == 0 && strcmp(e->l, tname) == 0)
			return e;
	}
	return NULL;
}


static sql_rel *
rel_bind_column_( sql_rel **p, sql_rel *rel, char *cname )
{
	sql_rel *r = NULL;
	switch(rel->op) {
	case op_join:
	case op_left:
	case op_right:
	case op_full:
		*p = rel;
		r = rel_bind_column_( p, rel->l, cname);
		if (r) 
			return r;
		*p = rel;
		return rel_bind_column_( p, rel->r, cname);
	case op_project:
	case op_groupby:
		if (rel->exps && exps_bind_column(rel->exps, cname))
			return rel;
		*p = rel;
		return rel_bind_column_( p, rel->l, cname );
	case op_basetable:
	{
		node *cn;
		sql_table *t = rel->l;

		for (cn = t->columns.set->h; cn; cn = cn->next) {
			sql_column *c = cn->data;
			if (strcmp(c->base.name, cname) == 0)
				return rel;
		}
	} 
	case op_select:
	case op_union:
	case op_except:
	case op_inter:
	case op_orderby:
	case op_topn:
		*p = rel;
		return rel_bind_column_( p, rel->l, cname);
	default:
		return NULL;
	}
	return NULL;
}

static sql_exp *
rel_bind_column( sql_rel *rel, char *cname )
{
	sql_rel *p = NULL;

	if (!rel || (rel = rel_bind_column_(&p, rel, cname)) == NULL)
		return NULL;

	if (rel->op == op_project || rel->op == op_groupby) {
		if (rel->exps) {
			sql_exp *e = exps_bind_column(rel->exps, cname);
			if (e)
				return exp_alias(rel->name, e->name, e);
		}
	} else if (rel->op == op_basetable) {
		node *cn;
		sql_table *t = rel->l;

		for (cn = t->columns.set->h; cn; cn = cn->next) {
			sql_column *c = cn->data;
			if (strcmp(c->base.name, cname) == 0)
				return exp_column(rel->name, cname, c->type );
		}
	}
	return NULL;
}

static sql_exp *
rel_bind_column2( sql_rel *rel, char *tname, char *cname )
{
	if (rel->op == op_project || rel->op == op_groupby) {
		if (rel->exps) {
			sql_exp *e = exps_bind_column2(rel->exps, tname, cname);
			if (e)
				return exp_alias(tname, e->name, e);
		}
	} else if (rel->op == op_basetable && strcmp(rel->name,tname) == 0) {
		node *cn;
		sql_table *t = rel->l;

		for (cn = t->columns.set->h; cn; cn = cn->next) {
			sql_column *c = cn->data;
			if (strcmp(c->base.name, cname) == 0)
				return exp_column(rel->name, cname, c->type );
		}
	}
	return NULL;
}


static sql_rel *
rel_bind_table( sql_rel **p, sql_rel *rel, char *tname ) 
{
	sql_rel *r;

	if (rel->name && strcmp(rel->name, tname) == 0) 
		return rel; 
	switch(rel->op) {
	case op_join:
	case op_left:
		*p = rel;
		r = rel_bind_table( p,  rel->l, tname);
		if (r) 
			return r;
		*p = rel;
		return rel_bind_table( p, rel->r, tname);
	case op_project:
	case op_groupby:
	case op_select:
	case op_union:
	case op_orderby:
	case op_topn:
		*p = rel;
		return rel_bind_table( p, rel->l, tname);
	default:
		return NULL;
	}
	return NULL;
}

static sql_rel * 
rel_bind_exp(sql_rel **p, sql_rel *rel, sql_exp *e )
{
	if (rel->op == op_groupby)
		return rel;
	switch(e->type) {
	case e_column:
		if (e->l)
			rel = rel_bind_table(p, rel, e->l);
		if (rel)
			return rel_bind_column_(p, rel, e->r);
	default:
		return rel;
	}
	return rel;
}


static list *
rel_projections( sql_rel *rel, char *tname )
{
	list *rexps, *exps ;

	if (!tname)
		tname = rel->name;

	switch(rel->op) {
	case op_join:
	case op_left:
	case op_right:
	case op_full:
		exps = rel_projections( rel->l, tname );
		rexps = rel_projections( rel->r, tname );
		exps = list_merge( exps, rexps, (fdup)&exp_dup);
		list_destroy(rexps);
		return exps;
	case op_project:
	case op_groupby:
		if (rel->exps) {
			node *en;

			exps = new_exp_list();
			for (en = rel->exps->h; en; en = en->next) {
				sql_exp *e = en->data;
				list_append(exps, exp_alias(tname, e->name, e));
			}
			return exps;
		}
	case op_select:
	case op_union:
	case op_except:
	case op_inter:
	case op_orderby:
	case op_topn:
		return rel_projections( rel->l, tname );
	case op_basetable: 
	{
		node *cn;
		sql_table *t = rel->l;

		exps = new_exp_list();
		for (cn = t->columns.set->h; cn; cn = cn->next) {
			sql_column *c = cn->data;
			list_append(exps, exp_column(tname, c->base.name, c->type ));
		}
		return exps;
	} 
	default:
		return NULL;
	}
	return NULL;
}

static sql_exp *
exp_copy( sql_exp *e )
{
	if (e->type == e_relation) {
		sql_rel *r = e->l;
		if (r->op == op_project)
			return r->exps->h->data;
	}
	return e;
}

static sql_rel *
rel_copy( sql_rel *i ) 
{
	sql_rel *rel = NEW(sql_rel);

	rel->name = (i->name)?_strdup(i->name):NULL;
	rel->l = NULL;
	rel->r = NULL;
	rel->card = i->card;

	switch(i->op) {
	case op_basetable:
		rel->l = i->l;
		break;
	case op_groupby:
		rel->l = rel_copy(i->l);
		if (i->r)
			rel->r = (i->r)?list_dup(i->r, (fdup)&exp_dup):NULL;
		break;
	case op_orderby:
	case op_join:
	case op_left:
	case op_project:
	case op_select:
	default:
		if (i->l)
			rel->l = rel_copy(i->l);
		if (i->r)
			rel->r = rel_copy(i->r);
		break;
	}
	rel->op = i->op;
	rel->exps = (i->exps)?list_dup(i->exps, (fdup)&exp_dup):NULL;
	return rel;
}

static sql_rel *
rel_basetable(sql_table *t, char *tname) 
{
	sql_rel *rel = NEW(sql_rel);

	rel->name = (tname)?_strdup(tname):NULL;
	rel->l = t;
	rel->r = NULL;
	rel->op = op_basetable;
	rel->exps = NULL;
	rel->card = CARD_MULTI;
	return rel;
}

static sql_rel *
rel_setop(sql_rel *l, sql_rel *r, operator_type setop)
{
	sql_rel *rel = NEW(sql_rel);

	rel->name = NULL;
	rel->l = l;
	rel->r = r;
	rel->op = setop;
	rel->exps = NULL;
	rel->card = CARD_MULTI;
	return rel;
}

static sql_rel *
rel_crossproduct(sql_rel *l, sql_rel *r, operator_type join)
{
	sql_rel *rel = NEW(sql_rel);

	rel->name = NULL;
	rel->l = l;
	rel->r = r;
	rel->op = join;
	rel->exps = NULL;
	rel->card = CARD_MULTI;
	return rel;
}

static sql_rel *
rel_join(sql_rel *rel, sql_exp *e)
{
	if (!is_join(rel->op)) 
		return rel_join(rel->l, e);

	/* optimize a small bit, ie push down join predicates */
	if (e->type == e_cmp && e->flag != cmp_like && e->flag != cmp_notlike) {
		sql_rel *p = NULL;
		sql_rel *l = rel_bind_exp(&p, rel->l, e->l);
		sql_rel *r = rel_bind_exp(&p, rel->r, e->r);
		sql_exp *le = e->l;
		sql_exp *re = e->r;
		int swapped = 0;
		if (!l && !r) {
			sql_exp *te = le;
			le = re; 
			re = te;
			swapped = 1;
			l = rel_bind_exp(&p, rel->l, le);
			r = rel_bind_exp(&p, rel->r, re);
		}
		if (!l && r && r != rel) {
			l = rel_bind_exp(&p, rel->r, le);
			if (l) { 
				rel_join(rel->r, e);
				return rel;
			}
		} else if (l && !r && l != rel) {
			r = rel_bind_exp(&p, rel->l, re);
			if (r) { 
				rel_join(rel->l, e);
				return rel;
			}
		}
		(void)p;
	}
	if (!rel->exps)
		rel->exps = new_exp_list();
	list_append(rel->exps, e);
	if (e->card > rel->card)
		rel->card = e->card;
	return rel;
}

static sql_rel *
rel_distinct(sql_rel *l) 
{
	assert (l->op == op_project && !l->r);
	l->r = l; /* distinct */
	return l;
}

static sql_rel *
rel_project(sql_rel *l, list *e)
{
	sql_rel *rel = NEW(sql_rel);

	rel->name = NULL;
	rel->l = l;
	rel->r = NULL;
	rel->op = op_project;
	rel->exps = e;
	rel->card = CARD_ATOM; /* no relation */
	if (l)
		rel->card = l->card;
	return rel;
}

static sql_rel *
rel_select(sql_rel *l, sql_exp *e)
{
	if (l && l->op == op_select) {
		list_append(l->exps, e);
		return l;
	} else {
		sql_rel *rel = NEW(sql_rel);
	
		rel->name = NULL;
		rel->l = l;
		rel->r = NULL;
		rel->op = op_select;
		rel->exps = list_append(new_exp_list(), e);
		rel->card = CARD_ATOM; /* no relation */
		if (l)
			rel->card = l->card;
		return rel;
	}
}

static sql_rel *
rel_groupby(sql_rel *l, list *aggrs, list *groupbyexps )
{
	sql_rel *rel = NEW(sql_rel);

	rel->name = NULL;
	rel->l = l;
	rel->r = aggrs;
	rel->card = CARD_AGGR;
	if (!aggrs)
		rel->r = new_exp_list();
	rel->op = op_groupby;
	rel->exps = groupbyexps;
	return rel;
}

static void rel_groupby_add_aggr(sql_rel *rel, sql_exp *e)
{
	list_append(rel->r, e);
}

static sql_rel *
rel_orderby(sql_rel *l, list *orderbyexps )
{
	sql_rel *rel = NEW(sql_rel);

	rel->name = NULL;
	rel->l = l;
	rel->r = NULL;
	rel->op = op_orderby;	
	rel->exps = orderbyexps;
	rel->card = l->card;
	return rel;
}

static sql_rel *
rel_topn(sql_rel *l, list *e )
{
	sql_rel *r = rel_orderby( l, e);
	r->op = op_topn;	
	r->card = l->card;
	return r;
}

static void rel_set_name( sql_rel *rel, char *name )
{
	if (rel->name)
		_DELETE(rel->name);
	rel->name = _strdup(name);
}

static char * rel_get_name( sql_rel *rel )
{
	if (rel->name)
		return (rel->name);
	switch(rel->op) {
	case op_basetable:
	{
		sql_table *t = rel->l;
		return t->base.name;
	}
	default:
		return rel_get_name(rel->l);
	}
	assert(0);
	return NULL;
}

/* forward refs */
static sql_rel * rel_subquery(mvc *sql, sql_rel *rel, symbol *sq);
static sql_rel * rel_joinquery(mvc *sql, sql_rel *rel, symbol *sq);
static sql_exp * rel_value_exp(mvc *sql, sql_rel *rel, symbol *se, int f);


static sql_rel *
rel_table_optname(mvc *sql, sql_rel *sq, symbol *optname)
{
	(void)sql;
	if (optname && optname->token == SQL_NAME) {
		dlist *columnrefs = NULL;
		char *tname = optname->data.lval->h->data.sval;

		if (tname)
			rel_set_name( sq, tname );
		columnrefs = optname->data.lval->h->next->data.lval;
		if (columnrefs && sq->exps) {
			dnode *d = columnrefs->h;
			node *ne = sq->exps->h;

			for (; d && ne; d = d->next, ne = ne->next) 
				exp_set_name( ne->data, d->data.sval );
		}
	}
	return sq;
}

static sql_rel *
rel_subquery_optname(mvc *sql, sql_rel *rel, symbol *query)
{
	SelectNode *sn = (SelectNode *) query;
	sql_rel *sq = rel_subquery(sql, rel, query);

	if (!sq)
		return NULL;

	return rel_table_optname(sql, sq, sn->name);
}

static sql_rel *
table_ref(mvc *sql, sql_rel *rel, symbol *tableref)
{
	char *tname = NULL;
	sql_table *t = NULL;

	(void)rel;
	if (tableref->token == SQL_NAME) {
		sql_schema *s = qname_schema(sql, tableref->data.lval->h->data.lval);

		tname = qname_table(tableref->data.lval->h->data.lval);

		if (!s) {
			return sql_error(sql, 02, "unknown schema");
		}
		t = mvc_bind_table(sql, s, tname);
		if (!t) {
			return sql_error(sql, 02, "unknown table %s", tname);
		} else if (!table_privs(sql, t, PRIV_SELECT)) {
			return sql_error(sql, 02, "User is not allowed to select from table %s", tname);
		}
		if (tableref->data.lval->h->next->data.sym) {	/* AS */
			tname = tableref->data.lval->h->next->data.sym->data.lval->h->data.sval;
		}
		if (!t->table && t->query) { /* base view */
			sql_rel *rel = rel_parse(sql, t->query);
			if (!rel)
				return rel;
			rel_set_name(rel, tname);
			return rel;
		}
		return rel_basetable(t, tname);
	} else if (tableref->token == SQL_TABLE) {
		/* not sure this is valid SQL, (func_ref table_name)! */
		symbol *ts = tableref->data.lval->h->data.sym;
		sql_exp *e = rel_value_exp(sql, rel, ts, sql_from);
		sql_rel *rel;
		char *tname = tableref->data.lval->h->next->data.sym->data.lval->h->data.sval;

		if (!e)
			return NULL;
		if (e->type != e_relation) {
			exp_destroy(e);
			return sql_error(sql, 02, "No relation returned by table reference %s", tname);
		}
		rel = e->l;
		e->l = NULL;
		rel_set_name(rel, tname); 
		return rel;
	} else if (tableref->token == SQL_SELECT) {
		return rel_subquery_optname(sql, rel, tableref);
	} else {
		/* TODO JOIN/UNIONs ?
		return query_exp_optname(sql, rel, tableref);
		*/
		return NULL;
	}
}

static sql_exp *
rel_column_ref(mvc *sql, sql_rel *rel, symbol *column_r)
{
	sql_exp *exp = NULL;
	dlist *l = column_r->data.lval;

	(void)sql;
	(void)rel;
	assert(column_r->token == SQL_COLUMN && column_r->type == type_list);

	if (dlist_length(l) == 1 && l->h->type == type_int) {
		int nr = l->h->data.ival;
		atom *a;
		if ((a = sql_bind_arg(sql, nr)) != NULL)
			return exp_atom_ref(nr, a->tpe);
		return NULL;
	} else if (dlist_length(l) == 1) {
		char *name = l->h->data.sval;
		
		exp = rel_bind_column(rel, name);
		if (!exp)
			return sql_error(sql, 02, "Column: %s unknown", name);
	} else if (dlist_length(l) == 2) {
		char *tname = l->h->data.sval;
		char *cname = l->h->next->data.sval;

		exp = rel_bind_column2(rel, tname, cname);
		if (!exp) {
			sql_rel *p, *r = rel_bind_table(&p, rel, tname);

			(void)p;
			if (r)
				exp = rel_bind_column(r, cname);
		}
		if (!exp)
			return sql_error(sql, 02, "Column: %s.%s unknown", tname, cname);
	} else if (dlist_length(l) >= 3) {
		return sql_error(sql, 02, "TODO: column names of level >= 3");
	}
	return exp;
}

static lng
scale2value(int scale)
{
	lng val = 1;

	if (scale < 0)
		scale = -scale;
	for (; scale; scale--) {
		val = val * 10;
	}
	return val;
}

static sql_exp *
exp_fix_scale(mvc *sql, sql_subtype *ct, sql_exp *e, int both, int always)
{
	sql_subtype *et = exp_subtype(e);
	(void) sql;		/* Stefan: unused!? */

	if (ct->type->scale == SCALE_FIX && et->type->scale == SCALE_FIX) {
		int scale_diff = ((int) ct->scale - (int) et->scale);

		if (scale_diff) {
			sql_subtype *it = sql_bind_localtype(et->type->base.name);
			sql_subfunc *c = NULL;

			if (scale_diff < 0) {
				if (!both)
					return e;
				c = sql_bind_func(sql->trans->module, "scale_down", et, it);
			} else {
				c = sql_bind_func(sql->trans->module, "scale_up", et, it);
			}
			if (c) {
				lng val = scale2value(scale_diff);
				atom *a = atom_int(sql_dup_subtype(it), val);

				c->res->scale = (et->scale + scale_diff);
				return exp_binop(e, exp_atom(a), c);
			}
		}
	} else if (always && et->scale) {	/* scale down */
		int scale_diff = -(int) et->scale;
		sql_subtype *it = sql_bind_localtype(et->type->base.name);
		sql_subfunc *c = sql_bind_func(sql->trans->module, "scale_down", et, it);

		if (c) {
			lng val = scale2value(scale_diff);
			atom *a = atom_int(sql_dup_subtype(it), val);

			c->res->scale = 0;
			return exp_binop(e, exp_atom(a), c);
		} else {
			printf("scale_down mising (%s)\n", et->type->base.name);
		}
	}
	return e;
}

static sql_exp * 
rel_check_type(mvc *sql, sql_subtype *t, sql_exp *exp, int typecheck)
{
	sql_subtype *fromtype = exp_subtype(exp);
	
	if (!fromtype)
		return NULL;

	if (fromtype && subtype_cmp(t, fromtype) != 0) {
		sql_subtype *nt;
		int c = sql_type_convert(fromtype->type->eclass, t->type->eclass);
		if (!c) { 
			exp_destroy(exp);
			exp = NULL;
		} else {
			nt = sql_dup_subtype(t);
			exp = exp_convert(exp, sql_dup_subtype(fromtype), nt);
		}
	}
	(void)typecheck;
	if (!exp) {
		sql_exp *res = sql_error(
			sql, 03,
			"types %s(%d,%d) (%s) and %s(%d,%d) (%s) are not equal",
			fromtype->type->sqlname,
			fromtype->digits,
			fromtype->scale,
			t->type->base.name,
			t->type->sqlname,
			t->digits,
			t->scale,
			t->type->base.name
		);
		return res;
	}
	return exp;
}

static sql_exp *
exp_sum_scales(mvc *sql, sql_subfunc *f, sql_exp *l, sql_exp *r)
{
	if (strcmp(f->func->imp, "*") == 0 && 
	    f->func->res->type->scale == SCALE_FIX) {
		sql_subtype *t = NULL;
		sql_subtype *lt = exp_subtype(l);
		sql_subtype *rt = exp_subtype(r);

		f->res->scale = lt->scale + rt->scale;
		f->res->digits = lt->digits + rt->digits;
		/* HACK alert: digits should be less then max */
		if (f->res->type->radix == 10 && f->res->digits > 19)
			f->res->digits = 19;
		if (f->res->type->radix == 2 && f->res->digits > 53)
			f->res->digits = 53;
		/* sum of digits may mean we need a bigger result type 
		 * as the function don't support this we need to
		 * make bigger input types!
		 */

		/* numeric types are fixed length */
		if (f->res->type->eclass == EC_NUM) {
			t = sql_bind_numeric(f->res->type->localtype, f->res->digits);
		} else {
			t = sql_bind_subtype(f->res->type->sqlname, f->res->digits, f->res->scale);
		}
		if (type_cmp(t->type, f->res->type) != 0) { 
			/* do we need to convert to the a larger localtype 
			   int * int may not fit in an int, so we need to 
			   convert to lng * int.
			 */
			sql_subtype *nlt = sql_create_subtype(t->type, 
				f->res->digits, lt->scale);
			l = rel_check_type( sql, nlt, l, type_equal );
			sql_subtype_destroy(nlt);
		}
		sql_subtype_destroy(f->res);
		f->res = t;
	}
	return l;
}

static sql_exp *
exp_scale_algebra(mvc *sql, sql_subfunc *f, sql_exp *l, sql_exp *r)
{
	sql_subtype *lt = exp_subtype(l);
	sql_subtype *rt = exp_subtype(r);

	/*
	 * Decimals are mapped on plain integers. This has impact on the
	 * implemantion of division. First the 'dividend' should be large 
	 * enough to prevent rounding errors. This is solved by a 
	 * multiplication with the 'scale' of the divisor.
	 * Second the result type of the division should be equal to the 
	 * 'dividend', with the maximum scale of the dividend and divisor.
	 *
	 * Example      1.0/0.1 mapped (int 1 dec(1,0) and int 1 dec(2,1))
	 *                              1 * 10 = 10 (scale of divisor)
	 *                              10/1 = 1 dec(1)
	 */

	if (lt->type->scale == SCALE_FIX && rt->scale && 
		strcmp(f->func->imp, "/") == 0) {
		int digits = rt->scale + lt->digits;
		sql_subtype *nlt;

		/* HACK alert: digits should be less then max */
		if (f->res->type->radix == 10 && digits > 19)
			digits = 19;
		if (f->res->type->radix == 2 && digits > 53)
			digits = 53;

		/* scale fixing may require a larger type ! */
		nlt = sql_bind_subtype(lt->type->sqlname, digits, lt->scale+rt->scale);
		f->res->digits = digits;
		f->res->scale = lt->scale;
		
		l = rel_check_type( sql, nlt, l, type_equal );
		sql_subtype_destroy(nlt);
	}
	return l;
}

static int 
rel_convert_types(mvc *sql, sql_exp **L, sql_exp **R, int scale_fixing)
{
	sql_exp *ls = *L;
	sql_exp *rs = *R;
	sql_subtype *lt = exp_subtype(ls);
	sql_subtype *rt = exp_subtype(rs);

	/* TODO parameters */
	if (!rt || !lt) {
		sql_error(sql, 01, "Cannot have a parameter (?) on both sides of an expression");
		return -1;
	}
	if (rt && lt) {
		sql_subtype *i = lt;
		sql_subtype *r = rt;

		if (subtype_cmp(lt, rt) != 0) {
			sql_subtype *super = supertype(r, i);

			if (scale_fixing) {
				/* convert ls to super type */
				ls = rel_check_type(sql, super, ls, type_equal);
				/* convert rs to super type */
				rs = rel_check_type(sql, super, rs, type_equal);
			} else {
				/* convert ls to super type */
				super->scale = lt->scale;
				ls = rel_check_type(sql, super, ls, type_equal);
				/* convert rs to super type */
				super->scale = rt->scale;
				rs = rel_check_type(sql, super, rs, type_equal);
			}
			sql_subtype_destroy(super);
		}
		*L = ls;
		*R = rs;
		if (!ls || !rs) {
			return -1;
		}
		return 0;
	}
	return -1;
}

static sql_rel *
rel_compare_exp(mvc *sql, sql_rel *rel, sql_exp *ls, sql_exp *rs, char *compare_op, sql_exp *esc, int f )
{
	sql_exp *e = NULL;
	comp_type type = cmp_equal;

	if (!ls || !rs)
		return NULL;

	if (!rel || f == sql_sel || (ls->card <= CARD_ATOM && rs->card <= CARD_ATOM)) {
		sql_exp *e = rel_binop_(sql, ls, rs, compare_op);

		if (!e)
			return NULL;
		/* HACK pass expression with in simple value projection */
		if (f == sql_sel) {
			list *exps = new_exp_list();

			list_append(exps, e);
			return rel_project(rel, exps);
		} else {
			return rel_select(rel, e);
		}
	}
	if (compare_op[0] == '=') {
		type = cmp_equal;
	} else if (compare_op[0] == '<') {
		type = cmp_lt;
		if (compare_op[1] != '\0') {
			if (compare_op[1] == '>') {
				type = cmp_notequal;
			} else if (compare_op[1] == '=') {
				type = cmp_lte;
			}
		}
	} else if (compare_op[0] == '>') {
		type = cmp_gt;
		if (compare_op[1] != '\0') {
			if (compare_op[1] == '=') {
				type = cmp_gte;
			}
		}
	} else if (compare_op[0] == 'l') {
		type = cmp_like;
	} else if (compare_op[0] == 'n') {
		type = cmp_notlike;
	}
	if (rel_convert_types(sql, &ls, &rs, 1) < 0) {
		if (ls)
			exp_destroy(ls);
		if (rs)
			exp_destroy(rs);
		return NULL;
	}
	if (type != cmp_like && type != cmp_notlike) {
		if (ls->card < rs->card) {
			sql_exp *swap = ls;
	
			ls = rs;
			rs = swap;
		}
		e = exp_compare( ls, rs, type );
	} else {
		e = exp_like( ls, rs, esc, type );
	}

	/* TODO handle subqueries with outer references */

	/* one value or row => select */
	/* TODO or expression 2 columns of the same relation */
	if (rs->card <= CARD_ATOM) {
		sql_rel *r, *p = NULL;

		if (ls->card == rs->card)  /* bin compare op */
			return rel_select(rel, e);

		/* push select into the given relation */
		/* find relation for the column expression */
		r = rel_bind_exp(&p, rel, ls);
		if (p && r->op == op_basetable && p->op == op_select) {
			rel_select(p, e);
		} else {
			sql_rel *n = rel_select(r, e);

			if (p) {
				if (p->l == r)
					p->l = n;
				else
					p->r = n;
			} else {
				rel = n;
			}
			return rel;
		}
		return rel;
	} else { /* join */
		sql_rel *p = NULL;
		sql_rel *l = rel_bind_exp(&p, rel, ls);
		sql_rel *r = rel_bind_exp(&p, rel, rs);

		if (l == r) /* filter on columns of this table */
			return rel_select(rel, e);

		return rel_join(rel, e);
	}
	return rel;
}

static sql_rel *
rel_compare(mvc *sql, sql_rel *rel, symbol *lo, symbol *ro, char *compare_op, int f )
{
	sql_exp *rs, *ls;

	if (lo->token == SQL_SELECT) { /* swap subquery to the right handside */
		symbol *tmp = lo;

		lo = ro;
		ro = tmp;

		if (compare_op[0] == '>')
			compare_op[0] = '<';
		else if (compare_op[0] == '<')
			compare_op[0] = '>';
	}

	ls = rel_value_exp(sql, rel, lo, f);
	if (!ls)
		return NULL;
	if (ro->token != SQL_SELECT) {
		rs = rel_value_exp(sql, rel, ro, f);
	} else {
		sql_rel *r = rel_subquery(sql, rel, ro);

		if (!r) {
			exp_destroy(ls);
			return NULL;
		}
		rs = exp_relation(r);
	}
	if (!rs) {
		exp_destroy(ls);
		return NULL;
	}
	return rel_compare_exp(sql, rel, ls, rs, compare_op, NULL, f);
}

static sql_rel *
rel_or(mvc *sql, sql_rel *l, sql_rel *r, int f)
{
	(void)sql;
	(void)f;
	return rel_setop(l, r, op_union);
}

static sql_rel *
rel_logical_exp(mvc *sql, sql_rel *rel, symbol *sc, int f)
{
	if (!sc)
		return NULL;
	switch (sc->token) {
	case SQL_OR:
	{
		symbol *lo = sc->data.lval->h->data.sym;
		symbol *ro = sc->data.lval->h->next->data.sym;
		sql_rel *ls = rel;
		sql_rel *rs = rel_copy(rel);

		ls = rel_logical_exp(sql, ls, lo, f);
		rs = rel_logical_exp(sql, rs, ro, f);

		return rel_or(sql, ls, rs, f);
	}
	case SQL_AND:
	{
		symbol *lo = sc->data.lval->h->data.sym;
		symbol *ro = sc->data.lval->h->next->data.sym;

		rel = rel_logical_exp(sql, rel, lo, f);
		if (!rel)
			return NULL;
		return rel_logical_exp(sql, rel, ro, f);
	}
	case SQL_COMPARE:
	{
		symbol *lo = sc->data.lval->h->data.sym;
		symbol *ro = sc->data.lval->h->next->next->data.sym;
		char *compare_op = sc->data.lval->h->next->data.sval;
		return rel_compare(sql, rel, lo, ro, compare_op, f);
	}
		break;
	/* Set Member ship */
	case SQL_IN:
	case SQL_NOT_IN:
	{
		dlist *dl = sc->data.lval;
		symbol *lo = dl->h->data.sym;
		sql_exp *l = rel_value_exp(sql, rel, lo, f);
		sql_rel *r = NULL;

		if (!l)
			return NULL;

		/* value list */
		if (dl->h->next->type == type_list) {
			dnode *n = dl->h->next->data.lval->h;
			list *exps = new_exp_list();

			for (; n; n = n->next) {
				symbol *sval = n->data.sym;
				sql_exp *r = rel_value_exp(sql, rel, sval, f);

				list_append(exps, r);
			}
			r = rel_project(NULL, exps );
		} else if (dl->h->next->type == type_symbol) {
			symbol *ro = dl->h->next->data.sym;

			r = rel_subquery(sql, rel, ro);
		}
		if (!r) 
			return r;
		/* create join column expressions */
		/*
		return rel_join(sql, rel, le, re, cmp, ee); 
		*/
		return NULL;
	}
	case SQL_EXISTS:
	case SQL_NOT_EXISTS:
	{
		symbol *lo = sc->data.sym;
		sql_rel *l = rel_subquery(sql, rel, lo);
		char *cmp;

		if (!l)
			return NULL;

		/* change to aggr(count(*)) ==/<> 0 */
		if (sc->token == SQL_EXISTS) {
 			cmp = "<>";
		/* change to aggr(count(*)) == 1 */
		} else {	/* NOT EXISTS */
 			cmp = "=";
		}
		/* 
		rel_groupby( l, exp_aggr(count) as "exists count", distinct); 
		le = exp_column( NULL, "exists count", it ); 
		re = exp_atom_int(1); 
		return rel_compare_exp(sql, rel, le, re, cmp, ee, f); 
		*/
		(void)cmp;
		return NULL;
	}
	case SQL_LIKE:
	case SQL_NOT_LIKE:
	{
		symbol *lo = sc->data.lval->h->data.sym;
		symbol *ro = sc->data.lval->h->next->data.sym;
		sql_subtype *st = sql_bind_localtype("str");
		sql_exp *le = rel_value_exp(sql, rel, lo, f);
		sql_exp *re, *ee = NULL;

		if (!le)
			return NULL;
		/* Do we need to escape ? */
		if (dlist_length(ro->data.lval) == 2) {
			char *escape = ro->data.lval->h->next->data.sval;
			ee = exp_atom(atom_string(sql_dup_subtype(st), _strdup(escape), 1));
		}
		ro = ro->data.lval->h->data.sym;
		re = rel_value_exp(sql, rel, ro, f);
		if (!re)
			return NULL;
		if ((re = rel_check_type(sql, st, re, type_equal)) == NULL) {
			return sql_error(sql, 02, "Wrong type used with LIKE statement, should be string");
		}
		if (sc->token == SQL_LIKE) 
			return rel_compare_exp(sql, rel, le, re, "l", ee, f);
		return rel_compare_exp(sql, rel, le, re, "n", ee, f);
	}
	case SQL_BETWEEN:
	case SQL_NOT_BETWEEN:
	{
		symbol *lo = sc->data.lval->h->data.sym;
		int symmetric = sc->data.lval->h->next->data.ival;
		symbol *ro1 = sc->data.lval->h->next->next->data.sym;
		symbol *ro2 = sc->data.lval->h->next->next->next->data.sym;
		sql_exp *le = rel_value_exp(sql, rel, lo, f);
		sql_exp *re1 = rel_value_exp(sql, rel, ro1, f);
		sql_exp *re2 = rel_value_exp(sql, rel, ro2, f);
		sql_subtype *ct = NULL;

		if (!le || !re1 || !re2) {
			exp_destroy(le);
			exp_destroy(re1);
			exp_destroy(re2);
			return NULL;
		}
		ct = exp_subtype(le);
		re1 = rel_check_type(sql, ct, re1, type_equal);
		re2 = rel_check_type(sql, ct, re2, type_equal);

		if (!re1 || !re2) {
			exp_destroy(le);
			exp_destroy(re1);
			exp_destroy(re2);
			return NULL;
		}

		if (symmetric) {
			sql_exp *tmp = NULL;
			sql_subfunc *min = sql_bind_func(sql->trans->module, "min", exp_subtype(re1), exp_subtype(re2));
			sql_subfunc *max = sql_bind_func(sql->trans->module, "max", exp_subtype(re1), exp_subtype(re2));

			if (!min || !max) {
				return sql_error(sql, 02, "min or max operator on types %s %s missing", exp_subtype(re1)->type->sqlname, exp_subtype(re2)->type->sqlname);
			}
			tmp = exp_binop(re1, re2, min);
			re2 = exp_binop(exp_dup(re1), exp_dup(re2), max);
			re1 = tmp;
		}

		if (sc->token == SQL_NOT_BETWEEN) {
			rel = rel_compare_exp(sql, rel, le, re1, "<", NULL, f);
			rel = rel_compare_exp(sql, rel, exp_dup(le), re2, ">", NULL, f);
		} else {
			rel = rel_compare_exp(sql, rel, le, re1, ">=", NULL, f);
			rel = rel_compare_exp(sql, rel, exp_dup(le), re2, "<=", NULL, f);
		}
		return rel;
	}
	case SQL_NULL:
	case SQL_NOT_NULL:
	/* is (NOT) NULL */
	{
		sql_exp *re, *le = rel_value_exp(sql, rel, sc->data.sym, f);

		if (!le)
			return NULL;
		re = exp_atom(atom_general(sql_dup_subtype(sql_bind_localtype("str")), NULL, 0));
		if (sc->token == SQL_NULL) 
			return rel_compare_exp(sql, rel, le, re, "=", NULL, f);
		else
			return rel_compare_exp(sql, rel, le, re, "!=", NULL, f);
	}
	case SQL_ATOM: {
		/* TRUE or FALSE */
		AtomNode *an = (AtomNode *) sc;
		sql_exp *e = exp_atom(atom_dup(an->a));
		return rel_select(rel, e);
	} 
	default:
		return sql_error(sql, 02, "Predicate %s %d: time to implement some more", token2string(sc->token), sc->token);
	}
	return sql_error(sql, 02, "Predicate: time to implement some more");
}

static sql_exp *
rel_op(mvc *sql, sql_rel *rel, symbol *se )
{
	dnode *l = se->data.lval->h;
	sql_subfunc *f = NULL;

	(void) rel;

	f = sql_bind_func(sql->trans->module, l->data.sval, NULL, NULL);
	if (f) {
		return exp_op(NULL, f);
	} else {
		return sql_error(sql, 02, "operator: %s() unknown", l->data.sval);
	}
	return NULL;
}

static sql_exp *
rel_unop(mvc *sql, sql_rel *rel, symbol *se, int fs)
{
	dnode *l = se->data.lval->h;
	char *fname = l->data.sval;
	sql_subfunc *f = NULL;
	sql_subtype *t = NULL;
	sql_exp *e = rel_value_exp(sql, rel, l->next->data.sym, fs);

	if (!e)
		return NULL;
	t = exp_subtype(e);
	f = sql_bind_func(sql->trans->module, fname, t, NULL);
	/* try to find the function without a type, and convert
	 * the value to the type needed by this function!
	 */
	if (!f && (f = sql_find_func(sql->trans->module, fname, 1)) != NULL) {
		sql_arg *a = f->func->ops->h->data;

		e = rel_check_type(sql, a->type, e, type_equal);
		if (!e) {
			sql_subfunc_destroy(f);
			f = NULL;
		}
	}
	if (f) {
		if (f->func->imp) {
			if (f->func->res->scale == INOUT) {
				f->res->digits = t->digits;
				f->res->scale = t->scale;
			}
			return exp_unop(e, f);
		/*
		} else {
			stmt *res;
			sql_arg *a = f->func->ops->h->data;

			sql_add_param(sql, _strdup(a->name), e);

			res = sqlparse_intern(sql, f->func->imp);
			sql_subfunc_destroy(f);
			return res;
		*/
		}
	} else if (e) {
		char *type = exp_subtype(e)->type->sqlname;

		exp_destroy(e);
		return sql_error(sql, 02, "unary operator %s(%s) unknown", l->data.sval, type);
	}
	return NULL;
}


static sql_exp *
rel_binop_(mvc *sql, sql_exp *l, sql_exp *r, char *fname)
{
	sql_exp *res = NULL;
	sql_subtype *t1, *t2;
	sql_subfunc *f = NULL;

	t1 = exp_subtype(l);
	t2 = exp_subtype(r);

	f = sql_bind_func(sql->trans->module, fname, t1, t2);
	if (!f && is_commutative(fname)) {
		f = sql_bind_func(sql->trans->module, fname, t2, t1);
		if (f) {
			sql_subtype *tmp = t1;
			t1 = t2;	
			t2 = tmp;
			res = l;		
			l = r;
			r = res;
		}
	}
	if (f) {
		if (f->func->res->scale == SCALE_FIX) {
			l = exp_fix_scale(sql, t2, l, 0, 0);
			r = exp_fix_scale(sql, t1, r, 0, 0);
		} else if (f->func->res->scale == SCALE_SUB) {
			l = exp_scale_algebra(sql, f, l, r);
		} else if (f->func->res->scale == SCALE_ADD) {
			l = exp_sum_scales(sql, f, l, r);
		} else if (f->func->res->scale == DIGITS_ADD) {
			f->res->digits = t1->digits + t2->digits;
		}
		return exp_binop(l, r, f);
	} else {
		int digits = t1->digits + t2->digits;

		if ((f = sql_bind_member(sql->trans->module, fname, t1, 2)) != NULL) {
			/* try finding function based on first argument */
			node *m = f->func->ops->h;
			sql_arg *a = m->next->data;

			r = rel_check_type(sql, a->type, r, type_equal);
			if (r)
				return exp_binop(l, r, f);
		} else if (rel_convert_types(sql, &l, &r, 0) >= 0) {
			/* try operators */
			t1 = exp_subtype(l);
			t2 = exp_subtype(r);
			f = sql_bind_func(sql->trans->module, fname, t1, t2);
			if (f) {
				if (f->func->res->scale == SCALE_FIX) {
					l = exp_fix_scale(sql, t2, l, 0, 0);
					r = exp_fix_scale(sql, t1, r, 0, 0);
				} else if (f->func->res->scale == SCALE_SUB) {
					l = exp_scale_algebra(sql, f, l, r);
				} else if (f->func->res->scale == SCALE_ADD) {
					l = exp_sum_scales(sql, f, l, r);
				} else if (f->func->res->scale == DIGITS_ADD) {
					f->res->digits = digits;
				}
				return exp_binop(l, r, f);
			}
		}
	}
	if (r && l)
		res = sql_error(sql, 02, "binary operator %s(%s,%s) unknown", fname, exp_subtype(l)->type->sqlname, exp_subtype(r)->type->sqlname);
	if (l)
		exp_destroy(l);
	if (r)
		exp_destroy(r);
	return res;
}

static sql_exp *
rel_binop(mvc *sql, sql_rel *rel, symbol *se, int f)
{
	dnode *dl = se->data.lval->h;
	sql_exp *l = rel_value_exp(sql, rel, dl->next->data.sym, f);
	sql_exp *r = rel_value_exp(sql, rel, dl->next->next->data.sym, f);

	if (!l || !r) {
		if (l)
			exp_destroy(l);
		if (r)
			exp_destroy(r);
		return NULL;
	}

	return rel_binop_(sql, l, r, dl->data.sval);
}

static sql_exp *
rel_nop(mvc *sql, sql_rel *rel, symbol *se, int fs)
{
	dnode *l = se->data.lval->h;
	dnode *ops = l->next->data.lval->h;
	list *exps = new_exp_list();
	list *tl = list_create(NULL);
	sql_subfunc *f = NULL;

	for (; ops; ops = ops->next) {
		sql_exp *e = rel_value_exp(sql, rel, ops->data.sym, fs);

		if (!e) {
			list_destroy(exps);
			return NULL;
		}
		list_append(exps, e);
		list_append(tl, exp_subtype(e));
	}
	f = sql_bind_func_(sql->trans->module, l->data.sval, tl);
	list_destroy(tl);
	if (f) {
		return exp_op(exps, f);
	} else if ((f = sql_bind_member(sql->trans->module, l->data.sval, exp_subtype(exps->h->data), list_length(exps))) != NULL) {
		node *n, *m;
		list *nexps = new_exp_list();

		n = exps->h;
		list_append(nexps, exp_dup(n->data));
		m = f->func->ops->h;
		for (n = n->next, m = m->next; n && m; n = n->next, m = m->next) {
			sql_arg *a = m->data;
			sql_exp *e = exp_dup(n->data);

			e = rel_check_type(sql, a->type, e, type_equal);
			if (!e) {
				list_destroy(nexps);
				nexps = NULL;
				break;
			}
			list_append(nexps, e);
		}
		if (nexps) {
			list_destroy(exps);
			return exp_op(nexps, f);
		}
	}
	list_destroy(exps);
	return sql_error(sql, 02, "operator: %s unknown", l->data.sval);
}

static str
number2name(str s, int len, int i)
{
	s[--len] = 0;
	while(i>0) {
		s[--len] = '0' + (i & 7);
		i >>= 3;
	}
	return s + len;
}

static sql_exp *
rel_aggr(mvc *sql, sql_rel *rel, symbol *se, int f)
{
	char name[16], *nme;
	dlist *l = se->data.lval;
	sql_subaggr *a = NULL;
	int distinct = l->h->next->data.ival;
	char *aggrstr = l->h->data.sval;
	sql_exp *e = NULL, *exp = NULL;
	sql_rel *groupby; 

	groupby = rel;
	while(groupby->l && groupby->op != op_groupby && groupby->op != op_basetable)
		groupby = groupby->l;

	if (groupby->op != op_groupby) {
		/* UGH, implicite groupby, we need to overwrite relation rel */
		/* TODO add function for overwrites (happens a lot) */
		groupby = rel_groupby(rel_copy(rel), NULL, NULL);
		/* destroy rel but keep structure */
		rel_destroy_(rel);
		*rel = *groupby;
		_DELETE(groupby);
		groupby = rel;
	}

	if (f == sql_where && !groupby) 
		return sql_error(sql, 02, "aggregates not allowed in WHERE clause");
	
	if (!l->h->next->next->data.sym) {	/* count(*) case */

		if (strcmp(aggrstr, "count") != 0) {
			return sql_error(sql, 02, "unable to perform %s(*) aggregate", l->h->data.sval);
		}
		a = sql_bind_aggr(sql->trans->module, aggrstr, NULL);
		/* add aggr expression to the groupby, and return an 
			column expression */
		e = exp_aggr(NULL, a, distinct);
		nme = number2name(name, 16, list_length(groupby->r));
		exp_set_name(e, nme);
		rel_groupby_add_aggr(groupby, e);
		exp = exp_alias(groupby->name, nme, e);
		return exp;
	} else {
		/* use cnt as nils shouldn't to be counted */
		if (strcmp(aggrstr, "count") == 0) {
			aggrstr = "count_no_nil";
		}
		e = rel_value_exp(sql, rel, l->h->next->next->data.sym, f);
	}

	if (!e)
		return NULL;
	a = sql_bind_aggr(sql->trans->module, aggrstr, exp_subtype(e));
	if (a) {
		/* type may have changed, ie. need to fix_scale */
		sql_subtype *t = exp_subtype(e);
		list *exps = new_exp_list();

		list_append(exps, e);
		e = exp_aggr(exps, a, distinct);
		nme = number2name(name, 16, list_length(groupby->r));
		exp_set_name(e, nme);
		rel_groupby_add_aggr(groupby, e);
		exp = exp_alias(groupby->name, nme, e);
		return exp_fix_scale(sql, t, exp, 1, (t->type->scale == SCALE_FIX));
	} else {
		char *type = exp_subtype(e)->type->sqlname;

		exp_destroy(e);
		return sql_error(sql, 02, "aggregate: %s(%s) unknown", l->h->data.sval, type);
	}
	return NULL;
}

static sql_exp *
rel_cast(mvc *sql, sql_rel *rel, symbol *se, int f)
{

	dlist *dl = se->data.lval;
	symbol *s = dl->h->data.sym;
	sql_subtype *tpe = dl->h->next->data.typeval;

	sql_exp *e = rel_value_exp(sql, rel, s, f);

	if (e)
		return rel_check_type(sql, tpe, e, type_cast);
	return NULL;
}


static sql_exp *
rel_value_exp(mvc *sql, sql_rel *rel, symbol *se, int f)
{
	switch (se->token) {
	case SQL_OP:
		return rel_op(sql, rel, se );
	case SQL_UNOP:
		return rel_unop(sql, rel, se, f);
	case SQL_BINOP:
		return rel_binop(sql, rel, se, f);
	case SQL_NOP:
		return rel_nop(sql, rel, se, f);
	case SQL_AGGR:
		return rel_aggr(sql, rel, se, f);
	case SQL_COLUMN:
		return rel_column_ref(sql, rel, se );
	case SQL_SELECT:{
		sql_rel *r = rel_subquery(sql, rel, se);

		/* convert relation into expression, limit to single columns */
		if (r && r->op == op_project && list_length(r->exps) == 1) {
			return exp_relation(r);
		} else if (r) {
			rel_destroy(r);
		}
		return NULL;
	}
	/*
	case SQL_PARAMETER:{
		char *n = "param";
		stmt *s;

		if (sql->mode != m_prepare) {
			return sql_error(sql, 02, "Cannot have parameters (?) in normal queries, use PREPARE;");
		}
		sql_add_param(sql, _strdup(n), s = stmt_var(_strdup(n), NULL));
		return stmt_dup(s);
	}
	case SQL_NULL:
		return stmt_atom(atom_general(sql_dup_subtype(sql_bind_localtype("str")), NULL, 0));
	*/
	case SQL_ATOM:{
		AtomNode *an = (AtomNode *) se;

		if (!an || !an->a) {
			return exp_atom(atom_general(sql_dup_subtype(sql_bind_localtype("str")), NULL, 0));
		} else {
			return exp_atom(atom_dup(an->a));
		}
	}
	case SQL_CAST:
		return rel_cast(sql, rel, se, f);
	/*
	case SQL_CASE:
		return sql_case_exp(sql, scp, se, grp, subset, f);
	case SQL_COALESCE:
	case SQL_NULLIF:
		return sql_case_exp(sql, scp, se, grp, subset, f);
	*/
	default: {
		sql_rel *r = rel_logical_exp(sql, rel, se, f);
		if (!r)
			return NULL;
		if (r->op == op_project && list_length(r->exps) == 1) {
			sql_exp *e = exp_dup(r->exps->h->data);
			rel_destroy(r);
			return e;
		} else {
			return exp_relation(r);
		}
		}
	}
	return NULL;
}

static sql_exp *
column_exp(mvc *sql, sql_rel *rel, symbol *column_e, int f)
{
	dlist *l = column_e->data.lval;
	sql_exp *ve = rel_value_exp(sql, rel, l->h->data.sym, f);

	if (!ve)
		return NULL;
	/* AS name */
	if (ve && l->h->next->data.sval) 
		exp_set_name(ve, l->h->next->data.sval);
	return ve;
}

static list *
rel_table_exp(mvc *sql, sql_rel *rel, symbol *column_e )
{
	if (column_e->token == SQL_TABLE) {
		char *tname = column_e->data.lval->h->data.sval;
		sql_rel *p, *r = rel_bind_table(&p, rel, tname);

		(void)p;
		if (r) 
			return rel_projections( r, tname );
		return sql_error(sql, 02, 
			"Column expression Table %s unknown", tname);
	}
	return NULL;
}

static sql_exp *
rel_column_exp(mvc *sql, sql_rel *rel, symbol *column_e, int f)
{
	if (column_e->token == SQL_COLUMN) {
		return column_exp(sql, rel, column_e, f);
	}
	return NULL;
}

static sql_rel *
rel_simple_select(mvc *sql, sql_rel *rel, symbol *where, dlist *selection)
{
	list *exps;
	dnode *n = selection->h;

	(void) where;
	if (where) {
		sql_rel *r = rel_logical_exp(sql, rel, where, sql_where);
		if (!r)
			return NULL;
		rel = r;
	}
	exps = new_exp_list();
	for (; n; n = n->next ) {
		/* Here we could get real column expressions (including single
		 * atoms) but also table results. Therefor we try both
		 * rel_column_exp and rel_table_exp.
		 */
		list *te = NULL; 
		sql_exp *ce = rel_column_exp(sql, rel, n->data.sym, sql_sel);

		if (ce) {
			list_append(exps, ce);
			continue;
		} else {
			te = rel_table_exp(sql, rel, n->data.sym );
		}
		if (!ce && !te) {
			list_destroy(exps);
			return NULL;
		}
		/* here we should merge the column expressions we obtained
		 * sofar with the table expression, ie t1.* or a subquery 
		 */
		if (te) {
			exps = list_merge( exps, te, (fdup)&exp_dup);
			/*list_destroy(te);*/
		}
	}
	rel = rel_project(rel, exps);
	return rel;
}

static sql_rel *
rel_group_by(mvc *sql, sql_rel *rel, symbol *groupby )
{
	dnode *o = groupby->data.lval->h;
	list *exps = new_exp_list();

	for (; o; o = o->next) {
		symbol *grp = o->data.sym;
		sql_exp *e = rel_column_ref(sql, rel, grp);

		if (!e) {
			list_destroy(exps);
			return NULL;
		}
		e->card = CARD_AGGR; /* group by column */ 
		list_append(exps, e);
	}
	return rel_groupby( rel, list_dup(exps, (fdup)&exp_dup), exps );
}

static sql_rel *
rel_order_by(mvc *sql, sql_rel *rel, symbol *orderby )
{
	list *exps = new_exp_list();
	dnode *o = orderby->data.lval->h;

	for (; o; o = o->next) {
		symbol *order = o->data.sym;

		if (order->token == SQL_COLUMN) {
			symbol *col = order->data.lval->h->data.sym;
			int direction = order->data.lval->h->next->data.ival;
			sql_exp *e = rel_column_ref(sql, rel, col);

			if (!e) {
				list_destroy(exps);
				return NULL;
			}
			list_append(exps, e);
			list_append(exps, exp_atom_int(direction) );
		} else {
			return sql_error(sql, 02, "order not of type SQL_COLUMN\n");
		}
	}
	return rel_orderby( rel, exps);
}

static sql_rel *
join_on_column_name(mvc *sql, sql_rel *rel, sql_rel *t1, sql_rel *t2, int all)
{
	int found = 0;
	list *res;
	list *exps = rel_projections( t1, NULL);
	node *n;

	if (!exps)
		return NULL;
 	res = create_stmt_list();
	for (n = exps->h; n; n = n->next) {
		sql_exp *lc = n->data;
		sql_exp *rc = rel_bind_column(t2, lc->name);

		if (rc) {
			found = 1;
			rel = rel_compare_exp(sql, rel, lc, rc, "=", NULL, sql_where);
		} else if (all) {
			found = 0;
			break;
		}
	}
	list_destroy(exps);
	if (!found) {
		rel_destroy(rel);
		return sql_error(sql, 02, "no%s columns of tables %s and %s match\n", (all)?"t all":"", rel_get_name(t1), rel_get_name(t2));
	}
	return rel;
}


sql_rel *exp_top_relation(sql_exp *e )
{
	switch(e->type) {	
	case e_atom:
		return NULL;
	case e_relation:
		if (e->l)
			return e->l;
		return NULL;
	case e_exp:
	case e_convert: 
	case e_cmp:
		if (e->l)
			return exp_top_relation(e->l);
		break;
	case e_column:
	default:
		return NULL;
	}
	return NULL;
}

static sql_rel *
rel_select_exp(mvc *sql, sql_rel *rel, SelectNode *sn, int toplevel)
{
	int aggr = 0;

	if (!sn->from)
		return rel_simple_select(sql, rel, sn->where, sn->selection);

	if (sn->where) {
		sql_rel *r = rel_logical_exp(sql, rel, sn->where, sql_where);
		if (!r) 
			return sql_error(sql, 02, "Subquery result missing");
		rel = r;
	}

	if (rel) {
		if (rel && sn->groupby) {
			rel = rel_group_by(sql, rel, sn->groupby );

			if (!rel) 
				return NULL;
			aggr = 1;
		}

		/* TODO ?? outer refs ?? */
	}

	if (sn->having) {
		/* having implies group by, ie if not supplied do a group by */
		if (rel->op != op_groupby) 
			rel = rel_groupby( rel, NULL, NULL);

		aggr = 1;
		rel = rel_logical_exp(sql, rel, sn->having, sql_search);

		if (!rel) 
			return NULL;
		if (rel -> exps && exps_card(rel->exps) > CARD_AGGR) {
			/* clean up missing */
			return sql_error(sql, 02, "cannot compare sets with values, probably an aggregate function missing");
		}
	}

	if (sn->selection) {
		list *exps = new_exp_list();
		dnode *n = sn->selection->h;
		int card = 0;

		for (; n; n = n->next) {
			/* Here we could get real column expressions 
			 * (including single atoms) but also table results. 
			 * Therefor we try both rel_column_exp 
			 * and rel_table_exp.
		 	 */
			list *te = NULL; 
			sql_exp *ce = rel_column_exp(sql, rel, n->data.sym, sql_sel);
			if (ce) {
				sql_rel *r;

				if (!card)
					card = ce->card;
				if (card && card != ce->card && ce->card != CARD_ATOM && card != CARD_ATOM) {
					exp_destroy(ce);
					list_destroy(exps);
					if (rel) rel_destroy(rel);
					return sql_error(sql, 02, "single value in column expression");
				}
				if (ce->card > card)
					card = ce->card;
					
				/* ce may contain subqueries we need to rewrite */
				if ((r = exp_top_relation(ce)) && r != rel) {
					/* move all exps into r */ 
					node *n;
					if (r->op != op_project) {
						assert(0);
						return NULL;
					}
						
					for (n = exps->h; n; n = n->next) {
						list_append(r->exps, n->data);
					}
					ce = exp_copy(ce);
					list_append(exps, ce);
					rel = rel_copy(r);
					/* TODO leaking ... */
				} else {
					list_append(exps, ce);
				}
				continue;
			} else {
				te = rel_table_exp(sql, rel, n->data.sym);
			}
			if (!ce && !te) {
				list_destroy(exps);
				return NULL;
			}
			/* here we should merge the column expressions we 
			 * obtained sofar with the table expression, ie 
			 * t1.* or a subquery.
		 	 */
			exps = list_merge( exps, te, (fdup)&exp_dup);
			/*list_destroy(te);*/
		}
		rel = rel_project(rel, exps);
	} else {
		/* select * from tables */

		if (aggr) {
			rel_destroy(rel);
			return sql_error(sql, 02, "Cannot combine select * with group by");
		}

		if (toplevel) {
			rel = rel_project(rel, rel_projections(rel, NULL));
		} else {
			/* 
			 * subquery can only return one column
			 */
		}
	}

	if (rel && sn->distinct) 
		rel = rel_distinct(rel);

	if (rel && sn->orderby) 
		rel = rel_order_by(sql, rel, sn->orderby);

	if (!rel) 
		return NULL;

	if (sn->limit > 0 || sn->offset > 0) {
		list *exps = new_exp_list();

		list_append(exps, exp_atom_int(sn->limit));
		if (sn->offset > 0)
			list_append(exps, exp_atom_int(sn->offset));
		rel = rel_topn(rel, exps);
	}
	return rel;
}


sql_rel *
rel_query(mvc *sql, sql_rel *rel, symbol *sq, int toplevel)
{
	sql_rel *res = NULL;
	SelectNode *sn = (SelectNode *) sq;

	assert(sn->s.token == SQL_SELECT);

	if (!toplevel && sn->limit >= 0)
		return sql_error(sql, 01, "Can only limit outer select ");

	if (!toplevel && sn->orderby)
		return sql_error(sql, 01, "Can only order by outer select ");

	if (sn->from) {		/* keep variable list with tables and names */
		dlist *fl = sn->from->data.lval;
		dnode *n = NULL;
		sql_rel *fnd = NULL;

		for (n = fl->h; n ; n = n->next) {
			fnd = table_ref(sql, rel, n->data.sym);

			if (!fnd)
				break;
			if (res) 
				res = rel_crossproduct(res, fnd, op_join);
			else 
				res = fnd;
		}
		if (rel) /* We need to make sure this sub query returns
			    one value per left relation (outer reference) */
			res = rel_crossproduct(rel_copy(rel), res, op_left);

		if (!fnd) {
			if (res)
				rel_destroy(res);
			return NULL;
		}

	} else if (toplevel) {	/* only on top level query */
		return rel_simple_select(sql, rel, sn->where, sn->selection);
	}
	return rel_select_exp(sql, res, sn, toplevel);
}

static sql_rel *
rel_joinquery_(mvc *sql, sql_rel *rel, symbol *tab1, int natural, jt jointype, symbol *tab2, symbol *js)
{
	operator_type op = op_join;
	sql_rel *t1, *t2;

	t1 = table_ref(sql, rel, tab1);
	t2 = table_ref(sql, rel, tab2);

	if (!t1 || !t2)
		return NULL;

	switch(jointype) {
	case jt_inner: op = op_join;
		break;
	case jt_left: op = op_left;
		break;
	case jt_right: op = op_right;
		break;
	case jt_full: op = op_full;
		break;
	case jt_union:
		/* fool compiler */
		return NULL;
	}
	rel = rel_crossproduct(t1, t2, op);

	if (js && natural) {
		return sql_error(sql, 02, "cannot have a NATURAL JOIN with a join specification (ON or USING);");
	}
	if (!js && !natural) {
		return sql_error(sql, 02, "must have NATURAL JOIN or a JOIN with a specification (ON or USING);");
	}

	if (js && js->token != SQL_USING) {	/* On sql_logical_exp */
		rel = rel_logical_exp(sql, rel, js, sql_where);
	} else if (js) {	/* using */
		dnode *n = js->data.lval->h;

		for (; n; n = n->next) {
			char *nm = n->data.sval;

			sql_exp *ls = rel_bind_column(t1, nm);
			sql_exp *rs = rel_bind_column(t2, nm);

			if (!ls || !rs) {
				if (ls)
					exp_destroy(ls);
				if (rs)
					exp_destroy(rs);
				sql_error(sql, 02, "tables %s and/or %s do not have a matching column %s\n", rel_get_name(t1), rel_get_name(t2), nm);
				rel_destroy(rel);
				return NULL;
			}
			rel = rel_compare_exp(sql, rel, ls, rs, "=", NULL, sql_where);
			if (!rel)
				return NULL;
		}
	} else {		/* ! js -> natural join */
		rel = join_on_column_name(sql, rel, t1, t2, 0);
	}
	return rel;
}

static sql_rel *
rel_joinquery(mvc *sql, sql_rel *rel, symbol *q)
{

	dnode *n = q->data.lval->h;
	symbol *tab_ref1 = n->data.sym;
	int natural = n->next->data.ival;
	jt jointype = (jt) n->next->next->data.ival;
	symbol *tab_ref2 = n->next->next->next->data.sym;
	symbol *joinspec = n->next->next->next->next->data.sym;

	return rel_joinquery_(sql, rel, tab_ref1, natural, jointype, tab_ref2, joinspec);
}

static sql_rel *
rel_crossquery(mvc *sql, sql_rel *rel, symbol *q)
{
	dnode *n = q->data.lval->h;
	symbol *tab1 = n->data.sym;
	symbol *tab2 = n->next->data.sym;
	sql_rel *t1 = table_ref(sql, rel, tab1);
	sql_rel *t2 = table_ref(sql, rel, tab2);

	if (!t1 || !t2)
		return NULL;

	rel = rel_crossproduct(t1, t2, op_join);
	return rel;
}

static sql_rel *
rel_subquery(mvc *sql, sql_rel *rel, symbol *sq)
{
	int toplevel = (rel) ? 0 : 1;

	return rel_query(sql, rel, sq, toplevel);
}

sql_rel *
rel_selects(mvc *sql, symbol *s)
{
	sql_rel *ret = NULL;

	switch (s->token) {
	case SQL_SELECT:
		ret = rel_subquery(sql, NULL, s);
		sql->type = Q_TABLE;
		break;
	case SQL_JOIN:
		ret = rel_joinquery(sql, NULL, s);
		sql->type = Q_TABLE;
		break;
	case SQL_CROSS:
		ret = rel_crossquery(sql, NULL, s);
		sql->type = Q_TABLE;
		break;
	case SQL_UNION:
		sql->type = Q_TABLE;
		break;
	case SQL_EXCEPT:
		sql->type = Q_TABLE;
		break;
	case SQL_INTERSECT:
		sql->type = Q_TABLE;
		break;

	default:
		return NULL;
	}
	if (mvc_debug_on(sql,32768)) {
		rel_print(sql, ret, 0);
		printf("\n");
	}
	return ret;
}
