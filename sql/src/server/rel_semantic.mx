@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f rel_semantic
@a N.J. Nes
@* 

@h
#ifndef _REL_SEMANTIC_H_
#define _REL_SEMANTIC_H_

#include <sql_list.h>
#include "sql_symbol.h"
#include "sql_parser.h"
#include "sql_relation.h"
#include <stdarg.h>

extern sql_rel *rel_semantic(mvc *sql, symbol *sym);
extern sql_rel * rel_parse(mvc *m, char *query);

#endif /*_REL_SEMANTIC_H_*/

@c

#include "sql_parser.h"
#include "sql_symbol.h"
#include "rel_semantic.h"
#include "rel_select.h"

#include <unistd.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>

sql_rel *
rel_parse(mvc *m, char *query)
{
	mvc o = *m;
	sql_rel *rel;
	buffer *b;
	char *n;
	int len = strlen(query);

	m->qc = NULL;

	m->cache = 0;

	b = (buffer*)GDKmalloc(sizeof(buffer));
	n = GDKmalloc(len + 1 + 1);
	strncpy(n, query, len);
	query = n;
	query[len] = '\n';
	query[len+1] = 0;
	len++;
	buffer_init(b, query, len);
	scanner_init( &m->scanner, 
		bstream_create(buffer_rastream(b, "sqlstatement"), b->len),
		NULL);
	m->scanner.mode = LINE_1; 
	bstream_next(m->scanner.rs);

	m->params = NULL;
	m->args = NULL;
	m->sym = NULL;
	m->errstr[0] = '\0';
	m->status = 0;
	/* via views we give access to protected objects */
	m->user_id = USER_MONETDB;

	(void) sqlparse(m);	/* blindly ignore errors */
	rel = rel_semantic(m, m->sym);

	GDKfree(query);
	GDKfree(b);
	bstream_destroy(m->scanner.rs);

	m->sym = NULL;
	if (m->status || m->errstr[0]) {
		int status = m->status;
		char errstr[ERRSIZE];

		strcpy(errstr, m->errstr);
		*m = o;
		m->status = status;
		strcpy(m->errstr, errstr);
	} else {
		*m = o;
	}
	return rel;
}

sql_rel * 
rel_semantic(mvc *sql, symbol *s)
{
	if (!s)
		return NULL;

	switch (s->token) {

	case TR_COMMIT:
	case TR_SAVEPOINT:
	case TR_RELEASE:
	case TR_ROLLBACK:
	case TR_START:
	case TR_MODE:

	case SQL_CREATE_SCHEMA:
	case SQL_DROP_SCHEMA:
	case SQL_CREATE_TABLE:
	case SQL_DROP_TABLE:
	case SQL_ALTER_TABLE:
	case SQL_CREATE_VIEW:
	case SQL_DROP_VIEW:
	case SQL_CREATE_INDEX:
	case SQL_DROP_INDEX:
	case SQL_CREATE_USER:
	case SQL_DROP_USER:
	case SQL_ALTER_USER:
	case SQL_CREATE_ROLE:
	case SQL_DROP_ROLE:
	case SQL_GRANT_ROLES:
	case SQL_GRANT:
	case SQL_REVOKE:
	case SQL_CREATE_MODULE:
	case SQL_DROP_MODULE:
	case SQL_CREATE_TYPE:
	case SQL_CREATE_FUNC:

	case SQL_CREATE_SEQ:
	case SQL_DROP_SEQ:

	case SQL_COPYFROM:
	case SQL_INSERT:
	case SQL_UPDATE:
	case SQL_DELETE:

	case SQL_DECLARE:
	case SQL_SET:

	case SQL_PREP:
		/*return sql_error(sql, 02, "Not implemented");*/
		return NULL;

	case SQL_SELECT:
	case SQL_JOIN:
	case SQL_CROSS:
	case SQL_UNION:
	case SQL_EXCEPT:
	case SQL_INTERSECT:
		return rel_selects(sql, s);

	default:
		return sql_error(sql, 02, "symbol type not found");
	}
	return sql_error(sql, 02, "symbol type not found");
}
