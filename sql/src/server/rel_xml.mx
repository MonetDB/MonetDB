@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2008 CWI.
@' All Rights Reserved.

@f rel_xml
@a N.J. Nes
@* 

@h
#ifndef _REL_XML_H_ 
#define _REL_XML_H_ 

#include "rel_semantic.h"

extern sql_exp *rel_xml(mvc *sql, sql_rel **rel, symbol *s, int f);

#endif /*_REL_XML_H_ */
@c

#include "sql_config.h"
#include "rel_xml.h"
#include "rel_exp.h"
#include "rel_select.h"
#include "sql_semantic.h"
#include "sql_parser.h"

static sql_subtype xml_type = { NULL, 0, 0, NULL };
static sql_subtype str_type = { NULL, 0, 0, NULL };

static sql_exp *
rel_xmlelement(mvc *sql, sql_rel **rel, symbol *sym, int f) 
{
	dnode *d = sym->data.lval->h;
	char *tag = d->data.sval; 
	dlist *ns_attrs_elms = d->next->data.lval; 
	lng returning = d->next->next->data.ival;
	sql_exp *ns_st = NULL, *attr_st = NULL, *res = NULL;

	(void)returning;
	if (ns_attrs_elms) {
		symbol *ns = ns_attrs_elms->h->data.sym;
		symbol *attr = ns_attrs_elms->h->next->data.sym;
		dlist *content = ns_attrs_elms->h->next->next->data.lval;

		/* loop over the content, create recursive element  */
		if (content) {
			dnode *n;
			dlist *cl = content->h->data.lval;
			lng content_option = content->h->next->data.ival;

			(void)content_option;
			for (n=cl->h; n; n = n->next) {
				symbol *c = n->data.sym;
				sql_subtype *st; 
				sql_exp *c_st = rel_value_exp(sql, rel, c, f);

				if (!c_st) 
					return NULL;

				st = exp_subtype(c_st);
				assert(st);
				if (type_cmp(st->type, xml_type.type) != 0) {
					/* convert to string first */
					c_st = rel_check_type(sql, &str_type, c_st, type_equal);
					/* then to xml */
					if (!c_st || (c_st = rel_check_type(sql, &xml_type, c_st, type_equal)) == NULL) 
						return NULL;
				}
				
				/* lets glue the xml content together */
				if (res) {
					res = rel_binop_(sql, res, c_st, NULL, "concat"); 
				} else {
					res = c_st;
				}
			}
		}
		if (ns) { 
			ns_st = rel_value_exp(sql, rel, ns, f); 
			if (!ns_st)
				return NULL;
		}
		if (attr) {
			attr_st = rel_value_exp(sql, rel, attr, f); 
			if (!attr_st)
				return NULL;
		}
	}

	if (!ns_st)
		ns_st = exp_atom(atom_general(&str_type, NULL, 0));
	if (!attr_st)
		attr_st = exp_atom(atom_general(&xml_type, NULL, 0));
	if (!res)
		res = exp_atom(atom_general(&xml_type, NULL, 0));

	if (!ns_st || !attr_st || !res) {
		exp_destroy(ns_st);
		exp_destroy(attr_st);
		exp_destroy(res);
		return NULL;
	}
	return rel_nop_(sql, exp_atom_clob(tag), ns_st, attr_st, res, NULL, "element");
}

static sql_exp *
rel_xmlforest(mvc *sql, sql_rel **rel, symbol *sym, int f) 
{
	dnode *d = sym->data.lval->h;
	symbol *ns = d->data.sym;
	dlist *elms = d->next->data.lval;  
	lng content_option = d->next->next->data.ival;
	lng returning = d->next->next->next->data.ival;
	sql_exp *ns_st, *attr_st, *res = NULL;

	(void)content_option;
	(void)returning;

	if (ns) {
		ns_st = rel_value_exp(sql, rel, ns, f); 
	} else {
		ns_st = exp_atom(atom_general(&str_type, NULL, 0));
	}
	if (!ns_st)
		return NULL;
	attr_st = exp_atom(atom_general(&xml_type, NULL, 0));
	if (elms) {
		dnode *e;

		for (e = elms->h; e; e = e->next) {
			dnode *cc = e->data.lval->h;
			symbol *c = cc->data.sym;
			str tag = cc->next->data.sval;

			sql_exp *c_st = rel_value_exp(sql, rel, c, f);
			sql_subtype *st;
			if (!c_st) { 
				exp_destroy(ns_st);
				exp_destroy(attr_st);
				exp_destroy(res);
				return NULL;
			}

			st = exp_subtype(c_st);
			assert(st);
			if (type_cmp(st->type, xml_type.type) != 0) {
				/* convert to string first */
				c_st = rel_check_type(sql, &str_type, c_st, type_equal);
				/* then to xml */
				if (!c_st || (c_st = rel_check_type(sql, &xml_type, c_st, type_equal)) == NULL) {
					exp_destroy(ns_st);
					exp_destroy(attr_st);
					exp_destroy(res);
					return NULL;
				}
			}
				
			if (!tag) {
				tag = exp_name(c_st);
			} else {
				tag = _strdup(tag);
			}
			c_st = rel_nop_(sql, exp_atom_clob(tag), exp_dup(ns_st), exp_dup(attr_st), c_st, NULL, "element");
			/* lets glue the xml content together */
			if (res) {
				res = rel_binop_(sql, res, c_st, NULL, "concat"); 
			} else {
				res = c_st;
			}
		}
	}
	exp_destroy(ns_st);
	exp_destroy(attr_st);
	return res;
}

static sql_exp *
rel_xmlcomment(mvc *sql, sql_rel **rel, symbol *sym, int f) 
{
	dnode *d = sym->data.lval->h;
	symbol *comment = d->data.sym;
	lng returning = d->next->data.ival;
	sql_exp *comment_st;

	(void)returning;
	comment_st = rel_value_exp(sql, rel, comment, f); 
	if (!comment_st)
		return NULL;
	return rel_unop_(sql, comment_st, NULL, "comment"); 
}

static sql_exp *
rel_xmlattribute(mvc *sql, sql_rel **rel, symbol *sym, int f) 
{
	dnode *d = sym->data.lval->h;
	char *attr_name = d->data.sval;
	symbol *attr = d->next->data.sym;
	sql_exp *attr_st, *attr_name_st = NULL;

	attr_st = rel_value_exp(sql, rel, attr, f); 
	if (!attr_st)
		return NULL;
	if (!attr_name) {
		/*TODO:convert simple column names into valid attribute names */
		attr_name = exp_name(attr_st);
	}
	attr_name_st = exp_atom_str(attr_name, &str_type);
	return rel_binop_(sql, attr_name_st, attr_st, NULL, "attribute"); 
}


static sql_exp *
rel_xmlconcat(mvc *sql, sql_rel **rel, symbol *sym, int f) 
{
	dnode *d = sym->data.lval->h;
	dnode *en = d->data.lval->h;
	lng returning = d->next->data.ival;
	sql_exp *concat_st, *res = NULL;

	(void)returning;
	for (; en; en = en->next) {
		symbol *c = en->data.sym;
		concat_st = rel_value_exp(sql, rel, c, f); 
		if (!concat_st) {
			exp_destroy(res);
			return NULL;
		}
		if (res) 
			res = rel_binop_(sql, res, concat_st, NULL, "concat"); 
		else
			res = concat_st;
	}	
	return res;
}

static sql_exp *
rel_xmldocument(mvc *sql, sql_rel **rel, symbol *sym, int f) 
{
	dnode *d = sym->data.lval->h;
	symbol *val = d->data.sym;
	lng returning = d->next->data.ival;
	sql_exp *val_st;

	(void)returning;
	val_st = rel_value_exp(sql, rel, val, f); 
	if (!val_st)
		return NULL;
	return rel_unop_(sql, val_st, NULL, "document"); 
}

static sql_exp *
rel_xmlpi(mvc *sql, sql_rel **rel, symbol *sym, int f) 
{
	dnode *d = sym->data.lval->h;
	char *target = d->data.sval;
	symbol *val = d->next->data.sym;
	lng returning = d->next->next->data.ival;
	sql_exp *target_st, *val_st;

	(void)returning;
	target_st = exp_atom_str(target, &str_type);
	if (!val)
		val_st = rel_value_exp(sql, rel, val, f); 
	else
		val_st = exp_atom(atom_general(&str_type, NULL, 0));
	if (!val_st) {
		exp_destroy(target_st);
		return NULL;
	}
	return rel_binop_(sql, target_st, val_st, NULL, "pi"); 
}

/* cast string too xml */
static sql_exp *
rel_xmltext(mvc *sql, sql_rel **rel, symbol *sym, int f) 
{
	dnode *d = sym->data.lval->h;
	symbol *text = d->data.sym;
	lng returning = d->next->data.ival;
	sql_exp *text_st;

	(void)returning;
	text_st = rel_value_exp(sql, rel, text, f); 
	if (!text_st || (text_st = rel_check_type(sql, &xml_type, text_st, type_equal)) == NULL) 
		return NULL;
	return text_st;
}

sql_exp *
rel_xml(mvc *sql, sql_rel **rel, symbol *s, int f)
{
	sql_exp *ret = NULL;
	sql_type *t = NULL;

	if (!xml_type.type) {
		if ((t = mvc_bind_type(sql, "xml")) == NULL)
			return sql_error(sql, 02, "XML: xml type missing, probably the xml module wasn't added");
		sql_init_subtype(&xml_type, t, 0, 0);
		sql_find_subtype(&str_type, "clob", 0, 0);
	}

	switch (s->token) {
	case SQL_XMLELEMENT: 
		ret = rel_xmlelement(sql, rel, s, f);
		break;
	case SQL_XMLFOREST: 
		ret = rel_xmlforest(sql, rel, s, f);
		break;
	case SQL_XMLCOMMENT: 
		ret = rel_xmlcomment(sql, rel, s, f);
		break;
	case SQL_XMLATTRIBUTE: 
		ret = rel_xmlattribute(sql, rel, s, f);
		break;
	case SQL_XMLCONCAT: 
		ret = rel_xmlconcat(sql, rel, s, f);
		break;
	case SQL_XMLDOCUMENT: 
		ret = rel_xmldocument(sql, rel, s, f);
		break;
	case SQL_XMLPI: 
		ret = rel_xmlpi(sql, rel, s, f);
		break;
	case SQL_XMLTEXT: 
		ret = rel_xmltext(sql, rel, s, f);
		break;
	default:
		return sql_error(sql, 01, "XML statement unknown symbol(%ld)->token = %s", (long) s, token2string(s->token));
	}
	return ret;
}

