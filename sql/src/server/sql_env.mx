@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.

@f sql_env
@a N.J. Nes
@* Environment variables
The processing setting of the SQL front-end can collect information
for postprocessing and debugging by setting a flag
using the SQL construct: 
SET <variable>=<string> 
SET <variable>=<boolean>
SET <variable>=<int>

The SQL engine comes with a limited set of environment variables
to control its behavior. 
The 'debug' variable takes an integer and sets the Mserver global
debug flag. (See MonetDB documentation.)
The 'explain' variable currently takes the values 'plan' or
'performance'. The 'plan' qualifier produces a relational table with
the plan derived for execution using the applicable back end and
optimizer schemes. The 'performance' qualifier produces a performance
trace of the SQL queries for post analysis. It is available in
the system table called history. Omission of either qualifier merely
results in a straight execution of the query.

The 'auto_commit' flag takes a boolean and controls automatic commit
after a successful SQL execution, or conversely an automatic rollback.

The 'reply_size' limits the number of tuples sent to the front end.
[It is unclear how the remainder can be obtained within the SQL language
framework. The reply_size should be replaced by 'limit']
The 'history' variable is a boolean flag which captures execution information
of any SQL query in a table for post-analysis.

By default all remaining variables are stored as strings and 
any type analysis is up to the user. The can be freely used by the
SQL programmer for inclusion in his queries. [TODO]

The limited number of built-in variables defined above are 
strongly typed the hard way.
Moreover, they have a counterpart representation in the 
MVC structure to ease inspection during query processing.

The variables and their type definition are assembled in a system table
called 'sessions'.
@{
@h
#ifndef _SQL_ENV_H_
#define _SQL_ENV_H_

#include "sql_parser.h"
#include "sql_symbol.h"
#include "sql_statement.h"
#include "sql_mvc.h"

sql_export int mvc_debug_on( mvc *m, int flag);

sql_export stmt *env(mvc * sql, symbol * s); 

sql_export int sql_update_var(mvc *sql, char *name );
sql_export int sql_set_var_value(mvc *sql, char *name, char *value );

sql_export char * sql_get_var( mvc *sql, char *name );
sql_export char * sql_get_type( mvc *sql, char *name );

sql_export int sql_create_sessions(mvc *sql, sql_schema *s);
sql_export int sql_create_history(mvc *sql, sql_schema *s);
sql_export int sql_session(mvc *sql);

#endif /* _SQL_ENV_H_ */
@c
#include <bat.h>
#include "sql_env.h"
#include "sql_bm.h"
#include "sql_scope.h"
#include "sql_select.h"
#include "sql_updates.h"
#include "sql_semantic.h"
#include "sql_privileges.h"

#define SESSION_RW 0
#define SESSION_RO 1

int mvc_debug_on( mvc *m, int flg)
{
	
	if (m->debug&flg)
		return 1;

	return 0;
}

char * 
sql_get_var( mvc *sql, char *name )
{
	BAT *n = mvc_bind( sql, "sys", "sessions", "name", 0); 
	BAT *v = mvc_bind( sql, "sys", "sessions", "value", 0); 
	char *val = NULL;
	BUN p;

	if ((p=BUNfnd(BATmirror(n), name))) {
		val = BUNtail(v, BUNfnd(v, BUNhead(n, p)));
	}
	bat_destroy(n);
	bat_destroy(v);
	return val;
}

char * 
sql_get_type( mvc *sql, char *name )
{
	BAT *n = mvc_bind( sql, "sys", "sessions", "name", 0); 
	BAT *t = mvc_bind( sql, "sys", "sessions", "type", 0); 
	char *type = NULL;
	BUN p;

	if ((p=BUNfnd(BATmirror(n), name))) {
		type = BUNtail(t, BUNfnd(t, BUNhead(n, p)));
	}
	bat_destroy(n);
	bat_destroy(t);
	return type;
}

int  
sql_get_access( mvc *sql, char *name )
{
	BAT *n = mvc_bind( sql, "sys", "sessions", "name", 0); 
	BAT *a = mvc_bind( sql, "sys", "sessions", "access", 0); 
	int access = -1;
	BUN p;

	if ((p=BUNfnd(BATmirror(n), name))) {
		access = *(int*)BUNtail(a, BUNfnd(a, BUNhead(n, p)));
	}
	bat_destroy(n);
	bat_destroy(a);
	return access;
}

int 
sql_get_bit_var( mvc *sql, char *name )
{
	char *val = sql_get_var(sql, name);
	if (val && strcmp(val, "true") == 0)
		return TRUE;
	return FALSE;
}

static int 
sql_get_int_var( mvc *sql, char *name ) 
{
	char *val = sql_get_var(sql, name);
	if (val)
		return strtol(val, &val, 10);
	return 0;
}

static char *
sql_get_str_var( mvc *sql, char *name ) 
{
	char *val = sql_get_var(sql, name);
	if (val)
		return (char*)val;
	assert(0);
	return NULL;
}

int 
inttype( sql_subtype *itype, sql_subtype *rtype ) 
{
	if (strcmp(rtype->type->base.name, "int") == 0) {
		if (strcmp(itype->type->base.name, "sht") == 0 ||
		    strcmp(itype->type->base.name, "int") == 0 ||
		    strcmp(itype->type->base.name, "lng") == 0) 
		return 1;
	}
	return 0;
}

static stmt *
set_var( mvc *sql, char *name, symbol *val, char *typename )
{
	sql_subtype *ctype;
	scope *scp = scope_open(NULL);
	sql_schema *sys = mvc_bind_schema(sql, "sys");
	sql_table *sessions = mvc_bind_table(sql, sys, "sessions");
	tvar *tv = scope_add_table_columns(sql, scp, sessions, sessions->base.name);
	stmt *st, *v = sql_value_exp( sql, scp, val, NULL, NULL, sql_sel);
	sql_column *c = mvc_bind_column(sql, sessions, "value");
	list *l;

	if (!v) {
		scope_close(scp);
		return NULL;
	}

	/* find variable */
 	ctype = sql_bind_subtype(typename, 0, 0);
	v = check_types(sql, ctype, v, type_equal);
	sql_subtype_destroy(ctype);
	if (!v || (v = check_types(sql, c->type, v, type_equal)) == NULL) {
		return NULL;
	}
	st = sql_compare(sql, scope_bind(scp, NULL, "name"), 
			 stmt_atom_string(name),"=", sql_where );
	st = stmt_const(st, v);
	st = stmt_replace( stmt_cbat(c, stmt_dup(tv->s), UPD, st_bat), st);
	scp = scope_close(scp);
	l = create_stmt_list();
	list_append(l, st );
	list_append(l, stmt_update_var(name) );
	list_append(l, output_value( stmt_atom_int(1) ));
	return stmt_list(l);
}

static stmt *
sql_set_var( mvc *sql, symbol *s )
{
	if (s->token == SQL_SET) {
		dlist *dl = s->data.lval;
		char *name = dl->h->data.sval;
		symbol *val = dl->h->next->data.sym;
		int access = sql_get_access(sql, name);

		if (access < 0) {
			return sql_error(sql, 02, 
				"Unknown session variable %s\n",
				name);
		} else if (access == SESSION_RO) {
			return sql_error(sql, 02, 
				"You have no permissions to change the session variable %s\n",
				name);
		}
		return set_var(sql, name, val, sql_get_type(sql, name) );
	}
	return NULL;
}

int
sql_set_var_value( mvc *sql, char *name, char *value )
{
	int res = -1;
	BAT *n = mvc_bind( sql, "sys", "sessions", "name", 0); 
	BAT *a = mvc_bind( sql, "sys", "sessions", "access", 0); 
	BUN p;
	
	if ((p=BUNfnd(BATmirror(n), name))) {
		oid id = *(oid*)BUNhead(n,p);
		int access = *(int*)BUNtail(a,BUNfnd(a,&id));

		if (access == SESSION_RW) {
			BAT *v = mvc_bind( sql, "sys", "sessions", "value", 1); 
			void_inplace(v, id, value);
			res = 0;
			bat_destroy(v);
		}
	}
	bat_destroy(n);
	bat_destroy(a);
	return res;
}

int sql_update_var(mvc *m, char *name )
{
	if (strcmp(name, "debug") == 0) {
		m->debug = sql_get_int_var(m, "debug");
	} else if (strcmp(name, "auto_commit") == 0) {
		m->auto_commit = sql_get_bit_var(m, "auto_commit");
	} else if (strcmp(name, "reply_size") == 0) {
		m->reply_size = sql_get_int_var(m, "reply_size");
	} else if (strcmp(name, "current_schema") == 0) {
		char *schema = sql_get_str_var(m, "current_schema");

		if (!mvc_set_schema(m, schema)){
			GDKwarning("Schema (%s) missing\n", schema);
			return GDK_FAIL;
		}
	} else if (strcmp(name, "current_role") == 0) {
		char *role = sql_get_str_var(m, "current_role");

		if (!mvc_set_role(m, role)){
			GDKwarning("Role (%s) missing\n", role);
			return GDK_FAIL;
		}
	} else if (strcmp(name, "current_timezone") == 0) {
		m->timezone = sql_get_int_var(m, "current_timezone")/60;
	} else if (strcmp(name, "explain") == 0) {
		char *explain = sql_get_str_var(m, "explain");

		if (m->explain)  
			_DELETE(m->explain);
		if (!explain || strcmp(explain, "") == 0)
			m->explain = NULL;
		else if (strcmp(explain, "plan") == 0 ||
			 strcmp(explain, "performance") == 0)
			m->explain = _strdup(explain);
		else {
			GDKwarning("Session variable explain can only be set to 'plan', 'performance' or to the empty string\n");
			return GDK_FAIL;
		}
	} else if (strcmp(name, "cache") == 0) {
		m->cache = sql_get_bit_var(m, "cache");
	} else if (strcmp(name, "factory") == 0) {
		m->factory = sql_get_bit_var(m, "factory");
	}
	return GDK_SUCCEED;
}


stmt *
sql_declare_var( mvc *sql, symbol *s ) 
{
	if (s->token == SQL_DECLARE) {
		int rw = SESSION_RW;
		dlist *l = s->data.lval;
		char *name = l->h->data.sval;
		sql_subtype *ctype = l->h->next->data.typeval;
		BAT *n = mvc_bind( sql, "sys", "sessions", "name", 0); 
		BAT *t = mvc_bind( sql, "sys", "sessions", "type", 0); 
		BAT *v = mvc_bind( sql, "sys", "sessions", "value", 0); 
		BAT *a = mvc_bind( sql, "sys", "sessions", "access", 0); 
		oid h;

		if (BUNfnd(BATmirror(n), name)) {
			bat_destroy(n);
			bat_destroy(t);
@-
Any user defined variable should be added to the table.
They don't survive session boundaries
@c
			return sql_error(sql, 02, 
				"Allready used session variable, %s\n",
				name);
		}

		h = BATcount(n);
		BUNins(n, (ptr) &h, name );
		BUNins(v, (ptr) &h, "NULL" );
		BUNins(t, (ptr) &h, ctype->type->sqlname);
		BUNins(a, (ptr) &h, &rw);

		bat_destroy(n);
		bat_destroy(v);
		bat_destroy(t);
		bat_destroy(a);
		return stmt_none();
	}
	return NULL;
}

@-
Handling of SQL variables is straightforward.
@c
int
sql_session( mvc *m ) 
{
	char buf[BUFSIZ];
	BAT *n,*v,*T, *a;
	int rw = SESSION_RW, ro = SESSION_RO;

	oid h = 0;

	n = mvc_bind( m, "sys", "sessions", "name", 1 );
	v = mvc_bind( m, "sys", "sessions", "value", 1 );
	T = mvc_bind( m, "sys", "sessions", "type", 1 );
	a = mvc_bind( m, "sys", "sessions", "access", 1 );

	BUNins(n, (ptr) &h, "debug" );
	snprintf(buf, BUFSIZ, "%d", m->debug );
	BUNins(v, (ptr) &h, buf);
	BUNins(T, (ptr) &h, "int");
	BUNins(a, (ptr) &h, &rw);
	h++;

	BUNins(n, (ptr) &h, "reply_size" );
	snprintf(buf, BUFSIZ, "%d", m->reply_size );
	BUNins(v, (ptr) &h, buf);
	BUNins(T, (ptr) &h, "int");
	BUNins(a, (ptr) &h, &rw);
	h++;

	BUNins(n, (ptr) &h, "explain" );
	buf[0] = 0;
	if (m->explain)
		snprintf(buf, BUFSIZ, "%s", m->explain );
	BUNins(v, (ptr) &h, buf);
	BUNins(T, (ptr) &h, "varchar");
	BUNins(a, (ptr) &h, &rw);
	h++;

	BUNins(n, (ptr) &h, "auto_commit" );
	if (m->auto_commit)
		BUNins(v, (ptr) &h, "true");
	else
		BUNins(v, (ptr) &h, "false");
	BUNins(T, (ptr) &h, "boolean");
	BUNins(a, (ptr) &h, &rw);
	h++;

	BUNins(n, (ptr) &h, "current_schema" );
	BUNins(v, (ptr) &h, m->schema);
	BUNins(T, (ptr) &h, "varchar");
	BUNins(a, (ptr) &h, &rw);
	h++;

	/* MonetDB/SQL user/current_user/session_user (authorization id) */
	BUNins(n, (ptr) &h, "current_user" );
	BUNins(v, (ptr) &h, m->user);
	BUNins(T, (ptr) &h, "varchar");
	BUNins(a, (ptr) &h, &ro);
	h++;

	/* MonetDB/SQL role/current_role/session_role */
	BUNins(n, (ptr) &h, "current_role" );
	BUNins(v, (ptr) &h, m->role);
	BUNins(T, (ptr) &h, "varchar");
	BUNins(a, (ptr) &h, &rw);
	h++;

	BUNins(n, (ptr) &h, "current_timezone" );
	snprintf(buf, BUFSIZ, "%d", m->timezone*60 );
	BUNins(v, (ptr) &h, buf);
	BUNins(T, (ptr) &h, "sec_interval");
	BUNins(a, (ptr) &h, &rw);
	h++;

	BUNins(n, (ptr) &h, "cache" );
	if (m->cache)
		BUNins(v, (ptr) &h, "true");
	else
		BUNins(v, (ptr) &h, "false");
	BUNins(T, (ptr) &h, "boolean");
	BUNins(a, (ptr) &h, &rw);
	h++;

	BUNins(n, (ptr) &h, "factory" );
	if (m->factory)
		BUNins(v, (ptr) &h, "true");
	else
		BUNins(v, (ptr) &h, "false");
	BUNins(T, (ptr) &h, "boolean");
	BUNins(a, (ptr) &h, &rw);
	h++;

	bat_destroy(n);
	bat_destroy(v);
	bat_destroy(T);
	bat_destroy(a);

	return 0;
}

int
sql_create_sessions( mvc *m, sql_schema *s ) 
{
	BUN p,q;
	BAT *n,*v;

	sql_table *t;

	t = mvc_create_table(m, s, "sessions", 1, 1, 1, -1 );
	mvc_create_column_(m, t, "name", "VARCHAR", 0);
	mvc_create_column_(m, t, "value", "VARCHAR", 0);
	mvc_create_column_(m, t, "type", "VARCHAR", 0);
	mvc_create_column_(m, t, "access", "INT", 9);
	/* access 0 	read/write
		  1	via sql_privileges (role/user) 	
				ie set session authorization bla
				   set role bla
		  2	read only
	 */

	t = mvc_create_table(m, s, "env", 1, 1, 0, -1 );
	mvc_create_column_(m, t, "name", "VARCHAR", 0);
	mvc_create_column_(m, t, "value", "VARCHAR", 0);

	n = mvc_bind( m, "sys", "env", "name", 1 );
	v = mvc_bind( m, "sys", "env", "value", 1 );
	BATloop(GDKenv,p,q){
		oid h = n->hseqbase + BATcount(n);
		char *name = BUNhead(GDKenv,p);
		char *val = BUNtail(GDKenv,p);

		BUNins(n, (ptr) &h, name);
		BUNins(v, (ptr) &h, val);
	}

	bat_destroy(n);
	bat_destroy(v);

	return 0;
}
@-
The history table contains information on the parsing, optimization,
and execution time. More detailed information should be obtained using
the MonetDB kernel profiler, e.g. using Mknife
@c

int
sql_create_history( mvc *m, sql_schema *s ) 
{
	sql_table *t = mvc_create_table(m, s, "history", 1, 1, 0, -1 );

	mvc_create_column_(m, t, "start", "TIMESTAMP", 0);
	mvc_create_column_(m, t, "query", "VARCHAR", 0);
	mvc_create_column_(m, t, "parse", "INT", 9);
	mvc_create_column_(m, t, "optimize", "INT", 9);
	mvc_create_column_(m, t, "exec", "INT", 9);
	mvc_create_column_(m, t, "total", "INT", 9);
	mvc_create_column_(m, t, "user", "VARCHAR", 0);

	return 0;
}
@}

stmt *
env(mvc * sql, symbol * s) 
{
	stmt *ret = NULL;

	switch (s->token) {
	case SQL_SET:
		return sql_set_var(sql, s);
	case SQL_DECLARE:
		return sql_declare_var(sql, s);
	default:
		return sql_error(sql, 01, 
			 "Env statement unknown Symbol(%ld)->token = %s",
			 (long) s, token2string(s->token));
	}
	return ret;
}
