@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f sql_mvc
@a N.J. Nes
@* 

@h
/* multi version catalog */
#ifndef _SQL_MVC_H
#define _SQL_MVC_H

#include <sql_mem.h>
#include <gdk.h>
#include <stdarg.h>
#include <sql_scan.h>
#include <sql_query.h>
#include <sql_list.h>
#include <sql_types.h>
#include <sql_backend.h>
#include <sql_catalog.h>
#include <sql_storage.h>
#include <stream.h>
#include <sql_keyword.h>

#define ERRSIZE 1024

typedef enum modes_t {
	m_normal = 0,
	m_prepare = 1,
	m_execute = 2,
	m_explain = 3,
	m_profile = 4,
	m_debug = 5,
	m_trace = 6
} modes_t;

typedef struct mvc {
	char errstr[ERRSIZE];

	sql_allocator *sa;
	struct qc *qc;
	backend_stack stk;
	struct scanner scanner;

	list *params;
	list *args;
	struct symbol *sym;

	int user_id;
	int role_id;

	/* current session variables */
	char *schema;
	char *user;
	char *role;
	int timezone;		/* minutes west of UTC */
	int cache;		/* some queries should not be cached ! */
	int factory;		/* enable/disable the factory */

	modes_t mode;
	int auto_commit;
	int reply_size;
	int debug;
	char *explain;

	sql_trans *trans;

	int type;
	ssize_t status;

	int result_id;
	res_table *results;
} mvc;

extern int mvc_init(int debug, backend_stack stk);
extern void mvc_exit();
extern void mvc_logmanager();

extern mvc *mvc_create(int cache, backend_stack stk, bstream *rs, stream *ws);
extern void mvc_destroy(mvc *c);

extern ssize_t mvc_status(mvc *c);
extern int mvc_type(mvc *c);

/* since Savepoints and transactions are related the 
 * commit function includes the savepoint creation.
 * Rollbacks can be either full or until a given savepoint. 
 * The special mvc_release can be used to release savepoints. 
 */
extern int mvc_trans(mvc *c);
extern int mvc_commit(mvc *c, int chain, char *name);
extern int mvc_rollback(mvc *c, int chain, char *name);
extern int mvc_release(mvc *c, char *name);

extern sql_module *mvc_bind_module(mvc *c, char *mname);
extern sql_type *mvc_bind_type(mvc *sql, char *name);
extern sql_type *mod_bind_type(mvc *sql, sql_module * m, char *name);
extern sql_func *mvc_bind_func(mvc *sql, char *name);
extern sql_func *mod_bind_func(mvc *sql, sql_module * m, char *name);

extern sql_schema *mvc_bind_schema(mvc *c, char *sname);
extern sql_table *mvc_bind_table(mvc *c, sql_schema *s, char *tname);
extern sql_column *mvc_bind_column(mvc *c, sql_table *t, char *cname);
extern sql_column *mvc_first_column(mvc *c, sql_table *t);
extern sql_idx *mvc_bind_idx(mvc *c, sql_schema *s, char *iname);
extern sql_key *mvc_bind_key(mvc *c, sql_schema *s, char *kname);
extern sql_key *mvc_bind_ukey(sql_table *t, list *cols);

extern void mvc_drop_module(mvc *c, char *name);
extern sql_module *mvc_create_module(mvc *c, char *name, char *opt_iname);
extern sql_type *mvc_create_type(mvc *sql, sql_module * m, char *sqlname, int digits, int scale, int radix, char *impl);
extern sql_func *mvc_create_func(mvc *sql, sql_module * m, char *name, list *args, bit issql, bit aggr, char *impl);

extern void mvc_drop_schema(mvc *c, char *name);
extern sql_schema *mvc_create_schema(mvc *c, char *name, int auth_id);
extern void mvc_drop_table(mvc *c, sql_schema *s, char *name, int cascade);
extern sql_table *mvc_create_view(mvc *c, sql_schema *s, char *name, char *sql, bit system, bit persists);
extern sql_table *mvc_create_table(mvc *c, sql_schema *s, char *name, bit system, bit persists, bit clear, int sz);
extern size_t mvc_clear_table(mvc *m, sql_table *t);

extern void mvc_drop_column(mvc *c, sql_table *t, char *name);
extern sql_column *mvc_create_column(mvc *c, sql_table *t, char *name, sql_subtype *type);
extern sql_column *mvc_create_column_(mvc *c, sql_table *t, char *name, char *type, int digits);
extern sql_column *mvc_null(mvc *c, sql_column *col, int flag);
extern sql_column *mvc_default(mvc *c, sql_column *col, char *val);

extern sql_key *mvc_create_key(mvc *m, sql_table *t, char *kname, key_type kt, sql_key *rk);
extern sql_key *mvc_create_kc(mvc *m, sql_key *k, sql_column *c);

extern void mvc_drop_key(mvc *c, sql_schema *s, char *kname);

extern sql_idx *mvc_create_idx(mvc *m, sql_table *t, char *iname, idx_type it);
extern sql_idx *mvc_create_ic(mvc *m, sql_idx * i, sql_column *c);
extern void mvc_drop_idx(mvc *c, sql_schema *s, char *iname);

#endif /*_SQL_MVC_H*/
@c

/* multi version catalog */

/* 
 * TODO 
 *
 * insert/delete/update should return ERROR (or success). Client side
 * should handle the result
 *
 * use mmap copy
 *
 * come up with a multifile log system (so a seperate thread could
 * Do the atomic bat commits).
 */

#include <gdk.h>
#include <bat.h>

#include "sql_mvc.h"
#include "sql_qc.h"
#include "sql_statement.h"
#include "sql_types.h"
#include "sql_env.h"
#include "sql_semantic.h"
#include "sql_sequence.h"
#include "sql_privileges.h"

static int mvc_debug = 0;

int
mvc_init(int debug, backend_stack stk)
{
	int first = 0;
	char *logdir = GDKgetenv("sql_logdir");
	char *dbname = GDKgetenv("gdk_dbname");

	assert(logdir && dbname);

	mvc_debug = debug;
	if (mvc_debug)
		fprintf(stderr, "mvc_init logdir %s%c%s\n", logdir, DIR_SEP, dbname);
	keyword_init();
	scanner_init_keywords();

	if ((first = store_init(debug, logdir, dbname, stk)) < 0) {
		fprintf(stderr, "!ERROR:mvc_init: unable to create system tables\n");
		return -1;
	}
	if (first) {
		sql_schema *s;
		sql_table *t;
		mvc *m = mvc_create(0, stk, NULL, NULL);

		mvc_trans(m);
		s = m->trans->schema = mvc_bind_schema(m, "sys");
		assert(m->trans->schema != NULL);

		t = mvc_create_table(m, s, "ttables", 1, 1, 1, -1);
		mvc_create_column_(m, t, "id", "int", 9);
		mvc_create_column_(m, t, "name", "varchar", 1024);
		mvc_create_column_(m, t, "schema_id", "int", 9);
		mvc_create_column_(m, t, "query", "varchar", 2048);
		mvc_create_column_(m, t, "istable", "boolean", 0);
		mvc_create_column_(m, t, "system", "boolean", 0);
		mvc_create_column_(m, t, "clear", "boolean", 0);

		t = mvc_create_table(m, s, "tcolumns", 1, 1, 1, -1);
		mvc_create_column_(m, t, "id", "int", 9);
		mvc_create_column_(m, t, "name", "varchar", 1024);
		mvc_create_column_(m, t, "type", "varchar", 1024);
		mvc_create_column_(m, t, "type_digits", "int", 9);
		mvc_create_column_(m, t, "type_scale", "int", 9);
		mvc_create_column_(m, t, "table_id", "int", 9);
		mvc_create_column_(m, t, "default", "varchar", 2048);
		mvc_create_column_(m, t, "null", "boolean", 0);
		mvc_create_column_(m, t, "number", "int", 9);

		t = mvc_create_view(m, s, "tables", "SELECT * FROM (SELECT p.*, 0 AS \"temporary\" FROM \"sys\".\"ptables\" AS p UNION ALL SELECT t.*, 1 AS \"temporary\" FROM \"sys\".\"ttables\" AS t) AS tables;", 1, 1);
		mvc_create_column_(m, t, "id", "int", 9);
		mvc_create_column_(m, t, "name", "varchar", 1024);
		mvc_create_column_(m, t, "schema_id", "int", 9);
		mvc_create_column_(m, t, "query", "varchar", 2048);
		mvc_create_column_(m, t, "istable", "boolean", 0);
		mvc_create_column_(m, t, "system", "boolean", 0);
		mvc_create_column_(m, t, "clear", "boolean", 0);
		mvc_create_column_(m, t, "temporary", "int", 4);

		t = mvc_create_view(m, s, "columns", "SELECT * FROM (SELECT p.* FROM \"sys\".\"pcolumns\" AS p UNION ALL SELECT t.* FROM \"sys\".\"tcolumns\" AS t) AS columns;", 1, 1);
		mvc_create_column_(m, t, "id", "int", 9);
		mvc_create_column_(m, t, "name", "varchar", 1024);
		mvc_create_column_(m, t, "type", "varchar", 1024);
		mvc_create_column_(m, t, "type_digits", "int", 9);
		mvc_create_column_(m, t, "type_scale", "int", 9);
		mvc_create_column_(m, t, "table_id", "int", 9);
		mvc_create_column_(m, t, "default", "varchar", 2048);
		mvc_create_column_(m, t, "null", "boolean", 0);
		mvc_create_column_(m, t, "number", "int", 9);

		sql_create_history(m, s);
		sql_create_sessions(m, s);
		sql_create_sequences(m, s);
		sql_create_privileges(m, s);

		m->trans->schema = s;
		if (mvc_commit(m, 0, NULL) < 0) {
			fprintf(stderr, "!ERROR:mvc_init: unable to commit system tables\n");
			return -1;
		}

		mvc_destroy(m);
	}
	return first;
}

void
mvc_exit()
{
	if (mvc_debug)
		fprintf(stderr, "mvc_exit\n");

	store_exit();
	keyword_exit();
}

void
mvc_logmanager()
{
	store_manager();
}

ssize_t
mvc_status(mvc *m)
{
	int res = m->status;

	return res;
}

int
mvc_type(mvc *m)
{
	int res = m->type;

	m->type = Q_PARSE;
	return res;
}

int
mvc_trans(mvc *m)
{
	int res = Q_TRANS;

	assert(!m->trans);	/* can only start a new transaction */

	store_lock();
	m->trans = sql_trans_create(m->stk, NULL, NULL);
	if (m->trans) {
		m->trans->level = ISO_SERIALIZABLE;
		m->type = res;
		if (m->schema) {
			m->trans->schema = find_sql_schema(m->trans, m->schema);
			sql_session(m);
		}
	}
	store_unlock();
	m->status = 0;
	return res;
}

int
mvc_commit(mvc *m, int chain, char *name)
{
	char *schema = NULL;
	sql_trans *tr = m->trans;
	int level = (chain) ? tr->level : ISO_SERIALIZABLE;
	int ok = SQL_OK;

	assert(tr);
	if (mvc_debug)
		fprintf(stderr, "mvc_commit %s\n", (name) ? name : "");

	if (m->status < 0) {
		GDKerror("COMMIT: transaction is aborted, will ROLLBACK instead");
		mvc_rollback(m, chain, name);
		return -1;
	}

	schema = _strdup(m->trans->schema->base.name);
	/* savepoint then simply make a copy of the current transaction */
	if (name && name[0] != '\0') {
		if (mvc_debug)
			fprintf(stderr, "mvc_savepoint\n");
		m->trans = sql_trans_create(m->trans->stk, m->trans, name);
		m->trans->schema = find_sql_schema(m->trans, schema);
		m->type = Q_TRANS;
		_DELETE(schema);
		if (mvc_debug)
			fprintf(stderr, "mvc_commit %s done\n", (name) ? name : "");
		return 0;
	}

	/* first commit all the savepoints */
	while (tr->parent->parent != NULL && ok == SQL_OK) {
		ok = sql_trans_commit(tr);
		tr = sql_trans_destroy(tr);
	}
	if (ok != SQL_OK) {
		GDKerror("COMMIT: transaction is aborted, will ROLLBACK instead");
		mvc_rollback(m, chain, name);
		_DELETE(schema);
		return -1;
	}

	/* if there is nothing to commit reuse the current transaction */
	if (tr->wtime == 0) {
		if (chain) {
			if (mvc_debug)
				fprintf(stderr, "no changes\n");
		} else {
			sql_trans_destroy(tr);
			m->trans = NULL;
		}
		m->type = Q_TRANS;
		_DELETE(schema);
		if (mvc_debug)
			fprintf(stderr, "mvc_commit %s done\n", (name) ? name : "");
		return 0;
	}

	/* validation phase */
	store_lock();
	if (sql_trans_validate(tr)) {
		if ((ok = sql_trans_commit(tr)) != SQL_OK)
			GDKfatal("Your disk seems to be full, exiting ...");
	} else {
		store_unlock();
		GDKerror("COMMIT: transaction is aborted because of concurency conflicts, will ROLLBACK instead");
		mvc_rollback(m, chain, name);
		_DELETE(schema);
		return -1;
	}
	store_unlock();

	while (tr->parent)
		tr = sql_trans_destroy(tr);

	if (chain) {
		store_lock();
		if (tr) {
			m->trans = sql_trans_create(tr->stk, tr, NULL);
			m->trans->level = level;
			m->trans->schema = find_sql_schema(m->trans, schema);
			sql_session(m);
		}
		store_unlock();
	} else {
		m->trans = NULL;
	}
	_DELETE(schema);
	if (ok == SQL_OK)
		m->type = Q_TRANS;
	if (mvc_debug)
		fprintf(stderr, "mvc_commit %s done\n", (name) ? name : "");
	return ok;
}

int
mvc_rollback(mvc *m, int chain, char *name)
{
	char *schema = NULL;
	int res = 0;
	int level = (chain) ? m->trans->level : ISO_SERIALIZABLE;
	sql_trans *tr = m->trans;

	if (mvc_debug)
		fprintf(stderr, "mvc_rollback %s\n", (name) ? name : "");

	schema = _strdup(tr->schema->base.name);
	assert(schema);
	if (name && name[0] != '\0') {
		while (tr && (!tr->name || strcmp(tr->name, name) != 0))
			tr = tr->parent;
		if (!tr) {
			GDKerror("rollback savepoint %s doesn't exists", name);
			m->status = -1;
			return -1;
		}
		tr = m->trans;
		while (!tr->name || strcmp(tr->name, name) != 0)
			tr = sql_trans_destroy(tr);
		m->trans = tr;	/* restart at savepoint */
		chain = 1;
	} else {
		while (tr->parent)
			tr = sql_trans_destroy(tr);
	}
	m->status = 0;
	if (chain) {
		store_lock();
		if (tr) {
			m->trans = sql_trans_create(tr->stk, tr, NULL);
			m->trans->level = level;
			m->trans->schema = find_sql_schema(m->trans, schema);
			if (tr->parent)
				sql_session(m);
		}
		store_unlock();
	} else {
		m->trans = NULL;
	}
	_DELETE(schema);
	m->type = Q_TRANS;
	return res;
}

/* release all savepoints up including the given named savepoint 
 * but keep the current changes.
 * */
int
mvc_release(mvc *m, char *name)
{
	int ok = SQL_OK;
	int res = Q_TRANS;
	sql_trans *tr = m->trans;

	if (mvc_debug)
		fprintf(stderr, "mvc_release %s\n", (name) ? name : "");

	while (tr && (!tr->name || strcmp(tr->name, name) != 0))
		tr = tr->parent;
	if (!tr || !tr->name || strcmp(tr->name, name) != 0) {
		GDKerror("release savepoint %s doesn't exists", name);
		m->status = -1;
		return -1;
	}
	tr = m->trans;
	while (ok == SQL_OK && (!tr->name || strcmp(tr->name, name) != 0)) {
		ok = sql_trans_commit(tr);
		tr = sql_trans_destroy(tr);
	}
	if (tr->name && strcmp(tr->name, name) == 0) {
		_DELETE(tr->name);
		tr->name = NULL;
	}

	m->trans = tr;		/* restart at savepoint */
	m->type = res;
	return res;
}

mvc *
mvc_create(int cache, backend_stack stk, bstream *rs, stream *ws)
{
	mvc *m = NEW(mvc);

	if (mvc_debug)
		fprintf(stderr, "mvc_create\n");

	m->errstr[0] = '\0';

	m->qc = qc_create();
	m->sa = sa_create();

	m->stk = stk;

	m->params = NULL;
	m->args = NULL;
	m->sym = NULL;

	m->role_id = m->user_id = -1;
	m->schema = m->role = m->user = NULL;
	m->timezone = 0;
	m->cache = cache;
	m->factory = cache;

	m->mode = 0;
	m->auto_commit = 0;
	m->reply_size = -1;
	m->debug = 0;
	m->explain = NULL;

	m->trans = NULL;
	m->status = 0;
	m->type = Q_PARSE;

	m->result_id = 0;
	m->results = NULL;

	scanner_init(&m->scanner, rs, ws);
	return m;
}

void
mvc_destroy(mvc *m)
{
	sql_trans *tr;

	if (mvc_debug)
		fprintf(stderr, "mvc_destroy\n");
	tr = m->trans;
	if (tr)
		while (tr->parent)
			tr = sql_trans_destroy(tr);
	if (m->schema)
		_DELETE(m->schema);
	if (m->user)
		_DELETE(m->user);
	if (m->role)
		_DELETE(m->role);

	if (m->sa)
		sa_destroy(m->sa);
	m->sa = NULL;
	if (m->qc)
		qc_destroy(m->qc);
	m->qc = NULL;

	_DELETE(m);
}

sql_module *
mvc_bind_module(mvc *m, char *mname)
{
	sql_trans *tr = m->trans;
	sql_module *s = find_sql_module(tr, mname);

	if (!s)
		return NULL;
	/*
	   s->base.rtime = tr->rtime;
	 */

	if (mvc_debug)
		fprintf(stderr, "mvc_bind_module %s\n", mname);
	return s;
}

sql_type *
mvc_bind_type(mvc *sql, char *name)
{
	sql_type *t = sql_trans_bind_type(sql->trans, name);

	if (mvc_debug)
		fprintf(stderr, "mvc_bind_type %s\n", name);
	return t;
}

sql_type *
mod_bind_type(mvc *sql, sql_module * m, char *name)
{
	sql_type *t = find_sql_type(m, name);

	(void) sql;
	if (!t)
		return NULL;
	/*
	   sql_trans *tr = sql->trans;
	   t->base.rtime = tr->rtime;
	 */

	if (mvc_debug)
		fprintf(stderr, "mod_bind_type %s\n", name);
	return t;
}

sql_func *
mvc_bind_func(mvc *sql, char *name)
{
	sql_func *t = sql_trans_bind_func(sql->trans, name);

	if (mvc_debug)
		fprintf(stderr, "mvc_bind_func %s\n", name);
	return t;
}

sql_func *
mod_bind_func(mvc *sql, sql_module * m, char *name)
{
	sql_func *t = find_sql_func(m, name);

	(void) sql;
	if (!t)
		return NULL;
	/*
	   sql_trans *tr = sql->trans;
	   t->base.rtime = tr->rtime;
	 */

	if (mvc_debug)
		fprintf(stderr, "mod_bind_func %s\n", name);
	return t;
}

sql_schema *
mvc_bind_schema(mvc *m, char *sname)
{
	sql_trans *tr = m->trans;
	sql_schema *s = find_sql_schema(tr, sname);

	if (!s)
		return NULL;
	/*
	   s->base.rtime = tr->rtime;
	 */

	if (mvc_debug)
		fprintf(stderr, "mvc_bind_schema %s\n", sname);
	return s;
}

sql_table *
mvc_bind_table(mvc *m, sql_schema *s, char *tname)
{
	sql_table *t = find_sql_table(s, tname);

	(void) m;
	if (!t)
		return NULL;
	/*
	   t->base.rtime = s->base.rtime;
	 */

	if (mvc_debug)
		fprintf(stderr, "mvc_bind_table %s.%s\n", s->base.name, tname);

	return t;
}

sql_column *
mvc_bind_column(mvc *m, sql_table *t, char *cname)
{
	sql_column *c = find_sql_column(t, cname);

	(void) m;
	if (!c)
		return NULL;
	/*
	   c->base.rtime = t->base.rtime;
	 */

	if (mvc_debug)
		fprintf(stderr, "mvc_bind_column %s.%s\n", t->base.name, cname);

	return c;
}

static sql_column *
first_column(sql_table *t)
{
	node *n = cs_first_node(&t->columns);

	if (n)
		return n->data;
	return NULL;
}


sql_column *
mvc_first_column(mvc *m, sql_table *t)
{
	sql_column *c = first_column(t);

	(void) m;
	if (!c)
		return NULL;
	/*
	   c->base.rtime = t->base.rtime;
	 */

	if (mvc_debug)
		fprintf(stderr, "mvc_first_column %s.%s\n", t->base.name, c->base.name);

	return c;
}

sql_key *
mvc_bind_key(mvc *m, sql_schema *s, char *kname)
{
	node *n = list_find_name(s->keys, kname);
	sql_key *k;

	(void) m;
	if (!n)
		return NULL;
	k = n->data;
	/*
	   k->base.rtime = k->t->base.rtime = s->base.rtime;
	 */

	if (mvc_debug)
		fprintf(stderr, "mvc_bind_key %s.%s\n", s->base.name, kname);

	return k;
}

sql_idx *
mvc_bind_idx(mvc *m, sql_schema *s, char *iname)
{
	node *n = list_find_name(s->idxs, iname);
	sql_idx *i;

	(void) m;
	if (!n)
		return NULL;
	i = n->data;
	/*
	   i->base.rtime = i->t->base.rtime = s->base.rtime;
	 */

	if (mvc_debug)
		fprintf(stderr, "mvc_bind_idx %s.%s\n", s->base.name, iname);

	return i;
}

int
uniqueKey(sql_key *k)
{
	return (k->type == pkey || k->type == ukey);
}

sql_key *
mvc_bind_ukey(sql_table *t, list *colnames)
{
	node *cn;
	node *cur;
	sql_key *res = NULL;
	int len = list_length(colnames);

	if (cs_size(&t->keys))
		for (cur = t->keys.set->h; cur; cur = cur->next) {
			node *cc;
			sql_key *k = cur->data;

			if (uniqueKey(k) && list_length(k->columns) == len) {
				res = k;
				for (cc = k->columns->h, cn = colnames->h; cc && cn; cc = cc->next, cn = cn->next) {
					sql_kc *c = cc->data;
					char *n = cn->data;

					if (strcmp(c->c->base.name, n) != 0) {
						res = NULL;
						break;
					}
				}
				if (res)
					break;
			}
		}
	return res;
}

sql_module *
mvc_create_module(mvc *m, char *name, char *opt_internal_name)
{
	sql_module *mod = NULL;

	if (mvc_debug)
		fprintf(stderr, "mvc_create_module %s, %s\n", name, opt_internal_name);

	mod = sql_trans_create_module(m->trans, name, opt_internal_name);
	m->type = Q_SCHEMA;
	return mod;
}

void
mvc_drop_module(mvc *m, char *name)
{
	if (mvc_debug)
		fprintf(stderr, "mvc_drop_module %s\n", name);
	sql_trans_drop_module(m->trans, name);
	m->type = Q_SCHEMA;
}

sql_type *
mvc_create_type(mvc *sql, sql_module * m, char *name, int digits, int scale, int radix, char *impl)
{
	sql_type *t = NULL;

	if (mvc_debug)
		fprintf(stderr, "mvc_create_type %s\n", name);

	t = sql_trans_create_type(sql->trans, m, name, digits, scale, radix, impl);
	sql->type = Q_SCHEMA;
	return t;
}

sql_func *
mvc_create_func(mvc *sql, sql_module * m, char *name, list *args, bit issql, bit aggr, char *impl)
{
	sql_func *f = NULL;

	if (mvc_debug)
		fprintf(stderr, "mvc_create_func %s\n", name);

	f = sql_trans_create_func(sql->trans, m, name, args, issql, aggr, impl);
	sql->type = Q_SCHEMA;
	return f;
}


sql_schema *
mvc_create_schema(mvc *m, char *name, int auth_id)
{
	sql_schema *s = NULL;

	if (mvc_debug)
		fprintf(stderr, "mvc_create_schema %s %d\n", name, auth_id);

	s = sql_trans_create_schema(m->trans, name, auth_id);
	m->type = Q_SCHEMA;
	return s;
}

void
mvc_drop_schema(mvc *m, char *sname)
{
	if (mvc_debug)
		fprintf(stderr, "mvc_drop_schema %s\n", sname);
	sql_trans_drop_schema(m->trans, sname);
	m->type = Q_SCHEMA;
}

sql_key *
mvc_create_key(mvc *m, sql_table *t, char *name, key_type kt, sql_key *rkey)
{
	sql_key *k;

	if (mvc_debug)
		fprintf(stderr, "mvc_create_key %s %d %ld\n", t->base.name, kt, (long) rkey);
	k = sql_trans_create_key(m->trans, t, name, kt, rkey);
	m->type = Q_SCHEMA;
	return k;
}

sql_key *
mvc_create_kc(mvc *m, sql_key *k, sql_column *c /*, extra options such as trunc */ )
{
	sql_trans_create_kc(m->trans, k, c);
	m->type = Q_SCHEMA;
	return k;
}

void
mvc_drop_key(mvc *m, sql_schema *s, char *name)
{
	if (mvc_debug)
		fprintf(stderr, "mvc_drop_key %s %s\n", s->base.name, name);
	sql_trans_drop_key(m->trans, s, name);
}

sql_idx *
mvc_create_idx(mvc *m, sql_table *t, char *name, idx_type it)
{
	sql_idx *i;

	if (mvc_debug)
		fprintf(stderr, "mvc_create_idx %s %d\n", t->base.name, it);

	i = sql_trans_create_idx(m->trans, t, name, it);
	m->type = Q_SCHEMA;
	return i;
}

sql_idx *
mvc_create_ic(mvc *m, sql_idx * i, sql_column *c /*, extra options such as trunc */ )
{
	sql_trans_create_ic(m->trans, i, c);
	m->type = Q_SCHEMA;
	return i;
}

void
mvc_drop_idx(mvc *m, sql_schema *s, char *name)
{
	if (mvc_debug)
		fprintf(stderr, "mvc_drop_idx %s %s\n", s->base.name, name);

	m->type = Q_SCHEMA;
	sql_trans_drop_idx(m->trans, s, name);
}

sql_table *
mvc_create_table(mvc *m, sql_schema *s, char *name, bit system, bit persists, bit clear, int sz)
{
	sql_table *t = NULL;

	if (mvc_debug)
		fprintf(stderr, "mvc_create_table %s %s %d %d %d\n", s->base.name, name, system, persists, clear);

	t = sql_trans_create_table(m->trans, s, name, system, persists, clear, sz);
	m->type = Q_SCHEMA;
	return t;
}


sql_table *
mvc_create_view(mvc *m, sql_schema *s, char *name, char *sql, bit system, bit persists)
{
	sql_table *t = NULL;

	if (mvc_debug)
		fprintf(stderr, "mvc_create_view %s %s %s\n", s->base.name, name, sql);

	t = sql_trans_create_view(m->trans, s, name, sql, system, persists);
	m->type = Q_SCHEMA;
	return t;
}

void
mvc_drop_table(mvc *m, sql_schema *s, char *name, int cascade)
{
	if (mvc_debug)
		fprintf(stderr, "mvc_drop_table %s %s\n", s->base.name, name);

	sql_trans_drop_table(m->trans, s, name, cascade);
	m->type = Q_SCHEMA;
}

size_t
mvc_clear_table(mvc *m, sql_table *t)
{
	m->type = Q_UPDATE;
	return sql_trans_clear_table(m->trans, t);
}

sql_column *
mvc_create_column_(mvc *m, sql_table *t, char *name, char *type, int digits)
{
	sql_subtype *tpe = sql_bind_subtype(type, digits, 0);

	m->type = Q_SCHEMA;
	return sql_trans_create_column(m->trans, t, name, tpe);
}

sql_column *
mvc_create_column(mvc *m, sql_table *t, char *name, sql_subtype *tpe)
{
	if (mvc_debug)
		fprintf(stderr, "mvc_create_column %s %s %s\n", t->base.name, name, tpe->type->sqlname);
	m->type = Q_SCHEMA;
	return sql_trans_create_column(m->trans, t, name, tpe);
}

void
mvc_drop_column(mvc *m, sql_table *t, char *name)
{
	if (mvc_debug)
		fprintf(stderr, "mvc_drop_column %s %s\n", t->base.name, name);
	sql_trans_drop_column(m->trans, t, name);
	m->type = Q_SCHEMA;
}

sql_column *
mvc_null(mvc *m, sql_column *col, int isnull)
{
	if (mvc_debug)
		fprintf(stderr, "mvc_null %s %d\n", col->base.name, isnull);

	m->type = Q_SCHEMA;
	return sql_trans_alter_null(m->trans, col, isnull);
}

sql_column *
mvc_default(mvc *m, sql_column *col, char *val)
{
	if (mvc_debug)
		fprintf(stderr, "mvc_default %s %s\n", col->base.name, val);

	m->type = Q_SCHEMA;
	return sql_trans_alter_default(m->trans, col, val);
}
