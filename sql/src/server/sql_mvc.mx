@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at 
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2002 CWI.  
@' All Rights Reserved.
@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold <Stefan.Manegold@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>

@f sql_mvc
@a N.J. Nes
@* 

@h
/* multi version catalog */
#ifndef _SQL_MVC_H
#define _SQL_MVC_H

#include <sql_mem.h>
#include <gdk.h>
#include <stdarg.h>
#include <sql_query.h>
#include <sql_list.h>
#include <sql_types.h>

#define ISO_READ_UNCOMMITED 1
#define ISO_READ_COMMITED   2
#define ISO_READ_REPEAT	    3
#define ISO_SERIALIZABLE    4

typedef int sqlid;

/*
 * name bats using schema_table_column etc.
 * 
 * support multiple db's using multiple servers, requires a shallow connection setup
 * server, which communicates using shmem or pipes. 
 */

#define cur_user 1
#define cur_role 2

typedef struct sql_base {
	int wtime;
	int rtime;
	int flag;
	sqlid id;
	char *name; 	
} sql_base;

/* TODO keep a single list of sql_bats with each table 
 * also change D_* to use the sql_bat
 */
typedef struct sql_bat {
	oid bid;
	oid ubid;     /* bat with updates */
} sql_bat;

typedef enum key_type {
	pkey,
	ukey,
	fkey
} key_type;

typedef struct sql_kc {
	struct sql_column *c;
	int trunc; /* 0 not truncated, >0 colum is truncated */
} sql_kc;

typedef enum idx_type {
	unique,
	join_idx,
	new_idx_types
} idx_type;

typedef struct sql_idx { 
	sql_base base;
	idx_type type; 		/* unique */
	struct list *columns; 	/* list of sql_kc */
	struct sql_table *t;
	sql_bat bat;
	struct sql_key *key; 		/* key */
} sql_idx;

/* fkey consists of two of these */
typedef struct sql_key { /* pkey, ukey, fkey */
	sql_base base;
	key_type type; 		/* pkey, ukey, fkey */
	sql_idx	*idx;		/* idx to accelerate key check */

	struct list *columns; 	/* list of sql_kc */
	struct sql_table *t;
} sql_key;

typedef struct sql_ukey { /* pkey, ukey */
	sql_key k;
	list *keys;
} sql_ukey;

typedef struct sql_fkey { /* fkey */
	sql_key k;
	struct sql_ukey *rkey; /* only set for fkey and rkey */
} sql_fkey;

typedef struct sql_column {
	sql_base base;
	sql_subtype *type;
	int colnr;
	int null;
	char *def;

	struct stmt *st; /* for prepared view's */
	struct sql_table *t;
	sql_bat bat;

} sql_column;

typedef enum table_type {
	tt_base = 0,
	tt_system = 1,
	tt_view = 2,
	tt_session = 3,
	tt_temp = 4
} table_type;

typedef struct changeset {
	fdestroy destroy;
	struct list *set;
	struct list *dset;
	node *nelm;
} changeset;

typedef struct sql_table {
	sql_base base;
	table_type type;
	char *query;

	changeset columns;
	changeset idxs;
	changeset keys;
	sql_ukey *pkey;

	oid dbid;     /* bat with deletes */

	struct stmt *st; /* for prepared view's */
	struct sql_schema *s;

} sql_table;

typedef struct sql_schema {
	sql_base base;
	char *auth;

	changeset tables;
	list *keys; 	/* the names for keys and idxs are global, but */	
	list *idxs;	/* these objects are only usefull within a table */
} sql_schema;

typedef struct sql_trans {
	char *name;
	int stime; /* transaction time stamp (aka start time) */
	int rtime;
	int wtime;
	int level; 

	sql_schema *schema;
	changeset schemas;
	struct bm *bm;

	struct sql_trans *parent; /* multilevel transaction support */
} sql_trans;

typedef struct res_col {
	char *name;
	sql_subtype *type;
	bat b;
	int mtype;
	ptr *p;
} res_col;

typedef struct res_table {
	int id; 
	int nr_cols; 
	int cur_col;
	res_col *cols;
	bat order;
	struct res_table *next;
} res_table;

typedef struct mvc {
	int debug;

	/* not used jet */
	int privileges;
	int user_id;
	int role_id;
	char *user;
	char *role;

	sql_trans *trans;
	
	int type;
	ssize_t status;
	int result_id;
	res_table *results;
} mvc;


sql_export void mvc_init(int debug);
sql_export void mvc_exit();

sql_export mvc *mvc_create( int debug );
sql_export void mvc_destroy( mvc *c );
sql_export char *mvc_login( mvc *c, char *user, char *passwd );
/* later a change_schema and a change_database could be added 
	connect to ...
*/

sql_export ssize_t mvc_status( mvc *c );
sql_export int mvc_type( mvc *c );

/* since Savepoints and transactions related the 
 * statement commit function includes the savepoint creation.
 * And rollbacks can be eigther full or until a given savepoint. 
 * The special statement_release can be used to release savepoints. 
 */
sql_export int mvc_commit( mvc *c, int chain, char *name );
sql_export int mvc_rollback( mvc *c, int chain, char *name );
sql_export int mvc_release( mvc *c, char *name );
sql_export int mvc_set_iso_level(mvc * m, int level);

sql_export BAT *mvc_bind( mvc *c, char *sname, char *tname, char *cname, int access );
sql_export BAT *mvc_bind_ubat( mvc *c, char *sname, char *tname, char *cname, int access );
sql_export BAT *mvc_bind_dbat( mvc *c, char *sname, char *tname, int access );

sql_export BAT *mvc_bind_ibat(  mvc *c, char *sname, char *tname, char *idx, int access );

sql_export sql_schema *mvc_bind_schema( mvc *c, char *sname );
sql_export sql_table *mvc_bind_table( mvc *c, sql_schema *s, char *tname );
sql_export sql_column *mvc_bind_column( mvc *c, sql_table *t, char *cname );
sql_export sql_idx *mvc_bind_idx( mvc *c, sql_schema *s, char *iname );
sql_export sql_key *mvc_bind_key( mvc *c, sql_schema *s, char *kname );
extern sql_key *mvc_bind_ukey( sql_table *t, list *cols );

sql_export void mvc_drop_schema( mvc *c, char *name );
sql_export sql_schema *mvc_create_schema( mvc *c, char *name, char *auth);
sql_export void mvc_drop_table( mvc *c, sql_schema *s, char *name, int cascade );
sql_export sql_table *mvc_create_view( mvc *c, sql_schema *s, char *name, char *sql);
sql_export sql_table *mvc_create_table(mvc *c, sql_schema *s, char *name, table_type type);
sql_export void mvc_drop_column( mvc *c, sql_table *t, char *name );
sql_export sql_column *mvc_create_column( mvc *c, sql_table *t, char *name, char *type, int type_digits, int type_scale );
sql_export sql_column *mvc_null( mvc *c, sql_column *col, int flag );
sql_export sql_column *mvc_default( mvc *c, sql_column *col, char *val );

sql_export sql_key *mvc_create_key( mvc *m, sql_table *t, char *kname, key_type kt, sql_key *rk );
sql_export sql_key *mvc_create_kc( mvc *m, sql_key *k, sql_column *c);

sql_export void mvc_drop_key( mvc *c, sql_schema *s, char *kname );

sql_export sql_idx *mvc_create_idx( mvc *m, sql_table *t, char *iname, idx_type it);
sql_export sql_idx *mvc_create_ic( mvc *m, sql_idx *i, sql_column *c);
sql_export void mvc_drop_idx( mvc *c, sql_schema *s, char *iname );

sql_export size_t void_insert_bat( BAT *b, BAT *u);
sql_export size_t void_append_bat( BAT *b, BAT *u);
sql_export size_t void_replace_bat( BAT *b, BAT *u);

sql_export int mvc_result_table( mvc *c, int nr_cols, BAT *order );
sql_export int mvc_result_row( mvc *c, int nr_cols );
sql_export int mvc_result_column( mvc *c, char *name, char *typename, int digits, int scale, BAT *b);
sql_export int mvc_result_value( mvc *c, char *name, char *typename, int digits, int scale, ptr *p, int mtype);
sql_export void mvc_clean_result( mvc *m, res_table *t);

#endif /*_SQL_MVC_H*/
@c

/* multi version catalog */

/* 
 * TODO 
 *
 * insert/delete/update should return ERROR (or success). Client side
 * should handle the result
 *
 * use mmap copy
 *
 * come up with a multifile log system (so a seperate thread could
 * Do the atomic bat commits).
 */

#include <gdk.h>

#include "sql_mvc.h"
#include "sql_logger.h"
#include "sql_context.h"
#include "sql_statement.h"
#include "sql_types.h"
#include "sql_privileges.h"

#define TR_OLD 0
#define TR_NEW 1

static int 		mvc_debug = 0;
static MT_Lock 	  	mvc_lock = NULL;
static struct logger 	*logger = NULL;
static sql_trans 	*gtrans = NULL;

static sql_schema *bootstrap_create_schema(mvc * m, char *name, char *auth);
static sql_table *bootstrap_create_table(mvc * m, sql_schema *s, char *name, table_type type);
static sql_column *bootstrap_create_column(mvc * m, sql_table *t, char *name,
		       char *sqltype, int type_digits, int type_scale );
/* current time stamps model is simple. Two time stamps per column, 
   one for reads and writes. 
 */

static int stamp = 1;

static int timestamp()
{
	return stamp++;
}

static int key_cmp(sql_key *k, sqlid*id)
{
	if (k && id && k->base.id == *id)
		return 0;
	return 1;
}

static ptr bun_find(BAT *b, ptr v){
	BUN p = BUNfnd(b,v);
	if (p)
		return BUNtail(b,p);
	return NULL;
}

static void bun_inplace(BAT *b, oid id, ptr val )
{
	BUN p = NULL;
	BUN oldInserted = b->batInserted;

	assert(b->htype == TYPE_void);
	assert(b->hseqbase == 0);
	assert(BATcount(b) > id);

	b->batInserted = NULL;
	BUNfndVOID(p, b, (ptr)&id);
	assert(p >= b->batInserted); /* we don't want delete/ins */
	(void) BUNinplace(b, p, (ptr)&id, val);
	b->batInserted = oldInserted;
}

static size_t void_delete_bat( BAT *b, BAT *d, int delta){
	size_t nr = 0;
	BUN r,s;
	ptr nil = ATOMnilptr(b->ttype);

	if (delta) {
	    for (r = d->batInserted; r < BUNlast(d); r = BUNnext(d, r)) { 
		oid delid = *(oid*)BUNtail(d,r);
		bun_inplace(b,  delid, nil);
		nr++;
            } 
	} else {
	    BATloop(d, r, s){
		oid delid = *(oid*)BUNtail(d,r);
		bun_inplace(b,  delid, nil);
		nr++;
	    }
	}
	return nr;
}

static size_t void_insert_delta( BAT *b, BAT *u ){
	size_t nr = 0;
	BUN r;
	oid nil = oid_nil;

	assert( b->batCacheid != u->batCacheid);
	for (r = u->batInserted; r < BUNlast(u); r = BUNnext(u, r)) { 
		BUNins(b,  (ptr)&nil, BUNtail(u,r));
		nr++;
	}
	return nr;
}

static size_t insert_delta( BAT *b, BAT *u ){
	size_t nr = 0;
	BUN r;

	for (r = u->batInserted; r < BUNlast(u); r = BUNnext(u, r)) { 
		BUNins(b,  BUNhead(u,r), BUNtail(u,r));
		nr++;
	}
	return nr;
}


static size_t void_replace_delta( BAT *b, BAT *u){
	size_t nr = 0;
	BUN r;

	for (r = u->batInserted; r < BUNlast(u); r = BUNnext(u, r)) { 
		oid updid = *(oid*)BUNhead(u,r);
		ptr val = BUNtail(u,r);
		bun_inplace(b,  updid, val);
		nr++;
	}
	return nr;
}

size_t void_replace_bat( BAT *b, BAT *u){
	size_t nr = 0;
	BUN r,s;

	BATloop(u, r, s){
		oid updid = *(oid*)BUNhead(u,r);
		ptr val = BUNtail(u,r);
		bun_inplace(b,  updid, val);
		nr++;
	}
	return nr;
}


size_t void_insert_bat( BAT *b, BAT *u){
	size_t nr = 0;
	BUN r,s;
	oid nil = oid_nil;

	BATloop(u, r, s){
		BUNins(b,  (ptr)&nil, BUNtail(u,r));
		nr++;
	}
	return nr;
}

size_t void_append_bat( BAT *b, BAT *u){
        size_t sz = BUNsize(u);
	size_t sbase = b->hseqbase + BATcount(b);
	BATseqbase(u, sbase);
	BATins(b, u);
	return sz;
}

static BAT *bat_lcopy(BAT *b){
	BAT *nb = BATcopy(b);

	BATkey(nb, b->hkey);
	BATkey(BATmirror(nb), b->tkey);

	bat_destroy(b);
	BATfakeCommit(nb);
	return nb;
}

static void
base_init( sql_base *b, sqlid id, int flag, char *name )
{
	b->id = id;
	b->wtime = 0;
	b->rtime = 0;
	b->flag = flag;
	b->name = NULL;
	if (name) b->name = _strdup(name);
}

static void
base_set_name( sql_base *b, char *name )
{
	assert(name);
	if (b->name) _DELETE(b->name);
	b->name = _strdup(name);
}

static void
base_destroy( sql_base *b )
{
	if (b->name) _DELETE(b->name);
}

static void 
cs_init( changeset *cs, fdestroy destroy )
{
	cs->destroy = destroy;
	cs->set = NULL;
	cs->dset = NULL;
	cs->nelm = NULL;
}  

static void 
cs_destroy( changeset *cs )
{
	if (cs->set) 
		list_destroy(cs->set);
	if (cs->dset) 
		list_destroy(cs->dset);
}

static void
cs_add( changeset *cs, void *elm, int flag )
{
	if (!cs->set)
		cs->set = list_create(cs->destroy);
	list_append(cs->set, elm);
	if (flag == TR_NEW && !cs->nelm) 
		cs->nelm = cs->set->t;
}

static void
cs_del( changeset *cs, node *elm, int flag )
{
	if (flag == TR_NEW){ /* remove just added */
		if (cs->nelm == elm)
			cs->nelm = elm->next;
		list_remove_node(cs->set, elm);
	} else {
		if (!cs->dset)
			cs->dset = list_create(cs->destroy);
		list_move_data(cs->set, cs->dset, elm->data);
	}
}

static int
cs_size( changeset * cs )
{
	if (cs->set)
		return list_length(cs->set);
	return 0;
}

static node *
list_find_name( list * l, char *name )
{
	node *n;
	if (l) for (n = l->h; n; n = n->next) {
		sql_base *b = n->data;
		/* check if names match */
		if (strcmp(name, b->name) == 0) {
			return n;
		}
	}
	return NULL;
}

static node *
cs_find_name(changeset * cs, char *name)
{
	return list_find_name(cs->set, name);
}

static BAT *sys_bat( struct bm *bm, char *name ) {
	oid lbid = bm_find_bat(bm, name);
	BAT *b = bm_lbid2bat(bm, lbid);
	
	if (!bm_lbid2mode(bm, lbid)) {	
		if (mvc_debug)
			fprintf(stderr, "sys_bat %s\n", name );
		b = bat_lcopy(b);
		bm_new_bat(bm, lbid, b->batCacheid);
	}
	return b;
}

static BAT *col_bind( sql_trans * tr, oid lbid, sql_column *c, int access )
{
	BAT *b = bm_lbid2bat(tr->bm, lbid);
	if (access && !bm_lbid2mode(tr->bm, lbid)) {	/* first write ie. need to copy */
		if (mvc_debug)
			fprintf(stderr, "new bat for column %s.%s\n", 
				c->t->base.name, c->base.name );
		b = bat_lcopy(b);
		c->base.wtime = c->t->base.wtime = c->t->s->base.wtime = 
			tr->wtime = tr->stime;
		bm_new_bat(tr->bm, lbid, b->batCacheid);
	}
	return b;
}

static BAT *bind_bat(sql_trans * tr, sql_column * c, int access )
{
	return col_bind(tr, c->bat.bid, c, access);
}

static BAT *bind_ubat( sql_trans *tr, sql_column *c, int access )
{
	return col_bind(tr, c->bat.ubid, c, access);
}

static BAT *tab_bind( sql_trans * tr, oid lbid, sql_table *t, int access )
{
	BAT *b = bm_lbid2bat(tr->bm, lbid);

	if (access && !bm_lbid2mode(tr->bm, lbid)) {	/* first write ie. need to copy */
		if (mvc_debug)
			fprintf(stderr, "new bat for table %s\n", t->base.name);
		b = bat_lcopy(b);
		t->base.wtime = t->s->base.wtime = tr->wtime = tr->stime;
		bm_new_bat(tr->bm, lbid, b->batCacheid);
	}
	return b;
}

static BAT *bind_dbat( sql_trans *tr, sql_table *t, int access )
{
	return tab_bind(tr, t->dbid, t, access);
}

static BAT *bind_idx( sql_trans *tr, sql_idx *i, int access )
{
	return tab_bind(tr, i->bat.bid, i->t, access);
}

static BAT *bind_uidx( sql_trans *tr, sql_idx *i, int access )
{
	return tab_bind(tr, i->bat.ubid, i->t, access);
}

static void kc_destroy(sql_kc * kc)
{
	_DELETE(kc);
}

static void key_destroy(sql_key * k)
{
	base_destroy( &k->base );
	list_destroy(k->columns);
}

static void idx_destroy(sql_idx * i)
{
	base_destroy( &i->base );
	list_destroy(i->columns);
}

static void column_destroy(sql_column * c)
{
	base_destroy( &c->base );
	sql_subtype_destroy(c->type);
	_DELETE(c->def);
	if (c->st)
		stmt_destroy(c->st);
	_DELETE(c);
}

static void table_destroy(sql_table * t)
{
	base_destroy( &t->base );
	_DELETE(t->query);

	cs_destroy( &t->keys );
	cs_destroy( &t->idxs );
	cs_destroy( &t->columns );
	if (t->st)
		stmt_destroy(t->st);
	_DELETE(t);
}

static void schema_destroy(sql_schema * s)
{
	base_destroy( &s->base );
	_DELETE(s->auth);

	list_destroy(s->keys);
	list_destroy(s->idxs);

	cs_destroy( &s->tables );
	_DELETE(s);
}

static sql_trans *
trans_destroy(sql_trans *t)
{
	sql_trans *res = t->parent;

	if (t->name) _DELETE(t->name); 

	cs_destroy( &t->schemas );
	t->schema = NULL;
	bm_destroy(t->bm);
	_DELETE(t);
	return res;
}

static node *
find_key_node(sql_table * t, char *kname)
{
	return cs_find_name( &t->keys, kname );
}

static sql_key *
find_key(sql_table * t, char *kname)
{
	node *n = find_key_node(t, kname );
	if (n) return n->data;
	return NULL;
}

static node *
find_idx_node(sql_table * t, char *kname)
{
	return cs_find_name( &t->idxs, kname );
}

static sql_idx *
find_idx(sql_table * t, char *kname)
{
	node *n = find_idx_node(t, kname );
	if (n) return n->data;
	return NULL;
}

static node *
find_column_node(sql_table * t, char *cname)
{
	return cs_find_name( &t->columns, cname );
}

static sql_column *find_column(sql_table * t, char *cname)
{
	node *n = find_column_node(t, cname );
	if (n) return n->data;
	return NULL;
}

static node *
find_table_node(sql_schema * s, char *tname)
{
	return cs_find_name( &s->tables, tname );
}

static sql_table *
find_table(sql_schema * s, char *tname)
{
	node *n = find_table_node( s, tname );
	if (n) return n->data;
	return NULL;
}

static node *
find_schema_node(sql_trans *t, char *sname)
{
	return cs_find_name( &t->schemas, sname );
}

static
sql_schema *find_schema(sql_trans *t, char *sname)
{
	node *n = find_schema_node( t, sname );
	if (n) return n->data;
	return NULL;
}

static void update_table_bat( BAT *b, BAT *ub, BAT *db)
{
	if (ub && BATcount(ub)){
		void_replace_bat(b, ub);
	}
	if (db && BATcount(db)){
		void_delete_bat(b, db, 0 );
	}
}

static void load_keycolumn(sql_trans *tr, BAT * columns, BUN j, sql_key *k )
{
	sql_kc *kc = NEW(sql_kc);
	BAT *kc_col = sys_bat(tr->bm, "keycolumns_column");
	BAT *kc_trunc = sys_bat(tr->bm, "keycolumns_trunc");
	ptr lid = BUNhead(columns, j);
	char *name = bun_find(kc_col, lid);
	int trunc = *(int*)bun_find(kc_trunc, lid);
	sql_column *c = find_column(k->t, name);
	assert(c);

	kc->c = c;
	kc->trunc = trunc;
	list_append(k->columns,kc);

	bat_destroy(kc_col);
	bat_destroy(kc_trunc);
}

static sql_key *load_key(sql_trans *tr, BAT * keys, BUN j, sql_table *t)
{
	int ccnt;
	BAT *cols, *rcols;
	BAT *key_id = sys_bat(tr->bm, "keys_id");
	BAT *key_tpe = sys_bat(tr->bm, "keys_type");
	BAT *key_name = sys_bat(tr->bm, "keys_name");
	BAT *key_rkey = sys_bat(tr->bm, "keys_rkey");
	BAT *kc_id = sys_bat(tr->bm, "keycolumns_id");
	BAT *kc_nr = sys_bat(tr->bm, "keycolumns_nr");
	ptr lid = BUNhead(keys, j);
	key_type ktype = (key_type)*(int*) bun_find(key_tpe, lid);
	char *name = (char*) bun_find(key_name, lid);
	sql_key *nk = (ktype!=fkey)?(sql_key*)NEW(sql_ukey)
				:(sql_key*)NEW(sql_fkey);
	BUN p,q;
	node *n;

	base_init( &nk->base, *(sqlid*) bun_find(key_id, lid), TR_OLD, name);
	nk->type = ktype;
	nk->columns = list_create((fdestroy)&kc_destroy);
	nk->t = t;

	if (ktype == ukey || ktype == pkey){
		sql_ukey *uk = (sql_ukey*)nk;
		uk -> keys = NULL;

		if (ktype == pkey)
			t->pkey = uk;
	} else {
		sql_fkey *fk = (sql_fkey*)nk;
		fk -> rkey = NULL;
	}

	cols = BATselect(kc_id, (ptr) & nk->base.id, (ptr) & nk->base.id);
	rcols = BATsemijoin(kc_nr, cols);
	bat_destroy(cols);
	cols = BATmirror(rcols);
	rcols = BATsort(cols);
	bat_destroy(cols);
	cols = BATmirror(rcols);

	ccnt = BATcount(cols);
	if (ccnt) {
		BATloop(cols,p,q)
			load_keycolumn(tr, cols, p, nk);
	}
	bat_destroy(cols);

	/* find idx with same name */
	n = list_find_name(nk->t->s->idxs, nk->base.name ); 
	if (n) {
		nk->idx = (sql_idx*) n->data;
		nk->idx -> key = nk;
	}

	if (ktype == fkey){
		sql_fkey *fk = (sql_fkey*)nk;
		sqlid rkey = *(sqlid*) bun_find(key_rkey, lid);
		node *n = list_find(t->s->keys, &rkey, (fcmp)&key_cmp);

		assert(n);
		if (n){
			sql_ukey *uk = n->data;
			fk->rkey = uk;
			if (!uk->keys) uk->keys = list_create(NULL);
			list_append(uk->keys, fk);
		}
	} else { /* could be a set of rkeys */
		sql_ukey *uk = (sql_ukey*)nk;
		BAT *keys = BATselect(key_rkey, (ptr) & nk->base.id, (ptr) & nk->base.id);

		BATloop(keys,p,q){
			sqlid fkey = *(sqlid*) BUNhead(keys, p);
			node *n = list_find(t->s->keys, &fkey, (fcmp)&key_cmp);
			if (n){
				sql_fkey *fk = n->data;
				if (!uk->keys) uk->keys = list_create(NULL);
				list_append(uk->keys, fk);
				fk->rkey = uk;
			}
		}
		BBPreclaim(keys);
	}

	bat_destroy(key_id);
	bat_destroy(key_tpe);
	bat_destroy(key_name);
	bat_destroy(key_rkey);
	bat_destroy(kc_id);
	bat_destroy(kc_nr);
	return nk;
}

static void load_idxcolumn(sql_trans *tr, BAT * columns, BUN j, sql_idx *i )
{
	sql_kc *kc = NEW(sql_kc);
	BAT *kc_col = sys_bat(tr->bm, "keycolumns_column");
	BAT *kc_trunc = sys_bat(tr->bm, "keycolumns_trunc");
	ptr lid = BUNhead(columns, j);
	char *name = bun_find(kc_col, lid);
	int trunc = *(int*)bun_find(kc_trunc, lid);
	sql_column *c = find_column(i->t, name);
	assert(c);

	kc->c = c;
	kc->trunc = trunc;
	list_append(i->columns,kc);

	bat_destroy(kc_col);
	bat_destroy(kc_trunc);
}

static sql_idx *load_idx(sql_trans *tr, BAT * idxs, BUN j, sql_table *t)
{
	char bname[BUFSIZ];
	int ccnt;
	BAT *cols, *rcols;
	BAT *idx_id = sys_bat(tr->bm, "idxs_id");
	BAT *idx_tpe = sys_bat(tr->bm, "idxs_type");
	BAT *idx_name = sys_bat(tr->bm, "idxs_name");
	BAT *kc_id = sys_bat(tr->bm, "keycolumns_id");
	BAT *kc_nr = sys_bat(tr->bm, "keycolumns_nr");
	ptr lid = BUNhead(idxs, j);
	idx_type itype = (idx_type)*(int*) bun_find(idx_tpe, lid);
	char *name = (char*) bun_find(idx_name, lid);
	sql_idx *ni = NEW(sql_idx);
	BUN p,q;

	base_init( &ni->base, *(sqlid*) bun_find(idx_id, lid), TR_OLD, name);
	ni->type = itype;
	ni->columns = list_create((fdestroy)&kc_destroy);
	ni->t = t;
	ni->key = NULL;

	cols = BATselect(kc_id, (ptr) & ni->base.id, (ptr) & ni->base.id);
	rcols = BATsemijoin(kc_nr, cols);
	bat_destroy(cols);
	cols = BATmirror(rcols);
	rcols = BATsort(cols);
	bat_destroy(cols);
	cols = BATmirror(rcols);

	ccnt = BATcount(cols);
	if (ccnt) {
		BATloop(cols,p,q)
			load_idxcolumn(tr, cols, p, ni);
	}
	bat_destroy(cols);

	snprintf(bname, BUFSIZ, "%s_%s", t->base.name, ni->base.name);
	ni->bat.bid = bm_find_bat(tr->bm, bname);

	snprintf(bname, BUFSIZ, "U_%s_%s", t->base.name, ni->base.name);
	ni->bat.ubid = bm_find_bat(tr->bm, bname);

	if (ni->bat.bid && ni->bat.ubid){
		BAT *ub = bm_lbid2bat(tr->bm, ni->bat.ubid);
		BAT *db = bm_lbid2bat(tr->bm, t->dbid);
		if (BATcount(db)){
			BAT *b = bind_idx(tr, ni, 1);
			update_table_bat(b, ub, db);
			bat_destroy(b);
		}
		bat_destroy(ub);
		bat_destroy(db);
	}

	bat_destroy(idx_id);
	bat_destroy(idx_tpe);
	bat_destroy(idx_name);
	bat_destroy(kc_id);
	bat_destroy(kc_nr);
	return ni;
}


static sql_column *load_column(sql_trans *tr, sql_table *t, BAT * columns, BUN j)
{
	char name[BUFSIZ], *tpe;
	sql_column *c = NEW(sql_column);
	ptr lid = BUNhead(columns, j);
	int sz,d;
	BAT *column_id = sys_bat(tr->bm, "columns_id");
	BAT *column_name = sys_bat(tr->bm, "columns_name");
	BAT *column_type = sys_bat(tr->bm, "columns_type");
	BAT *column_type_digits = sys_bat(tr->bm, "columns_type_digits");
	BAT *column_type_scale = sys_bat(tr->bm, "columns_type_scale");
	BAT *column_default = sys_bat(tr->bm, "columns_default");
	BAT *column_null = sys_bat(tr->bm, "columns_null");
	BAT *column_number = sys_bat(tr->bm, "columns_number");

	base_init( &c->base, *(sqlid*) bun_find(column_id, lid),
		    TR_OLD, (char *) bun_find(column_name, lid));

	tpe = (char *) bun_find(column_type, lid);
	sz = *(int*)bun_find(column_type_digits, lid);
	d =  *(int*)bun_find(column_type_scale, lid);
	c->type = sql_bind_subtype(tpe,sz,d);
	c->def = _strdup((char *) bun_find(column_default, lid));
	c->null = *(bit *) bun_find(column_null, lid);
	c->colnr = *(int *) bun_find(column_number, lid);
	c->t = t;
	c->st = NULL;

	if (t->type != tt_view){
		snprintf(name, BUFSIZ, "%s_%s", t->base.name, c->base.name );
		c->bat.bid = bm_find_bat(tr->bm, name);

		snprintf(name, BUFSIZ, "U_%s_%s", t->base.name, c->base.name );
		c->bat.ubid = bm_find_bat(tr->bm, name);
	} else {
		c->bat.bid = c->bat.ubid = 0;
	}

	if (mvc_debug)
		fprintf(stderr, "\t\tload column %s\n", c->base.name);

	if (c->bat.bid && c->bat.ubid){
		BAT *ub = bm_lbid2bat(tr->bm, c->bat.ubid);
		BAT *db = bm_lbid2bat(tr->bm, t->dbid);
		if (BATcount(ub) || BATcount(db)){
			BAT *b = bind_bat(tr, c, 1);
			update_table_bat(b, ub, db);
			bat_destroy(b);
		}
		bat_destroy(ub);
		bat_destroy(db);
	}

	bat_destroy(column_id);
	bat_destroy(column_name);
	bat_destroy(column_type);
	bat_destroy(column_type_digits);
	bat_destroy(column_type_scale);
	bat_destroy(column_default);
	bat_destroy(column_null);
	bat_destroy(column_number);
	return c;
}

static sql_table *load_table(sql_trans *tr, sql_schema *s, BAT * tables, BUN j)
{
	char name[BUFSIZ];
	sql_table *t = NEW(sql_table);
	ptr lid = BUNhead(tables, j);
	BAT *cols, *rcols, *keys, *idxs;
	BUN p,q;
	int ccnt;
	BAT *column_table = sys_bat(tr->bm, "columns_table_id");
	BAT *column_number = sys_bat(tr->bm, "columns_number");
	BAT *key_table = sys_bat(tr->bm, "keys_table_id");
	BAT *idx_table = sys_bat(tr->bm, "idxs_table_id");
	BAT *table_id = sys_bat(tr->bm, "tables_id");
	BAT *table_names = sys_bat(tr->bm, "tables_name");
	BAT *table_queries = sys_bat(tr->bm, "tables_query");
	BAT *table_types = sys_bat(tr->bm, "tables_type");

	base_init( &t->base, *(sqlid*) bun_find(table_id, lid),
		TR_OLD, bun_find(table_names, lid));
	t->query = _strdup(bun_find(table_queries, lid));
	t->type = (table_type)*(int*) bun_find(table_types, lid);

	t->pkey = NULL;
	t->s = s;
	t->st = NULL;

	cs_init( &t->columns, (fdestroy)&column_destroy );
	cs_init( &t->idxs, (fdestroy)&idx_destroy );
	cs_init( &t->keys, (fdestroy)&key_destroy );

	snprintf(name, BUFSIZ, "D_%s", t->base.name );
	t->dbid = bm_find_bat(tr->bm, name);

	cols = BATselect(column_table, (ptr) & t->base.id, (ptr) & t->base.id);
	rcols = BATsemijoin(column_number, cols);
	bat_destroy(cols);
	cols = BATmirror(rcols);
	rcols = BATsort(cols);
	bat_destroy(cols);
	cols = BATmirror(rcols);

	if (mvc_debug)
		fprintf(stderr, "\tload table %s\n", t->base.name);

	BATloop (cols,p,q)
		cs_add( &t->columns, load_column(tr, t, cols, p), TR_OLD);

	bat_destroy(cols);

	/* load idx's first as the may be needed by the keys */
	idxs = BATselect(key_table, (ptr) & t->base.id, (ptr) & t->base.id);
	ccnt = BATcount(idxs);
	if (t->type != tt_view && ccnt) {
		BATloop(idxs,p,q){
			sql_idx *i;
			cs_add( &t->idxs, i=load_idx(tr, idxs, p, t), TR_OLD);
			list_append(s->idxs,i);
		}
	}
	bat_destroy(idxs);

	keys = BATselect(key_table, (ptr) & t->base.id, (ptr) & t->base.id);
	ccnt = BATcount(keys);
	if (t->type != tt_view && ccnt) {
		BATloop(keys,p,q){
			sql_key *k;
			cs_add( &t->keys, k=load_key(tr, keys, p, t), TR_OLD);
			list_append(s->keys,k);
		}
	}

	bat_destroy(keys);

	bat_destroy(idx_table);
	bat_destroy(key_table);
	bat_destroy(column_table);
	bat_destroy(column_number);
	bat_destroy(table_id);
	bat_destroy(table_names);
	bat_destroy(table_queries);
	bat_destroy(table_types);
	return t;
}

static sql_schema *load_schema(sql_trans *tr, BAT * schemas, BUN j)
{
	sql_schema *s = NEW(sql_schema);
	ptr lid = BUNhead(schemas, j);
	BAT *tables;
	BUN p,q;
	BAT *schema_names = sys_bat(tr->bm, "schemas_name");
	BAT *schema_auths = sys_bat(tr->bm, "schemas_authorization");
	BAT *table_schema = sys_bat(tr->bm, "tables_schema_id");

	base_init( &s->base, *(sqlid*) bun_find(schemas, lid),
		TR_OLD, bun_find(schema_names, lid));
	s->auth = _strdup(bun_find(schema_auths, lid));
	s->keys = list_create((fdestroy)NULL);
	s->idxs = list_create((fdestroy)NULL);
	cs_init( &s->tables, (fdestroy)&table_destroy);

	if (mvc_debug)
		fprintf(stderr, "load schema %s %d\n", s->base.name, s->base.id);

	tables = BATselect(table_schema, (ptr) & s->base.id, (ptr) & s->base.id);
	
	BATloop(tables,p,q)
		cs_add( &s->tables, load_table(tr, s, tables, p), TR_OLD);

	bat_destroy(tables);
	bat_destroy(table_schema);
	bat_destroy(schema_auths);
	bat_destroy(schema_names);
	return s;
}

static sql_trans *load_trans(struct bm *bm)
{
	sql_trans *t = NEW(sql_trans);
	BUN p,q;
	BAT *schema_ids = sys_bat(bm, "schemas_id");

	t->name = NULL;
	t->wtime = t->rtime = 0;
	t->stime = timestamp();
	t->level = ISO_SERIALIZABLE;
	t->parent = NULL;
	t->bm = bm;

	cs_init( &t->schemas, (fdestroy)&schema_destroy );

	if (mvc_debug)
		fprintf(stderr, "load trans\n");

	BATloop(schema_ids,p,q)
		cs_add( &t->schemas, load_schema(t, schema_ids, p), TR_OLD);

	bat_destroy(schema_ids);
	return t;
}

static sql_kc *kc_dup(sql_trans *tr, sql_kc *kc, sql_table *t)
{
	sql_kc *nkc = NEW(sql_kc);
	sql_column *c = find_column(t, kc->c->base.name); 

	(void) tr; /* unused! */
	assert(c);
	nkc->c = c;
	nkc->trunc = kc->trunc;
	return nkc;
}

static sql_key *key_dup(sql_trans *tr, sql_key *k, sql_table *t)
{
	sql_key *nk = (k->type!=fkey)?(sql_key*)NEW(sql_ukey)
				:(sql_key*)NEW(sql_fkey);
	node *n;

	base_init( &nk->base, k->base.id, TR_OLD, k->base.name);
	nk->type = k->type;
	nk->columns = list_create((fdestroy)&kc_destroy);
	nk->t = t;
	nk->idx = NULL;

	if (k->idx){
		node *n = list_find_name(nk->t->s->idxs, nk->base.name ); 
		if (n){
			nk->idx = (sql_idx*) n->data;
			nk->idx -> key = nk;
		}
	}

	if (nk->type != fkey){
		sql_ukey *tk = (sql_ukey*)nk;
		tk -> keys = NULL;

		if (nk->type == pkey)
			t->pkey = tk;
	} else {
		sql_fkey *tk = (sql_fkey*)nk;
		tk -> rkey = NULL;
	}

	for(n = k->columns->h; n; n = n->next){
		sql_kc *okc = n->data;
		list_append(nk->columns, kc_dup(tr, okc, t));
	}

	if (nk->type == fkey){
		sql_fkey *fk = (sql_fkey*)nk;
		sql_fkey *ok = (sql_fkey*)k;
		node *n;
		assert( ok->rkey );
		n = list_find(t->s->keys, &ok->rkey->k.base.id, (fcmp)&key_cmp);
		assert(n);
		if (n){
			sql_ukey *uk = n->data;
			fk->rkey = uk;
			if (!uk->keys) uk->keys = list_create(NULL);
			list_append(uk->keys, fk);
		}
	} else { /* could be a set of rkeys */
		sql_ukey *uk = (sql_ukey*)nk;
		sql_ukey *ok = (sql_ukey*)k;
		node *m;
		if (ok->keys) for(m=ok->keys->h; m; m = m -> next){
			sql_fkey *ofk = m->data;
			node *n = list_find(t->s->keys, &ofk->k.base.id, (fcmp)&key_cmp);
			if (n){
				sql_fkey *fk = n->data;
				if (!uk->keys) uk->keys = list_create(NULL);
				list_append(uk->keys, fk);
				fk->rkey = uk;
			}
		}
	}
	list_append(t->s->keys, nk);
	return nk;
}

static sql_idx *idx_dup(sql_trans *tr, sql_idx *i, sql_table *t)
{
	sql_idx *ni = NEW(sql_idx);
	node *n;

	base_init( &ni->base, i->base.id, TR_OLD, i->base.name);
	ni->columns = list_create((fdestroy)&kc_destroy);
	ni->t = t;
	ni->type = i->type;
	ni->bat.bid = i->bat.bid;
	ni->bat.ubid = i->bat.ubid;
	ni->key = NULL;

	for(n = i->columns->h; n; n = n->next){
		sql_kc *okc = n->data;
		list_append(ni->columns, kc_dup(tr, okc, t));
	}
	list_append(t->s->idxs, ni);
	return ni;
}

static sql_column *column_dup(sql_trans *tr, sql_column * oc, sql_table *t)
{
	sql_column *c = NEW(sql_column);
	(void)tr;
	base_init( &c->base, oc->base.id, TR_OLD, oc->base.name);
	c->type = sql_dup_subtype(oc->type);
	c->def = _strdup(oc->def);
	c->null = oc->null;
	c->colnr = oc->colnr;
	c->bat.bid = oc->bat.bid;
	c->bat.ubid = oc->bat.ubid;

	c->t = t;
	c->st = NULL;
	return c;
}

static sql_table *table_dup(sql_trans *tr, sql_table * ot, sql_schema *s)
{
	node *n;
	sql_table *t = NEW(sql_table);

	base_init( &t->base, ot->base.id, TR_OLD, ot->base.name);
	t->type = ot->type;
	t->query = _strdup(ot->query);

	cs_init( &t->columns, (fdestroy)&column_destroy);
	cs_init( &t->keys, (fdestroy)&key_destroy);
	cs_init( &t->idxs, (fdestroy)&idx_destroy);

	t->pkey = NULL;

	t->dbid = ot->dbid;

	t->s = s;
	t->st = NULL;

	if (ot->columns.set) for (n = ot->columns.set->h; n; n = n->next) {
		sql_column *c = n->data;
		cs_add( &t->columns, column_dup(tr, c, t), TR_OLD);
	}
	if (ot->idxs.set) for (n = ot->idxs.set->h; n; n = n->next) {
		sql_idx *i = n->data;
		cs_add( &t->idxs, idx_dup(tr, i, t), TR_OLD);
	}
	if (ot->keys.set) for (n = ot->keys.set->h; n; n = n->next) {
		sql_key *k = n->data;
		cs_add( &t->keys, key_dup(tr, k, t), TR_OLD);
	}
	return t;
}

static sql_schema *schema_dup(sql_trans *tr, sql_schema * os, sql_trans *o)
{
	node *n;
	sql_schema *s = NEW(sql_schema);
	
	(void)o;
	base_init( &s->base, os->base.id, TR_OLD, os->base.name);
	s->auth = _strdup(os->auth);
	cs_init( &s->tables, (fdestroy)&table_destroy );
	s->keys = list_create((fdestroy)NULL);
	s->idxs = list_create((fdestroy)NULL);

	if (os->tables.set ) for (n = os->tables.set->h; n; n = n->next) {
		sql_table *ot = n->data;
		if (ot->type != tt_temp && ot->type != tt_session)
			cs_add( &s->tables, table_dup(tr, ot, s), TR_OLD);
	}
	return s;
}


static sql_trans *trans_dup(sql_trans *ot, char *newname ){
	node *n;
	sql_trans *t = NEW(sql_trans);

	t->wtime = t->rtime = 0;
	t->stime = timestamp();
	t->level = ot->level;
	t->parent = ot;
	t->bm = bm_dup(ot->bm);

	cs_init( &t->schemas, (fdestroy)&schema_destroy );
	if (newname)
		t->name = _strdup(newname);
	else 
		t->name = NULL;

	if (ot->schemas.set) for (n = ot->schemas.set->h; n; n = n->next) {
		cs_add( &t->schemas, schema_dup(t, n->data, t), TR_OLD);
	}
	return t;
}

static BAT *mvc_bat( struct bm *bm, char *name, int type)
{
	BAT *b = NULL;
	bat id = bm_find_bat(bm, name);

	if (mvc_debug)
		fprintf(stderr, "mvc_bat %s bid %d\n", name, id);

	if (id == 0) {
		if (mvc_debug)
			fprintf(stderr, "mvc_bat created %s bid %d\n", name,id);
		b = BATnew( TYPE_void, type, BUFSIZ );
		BATseqbase(b,0);
		bm_add_bat(bm, b->batCacheid, name, 0 /* do not use a transaction id */);
	} else {
		if (mvc_debug)
			fprintf(stderr, "mvc_bat loaded %s bid %d\n", name, id);
		b = bm_lbid2bat(bm, id);
		if (!bm_lbid2mode(bm, id)){
			b = bat_lcopy(b);
			bm_new_bat(bm, id, b->batCacheid);
		}
	}
	return b;
}

static void mvc_init_schema( struct bm *bm )
{
	BAT *sql_schema_id = mvc_bat(bm, "schemas_id", TYPE_int);
	BAT *sql_schema_name = mvc_bat(bm, "schemas_name", TYPE_str);
	BAT *sql_schema_auth = mvc_bat(bm, "schemas_authorization", TYPE_str);
	BAT *U_schema_id = mvc_bat(bm, "U_schemas_id", TYPE_int);
	BAT *U_schema_name = mvc_bat(bm, "U_schemas_name", TYPE_str);
	BAT *U_schema_auth = mvc_bat(bm, "U_schemas_authorization", TYPE_str);
	BAT *D_sql_schema = mvc_bat(bm, "D_schemas", TYPE_oid);

	update_table_bat(sql_schema_id, U_schema_id, D_sql_schema);
	update_table_bat(sql_schema_name, U_schema_name, D_sql_schema);
	update_table_bat(sql_schema_auth, U_schema_auth, D_sql_schema);

	bat_destroy(sql_schema_id);
	bat_destroy(sql_schema_name);
	bat_destroy(sql_schema_auth);
	bat_destroy(U_schema_id);
	bat_destroy(U_schema_name);
	bat_destroy(U_schema_auth);
	bat_destroy(D_sql_schema);
}

static void mvc_init_table( struct bm *bm )
{
	BAT *sql_table_id = mvc_bat(bm, "tables_id", TYPE_int);
	BAT *sql_table_name = mvc_bat(bm, "tables_name", TYPE_str);
	BAT *sql_table_schema = mvc_bat(bm, "tables_schema_id", TYPE_int);
	BAT *sql_table_query = mvc_bat(bm, "tables_query", TYPE_str);
	BAT *sql_table_type = mvc_bat(bm, "tables_type", TYPE_int);
	BAT *U_table_id = mvc_bat(bm, "U_tables_id", TYPE_int);
	BAT *U_table_name = mvc_bat(bm, "U_tables_name", TYPE_str);
	BAT *U_table_schema = mvc_bat(bm, "U_tables_schema_id", TYPE_int);
	BAT *U_table_query = mvc_bat(bm, "U_tables_query", TYPE_str);
	BAT *U_table_type = mvc_bat(bm, "U_tables_type", TYPE_int);
	BAT *D_sql_table = mvc_bat(bm, "D_tables", TYPE_oid);

	update_table_bat(sql_table_id, U_table_id, D_sql_table);
	update_table_bat(sql_table_name, U_table_name, D_sql_table);
	update_table_bat(sql_table_schema, U_table_schema, D_sql_table);
	update_table_bat(sql_table_query, U_table_query, D_sql_table);
	update_table_bat(sql_table_type, U_table_type, D_sql_table);

	bat_destroy(sql_table_id);
	bat_destroy(sql_table_name);
	bat_destroy(sql_table_schema);
	bat_destroy(sql_table_query);
	bat_destroy(sql_table_type);
	bat_destroy(U_table_id);
	bat_destroy(U_table_name);
	bat_destroy(U_table_schema);
	bat_destroy(U_table_query);
	bat_destroy(U_table_type);
	bat_destroy(D_sql_table);
}

static void mvc_init_column( struct bm *bm )
{
	BAT *sql_column_id = mvc_bat(bm, "columns_id", TYPE_int);
	BAT *sql_column_name = mvc_bat(bm, "columns_name", TYPE_str);
	BAT *sql_column_type = mvc_bat(bm, "columns_type", TYPE_str);
	BAT *sql_column_type_digits = mvc_bat(bm, "columns_type_digits", TYPE_int);
	BAT *sql_column_type_scale = mvc_bat(bm, "columns_type_scale", TYPE_int);
	BAT *sql_column_table = mvc_bat(bm, "columns_table_id", TYPE_int);
	BAT *sql_column_default = mvc_bat(bm, "columns_default", TYPE_str);
	BAT *sql_column_null = mvc_bat(bm, "columns_null", TYPE_bit);
	BAT *sql_column_number = mvc_bat(bm, "columns_number", TYPE_int);
	BAT *U_column_id = mvc_bat(bm, "U_columns_id", TYPE_int);
	BAT *U_column_name = mvc_bat(bm, "U_columns_name", TYPE_str);
	BAT *U_column_type = mvc_bat(bm, "U_columns_type", TYPE_str);
	BAT *U_column_type_digits = mvc_bat(bm, "U_columns_type_digits", TYPE_int);
	BAT *U_column_type_scale = mvc_bat(bm, "U_columns_type_scale", TYPE_int);
	BAT *U_column_table = mvc_bat(bm, "U_columns_table_id", TYPE_int);
	BAT *U_column_default = mvc_bat(bm, "U_columns_default", TYPE_str);
	BAT *U_column_null = mvc_bat(bm, "U_columns_null", TYPE_bit);
	BAT *U_column_number = mvc_bat(bm, "U_columns_number", TYPE_int);
	BAT *D_sql_column = mvc_bat(bm, "D_columns", TYPE_oid);

	update_table_bat(sql_column_id, U_column_id, D_sql_column);
	update_table_bat(sql_column_name, U_column_name, D_sql_column);
	update_table_bat(sql_column_type, U_column_type, D_sql_column);
	update_table_bat(sql_column_type_digits, U_column_type_digits, D_sql_column);
	update_table_bat(sql_column_type_scale, U_column_type_scale, D_sql_column);
	update_table_bat(sql_column_table, U_column_table, D_sql_column);
	update_table_bat(sql_column_default, U_column_default, D_sql_column);
	update_table_bat(sql_column_null, U_column_null, D_sql_column);
	update_table_bat(sql_column_number, U_column_number, D_sql_column);

	bat_destroy(sql_column_id);
	bat_destroy(sql_column_name);
	bat_destroy(sql_column_type);
	bat_destroy(sql_column_type_digits);
	bat_destroy(sql_column_type_scale);
	bat_destroy(sql_column_table);
	bat_destroy(sql_column_default);
	bat_destroy(sql_column_null);
	bat_destroy(sql_column_number);
	bat_destroy(U_column_id);
	bat_destroy(U_column_name);
	bat_destroy(U_column_type);
	bat_destroy(U_column_type_digits);
	bat_destroy(U_column_type_scale);
	bat_destroy(U_column_table);
	bat_destroy(U_column_default);
	bat_destroy(U_column_null);
	bat_destroy(U_column_number);
	bat_destroy(D_sql_column);
}


static void mvc_init_key( struct bm *bm )
{
	BAT *key_id = mvc_bat(bm, "keys_id", TYPE_int);
	BAT *key_table = mvc_bat(bm, "keys_table_id", TYPE_int);
	BAT *key_tpe = mvc_bat(bm, "keys_type", TYPE_int);
	BAT *key_name = mvc_bat(bm, "keys_name", TYPE_str);
	BAT *key_rkey = mvc_bat(bm, "keys_rkey", TYPE_int);
	BAT *U_key_id = mvc_bat(bm, "U_keys_id", TYPE_int);
	BAT *U_key_table = mvc_bat(bm, "U_keys_table_id", TYPE_int);
	BAT *U_key_tpe = mvc_bat(bm, "U_keys_type", TYPE_str);
	BAT *U_key_name = mvc_bat(bm, "U_keys_name", TYPE_int);
	BAT *U_key_rkey = mvc_bat(bm, "U_keys_rkey", TYPE_int);
	BAT *D_key = mvc_bat(bm, "D_keys", TYPE_oid);

	BAT *kc_id = mvc_bat(bm, "keycolumns_id", TYPE_int);
	BAT *kc_col = mvc_bat(bm, "keycolumns_column", TYPE_str);
	BAT *kc_trunc = mvc_bat(bm, "keycolumns_trunc", TYPE_int);
	BAT *kc_nr = mvc_bat(bm, "keycolumns_nr", TYPE_int);
	BAT *U_kc_id = mvc_bat(bm, "U_keycolumns_id", TYPE_int);
	BAT *U_kc_col = mvc_bat(bm, "U_keycolumns_column", TYPE_str);
	BAT *U_kc_trunc = mvc_bat(bm, "U_keycolumns_trunc", TYPE_int);
	BAT *U_kc_nr = mvc_bat(bm, "U_keycolumns_nr", TYPE_int);
	BAT *D_kc = mvc_bat(bm, "D_keycolumns", TYPE_oid);

	update_table_bat(key_id, U_key_id, D_key);
	update_table_bat(key_table, U_key_table, D_key);
	update_table_bat(key_tpe, U_key_tpe, D_key);
	update_table_bat(key_name, U_key_name, D_key);
	update_table_bat(key_rkey, U_key_rkey, D_key);
	/* key_updaterule = mvc_bat(bm, "keys_updaterule", TYPE_int); */
	/* key_deleterule = mvc_bat(bm, "keys_deleterule", TYPE_int); */
	/* key_deferrability = mvc_bat(bm, "keys_deferrability", TYPE_int); */

	update_table_bat(kc_id, U_kc_id, D_kc);
	update_table_bat(kc_col, U_kc_col, D_kc);
	update_table_bat(kc_trunc, U_kc_trunc, D_kc);
	update_table_bat(kc_nr, U_kc_nr, D_kc);

	bat_destroy(key_id);
	bat_destroy(key_table);
	bat_destroy(key_tpe);
	bat_destroy(key_name);
	bat_destroy(key_rkey);
	bat_destroy(U_key_id);
	bat_destroy(U_key_table);
	bat_destroy(U_key_tpe);
	bat_destroy(U_key_name);
	bat_destroy(U_key_rkey);
	bat_destroy(D_key);

	bat_destroy(kc_id);
	bat_destroy(kc_col);
	bat_destroy(kc_trunc);
	bat_destroy(kc_nr);
	bat_destroy(U_kc_id);
	bat_destroy(U_kc_col);
	bat_destroy(U_kc_trunc);
	bat_destroy(U_kc_nr);
	bat_destroy(D_kc);
}

static void mvc_init_idx( struct bm *bm )
{
	BAT *idx_id = mvc_bat(bm, "idxs_id", TYPE_int);
	BAT *idx_table = mvc_bat(bm, "idxs_table_id", TYPE_int);
	BAT *idx_tpe = mvc_bat(bm, "idxs_type", TYPE_int);
	BAT *idx_name = mvc_bat(bm, "idxs_name", TYPE_str);
	BAT *U_idx_id = mvc_bat(bm, "U_idxs_id", TYPE_int);
	BAT *U_idx_table = mvc_bat(bm, "U_idxs_table_id", TYPE_int);
	BAT *U_idx_tpe = mvc_bat(bm, "U_idxs_type", TYPE_str);
	BAT *U_idx_name = mvc_bat(bm, "U_idxs_name", TYPE_int);
	BAT *D_idx = mvc_bat(bm, "D_idxs", TYPE_oid);

	BAT *kc_id = mvc_bat(bm, "keycolumns_id", TYPE_int);
	BAT *kc_col = mvc_bat(bm, "keycolumns_column", TYPE_str);
	BAT *kc_trunc = mvc_bat(bm, "keycolumns_trunc", TYPE_int);
	BAT *kc_nr = mvc_bat(bm, "keycolumns_nr", TYPE_int);
	BAT *U_kc_id = mvc_bat(bm, "U_keycolumns_id", TYPE_int);
	BAT *U_kc_col = mvc_bat(bm, "U_keycolumns_column", TYPE_str);
	BAT *U_kc_trunc = mvc_bat(bm, "U_keycolumns_trunc", TYPE_int);
	BAT *U_kc_nr = mvc_bat(bm, "U_keycolumns_nr", TYPE_int);
	BAT *D_kc = mvc_bat(bm, "D_keycolumns", TYPE_oid);

	update_table_bat(idx_id, U_idx_id, D_idx);
	update_table_bat(idx_table, U_idx_table, D_idx);
	update_table_bat(idx_tpe, U_idx_tpe, D_idx);
	update_table_bat(idx_name, U_idx_name, D_idx);
	/* key_updaterule = mvc_bat(bm, "keys_updaterule", TYPE_int); */
	/* key_deleterule = mvc_bat(bm, "keys_deleterule", TYPE_int); */
	/* key_deferrability = mvc_bat(bm, "keys_deferrability", TYPE_int); */

	update_table_bat(kc_id, U_kc_id, D_kc);
	update_table_bat(kc_col, U_kc_col, D_kc);
	update_table_bat(kc_trunc, U_kc_trunc, D_kc);
	update_table_bat(kc_nr, U_kc_nr, D_kc);

	bat_destroy(idx_id);
	bat_destroy(idx_table);
	bat_destroy(idx_tpe);
	bat_destroy(idx_name);
	bat_destroy(U_idx_id);
	bat_destroy(U_idx_table);
	bat_destroy(U_idx_tpe);
	bat_destroy(U_idx_name);
	bat_destroy(D_idx);

	bat_destroy(kc_id);
	bat_destroy(kc_col);
	bat_destroy(kc_trunc);
	bat_destroy(kc_nr);
	bat_destroy(U_kc_id);
	bat_destroy(U_kc_col);
	bat_destroy(U_kc_trunc);
	bat_destroy(U_kc_nr);
	bat_destroy(D_kc);
}

static void mvc_init_type( struct bm *bm )
{
	node *n = NULL;

	BAT *type_sqlname = mvc_bat(bm, "types_sqlname", TYPE_str);
	BAT *type_digits = mvc_bat(bm, "types_digits", TYPE_int);
	BAT *type_scale = mvc_bat(bm, "types_scale", TYPE_int);
	BAT *type_radix = mvc_bat(bm, "types_radix", TYPE_int);
	BAT *type_systemname = mvc_bat(bm, "types_systemname", TYPE_str);
	BAT *U_type_sqlname = mvc_bat(bm, "U_types_sqlname", TYPE_str);
	BAT *U_type_digits = mvc_bat(bm, "U_types_digits", TYPE_int);
	BAT *U_type_scale = mvc_bat(bm, "U_types_scale", TYPE_int);
	BAT *U_type_radix = mvc_bat(bm, "U_types_radix", TYPE_int);
	BAT *U_type_systemname = mvc_bat(bm, "U_types_systemname", TYPE_str);
	BAT *D_type = mvc_bat(bm, "D_types", TYPE_oid);

	if (BATcount(type_sqlname) == 0) for (n = types->h; n; n = n->next) {
		oid nil = oid_nil;
		sql_type *t = n->data;

		BUNins(type_sqlname, &nil, t->sqlname);
		BUNins(type_digits, &nil, &t->digits);
		BUNins(type_scale, &nil, &t->scale);
		BUNins(type_radix, &nil, &t->radix);
		BUNins(type_systemname, &nil, t->name);
	}

	bat_destroy(type_sqlname);
	bat_destroy(type_digits);
	bat_destroy(type_scale);
	bat_destroy(type_radix);
	bat_destroy(type_systemname);
	bat_destroy(U_type_sqlname);
	bat_destroy(U_type_digits);
	bat_destroy(U_type_scale);
	bat_destroy(U_type_radix);
	bat_destroy(U_type_systemname);
	bat_destroy(D_type);
}

void mvc_init(int debug)
{
	struct bm *bm = NULL;
	char *logdir = GDKgetenv("sql_logdir");
	char *dbname = GDKgetenv("gdk_dbname");
	
	assert(logdir && dbname);

	mvc_debug = debug;
	if (mvc_debug)
		fprintf(stderr, "mvc_init logdir %s%c%s\n", logdir, DIR_SEP, dbname);

	parser_init(debug);

	bm = bm_create(debug);
	logger = logger_create(mvc_debug, logdir, dbname, bm);

	mvc_init_schema(bm);
	mvc_init_table(bm);
	mvc_init_column(bm);
	mvc_init_key(bm);
	mvc_init_idx(bm);
	mvc_init_type(bm);

	mvc_lock = MT_create_lock();

	MT_set_lock(mvc_lock, "mvc_init");

	gtrans = load_trans(bm);

	MT_unset_lock(mvc_lock, "mvc_init");

	if (!find_schema(gtrans, "sys")){
		sql_schema *s;
		sql_table *t;
		mvc *m = mvc_create(mvc_debug);

		s = bootstrap_create_schema(m, "sys", "sqladmin");
		t = bootstrap_create_table (m, s, "schemas", tt_system);
		bootstrap_create_column(m, t, "id", "MEDIUMINT",0,0);
		bootstrap_create_column(m, t, "name", "VARCHAR",0,0);
		bootstrap_create_column(m, t, "authorization", "VARCHAR",0,0);

		t = bootstrap_create_table(m, s, "tables", tt_system);
		bootstrap_create_column(m, t, "id", "MEDIUMINT",0,0);
		bootstrap_create_column(m, t, "name", "VARCHAR",0,0);
		bootstrap_create_column(m, t, "schema_id", "MEDIUMINT",0,0);
		bootstrap_create_column(m, t, "query", "VARCHAR",0,0);
		bootstrap_create_column(m, t, "type", "MEDIUMINT",0,0);

		t = bootstrap_create_table(m, s, "columns", tt_system);
		bootstrap_create_column(m, t, "id", "MEDIUMINT", 0, 0);
		bootstrap_create_column(m, t, "name", "VARCHAR", 0, 0);
		bootstrap_create_column(m, t, "type", "VARCHAR", 0, 0);
		bootstrap_create_column(m, t, "type_digits", "MEDIUMINT", 0, 0);
		bootstrap_create_column(m, t, "type_scale", "MEDIUMINT", 0, 0);
		bootstrap_create_column(m, t, "table_id", "MEDIUMINT", 0, 0);
		bootstrap_create_column(m, t, "default", "VARCHAR", 0, 0);
		bootstrap_create_column(m, t, "null", "BOOL", 0, 0);
		bootstrap_create_column(m, t, "number", "MEDIUMINT", 0, 0);

		t = bootstrap_create_table(m, s, "keys", tt_system);
		bootstrap_create_column(m, t, "id", "MEDIUMINT",0,0);
		bootstrap_create_column(m, t, "table_id", "MEDIUMINT",0,0);
		bootstrap_create_column(m, t, "type", "MEDIUMINT",0,0);
		bootstrap_create_column(m, t, "name", "MEDIUMINT",0,0);
		bootstrap_create_column(m, t, "rkey", "MEDIUMINT",0,0);

		t = bootstrap_create_table(m, s, "idxs", tt_system);
		bootstrap_create_column(m, t, "id", "MEDIUMINT",0,0);
		bootstrap_create_column(m, t, "table_id", "MEDIUMINT",0,0);
		bootstrap_create_column(m, t, "type", "MEDIUMINT",0,0);
		bootstrap_create_column(m, t, "name", "MEDIUMINT",0,0);

		t = bootstrap_create_table(m, s, "keycolumns", tt_system);
		bootstrap_create_column(m, t, "id", "MEDIUMINT",0,0);
		bootstrap_create_column(m, t, "column", "VARCHAR",0,0);
		bootstrap_create_column(m, t, "trunc", "MEDIUMINT",0,0);
		bootstrap_create_column(m, t, "nr", "MEDIUMINT",0,0);

		t = bootstrap_create_table (m, s, "types", tt_system);
		bootstrap_create_column(m, t, "sqlname", "VARCHAR",0,0);
		bootstrap_create_column(m, t, "digits", "MEDIUMINT",0,0);
		bootstrap_create_column(m, t, "scale", "MEDIUMINT",0,0);
		bootstrap_create_column(m, t, "radix", "MEDIUMINT",0,0);
		bootstrap_create_column(m, t, "systemname", "VARCHAR",0,0);

		/* now the authorisation related tables */
		t = mvc_create_table(m, s, "users", tt_system );
		mvc_create_column(m, t, "name", "VARCHAR",0,0);
		mvc_create_column(m, t, "passwd", "VARCHAR",0,0);
		mvc_create_column(m, t, "fullname", "VARCHAR",0,0);
		mvc_create_column(m, t, "default_schema", "MEDIUMINT",0,0);

		t = mvc_create_table(m, s, "auths", tt_system );
		mvc_create_column(m, t, "id", "MEDIUMINT",0,0);
		mvc_create_column(m, t, "name", "VARCHAR",0,0);
		mvc_create_column(m, t, "grantor", "MEDIUMINT",0,0);
		mvc_create_column(m, t, "privileges", "MEDIUMINT",0,0);

		t = mvc_create_table(m, s, "user_role", tt_system );
		mvc_create_column(m, t, "login_id", "MEDIUMINT",0,0);
		mvc_create_column(m, t, "role_id", "MEDIUMINT",0,0);

		t = mvc_create_table(m, s, "table_privileges", tt_system );
		mvc_create_column(m, t, "table_id", "MEDIUMINT",0,0);
		mvc_create_column(m, t, "auth_id", "MEDIUMINT",0,0);
		mvc_create_column(m, t, "privileges", "MEDIUMINT",0,0);

		t = mvc_create_table(m, s, "column_privileges", tt_system );
		mvc_create_column(m, t, "column_id", "MEDIUMINT",0,0);
		mvc_create_column(m, t, "auth_id", "MEDIUMINT",0,0);
		mvc_create_column(m, t, "privileges", "MEDIUMINT",0,0);

		/* add monetdb user */
		sql_create_user(m, "monetdb", "monetdb", "MonetDB Admin", "sys", 0);
		mvc_create_schema(m, "default-schema", "sqladmin");

		m->trans->schema = s;
		if (mvc_commit(m, 0, NULL) <0){
			fprintf(stderr, "mvc_init: unable to create system tables\n");
			exit(1);
		}
		mvc_destroy(m);
	}
}

int mvc_set_user( mvc *m, char *user )
{
	BUN p;
	int res = 0;
	BAT *auth_name = BATmirror(mvc_bind(m, "sys", "auths", "name", 0 ));

	if (mvc_debug)
		fprintf(stderr, "mvc_set_user %s\n", user);

	if ((p=BUNfnd(auth_name, user)) != NULL){
		ptr lid = BUNtail(auth_name,p);
		BAT *auth_id = mvc_bind(m, "sys", "auths", "id", 0 );
		int id = *(int*)BUNtail(auth_id, BUNfnd(auth_id, lid));
		BAT *auth_priv = mvc_bind(m, "sys", "auths", "privileges", 0 );
		int priv = *(int*)BUNtail(auth_priv, BUNfnd(auth_priv, lid));
		m->user_id = m->role_id = id;
		m->user = _strdup(user);
		m->privileges = priv;
		res = 1;
		bat_destroy(auth_id);
		bat_destroy(auth_priv);
	}
	bat_destroy(auth_name);
	return res;
}

char *mvc_login(mvc *m, char *user, char *passwd)
{
	char *schema = NULL;
	BAT *name_user = BATmirror(mvc_bind(m, "sys", "users", "name", 0 ));
	BUN p;

	if (mvc_debug)
		fprintf(stderr, "mvc_login %s\n", user);

	if ((p=BUNfnd(name_user, user)) != NULL){
		ptr userid = BUNtail(name_user, p);
		BAT *user_pwd = mvc_bind(m, "sys", "users", "passwd", 0 );
		char *pwd = BUNtail(user_pwd, BUNfnd(user_pwd, userid));
		
		if (strcmp(passwd, pwd) == 0){
			BAT *user_ds = mvc_bind(m, "sys", "users", "default_schema", 0 );
			BAT *id_schema = BATmirror(mvc_bind(m, "sys", "schemas", "id", 0 ));
			BAT *schema_name = mvc_bind(m, "sys", "schemas", "name", 0 );
			ptr schema_id = BUNtail(user_ds, BUNfnd(user_ds, userid)); 
			ptr lid = BUNtail(id_schema,BUNfnd(id_schema, schema_id));
			schema = BUNtail(schema_name,BUNfnd(schema_name, lid));
			if (mvc_set_user(m, user)){ 
				schema = _strdup(schema);
			} else { /* only set schema if user is found */
				schema = NULL;
			}
			bat_destroy(id_schema);
			bat_destroy(schema_name);
			bat_destroy(user_ds);
		}
		bat_destroy(user_pwd);
	}
	bat_destroy(name_user);

	if (!schema)
		return NULL;

	m->trans->schema = find_schema(m->trans, schema);
	if (!m->trans->schema) {
		_DELETE(schema);
		return NULL;
	}
	return schema;
}

void mvc_exit()
{

	if (mvc_debug)
		fprintf(stderr, "mvc_exit\n");

	logger_exit(logger); 
	logger_destroy(logger); 
	parser_exit();

	trans_destroy(gtrans);
}

mvc *mvc_create(int debug)
{
	mvc *m = NEW(mvc);

	if (debug)
		fprintf(stderr, "mvc_create\n");

	MT_set_lock(mvc_lock, "mvc_create");

	m->debug = debug;
	m->role_id = m->user_id = -1;
	m->role = m->user = NULL;
	m->privileges = 0;
	m->trans = NULL;
	m->trans = trans_dup(gtrans,NULL);
	m->status = 0;
	m->type = Q_PARSE;

	m->result_id = 0;
	m->results = NULL;

	MT_unset_lock(mvc_lock, "mvc_create");
	return m;
}

ssize_t mvc_status( mvc *m ){
	int res = m->status;

	m->status = 0;
	return res;
}

int mvc_type( mvc *m ){
	int res = m->type;
	m->type = Q_PARSE;
	return res;
}

typedef void (*rfufunc)( sql_trans *tr, sql_base *fs, sql_base *ts );
typedef sql_base *(*rfcfunc)( sql_trans *tr, sql_base *b );
typedef sql_base *(*rfdfunc)( sql_trans *tr, sql_base *b );
typedef sql_base *(*dupfunc)( sql_trans *tr, sql_base *b, sql_base *p );

static void 
rollforward_changeset_updates(sql_trans *tr, changeset *fs, changeset *ts, 
	sql_base *b,
	rfufunc rollforward_updates, 
	rfcfunc rollforward_creates, 
	rfdfunc rollforward_deletes, 
	dupfunc fd)
{
	node *n = NULL;
	
	/* delete removed bases */
	if (fs->dset) for (n = fs->dset->h; n; n = n->next) {	
		sql_base *fb = n->data;
		sql_base *tb = cs_find_name(ts, fb->name)->data;

		if (rollforward_deletes) 
			rollforward_deletes(tr, tb);
		list_remove_data(ts->set, tb);
	}
	/* changes to the existing bases */
	if (fs->set && rollforward_updates){
		for (n = fs->set->h; n && n != fs->nelm; n = n->next) {	
			sql_base *fb = n->data;
			sql_base *tb = cs_find_name(ts, fb->name)->data;

			if (fb->wtime && fb->flag == TR_OLD)
				rollforward_updates(tr, fb, tb);
		}
		/* add the new bases */
		if (fd) {
			for (; n; n = n->next) {	
				sql_base *fb = n->data;
				sql_base *tb = fd(tr, fb, b);
	
				/* add the new bases */
				if (rollforward_creates)
					cs_add( ts, rollforward_creates(tr, tb), TR_OLD );
			}
		}
	}
}

static void
rollforward_changeset_creates( sql_trans *tr, changeset *cs, rfcfunc rf )
{
	if (cs->set){
		node *n;

		for (n = cs->set->h; n; n = n->next){
			sql_base *b = n->data;

			rf(tr, b);
		}
	}
}

static void
rollforward_changeset_deletes( sql_trans *tr, changeset *cs, rfdfunc rf )
{
	if (cs->dset){
		node *n;
		for (n = cs->dset->h; n; n = n->next){
			sql_base *b = n->data;

			rf(tr, b);
		}
	}
}

static sql_idx *
rollforward_create_idx( sql_trans *tr, sql_idx *i )
{
	char bname[BUFSIZ];

	if (i->bat.bid && i->bat.ubid){
		BAT *b = bm_lbid2bat( tr->bm, i->bat.bid);
		BAT *u = bm_lbid2bat( tr->bm, i->bat.ubid);
	
		snprintf(bname, BUFSIZ, "%s_%s", i->t->base.name, i->base.name );
		i->bat.bid = log_bat_persists(logger, b, bname); 
		bat_destroy(b);
	
		snprintf(bname, BUFSIZ, "U_%s_%s", i->t->base.name, i->base.name );
		i->bat.ubid = log_bat_persists(logger, u, bname); 
		bat_destroy(u);
	} else {
		sql_kc *c = i->columns->h->data;
		BAT *b = bind_bat(tr->parent, c->c, 0);
		BATkey(BATmirror(b), BOUND2BTRUE);
		bat_destroy(b);
	}
	return i;
}

static sql_column *
rollforward_create_column( sql_trans *tr, sql_column *c )
{
	char bname[BUFSIZ];
	BAT *b = bm_lbid2bat( tr->bm, c->bat.bid);
	BAT *u = bm_lbid2bat( tr->bm, c->bat.ubid);

	snprintf(bname, BUFSIZ, "%s_%s", c->t->base.name, c->base.name );
	c->bat.bid = log_bat_persists(logger, b, bname); 
	bat_destroy(b);

	snprintf(bname, BUFSIZ, "U_%s_%s", c->t->base.name, c->base.name );
	c->bat.ubid = log_bat_persists(logger, u, bname); 
	bat_destroy(u);
	return c;
}

static sql_table *
rollforward_create_table( sql_trans *tr, sql_table *t )
{
	if (t->type != tt_view){
		char name[BUFSIZ];

		BAT *d = bm_lbid2bat(tr->bm, t->dbid);

		snprintf(name, BUFSIZ, "D_%s", t->base.name );
		t->dbid = log_bat_persists(logger, d, name); 
		bat_destroy(d);

		rollforward_changeset_creates( tr, &t->columns, 
			(rfcfunc)&rollforward_create_column );
		rollforward_changeset_creates( tr, &t->idxs, 
			(rfcfunc)&rollforward_create_idx );
	}
	return t;
}

static void
rollforward_drop_column( sql_trans *tr, sql_column *c )
{
	(void)tr; /* unused! */
	if (c->bat.bid && c->bat.ubid){
		log_bat_transient(logger, c->bat.bid); 
		log_bat_transient(logger, c->bat.ubid); 
	}
}

static void
rollforward_drop_idx( sql_trans *tr, sql_idx *i )
{
	(void)tr; /* unused! */
	if (i->bat.bid && i->bat.ubid){
		log_bat_transient(logger, i->bat.bid); 
		log_bat_transient(logger, i->bat.ubid); 
	}
	list_remove_data( i->t->s->idxs, i); 
}

static void
rollforward_drop_key( sql_trans *tr, sql_key *k )
{
	(void) tr; /* unused! */
	list_remove_data( k->t->s->keys, k); 
}

static void 
rollforward_drop_table( sql_trans *tr, sql_table *t )
{
	if (t->type != tt_view){
		log_bat_transient(logger, t->dbid); 
	} 

	rollforward_changeset_deletes( tr, &t->columns, 
			(rfdfunc)&rollforward_drop_column);
	rollforward_changeset_deletes( tr, &t->idxs, 
			(rfdfunc)&rollforward_drop_idx);
	rollforward_changeset_deletes( tr, &t->keys, 
			(rfdfunc)&rollforward_drop_key);
}

static void 
rollforward_drop_schema( sql_trans *tr, sql_schema *s )
{
	rollforward_changeset_deletes( tr, &s->tables, 
			(rfdfunc)&rollforward_drop_table);
}

static sql_schema *
rollforward_create_schema( sql_trans *tr, sql_schema *s )
{
	rollforward_changeset_creates( tr, &s->tables, 
		(rfcfunc)&rollforward_create_table );
	return s;
}

static void
rollforward_update_table( sql_trans *tr, sql_table *ft, sql_table *tt)
{
	sql_trans *ttr = tr->parent;
	node *n, *m;

	/* cannot update views */
	if (ft->type == tt_view)
		return;

	assert(cs_size( &tt->columns) == cs_size( &ft->columns));

	n = ft->columns.set->h;
	m = tt->columns.set->h;
	if (n && m) {
		BAT *db = bm_lbid2bat( tr->bm, tt->dbid );

                tt->base.rtime = tt->base.rtime;
                tt->base.wtime = tt->base.wtime;

		do { 
			sql_column *cc = n->data;
			sql_column *oc = m->data;

			BAT *ins = bm_lbid2bat( tr->bm, cc->bat.bid);
			BAT *ups = bm_lbid2bat( tr->bm, cc->bat.ubid);
			BAT *gob = bind_bat(ttr, oc, 1);

                	oc->base.rtime = cc->base.rtime;
                	oc->base.wtime = cc->base.wtime;

			/* forward inserts */
			if (ins->batInserted < BUNlast(ins)) {
				void_insert_delta(gob, ins);
				log_bat(logger, oc->bat.bid, gob);
			}
			bat_destroy(ins);

			if (ups->batInserted < BUNlast(ups)) {
				BAT *oub = bind_ubat(ttr, oc, 1);
				insert_delta(oub, ups);
				void_replace_delta(gob, ups);
				log_bat(logger, oc->bat.ubid, oub);
				bat_destroy(oub);
			}
			bat_destroy(ups);

			if (db->batInserted < BUNlast(db)) {
				void_delete_bat(gob, db, 1);
			}

			bat_destroy(gob);

			n = n->next;
			m = m->next;
		} while (n && m);

		if (tt->idxs.set){
			for(n = tt->idxs.set->h, m = tt->idxs.set->h; n && m; 
				n = n->next, m = m->next){
			    sql_idx *ci = n->data;
			    sql_idx *oi = m->data;

			    if (ci->bat.bid && ci->bat.ubid){
				BAT *ins = bm_lbid2bat( tr->bm, ci->bat.bid);
				BAT *ups = bm_lbid2bat( tr->bm, ci->bat.ubid);
				BAT *gib = bind_idx(ttr, oi, 1);

                		oi->base.rtime = ci->base.rtime;
                		oi->base.wtime = ci->base.wtime;

				/* forward inserts */
				if (ins->batInserted < BUNlast(ins)) {
					void_insert_delta(gib, ins);
					log_bat(logger, oi->bat.bid, gib);
				}
				bat_destroy(ins);

				if (ups->batInserted < BUNlast(ups)) {
					BAT *oub = bind_uidx(ttr, oi, 1);
					insert_delta(oub, ups);
					void_replace_delta(gib, ups);
					log_bat(logger, oi->bat.ubid, oub);
					bat_destroy(oub);
				}
				bat_destroy(ups);

				if (db->batInserted < BUNlast(db)) {
					void_delete_bat(gib, db, 1);
				}
				bat_destroy(gib);
			    }
			}
		}
		if (db->batInserted < BUNlast(db)) {
			BAT *odb = bind_dbat(ttr, tt, 1);
			void_insert_delta(odb, db);
			log_bat(logger, tt->dbid, odb);
			bat_destroy(odb);
		}
		bat_destroy(db);
	}
	rollforward_changeset_updates( tr, &ft->columns, &tt->columns, 
		&tt->base,
		(rfufunc)NULL, 
		(rfcfunc)&rollforward_create_column,
		(rfcfunc)&rollforward_drop_column,
		(dupfunc)&column_dup );
	rollforward_changeset_updates( tr, &ft->idxs, &tt->idxs, &tt->base,
		(rfufunc)NULL, 
		(rfcfunc)&rollforward_create_idx,
		(rfcfunc)&rollforward_drop_idx,
		(dupfunc)&idx_dup );
	rollforward_changeset_updates( tr, &ft->keys, &tt->keys, &tt->base,
		(rfufunc)NULL, 
		(rfcfunc)NULL,
		(rfcfunc)&rollforward_drop_key,
		(dupfunc)&key_dup );
}

static void
rollforward_update_schema( sql_trans *tr, sql_schema *fs, sql_schema *ts)
{
	rollforward_changeset_updates( tr, &fs->tables, &ts->tables, &ts->base,
		(rfufunc)&rollforward_update_table, 
		(rfcfunc)&rollforward_create_table,
		(rfdfunc)&rollforward_drop_table,
		(dupfunc)&table_dup );
}

static void 
rollforward_trans(sql_trans *tr)
{
	rollforward_changeset_updates(tr, &tr->schemas, &tr->parent->schemas, 
		NULL,
		(rfufunc)&rollforward_update_schema, 
		(rfcfunc)&rollforward_create_schema, 
		(rfcfunc)&rollforward_drop_schema, 
		(dupfunc)&schema_dup);
}

static int validate_tables(sql_schema * s, sql_schema * os)
{
	/* bm_validate(tr->bm, tr->parent->bm); */
	node *n, *o, *p;

	if (cs_size( &s->tables)) for (n = s->tables.set->h; n; n = n->next) {
		sql_table *t = n->data;
		sql_table *ot = find_table(os, t->base.name);

		if (ot || (t->base.wtime == 0 && t->base.rtime == 0)) {
			for (o = t->columns.set->h, p = ot->columns.set->h;
			     o && p; o = o->next, p = p->next) {
				sql_column *c = o->data;
				sql_column *oc = p->data;
				/* t wrote, ie. check read and write time */
				/* read or write after t's write */
				if (c->base.wtime &&
				    (c->base.wtime < oc->base.rtime
				     || c->base.wtime < oc->base.wtime)) {
					return 0;
				}
				/* commited write before t's read */
				if (c->base.rtime && 
					c->base.rtime < oc->base.wtime) {
					return 0;
				}
			}
		}
	}
	return 1;
}

static int validate(sql_trans *tr)
{
	node *n;
	/* depends on the iso level */

	/* since we protect usage through private copies both the iso levels
	   read uncommited and read commited always succeed.
	 */
	if (tr->level == ISO_READ_UNCOMMITED
	    || tr->level == ISO_READ_COMMITED)
		return 1;

	/* If only 'inserts' occurred on the read bats the repeatable reads
	   iso level can continue */

	/* the hard case */
	if (cs_size( &tr->schemas )) 
	    for (n = tr->schemas.set->h; n; n = n->next) {
		sql_schema *s = n->data;
		sql_schema *os = find_schema(tr->parent, s->base.name);
		if (os || (s->base.wtime == 0 && s->base.rtime == 0)) {
                        if (!validate_tables(s, os)) return 0;
                }
	}
	return 1;
}

/* 
 * mvc_commit implements the last two phases (out of 3) of 
 * optimistic concurrency control. The first phase, ie. read phase 
 * starts when the transaction is started (aka with any sql statement) 
 * and ends with mvc_commit. The validation phase checks the timestamps 
 * to see if a commit could succeed. Then the write phase makes 
 * the changes global.
 *
 * Commit will first forward the changes to the schema, ie.
 * leaving out the temp tables and adding the new tables directly.
 * 
 * After that the changes to existing tables are forwarded.
 */

int mvc_commit(mvc * m, int chain, char *name)
{
	char *schema = NULL;
	sql_trans *tr = m->trans;
	int level = (chain)?tr->level:ISO_SERIALIZABLE;
	int res = -1;

	assert(tr);
	if (m->debug)
		fprintf(stderr, "mvc_commit\n");

	/* savepoint then simply make a copy of the current transaction */
	if (name && name[0] != '\0'){
		if (m->debug)
			fprintf(stderr, "mvc_savepoint\n");
		schema = _strdup(m->trans->schema->base.name);
		assert(schema);
		m->trans = trans_dup(m->trans, name);
		m->trans->schema = find_schema(m->trans, schema);
		_DELETE(schema);
		m->type = Q_TRANS;
		return 0;
	}

	/* if there is nothing to commit reuse the current transaction */
	if (tr->wtime == 0) {
		if (m->debug)
			fprintf(stderr, "no changes\n");
		tr->stime = timestamp();
		return 0;
	}

	MT_set_lock(mvc_lock, "mvc_commit");

	/* validation phase */
	if (validate(tr)) {
		/* write phase */
		if (m->debug)
			fprintf(stderr, "forwarding changes\n");
		log_tstart(logger);
		rollforward_trans(tr);
		log_tend(logger);
		if (m->debug)
			fprintf(stderr, "done forwarding changes\n");
		res = Q_TRANS;
	}

	MT_unset_lock(mvc_lock, "mvc_commit");

	tr = m->trans;
	assert(tr->schema);
	schema = _strdup(tr->schema->base.name);
	assert(schema);
	while(tr->parent) 
		tr = trans_destroy(tr);

	m->trans = trans_dup(tr,NULL);
	m->trans->level = level;
	m->type = res;
	m->trans->schema = find_schema(m->trans, schema);
	_DELETE(schema);
	return res;
}

int 
mvc_rollback(mvc * m, int chain, char *name)
{
	char *schema = NULL;
	int res = 0;
	int level = (chain)?m->trans->level:ISO_SERIALIZABLE;
	sql_trans *tr = m->trans;

	if (m->debug)
		fprintf(stderr, "mvc_rollback\n");

	schema = _strdup(tr->schema->base.name);
	assert(schema);
	if (name && name[0] != '\0'){
		while(tr->name && strcmp(tr->name,name) != 0)
	       		tr = trans_destroy(tr);
		m->trans = tr; /* restart at savepoint */
	} else {
		while(tr->parent) 
	       		tr = trans_destroy(tr);
		m->trans = trans_dup(tr,NULL);
	}
	m->trans->level = level;
	m->type = Q_TRANS;
	m->trans->schema = find_schema(m->trans, schema);
	_DELETE(schema);
	return res;
}

/* release all savepoints up including the given named savepoint 
 * but keep the current changes.
 * */
int 
mvc_release(mvc * m, char *name)
{
	int res = Q_TRANS;
	sql_trans *tr = m->trans;
	sql_trans *p = tr->parent;

	while(p->name && strcmp(p->name, name) != 0)
	   	p = trans_destroy(p);

	tr->parent = p; 
	m->trans = tr; /* restart at savepoint */
	m->type = res;
	return res;
}

int 
mvc_set_iso_level(mvc * m, int level)
{
	int res = mvc_commit(m,1,NULL);
	m->trans->level = level;
	m->type = res;
	return res;
}

static void clean_table_result(res_table *t)
{
	int i;
	for(i=0; i<t->nr_cols; i++){
		res_col *c = t->cols+i;
		if (c->b){
			BBPdecref(c->b, TRUE);
		} else {
			_DELETE(c->p);
		}
		_DELETE(c->name);
		sql_subtype_destroy(c->type);
	}
	if (t->order)
		BBPdecref(t->order, TRUE);
	_DELETE(t->cols);
	_DELETE(t);
}

void mvc_clean_result( mvc *m, res_table *t)
{
	res_table *r = m->results;
	if (r == t){
		m->results = t->next;
	} else {
		for( ; r; r = r->next){
			if (r->next == t){
				r->next = t->next;
				break;
			}
		}
	}
	clean_table_result(t);
}

void 
mvc_destroy(mvc * m)
{
	sql_trans *tr;

	if (m->results){
		res_table *r = m->results, *t;
		for(t=r; t; t=r){ 
			r = t->next;
			clean_table_result(t);
		}
	}

	tr = m->trans;
	while(tr->parent) tr = trans_destroy(tr);
	if (m->user) _DELETE(m->user);
	if (m->role) _DELETE(m->role);
	_DELETE(m);
}

BAT *
mvc_bind(mvc * m, char *sname, char *tname, char *cname, int access)
{
	sql_trans *tr = m->trans;
	BAT *b = NULL;
	sql_schema *s = find_schema(tr, sname);
	sql_table *t = find_table(s, tname);
	sql_column *c;

	if (m->debug)
		fprintf(stderr, "mvc_bind %s.%s(%d)\n", tname, cname, access);

	/* TODO check for access */

	assert(t);

	c = find_column(t, cname);
	b = bind_bat(tr, c, access);

	c->base.rtime = t->base.rtime = s->base.rtime = tr->rtime = tr->stime;
	assert(b->htype == TYPE_void && b->hseqbase == 0);
	return b;
}

BAT *
mvc_bind_ubat(mvc * m, char *sname, char *tname, char *cname, int access )
{
	sql_trans *tr = m->trans;
	BAT *b = NULL;
	sql_schema *s = find_schema(tr, sname);
	sql_table *t = find_table(s, tname);
	sql_column *c;

	if (m->debug)
		fprintf(stderr, "mvc_bind_ubat %s.%s\n", tname, cname);

	/* TODO check for access */

	assert(t);

	c = find_column(t, cname);
	b = bind_ubat(tr, c, access);

	c->base.rtime = t->base.rtime = tr->rtime = tr->stime;
	return b;
}

BAT *
mvc_bind_dbat(mvc * m, char *sname, char *tname, int access )
{
	sql_trans *tr = m->trans;
	BAT *b = NULL;
	sql_schema *s = find_schema(tr, sname);
	sql_table *t = find_table(s, tname);

	if (m->debug)
		fprintf(stderr, "mvc_bind_dbat %s.deletes\n", tname );

	/* TODO check for access */

	assert(t);
	b = bind_dbat(tr, t, access);

	t->base.rtime = tr->rtime = tr->stime;
	assert(b->htype == TYPE_void && b->hseqbase == 0);
	return b;
}

BAT *
mvc_bind_ibat(mvc * m, char *sname, char *tname, char *iname, int access )
{
	sql_trans *tr = m->trans;
	BAT *b = NULL;
	sql_schema *s = find_schema(tr, sname);
	sql_table *t = find_table(s, tname);
	sql_idx *i = find_idx(t, iname);

	if (m->debug)
		fprintf(stderr, "mvc_bind_ibat %s.%s\n", tname, iname );

	/* TODO check for access */

	assert(t);
	b = bind_idx(tr, i, access);

	i->base.rtime = t->base.rtime = tr->rtime = tr->stime;
	assert(b->htype == TYPE_void && b->hseqbase == 0);
	return b;
}


sql_schema *
mvc_bind_schema(mvc * m, char *sname )
{
	sql_trans *tr = m->trans;
	sql_schema *s = find_schema(tr, sname);
	if (!s)
		return NULL;
	s->base.rtime = tr->rtime;

	if (m->debug)
		fprintf(stderr, "mvc_bind_schema %s\n", sname );

	return s;
}

sql_table *
mvc_bind_table(mvc * m, sql_schema *s, char *tname )
{
	sql_table *t = find_table(s, tname);
	if (!t)
		return NULL;
	t->base.rtime = s->base.rtime;

	if (m->debug)
		fprintf(stderr, "mvc_bind_table %s.%s\n", s->base.name, tname );

	return t;
}

sql_column *
mvc_bind_column(mvc * m, sql_table * t, char *cname )
{
	sql_column *c = find_column(t, cname);
	if (!c)
		return NULL;
	c->base.rtime = t->base.rtime;

	if (m->debug)
		fprintf(stderr, "mvc_bind_column %s.%s\n", t->base.name, cname);

	return c;
}

sql_key *
mvc_bind_key(mvc * m, sql_schema * s, char *kname )
{
	node *n = list_find_name(s->keys, kname);
	sql_key *k;
	if (!n)
		return NULL;
	k = n->data;
	k->base.rtime = k->t->base.rtime = s->base.rtime;

	if (m->debug)
		fprintf(stderr, "mvc_bind_key %s.%s\n", s->base.name, kname );

	return k;
}

sql_idx *
mvc_bind_idx(mvc * m, sql_schema * s, char *iname )
{
	node *n = list_find_name(s->idxs, iname);
	sql_idx *i;
	if (!n)
		return NULL;
	i = n->data;
	i->base.rtime = i->t->base.rtime = s->base.rtime;

	if (m->debug)
		fprintf(stderr, "mvc_bind_idx %s.%s\n", s->base.name, iname );

	return i;
}

int uniqueKey(sql_key *k){
	return (k->type == pkey || k->type == ukey);
}

sql_key *mvc_bind_ukey( sql_table *t, list *colnames )
{
	node *cn;
	node *cur;
	sql_key * res = NULL;
	int len = list_length(colnames);

	if ( cs_size( &t->keys)) 
	    for ( cur = t->keys.set->h; cur; cur = cur -> next ){ 
		node *cc;
		sql_key *k = cur->data;
		if (uniqueKey(k) && list_length(k->columns) == len){
			res = k;
		   	for ( cc = k->columns->h, cn = colnames->h; 
				cc && cn; cc = cc -> next, cn = cn -> next ){
				sql_kc *c = cc->data;
				char *n = cn->data;
				if (strcmp(c->c->base.name, n) != 0){
					res = NULL;
					break;
				}
			}
			if (res) 
				break;
		}
	}
	return res;
}

static void sys_drop_kc(sql_trans *tr, sql_key *k, sql_kc *kc ){
	sql_table *syskc = find_table(find_schema(tr, "sys"), "keycolumns");
	BAT *b, *r;
	oid rid = 0;
	(void) kc; /* Stefan: unused!? */

	/* drop from sys keys */
	b = bind_bat(tr, find_column(syskc, "id"), 1);
	r = BATmirror(b);
	rid = *(oid*)BUNtail(r, BUNfnd(r, (ptr) & k->base.id ));
	bun_inplace(b, rid, ATOMnilptr(b->ttype)); BBPunfix(b->batCacheid);
	b = bind_bat(tr, find_column(syskc, "column"), 1);
	bun_inplace(b, rid, ATOMnilptr(b->ttype)); BBPunfix(b->batCacheid);
	b = bind_bat(tr, find_column(syskc, "trunc"), 1);
	bun_inplace(b, rid, ATOMnilptr(b->ttype)); BBPunfix(b->batCacheid);
	b = bind_bat(tr, find_column(syskc, "nr"), 1);
	bun_inplace(b, rid, ATOMnilptr(b->ttype)); BBPunfix(b->batCacheid);
	b = bind_dbat(tr, syskc, 1);
	BUNins(b, ATOMnilptr(TYPE_void), (ptr) & rid); BBPunfix(b->batCacheid);

	syskc->base.wtime = tr->wtime = tr->stime;
}

static void 
sys_drop_key(sql_trans *tr, sql_key *k ){
	node *n;
	sql_table *syskey = find_table(find_schema(tr, "sys"), "keys");
	BAT *b, *r;
	oid rid = 0;

	/* drop from sys keys */
	b = bind_bat(tr, find_column(syskey, "id"), 1);
	r = BATmirror(b);
	rid = *(oid*)BUNtail(r, BUNfnd(r, (ptr) & k->base.id ));
	bun_inplace(b, rid, ATOMnilptr(b->ttype)); BBPunfix(b->batCacheid);
	b = bind_bat(tr, find_column(syskey, "table_id"), 1);
	bun_inplace(b, rid, ATOMnilptr(b->ttype)); BBPunfix(b->batCacheid);
	b = bind_bat(tr, find_column(syskey, "name"), 1);
	bun_inplace(b, rid, ATOMnilptr(b->ttype)); BBPunfix(b->batCacheid);
	b = bind_bat(tr, find_column(syskey, "rkey"), 1);
	bun_inplace(b, rid, ATOMnilptr(b->ttype)); BBPunfix(b->batCacheid);
	b = bind_dbat(tr, syskey, 1);
	BUNins(b, ATOMnilptr(TYPE_void), (ptr) & rid); BBPunfix(b->batCacheid);

	for (n = k->columns->h; n; n = n->next) {
		sql_kc *kc = n->data;
		sys_drop_kc(tr, k, kc);
	}
	syskey->base.wtime = tr->wtime = tr->stime;
}

static void 
sys_drop_ic(sql_trans *tr, sql_idx *i, sql_kc *kc ){
	sql_table *syskc = find_table(find_schema(tr, "sys"), "keycolumns");
	BAT *b, *r;
	oid rid = 0;
	(void) kc; /* Stefan: unused!? */

	/* drop from sys keys */
	b = bind_bat(tr, find_column(syskc, "id"), 1);
	r = BATmirror(b);
	rid = *(oid*)BUNtail(r, BUNfnd(r, (ptr) & i->base.id ));
	bun_inplace(b, rid, ATOMnilptr(b->ttype)); BBPunfix(b->batCacheid);
	b = bind_bat(tr, find_column(syskc, "column"), 1);
	bun_inplace(b, rid, ATOMnilptr(b->ttype)); BBPunfix(b->batCacheid);
	b = bind_bat(tr, find_column(syskc, "trunc"), 1);
	bun_inplace(b, rid, ATOMnilptr(b->ttype)); BBPunfix(b->batCacheid);
	b = bind_bat(tr, find_column(syskc, "nr"), 1);
	bun_inplace(b, rid, ATOMnilptr(b->ttype)); BBPunfix(b->batCacheid);
	b = bind_dbat(tr, syskc, 1);
	BUNins(b, ATOMnilptr(TYPE_void), (ptr) & rid); BBPunfix(b->batCacheid);

	syskc->base.wtime = tr->wtime = tr->stime;
}

static void 
sys_drop_idx(sql_trans *tr, sql_idx *i ){
	node *n;
	sql_table *sysidx = find_table(find_schema(tr, "sys"), "idxs");
	BAT *b, *r;
	oid rid = 0;

	/* drop from sys idxs */
	b = bind_bat(tr, find_column(sysidx, "id"), 1);
	r = BATmirror(b);
	rid = *(oid*)BUNtail(r, BUNfnd(r, (ptr) & i->base.id ));
	bun_inplace(b, rid, ATOMnilptr(b->ttype)); BBPunfix(b->batCacheid);
	b = bind_bat(tr, find_column(sysidx, "table_id"), 1);
	bun_inplace(b, rid, ATOMnilptr(b->ttype)); BBPunfix(b->batCacheid);
	b = bind_bat(tr, find_column(sysidx, "name"), 1);
	bun_inplace(b, rid, ATOMnilptr(b->ttype)); BBPunfix(b->batCacheid);
	b = bind_dbat(tr, sysidx, 1);
	BUNins(b, ATOMnilptr(TYPE_void), (ptr) & rid); BBPunfix(b->batCacheid);

	for (n = i->columns->h; n; n = n->next) {
		sql_kc *ic = n->data;
		sys_drop_ic(tr, i, ic);
	}
	sysidx->base.wtime = tr->wtime = tr->stime;
}

static void 
sys_drop_column(sql_trans *tr, sql_column *col ){
	sql_table *syscolumn = find_table(find_schema(tr, "sys"), "columns");
	BAT *b, *r;
	oid rid = 0;

	/* drop from sys columns */
	b = bind_bat(tr, find_column(syscolumn, "id"), 1);
	r = BATmirror(b);
	rid = *(oid*)BUNtail(r, BUNfnd(r, (ptr) & col->base.id ));
	bun_inplace(b, rid, ATOMnilptr(b->ttype)); BBPunfix(b->batCacheid);
	b = bind_bat(tr, find_column(syscolumn, "table_id"), 1);
	bun_inplace(b, rid, ATOMnilptr(b->ttype)); BBPunfix(b->batCacheid);
	b = bind_bat(tr, find_column(syscolumn, "name"), 1);
	bun_inplace(b, rid, ATOMnilptr(b->ttype)); BBPunfix(b->batCacheid);
	b = bind_bat(tr, find_column(syscolumn, "type"), 1);
	bun_inplace(b, rid, ATOMnilptr(b->ttype)); BBPunfix(b->batCacheid);
	b = bind_bat(tr, find_column(syscolumn, "type_digits"), 1);
	bun_inplace(b, rid, ATOMnilptr(b->ttype)); BBPunfix(b->batCacheid);
	b = bind_bat(tr, find_column(syscolumn, "type_scale"), 1);
	bun_inplace(b, rid, ATOMnilptr(b->ttype)); BBPunfix(b->batCacheid);
	b = bind_bat(tr, find_column(syscolumn, "default"), 1);
	bun_inplace(b, rid, ATOMnilptr(b->ttype)); BBPunfix(b->batCacheid);
	b = bind_bat(tr, find_column(syscolumn, "null"), 1);
	bun_inplace(b, rid, ATOMnilptr(b->ttype)); BBPunfix(b->batCacheid);
	b = bind_bat(tr, find_column(syscolumn, "number"), 1);
	bun_inplace(b, rid, ATOMnilptr(b->ttype)); BBPunfix(b->batCacheid);
	b = bind_dbat(tr, syscolumn, 1);
	BUNins(b, ATOMnilptr(TYPE_void), (ptr) & rid); BBPunfix(b->batCacheid);

	syscolumn->base.wtime = tr->stime;
}

static void sys_drop_keys(sql_trans * tr, sql_table * t)
{
	node *n;

	if (cs_size( &t->keys)) for (n = t->keys.set->h; n; n = n->next) {
		sql_key *k = n->data;
		sys_drop_key(tr, k);
	}
}

static void sys_drop_idxs(sql_trans * tr, sql_table * t)
{
	node *n;

	if (cs_size( &t->idxs)) for (n = t->idxs.set->h; n; n = n->next) {
		sql_idx *k = n->data;
		sys_drop_idx(tr, k);
	}
}

static void sys_drop_columns(sql_trans * tr, sql_table * t)
{
	node *n;

	if (cs_size( &t->columns)) for (n = t->columns.set->h; n; n = n->next) {
		sql_column *c = n->data;
		sys_drop_column(tr, c);
	}
}

static void sys_drop_table(sql_trans * tr, sql_table *t)
{
	sql_table *systable = find_table(find_schema(tr, "sys"), "tables");
	BAT *b, *r;
	oid rid = 0;

	/* drop from sys tables */
	b = bind_bat(tr, find_column(systable, "id"), 1);
	r = BATmirror(b);
	rid = *(oid*)BUNtail(r, BUNfnd(r, (ptr) & t->base.id ));
	bun_inplace(b, rid, ATOMnilptr(b->ttype)); BBPunfix(b->batCacheid);
	b = bind_bat(tr, find_column(systable, "schema_id"), 1);
	bun_inplace(b, rid, ATOMnilptr(b->ttype)); BBPunfix(b->batCacheid);
	b = bind_bat(tr, find_column(systable, "name"), 1);
	bun_inplace(b, rid, ATOMnilptr(b->ttype)); BBPunfix(b->batCacheid);
	b = bind_bat(tr, find_column(systable, "type"), 1);
	bun_inplace(b, rid, ATOMnilptr(b->ttype)); BBPunfix(b->batCacheid);
	b = bind_bat(tr, find_column(systable, "query"), 1);
	bun_inplace(b, rid, ATOMnilptr(b->ttype)); BBPunfix(b->batCacheid);
	b = bind_dbat(tr, systable, 1);
	BUNins(b, ATOMnilptr(TYPE_void), (ptr) & rid); BBPunfix(b->batCacheid);

	sys_drop_keys(tr, t);
	sys_drop_idxs(tr, t);
	if (t->type != tt_view)
		sys_drop_columns(tr, t);

	systable->base.wtime = tr->stime;
}

static void sys_drop_tables(sql_trans * tr, sql_schema * s)
{
	node *n;

	if (cs_size(&s->tables)) for (n = s->tables.set->h; n; n = n->next) {
		sql_table *t = n->data;

		sys_drop_table(tr, t);
	}
}


sql_schema *bootstrap_create_schema(mvc * m, char *name, char *auth)
{
	sql_trans *tr = m->trans;
	sql_schema *s = NEW(sql_schema);
	
	BAT *b;
	oid rid;

	if (m->debug)
		fprintf(stderr, "bootstrap_create_schema %s %s\n", name, auth);

	base_init( &s->base, OIDnew(1), TR_NEW, name);
	s->auth = _strdup(auth);
	cs_init( &s->tables, (fdestroy)&table_destroy);
	s->keys = list_create((fdestroy)NULL);
	s->idxs = list_create((fdestroy)NULL);

	cs_add( &tr->schemas, s, TR_NEW);

	b = sys_bat(m->trans->bm, "schemas_id");
	rid = BATcount(b);
	BUNins(b, (ptr) & rid, (ptr) & s->base.id); BBPunfix(b->batCacheid);
	b = sys_bat(m->trans->bm, "schemas_name");
	BUNins(b, (ptr) & rid, (ptr) s->base.name); BBPunfix(b->batCacheid);
	b = sys_bat(m->trans->bm, "schemas_authorization");
	BUNins(b, (ptr) & rid, (ptr) s->auth); BBPunfix(b->batCacheid);

	s->base.wtime = tr->wtime = tr->stime;
	return s;
}

sql_schema *mvc_create_schema(mvc * m, char *name, char *auth)
{
	sql_trans *tr = m->trans;
	sql_schema *s = NEW(sql_schema);

	sql_table *sysschema = find_table(find_schema(tr, "sys"), "schemas");
	BAT *b;
	oid rid = 0;

	if (m->debug)
		fprintf(stderr, "mvc_create_schema %s %s\n", name, auth);

	base_init( &s->base, OIDnew(1), TR_NEW, name);
	s->auth = _strdup(auth);
	cs_init( &s->tables, (fdestroy)&table_destroy);
	s->keys = list_create((fdestroy)NULL);
	s->idxs = list_create((fdestroy)NULL);


	cs_add( &tr->schemas, s, TR_NEW);

	b = bind_bat(tr, find_column(sysschema, "id"), 1);
	rid = BATcount(b);
	BUNins(b, (ptr) & rid, (ptr) & s->base.id); BBPunfix(b->batCacheid);
	b = bind_bat(tr, find_column(sysschema, "name"), 1);
	BUNins(b, (ptr) & rid, (ptr) s->base.name); BBPunfix(b->batCacheid);
	b = bind_bat(tr, find_column(sysschema, "authorization"), 1);
	BUNins(b, (ptr) & rid, (ptr) s->auth); BBPunfix(b->batCacheid);

	sysschema->base.wtime = s->base.wtime = tr->wtime = tr->stime;
	m->type = Q_SCHEMA;
	return s;
}

void mvc_drop_schema(mvc * m, char *sname)
{
	sql_trans *tr = m->trans;
	node *n = find_schema_node(tr, sname);
	sql_schema *s = n->data; 

	sql_table *sysschema = find_table(find_schema(tr, "sys"), "schemas");
	BAT *b;
	oid rid = 0;

	if (m->debug)
		fprintf(stderr, "mvc_drop_schema %s\n", sname);

	/* drop from sys schema */
	b = bind_bat(tr, find_column(sysschema, "id"), 1);
	rid = *(oid*)BUNhead(b, BUNfnd(BATmirror(b), (ptr) & s->base.id ));
	bun_inplace(b, rid, ATOMnilptr(b->ttype)); BBPunfix(b->batCacheid);
	b = bind_bat(tr, find_column(sysschema, "name"), 1);
	bun_inplace(b, rid, ATOMnilptr(b->ttype)); BBPunfix(b->batCacheid);
	b = bind_bat(tr, find_column(sysschema, "authorization"), 1);
	bun_inplace(b, rid, ATOMnilptr(b->ttype)); BBPunfix(b->batCacheid);
	b = bind_dbat(tr, sysschema, 1);
	BUNins(b, ATOMnilptr(TYPE_void), (ptr) & rid); BBPunfix(b->batCacheid);
	sys_drop_tables(tr, s);

	s->base.wtime = sysschema->base.wtime = tr->wtime = tr->stime;
	cs_del( &tr->schemas, n, s->base.flag);
}

static sql_table *create_table_intern( mvc *m, char *name, table_type type)
{
	sql_table *t = NEW(sql_table);
	(void) m; /* Stefan: unused!? */

	base_init( &t->base, OIDnew(1), TR_NEW, name);
	t->type = type;
	t->query = NULL;
	cs_init( &t->columns, (fdestroy)&column_destroy);
	cs_init( &t->idxs, (fdestroy)&idx_destroy);
	cs_init( &t->keys, (fdestroy)&key_destroy);
	t->pkey = NULL;
	t->dbid = 0;
	t->st = NULL;
	return t;
}

sql_key *
mvc_create_key( mvc * m, sql_table *t, char *name, key_type kt, sql_key *rkey )
{ 
/* can only have keys between persistent tables */
	int neg = -1;
	sql_trans *tr = m->trans;
	sql_key *nk;
	sql_table *syskey = find_table(find_schema(tr, "sys"), "keys");
	BAT *b;
	oid rid = 0;

	if (m->debug)
		fprintf(stderr, "mvc_create_key %s %d %ld\n",
		 t->base.name, kt, (long)rkey);

	if (t->type == tt_temp && t->type == tt_session)
		return NULL;

 	nk = (kt!=fkey)?(sql_key*)NEW(sql_ukey)
				:(sql_key*)NEW(sql_fkey);
	assert(name);
	base_init( &nk->base, OIDnew(1), TR_NEW, name);
	nk->type = kt;
	nk->columns = list_create((fdestroy)&kc_destroy);
	nk->t = t;
	nk->idx = mvc_create_idx(m, t, name, (nk->type==fkey)?join_idx:unique);
	nk->idx -> key = nk;

	if (nk->type != fkey){
		sql_ukey *uk = (sql_ukey*)nk;
		uk -> keys = NULL;

		if (nk->type == pkey)
			t->pkey = uk;
	} else if (nk->type == fkey) {
		sql_fkey *fk = (sql_fkey*)nk;
		sql_ukey *uk = (sql_ukey*)rkey;
		fk -> rkey = uk;
		if (!uk->keys) uk->keys = list_create(NULL);
		list_append(uk->keys, fk);
	}

	cs_add( &t->keys, nk, TR_NEW );
	list_append( t->s->keys, nk);

	b = bind_bat(tr, find_column(syskey, "id"), 1);
	rid = BATcount(b);
	BUNins(b, (ptr) & rid, (ptr) & nk->base.id); bat_destroy(b);
	b = bind_bat(tr, find_column(syskey, "table_id"), 1);
	BUNins(b, (ptr) & rid, (ptr) & t->base.id); bat_destroy(b);
	b = bind_bat(tr, find_column(syskey, "name"), 1);
	BUNins(b, (ptr) & rid, (ptr) nk->base.name); bat_destroy(b);
	b = bind_bat(tr, find_column(syskey, "type"), 1);
	BUNins(b, (ptr) & rid, (ptr) & nk->type); bat_destroy(b);
	b = bind_bat(tr, find_column(syskey, "rkey"), 1);
	if (nk->type == fkey)
		BUNins(b, (ptr) & rid, (ptr) & 
				((sql_fkey*)nk)->rkey->k.base.id); 
	else
		BUNins(b, (ptr) & rid, (ptr) & neg); 
	bat_destroy(b);

	syskey->base.wtime = tr->wtime = tr->stime;
	m->type = Q_SCHEMA;
	return nk;
}

sql_key *mvc_create_kc( mvc *m, sql_key *k, sql_column *c /*, extra options such as trunc*/ )
{
	sql_trans *tr = m->trans;
	sql_kc *kc = NEW(sql_kc);
	int nr = list_length(k->columns);
	sql_table *syskc = find_table(find_schema(tr, "sys"), "keycolumns");
	BAT *b;
	oid rid = 0;

	assert(c);
	kc->c = c;
	kc->trunc = 0;
	list_append(k->columns, kc);
	if (k->idx) mvc_create_ic( m, k->idx, c);

	b = bind_bat(tr, find_column(syskc, "id"), 1);
	rid = BATcount(b);
	BUNins(b, (ptr) & rid, (ptr) & k->base.id); bat_destroy(b);
	b = bind_bat(tr, find_column(syskc, "column"), 1);
	BUNins(b, (ptr) & rid, (ptr) kc->c->base.name); bat_destroy(b);
	b = bind_bat(tr, find_column(syskc, "trunc"), 1);
	BUNins(b, (ptr) & rid, (ptr) & kc->trunc); bat_destroy(b);
	b = bind_bat(tr, find_column(syskc, "nr"), 1);
	BUNins(b, (ptr) & rid, (ptr) & nr); bat_destroy(b);

	syskc->base.wtime = tr->wtime = tr->stime;
	m->type = Q_SCHEMA;
	return k;
}


void mvc_drop_key(mvc * m, sql_schema *s, char *name)
{
	sql_trans *tr = m->trans;
	node *n = list_find_name(s->keys, name);
	sql_key *k = n->data;

	if (m->debug)
		fprintf(stderr, "mvc_drop_key %s %s\n", k->t->base.name, name);

	if (k->t->type != tt_temp && k->t->type != tt_session)
		sys_drop_key(tr, k);

	k->base.wtime = k->t->base.wtime = tr->wtime = tr->stime;
	cs_del( &k->t->keys, n, k->base.flag);
	list_remove_data( k->t->s->keys, k);
}

sql_idx *
mvc_create_idx( mvc * m, sql_table *t, char *name, idx_type it )
{ 
/* can only have idxs between persistent tables */
	sql_trans *tr = m->trans;
	sql_idx *ni = NEW(sql_idx);
	sql_table *sysidx = find_table(find_schema(tr, "sys"), "idxs");
	BAT *b;
	oid rid = 0;

	if (m->debug)
		fprintf(stderr, "mvc_create_idx %s %d\n", t->base.name, it);

	if (t->type == tt_temp && t->type == tt_session)
		return NULL;

	assert(name);
	base_init( &ni->base, OIDnew(1), TR_NEW, name);
	ni->type = it;
	ni->columns = list_create((fdestroy)&kc_destroy);
	ni->t = t;
	ni->key = NULL;

	ni->bat.bid = ni->bat.ubid = 0;

	cs_add( &t->idxs, ni, TR_NEW );
	list_append( t->s->idxs, ni);

	/* create void,int bat to keep the hash values */
	if (it == join_idx){
		BAT *u;
		int cnt = BUFSIZ; 
		char bname[BUFSIZ];

		b = BATnew( TYPE_void, TYPE_oid, cnt );
		BATseqbase(b,0);
		snprintf(bname, BUFSIZ, "%s_%s", ni->t->base.name, ni->base.name );
		ni->bat.bid = bm_add_bat(tr->bm, b->batCacheid, bname, 0);
		bat_destroy(b);

		u = BATnew( TYPE_oid, TYPE_oid, cnt );
		snprintf(bname, BUFSIZ, "U_%s_%s", ni->t->base.name, ni->base.name );
		ni->bat.ubid = bm_add_bat(tr->bm, u->batCacheid, bname, 0);
		bat_destroy(u);
	}

	b = bind_bat(tr, find_column(sysidx, "id"), 1);
	rid = BATcount(b);
	BUNins(b, (ptr) & rid, (ptr) & ni->base.id); bat_destroy(b);
	b = bind_bat(tr, find_column(sysidx, "table_id"), 1);
	BUNins(b, (ptr) & rid, (ptr) & t->base.id); bat_destroy(b);
	b = bind_bat(tr, find_column(sysidx, "name"), 1);
	BUNins(b, (ptr) & rid, (ptr) ni->base.name); bat_destroy(b);
	b = bind_bat(tr, find_column(sysidx, "type"), 1);
	BUNins(b, (ptr) & rid, (ptr) & ni->type); bat_destroy(b);

	sysidx->base.wtime = tr->wtime = tr->stime;
	m->type = Q_SCHEMA;
	return ni;
}

sql_idx *mvc_create_ic( mvc *m, sql_idx *i, sql_column *c /*, extra options such as trunc*/ )
{
	sql_trans *tr = m->trans;
	sql_kc *ic = NEW(sql_kc);
	int nr = list_length(i->columns);
	sql_table *sysic = find_table(find_schema(tr, "sys"), "keycolumns");
	BAT *b;
	oid rid = 0;

	assert(c);
	ic->c = c;
	ic->trunc = 0;
	list_append(i->columns, ic);

	if (!i->bat.bid && i->type == unique && list_length(i->columns) > 1){
		BAT *u;
		int cnt = BUFSIZ; 
		char bname[BUFSIZ];

		b = BATnew( TYPE_void, TYPE_int, cnt );
		BATseqbase(b,0);
		snprintf(bname, BUFSIZ, "%s_%s", i->t->base.name, i->base.name );
		i->bat.bid = bm_add_bat(tr->bm, b->batCacheid, bname, 0);
		bat_destroy(b);

		u = BATnew( TYPE_oid, TYPE_int, cnt );
		snprintf(bname, BUFSIZ, "U_%s_%s", i->t->base.name, i->base.name );
		i->bat.ubid = bm_add_bat(tr->bm, u->batCacheid, bname, 0);
		bat_destroy(u);
	}

	b = bind_bat(tr, find_column(sysic, "id"), 1);
	rid = BATcount(b);
	BUNins(b, (ptr) & rid, (ptr) & i->base.id); bat_destroy(b);
	b = bind_bat(tr, find_column(sysic, "column"), 1);
	BUNins(b, (ptr) & rid, (ptr) ic->c->base.name); bat_destroy(b);
	b = bind_bat(tr, find_column(sysic, "trunc"), 1);
	BUNins(b, (ptr) & rid, (ptr) & ic->trunc); bat_destroy(b);
	b = bind_bat(tr, find_column(sysic, "nr"), 1);
	BUNins(b, (ptr) & rid, (ptr) & nr); bat_destroy(b);

	sysic->base.wtime = tr->wtime = tr->stime;
	m->type = Q_SCHEMA;
	return i;
}

void mvc_drop_idx(mvc * m, sql_schema *s, char *name)
{
	sql_trans *tr = m->trans;
	node *n = list_find_name(s->idxs, name);
	sql_idx *i = n->data;

	if (m->debug)
		fprintf(stderr, "mvc_drop_idx %s %s\n", i->t->base.name, name);

	if (i->t->type != tt_temp && i->t->type != tt_session)
		sys_drop_idx(tr, i);

	i->base.wtime = i->t->base.wtime = tr->wtime = tr->stime;
	cs_del( &i->t->idxs, n, i->base.flag);
	list_remove_data( i->t->s->idxs, i);
}

static sql_table *bootstrap_create_table(mvc * m, sql_schema *s, char *name, table_type type)
{
	char bname[BUFSIZ];
	sql_trans *tr = m->trans;
	sql_table *t = create_table_intern(m, name, type);

	BAT *b;
	oid rid;

	t->query = _strdup("");
	t->s = s;
	cs_add( &s->tables, t, TR_NEW);

	snprintf(bname, BUFSIZ, "D_%s", t->base.name );
	t->dbid = bm_find_bat(tr->bm, bname);
	assert(t->dbid);

	b = sys_bat(m->trans->bm, "tables_id");
	rid = BATcount(b);
	BUNins(b, (ptr) & rid, (ptr) & t->base.id); BBPunfix(b->batCacheid);
	b = sys_bat(m->trans->bm, "tables_schema_id");
	BUNins(b, (ptr) & rid, (ptr) & s->base.id); BBPunfix(b->batCacheid);
	b = sys_bat(m->trans->bm, "tables_name");
	BUNins(b, (ptr) & rid, (ptr) t->base.name); BBPunfix(b->batCacheid);
	b = sys_bat(m->trans->bm, "tables_type");
	BUNins(b, (ptr) & rid, (ptr) & t->type); BBPunfix(b->batCacheid);
	b = sys_bat(m->trans->bm, "tables_query");
	BUNins(b, (ptr) & rid, (ptr) t->query); BBPunfix(b->batCacheid);

	t->base.wtime = s->base.wtime = tr->wtime = tr->stime;
	return t;
}

sql_table *mvc_create_table(mvc * m, sql_schema *s, char *name, table_type type)
{
	char bname[BUFSIZ];
	sql_trans *tr = m->trans;
	sql_table *t = create_table_intern(m, name, type);
	int cnt = BUFSIZ;
	BAT *b = BATnew( TYPE_void, TYPE_oid, cnt );

	sql_table *systable = find_table(find_schema(tr, "sys"), "tables");
	oid rid = 0;

	BATseqbase(b, 0);

	if (m->debug)
		fprintf(stderr, "mvc_create_table %s %s %d\n", 
		 s->base.name, name, type);

	t->query = _strdup("");
	t->s = s;
	cs_add( &s->tables, t, TR_NEW);

	snprintf(bname, BUFSIZ, "D_%s", t->base.name );
	t->dbid = bm_add_bat(tr->bm, b->batCacheid, bname, 0);
	bat_destroy(b);

	if (t->type != tt_temp && t->type != tt_session){
		b = bind_bat(tr, find_column(systable, "id"), 1);
		rid = BATcount(b);
		BUNins(b, (ptr)&rid, & t->base.id ); BBPunfix(b->batCacheid);
		b = bind_bat(tr, find_column(systable, "schema_id"), 1);
		BUNins(b, (ptr)&rid, & s->base.id ); BBPunfix(b->batCacheid);
		b = bind_bat(tr, find_column(systable, "name"), 1);
		BUNins(b, (ptr)&rid, t->base.name ); BBPunfix(b->batCacheid);
		b = bind_bat(tr, find_column(systable, "type"), 1);
		BUNins(b, (ptr)&rid, & t->type ); BBPunfix(b->batCacheid);
		b = bind_bat(tr, find_column(systable, "query"), 1);
		BUNins(b, (ptr)&rid, t->query ); BBPunfix(b->batCacheid);
		systable->base.wtime = tr->stime;
	}

	t->base.wtime = s->base.wtime = tr->wtime = tr->stime;
	m->type = Q_SCHEMA;
	return t;
}


sql_table *mvc_create_view(mvc * m, sql_schema *s, char *name, char *sql)
{
	sql_trans *tr = m->trans;
	sql_table *t = create_table_intern(m, name, tt_view);

	sql_table *systable = find_table(find_schema(tr, "sys"), "tables");
	BAT *b;
	oid rid = 0;

	if (m->debug)
		fprintf(stderr, "mvc_create_view %s %s %s\n", 	
			s->base.name, name, sql);

	t->query = _strdup(sql);
	cs_add( &s->tables, t, TR_NEW);

	b = bind_bat(tr, find_column(systable, "id"), 1);
	rid = BATcount(b);
	BUNins(b, (ptr)&rid, & t->base.id ); BBPunfix(b->batCacheid);
	b = bind_bat(tr, find_column(systable, "schema_id"), 1);
	BUNins(b, (ptr)&rid, & s->base.id ); BBPunfix(b->batCacheid);
	b = bind_bat(tr, find_column(systable, "name"), 1);
	BUNins(b, (ptr)&rid, t->base.name ); BBPunfix(b->batCacheid);
	b = bind_bat(tr, find_column(systable, "type"), 1);
	BUNins(b, (ptr)&rid, & t->type ); BBPunfix(b->batCacheid);
	b = bind_bat(tr, find_column(systable, "query"), 1);
	BUNins(b, (ptr)&rid, t->query ); BBPunfix(b->batCacheid);

	systable->base.wtime = t->base.wtime = s->base.wtime = 
		tr->wtime = tr->stime;
	m->type = Q_SCHEMA;
	return t;
}

void mvc_drop_table(mvc * m, sql_schema *s, char *name, int cascade)
{
	sql_trans *tr = m->trans;
	node *n = find_table_node(s, name );
	sql_table *t = n->data;
	(void) cascade; /* Stefan: unused!? */

	if (m->debug)
		fprintf(stderr, "mvc_drop_table %s %s\n", s->base.name, name);

	if (t->type != tt_temp && t->type != tt_session)
		sys_drop_table(tr, t);

	t->base.wtime = s->base.wtime = tr->wtime = tr->stime;
	cs_del( &s->tables, n, t->base.flag );

	/* TODO cascade, ie. remove al references to this table */
}

static sql_column *bootstrap_create_column(mvc * m, sql_table *t, char *name,
		       char *sqltype, int type_digits, int type_scale )
{
	char bname[BUFSIZ];
	sql_trans *tr = m->trans;
	sql_column *col = NEW(sql_column);

	BAT *b;
	oid rid;

	base_init( &col->base, OIDnew(1), TR_NEW, name);
	col->type = sql_bind_subtype(sqltype, type_digits, type_scale);
	col->def = _strdup("");
	col->null = 1;
	col->colnr = cs_size( &t->columns);
	col->t = t;
	col->st = NULL;
	cs_add( &t->columns, col, TR_NEW);

	snprintf(bname, BUFSIZ, "%s_%s", col->t->base.name, col->base.name );
	col->bat.bid = bm_find_bat(tr->bm, bname);

	snprintf(bname, BUFSIZ, "U_%s_%s", col->t->base.name, col->base.name );
	col->bat.ubid = bm_find_bat(tr->bm, bname);
	assert(col->bat.bid && col->bat.ubid);

	b = sys_bat(m->trans->bm, "columns_id");
	rid = BATcount(b);
	BUNins(b, (ptr) & rid, (ptr) & col->base.id); BBPunfix(b->batCacheid);
	b = sys_bat(m->trans->bm, "columns_table_id");
	BUNins(b, (ptr) & rid, (ptr) & t->base.id); BBPunfix(b->batCacheid);
	b = sys_bat(m->trans->bm, "columns_name");
	BUNins(b, (ptr) & rid, (ptr) col->base.name); BBPunfix(b->batCacheid);
	b = sys_bat(m->trans->bm, "columns_type");
	BUNins(b, (ptr) & rid, (ptr) col->type->type->sqlname); BBPunfix(b->batCacheid);
	b = sys_bat(m->trans->bm, "columns_type_digits");
	BUNins(b, (ptr) & rid, (ptr) & col->type->digits); BBPunfix(b->batCacheid);
	b = sys_bat(m->trans->bm, "columns_type_scale");
	BUNins(b, (ptr) & rid, (ptr) & col->type->scale); BBPunfix(b->batCacheid);
	b = sys_bat(m->trans->bm, "columns_default");
	BUNins(b, (ptr) & rid, (ptr) col->def); BBPunfix(b->batCacheid);
	b = sys_bat(m->trans->bm, "columns_null");
	BUNins(b, (ptr) & rid, (ptr) & col->null); BBPunfix(b->batCacheid);
	b = sys_bat(m->trans->bm, "columns_number");
	BUNins(b, (ptr) & rid, (ptr) & col->colnr); BBPunfix(b->batCacheid);

	col->base.wtime = t->base.wtime = tr->wtime = tr->stime;

	return col;
}

static sql_column *mvc_create_column_bat(mvc * m, sql_table *t, char *name,
		       char *sqltype, int type_digits, int type_scale, BAT *bb, BAT *u)
{
	char bname[BUFSIZ];
	sql_trans *tr = m->trans;
	sql_column *col = NEW(sql_column);

	sql_table *syscolumn = find_table(find_schema(tr, "sys"), "columns");
	BAT *b;
	oid rid = 0;

	base_init( &col->base, OIDnew(1), TR_NEW, name);
	col->type = sql_bind_subtype(sqltype, type_digits, type_scale);
	col->def = _strdup("");
	col->null = 1;
	col->colnr = cs_size( &t->columns );
	col->t = t;
	col->st = NULL;
	cs_add( &t->columns, col, TR_NEW);

	if (bb){
		snprintf(bname, BUFSIZ, "%s_%s", col->t->base.name, 
			col->base.name );
		col->bat.bid = bm_add_bat(tr->bm, bb->batCacheid, bname, 0);
	}

	if (u){
		snprintf(bname, BUFSIZ, "U_%s_%s", col->t->base.name, 
			col->base.name );
		col->bat.ubid = bm_add_bat(tr->bm, u->batCacheid, bname, 0);
	}

	col->base.wtime = t->base.wtime = tr->wtime = tr->stime;
	if (t->type == tt_temp || t->type == tt_session)
		return col;

	b = bind_bat(tr, find_column(syscolumn, "id"), 1);
	rid = BATcount(b);
	BUNins(b, (ptr) & rid, (ptr) & col->base.id); BBPunfix(b->batCacheid);
	b = bind_bat(tr, find_column(syscolumn, "table_id"), 1);
	BUNins(b, (ptr) & rid, (ptr) & t->base.id); BBPunfix(b->batCacheid);
	b = bind_bat(tr, find_column(syscolumn, "name"), 1);
	BUNins(b, (ptr) & rid, (ptr) col->base.name); BBPunfix(b->batCacheid);
	b = bind_bat(tr, find_column(syscolumn, "type"), 1);
	BUNins(b, (ptr) & rid, (ptr) col->type->type->sqlname); BBPunfix(b->batCacheid);
	b = bind_bat(tr, find_column(syscolumn, "type_digits"), 1);
	BUNins(b, (ptr) & rid, (ptr) & col->type->digits); BBPunfix(b->batCacheid);
	b = bind_bat(tr, find_column(syscolumn, "type_scale"), 1);
	BUNins(b, (ptr) & rid, (ptr) & col->type->scale); BBPunfix(b->batCacheid);
	b = bind_bat(tr, find_column(syscolumn, "default"), 1);
	BUNins(b, (ptr) & rid, (ptr) col->def); BBPunfix(b->batCacheid);
	b = bind_bat(tr, find_column(syscolumn, "null"), 1);
	BUNins(b, (ptr) & rid, (ptr) & col->null); BBPunfix(b->batCacheid);
	b = bind_bat(tr, find_column(syscolumn, "number"), 1);
	BUNins(b, (ptr) & rid, (ptr) & col->colnr); BBPunfix(b->batCacheid);

	syscolumn->base.wtime = tr->stime;
	m->type = Q_SCHEMA;
	return col;
}

sql_column *mvc_create_column(mvc * m, sql_table *t, char *name,
		       char *sqltype, int type_digits, int type_scale)
{

	sql_column *res = NULL;
	sql_subtype *tpe = sql_bind_subtype(sqltype, type_digits, type_scale);

	char *typename;
	int type, cnt = BUFSIZ;
	BAT *u, *b;

	if (!tpe) return NULL;

 	typename = tpe->type->name;
 	type = ATOMindex(typename);

	if (m->debug)
		fprintf(stderr, "mvc_create_column %s %s %s\n", t->base.name,
		       name, sqltype);

	if (t->type != tt_view){ 
		b = BATnew( TYPE_void, type, cnt );
 		u = BATnew( TYPE_oid, type, cnt );

		if (!b || !u){
			if (b) BBPreclaim(b);
			if (u) BBPreclaim(u);
			sql_subtype_destroy(tpe);
			return NULL;
		}

		BATseqbase(b,0);
		res = mvc_create_column_bat(m, t, name, sqltype, type_digits, type_scale, b, u);
		bat_destroy(b);
		bat_destroy(u);
	} else {
		res = mvc_create_column_bat(m, t, name, sqltype, type_digits, type_scale, NULL, NULL);
	}

	sql_subtype_destroy(tpe);

	return res;
}

void mvc_drop_column(mvc * m, sql_table *t, char *name)
{
	sql_trans *tr = m->trans;
	node *n = find_column_node(t, name);
	sql_column *col = n->data;

	if (m->debug)
		fprintf(stderr, "mvc_drop_column %s %s\n", t->base.name, name);

	if (t->type != tt_temp && t->type != tt_session)
		sys_drop_column(tr, col);

	col->base.wtime = t->base.wtime = tr->wtime = tr->stime;
	cs_del( &t->columns, n, col->base.flag);
}

sql_column * mvc_null(mvc * m, sql_column * col, int isnull)
{
	sql_trans *tr = m->trans;

	if (m->debug)
		fprintf(stderr, "mvc_null %s %d\n", col->base.name, isnull);

	if (col->null != isnull){
		sql_table *syscolumn = find_table(find_schema(tr, "sys"), "columns");
		BAT *b, *r;
		oid rid = 0;
	
		/* replace null value in sys columns */
		b = bind_bat(tr, find_column(syscolumn, "id"), 1);
		r = BATmirror(b);
		rid = *(oid*)BUNtail(r, BUNfnd(r, (ptr) & col->base.id ));
		BBPunfix(b->batCacheid);
		b = bind_bat(tr, find_column(syscolumn, "null"), 1);
		bun_inplace(b, rid, &isnull); 
		BBPunfix(b->batCacheid);

		if (col->base.flag != TR_NEW) {
			b = bind_ubat(tr, find_column(syscolumn, "null"), 1);
			BUNins(b, (ptr) & rid, (ptr) & isnull); 
			BBPunfix(b->batCacheid);
		}
		col->null = isnull;
		col->base.wtime = tr->wtime = tr->stime;
	}

	return col;
}

sql_column * mvc_default(mvc * m, sql_column * col, char *val)
{
	sql_trans *tr = m->trans;

	if (m->debug)
		fprintf(stderr, "mvc_default %s %s\n", col->base.name, val);

	if (strcmp(col->def, val) != 0){
		sql_table *syscolumn = find_table(find_schema(tr, "sys"), "columns");
		BAT *b, *r;
		oid rid = 0;
	
		/* replace default value in sys columns */
		b = bind_bat(tr, find_column(syscolumn, "id"), 1);
		r = BATmirror(b);
		rid = *(oid*)BUNtail(r, BUNfnd(r, (ptr) & col->base.id ));
		BBPunfix(b->batCacheid);
		b = bind_bat(tr, find_column(syscolumn, "default"), 1);
		bun_inplace(b, rid, val); 
		BBPunfix(b->batCacheid);

		if (col->base.flag != TR_NEW) {
			b = bind_ubat(tr, find_column(syscolumn, "default"), 1);
			BUNins(b, (ptr) & rid, (ptr) val); 
			BBPunfix(b->batCacheid);
		}
		_DELETE(col->def);
		col->def = _strdup(val);
		col->base.wtime = tr->wtime = tr->stime;
	}
	return col;
}

/* roles can be defineed 
 * on the 'top (aka catalog) layer' and on the schema layer 
sql_role *mvc_create_role( mvc *m, sql_schema *s, char *name, int grantor )
{
	sql_trans *tr = m->trans;
	sql_role *role = NEW(sql_role);

	role -> id = 0;
	role -> name = _strdup(name);
	role -> grantor = grantor;
	role -> flag = TR_NEW;

	if (!s->nrole) s->nrole = role;
	list_append(s->roles, role);

	s->wtime = tr->wtime = tr->stime;
	m->type = Q_SCHEMA;
	return role;
}

sql_role *mvc_drop_role( mvc *m, sql_schema *s, char *name)
{
	sql_trans *tr = m->trans;
	node *n = find_role_node(s, name );
	sql_role *r = n->data;

	if (m->debug)
		fprintf(stderr, "mvc_drop_role %s %s\n", s->base.name, name);

	s->wtime = tr->wtime = tr->stime;
	cs_del( &s->roles, n, r->base.flag );
}
*/

static res_table *mvc_result_table_( mvc *m, int nr_cols )
{
	int res_id = m->result_id++;
	res_table *t = NEW(res_table);
	t->id = res_id;
	t->nr_cols = nr_cols;
	t->cur_col = 0;
	t->cols = NEW_ARRAY(res_col,nr_cols);
	t->order = 0;

	t->next = m->results;
	m->results = t;
	return t;
}

int mvc_result_row( mvc *m, int nr_cols )
{
	res_table *t = mvc_result_table_(m, nr_cols);

	return t->id;
}

int mvc_result_table( mvc *m, int nr_cols, BAT *order )
{
	res_table *t = mvc_result_table_(m, nr_cols);

	t->order = order->batCacheid;
	BBPincref(t->order, TRUE);
	return t->id;
}

static res_col *mvc_result_value_( mvc *m, char *name, char *typename, int digits, int scale ){
	sql_subtype *tpe = sql_bind_subtype(typename, digits, scale);
	res_table *t = m->results;
	res_col *c = t->cols+t->cur_col;

	c->name = _strdup(name);
	c->type = tpe;
	c->b = 0;
	c->p = NULL;
	c->mtype = TYPE_bat;
	t->cur_col++;
	return c;
}

int mvc_result_column( mvc *m, char *name, char *typename, int digits, int scale, BAT *b){
	res_col *c = mvc_result_value_(m, name, typename, digits, scale);

	c->b = b->batCacheid;
	BBPincref(c->b, TRUE);
	return 0;
}

int mvc_result_value( mvc *m, char *name, char *typename, int digits, int scale, ptr *p, int mtype){
	res_col *c = mvc_result_value_(m, name, typename, digits, scale);

	c->mtype = mtype;
	c->p = ATOMdup(mtype,p); 
	return 0;
}

