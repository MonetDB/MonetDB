@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.
@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f sql_schema
@a N.J. Nes
@* 

@h
#ifndef _SQL_SCHEMA_H_
#define _SQL_SCHEMA_H_

#include <stdio.h>
#include <stdarg.h>
#include <sql_list.h>
#include "sql_symbol.h"
#include "sql_statement.h"

sql_export stmt *schemas( mvc * sql, symbol * sym);

#endif /*_SQL_SCHEMA_H_*/

@c

#include "sql_config.h"
#include "sql_schema.h"
#include "sql_parser.h"
#include "sql_scope.h"
#include "sql_updates.h"
#include "sql_select.h"
#include "sql_semantic.h"
#include "sql_privileges.h"


static void list_append_stmt( list *l, stmt *s )
{
	if (s->type == st_none){
		stmt_destroy(s);
	} else {
		list_append(l, s);
	}
}

static stmt *list2stmt( list *l )
{
	if (list_length(l) == 0) {
		list_destroy(l);
		return stmt_none();
	} else {
		return stmt_list(l);
	}
	
}

static stmt *
grant_roles(mvc * sql, sql_schema *schema,
		dlist * roles, dlist * grantees, int grant, int grantor)
{
	/* grant roles to the grantees */
	dnode *r, *g;

	(void) sql; (void) schema; (void) grant; (void) grantor; /* Stefan: unused!? */
	
	for( r = roles->h; r; r = r->next ){
		char *role = r->data.sval;

		/*
		role_id = relproject(relselect(auths, role),id);
		exception(count(role_id) == 0), "Role %s not found !", role;
		*/
		for( g = grantees->h; g; g = g->next ){
			char *grantee = g->data.sval;

			/* 
			   grantee_id = relproject(relselect(auths,grantee),id);
			   exception (count(grantee_id) == 0), "User/role %s not found !", grantee;
			   r = relselect(role_user,role_id,grantee_id)
			   exception(count(r) > 0), "Role (%s,%s) already granted", role, grantee;
			   relinsert(role_user,role_id,grantee_id,grantor,grant);
			 */ 
			sql_grant_role(sql, grantee, role);
		}
	}
	return stmt_none();
}

static stmt *revoke_roles(mvc * sql, sql_schema *schema,
		dlist * roles, dlist * grantees, int admin, int grantor)
{
	/* revoke roles from the grantees */
	dnode *r, *g;
	(void) schema; (void) admin; (void) grantor; /* Stefan: unused!? */
	
	for( r = roles->h; r; r = r->next ){
		char *role = r->data.sval;
		for( g = grantees->h; g; g = g->next ){
			char *grantee = g->data.sval;
			sql_revoke_role(sql, grantee, role);
		}
	}
	return stmt_none();
}

static stmt *
sql_insert_priv( mvc *sql, int auth_id, int obj_id, 
	int privilege, int grantor, int grantable )
{
	sql_schema *ss = mvc_bind_schema( sql, "sys");
	sql_table *pt = mvc_bind_table( sql, ss, "privileges" );
	node *n = pt->columns.set->h;
	stmt *res, **inserts = NEW_ARRAY(stmt*,5);
	stmt *pts = stmt_basetable( pt, pt->base.name );

	inserts[0] = stmt_append(stmt_cbat(n->data, stmt_dup(pts), INS, st_bat),
 			stmt_atom_int(obj_id));
	n = n->next;
	inserts[1] = stmt_append(stmt_cbat(n->data, stmt_dup(pts), INS, st_bat),
 			stmt_atom_int(auth_id));
	n = n->next;
	inserts[2] = stmt_append(stmt_cbat(n->data, stmt_dup(pts), INS, st_bat),
 			stmt_atom_int(privilege));
	n = n->next;
	inserts[3] = stmt_append(stmt_cbat(n->data, stmt_dup(pts), INS, st_bat),
 			stmt_atom_int(grantor));
	n = n->next;
	inserts[4] = stmt_append(stmt_cbat(n->data, stmt_dup(pts), INS, st_bat),
 			stmt_atom_int(grantable));
	stmt_destroy(pts);
	res = sql_insert(sql, pt, inserts, 5, 0);
	cleanup_stmts(inserts, 5);
	return res;
}

void
sql_insert_all_privs( mvc *sql, int auth_id, int obj_id, 
			int grantor, int grantable, list *l) 
{
	list_append(l, sql_insert_priv( sql, auth_id, obj_id, PRIV_SELECT, 
		grantor, grantable ));
	list_append(l, sql_insert_priv( sql, auth_id, obj_id, PRIV_UPDATE, 
		grantor, grantable ));
	list_append(l, sql_insert_priv( sql, auth_id, obj_id, PRIV_INSERT, 
		grantor, grantable ));
	list_append(l, sql_insert_priv( sql, auth_id, obj_id, PRIV_DELETE, 
		grantor, grantable ));
}

const char *
priv2string( int priv )
{
	switch(priv) {
	case PRIV_SELECT: return "SELECT";
	case PRIV_UPDATE: return "UPDATE";
	case PRIV_INSERT: return "INSERT";
	case PRIV_DELETE: return "DELETE";
	case PRIV_EXECUTE: return "EXECUTE";
	}
	return "UNKNOWN PRIV";
}

static stmt *
grant_table( mvc *sql, sql_schema *cur, dlist *privs, char *tname,  
	dlist *grantees, int grant, int grantor )
{
	dnode *gn;
	sql_table *t = mvc_bind_table( sql, cur, tname );
	list *l;

	if (!t) {
		return sql_error(sql, 02, 
			 "GRANT Table name %s doesn't exist", tname);
	}
		
 	l = create_stmt_list();
	if (privs == NULL){ /* ALL [ PRIVILEGES ] */
		int all = PRIV_SELECT|PRIV_UPDATE|PRIV_INSERT|PRIV_DELETE;
		int allowed = sql_grantable( sql, grantor, t->s->base.id, all, 1);

		if (!allowed)
			allowed = sql_grantable( sql, grantor, t->base.id, all, 0);
		if (!allowed){
			list_destroy(l);
			return sql_error(sql, 02, 
				 "GRANTOR %s is not allowed to grant ALL privileges for table %s", sql->user, tname);
		}

		for ( gn = grantees->h; gn; gn = gn->next ) {
			char *grantee = gn->data.sval;
			int grantee_id;

			if (grantee)
				grantee_id = sql_find_auth(sql, grantee);
			else
				grantee_id = sql_find_auth(sql, "public");

			if (grantee_id <= 0){
				list_destroy(l);
				return sql_error(sql, 02,
					"User/Role %s unknown", grantee);
			}
			sql_insert_all_privs(sql, grantee_id, t->base.id, grantor, grant, l);
		}
		return stmt_list(l);
	}
	for ( gn = grantees->h; gn; gn = gn->next ) {
		dnode *opn;
		char *grantee = gn->data.sval;
		int grantee_id = sql_find_auth(sql, grantee);

		if (grantee_id < 0){
			list_destroy(l);
			return sql_error(sql, 02, 
				"User/Role %s unknown", grantee);
		}

		for ( opn = privs->h; opn; opn = opn->next ){
			symbol *op = opn->data.sym;
			int priv = PRIV_SELECT;

			switch(op->token) {
			case SQL_SELECT: priv = PRIV_SELECT; break;
			case SQL_UPDATE: priv = PRIV_UPDATE; break;

			case SQL_INSERT: priv = PRIV_INSERT; break;
			case SQL_DELETE: priv = PRIV_DELETE; break;

			case SQL_EXECUTE:
			default:
				list_destroy(l);
				return sql_error(sql, 02, 
			 		"Cannot GRANT EXECUTE on table name %s",
					tname);
			}

			if ((op->token == SQL_SELECT || 
			     op->token == SQL_UPDATE) && op->data.lval){
				dnode *cn;

				for(cn = op->data.lval->h; cn; cn = cn->next) {
					char *cname = cn->data.sval;
					sql_column *c=0;

					int allowed = sql_grantable( sql, 
						grantor, t->s->base.id, 
						priv, 1);

					if (!allowed)
						allowed = sql_grantable( sql, 
							grantor, 
							t->base.id, priv, 1);
					if (!allowed)
						allowed = sql_grantable( sql, 
							grantor, 
							c->base.id, priv, 0);
					if (!allowed) {
						list_destroy(l);
						return sql_error(sql, 02, 
				 			"GRANTOR %s is not allowed to grant privilege %s for table %s", sql->user, priv2string(priv), tname);
					}

					c = mvc_bind_column( sql, t, cname );
					if (!c) {
						list_destroy(l);
						return sql_error(sql, 02, 
			 				"Grant: table %s has no column %s", tname, cname);
					}
		     			list_append(l, sql_insert_priv( 
						sql, grantee_id, 
						c->base.id, priv, 
						grantor, grant ));
				}
			} else {
				int allowed = sql_grantable( sql, grantor, 
					t->s->base.id, priv, 1);

				if (!allowed)
					allowed = sql_grantable( sql, grantor, 
						t->base.id, priv, 0);
				if (!allowed) {
					list_destroy(l);
					return sql_error(sql, 02, 
				 		"GRANTOR %s is not allowed to grant privilege %s for table %s", sql->user, priv2string(priv), tname);
				}

				list_append(l, sql_insert_priv( sql, 
					grantee_id, t->base.id, priv, 
					grantor, grant ));
			}
		}
	}
	return stmt_list(l);
}

static stmt *
grant_func( mvc *sql, sql_schema *cur, dlist *privs, char *fname,  
	dlist *grantees, int grant, int grantor )
{
/* todo */
	(void)sql;
	(void)cur;
	(void)privs;
	(void)fname;
	(void)grantees;
	(void)grant;
	(void)grantor;
	return sql_error(sql, 02, 
		 "GRANT Table/Function name %s doesn't exist", fname);
}


static stmt *grant_privs(mvc *sql, sql_schema *cur, 
	dlist *privs, dlist *grantees, 
	int grant, int grantor )
{
	dlist *obj_privs = privs->h->data.lval;
	symbol *obj      = privs->h->next->data.sym;
	int token = obj->token;
	
	if (token == SQL_NAME)
		if (mvc_bind_table(sql, cur, obj->data.sval) != NULL)	
			token = SQL_TABLE;

	switch(token){
	case SQL_TABLE:
		return
		grant_table( sql, cur, obj_privs, obj->data.sval, grantees,
				grant, grantor );
	case SQL_NAME:
		return
		grant_func( sql, cur, obj_privs, obj->data.sval, grantees,
				grant, grantor );
	default: 
		return sql_error(sql, 02, "Grant: unknown token %d", token );
	}
	return sql_error(sql, 02, "Grant: unknown token %d", token );
}
	
static stmt *
sql_delete_priv( mvc *sql, int auth_id, int obj_id, 
	int privilege, int grantor, int grantable )
{
	sql_schema *ss = mvc_bind_schema( sql, "sys");
	sql_table *pt = mvc_bind_table( sql, ss, "privileges" );
	node *n = pt->columns.set->h;

	stmt *pts = stmt_basetable( pt, pt->base.name );
	stmt *s = stmt_relselect_init();
	scope *scp = scope_open(NULL);
	tvar *ptv = scope_add_table_columns(sql, scp, pt, pt->base.name);

	(void)grantor;
	(void)grantable;

	stmt_relselect_fill( s, stmt_uselect(
		stmt_cbat(n->data, stmt_dup(pts), RDONLY, st_bat),
 			stmt_atom_int(auth_id), cmp_equal));
	n = n->next;
	stmt_relselect_fill( s, stmt_uselect(
		stmt_cbat(n->data, stmt_dup(pts), RDONLY, st_bat),
 			stmt_atom_int(privilege), cmp_equal));
	n = n->next;
	stmt_relselect_fill( s, stmt_uselect(
		stmt_cbat(n->data, stmt_dup(pts), RDONLY, st_bat),
 			stmt_atom_int(obj_id), cmp_equal));
	
	s = sql_delete(sql, ptv, pt, s, 0, 0);
	scope_close(scp);
	return s;
}

static stmt *
revoke_table( mvc *sql, sql_schema *cur, dlist *privs, char *tname,  
	dlist *grantees, int grant, int grantor )
{
	dnode *gn;
	sql_table *t = mvc_bind_table( sql, cur, tname );
	list *l;

	if (!t) {
		return sql_error(sql, 02, 
			 "REVOKE Table name %s doesn't exist", tname);
	}
		
	/* TODO 
	if (grant)
		do update !
	if (grant)
		return
	 */
 	l = create_stmt_list();
	if (privs == NULL){ /* ALL [ PRIVILEGES ] */
		for ( gn = grantees->h; gn; gn = gn->next ) {
			char *grantee = gn->data.sval;
			int grantee_id = sql_find_auth(sql, grantee);

			if (grantee_id < 0){
				list_destroy(l);
				return sql_error(sql, 02,
					"User/Role %s unknown", grantee);
			}

		     	list_append(l, sql_delete_priv( sql, grantee_id, 
				t->base.id, PRIV_SELECT, grantor, grant));
		     	list_append(l, sql_delete_priv( sql, grantee_id, 
				t->base.id, PRIV_UPDATE, grantor, grant));
		     	list_append(l, sql_delete_priv( sql, grantee_id, 
				t->base.id, PRIV_INSERT, grantor, grant));
		     	list_append(l, sql_delete_priv( sql, grantee_id, 
				t->base.id, PRIV_DELETE, grantor, grant));
		}
		return stmt_list(l);
	}
	for ( gn = grantees->h; gn; gn = gn->next ) {
		char *grantee = gn->data.sval;
		int grantee_id = sql_find_auth(sql, grantee);
		dnode *opn;

		if (grantee_id < 0){
			list_destroy(l);
			return sql_error(sql, 02, 
				"User/Role %s unknown", grantee);
		}

		for ( opn = privs->h; opn; opn = opn->next ){
			symbol *op = opn->data.sym;
			int priv = PRIV_SELECT;

			switch(op->token) {
			case SQL_SELECT: priv = PRIV_SELECT; break;
			case SQL_UPDATE: priv = PRIV_UPDATE; break;

			case SQL_INSERT: priv = PRIV_INSERT; break;
			case SQL_DELETE: priv = PRIV_DELETE; break;

			case SQL_EXECUTE:
			default:
				list_destroy(l);
				return sql_error(sql, 02, 
			 		"Cannot GRANT EXECUTE on table name %s",
					tname);
			}

			if ((op->token == SQL_SELECT || 
			     op->token == SQL_UPDATE) && op->data.lval){
				dnode *cn;

				for(cn = op->data.lval->h; cn; cn = cn->next) {
					char *cname = cn->data.sval;
					sql_column *c;

					c = mvc_bind_column( sql, t, cname );
					if (!c) {
						list_destroy(l);
						return sql_error(sql, 02, 
			 				"Grant: table %s has no column %s", tname, cname);
					}
		     			list_append(l, sql_delete_priv( 
						sql, grantee_id, 
						c->base.id, priv, 
						grantor, grant ));
				}
			} else {
				list_append(l, sql_delete_priv( sql, 
					grantee_id, t->base.id, priv, 
					grantor, grant ));
			}
		}
	}
	return stmt_list(l);
}

static stmt *
revoke_func( mvc *sql, sql_schema *cur, dlist *privs, char *fname,  
	dlist *grantees, int grant, int grantor )
{
/* todo */
	(void)sql;
	(void)cur;
	(void)privs;
	(void)fname;
	(void)grantees;
	(void)grant;
	(void)grantor;
	return NULL;
}

static stmt *revoke_privs(mvc *sql, sql_schema *cur, 
	dlist *privs, dlist *grantees, int grant, int grantor )
{
	dlist *obj_privs = privs->h->data.lval;
	symbol *obj      = privs->h->next->data.sym;
	int token = obj->token;
	
	if (token == SQL_NAME)
		if (mvc_bind_table(sql, cur, obj->data.sval) != NULL)	
			token = SQL_TABLE;

	switch(token){
	case SQL_TABLE:
		return
		revoke_table( sql, cur, obj_privs, obj->data.sval, grantees,
				grant, grantor );
	case SQL_NAME:
		return
		revoke_func( sql, cur, obj_privs, obj->data.sval, grantees,
				grant, grantor );
	default: 
		return sql_error(sql, 02, "Grant: unknown token %d", token );
	}
	return NULL;
}


static stmt *
create_module(mvc * sql, dlist *qname ){
	char *mname = qname_table(qname);

	sql->trans->module = mvc_create_module(sql, mname);
	return stmt_none();
}

static stmt *
drop_module(mvc * sql, dlist *qname )
{
	char *mname = qname_table(qname);

	mvc_drop_module(sql, mname);
	return stmt_none();
}

static stmt *
create_type(mvc * sql, dlist * qname, char *impl ){
	char *tname = qname_table(qname);

	mvc_create_type(sql, sql->trans->module, tname, 0, 0, 0, impl);
	return stmt_none();
}

static stmt *
create_func(mvc * sql, dlist * qname, dlist *params, sql_subtype *res, char *impl, symbol *body ){
	char *fname = qname_table(qname);
	dnode *n;
	list *l = list_create((fdestroy)&arg_destroy);

	for(n=params->h; n; n = n->next){ 
		dnode *an = n->data.lval->h;
		list_append(l, 
			sql_create_arg( 
				_strdup(an->data.sval),
				sql_dup_subtype(an->next->data.typeval)));
	}
	if (body){ /* sql func */
		char *subquery = QUERY(sql->scanner) + sql->scanner.as;
		stmt *b = NULL;
		
		for(n=params->h; n; n = n->next){ 
			dnode *m = n->data.lval->h;
			char *name = _strdup(m->data.sval);
			sql_subtype *t = sql_dup_subtype(m->next->data.typeval);
			sql_add_param(sql, name, stmt_var(_strdup(name), t ) );
		}
		if (!(b = scope_subquery(sql, NULL, body))){
			sql_destroy_params(sql);
 			return NULL;
		}
		sql_destroy_params(sql);
		stmt_destroy(b);
		
		sql_create_sqlfunc(fname, subquery, l, sql_dup_subtype(res));
	} else {
		sql_create_func_(fname, impl, l, sql_dup_subtype(res));
	}
	return stmt_none();
}

static stmt *
create_view(mvc * sql, sql_schema * ss, dlist * qname, dlist * column_spec,
	    symbol * query, int check)
{

	char *name = qname_table(qname);
	(void) check; /* Stefan: unused!? */

	if (mvc_bind_table(sql, cur_schema(sql), name)) {
		return sql_error(sql, 02, "Create View name %s already in use", name);
	} else {
		char buf[BUFSIZ];
		stmt *sq;
		SelectNode *sn = (SelectNode*)query;
		char *subquery;

		if (sn->limit >= 0) 
			return sql_error( sql, 01, 
				"Limit not supported for views" );
		if (sn->orderby) 
			return sql_error( sql, 01, 
				"Order by not supported for views" );

 		sq = scope_subquery(sql, NULL, query);
		if (!sq)
			return NULL;

 		subquery = QUERY(sql->scanner) + sql->scanner.as;
		if (column_spec) {
			dnode *n = column_spec->h;
			node *m = sq->op1.lval->h;
			sql_table *t = mvc_create_view(sql, ss, name, subquery, 0, 1);

			for (; n; n = n->next, m = m->next) {
				char *cname = n->data.sval;
				stmt *st = m->data;
				sql_subtype *tp = 
					sql_dup_subtype(tail_type(st));

				mvc_create_column(sql, t, cname, tp );  
			}
		} else {
			node *m;
			sql_table *t = mvc_create_view(sql, ss, name, subquery, 0, 1);

       			for ( m = sq->op1.lval->h; m; m = m->next) {
				stmt *st = m->data;
				char *cname = column_name(st);
				sql_subtype *tp = 
					sql_dup_subtype(tail_type(st));

				mvc_create_column(sql, t, cname, tp );  
			}
		}
		stmt_destroy(sq);

		snprintf(buf, BUFSIZ, "grant select on \"%s\" to \"%s\" with grant option;", name, sql->user);
		return stmt_sql(buf);
	}
	return NULL;
}

static stmt *drop_view(mvc * sql, dlist * qname )
{
	sql_schema *ss = cur_schema(sql);
	char *tname = qname_table(qname);
	sql_table *t = mvc_bind_table(sql, ss, tname);

	if (!t) {
		return sql_error(sql, 02, "Drop View, view %s unknown", tname);
	} else if (!t->table){
		mvc_drop_table(sql, ss, t->base.name, 0);
		return stmt_none();
	} else {
		return sql_error(sql, 02, 
			"Drop View, cannot drop view %s", tname);
	}
}

static stmt *
create_index(mvc * sql, sql_schema *ss, char * iname, int itype, 
	     dlist * qname, dlist * column_list) 
{

	char *name = qname_table(qname);
	sql_idx *i = mvc_bind_idx(sql, ss, iname);

	sql_table *t = mvc_bind_table(sql, ss, name); 

	if (i){ 
		return sql_error(sql, 02, "Index name %s allready used", iname);
	} else if (!t){
		return sql_error(sql, 02, 
			"Create Index could not find table name %s", name);
	} else {
		dnode *n = column_list->h;
		sql_idx *i = mvc_create_idx(sql, t, iname, (idx_type)itype);

		if (!i) {
			return sql_error(sql, 02, 
			 "Create Index failed, index %s allready exists",iname);
		}
		for (; n; n = n->next) {
			char *cname = n->data.sval;
			sql_column *c = mvc_bind_column(sql, t, cname);
			if (!c){
				return sql_error(sql, 02, 
				  "Create Index unknown column %s", cname);
			} else {
				mvc_create_ic( sql, i, c);
			}
		}
		return stmt_none();
	}
	return NULL;
}

static stmt *drop_index(mvc * sql, dlist * qname )
{
	stmt *res = NULL;
	char *iname = qname_table(qname);
	sql_schema *ss = cur_schema(sql);

	sql_idx *i = mvc_bind_idx(sql, ss, iname);

	if (!i) {
		return sql_error(sql, 02, 
			 "Drop Index, index %s unknown", iname);
	} else {
		mvc_drop_idx(sql, ss, i->base.name);
		res = stmt_none();
	}
	return res;
}

static stmt *
create_user(mvc * sql, char * user, char * passwd, char *fullname, char *schema)
{
	int schema_id = 0;
	list *l;
	char buf[BUFSIZ];

	if (sql_find_auth( sql, user) >= 0) {
		return sql_error(sql, 02, 
			 "User %s already exists", user);
	}
	if ((schema_id = sql_find_schema( sql, schema)) < 0) {
		return sql_error(sql, 02, 
			 "Schema %s doesn't exist", schema);
	}
	l = create_stmt_list();
	snprintf(buf, BUFSIZ, "insert into sys.db_users values('%s','%s','%s',%d);", user, passwd, fullname, schema_id );
	list_append(l, stmt_sql(buf));
	snprintf(buf, BUFSIZ, "insert into sys.auths values(" SZFMT ", '%s', %d);", OIDnew(1), user, sql->user_id);
	list_append(l, stmt_sql(buf));
	return stmt_list(l);
}

static stmt *
drop_user(mvc * sql, char * user )
{
	/* TODO check if user exists */

	sql_drop_user(sql, user);
	return stmt_none();
}

static stmt *
create_role(mvc * sql, dlist * qname, int grantor)
{
	char *role_name = qname->t->data.sval;

	if (dlist_length(qname) > 2){
		return sql_error(sql, 02, 
			"qualified role can only have a schema and a role\n");
	} 
	sql_create_role(sql, role_name, grantor);
	return stmt_none();
}

static stmt *
drop_role(mvc * sql, dlist * qname )
{
	char *role_name = qname->t->data.sval;

	if (dlist_length(qname) > 2){
		return sql_error(sql, 02, "qualified role can only have a schema and a role\n");
	} 
	sql_drop_role(sql, role_name);
	return stmt_none();
}

static stmt *
column_constraint_type(mvc * sql, char *name, symbol * s, sql_schema * ss, sql_table * t, sql_column * cs )
{
	stmt *res = NULL;

	(void)ss;
	switch (s->token) {
	case SQL_UNIQUE: 
	case SQL_PRIMARY_KEY: 
	{
		key_type kt = (s->token == SQL_UNIQUE)?ukey:pkey;
		sql_key *k = mvc_create_key(sql, t, name, kt, NULL);
		mvc_create_kc(sql, k, cs );
		res = stmt_none();
	} break;
	case SQL_FOREIGN_KEY:
	{
		dnode *n = s->data.lval->h;
		char *rtname = qname_table(n->data.lval);
		char *rcname = n->next->data.lval->h->data.sval;
		list *cols = list_append(list_create(NULL), rcname);
		sql_table *rt = mvc_bind_table( sql, cur_schema(sql), rtname );
		sql_key *k, *rk;

		list_destroy(cols);
		if (!rt) 
			return sql_error(sql, 02, "table %s unknown\n", rtname);

 		rk = mvc_bind_ukey( rt, cols);
		if (!rk) 
			return sql_error(sql, 02, "Could not find referenced unique key in table %s.%s\n", rtname, rcname );
		k = mvc_create_key(sql, t, name, fkey, rk);
		mvc_create_kc(sql, k, cs );
		res = stmt_none();
	} break;
	case SQL_NOT_NULL:
	case SQL_NULL: {
		int null = (s->token == SQL_NOT_NULL)?0:1;
		mvc_null(sql, cs, null);
		res = stmt_none();
	} 	break;
	}

	if (!res) {
		return sql_error(sql, 02, 
			 "Unknown constraint (%ld)->token = %s\n",
			 (long) s, token2string(s->token));
	}
	return res;
}

/* 
column_option: default | column_constraint ;
*/

static char *table_constraint_name()
{
	oid id = OIDnew(1);
	static char buf[BUFSIZ];
	snprintf(buf, BUFSIZ, "c%ld", id );
	return buf;
}


static stmt *
column_option(mvc * sql, symbol * s, sql_schema * ss, sql_table * t, sql_column * cs )
{
	stmt *res = NULL;
	assert(cs);
	switch (s->token) {
	case SQL_CONSTRAINT:
		{
			dlist *l = s->data.lval;
			char *opt_name = l->h->data.sval;  
			symbol *sym = l->h->next->data.sym;
			if (!opt_name) 
				opt_name = table_constraint_name();
			res = column_constraint_type(sql, opt_name, sym, ss, t, cs);
		}
		break;
	case SQL_ATOM: {
			AtomNode *an = (AtomNode*)s;
			if (!an || !an->a){
				mvc_default(sql, cs, NULL);
			} else {
				atom *a = an->a;

				if (a->data.vtype == TYPE_str) {
					mvc_default(sql, cs, a->data.val.sval); 
				} else {
					char *r = atom2string(a);

					mvc_default(sql, cs, r);
					_DELETE(r);
				}
			}
			res = stmt_none();
		} break;
	}
	if (!res) {
		return sql_error(sql, 02, 
			 "Unknown column option (%ld)->token = %s\n",
			 (long) s, token2string(s->token));
	}
	return res;
}

static int 
column_options(mvc * sql, dlist * opt_list, list *stmt_list, sql_schema *ss, sql_table * t, sql_column * cs )
{
	assert(cs);

	if (opt_list) {
		dnode *n = NULL;
		for (n = opt_list->h; n; n = n->next) {
			stmt *res = column_option(sql, n->data.sym, ss, t, cs);
			if (!res) 
				return -1;
			list_append_stmt( stmt_list, res);
		}
	}
	return 0;
}

static stmt *
create_column(mvc * sql, symbol * s, sql_schema * ss, sql_table * t, int alter )
{
	dlist *l = s->data.lval;
	char *cname = l->h->data.sval;
	sql_subtype *ctype = l->h->next->data.typeval;
	dlist *opt_list = NULL;
	stmt *res = NULL;

	if (l->h->next->next)
		opt_list = l->h->next->next->data.lval;

	if (cname && ctype) {
		list *l = create_stmt_list();
		sql_column *cs = NULL;

		ctype = sql_dup_subtype(ctype);
		cs = mvc_create_column(sql, t, cname, ctype );

		if (column_options(sql, opt_list, l, ss, t, cs) < 0) {
			list_destroy(l);
			return NULL;
		}
		if (alter) { 
			atom *a = NULL;
			if (!cs->null && !cs->def) {
				return sql_error(sql, 02, 
			 		"Default value is NULL, but column has NOT NULL constraint\n" );
			}
			if (cs->null && !cs->def) {
			     a = atom_general( sql_dup_subtype(cs->type), NULL);
			} else {
			     a = atom_general( sql_dup_subtype(cs->type),
					_strdup(cs->def) );
			}
			if (!a) {
				return sql_error(sql, 02, "Failed to create default value for alter table add (%s)\n", cs->def?cs->def:"NULL" );
			}
			res = stmt_append(
			  stmt_cbat(cs, stmt_basetable(t, t->base.name), 1, st_bat),
			  stmt_const( 
			    stmt_cbat(
			      mvc_first_column(sql, t), 
			      stmt_basetable(t, t->base.name), 0, st_bat), 
				stmt_atom(a) ));
		}
		if (!res)
			res = stmt_none();
	}

	if (!res) 
		return sql_error(sql, 02, "Create Column: type or name");
	return res;
}

static stmt *
table_foreign_key( mvc * sql, char *name, symbol * s, sql_schema * ss, sql_table * t )
{
	stmt *res = NULL;
	dnode *n = s->data.lval->h;
	char *rtname = qname_table(n->data.lval);
	sql_table *ft = mvc_bind_table( sql, ss, rtname );

	if (!ft){
		return sql_error(sql, 02, "Table %s unknown\n", rtname );
	} else {
		sql_key *k, *rk = NULL;
		dnode *nms = n->next->data.lval->h;
		node *fnms;

		if (n->next->next->data.lval){ /* find unique referenced key */
			dnode *rnms = n->next->next->data.lval->h;
			list *cols = list_create(NULL);

			for( ;rnms; rnms = rnms->next)
				list_append(cols, rnms->data.sval);

			/* find key in ft->keys*/
			rk = mvc_bind_ukey(ft, cols);
			list_destroy(cols);
		} else { /* no list of columns to find referenced unique key ie
			    use ft.pkey */
			rk = &ft->pkey->k;
		}
		if (!rk){
			return sql_error(sql, 02, "Could not find referenced unique key in table %s\n", ft->base.name );
		}
		k = mvc_create_key(sql, t, name, fkey, rk);

		for(fnms = rk->columns->h; nms && fnms; nms = nms->next, fnms = fnms->next){
			char *nm = nms->data.sval;
			sql_column *c = mvc_bind_column(sql, t, nm );

			if (!c){
				return sql_error(sql, 02, 
					"Table %s has no column %s\n", 
					t->base.name, nm);
			}
			mvc_create_kc( sql, k, c );
		}
		if (nms || fnms){
			return sql_error(sql, 02, 
			   "Not all colunms are handeled in the foreign key\n");
		}
		res = stmt_none();
	}
	return res;
}

static stmt *
table_constraint_type( mvc * sql, char *name, symbol * s, sql_schema * ss, sql_table *t, int alter)
{
	stmt *res = NULL;

	switch(s->token){
		case SQL_UNIQUE: 
		case SQL_PRIMARY_KEY:
		{
			key_type kt = (s->token==SQL_PRIMARY_KEY?pkey:ukey);
			sql_key *k = mvc_create_key(sql, t, name, kt, NULL);
			dnode *nms = s->data.lval->h;

			for(;nms; nms = nms->next){
				char *nm = nms->data.sval;
				sql_column *c = mvc_bind_column(sql, t, nm);

				if (!c) {
					return sql_error(sql, 02, 
						"Table %s has no column %s\n", 
						t->base.name, nm);
				}
				(void)mvc_create_kc( sql, k, c );
			}
			if (alter){
				/* TODO */
			}
			res = stmt_none();
		} break;
		case SQL_FOREIGN_KEY:
			res = table_foreign_key( sql, name, s, ss, t );
			if (alter){
				/* TODO */
			}
			res = stmt_none();
		 	break;
	}
	if (!res) {
		return sql_error(sql, 02, 
			 "Table Constraint Type: wrong token (%ld) = %s\n",
			 (long) s, token2string(s->token));
	}
	return res;
}

static stmt *
table_constraint( mvc * sql, symbol * s, sql_schema *ss, sql_table * t, int alter) 
{
	stmt *res = NULL;

	if (s->token == SQL_CONSTRAINT){
		dlist *l = s->data.lval;
		char *opt_name = l->h->data.sval; 
		symbol *sym = l->h->next->data.sym;
		if (!opt_name) 
			opt_name = table_constraint_name();
		res = table_constraint_type(sql, opt_name, sym, ss, t, alter);
	}

	if (!res) {
		return sql_error(sql, 02, 
			 "Table Constraint: wrong token (%ld) = %s\n",
			 (long) s, token2string(s->token));
	}
	return res;
}

static stmt *
table_element(mvc * sql, symbol * s, sql_schema *ss, sql_table *t, int alter )
{
	stmt *res = NULL;

	switch (s->token) {
	case SQL_COLUMN:
		res = create_column(sql, s, ss, t, alter );
		break;
	case SQL_CONSTRAINT:
		res = table_constraint(sql, s, ss, t, alter );
		break;
	case SQL_COLUMN_OPTIONS:
		{
			dnode *n = s->data.lval->h;
			char *cname = n->data.sval;
			sql_column *c = mvc_bind_column(sql, t, cname );
			dlist *olist = n->next->data.lval;

			if (!c){
				return sql_error(sql, 02, 
					"Column %s not found\n", cname);
			} else {
				list *l = create_stmt_list();
				column_options(sql, olist, l, ss, t, c);
				res = list2stmt(l);
			}
			if (alter) {
				/* TODO check constraint and update index */
			}
		} break;
	case SQL_LIKE:
		{
			char *name = qname_table(s->data.lval);
			sql_table *ot = mvc_bind_table( sql, ss, name );
			node *n;

			for (n = ot->columns.set->h; n; n = n->next ){ 
				sql_column *oc = n->data;
				sql_subtype *tpe = sql_dup_subtype( oc->type );

				(void)mvc_create_column( sql, t, oc->base.name, tpe );
			}
			res = stmt_none();
		} break;
	}
	if (!res) {
		return sql_error(sql, 02, 
			 "Unknown table element (%ld)->token = %s\n",
			 (long) s, token2string(s->token));
	}
	return res;
}

static stmt *
create_table(mvc * sql, sql_schema * ss,
			int temp, dlist * qname, dlist * columns, int size)
{
	char *name = qname_table(qname);

	if (mvc_bind_table(sql, ss, name)) {
		return sql_error(sql, 02, 
			"Create Table name %s already in use", name);
	} else if (!schema_privs(sql, ss, PRIV_INSERT)){
		return sql_error(sql, 02, 
			"User is not allowed to create tables in schema %s", 
			ss->base.name);
	} else {
		char buf[BUFSIZ];

		sql_table *t = mvc_create_table(sql, ss, name, 0, !temp, 0, size);
		list *new_columns = create_stmt_list();
		dnode *n;

		for (n = columns->h; n; n = n->next) {
			symbol *sym = n->data.sym;
			stmt *te = table_element(sql, sym, ss, t, 0 );
			if (!te){
				list_destroy(new_columns);
				return NULL;
			}
			list_append_stmt(new_columns, te );
		}
		snprintf(buf, BUFSIZ, "grant all on \"%s\" to \"%s\" with grant option;", name, sql->user);
		list_append( new_columns, stmt_sql(buf));
		return list2stmt(new_columns);
	}
}

static stmt *
drop_table(mvc * sql, dlist * qname, int drop_action)
{
	sql_schema *ss = cur_schema(sql);
	char *tname = qname_table(qname);
	sql_table *t = mvc_bind_table(sql, ss, tname);

	if (!t) {
		return sql_error(sql, 02, 
			"Drop Table, table %s unknown", tname);
	} else if (t->keys.set){
		node *n;
		for (n = t->keys.set->h; n; n = n->next) {
			sql_key *k = n->data;
			if (k->type == ukey || k->type == pkey){
				sql_ukey *uk = (sql_ukey*)k;
				if (uk->keys && list_length(uk->keys)) {
					return sql_error(sql, 02, 
					"Cannot drop Table %s, foreign keys depend on it", tname);
				}
			}
		}
	} 
	if (t->table){
		node *n, *m;
		for (n = t->s->tables.set->h; n; n = n->next ) {
			sql_table *ot = n->data;
			if (!ot->table) {
				scope *scp = scope_open(NULL);
				stmt *s = scope_sqlparse(sql, scp, ot->query);
				
				for(m = scp->bases->h; m; m = m->next) {
					sql_table *ut = m->data;
					if (ut == t) {
						return sql_error(sql, 02, 
							"Cannot drop Table %s, views depend on it", tname);
					}
				}
				stmt_destroy(s);
				scope_close(scp);
			}
		}
		mvc_drop_table(sql, ss, t->base.name, drop_action);
		return stmt_none();
	} else {
		return sql_error(sql, 02, 
			"Drop Table, cannot drop view %s ", tname);
	}
}

static stmt *
alter_table(mvc * sql, sql_schema *ss, dlist * qname, symbol * te)
{
	char *name = qname_table(qname);
	sql_table *t = NULL;

	if ((t = mvc_bind_table(sql, ss, name)) == NULL) {
		return sql_error(sql, 02, 
			 "Alter Table name %s doesn't exist", name);
	} else {
		return table_element(sql, te, ss, t, 1 );
	}
}

static char *
schema_name(dlist * name_auth)
{
	assert(name_auth && name_auth->h);

	return name_auth->h->data.sval;
}

static char *
schema_auth(dlist * name_auth)
{
	assert(name_auth && name_auth->h && dlist_length(name_auth) == 2);

	return name_auth->h->next->data.sval;
}

static stmt *
create_schema(mvc * sql, dlist * auth_name, dlist * schema_elements)
{
	char *name = schema_name(auth_name);
	char *auth = schema_auth(auth_name);
	int auth_id = sql->role_id;

	if (auth && sql_find_auth( sql, auth) < 0) {
		return sql_error(sql, 02, 
			 "Authorizaion %s doesn't exist", auth);
	}
	if (sql->user_id != USER_MONETDB && sql->role_id != ROLE_SYSADMIN){
		return sql_error(sql, 02, 
		       	"Current user %s doesn't have CREATE SCHEMA privileges",
			sql->user);
	}
	if (mvc_bind_schema(sql, name)) {
		return sql_error(sql, 02, 
			"Create Schema name %s already in use", name);
	} else {
		list *table_elements = create_stmt_list();
		sql_schema *ss = mvc_create_schema(sql, name, auth_id);

		dnode *n = schema_elements->h;
		while (n) {
			stmt *res = NULL;
			if (n->data.sym->token == SQL_CREATE_TABLE) {
				dlist *l = n->data.sym->data.lval;
				res = create_table(sql, ss,
						  l->h->data.ival,
						  l->h->next->data.lval,
						  l->h->next->next->data.lval,
						  l->h->next->next->next->data.ival);
			} else if (n->data.sym->token == SQL_CREATE_VIEW) {
				dlist *l = n->data.sym->data.lval;
				res = create_view(sql, ss,
						 l->h->data.lval,
						 l->h->next->data.lval,
						 l->h->next->next->data.
						 sym,
						 l->h->next->next->next->
						 data.ival);
			}
			if (!res) {
				list_destroy(table_elements);
				return NULL;
			}
			list_append_stmt(table_elements, res);
			n = n->next;
		}
		return list2stmt(table_elements);
	}
}

static stmt *
drop_schema(mvc * sql, dlist * qname, int dropaction)
{
	char *name = schema_name(qname);
	sql_schema *s = mvc_bind_schema( sql, name );

	(void)dropaction;
	if (!s) {
		return sql_error(sql, 02, 
			"Drop Schema name %s does not exist", name);
	} else {
		/* TODO use dropaction */
		mvc_drop_schema(sql, name);
		return stmt_none();
	}
}

stmt *
schemas(mvc * sql, symbol * s) 
{
	stmt *ret = NULL;

	switch (s->token) {
	case SQL_CREATE_SCHEMA:
		{
			dlist *l = s->data.lval;
			ret = create_schema(sql, 
				l->h->data.lval, /* qname (name.authid) */
				l->h->next->next->next->data.lval /* schema_elements */);
			sql->type = Q_SCHEMA;
		}
		break;
	case SQL_DROP_SCHEMA:
		{
			dlist *l = s->data.lval;
			ret = drop_schema(sql, 
				l->h->data.lval, /* qname */
				l->h->next->data.ival); /* drop_action */
			sql->type = Q_SCHEMA;
		}
		break;
	case SQL_DROP_TABLE:
		{
			dlist *l = s->data.lval;
			ret = drop_table(sql, l->h->data.lval,
				         l->h->next->data.ival);
			sql->type = Q_SCHEMA;
		}
		break;
	case SQL_DROP_VIEW:
		{
			dlist *l = s->data.lval;
			ret = drop_view(sql, l);
			sql->type = Q_SCHEMA;
		}
		break;
	case SQL_CREATE_TABLE:
		{
			
			dlist *l = s->data.lval;
			ret = create_table(sql, cur_schema(sql),
					   l->h->data.ival,
					   l->h->next->data.lval,
					   l->h->next->next->data.lval,
					   l->h->next->next->next->data.ival
					   );
			sql->type = Q_SCHEMA;
		}
		break;
	case SQL_CREATE_VIEW:
		{
			dlist *l = s->data.lval;
			ret = create_view(sql, cur_schema(sql),
					  l->h->data.lval,
					  l->h->next->data.lval,
					  l->h->next->next->data.sym,
					  l->h->next->next->next->data.
					  ival);
			sql->type = Q_SCHEMA;
		}
		break;
	case SQL_CREATE_INDEX:
		{
			dlist *l = s->data.lval;
			ret = create_index(sql, cur_schema(sql),
					  l->h->data.sval,
					  l->h->next->data.ival,
					  l->h->next->next->data.lval,
					  l->h->next->next->next->data.lval);
			sql->type = Q_SCHEMA;
		}
		break;
	case SQL_DROP_INDEX:
		{
			dlist *l = s->data.lval;
			ret = drop_index(sql, l); /* index name */
			sql->type = Q_SCHEMA;
		}
		break;
	case SQL_CREATE_USER:
		{
			dlist *l = s->data.lval;
			ret = create_user(sql, 
				  l->h->data.sval, /* user name */
				  l->h->next->data.sval, /* password */
				  l->h->next->next->data.sval, /* fullname */
				  l->h->next->next->next->data.sval); /* dschema */
			sql->type = Q_SCHEMA;
		}
		break;
	case SQL_DROP_USER:
			ret = drop_user(sql, s->data.sval); /* user name */
			sql->type = Q_SCHEMA;
		break;
	case SQL_CREATE_ROLE:
		{
			dlist *l = s->data.lval;
			ret = create_role(sql, 
				  l->h->data.lval, /* role name */
				  l->h->next->data.ival); /* role grantor */
			sql->type = Q_SCHEMA;
		}
		break;
	case SQL_DROP_ROLE:
		{
			dlist *l = s->data.lval;
			ret = drop_role(sql, l); /* role name */
			sql->type = Q_SCHEMA;
		}
		break;
	case SQL_ALTER_TABLE:
		{
			dlist *l = s->data.lval;
			ret = alter_table(sql, cur_schema(sql),
					l->h->data.lval,	/* table name */
					l->h->next->data.sym);	/* table element */
			sql->type = Q_SCHEMA;
		}
		break;
	case SQL_GRANT_ROLES:
		{
			dlist *l = s->data.lval;
			ret = grant_roles(sql, cur_schema(sql), 
			    l->h->data.lval,	/* authids */
			    l->h->next->data.lval,	/* grantees */
			    l->h->next->next->data.ival, /* admin? */
			    l->h->next->next->next->data.ival?
				sql->user_id:sql->role_id); 
				/* grantor ? */
			sql->type = Q_SCHEMA;
		} break;
	case SQL_GRANT:
		{
			dlist *l = s->data.lval;
			ret = grant_privs( sql, cur_schema(sql),
			    l->h->data.lval,		/* privileges */
			    l->h->next->data.lval,	/* grantees */
			    l->h->next->next->data.ival, /* grant ? */
			    l->h->next->next->next->data.ival?
				sql->user_id:sql->role_id); 
				/* grantor ? */
			sql->type = Q_SCHEMA;
		} break;
	case SQL_REVOKE:
		{
			dlist *l = s->data.lval;
			ret = revoke_privs( sql, cur_schema(sql),
			    l->h->data.lval,		/* privileges */
			    l->h->next->data.lval,	/* grantees */
			    l->h->next->next->data.ival, /* grant ? */
			    l->h->next->next->next->data.ival?
				sql->user_id:sql->role_id); 
				/* grantor ? */
			sql->type = Q_SCHEMA;
		} break;

	case SQL_CREATE_MODULE:
		{
			dlist *l = s->data.lval;
			ret = create_module( sql, l);
			sql->type = Q_SCHEMA;
		}
		break;

	case SQL_DROP_MODULE:
		{
			dlist *l = s->data.lval;
			ret = drop_module( sql, l );
			sql->type = Q_SCHEMA;
		}
		break;

	case SQL_CREATE_TYPE:
		{
			dlist *l = s->data.lval;
			ret = create_type( sql, l->h->data.lval,
					  l->h->next->data.sval );
			sql->type = Q_SCHEMA;
		}
		break;

	case SQL_CREATE_FUNC:
		{
			dlist *l = s->data.lval;
			ret = create_func( sql, l->h->data.lval,
					  l->h->next->data.lval,
					  l->h->next->next->data.typeval,
					  l->h->next->next->next->data.sval,
					  l->h->next->next->next->next->data.sym
					);
			sql->type = Q_SCHEMA;
		}
		break;

	default:
		return sql_error(sql, 01, 
			 "Schema statement unknown Symbol(%ld)->token = %s",
			 (long) s, token2string(s->token));
	}
	return ret;
}
