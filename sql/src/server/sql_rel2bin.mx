@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f sql_rel2bin
@a S. Manegold
@* 

@h

#ifndef _SQL_REL2BIN_H
#define _SQL_REL2BIN_H

#include "sql_statement.h"
#include "sql_types.h"

extern stmt *rel2bin(mvc *c, stmt *s);

#endif /* _SQL_REL2BIN_H */

@c

#include "sql_rel2bin.h"
#include "sql_env.h"
#include <stdio.h>

static stmt *head_column(stmt *st);

static stmt *
tail_column(stmt *st)
{
	switch (st->type) {
	case st_join:
	case st_outerjoin:
	case st_intersect:
	case st_find:
	case st_reorder:
		return tail_column(st->op2.stval);

	case st_reljoin:
		return tail_column(st->op2.lval->h->data);

	case st_const:

	case st_filter:
	case st_select:
	case st_select2:
	case st_uselect:
	case st_uselect2:
	case st_semijoin:
	case st_limit:

	case st_diff:
	case st_union:

	case st_append:
	case st_insert:
	case st_replace:

	case st_unique:
	case st_unop:
	case st_binop:
	case st_Nop:
	case st_aggr:
	case st_order:

	case st_alias:

	case st_pivot:
	case st_convert:

		return tail_column(st->op1.stval);

	case st_table_clear:
	case st_column:
	case st_bat:
		return st;

	case st_mirror:
	case st_reverse:
		return head_column(st->op1.stval);
	case st_list:
		return tail_column(st->op1.lval->h->data);

		/* required for shrink_select_ranges() in sql_rel2bin.mx */
	case st_idxbat:

		/* required for eliminate_semijoin() in sql_rel2bin.mx */
	case st_relselect:

		/* some statements have no column coming from any basetable */
	case st_atom:
	case st_var:
	case st_update_var:
	case st_mark:
	case st_gen_group:
	case st_derive:
	case st_group_ext:
	case st_group:
	case st_basetable:	/* a table is not a column */
	case st_ptable:
	case st_temp:
		return NULL;

	default:
		fprintf(stderr, "missing tail column %d: %s\n", st->type, st_type2string(st->type));
		assert(0);
		return NULL;
	}
}

static stmt *
head_column(stmt *st)
{
	switch (st->type) {
	case st_const:
	case st_mark:
	case st_gen_group:
	case st_mirror:

	case st_filter:
	case st_select:
	case st_select2:
	case st_uselect:
	case st_uselect2:
	case st_semijoin:
	case st_limit:

	case st_join:
	case st_outerjoin:
	case st_diff:
	case st_intersect:
	case st_union:

	case st_append:
	case st_insert:
	case st_replace:

	case st_group_ext:
	case st_group:
	case st_unique:
	case st_unop:
	case st_binop:
	case st_Nop:
	case st_aggr:
	case st_order:

	case st_alias:

	case st_pivot:
	case st_convert:

		return head_column(st->op1.stval);

	case st_relselect:
	case st_reljoin:
		return head_column(st->op1.lval->h->data);

	case st_table_clear:
	case st_column:
	case st_bat:
		return st;

	case st_reverse:
		return tail_column(st->op1.stval);

	case st_reorder:
	case st_derive:
		return tail_column(st->op2.stval);

	case st_list:
		return head_column(st->op1.lval->h->data);

		/* required for eliminate_semijoin() in sql_rel2bin.mx */
		/* st_temp has no head column coming from any basetable */
	case st_atom:
	case st_var:
	case st_update_var:
	case st_seq_next:
	case st_basetable:
	case st_temp:
	case st_op:
	case st_ptable:
	case st_groupby:
	case st_idxbat:
		return NULL;

		/* stmts without head column which also are not expected */
	case st_none:
	case st_sql:

	case st_ubat:
	case st_dbat:

	case st_ordered:
	case st_output:

	case st_find:
	case st_bulkinsert:

	case st_exception:

	case st_set:
	case st_sets:
		fprintf(stderr, "missing head column %d: %s\n", st->type, st_type2string(st->type));
		assert(0);
		return NULL;
	}
	return NULL;
}

static sql_column *
basecolumn(stmt *st)
{
	if (!st)
		return NULL;	/* required for shrink_select_ranges() and eliminate_semijoin() in sql_rel2bin.mx */
	switch (st->type) {
	case st_reverse:
		return basecolumn(head_column(st->op1.stval));

	case st_pivot:
		return basecolumn(st->op1.stval);
	case st_bat:
		return st->op1.cval;

		/* relational column (result of view etc) has no direct base column */
	case st_column:
		return NULL;

	default:
		return basecolumn(tail_column(st));
	}
}


static int
cmp_sel2(stmt *sel, st_type *tpe)
{
	(void) tpe;		/* Stefan: unsed, but required for list_select() / type fcmp() */
	if (sel->type == st_select2 || sel->type == st_uselect2) {
		return 0;
	}
	return -1;
}

static int
cmp_sel_oneCol(stmt *sel)
{
	int rtrn = -1;

	if (sel->type >= st_select && sel->type <= st_uselect2) {
		if (sel->op2.stval->nrcols == 0) {
			rtrn = 0;
		}
#ifndef NDEBUG
/*
	} else {
		if (sel->type == st_reverse) {
			printf("= TODO: sql_rel2bin: shrink_select_ranges: handle %s(%s)!\n", st_type2string(sel->type), st_type2string(sel->op1.stval->type));
		} else {
			printf("= TODO: sql_rel2bin: shrink_select_ranges: handle %s!\n", st_type2string(sel->type));
		}
*/
#endif
	}
	return rtrn;
}

static int
cmp_sel_twoCol(stmt *sel)
{
	return !cmp_sel_oneCol(sel);
}

static int
cmp_sel_hasNoBasecol(stmt *sel)
{
	int rtrn = -1;

	if (basecolumn(sel) == NULL) {
		rtrn = 0;
	}
	return rtrn;
}

static int
cmp_sel_hasBasecol(stmt *sel)
{
	int rtrn = -1;

	if (basecolumn(sel) != NULL) {
		rtrn = 0;
	}
	return rtrn;
}

static int
cmp_sel_basecol(stmt *sel, stmt *key)
{
	if (basecolumn(key) == basecolumn(sel)) {
		return 0;
	}
	return -1;
}

static int
cmp_sel_val(stmt *sel, stmt *key)
{
	if (sel->op2.stval == key->op2.stval) {
		return 0;
	}
	return -1;
}

static int
cmp_sel_comp_type(stmt *sel, comp_type *flg)
{
	if ((sel->type == st_select || sel->type == st_uselect) && (comp_type) sel->flag == *flg) {
		return 0;
	}
	return -1;
}

static stmt *
stmt_min(stmt *x, stmt *y)
{
	sql_subtype *t;
	sql_subfunc *f;

	assert(x->nrcols == 0);
	assert(y->nrcols == 0);
	t = tail_type(x);
	assert(t);
/*	assert(t == tail_type(y));	*/
	f = sql_bind_func_result(NULL, "sql_min", t, t, t);
	assert(f);
	return stmt_binop(x, y, f);
}

static stmt *
stmt_max(stmt *x, stmt *y)
{
	sql_subtype *t;
	sql_subfunc *f;

	assert(x->nrcols == 0);
	assert(y->nrcols == 0);
	t = tail_type(x);
	assert(t);
/*	assert(t == tail_type(y));	*/
	f = sql_bind_func_result(NULL, "sql_max", t, t, t);
	assert(f);
	return stmt_binop(x, y, f);
}

stmt *
stmt_uselect_select(stmt *s)
{
	assert(s->type == st_uselect2 || (s->type == st_uselect && !s->op2.stval->nrcols));
	if (s->type == st_uselect2)
		s->type = st_select2;
	else
		s->type = st_select;
	assert(!s->t);
	s->t = stmt_dup(s->op1.stval->t);
	return s;
}


list *
shrink_select_ranges(mvc *sql, list *oldsels)
{
	/* find minimal ranges for selects per column on one table */
	sql_subfunc *min = NULL;
	sql_subfunc *max = NULL;

	list *newsels, *haveNoBasecol, *haveBasecol, *basecols, *oneColSels, *twoColSels;
	node *bc;

	newsels = list_create((fdestroy) &stmt_destroy);

	/* we skip selects that involve two columns, e.g., R.a < R.b, here */
	twoColSels = list_select(oldsels, (void *) 1L, (fcmp) &cmp_sel_twoCol, (fdup) &stmt_dup);
	oneColSels = list_select(oldsels, (void *) 1L, (fcmp) &cmp_sel_oneCol, (fdup) &stmt_dup);
	assert(list_length(twoColSels) + list_length(oneColSels) == list_length(oldsels));
	list_destroy(oldsels);

	/* some statments (e.g., st_idxbat when checking key constraints during inserts)
	   don't seem to have a basecolumn, hence, we skip them, here */
	haveNoBasecol = list_select(oneColSels, (void *) 1L, (fcmp) &cmp_sel_hasNoBasecol, (fdup) &stmt_dup);
	haveBasecol = list_select(oneColSels, (void *) 1L, (fcmp) &cmp_sel_hasBasecol, (fdup) &stmt_dup);
	assert(list_length(haveNoBasecol) + list_length(haveBasecol) == list_length(oneColSels));
	list_destroy(oneColSels);

	basecols = list_distinct(haveBasecol, (fcmp) &cmp_sel_basecol, (fdup) &stmt_dup);
	for (bc = basecols->h; bc; bc = bc->next) {
		list *colsels = list_select(haveBasecol, bc->data, (fcmp) &cmp_sel_basecol, (fdup) &stmt_dup);
		sql_subtype *tt = tail_type(((stmt *) (colsels->h->data))->op2.stval);

		assert(tt);
		if (list_length(colsels) == 1) {
			/* only one select on this column; simply keep it. */
			list_append(newsels, stmt_dup(colsels->h->data));
		} else if (!(min = sql_bind_func_result(sql->trans->module, "sql_min", tt, tt, tt)) || !(max = sql_bind_func_result(sql->trans->module, "sql_max", tt, tt, tt))) {
			/* no "min" and/or "max" available on this data type, hence, we cannot apply the following "tricks" */
			list_merge(newsels, colsels, (fdup) &stmt_dup);
		} else {
			list *sels2, *sels1[cmp_all];
			stmt *bound[4] = { NULL, NULL, NULL, NULL };
			stmt *col[4] = { NULL, NULL, NULL, NULL };
			comp_type ct;
			node *n;
			int flg, len = 0;

			sql_subfunc_destroy(min);
			sql_subfunc_destroy(max);

			/* separate all single-range, equal, notequal, notlike, & like selects and eliminate duplicates
			 * (notequal, notlike, & like selects are saved and re-added at the end) */
			for (ct = cmp_gt; ct < cmp_all; ct++) {
				list *l = list_select(colsels, (void *) &ct, (fcmp) &cmp_sel_comp_type, (fdup) &stmt_dup);

				len += list_length(l);
				sels1[ct] = list_distinct(l, (fcmp) &cmp_sel_val, (fdup) &stmt_dup);
				list_destroy(l);
			}
			/* separate all double-sided range selects */
			sels2 = list_select(colsels, (void *) 1L, (fcmp) &cmp_sel2, (fdup) &stmt_dup);
			len += list_length(sels2);

			/* make sure we didn't miss anything */
			assert(len == list_length(colsels));

			/* split-up each double-sided range select in two single-sided ones
			 * (x<[=]a<[=]y  =>  a>[=]x && a<[=]y) to find the minimal ranges below */
			for (n = sels2->h; n; n = n->next) {
				stmt *sl, *sr, *s = n->data;
				comp_type cl = cmp_all, cr = cmp_all;	/* invalid values; just to pacify compilers */

				switch (s->flag) {
				case 0:
					cl = cmp_gt;
					cr = cmp_lt;
					break;
				case 1:
					cl = cmp_gt;
					cr = cmp_lte;
					break;
				case 2:
					cl = cmp_gte;
					cr = cmp_lt;
					break;
				case 3:
					cl = cmp_gte;
					cr = cmp_lte;
					break;
				default:
					assert(0);
				}
				sl = stmt_uselect(stmt_dup(s->op1.stval), stmt_dup(s->op2.stval), cl);
				sr = stmt_uselect(stmt_dup(s->op1.stval), stmt_dup(s->op3.stval), cr);
				list_append(sels1[cl], sl);
				list_append(sels1[cr], sr);
			}
			list_destroy(sels2);

			/* split-up each equal (point) select in two single-sided ones
			 * (a=x  =>  a>=x && a<=x) to find the minimal ranges below */
			/*
			 * in the "worst case", this gets later re-combined to
			 *      x<=a<=x   which is identical to   a=x
			 *
			 * in case there are other equal (point) or range selects,
			 * this improves optimization, especially empty selections
			 * are detected instantly, e.g.:
			 *      a=x && a=y
			 *  =>  a>=x && a<=x && a>=y && a<=y
			 *  =>  a>=max(x,y) && a<=min(x,y)
			 *  =>  max(x,y)<=a<=min(x,y)
			 * or
			 *      a=x && a<=y
			 *  =>  a>=x && a<=x && a<=y
			 *  =>  a>=x && a<=min(x,y)
			 *  =>  x<=a<=min(x,y)
			 *
			 * in both cases we end up with just a single select
			 * instead of two selects plus a semijoin
			 */
			for (n = sels1[cmp_equal]->h; n; n = n->next) {
				stmt *sl, *sr, *s = n->data;

				sl = stmt_uselect(stmt_dup(s->op1.stval), stmt_dup(s->op2.stval), cmp_gte);
				sr = stmt_uselect(stmt_dup(s->op1.stval), stmt_dup(s->op2.stval), cmp_lte);
				list_append(sels1[cmp_gte], sl);
				list_append(sels1[cmp_lte], sr);
			}
			list_destroy(sels1[cmp_equal]);

			/* minimize all single-sided range selects */
			/*
			 * while
			 *      1) a< x && a< y  =>  a <  min(x,y)
			 *      2) a<=x && a<=y  =>  a <= min(x,y)
			 *      3) a> x && a> y  =>  a >  max(x,y)
			 *      4) a>=x && a>=y  =>  a >= max(x,y)
			 * we cannot do similar simple stuff for
			 *      5) a < x && a <= y
			 * and
			 *      6) a > x && a >= y
			 * TODO:
			 * for the latter two cases, produce code like
			 *      5: if (x<=y) { a < x } else { a <= y }
			 *      6: if (x>=y) { a > x } else { a >= y }
			 */
			for (ct = cmp_gt; ct <= cmp_lt; ct++) {
				if (list_length(sels1[ct]) > 0) {
					col[ct] = stmt_dup(((stmt *) (sels1[ct]->h->data))->op1.stval);
				}
				if (list_length(sels1[ct]) == 1) {
					bound[ct] = stmt_dup(((stmt *) (sels1[ct]->h->data))->op2.stval);
				}
				if (list_length(sels1[ct]) > 1) {
					list *bnds = list_create((fdestroy) &stmt_destroy);

					for (n = sels1[ct]->h; n; n = n->next) {
						list_append(bnds, stmt_dup(((stmt *) (n->data))->op2.stval));
					}
					if (ct <= cmp_gte)
						bound[ct] = (stmt *) list_reduce(bnds, (freduce) &stmt_max, (fdup) &stmt_dup);
					else
						bound[ct] = (stmt *) list_reduce(bnds, (freduce) &stmt_min, (fdup) &stmt_dup);
					list_destroy(bnds);
				}
				list_destroy(sels1[ct]);
			}

			/* pairwise (re-)combine single-sided range selects to double-sided range selects */
			/*
			 *      0) a> x && a< y  =>  x< a< y
			 *      1) a> x && a<=y  =>  x< a<=y
			 *      2) a>=x && a< y  =>  x<=a< y
			 *      3) a>=x && a<=y  =>  x<=a<=y
			 */
			for (flg = 0; flg <= 3; flg++) {
				comp_type cl = cmp_all, cr = cmp_all;	/* invalid values; just to pacify compilers */

				switch (flg) {
				case 0:
					cl = cmp_gt;
					cr = cmp_lt;
					break;
				case 1:
					cl = cmp_gt;
					cr = cmp_lte;
					break;
				case 2:
					cl = cmp_gte;
					cr = cmp_lt;
					break;
				case 3:
					cl = cmp_gte;
					cr = cmp_lte;
					break;
				default:
					assert(0);
				}
				if (bound[cl] && bound[cr]) {
					list_append(newsels, stmt_uselect2(stmt_dup(col[cl]), bound[cl], bound[cr], flg));
					bound[cl] = bound[cr] = NULL;
				}
			}

			/* collect remaining single-sided range selects that haven't found a partner */
			for (ct = cmp_gt; ct <= cmp_lt; ct++) {
				if (bound[ct]) {
					list_append(newsels, stmt_uselect(stmt_dup(col[ct]), bound[ct], ct));
				}
				if (col[ct]) {
					stmt_destroy(col[ct]);
				}
			}

			/* finally collect all saved like, notlike, and notequal selects */
			for (ct = cmp_like; ct >= cmp_notequal; ct--) {
				list_merge(newsels, sels1[ct], (fdup) &stmt_dup);
				list_destroy(sels1[ct]);
			}
		}
		list_destroy(colsels);
	}
	/* re-add the skipped statements without basecolumn */
	list_merge(newsels, haveNoBasecol, (fdup) &stmt_dup);
	/* re-add the skipped two-column selects */
	list_merge(newsels, twoColSels, (fdup) &stmt_dup);

	list_destroy(twoColSels);
	list_destroy(haveNoBasecol);
	list_destroy(haveBasecol);
	list_destroy(basecols);

	return newsels;
}

#define PSEL(s) ((s->type == st_select || s->type == st_uselect) && !s->op2.stval->nrcols)
#define RSEL(s) (s->type == st_select2 || s->type == st_uselect2)
#define USEL(s) (s->type == st_uselect || s->type == st_uselect2)

stmt *
eliminate_semijoin(stmt *s)
{
	stmt *s1, *s2;
	sql_column *bc1, *bc2;

	assert(s->type == st_semijoin);
	s1 = s->op1.stval;
	s2 = s->op2.stval;
	bc1 = basecolumn(s1);
	bc2 = basecolumn(s2);
	if (bc1 && bc1 == bc2) {
		int match1 = (PSEL(s1) || RSEL(s1));
		int match2 = (PSEL(s2) || RSEL(s2));

		if (match1 && match2) {
			/* semijoin( select(x,..), select(x,..) ) */
			int swap = 0;

			if (PSEL(s1) && s1->flag == cmp_equal) {
				/* do point select first */
				swap = 0;
			} else if (PSEL(s2) && s2->flag == cmp_equal) {
				/* do point select first */
				swap = 1;
			} else if (PSEL(s2) && s2->flag == cmp_notequal) {
				/* do notequal select last */
				swap = 0;
			} else if (PSEL(s1) && s1->flag == cmp_notequal) {
				/* do notequal select last */
				swap = 1;
			} else if (PSEL(s2) && s2->flag == cmp_notlike) {
				/* do notequal select last */
				swap = 0;
			} else if (PSEL(s1) && s1->flag == cmp_notlike) {
				/* do notequal select last */
				swap = 1;
			} else if (PSEL(s2) && s2->flag == cmp_like) {
				/* do like select last */
				swap = 0;
			} else if (PSEL(s1) && s1->flag == cmp_like) {
				/* do like select last */
				swap = 1;
			} else if (PSEL(s1)) {
				/* single-sided range before double-sided range */
				swap = 0;
			} else if (PSEL(s2)) {
				/* single-sided range before double-sided range */
				swap = 1;
			}
			if (swap) {
				stmt *os;

				os = s1;
				s1 = s2;
				s2 = os;
			}
			if (USEL(s1)) {
				/* uselect => select  to keep tail for s2 */
				s1 = stmt_uselect_select(s1);
			}
		} else if (match1) {
			/* semijoin( select(x,..), f(x) )  =>  semijoin( f(x), select(x,..) ) */
			stmt *os;
			int m;

			m = match1;
			match1 = match2;
			match2 = m;
			os = s1;
			s1 = s2;
			s2 = os;
		}
		if (match2) {
			/* semijoin( f(x), select(x,..) )  =>  select( f(x), .. ) */
			stmt *ns = NULL;

			switch (s2->type) {
			case st_select:
			case st_uselect:
				/* uselect => select  as semijoin also propagates the left input's tail */
				ns = stmt_select(stmt_dup(s1), stmt_dup(s2->op2.stval), (comp_type) s2->flag);
				break;
			case st_select2:
			case st_uselect2:
				/* uselect => select  as semijoin also propagates the left input's tail */
				ns = stmt_select2(stmt_dup(s1), stmt_dup(s2->op2.stval), stmt_dup(s2->op3.stval), s2->flag);
				break;
			default:
				/* pacify compiler; should never be reached. */
				assert(0);
			}
			return ns;
		}
	}
	return stmt_dup(s);
}

stmt *
eliminate_reverse(stmt *s)
{
	stmt *os = s->op1.stval, *ns;

	assert(s->type == st_reverse);
	switch (os->type) {
	case st_reverse:
		/* reverse(reverse(x)) => x */
		ns = os->op1.stval;
		break;
	case st_mirror:
		/* reverse(mirror(x)) => mirror(x) */
		ns = os;
		break;
	default:
		ns = s;
	}
	return stmt_dup(ns);
}

static stmt *
stmt_hash( mvc *sql, list *l ) 
{
	node *m;
	int bits = 0;
	sql_subtype *it;
	stmt *h = NULL;

	it = sql_bind_localtype("int");
	for (m = l->h; m; m = m->next, bits += 8) {
		stmt *s = stmt_dup(m->data);
		sql_subfunc *hf = sql_bind_func_result(sql->trans->module, "hash", tail_type(s), it, it);

		if (h) {
			sql_subfunc *xor = sql_bind_func_result(sql->trans->module, "xor", it, it, it);

			h = stmt_binop(h, stmt_binop(s, stmt_atom_int(bits), hf), xor);
		} else {
			h = stmt_binop(s, stmt_atom_int(bits), hf);
		}
	}
	return h;
}

static stmt *
stmt_reljoin_( mvc *sql, list *l1, list *l2 )
{
	node *n1, *n2;
	stmt *l, *r, *res;

	if (list_length(l1) <= 1) {
		l = stmt_dup(l1->h->data);
		r = stmt_dup(l2->h->data);
		return stmt_join(l, stmt_reverse(r), cmp_equal);
	}
	l = stmt_hash(sql, l1);
	r = stmt_hash(sql, l2);
	res = stmt_join(l, stmt_reverse(r), cmp_equal);
	l = stmt_mark(stmt_reverse(res), 4);
	r = stmt_mark(stmt_dup(res), 4);
	for (n1 = l1->h, n2 = l2->h; n1 && n2; n1 = n1->next, n2 = n2->next) {
		stmt *ld = stmt_dup(n1->data);
		stmt *rd = stmt_dup(n2->data);
		stmt *le = stmt_join(l, ld, cmp_equal);
		stmt *re = stmt_join(r, rd, cmp_equal);
		/* intentional both tail_type's of le (as re sometimes is a
		   find for bulk loading */
		sql_subfunc *f=sql_bind_func(sql->trans->module, "=", tail_type(le), tail_type(le));

		stmt * cmp;

		assert(f);

		cmp = stmt_binop(le, re, f);

		cmp = stmt_uselect(cmp, stmt_bool(1), cmp_equal);

		l = stmt_semijoin(stmt_dup(l), stmt_dup(cmp));
		r = stmt_semijoin(stmt_dup(r), cmp);
	}
	res = stmt_join(stmt_reverse(l), r, cmp_equal);
	return res;
}


stmt *
rel2bin(mvc *c, stmt *s)
{
	assert(!(s->optimized < 2 && s->rewritten));
	if (s->optimized >= 2) {
		if (s->rewritten)
			return stmt_dup(s->rewritten);
		else
			return stmt_dup(s);
	}

	switch (s->type) {
		/* first just return those statements which we cannot optimize,
		 * such as schema manipulation, transaction managment, 
		 * and user authentication.
		 */
	case st_none:
	case st_sql:
	case st_dbat:
	case st_basetable:
	case st_idxbat:

	case st_atom:
	case st_find:
	case st_bulkinsert:
	case st_var:
	case st_update_var:
	case st_seq_next:
	case st_table_clear:

		s->optimized = 2;
		return stmt_dup(s);

	case st_reljoin:{

		list *l1 = create_stmt_list();
		list *l2 = create_stmt_list();
		node *n1, *n2;
		stmt *res;

		for (n1 = s->op1.lval->h, n2 = s->op2.lval->h; n1 && n2; n1 = n1->next, n2 = n2->next) {
			list_append(l1, rel2bin(c, n1->data));
			list_append(l2, rel2bin(c, n2->data));
		}
		/*res = stmt_reljoin2(l1, l2); */
		res = stmt_reljoin_(c, l1, l2);
		list_destroy(l1);
		list_destroy(l2);
		s->optimized = res->optimized = 2;
		if (res != s) {
			s->rewritten = stmt_dup(res);
		}
		return res;
	}

	case st_relselect:{

		stmt *res;
		node *n;
		list *l = create_stmt_list();

		for (n = s->op1.lval->h; n; n = n->next) {
			list_append(l, rel2bin(c, n->data));
		}
		if (list_length(l) == 1) {
			res = stmt_dup(l->h->data);
		} else {
			if (!mvc_debug_on(c, 4096)) {
				l = shrink_select_ranges(c, l);
			}
			res = (stmt *) list_reduce(l, (freduce) &stmt_semijoin, (fdup) &stmt_dup);
		}
		list_destroy(l);
		s->optimized = res->optimized = 2;
		if (res != s) {
			s->rewritten = stmt_dup(res);
		}
		return res;
	}

	case st_limit: {
		stmt *ns, *j = NULL, *os = s;

		/* try to push the limit through the (fetch) join */
		j = s->op1.stval;
		/* equi join on same base table */
		if (s->flag == 0 &&
		    j->type == st_join && 
		  ((j->flag == cmp_equal && 
		    j->op1.stval->t && j->op1.stval->t == j->op2.stval->h) || 
		    j->flag == cmp_all)) {
			stmt *l = stmt_dup(j->op1.stval);
			stmt *r = stmt_dup(j->op2.stval);

			l = stmt_limit(l, 
			      s->op2.stval->op1.aval->data.val.ival,
			      s->op3.stval->op1.aval->data.val.ival,
			      s->flag);
			s = stmt_join(l, r, cmp_equal); 
			ns = rel2bin(c, s);
			stmt_destroy(s);
			os->rewritten = stmt_dup(ns);
			os->optimized = ns->optimized = 2;
			return ns;
		} else
		if (s->flag != 0 /* topn, ie limit and orderby */ &&
		    j->type == st_join && 
		  ((j->flag == cmp_equal && 
		    j->op1.stval->t && j->op1.stval->t == j->op2.stval->h) || 
		    j->flag == cmp_all)) {
			stmt *l = stmt_dup(j->op1.stval);
			stmt *r = stmt_dup(j->op2.stval);

			r = stmt_limit(r, 
			      s->op2.stval->op1.aval->data.val.ival,
			      s->op3.stval->op1.aval->data.val.ival,
			      s->flag);
			s = stmt_join(l, r, cmp_equal); 
			ns = rel2bin(c, s);
			stmt_destroy(s);
			os->rewritten = stmt_dup(ns);
			os->optimized = ns->optimized = 2;
			return ns;
		}
		/* try to push the limit through the order */
		if (j->type == st_order) {
			s = stmt_order(stmt_limit(stmt_dup(j->op1.stval),
				s->op2.stval->op1.aval->data.val.ival,
				s->op3.stval->op1.aval->data.val.ival,
				j->flag+1), j->flag);
			ns = rel2bin(c, s);
			stmt_destroy(s);
			os->rewritten = stmt_dup(ns);
			os->optimized = ns->optimized = 2;
			return ns;
		}
		/* try to push the limit through the reverse */
		if (j->type == st_reverse) {
			s = stmt_reverse(stmt_limit(stmt_dup(j->op1.stval),
				s->op2.stval->op1.aval->data.val.ival,
				s->op3.stval->op1.aval->data.val.ival,
				j->flag));
			ns = rel2bin(c, s);
			stmt_destroy(s);
			os->rewritten = stmt_dup(ns);
			os->optimized = ns->optimized = 2;
			return ns;
		}
		/* try to push the limit through the mark */
		if (j->type == st_mark) {
			s = stmt_mark_tail(stmt_limit(stmt_dup(j->op1.stval),
				s->op2.stval->op1.aval->data.val.ival,
				s->op3.stval->op1.aval->data.val.ival, j->flag),
				j->op2.stval->op1.aval->data.val.ival);
			ns = rel2bin(c, s);
			stmt_destroy(s);
			os->rewritten = stmt_dup(ns);
			os->optimized = ns->optimized = 2;
			return ns;
		}
		if (s->op1.stval) {
			stmt *os = s->op1.stval;
			stmt *ns = rel2bin(c, os);

			assert(ns != s);
			stmt_destroy(os);
			s->op1.stval = ns;
		}
		s->optimized = 2;
		return stmt_dup(s);
	}
	case st_semijoin:{

		stmt *j = NULL;
		stmt *os, *ns;

		os = stmt_semijoin(rel2bin(c, s->op1.stval), rel2bin(c, s->op2.stval));
		/* try to push the semijoin through the (fetch) join */
		if (os->op1.stval->type == st_join) {
			j = os->op1.stval;
			/* equi join on same base table */
			if (j->type == st_join && 
		    		j->flag == cmp_equal &&
		    		j->op1.stval->t == j->op2.stval->h ) {
				stmt *l = stmt_dup(j->op1.stval);
				stmt *r = stmt_dup(j->op2.stval);
				s = stmt_semijoin(l, stmt_dup(os->op2.stval));
				l = rel2bin(c, s);
				stmt_destroy(s);
				stmt_destroy(os);
				os = stmt_join( l, r, cmp_equal);
				os->optimized = 2; 
				return os;
			}
		} 
		if (!mvc_debug_on(c, 4096) && os->nrcols) {
			ns = eliminate_semijoin(os);
		} else {
			ns = stmt_dup(os);
		}
		stmt_destroy(os);
		s->optimized = ns->optimized = 2;
		if (ns != s) {
			s->rewritten = stmt_dup(ns);
		}
		return ns;
	}

	case st_join:{

		if (s->op1.stval) {
			stmt *os = s->op1.stval;
			stmt *ns = rel2bin(c, os);

			assert(ns != s);
			stmt_destroy(os);
			s->op1.stval = ns;
		}
		if (s->op2.stval) {
			stmt *os = s->op2.stval;
			stmt *ns = rel2bin(c, os);

			assert(ns != s);
			stmt_destroy(os);
			s->op2.stval = ns;
		}

		/* remove expensive double kdiffs 
		 * if join on oids from the same table then 	
		 * right kdiff is not needed 
		 */
		if (s->flag == cmp_equal && 
		    s->op1.stval->t == s->op2.stval->h &&
		    s->op2.stval->type == st_diff){
			stmt *old = s->op2.stval;
			s->op2.stval = stmt_dup(old->op1.stval);
			stmt_destroy(old);
		}
		s->optimized = 2;
		return stmt_dup(s);
	}

	case st_reverse:{

		stmt *os, *ns;

		os = stmt_reverse(rel2bin(c, s->op1.stval));
		if (!mvc_debug_on(c, 4096)) {
			ns = eliminate_reverse(os);
		} else {
			ns = stmt_dup(os);
		}
		stmt_destroy(os);
		s->optimized = ns->optimized = 2;
		if (ns != s) {
			s->rewritten = stmt_dup(ns);
		}
		return ns;
	}
	case st_select:
	case st_select2:
	case st_uselect:
	case st_uselect2: {

		if (s->op1.stval) {
			stmt *os = s->op1.stval;
			stmt *ns = rel2bin(c, os);

			assert(ns != s);
			stmt_destroy(os);
			s->op1.stval = ns;
		}
		if (s->op2.stval) {
			stmt *os = s->op2.stval;
			stmt *ns = rel2bin(c, os);

			assert(ns != s);
			stmt_destroy(os);
			s->op2.stval = ns;
		}
		/* remove expensive double kdiffs 
		 * if join on oids from the same table then 	
		 * right kdiff is not needed 
		 */
		if (s->op1.stval->type == st_diff){
			stmt *old = s->op1.stval;
			s->op1.stval = stmt_dup(old->op1.stval);
			stmt_destroy(old);
		}
		s->optimized = 2;
		return stmt_dup(s);
	}

	case st_temp:
	case st_filter:
	case st_diff:
	case st_intersect:
	case st_union:
	case st_outerjoin:
	case st_mirror:
	case st_const:
	case st_mark:
	case st_gen_group:
	case st_group:
	case st_group_ext:
	case st_derive:
	case st_unique:
	case st_order:
	case st_reorder:
	case st_ordered:

	case st_alias:
	case st_column:
	case st_append:
	case st_insert:
	case st_replace:
	case st_exception:

	case st_aggr:
	case st_op:
	case st_unop:
	case st_binop:
	case st_Nop:
	case st_convert:

		if (s->op1.stval) {
			stmt *os = s->op1.stval;
			stmt *ns = rel2bin(c, os);

			assert(ns != s);
			stmt_destroy(os);
			s->op1.stval = ns;
		}
		if (s->type != st_convert) {
			if (s->op2.stval) {
				stmt *os = s->op2.stval;
				stmt *ns = rel2bin(c, os);
	
				assert(ns != s);
				stmt_destroy(os);
				s->op2.stval = ns;
			}
			if (s->op3.stval) {
				stmt *os = s->op3.stval;
				stmt *ns = rel2bin(c, os);
	
				assert(ns != s);
				stmt_destroy(os);
				s->op3.stval = ns;
			}
		}
		s->optimized = 2;
		return stmt_dup(s);

	case st_output: {

		if (s->op1.stval) {
			stmt *os = s->op1.stval;
			stmt *ns = rel2bin(c, os);

			assert(ns != s);
			stmt_destroy(os);
			s->op1.stval = ns;
		}

		if (s->op2.stval) {
			stmt *os = s->op2.stval;
			stmt *ns = rel2bin(c, os);

			assert(ns != s);
			stmt_destroy(os);
			s->op2.stval = ns;
		}

		/*
		if all outputs depend on the same mark, just use
			   the mark as order and simply use the bases.
		*/
/*
		if (!mvc_debug_on(c, 65536) && s->op1.stval->type != st_ordered)
		{
			stmt *lst = s->op1.stval;

			node *n = lst->op1.lval->h;
			stmt *c = n->data;
			stmt *h = c->op1.stval;
			list *l = create_stmt_list();
			int all = 1;
			for( ; n; n = n->next) {
				stmt *c = n->data;
				if (c->type != st_join || h != c->op1.stval ||
				    c->op2.stval->type != st_bat) {
					all = 0;
					break;
				}
				list_append(l, stmt_dup(c->op2.stval));
			}
			if (all) {
				stmt *m = stmt_reverse(stmt_dup(h));
				stmt *r = eliminate_reverse(m);
				stmt *res = stmt_output(stmt_ordered(r, stmt_list(l)));
				stmt_destroy(m);
				res->optimized = 2;
				return res;
			} else {
				list_destroy(l);
			}
		}
*/
		s->optimized = 2;
		return stmt_dup(s);
	}
	case st_list:{

		stmt *res = NULL;
		node *n;
		list *l = s->op1.lval;
		list *nl = NULL;

		nl = create_stmt_list();
		for (n = l->h; n; n = n->next) {
			stmt *ns = rel2bin(c, n->data);

			list_append(nl, ns);
		}
		res = stmt_list(nl);
		s->optimized = res->optimized = 2;
		if (res != s) {
			s->rewritten = stmt_dup(res);
		}
		return res;
	}

	case st_bat:
		if (s->flag == RDONLY && s->op1.cval->t->table) {
			return stmt_diff(stmt_dup(s), stmt_reverse(stmt_tbat(s->op1.cval->t, RDONLY)));
		}
		/* fall through */
	case st_ubat:
		s->optimized = 2;
		return stmt_dup(s);



	case st_pivot:
	case st_ptable:
	case st_set:
	case st_sets:
	default:
		assert(0);	/* these should have been rewriten by now */
	}
	return stmt_dup(s);
}
