@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008-2010 MonetDB B.V.
@' All Rights Reserved.

@f sql_statement
@a N.J. Nes
@*

@h
#ifndef _SQL_STATEMENT_H_
#define _SQL_STATEMENT_H_

#include "sql_mem.h"
#include "sql_types.h"
#include "sql_atom.h"
#include "sql_string.h"
#include "sql_mvc.h"

#define create_stmt_list() list_create((fdestroy)&stmt_destroy)

typedef union stmtdata {
	int ival;
	char *sval;
	struct atom *aval;
	struct list *lval;
	struct stmt *stval;
	struct group *gval;
	struct sql_column *cval;
	struct sql_key *kval;
	struct sql_idx *idxval;
	struct sql_table *tval;
	struct sql_schema *schema;
	sql_subtype typeval;
	struct sql_subaggr *aggrval;
	struct sql_subfunc *funcval;
} stmtdata;

typedef enum stmt_type {
	st_none,
	st_var,			/* use and/or declare variable */

	st_basetable,	
	st_table,		/* some functions return a table */
	st_temp,		/* temporal bat */
	st_single,		/* single value bat */
	st_rs_column,
	st_column,		/* relational column result */
	st_bat,
	st_dbat,
	st_idxbat,
	st_const,
	st_mark,
	st_gen_group,
	st_reverse,
	st_mirror,

	st_limit,
	st_order,
	st_reorder,

	st_ordered,
	st_output,
	st_affected_rows,

	st_atom,
	st_select,
	st_select2,
	st_selectN,
	st_uselect,
	st_uselect2,
	st_uselectN,
	st_semijoin,
	st_relselect,

	st_releqjoin,
	st_join,
	st_join2,
	st_joinN,
	st_outerjoin,
	st_diff,
	st_union,
	st_reljoin,

	st_export,
	st_append,
	st_table_clear,
	st_exception,
	st_trans,
	st_catalog,

	st_append_col,
	st_append_idx,
	st_update_col,
	st_update_idx,
	st_delete,

	st_group_ext,
	st_group,
	st_derive,
	st_unique,
	st_convert,
	st_unop,
	st_binop,
	st_Nop,
	st_aggr,

	st_alias,

	st_connection,		/*To handle support sql connections*/

	/* used internally only */
	st_list,

	/* flow control statements */
	st_while,
	st_if,
	st_return,
	st_assign
} st_type;

typedef enum comp_type {
	cmp_gt = 0,
	cmp_gte = 1,
	cmp_lte = 2,
	cmp_lt = 3,
	cmp_equal = 4,
	cmp_notequal = 5,
	cmp_notlike = 6,
	cmp_like = 7,
	cmp_notilike = 8,
	cmp_ilike = 9,
	cmp_all = 10,
	cmp_or = 11,
	cmp_project = 12
} comp_type;

/* flag to indicate anti join/select */
#define ANTI 16
#define GRP_DONE 32

typedef struct stmt {
	sql_ref ref;

	st_type type;
	stmtdata op1;
	stmtdata op2;
	stmtdata op3;
	stmtdata op4;		/* only op4 will hold other types */

	char nrcols;
	char key;		/* key (aka all values are unique) */
	char aggr;		/* aggregated */

	int flag;

	int nr;			/* variable assignment */
	int nr2;		/* usage count */

	struct stmt *h;
	struct stmt *t;
	int optimized;
	struct stmt *rewritten;
} stmt;

typedef struct group {
	sql_ref ref;

	stmt *grp;
	stmt *ext;
} group;

extern const char *st_type2string(st_type type);

extern int stmt2dot(stmt *s, int i, char *fn);
extern int print_stmt(stmt *s, int *nr);
extern void Sprint(stmt *s);

extern stmt *stmt_none(void);

#define VAR_DECLARE 1
#define VAR_GLOBAL(f) ((f>>1)==1)
extern stmt *stmt_var(char *varname, sql_subtype *t, int declare, int level);
extern stmt *stmt_varnr(int nr, sql_subtype *t);

extern stmt *stmt_table(stmt *cols, int temp);
extern stmt *stmt_basetable(sql_table *t, char *tname);

#define isbasetable(s) (s->type == st_basetable && isTable(s->op1.tval))
#define basetable_table(s) s->op1.tval

extern stmt *stmt_column(stmt *i, stmt *basetable, sql_table *t);	/* relational column */
extern stmt *stmt_rs_column(stmt *result_set, stmt *v, sql_subtype *tpe);

extern stmt *stmt_bat(sql_column *c, stmt *basetable, int access );
extern stmt *stmt_delta_table_bat(sql_column *c, stmt *basetable, int access );
extern stmt *stmt_idxbat(sql_idx * i, int access);
extern stmt *stmt_delta_table_idxbat(sql_idx * i, int access);

extern stmt *stmt_append_col(sql_column *c, stmt *b);
extern stmt *stmt_append_idx(sql_idx *i, stmt *b);
extern stmt *stmt_update_col(sql_column *c, stmt *b);
extern stmt *stmt_update_idx(sql_idx *i, stmt *b);
extern stmt *stmt_delete(sql_table *t, stmt *b);

extern stmt *stmt_append(stmt *c, stmt *values);
extern stmt *stmt_table_clear(sql_table *t);
extern stmt *stmt_export(stmt *t, char *sep, char *rsep, char *ssep, char *null_string, stmt *file);
extern stmt *stmt_trans(int type, stmt *chain, stmt *name);
extern stmt *stmt_catalog(int type, stmt *name, stmt *auth, stmt *action);

extern stmt *stmt_temp(sql_subtype *t);
extern stmt *stmt_atom(atom *op1);
extern stmt *stmt_atom_string(char *s);
extern stmt *stmt_atom_clob(char *S);
extern stmt *stmt_atom_int(int i);
extern stmt *stmt_atom_wrd(wrd i);
extern stmt *stmt_atom_lng(lng l);
extern stmt *stmt_bool(int b);
extern stmt *stmt_select(stmt *op1, stmt *op2, comp_type cmptype);
extern stmt *stmt_uselect(stmt *op1, stmt *op2, comp_type cmptype);
/* cmp
       0 ==   l <  x <  h
       1 ==   l <  x <= h
       2 ==   l <= x <  h
       3 ==   l <= x <= h
       */
extern stmt *stmt_select2(stmt *op1, stmt *op2, stmt *op3, int cmp);
extern stmt *stmt_uselect2(stmt *op1, stmt *op2, stmt *op3, int cmp);
extern stmt *stmt_selectN(stmt *l, stmt *r, sql_subfunc *op);
extern stmt *stmt_uselectN(stmt *l, stmt *r, sql_subfunc *op);
extern stmt *stmt_likeselect(stmt *op1, stmt *op2, stmt *op3, comp_type cmptype);

#define isEqJoin(j) \
	(j->type == st_join && (j->flag == cmp_equal || j->flag == cmp_project))

extern stmt *stmt_semijoin(stmt *op1, stmt *op2);

extern stmt *stmt_relselect_init(void);
extern void stmt_relselect_fill(stmt *relselect, stmt *select);

extern stmt *stmt_releqjoin_init(void);
extern void stmt_releqjoin_fill(stmt *releqjoin, stmt *lc, stmt *rc);
extern stmt *stmt_releqjoin1(list *joins);
extern stmt *stmt_releqjoin2(list *l1, list *l2);
extern stmt *stmt_join(stmt *op1, stmt *op2, comp_type cmptype);

/* generic join operator, with a left and right statement list */
extern stmt *stmt_joinN(stmt *l, stmt *r, sql_subfunc *op);

extern stmt *stmt_join2(stmt *l, stmt *ra, stmt *rb, int cmp);
extern stmt *stmt_project(stmt *op1, stmt *op2);
extern stmt *stmt_outerjoin(stmt *op1, stmt *op2, comp_type cmptype);
extern stmt *stmt_reljoin(stmt *op1, list *neqjoins);

extern stmt *stmt_diff(stmt *op1, stmt *op2);
extern stmt *stmt_union(stmt *op1, stmt *op2);
extern stmt *stmt_list(list *l);
extern void stmt_set_nrcols(stmt *s);
extern stmt *stmt_connection(int *id, char *server, int *port, char *db, char *db_alias, char *user, char *passwd, char *lang);

/* raise exception incase the condition (cond) holds, continue with stmt res */
extern stmt *stmt_exception(stmt *cond, char *errstr, int errcode);

extern stmt *stmt_const(stmt *s, stmt *val);

extern stmt *stmt_mark(stmt *s, int id);
extern stmt *stmt_mark_tail(stmt *s, int id);
extern stmt *stmt_gen_group(stmt *s); /* given a gid,cnt blowup to full groups */
extern stmt *stmt_reverse(stmt *s);
extern stmt *stmt_mirror(stmt *s);

#define LIMIT_DIRECTION(dir,order,before_project) \
		(dir<<2)+(before_project<<1)+(order)
extern stmt *stmt_limit(stmt *s, wrd offset, wrd limit, int direction);
extern stmt *stmt_order(stmt *s, int direction);
extern stmt *stmt_reorder(stmt *s, stmt *t, int direction);

extern stmt *stmt_convert(stmt *v, sql_subtype *from, sql_subtype *to);
extern stmt *stmt_unop(stmt *op1, sql_subfunc *op);
extern stmt *stmt_binop(stmt *op1, stmt *op2, sql_subfunc *op);
extern stmt *stmt_Nop(stmt *ops, sql_subfunc *op);
extern stmt *stmt_aggr(stmt *op1, group *grp, sql_subaggr *op, int reduce);
extern stmt *stmt_aggr2(stmt *op1, stmt *op2, sql_subaggr *op);
extern stmt *stmt_unique(stmt *s, group *grp);

extern stmt *stmt_alias(stmt *op1, char *tname, char *name);

extern stmt *stmt_ordered(stmt *order, stmt *res);
extern stmt *stmt_output(stmt *l);
extern stmt *stmt_affected_rows(stmt *l);

/* flow control statements */
extern stmt *stmt_while(stmt *cond, stmt *whilestmts );
extern stmt *stmt_if(stmt *cond, stmt *ifstmts, stmt *elsestmts);
extern stmt *stmt_return(stmt *val, int nr_of_declared_tables);
extern stmt *stmt_assign(char *varname, stmt *val, int level);

extern sql_subtype *head_type(stmt *st);
extern sql_subtype *tail_type(stmt *st);
extern int stmt_has_null( stmt *s );

extern char *column_name(stmt *st);
extern char *table_name(stmt *st);
extern char *schema_name(stmt *st);

extern void cond_stmt_destroy(stmt *s);
extern void stmt_destroy(stmt *s);
extern stmt *stmt_dup(stmt *s);

/*Dependency control*/
extern list* stmt_list_dependencies(stmt *s, int depend_type);

extern group *grp_create(stmt *s, group *og);
extern void grp_done(group *g);
extern void grp_destroy(group *g);
extern group *grp_dup(group *g);

extern stmt *stmt_group(stmt *s);
extern stmt *stmt_derive(stmt *g, stmt *s);

extern stmt *const_column(stmt *val );

#endif /* _SQL_STATEMENT_H_ */

@c
#include "sql_config.h"
#include "sql_mem.h"
#include "sql_statement.h"
#include <string.h>

const char *
st_type2string(st_type type)
{
	switch (type) {
#define ST(TYPE) case st_##TYPE : return #TYPE
		ST(none);
		ST(var);

		ST(basetable);
		ST(table);
		ST(temp);
		ST(single);

		ST(rs_column);
		ST(column);

		ST(bat);
		ST(dbat);
		ST(idxbat);

		ST(const);

		ST(mark);
		ST(gen_group);
		ST(reverse);
		ST(mirror);

		ST(limit);
		ST(order);
		ST(reorder);

		ST(ordered);
		ST(output);
		ST(affected_rows);

		ST(atom);

		ST(select);
		ST(select2);
		ST(uselect);
		ST(selectN);
		ST(uselect2);
		ST(uselectN);
		ST(semijoin);
		ST(relselect);

		ST(releqjoin);
		ST(join);
		ST(join2);
		ST(joinN);
		ST(outerjoin);
		ST(diff);
		ST(union);
		ST(reljoin);

		ST(export);
		ST(append);
		ST(table_clear);
		ST(exception);
		ST(trans);
		ST(catalog);

		ST(append_col);
		ST(append_idx);
		ST(update_col);
		ST(update_idx);
		ST(delete);

		ST(group_ext);
		ST(group);

		ST(derive);
		ST(unique);
		ST(convert);
		ST(unop);
		ST(binop);
		ST(Nop);
		ST(aggr);

		ST(alias);
		ST(connection);

		ST(list);
	
		ST(while);
		ST(if);
		ST(return);
		ST(assign);
	}
	return "unknown";	/* just needed for broken compilers ! */
}

/* #TODO make proper traversal operations */
stmt *
stmt_atom_string(char *S)
{
	char *s = sql2str(S);
	sql_subtype t; 

	sql_find_subtype(&t, "varchar", _strlen(s), 0);
	return stmt_atom(atom_string(&t, s, 1));
}

stmt *
stmt_atom_clob(char *S)
{
	char *s = sql2str(S);
	sql_subtype t; 

	sql_find_subtype(&t, "clob", _strlen(s), 0);
	return stmt_atom(atom_string(&t, s, 1));
}

stmt *
stmt_atom_int(int i)
{
	sql_subtype t;

	sql_find_subtype(&t, "int", 32, 0);
	return stmt_atom(atom_int(&t, i));
}

stmt *
stmt_atom_wrd(wrd i)
{
	sql_subtype t;

	if (sizeof(wrd) == sizeof(int))
		sql_find_subtype(&t, "wrd", 32, 0);
	else
		sql_find_subtype(&t, "wrd", 64, 0);
	return stmt_atom(atom_int(&t, i));
}

stmt *
stmt_atom_lng(lng l)
{
	sql_subtype t;

	sql_find_subtype(&t, "bigint", 64, 0);
	return stmt_atom(atom_int(&t, l));
}

stmt *
stmt_bool(int b)
{
	sql_subtype t;

	sql_find_subtype(&t, "boolean", 0, 0);
	if (b) {
		return stmt_atom(atom_bool(&t, TRUE));
	} else {
		return stmt_atom(atom_bool(&t, FALSE));
	}
}

static stmt *
stmt_atom_oid(oid i)
{
	sql_subtype t;

	sql_find_subtype(&t, "oid", 0, 0);
	return stmt_atom(atom_int(&t, i));
}

static stmt *
stmt_create(st_type type)
{
	stmt *s = NEW(stmt);

	sql_ref_init(&s->ref);
	s->type = type;
	s->op1.sval = NULL;
	s->op2.sval = NULL;
	s->op3.sval = NULL;
	s->op4.sval = NULL;
	s->flag = 0;
	s->nrcols = 0;
	s->key = 0;
	s->aggr = 0;
	s->nr = 0;
	s->nr2 = int_nil;
	s->h = NULL;
	s->t = NULL;
	s->optimized = -1;
	s->rewritten = NULL;
	return s;
}

static stmt *
stmt_ext(stmt *grp)
{
	stmt *ns = stmt_create(st_group_ext);

	ns->op1.stval = grp;
	ns->nrcols = grp->nrcols;
	ns->key = 1;
	ns->h = stmt_dup(grp->h);
	ns->t = stmt_dup(grp->t);
	return ns;
}

stmt *
stmt_group(stmt *s)
{
	stmt *ns = stmt_create(st_group);

	ns->op1.stval = s;
	ns->nrcols = s->nrcols;
	ns->key = 0;
	ns->h = stmt_dup(s->h);
	ns->t = stmt_dup(s->t);
	return ns;
}

stmt *
stmt_derive(stmt *s, stmt *t)
{
	stmt *ns = stmt_create(st_derive);

	ns->op1.stval = s;
	ns->op2.stval = t;
	ns->nrcols = s->nrcols;
	ns->key = 0;
	ns->h = stmt_dup(s->h);
	ns->t = stmt_dup(s->t);
	return ns;
}

void
grp_destroy(group *g)
{
	if (sql_ref_dec(&g->ref) == 0) {
		stmt_destroy(g->grp);
		stmt_destroy(g->ext);
		_DELETE(g);
	}
}

group *
grp_dup(group *g)
{
	if (g)
		sql_ref_inc(&g->ref);
	return g;
}

group *
grp_create(stmt *s, group *og)
{
	group *g = NEW(group);

	sql_ref_init(&g->ref);
	if (og) {
		g->grp = stmt_derive(stmt_dup(og->grp), s);
		grp_destroy(og);
	} else {
		g->grp = stmt_group(s);
	}
	g->ext = stmt_ext(stmt_dup(g->grp));
	return g;
}

void 
grp_done(group *g)
{
	if (g && g->grp)
		g->grp->flag = GRP_DONE;
}

void
cond_stmt_destroy(stmt *s)
{
	if (s)
		stmt_destroy(s);
}

void
stmt_destroy(stmt *s)
{
	if (sql_ref_dec(&s->ref) == 0) {
		switch (s->type) {
			/* stmt_destroy  op1 */
		case st_relselect:
		case st_connection:
			list_destroy(s->op1.lval);
			break;
		case st_releqjoin: 
			list_destroy(s->op1.lval);
			list_destroy(s->op2.lval);
			break;
		case st_reljoin:
			if (s->op1.stval)
				stmt_destroy(s->op1.stval);
			if (s->op2.lval)
				list_destroy(s->op2.lval);
			break;

		case st_diff:
		case st_union:
		case st_join:
		case st_join2:
		case st_joinN:
		case st_outerjoin:
		case st_derive:
		case st_unique:
		case st_alias:
		case st_append:
		case st_rs_column:

		case st_while:
		case st_if:
		case st_return:
		case st_assign:
		case st_exception:
		case st_trans:
		case st_catalog:

			if (s->op1.stval)
				stmt_destroy(s->op1.stval);
			if (s->op2.stval)
				stmt_destroy(s->op2.stval);
			if (s->op3.stval)
				stmt_destroy(s->op3.stval);
			break;

		case st_list:
			list_destroy(s->op1.lval);
			break;
		case st_var:
			if (s->op1.sval)
				_DELETE(s->op1.sval);
			break;

			/* reference only independently managed resources */
		case st_table:
			stmt_destroy(s->op1.stval); 
			break;
		case st_basetable:
		case st_table_clear:
			if (s->op2.sval)
				_DELETE(s->op2.sval);
		case st_bat:
		case st_dbat:
		case st_idxbat:
		case st_none:
			break;

			/* special cases */
		case st_temp:
		case st_single:
			if (s->op1.stval)
				stmt_destroy(s->op1.stval);

		case st_append_col:
		case st_update_col:
		case st_append_idx:
		case st_update_idx:
		case st_delete:
			if (s->op2.stval)
				stmt_destroy(s->op2.stval);
			if (s->op3.stval)
				stmt_destroy(s->op3.stval);
			break;

		case st_export:
			if (s->op1.stval)
				stmt_destroy(s->op1.stval);
			if (s->op4.stval) {
				if (s->op2.lval == NULL || s->op2.lval->h->data)
					stmt_destroy(s->op4.stval);
				else
					list_destroy(s->op4.lval);
			}
			if (s->op2.lval)
				list_destroy(s->op2.lval);
			break;
		case st_aggr:
			if (s->op1.stval)
				stmt_destroy(s->op1.stval);
			if (s->op2.stval)
				stmt_destroy(s->op2.stval);
			if (s->op3.stval)
				stmt_destroy(s->op3.stval);
			sql_subaggr_destroy(s->op4.aggrval);
			break;
		case st_convert:
			if (s->op1.stval)
				stmt_destroy(s->op1.stval);
			break;
		case st_unop:
		case st_binop:
		case st_Nop:
			if (s->op1.stval)
				stmt_destroy(s->op1.stval);
			if (s->op2.stval)
				stmt_destroy(s->op2.stval);
			if (s->op3.stval)
				stmt_destroy(s->op3.stval);
			sql_subfunc_destroy(s->op4.funcval);
			break;
		case st_atom:
			atom_destroy(s->op1.aval);
			break;

			/* simple case of statements of only statements */
		case st_const:
		case st_mark:
		case st_gen_group:
		case st_reverse:
		case st_mirror:
		case st_limit:
		case st_order:
		case st_reorder:
		case st_ordered:
		case st_output:
		case st_affected_rows:

		case st_column:
			if (s->op1.stval)
				stmt_destroy(s->op1.stval);
			if (s->op2.stval)
				stmt_destroy(s->op2.stval);
			if (s->op3.stval)
				stmt_destroy(s->op3.stval);
			break;
		case st_group:
		case st_group_ext:

		case st_select:
		case st_select2:
		case st_selectN:
		case st_uselect:
		case st_uselect2:
		case st_uselectN:
		case st_semijoin:
			if (s->op1.stval)
				stmt_destroy(s->op1.stval);
			if (s->op2.stval)
				stmt_destroy(s->op2.stval);
			if (s->op3.stval)
				stmt_destroy(s->op3.stval);
			if (s->type != st_selectN && s->type != st_uselectN && s->op4.stval)
				stmt_destroy(s->op4.stval);
			break;
		default:
			printf("! TODO: stmt_destroy(%u=%s) !\n", s->type, st_type2string(s->type));
		}
		if (s->h)
			stmt_destroy(s->h);
		if (s->t)
			stmt_destroy(s->t);
		if (s->rewritten)
			stmt_destroy(s->rewritten);

#ifndef NDEBUG
		if (s->nr2 > 0) {
/*
 * happens far too often for now, hence, we keep it for debugging, only ...
			printf("= sql_statement.mx: stmt_destroy: (result of) statement %s (%u) was used %d times less often than its refcnt indicated!\n",
				st_type2string(s->type), s->type, s->nr2);
 */
		} else if (s->nr2 == int_nil) {
/*
 * happens far too often for now, hence, we keep it for debugging, only ...

NIELS: Because the optimizer rewrites partly inplace some parts of the
  statement tree are really not executed!
			printf("= sql_statement.mx: stmt_destroy: statement %s (%u) was never executed!\n",
				st_type2string(s->type), s->type);

 */
		} else if (s->nr2 < 0) {
			printf("= sql_statement.mx: stmt_destroy: (rssult of) statement %s (%u) was used %d times more often than its refcnt indicated!\n", st_type2string(s->type), s->type, -s->nr2);
		}
#endif

		_DELETE(s);
	}
}

static void stmt_deps( list *dep_list, stmt *s, int depend_type, int dir);

static int
id_cmp(int *id1, int *id2)
{
	if (*id1 == *id2)
		return 0;
	return -1;
}

static list *
cond_append( list *l, int *id )
{
	if (!list_find(l, id, (fcmp)&id_cmp))
		list_append(l, id);
	return l;
}

static void 
list_deps(list *dep_list, list *l, int depend_type, int dir)
{
	if (l) {
		node *n;
		for (n = l->h; n; n = n->next) 
			stmt_deps(dep_list, n->data, depend_type, dir);
	}
}

#define push(s) stack[top++] = s
#define pop()	stack[--top]
static void 
stmt_deps(list *dep_list, stmt *s, int depend_type, int dir)
{
	stmt **stack;
	int top = 0, sz = 1024;
 
	stack = NEW_ARRAY(stmt*, sz+1);
	if (stack == NULL)
		return;
	push(NULL);
	push(s);
	while((s=pop()) != NULL) {
	   if ((dir < 0 && s->optimized < 0) || (dir >=0 && s->optimized >= 0)){
		switch (s->type) {
		case st_list:
		case st_relselect:
			list_deps(dep_list, s->op1.lval, depend_type, dir);
			break;

		case st_releqjoin: 
			list_deps(dep_list, s->op1.lval, depend_type, dir);
			list_deps(dep_list, s->op2.lval, depend_type, dir);
			break;

		case st_reljoin:
			if (s->op1.stval)
				push(s->op1.stval);
			if (s->op2.lval)
				list_deps(dep_list, s->op2.lval, depend_type, dir);
			break;

		case st_diff:
		case st_alias:
		case st_union:
		case st_join:
		case st_join2:
		case st_joinN:
		case st_outerjoin:
		case st_derive:
		case st_unique:
		case st_append:
		case st_rs_column:

		case st_while:
		case st_if:
		case st_return:
		case st_assign:
		case st_exception:
			if (s->op1.stval)
				push(s->op1.stval);
			if (s->op2.stval)
				push(s->op2.stval);
			if (s->op3.stval)
				push(s->op3.stval);
			break;

			/* reference only independently managed resources */
		case st_table:
			push(s->op1.stval);
			break;
		case st_basetable:
			if (depend_type == COLUMN_DEPENDENCY) {
				dep_list = cond_append(dep_list, &s->op1.tval->base.id);	
			}
			break;
		case st_table_clear:
			if(depend_type == TRIGGER_DEPENDENCY) {
				dep_list = cond_append(dep_list, &s->op1.tval->base.id);
			}
			break;
		case st_bat:
		case st_append_col:
		case st_update_col:
			if (depend_type == COLUMN_DEPENDENCY) { 
			    	if (isTable(s->op1.cval->t)) 
					dep_list = cond_append(dep_list, &s->op1.cval->base.id);
				dep_list = cond_append(dep_list, &s->op1.cval->t->base.id);
			}
			break;
		case st_append_idx:
		case st_update_idx:
		case st_delete:
		case st_dbat:
		case st_idxbat:
		case st_none:
		case st_var:
		case st_temp:
		case st_single:
		case st_atom:
		case st_trans:
		case st_catalog:
			break;

			/* special cases */
		case st_export:
			if (s->op1.stval)
				push(s->op1.stval);
			if (s->op4.stval)
				push(s->op4.stval);
			break;
		case st_aggr:
			if (s->op1.stval)
				push(s->op1.stval);
			if (s->op2.stval)
				push(s->op2.stval);
			if (s->op3.stval)
				push(s->op3.stval);
			if (depend_type == FUNC_DEPENDENCY) {
				dep_list = cond_append(dep_list, &s->op4.funcval->func->base.id);	
			}
			break;
		case st_convert:
			if (s->op1.stval)
				push(s->op1.stval);
			break;
		case st_unop:
		case st_binop:
		case st_Nop:
			if (s->op1.stval)
				push(s->op1.stval);
			if (s->op2.stval)
				push(s->op2.stval);
			if (s->op3.stval)
				push(s->op3.stval);
			if (depend_type == FUNC_DEPENDENCY) {
				dep_list = cond_append(dep_list, &s->op4.funcval->func->base.id);	
			}
			break;
		case st_column:
			if (s->op4.tval && depend_type == VIEW_DEPENDENCY) {
				dep_list = cond_append(dep_list, &s->op4.tval->base.id);	
			}
			if (s->op1.stval && depend_type == VIEW_DEPENDENCY) 
				push(s->op1.stval);
			break;

			/* simple case of statements of only statements */
		case st_const:
		case st_mark:
		case st_gen_group:
		case st_reverse:
		case st_mirror:
		case st_limit:
		case st_order:
		case st_reorder:
		case st_ordered:
		case st_output:
		case st_affected_rows:

		case st_group:
		case st_group_ext:

		case st_select:
		case st_select2:
		case st_selectN:
		case st_uselect:
		case st_uselect2:
		case st_uselectN:
		case st_semijoin:
		case st_connection:
			if (s->op1.stval)
				push(s->op1.stval);
			if (s->op2.stval)
				push(s->op2.stval);
			if (s->op3.stval)
				push(s->op3.stval);
			if (s->type != st_selectN && s->type != st_uselectN && s->op4.stval)
				push(s->op4.stval);
			break;
		}
	    }
	    if (top+10 >= sz) {
		sz *= 2;
		stack = RENEW_ARRAY(stmt*, stack, sz);
	    }
	    if (dir < 0)
		s->optimized = 0;
	    else
		s->optimized = -1;
	}
	_DELETE(stack);
}

list* stmt_list_dependencies(stmt *s, int depend_type)
{
	list *dep_list = list_create((fdestroy) NULL);

	stmt_deps(dep_list, s, depend_type, s->optimized);
	return dep_list;
}

stmt *
stmt_none()
{
	return stmt_create(st_none);
}

stmt *
stmt_var(char *varname, sql_subtype *t, int declare, int level)
{
	stmt *s = stmt_create(st_var);

	s->op1.sval = varname;
	if (t)
		s->op2.typeval = *t;
	else
		s->op2.typeval.type = NULL;
	s->flag = declare + (level<<1);
	s->key = 1;
	return s;
}

stmt *
stmt_varnr(int nr, sql_subtype *t)
{
	stmt *s = stmt_create(st_var);

	s->op1.sval = NULL;
	if (t)
		s->op2.typeval = *t;
	else
		s->op2.typeval.type = NULL;
	s->flag = nr;
	s->key = 1;
	return s;
}

stmt *
stmt_table(stmt *cols, int temp)
{
	stmt *s = stmt_create(st_table);

	s->op1.stval = cols;
	s->flag = temp;
	return s;
}

stmt *
stmt_basetable(sql_table *t, char *name)
{
	stmt *s = stmt_create(st_basetable);

	s->op1.tval = t;
	s->op2.sval = _strdup(name);
	return s;
}

stmt *
stmt_temp(sql_subtype *t)
{
	stmt *s = stmt_create(st_temp);

	s->op4.typeval = *t;
	s->nrcols = 1;
	return s;
}

stmt *
stmt_single(sql_subtype *t)
{
	stmt *s = stmt_create(st_single);

	s->op4.typeval = *t;
	s->nrcols = 1;
	return s;
}


stmt *
stmt_column(stmt *op1, stmt *table, sql_table *t)
{
	stmt *s = stmt_create(st_column);

	s->op1.stval = op1;
	/* if not single value, its a single column ! */
	if (op1->nrcols > 0)
		s->nrcols = 1;
	s->key = op1->key;
	s->aggr = op1->aggr;
	s->h = table;	/* oid's used from this table */
	s->op4.tval = t;
	return s;
}

stmt *
stmt_bat(sql_column *c, stmt *basetable, int access )
{
	stmt *s = stmt_create(st_bat);

	s->op1.cval = c;
	s->nrcols = 1;
	s->flag = access;
	s->h = basetable;	/* oid's used from this basetable */
	return s;
}

static stmt *
stmt_tbat(sql_table *t, int access)
{
	stmt *s = stmt_create(st_dbat);

	assert(access == RD_INS);

	s->nrcols = 0;
	s->flag = access;
	s->op1.tval = t;
	return s;
}

stmt *
stmt_delta_table_bat(sql_column *c, stmt *basetable, int access )
{
	stmt *s = stmt_bat(c, basetable, access );

	if (c->t->readonly)
		return s;

	if (isTable(c->t) &&
	   (c->base.flag != TR_NEW || c->t->base.flag != TR_NEW /* alter */) &&
	    access == RDONLY && c->t->persistence == SQL_PERSIST && !c->t->commit_action) {
		stmt *i = stmt_bat(c, stmt_dup(basetable), RD_INS );
		stmt *u = stmt_bat(c, stmt_dup(basetable), RD_UPD );

		s = stmt_diff(s, u);
		s = stmt_union(s, stmt_dup(u));
		s = stmt_union(s, i);
	} 
	/* even temp tables have deletes because we like to keep void heads */
	if (access == RDONLY && isTable(c->t)) {
		stmt *d = stmt_tbat(c->t, RD_INS);
		s = stmt_diff(s, stmt_reverse(d));
	}
	return s;
}

stmt *
stmt_idxbat(sql_idx * i, int access)
{
	stmt *s = stmt_create(st_idxbat);

	s->op1.idxval = i;
	s->nrcols = 1;
	s->flag = access;
	return s;
}

stmt *
stmt_delta_table_idxbat(sql_idx * idx, int access)
{
	stmt *s = stmt_idxbat(idx, access);

	if (idx->t->readonly)
		return s;

	if (isTable(idx->t) &&
	   (idx->base.flag != TR_NEW || idx->t->base.flag != TR_NEW /* alter */) && 
	    access == RDONLY && idx->t->persistence == SQL_PERSIST && !idx->t->commit_action) {
		stmt *i = stmt_idxbat(idx, RD_INS);
		stmt *u = stmt_idxbat(idx, RD_UPD);

		s = stmt_diff(s, u);
		s = stmt_union(s, stmt_dup(u));
		s = stmt_union(s, i);
	} 
	/* even temp tables have deletes because we like to keep void heads */
	if (access == RDONLY && isTable(idx->t)) {
		stmt *d = stmt_tbat(idx->t, RD_INS);
		s = stmt_diff(s, stmt_reverse(d));
	}
	return s;
}

stmt *
stmt_append_col(sql_column *c, stmt *b)
{
	stmt *s = stmt_create(st_append_col);

	s->op1.cval = c;
	s->op2.stval = b;
	return s;
}

stmt *
stmt_append_idx(sql_idx *i, stmt *b)
{
	stmt *s = stmt_create(st_append_idx);

	s->op1.idxval = i;
	s->op2.stval = b;
	return s;
}

stmt *
stmt_update_col(sql_column *c, stmt *b)
{
	stmt *s = stmt_create(st_update_col);

	s->op1.cval = c;
	s->op2.stval = b;
	return s;
}

stmt *
stmt_update_idx(sql_idx *i, stmt *b)
{
	stmt *s = stmt_create(st_update_idx);

	s->op1.idxval = i;
	s->op2.stval = b;
	return s;
}

stmt *
stmt_delete(sql_table *t, stmt *b)
{
	stmt *s = stmt_create(st_delete);

	s->op1.tval = t;
	s->op2.stval = b;
	return s;
}

static stmt *
stmt_const_(stmt *s, stmt *val)
{
	stmt *ns = stmt_create(st_const);

	ns->op1.stval = s;
	ns->op2.stval = val;
	ns->nrcols = s->nrcols;
	ns->key = s->key;
	ns->aggr = s->aggr;
	ns->h = stmt_dup(s->h);
	return ns;
}

static stmt *
push_project(stmt *rows, stmt *val) 
{
	switch (val->type) {
	case st_convert:
		val->op1.stval = push_project(rows, val->op1.stval);
		break;
	case st_Nop:
		if (val->op4.funcval->func->side_effect) {
			stmt *l = val->op1.stval;
			node *n = l->op1.lval->h;
			if (n) {
				n->data = stmt_const_(stmt_dup(rows), n->data);
			} else {  /* no args, ie. change into a st_unop */
				val->type = st_unop;
				stmt_destroy(val->op1.stval);
				val->op1.stval = stmt_const_(stmt_dup(rows), stmt_atom_int(0));
			}
		} else {
			/* push through arguments of Nop */
			node *n;
			for(n=val->op1.lval->h; n; n = n->next) 
				n->data = push_project(rows, n->data);
		}
		break;
	case st_binop:
		if (val->op4.funcval->func->side_effect) {
			val->op1.stval = stmt_const_(stmt_dup(rows), val->op1.stval);
		} else {
			val->op1.stval = push_project(rows, val->op1.stval);
			val->op2.stval = push_project(rows, val->op2.stval);
		}
		break;
	case st_unop:
		if (val->op4.funcval->func->side_effect) {
			val->op1.stval = stmt_const_(stmt_dup(rows), val->op1.stval);
		} else {
			val->op1.stval = push_project(rows, val->op1.stval);
		}
		break;
	default:
		if (!val->nrcols)
			val = stmt_const_(stmt_dup(rows), val);
		return val;
	}
	val->nrcols = rows->nrcols;
	return val;
}

static int
has_side_effect(stmt *val)
{
	int se = 0;

	switch (val->type) {
	case st_convert:
		se = has_side_effect(val->op1.stval);
		break;
	case st_Nop:
		se = val->op4.funcval->func->side_effect;
		if (!se) {
			stmt *l = val->op1.stval;
			node *n;
			for (n=l->op1.lval->h; n; n = n->next) 
				se += has_side_effect(n->data);
		}
		break;
	case st_binop:
		se = val->op4.funcval->func->side_effect;
		if (!se) 
			se = has_side_effect(val->op1.stval) + 
		     	     has_side_effect(val->op2.stval);
		break;
	case st_unop:
		se = val->op4.funcval->func->side_effect;
		if (!se) 
			se = has_side_effect(val->op1.stval);
		break;
	default:
		return se;
	}
	return se;
}

stmt *
stmt_const(stmt *rows, stmt *val) 
{
	if (val && has_side_effect(val)) {
		stmt *x = push_project(rows, val);
		stmt_destroy(rows);
		return x;
	} else {
		return stmt_const_(rows, val);
	}
}

/* BEWARE stmt_mark marks the head, this while the mil mark is a mark tail
 * Current implementation adds the reverses in stmt_mark nolonger in
 * the generated code.
*/
stmt *
stmt_mark(stmt *s, int id)
{
	stmt *ns = stmt_create(st_mark);

	ns->op1.stval = stmt_reverse(s);
	ns->op2.stval = stmt_atom_oid(id);

	ns->nrcols = s->nrcols;
	ns->key = s->key;
	ns->aggr = s->aggr;
	ns->h = stmt_dup(s->t);
	return stmt_reverse(ns);
}

stmt *
stmt_mark_tail(stmt *s, int id)
{
	stmt *ns = stmt_create(st_mark);

	ns->op1.stval = s;
	ns->op2.stval = stmt_atom_oid(id);

	ns->nrcols = s->nrcols;
	ns->key = s->key;
	ns->aggr = s->aggr;
	ns->h = stmt_dup(s->h);
	return ns;
}

stmt *
stmt_gen_group(stmt *s)
{
	stmt *ns = stmt_create(st_gen_group);

	ns->op1.stval = s;

	ns->nrcols = s->nrcols;
	ns->key = 0;
	ns->aggr = 0;
	ns->h = stmt_dup(s->h);
	return ns;
}

stmt *
stmt_reverse(stmt *s)
{
	stmt *ns = stmt_create(st_reverse);

	ns->op1.stval = s;
	ns->nrcols = s->nrcols;
	ns->key = s->key;
	ns->aggr = s->aggr;
	ns->h = stmt_dup(s->t);
	ns->t = stmt_dup(s->h);
	return ns;
}

stmt *
stmt_mirror(stmt *s)
{
	stmt *ns = stmt_create(st_mirror);

	ns->op1.stval = s;
	ns->nrcols = 2;
	ns->key = s->key;
	ns->aggr = s->aggr;
	ns->h = stmt_dup(s->h);
	ns->t = stmt_dup(s->h);
	return ns;
}

stmt *
stmt_limit(stmt *s, wrd offset, wrd limit, int direction)
{
	stmt *ns = stmt_create(st_limit);

	ns->op1.stval = s;
	ns->op2.stval = stmt_atom_wrd(offset);
	ns->op3.stval = stmt_atom_wrd(limit);
	ns->nrcols = s->nrcols;
	ns->key = s->key;
	ns->aggr = s->aggr;
	ns->t = stmt_dup(s->t);
	ns->flag = direction;
	return ns;
}

stmt *
stmt_order(stmt *s, int direction)
{
	stmt *ns = stmt_create(st_order);

	ns->op1.stval = s;
	ns->flag = direction;
	ns->nrcols = s->nrcols;
	ns->key = s->key;
	ns->aggr = s->aggr;
	ns->t = stmt_dup(s->t);
	return ns;
}

stmt *
stmt_reorder(stmt *s, stmt *t, int direction)
{
	stmt *ns = stmt_create(st_reorder);

	ns->op1.stval = s;
	ns->op2.stval = t;
	ns->flag = direction;
	ns->nrcols = s->nrcols;
	ns->key = s->key;
	ns->aggr = s->aggr;
	ns->t = stmt_dup(s->t);
	return ns;
}

stmt *
stmt_unique(stmt *s, group *g)
{
	stmt *ns = stmt_create(st_unique);

	ns->op1.stval = s;
	if (g) {
		ns->op2.stval = stmt_dup(g->grp);
		grp_destroy(g);
	}
	ns->nrcols = s->nrcols;
	ns->key = 1;		/* ?? maybe change key to unique ? */
	ns->aggr = s->aggr;
	ns->t = stmt_dup(s->t);
	return ns;
}

stmt *
stmt_atom(atom *op1)
{
	stmt *s = stmt_create(st_atom);

	s->op1.aval = op1;
	s->key = 1;		/* values are also unique */
	return s;
}

stmt *
stmt_relselect_init()
{
	stmt *s = stmt_create(st_relselect);

	s->op1.lval = list_create((fdestroy) &stmt_destroy);
	s->nrcols = 0;
	return s;
}

void
stmt_relselect_fill(stmt *rs, stmt *sel)
{
	list_append(rs->op1.lval, sel);
	if (sel->nrcols > rs->nrcols)
		rs->nrcols = sel->nrcols;
	if (!rs->h)
		rs->h = stmt_dup(((stmt *) (rs->op1.lval->h->data))->h);
}

stmt *
stmt_select(stmt *op1, stmt *op2, comp_type cmptype)
{
	stmt *s = stmt_create(st_select);

	s->op1.stval = op1;
	s->op2.stval = op2;
	s->flag = cmptype;
        s->nrcols = (op1->nrcols==2)?2:1;
	s->h = stmt_dup(s->op1.stval->h);
	s->t = stmt_dup(s->op1.stval->t);
	return s;
}

stmt *
stmt_likeselect(stmt *op1, stmt *op2, stmt *op3, comp_type cmptype)
{
	stmt *s = stmt_create(st_select);

	s->op1.stval = op1;
	s->op2.stval = op2;
	s->op3.stval = op3;
	s->flag = cmptype;
        s->nrcols = (op1->nrcols==2)?2:1;
	s->h = stmt_dup(s->op1.stval->h);
	s->t = stmt_dup(s->op1.stval->t);
	return s;
}

stmt *
stmt_select2(stmt *op1, stmt *op2, stmt *op3, int cmp)
{
	stmt *s = stmt_create(st_select2);

	s->op1.stval = op1;
	s->op2.stval = op2;
	s->op3.stval = op3;
	s->flag = cmp;
        s->nrcols = (op1->nrcols==2)?2:1;
	s->h = stmt_dup(s->op1.stval->h);
	s->t = stmt_dup(s->op1.stval->t);
	return s;
}

stmt *
stmt_selectN(stmt *op1, stmt *op2, sql_subfunc *op)
{
	stmt *s = stmt_create(st_selectN);

	s->op1.stval = op1;
	s->op2.stval = op2;
	s->op4.funcval = op;
        s->nrcols = (op1->nrcols==2)?2:1;
	s->h = stmt_dup(s->op1.stval->h);
	s->t = stmt_dup(s->op1.stval->t);
	return s;
}

stmt *
stmt_uselect(stmt *op1, stmt *op2, comp_type cmptype)
{
	stmt *s = stmt_create(st_uselect);

	assert(cmptype != cmp_like && cmptype != cmp_notlike &&
	       cmptype != cmp_ilike && cmptype != cmp_notilike);
	s->op1.stval = op1;
	s->op2.stval = op2;
	s->flag = cmptype;
        s->nrcols = (op1->nrcols==2)?2:1;
	s->h = stmt_dup(s->op1.stval->h);
	return s;
}

stmt *
stmt_uselect2(stmt *op1, stmt *op2, stmt *op3, int cmp)
{
	stmt *s = stmt_create(st_uselect2);

	s->op1.stval = op1;
	s->op2.stval = op2;
	s->op3.stval = op3;
	s->flag = cmp;
        s->nrcols = (op1->nrcols==2)?2:1;
	s->h = stmt_dup(s->op1.stval->h);
	return s;
}

stmt *
stmt_uselectN(stmt *op1, stmt *op2, sql_subfunc *op)
{
	stmt *s = stmt_create(st_uselectN);

	s->op1.stval = op1;
	s->op2.stval = op2;
	s->op4.funcval = op;
        s->nrcols = (op1->nrcols==2)?2:1;
	s->h = stmt_dup(s->op1.stval->h);
	return s;
}

stmt *
stmt_semijoin(stmt *op1, stmt *op2)
{
	stmt *s = stmt_create(st_semijoin);

	s->op1.stval = op1;
	s->op2.stval = op2;
	/* assert( op1->h == op2->h ); */
	s->nrcols = op1->nrcols;
	s->key = op1->key;
	s->aggr = op1->aggr;
	s->h = stmt_dup(op1->h);
	s->t = stmt_dup(op1->t);
	return s;
}

stmt *
stmt_reljoin( stmt *op1, list *neqjoins )
{
	stmt *s = stmt_create(st_reljoin);

	s->op1.stval = op1;
	s->op2.lval = neqjoins;
	s->nrcols = 2;
	if (!op1)
		op1 = neqjoins->h->data;
	s->h = stmt_dup(op1->h);
	s->t = stmt_dup(op1->t);
	return s;
}

stmt *
stmt_releqjoin_init()
{
	stmt *s = stmt_create(st_releqjoin);

	s->op1.lval = list_create((fdestroy) &stmt_destroy);
	s->op2.lval = list_create((fdestroy) &stmt_destroy);
	s->nrcols = 2;
	return s;
}

void
stmt_releqjoin_fill(stmt *rj, stmt *lc, stmt *rc)
{
	list_append(rj->op1.lval, lc);
	list_append(rj->op2.lval, rc);
	if (!rj->h)
		rj->h = stmt_dup(((stmt *) (rj->op1.lval->h->data))->h);
	if (!rj->t)
		rj->t = stmt_dup(((stmt *) (rj->op2.lval->h->data))->h);
}

stmt *
stmt_releqjoin2(list *l1, list *l2)
{
	stmt *s = stmt_create(st_releqjoin);

	s->op1.lval = l1;
	s->op2.lval = l2;
	s->nrcols = 2;
	s->h = stmt_dup(((stmt *) (s->op1.lval->h->data))->h);
	s->t = stmt_dup(((stmt *) (s->op2.lval->h->data))->h);
	return s;
}

stmt *
stmt_releqjoin1(list *joins)
{
	list *l1 = list_create((fdestroy) &stmt_destroy);
	list *l2 = list_create((fdestroy) &stmt_destroy);
	stmt *L = NULL;
	node *n = NULL;

	for (n = joins->h; n; n = n->next) {
		stmt *l = stmt_dup(((stmt *) (n->data))->op1.stval);
		stmt *r = stmt_dup(((stmt *) (n->data))->op2.stval);

		while (l->type == st_reverse) {
			stmt *t = l;

			l = stmt_dup(l->op1.stval);
			stmt_destroy(t);
		}
		while (r->type == st_reverse) {
			stmt *t = r;

			r = stmt_dup(r->op1.stval);
			stmt_destroy(t);
		}
		if (l->t != r->t) {
			r = stmt_reverse(r);
		}
		if (L == NULL) {
			L = stmt_dup(l);
		} else if (L->h != l->h) {
			stmt *t = l;

			l = r;
			r = t;
		}
		l1 = list_append(l1, l);
		l2 = list_append(l2, r);
	}
	if (L != NULL)
		stmt_destroy(L);
	return stmt_releqjoin2(l1, l2);
}

stmt *
stmt_join(stmt *op1, stmt *op2, comp_type cmptype)
{
	stmt *s = stmt_create(st_join);

	s->op1.stval = op1;
	s->op2.stval = op2;
	s->flag = cmptype;
	s->key = op1->key;
	s->nrcols = 2;
	s->h = stmt_dup(op1->h);
	s->t = stmt_dup(op2->t);
	return s;
}

stmt *
stmt_project(stmt *op1, stmt *op2)
{
	return stmt_join(op1, op2, cmp_project);
}

stmt *
stmt_join2(stmt *l, stmt *ra, stmt *rb, int cmp)
{
	stmt *s = stmt_create(st_join2);

	s->op1.stval = l;
	s->op2.stval = ra;
	s->op3.stval = rb;
	s->flag = cmp;
	s->nrcols = 2;
	s->h = stmt_dup(l->h);
	s->t = stmt_dup(ra->h);
	return s;
}

stmt *
stmt_joinN(stmt *l, stmt *r, sql_subfunc *op)
{
	stmt *s = stmt_create(st_joinN);

	s->op1.stval = l;
	s->op2.stval = r;
	s->op4.funcval = op;
	s->nrcols = 2;
	s->h = stmt_dup(l->h);
	s->t = stmt_dup(r->h);
	return s;
}

stmt *
stmt_outerjoin(stmt *op1, stmt *op2, comp_type cmptype)
{
	stmt *s = stmt_create(st_outerjoin);

	s->op1.stval = op1;
	s->op2.stval = op2;
	s->flag = cmptype;
	s->nrcols = 2;
	s->h = stmt_dup(op1->h);
	s->t = stmt_dup(op2->t);
	return s;
}

stmt *
stmt_diff(stmt *op1, stmt *op2)
{
	stmt *s = stmt_create(st_diff);

	s->op1.stval = op1;
	s->op2.stval = op2;
	s->nrcols = op1->nrcols;
	s->key = op1->key;
	s->aggr = op1->aggr;
	s->h = stmt_dup(op1->h);
	s->t = stmt_dup(op1->t);
	return s;
}

stmt *
stmt_union(stmt *op1, stmt *op2)
{
	stmt *s = stmt_create(st_union);

	s->op1.stval = op1;
	s->op2.stval = op2;
	s->nrcols = op1->nrcols;
	s->h = stmt_dup(op1->h);
	s->t = stmt_dup(op1->t);
	return s;
}

stmt *
stmt_rs_column(stmt *rs, stmt *name, sql_subtype *tpe)
{
	stmt *s = stmt_create(st_rs_column);

	s->op1.stval = rs;
	s->op2.stval = name;
	s->op4.typeval = *tpe;
	s->nrcols = 1;
	s->key = 0;
	s->h = NULL;
	s->t = NULL;
	return s;
}

stmt *
stmt_export(stmt *t, char *sep, char *rsep, char *ssep, char *null_string, stmt *file)
{
	stmt *s = stmt_create(st_export);

	s->op1.stval = t;
	s->op2.lval = list_create((fdestroy)& GDKfree);
	list_append(s->op2.lval, sep);
	list_append(s->op2.lval, rsep);
	list_append(s->op2.lval, ssep);
	list_append(s->op2.lval, null_string);
	s->op4.stval = file;
	return s;
}

stmt *
stmt_trans(int type, stmt *chain, stmt *name)
{
	stmt *s = stmt_create(st_trans);

	s->op1.stval = chain;
	s->op2.stval = name;
	s->flag = type;
	return s;
}

stmt *
stmt_catalog(int type, stmt *sname, stmt *auth, stmt *action)
{
	stmt *s = stmt_create(st_catalog);

	s->op1.stval = sname;
	s->op2.stval = auth;
	s->op3.stval = action;
	s->flag = type;
	return s;
}

void
stmt_set_nrcols(stmt *s)
{
	int nrcols = 0;
	int key = 1;
	node *n;
	list *l = s->op1.lval;

	assert(s->type == st_list);
	for (n = l->h; n; n = n->next) {
		stmt *f = n->data;

		if (f->nrcols > nrcols)
			nrcols = f->nrcols;
		key &= f->key;
	}
	s->nrcols = nrcols;
	s->key = key;
}

stmt *
stmt_list(list *l)
{
	stmt *s = stmt_create(st_list);

	s->op1.lval = l;
	stmt_set_nrcols(s);
	return s;
}

stmt *
stmt_ordered(stmt *order, stmt *res)
{
	stmt *ns = stmt_create(st_ordered);

	ns->type = st_ordered;
	ns->op1.stval = order;
	ns->op2.stval = res;
	ns->nrcols = res->nrcols;
	ns->key = res->key;
	ns->aggr = res->aggr;
	ns->t = stmt_dup(res->t);
	return ns;
}

stmt *
stmt_output(stmt *l)
{
	stmt *s = stmt_create(st_output);

	s->op1.stval = l;
	return s;
}

stmt *
stmt_affected_rows(stmt *l)
{
	stmt *s = stmt_create(st_affected_rows);

	s->op1.stval = l;
	return s;
}

stmt*
stmt_connection(int *id, char *server, int *port, char *db, char * db_alias, char *user, char *passwd, char *lang)
{
	stmt *s = stmt_create(st_connection);
	s->op1.lval = list_create((fdestroy) GDKfree);

	if (*id != 0)
		list_append(s->op1.lval, id);
	if (server)
		list_append(s->op1.lval, server);
	if (*port != -1)
		list_append(s->op1.lval, port);
	if (db)
		list_append(s->op1.lval, db);
	if (db_alias)
		list_append(s->op1.lval, db_alias);
	if (user)
		list_append(s->op1.lval, user);
	if (passwd)
		list_append(s->op1.lval, passwd);
	if (lang)
		list_append(s->op1.lval, lang);

	return s;
}

stmt *
stmt_append(stmt *c, stmt *a)
{
	stmt *s = stmt_create(st_append);

	s->op1.stval = c;
	s->op2.stval = a;
	s->h = stmt_dup(c->h);
	s->t = stmt_dup(c->t);
	s->nrcols = c->nrcols;
	s->key = c->key;
	return s;
}

stmt *
stmt_table_clear(sql_table *t)
{
	stmt *s = stmt_create(st_table_clear);

	s->op1.tval = t;
	s->nrcols = 0;
	return s;
}

stmt *
stmt_exception(stmt *cond, char *errstr, int errcode)
{
	stmt *s = stmt_create(st_exception);

	assert(cond);
	s->op1.stval = cond;
	s->op2.stval = stmt_atom_string(errstr);
	s->op3.stval = stmt_atom_int(errcode);
	s->nrcols = 0;
	return s;
}


stmt *
stmt_convert(stmt *v, sql_subtype *from, sql_subtype *to)
{
	stmt *s = stmt_create(st_convert);

	s->op1.stval = v;
	s->op3.typeval = *from;
	s->op4.typeval = *to;
	s->nrcols = 0;		/* function without arguments returns single value */
	s->h = stmt_dup(v->h);
	s->key = v->key;
	s->nrcols = v->nrcols;
	s->aggr = v->aggr;
	return s;
}

stmt *
stmt_unop(stmt *op1, sql_subfunc *op)
{
	stmt *s = stmt_create(st_unop);

	s->op1.stval = op1;
	assert(op);
	s->op4.funcval = op;
	s->h = stmt_dup(op1->h);
	s->nrcols = op1->nrcols;
	s->key = op1->key;
	s->aggr = op1->aggr;
	return s;
}

stmt *
stmt_binop(stmt *op1, stmt *op2, sql_subfunc *op)
{
	stmt *s = stmt_create(st_binop);
	int aggr = 0;

	s->op1.stval = op1;
	s->op2.stval = op2;
	assert(op);
	s->op4.funcval = op;
	aggr = op1->aggr;
	if (!aggr)
		aggr = op2->aggr;
	if (op1->nrcols > op2->nrcols) {
		s->h = stmt_dup(op1->h);
		s->nrcols = op1->nrcols;
		s->key = op1->key;
	} else {
		s->h = stmt_dup(op2->h);
		s->nrcols = op2->nrcols;
		s->key = op2->key;
	}
	s->aggr = aggr;
	return s;
}

stmt *
stmt_Nop(stmt *ops, sql_subfunc *op)
{
	node *n;
	stmt *o = NULL, *s = stmt_create(st_Nop);

	s->op1.stval = ops;
	assert(op);
	s->op4.funcval = op;
	if (list_length(ops->op1.lval)) {
		for (n = ops->op1.lval->h, o = n->data; n; n = n->next) {
			stmt *c = n->data;
	
			if (o->nrcols < c->nrcols)
				o = c;
		}
	}

	if (o) {
		s->h = stmt_dup(o->h);
		s->nrcols = o->nrcols;
		s->key = o->key;
		s->aggr = o->aggr;
	} else {
		s->nrcols = 0;
		s->key = 1;
	}
	return s;
}

stmt *
stmt_aggr(stmt *op1, group *grp, sql_subaggr *op, int reduce)
{
	stmt *s = stmt_create(st_aggr);

	s->op1.stval = op1;
	if (grp) {
		s->op2.stval = stmt_dup(grp->grp);
		s->op3.stval = stmt_dup(grp->ext);
		s->nrcols = 1;
		s->h = stmt_dup(grp->grp->h);
		grp_destroy(grp);
	} else {
		if (!reduce)
			s->nrcols = 1;
		s->h = stmt_dup(op1->h);
	}
	s->key = reduce;
	s->aggr = reduce;
	s->op4.aggrval = op;
	s->flag = 0;
	return s;
}

stmt *
stmt_aggr2(stmt *op1, stmt *op2, sql_subaggr *op)
{
	stmt *s = stmt_create(st_aggr);

	s->op1.stval = op1;
	s->op2.stval = op2;
	s->nrcols = 1;
	s->nrcols = 0;
	s->h = stmt_dup(op1->h);
	s->key = 1;
	s->aggr = 1;
	s->op4.aggrval = op;
	s->flag = 1;
	return s;
}

stmt *
stmt_alias(stmt *op1, char *tname, char *alias)
{
	stmt *s = stmt_create(st_alias);

	s->op1.stval = op1;
	if (tname)
		s->op2.stval = stmt_atom_string(tname);
	s->op3.stval = stmt_atom_string(alias);
	s->h = stmt_dup(op1->h);
	s->t = stmt_dup(op1->t);
	s->nrcols = op1->nrcols;
	s->key = op1->key;
	s->aggr = op1->aggr;
	return s;
}

stmt *
stmt_dup(stmt *s)
{
	if (s)
		sql_ref_inc(&s->ref);
	return s;
}

sql_subtype *
tail_type(stmt *st)
{
	switch (st->type) {
	case st_const:
	case st_join:
	case st_outerjoin:
		return tail_type(st->op2.stval);
	case st_join2:
	case st_joinN:
		/* The tail type of a join2 is the head of the second operant!,
		   ie should be 'oid' */
		return head_type(st->op2.stval);
	case st_releqjoin:
		/* The tail type of a releqjoin is the head of the second list!,
		   ie should be 'oid' */
		return head_type(st->op2.lval->h->data);
	case st_reljoin:
		if (st->op1.stval)
			return tail_type(st->op1.stval);
		else
			return tail_type(st->op2.lval->h->data);

	case st_diff:
	case st_select:
	case st_select2:
	case st_selectN:
	case st_uselect:
	case st_uselect2:
	case st_uselectN:
	case st_limit:
	case st_semijoin:
	case st_unique:
	case st_union:
	case st_append:
	case st_alias:
	case st_column:
	case st_gen_group:
	case st_order:
		return tail_type(st->op1.stval);

	case st_list:
		return tail_type(st->op1.lval->h->data);

	case st_bat:
		return &st->op1.cval->type;
	case st_idxbat:
		if (hash_index(st->op1.idxval->type)) {
			return sql_bind_localtype("wrd");
		} else if (st->op1.idxval->type == join_idx) {
			return sql_bind_localtype("oid");
		}
	case st_mark:
	case st_reorder:
	case st_group:
	case st_derive:
	case st_group_ext:
		return sql_bind_localtype("oid");
	case st_table_clear:
		return sql_bind_localtype("lng");
	case st_mirror:
	case st_reverse:
		return head_type(st->op1.stval);

	case st_aggr:
		return &st->op4.aggrval->res;
	case st_unop:
	case st_binop:
	case st_Nop:
		return &st->op4.funcval->res;
	case st_atom:
		return atom_type(st->op1.aval);
	case st_convert:
	case st_temp:
	case st_single:
	case st_rs_column:
		return &st->op4.typeval;
	case st_var:
		if (st->op2.typeval.type)
			return &st->op2.typeval;
		/* fall through */
	case st_exception:
		return NULL;
	case st_table:
		return sql_bind_localtype("bat");
	case st_relselect:
	default:
		fprintf(stderr, "missing tail type %u: %s\n", st->type, st_type2string(st->type));
		assert(0);
		return NULL;
	}
}

sql_subtype *
head_type(stmt *st)
{
	switch (st->type) {
	case st_aggr:
	case st_convert:
	case st_unop:
	case st_binop:
	case st_Nop:
	case st_unique:
	case st_union:
	case st_alias:
	case st_diff:
	case st_join:
	case st_join2:
	case st_joinN:
	case st_outerjoin:
	case st_semijoin:
	case st_mirror:
	case st_select:
	case st_select2:
	case st_selectN:
	case st_uselect:
	case st_uselect2:
	case st_uselectN:
	case st_column:
	case st_append:
	case st_gen_group:
	case st_group:
	case st_group_ext:
	case st_order:
	case st_mark:
		return head_type(st->op1.stval);
	case st_relselect:
	case st_releqjoin:
		return head_type(st->op1.lval->h->data);

	case st_reljoin:
		if (st->op1.stval)
			return head_type(st->op1.stval);
		else
			return head_type(st->op2.lval->h->data);

	case st_list:
		return head_type(st->op1.lval->h->data);

	case st_temp:
	case st_single:
	case st_bat:
	case st_idxbat:
	case st_const:
	case st_rs_column:
		return sql_bind_localtype("oid");
		/* return NULL; oid */

	case st_reverse:
		return tail_type(st->op1.stval);
	case st_atom:
		return atom_type(st->op1.aval);
	case st_var:
		if (st->op2.typeval.type)
			return &st->op2.typeval;
	default:
		fprintf(stderr, "missing head type %u: %s\n", st->type, st_type2string(st->type));
		return NULL;
	}
}

int
stmt_has_null( stmt *s )
{
	switch (s->type) {
	case st_aggr:
	case st_Nop:
	case st_select:
	case st_select2:
	case st_selectN:
	case st_uselect:
	case st_uselect2:
	case st_uselectN:
	case st_atom:
		return 0;
	case st_unop:
	case st_reverse:
	case st_mark:
		return stmt_has_null(s->op1.stval);
	case st_binop:
		return stmt_has_null(s->op1.stval) + stmt_has_null(s->op2.stval);
	case st_join:
		return stmt_has_null(s->op2.stval);
	case st_bat:
		return s->op1.cval->null;

	default:
		return 1;
	}
}

static char *
func_name(char *n1, char *n2)
{
	int l1 = _strlen(n1), l2; 

	if (!n2)
		return _strdup(n1);
	l2 = _strlen(n2);

	if (l2 > 16) {		/* only support short names */
		char *ns = NEW_ARRAY(char, l2 + 1);

		strncpy(ns, n2, l2);
		ns[l2] = 0;
		return ns;
	} else {
		char *ns = NEW_ARRAY(char, l1 + l2 + 2), *s = ns;

		strncpy(ns, n1, l1);
		ns += l1;
		*ns++ = '_';
		strncpy(ns, n2, l2);
		ns += l2;
		*ns = '\0';
		return s;
	}
}

char *
column_name(stmt *st)
{
	switch (st->type) {
	case st_reverse:
	case st_order:
	case st_reorder:
		return column_name(st->op1.stval);
	case st_const:
	case st_join:
	case st_join2:
	case st_joinN:
	case st_outerjoin:
	case st_derive:
	case st_rs_column:
		return column_name(st->op2.stval);

	case st_mirror:
	case st_group:
	case st_group_ext:
	case st_column:
	case st_union:
	case st_append:
	case st_mark:
	case st_gen_group:
	case st_select:
	case st_select2:
	case st_selectN:
	case st_uselect:
	case st_uselect2:
	case st_uselectN:
	case st_limit:
	case st_semijoin:
	case st_diff:
	case st_unique:
	case st_convert:
		return column_name(st->op1.stval);

	case st_unop:
	case st_binop:
	case st_Nop:
	{
		char *cn = column_name(st->op1.stval);
		char *r = func_name(st->op4.funcval->func->base.name, cn);

		if (cn) _DELETE(cn);
		return r;
	}
	case st_aggr:
	{
		char *cn = column_name(st->op1.stval);
		char *r = func_name(st->op4.aggrval->aggr->base.name, cn);

		if (cn) _DELETE(cn);
		return r;
	}
	case st_alias:
		return column_name(st->op3.stval);
	case st_bat:
		return _strdup(st->op1.cval->base.name);
	case st_atom:
		if (st->op1.aval->data.vtype == TYPE_str)
			return atom2string(st->op1.aval);
	case st_var:
	case st_temp:
	case st_single:
		return _strdup("single_value");

	case st_relselect:
	case st_releqjoin:
	case st_reljoin:
	case st_list:
		if (list_length(st->op1.lval))
			return column_name(st->op1.lval->h->data);
		return NULL;
	default:
		fprintf(stderr, "missing column name %u: %s\n", st->type, st_type2string(st->type));
		return NULL;
	}
}

char *
table_name(stmt *st)
{
	switch (st->type) {
	case st_reverse:
		return table_name(st->op1.stval);
	case st_const:
	case st_join:
	case st_join2:
	case st_joinN:
	case st_outerjoin:
	case st_derive:
		return table_name(st->op2.stval);
	case st_mirror:
	case st_group:
	case st_group_ext:
	case st_column:
	case st_union:
	case st_append:
	case st_mark:
	case st_gen_group:
	case st_select:
	case st_select2:
	case st_selectN:
	case st_uselect:
	case st_uselect2:
	case st_uselectN:
	case st_limit:
	case st_semijoin:
	case st_diff:
	case st_aggr:
	case st_unique:
		return table_name(st->op1.stval);

	case st_basetable:
	case st_table_clear:
		if (st->op2.sval)
			return _strdup(st->op2.sval);
		return _strdup(st->op1.tval->base.name);
	case st_bat:
		return table_name(st->h);
	case st_alias:
		if (st->op2.stval)
			return table_name(st->op2.stval);
		else
			/* there are no table aliases, ie look into the base column */
			return table_name(st->op1.stval);
	case st_atom:
		if (st->op1.aval->data.vtype == TYPE_str && st->op1.aval->data.val.sval && _strlen(st->op1.aval->data.val.sval))
			return atom2string(st->op1.aval);

	case st_var:
	case st_temp:
	case st_single:
	case st_relselect:
	case st_releqjoin:
	case st_reljoin:
	default:
		return NULL;
	}
}

char *
schema_name(stmt *st)
{
	switch (st->type) {
	case st_reverse:
		return schema_name(st->op1.stval);
	case st_const:
	case st_join:
	case st_join2:
	case st_joinN:
	case st_outerjoin:
	case st_derive:
		return schema_name(st->op2.stval);
	case st_mirror:
	case st_group:
	case st_group_ext:
	case st_union:
	case st_append:
	case st_mark:
	case st_gen_group:
	case st_select:
	case st_select2:
	case st_selectN:
	case st_uselect:
	case st_uselect2:
	case st_uselectN:
	case st_limit:
	case st_semijoin:
	case st_diff:
	case st_unique:
	case st_convert:
	case st_unop:
	case st_binop:
	case st_Nop:
	case st_aggr:
		return schema_name(st->op1.stval);
	case st_alias:
		/* there are no schema aliases, ie look into the base column */
		return schema_name(st->op1.stval);
	case st_bat:
		return _strdup(st->op1.cval->t->s->base.name);
	case st_column:
		if (st->op4.tval)
			return _strdup(st->op4.tval->s->base.name);
		return schema_name(st->op1.stval);
	case st_atom:
		return NULL;
	case st_var:
	case st_temp:
	case st_single:
		return NULL;
	case st_relselect:
	case st_releqjoin:
	case st_reljoin:
	case st_list:
		if (list_length(st->op1.lval))
			return schema_name(st->op1.lval->h->data);
		return NULL;
	default:
		return NULL;
	}
}

stmt *stmt_while(stmt *cond, stmt *whilestmts )
{
	stmt *s = stmt_create(st_while);

	s->op1.stval = cond;
	s->op2.stval = whilestmts;
	return s;
}

stmt *stmt_if(stmt *cond, stmt *ifstmts, stmt *elsestmts)
{
	stmt *s = stmt_create(st_if);

	s->op1.stval = cond;
	s->op2.stval = ifstmts;
	s->op3.stval = elsestmts;
	return s;
}

stmt *stmt_return(stmt *val, int nr_declared_tables)
{
	stmt *s = stmt_create(st_return);

	s->op1.stval = val;
	s->flag = nr_declared_tables;
	return s;
}

stmt *stmt_assign(char *varname, stmt *val, int level)
{
	stmt *s = stmt_create(st_assign);

	s->op1.stval = stmt_atom_string(_strdup(varname));
	s->op2.stval = val;
	s->flag = (level<<1);
	return s;
}

static int 
stmt_stmt2dot(stmt *s, int l, int *i, FILE *fp)
{
	node *n;
	int j;

	assert(s);
	if (s->optimized >= l) {
		s->optimized = --(*i);
		fprintf(fp,"id%d[label=\"%s\\n",
			-(s->optimized), st_type2string(s->type));
/*
		if (s->ref.refcnt)
			fprintf(fp," refcnt=%d", s->ref.refcnt);
		if (s->nrcols)
			fprintf(fp," nrcols=%d", (int)s->nrcols);
*/
		if (s->key)
			fprintf(fp," key=%d", (int)s->key);
		if (s->aggr)
			fprintf(fp," aggr=%d", (int)s->aggr);
		if (s->flag)
			fprintf(fp," flag=%d", (int)s->flag);
		if (s->h)
			fprintf(fp," h=%p", s->h);
		if (s->t)
			fprintf(fp," t=%p", s->t);
		fprintf(fp," ptr=%p", s);

		switch (s->type) {
		case st_append_col:
		case st_update_col:
		case st_bat:
			fprintf(fp," column='%s'", s->op1.cval->base.name);
			break;
		case st_atom:
			if (s->op1.aval) 
				fprintf(fp," value='%s'", 
					atom2string(s->op1.aval));
			break;
		default:
			break;
		}
		fprintf(fp," \\n");
		fprintf(fp,"\" ];\n");		

		switch (s->type) {
		case st_relselect:
		case st_releqjoin:
			if (s->op1.lval)
			    for (j=1, n=s->op1.lval->h; n; n=n->next, j++)
				fprintf(fp, "id%d -> id%d [headlabel=\"1.%d\"];\n",
					stmt_stmt2dot(n->data, l, i, fp), -(s->optimized), j);
			if (s->op2.lval)
			    for (j=1, n=s->op2.lval->h; n; n=n->next, j++)
				fprintf(fp, "id%d -> id%d [headlabel=\"2.%d\"];\n",
					stmt_stmt2dot(n->data, l, i, fp), -(s->optimized), j);
			break;

		case st_reljoin:
			if (s->op1.stval)
				fprintf(fp, "id%d -> id%d [headlabel=\"1\"];\n",
					stmt_stmt2dot(s->op1.stval, l, i, fp), -(s->optimized));
			if (s->op2.lval)
			    for (j=1, n=s->op2.lval->h; n; n=n->next, j++)
				fprintf(fp, "id%d -> id%d [headlabel=\"2.%d\"];\n",
					stmt_stmt2dot(n->data, l, i, fp), -(s->optimized), j);
			break;

		case st_list:
			if (s->op1.lval)
			    for (j=1, n=s->op1.lval->h; n; n=n->next, j++)
				fprintf(fp, "id%d -> id%d [headlabel=\"1.%d\"];\n",
					stmt_stmt2dot(n->data, l, i, fp), -(s->optimized), j);


			break;

		case st_var:
			if (s->op1.sval) {
				fprintf(fp,"var_%s[label=\"var '%s'\",shape=ellipse];\n", s->op1.sval, s->op1.sval);
				fprintf(fp, "var_%s -> id%d [headlabel=\"1\"];\n",
					s->op1.sval, -(s->optimized));
			} else {
				fprintf(fp,"var_%d[label=\"var '%d'\",shape=ellipse];\n", s->flag, s->flag);
				fprintf(fp, "var_%d -> id%d [headlabel=\"1\"];\n",
					s->flag, -(s->optimized));
			}
			break;

		/* reference only independently managed resources */
		case st_basetable:
		case st_dbat:
		case st_delete:
			fprintf(fp,"table_%s[label=\"table '%s'\",shape=ellipse];\n", s->op1.tval->base.name, s->op1.tval->base.name);
			fprintf(fp, "table_%s -> id%d [headlabel=\"1\"];\n",
				s->op1.tval->base.name, -(s->optimized));
			break;
			
		case st_append_idx:
		case st_update_idx:
		case st_idxbat:
			fprintf(fp,"index_%s[label=\"index '%s'\",shape=ellipse];\n", s->op1.idxval->base.name, s->op1.idxval->base.name);
			fprintf(fp, "index_%s -> id%d [headlabel=\"1\"];\n",
				s->op1.idxval->base.name, -(s->optimized));
			break;

		case st_none:
			break;

		case st_convert:
			if (s->op1.stval) 
				fprintf(fp, "id%d -> id%d [headlabel=\"1\"];\n",
					stmt_stmt2dot(s->op1.stval, l, i, fp), -(s->optimized));
			break;

		/* large group with only up till 3 operants */ 
		case st_column:
		case st_temp:
		case st_single:
		case st_aggr:
		case st_unop: case st_binop: case st_Nop:
		case st_diff: case st_union:
		case st_join: case st_join2: case st_joinN: case st_outerjoin:
		case st_derive:
		case st_unique:
		case st_alias:
		case st_append: 
		case st_exception:
	  	case st_rs_column:

		case st_const: case st_mark: case st_gen_group:
		case st_reverse: case st_mirror:
		case st_limit: case st_order: case st_reorder:
		case st_ordered: case st_output: case st_affected_rows:

		case st_group: case st_group_ext:

		case st_select: case st_select2: case st_selectN:
		case st_uselect: case st_uselect2: case st_uselectN:
		case st_semijoin:

		case st_export:
			if (s->op1.stval) 
				fprintf(fp, "id%d -> id%d [headlabel=\"1\"];\n",
					stmt_stmt2dot(s->op1.stval, l, i, fp), -(s->optimized));
			if (s->type == st_export && s->op4.stval) 
				fprintf(fp, "id%d -> id%d [headlabel=\"4\"];\n",
					stmt_stmt2dot(s->op4.stval, l, i, fp), -(s->optimized));
			break;

		case st_trans:
		case st_catalog:
		case st_atom:
		case st_bat:
			break;
		default:
			printf("! TODO: stmt_stmt2dot(%u=%s) !\n",s->type,st_type2string(s->type));
			assert(0);
		}
		if (s->h) 
			fprintf(fp, "id%d -> id%d [headlabel=\"h\",color=green];\n",
				stmt_stmt2dot(s->h, l, i, fp), -(s->optimized));
		if (s->t) 
			fprintf(fp, "id%d -> id%d [headlabel=\"t\",color=orange];\n",
				stmt_stmt2dot(s->t, l, i, fp), -(s->optimized));
	}

	return -(s->optimized);
}

int 
stmt2dot(stmt *s, int i, char *fn)
{
	FILE *fp = fopen(fn, "w");
	if (fp) {
		int res = 0; 

		i *= -10;
		fprintf(fp, "\ndigraph %d {\nnode[shape=box,fontname=Helvetica];\nedge[labelfontname=Helvetica,labelfontcolor=red];\n", i);
		res = stmt_stmt2dot(s, i, &i, fp);
		fprintf(fp, "}\n");
		fclose(fp);
		return res;
	}
	return -1;
}

static void dump1(stmt *s, char *name, int *nr)
{
	int o1 = 0;

	if (s->op1.stval)
		o1 = print_stmt(s->op1.stval, nr);

	printf("s%d = %s( s%d );\n", -s->nr, name, o1);
}

static void dump2(stmt *s, char *name, int *nr)
{
	int o1 = 0, o2 = 0;

	if (s->op1.stval)
		o1 = print_stmt(s->op1.stval, nr);
	if (s->op2.stval)
		o2 = print_stmt(s->op2.stval, nr);

	printf("s%d = %s( s%d, s%d );\n", -s->nr, name, o1, o2);
}

static void dump3(stmt *s, char *name, int *nr)
{
	int o1 = 0, o2 = 0, o3 = 0;

	if (s->op1.stval)
		o1 = print_stmt(s->op1.stval, nr);
	if (s->op2.stval)
		o2 = print_stmt(s->op2.stval, nr);
	if (s->op3.stval)
		o3 = print_stmt(s->op3.stval, nr);

	printf("s%d = %s( s%d, s%d, s%d );\n", -s->nr, name, o1, o2, o3);
}


int 
print_stmt(stmt *s, int *nr)
{
	node *n;
	str a;

	assert(s);
	if (s->nr > 0)
		return s->nr;

	if (s->nr == 0)
		s->nr = -(*nr)++;

	switch(s->type) {
	case st_none: 	
	case st_temp:
	case st_single:
	case st_unique:
		 	printf("temp,unique,none\n"); break;
	case st_exception:
		 	printf("exception\n"); break;
	case st_rs_column:
	case st_export:
			printf("export\n"); break;
	case st_trans:
			printf("trans\n"); break;
	case st_catalog:
			printf("catalog\n"); break;
	case st_affected_rows: 
	case st_while: 
	case st_if: 
	case st_return: 
	case st_assign: 
			printf("psm\n"); break;
	case st_var:	
			if (s->op1.sval) 
				printf("s%d = var(%s)\n", -s->nr, s->op1.sval);
			else 
				printf("s%d = A%d\n", -s->nr, s->flag);
			break;
	case st_atom:	a = atom2string(s->op1.aval);
			printf("s%d = %s\n", -s->nr, a);
			GDKfree(a);
			break;
	case st_column:  s->nr = -print_stmt(s->op1.stval, nr); break;
				
	case st_bat: 	 printf("s%d = Column(\"%s\".\"%s\".\"%s\", %d);\n", -s->nr, s->op1.cval->t->s->base.name, s->op1.cval->t->base.name, s->op1.cval->base.name, s->flag); break;
	case st_dbat:    printf("s%d = Table(\"%s\".\"%s\");\n", -s->nr, s->op1.tval->s->base.name, s->op1.tval->base.name); break;
	case st_idxbat:  printf("s%d = Index(\"%s\".\"%s\".\"%s\", %d);\n", -s->nr, s->op1.idxval->t->s->base.name, s->op1.idxval->t->base.name, s->op1.idxval->base.name, s->flag); break;
	case st_const: 	 dump2(s, "project", nr); break;
	case st_mark: 	 dump2(s, "mark", nr); break;
	case st_gen_group: dump1(s, "group", nr); break;
	case st_reverse: dump1(s, "reverse", nr); break;
	case st_mirror:  dump1(s, "mirror", nr); break;
	case st_limit:   dump3(s, "limit", nr); break;
	case st_order:   dump1(s, "order", nr); break;
	case st_reorder: dump2(s, "reorder", nr); break;
	case st_ordered: dump2(s, "ordered", nr); s->nr = -s->op1.stval->nr; break;
	case st_select:
	case st_uselect: 
			if (s->flag == cmp_like || s->flag == cmp_notlike ||
			    s->flag == cmp_ilike || s->flag == cmp_notilike)
				dump3(s, "likeselect", nr);
			else
				dump2(s, "select", nr);
			break;
	case st_select2:
	case st_uselect2:
			dump3(s, "select", nr); break;
	case st_selectN:
	case st_uselectN:
			dump2(s, "selectN", nr); break;
	case st_semijoin: dump2(s, "semijoin", nr); break;
	case st_diff:	dump2(s, "diff", nr); break;
	case st_union:	dump2(s, "union", nr); break;
	case st_outerjoin:
	case st_join:	
			if (s->flag == cmp_all)
				dump2(s, "crossproduct", nr); 
			else
				dump2(s, "join", nr); 
			break;
	case st_join2:	
			dump3(s, "join", nr); break;
	case st_joinN:	
			dump2(s, "joinN", nr); break;
	case st_group:	dump1(s, "group", nr); break;
	case st_group_ext:	dump1(s, "extent", nr); break;
	case st_derive:	dump2(s, "derive", nr); break;
	case st_convert:dump1(s, "convert", nr); break;
	case st_unop:	dump1(s, s->op4.funcval->func->imp, nr); break;
	case st_binop:	dump2(s, s->op4.funcval->func->imp, nr); break;
	case st_aggr:	
			if (s->flag)
				dump2(s, s->op4.aggrval->aggr->imp, nr);
			else
				dump1(s, s->op4.aggrval->aggr->imp, nr);
			break;
	case st_append:	dump2(s, "append", nr); break;
	case st_append_col: 
	case st_update_col: { 
			sql_column *c = s->op1.cval; 
			char *n = (s->type == st_append_col)?"append":"update";
			int r = print_stmt(s->op2.stval, nr);
			printf("s%d = %s(\"%s\".\"%s\".\"%s\", s%d);\n", -s->nr, n, c->t->s->base.name, c->t->base.name, c->base.name, r);
	} break;
	case st_append_idx: 
	case st_update_idx: {
			sql_idx *i = s->op1.idxval; 
			char *n = (s->type == st_append_idx)?"append":"update";
			int r = print_stmt(s->op2.stval, nr);
			printf("s%d = %s_idx(\"%s\".\"%s\".\"%s\", s%d);\n", -s->nr, n, i->t->s->base.name, i->t->base.name, i->base.name, r);
	} break;
	case st_delete:{
			sql_table *t = s->op1.tval;
			int r = print_stmt(s->op2.stval, nr);
			printf("s%d = delete(\"%s\".\"%s\", s%d);\n", -s->nr, t->s->base.name, t->base.name, r);
	} break;
	case st_table_clear: printf("s%d := clear(\"%s\".\"%s\");\n", -s->nr, s->op1.tval->s->base.name, s->op1.tval->base.name); break;
	case st_alias: 	dump3(s, "alias", nr); break;
	case st_output: dump1(s, "output", nr); break;
	case st_table:  dump1(s, "table", nr); break;
	case st_Nop:	
		(void)print_stmt(s->op1.stval, nr);
		printf("s%d = %s(list)\n", -s->nr, s->op4.funcval->func->imp);
		break;
	case st_list:
	case st_relselect:
		if (s->type == st_relselect) 
			printf("s%d = relselect(\n", -s->nr);
		for (n = s->op1.lval->h; n; n = n->next) 
			(void) print_stmt(n->data, nr);
		if (s->type != st_list)
			printf(")\n");
		break;
	case st_releqjoin:
		printf("s%d = releqjoin(\n", -s->nr);
		printf("R(\n");
		for (n = s->op1.lval->h; n; n = n->next) 
			(void) print_stmt(n->data, nr);
		printf(")\nL(\n");
		for (n = s->op2.lval->h; n; n = n->next) 
			(void) print_stmt(n->data, nr);
		printf("))\n");
		break;
	case st_reljoin:
		printf("s%d = reljoin(\n", -s->nr);
		if (s->op1.stval)
			print_stmt(s->op1.stval, nr);
		printf("(\n");
		if (s->op2.lval)
			for (n = s->op2.lval->h; n; n = n->next) 
				(void) print_stmt(n->data, nr);
		printf("))\n");
		break;
	case st_basetable:	
		printf("basetable\n"); break;
	case st_connection:
		printf("connection\n"); break;
	}
	s->nr = -s->nr;
	return s->nr;
}

void
Sprint(stmt *s)
{
	int nr = 0;

	(void)print_stmt(s, &nr);
}

stmt *const_column(stmt *val ) 
{
	sql_subtype *ct = tail_type(val);
	stmt *temp = stmt_temp(ct);
	return stmt_append(temp, val);
}

