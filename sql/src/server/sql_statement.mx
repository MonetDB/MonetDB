@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.

@f sql_statement
@a N.J. Nes
@* 

@h
#ifndef _SQL_STATEMENT_H_
#define _SQL_STATEMENT_H_

#include "sql_sym.h"
#include "sql_atom.h"
#include "sql_string.h"
#include "sql_mvc.h"

#define RDONLY 0
#define INS 1
#define DEL 2
#define UPD 3

#define create_stmt_list() list_create((fdestroy)&stmt_destroy)

typedef enum stmt_type {
	st_none,
	st_sql,		/* sometimes a query rewrite is easier */
	st_var,		/* still needs work */
	st_update_var,	

	st_basetable,
	st_temp,	/* temporal bat */
	st_bat,
	st_ubat,
	st_ibat,	/* intermediate table result */
	st_dbat,
	st_idxbat,
	st_const,
	st_mark,
	st_reverse,
	st_mirror,

	st_limit,
	st_order,
	st_reorder,

	st_ordered,
	st_output,

	st_atom,
	st_filter,
	st_select,
	st_select2,
	st_uselect,
	st_uselect2,
	st_semijoin,
	st_relselect,

	st_reljoin,
	st_join,
	st_outerjoin,
	st_diff,
	st_intersect,
	st_union,

	st_find,
	st_bulkinsert,
	st_append,
	st_insert,
	st_replace,
	st_exception,

	st_group_ext,
	st_group,
	st_derive,
	st_unique,
	st_op,
	st_unop,
	st_binop,
	st_Nop,
	st_aggr,

	st_alias,

	st_set,
	st_sets,

	st_ptable,  /* (R(tables) */
	st_pivot,   /* binary relation between R and input table */
	st_groupby, /* (R, groupby columns) */

	/* used internally only */
	st_list
} st_type;

typedef enum comp_type {
	cmp_gt = 0,
	cmp_gte = 1,
	cmp_lte = 2,
	cmp_lt = 3,
	cmp_equal = 4,
	cmp_notequal = 5,
	cmp_notlike = 6,
	cmp_like = 7,
	cmp_all = 8
} comp_type;

typedef struct stmt {
	sql_ref ref;

	st_type type;
	symdata op1;
	symdata op2;
	symdata op3;
	symdata op4;		/* only op4 will hold other types */

	char nrcols;
	char key;		/* key (aka all values are unique) */
	char aggr;		/* aggregated */

	int flag;

	int nr; 		/* variable assignement */
	int nr2;		/* usage count */

	struct stmt *h;
	struct stmt *t;
	int optimized;
	struct stmt *rewritten;
} stmt;

typedef struct group {
	sql_ref ref;

	stmt *grp;
	stmt *ext;
	list *cols; /* list of group by columns */
} group;

sql_export const char * st_type2string(st_type type);

extern stmt *stmt_none();
extern stmt *stmt_sql( char *query );
extern stmt *stmt_var( char *varname, sql_subtype *t);
extern stmt *stmt_varnr(int nr, sql_subtype *t);
extern stmt *stmt_update_var( char *varname );

extern stmt *stmt_basetable(sql_table *t, char *tname); 

#define isbasetable(s) (s->type == st_basetable)
#define basetable_table(s) s->op1.tval 

#define ptable_pivots(s) 	((s)->op1.lval)
#define ptable_parent(s)	((s)->op2.stval)
#define ptable_statements(s) 	((s)->op3.stval)

extern stmt *stmt_cbat(sql_column * c, stmt * basetable, int access, st_type type);
extern stmt *stmt_ibat(stmt * i, stmt * basetable );
extern stmt *stmt_tbat(sql_table * t, int access );
extern stmt *stmt_idxbat(sql_idx *i, int access );

extern stmt *stmt_temp(sql_subtype * t );
extern stmt *stmt_atom(atom * op1);
extern stmt *stmt_atom_string( char * s );
extern stmt *stmt_atom_int( int i );
extern stmt *stmt_bool( int b );
extern stmt *stmt_filter(stmt * sel);
extern stmt *stmt_select(stmt * op1, stmt * op2, comp_type cmptype);
extern stmt *stmt_uselect(stmt * op1, stmt * op2, comp_type cmptype);
/* cmp 
       0 ==   l <  x <  h 	
       1 ==   l <  x <= h 
       2 ==   l <= x <  h
       3 ==   l <= x <= h
       */
extern stmt *stmt_select2(stmt * op1, stmt * op2, stmt * op3, int cmp);
extern stmt *stmt_uselect2(stmt * op1, stmt * op2, stmt * op3, int cmp);
extern stmt *stmt_semijoin(stmt * op1, stmt * op2);

extern stmt *stmt_relselect_init();
extern void stmt_relselect_fill(stmt *relselect, stmt *select);
extern stmt *stmt_relselect(list * sels);

extern stmt *stmt_reljoin_init();
extern void stmt_reljoin_fill(stmt *reljoin, stmt *lc, stmt *rc);
extern stmt *stmt_reljoin1(list * joins);
extern stmt *stmt_reljoin2(list * l1, list * l2);
extern stmt *stmt_join(stmt * op1, stmt * op2, comp_type cmptype);
extern stmt *stmt_outerjoin(stmt * op1, stmt * op2, comp_type cmptype);

extern stmt *stmt_diff(stmt * op1, stmt * op2);
extern stmt *stmt_intersect(stmt * op1, stmt * op2);
extern stmt *stmt_union(stmt * op1, stmt * op2);
extern stmt *stmt_list(list * l);
extern stmt *stmt_set(stmt * s1);
extern stmt *stmt_sets(list * s1);
extern stmt *stmt_ptable( stmt *p );
extern stmt *stmt_pivot(stmt *s, stmt *ptable);
extern stmt *stmt_groupby( stmt *p, list *cols );

extern stmt *stmt_find(stmt *b, stmt *v );
extern stmt *stmt_bulkinsert(stmt *t, char *sep, char *rsep, stmt *file, int nr);

extern stmt *stmt_append(stmt *c, stmt * values);
extern stmt *stmt_insert(stmt *c, stmt * values);
extern stmt *stmt_replace(stmt * c, stmt * values);

/* raise exception incase the condition (cond) holds */
extern stmt *stmt_exception(stmt *cond, char *errstr, int errcode);

extern stmt *stmt_const(stmt * s, stmt * val);
extern stmt *stmt_mark(stmt * s, int id);
extern stmt *stmt_reverse(stmt * s);
extern stmt *stmt_mirror(stmt * s);

extern stmt *stmt_limit(stmt * s, int limit);
extern stmt *stmt_order(stmt * s, int direction);
extern stmt *stmt_reorder(stmt * s, stmt * t, int direction);

extern stmt *stmt_op(sql_subfunc * op);
extern stmt *stmt_unop(stmt * op1, sql_subfunc * op);
extern stmt *stmt_binop(stmt * op1, stmt * op2, sql_subfunc * op);
extern stmt *stmt_Nop(stmt * ops, sql_subfunc * op);
extern stmt *stmt_aggr(stmt * op1, group * grp, sql_subaggr * op );
extern stmt *stmt_unique(stmt * s, group * grp);

extern stmt *stmt_alias(stmt * op1, char *tname, char *name);

extern stmt *stmt_ordered(stmt * order, stmt * res);
extern stmt *stmt_output(stmt * l);

extern sql_subtype *head_type(stmt * st);
sql_export sql_subtype *tail_type(stmt * st);

/* return max(s1.nrcols, .. , sn.nrcols where si in l ) */
extern int stmt_list_nrcols(list *l);

sql_export char *column_name(stmt * st);
sql_export char *table_name(stmt * st);

sql_export void stmt_destroy(stmt *s );
extern stmt *stmt_dup( stmt *s );

extern group *grp_create(stmt * s, group *og, stmt *col );
extern group *grp_semijoin(group *og, stmt *s );
extern void grp_destroy(group * g);
extern group *grp_dup(group * g);
extern stmt *grp_find_groupby_col( group *g , stmt *s );

#endif	/* _SQL_STATEMENT_H_ */

@c
#include "sql_mem.h"
#include "sql_statement.h"
#include <string.h>

const char * st_type2string(st_type type) {
	switch (type) {
	#define ST(TYPE) case st_##TYPE : return #TYPE
	ST(none);
	ST(sql);
	ST(var);

	ST(basetable);
	ST(temp);
	ST(bat);
	ST(ubat);
	ST(ibat);
	ST(dbat);
	ST(idxbat);

	ST(const);
	ST(mark);
	ST(reverse);
	ST(mirror);

	ST(limit);
	ST(order);
	ST(reorder);

	ST(ordered);
	ST(output);

	ST(atom);
	ST(filter);
	ST(select);
	ST(select2);
	ST(uselect);
	ST(uselect2);
	ST(semijoin);
	ST(relselect);

	ST(reljoin);
	ST(join);
	ST(outerjoin);
	ST(diff);
	ST(intersect);
	ST(union);

	ST(find);
	ST(bulkinsert);
	ST(append);
	ST(insert);
	ST(replace);
	ST(exception);

	ST(group_ext);
	ST(group);
	ST(derive);
	ST(unique);
	ST(op);
	ST(unop);
	ST(binop);
	ST(Nop);
	ST(aggr);

	ST(alias);

	ST(set);
	ST(sets);
	ST(ptable);
	ST(pivot);
	ST(groupby);
	ST(list);
	default:	
		assert(0);
		return "st_?";
	}
	return "unknown"; /* just needed for broken compilers ! */
}

/* #TODO make proper traversal operations */
stmt *stmt_atom_string( char * S )
{
	char *s = sql2str(_strdup(S));
	sql_subtype *t = sql_bind_subtype("VARCHAR", strlen(s), 0);
	return stmt_atom( atom_string(t, s) );
}

stmt *stmt_atom_int( int i )
{
	sql_subtype *t = sql_bind_subtype("INT", 9, 0);
	return stmt_atom( atom_int(t, i) );
}

stmt *stmt_bool( int b )
{
	sql_subtype *t = sql_bind_subtype("BOOLEAN", 0, 0);

	if (b){
		return stmt_atom( atom_general(t, _strdup("true")));
	} else {
		return stmt_atom( atom_general(t, _strdup("false")));
	}
}

static stmt *stmt_atom_oid( int i )
{
	sql_subtype *t = sql_bind_subtype("OID", 0, 0);
	return stmt_atom( atom_int(t, i) );
}

static stmt *stmt_create(st_type type)
{
	stmt *s = NEW(stmt);

	sql_ref_init(&s->ref);
	s->type = type;
	s->op1.sval = NULL;
	s->op2.sval = NULL;
	s->op3.sval = NULL;
	s->op4.sval = NULL;
	s->flag = 0;
	s->nrcols = 0;
	s->key = 0;
	s->aggr = 0;
	s->nr = 0;
	s->nr2 = int_nil;
	s->h = NULL;
	s->t = NULL;
	s->optimized = 0;
	s->rewritten = NULL;
	return s;
}

static stmt *stmt_ext( stmt *grp )
{
	stmt *ns = stmt_create(st_group_ext);

	ns->op1.stval = grp;
	ns->nrcols = grp->nrcols;
	ns->key = 1;
	ns->h = stmt_dup(grp->h);
	ns->t = stmt_dup(grp->t);
	return ns;
}

static stmt *stmt_group(stmt * s)
{
	stmt *ns = stmt_create(st_group);

	ns->op1.stval = s;
	ns->nrcols = s->nrcols;
	ns->key = 0;
	ns->h = stmt_dup(s->h);
	ns->t = stmt_dup(s->t);
	return ns;
}

static stmt *stmt_derive(stmt * s, stmt * t)
{
	stmt *ns = stmt_create(st_derive);
	ns->op1.stval = s;
	ns->op2.stval = t;
	ns->nrcols = s->nrcols;
	ns->key = 0;
	ns->h = stmt_dup(s->h);
	ns->t = stmt_dup(s->t);
	return ns;
}

void grp_destroy( group * g)
{
	if (sql_ref_dec(&g->ref) == 0) {
		stmt_destroy(g->grp);
		stmt_destroy(g->ext);
		if (g->cols)
			list_destroy(g->cols);
		_DELETE(g);
	}
}

group *grp_dup( group * g) 
{
	if (g) 
		sql_ref_inc(&g->ref);
	return g;
}

group *grp_create( stmt *s, group *og, stmt *col )
{
	group *g = NEW(group);
	sql_ref_init(&g->ref);
	g->cols = NULL;
	if (og){
		g->grp = stmt_derive(stmt_dup(og->grp), s);
		g->cols = og->cols;
		og -> cols = NULL;
		grp_destroy(og);
	} else {
		g->grp = stmt_group(s);
		if (col) 
			g->cols = list_create(NULL);
	}
	if (col) {
		assert(g->cols);
		list_append(g->cols, col);
	}
	g->ext = stmt_ext(stmt_dup(g->grp));
	return g;
}

static stmt *stmt_semijoin_tail( stmt *op1, stmt *op2 )
{
	return stmt_reverse(stmt_semijoin(stmt_reverse(op1), op2));
}

group *grp_semijoin( group *og, stmt *s )
{
	group *g = NEW(group);
	sql_ref_init(&g->ref);
	g->grp = stmt_semijoin_tail(stmt_dup(og->grp),s);
	g->ext = stmt_semijoin(stmt_dup(og->ext),stmt_dup(s));
	g->cols = og->cols;
	og->cols = NULL;
	grp_destroy(og);
	return g;
}

void stmt_destroy(stmt * s)
{
	if (sql_ref_dec(&s->ref) == 0) {
		switch (s->type) {
			/* stmt_destroy  op1 */
		case st_relselect:
			list_destroy(s->op1.lval);
			break;
		case st_reljoin:
			list_destroy(s->op1.lval);
			list_destroy(s->op2.lval);
			break;

		case st_diff: case st_intersect: case st_union:
		case st_join: case st_outerjoin:
		case st_derive:
		case st_unique:
		case st_alias: 
		case st_append: case st_insert: case st_replace:
		case st_exception: 
		case st_pivot:
	  	case st_find:
		case st_sql:
		case st_update_var:

			if (s->op1.stval) stmt_destroy(s->op1.stval);
			if (s->op2.stval) stmt_destroy(s->op2.stval);
			if (s->op3.stval) stmt_destroy(s->op3.stval);
			break;

		case st_set: case st_sets: case st_list:

		case st_ptable:
			list_destroy(s->op1.lval);
			if (s->op2.stval) stmt_destroy(s->op2.stval);
			if (s->op3.stval) stmt_destroy(s->op3.stval);
			break;

		case st_groupby:
			stmt_destroy(s->op1.stval);
			list_destroy(s->op2.lval);
			if (s->op3.stval) stmt_destroy(s->op3.stval);
			break;

		case st_var:
			if (s->op1.sval) _DELETE(s->op1.sval);
			sql_subtype_destroy(s->op2.typeval);
			break;

		/* reference only independently managed resources */
		case st_basetable: 
			_DELETE(s->op2.sval);
		case st_bat: case st_ubat:
		case st_dbat: case st_idxbat:
		case st_none:
			break;

		/* special cases */
		case st_temp:
			if (s->op1.stval) stmt_destroy(s->op1.stval);
			if (s->op2.stval) stmt_destroy(s->op2.stval);
			if (s->op3.stval) stmt_destroy(s->op3.stval);
			sql_subtype_destroy(s->op4.typeval);
			break;
		case st_aggr:
			if (s->op1.stval) stmt_destroy(s->op1.stval);
			if (s->op2.stval) stmt_destroy(s->op2.stval);
			if (s->op3.stval) stmt_destroy(s->op3.stval);
			sql_subaggr_destroy(s->op4.aggrval);
			break;
		case st_op: case st_unop: case st_binop: case st_Nop:
			if (s->op1.stval) stmt_destroy(s->op1.stval);
			if (s->op2.stval) stmt_destroy(s->op2.stval);
			if (s->op3.stval) stmt_destroy(s->op3.stval);
			sql_subfunc_destroy(s->op4.funcval);
			break;
		case st_atom:
			atom_destroy(s->op1.aval);
			break;

		/* simple case of statements of only statements */
		case st_const: case st_mark:
		case st_reverse: case st_mirror:
		case st_limit: case st_order: case st_reorder:
		case st_ordered: case st_output:

		case st_ibat:
		case st_group: case st_group_ext:

		case st_filter:
		case st_select: case st_select2:
		case st_uselect: case st_uselect2:
		case st_semijoin:

		case st_bulkinsert:
			if (s->op1.stval) stmt_destroy(s->op1.stval);
			if (s->op2.stval) stmt_destroy(s->op2.stval);
			if (s->op3.stval) stmt_destroy(s->op3.stval);
			if (s->op4.stval) stmt_destroy(s->op4.stval);
			break;

		default:
			printf("! TODO: stmt_destroy(%d=%s) !\n",s->type,st_type2string(s->type));
		}
		if (s->h) 
			stmt_destroy(s->h);
		if (s->t) 
			stmt_destroy(s->t);
		if (s->rewritten) 
			stmt_destroy(s->rewritten);

		if (s->nr2 > 0) {
/*
 * happens far too often for now, hence, we keep it for debugging, only ...
			printf("= sql_statement.mx: stmt_destroy: (result of) statement %s (%d) was used %d times less often than its refcnt indicated!\n",
				st_type2string(s->type), (int)s->type, s->nr2);
 */
		} else if (s->nr2 == int_nil) {
/*
 * happens far too often for now, hence, we keep it for debugging, only ...

NIELS: Because the optimizer rewrites partly inplace some parts of the 
  statement tree are really not executed!
			printf("= sql_statement.mx: stmt_destroy: statement %s (%d) was never executed!\n",
				st_type2string(s->type), (int)s->type);

*/
		} else if (s->nr2 < 0) {
			printf("= sql_statement.mx: stmt_destroy: (rssult of) statement %s (%d) was used %d times more often than its refcnt indicated!\n",
				st_type2string(s->type), (int)s->type, -s->nr2);
		}

		_DELETE(s);
	}
}

stmt *stmt_none(){
	return stmt_create(st_none);
}

stmt *stmt_sql(char *query ){
	stmt *s = stmt_create(st_sql);
	s->op1.stval = stmt_atom_string(query );
	return s;
}

stmt *stmt_var(char *varname, sql_subtype *t){
	stmt *s = stmt_create(st_var);
	s->op1.sval = varname;
	s->op2.typeval = t;
	s->key = 1;
	return s;
}

stmt *stmt_varnr(int nr, sql_subtype *t){
	stmt *s = stmt_create(st_var);
	s->op1.sval = NULL;
	s->op2.typeval = t;
	s->key = 1;
	s->flag = nr;
	return s;
}


stmt *stmt_update_var(char *varname){
	stmt *s = stmt_create(st_update_var);
	s->op1.stval = stmt_atom_string(varname);
	s->key = 1;
	return s;
}

stmt *stmt_basetable( sql_table *t, char *name )
{
	stmt *s = stmt_create(st_basetable);
	s->op1.tval = t;
	s->op2.sval = _strdup(name);
	return s;
}

stmt *stmt_temp(sql_subtype * t)
{
	stmt *s = stmt_create(st_temp);
	s->op4.typeval = t;
	s->nrcols = 1;
	return s;
}

stmt *stmt_ibat(stmt * op1, stmt * basetable )
{
	stmt *s = stmt_create(st_ibat);
	s->op1.stval = op1;
	/* if not single value, its a single column ! */
	if (op1->nrcols > 0)
		s->nrcols = 1;
	s->key = op1->key;
	s->aggr = op1->aggr;
	s->h = basetable; /* oid's used from this basetable */
	return s;
}

stmt *stmt_cbat(sql_column * c, stmt * basetable, int access, st_type type)
{
	stmt *s = stmt_create(type);
	s->op1.cval = c;
	s->nrcols = 1;
	s->flag = access;
	s->h = basetable; /* oid's used from this basetable */
	return s;
}

stmt *stmt_tbat(sql_table * t, int access )
{
	stmt *s = stmt_create(st_dbat);
	s->nrcols = 0;
	s->flag = access;
	s->op1.tval = t;
	return s;
}

stmt *stmt_idxbat(sql_idx * i, int access)
{
	stmt *s = stmt_create(st_idxbat);
	s->op1.idxval = i;
	s->nrcols = 1;
	s->flag = access;
	return s;
}

stmt *stmt_const(stmt * s, stmt * val)
{
	stmt *ns = stmt_create(st_const);
	ns->op1.stval = s;
	ns->op2.stval = val;
	ns->nrcols = s->nrcols;
	ns->key = s->key;
	ns->aggr = s->aggr;
	ns->h = stmt_dup(s->h);
	return ns;
}

/* BEWARE stmt_mark marks the head, this while the mil mark is a mark tail 
 * Current implementation adds the reverses in stmt_mark nolonger in
 * statement_exec.
*/
stmt *stmt_mark(stmt * s, int id)
{
	stmt *ns = stmt_create(st_mark);
	ns->op1.stval = stmt_reverse(s);
	ns->op2.stval = stmt_atom_oid(id);
	ns->nrcols = s->nrcols;
	ns->key = s->key;
	ns->aggr = s->aggr;
	ns->h = stmt_dup(s->t);
	return stmt_reverse(ns);
}

stmt *stmt_reverse(stmt * s)
{
	stmt *ns = stmt_create(st_reverse);
	ns->op1.stval = s;
	ns->nrcols = s->nrcols;
	ns->key = s->key;
	ns->aggr = s->aggr;
	ns->h = stmt_dup(s->t);
	ns->t = stmt_dup(s->h);
	return ns;
}

stmt *stmt_mirror(stmt * s)
{
	stmt *ns = stmt_create(st_mirror);
	ns->op1.stval = s;
	ns->nrcols = 2;
	ns->key = s->key;
	ns->aggr = s->aggr;
	ns->h = stmt_dup(s->h);
	ns->t = stmt_dup(s->h);
	return ns;
}

stmt *stmt_limit(stmt * s, int limit)
{
	stmt *ns = stmt_create(st_limit);
	ns->op1.stval = s;
	ns->op2.stval = stmt_atom_int(limit);
	ns->nrcols = s->nrcols;
	ns->key = s->key;
	ns->aggr = s->aggr;
	ns->t = stmt_dup(s->t);
	return ns;
}

stmt *stmt_order(stmt * s, int direction)
{
	stmt *ns = stmt_create(st_order);
	ns->op1.stval = s;
	ns->flag = direction;
	ns->nrcols = s->nrcols;
	ns->key = s->key;
	ns->aggr = s->aggr;
	ns->t = stmt_dup(s->t);
	return ns;
}

stmt *stmt_reorder(stmt * s, stmt * t, int direction)
{
	stmt *ns = stmt_create(st_reorder);
	ns->op1.stval = s;
	ns->op2.stval = t;
	ns->flag = direction;
	ns->nrcols = s->nrcols;
	ns->key = s->key;
	ns->aggr = s->aggr;
	ns->t = stmt_dup(s->t);
	return ns;
}

stmt *stmt_unique(stmt * s, group * g)
{
	stmt *ns = stmt_create(st_unique);
	ns->op1.stval = s;
	if (g) {
		ns->op2.stval = stmt_dup(g->grp);
		grp_destroy(g);
	}
	ns->nrcols = s->nrcols;
	ns->key = 1; /* ?? maybe change key to unique ? */
	ns->aggr = s->aggr;
	ns->t = stmt_dup(s->t);
	return ns;
}

stmt *stmt_atom(atom * op1)
{
	stmt *s = stmt_create(st_atom);
	s->op1.aval = op1;
	s->key = 1; /* values are also unique */
	return s;
}

stmt *stmt_filter(stmt * sel )
{
	stmt *s = stmt_create(st_filter);
	s->op1.stval = sel;
	s->nrcols = 1;
	s->h = stmt_dup(s->op1.stval->h);
	return s;
}

stmt *stmt_relselect_init()
{
	stmt *s = stmt_create(st_relselect);
	s->op1.lval = list_create((fdestroy)&stmt_destroy);
	s->nrcols = 1;
	return s;
}

void stmt_relselect_fill(stmt *rs, stmt *sel)
{
	list_append(rs->op1.lval, sel);
	if (!rs->h) rs->h = stmt_dup(((stmt*)(rs->op1.lval->h->data))->h);
}

stmt *stmt_relselect(list * sels)
{
	stmt *s = stmt_create(st_relselect);
	s->op1.lval = sels;
	s->nrcols = 1;
	s->h = stmt_dup(((stmt*)(s->op1.lval->h->data))->h);
	return s;
}

stmt *stmt_select(stmt * op1, stmt * op2, comp_type cmptype)
{
	stmt *s = stmt_create(st_select);
	s->op1.stval = op1;
	s->op2.stval = op2;
	s->flag = cmptype;
	s->nrcols = 1;
	s->h = stmt_dup(s->op1.stval->h);
	s->t = stmt_dup(s->op1.stval->t);
	return s;
}

stmt *stmt_select2(stmt * op1, stmt * op2, stmt * op3, int cmp)
{
	stmt *s = stmt_create(st_select2);
	s->op1.stval = op1;
	s->op2.stval = op2;
	s->op3.stval = op3;
	s->flag = cmp;
	s->nrcols = 1;
	s->h = stmt_dup(s->op1.stval->h);
	s->t = stmt_dup(s->op1.stval->t);
	return s;
}

stmt *stmt_uselect(stmt * op1, stmt * op2, comp_type cmptype)
{
	stmt *s = stmt_create(st_uselect);
	assert(cmptype != cmp_like && cmptype != cmp_notlike);
	s->op1.stval = op1;
	s->op2.stval = op2;
	s->flag = cmptype;
	s->nrcols = 1;
	s->h = stmt_dup(s->op1.stval->h);
	return s;
}

stmt *stmt_uselect2(stmt * op1, stmt * op2, stmt * op3, int cmp)
{
	stmt *s = stmt_create(st_uselect2);
	s->op1.stval = op1;
	s->op2.stval = op2;
	s->op3.stval = op3;
	s->flag = cmp;
	s->nrcols = 1;
	s->h = stmt_dup(s->op1.stval->h);
	return s;
}

stmt *stmt_semijoin(stmt * op1, stmt * op2)
{
	stmt *s = stmt_create(st_semijoin);
	s->op1.stval = op1;
	s->op2.stval = op2;
	/* assert( op1->h == op2->h ); */
	s->nrcols = op1->nrcols;
	s->key = op1->key;
	s->aggr = op1->aggr;
	s->h = stmt_dup(op1->h);
	s->t = stmt_dup(op1->t);
	return s;
}


stmt *stmt_reljoin_init()
{
	stmt *s = stmt_create(st_reljoin);
	s->op1.lval = list_create((fdestroy)&stmt_destroy);
	s->op2.lval = list_create((fdestroy)&stmt_destroy);
	s->nrcols = 2;
	return s;
}

void stmt_reljoin_fill(stmt *rj, stmt *lc, stmt *rc)
{
	list_append(rj->op1.lval, lc);
	list_append(rj->op2.lval, rc);
	if (!rj->h) rj->h = stmt_dup(((stmt*)(rj->op1.lval->h->data))->h);
	if (!rj->t) rj->t = stmt_dup(((stmt*)(rj->op2.lval->h->data))->h);
}

stmt *stmt_reljoin2(list * l1, list * l2)
{
	stmt *s = stmt_create(st_reljoin);
	s->op1.lval = l1;
	s->op2.lval = l2;
	s->nrcols = 2;
	s->h = stmt_dup(((stmt*)(s->op1.lval->h->data))->h);
	s->t = stmt_dup(((stmt*)(s->op2.lval->h->data))->h);
	return s;
}

stmt *stmt_reljoin1(list * joins)
{
	list *l1 = list_create((fdestroy)&stmt_destroy);
	list *l2 = list_create((fdestroy)&stmt_destroy);
	stmt *L = NULL;
	node *n = NULL;
	for (n = joins->h; n; n = n->next){
		stmt *l = stmt_dup(((stmt*)(n->data))->op1.stval);
		stmt *r = stmt_dup(((stmt*)(n->data))->op2.stval);
		while(l->type == st_reverse){
			stmt *t = l;
			l = stmt_dup(l->op1.stval);
			stmt_destroy(t);
		}
		while(r->type == st_reverse){
			stmt *t = r;
			r = stmt_dup(r->op1.stval);
			stmt_destroy(t);
		}
		if (l->t != r->t){
			r = stmt_reverse(r);
		}
		if (L == NULL) {
			L = stmt_dup(l);
		} else if (L->h != l->h) {
			stmt *t = l;
			l = r;
			r = t;
		}
		l1 = list_append(l1, l);
		l2 = list_append(l2, r);
	}
	if (L != NULL) stmt_destroy(L);
	return stmt_reljoin2(l1, l2);
}

stmt *stmt_join(stmt * op1, stmt * op2, comp_type cmptype)
{
	stmt *s = stmt_create(st_join);
	s->op1.stval = op1;
	s->op2.stval = op2;
	s->flag = cmptype;
	s->key = op1->key;
	s->nrcols = 2;
	s->h = stmt_dup(op1->h);
	s->t = stmt_dup(op2->t);
	return s;
}

stmt *stmt_outerjoin(stmt * op1, stmt * op2, comp_type cmptype)
{
	stmt *s = stmt_create(st_outerjoin);
	s->op1.stval = op1;
	s->op2.stval = op2;
	s->flag = cmptype;
	s->nrcols = 2;
	s->h = stmt_dup(op1->h);
	s->t = stmt_dup(op2->t);
	return s;
}

stmt *stmt_diff(stmt * op1, stmt * op2)
{
	stmt *s = stmt_create(st_diff);
	s->op1.stval = op1;
	s->op2.stval = op2;
	s->nrcols = op1->nrcols;
	s->key = op1->key;
	s->aggr = op1->aggr;
	s->h = stmt_dup(op1->h);
	s->t = stmt_dup(op1->t);
	return s;
}

stmt *stmt_intersect(stmt * op1, stmt * op2)
{
	stmt *res = NULL;
	int reverse = 0;

	while(op1->type == st_reverse){
		stmt *r = op1;
		op1 = stmt_dup(op1->op1.stval);
		stmt_destroy(r);
	}
	while(op2->type == st_reverse){
		stmt *r = op2;
		op2 = stmt_dup(op2->op1.stval);
		stmt_destroy(r);
	}
	if (op1->h != op2->h){
		reverse = 1;
	}
	assert ((op1->type == st_join || op1->type == st_reljoin) && (op2->type == st_join || op2->type == st_reljoin));
	if (op1->type == st_join && op1->flag == cmp_all){
		stmt_destroy(op1);
		return op2;
	} else if (op2->type == st_join && op2->flag == cmp_all){
		stmt_destroy(op2);
		return op1;
	}

	/* this case should have been transformed into a proper multi-att join ("st_reljoin") by push_selects_down() */
	assert (!(op1->flag == cmp_equal && op2->flag == cmp_equal));
	
	if (op1->type == st_reljoin || op2->type == st_reljoin) {
printf("= TODO stmt_intersect (1)\n");
		/* 
		 * could/should we do a similar rewrite here as we do below?
		 */
		res = stmt_create(st_intersect);
		res->op1.stval = op1;
		if (reverse){
			res->op2.stval = stmt_reverse(op2);
		} else {
			res->op2.stval = op2;
		}
		res->nrcols = op1->nrcols;
		res->key = op1->key;
		res->aggr = op1->aggr;
		res->h = stmt_dup(op1->h);
		res->t = stmt_dup(op1->t);
	} else {
printf("= TODO stmt_intersect (2)\n");
		/*
	         * need to add the mark trick as [].select(true) on tables 
		 * without unique head identifiers + semijoin is wrong
		 */
		if (!reverse){
			stmt *ml = stmt_mark(stmt_reverse(stmt_dup(op1)), 50);
			stmt *mr = stmt_mark(stmt_dup(op1), 50);
			stmt *l = stmt_join(stmt_dup(ml), 
				stmt_dup(op2->op1.stval), cmp_equal ); 
			stmt *r = stmt_join(stmt_dup(mr), 
				stmt_reverse(stmt_dup(op2->op2.stval)), cmp_equal);
			stmt *v = stmt_uselect( l, r, (comp_type)op2->flag);
			res = stmt_join(stmt_reverse(stmt_semijoin(ml,v)), mr, cmp_equal);
		} else { /* reverse */
			stmt *ml = stmt_mark(stmt_reverse(stmt_dup(op1)), 50);
			stmt *mr = stmt_mark(stmt_dup(op1), 50);
			stmt *l = stmt_join(stmt_dup(mr), 
				stmt_dup(op2->op1.stval), cmp_equal ); 
			stmt *r = stmt_join(stmt_dup(ml), 
				stmt_reverse(stmt_dup(op2->op2.stval)), cmp_equal);
			stmt *v = stmt_uselect( l, r, (comp_type)op2->flag);
			res = stmt_join(stmt_reverse(stmt_semijoin(ml,v)), mr, cmp_equal);
		}

/*
		if (!reverse){
	 		res = stmt_semijoin( stmt_dup(op1), stmt_uselect( stmt_join(op1, stmt_reverse(stmt_dup(op2->op2.stval)), cmp_equal ), stmt_dup(op2->op1.stval), (comp_type)op2->flag));
		} else {
	 		res = stmt_semijoin( stmt_dup(op1), stmt_uselect( stmt_join(op1, stmt_dup(op2->op1.stval), cmp_equal ), stmt_reverse(stmt_dup(op2->op2.stval)), (comp_type)op2->flag));
		}
		stmt_destroy(op2);
*/
		stmt_destroy(op1);
		stmt_destroy(op2);
	}
	return res;
}

stmt *stmt_union(stmt * op1, stmt * op2)
{
	stmt *s = stmt_create(st_union);
	s->op1.stval = op1;
	s->op2.stval = op2;
	s->nrcols = op1->nrcols;
	s->h = stmt_dup(op1->h);
	s->t = stmt_dup(op1->t);
	return s;
}

stmt *stmt_find(stmt * b, stmt * v)
{
	stmt *s = stmt_create(st_find);
	s->op1.stval = b;
	s->op2.stval = v;
	s->nrcols = 1;
	s->key = 0;
	s->h = stmt_dup(b->h);
	s->t = stmt_dup(b->t);
	return s;
}

stmt *stmt_bulkinsert(stmt *t, char *sep, char *rsep, stmt *file, int nr )
{
	stmt *s = stmt_create(st_bulkinsert);
	s->op1.stval = t;
	s->op2.stval = stmt_atom_string(sep);
	s->op3.stval = stmt_atom_string(rsep);
	s->op4.stval = file;
	s->flag = nr; 
	return s;
}

stmt *stmt_list(list * l)
{
	int nrcols = 0;
	int key = 1;
	node *n;
	stmt *s = stmt_create(st_list);
	s->op1.lval = l;
	
	for (n = l->h; n; n = n->next){
		stmt *f = n->data;
		if (f->nrcols > nrcols)
			nrcols = f->nrcols;
		key &= f->key;
	}
	s->nrcols = nrcols;
	s->key = key;
	return s;
}

stmt *stmt_ordered(stmt * order, stmt * res)
{
	stmt *ns = stmt_create(st_ordered);
	ns->type = st_ordered;
	ns->op1.stval = order;
	ns->op2.stval = res;
	ns->nrcols = res->nrcols;
	ns->key = res->key;
	ns->aggr = res->aggr;
	ns->t = stmt_dup(res->t);
	return ns;
}

stmt *stmt_output(stmt * l)
{
	stmt *s = stmt_create(st_output);
	s->op1.stval = l;
	return s;
}

stmt *stmt_set(stmt * s1)
{
	stmt *s = stmt_create(st_set);
	s->op1.lval = list_append(list_create((fdestroy)&stmt_destroy),s1);
	s->nrcols = s1->nrcols;
	return s;
}

stmt *stmt_sets(list * l1)
{
	node *n;
	int nrcols = 0;
	stmt *s = stmt_create(st_sets);

	s->op1.lval = l1;
	for(n = l1->h; n; n = n->next) {
		list *l = n->data;
		node *m;
		for(m = l->h; m; m = m->next) {
			stmt *t = m->data;
			if (t->nrcols > nrcols)
				nrcols = t->nrcols;
		}
	}
	assert(nrcols <= 2);
	s->nrcols = nrcols;
	return s;
}

/* ptable 
		list of pivots
		parent
		statements	
 */

stmt *stmt_ptable(stmt * ptable)
{
	stmt *s = stmt_create(st_ptable);
	s->op1.lval = list_create( (fdestroy)NULL );
	s->op2.stval = ptable;
	s->nrcols = 2;
	return s;
}

stmt *stmt_pivot(stmt * base, stmt *ptable)
{
	stmt *s = stmt_create(st_pivot);

	assert(ptable->type == st_ptable);

	s->op1.stval = base;
	s->op2.stval = ptable;
	s->h = stmt_dup(ptable); /* the ptable is the new base table */
	s->t = stmt_dup(base); 	 /* pivots have oid's in the tail */
	s->nrcols = 2;
	list_append(ptable_pivots(ptable), s);
	return s;
}

stmt *stmt_groupby( stmt *ptable, list *cols )
{
	stmt *s = stmt_create(st_groupby);

	assert(ptable->type == st_ptable);

	s->op1.stval = ptable;
	s->op2.lval = cols;
	s->nrcols = 2;
	return s;
}

stmt *stmt_append(stmt * c, stmt * a )
{
	stmt *s = stmt_create(st_append);
	s->op1.stval = c;
	s->op2.stval = a;
	s->h = stmt_dup(c->h);
	s->t = stmt_dup(c->t);
	s->nrcols = c->nrcols;
	s->key = c->key;
	return s;
}

stmt *stmt_insert(stmt * c, stmt * a )
{
	stmt *s = stmt_create(st_insert);
	s->op1.stval = c;
	s->op2.stval = a;
	s->h = stmt_dup(c->h);
	s->t = stmt_dup(c->t);
	return s;
}

stmt *stmt_replace(stmt * c, stmt * b)
{
	stmt *s = stmt_create(st_replace);
	s->op1.stval = c;
	s->op2.stval = b;
	s->nrcols = 1;
	return s;
}

stmt *stmt_exception(stmt * cond, char *errstr, int errcode )
{
	stmt *s = stmt_create(st_exception);
	s->op1.stval = cond;
	s->op2.stval = stmt_atom_string(errstr);
	s->op3.stval = stmt_atom_int(errcode);
	s->nrcols = 0;
	return s;
}

stmt *stmt_op(sql_subfunc * op)
{
	stmt *s = stmt_create(st_op);
	assert(op);
	
	s->op4.funcval = op;
	s->nrcols = 0; /* function without arguments returns single value */
	s->key = 1;
	return s;
}

stmt *stmt_unop(stmt * op1, sql_subfunc * op)
{
	stmt *s = stmt_create(st_unop);
	s->op1.stval = op1;
	assert(op);
	s->op4.funcval = op;
	s->h = stmt_dup(op1->h);
	s->nrcols = op1->nrcols;
	s->key = op1->key;
	s->aggr = op1->aggr;
	return s;
}

stmt *stmt_binop(stmt * op1, stmt * op2, sql_subfunc * op)
{
	stmt *s = stmt_create(st_binop);
	int aggr = 0;
	s->op1.stval = op1;
	s->op2.stval = op2;
	assert(op);
	s->op4.funcval = op;
	aggr = op1->aggr;
	if (!aggr) 	
		aggr = op2->aggr;
	if (op1->nrcols > op2->nrcols){
		s->h = stmt_dup(op1->h);
		s->nrcols = op1->nrcols;
		s->key = op1->key;
	} else {
		s->h = stmt_dup(op2->h);
		s->nrcols = op2->nrcols;
		s->key = op2->key;
	}
	s->aggr = aggr;
	return s;
}

stmt *stmt_Nop(stmt * ops, sql_subfunc * op)
{
	node *n;
	stmt *o, *s = stmt_create(st_Nop);

	s->op1.stval = ops; 
	assert(op);
	s->op4.funcval = op;
	for(n = ops->op1.lval->h, o = n->data; n; n = n->next){
		stmt *c = n->data;
		if (o->nrcols < c->nrcols)
			o = c;
	}

	s->h = stmt_dup(o->h);
	s->nrcols = o->nrcols;
	s->key = o->key;
	s->aggr = o->aggr;

	return s;
}

stmt *stmt_aggr(stmt * op1, group * grp, sql_subaggr * op )
{
	stmt *s = stmt_create(st_aggr);
	s->op1.stval = op1;
	if (grp) {
		s->op2.stval = stmt_dup(grp->grp);
		s->op3.stval = stmt_dup(grp->ext);
		s->nrcols = 1;
		s->h = stmt_dup(grp->grp->h);
		grp_destroy(grp);
	} else {
		s->nrcols = 0;
		s->h = stmt_dup(op1->h);
	}
	s->key = 1;
	s->aggr = 1;
	s->op4.aggrval = op;
	return s;
}

stmt *stmt_alias(stmt * op1, char *tname, char *alias)
{
	stmt *s = stmt_create(st_alias);
	s->op1.stval = op1;
	if (tname)
		s->op2.stval = stmt_atom_string(tname);
	s->op3.stval = stmt_atom_string(alias);
	s->h = stmt_dup(op1->h);
	s->t = stmt_dup(op1->t);
	s->nrcols = op1->nrcols;
	s->key = op1->key;
	s->aggr = op1->aggr;
	return s;
}

stmt *stmt_dup( stmt * s)
{
	if (s) 
		sql_ref_inc(&s->ref);
	return s;
}


sql_subtype *tail_type(stmt * st) 
{
	switch (st->type) {
	case st_const:
	case st_join:
	case st_outerjoin:
	case st_find:
		return tail_type(st->op2.stval);
	case st_reljoin: 
		/* The tail type of a reljoin is the head of the second list!,	
		   ie should be 'oid' */
		return head_type(st->op2.lval->h->data);

	case st_diff:
	case st_filter:
	case st_select:
	case st_select2:
	case st_uselect:
	case st_uselect2:
	case st_semijoin:
	case st_unique:
	case st_union:
	case st_append:
	case st_replace:
	case st_alias:
	case st_ibat:
	case st_pivot:
	case st_group:
	case st_group_ext:
	case st_mark:
		return tail_type(st->op1.stval);

	case st_list:
		return tail_type(st->op1.lval->h->data);

	case st_bat:
		return st->op1.cval->type;
	case st_idxbat:
		if (st->op1.idxval->type == unique){	
			return sql_bind_localtype( "int" );
		} else if (st->op1.idxval->type == join_idx){	
			return sql_bind_localtype( "oid" );
		}
	case st_mirror:
	case st_reverse:
		return head_type(st->op1.stval);

	case st_aggr:
		return st->op4.aggrval->res;
	case st_op:
	case st_unop:
	case st_binop:
	case st_Nop:
		return st->op4.funcval->res;
	case st_atom:
		return atom_type(st->op1.aval);
	case st_temp:
		return st->op4.typeval;
	case st_var:
		return st->op2.typeval;
	case st_relselect:
	default:
		fprintf(stderr, "missing tail type %d: %s\n", st->type, st_type2string(st->type) );
		assert(0);
		return NULL;
	}
}

sql_subtype *head_type(stmt * st)
{
	switch (st->type) {
	case st_aggr:
	case st_unop:
	case st_binop:
	case st_Nop:
	case st_unique:
	case st_union:
	case st_alias:
	case st_diff:
	case st_join:
	case st_outerjoin:
	case st_semijoin:
	case st_mirror:
	case st_filter:
	case st_select:
	case st_select2:
	case st_uselect:
	case st_uselect2:
	case st_ibat:
	case st_append:
	case st_insert:
	case st_replace:
	case st_pivot:
	case st_mark:
	case st_group:
	case st_group_ext:
	case st_order:
		return head_type(st->op1.stval);
	case st_relselect:
	case st_reljoin:
		return head_type(st->op1.lval->h->data);

	case st_list:
		return head_type(st->op1.lval->h->data);

	case st_temp:
	case st_bat:
		return sql_bind_localtype("oid");
		/* return NULL;	oid */

	case st_reverse:
		return tail_type(st->op1.stval);
	case st_atom:
		return atom_type(st->op1.aval);
	case st_find:
		return head_type(st->op2.stval);

	default:
		fprintf(stderr, "missing head type %d: %s\n", st->type, st_type2string(st->type) );
		return NULL;
	}
}

int 
stmt_list_nrcols( list *l )
{
	int nrcols = 0;
	node *n;

	for(n = l->h; n; n = n->next) {
		stmt *s = n->data;
		if (s->nrcols > nrcols)
			nrcols = s->nrcols;
	}
	return nrcols;
}

static char *func_name(char *n1, char *n2)
{
	int l1 = strlen(n1);
	int l2 = strlen(n2);
	if (l2 > 16) { /* only support short names */
		char *ns = NEW_ARRAY(char, l2 + 1);
		strncpy(ns, n2, l2);
		ns[l2] = 0;
		return ns;
	} else {
		char *ns = NEW_ARRAY(char, l1 + l2 + 2), *s = ns;
		strncpy(ns, n1, l1);
		ns += l1;
		*ns++ = '_';
		strncpy(ns, n2, l2);
		ns += l2;
		*ns = '\0';
		return s;
	}
}

char *column_name(stmt * st)
{
	switch (st->type) {
	case st_reverse:
		return column_name(st->op1.stval);
	case st_const:
	case st_join:
	case st_outerjoin:
	case st_derive:
		return column_name(st->op2.stval);

	case st_mirror:
	case st_group:
	case st_group_ext:
	case st_ibat:
	case st_union:
	case st_append:
	case st_mark:
	case st_filter:
	case st_select:
	case st_select2:
	case st_uselect:
	case st_uselect2:
	case st_semijoin:
	case st_diff:
	case st_unique:
	case st_pivot:
	case st_replace:
		return column_name(st->op1.stval);

	case st_op:
		return _strdup(st->op4.funcval->func->name);
	case st_unop:
	case st_binop:
	case st_Nop: 
	{
		char *cn = column_name(st->op1.stval);
		char *r = func_name(st->op4.funcval->func->name, cn);
		_DELETE(cn);
		return r;
	}
	case st_aggr: 
	{
		char *cn = column_name(st->op1.stval);
		char *r = func_name(st->op4.aggrval->aggr->name, cn);
		_DELETE(cn);
		return r;
	}
	case st_alias:
		return column_name(st->op3.stval);
	case st_bat:
		return _strdup(st->op1.cval->base.name);
	case st_atom:
		if (st->op1.aval->data.vtype == TYPE_str)
			return atom2string(st->op1.aval);
	case st_var:
	case st_temp:
		return _strdup("single_value");

	case st_relselect:
	case st_reljoin:
	case st_list:
		if (list_length(st->op1.lval))
			return column_name(st->op1.lval->h->data);
		/* whats the name of an empty list ? */
		assert(0);
	default:
		fprintf(stderr, "missing column name %d: %s\n", st->type, st_type2string(st->type) );
		return NULL;
	}
}

char *table_name(stmt * st)
{
	switch (st->type) {
	case st_reverse:
		return table_name(st->op1.stval);
	case st_const:
	case st_join:
	case st_outerjoin:
	case st_derive:
		return table_name(st->op2.stval);
	case st_mirror:
	case st_group:
	case st_group_ext:
	case st_ibat:
	case st_union:
	case st_append:
	case st_mark:
	case st_filter:
	case st_select:
	case st_select2:
	case st_uselect:
	case st_uselect2:
	case st_semijoin:
	case st_diff:
	case st_aggr:
	case st_unique:
	case st_pivot:
		return table_name(st->op1.stval);

	case st_basetable:
		return _strdup(st->op2.sval);
	case st_bat:
		return table_name(st->h);
	case st_alias:
		if (st->op2.stval)
			return table_name(st->op2.stval);
		return NULL;

	case st_atom:
		if (st->op1.aval->data.vtype == TYPE_str && 
		    st->op1.aval->data.val.sval &&
		    strlen(st->op1.aval->data.val.sval))
			return atom2string(st->op1.aval);

	case st_var:
	case st_temp:
	case st_relselect:
	case st_reljoin:
	default:
		return NULL;
	}
}

stmt *grp_find_groupby_col( group *g , stmt *s )
{
	node *n;

	/* groups built for outer references or implicite groups 
		can allways find columns */ 
	if (!g->cols)
		return s;

        for(n = g->cols->h; n; n = n->next ) {
		stmt *gs = n->data;
		if (gs == s)
			return s;
	}
	return NULL;
}
