@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2007 CWI.
@' All Rights Reserved.

@f sql_qc
@a N.J. Nes
@* The query cache
An effective scheme to speedup processing of an SQL engine is
to keep a cache of recently executed queries around.
This cache can be inspected by simply searching for an
identical query string, or a simple pattern match against
the sql query tree.  Finding an element saves code generation.

The scheme used here is based on keeping a hash-key around for
the original text and subsequently perform a parse-tree comparison.
This means that only text-identical queries are captured.

The upper layers should consider the cache as an auxiliary
structure. There is no guarantee that elements remain in
the cache forever, nor control features to assure this.

Entries in the cache obtain a unique(?) cache entry number.
It can be used as an external name.

[todo]
The information retain for each cached item is back-end specific.
It should have a hook to update the initialize the cache entry
and a method to destroy it.

The optimization/processing cost should be kept around and the re-use of
a cache entry.
@h
#ifndef _SQL_QC_H_
#define _SQL_QC_H_

#include <sql_mem.h>
#include <sql_list.h>
#include <sql_symbol.h>
#include <sql_backend.h>

typedef struct cq {
	struct cq *next;	/* link them into a queue */
	int type;		/* sql_query_t: Q_PARSE,Q_SCHEMA,.. */
	sql_allocator *sa;	/* the symbols are allocated from this sa */
	symbol *s;		/* the SQL parse tree */
	sql_subtype *params;	/* parameter types */
	int paramlen;		/* number of parameters */
	backend_stack stk;	/* V4 state information */
	backend_code code;	/* V4 state information */
	int id;			/* cache identity */
	int key;		/* the hash key for the query text */
	char *codestring;	/* keep code in string form to aid debugging */
	char *name;		/* name of cache query */
	int count;		/* number of times the query is matched */
} cq;

typedef struct qc {
	int clientid;
	int id;
	cq *q;
} qc;

extern qc *qc_create(int clientid);
extern void qc_destroy(qc *cache);
extern cq *qc_find(qc *cache, int id);
extern cq *qc_match(qc *cache, symbol *s, atom **params, int plen, int key);
extern cq *qc_insert(qc *cache, sql_allocator *sa, symbol *s, atom **params, int paramlen, int key, int type, char *codedstr);
extern void qc_delete(qc *cache, cq *q);
extern int qc_size(qc *cache);

#endif /*_SQL_QC_H_*/

@c
#include "sql_config.h"

#include "sql_qc.h"
#include "sql_scope.h"

qc *
qc_create(int clientid)
{
	qc *r = NEW(qc);
	r->clientid = clientid;
	r->id = 0;

	r->q = NULL;
	return r;
}

static void
cq_delete(cq *q)
{
	if (q->code)
		backend_freecode(q->code, q->stk, q->id, q->name);
	if (q->stk)
		backend_freestack(q->stk);
	if (q->codestring)
		_DELETE(q->codestring);

	/* params and name are allocated using sa, ie need to be delete last */
	if (q->sa) 
		sa_destroy(q->sa);
	_DELETE(q);
}

void
qc_delete(qc *cache, cq *q)
{
	cq *n, *p = NULL;

	for (n = cache->q; n; p = n, n = n->next) {
		if (n == q) {
			if (p) {
				p->next = q->next;
			} else {
				cache->q = q->next;
			}
			cq_delete(q);
			break;
		}
	}
}

void
qc_destroy(qc *cache)
{
	cq *q, *n;

	for (q = cache->q; q; q = n) {
		n = q->next;

		cq_delete(q);
	}
	_DELETE(cache);
}

int
param_cmp(sql_subtype *t1, sql_subtype *t2)
{
	int res;

	if (t1->scale != t2->scale)
		return -1;
	res = is_subtype(t2, t1);
	if (!res)
		return -1;
/*
	if ((t1->digits > 0 && t1->scale == 0 && t1->digits < t2->digits) || (t1->scale > 0 && t1->digits > 0 && t1->digits - t1->scale < t2->digits - t2->scale)) {
		return -1;
	}
*/
	return 0;
}

int
param_list_cmp(sql_subtype *typelist, atom **atoms, int plen)
{
	int i;

	if (!plen && !typelist && !atoms)
		return 0;

	if (!typelist || !atoms)
		return -1;
	for (i=0; i < plen; i++) {
		sql_subtype *t1 = typelist + i;
		atom *a2 = atoms[i];

		/* NULL values match any type */
		if (!atom_null(a2) && param_cmp(t1, atom_type(a2)) != 0) {
			sql_subtype *at = atom_type(a2);

			/* FLT == DEC/NUM and DEC/NUM are equal */
			if ((!(t1->type->eclass == EC_FLT && 
			    (at->type->eclass == EC_DEC ||
			     at->type->eclass == EC_NUM))) &&
			   (!(t1->type->eclass == EC_DEC &&
			      at->type->eclass == EC_NUM &&
			      t1->type->localtype >= at->type->localtype)) &&
			/*
			   (!(t1->type->eclass == EC_DEC &&
			      at->type->eclass == EC_DEC &&
			      t1->type->localtype >= at->type->localtype &&
			      at->digits <= t1->digits &&
			      at->scale <= t1->scale)) &&
			*/
			   (!(t1->type->eclass == EC_NUM &&
			      atom_type(a2)->type->eclass == EC_NUM &&
			       t1->type->localtype >= atom_type(a2)->type->localtype)))
				return -1;
		}
	}
	return 0;
}

cq *
qc_find(qc *cache, int id)
{
	cq *q;

	for (q = cache->q; q; q = q->next) {
		if (q->id == id) {
			q->count++;
			return q;
		}
	}
	return NULL;
}

cq *
qc_match(qc *cache, symbol *s, atom **params, int  plen, int key)
{
	cq *q;

	for (q = cache->q; q; q = q->next) {
		if (q->key == key) {
			if (q->paramlen == plen && param_list_cmp(q->params, params, plen) == 0 && symbol_cmp(q->s, s) == 0) {
				q->count++;
				return q;
			}
		}
	}
	return NULL;
}

cq *
qc_insert(qc *cache, sql_allocator *sa, symbol *s, atom **params, int paramlen, int key, int type, char *cmd)
{
	char name[BUFSIZ];
	int i;
	cq *n = NEW(cq);

	n->id = cache->id ++;

	n->sa = sa;
	n->s = s;

	n->params = NULL;
	n->paramlen = paramlen;
	if (paramlen)
		n->params = SA_NEW_ARRAY(sa, sql_subtype,paramlen);
		for (i = 0; i < paramlen; i++) {
			atom *a = params[i];

			n->params[i] = *(atom_type(a));
		}
	n->next = cache->q;
	n->stk = 0;
	n->code = NULL;
	n->type = type;
	n->key = key;
	n->codestring = cmd;
	n->count = 1;
	(void) snprintf(name, BUFSIZ, "s%d_%d", n->id, cache->clientid);
	n->name = sa_strdup(sa, name);
	cache->q = n;
	return n;
}

int
qc_size(qc *cache)
{
	return cache->id;
}
