@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f bat_bm
@t Bat Manager
@a N. J. Nes
@v 1.0
@T
@* Introduction
Manages the collections of bats needed for the SQL frontend. This gives 
an abstraction on top of the monet bat ids. Currently it stores two sets;
the active and persistent bats. The active set is store in the bats current 
content, the deleted and inserted can then be found using the delta status. 

@* Implementation Code 
@h
#ifndef _SQL_BM_H_
#define _SQL_BM_H_

#include "sql_mem.h"
#include <gdk.h>

extern void bat_destroy(BAT *b);
extern BAT *bat_descriptor(bat bid, char *func);
extern BAT *bat_copy(BAT *b, char *func);
extern BAT *bat_new(int ht, int tt, size_t size, char *func);
extern void bat_incref(bat bid, bit flag, char *func);
extern void bat_decref(bat bid, bit flag);

extern ptr bun_find(BAT *b, ptr v);

extern struct bm *bm_create(int debug);
extern void bm_destroy(struct bm *bm);
extern int bm_commit(struct bm *bm);
extern void bm_abort(struct bm *bm );

extern void bm_set_oid(struct bm *bm, int id );
extern int  bm_get_oid(struct bm *bm );

extern oid bm_add_bat(struct bm *bm, BAT *b, char *name);
extern void bm_del_bat(struct bm *bm, oid bid);

extern oid bm_find_bat(struct bm *bm, char *name);

#endif /*_SQL_BM_H_*/
@c
#include "sql_mem.h"
#include "bat_bm.h"
#include "stream.h"

/* #define RENAME */

typedef struct bm {
	/* Store oids to circumvent trouble with reference counting */
	int debug;
	BAT *bat_name;		/*      [ oid, str ]   */
} bm;

static int bm_debug = 0;

void
bat_destroy(BAT *b)
{
	if (bm_debug)
		printf("destroy %d (%d,%d)\n", b->batCacheid, BBPrefs(b->batCacheid), BBP_lrefs(b->batCacheid));
	if (b)
		BBPunfix(b->batCacheid);
}

BAT *
bat_descriptor(bat bid, char *func)
{
	BAT *b = BATdescriptor(bid);

	if (bm_debug)
		printf("bat_destriptor %s %d (%d,%d)\n", func, bid, BBPrefs(bid), BBP_lrefs(bid));
	return b;
}

BAT *
bat_copy(BAT *b, char *func)
{
	BAT *nb = BATcopy(b);

	if (bm_debug)
		printf("bat_copy(%s) %d (%d,%d)\n", func, nb->batCacheid, BBPrefs(nb->batCacheid), BBP_lrefs(nb->batCacheid));
	return nb;
}

BAT *
bat_new(int ht, int tt, size_t size, char *func)
{
	BAT *nb = BATnew(ht, tt, size);

	if (bm_debug)
		printf("bat_new(%s) %d (%d,0)\n", func, nb->batCacheid, BBPrefs(nb->batCacheid));
	if (ht == TYPE_void)
		BATseqbase(nb, 0);
	nb->batDirty |= 2;
	return nb;
}

void
bat_incref(bat bid, bit flag, char *func)
{
	BBPincref(bid, flag);
	if (bm_debug)
		printf("bat_incref(%s) %d (%d,%d)\n", func, bid, BBP_refs(bid), BBP_lrefs(bid));
}

void
bat_decref(bat bid, bit flag)
{
	if (bm_debug)
		printf("bat_decref() %d (%d,%d)\n", bid, BBP_refs(bid), BBP_lrefs(bid));
	BBPdecref(bid, flag);
}

ptr
bun_find(BAT *b, ptr v)
{
	BUN p = BUNfnd(b, v);

	if (p)
		return BUNtail(b, p);
	return NULL;
}

static BAT *
bm_create_bat(int ht, int tt, size_t size)
{
	BAT *b = bat_new(ht, tt, size, "bm_create_bat");

	/* Make persistent as only persistent bats keep delta information */
	bat_incref(b->batCacheid, TRUE, "bm_create_bat");
	return b;
}

static
int bm_subcommit( BAT * catalog ) 
{
	BUN p,q;
	BAT *n = bat_new(TYPE_void, TYPE_str, BATcount(catalog)*2, "subcommit");
	BAT *b = catalog;
	int res;

	BATseqbase(n,0);
	/* first loop over deleted then over current and new */
	for (p = b->batDeleted; p < b->batFirst; p = BUNnext(b, p)) {
		bat col = *(oid*)BUNhead(b,p);
		str name = BBPname(col);
		BUNappend(n, name, FALSE);
	}
	BATloop(b, p, q) {
		bat col = *(oid*)BUNhead(b,p);
		str name = BBPname(col);
		BUNappend(n, name, FALSE);
	}
	/* now commit catalog, so its also up to date on disk */
	BATcommit(catalog); 
	res = TMsubcommit(n);
	BBPreclaim(n);
	return res;
}

bm *
bm_create(int debug)
{
	char *catalog = "sql_catalog";
	bm *bm = NEW(struct bm);
	bat sql_catalog = BBPindex("sql_catalog");

	bm->debug = debug;
	if (sql_catalog == 0) {
		oid bid = 0;
		bm->bat_name = bm_create_bat(TYPE_oid, TYPE_str, BUFSIZ);
		if (bm->debug)
			printf("create sql_catalog\n");
		BATmode(bm->bat_name, PERSISTENT);
		BBPrename(bm->bat_name->batCacheid, catalog);
		/* insert catalog bat, to make TMsubcommit calls possible */
		bid = bm->bat_name->batCacheid;
		BUNins(bm->bat_name, &bid, catalog);
		if (bm_subcommit(bm->bat_name) != 0)	/* save sql_catalog */
			return NULL;
	} else { /* find the persisten sql_catalog. As non persistent bats
		    require a logical reference we also add a logical 
		    reference for the persistent bats */
		BUN p, q;
		BAT *b = bat_descriptor(sql_catalog, "bm_create");

		bm->bat_name = b;
		BATloop(b, p, q) {
			bat bid = *(oid *) BUNhead(b, p);

			bat_incref(bid, TRUE, "bm_create");
		}
	}
	return bm;
}

void
bm_destroy(bm *bm)
{
	BUN p, q;
	BAT *b = bm->bat_name;

	/* destroy the deleted */
/* would be an error ....
	for (p = b->batDeleted; p < b->batFirst; p = BUNnext(b, p)) {
		bat bid = *(oid *) BUNhead(b, p);

		bat_decref(bid, TRUE);
	}
*/
	/* free resources */
	BATloop(b, p, q) {
		bat bid = *(oid *) BUNhead(b, p);

		bat_decref(bid, TRUE);
	}

	bat_decref(bm->bat_name->batCacheid, TRUE);
	bat_destroy(bm->bat_name);

	_DELETE(bm);
}

int
bm_commit(bm *bm)
{
	BUN p;
	BAT *b = bm->bat_name;

	/* remove the destroyed bats */
	for (p = b->batDeleted; p < b->batFirst; p = BUNnext(b, p)) {
		bat bid = *(oid *) BUNhead(b, p);
		BAT *b = bat_descriptor(bid, "bm_commit");

		BATmode(b, TRANSIENT);
		bat_decref(bid, TRUE);
		bat_destroy(b);
	}

	for (p = b->batInserted; p < BUNlast(b); p = BUNnext(b, p)) {
		oid bid = *(oid *) BUNhead(b, p);
		BAT *b = bat_descriptor(bid, "bm_commit");

		BATmode(b, PERSISTENT);
		bat_destroy(b);
	}
	if (bm_subcommit(bm->bat_name) != 0)	/* save new bats */
		return SQL_ERR;
	return 0;
}

void
bm_abort(bm *bm)
{
	BUN p;
	BAT *b = bm->bat_name;

	/* remove the created bats */
	for (p = b->batInserted; p < BUNlast(b); p = BUNnext(b, p)) {
		bat bid = *(oid *) BUNhead(b, p);

		bat_decref(bid, TRUE);
	}
	for (p = BUNfirst(b); p < b->batInserted; p = BUNnext(b, p)) {
		oid bid = *(oid *) BUNhead(b, p);
		BAT *b = bat_descriptor(bid, "bm_abort");

		BATundo(b);
		BATcommit(b);
		bat_destroy(b);
	}
	BATundo(bm->bat_name);
}

oid
bm_add_bat(bm *bm, BAT *b, char *name)
{
	oid bid = bm_find_bat(bm, name);

	if (bid) {
		if (bid != b->batCacheid) 
			BUNdelHead(bm->bat_name, &bid);
		else
			return bid;
	}
	bid = b->batCacheid;
	if (bm->debug)
		printf("create %s\n", name);
	BUNins(bm->bat_name, &bid, name);
	bat_incref(bid, TRUE, "bm_add_bat");
	return bid;
}

void
bm_del_bat(bm *bm, oid bid)
{
	BUNdelHead(bm->bat_name, &bid);
}

oid
bm_find_bat(bm *bm, char *name)
{
	BAT *r_bat_name = BATmirror(bm->bat_name);
	oid res = 0;
	BUN p = BUNfnd(r_bat_name, name);

	if (p) 
		res = *(oid *) BUNtail(r_bat_name, p);
	return res;
}
