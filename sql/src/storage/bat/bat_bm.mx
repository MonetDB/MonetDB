@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f bat_bm
@t Bat Manager
@a N. J. Nes
@v 1.0
@T
@* Introduction
Manages a collection of bats. This gives an abstraction on top of the monet
bat ids.

@* Implementation Code 
@h
#ifndef _SQL_BM_H_
#define _SQL_BM_H_

#include "sql_mem.h"
#include <gdk.h>

extern void bat_destroy(BAT *b);
extern BAT *bat_descriptor(bat bid, char *func);
extern BAT *bat_copy(BAT *b, char *func);
extern BAT *bat_new(int ht, int tt, size_t size, char *func);
extern void bat_incref(bat bid, bit flag, char *func);
extern void bat_decref(bat bid, bit flag);

extern ptr bun_find(BAT *b, ptr v);

extern struct bm *bm_create(int debug);
extern void bm_destroy(struct bm *bm);
extern struct bm *bm_dup(struct bm *bm);

/* The current state of the bat manager can be saved using
 * the bm_save function. It makes the managed bats persistent. 
 * For each persistent bat the name,version pairs are writen 
 * to the given file. 
 *
 * The previous persistent versions should be removed (after the
 * file writen by bm_save saved), using the bm_cleanup.
 */
extern int bm_save(struct bm *bm, FILE *fp);
extern int bm_load(struct bm *bm, FILE *fp);
extern void bm_cleanup(struct bm *bm);

/* fake commits as real commits are handled by a log manager */
extern void bm_commit(struct bm *bm, int tid);
extern void bm_abort(struct bm *bm, int tid);
extern int bm_version(struct bm *bm);

extern oid bm_add_bat(struct bm *bm, oid bid, char *name, int version);
extern void bm_del_bat(struct bm *bm, oid lbid);
extern void bm_new_version(struct bm *bm, oid lbid, int version);
extern void bm_new_bat(struct bm *bm, oid lbid, BAT *b);

extern oid bm_find_bat(struct bm *bm, char *name);
extern BAT *bm_lbid2bat(struct bm *bm, oid lbid);
extern char *bm_lbid2name(struct bm *bm, oid lbid);
extern int bm_lbid2version(struct bm *bm, oid lbid);
extern int bm_lbid2mode(struct bm *bm, oid lbid);

#define BM_READ 0
#define BM_APPEND 1
#define BM_WRITE 2

#endif /*_SQL_BM_H_*/
@c
#include "sql_mem.h"
#include "bat_bm.h"
#include "stream.h"

typedef struct bm {
	/* Store oids to circumvent trouble with reference counting */
	int debug;
	oid vid;
	oid lbid;
	int version;
	BAT *bat_version;	/*      [ void, int ]   */
	BAT *bat_name;		/*      [ void, str ]   */
	BAT *bat_bid;		/*      [ void, oid ]   */
	BAT *bat_lbid;		/*      [ void, oid ]   */
	BAT *bat_mode;		/*      [ void, int ]   */
	BAT *bat_oversion;	/*      [ void, int ]   */
	BAT *bat_pbid;		/*      [ void, oid ]   */
	BAT *bat_opbid;		/*      [ void, oid ]   */
} bm;

static int bm_debug = 0;

void
bat_destroy(BAT *b)
{
	if (bm_debug)
		printf("destroy %d (%d,%d)\n", b->batCacheid, BBPrefs(b->batCacheid), BBP_lrefs(b->batCacheid));
	if (b)
		BBPunfix(b->batCacheid);
}

BAT *
bat_descriptor(bat bid, char *func)
{
	BAT *b = BATdescriptor(bid);

	if (bm_debug)
		printf("bat_destriptor %s %d (%d,%d)\n", func, bid, BBPrefs(bid), BBP_lrefs(bid));
	return b;
}

BAT *
bat_copy(BAT *b, char *func)
{
	BAT *nb = BATcopy(b);

	if (bm_debug)
		printf("bat_copy(%s) %d (%d,%d)\n", func, nb->batCacheid, BBPrefs(nb->batCacheid), BBP_lrefs(nb->batCacheid));
	return nb;
}

BAT *
bat_new(int ht, int tt, size_t size, char *func)
{
	BAT *nb = BATnew(ht, tt, size);

	if (bm_debug)
		printf("bat_new(%s) %d (%d,0)\n", func, nb->batCacheid, BBPrefs(nb->batCacheid));
	if (ht == TYPE_void)
		BATseqbase(nb, 0);
	nb->batDirty |= 2;
	return nb;
}

void
bat_incref(bat bid, bit flag, char *func)
{
	BBPincref(bid, flag);
	if (bm_debug)
		printf("bat_incref(%s) %d (%d,%d)\n", func, bid, BBP_refs(bid), BBP_lrefs(bid));
}

void
bat_decref(bat bid, bit flag)
{
	if (bm_debug)
		printf("bat_decref() %d (%d,%d)\n", bid, BBP_refs(bid), BBP_lrefs(bid));
	BBPdecref(bid, flag);
}

ptr
bun_find(BAT *b, ptr v)
{
	BUN p = BUNfnd(b, v);

	if (p)
		return BUNtail(b, p);
	return NULL;
}

static BAT *
bm_create_bat(int ht, int tt, size_t size)
{
	BAT *b = bat_new(ht, tt, size, "bm_create_bat");

	/* Make persistent as only persistent bats keep delta information */
	bat_incref(b->batCacheid, TRUE, "bm_create_bat");
	return b;
}

static oid
bm_add_bat_intern(bm *bm, oid lbid, oid bid, char *name, int version, int mode)
{
	oid vid = bm->vid;
	BUNins(bm->bat_name, &vid, name);
	BUNins(bm->bat_bid, &vid, &bid);
	BUNins(bm->bat_lbid, &vid, &lbid);
	BUNins(bm->bat_mode, &vid, &mode);
	BUNins(bm->bat_version, &vid, &version);

	bat_incref(bid, TRUE, "bm_add_bat_intern");
	bm->vid++;

	if (version > bm->version)
		bm->version = version;

	return vid;
}

bm *
bm_create(int debug)
{
	bm *bm = NEW(struct bm);
	bm->debug = debug;
	bm->vid = 1;
	bm->lbid = 1;
	bm->version = 0;

	bm->bat_name = bm_create_bat(TYPE_oid, TYPE_str, BUFSIZ);
	bm->bat_bid = bm_create_bat(TYPE_oid, TYPE_oid, BUFSIZ);
	bm->bat_lbid = bm_create_bat(TYPE_oid, TYPE_oid, BUFSIZ);
	bm->bat_mode = bm_create_bat(TYPE_oid, TYPE_int, BUFSIZ);
	bm->bat_version = bm_create_bat(TYPE_oid, TYPE_int, BUFSIZ);
	bm->bat_oversion = NULL;
	bm->bat_pbid = NULL;
	bm->bat_opbid = NULL;
	return bm;
}

void
bm_destroy(bm *bm)
{
	BUN p, q;
	BAT *b = bm->bat_bid;

	/* destroy the deleted */
	for (p = b->batDeleted; p < b->batFirst; p = BUNnext(b, p)) {
		bat bid = *(oid *) BUNtail(b, p);

		bat_decref(bid, TRUE);
	}
	/* free resources */
	BATloop(b, p, q) {
		bat bid = *(oid *) BUNtail(b, p);

		bat_decref(bid, TRUE);
	}

	bat_decref(bm->bat_name->batCacheid, TRUE);
	bat_decref(bm->bat_bid->batCacheid, TRUE);
	bat_decref(bm->bat_lbid->batCacheid, TRUE);
	bat_decref(bm->bat_mode->batCacheid, TRUE);
	bat_decref(bm->bat_version->batCacheid, TRUE);
	bat_destroy(bm->bat_name);
	bat_destroy(bm->bat_bid);
	bat_destroy(bm->bat_lbid);
	bat_destroy(bm->bat_mode);
	bat_destroy(bm->bat_version);

	if (bm->bat_oversion)
		bat_destroy(bm->bat_oversion);

	if (bm->bat_pbid)
		bat_destroy(bm->bat_pbid);

	if (bm->bat_opbid)
		bat_destroy(bm->bat_opbid);
	_DELETE(bm);
}

bm *
bm_dup(bm *obm)
{
	BUN p, q;
	BAT *b = obm->bat_version;
	bm *nbm = bm_create(obm->debug);

	nbm->version = obm->version;

	BATloop(b, p, q) {
		int version = *(int *) BUNtail(b, p);
		oid id = *(oid *) BUNhead(b, p);
		str name = BUNtail(obm->bat_name, BUNfnd(obm->bat_name, &id));
		bat bid = *(oid *) BUNtail(obm->bat_bid,
					   BUNfnd(obm->bat_bid, &id));
		oid lbid = *(oid *) BUNtail(obm->bat_lbid,
					    BUNfnd(obm->bat_lbid, &id));

		if (lbid >= nbm->lbid)
			nbm->lbid = lbid + 1;
		(void) bm_add_bat_intern(nbm, lbid, bid, name, version, BM_READ);
	}
	BATfakeCommit(nbm->bat_version);
	BATfakeCommit(nbm->bat_name);
	BATfakeCommit(nbm->bat_bid);
	BATfakeCommit(nbm->bat_lbid);
	BATfakeCommit(nbm->bat_mode);
	return nbm;
}

int
bm_save(bm *bm, FILE *fp)
		/* keep the bat id's, schema_table_* can become too long! */
{
	BUN p, q;
	BAT *b = bm->bat_version;
	BAT *pbat = bm_create_bat(TYPE_oid, TYPE_oid, BATcount(b));

	BATloop(b, p, q) {
		BUN z;

		/*
		 * Save all bats using name_version 
		 */
		oid id = *(oid *) BUNhead(b, p);
		int version = *(int *) BUNtail(b, p);
		int oversion = 0;
		str name = BUNtail(bm->bat_name, BUNfnd(bm->bat_name, &id));
		oid bid = *(oid *) BUNtail(bm->bat_bid, BUNfnd(bm->bat_bid, &id));
		oid pbid = bid;

		if (bm->bat_oversion && (z = BUNfnd(bm->bat_oversion, &id)))
			 oversion = *(int *) BUNtail(bm->bat_oversion, z);

		/* keep the bat id's, schema_table_* can become too long! */
		if (bm->bat_pbid && (z = BUNfnd(bm->bat_pbid, &id)))
			 pbid = *(oid *) BUNtail(bm->bat_pbid, z);

		if (version > oversion) {
#ifdef RENAME
			char name_version[BUFSIZ];
#endif
			BAT *b, *o = bat_descriptor(bid, "bm_save");

			if (!o) 
				return -1;
			if ((b = bat_copy(o, "bm_save")) == NULL)
				return -1;

#ifdef RENAME
			snprintf(name_version, BUFSIZ, "%s_%d", name, version);
			if (bm->debug & 1)
				printf("bm_save %s %ld\n", name_version, BATcount(b));
			BATrename(b, name_version);
#endif
			BATmode(b, PERSISTENT);
			BATkey(b, o->hkey);
			BATkey(BATmirror(b), o->tkey);
			pbid = b->batCacheid;
			bat_destroy(b);
			bat_destroy(o);
		}
		BUNins(pbat, &id, &pbid);

		fprintf(fp, "%s,%d," SZFMT "\n", name, version, (size_t)pbid);
		if (!(BBP_status(pbid)&BBPPERSISTENT)) 
			return -1;
	}
	assert(!bm->bat_opbid);

	if (bm->bat_pbid)
		bm->bat_opbid = bm->bat_pbid;
	bm->bat_pbid = pbat;

	if (bm->bat_oversion)
		bat_destroy(bm->bat_oversion);
	bm->bat_oversion = bat_copy(bm->bat_version, "bm_cleanup");
	return 0;
}

void
bm_cleanup(bm *bm)
{
	BUN p, q;

	if (bm->bat_opbid) {
		BAT *b = bm->bat_opbid;

		BATloop(b, p, q) {
			BUN z;
			oid id = *(oid *) BUNhead(b, p);
			oid opbid = *(oid *) BUNtail(b, p);
			oid pbid = 0;

			/* keep the bat id's, schema_table_* can become too long! */
			if (bm->bat_pbid && (z = BUNfnd(bm->bat_pbid, &id)))
				 pbid = *(oid *) BUNtail(bm->bat_pbid, z);

			if (opbid != pbid) {
				BAT *ob = NULL;

				ob = bat_descriptor(opbid, "bm_cleanup");
				BATmode(ob, TRANSIENT);
				bat_destroy(ob);
			}
		}
		bat_destroy(bm->bat_opbid);
	}
	bm->bat_opbid = NULL;
}

int
bm_load(bm *bm, FILE *fp)
{
	BAT *pbid = bm_create_bat(TYPE_oid, TYPE_oid, BUFSIZ);
	char line[BUFSIZ];

	while (fgets(line, BUFSIZ, fp) != NULL && line[0] != '\n') {
		char *s = strchr(line, ',');

		if (s) {
			char *name = NULL;
			oid vid, bid = 0;
			int version = 0;

			name = line;
			*s++ = 0;
			version = strtol(s, NULL, 10);
			s = strchr(s, ',');
			if (!s) {
				GDKwarning("wrong bm format, please do a dump/restore!\n");
				return -1;
			}
			s++;	/* skip , */
			bid = strtol(s, NULL, 10);

			if ((s = strchr(s, '\n')) != NULL)
				*s = 0;
			vid = bm_add_bat_intern(bm, bm->lbid++, bid, line, version, BM_WRITE);

			if (!(BBP_status(bid)&BBPPERSISTENT)) 
				return -1;

			BUNins(pbid, &vid, &bid);

			if (bm->debug & 1)
				printf("bm_load %s %d " SZFMT "\n", name, version, (size_t)bid);
		}
	}
	if (!bm->bat_oversion)
		bm->bat_oversion = bat_copy(bm->bat_version, "bm_load");
	BATfakeCommit(bm->bat_version);
	BATfakeCommit(bm->bat_name);
	BATfakeCommit(bm->bat_bid);
	BATfakeCommit(bm->bat_lbid);
	BATfakeCommit(bm->bat_mode);
	bm->bat_pbid = pbid;
	return 0;
}

void
bm_commit(bm *bm, int tid)
{
	BUN p, q;
	BAT *b = bm->bat_version;
	BAT *bat_mode = bm_create_bat(TYPE_oid, TYPE_int, BUFSIZ);
	int bm_read = BM_READ;

	BATloop(b, p, q) {
		oid id = *(oid *) BUNhead(b, p);
		int version = *(int *) BUNtail(b, p);

		BUNins(bat_mode, &id, &bm_read);

		if (tid == version) {
			bat bid = *(oid *) BUNtail(bm->bat_bid,
						   BUNfnd(bm->bat_bid, &id));
			BAT *b = bat_descriptor(bid, "bm_commit");

			BATfakeCommit(b);
			bat_destroy(b);
		}
	}
	/* remove the destroyed bats */
	b = bm->bat_bid;

	for (p = b->batDeleted; p < b->batFirst; p = BUNnext(b, p)) {
		bat bid = *(oid *) BUNtail(b, p);

		bat_decref(bid, TRUE);
	}
	BATfakeCommit(bm->bat_version);
	BATfakeCommit(bm->bat_name);
	BATfakeCommit(bm->bat_bid);
	BATfakeCommit(bm->bat_lbid);
	bat_decref(bm->bat_mode->batCacheid, TRUE);
	bat_destroy(bm->bat_mode);

	BATfakeCommit(bat_mode);
	bm->bat_mode = bat_mode;
}

void
bm_abort(bm *bm, int tid)
{
	BUN p;
	BAT *b;

	/* remove the created bats */
	b = bm->bat_bid;

	for (p = b->batInserted; p < BUNlast(b); p = BUNnext(b, p)) {
		bat bid = *(oid *) BUNtail(b, p);

		bat_decref(bid, TRUE);
	}
	b = bm->bat_version;

	for (p = BUNfirst(b); p < b->batInserted; p = BUNnext(b, p)) {
		int version = *(int *) BUNtail(b, p);

		if (tid == version) {
			oid id = *(oid *) BUNhead(b, p);
			bat bid = *(oid *) BUNtail(bm->bat_bid,
						   BUNfnd(bm->bat_bid, &id));
			BAT *b = bat_descriptor(bid, "bm_abort");

			BATundo(b);
			BATfakeCommit(b);
			bat_destroy(b);
		}
	}
	BATundo(bm->bat_version);
	BATundo(bm->bat_name);
	BATundo(bm->bat_bid);
	BATundo(bm->bat_lbid);
	BATundo(bm->bat_mode);
}

oid
bm_name2lbid(bm *bm, char *name)
{
	BAT *r_bat_name = BATmirror(bm->bat_name);
	oid res = 0;
	BUN p = BUNfnd(r_bat_name, name);

	if (p) {
		BUN q = BUNfnd(bm->bat_lbid, BUNtail(r_bat_name, p));
		res = *(oid *) BUNtail(bm->bat_lbid, q);
	}
	return res;
}

oid
bm_lbid2vid(bm *bm, oid lbid)
{
	BAT *r_bat_lbid = BATmirror(bm->bat_lbid);
	oid res = 0;
	BUN p = BUNfnd(r_bat_lbid, &lbid);

	if (p) {
		res = *(oid *) BUNtail(r_bat_lbid, p);
	}
	return res;
}

char *
bm_lbid2name(bm *bm, oid lbid)
{
	oid vid = bm_lbid2vid(bm, lbid);
	return BUNtail(bm->bat_name, BUNfnd(bm->bat_name, &vid));
}

void
bm_new_version(bm *bm, oid lbid, int version)
{
	oid vid = bm_lbid2vid(bm, lbid);
	BUNreplace(bm->bat_version, (ptr) &vid, &version);

	if (version > bm->version)
		bm->version = version;
}

#ifdef RENAME
static void
bat_rename(bat bid, char *name, int version, int mode)
{
	char buf[BUFSIZ];
	BAT *b = bat_descriptor(bid, "bat_rename");

	snprintf(buf, BUFSIZ, "%s_%c_%d", name, (mode == BM_WRITE) ? 'W' : 'R', version);
	if (strlen(buf) < (IDLENGTH - 1))
		BATrename(b, buf);
	bat_destroy(b);
}
#endif


static void
_bm_new_bat(bm *bm, oid lbid, oid bid)
{
	int mode = BM_WRITE;
	oid vid = bm_lbid2vid(bm, lbid);

/* Stefan: not used ?
	bat obid = *(oid*)BUNtail(bm->bat_bid, BUNfnd(bm->bat_bid, &vid));
*/
	/* no bat_decref(obid, TRUE); here as this needs to be done 
	 *  by the bm_{commit,abort,destroy} */
	bat_incref(bid, TRUE, "bm_new_bat");
	BUNreplace(bm->bat_bid, (ptr) &vid, &bid);
	BUNreplace(bm->bat_mode, (ptr) &vid, &mode);
}

void
bm_new_bat(bm *bm, oid lbid, BAT *b)
{
	if (b->batRestricted) 
		BATsetaccess(b, BAT_WRITE);
	_bm_new_bat(bm, lbid, (oid) b->batCacheid);
}

oid
bm_add_bat(bm *bm, oid bid, char *name, int version)
{
	oid lbid = bm_find_bat(bm, name);

	if (!lbid) {
		lbid = bm->lbid++;
		(void) bm_add_bat_intern(bm, lbid, bid, name, version, BM_WRITE);

#ifdef RENAME
		if (!version)
			bat_rename(bid, name, version, BM_WRITE);
#endif
	} else {
		_bm_new_bat(bm, lbid, bid);
		bm_new_version(bm, lbid, version);
	}
	if (version > bm->version)
		bm->version = version;

	return lbid;
}

void
bm_del_bat(bm *bm, oid lbid)
{
	oid vid = bm_lbid2vid(bm, lbid);
	BUN p = BUNfnd(bm->bat_bid, &vid);

	/* Only bats created in this session, can be destroyed directly.
	   Others should be handled by the bm_{commit,abort,destroy} 
	 */
	if (p >= bm->bat_bid->batInserted) {
		bat bid = *(oid *) BUNtail(bm->bat_bid, p);

		bat_decref(bid, TRUE);
	}
	BUNdelHead(bm->bat_version, &vid);
	BUNdelHead(bm->bat_name, &vid);
	BUNdelHead(bm->bat_bid, &vid);
	BUNdelHead(bm->bat_lbid, &vid);
	BUNdelHead(bm->bat_mode, &vid);

/*
	if (bm->bat_oversion)
		BUNdelHead(bm->bat_oversion, &vid);
*/
}

oid
bm_find_bat(bm *bm, char *name)
{
	return bm_name2lbid(bm, name);
}

BAT *
bm_lbid2bat(bm *bm, oid lbid)
{
	BAT *b;
	bat bid;
	oid vid;

	vid = bm_lbid2vid(bm, lbid);

	bid = *(oid *) BUNtail(bm->bat_bid, BUNfnd(bm->bat_bid, &vid));

	b = bat_descriptor(bid, "bm_lbid2bat");
	return b;
}

int
bm_lbid2version(bm *bm, oid lbid)
{
	oid vid = bm_lbid2vid(bm, lbid);
	return *(int *) BUNtail(bm->bat_version, BUNfnd(bm->bat_version, &vid));
}

int
bm_lbid2mode(bm *bm, oid lbid)
{
	oid vid = bm_lbid2vid(bm, lbid);
	return *(int *) BUNtail(bm->bat_mode, BUNfnd(bm->bat_mode, &vid));
}

int
bm_version(bm *bm)
{
	return bm->version;
}
