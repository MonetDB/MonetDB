@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f bat_store

@h
#ifndef BATSTORE_H
#define BATSTORE_H

#include "sql_storage.h"

#include <gdk.h>

#define isNew(x)	(x->base.flag == TR_NEW)
#define isTemp(x)	(isNew(x)||!x->t->persists||x->t->clear)

extern BAT *bind_bat(sql_trans *tr, sql_column *c, int access);
extern BAT *bind_ubat(sql_trans *tr, sql_column *c, int access);
extern BAT *bind_dbat(sql_trans *tr, sql_table *t, int access);
extern BAT *bind_idx(sql_trans *tr, sql_idx * i, int access);
extern BAT *bind_uidx(sql_trans *tr, sql_idx * i, int access);

#endif /*BATSTORE_H */
@c
#include "bat_store.h"
#include <bat.h>
#include "bat_logger.h"
#include "bat_bm.h"
#include "sql_types.h"
#include "sql_backend.h"
#include "bat_sequence.h"

/* version 02.00.00 of catalog */
#define CATALOG_VERSION 20001

static struct logger *logger = NULL;
static MT_Lock bs_lock = NULL;
static sql_trans *gtrans = NULL;
static int bs_debug = 0;

int
key_cmp(sql_key *k, sqlid *id)
{
	if (k && id &&k->base.id == *id)
		return 0;
	return 1;
}

static int stamp = 1;

static int timestamp () {
	return stamp++;
}

static void
temp_destroy(oid b)
{
	BBPdecref(b, TRUE);
}

static void
temp_dup(oid b)
{
	BBPincref(b, TRUE);
}

static oid
temp_create(BAT *b)
{
	temp_dup(b->batCacheid);
	return b->batCacheid;
}

static BAT *
temp_descriptor(oid b)
{
	return BATdescriptor((bat) b);
}

static oid
temp_copy(oid b, int clear)
{
/* make a copy of b, if clear is set only create a empty bat */
	BAT *o = temp_descriptor(b);
	BAT *c;
	oid r;

	if (!clear) {
		c = bat_copy(o, "temp_copy");
	} else {
		c = bat_new(o->htype, o->ttype, BUFSIZ, "temp_copy");
	}
	r = temp_create(c);
	bat_destroy(c);
	return r;
}

/* probably not needed any more (also still in mvc) */
static BAT *
bat_lcopy(BAT *b, char *func)
{
	BAT *nb = bat_copy(b, func);

	BATkey(nb, b->hkey);
	BATkey(BATmirror(nb), b->tkey);

	bat_destroy(b);
	BATfakeCommit(nb);
	return nb;
}


static BAT *
col_bind(sql_trans *tr, oid lbid, sql_column *c, int access)
{
	BAT *b;

	if (!c->t->persists || c->t->clear) {
		b = temp_descriptor(lbid);
	} else {
		b = bm_lbid2bat(tr->bm, lbid);

		/* first write ie. need to copy */
		if (access && !bm_lbid2mode(tr->bm, lbid)) {
			if (bs_debug)
				fprintf(stderr, "new bat for column %s.%s\n", c->t->base.name, c->base.name);
			b = bat_lcopy(b, "col_bind");
			c->base.wtime = c->t->base.wtime = c->t->s->base.wtime = tr->wtime = tr->stime;
			if (access == UPD)
				c->base.rtime = c->t->base.rtime = c->t->s->base.rtime = tr->rtime = tr->stime;
			bm_new_bat(tr->bm, lbid, b);

			b->batDirty |= 2;
		}
	}
	return b;
}

BAT *
bind_bat(sql_trans *tr, sql_column *c, int access)
{
	if (c->bat.ibid) {
		BAT *i = temp_descriptor(c->bat.ibid);

		if (access != INS) {
			/* on all but inserts merge! */
			BAT *b = col_bind(tr, c->bat.bid, c, INS);

			void_append_bat(b, i);
			assert(b->htype == TYPE_void);

			bat_destroy(i);
			temp_destroy(c->bat.ibid);
			c->bat.ibid = 0;

			if (access == UPD) {
				bat_destroy(b);
				return col_bind(tr, c->bat.bid, c, access);
			}
			i = b;
		}
		i->batDirty |= 2;
		return i;
	} else {
		if (access == INS && c->base.wtime == 0 && c->t->persists && !c->t->clear && c->base.flag != TR_NEW) {
			int type = ATOMindex(c->type->type->base.name);
			BAT *b = bat_new(TYPE_void, type, c->t->sz, "bind_bat");

			c->bat.ibid = temp_create(b);

			c->base.wtime = c->t->base.wtime = c->t->s->base.wtime = tr->wtime = tr->stime;
			return b;
		}
	}
	return col_bind(tr, c->bat.bid, c, access);
}

BAT *
bind_ubat(sql_trans *tr, sql_column *c, int access)
{
	return col_bind(tr, c->bat.ubid, c, access);
}

static BAT *
tab_bind(sql_trans *tr, oid lbid, sql_table *t, int access)
{
	BAT *b;

	if (!t->persists || t->clear) {
		b = temp_descriptor(lbid);
	} else {
		b = bm_lbid2bat(tr->bm, lbid);

		/* first write ie. need to copy */
		if (access && !bm_lbid2mode(tr->bm, lbid)) {
			if (bs_debug)
				fprintf(stderr, "new bat for table %s\n", t->base.name);
			b = bat_lcopy(b, "tab_bind");
			t->base.wtime = t->s->base.wtime = tr->wtime = tr->stime;
			bm_new_bat(tr->bm, lbid, b);
		}
	}
	return b;
}

BAT *
bind_dbat(sql_trans *tr, sql_table *t, int access)
{
	return tab_bind(tr, t->dbid, t, access);
}

BAT *
bind_idx(sql_trans *tr, sql_idx * i, int access)
{
	return tab_bind(tr, i->bat.bid, i->t, access);
}

BAT *
bind_uidx(sql_trans *tr, sql_idx * i, int access)
{
	return tab_bind(tr, i->bat.ubid, i->t, access);
}

static size_t
void_delete_bat(BAT *b, BAT *d, int delta)
{
	size_t nr = 0;
	BUN r, s;
	ptr nil = ATOMnilptr(b->ttype);

	if (delta) {
		for (r = d->batInserted; r < BUNlast(d); r = BUNnext(d, r)) {
			oid delid = *(oid *) BUNtail(d, r);

			void_inplace(b, delid, nil);
			nr++;
		}
	} else {
		BATloop(d, r, s) {
			oid delid = *(oid *) BUNtail(d, r);

			void_inplace(b, delid, nil);
			nr++;
		}
	}
	return nr;
}

/* probably not needed any more */
static void
update_table_bat(BAT *b, BAT *ub, BAT *db)
{
	if (ub && BATcount(ub)) {
		void_replace_bat(b, ub);
	}
	if (db && BATcount(db)) {
		void_delete_bat(b, db, 0);
	}
}

void
kc_destroy(sql_kc *kc)
{
	_DELETE(kc);
}

void
key_destroy(sql_key *k)
{
	sql_ukey *uk;

	if (k->type == ukey || k->type == pkey) {
		uk = (sql_ukey *) k;
		if (uk->keys)
			list_destroy(uk->keys);
	}
	base_destroy(&k->base);
	list_destroy(k->columns);
	_DELETE(k);
}

void
idx_destroy(sql_idx * i)
{
	base_destroy(&i->base);
	list_destroy(i->columns);
	_DELETE(i);
}

void
column_destroy(sql_column *c)
{
	if (!c->t->persists || c->t->clear) {
		temp_destroy(c->bat.bid);
		temp_destroy(c->bat.ubid);
	}
	if (c->bat.ibid)
		temp_destroy(c->bat.ibid);

	base_destroy(&c->base);
	sql_subtype_destroy(c->type);
	if (c->def)
		_DELETE(c->def);
	_DELETE(c);
}

void
table_destroy(sql_table *t)
{
	if (!t->persists || t->clear) {
		temp_destroy(t->dbid);
	}
	base_destroy(&t->base);
	if (t->query)
		_DELETE(t->query);
	cs_destroy(&t->keys);
	cs_destroy(&t->idxs);
	cs_destroy(&t->columns);
	_DELETE(t);
}

void
schema_destroy(sql_schema *s)
{
	base_destroy(&s->base);
	list_destroy(s->keys);
	list_destroy(s->idxs);

	cs_destroy(&s->tables);
	_DELETE(s);
}

void
module_destroy(sql_module * s)
{
	cs_destroy(&s->funcs);
	cs_destroy(&s->types);
	base_destroy(&s->base);
	_DELETE(s);
}


sql_trans *
sql_trans_destroy(sql_trans *t)
{
	sql_trans *res = t->parent;

	if (t->name)
		_DELETE(t->name);

	cs_destroy(&t->schemas);
	cs_destroy(&t->modules);
	t->schema = NULL;
	bm_destroy(t->bm);

	_DELETE(t);
	return res;
}

static int
tr_flag(sql_base * b, int flag)
{
	if (flag == TR_OLD)
		return flag;
	return b->flag;
}

static BAT *
sys_bat(struct bm *bm, char *name)
{
	oid lbid = bm_find_bat(bm, name);
	BAT *b = bm_lbid2bat(bm, lbid);

	if (!bm_lbid2mode(bm, lbid)) {
		b = bat_lcopy(b, "sys_bat");
		bm_new_bat(bm, lbid, b);
	}
	assert(b);
	return b;
}


static void
load_keycolumn(sql_trans *tr, BAT *columns, BUN j, sql_key *k)
{
	sql_kc *kc = NEW(sql_kc);
	BAT *kc_col = sys_bat(tr->bm, "keycolumns_column");
	BAT *kc_trunc = sys_bat(tr->bm, "keycolumns_trunc");
	ptr lid = BUNhead(columns, j);
	char *name = bun_find(kc_col, lid);
	int trunc = *(int *) bun_find(kc_trunc, lid);
	sql_column *c = find_sql_column(k->t, name);

	assert(c);

	kc->c = c;
	kc->trunc = trunc;
	list_append(k->columns, kc);

	bat_destroy(kc_col);
	bat_destroy(kc_trunc);
}

static sql_key *
load_key(sql_trans *tr, BAT *keys, BUN j, sql_table *t)
{
	int ccnt;
	BAT *cols, *rcols;
	BAT *key_id = sys_bat(tr->bm, "keys_id");
	BAT *key_tpe = sys_bat(tr->bm, "keys_type");
	BAT *key_name = sys_bat(tr->bm, "keys_name");
	BAT *key_rkey = sys_bat(tr->bm, "keys_rkey");
	BAT *kc_id = sys_bat(tr->bm, "keycolumns_id");
	BAT *kc_nr = sys_bat(tr->bm, "keycolumns_nr");
	ptr lid = BUNhead(keys, j);
	key_type ktype = (key_type) *(int *) bun_find(key_tpe, lid);
	char *name = (char *) bun_find(key_name, lid);
	sql_key *nk = (ktype != fkey) ? (sql_key *) NEW(sql_ukey)
	    : (sql_key *) NEW(sql_fkey);
	BUN p, q;
	node *n;

	base_init(&nk->base, *(sqlid *) bun_find(key_id, lid), TR_OLD, name);
	nk->type = ktype;
	nk->columns = list_create((fdestroy) &kc_destroy);
	nk->t = t;

	if (ktype == ukey || ktype == pkey) {
		sql_ukey *uk = (sql_ukey *) nk;

		uk->keys = NULL;

		if (ktype == pkey)
			t->pkey = uk;
	} else {
		sql_fkey *fk = (sql_fkey *) nk;

		fk->rkey = NULL;
	}

	cols = BATselect(kc_id, (ptr) &nk->base.id, (ptr) &nk->base.id);

	rcols = BATsemijoin(kc_nr, cols);
	bat_destroy(cols);
	cols = BATmirror(rcols);
	rcols = BATsort(cols);
	bat_destroy(cols);
	cols = BATmirror(rcols);

	ccnt = BATcount(cols);
	if (ccnt) {
		BATloop(cols, p, q)
		    load_keycolumn(tr, cols, p, nk);
	}
	bat_destroy(cols);

	/* find idx with same name */
	n = list_find_name(nk->t->s->idxs, nk->base.name);
	if (n) {
		nk->idx = (sql_idx *) n->data;
		nk->idx->key = nk;
	}

	if (ktype == fkey) {
		sql_fkey *fk = (sql_fkey *) nk;
		sqlid rkey = *(sqlid *) bun_find(key_rkey, lid);
		node *n = list_find(t->s->keys, &rkey, (fcmp) &key_cmp);

		if (n) {
			sql_ukey *uk = n->data;

			fk->rkey = uk;
			if (!uk->keys)
				uk->keys = list_create(NULL);
			list_append(uk->keys, fk);
		}
	} else {		/* could be a set of rkeys */
		sql_ukey *uk = (sql_ukey *) nk;
		BAT *keys = BATselect(key_rkey, (ptr) &nk->base.id, (ptr) &nk->base.id);

		BATloop(keys, p, q) {
			ptr fkey_lid = (sqlid *) BUNhead(keys, p);
			sqlid fkey = *(sqlid *) bun_find(key_id, fkey_lid);
			node *n = list_find(t->s->keys, &fkey, (fcmp) &key_cmp);

			if (n) {
				sql_fkey *fk = n->data;

				if (!uk->keys)
					uk->keys = list_create(NULL);
				list_append(uk->keys, fk);
				fk->rkey = uk;
			}
		}
		BBPreclaim(keys);
	}

	bat_destroy(key_id);
	bat_destroy(key_tpe);
	bat_destroy(key_name);
	bat_destroy(key_rkey);
	bat_destroy(kc_id);
	bat_destroy(kc_nr);
	return nk;
}

static void
load_idxcolumn(sql_trans *tr, BAT *columns, BUN j, sql_idx * i)
{
	sql_kc *kc = NEW(sql_kc);
	BAT *kc_col = sys_bat(tr->bm, "keycolumns_column");
	BAT *kc_trunc = sys_bat(tr->bm, "keycolumns_trunc");
	ptr lid = BUNhead(columns, j);
	char *name = bun_find(kc_col, lid);
	int trunc = *(int *) bun_find(kc_trunc, lid);
	sql_column *c = find_sql_column(i->t, name);

	assert(c);

	kc->c = c;
	kc->trunc = trunc;
	list_append(i->columns, kc);

	bat_destroy(kc_col);
	bat_destroy(kc_trunc);
}

static sql_idx *
load_idx(sql_trans *tr, BAT *idxs, BUN j, sql_table *t)
{
	char bname[BUFSIZ];
	int ccnt;
	BAT *cols, *rcols;
	BAT *idx_id = sys_bat(tr->bm, "idxs_id");
	BAT *idx_tpe = sys_bat(tr->bm, "idxs_type");
	BAT *idx_name = sys_bat(tr->bm, "idxs_name");
	BAT *kc_id = sys_bat(tr->bm, "keycolumns_id");
	BAT *kc_nr = sys_bat(tr->bm, "keycolumns_nr");
	ptr lid = BUNhead(idxs, j);
	idx_type itype = (idx_type) * (int *) bun_find(idx_tpe, lid);
	char *name = (char *) bun_find(idx_name, lid);
	sql_idx *ni = NEW(sql_idx);
	BUN p, q;

	base_init(&ni->base, *(sqlid *) bun_find(idx_id, lid), TR_OLD, name);
	ni->type = itype;

	ni->columns = list_create((fdestroy) &kc_destroy);
	ni->t = t;
	ni->key = NULL;

	cols = BATselect(kc_id, (ptr) &ni->base.id, (ptr) &ni->base.id);

	rcols = BATsemijoin(kc_nr, cols);
	bat_destroy(cols);
	cols = BATmirror(rcols);
	rcols = BATsort(cols);
	bat_destroy(cols);
	cols = BATmirror(rcols);

	ccnt = BATcount(cols);
	if (ccnt) {
		BATloop(cols, p, q)
		    load_idxcolumn(tr, cols, p, ni);
	}
	bat_destroy(cols);

	snprintf(bname, BUFSIZ, "%s_%s", t->base.name, ni->base.name);
	ni->bat.bid = bm_find_bat(tr->bm, bname);
	ni->bat.ibid = 0;

	snprintf(bname, BUFSIZ, "U_%s_%s", t->base.name, ni->base.name);
	ni->bat.ubid = bm_find_bat(tr->bm, bname);

	if (ni->bat.bid && ni->bat.ubid) {
		BAT *ub = bm_lbid2bat(tr->bm, ni->bat.ubid);
		BAT *db = bm_lbid2bat(tr->bm, t->dbid);

		if (BATcount(ub) || BATcount(db)) {
			BAT *b = bind_idx(tr, ni, UPD);

			update_table_bat(b, ub, db);
			bat_destroy(b);
		}
		bat_destroy(ub);
		bat_destroy(db);
	}

	bat_destroy(idx_id);
	bat_destroy(idx_tpe);
	bat_destroy(idx_name);
	bat_destroy(kc_id);
	bat_destroy(kc_nr);
	return ni;
}

static sql_column *
load_column(sql_trans *tr, sql_table *t, BAT *columns, BUN j)
{
	char *def;
	char name[BUFSIZ], *tpe;
	sql_column *c = NEW(sql_column);
	ptr lid = BUNhead(columns, j);
	int sz, d;
	BAT *column_id = sys_bat(tr->bm, "pcolumns_id");
	BAT *column_name = sys_bat(tr->bm, "pcolumns_name");
	BAT *column_type = sys_bat(tr->bm, "pcolumns_type");
	BAT *column_type_digits = sys_bat(tr->bm, "pcolumns_type_digits");
	BAT *column_type_scale = sys_bat(tr->bm, "pcolumns_type_scale");
	BAT *column_default = sys_bat(tr->bm, "pcolumns_default");
	BAT *column_null = sys_bat(tr->bm, "pcolumns_null");
	BAT *column_number = sys_bat(tr->bm, "pcolumns_number");

	base_init(&c->base, *(sqlid *) bun_find(column_id, lid), TR_OLD, (char *) bun_find(column_name, lid));

	tpe = (char *) bun_find(column_type, lid);
	sz = *(int *) bun_find(column_type_digits, lid);
	d = *(int *) bun_find(column_type_scale, lid);
	c->type = sql_bind_subtype(tpe, sz, d);
	if (!c->type)
		c->type = sql_create_subtype(sql_trans_bind_type(tr, tpe), sz, d);
	def = (char *) bun_find(column_default, lid);
	c->def = NULL;
	if (ATOMcmp(TYPE_str, ATOMnilptr(TYPE_str), def) != 0)
		c->def = _strdup(def);
	c->null = *(bit *) bun_find(column_null, lid);
	c->colnr = *(int *) bun_find(column_number, lid);
	c->t = t;

	c->bat.bid = c->bat.ibid = c->bat.ubid = 0;

	if (t->table && !t->clear) {
		snprintf(name, BUFSIZ, "%s_%s", t->base.name, c->base.name);
		c->bat.bid = bm_find_bat(tr->bm, name);

		snprintf(name, BUFSIZ, "U_%s_%s", t->base.name, c->base.name);
		c->bat.ubid = bm_find_bat(tr->bm, name);
	} else if (t->table && t->clear) {
		int type = ATOMindex(c->type->type->base.name);
		BAT *b = bat_new(TYPE_void, type, t->sz, "load_column");
		BAT *u = bat_new(TYPE_oid, type, t->sz, "load_column");

		c->bat.bid = temp_create(b);
		c->bat.ubid = temp_create(u);

		bat_destroy(b);
		bat_destroy(u);
	} else if (!t->table && !t->query) {
		snprintf(name, BUFSIZ, "%s_%s", t->base.name, c->base.name);
		c->bat.bid = bm_find_bat(tr->bm, name);
	}

	if (bs_debug)
		fprintf(stderr, "\t\tload column %s\n", c->base.name);

	if (c->bat.bid && c->bat.ubid && !t->clear) {
		BAT *b  = bm_lbid2bat(tr->bm, c->bat.bid);
		BAT *ub = bm_lbid2bat(tr->bm, c->bat.ubid);
		BAT *db = bm_lbid2bat(tr->bm, t->dbid);

		t->cnt = (BATcount(b)-BATcount(db));
		bat_destroy(b);
		if (BATcount(ub) || BATcount(db)) {
			BAT *b = bind_bat(tr, c, UPD);

			update_table_bat(b, ub, db);
			bat_destroy(b);
		}
		bat_destroy(ub);
		bat_destroy(db);
	}

	bat_destroy(column_id);
	bat_destroy(column_name);
	bat_destroy(column_type);
	bat_destroy(column_type_digits);
	bat_destroy(column_type_scale);
	bat_destroy(column_default);
	bat_destroy(column_null);
	bat_destroy(column_number);
	return c;
}

static sql_table *
load_table(sql_trans *tr, sql_schema *s, BAT *tables, BUN j)
{
	char name[BUFSIZ], *query;
	sql_table *t = NEW(sql_table);
	ptr lid = BUNhead(tables, j);
	BAT *cols, *rcols, *keys, *idxs;
	BUN p, q;
	int ccnt;
	BAT *column_table = sys_bat(tr->bm, "pcolumns_table_id");
	BAT *column_number = sys_bat(tr->bm, "pcolumns_number");
	BAT *key_table = sys_bat(tr->bm, "keys_table_id");
	BAT *idx_table = sys_bat(tr->bm, "idxs_table_id");
	BAT *table_id = sys_bat(tr->bm, "ptables_id");
	BAT *table_names = sys_bat(tr->bm, "ptables_name");
	BAT *table_queries = sys_bat(tr->bm, "ptables_query");
	BAT *table_istable = sys_bat(tr->bm, "ptables_istable");
	BAT *table_system = sys_bat(tr->bm, "ptables_system");
	BAT *table_clear = sys_bat(tr->bm, "ptables_clear");

	base_init(&t->base, *(sqlid *) bun_find(table_id, lid), TR_OLD, bun_find(table_names, lid));
	query = (char *) bun_find(table_queries, lid);
	t->query = NULL;
	if (ATOMcmp(TYPE_str, ATOMnilptr(TYPE_str), query) != 0)
		t->query = _strdup(query);
	t->table = *(bit *) bun_find(table_istable, lid);
	t->system = *(bit *) bun_find(table_system, lid);
	t->clear = *(bit *) bun_find(table_clear, lid);
	t->persists = 1;
	t->cleared = 0;

	t->pkey = NULL;
	t->s = s;
	t->sz = BUFSIZ;
	t->cnt = 0;

	cs_init(&t->columns, (fdestroy) &column_destroy);
	cs_init(&t->idxs, (fdestroy) &idx_destroy);
	cs_init(&t->keys, (fdestroy) &key_destroy);

	if (t->table) {
		if (!t->clear) {
			snprintf(name, BUFSIZ, "D_%s", t->base.name);
			t->dbid = bm_find_bat(tr->bm, name);
		} else {
			BAT *b = bat_new(TYPE_void, TYPE_oid, t->sz, "load_table");

			t->dbid = temp_create(b);
			bat_destroy(b);
		}
	}

	cols = BATselect(column_table, (ptr) &t->base.id, (ptr) &t->base.id);

	rcols = BATsemijoin(column_number, cols);
	bat_destroy(cols);
	cols = BATmirror(rcols);
	rcols = BATsort(cols);
	bat_destroy(cols);
	cols = BATmirror(rcols);

	if (bs_debug)
		fprintf(stderr, "\tload table %s\n", t->base.name);

	BATloop(cols, p, q)
	    cs_add(&t->columns, load_column(tr, t, cols, p), TR_OLD);

	bat_destroy(cols);

	/* load idx's first as the may be needed by the keys */
	idxs = BATselect(idx_table, (ptr) &t->base.id, (ptr) &t->base.id);

	ccnt = BATcount(idxs);
	if (t->table && ccnt) {
		BATloop(idxs, p, q) {
			sql_idx *i;

			cs_add(&t->idxs, i = load_idx(tr, idxs, p, t), TR_OLD);
			list_append(s->idxs, i);
		}
	}
	bat_destroy(idxs);

	keys = BATselect(key_table, (ptr) &t->base.id, (ptr) &t->base.id);

	ccnt = BATcount(keys);
	if (t->table && ccnt) {
		BATloop(keys, p, q) {
			sql_key *k;

			cs_add(&t->keys, k = load_key(tr, keys, p, t), TR_OLD);
			list_append(s->keys, k);
		}
	}

	bat_destroy(keys);

	bat_destroy(idx_table);
	bat_destroy(key_table);
	bat_destroy(column_table);
	bat_destroy(column_number);
	bat_destroy(table_id);
	bat_destroy(table_names);
	bat_destroy(table_queries);
	bat_destroy(table_istable);
	return t;
}

static sql_type *
load_type(sql_trans *tr, sql_module * m, BAT *types, BUN j)
{
	sql_type *t = NEW(sql_type);
	ptr lid = BUNhead(types, j);
	BAT *type_id = sys_bat(tr->bm, "types_id");
	BAT *type_systemname = sys_bat(tr->bm, "types_systemname");
	BAT *type_sqlname = sys_bat(tr->bm, "types_sqlname");
	BAT *type_digits = sys_bat(tr->bm, "types_digits");
	BAT *type_scale = sys_bat(tr->bm, "types_scale");
	BAT *type_radix = sys_bat(tr->bm, "types_radix");
	BAT *type_eclass = sys_bat(tr->bm, "types_eclass");

	base_init(&t->base, *(sqlid *) bun_find(type_id, lid), TR_OLD, bun_find(type_systemname, lid));
	t->sqlname = _strdup((char *) bun_find(type_sqlname, lid));
	t->digits = *(int *) bun_find(type_digits, lid);
	t->scale = *(int *) bun_find(type_scale, lid);
	t->radix = *(int *) bun_find(type_radix, lid);
	t->eclass = *(int *) bun_find(type_eclass, lid);
	t->localtype = ATOMindex(t->base.name);
	t->m = m;

	bat_destroy(type_id);
	bat_destroy(type_systemname);
	bat_destroy(type_sqlname);
	bat_destroy(type_digits);
	bat_destroy(type_scale);
	bat_destroy(type_radix);
	bat_destroy(type_eclass);
	return t;
}

static sql_arg *
load_arg(sql_trans *tr, sql_func * f, BAT *args, BUN j)
{
	char *tpe;
	sql_arg *a = NEW(sql_arg);
	ptr lid = BUNhead(args, j);
	int sz, d;
	BAT *arg_name = sys_bat(tr->bm, "args_name");
	BAT *arg_type = sys_bat(tr->bm, "args_type");
	BAT *arg_type_digits = sys_bat(tr->bm, "args_type_digits");
	BAT *arg_type_scale = sys_bat(tr->bm, "args_type_scale");

	(void)f;
	a->name = _strdup((char *) bun_find(arg_name, lid));
	tpe = (char *) bun_find(arg_type, lid);
	sz = *(int *) bun_find(arg_type_digits, lid);
	d = *(int *) bun_find(arg_type_scale, lid);
	a->type = sql_bind_subtype(tpe, sz, d);
	if (!a->type)
		a->type = sql_create_subtype(sql_trans_bind_type(tr, tpe), sz, d);

	bat_destroy(arg_name);
	bat_destroy(arg_type);
	bat_destroy(arg_type_digits);
	bat_destroy(arg_type_scale);
	return a;
}

static sql_func *
load_func(sql_trans *tr, sql_module * m, BAT *funcs, BUN j)
{
	sql_func *t = NEW(sql_func);
	ptr lid = BUNhead(funcs, j);
	BAT *args, *rargs;
	BUN p, q;
	BAT *func_id = sys_bat(tr->bm, "functions_id");
	BAT *func_name = sys_bat(tr->bm, "functions_name");
	BAT *func_func = sys_bat(tr->bm, "functions_func");
	BAT *func_sql = sys_bat(tr->bm, "functions_sql");
	BAT *func_aggr = sys_bat(tr->bm, "functions_aggr");
	BAT *arg_func_id = sys_bat(tr->bm, "args_func_id");
	BAT *arg_number = sys_bat(tr->bm, "args_number");
	int first = 1;

	base_init(&t->base, *(sqlid *) bun_find(func_id, lid), TR_OLD, bun_find(func_name, lid));
	t->imp = _strdup((char *) bun_find(func_func, lid));
	t->sql = *(bit *) bun_find(func_sql, lid);
	t->aggr = *(bit *) bun_find(func_aggr, lid);
	t->res = NULL;
	t->m = m;

	args = BATselect(arg_func_id, (ptr) &t->base.id, (ptr) &t->base.id);

	rargs = BATsemijoin(arg_number, args);
	bat_destroy(args);
	args = BATmirror(rargs);
	rargs = BATsort(args);
	bat_destroy(args);
	args = BATmirror(rargs);

	if (bs_debug)
		fprintf(stderr, "\tload table %s\n", t->base.name);

	t->ops = list_create((fdestroy)&arg_destroy);
	BATloop(args, p, q) {
		sql_arg *a = load_arg(tr, t, args, p);
		if (first) {
			first = 0;
			if (strcmp(a->name, "result") == 0) {
				t -> res = sql_dup_subtype(a->type);
				arg_destroy(a);
			} else {
				list_append(t->ops, a);
			}
		} else {
			list_append(t->ops, a);
		}
	}
	bat_destroy(args);

	bat_destroy(func_id);
	bat_destroy(func_name);
	bat_destroy(func_func);
	bat_destroy(func_sql);
	bat_destroy(func_aggr);
	bat_destroy(arg_func_id);
	bat_destroy(arg_number);
	return t;
}

static sql_schema *
load_schema(sql_trans *tr, BAT *schemas, BUN j)
{
	sql_schema *s = NEW(sql_schema);
	ptr lid = BUNhead(schemas, j);
	BAT *tables;
	BUN p, q;
	BAT *schema_names = sys_bat(tr->bm, "schemas_name");
	BAT *schema_auths = sys_bat(tr->bm, "schemas_authorization");
	BAT *table_schema = sys_bat(tr->bm, "ptables_schema_id");

	base_init(&s->base, *(sqlid *) bun_find(schemas, lid), TR_OLD, bun_find(schema_names, lid));
	s->auth_id = *(sqlid *) bun_find(schema_auths, lid);
	s->keys = list_create((fdestroy) NULL);
	s->idxs = list_create((fdestroy) NULL);
	cs_init(&s->tables, (fdestroy) &table_destroy);

	if (bs_debug)
		fprintf(stderr, "load schema %s %d\n", s->base.name, s->base.id);

	tables = BATselect(table_schema, (ptr) &s->base.id, (ptr) &s->base.id);

	BATloop(tables, p, q)
	    cs_add(&s->tables, load_table(tr, s, tables, p), TR_OLD);
	bat_destroy(tables);

	bat_destroy(table_schema);
	bat_destroy(schema_auths);
	bat_destroy(schema_names);
	return s;
}

static void
do_load_module(sql_trans *tr, char *name)
{
	char buf[BUFSIZ];

	snprintf(buf, BUFSIZ, "module(\"%s\");", name);
	backend_interpret(tr->stk, buf);
}

static void
do_drop_module(sql_trans *tr, char *name)
{
	char buf[BUFSIZ];

	snprintf(buf, BUFSIZ, "drop(\"%s\");", name);
	backend_interpret(tr->stk, buf);
}

static sql_module *
load_module(sql_trans *tr, BAT *modules, BUN j)
{
	char *internal;
	sql_module *s = NEW(sql_module);
	ptr lid = BUNhead(modules, j);
	BAT *types, *funcs;
	BUN p, q;
	BAT *module_names = sys_bat(tr->bm, "modules_name");
	BAT *module_internal = sys_bat(tr->bm, "modules_internal");
	BAT *type_module = sys_bat(tr->bm, "types_module_id");
	BAT *func_module = sys_bat(tr->bm, "functions_module_id");

	base_init(&s->base, *(sqlid *) bun_find(modules, lid), TR_OLD, bun_find(module_names, lid));
	cs_init(&s->types, (fdestroy) &type_destroy);
	cs_init(&s->funcs, (fdestroy) &func_destroy);
	s->internal = NULL;
	internal = (char*)bun_find(module_internal, lid);
	if (ATOMcmp(TYPE_str, ATOMnilptr(TYPE_str), internal) != 0)
		s->internal = _strdup(internal);

	if (s->internal)
		do_load_module(tr, s->internal);

	if (bs_debug)
		fprintf(stderr, "load module %s %d\n", s->base.name, s->base.id);
	tr->module = s;
	types = BATselect(type_module, (ptr) &s->base.id, (ptr) &s->base.id);

	BATloop(types, p, q)
	    cs_add(&s->types, load_type(tr, s, types, p), TR_OLD);
	bat_destroy(types);

	funcs = BATselect(func_module, (ptr) &s->base.id, (ptr) &s->base.id);

	BATloop(funcs, p, q)
	    cs_add(&s->funcs, load_func(tr, s, funcs, p), TR_OLD);
	bat_destroy(funcs);

	bat_destroy(module_names);
	bat_destroy(module_internal);
	return s;
}

static sql_trans *
load_trans(struct bm *bm, backend_stack stk)
{
	sql_trans *t = NEW(sql_trans);
	BUN p, q;
	BAT *schema_ids = sys_bat(bm, "schemas_id");
	BAT *module_ids = sys_bat(bm, "modules_id");

	t->name = NULL;
	t->wtime = t->rtime = 0;
	t->stime = timestamp ();

	t->level = ISO_SERIALIZABLE;
	t->parent = NULL;
	t->module = NULL;
	t->bm = bm;

	t->stk = stk;

	cs_init(&t->schemas, (fdestroy) &schema_destroy);
	cs_init(&t->modules, (fdestroy) &module_destroy);

	if (bs_debug)
		fprintf(stderr, "load trans\n");

	BATloop(module_ids, p, q)
	    cs_add(&t->modules, load_module(t, module_ids, p), TR_OLD);

	BATloop(schema_ids, p, q)
	    cs_add(&t->schemas, load_schema(t, schema_ids, p), TR_OLD);

	bat_destroy(module_ids);
	bat_destroy(schema_ids);
	return t;
}

static BAT *
mvc_bat(struct bm *bm, char *name, int type)
{
	BAT *b = NULL;
	bat id = bm_find_bat(bm, name);

	if (bs_debug)
		fprintf(stderr, "mvc_bat %s bid %d\n", name, id);

	if (id == 0) {
		if (bs_debug)
			fprintf(stderr, "mvc_bat created %s bid %d\n", name, id);

		if (name[0] == 'U')
			b = bat_new(TYPE_oid, type, BUFSIZ, "mvc_bat");
		else
			b = bat_new(TYPE_void, type, BUFSIZ, "mvc_bat");
		bm_add_bat(bm, b->batCacheid, name, 0 /* do not use a transaction id */ );
	} else {
		if (bs_debug)
			fprintf(stderr, "mvc_bat loaded %s bid %d\n", name, id);
		b = bm_lbid2bat(bm, id);
		if (!bm_lbid2mode(bm, id)) {
			b = bat_lcopy(b, "mvc_bat");
			bm_new_bat(bm, id, b);
		}
	}
	return b;
}


static void
bs_init_modules(struct bm *bm)
{
	BAT *sql_module_id = mvc_bat(bm, "modules_id", TYPE_int);
	BAT *sql_module_name = mvc_bat(bm, "modules_name", TYPE_str);
	BAT *sql_module_internal = mvc_bat(bm, "modules_internal", TYPE_str);
	BAT *U_module_id = mvc_bat(bm, "U_modules_id", TYPE_int);
	BAT *U_module_name = mvc_bat(bm, "U_modules_name", TYPE_str);
	BAT *U_module_internal = mvc_bat(bm, "U_modules_internal", TYPE_str);
	BAT *D_sql_module = mvc_bat(bm, "D_modules", TYPE_oid);

	update_table_bat(sql_module_id, U_module_id, D_sql_module);
	update_table_bat(sql_module_name, U_module_name, D_sql_module);
	update_table_bat(sql_module_internal, U_module_internal, D_sql_module);

	bat_destroy(sql_module_id);
	bat_destroy(sql_module_name);
	bat_destroy(sql_module_internal);
	bat_destroy(U_module_id);
	bat_destroy(U_module_name);
	bat_destroy(U_module_internal);
	bat_destroy(D_sql_module);
}

static void
bs_init_schema(struct bm *bm)
{
	BAT *sql_schema_id = mvc_bat(bm, "schemas_id", TYPE_int);
	BAT *sql_schema_name = mvc_bat(bm, "schemas_name", TYPE_str);
	BAT *sql_schema_auth = mvc_bat(bm, "schemas_authorization", TYPE_int);
	BAT *U_schema_id = mvc_bat(bm, "U_schemas_id", TYPE_int);
	BAT *U_schema_name = mvc_bat(bm, "U_schemas_name", TYPE_str);
	BAT *U_schema_auth = mvc_bat(bm, "U_schemas_authorization", TYPE_int);
	BAT *D_sql_schema = mvc_bat(bm, "D_schemas", TYPE_oid);

	update_table_bat(sql_schema_id, U_schema_id, D_sql_schema);
	update_table_bat(sql_schema_name, U_schema_name, D_sql_schema);
	update_table_bat(sql_schema_auth, U_schema_auth, D_sql_schema);

	bat_destroy(sql_schema_id);
	bat_destroy(sql_schema_name);
	bat_destroy(sql_schema_auth);
	bat_destroy(U_schema_id);
	bat_destroy(U_schema_name);
	bat_destroy(U_schema_auth);
	bat_destroy(D_sql_schema);
}

static void
bs_init_table(struct bm *bm)
{
	BAT *sql_table_id = mvc_bat(bm, "ptables_id", TYPE_int);
	BAT *sql_table_name = mvc_bat(bm, "ptables_name", TYPE_str);
	BAT *sql_table_schema = mvc_bat(bm, "ptables_schema_id", TYPE_int);
	BAT *sql_table_query = mvc_bat(bm, "ptables_query", TYPE_str);
	BAT *sql_table_istable = mvc_bat(bm, "ptables_istable", TYPE_bit);
	BAT *sql_table_system = mvc_bat(bm, "ptables_system", TYPE_bit);
	BAT *sql_table_clear = mvc_bat(bm, "ptables_clear", TYPE_bit);
	BAT *U_table_id = mvc_bat(bm, "U_ptables_id", TYPE_int);
	BAT *U_table_name = mvc_bat(bm, "U_ptables_name", TYPE_str);
	BAT *U_table_schema = mvc_bat(bm, "U_ptables_schema_id", TYPE_int);
	BAT *U_table_query = mvc_bat(bm, "U_ptables_query", TYPE_str);
	BAT *U_table_istable = mvc_bat(bm, "U_ptables_istable", TYPE_bit);
	BAT *U_table_system = mvc_bat(bm, "U_ptables_system", TYPE_bit);
	BAT *U_table_clear = mvc_bat(bm, "U_ptables_clear", TYPE_bit);
	BAT *D_sql_table = mvc_bat(bm, "D_ptables", TYPE_oid);

	update_table_bat(sql_table_id, U_table_id, D_sql_table);
	update_table_bat(sql_table_name, U_table_name, D_sql_table);
	update_table_bat(sql_table_schema, U_table_schema, D_sql_table);
	update_table_bat(sql_table_query, U_table_query, D_sql_table);
	update_table_bat(sql_table_istable, U_table_istable, D_sql_table);

	bat_destroy(sql_table_id);
	bat_destroy(sql_table_name);
	bat_destroy(sql_table_schema);
	bat_destroy(sql_table_query);
	bat_destroy(sql_table_istable);
	bat_destroy(sql_table_system);
	bat_destroy(sql_table_clear);
	bat_destroy(U_table_id);
	bat_destroy(U_table_name);
	bat_destroy(U_table_schema);
	bat_destroy(U_table_query);
	bat_destroy(U_table_istable);
	bat_destroy(U_table_system);
	bat_destroy(U_table_clear);
	bat_destroy(D_sql_table);
}

static void
bs_init_column(struct bm *bm)
{
	BAT *sql_column_id = mvc_bat(bm, "pcolumns_id", TYPE_int);
	BAT *sql_column_name = mvc_bat(bm, "pcolumns_name", TYPE_str);
	BAT *sql_column_type = mvc_bat(bm, "pcolumns_type", TYPE_str);
	BAT *sql_column_type_digits = mvc_bat(bm, "pcolumns_type_digits", TYPE_int);
	BAT *sql_column_type_scale = mvc_bat(bm, "pcolumns_type_scale", TYPE_int);
	BAT *sql_column_table = mvc_bat(bm, "pcolumns_table_id", TYPE_int);
	BAT *sql_column_default = mvc_bat(bm, "pcolumns_default", TYPE_str);
	BAT *sql_column_null = mvc_bat(bm, "pcolumns_null", TYPE_bit);
	BAT *sql_column_number = mvc_bat(bm, "pcolumns_number", TYPE_int);
	BAT *U_column_id = mvc_bat(bm, "U_pcolumns_id", TYPE_int);
	BAT *U_column_name = mvc_bat(bm, "U_pcolumns_name", TYPE_str);
	BAT *U_column_type = mvc_bat(bm, "U_pcolumns_type", TYPE_str);
	BAT *U_column_type_digits = mvc_bat(bm, "U_pcolumns_type_digits", TYPE_int);
	BAT *U_column_type_scale = mvc_bat(bm, "U_pcolumns_type_scale", TYPE_int);
	BAT *U_column_table = mvc_bat(bm, "U_pcolumns_table_id", TYPE_int);
	BAT *U_column_default = mvc_bat(bm, "U_pcolumns_default", TYPE_str);
	BAT *U_column_null = mvc_bat(bm, "U_pcolumns_null", TYPE_bit);
	BAT *U_column_number = mvc_bat(bm, "U_pcolumns_number", TYPE_int);
	BAT *D_sql_column = mvc_bat(bm, "D_pcolumns", TYPE_oid);

	update_table_bat(sql_column_id, U_column_id, D_sql_column);
	update_table_bat(sql_column_name, U_column_name, D_sql_column);
	update_table_bat(sql_column_type, U_column_type, D_sql_column);
	update_table_bat(sql_column_type_digits, U_column_type_digits, D_sql_column);
	update_table_bat(sql_column_type_scale, U_column_type_scale, D_sql_column);
	update_table_bat(sql_column_table, U_column_table, D_sql_column);
	update_table_bat(sql_column_default, U_column_default, D_sql_column);
	update_table_bat(sql_column_null, U_column_null, D_sql_column);
	update_table_bat(sql_column_number, U_column_number, D_sql_column);

	bat_destroy(sql_column_id);
	bat_destroy(sql_column_name);
	bat_destroy(sql_column_type);
	bat_destroy(sql_column_type_digits);
	bat_destroy(sql_column_type_scale);
	bat_destroy(sql_column_table);
	bat_destroy(sql_column_default);
	bat_destroy(sql_column_null);
	bat_destroy(sql_column_number);
	bat_destroy(U_column_id);
	bat_destroy(U_column_name);
	bat_destroy(U_column_type);
	bat_destroy(U_column_type_digits);
	bat_destroy(U_column_type_scale);
	bat_destroy(U_column_table);
	bat_destroy(U_column_default);
	bat_destroy(U_column_null);
	bat_destroy(U_column_number);
	bat_destroy(D_sql_column);
}


static void
bs_init_key(struct bm *bm)
{
	BAT *key_id = mvc_bat(bm, "keys_id", TYPE_int);
	BAT *key_table = mvc_bat(bm, "keys_table_id", TYPE_int);
	BAT *key_tpe = mvc_bat(bm, "keys_type", TYPE_int);
	BAT *key_name = mvc_bat(bm, "keys_name", TYPE_str);
	BAT *key_rkey = mvc_bat(bm, "keys_rkey", TYPE_int);
	BAT *U_key_id = mvc_bat(bm, "U_keys_id", TYPE_int);
	BAT *U_key_table = mvc_bat(bm, "U_keys_table_id", TYPE_int);
	BAT *U_key_tpe = mvc_bat(bm, "U_keys_type", TYPE_int);
	BAT *U_key_name = mvc_bat(bm, "U_keys_name", TYPE_str);
	BAT *U_key_rkey = mvc_bat(bm, "U_keys_rkey", TYPE_int);
	BAT *D_key = mvc_bat(bm, "D_keys", TYPE_oid);

	BAT *kc_id = mvc_bat(bm, "keycolumns_id", TYPE_int);
	BAT *kc_col = mvc_bat(bm, "keycolumns_column", TYPE_str);
	BAT *kc_trunc = mvc_bat(bm, "keycolumns_trunc", TYPE_int);
	BAT *kc_nr = mvc_bat(bm, "keycolumns_nr", TYPE_int);
	BAT *U_kc_id = mvc_bat(bm, "U_keycolumns_id", TYPE_int);
	BAT *U_kc_col = mvc_bat(bm, "U_keycolumns_column", TYPE_str);
	BAT *U_kc_trunc = mvc_bat(bm, "U_keycolumns_trunc", TYPE_int);
	BAT *U_kc_nr = mvc_bat(bm, "U_keycolumns_nr", TYPE_int);
	BAT *D_kc = mvc_bat(bm, "D_keycolumns", TYPE_oid);

	update_table_bat(key_id, U_key_id, D_key);
	update_table_bat(key_table, U_key_table, D_key);
	update_table_bat(key_tpe, U_key_tpe, D_key);
	update_table_bat(key_name, U_key_name, D_key);
	update_table_bat(key_rkey, U_key_rkey, D_key);
	/* key_updaterule = mvc_bat(bm, "keys_updaterule", TYPE_int); */
	/* key_deleterule = mvc_bat(bm, "keys_deleterule", TYPE_int); */
	/* key_deferrability = mvc_bat(bm, "keys_deferrability", TYPE_int); */

	update_table_bat(kc_id, U_kc_id, D_kc);
	update_table_bat(kc_col, U_kc_col, D_kc);
	update_table_bat(kc_trunc, U_kc_trunc, D_kc);
	update_table_bat(kc_nr, U_kc_nr, D_kc);

	bat_destroy(key_id);
	bat_destroy(key_table);
	bat_destroy(key_tpe);
	bat_destroy(key_name);
	bat_destroy(key_rkey);
	bat_destroy(U_key_id);
	bat_destroy(U_key_table);
	bat_destroy(U_key_tpe);
	bat_destroy(U_key_name);
	bat_destroy(U_key_rkey);
	bat_destroy(D_key);

	bat_destroy(kc_id);
	bat_destroy(kc_col);
	bat_destroy(kc_trunc);
	bat_destroy(kc_nr);
	bat_destroy(U_kc_id);
	bat_destroy(U_kc_col);
	bat_destroy(U_kc_trunc);
	bat_destroy(U_kc_nr);
	bat_destroy(D_kc);
}

static void
bs_init_idx(struct bm *bm)
{
	BAT *idx_id = mvc_bat(bm, "idxs_id", TYPE_int);
	BAT *idx_table = mvc_bat(bm, "idxs_table_id", TYPE_int);
	BAT *idx_tpe = mvc_bat(bm, "idxs_type", TYPE_int);
	BAT *idx_name = mvc_bat(bm, "idxs_name", TYPE_str);
	BAT *U_idx_id = mvc_bat(bm, "U_idxs_id", TYPE_int);
	BAT *U_idx_table = mvc_bat(bm, "U_idxs_table_id", TYPE_int);
	BAT *U_idx_tpe = mvc_bat(bm, "U_idxs_type", TYPE_str);
	BAT *U_idx_name = mvc_bat(bm, "U_idxs_name", TYPE_int);
	BAT *D_idx = mvc_bat(bm, "D_idxs", TYPE_oid);

	BAT *kc_id = mvc_bat(bm, "keycolumns_id", TYPE_int);
	BAT *kc_col = mvc_bat(bm, "keycolumns_column", TYPE_str);
	BAT *kc_trunc = mvc_bat(bm, "keycolumns_trunc", TYPE_int);
	BAT *kc_nr = mvc_bat(bm, "keycolumns_nr", TYPE_int);
	BAT *U_kc_id = mvc_bat(bm, "U_keycolumns_id", TYPE_int);
	BAT *U_kc_col = mvc_bat(bm, "U_keycolumns_column", TYPE_str);
	BAT *U_kc_trunc = mvc_bat(bm, "U_keycolumns_trunc", TYPE_int);
	BAT *U_kc_nr = mvc_bat(bm, "U_keycolumns_nr", TYPE_int);
	BAT *D_kc = mvc_bat(bm, "D_keycolumns", TYPE_oid);

	update_table_bat(idx_id, U_idx_id, D_idx);
	update_table_bat(idx_table, U_idx_table, D_idx);
	update_table_bat(idx_tpe, U_idx_tpe, D_idx);
	update_table_bat(idx_name, U_idx_name, D_idx);
	/* key_updaterule = mvc_bat(bm, "keys_updaterule", TYPE_int); */
	/* key_deleterule = mvc_bat(bm, "keys_deleterule", TYPE_int); */
	/* key_deferrability = mvc_bat(bm, "keys_deferrability", TYPE_int); */

	update_table_bat(kc_id, U_kc_id, D_kc);
	update_table_bat(kc_col, U_kc_col, D_kc);
	update_table_bat(kc_trunc, U_kc_trunc, D_kc);
	update_table_bat(kc_nr, U_kc_nr, D_kc);

	bat_destroy(idx_id);
	bat_destroy(idx_table);
	bat_destroy(idx_tpe);
	bat_destroy(idx_name);
	bat_destroy(U_idx_id);
	bat_destroy(U_idx_table);
	bat_destroy(U_idx_tpe);
	bat_destroy(U_idx_name);
	bat_destroy(D_idx);

	bat_destroy(kc_id);
	bat_destroy(kc_col);
	bat_destroy(kc_trunc);
	bat_destroy(kc_nr);
	bat_destroy(U_kc_id);
	bat_destroy(U_kc_col);
	bat_destroy(U_kc_trunc);
	bat_destroy(U_kc_nr);
	bat_destroy(D_kc);
}

static void
bs_init_type(struct bm *bm)
{
	int zero = 0;
	node *n = NULL;

	BAT *type_id = mvc_bat(bm, "types_id", TYPE_int);
	BAT *type_sqlname = mvc_bat(bm, "types_sqlname", TYPE_str);
	BAT *type_digits = mvc_bat(bm, "types_digits", TYPE_int);
	BAT *type_scale = mvc_bat(bm, "types_scale", TYPE_int);
	BAT *type_radix = mvc_bat(bm, "types_radix", TYPE_int);
	BAT *type_eclass = mvc_bat(bm, "types_eclass", TYPE_int);
	BAT *type_module_id = mvc_bat(bm, "types_module_id", TYPE_int);
	BAT *type_systemname = mvc_bat(bm, "types_systemname", TYPE_str);
	BAT *U_type_id = mvc_bat(bm, "U_types_id", TYPE_int);
	BAT *U_type_sqlname = mvc_bat(bm, "U_types_sqlname", TYPE_str);
	BAT *U_type_digits = mvc_bat(bm, "U_types_digits", TYPE_int);
	BAT *U_type_scale = mvc_bat(bm, "U_types_scale", TYPE_int);
	BAT *U_type_radix = mvc_bat(bm, "U_types_radix", TYPE_int);
	BAT *U_type_eclass = mvc_bat(bm, "U_types_eclass", TYPE_int);
	BAT *U_type_module_id = mvc_bat(bm, "U_types_module_id", TYPE_int);
	BAT *U_type_systemname = mvc_bat(bm, "U_types_systemname", TYPE_str);
	BAT *D_type = mvc_bat(bm, "D_types", TYPE_oid);

	if (BATcount(type_sqlname) == 0)
		for (n = types->h; n; n = n->next) {
			oid nil = oid_nil;
			sql_type *t = n->data;
			int radix = t->radix;
			int eclass = t->eclass;

			BUNins(type_id, &nil, &t->base.id);

			BUNins(type_sqlname, &nil, t->sqlname);
			BUNins(type_digits, &nil, &t->digits);
			BUNins(type_scale, &nil, &t->scale);
			BUNins(type_radix, &nil, &radix);
			BUNins(type_eclass, &nil, &eclass);
			BUNins(type_module_id, &nil, &zero);
			BUNins(type_systemname, &nil, t->base.name);
		}

	bat_destroy(type_id);
	bat_destroy(type_sqlname);
	bat_destroy(type_digits);
	bat_destroy(type_scale);
	bat_destroy(type_radix);
	bat_destroy(type_eclass);
	bat_destroy(type_module_id);
	bat_destroy(type_systemname);
	bat_destroy(U_type_id);
	bat_destroy(U_type_sqlname);
	bat_destroy(U_type_digits);
	bat_destroy(U_type_scale);
	bat_destroy(U_type_radix);
	bat_destroy(U_type_eclass);
	bat_destroy(U_type_module_id);
	bat_destroy(U_type_systemname);
	bat_destroy(D_type);
}

static void
bs_init_func(struct bm *bm)
{
	bit T = TRUE, F = FALSE;
	int zero = 0;
	node *n = NULL, *m = NULL;

	BAT *func_id = mvc_bat(bm, "functions_id", TYPE_int);
	BAT *func_name = mvc_bat(bm, "functions_name", TYPE_str);
	BAT *func_func = mvc_bat(bm, "functions_func", TYPE_str);
	BAT *func_sql = mvc_bat(bm, "functions_sql", TYPE_bit);
	BAT *func_aggr = mvc_bat(bm, "functions_aggr", TYPE_bit);
	BAT *func_module_id = mvc_bat(bm, "functions_module_id", TYPE_int);
	BAT *U_func_id = mvc_bat(bm, "U_functions_id", TYPE_int);
	BAT *U_func_name = mvc_bat(bm, "U_functions_name", TYPE_str);
	BAT *U_func_func = mvc_bat(bm, "U_functions_func", TYPE_str);
	BAT *U_func_sql = mvc_bat(bm, "U_functions_sql", TYPE_bit);
	BAT *U_func_aggr = mvc_bat(bm, "U_functions_aggr", TYPE_bit);
	BAT *U_func_module_id = mvc_bat(bm, "U_functions_module_id", TYPE_int);
	BAT *D_func = mvc_bat(bm, "D_functions", TYPE_oid);

	BAT *arg_id = mvc_bat(bm, "args_id", TYPE_int);
	BAT *arg_func_id = mvc_bat(bm, "args_func_id", TYPE_int);
	BAT *arg_name = mvc_bat(bm, "args_name", TYPE_str);
	BAT *arg_type = mvc_bat(bm, "args_type", TYPE_str);
	BAT *arg_type_digits = mvc_bat(bm, "args_type_digits", TYPE_int);
	BAT *arg_type_scale = mvc_bat(bm, "args_type_scale", TYPE_int);
	BAT *arg_number = mvc_bat(bm, "args_number", TYPE_int);
	BAT *U_arg_id = mvc_bat(bm, "U_args_id", TYPE_int);
	BAT *U_arg_func_id = mvc_bat(bm, "U_args_func_id", TYPE_int);
	BAT *U_arg_name = mvc_bat(bm, "U_args_name", TYPE_str);
	BAT *U_arg_type = mvc_bat(bm, "U_args_type", TYPE_str);
	BAT *U_arg_type_digits = mvc_bat(bm, "U_args_type_digits", TYPE_int);
	BAT *U_arg_type_scale = mvc_bat(bm, "U_args_type_scale", TYPE_int);
	BAT *U_arg_number = mvc_bat(bm, "U_args_number", TYPE_int);
	BAT *D_arg = mvc_bat(bm, "D_args", TYPE_oid);

	if (BATcount(func_name) == 0) {
		for (n = funcs->h; n; n = n->next) {
			oid nil = oid_nil;
			sql_func *f = n->data;
			bit sql = f->sql;
			int id, nr = 0;
			char arg_nme[] = "arg_0";

			BUNins(func_id, &nil, &f->base.id);
			BUNins(func_name, &nil, f->base.name);
			BUNins(func_func, &nil, f->imp);
			BUNins(func_sql, &nil, &sql);
			BUNins(func_aggr, &nil, &F);
			BUNins(func_module_id, &nil, &zero);
		
			if (f->res) {
				char *name = "result";

				id = OIDnew(1);
				BUNins(arg_id, &nil, &id);
				BUNins(arg_func_id, &nil, &f->base.id);
				BUNins(arg_name, &nil, name);
				BUNins(arg_type, &nil, f->res->type->sqlname);
				BUNins(arg_type_digits, &nil, &f->res->scale);
				BUNins(arg_type_scale, &nil, &f->res->scale);
				BUNins(arg_number, &nil, &nr);
				nr++;
			}
			for (m = f->ops->h; m; m = m->next, nr++) {
				sql_arg *a = m->data;

				id = OIDnew(1);
				BUNins(arg_id, &nil, &id);
				BUNins(arg_func_id, &nil, &f->base.id);
				if (a->name) {
					BUNins(arg_name, &nil, a->name);
				} else {
					arg_nme[4] = '0' + nr;
					BUNins(arg_name, &nil, arg_nme);
				}
				BUNins(arg_type, &nil, a->type->type->sqlname);
				BUNins(arg_type_digits, &nil, &a->type->scale);
				BUNins(arg_type_scale, &nil, &a->type->scale);
				BUNins(arg_number, &nil, &nr);
			}
		}
		for (n = aggrs->h; n; n = n->next) {
			char *name1 = "result";
			char *name2 = "arg";
			oid nil = oid_nil;
			sql_aggr *aggr = n->data;
			int nr = 0, id;

			BUNins(func_id, &nil, &aggr->base.id);
			BUNins(func_name, &nil, aggr->base.name);
			BUNins(func_func, &nil, aggr->imp);
			BUNins(func_sql, &nil, &F);
			BUNins(func_aggr, &nil, &T);
			BUNins(func_module_id, &nil, &zero);

			id = OIDnew(1);
			BUNins(arg_id, &nil, &id);
			BUNins(arg_func_id, &nil, &aggr->base.id);
			BUNins(arg_name, &nil, name1);
			BUNins(arg_type, &nil, aggr->res->type->sqlname);
			BUNins(arg_type_digits, &nil, &aggr->res->scale);
			BUNins(arg_type_scale, &nil, &aggr->res->scale);
			BUNins(arg_number, &nil, &nr);
			nr++;

			if (aggr->tpe) {
				id = OIDnew(1);
				BUNins(arg_id, &nil, &id);
				BUNins(arg_func_id, &nil, &aggr->base.id);
				BUNins(arg_name, &nil, name2);
				BUNins(arg_type, &nil, aggr->tpe->type->sqlname);
				BUNins(arg_type_digits, &nil, &aggr->tpe->scale);
				BUNins(arg_type_scale, &nil, &aggr->tpe->scale);
				BUNins(arg_number, &nil, &nr);
			}
		}
	}

	bat_destroy(func_id);
	bat_destroy(func_name);
	bat_destroy(func_func);
	bat_destroy(func_sql);
	bat_destroy(func_aggr);
	bat_destroy(func_module_id);
	bat_destroy(U_func_id);
	bat_destroy(U_func_name);
	bat_destroy(U_func_func);
	bat_destroy(U_func_sql);
	bat_destroy(U_func_aggr);
	bat_destroy(U_func_module_id);
	bat_destroy(D_func);

	bat_destroy(arg_id);
	bat_destroy(arg_func_id);
	bat_destroy(arg_name);
	bat_destroy(arg_type);
	bat_destroy(arg_type_digits);
	bat_destroy(arg_type_scale);
	bat_destroy(arg_number);
	bat_destroy(U_arg_id);
	bat_destroy(U_arg_func_id);
	bat_destroy(U_arg_name);
	bat_destroy(U_arg_type);
	bat_destroy(U_arg_type_digits);
	bat_destroy(U_arg_type_scale);
	bat_destroy(U_arg_number);
	bat_destroy(D_arg);
}


static sql_column *
bootstrap_create_column(sql_trans *tr, sql_table *t, char *name, char *sqltype, int digits)
{
	char bname[BUFSIZ];
	sql_column *col = NEW(sql_column);

	BAT *b;
	oid rid;

	base_init(&col->base, OIDnew(1), TR_NEW, name);
	col->type = sql_bind_subtype(sqltype, digits, 0);
	col->def = NULL;
	col->null = 1;
	col->colnr = cs_size(&t->columns);
	col->t = t;
	cs_add(&t->columns, col, TR_NEW);

	snprintf(bname, BUFSIZ, "%s_%s", col->t->base.name, col->base.name);
	col->bat.bid = bm_find_bat(tr->bm, bname);
	col->bat.ibid = 0;

	snprintf(bname, BUFSIZ, "U_%s_%s", col->t->base.name, col->base.name);
	col->bat.ubid = bm_find_bat(tr->bm, bname);
	assert(col->bat.bid && col->bat.ubid);

	b = sys_bat(tr->bm, "pcolumns_id");

	rid = BATcount(b);
	BUNins(b, (ptr) &rid, (ptr) &col->base.id);

	bat_destroy(b);
	b = sys_bat(tr->bm, "pcolumns_table_id");
	BUNins(b, (ptr) &rid, (ptr) &t->base.id);

	bat_destroy(b);
	b = sys_bat(tr->bm, "pcolumns_name");

	BUNins(b, (ptr) &rid, (ptr) col->base.name);
	bat_destroy(b);
	b = sys_bat(tr->bm, "pcolumns_type");

	BUNins(b, (ptr) &rid, (ptr) col->type->type->sqlname);
	bat_destroy(b);
	b = sys_bat(tr->bm, "pcolumns_type_digits");

	BUNins(b, (ptr) &rid, (ptr) &col->type->digits);
	bat_destroy(b);
	b = sys_bat(tr->bm, "pcolumns_type_scale");

	BUNins(b, (ptr) &rid, (ptr) &col->type->scale);
	bat_destroy(b);
	b = sys_bat(tr->bm, "pcolumns_default");

	if (col->def)
		BUNins(b, (ptr) &rid, (ptr) col->def);
	else
		BUNins(b, (ptr) &rid, (ptr) ATOMnilptr(TYPE_str));
	bat_destroy(b);
	b = sys_bat(tr->bm, "pcolumns_null");

	BUNins(b, (ptr) &rid, (ptr) &col->null);
	bat_destroy(b);
	b = sys_bat(tr->bm, "pcolumns_number");

	BUNins(b, (ptr) &rid, (ptr) &col->colnr);
	bat_destroy(b);

	col->base.wtime = t->base.wtime = t->s->base.wtime = tr->wtime = tr->stime;

	return col;
}

static sql_table *
create_table_intern(char *name, bit table, bit system, bit persists, bit clear)
{
	sql_table *t = NEW(sql_table);

	base_init(&t->base, OIDnew(1), TR_NEW, name);
	t->table = table;
	t->system = system;
	t->persists = persists;
	t->clear = clear;
	t->query = NULL;
	cs_init(&t->columns, (fdestroy) &column_destroy);
	cs_init(&t->idxs, (fdestroy) &idx_destroy);
	cs_init(&t->keys, (fdestroy) &key_destroy);
	t->pkey = NULL;
	t->dbid = 0;
	t->sz = BUFSIZ;
	t->cnt = 0;
	t->cleared = 0;
	return t;
}

static sql_table *
bootstrap_create_table(sql_trans *tr, sql_schema *s, char *name, bit clear)
{
	char bname[BUFSIZ];
	sql_table *t = create_table_intern(name, 1, 1, 1, clear);

	BAT *b;
	oid rid;

	t->query = NULL;
	t->s = s;
	cs_add(&s->tables, t, TR_NEW);

	snprintf(bname, BUFSIZ, "D_%s", t->base.name);
	t->dbid = bm_find_bat(tr->bm, bname);

	assert(t->dbid);

	b = sys_bat(tr->bm, "ptables_id");

	rid = BATcount(b);
	BUNins(b, (ptr) &rid, (ptr) &t->base.id);

	bat_destroy(b);
	b = sys_bat(tr->bm, "ptables_schema_id");
	BUNins(b, (ptr) &rid, (ptr) &s->base.id);

	bat_destroy(b);
	b = sys_bat(tr->bm, "ptables_name");

	BUNins(b, (ptr) &rid, (ptr) t->base.name);
	bat_destroy(b);
	b = sys_bat(tr->bm, "ptables_istable");

	BUNins(b, (ptr) &rid, (ptr) &t->table);
	bat_destroy(b);
	b = sys_bat(tr->bm, "ptables_system");

	BUNins(b, (ptr) &rid, (ptr) &t->system);
	bat_destroy(b);
	b = sys_bat(tr->bm, "ptables_clear");

	BUNins(b, (ptr) &rid, (ptr) &t->clear);
	bat_destroy(b);
	b = sys_bat(tr->bm, "ptables_query");

	BUNins(b, (ptr) &rid, (ptr) ATOMnilptr(TYPE_str));
	bat_destroy(b);

	t->base.wtime = s->base.wtime = tr->wtime = tr->stime;
	return t;
}


static sql_schema *
bootstrap_create_schema(sql_trans *tr, char *name, int auth_id)
{
	sql_schema *s = NEW(sql_schema);

	BAT *b;
	oid rid;

	if (bs_debug)
		fprintf(stderr, "bootstrap_create_schema %s %d\n", name, auth_id);

	base_init(&s->base, OIDnew(1), TR_NEW, name);
	s->auth_id = auth_id;
	cs_init(&s->tables, (fdestroy) &table_destroy);
	s->keys = list_create((fdestroy) NULL);
	s->idxs = list_create((fdestroy) NULL);

	cs_add(&tr->schemas, s, TR_NEW);

	b = sys_bat(tr->bm, "schemas_id");

	rid = BATcount(b);
	BUNins(b, (ptr) &rid, (ptr) &s->base.id);

	bat_destroy(b);
	b = sys_bat(tr->bm, "schemas_name");

	BUNins(b, (ptr) &rid, (ptr) s->base.name);
	bat_destroy(b);
	b = sys_bat(tr->bm, "schemas_authorization");

	BUNins(b, (ptr) &rid, (ptr) &s->auth_id);
	bat_destroy(b);

	s->base.wtime = tr->wtime = tr->stime;
	return s;
}

int
store_init(int debug, char *logdir, char *dbname, backend_stack stk)
{
	struct bm *bm = NULL;
	int first = 0;

	bs_debug = debug;
	bm = bm_create(debug);
	logger = logger_create(debug, logdir, dbname, CATALOG_VERSION, bm);

	if (!logger)
		return -1;

	bs_lock = MT_create_lock();

	types_init(debug);

	bs_init_modules(bm);
	bs_init_schema(bm);
	bs_init_table(bm);
	bs_init_column(bm);
	bs_init_key(bm);
	bs_init_idx(bm);
	bs_init_type(bm);
	bs_init_func(bm);
	sequences_init();

	gtrans = load_trans(bm, stk);

	if (!find_sql_schema(gtrans, "sys")) {
		sql_schema *s;
		sql_table *t;

		sql_trans *tr = sql_trans_create(stk, NULL, NULL);

		first = 1;

		s = bootstrap_create_schema(tr, "sys", ROLE_SYSADMIN);
		t = bootstrap_create_table(tr, s, "modules", 0);
		bootstrap_create_column(tr, t, "id", "int", 9);
		bootstrap_create_column(tr, t, "name", "varchar", 1024);
		bootstrap_create_column(tr, t, "internal", "varchar", 1024);

		t = bootstrap_create_table(tr, s, "schemas", 0);
		bootstrap_create_column(tr, t, "id", "int", 9);
		bootstrap_create_column(tr, t, "name", "varchar", 1024);
		bootstrap_create_column(tr, t, "authorization", "int", 9);

		t = bootstrap_create_table(tr, s, "ptables", 0);
		bootstrap_create_column(tr, t, "id", "int", 9);
		bootstrap_create_column(tr, t, "name", "varchar", 1024);
		bootstrap_create_column(tr, t, "schema_id", "int", 9);
		bootstrap_create_column(tr, t, "query", "varchar", 2048);
		bootstrap_create_column(tr, t, "istable", "boolean", 0);
		bootstrap_create_column(tr, t, "system", "boolean", 0);
		bootstrap_create_column(tr, t, "clear", "boolean", 0);

		t = bootstrap_create_table(tr, s, "pcolumns", 0);
		bootstrap_create_column(tr, t, "id", "int", 9);
		bootstrap_create_column(tr, t, "name", "varchar", 1024);
		bootstrap_create_column(tr, t, "type", "varchar", 1024);
		bootstrap_create_column(tr, t, "type_digits", "int", 9);
		bootstrap_create_column(tr, t, "type_scale", "int", 9);
		bootstrap_create_column(tr, t, "table_id", "int", 9);
		bootstrap_create_column(tr, t, "default", "varchar", 2048);
		bootstrap_create_column(tr, t, "null", "boolean", 0);
		bootstrap_create_column(tr, t, "number", "int", 9);

		t = bootstrap_create_table(tr, s, "keys", 0);
		bootstrap_create_column(tr, t, "id", "int", 9);
		bootstrap_create_column(tr, t, "table_id", "int", 9);
		bootstrap_create_column(tr, t, "type", "int", 9);
		bootstrap_create_column(tr, t, "name", "varchar", 1024);
		bootstrap_create_column(tr, t, "rkey", "int", 9);

		t = bootstrap_create_table(tr, s, "idxs", 0);
		bootstrap_create_column(tr, t, "id", "int", 9);
		bootstrap_create_column(tr, t, "table_id", "int", 9);
		bootstrap_create_column(tr, t, "type", "int", 9);
		bootstrap_create_column(tr, t, "name", "varchar", 1024);

		t = bootstrap_create_table(tr, s, "keycolumns", 0);
		bootstrap_create_column(tr, t, "id", "int", 9);
		bootstrap_create_column(tr, t, "column", "varchar", 1024);
		bootstrap_create_column(tr, t, "trunc", "int", 9);
		bootstrap_create_column(tr, t, "nr", "int", 9);

		t = bootstrap_create_table(tr, s, "types", 0);
		bootstrap_create_column(tr, t, "id", "int", 9);
		bootstrap_create_column(tr, t, "systemname", "varchar", 256);
		bootstrap_create_column(tr, t, "sqlname", "varchar", 1024);
		bootstrap_create_column(tr, t, "digits", "int", 9);
		bootstrap_create_column(tr, t, "scale", "int", 9);
		bootstrap_create_column(tr, t, "radix", "int", 9);
		bootstrap_create_column(tr, t, "eclass", "int", 9);
		bootstrap_create_column(tr, t, "module_id", "int", 9);

		t = bootstrap_create_table(tr, s, "functions", 0);
		bootstrap_create_column(tr, t, "id", "int", 9);
		bootstrap_create_column(tr, t, "name", "varchar", 256);
		bootstrap_create_column(tr, t, "func", "varchar", 8196);
		/* sql or database internal */
		bootstrap_create_column(tr, t, "sql", "boolean", 9);
		/* aggr or func */
		bootstrap_create_column(tr, t, "aggr", "boolean", 9);
		bootstrap_create_column(tr, t, "module_id", "int", 9);

		t = bootstrap_create_table(tr, s, "args", 0);
		bootstrap_create_column(tr, t, "id", "int", 9);
		bootstrap_create_column(tr, t, "func_id", "int", 9);
		bootstrap_create_column(tr, t, "name", "varchar", 256);
		bootstrap_create_column(tr, t, "type", "varchar", 1024);
		bootstrap_create_column(tr, t, "type_digits", "int", 9);
		bootstrap_create_column(tr, t, "type_scale", "int", 9);
		bootstrap_create_column(tr, t, "number", "int", 9);

		if (sql_trans_commit(tr) != SQL_OK)
			fprintf(stderr, "Cannot commit initial transaction\n");
		sql_trans_destroy(tr);
	}
	return first;
}

static int cleanup = 0;

void
store_exit()
{
	struct logger *l = logger;

	/* never started! */
	if (!logger)
		return;

	sequences_exit();
	MT_set_lock(bs_lock, "store_exit");
	/* busy wait till the logmanager is ready with the cleanup */
	while (cleanup)
		MT_sleep_ms(100);
	logger = NULL;

	logger_exit(l);
	logger_destroy(l);

	sql_trans_destroy(gtrans);
	gtrans = NULL;
	MT_unset_lock(bs_lock, "store_exit");
	types_exit();
}

void
store_manager()
{
	int res = SQL_OK;

	MT_set_lock(bs_lock, "store_manager");
	if (!logger ||log_changes(logger) < 1000) {
		MT_unset_lock(bs_lock, "store_manager");
		return;
	}

	res = logger_restart(logger);
	cleanup = 1;
	MT_unset_lock(bs_lock, "store_manager");
	if (cleanup && res == SQL_OK)
		logger_cleanup(logger);

	cleanup = 0;
}

void
store_lock()
{
	MT_set_lock(bs_lock, "trans_lock");
}

void
store_unlock()
{
	MT_unset_lock(bs_lock, "trans_unlock");
}

static sql_kc *
kc_dup(sql_trans *tr, int flag, sql_kc *kc, sql_table *t)
{
	sql_kc *nkc = NEW(sql_kc);
	sql_column *c = find_sql_column(t, kc->c->base.name);

	(void) tr;		/* unused! */
	(void) flag;
	assert(c);
	nkc->c = c;
	nkc->trunc = kc->trunc;
	return nkc;
}

static sql_key *
key_dup(sql_trans *tr, int flag, sql_key *k, sql_table *t)
{
	sql_key *nk = (k->type != fkey) ? (sql_key *) NEW(sql_ukey)
	    : (sql_key *) NEW(sql_fkey);
	node *n;

	base_init(&nk->base, k->base.id, tr_flag(&k->base, flag), k->base.name);

	nk->type = k->type;
	nk->columns = list_create((fdestroy) &kc_destroy);
	nk->t = t;
	nk->idx = NULL;

	if (k->idx) {
		node *n = list_find_name(nk->t->s->idxs, nk->base.name);

		if (n) {
			nk->idx = (sql_idx *) n->data;
			nk->idx->key = nk;
		}
	}

	if (nk->type != fkey) {
		sql_ukey *tk = (sql_ukey *) nk;

		tk->keys = NULL;

		if (nk->type == pkey)
			t->pkey = tk;
	} else {
		sql_fkey *tk = (sql_fkey *) nk;

		tk->rkey = NULL;
	}

	for (n = k->columns->h; n; n = n->next) {
		sql_kc *okc = n->data;

		list_append(nk->columns, kc_dup(tr, flag, okc, t));
	}

	if (nk->type == fkey) {
		sql_fkey *fk = (sql_fkey *) nk;
		sql_fkey *ok = (sql_fkey *) k;
		node *n;

		if (ok->rkey) {
			n = list_find(t->s->keys, &ok->rkey->k.base.id, (fcmp) &key_cmp);

			if (n) {
				sql_ukey *uk = n->data;
	
				fk->rkey = uk;
				if (!uk->keys)
					uk->keys = list_create(NULL);
				list_append(uk->keys, fk);
			}
		}
	} else {		/* could be a set of rkeys */
		sql_ukey *uk = (sql_ukey *) nk;
		sql_ukey *ok = (sql_ukey *) k;
		node *m;

		if (ok->keys)
			for (m = ok->keys->h; m; m = m->next) {
				sql_fkey *ofk = m->data;
				node *n = list_find(t->s->keys, &ofk->k.base.id, (fcmp) &key_cmp);

				if (n) {
					sql_fkey *fk = n->data;

					if (!uk->keys)
						uk->keys = list_create(NULL);
					list_append(uk->keys, fk);
					fk->rkey = uk;
				}
			}
	}
	list_append(t->s->keys, nk);
	return nk;
}

static sql_idx *
idx_dup(sql_trans *tr, int flag, sql_idx * i, sql_table *t)
{
	sql_idx *ni = NEW(sql_idx);
	node *n;

	base_init(&ni->base, i->base.id, tr_flag(&i->base, flag), i->base.name);

	ni->columns = list_create((fdestroy) &kc_destroy);
	ni->t = t;
	ni->type = i->type;
	ni->bat.bid = i->bat.bid;
	ni->bat.ibid = 0;
	ni->bat.ubid = i->bat.ubid;

	ni->key = NULL;

	for (n = i->columns->h; n; n = n->next) {
		sql_kc *okc = n->data;

		list_append(ni->columns, kc_dup(tr, flag, okc, t));
	}
	list_append(t->s->idxs, ni);
	return ni;
}

static sql_subtype *
subtype_dup(sql_trans *tr, int flag, sql_subtype *ot ) 
{
	/* here we need to take care that the types come from
	   the global types list or from our own modules types */

	sql_subtype *t = 
		sql_bind_subtype(ot->type->sqlname, ot->digits, ot->scale);

	if (!t) {
		sql_trans *trans = tr;

		if (flag == TR_NEW) /* commiting changes */
			trans = tr->parent;
		t = sql_create_subtype(
	    		sql_trans_bind_type(trans, ot->type->sqlname), 
	    		ot->digits, ot->scale);
	}
	return t;
}

static sql_column *
column_dup(sql_trans *tr, int flag, sql_column *oc, sql_table *t)
{
	sql_column *c = NEW(sql_column);

	base_init(&c->base, oc->base.id, tr_flag(&oc->base, flag), oc->base.name);

	if (oc->type) 
		c->type = subtype_dup(tr, flag, oc->type);

	c->def = NULL;
	if (oc->def)
		c->def = _strdup(oc->def);
	c->null = oc->null;
	c->colnr = oc->colnr;
	c->bat.ibid = oc->bat.ibid;

	if (oc->bat.ibid) {
		if (c->base.flag == TR_NEW) {
			c->bat.ibid = temp_copy(c->bat.ibid, 0);
		} else {
			/* The column flag == TR_OLD, ie recusive transaction.
			   We should make sure we don't have ibids 
			   within recursive transaction trees
			 */
			BAT *b = bind_bat(tr->parent, oc, UPD);

			bat_destroy(b);
			c->bat.ibid = 0;
		}
	}
	c->bat.bid = oc->bat.bid;
	c->bat.ubid = oc->bat.ubid;

	c->t = t;

	if (!c->t->persists || c->t->clear) {
		c->bat.bid = temp_copy(c->bat.bid, c->t->clear);
		c->bat.ubid = temp_copy(c->bat.ubid, c->t->clear);
	}
	return c;
}

static sql_table *
table_dup(sql_trans *tr, int flag, sql_table *ot, sql_schema *s)
{
	node *n;
	sql_table *t = NEW(sql_table);

	base_init(&t->base, ot->base.id, tr_flag(&ot->base, flag), ot->base.name);

	t->table = ot->table;
	t->system = ot->system;
	t->persists = ot->persists;
	t->clear = ot->clear;
	t->query = (ot->query) ? _strdup(ot->query) : NULL;

	cs_init(&t->columns, (fdestroy) &column_destroy);
	cs_init(&t->keys, (fdestroy) &key_destroy);
	cs_init(&t->idxs, (fdestroy) &idx_destroy);

	t->pkey = NULL;

	t->dbid = ot->dbid;
	if (!t->persists || t->clear)
		temp_dup(t->dbid);

	t->s = s;
	t->sz = ot->sz;
	t->cnt = ot->cnt;
	t->cleared = 0;

	if (ot->columns.set)
		for (n = ot->columns.set->h; n; n = n->next) {
			sql_column *c = n->data;

			cs_add(&t->columns, column_dup(tr, flag, c, t), tr_flag(&c->base, flag));
		}
	if (ot->idxs.set)
		for (n = ot->idxs.set->h; n; n = n->next) {
			sql_idx *i = n->data;

			cs_add(&t->idxs, idx_dup(tr, flag, i, t), tr_flag(&i->base, flag));
		}
	if (ot->keys.set)
		for (n = ot->keys.set->h; n; n = n->next) {
			sql_key *k = n->data;

			cs_add(&t->keys, key_dup(tr, flag, k, t), tr_flag(&k->base, flag));
		}
	return t;
}

static sql_schema *
schema_dup(sql_trans *tr, int flag, sql_schema *os, sql_trans *o)
{
	node *n;
	sql_schema *s = NEW(sql_schema);

	(void) o;
	base_init(&s->base, os->base.id, tr_flag(&os->base, flag), os->base.name);

	s->auth_id = os->auth_id;
	cs_init(&s->tables, (fdestroy) &table_destroy);
	s->keys = list_create((fdestroy) NULL);
	s->idxs = list_create((fdestroy) NULL);

	if (os->tables.set)
		for (n = os->tables.set->h; n; n = n->next) {
			sql_table *ot = n->data;

			if (ot->persists || tr != gtrans)
				cs_add(&s->tables, table_dup(tr, flag, ot, s), tr_flag(&ot->base, flag));
		}
	return s;
}

static sql_type *
type_dup(sql_trans *tr, int flag, sql_type *ot, sql_module * m)
{
	sql_type *t = NEW(sql_type);

	(void) tr;
	base_init(&t->base, ot->base.id, tr_flag(&ot->base, flag), ot->base.name);

	t->sqlname = _strdup(ot->sqlname);
	t->digits = ot->digits;
	t->scale = ot->scale;
	t->radix = ot->radix;
	t->localtype = ot->localtype;
	t->m = m;
	return t;
}

static sql_arg *
arg_dup2(sql_trans *tr, int flag, sql_arg *oa ) 
{
	sql_arg *a = NEW(sql_arg);

	a->name = _strdup(oa->name);
	a->type = subtype_dup(tr, flag, oa->type );
	return a;
}

static sql_func *
func_dup(sql_trans *tr, int flag, sql_func *of, sql_module * m)
{
	node *n;
	sql_func *f = NEW(sql_func);

	base_init(&f->base, of->base.id, tr_flag(&of->base, flag), of->base.name);

	f->imp = _strdup(of->imp);
	f->sql = of->sql;
	f->aggr = of->aggr;
	f->ops = list_create(of->ops->destroy);
	for(n=of->ops->h; n; n = n->next) 
		list_append(f->ops, arg_dup2(tr, flag, n->data));
	f->res = NULL;
	if (of->res) 
		f->res = subtype_dup(tr, flag, of->res);

	f->m = m;
	return f;
}


static sql_module *
module_dup(sql_trans *tr, int flag, sql_module * om, sql_trans *o)
{
	node *n;
	sql_module *m = NEW(sql_module);

	(void) tr;
	base_init(&m->base, om->base.id, tr_flag(&om->base, flag), om->base.name);

	cs_init(&m->types, (fdestroy) &type_destroy);
	cs_init(&m->funcs, (fdestroy) &func_destroy);
	m->internal = NULL;
	if (om->internal)
		m->internal = _strdup(om->internal);

	if (flag == TR_NEW)  
		tr->parent->module = m;
	else
		tr->module = m;

	if (om->types.set)
		for (n = om->types.set->h; n; n = n->next) {
			cs_add(&m->types, type_dup(tr, flag, n->data, m), tr_flag(&om->base, flag));
		}
	if (om->funcs.set)
		for (n = om->funcs.set->h; n; n = n->next) {
			cs_add(&m->funcs, func_dup(tr, flag, n->data, m), tr_flag(&om->base, flag));
		}
	if (m->internal && tr->parent == gtrans && tr_flag(&om->base, flag) == TR_NEW)  
		do_load_module(o, m->internal);
	return m;
}


static sql_trans *
trans_dup(backend_stack stk, sql_trans *ot, char *newname)
{
	node *n;
	sql_trans *t = NEW(sql_trans);

	t->wtime = t->rtime = 0;
	t->stime = timestamp ();

	t->level = ot->level;
	t->parent = ot;
	t->stk = stk;

	cs_init(&t->modules, (fdestroy) &module_destroy);
	cs_init(&t->schemas, (fdestroy) &schema_destroy);
	t->name = NULL;
	if (newname) {
		if (ot->name)
			_DELETE(ot->name);
		ot->name = _strdup(newname);
	} else {
		ot->name = NULL;
	}

	if (ot->modules.set)
		for (n = ot->modules.set->h; n; n = n->next) {
			cs_add(&t->modules, module_dup(t, TR_OLD, n->data, t), TR_OLD);
		}
	if (ot->schemas.set)
		for (n = ot->schemas.set->h; n; n = n->next) {
			cs_add(&t->schemas, schema_dup(t, TR_OLD, n->data, t), TR_OLD);
		}
	/* needed last because the ot->bm may change (ibid->bid conversions) */
	t->bm = bm_dup(ot->bm);

	return t;
}

typedef int (*rfufunc) (sql_trans *tr, sql_base * fs, sql_base * ts);
typedef sql_base *(*rfcfunc) (sql_trans *tr, sql_base * b);
typedef int (*rfdfunc) (sql_trans *tr, sql_base * b);
typedef sql_base *(*dupfunc) (sql_trans *tr, int flag, sql_base * b, sql_base * p);

static int
rollforward_changeset_updates(sql_trans *tr, changeset * fs, changeset * ts, sql_base * b, rfufunc rollforward_updates, rfcfunc rollforward_creates, rfdfunc rollforward_deletes, dupfunc fd)
{
	int ok = SQL_OK;
	node *n = NULL;

	/* delete removed bases */
	if (fs->dset)
		for (n = fs->dset->h; ok == SQL_OK && n; n = n->next) {
			sql_base *fb = n->data;
			node *tbn = cs_find_name(ts, fb->name);

			if (tbn) {
				sql_base *tb = tbn->data;

				if (rollforward_deletes)
					ok = rollforward_deletes(tr, tb);
				if (ts->nelm == tbn)
					ts->nelm = tbn->next;
				if (tr->parent != gtrans) {
					if (!ts->dset)
						ts->dset = list_create(ts->destroy);
					list_move_data(ts->set, ts->dset, tb);
				} else {
					list_remove_data(ts->set, tb);
					ts->set->destroy(tb);
				}
			}
		}
	/* changes to the existing bases */
	if (fs->set) {
		/* update existing */
		if (rollforward_updates) {
			for (n = fs->set->h; ok == SQL_OK && n && n != fs->nelm; n = n->next) {
				sql_base *fb = n->data;
				node *tbn = cs_find_name(ts, fb->name);

				if (tbn && fb->wtime && fb->flag == TR_OLD) {
					sql_base *tb = tbn->data;

					/* update timestamps */
					if (fb->rtime > tb->rtime)
						tb->rtime = fb->rtime;
					if (fb->wtime > tb->wtime)
						tb->wtime = fb->wtime;

					ok = rollforward_updates(tr, fb, tb);
				}
			}
		}
		/* add the new bases */
		if (fd && rollforward_creates) {
			for (n = fs->nelm; ok == SQL_OK && n; n = n->next) {
				sql_base *fb = n->data;
				sql_base *tb = fd(tr, TR_NEW, fb, b);

				/* conditional add the new bases */
				if (tb) {
					sql_base *r = rollforward_creates(tr, tb);

					if (r)
						cs_add(ts, r, TR_NEW);
					else
						ok = SQL_ERR;
				}
			}
		}
	}
	return ok;
}

static int
rollforward_changeset_creates(sql_trans *tr, changeset * cs, rfcfunc rf)
{
	if (cs->set) {
		node *n;

		for (n = cs->set->h; n; n = n->next) {
			sql_base *b = n->data;

			if (!rf(tr, b))
				return SQL_ERR;
		}
	}
	return SQL_OK;
}

static int
rollforward_changeset_deletes(sql_trans *tr, changeset * cs, rfdfunc rf)
{
	int ok = SQL_OK;

	if (!cs)
		return ok;
	if (cs->dset) {
		node *n;

		for (n = cs->dset->h; ok == SQL_OK && n; n = n->next) {
			sql_base *b = n->data;

			ok = rf(tr, b);
		}
	}
	if (cs->set) {
		node *n;

		for (n = cs->set->h; ok == SQL_OK && n; n = n->next) {
			sql_base *b = n->data;

			ok = rf(tr, b);
		}
	}
	return ok;
}

static sql_idx *
rollforward_create_idx(sql_trans *tr, sql_idx * i)
{
	int ok = SQL_OK;

	if (i->bat.bid && i->bat.ubid) {
		char bname[BUFSIZ];
		BAT *b = bm_lbid2bat(tr->bm, i->bat.bid);
		BAT *u = bm_lbid2bat(tr->bm, i->bat.ubid);

		snprintf(bname, BUFSIZ, "%s_%s", i->t->base.name, i->base.name);
		i->bat.bid = bm_add_bat(tr->parent->bm, b->batCacheid, bname, 0);

		if (tr->parent == gtrans)
			ok = log_bat_persists(logger, b, i->bat.bid, bname);

		bat_destroy(b);

		snprintf(bname, BUFSIZ, "U_%s_%s", i->t->base.name, i->base.name);
		i->bat.ubid = bm_add_bat(tr->parent->bm, u->batCacheid, bname, 0);

		if (tr->parent == gtrans && ok == SQL_OK)
			ok = log_bat_persists(logger, u, i->bat.ubid, bname);

		bat_destroy(u);
	} else if (i->key != NULL) {
		sql_kc *c = i->columns->h->data;
		BAT *b = bind_bat(tr->parent, c->c, RDONLY);

		BATkey(BATmirror(b), BOUND2BTRUE);
		bat_destroy(b);
	}
	if (ok != SQL_OK)
		return NULL;
	return i;
}

static sql_key *
rollforward_create_key(sql_trans *tr, sql_key *k)
{
	(void) tr;
	return k;
}

static sql_column *
rollforward_create_column(sql_trans *tr, sql_column *c)
{
	int ok = SQL_OK;
	char bname[BUFSIZ];
	BAT *b, *u;

	if (!c->t->clear) {
		/* only log on toplevel */
		assert(!c->bat.ibid);
		b = bm_lbid2bat(tr->bm, c->bat.bid);

		snprintf(bname, BUFSIZ, "%s_%s", c->t->base.name, c->base.name);
		c->bat.bid = bm_add_bat(tr->parent->bm, b->batCacheid, bname, 0);
		if (tr->parent == gtrans)
			ok = log_bat_persists(logger, b, c->bat.bid, bname);

		c->t->cnt = BATcount(b);
		bat_destroy(b);

		u = bm_lbid2bat(tr->bm, c->bat.ubid);

		snprintf(bname, BUFSIZ, "U_%s_%s", c->t->base.name, c->base.name);
		c->bat.ubid = bm_add_bat(tr->parent->bm, u->batCacheid, bname, 0);

		if (tr->parent == gtrans && ok == SQL_OK)
			ok = log_bat_persists(logger, u, c->bat.ubid, bname);

		bat_destroy(u);
	}

	if (ok != SQL_OK)
		return NULL;
	return c;
}

static sql_column *
rollforward_use_bat(sql_trans *tr, sql_column *c)
{
	int ok = SQL_OK;
	char bname[BUFSIZ];
	BAT *b;

	/* only log on toplevel */
	assert(!c->bat.ibid);
	b = bm_lbid2bat(tr->bm, c->bat.bid);

	snprintf(bname, BUFSIZ, "%s_%s", c->t->base.name, c->base.name);
	c->bat.bid = bm_add_bat(tr->parent->bm,
				b->batCacheid, bname, 1 /*=> no rename */ );

	if (tr->parent == gtrans)
		ok = log_bat_persists(logger, b, c->bat.bid, bname);

	bat_destroy(b);

	if (ok != SQL_OK)
		return NULL;
	return c;
}

static sql_table *
rollforward_create_table(sql_trans *tr, sql_table *t)
{
	int ok = SQL_OK;

	if (t->table && t->persists) {
		/* only register bats for non cleared tables */

		rollforward_changeset_creates(tr, &t->columns, (rfcfunc) &rollforward_create_column);
		if (!t->clear) {
			char name[BUFSIZ];

			BAT *d = bm_lbid2bat(tr->bm, t->dbid);

			snprintf(name, BUFSIZ, "D_%s", t->base.name);
			t->dbid = bm_add_bat(tr->parent->bm, d->batCacheid, name, 0);

			if (tr->parent == gtrans)
				ok = log_bat_persists(logger, d, t->dbid, name);

			t->cnt -= BATcount(d);
			bat_destroy(d);
		}

		rollforward_changeset_creates(tr, &t->idxs, (rfcfunc) &rollforward_create_idx);
		/* bat views also need to be registered */
	} else if (!t->table && t->persists && !t->query) {
		rollforward_changeset_creates(tr, &t->columns, (rfcfunc) &rollforward_use_bat);
	}
	if (ok != SQL_OK)
		return NULL;
	return t;
}

static int
rollforward_drop_column(sql_trans *tr, sql_column *c)
{
	int ok = SQL_OK;

	if (c->bat.bid && c->bat.ubid) {
		if (tr->parent == gtrans) {
			ok = log_bat_transient(logger, c->bat.bid);

			if (ok == SQL_OK)
				ok = log_bat_transient(logger, c->bat.ubid);
		}
		bm_del_bat(tr->parent->bm, c->bat.bid);
		bm_del_bat(tr->parent->bm, c->bat.ubid);
	}
	return SQL_OK;
}

static int
rollforward_drop_idx(sql_trans *tr, sql_idx * i)
{
	int ok = SQL_OK;

	if (i->bat.bid && i->bat.ubid) {
		if (tr->parent == gtrans) {
			ok = log_bat_transient(logger, i->bat.bid);

			if (ok == SQL_OK)
				ok = log_bat_transient(logger, i->bat.ubid);
		}
		bm_del_bat(tr->parent->bm, i->bat.bid);
		bm_del_bat(tr->parent->bm, i->bat.ubid);
	}
	list_remove_data(i->t->s->idxs, i);
	return SQL_OK;
}

static int
rollforward_drop_key(sql_trans *tr, sql_key *k)
{
	(void) tr;		/* unused! */
	/* remove key from schema */
	list_remove_data(k->t->s->keys, k);
	if (k->type == fkey) {
		sql_fkey *fk = (sql_fkey *) k;
		node *n = list_find_name(fk->rkey->keys, fk->k.base.name);

		list_remove_node(fk->rkey->keys, n);
	}
	return SQL_OK;
}

static int
rollforward_drop_table(sql_trans *tr, sql_table *t)
{
	int ok = SQL_OK;

	if (t->table && t->persists && !t->clear) {
		if (tr->parent == gtrans)
			ok = log_bat_transient(logger, t->dbid);
		bm_del_bat(tr->parent->bm, t->dbid);
	}

	if (ok == SQL_OK)
		ok = rollforward_changeset_deletes(tr, &t->columns, (rfdfunc) &rollforward_drop_column);
	if (ok == SQL_OK)
		ok = rollforward_changeset_deletes(tr, &t->idxs, (rfdfunc) &rollforward_drop_idx);
	if (ok == SQL_OK)
		ok = rollforward_changeset_deletes(tr, &t->keys, (rfdfunc) &rollforward_drop_key);
	return ok;
}

static void
rollforward_drop_schema(sql_trans *tr, sql_schema *s)
{
	rollforward_changeset_deletes(tr, &s->tables, (rfdfunc) &rollforward_drop_table);
}

static sql_schema *
rollforward_create_schema(sql_trans *tr, sql_schema *s)
{
	rollforward_changeset_creates(tr, &s->tables, (rfcfunc) &rollforward_create_table);
	return s;
}

static sql_module *
rollforward_create_module(sql_trans *tr, sql_module *m)
{
	(void)tr;
	return m;
}


static int
rollforward_update_table(sql_trans *tr, sql_table *ft, sql_table *tt)
{
	int ok = SQL_OK;
	sql_trans *ttr = tr->parent;
	node *n, *m;

	/* cannot update views, temporaries and cleared tables */
	if (!ft->table || !ft->persists || ft->clear)
		return ok;

	ok = rollforward_changeset_updates(tr, &ft->columns, &tt->columns, &tt->base, (rfufunc) NULL, (rfcfunc) &rollforward_create_column, (rfdfunc) &rollforward_drop_column, (dupfunc) &column_dup);
	if (ok == SQL_OK)
		ok = rollforward_changeset_updates(tr, &ft->idxs, &tt->idxs, &tt->base, (rfufunc) NULL, (rfcfunc) &rollforward_create_idx, (rfdfunc) &rollforward_drop_idx, (dupfunc) &idx_dup);
	if (ok == SQL_OK)
		ok = rollforward_changeset_updates(tr, &ft->keys, &tt->keys, &tt->base, (rfufunc) NULL, (rfcfunc) &rollforward_create_key, (rfdfunc) &rollforward_drop_key, (dupfunc) &key_dup);

	assert(cs_size(&tt->columns) == cs_size(&ft->columns));

	n = ft->columns.set->h;
	m = tt->columns.set->h;

	if (ok == SQL_OK && n && m) {
		lng deleted = 0;
		BAT *db = bm_lbid2bat(tr->bm, ft->dbid);

		if (ft->base.rtime)
			tt->base.rtime = tr->stime;
		tt->base.wtime = tr->stime;

		if (ft->cleared && ttr == gtrans)
			ok = log_bat_clear(logger, tt->dbid);

		deleted = BATcount(db);
		tt->cnt = 0;
		if (BUNlast(db) > db->batInserted) {
			bm_new_bat(ttr->bm, tt->dbid, db);

			BATsetaccess(db, BAT_READ);
			if (ttr == gtrans)
				ok = log_bat(logger, tt->dbid, db);
		} else {
			bat_destroy(db);
			db = NULL;
		}

		do {
			sql_column *cc = n->data;
			sql_column *oc = m->data;
			BAT *ins, *ups, *cur;
			int renewed = ft->cleared, inserted = 0;

			if (!cc->base.wtime) {
				n = n->next;
				m = m->next;
				continue;
			}

			ins = cc->bat.ibid ? temp_descriptor(cc->bat.ibid) : bm_lbid2bat(tr->bm, cc->bat.bid);
			ups = bm_lbid2bat(tr->bm, cc->bat.ubid);

			cur = ins;
			if (cc->bat.ibid) {
				BAT *ocur = bm_lbid2bat(ttr->bm, oc->bat.bid);

				if (BATcount(ocur)) {
					/* void union ? */
					cur = bat_lcopy(ocur, "rollforward");
					void_append_bat(cur, ins);
					assert(cur->htype == TYPE_void);
					bat_destroy(ins);
				} else {
					bat_destroy(ocur);
				}
			} else if (oc->base.wtime > cc->base.wtime) {
				/* write without read, ie append 
				 * are handled by the special insert bat,
				 * so we should not arrive here 
				 */
				assert(0);
			}
			if (BUNlast(cur) > cur->batInserted) {
				renewed = 1;
				inserted = 1;
			}
			if (ok == SQL_OK && ttr == gtrans && inserted)
				ok = log_bat(logger, oc->bat.bid, cur);

			if (db) {
				if (!renewed) {
					cur = bat_lcopy(cur, "rollforward");
					renewed = 1;
				}
				void_delete_bat(cur, db, 1);
			}
			if (BUNlast(ups) > ups->batInserted) {
				if (!renewed) {
					cur = bat_lcopy(cur, "rollforward");
					renewed = 1;
				}
				bm_new_bat(ttr->bm, oc->bat.ubid, ups);

				BATsetaccess(ups, BAT_READ);
				void_replace_bat(cur, ups);
				if (ok == SQL_OK && ttr == gtrans)
					ok = log_bat(logger, oc->bat.ubid, ups);
			}
			bat_destroy(ups);
			if (renewed) {
				bm_new_bat(ttr->bm, oc->bat.bid, cur);

				BATsetaccess(cur, BAT_READ);
			}
			if (!tt->cnt)
				tt->cnt = BATcount(cur)-deleted;
			bat_destroy(cur);

			if (cc->base.rtime)
				oc->base.rtime = tr->stime;
			oc->base.wtime = tr->stime;

			n = n->next;
			m = m->next;
		} while (ok == SQL_OK && n && m);
		if (tt->idxs.set) {
			for (n = tt->idxs.set->h, m = tt->idxs.set->h; ok == SQL_OK && n && m; n = n->next, m = m->next) {
				sql_idx *ci = n->data;
				sql_idx *oi = m->data;

				if (ci->bat.bid && ci->bat.ubid) {
					BAT *ins = ci->bat.ibid ? temp_descriptor(ci->bat.ibid) : bm_lbid2bat(tr->bm, ci->bat.bid);
					BAT *ups = bm_lbid2bat(tr->bm, ci->bat.ubid);

					assert(!ci->bat.ibid);

					if (ci->base.rtime)
						oi->base.rtime = tr->stime;
					oi->base.wtime = tr->stime;

					if (BUNlast(ins) > ins->batInserted) {
						bm_new_bat(ttr->bm, oi->bat.bid, ins);

						BATsetaccess(ins, BAT_READ);
						if (ttr == gtrans)
							ok = log_bat(logger, oi->bat.bid, ins);
					} else if (db) {
						BAT *cur = bm_lbid2bat(ttr->bm, oi->bat.bid);

						cur = bat_lcopy(cur, "rollforward");

						void_delete_bat(cur, db, 1);
						bm_new_bat(ttr->bm, oi->bat.bid, cur);

						BATsetaccess(cur, BAT_READ);
						bat_destroy(cur);
					}
					bat_destroy(ins);
					if (BUNlast(ups) > ups->batInserted) {
						bm_new_bat(ttr->bm, oi->bat.ubid, ups);

						BATsetaccess(ups, BAT_READ);
						if (ttr == gtrans)
							ok = log_bat(logger, oi->bat.ubid, ups);
					}
					bat_destroy(ups);
				}
			}
		}
		if (db)
			bat_destroy(db);

	}
	return ok;
}

static sql_table *
conditional_table_dup(sql_trans *tr, int flag, sql_table *ot, sql_schema *s)
{
	/* persistent bats need to be dupped */
	if ((ot->persists && tr->parent == gtrans) ||
	    /* allways dup in recursive mode */
	    tr->parent != gtrans)
		return table_dup(tr, flag, ot, s);
	return NULL;
}

static int
rollforward_update_schema(sql_trans *tr, sql_schema *fs, sql_schema *ts)
{
	return rollforward_changeset_updates(tr, &fs->tables, &ts->tables, &ts->base, (rfufunc) &rollforward_update_table, (rfcfunc) &rollforward_create_table, (rfdfunc) &rollforward_drop_table, (dupfunc) &conditional_table_dup);
}

static int
rollforward_trans(sql_trans *tr)
{
	int ok = rollforward_changeset_updates(tr, &tr->modules,
					       &tr->parent->modules,
					       (sql_base *) tr->parent,
					       (rfufunc) NULL,
					       (rfcfunc) &rollforward_create_module,
					       (rfdfunc) NULL,
					       (dupfunc) &module_dup);

	if (tr->parent && tr->wtime > tr->parent->wtime)
		tr->parent->wtime = tr->wtime;

	if (ok == SQL_OK)
		ok = rollforward_changeset_updates(tr, &tr->schemas, &tr->parent->schemas, (sql_base *) tr->parent, (rfufunc) &rollforward_update_schema, (rfcfunc) &rollforward_create_schema, (rfdfunc) &rollforward_drop_schema, (dupfunc) &schema_dup);
	return ok;
}

static int
validate_tables(sql_schema *s, sql_schema *os)
{
	/* bm_validate(tr->bm, tr->parent->bm); */
	node *n, *o, *p;

	if (cs_size(&s->tables))
		for (n = s->tables.set->h; n; n = n->next) {
			sql_table *t = n->data;
			sql_table *ot = find_sql_table(os, t->base.name);

			if (ot && ot->table && t->table) {
				for (o = t->columns.set->h, p = ot->columns.set->h; o && p; o = o->next, p = p->next) {
					sql_column *c = o->data;
					sql_column *oc = p->data;

					/* t wrote, ie. check read and write time */
					/* read or write after t's write */
					if (c->base.wtime && (c->base.wtime < oc->base.rtime
							      /* allow for late appends, ie 
							       * wtime but no rtime 
							       */
							      || (c->base.wtime < oc->base.wtime && c->base.rtime))) {
						return 0;
					}
					/* commited write before t's read */
					if (c->base.rtime && c->base.rtime < oc->base.wtime) {
						return 0;
					}
				}
			}
		}
	return 1;
}

sql_trans *
sql_trans_create(backend_stack stk, sql_trans *parent, char *name)
{
	sql_trans *tr = NULL;

	if (gtrans) {
		tr = trans_dup(stk, (parent) ? parent : gtrans, name);
	}
	return tr;
}

int
sql_trans_validate(sql_trans *tr)
{
	node *n;

	/* depends on the iso level */

	/* since we protect usage through private copies both the iso levels
	   read uncommited and read commited always succeed.
	 */
	if (tr->level == ISO_READ_UNCOMMITED || tr->level == ISO_READ_COMMITED)
		return 1;

	/* If only 'inserts' occurred on the read bats the repeatable reads
	   iso level can continue */

	/* the hard case */
	if (cs_size(&tr->schemas))
		for (n = tr->schemas.set->h; n; n = n->next) {
			sql_schema *s = n->data;
			sql_schema *os = find_sql_schema(tr->parent, s->base.name);

			if (os || (s->base.wtime == 0 && s->base.rtime == 0)) {
				if (!validate_tables(s, os))
					return 0;
			}
		}
	return 1;
}

int
sql_trans_commit(sql_trans *tr)
{
	int ok = SQL_OK;

	/* write phase */
	if (bs_debug)
		fprintf(stderr, "forwarding changes\n");
	if (tr->parent == gtrans) {
		tr->stime = timestamp ();
		ok = log_tstart(logger);
	}
	if (ok == SQL_OK)
		ok = rollforward_trans(tr);
	if (tr->parent == gtrans) {
		if (ok == SQL_OK)
			ok = log_tend(logger);
	}
	if (bs_debug)
		fprintf(stderr, "done forwarding changes\n");
	return ok;
}

static void
sys_drop_kc(sql_trans *tr, sql_key *k, sql_kc *kc)
{
	sql_table *syskc = find_sql_table(find_sql_schema(tr, "sys"), "keycolumns");
	oid rid = column_find_row(tr, find_sql_column(syskc, "id"), &k->base.id, NULL);

	(void) kc;		/* Stefan: unused!? */

	table_delete(tr, syskc, rid);

	syskc->base.wtime = syskc->s->base.wtime = tr->wtime = tr->stime;
}

static void
sys_drop_key(sql_trans *tr, sql_key *k)
{
	node *n;
	sql_table *syskey = find_sql_table(find_sql_schema(tr, "sys"), "keys");
	oid rid = column_find_row(tr, find_sql_column(syskey, "id"), &k->base.id, NULL);

	table_delete(tr, syskey, rid);

	for (n = k->columns->h; n; n = n->next) {
		sql_kc *kc = n->data;

		sys_drop_kc(tr, k, kc);
	}
	syskey->base.wtime = syskey->s->base.wtime = tr->wtime = tr->stime;
	list_remove_data(k->t->s->keys, k);
	if (k->type == fkey) {
		sql_fkey *fk = (sql_fkey *) k;
		node *n = list_find_name(fk->rkey->keys, fk->k.base.name);

		list_remove_node(fk->rkey->keys, n);
	}
}

static void
sys_drop_ic(sql_trans *tr, sql_idx * i, sql_kc *kc)
{
	sql_table *syskc = find_sql_table(find_sql_schema(tr, "sys"), "keycolumns");
	oid rid = column_find_row(tr, find_sql_column(syskc, "id"), &i->base.id, NULL);

	(void) kc;		/* Stefan: unused!? */

	table_delete(tr, syskc, rid);

	syskc->base.wtime = syskc->s->base.wtime = tr->wtime = tr->stime;
}

static void
sys_drop_idx(sql_trans *tr, sql_idx * i)
{
	node *n;
	sql_table *sysidx = find_sql_table(find_sql_schema(tr, "sys"), "idxs");
	oid rid = column_find_row(tr, find_sql_column(sysidx, "id"), &i->base.id, NULL);

	table_delete(tr, sysidx, rid);

	for (n = i->columns->h; n; n = n->next) {
		sql_kc *ic = n->data;

		sys_drop_ic(tr, i, ic);
	}

	sysidx->base.wtime = sysidx->s->base.wtime = tr->wtime = tr->stime;
	list_remove_data(i->t->s->idxs, i);
}

static void
sys_drop_column(sql_trans *tr, sql_column *col)
{
	sql_table *syscolumn = find_sql_table(find_sql_schema(tr, "sys"), "pcolumns");
	oid rid = column_find_row(tr, find_sql_column(syscolumn, "id"),
				  &col->base.id, NULL);

	table_delete(tr, syscolumn, rid);
	syscolumn->base.wtime = syscolumn->s->base.wtime = tr->wtime = tr->stime;
}

static void
sys_drop_keys(sql_trans *tr, sql_table *t)
{
	node *n;

	if (cs_size(&t->keys))
		for (n = t->keys.set->h; n; n = n->next) {
			sql_key *k = n->data;

			sys_drop_key(tr, k);
		}
}

static void
sys_drop_idxs(sql_trans *tr, sql_table *t)
{
	node *n;

	if (cs_size(&t->idxs))
		for (n = t->idxs.set->h; n; n = n->next) {
			sql_idx *k = n->data;

			sys_drop_idx(tr, k);
		}
}

static void
sys_drop_columns(sql_trans *tr, sql_table *t)
{
	node *n;

	if (cs_size(&t->columns))
		for (n = t->columns.set->h; n; n = n->next) {
			sql_column *c = n->data;

			sys_drop_column(tr, c);
		}
}

static void
sys_drop_table(sql_trans *tr, sql_table *t)
{
	sql_schema *syss = find_sql_schema(tr, "sys");
	sql_table *systable = find_sql_table(syss,
					 t->persists ? "ptables" : "ttables");
	oid rid = column_find_row(tr, find_sql_column(systable, "id"), &t->base.id, NULL);

	table_delete(tr, systable, rid);
	sys_drop_keys(tr, t);
	sys_drop_idxs(tr, t);

	if (t->table)
		sys_drop_columns(tr, t);

	systable->base.wtime = systable->s->base.wtime = tr->wtime = tr->stime;
}

static void
sys_drop_tables(sql_trans *tr, sql_schema *s)
{
	node *n;

	if (cs_size(&s->tables))
		for (n = s->tables.set->h; n; n = n->next) {
			sql_table *t = n->data;

			sys_drop_table(tr, t);
		}
}

sql_module *
sql_trans_create_module(sql_trans *tr, char *name, char *opt_mod)
{
	sql_module *m = NEW(sql_module);
	sql_table *sysmodule = find_sql_table(find_sql_schema(tr, "sys"), "modules");

	base_init(&m->base, OIDnew(1), TR_NEW, name);
	cs_init(&m->types, (fdestroy) &type_destroy);
	cs_init(&m->funcs, (fdestroy) &func_destroy);
	m->internal = NULL;
	if (opt_mod)
		m->internal = _strdup(opt_mod);

	cs_add(&tr->modules, m, TR_NEW);

	table_insert(tr, sysmodule, &m->base.id, m->base.name, m->internal);

	if (opt_mod) 
		do_load_module(tr, opt_mod);
	sysmodule->base.wtime = sysmodule->s->base.wtime = m->base.wtime = tr->wtime = tr->stime;
	return m;
}

void
sql_trans_drop_module(sql_trans *tr, char *name)
{
	node *n = find_sql_module_node(tr, name);
	sql_module *m = n->data;

	sql_table *sysmodule = find_sql_table(find_sql_schema(tr, "sys"), "modules");
	oid rid = column_find_row(tr, find_sql_column(sysmodule, "id"), &m->base.id, NULL);

	table_delete(tr, sysmodule, rid);
	m->base.wtime = sysmodule->base.wtime = sysmodule->s->base.wtime = tr->wtime = tr->stime;
	cs_del(&tr->modules, n, m->base.flag);
}

sql_type *
sql_trans_create_type(sql_trans *tr, sql_module * m, char *sqlname, int digits, int scale, int radix, char *impl)
{
	sql_type *t = NEW(sql_type);
	sql_table *systype = find_sql_table(find_sql_schema(tr, "sys"), "types");

	base_init(&t->base, OIDnew(1), TR_NEW, impl);
	t->sqlname = _strdup(sqlname);
	t->digits = digits;
	t->scale = scale;
	t->radix = radix;
	t->eclass = EC_ANY;
	t->localtype = ATOMindex(t->base.name);
	t->m = m;

	cs_add(&m->types, t, TR_NEW);

	table_insert(tr, systype, &t->base.id, t->base.name, t->sqlname, &t->digits, &t->scale, &t->radix, &t->eclass, &m->base.id);

	systype->base.wtime = systype->s->base.wtime = t->base.wtime = m->base.wtime = tr->wtime = tr->stime;
	return t;
}

sql_func *
sql_trans_create_func(sql_trans *tr, sql_module * m, char *func, list *args, bit sql, bit aggr, char *impl)
{
	sql_func *t = NEW(sql_func);
	sql_table *sysfunc = find_sql_table(find_sql_schema(tr, "sys"), "functions");
	sql_table *sysarg = find_sql_table(find_sql_schema(tr, "sys"), "args");
	node *n;
	int number = 0;

	base_init(&t->base, OIDnew(1), TR_NEW, func);
	t->imp = _strdup(impl);
	t->sql = sql;
	t->aggr = aggr;
	t->ops = list_dup(args, (fdup)&arg_dup);
	t->res = NULL;
	t->m = m;

	cs_add(&m->funcs, t, TR_NEW);

	table_insert(tr, sysfunc, &t->base.id, t->base.name, t->imp, &t->sql, &t->aggr, &m->base.id);
	if (t->ops) for (n = t->ops->h; n; n = n->next, number++) {
		sql_arg *a = n->data;
		oid id = OIDnew(1);

		table_insert(tr, sysarg, &id, &t->base.id, a->name, a->type->type->sqlname, &a->type->type->digits, &a->type->type->scale, &number);
	}
	if (!aggr && list_length(args) > 0) {
		node *n = t->ops->h;
		sql_arg *a = n->data;
		t->res = sql_dup_subtype(a->type);
		list_remove_node(t->ops, n);
	}

	sysfunc->base.wtime = sysfunc->s->base.wtime = t->base.wtime = m->base.wtime = tr->wtime = tr->stime;
	return t;
}

sql_schema *
sql_trans_create_schema(sql_trans *tr, char *name, int auth_id)
{
	sql_schema *s = NEW(sql_schema);
	sql_table *sysschema = find_sql_table(find_sql_schema(tr, "sys"), "schemas");

	base_init(&s->base, OIDnew(1), TR_NEW, name);
	s->auth_id = auth_id;
	cs_init(&s->tables, (fdestroy) &table_destroy);
	s->keys = list_create((fdestroy) NULL);
	s->idxs = list_create((fdestroy) NULL);

	cs_add(&tr->schemas, s, TR_NEW);
	/* switch to the new schema */
	tr->schema = s;

	table_insert(tr, sysschema, &s->base.id, s->base.name, &s->auth_id);

	sysschema->base.wtime = sysschema->s->base.wtime = s->base.wtime = tr->wtime = tr->stime;
	return s;
}

void
sql_trans_drop_schema(sql_trans *tr, char *sname)
{
	node *n = find_sql_schema_node(tr, sname);
	sql_schema *s = n->data;
	sql_table *sysschema = find_sql_table(find_sql_schema(tr, "sys"), "schemas");
	oid rid = column_find_row(tr, find_sql_column(sysschema, "id"), &s->base.id, NULL);

	table_delete(tr, sysschema, rid);
	sys_drop_tables(tr, s);

	s->base.wtime = sysschema->base.wtime = sysschema->s->base.wtime = tr->wtime = tr->stime;
	cs_del(&tr->schemas, n, s->base.flag);
}

sql_table *
sql_trans_create_table(sql_trans *tr, sql_schema *s, char *name, bit system, bit persists, bit clear, int sz)
{
	BAT *b;
	char bname[BUFSIZ];
	sql_table *t = create_table_intern(name, 1, system, persists, clear);
	sql_schema *syss = find_sql_schema(tr, "sys");
	sql_table *systable = find_sql_table(syss, persists ? "ptables" : "ttables");

	t->dbid = 0;
	t->query = NULL;
	t->s = s;
	t->sz = sz;
	if (sz < 0)
		t->sz = BUFSIZ;
	cs_add(&s->tables, t, TR_NEW);

	b = bat_new(TYPE_void, TYPE_oid, t->sz, "sql_trans_create_table");

	snprintf(bname, BUFSIZ, "D_%s", t->base.name);
	if (t->persists && !t->clear)
		t->dbid = bm_add_bat(tr->bm, b->batCacheid, bname, 0);

	else
		t->dbid = temp_create(b);
	bat_destroy(b);

	systable->base.wtime = tr->stime;

	table_insert(tr, systable, &t->base.id, t->base.name, &s->base.id, ATOMnilptr(TYPE_str), &t->table, &t->system, &t->clear);

	if (t->persists)
		t->base.wtime = s->base.wtime = tr->wtime = tr->stime;
	return t;
}


sql_table *
sql_trans_create_view(sql_trans *tr, sql_schema *s, char *name, char *sql, bit system, bit persists)
{
	sql_table *t = create_table_intern(name, 0, system, persists, 0);
	sql_schema *syss = find_sql_schema(tr, "sys");
	sql_table *systable = find_sql_table(syss, persists ? "ptables" : "ttables");

	t->query = NULL;
	if (sql)
		t->query = _strdup(sql);
	t->s = s;
	cs_add(&s->tables, t, TR_NEW);

	table_insert(tr, systable, &t->base.id, t->base.name, &s->base.id, (t->query) ? t->query : ATOMnilptr(TYPE_str), &t->table, &t->system, &t->clear);

	if (t->persists)
		systable->base.wtime = t->base.wtime = s->base.wtime = tr->wtime = tr->stime;
	return t;
}

static
sql_column *
create_column_bat(sql_trans *tr, sql_table *t, char *name, sql_subtype *tpe, BAT *bb, BAT *u)
{
	char bname[BUFSIZ];
	sql_column *col = NEW(sql_column);
	sql_schema *syss = find_sql_schema(tr, "sys");
	sql_table *syscolumn = find_sql_table(syss, t->persists ? "pcolumns" : "tcolumns");

	base_init(&col->base, OIDnew(1), TR_NEW, name);
	col->type = tpe;
	col->def = NULL;
	col->null = 1;
	col->colnr = cs_size(&t->columns);
	col->t = t;
	col->bat.bid = 0;
	col->bat.ibid = 0;
	col->bat.ubid = 0;

	cs_add(&t->columns, col, TR_NEW);

	col->base.wtime = t->base.wtime = t->s->base.wtime = tr->wtime = tr->stime;

	if (bb) {
		snprintf(bname, BUFSIZ, "%s_%s", col->t->base.name, col->base.name);
		if (t->persists && !t->clear)
			col->bat.bid = bm_add_bat(tr->bm, bb->batCacheid, bname, 0);
		else
			col->bat.bid = temp_create(bb);
	}

	if (u) {
		snprintf(bname, BUFSIZ, "U_%s_%s", col->t->base.name, col->base.name);
		if (t->persists && !t->clear)
			col->bat.ubid = bm_add_bat(tr->bm, u->batCacheid, bname, 0);
		else
			col->bat.ubid = temp_create(u);
	}

	table_insert(tr, syscolumn, &col->base.id, col->base.name, col->type->type->sqlname, &col->type->digits, &col->type->scale, &t->base.id, (col->def) ? col->def : ATOMnilptr(TYPE_str), &col->null, &col->colnr);

	syscolumn->base.wtime = syscolumn->s->base.wtime = tr->stime;
	return col;
}

char *
sql_view_on_bats(sql_trans *tr, sql_table *t, char **names, int nr)
{
	int i;
	char err[BUFSIZ];

	for ( i = 0; i<nr; i++ ) {
		bat bid = BBPindex(names[i]);
		BAT *b;
		sql_subtype *tp;

		if (!bid) {
			snprintf(err, BUFSIZ, "Create view as bats,"
		   		" bat %s does not exist", names[i]);
			return _strdup(err);
		}
		b = BATdescriptor(bid);
		if (b->htype != TYPE_void || b->hseqbase != 0) {
		   	bat_destroy(b);
			snprintf(err, BUFSIZ, "Create view as bats,"
		   	" bat %s does not have a void head or head seqbase 0", 
		   	names[i]);
			return _strdup(err);
		}
		tp = sql_bind_localtype(ATOMname(b->ttype));
		tp = sql_dup_subtype(tp);
		create_column_bat(tr, t, names[i], tp, b, NULL );  
		bat_destroy(b);
	}
	return NULL;
}

void
sql_trans_drop_table(sql_trans *tr, sql_schema *s, char *name, int cascade)
{
	node *n = find_sql_table_node(s, name);
	sql_table *t = n->data;

	(void) cascade;		/* Stefan: unused!? */

	sys_drop_table(tr, t);

	t->base.wtime = s->base.wtime = tr->wtime = tr->stime;
	cs_del(&s->tables, n, t->base.flag);

	/* TODO cascade, ie. remove al references to this table */
}

size_t
sql_trans_clear_table(sql_trans *tr, sql_table *t)
{
	node *n = t->columns.set->h;
	sql_column *c = n->data;
	size_t sz = 0;

	t->cleared = 1;
	t->base.wtime = t->s->base.wtime = tr->wtime = tr->stime;
	if (t->clear || !t->persists) {
		BAT *b = temp_descriptor(c->bat.bid);

		sz = BATcount(b);
		BATclear(b);
		bat_destroy(b);
		for (n = n->next; n; n = n->next) {
			c = n->data;
			b = temp_descriptor(c->bat.bid);

			BATclear(b);
			bat_destroy(b);
		}
		/* temp's do not have indices */
	} else {
		BAT *b, *nb;

		c->base.wtime = tr->stime;
		if (c->bat.ibid) {
			b = temp_descriptor(c->bat.ibid);

			sz += BATcount(b);
			bat_destroy(b);
			temp_destroy(c->bat.ibid);
			c->bat.ibid = 0;
		}
		b = bm_lbid2bat(tr->bm, c->bat.bid);

		sz += BATcount(b);
		nb = bat_new(TYPE_void, b->ttype, t->sz, "clear_table");
		bat_destroy(b);
		bm_new_bat(tr->bm, c->bat.bid, nb);

		bat_destroy(nb);
		if (c->bat.ubid) {
			b = bm_lbid2bat(tr->bm, c->bat.ubid);

			nb = bat_new(TYPE_oid, b->ttype, t->sz, "clear_table");
			bat_destroy(b);
			bm_new_bat(tr->bm, c->bat.ubid, nb);

			bat_destroy(nb);
		}
		if (t->dbid) {
			b = bm_lbid2bat(tr->bm, t->dbid);

			sz -= BATcount(b);
			nb = bat_new(TYPE_void, TYPE_oid, t->sz, "clear_table");
			bat_destroy(b);
			bm_new_bat(tr->bm, t->dbid, nb);

			bat_destroy(nb);
		}

		for (n = n->next; n; n = n->next) {
			c = n->data;
			c->base.wtime = tr->stime;
			if (c->bat.ibid) {
				b = temp_descriptor(c->bat.ibid);

				bat_destroy(b);
				temp_destroy(c->bat.ibid);
				c->bat.ibid = 0;
			}
			b = bm_lbid2bat(tr->bm, c->bat.bid);

			nb = bat_new(TYPE_void, b->ttype, t->sz, "clear_table");
			bat_destroy(b);
			bm_new_bat(tr->bm, c->bat.bid, nb);

			bat_destroy(nb);
			if (c->bat.ubid) {
				b = bm_lbid2bat(tr->bm, c->bat.ubid);

				nb = bat_new(TYPE_oid, b->ttype, t->sz, "clear_table");
				bat_destroy(b);
				bm_new_bat(tr->bm, c->bat.ubid, nb);

				bat_destroy(nb);
			}
		}
		if (t->idxs.set) {
			for (n = t->idxs.set->h; n; n = n->next) {
				sql_idx *ci = n->data;

				ci->base.wtime = tr->stime;
				if (ci->bat.bid && ci->bat.ubid) {
					if (ci->bat.ibid) {
						b = temp_descriptor(ci->bat.ibid);

						bat_destroy(b);
						temp_destroy(ci->bat.ibid);
						ci->bat.ibid = 0;
					}
					b = bm_lbid2bat(tr->bm, ci->bat.bid);

					nb = bat_new(TYPE_void, b->ttype, t->sz, "clear_table");
					bat_destroy(b);
					bm_new_bat(tr->bm, ci->bat.bid, nb);

					bat_destroy(nb);
					if (ci->bat.ubid) {
						b = bm_lbid2bat(tr->bm, ci->bat.ubid);

						nb = bat_new(TYPE_oid, b->ttype, t->sz, "clear_table");
						bat_destroy(b);
						bm_new_bat(tr->bm, ci->bat.ubid, nb);

						bat_destroy(nb);
					}
				}
			}
		}
	}
	return sz;
}

sql_column *
sql_trans_create_column(sql_trans *tr, sql_table *t, char *name, sql_subtype *tpe)
{
	sql_column *res = NULL;
	int type;

	if (!tpe)
		return NULL;

	type = tpe->type->localtype;

	if (t->table) {
		BAT *u, *b;

		b = bat_new(TYPE_void, type, t->sz, "sql_trans_create_column");
		u = bat_new(TYPE_oid, type, t->sz, "sql_trans_create_column");

		if (!b || !u) {
			if (b)
				BBPreclaim(b);
			if (u)
				BBPreclaim(u);
			sql_subtype_destroy(tpe);
			return NULL;
		}

		res = create_column_bat(tr, t, name, tpe, b, u);
		bat_destroy(b);
		bat_destroy(u);
	} else {
		res = create_column_bat(tr, t, name, tpe, NULL, NULL);
	}
	return res;
}

void
sql_trans_drop_column(sql_trans *tr, sql_table *t, char *name)
{
	node *n = find_sql_column_node(t, name);
	sql_column *col = n->data;

	if (t->table)
		sys_drop_column(tr, col);

	if (t->persists)
		col->base.wtime = t->base.wtime = t->s->base.wtime = tr->wtime = tr->stime;
	cs_del(&t->columns, n, col->base.flag);
}

sql_column *
sql_trans_alter_null(sql_trans *tr, sql_column *col, int isnull)
{
	if (col->null != isnull) {
		sql_table *syscolumn = find_sql_table(find_sql_schema(tr, "sys"),
						  col->t->persists ? "pcolumns" : "tcolumns");
		oid rid = column_find_row(tr, find_sql_column(syscolumn, "id"),
					  &col->base.id, NULL);

		column_update_value(tr, find_sql_column(syscolumn, "null"), rid, &isnull);
		col->null = isnull;
		col->base.wtime = col->t->base.wtime = col->t->s->base.wtime = tr->wtime = tr->stime;
	}

	return col;
}

sql_column *
sql_trans_alter_default(sql_trans *tr, sql_column *col, char *val)
{
	if (!col->def && !val)
		return col;	/* no change */

	if (!col->def || !val || strcmp(col->def, val) != 0) {
		void *p = val ? val : ATOMnilptr(TYPE_str);
		sql_table *syscolumn = find_sql_table(find_sql_schema(tr, "sys"),
						  col->t->persists ? "pcolumns" : "tcolumns");
		oid rid = column_find_row(tr, find_sql_column(syscolumn, "id"),
					  &col->base.id, NULL);

		column_update_value(tr, find_sql_column(syscolumn, "default"), rid, p);
		if (col->def)
			_DELETE(col->def);
		col->def = NULL;
		if (val)
			col->def = _strdup(val);
		col->base.wtime = col->t->base.wtime = col->t->s->base.wtime = tr->wtime = tr->stime;
	}
	return col;
}

sql_key *
sql_trans_create_key(sql_trans *tr, sql_table *t, char *name, key_type kt, sql_key *rkey)
{
/* can only have keys between persistent tables */
	int neg = -1;
	sql_key *nk;
	sql_table *syskey = find_sql_table(find_sql_schema(tr, "sys"), "keys");

	if (!t->persists || t->clear)
		return NULL;

	nk = (kt != fkey) ? (sql_key *) NEW(sql_ukey)
	: (sql_key *) NEW(sql_fkey);

	assert(name);
	base_init(&nk->base, OIDnew(1), TR_NEW, name);
	nk->type = kt;
	nk->columns = list_create((fdestroy) &kc_destroy);
	nk->t = t;
	nk->idx = sql_trans_create_idx(tr, t, name, (nk->type == fkey) ? join_idx : unique);
	nk->idx->key = nk;

	if (nk->type != fkey) {
		sql_ukey *uk = (sql_ukey *) nk;

		uk->keys = NULL;

		if (nk->type == pkey)
			t->pkey = uk;
	} else if (nk->type == fkey) {
		sql_fkey *fk = (sql_fkey *) nk;
		sql_ukey *uk = (sql_ukey *) rkey;

		fk->rkey = uk;
		if (!uk->keys)
			uk->keys = list_create(NULL);
		list_append(uk->keys, fk);
	}

	cs_add(&t->keys, nk, TR_NEW);
	list_append(t->s->keys, nk);

	table_insert(tr, syskey, &nk->base.id, &t->base.id, &nk->type, nk->base.name, (nk->type == fkey) ? &((sql_fkey *) nk)->rkey->k.base.id : &neg);

	syskey->base.wtime = syskey->s->base.wtime = t->base.wtime = t->s->base.wtime = tr->wtime = tr->stime;
	return nk;
}


sql_key *
sql_trans_create_kc(sql_trans *tr, sql_key *k, sql_column *c /*, extra options such as trunc */ )
{
	sql_kc *kc = NEW(sql_kc);
	int nr = list_length(k->columns);
	sql_table *syskc = find_sql_table(find_sql_schema(tr, "sys"), "keycolumns");

	assert(c);
	kc->c = c;
	kc->trunc = 0;
	list_append(k->columns, kc);
	if (k->idx)
		sql_trans_create_ic(tr, k->idx, c);

	if (k->type == pkey)
		sql_trans_alter_null(tr, c, 0);

	table_insert(tr, syskc, &k->base.id, kc->c->base.name, &kc->trunc, &nr);

	syskc->base.wtime = tr->wtime = tr->stime;
	return k;
}

void
sql_trans_drop_key(sql_trans *tr, sql_schema *s, char *name)
{
	node *n = list_find_name(s->keys, name);
	sql_key *k = n->data;

	if (k->t->persists && !k->t->clear)
		sys_drop_key(tr, k);

	k->base.wtime = k->t->base.wtime = s->base.wtime = tr->wtime = tr->stime;
	n = cs_find_name(&k->t->keys, name);
	if (n)
		cs_del(&k->t->keys, n, k->base.flag);
}

sql_idx *
sql_trans_create_idx(sql_trans *tr, sql_table *t, char *name, idx_type it)
{
	/* can only have idxs between persistent tables */
	sql_idx *ni = NEW(sql_idx);
	sql_table *sysidx = find_sql_table(find_sql_schema(tr, "sys"), "idxs");

	if (!t->persists || t->clear)
		return NULL;

	assert(name);
	base_init(&ni->base, OIDnew(1), TR_NEW, name);
	ni->type = it;
	ni->columns = list_create((fdestroy) &kc_destroy);
	ni->t = t;
	ni->key = NULL;

	ni->bat.bid = ni->bat.ibid = ni->bat.ubid = 0;

	cs_add(&t->idxs, ni, TR_NEW);
	list_append(t->s->idxs, ni);

	/* create void,int bat to keep the hash values */
	if (it == join_idx) {
		BAT *u, *b;
		char bname[BUFSIZ];

		b = bat_new(TYPE_void, TYPE_oid, t->sz, "sql_trans_create_idx");
		snprintf(bname, BUFSIZ, "%s_%s", ni->t->base.name, ni->base.name);
		ni->bat.bid = bm_add_bat(tr->bm, b->batCacheid, bname, 0);

		bat_destroy(b);

		u = bat_new(TYPE_oid, TYPE_oid, t->sz, "sql_trans_create_idx");
		snprintf(bname, BUFSIZ, "U_%s_%s", ni->t->base.name, ni->base.name);
		ni->bat.ubid = bm_add_bat(tr->bm, u->batCacheid, bname, 0);

		bat_destroy(u);
	}

	table_insert(tr, sysidx, &ni->base.id, &t->base.id, &ni->type, ni->base.name);

	sysidx->base.wtime = t->base.wtime = t->s->base.wtime = tr->wtime = tr->stime;
	return ni;
}

sql_idx *
sql_trans_create_ic(sql_trans *tr, sql_idx * i, sql_column *c /*, extra options such as trunc */ )
{
	sql_kc *ic = NEW(sql_kc);
	int nr = list_length(i->columns);
	sql_table *sysic = find_sql_table(find_sql_schema(tr, "sys"), "keycolumns");

	assert(c);
	ic->c = c;
	ic->trunc = 0;
	list_append(i->columns, ic);

	if (!i->bat.bid && i->type == unique && list_length(i->columns) > 1) {
		BAT *u, *b;
		char bname[BUFSIZ];

		b = bat_new(TYPE_void, TYPE_int, i->t->sz, "sql_trans_create_ic");
		snprintf(bname, BUFSIZ, "%s_%s", i->t->base.name, i->base.name);
		i->bat.bid = bm_add_bat(tr->bm, b->batCacheid, bname, 0);

		bat_destroy(b);

		u = bat_new(TYPE_oid, TYPE_int, i->t->sz, "sql_trans_create_ic");
		snprintf(bname, BUFSIZ, "U_%s_%s", i->t->base.name, i->base.name);
		i->bat.ubid = bm_add_bat(tr->bm, u->batCacheid, bname, 0);

		bat_destroy(u);
	}

	table_insert(tr, sysic, &i->base.id, ic->c->base.name, &ic->trunc, &nr);

	sysic->base.wtime = sysic->s->base.wtime = tr->wtime = tr->stime;
	return i;
}

void
sql_trans_drop_idx(sql_trans *tr, sql_schema *s, char *name)
{
	node *n = list_find_name(s->idxs, name);
	sql_idx *i = n->data;

	if (i->t->persists && !i->t->clear)
		sys_drop_idx(tr, i);

	i->base.wtime = i->t->base.wtime = s->base.wtime = tr->wtime = tr->stime;
	n = cs_find_name(&i->t->idxs, name);
	if (n)
		cs_del(&i->t->idxs, n, i->base.flag);
}
