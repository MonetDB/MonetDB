@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f bat_logger
@t Transactions
@a N. J. Nes
@v 1.0
@T
@* Introduction
[Make it a re-usable piece of code if possible, i.e. a module]
In the philosophy of Monet, transaction management overhead should only
be paid when necessary. Transaction management is for this purpose 
implemented as a separate module and applications are required to
obey the transaction policy, e.g. obtaining/releasing locks. 

This module is designed to support efficient logging of SQL database.
Once loaded, the SQL compiler will insert the proper calls at
transaction commit to include the changes in the log file.

[The alternative storage structure is an ASCII dump, using a slightly
enhanced Monet dump file format.
 +batname[hv,tv]	insert the bun
 -batname[hv,tv]	delete the bun
 *batname[headtype,tailtype]	define a bat
 =bat timestamp		check/update the bat timestamp

possibly use the tag and batname as a mode switcher to reduce the
the storage, i.e.
=mybat[int,int]
+[1,1]
[2,2]
[3,3]
-[2,2]
=yourbat[int,str]
*yourbat 16824
-[3,3]

]

The key decision to be made by the user is the location of the log file.
Ideally, it should be stored in fail-safe environment, or at least
the log and databases should be on separate disk columns.

The current setup assumes that the log directory is a mounted file system. (?)
This file system may reside on the hardware as the database server
and therefor the writes are done to the same disk, but could also 
reside on an other system and then the changes are flushed through the network.  
The logger works under the assumption that it is called to safeguard
updates on the database when it has an exclusive lock on
the latest version. This lock should be guaranteed by calling
the transaction manager first.

Finding the updates applied to a BAT is relatively easy, because each
BAT contains a delta structure. On commit these changes are
written to the log file and the delta management is reset. Since each 
commit is written to the same log file, the beginning and end are 
marked by a log identifier.

Shouldn't you dump the BAT version/timestamp? Updates are only
allowed when the BAT timestamp does not prohibit this.

A server restart should only (re)process blocks which are completely 
written to disk. 
Actually, the logger should issue commit statements after each block.

@* Implementation Code 
@h
#ifndef _SQL_LOGGER_H_
#define _SQL_LOGGER_H_

#include "bat_bm.h"

extern struct logger *logger_create(int debug, char *logdir, char *dbname, int version, struct bm *bm);

extern void logger_destroy(struct logger *logger);
extern int logger_exit(struct logger *logger);
extern int logger_restart(struct logger *logger);
extern int logger_cleanup(struct logger *logger);

extern int log_bat(struct logger *logger, oid lbid, BAT *b);
extern int log_bat_clear(struct logger *logger, oid lbid);
extern int log_bat_persists(struct logger *logger, BAT *b, oid lbid, char *n);
extern int log_bat_transient(struct logger *logger, oid lbid);
extern int log_changes(struct logger *logger);

extern int log_tstart(struct logger *logger);
extern int log_tend(struct logger *logger);

#endif /*_SQL_LOGGER_H_*/
@c
#include "sql_mem.h"
#include "bat_logger.h"
#include "stream.h"

@-
The log record encoding is geared at reduced storage space, but
at the expense of readability. A user can not easily inspect the
log a posteriori to check what has happened.

Since the logger uses global variables, you could opt to provide the
exclusive access as part of the logger implementation. 
This means that a client should use the following scheme

... update bat B ...
logger.start()
logger.safe(B)
... other BAT updates to be saved.
logger.commit()
gdk.commit()	# implied by the logger.commit?

[Niels, why not keeping a log per bat, e.g. mybat.log.230102.1 ?
this simplifies parallel 
recovery after a crash. Furthermore, the log time stamp can be
compared with the BAT to see if you need to consult the log file.]
[Martin, this is not done as keeping multiple files open (or opening
multiple files) has a too great performance impact.]
@c
#define SQL_LOG_START		1
#define SQL_LOG_END		2
#define SQL_LOG_INSERT		3
#define SQL_LOG_DELETE		4
#define SQL_LOG_CREATE		5
#define SQL_LOG_DESTROY		6
#define SQL_LOG_CLEAR		7

typedef struct logformat_t {
	char flag;
	int nr;
} logformat;

#define LOGFILE "log"

typedef struct logger {
	int debug;
	int changes;
	int version;
	int id;
	int tid;
	char *dir;
	stream *log;
	struct bm *bm;
} logger;

static int
log_read_format(logger *l, logformat *data)
{
	int res = 1;

	if (stream_read(l->log, &data->flag, 1, 1) != 1)
		return 0;
	res = stream_readInt(l->log, &data->nr);
	return res;
}

static int
log_write_format(logger *l, logformat *data)
{
	if (stream_write(l->log, &data->flag, 1, 1) != 1 || !stream_writeInt(l->log, data->nr))
		return SQL_ERR;
	return SQL_OK;
}

static char *
log_read_string(logger *l)
{
	int len, nr;
	char *buf;

	stream_readInt(l->log, &len);
	buf = NEW_ARRAY(char, len);

	if ((nr = stream_read(l->log, buf, 1, len)) != (ssize_t)len) {
		buf[len-1] = 0;
		printf("ERROR: couldn't read name (%s) %d\n", buf, nr);
		GDKfree(buf);
		return NULL;
	}
	return buf;
}

static int
log_write_string(logger *l, char *n)
{
	int len = strlen(n) + 1;	/* log including EOS */

	if (!stream_writeInt(l->log, len) || stream_write(l->log, n, 1, len) != (ssize_t) len)
		return SQL_ERR;
	return SQL_OK;
}

static void
log_read_clear(logger *logger, char *name)
{
	oid lbid = bm_find_bat(logger->bm, name);
	BAT *b = bm_lbid2bat(logger->bm, lbid);

	if (logger->debug & 1)
		fprintf(stderr, "logger found log_read_clear %s\n", name);

	if (b) {
		BATclear(b);
		bat_destroy(b);
	}
}

static void
log_read_updates(logger *logger, logformat *l, char *name)
{
	oid lbid = bm_find_bat(logger->bm, name);
	BAT *b = bm_lbid2bat(logger->bm, lbid);

	if (logger->debug & 1)
		fprintf(stderr, "logger found log_read_updates %s %s %d\n", name, (l->flag == SQL_LOG_INSERT) ? "insert" : "delete", l->nr);

	if (b) {
		int cnt = BATcount(b);
		void *(*rh) (ptr, stream *, size_t) = BATatoms[b->htype].atomRead;
		void *(*rt) (ptr, stream *, size_t) = BATatoms[b->ttype].atomRead;
		void *hv = ATOMnil(b->htype);
		void *tv = ATOMnil(b->ttype);

		if (b->hseqbase != oid_nil)
			cnt += b->hseqbase;
		if (b->tseqbase != oid_nil)
			cnt += b->tseqbase;

		for (; l->nr > 0; l->nr--) {
			void *h = rh(hv, logger->log, 1);
			void *t = rt(tv, logger->log, 1);

			if (l->flag == SQL_LOG_INSERT)
				BUNins(b, h, t);
			else if (l->flag == SQL_LOG_DELETE)
				BUNdel(b, h, t);
			cnt++;
			if (h != hv)
				_DELETE(h);
			if (t != tv)
				_DELETE(t);
		}
		_DELETE(hv);
		_DELETE(tv);
		bm_new_version(logger->bm, lbid, logger->tid);

		bat_destroy(b);
	}
}

static void
log_read_destroy(logger *logger, logformat *l, char *name)
{
	oid lbid = bm_find_bat(logger->bm, name);

	(void) l;		/* Stefan: unused!? */

	if (lbid)
		bm_del_bat(logger->bm, lbid);
}

static void
log_read_create(logger *logger, logformat *l, char *name)
{
	char *buf = log_read_string(logger);

	(void) l;		/* Stefan: unused!? */

	if (logger->debug & 1)
		fprintf(stderr, "log_read_create %s\n", name);

	if (!buf) {
		GDKerror("logger could not read create (%s)\n", name);
	} else {
		int ht, tt, hseq = 0, tseq = 0;
		char *ha = buf, *ta = strchr(buf, ',');
		BAT *b;

		if (!ta) {
			GDKerror("logger types are not ',' seperated (%s)\n", buf);
			return;
		}
		*ta = 0;
		ta++;		/* skip over , */
		if (strcmp(ha, "vid") == 0) {
			ht = TYPE_void;
			hseq = 1;
		} else {
			ht = ATOMindex(ha);
		}
		if (strcmp(ta, "vid") == 0) {
			tt = TYPE_void;
			tseq = 1;
		} else {
			tt = ATOMindex(ta);
		}
		b = BATnew(ht, tt, BUFSIZ);

		if (hseq)
			BATseqbase(b, 0);
		if (tseq)
			BATseqbase(b=BATmirror(b), 0);

		if (!b) {
			GDKerror("logger could not create bat (%s,%s,%s,%d,%d)\n", name, ha, ta, ht, tt);
			return;
		}
		bm_add_bat(logger->bm, b->batCacheid, name, logger->tid);
		bat_destroy(b);
	}
	if (buf)
		_DELETE(buf);
}

static void
logger_commit(logger *logger)
{
	if (logger->debug & 1)
		printf("logger_commit\n");

	bm_commit(logger->bm, logger->tid);
}

static void
logger_abort(logger *logger)
{
	if (logger->debug & 1)
		printf("logger_abort\n");

	bm_abort(logger->bm, logger->tid);
}

static int
logger_open(logger *logger)
{
	char filename[BUFSIZ];

	snprintf(filename, BUFSIZ, "%s%s.%d", logger->dir, LOGFILE, logger->id);
	logger->log = open_wstream(filename);
	if (stream_errnr(logger->log))
		 return SQL_ERR;

	return SQL_OK;
}

static void
logger_close(logger *logger)
{
	stream *log = logger->log;

	if (log) {
		stream_close(log);
		stream_destroy(log);
	}
	logger->log = NULL;
}

static int
logger_readlog(logger *logger, char *filename)
{
	logformat l;

	logger->log = open_rstream(filename);


	/* if the file doesn't exist, there is nothing to be readback */
	if (!logger->log || stream_errnr(logger->log)) {
		if (logger->log)
			stream_destroy(logger->log);

		return 0;
	}
	while (log_read_format(logger, &l)) {
		char *name = NULL;

		if (l.flag != SQL_LOG_START && l.flag != SQL_LOG_END) {
			name = log_read_string(logger);

			if (!name) {
				GDKerror("logger could not read name (%d)\n", l.flag);
				return -1;
			}
		}
		switch (l.flag) {
		case SQL_LOG_START:
			if (logger->tid != 0)
				logger_abort(logger);
			logger->tid = l.nr;

			break;
		case SQL_LOG_END:
			if (logger->tid == l.nr) {
				logger_commit(logger);
			} else {
				logger_abort(logger);
			}
			logger->tid = 0;

			break;
		case SQL_LOG_INSERT:
			log_read_updates(logger, &l, name);

			break;
		case SQL_LOG_DELETE:
			log_read_updates(logger, &l, name);

			break;
		case SQL_LOG_CREATE:
			log_read_create(logger, &l, name);

			break;
		case SQL_LOG_DESTROY:
			log_read_destroy(logger, &l, name);

			break;
		case SQL_LOG_CLEAR:
			log_read_clear(logger, name);

			break;
		default:
			GDKerror("logger error %d %s\n", l.flag, name);
			return -2;
		}
		if (name)
			_DELETE(name);
		logger->changes++;
	}
	logger_close(logger);

	if (logger->tid != 0)
		logger_abort(logger);

	return 0;
}

@-
The log files are incrementally numbered. They are processed in the
same sequence.
@c
static int
logger_readlogs(logger *logger, FILE *fp, char *filename)
{
	int res = 0;
	char id[BUFSIZ];

	if (logger->debug & 1)
		fprintf(stderr, "logger_readlogs %s\n", filename);

	while (fgets(id, BUFSIZ, fp) != NULL) {
		char buf[BUFSIZ];

		logger->id = strtol(id, NULL, 10);
		snprintf(buf, BUFSIZ, "%s.%d", filename, logger->id);

		if ((res = logger_readlog(logger, buf)) != 0) {
			break;
		}
	}
	return res;
}

static int
logger_save(logger *logger, FILE *fp)
{
	if (logger->debug & 1)
		fprintf(stderr, "logger_save\n");

	return bm_save(logger->bm, fp);
}

static int
logger_load(logger *logger, FILE *fp)
{
	if (logger->debug & 1)
		fprintf(stderr, "logger_load\n");

	return bm_load(logger->bm, fp);
}

static int
check_version(logger *logger, FILE *fp)
{
	int version = 0;

	if (fscanf(fp, "%6d", &version) != 1 || version != logger->version) {
		GDKerror("Incompatible database version %06d, "
			 "this server supports version %06d\n",
			 version, logger->version);

		return -1;
	}
	fgetc(fp);		/* skip \n */
	return 0;
}

static logger *
logger_new(int debug, char *logdir, char *dbname, int version, struct bm *bm)
{
	logger *logger = NEW(struct logger);
	FILE *fp;
	char filename[BUFSIZ];
	char bak[BUFSIZ];

	logger->debug = debug;
	logger->changes = 0;
	logger->version = version;
	logger->id = 1;
	logger->tid = 0;

	snprintf(filename, BUFSIZ, "%s%c%s%c", logdir, DIR_SEP, dbname, DIR_SEP);
	logger->dir = _strdup(filename);
	logger->log = NULL;
	logger->bm = bm;

	snprintf(filename, BUFSIZ, "%s%s", logger->dir, LOGFILE);

	snprintf(bak, BUFSIZ, "%s.bak", filename);

	if ((fp = fopen(filename, "r")) != NULL) {
		if (check_version(logger, fp))
			 return NULL;

		logger->changes++;
		if (logger_load(logger, fp) < 0)
			return NULL;
		logger_readlogs(logger, fp, filename);
	} else if ((fp = fopen(bak, "r")) != NULL) {
		fclose(fp);
		GDKmove(logger->dir, LOGFILE, "bak", logger->dir, LOGFILE, NULL);

		if ((fp = fopen(filename, "r")) != NULL) {
			if (check_version(logger, fp))
				 return NULL;

			logger->changes++;
			if (logger_load(logger, fp) < 0)
				return NULL;
			logger_readlogs(logger, fp, filename);
		}
	} else if ((fp = fopen(filename, "w")) == NULL) {
		if (!GDKcreatedir(filename)) {
			GDKerror("logger could not create log directory %s\n", logger->dir);

			return NULL;
		} else if ((fp = fopen(filename, "w")) == NULL) {
			GDKerror("logger could not create file %s\n", filename);
			return NULL;
		}
		fprintf(fp, "%06d\n\n", logger->version);
		logger->id ++;
		fprintf(fp, "%d\n", logger->id);
	} else {
		fprintf(fp, "%06d\n\n", logger->version);
		logger->id ++;
		fprintf(fp, "%d\n", logger->id);
	}
	fclose(fp);
	logger->tid = bm_version(logger->bm);
	return logger;
}

logger *
logger_create(int debug, char *logdir, char *dbname, int version, struct bm *bm)
{
	logger *logger = logger_new(debug, logdir, dbname, version, bm);
	if (!logger)
		return NULL;
	if (logger_open(logger) == SQL_ERR) {
		logger_destroy(logger);

		return NULL;
	}
	if (logger->changes && 
	    (logger_restart(logger) != SQL_OK ||
	    logger_cleanup(logger) != SQL_OK)) {
		logger_destroy(logger);

		return NULL;
	}
	return logger;
}

void
logger_destroy(logger *logger)
{
	if (logger->bm)
		logger_cleanup(logger);
	_DELETE(logger->dir);
	logger_close(logger);
	_DELETE(logger);
}

int
logger_exit(logger *logger)
{
	FILE *fp;
	char filename[BUFSIZ];

	logger_close(logger);
	if (GDKmove(logger->dir, LOGFILE, NULL, logger->dir, LOGFILE, "bak") < 0) {
		return SQL_ERR;
	}

	snprintf(filename, BUFSIZ, "%s%s", logger->dir, LOGFILE);
	if ((fp = fopen(filename, "w")) != NULL) {
		char ext[BUFSIZ];

		fprintf(fp, "%06d\n", logger->version);
		if (logger_save(logger, fp) < 0)
			return SQL_ERR;

		fprintf(fp, "\n");
		logger->id ++;
		fprintf(fp, "%d\n", logger->id);

		fclose(fp);
		if (TMcommit() != 0)	/* save new bats */
			return SQL_ERR;

		/* atomic action, switch to new log, keep old for later 
		   cleanup actions 
		 */
		snprintf(ext, BUFSIZ, "bak-%d", logger->id);
		if (GDKmove(logger->dir, LOGFILE, "bak", logger->dir, LOGFILE, ext) < 0)
			 return SQL_ERR;
	} else {
		GDKerror("logger could not open %s\n", filename);
		return SQL_ERR;
	}
	return SQL_OK;
}

int
logger_restart(logger *logger)
{
	int res = 0;

	if ((res = logger_exit(logger)) == SQL_OK)
		res = logger_open(logger);

	return res;
}

int
logger_cleanup(logger *logger)
{
	char buf[BUFSIZ];
	char id[BUFSIZ];
	FILE *fp = NULL;

	bm_cleanup(logger->bm);

	if (TMcommit() != 0)	/* cleanup old bats */
		return SQL_ERR;

	snprintf(buf, BUFSIZ, "%s%s.bak-%d", logger->dir, LOGFILE, logger->id);
	if (logger->debug & 1)
		fprintf(stderr, "logger_cleanup %s\n", buf);

	if ((fp = fopen(buf, "r")) == NULL)
		return SQL_ERR;

	/* skip catalog */
	while (fgets(id, BUFSIZ, fp) != NULL && id[0] != '\n')
		;

	while (fgets(id, BUFSIZ, fp) != NULL) {
		char *e = strchr(id, '\n');

		if (e)
			*e = 0;
		GDKunlink(logger->dir, LOGFILE, id);
	}
	fclose(fp);
	snprintf(buf, BUFSIZ, "bak-%d", logger->id);
	GDKunlink(logger->dir, LOGFILE, buf);

	return SQL_OK;
}

int
log_changes(logger *logger)
{
	return logger->changes;
}

@-
Changes made to the BAT descriptor should be stored in the log files.
Actually, we need to save the descriptor file, perhaps we should simply
introduce a versioning scheme. 
@c
int
log_bat_persists(logger *logger, BAT *b, oid lbid, char *name)
{
	char *ha, *ta;
	int len;
	char buf[BUFSIZ];
	logformat l;
	int havevoid = 0;

	l.flag = SQL_LOG_CREATE;
	l.nr = 0;
	logger->changes++;
	if (log_write_format(logger, &l) == SQL_ERR || log_write_string(logger, name) == SQL_ERR)
		return SQL_ERR;

	ha = ATOMname(b->htype);
	if (b->htype == TYPE_void && BAThdense(b)) {
		ha = "vid";
		havevoid = 1;
	}
	ta = ATOMname(b->ttype);
	if (!havevoid && b->ttype == TYPE_void && BATtdense(b)) {
		ta = "vid";
	}
	len = snprintf(buf, BUFSIZ, "%s,%s", ha, ta);
	len++;			/* include EOS */
	if (!stream_writeInt(logger->log, len) || stream_write(logger->log, buf, 1, len) != (ssize_t) len)
		 return SQL_ERR;

	if (logger->debug & 1)
		fprintf(stderr, "Logged new bat %s htype %s ttype %s\n", name, ha, ta);
	return log_bat(logger, lbid, b);
}

int
log_bat_transient(logger *logger, oid lbid)
{
	logformat l;
	char *name = bm_lbid2name(logger->bm, lbid);

	l.flag = SQL_LOG_DESTROY;
	l.nr = 0;
	logger->changes++;
	if (log_write_format(logger, &l) == SQL_ERR || log_write_string(logger, name) == SQL_ERR)
		return SQL_ERR;

	if (logger->debug & 1)
		fprintf(stderr, "Logged destroyed bat %s\n", name);
	return SQL_OK;
}

int
log_bat(logger *logger, oid lbid, BAT *b)
{
	int ok = GDK_SUCCEED;
	char *name = bm_lbid2name(logger->bm, lbid);
	logformat l;
	BUN p;

	if (logger->debug & 128) {
		/* logging is switched off */
		bm_new_version(logger->bm, lbid, logger->tid);

		return SQL_OK;
	}

	l.nr = BUNindex(b, BUNlast(b)) - BUNindex(b, b->batInserted);
	logger->changes += l.nr;

	if (l.nr) {
		int (*wh) (ptr, stream *, size_t) = BATatoms[b->htype].atomWrite;
		int (*wt) (ptr, stream *, size_t) = BATatoms[b->ttype].atomWrite;

		l.flag = SQL_LOG_INSERT;
		if (log_write_format(logger, &l) == SQL_ERR || log_write_string(logger, name) == SQL_ERR)
			return SQL_ERR;

		if (b->htype == TYPE_void && b->ttype < TYPE_str && !VIEWparent(b)) {
			ptr t = BUNtail(b, b->batInserted);
			ok = wt(t, logger->log, l.nr);
		} else {
			for (p = b->batInserted; p < BUNlast(b) && ok == GDK_SUCCEED; p = BUNnext(b, p)) {
				ptr h = BUNhead(b, p);
				ptr t = BUNtail(b, p);
				ok = wh(h, logger->log, 1);
				ok = (ok == GDK_FAIL) ? ok : wt(t, logger->log, 1);
			}
		}

		if (logger->debug)
			fprintf(stderr, "Logged %s %d inserts\n", name, l.nr);
	}
	l.nr = BUNindex(b, b->batFirst) - BUNindex(b, b->batDeleted);
	logger->changes += l.nr;

	if (l.nr && ok == GDK_SUCCEED) {
		int (*wh) (ptr, stream *, size_t) = BATatoms[b->htype].atomWrite;
		int (*wt) (ptr, stream *, size_t) = BATatoms[b->ttype].atomWrite;

		l.flag = SQL_LOG_DELETE;
		if (log_write_format(logger, &l) == SQL_ERR || log_write_string(logger, name) == SQL_ERR)
			return SQL_ERR;

		for (p = b->batDeleted; p < b->batFirst && ok == GDK_SUCCEED; p = BUNnext(b, p)) {
			ptr h = BUNhead(b, p);
			ptr t = BUNtail(b, p);
			ok = wh(h, logger->log, 1);
			ok = (ok == GDK_FAIL) ? ok : wt(t, logger->log, 1);
		}

		if (logger->debug)
			fprintf(stderr, "Logged %s %d deletes\n", name, l.nr);
	}
	bm_new_version(logger->bm, lbid, logger->tid);

	return (ok == GDK_SUCCEED) ? SQL_OK : SQL_ERR;
}

int
log_bat_clear(logger *logger, oid lbid)
{
	int ok = GDK_SUCCEED;
	char *name = bm_lbid2name(logger->bm, lbid);
	logformat l;

	if (logger->debug & 128) {
		/* logging is switched off */
		bm_new_version(logger->bm, lbid, logger->tid);

		return SQL_OK;
	}

	l.nr = 1;
	logger->changes += l.nr;

	l.flag = SQL_LOG_CLEAR;
	if (log_write_format(logger, &l) == SQL_ERR || log_write_string(logger, name) == SQL_ERR)
		return SQL_ERR;

	bm_new_version(logger->bm, lbid, logger->tid);
	return (ok == GDK_SUCCEED) ? SQL_OK : SQL_ERR;
}

int
log_tstart(logger *logger)
{
	logformat l;

	l.flag = SQL_LOG_START;
	l.nr = ++logger->tid;

	if (logger->debug)
		fprintf(stderr, "log_tstart %d\n", logger->tid);

	return log_write_format(logger, &l);
}

int
log_tend(logger *logger)
{
	logformat l;

	logger_commit(logger);

	if (logger->debug)
		fprintf(stderr, "log_tend %d\n", logger->tid);

	l.flag = SQL_LOG_END;
	l.nr = logger->tid;
	if (log_write_format(logger, &l) == SQL_ERR || stream_flush(logger->log))
		 return SQL_ERR;

	return SQL_OK;
}
