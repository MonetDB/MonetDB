@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2007 CWI.
@' All Rights Reserved.

@f bat_table
@+ The bat table store
The bat table stores tables using, Monet's binary association tables (BATs).
In the global view of the database, a table with columns Cj with 1<j<n,
is stored on disk using the following set of BATs. Each column has one
base bat (Bj), containing the current column values. As we like to use
void bats we cannot use the bat delete functionality, so we keep an extra
bat with the deleted oids (D).

To support the full ACID properties we need to keep a little more. First
when we get inserts, we need to add bats (BIj) with these inserts (we cannot
change the read only base columns). For deletes we also need an extra
delete bat (DI) in which we can insert the newly deleted oids.

Last to support updates we need one more set of bats (Uj) which stores
oid, values pairs.

Merging of base, insert, deletes and updates is done during the query
execution. There we try to reduce the overhead of these extra bats by
pushing the union, minus and update operations through the relational
operators.  

@c

#include "sql_config.h"
#include "sql_storage.h"
#include "bat_bm.h"
#include "bat_store.h"

static BAT *
full_column(sql_column *c, BAT *d, BAT *s )
{
	/* return full normalized column bat

		if (s) {
			b := b.semijoin(s);
			i := i.semijoin(s);
			u := u.semijoin(s);
		}
		b := b.kunion(i);
		b := b.kdiff(u);
		b := b.kunion(u);
		b := b.kdiff(reverse(d));
	*/
	BAT *r, *b, *u, *i = temp_descriptor(c->bat.ibid);
	r = i; 
	if (isTemp(c)) {
		if (s) {
			r = BATsemijoin(i,s);
			bat_destroy(i);
		}
		return r;
	}
	b = temp_descriptor(c->bat.bid);
	u = temp_descriptor(c->bat.ubid);
	if (s) {
		BAT *t;

		t = BATsemijoin(b,s); bat_destroy(b); b = t;
		t = BATsemijoin(i,s); bat_destroy(i); i = t;
		t = BATsemijoin(u,s); bat_destroy(u); u = t;
	}
	assert(b->ttype == i->ttype);
	r = BATkunion(b,i); bat_destroy(b); bat_destroy(i); b = r;
	r = BATkdiff(b,u); bat_destroy(b); b = r;
	assert(b->ttype == u->ttype);
	r = BATkunion(b,u); bat_destroy(b); bat_destroy(u); b = r;
	if (d) {
		r = BATkdiff(b,BATmirror(d)); bat_destroy(b); b = r;
	}
	assert(r->thash == NULL);
	return r;
}


list*
table_select_column_multi_values( sql_trans *tr, sql_column *val, sql_column *key1, void *key_value1, sql_column *key,list *values)
{
        BAT *b = NULL, *s = NULL, *valB = NULL, *d = NULL, *tmp = NULL;
	ptr lid;
	BUN p,q;
	int i, sz, ccnt;
	void * value = NULL, *aux = NULL;
	node *value_node;
	list* res = list_create((fdestroy) NULL);

	if (val->t->dbid)
		d = bind_dbat(tr, val->t, RDONLY);
	if(key1){
		b = full_column(key1, d, s);
		if(s)
			bat_destroy(s);
		s = BATselect(b, key_value1, key_value1);
		bat_destroy(b);
	}
	b = full_column(key, d, s);
	if (s)
		bat_destroy(s);
	tmp = bat_new(TYPE_void, b->ttype, key->t->sz, "tmp_table_select_column");
	value_node = values->h;
	for(i = 0; i < list_length(values); i++){
		value = value_node->data;
		BUNappend(tmp,value,FALSE);
	}
	s = BATjoin(b,BATmirror(tmp),BATcount(b)*BATcount(tmp));
	
	valB = full_column(val, d, s);
	if (s)
		bat_destroy(s);
	if (d)
		bat_destroy(d);
	ccnt = BATcount(valB);
	if (ccnt) {
		BATloop(valB,p,q){
			lid = BUNhead(valB,p);
			aux = bun_find(valB,lid);
			sz = ATOMlen(valB->ttype,aux);
 	               value = GDKmalloc(sz);
			memcpy(value,aux,sz);
			res = list_append(res,value);
		}
	}
	bat_destroy(b);
	bat_destroy(tmp);
        bat_destroy(valB);
        return res;
}

list*
table_select_column( sql_trans *tr, sql_column *val, sql_column *key, void *key_value, ...)
{
        BAT *b = NULL, *s = NULL, *valB = NULL, *d = NULL;
	ptr lid;
	BUN p,q;
	list* res = list_create((fdestroy) NULL);
	va_list va;
	sql_column *nc;
	void *nv,*value = NULL, *aux = NULL;
	int sz, ccnt;

	if (val->t->dbid)
		d = bind_dbat(tr, val->t, RDONLY);
	if(key){
		b = full_column(key, d, s);
		if(s)
			bat_destroy(s);
		s = BATselect(b, key_value, key_value);
		bat_destroy(b);
	}
	va_start(va, key_value);
	while ((nc = va_arg(va, sql_column *)) != NULL) {
		nv = va_arg(va, void *);
		key_value = nv;
		key = nc;
		
		b = full_column(key, d, s);
		if (s)
			bat_destroy(s);
		s = BATselect(b, key_value, key_value);
		bat_destroy(b);
	}
	valB = full_column(val, d, s);
	if (s)
		bat_destroy(s);
	if (d)
		bat_destroy(d);
	ccnt = BATcount(valB);
	
	if (ccnt) {
		BATloop(valB,p,q){
			lid = BUNhead(valB,p);
			aux = bun_find(valB,lid);
			sz = ATOMlen(valB->ttype,aux);
	                value = GDKmalloc(sz);
			memcpy(value,aux,sz);
			res = list_append(res,value);
		}
	}
        bat_destroy(valB);
        return res;
}

ssize_t
column_find_row(sql_trans *tr, sql_column *c, void *value, ...)
{
	va_list va;
	BUN p;
	BAT *b = NULL, *s = NULL, *r = NULL, *d = NULL;
	ssize_t rid = -1;
	sql_column *nc;
	void *nv;

	if (c->t->dbid) 
		d = bind_dbat(tr, c->t, RDONLY);
	va_start(va, value);
	while ((nc = va_arg(va, sql_column *)) != NULL) {
		nv = va_arg(va, void *);

		b = full_column(c, d, s);
		if (s)
			bat_destroy(s);
		s = BATselect(b, value, value);
		bat_destroy(b);
		c = nc;
		value = nv;
	}
	b = full_column(c, d, s);
	if (s)
		bat_destroy(s);
	if (d)
		bat_destroy(d);

	r = BATmirror(b);
	p = BUNfnd(r, value);
	if (p)
		rid = *(oid *) BUNtail(r, p);
	bat_destroy(b);
	return rid;
}

void *
column_find_value(sql_trans *tr, sql_column *c, ssize_t rid)
{
	BUN p;
	BAT *b, *d = NULL;
	void *res = NULL;

	if (c->t->dbid) 
		d = bind_dbat(tr, c->t, RDONLY);
	b = full_column(c, d, NULL);
	if (d)
		bat_destroy(d);

	p = BUNfnd(b, (ptr) &rid);
	if (p) {
		void *r;
		int sz;

		res = BUNtail(b, p);
                sz = ATOMlen(b->ttype, res);
                r = GDKmalloc(sz);
		memcpy(r,res,sz);
		res = r;
	}
	bat_destroy(b);
	return res;
}

int
column_update_value(sql_trans *tr, sql_column *c, ssize_t rid, void *value)
{
	BAT *b;

	assert(rid != (ssize_t)oid_nil);
	assert(rid != -1);

	if (c->bat.ubid) {
		b = temp_descriptor(c->bat.ubid);
		if (BUNfnd(b, &rid)) {
			BUNreplace(b, (ptr) &rid, value, TRUE);
		} else {
			bat_set_access(b, BAT_WRITE);
			BUNins(b, (ptr) &rid, value, FALSE);
			bat_set_access(b, BAT_READ);
		}
		bat_destroy(b);
	} else {
		b = temp_descriptor(c->bat.ibid);
		void_inplace(b, rid, value, TRUE);
		bat_destroy(b);
	}
	c->base.wtime = c->t->base.wtime = c->t->s->base.wtime = tr->wtime = tr->stime;
	return 0;
}

int
table_insert(sql_trans *tr, sql_table *t, ...)
{
	va_list va;
	node *n = cs_first_node(&t->columns);
	sql_column *c = n->data;
	BAT *b = temp_descriptor(c->bat.ibid);
	void *val = NULL;
	int cnt = 0;

	bat_destroy(b);
	va_start(va, t);

	c->base.wtime = tr->stime;
	for (val = va_arg(va, void *); n && val; n = n->next, val = va_arg(va, void *))
	{
		cnt++;
		c = n->data;
		b = temp_descriptor(c->bat.ibid);
		BUNappend(b, val, TRUE);
		bat_destroy(b);
		c->base.wtime = tr->stime;
	}
	t->cnt ++;
	if (n) {
		fprintf(stderr, "called table_insert(%s) with wrong number of args (%d,%d)\n", t->base.name, list_length(t->columns.set), cnt);
		assert(0);
		return -1;
	}
	t->base.wtime = t->s->base.wtime = tr->wtime = tr->stime;
	return 0;
}

int
table_delete(sql_trans *tr, sql_table *t, ssize_t rid)
{
	BAT *b = bind_dbat(tr, t, INS);

	assert(rid != (ssize_t)oid_nil);
	assert(rid != -1);

	BUNappend(b, (ptr) &rid, TRUE);
	bat_destroy(b);
	t->base.wtime = t->s->base.wtime = tr->wtime = tr->stime;
	return 0;
}


int
table_dump(sql_trans *tr, sql_table *t)
{
	node *n = cs_first_node(&t->columns);
	int i, l = cs_size(&t->columns);
	BAT **b = (BAT**)GDKmalloc(sizeof(BAT*) * l);
	
	(void)tr;
	for (i = 0; n; n = n->next, i++) {
		sql_column *c = n->data;

		b[i] = temp_descriptor(c->bat.bid);
	}
	BATmultiprintf(GDKstdout, l +1, b, TRUE, 0, 1);
	for (i = 0; i < l; i++)
		bat_destroy(b[i]);
	GDKfree(b);
	return 0;
}

int
table_check(sql_trans *tr, sql_table *t)
{
	node *n = cs_first_node(&t->columns);
	ssize_t cnt = -1;

	(void)tr;
	for (; n; n = n->next) {
		sql_column *c = n->data;
		BAT *b;

		b = temp_descriptor(c->bat.bid);
		if (cnt == -1) {
			cnt = BATcount(b);
		} else if (cnt != (ssize_t)BATcount(b)) {
			assert(0);
			return (int)(cnt - BATcount(b));
		}
		bat_destroy(b);
	}
	return 0;
}
