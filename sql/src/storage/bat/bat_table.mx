@f bat_table
@+ The bat table store
The bat table stores tables using, Monet's binary association tables (BATs).
In the global view of the database, a table with columns Cj with 1<j<n,
is stored on disk using the following set of BATs. Each column has one
base bat (Bj), containing the current column values. As we like to use
void bats we cannot use the bat delete functionality, so we keep an extra
bat with the deleted oids (D).

To support the full ACID properties we need to keep a little more. First
when we get inserts, we need to add bats (BIj) with these inserts (we cannot
change the read only base columns). For deletes we also need an extra
delete bat (DI) in which we can insert the newly deleted oids.

Last to support updates we need one more set of bats (Uj) which stores
oid, values pairs.

Merging of base, insert, deletes and updates is done during the query
execution. There we try to reduce the overhead of these extra bats by
pushing the union, minus and update operations through the relational
operators.  

@c

#include "sql_storage.h"
#include "bat_logger.h"
#include "bat_bm.h"
#include "bat_store.h"
#include <bat.h>

ssize_t column_find_row( sql_trans *tr, sql_column *c, void *value, ... )
{
	va_list va;
	BUN p;
	BAT *b = NULL, *r = NULL, *cur = NULL;
	ssize_t rid = -1;
	sql_column *nc;
	void *nv;

	va_start(va, value);
	while ( (nc = va_arg(va, sql_column*)) != NULL ) {
		nv = va_arg(va, void*);

		b = bind_bat(tr, c, RDONLY);
		if (cur) {
			BAT *nb = BATsemijoin(b, cur);
			bat_destroy(cur);
			bat_destroy(b);
			b = nb;
		} 
		cur = BATselect(b, value, value );
		c = nc;
		value = nv;
		bat_destroy(b);
	}

	b = bind_bat(tr, c, RDONLY);
	if (cur) {
		BAT *nb = BATsemijoin(b, cur);
		bat_destroy(cur);
		bat_destroy(b);
		b = nb;
	} 

	/* should check 
		1) updates
		2) inserted-deleted
		3) base-deleted
	 */
	r = BATmirror(b);
	p = BUNfnd(r, value );
	if (p) 
		rid = *(oid*)BUNtail(r, p);
	bat_destroy(b);
	return rid;
}

void* column_find_value( sql_trans *tr, sql_column *c, oid rid )
{
	BUN p;
	BAT *b;
	void *res = NULL;
	
	b = bind_bat(tr, c, RDONLY);
	/* should check 
		1) updates
		2) inserted-deleted
		3) base-deleted
	 */
	p = BUNfnd(b, (ptr) & rid );
	if (p) 
		res = BUNtail(b, p);
	bat_destroy(b);
	return res;
}

int column_update_value( sql_trans *tr, sql_column *c, oid rid, void *value )
{
	BAT *b = bind_bat(tr, c, UPD);
	oid oldcnt = b->hseqbase + (b->batInserted - BUNfirst(b));

	void_inplace(b, rid, value); 
	bat_destroy(b);

	/* needs fixing, only put value in the ubat if we update old values */
	if (rid < oldcnt) {
		b = bind_ubat(tr, c, UPD);
		BUNins(b, (ptr) & rid, value); 
		bat_destroy(b);
	}
	return 0;
}

int table_insert( sql_trans *tr, sql_table *t, ... )
{
	va_list va;
	node *n = cs_first_node(&t->columns);
	sql_column *c = n->data;
	BAT *b = bind_bat(tr, c, UPD);
	void *val = NULL;
	oid rid = BATcount(b);
	int cnt = 0;

	bat_destroy(b);
	va_start(va, t);

	for ( val = va_arg(va, void*); n && val; 
		n = n->next, val = va_arg(va, void*)) {

		cnt++;
		c = n->data;
		b = bind_bat(tr, c, UPD);
		BUNins(b, (ptr) & rid, val); 
		bat_destroy(b);
	}
	if (n) {
		fprintf(stderr, "called table_insert(%s) with wrong number of args (%d,%d)\n", t->base.name, list_length(t->columns.set), cnt);
		return -1;
	}
	return 0;
}

int table_delete( sql_trans *tr, sql_table *t, oid rid )
{
	node *n = cs_first_node(&t->columns);
	BAT *b = bind_dbat(tr, t, INS);

	BUNins(b, ATOMnilptr(TYPE_void), (ptr) & rid); 
	bat_destroy(b);

	/* if rid in base we cannot nil it */ 
	/* only if rid in inserts we nil it */ 
	for ( ; n; n = n->next ) {
		sql_column *c = n->data;

		b = bind_bat(tr, c, DEL);
		void_inplace(b, rid, ATOMnilptr(b->ttype)); 
		bat_destroy(b);
	}
	/* if rid in updates remove */ 
	return 0;
}

