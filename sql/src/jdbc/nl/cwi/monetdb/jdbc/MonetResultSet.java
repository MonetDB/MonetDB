/*
 * The contents of this file are subject to the MonetDB Public License
 * Version 1.1 (the "License"); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 * http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
 *
 * Software distributed under the License is distributed on an "AS IS"
 * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
 * License for the specific language governing rights and limitations
 * under the License.
 *
 * The Original Code is the MonetDB Database System.
 *
 * The Initial Developer of the Original Code is CWI.
 * Portions created by CWI are Copyright (C) 1997-2005 CWI.
 * All Rights Reserved.
 */

package nl.cwi.monetdb.jdbc;

import java.sql.*;
import java.io.*;
import java.util.*;
import java.math.*;
import java.net.*;

/**
 * A ResultSet suitable for the MonetDB database.
 * <br /><br />
 * A table of data representing a database result set, which is usually
 * generated by executing a statement that queries the database.
 * <br /><br />
 * A ResultSet object maintains a cursor pointing to its current row of data.
 * Initially the cursor is positioned before the first row. The next method
 * moves the cursor to the next row, and because it returns false when there
 * are no more rows in the ResultSet object, it can be used in a while loop to
 * iterate through the result set.
 * <br /><br />
 * The current state of this ResultSet is that it supports positioning in the
 * result set, absolute and relative. A slight performance difference between
 * FORWARD_ONLY or result sets scrollable in both directions can be noticed as
 * for FORWARD_ONLY result sets the memory usage will be likely lower for large
 * result sets.
 *
 * @author Fabian Groffen <Fabian.Groffen@cwi.nl>
 * @version 0.7
 */
public class MonetResultSet implements ResultSet {
	/** The last column read using some getXXX function */
	private int lastColumnRead = -1;
	// the following have default access modifier for the MonetVirtualResultSet
	/** The current line of the buffer split in columns */
	String[] result;
	/** The current position of the cursor for this ResultSet object */
	int curRow = 0;

	// a blank final is immutable once assigned in the constructor
	/** A Header to retrieve lines from */
	private final MonetConnection.Header header;
	/** The names of the columns in this ResultSet */
	private final String[] columns;
	/** The MonetDB types of the columns in this ResultSet */
	private final String[] types;
	/** The id of this ResultSet (needed for closing) */
	private final String tableID;
	/** The number of rows in this ResultSet */
	final int tupleCount;	// default for the MonetVirtualResultSet

	/** The parental Statement object */
	private final Statement statement;

	/** The type of this ResultSet (forward or scrollable) */
	private int type = TYPE_FORWARD_ONLY;
	/** The concurrency of this ResultSet (currently only read-only) */
	private int concurrency = CONCUR_READ_ONLY;
	/** The warnings for this ResultSet object */
	private SQLWarning warnings;

	/**
	 * Main constructor, sends query to MonetDB and reads header
	 *
	 * @param statement the statement which created this ResultSet
	 * @param header a header containing the query, resultset type, etc.
	 * @throws IllegalArgumentException if the given arguments are incorrect
	 * @throws SQLException is a protocol error occurs
	 */
	MonetResultSet(
		Statement statement,
		MonetConnection.Header header)
		throws IllegalArgumentException, SQLException
	{
		if (header == null)
			throw new IllegalArgumentException("Header is null!");

		this.statement = statement;
		this.header = header;
		this.type = header.getRSType();
		this.concurrency = header.getRSConcur();
		// well there is only one supported concurrency, so we don't have to
		// bother about that

		// throws SQLException on getters of Header, so we find out immediately
		// if an error occurred for this query
		columns = header.getNames();
		types = header.getTypes();
		tableID = "" + header.getID();
		tupleCount = header.getTupleCount();

		// create result array
		result = new String[columns.length];
	}

	/**
	 * Constructor used by MonetFillableResultSet.
	 * DO NOT USE THIS CONSTRUCTOR IF YOU ARE NOT EXTENDING THIS OBJECT!
	 *
	 * @param columns the column names
	 * @param types the column types
	 * @param results the number of rows in the ResultSet
	 * @throws IOException if communicating with monet failed
	 * @throws SQLException is a protocol error occurs
	 */
	MonetResultSet(
		String[] columns,
		String[] types,
		int results
	) throws IllegalArgumentException
	{
		if (columns == null || types == null) {
			throw new IllegalArgumentException("One of the given arguments is null!");
		}
		if (columns.length != types.length) {
			throw new IllegalArgumentException("Given arguments are not the same size!");
		}
		if (results < 0) {
			throw new IllegalArgumentException("Negative rowcount not allowed!");
		}

		this.header = null;
		this.tableID = null;
		this.statement = null; // no parent, required for specs

		this.columns = columns;
		this.types = types;
		this.tupleCount = results;
	}

	//== methods of interface ResultSet

	// Chapter 14.2.2 Sun JDBC 3.0 Specification
	/**
	 * Moves the cursor to the given row number in this ResultSet object.
	 * <br /><br />
	 * If the row number is positive, the cursor moves to the given row number
	 * with respect to the beginning of the result set. The first row is row 1,
	 * the second is row 2, and so on.
	 * <br /><br />
	 * If the given row number is negative, the cursor moves to an absolute row
	 * position with respect to the end of the result set. For example, calling
	 * the method absolute(-1) positions the cursor on the last row; calling the
	 * method absolute(-2) moves the cursor to the next-to-last row, and so on.
	 * <br /><br />
	 * An attempt to position the cursor beyond the first/last row in the result
	 * set leaves the cursor before the first row or after the last row.
	 * Note: calling absolute(1) is the same as calling first(). Calling
	 *       absolute(-1) is the same as calling last().
	 *
	 * @param row the number of the row to which the cursor should move. A
	 *        positive number indicates the row number counting from the
	 *        beginning of the result set; a negative number indicates the row
	 *        number counting from the end of the result set
	 * @return true if the cursor is on the result set; false otherwise
	 * @throws SQLException if a database access error occurs, or the result set
	 *         type is TYPE_FORWARD_ONLY
	 */
 	public boolean absolute(int row) throws SQLException {
		if (row != curRow + 1 && type == TYPE_FORWARD_ONLY) throw
			new SQLException("(Absolute) positioning not allowed on forward " +
				" only result sets!");

		if (header.isClosed()) throw new SQLException("ResultSet is closed!");

		// first calculate what the JDBC row is
		if (row < 0) {
			// calculate the negatives...
			row = tupleCount + row + 1;
		}
		// now place the row not farther than just before or after the result
		if (row < 0) row = 0;	// before first
		else if (row > tupleCount + 1) row = tupleCount + 1;	// after last

		String tmpLine = header.getLine(row - 1);

		// store it
		curRow = row;

		if (tmpLine == null) return(false);
		int len = tmpLine.length();
		char[] chrLine = new char[len];
		tmpLine.getChars(0, len, chrLine, 0);

		// extract separate fields by examining string, char for char
		boolean inString = false, escaped = false;
		int cursor = 2, column = 0, i = 2;
		StringBuffer uesc = new StringBuffer();
		for (; i < len; i++) {
			switch(chrLine[i]) {
				default:
					escaped = false;
				break;
				case '\\':
					escaped = !escaped;
				break;
				case '"':
					/**
					 * If all strings are wrapped between two quotes, a \" can
					 * never exist outside a string. Thus if we believe that we
					 * are not within a string, we can safely assume we're about
					 * to enter a string if we find a quote.
					 * If we are in a string we should stop being in a string if
					 * we find a quote which is not prefixed by a \, for that
					 * would be an escaped quote. However, a nasty situation can
					 * occur where the string is like "test \\" as obvious, a
					 * test for a \ in front of a " doesn't hold here for all
					 * cases. Because "test \\\"" can exist as well, we need to
					 * know if a quote is prefixed by an escaping slash or not.
					 */
					if (!inString) {
						inString = true;
					} else if (!escaped) {
						inString = false;
					}

					// reset escaped flag
					escaped = false;
				break;
				case '\t':
					if (!inString &&
						(i > 0 && chrLine[i - 1] == ',') ||
						(i + 1 == len - 1 && chrLine[++i] == ']')) // dirty
					{
						// split!
						if (chrLine[cursor] == '"' &&
							chrLine[i - 2] == '"')
						{
							// reuse the StringBuffer by cleaning it
							uesc.delete(0, uesc.length());
							// prevent capacity increasements
							uesc.ensureCapacity((i - 2) - (cursor + 1));
							for (int pos = cursor + 1; pos < i - 2; pos++) {
								if (chrLine[pos] == '\\' && pos + 1 < i - 2) {
									pos++;
									// strToStr and strFromStr in gdk_atoms.mx only
									// support \t \n \\ \" and \377
									switch (chrLine[pos]) {
										case '\\':
											uesc.append('\\');
										break;
										case 'n':
											uesc.append('\n');
										break;
										case 't':
											uesc.append('\t');
										break;
										case '"':
											uesc.append('"');
										break;
										case '0': case '1': case '2': case '3':
											// this could be an octal number, let's check it out
											if (pos + 2 < i - 2 &&
												chrLine[pos + 1] >= '0' && chrLine[pos + 1] <= '7' &&
												chrLine[pos + 2] >= '0' && chrLine[pos + 2] <= '7'
											) {
												// we got the number!
												try {
													uesc.append((char)(Integer.parseInt("" + chrLine[pos] + chrLine[pos + 1] + chrLine[pos + 2], 8)));
													pos += 2;
													break;
												} catch (NumberFormatException e) {
													// hmmm, this point should never be reached actually...
													throw new AssertionError("Flow error, should never try to parse non-number");
												}
											}
											// do default action if number seems not to be correct
										default:
											// this is wrong, just ignore the escape, and print the char
											uesc.append(chrLine[pos]);
										break;
									}
								} else {
									uesc.append(chrLine[pos]);
								}
							}

							// put the unescaped string in the right place
							result[column++] = uesc.toString();
						} else if ((i - 1) - cursor == 4 &&
								tmpLine.indexOf("NULL", cursor) == cursor)
						{
							result[column++] = null;
						} else {
							result[column++] =
								tmpLine.substring(cursor, i - 1);
						}
						cursor = i + 1;
					}

					// reset escaped flag
					escaped = false;
				break;
			}
		}
		// check if this result is of the size we expected it to be
		if (column != columns.length) throw new AssertionError("Illegal result length: " + column + "\nlast read: " + (column > 0 ? result[column - 1] : "<none>"));

		// reset lastColumnRead
		lastColumnRead = -1;

		return(true);
	}

	/**
	 * Moves the cursor to the end of this ResultSet object, just after the last
	 * row. This method has no effect if the result set contains no rows.
	 *
	 * @throws SQLException if a database access error occurs or the result set
	 *         type is TYPE_FORWARD_ONLY
	 */
	public void afterLast() throws SQLException {
		absolute(tupleCount + 1);
	}

	/**
	 * Moves the cursor to the front of this ResultSet object, just before the
	 * first row. This method has no effect if the result set contains no rows.
	 *
	 * @throws SQLException if a database access error occurs or the result set
	 *         type is TYPE_FORWARD_ONLY
	 */
	public void beforeFirst() throws SQLException {
		absolute(0);
	}

	/**
	 * Clears all warnings reported for this ResultSet object. After a call to
	 * this method, the method getWarnings returns null until a new warning is
	 * reported for this ResultSet object.
	 */
	public void clearWarnings() {
		warnings = null;
	}

	/**
	 * Releases this ResultSet object's database (and JDBC) resources
	 * immediately instead of waiting for this to happen when it is
	 * automatically closed.
	 */
	public void close() {
		if (!header.isClosed()) {
			header.close();
		}
	}

	// Chapter 14.2.3 from Sun JDBC 3.0 specification
	/**
	 * Maps the given ResultSet column name to its ResultSet column index.
	 * Column names supplied to getter methods are case insensitive. If a select
	 * list contains the same column more than once, the first instance of the
	 * column will be returned.
	 *
	 * @param columnName the name of the column
	 * @return the column index of the given column name
	 * @throws SQLException if the ResultSet object does not contain columnName
	 */
	public int findColumn(String columnName) throws SQLException {
		for (int i = 0; i < columns.length; i++) {
			if (columns[i].equalsIgnoreCase(columnName)) return(i + 1);
		}
		throw new SQLException("No such columnname: " + columnName);
	}

	/**
	 * Moves the cursor to the first row in this ResultSet object.
	 *
	 * @return true if the cursor is on a valid row; false if there are no rows
	 *         in the result set
	 * @throws SQLException - if a database access error occurs or the result
	 *         set type is TYPE_FORWARD_ONLY
	 */
	public boolean first() throws SQLException {
		return(absolute(1));
	}

	public Array getArray(int i) throws SQLException { throw new SQLException("Method not implemented yet, sorry!"); }
	public Array getArray(String colName) throws SQLException { throw new SQLException("Method not implemented yet, sorry!"); }

	/* Mapi doesn't allow something for streams at the moment, thus all
	   not implemented for now */
	public InputStream getAsciiStream(int columnIndex) throws SQLException { throw new SQLException("Method not implemented yet, sorry!"); }
	public InputStream getAsciiStream(String columnName) throws SQLException { throw new SQLException("Method not implemented yet, sorry!"); }
	public InputStream getBinaryStream(int columnIndex) throws SQLException { throw new SQLException("Method not implemented yet, sorry!"); }
	public InputStream getBinaryStream(String columnName) throws SQLException { throw new SQLException("Method not implemented yet, sorry!"); }
	public InputStream getUnicodeStream(int columnIndex) throws SQLException { throw new SQLException("Method not implemented yet, sorry!"); }
	public InputStream getUnicodeStream(String columnName) throws SQLException { throw new SQLException("Method not implemented yet, sorry!"); }
	public Blob getBlob(int i) throws SQLException { throw new SQLException("Method not implemented yet, sorry!"); }
	public Blob getBlob(String colName) throws SQLException { throw new SQLException("Method not implemented yet, sorry!"); }
	public Reader getCharacterStream(int columnIndex) throws SQLException { throw new SQLException("Method not implemented yet, sorry!"); }
	public Reader getCharacterStream(String columnName) throws SQLException { throw new SQLException("Method not implemented yet, sorry!"); }

	/**
	 * Retrieves the value of the designated column in the current row
	 * of this ResultSet object as a Clob object in the
	 * Java programming language.
	 *
	 * @param i the first column is 1, the second is 2, ...
	 * @return a Clob object representing the SQL CLOB value in the
	 *         specified column
	 * @throws SQLException if a database access error occurs
	 */
	public Clob getClob(int i) throws SQLException {
		String tmp = getString(i);
		if (tmp == null) {
			return(null);
		} else {
			return(new MonetClob(tmp));
		}
	}

	/**
	 * Retrieves the value of the designated column in the current row
	 * of this ResultSet object as a Clob object in the
	 * Java programming language.
	 *
	 * @param colName the name of the column from which to retrieve
	 *        the value
	 * @return a Clob object representing the SQL CLOB value in the
	 *         specified column
	 * @throws SQLException if a database access error occurs
	 */
	public Clob getClob(String colName) throws SQLException {
		return(getClob(findColumn(colName)));
	}

	/**
	 * Retrieves the value of the designated column in the current row of this
	 * ResultSet object as a java.math.BigDecimal with full precision.
	 *
	 * @param columnIndex the first column is 1, the second is 2, ...
	 * @return the column value (full precision); if the value is SQL NULL,
	 *         the value returned is null in the Java programming language.
	 * @throws SQLException if a database access error occurs
	 */
	public BigDecimal getBigDecimal(int columnIndex) throws SQLException {
		String decimal = getString(columnIndex);
		if (decimal == null) {
			return(null);
		} else {
			try {
				return(new BigDecimal(decimal));
			} catch (NumberFormatException e) {
				return(new BigDecimal("0"));
			}
		}
	}

	/**
	 * Retrieves the value of the designated column in the current row of this
	 * ResultSet object as a java.math.BigDecimal with full precision.
	 *
	 * @param columnIndex the first column is 1, the second is 2, ...
	 * @param scale the number of digits to the right of the decimal point
	 * @return the column value (full precision); if the value is SQL NULL,
	 *         the value returned is null in the Java programming language.
	 * @throws SQLException if a database access error occurs
	 */
	public BigDecimal getBigDecimal(int columnIndex, int scale)
		throws SQLException
	{
		String decimal = getString(columnIndex);
		if (decimal == null) {
			return(null);
		} else {
			BigDecimal bd;
			try {
				bd = new BigDecimal(decimal);
			} catch (NumberFormatException e) {
				bd = new BigDecimal("0");
			}
			bd.setScale(scale);
			return(bd);
		}
	}

	/**
	 * Retrieves the value of the designated column in the current row of this
	 * ResultSet object as a java.math.BigDecimal with full precision.
	 *
	 * @param columnName the SQL name of the column
	 * @return the column value (full precision); if the value is SQL NULL,
	 *         the value returned is null in the Java programming language.
	 * @throws SQLException if a database access error occurs
	 */
	public BigDecimal getBigDecimal(String columnName) throws SQLException {
		return(getBigDecimal(findColumn(columnName)));
	}

	/**
	 * Retrieves the value of the designated column in the current row of this
	 * ResultSet object as a java.math.BigDecimal with full precision.
	 *
	 * @param columnName the SQL name of the column
	 * @param scale the number of digits to the right of the decimal point
	 * @return the column value (full precision); if the value is SQL NULL,
	 *         the value returned is null in the Java programming language.
	 * @throws SQLException if a database access error occurs
	 */
	public BigDecimal getBigDecimal(String columnName, int scale)
		throws SQLException
	{
		return(getBigDecimal(findColumn(columnName), scale));
	}

	// See Sun JDBC Specification 3.0 Table B-6
	/**
	 * Retrieves the value of the designated column in the current row of this
	 * ResultSet object as a boolean in the Java programming language.
	 *
	 * @param columnIndex the first column is 1, the second is 2, ...
	 * @return the column value; if the value is SQL NULL, the value returned
	 *         is false
	 * @throws SQLException if there is no such column
	 */
	public boolean getBoolean(int columnIndex) throws SQLException{
		int dataType = MonetDriver.getJavaType(types[columnIndex - 1]);
		if (dataType == Types.TINYINT ||
			dataType == Types.SMALLINT ||
			dataType == Types.INTEGER ||
			dataType == Types.BIGINT)
		{
			if (getLong(columnIndex) == 0L) {
				return(false);
			} else {
				return(true);
			}
		} else if (dataType == Types.REAL ||
			dataType == Types.FLOAT ||
			dataType == Types.DOUBLE)
		{
			if (getDouble(columnIndex) == 0.0) {
				return(false);
			} else {
				return(true);
			}
		} else if (dataType == Types.DECIMAL ||
			dataType == Types.NUMERIC)
		{
			if (getBigDecimal(columnIndex).compareTo(new BigDecimal(0.0)) == 0) {
				return(false);
			} else {
				return(true);
			}
		} else if (dataType == Types.BIT ||
			dataType == Types.BOOLEAN ||
			dataType == Types.CHAR ||
			dataType == Types.VARCHAR ||
			dataType == Types.LONGVARCHAR)
		{
			return((Boolean.valueOf(getString(columnIndex))).booleanValue());
		} else {
			throw new SQLException("Conversion from " + types[columnIndex - 1] + " to boolean type not supported");
		}
	}

	/**
	 * Retrieves the value of the designated column in the current row of this
	 * ResultSet object as a boolean in the Java programming language.
	 *
	 * @param columnName the SQL name of the column
	 * @return the column value; if the value is SQL NULL, the value returned
	 *         is false
	 * @throws SQLException if the ResultSet object does not contain columnName
	 */
	public boolean getBoolean(String columnName) throws SQLException {
		return(getBoolean(findColumn(columnName)));
	}

	/**
	 * Retrieves the value of the designated column in the current row of this
	 * ResultSet object as a byte in the Java programming language.
	 *
	 * @param columnIndex the first column is 1, the second is 2, ...
	 * @return the column value; if the value is SQL NULL, the value returned
	 *         is 0
	 * @throws SQLException if a database access error occurs
	 */
	public byte getByte(int columnIndex) throws SQLException {
		String bytes = getString(columnIndex);
		if (bytes == null || bytes.length() == 0) {
			return((byte)0);
		} else {
			return(bytes.getBytes()[0]);
		}
	}

	/**
	 * Retrieves the value of the designated column in the current row of this
	 * ResultSet object as a byte in the Java programming language.
	 *
	 * @param columnName the SQL name of the column
	 * @return the column value; if the value is SQL NULL, the value returned
	 *         is 0
	 * @throws SQLException if a database access error occurs
	 */
	public byte getByte(String columnName) throws SQLException {
		return(getByte(findColumn(columnName)));
	}

	/**
	 * Retrieves the value of the designated column in the current row of this
	 * ResultSet object as a byte array in the Java programming language. The
	 * bytes represent the raw values returned by the driver.
	 * <br /><br />
	 * NOTE: Since the mapi protocol is ASCII-based, this method only returns
	 *       Java byte representations of Strings, which is nothing more than
	 *       an encoding into a sequence of bytes using the platform's default
	 *       charset.
	 *
	 * @param columnIndex the first column is 1, the second is 2, ...
	 * @return the column value; if the value is SQL NULL, the value returned
	 *         is null
	 * @throws SQLException if a database access error occurs
	 */
	public byte[] getBytes(int columnIndex) throws SQLException {
		String bytes = getString(columnIndex);
		if (bytes == null) {
			return(null);
		} else {
			return(bytes.getBytes());
		}
	}

	/**
	 * Retrieves the value of the designated column in the current row of this
	 * ResultSet object as a byte array in the Java programming language. The
	 * bytes represent the raw values returned by the driver.
	 * <br /><br />
	 * NOTE: Since the mapi protocol is ASCII-based, this method only returns
	 *       Java byte representations of Strings, which is nothing more than
	 *       an encoding into a sequence of bytes using the platform's default
	 *       charset.
	 *
	 * @param columnName the SQL name of the column
	 * @return the column value; if the value is SQL NULL, the value returned
	 *         is null
	 * @throws SQLException if a database access error occurs
	 */
	public byte[] getBytes(String columnName) throws SQLException {
		return(getBytes(findColumn(columnName)));
	}

	/**
	 * Retrieves the concurrency mode of this ResultSet object. The concurrency
	 * used is determined by the Statement object that created the result set.
	 * <br /><br />
	 * NOTE: MonetDB only supports read-only result sets, and will always return
	 *       ResultSet.CONCUR_READ_ONLY
	 *
	 * @return the concurrency type, either ResultSet.CONCUR_READ_ONLY or
	 *         ResultSet.CONCUR_UPDATABLE
	 */
	public int getConcurrency() {
		return(concurrency);
	}

	/**
	 * Retrieves the name of the SQL cursor used by this ResultSet object.
	 * In SQL, a result table is retrieved through a cursor that is named.
	 * For MonetDB this is the tableID returned in a resultset header. The
	 * current row of a result set can be updated or deleted using a positioned
	 * update/delete statement that references the cursor name. To insure that
	 * the cursor has the proper isolation level to support update, the
	 * cursor's SELECT statement should be of the form SELECT FOR UPDATE. If
	 * FOR UPDATE is omitted, the positioned updates may fail.
	 * <br /><br />
	 * The JDBC API supports this SQL feature by providing the name of the SQL
	 * cursor used by a ResultSet object. The current row of a ResultSet object
	 * is also the current row of this SQL cursor.
	 * <br /><br />
	 * Note: If positioned update is not supported, a SQLException is thrown.
	 *       MonetDB currently doesn't support updates, so the SQLException is
	 *       thrown for now.
	 *
	 * @return the SQL name for this ResultSet object's cursor
	 * @throws SQLException if a database access error occurs
	 */
	public String getCursorName() throws SQLException {
		throw new SQLException("Positioned updates not supported for this " +
							   "cursor (" + tableID + ")");
		//return("" + tableID);
	}

	/**
	 * Retrieves the value of the designated column in the current row of this
	 * ResultSet object as a double in the Java programming language.
	 *
	 * @param columnIndex the first column is 1, the second is 2, ...
	 * @return the column value; if the value is SQL NULL, the value returned
	 *         is 0
	 * @throws SQLException if there is no such column
	 */
	public double getDouble(int columnIndex) throws SQLException {
		double ret = 0;	// note: relaxing by compiler here
		String dbl = getString(columnIndex);
		if (dbl != null) {
			try {
				ret = Double.parseDouble(dbl);
			} catch (NumberFormatException e) {
				// ignore, return the default: 0
			}
			// do not catch SQLException for it is declared to be thrown
		}

		return(ret);
	}

	/**
	 * Retrieves the value of the designated column in the current row of this
	 * ResultSet object as a double in the Java programming language.
	 *
	 * @param columnName the SQL name of the column
	 * @return the column value; if the value is SQL NULL, the value returned
	 *         is 0
	 * @throws SQLException if the ResultSet object does not contain columnName
	 */
	public double getDouble(String columnName) throws SQLException {
		return(getDouble(findColumn(columnName)));
	}

	/**
	 * Retrieves the fetch direction for this ResultSet object.
	 * <b>currently not implemented</b>
	 *
	 * @return the current fetch direction for this ResultSet object
	 */
	public int getFetchDirection() {
		return(FETCH_FORWARD);
	}

	/**
	 * Retrieves the fetch size for this ResultSet object.
	 *
	 * @return the current fetch size for this ResultSet object
	 * @throws SQLException if a database access error occurs
	 */
	public int getFetchSize() throws SQLException {
		return(header.getCacheSize());
	}

	/**
	 * Retrieves the value of the designated column in the current row of this
	 * ResultSet object as a float in the Java programming language.
	 *
	 * @param columnIndex the first column is 1, the second is 2, ...
	 * @return the column value; if the value is SQL NULL, the value returned
	 *         is 0
	 * @throws SQLException if there is no such column
	 */
	public float getFloat(int columnIndex) throws SQLException {
		float ret = 0;	// note: relaxing by compiler here
		String flt = getString(columnIndex);
		if (flt != null) {
			try {
				ret = Float.parseFloat(flt);
			} catch (NumberFormatException e) {
				// ignore, return the default: 0
			}
			// do not catch SQLException for it is declared to be thrown
		}

		return(ret);
	}

	/**
	 * Retrieves the value of the designated column in the current row of this
	 * ResultSet object as a float in the Java programming language.
	 *
	 * @param columnName the SQL name of the column
	 * @return the column value; if the value is SQL NULL, the value returned
	 *         is 0
	 * @throws SQLException if the ResultSet object does not contain columnName
	 */
	public float getFloat(String columnName) throws SQLException {
		return(getFloat(findColumn(columnName)));
	}

	/**
	 * Retrieves the value of the designated column in the current row of this
	 * ResultSet object as an int in the Java programming language.
	 *
	 * @param columnIndex the first column is 1, the second is 2, ...
	 * @return the column value; if the value is SQL NULL, the value returned
	 *         is 0
	 * @throws SQLException if there is no such column
	 */
	public int getInt(int columnIndex) throws SQLException {
		int ret = 0;
		try {
			// note: Integer.parseInt DOES unlike Double and Float
			// accept a null value
			ret = Integer.parseInt(getString(columnIndex));
		} catch (NumberFormatException e) {
			// ignore, return the default: 0
		}
		// do not catch SQLException for it is declared to be thrown

		return(ret);
	}

	/**
	 * Retrieves the value of the designated column in the current row of this
	 * ResultSet object as an int in the Java programming language.
	 *
	 * @param columnName the SQL name of the column
	 * @return the column value; if the value is SQL NULL, the value returned
	 *         is 0
	 * @throws SQLException if the ResultSet object does not contain columnName
	 */
	public int getInt(String columnName) throws SQLException {
		return(getInt(findColumn(columnName)));
	}

	/**
	 * Retrieves the value of the designated column in the current row of this
	 * ResultSet object as a long in the Java programming language.
	 *
	 * @param columnIndex the first column is 1, the second is 2, ...
	 * @return the column value; if the value is SQL NULL, the value returned
	 *         is 0
	 * @throws SQLException if there is no such column
	 */
	public long getLong(int columnIndex) throws SQLException {
		long ret = 0;
		try {
			// note: Long.parseLong DOES unlike Double and Float
			// accept a null value
			ret = Long.parseLong(getString(columnIndex));
		} catch (NumberFormatException e) {
			// ignore, return the default: 0
		}
		// do not catch SQLException for it is declared to be thrown

		return(ret);
	}

	/**
	 * Retrieves the value of the designated column in the current row of this
	 * ResultSet object as a long in the Java programming language.
	 *
	 * @param columnName the SQL name of the column
	 * @return the column value; if the value is SQL NULL, the value returned
	 *         is 0
	 * @throws SQLException if the ResultSet object does not contain columnName
	 */
	public long getLong(String columnName) throws SQLException {
		return(getLong(findColumn(columnName)));
	}

	/**
	 * Retrieves the number, types and properties of this ResultSet object's
	 * columns.
	 *
	 * @return the description of this ResultSet object's columns
	 */
	public ResultSetMetaData getMetaData() {
		// return inner class which implements the ResultSetMetaData interface
		return(new ResultSetMetaData() {
			/**
			 * Returns the number of columns in this ResultSet object.
			 *
			 * @returns the number of columns
			 */
			public int getColumnCount() {
				return(columns.length);
			}

			/**
			 * Indicates whether the designated column is automatically
			 * numbered, thus read-only.
			 *
			 * @param column the first column is 1, the second is 2, ...
			 * @return true if so; false otherwise
			 * @throws SQLException if a database access error occurs
			 */
			public boolean isAutoIncrement(int column) throws SQLException {
				// the only column I know of is a 'secret' column called rowid
				// with datatype oid
				// avoid nullpointer exception here
				if ("oid".equals(getColumnTypeName(column))) {
					return(true);
				} else {
					return(false);
				}
			}

			/**
			 * Indicates whether a column's case matters. This holds for all
			 * columns in MonetDB resultsets since the mapping is done case
			 * insensitive. Therefore this method will always return false.
			 *
			 * @param column the first column is 1, the second is 2, ...
			 * @returns false
			 */
			public boolean isCaseSensitive(int column) {
				return(false);
			}

			/**
			 * Indicates whether the designated column can be used in a
			 * where clause.
			 * It is unknown to me what kind ot columns they regard to,
			 * as I think all columns are useable in a where clause.
			 * Returning true for all here, for the time being.
			 *
			 * @param column the first column is 1, the second is 2, ...
			 * @returns true
			 */
			public boolean isSearchable(int column) {
				return(true);
			}

			/**
			 * Indicates whether the designated column is a cash value.
			 * From the MonetDB database perspective it is by definition
			 * unknown whether the value is a currency, because there are
			 * no currency datatypes such as MONEY.  With this knowledge
			 * we can always return false here.
			 *
			 * @param column the first column is 1, the second is 2, ...
			 * @returns false
			 */
			public boolean isCurrency(int column) {
				return(false);
			}
			
			public int isNullable(int column) {return(columnNullableUnknown);}

			/**
			 * Indicates whether values in the designated column are signed
			 * numbers.
			 * Within MonetDB all numeric types are signed.
			 *
			 * @param column the first column is 1, the second is 2, ...
			 * @return true if so; false otherwise
			 */
			public boolean isSigned(int column) throws SQLException {
				// we can hardcode this, based on the colum type
				switch (getColumnType(column)) {
					case Types.NUMERIC:
					case Types.DECIMAL:
					case Types.TINYINT:
					case Types.SMALLINT:
					case Types.INTEGER:
					case Types.BIGINT:
					case Types.REAL:
					case Types.FLOAT:
					case Types.DOUBLE:
						return(true);
					case Types.BIT: // we don't use type BIT, it's here for completeness
					case Types.BOOLEAN:
					case Types.DATE:
					case Types.TIME:
					case Types.TIMESTAMP:
					default:
						return(false);
				}
			}

			/**
			 * Indicates the designated column's normal maximum width in
			 * characters.
			 *
			 * @param column the first column is 1, the second is 2, ...
			 * @return the normal maximum number of characters allowed as the
			 *         width of the designated column
			 * @throws SQLException if there is no such column
			 */
			public int getColumnDisplaySize(int column) throws SQLException {
				int ret;
				try {
					ret = header.getColumnLengths()[column - 1];
				} catch (IndexOutOfBoundsException e) {
					throw new SQLException("No such column " + column);
				}
				
				// if the display size is zero, try to guess a better size
				if (ret == 0) {
					switch (getColumnType(column)) {
						case Types.NUMERIC:
						case Types.DECIMAL:
							ret = 10;
						break;
						case Types.BIT: // we don't use type BIT, it's here for completeness
						case Types.BOOLEAN:
							ret = 5;	// "false".length();
						break;
						case Types.TINYINT:
						case Types.SMALLINT:
						case Types.INTEGER:
							ret = 8;
						break;
						case Types.BIGINT:
							ret = 12;
						break;
						case Types.REAL:
							ret = 10;
						break;
						case Types.FLOAT:
						case Types.DOUBLE:
							ret = 12;
						break;
						case Types.DATE:
							ret = 10;	// "year-mm-dd".length();
						break;
						case Types.TIME:
							ret = 12;	// "hh:mm:ss.SSS".length();
						break;
						case Types.TIMESTAMP:
							ret = 23;	// date + space + time
						break;
					}
				}
				
				return(ret);
			}

			/**
			 * Get the designated column's table's schema.  This method
			 * is currently very expensive as it needs to retrieve the
			 * information from the database using an SQL query.
			 *
			 * @param column the first column is 1, the second is 2, ...
			 * @return schema name or "" if not applicable
			 * @throws SQLException if a database access error occurs
			 */
			public String getSchemaName(int column) throws SQLException {
				if (getTableName(column) != "") {
					// we have to get a new Statement here in order not
					// to close the ResultSet that is being in use to
					// call this method
					Statement stmt = getStatement().getConnection().createStatement();
					// note, we cannot even see if we have the right
					// one, so this is extremely fuzzy...
					ResultSet rs = stmt.executeQuery(
							"select schemas.name from tables, schemas where schemas.id = tables.schema_id and tables.name like '" + getTableName(column) + "'");
					// if there are no results, this is the default
					String ret = "";
					for (int i = 0; rs.next(); i++) {
						if (i == 0) {
							ret = rs.getString(1);
						} else {
							// in case of multiple matches we pretent as
							// if the schema name is not applicable
							ret = "";
						}
					}
					rs.close();
					stmt.close();
					return(ret);
				} else {
					return("");
				}
			}

			public int getPrecision(int column) throws SQLException { throw new SQLException("Method not implemented yet, sorry!"); }
			public int getScale(int column) throws SQLException { throw new SQLException("Method not implemented yet, sorry!"); }

			/**
			 * Gets the designated column's table name.
			 *
			 * @param column the first column is 1, the second is 2, ...
			 * @return table name or "" if not applicable
			 */
			public String getTableName(int column) {
				return(header.getTableNames()[column - 1]);
			}

			/**
			 * Gets the designated column's table's catalog name.
			 * Because MonetDB handles only one catalog (dbfarm) at a
			 * time, the current one is the one we deal with here.
			 *
			 * @param column the first column is 1, the second is 2, ...
			 * @return the name of the catalog for the table in which the given
			 *         column appears or "" if not applicable
			 */
			public String getCatalogName(int column) throws SQLException {
				if (getTableName(column) != "") {
					return(getStatement().getConnection().getCatalog());
				} else {
					return("");
				}
			}

			/**
			 * Indicates whether the designated column is definitely not
			 * writable.  MonetDB does not support cursor updates, so
			 * nothing is writable.
			 *
			 * @param column the first column is 1, the second is 2, ...
			 * @return true if so; false otherwise
			 */
			public boolean isReadOnly(int column) {
				return(true);
			}

			/**
			 * Indicates whether it is possible for a write on the designated
			 * column to succeed.
			 *
			 * @param column the first column is 1, the second is 2, ...
			 * @return true if so; false otherwise
			 */
			public boolean isWritable(int column) {
				return(false);
			}

			/**
			 * Indicates whether a write on the designated column will
			 * definitely succeed.
			 *
			 * @param column the first column is 1, the second is 2, ...
			 * @return true if so; false otherwise
			 */
			public boolean isDefinitelyWritable(int column) {
				return(false);
			}

			/**
			 * Returns the fully-qualified name of the Java class whose
			 * instances are manufactured if the method ResultSet.getObject
			 * is called to retrieve a value from the column.
			 * ResultSet.getObject may return a subclass of the class returned
			 * by this method.
			 *
			 * @param column the first column is 1, the second is 2, ...
			 * @return the fully-qualified name of the class in the Java
			 *         programming language that would be used by the method
			 *         ResultSet.getObject to retrieve the value in the
			 *         specified column. This is the class name used for custom
			 *         mapping.
			 * @throws SQLException if there is no such column
			 */
			public String getColumnClassName(int column) throws SQLException {
				try {
					return(
						getClassForType(
							MonetDriver.getJavaType(types[column - 1])
						).getName()
					);
				} catch (IndexOutOfBoundsException e) {
					throw new SQLException("No such column " + column);
				}
			}

			/**
			 * Gets the designated column's suggested title for use in printouts
			 * and displays. This is currently equal to getColumnName().
			 *
			 * @param column the first column is 1, the second is 2, ...
			 * @return the suggested column title
			 * @throws SQLException if there is no such column
			 */
			public String getColumnLabel(int column) throws SQLException {
				return(getColumnName(column));
			}

			/**
			 * Gets the designated column's name
			 *
			 * @param column the first column is 1, the second is 2, ...
			 * @return the column name
			 * @throws SQLException if there is no such column
			 */
			public String getColumnName(int column) throws SQLException {
				try {
					return(columns[column - 1]);
				} catch (IndexOutOfBoundsException e) {
					throw new SQLException("No such column " + column);
				}
			}

			/**
			 * Retrieves the designated column's SQL type.
			 *
			 * @param column the first column is 1, the second is 2, ...
			 * @return SQL type from java.sql.Types
			 * @throws SQLException if there is no such column
			 */
			public int getColumnType(int column) throws SQLException {
				String type = getColumnTypeName(column);

				return(MonetDriver.getJavaType(type));
			}

			/**
			 * Retrieves the designated column's database-specific type name.
			 *
			 * @param column the first column is 1, the second is 2, ...
			 * @return type name used by the database. If the column type is a
			 *         user-defined type, then a fully-qualified type name is
			 *         returned.
			 * @throws SQLException if there is no such column
			 */
			public String getColumnTypeName(int column) throws SQLException {
				try {
					return(types[column - 1]);
				} catch (IndexOutOfBoundsException e) {
					throw new SQLException("No such column " + column);
				}
			}
		});
	}

	/**
	 * Gets the value of the designated column in the current row of this
	 * ResultSet object as an Object in the Java programming language.
	 * <br /><br />
	 * This method will return the value of the given column as a Java object.
	 * The type of the Java object will be the default Java object type
	 * corresponding to the column's SQL type, following the mapping for
	 * built-in types specified in the JDBC specification. If the value is
	 * an SQL NULL, the driver returns a Java null.
	 * <br /><br />
	 * This method may also be used to read database-specific abstract data
	 * types. In the JDBC 2.0 API, the behavior of method getObject is extended
	 * to materialize data of SQL user-defined types. When a column contains a
	 * structured or distinct value, the behavior of this method is as if it
	 * were a call to: getObject(columnIndex,
	 * this.getStatement().getConnection().getTypeMap()).
	 *
	 * @param columnIndex the first column is 1, the second is 2, ...
	 * @return a java.lang.Object holding the column value
	 * @throws SQLException if a database access error occurs
	 */
	public Object getObject(int columnIndex) throws SQLException {
		return(getObject(columnIndex, this.getStatement().getConnection().getTypeMap()));
	}

	/**
	 * Retrieves the value of the designated column in the current row of this
	 * ResultSet object as an Object in the Java programming language. If the
	 * value is an SQL NULL, the driver returns a Java null. This method uses
	 * the given Map object for the custom mapping of the SQL structured or
	 * distinct type that is being retrieved.
	 *
	 * @param i the first column is 1, the second is 2, ...
	 * @param map a java.util.Map object that contains the mapping from SQL
	 *        type names to classes in the Java programming language
	 * @return an Object in the Java programming language representing the SQL
	 *         value
	 * @throws SQLException if a database access error occurs
	 */
	public Object getObject(int i, Map map) throws SQLException {
		if (result[i - 1] == null) {
			lastColumnRead = i - 1;
			return(null);
		}

		Class type = getClassForType(MonetDriver.getJavaType(types[i - 1]));
		
		if (type == BigDecimal.class) {
			return(getBigDecimal(i));
		} else if (type == Boolean.class) {
			return(Boolean.valueOf(getBoolean(i)));
		} else if (type == Integer.class) {
			return(new Integer(getInt(i)));
		} else if (type == Long.class) {
			return(new Long(getLong(i)));
		} else if (type == Float.class) {
			return(new Float(getFloat(i)));
		} else if (type == Double.class) {
			return(new Double(getDouble(i)));
		} else if (type == java.sql.Date.class) {
			return(getDate(i));
		} else if (type == Time.class) {
			return(getTime(i));
		} else if (type == Timestamp.class) {
			return(getTimestamp(i));
		} else {
			return(getString(i));
		}
	}

	/**
	 * Helper method to support the getObject and
	 * ResultsetMetaData.getColumnClassName JDBC methods.
	 *
	 * @param type a value from java.sql.Types
	 * @return a Class object from which an instance would be returned
	 */
	static Class getClassForType(int type) {
		/**
		 * This switch returns the types as objects according to table B-3 from
		 * Sun's JDBC specification 3.0
		 */
		switch(type) {
			case Types.CHAR:
			case Types.VARCHAR:
			case Types.LONGVARCHAR:
				return(String.class);
			case Types.NUMERIC:
			case Types.DECIMAL:
				return(BigDecimal.class);
			case Types.BIT: // we don't use type BIT, it's here for completeness
			case Types.BOOLEAN:
				return(Boolean.class);
			case Types.TINYINT:
			case Types.SMALLINT:
			case Types.INTEGER:
				return(Integer.class);
			case Types.BIGINT:
				return(Long.class);
			case Types.REAL:
				return(Float.class);
			case Types.FLOAT:
			case Types.DOUBLE:
				return(Double.class);
			case Types.DATE:
				return(java.sql.Date.class);
			case Types.TIME:
				return(Time.class);
			case Types.TIMESTAMP:
				return(Timestamp.class);

			// all below are currently not implemented and used
			case Types.DISTINCT:
			case Types.CLOB:
			case Types.BLOB:
			case Types.ARRAY:
			case Types.STRUCT:
			case Types.REF:
			case Types.DATALINK:
			case Types.OTHER:
			case Types.BINARY:
			case Types.VARBINARY:
			case Types.LONGVARBINARY:
			default:
				return(String.class);
		}
	}

	/**
	 * Gets the value of the designated column in the current row of this
	 * ResultSet object as an Object in the Java programming language.
	 * <br /><br />
	 * This method will return the value of the given column as a Java object.
	 * The type of the Java object will be the default Java object type
	 * corresponding to the column's SQL type, following the mapping for
	 * built-in types specified in the JDBC specification. If the value is an
	 * SQL NULL, the driver returns a Java null.
	 * <br /><br />
	 * This method may also be used to read database-specific abstract data
	 * types.
	 * <br /><br />
	 * In the JDBC 2.0 API, the behavior of the method getObject is extended to
	 * materialize data of SQL user-defined types. When a column contains a
	 * structured or distinct value, the behavior of this method is as if it
	 * were a call to: getObject(columnName,
	 * this.getStatement().getConnection().getTypeMap()).
	 *
	 * @param columnName the SQL name of the column
	 * @return a java.lang.Object holding the column value
	 * @throws SQLException if a database access error occurs
	 */
	public Object getObject(String columnName) throws SQLException {
		return(getObject(columnName, this.getStatement().getConnection().getTypeMap()));
	}

	/**
	 * Retrieves the value of the designated column in the current row of this
	 * ResultSet object as an Object  in the Java programming language. If the
	 * value is an SQL NULL, the driver returns a Java null. This method uses
	 * the specified Map object for custom mapping if appropriate.
	 *
	 * @param colName the name of the column from which to retrieve the value
	 * @param map a java.util.Map object that contains the mapping from SQL
	 *        type names to classes in the Java programming language
	 * @return an Object representing the SQL value in the specified column
	 * @throws SQLException if a database access error occurs
	 */
	public Object getObject(String colName, Map map) throws SQLException {
		return(getObject(findColumn(colName), map));
	}

	public Ref getRef(int i) throws SQLException { throw new SQLException("Method not implemented yet, sorry!"); }
	public Ref getRef(String colName) throws SQLException { throw new SQLException("Method not implemented yet, sorry!"); }

	/**
	 * Retrieves the current row number. The first row is number 1, the second
	 * number 2, and so on.
	 *
	 * @return the current row number; 0 if there is no current row
	 */
	public int getRow() {
		return(curRow);
	}

	/**
	 * Retrieves the value of the designated column in the current row of this
	 * ResultSet object as a short in the Java programming language.
	 *
	 * @param columnIndex the first column is 1, the second is 2, ...
	 * @return the column value; if the value is SQL NULL, the value returned
	 *         is 0
	 * @throws SQLException if there is no such column
	 */
	public short getShort(int columnIndex) throws SQLException {
		short ret = 0;	// note: relaxing by compiler here
		try {
			ret = Short.parseShort(getString(columnIndex));
		} catch (NumberFormatException e) {
			// ignore, return the default: 0
		}
		// do not catch SQLException for it is declared to be thrown

		return(ret);
	}

	/**
	 * Retrieves the value of the designated column in the current row of this
	 * ResultSet object as a short in the Java programming language.
	 *
	 * @param columnName the SQL name of the column
	 * @return the column value; if the value is SQL NULL, the value returned
	 *         is 0
	 * @throws SQLException if the ResultSet object does not contain columnName
	 */
	public short getShort(String columnName) throws SQLException {
		return(getShort(findColumn(columnName)));
	}

	/**
	 * Retrieves the Statement object that produced this ResultSet object. If
	 * the result set was generated some other way, such as by a
	 * DatabaseMetaData method, this method returns null.
	 *
	 * @return the Statment object that produced this ResultSet object or null
	 *         if the result set was produced some other way
	 */
	public Statement getStatement() {
		return(statement);
	}

	/**
	 * Retrieves the value of the designated column in the current row of this
	 * ResultSet object as a String in the Java programming language.
	 *
	 * @param columnIndex the first column is 1, the second is 2, ...
	 * @return the column value; if the value is SQL NULL, the value returned
	 *         is null
	 * @throws SQLException if there is no such column
	 */
	public String getString(int columnIndex) throws SQLException {
		// note: all current getters use the string getter in the end
		// in the future this might change, and the lastColumnRead must
		// be updated for the wasNull command to work properly!!!
		try {
			String ret = result[columnIndex - 1];
			lastColumnRead = columnIndex - 1;
			return(ret);
		} catch (IndexOutOfBoundsException e) {
			throw new SQLException("No such column " + columnIndex);
		}
	}

	/**
	 * Retrieves the value of the designated column in the current row of this
	 * ResultSet object as a String in the Java programming language.
	 *
	 * @param columnName the SQL name of the column
	 * @return the column value; if the value is SQL NULL, the value returned
	 *         is null
	 * @throws SQLException if the ResultSet object does not contain columnName
	 */
	public String getString(String columnName) throws SQLException {
		return(getString(findColumn(columnName)));
	}

	// This behaviour is according table B-6 of Sun JDBC Specification 3.0
	/**
	 * Helper method which returns a java.util.Date for columns of type
	 * TIME, DATE and TIMESTAMP. For the types CHAR, VARCHAR and LONGVARCHAR
	 * an attempt is made to parse the date according to the given type.
	 * If the underlying type of the column is
	 * none of the mentioned six, January 1st 1970 0:00:00 GMT is
	 * returned.<br />
	 * The dates are parsed with the given Calendar.
	 *
	 * @param cal the Calendar to use when parsing the date
	 * @param col the column to parse
	 * @param type the corresponding java.sql.Types type of the calling
	 *        function
	 * @return an instance of java.util.Date representing this date corrected
	 *         with the given Calendar, or 0 if not parseable
	 * @throws SQLException if a database error occurs
	 * @see #getDate(int col, Calendar cal)
	 */
	private java.util.Date getJavaDate(Calendar cal, int col, int type)
		throws SQLException
	{
		if (cal == null) throw
			new IllegalArgumentException("No Calendar object given!");
		if (col <= 0) throw
			new IllegalArgumentException("No valid column number given!");

		String monetDate;
		if ((monetDate = getString(col)) == null) return(null);

		int dataType = MonetDriver.getJavaType(types[col - 1]);
		if (dataType == Types.CHAR ||
			dataType == Types.VARCHAR ||
			dataType == Types.LONGVARCHAR)
		{
			// If we got a string type, set the datatype to the given
			// type so we attempt to parse it as the caller thinks it is.
			dataType = type;
		}

		try {
			switch(dataType) {
				default:
					throw new java.text.ParseException("Unsupported data type", 0);

				case Types.DATE:
					synchronized (MonetConnection.mDate) {
						MonetConnection.mDate.setTimeZone(TimeZone.getDefault());
						return(MonetConnection.mDate.parse(monetDate));
					}
				case Types.TIME:
					// we know it's time or timetz, so observing the
					// length is enough to find out whether we have a
					// time with or without time zone
					if (types[col - 1].length() == 6) { // "timetz".length()
						// RFC822:         Sign TwoDigitHours Minutes
						// MonetDB/SQL99:  Sign TwoDigitHours : Minutes
						String tzRFC822 =
							monetDate.substring(12, 15) +
							monetDate.substring(16, 18);

						synchronized (MonetConnection.mTimeZ) {
							MonetConnection.mTimeZ.setCalendar(Calendar.getInstance());
							return(MonetConnection.mTimeZ.parse(monetDate.substring(0, 12) + tzRFC822));
						}
					} else {
						// if there is no time zone information in the database
						// we have to use the given calendar to construct it
						synchronized (MonetConnection.mTimeZ) {
							MonetConnection.mTime.setCalendar(cal);

							return(MonetConnection.mTime.parse(monetDate));
						}
					}
				//break; (not needed because of the else/return)
				case Types.TIMESTAMP:
					// we know it's timestamp or timestamptz, so
					// observing the length is enough to find out
					// whether we have a timestamp with or without time
					// zone
					if (types[col - 1].length() == 11) { // "timestamptz".length()
						// RFC822:         Sign TwoDigitHours Minutes
						// MonetDB/SQL99:  Sign TwoDigitHours : Minutes
						String tzRFC822 =
							monetDate.substring(23, 26) +
							monetDate.substring(27, 29);

						synchronized (MonetConnection.mTimestampZ) {
							MonetConnection.mTimestampZ.setCalendar(Calendar.getInstance());
							return(MonetConnection.mTimestampZ.parse(monetDate.substring(0, 23) + tzRFC822));
						}
					} else {
						// if there is no time zone information in the database
						// we have to use the given calendar to construct it
						synchronized (MonetConnection.mTimestampZ) {
							MonetConnection.mTimestamp.setCalendar(cal);
							
							return(MonetConnection.mTimestamp.parse(monetDate));
						}
					}
				//break; (not needed because of the else/return)
			}
		} catch(java.text.ParseException e) {
			// keep default value
		}
		return(Timestamp.valueOf("1970-01-01 00:00:00.000"));
	}

	/**
	 * Retrieves the value of the designated column in the current row of this
	 * ResultSet object as a java.sql.Date object in the Java programming
	 * language.
	 *
	 * @param columnIndex the first column is 1, the second is 2, ...
	 * @return the column value; if the value is SQL NULL, the value returned
	 *         is null
	 * @throws SQLException if a database access error occurs
	 */
	public java.sql.Date getDate(int columnIndex) throws SQLException {
		return(getDate(columnIndex,	Calendar.getInstance()));
	}

	/**
	 * Retrieves the value of the designated column in the current row of this
	 * ResultSet object as a java.sql.Date object in the Java programming
	 * language. This method uses the given calendar to construct an appropriate
	 * millisecond value for the date if the underlying database does not store
	 * timezone information.
	 *
	 * @param columnIndex the first column is 1, the second is 2, ...
	 * @param cal the java.util.Calendar object to use in constructing the date
	 * @return the column value; if the value is SQL NULL, the value returned
	 *         is null
	 * @throws SQLException if a database access error occurs
	 */
	public java.sql.Date getDate(int columnIndex, Calendar cal)
		throws SQLException
	{
		java.util.Date d = getJavaDate(cal, columnIndex, Types.DATE);
		return(d == null ? (java.sql.Date)d : new java.sql.Date(d.getTime()));
	}

	/**
	 * Retrieves the value of the designated column in the current row of this
	 * ResultSet object as a java.sql.Date object in the Java programming
	 * language.
	 *
	 * @param columnName the SQL name of the column from which to retrieve the
	 *        value
	 * @return the column value; if the value is SQL NULL, the value returned
	 *         is null
	 * @throws SQLException if a database access error occurs
	 */
	public java.sql.Date getDate(String columnName) throws SQLException {
		return(getDate(columnName, Calendar.getInstance()));
	}

	/**
	 * Retrieves the value of the designated column in the current row of this
	 * ResultSet object as a java.sql.Date object in the Java programming
	 * language. This method uses the given calendar to construct an appropriate
	 * millisecond value for the date if the underlying database does not store
	 * timezone information.
	 *
	 * @param columnName the SQL name of the column from which to retrieve the
	 *        value
	 * @param cal the java.util.Calendar object to use in constructing the date
	 * @return the column value; if the value is SQL NULL, the value returned
	 *         is null
	 * @throws SQLException if a database access error occurs
	 */
	public java.sql.Date getDate(String columnName, Calendar cal)
		throws SQLException
	{
		return(getDate(findColumn(columnName), cal));
	}

	/**
	 * Retrieves the value of the designated column in the current row of this
	 * ResultSet object as a java.sql.Time object in the Java programming
	 * language.
	 *
	 * @param columnIndex the first column is 1, the second is 2, ...
	 * @return the column value; if the value is SQL NULL, the value returned
	 *         is null
	 * @throws SQLException if a database access error occurs
	 */
	public Time getTime(int columnIndex) throws SQLException {
		return(getTime(columnIndex, Calendar.getInstance()));
	}

	/**
	 * Retrieves the value of the designated column in the current row of
	 * this ResultSet object as a java.sql.Time object in the Java programming
	 * language. This method uses the given calendar to construct an appropriate
	 * millisecond value for the time if the underlying database does not store
	 * timezone information.
	 *
	 * @param columnIndex the first column is 1, the second is 2, ...
	 * @param cal the java.util.Calendar object to use in constructing the
	 *        timestamp
	 * @return the column value as a java.sql.Timestamp object; if the value is
	 *         SQL NULL, the value returned is null in the Java programming
	 *         language
	 * @throws SQLException if a database access error occurs
	 */
	public Time getTime(int columnIndex, Calendar cal)
		throws SQLException
	{
		java.util.Date d = getJavaDate(cal, columnIndex, Types.TIME);
		return(d == null ? (Time)d : new Time(d.getTime()));
	}

	/**
	 * Retrieves the value of the designated column in the current row of this
	 * ResultSet object as a java.sql.Time object in the Java programming
	 * language.
	 *
	 * @param columnName the SQL name of the column
	 * @return the column value; if the value is SQL NULL, the value returned
	 *         is null
	 * @throws SQLException if a database access error occurs
	 */
	public Time getTime(String columnName) throws SQLException {
		return(getTime(columnName, Calendar.getInstance()));
	}

	/**
	 * Retrieves the value of the designated column in the current row of
	 * this ResultSet object as a java.sql.Time object in the Java programming
	 * language. This method uses the given calendar to construct an appropriate
	 * millisecond value for the time if the underlying database does not store
	 * timezone information.
	 *
	 * @param columnName the SQL name of the column
	 * @param cal the java.util.Calendar object to use in constructing the
	 *        timestamp
	 * @return the column value as a java.sql.Timestamp object; if the value is
	 *         SQL NULL, the value returned is null in the Java programming
	 *         language
	 * @throws SQLException if a database access error occurs
	 */
	public Time getTime(String columnName, Calendar cal)
		throws SQLException
	{
		return(getTime(findColumn(columnName), cal));
	}

	/**
	 * Retrieves the value of the designated column in the current row of this
	 * ResultSet object as a java.sql.Timestamp object in the Java programming
	 * language.
	 *
	 * @param columnIndex the first column is 1, the second is 2, ...
	 * @return the column value; if the value is SQL NULL, the value returned
	 *         is null
	 * @throws SQLException if a database access error occurs
	 */
	public Timestamp getTimestamp(int columnIndex) throws SQLException {
		return(getTimestamp(columnIndex, Calendar.getInstance()));
	}

	/**
	 * Retrieves the value of the designated column in the current row of this
	 * ResultSet object as a java.sql.Timestamp object in the Java programming
	 * language. This method uses the given calendar to construct an appropriate
	 * millisecond value for the timestamp if the underlying database does not
	 * store timezone information.
	 *
	 * @param columnIndex the first column is 1, the second is 2, ...
	 * @param cal the java.util.Calendar object to use in constructing the
	 *        timestamp
	 * @return the column value as a java.sql.Timestamp object; if the value is
	 *         SQL NULL, the value returned is null in the Java programming
	 *         language
	 * @throws SQLException if a database access error occurs
	 */
	public Timestamp getTimestamp(int columnIndex, Calendar cal)
		throws SQLException
	{
		java.util.Date d = getJavaDate(cal, columnIndex, Types.TIMESTAMP);
		return(d == null ? (Timestamp)d : new Timestamp(d.getTime()));
	}

	/**
	 * Retrieves the value of the designated column in the current row of this
	 * ResultSet object as a java.sql.Timestamp object in the Java programming
	 * language.
	 *
	 * @param columnName the SQL name of the column
	 * @return the column value; if the value is SQL NULL, the value returned
	 *         is null
	 * @throws SQLException if a database access error occurs
	 */
	public Timestamp getTimestamp(String columnName) throws SQLException {
		return(getTimestamp(columnName, Calendar.getInstance()));
	}

	/**
	 * Retrieves the value of the designated column in the current row of this
	 * ResultSet object as a java.sql.Timestamp object in the Java programming
	 * language. This method uses the given calendar to construct an appropriate
	 * millisecond value for the timestamp if the underlying database does not
	 * store timezone information.
	 *
	 * @param columnName the SQL name of the column
	 * @param cal the java.util.Calendar object to use in constructing the
	 *        timestamp
	 * @return the column value as a java.sql.Timestamp object; if the value is
	 *         SQL NULL, the value returned is null in the Java programming
	 *         language
	 * @throws SQLException if a database access error occurs
	 */
	public Timestamp getTimestamp(String columnName, Calendar cal)
		throws SQLException
	{
		return(getTimestamp(findColumn(columnName), cal));
	}

	/**
	 * Retrieves the type of this ResultSet object. The type is determined by
	 * the Statement object that created the result set.
	 *
	 * @return ResultSet.TYPE_FORWARD_ONLY, ResultSet.TYPE_SCROLL_INSENSITIVE,
	 *         or ResultSet.TYPE_SCROLL_SENSITIVE
	 */
	public int getType() {
		return(type);
	}

	/**
	 * Retrieves the value of the designated column in the current row
	 * of this ResultSet object as a java.net.URL object in the Java
	 * programming language.
	 *
	 * @param columnIndex the index of the column 1 is the first,
	 *                    2 is the second,...
	 * @return the column value as a java.net.URL object; if the value
	 *         is SQL NULL, the value returned is null in the Java
	 *         programming language
	 * @throws SQLException if a database access error occurs, or if a
	 *         URL is malformed
	 */
	public URL getURL(int columnIndex) throws SQLException {
		String url = getString(columnIndex);	
		if (url == null) return(null);
		try {
			return(new URL(url));
		} catch (MalformedURLException e) {
			throw new SQLException(e.getMessage());
		}
	}

	/**
	 * Retrieves the value of the designated column in the current row
	 * of this ResultSet object as a java.net.URL object in the Java
	 * programming language.
	 *
	 * @param columnName the SQL name of the column
	 * @return the column value as a java.net.URL object; if the value
	 *         is SQL NULL, the value returned is null in the Java
	 *         programming language
	 * @throws SQLException if a database access error occurs, or if a
	 *         URL is malformed
	 */
	public URL getURL(String columnName) throws SQLException {
		return(getURL(findColumn(columnName)));
	}

	/**
	 * Retrieves the first warning reported by calls on this ResultSet object.
	 * If there is more than one warning, subsequent warnings will be chained to
	 * the first one and can be retrieved by calling the method
	 * SQLWarning.getNextWarning on the warning that was retrieved previously.
	 * <br /><br />
	 * This method may not be called on a closed result set; doing so will cause
	 * an SQLException to be thrown.
	 * <br /><br />
	 * Note: Subsequent warnings will be chained to this SQLWarning.
	 *
	 * @return the first SQLWarning object or null if there are none
	 * @throws SQLException if a database access error occurs or this method is
	 *         called on a closed connection
	 */
	public SQLWarning getWarnings() throws SQLException {
		if (header.isClosed()) throw new SQLException("Cannot call on closed ResultSet");

		// if there are no warnings, this will be null, which fits with the
		// specification.
		return(warnings);
	}

	/**
	 * Retrieves whether the cursor is after the last row in this ResultSet
	 * object.
	 *
	 * @return true if the cursor is after the last row; false if the cursor is
	 *         at any other position or the result set contains no rows
	 */
	public boolean isAfterLast() {
		return(curRow == tupleCount + 1);
	}

	/**
	 * Retrieves whether the cursor is before the first row in this ResultSet
	 * object.
	 *
	 * @return true if the cursor is before the first row; false if the cursor
	 *         is at any other position or the result set contains no rows
	 */
	public boolean isBeforeFirst() {
		return(curRow == 0);
	}

	/**
	 * Retrieves whether the cursor is on the first row of this ResultSet
	 * object.
	 *
	 * @return true if the cursor is on the first row; false otherwise
	 */
	public boolean isFirst() {
		return(curRow == 1);
	}

	/**
	 * Retrieves whether the cursor is on the last row of this ResultSet object.
	 *
	 * @return true if the cursor is on the last row; false otherwise
	 */
	public boolean isLast() {
		return(curRow == tupleCount);
	}

	/**
	 * Moves the cursor to the last row in this ResultSet object.
	 *
	 * @return true if the cursor is on a valid row; false if there are no rows
	 *         in the result set
	 * @throws SQLException if a database access error occurs or the result set
	 *         type is TYPE_FORWARD_ONLY
	 */
	public boolean last() throws SQLException {
		return(absolute(-1));
	}

	/**
	 * Moves the cursor down one row from its current position. A ResultSet
	 * cursor is initially positioned before the first row; the first call to
	 * the method next makes the first row the current row; the second call
	 * makes the second row the current row, and so on.
	 * <br /><br />
	 * If an input stream is open for the current row, a call to the method
	 * next will implicitly close it. A ResultSet object's warning chain is
	 * cleared when a new row is read.
	 *
	 * @return true if the new current row is valid; false if there are no
	 *         more rows
	 * @throws SQLException if a database access error occurs or ResultSet is
	 *         closed
	 */
	public boolean next() throws SQLException {
		return(relative(1));
	}

	/**
	 * Moves the cursor to the previous row in this ResultSet object.
	 *
	 * @return true if the cursor is on a valid row; false if it is off
	 *         the result set
	 * @throws SQLException if a database access error occurs or ResultSet is
	 *         closed or the result set type is TYPE_FORWARD_ONLY
	 */
	public boolean previous() throws SQLException {
		return(relative(-1));
	}

	/**
	 * Moves the cursor a relative number of rows, either positive or negative.
	 * Attempting to move beyond the first/last row in the result set positions
	 * the cursor before/after the the first/last row. Calling relative(0) is
	 * valid, but does not change the cursor position.
	 * <br /><br />
	 * Note: Calling the method relative(1) is identical to calling the method
	 * next() and calling the method relative(-1) is identical to calling the
	 * method previous().
	 *
	 * @param rows an int specifying the number of rows to move from the current
	 *        row; a positive number moves the cursor forward; a negative number
	 *        moves the cursor backward
	 * @return true if the cursor is on a row; false otherwise
	 * @throws SQLException if a database access error occurs, there is no current
	 *         row, or the result set type is TYPE_FORWARD_ONLY
	 */
	public boolean relative(int rows) throws SQLException {
		return(absolute(curRow + rows));
	}

	/* these methods are all related to updateable result sets, which we
	   currently do not support */
	public void cancelRowUpdates() throws SQLException { throw new SQLException("Method not implemented yet, sorry!"); }
	public void deleteRow() throws SQLException { throw new SQLException("Method not implemented yet, sorry!"); }
	public void insertRow() throws SQLException { throw new SQLException("Method not implemented yet, sorry!"); }
	public void moveToCurrentRow() throws SQLException { throw new SQLException("Method not implemented yet, sorry!"); }
	public void moveToInsertRow() throws SQLException { throw new SQLException("Method not implemented yet, sorry!"); }
	public void refreshRow() throws SQLException { throw new SQLException("Method not implemented yet, sorry!"); }
	public boolean rowDeleted() throws SQLException { throw new SQLException("Method not implemented yet, sorry!"); }
	public boolean rowInserted() throws SQLException { throw new SQLException("Method not implemented yet, sorry!"); }
	public boolean rowUpdated() throws SQLException { throw new SQLException("Method not implemented yet, sorry!"); }
	public void setFetchDirection(int direction) throws SQLException { throw new SQLException("Method not implemented yet, sorry!"); }
	public void setFetchSize(int rows) throws SQLException { throw new SQLException("Method not implemented yet, sorry!"); }
	public void updateArray(int columnIndex, Array x) throws SQLException { throw new SQLException("Method not implemented yet, sorry!"); }
	public void updateArray(String columnName, Array x) throws SQLException { throw new SQLException("Method not implemented yet, sorry!"); }
	public void updateAsciiStream(int columnIndex, InputStream x, int length) throws SQLException { throw new SQLException("Method not implemented yet, sorry!"); }
	public void updateAsciiStream(String columnName, InputStream x, int length) throws SQLException { throw new SQLException("Method not implemented yet, sorry!"); }
	public void updateBigDecimal(int columnIndex, BigDecimal x) throws SQLException { throw new SQLException("Method not implemented yet, sorry!"); }
	public void updateBigDecimal(String columnName, BigDecimal x) throws SQLException { throw new SQLException("Method not implemented yet, sorry!"); }
	public void updateBinaryStream(int columnIndex, InputStream x, int length) throws SQLException { throw new SQLException("Method not implemented yet, sorry!"); }
	public void updateBinaryStream(String columnName, InputStream x, int length) throws SQLException { throw new SQLException("Method not implemented yet, sorry!"); }
	public void updateBlob(int columnIndex, Blob x) throws SQLException { throw new SQLException("Method not implemented yet, sorry!"); }
	public void updateBlob(String columnName, Blob x) throws SQLException { throw new SQLException("Method not implemented yet, sorry!"); }
	public void updateBoolean(int columnIndex, boolean x) throws SQLException { throw new SQLException("Method not implemented yet, sorry!"); }
	public void updateBoolean(String columnName, boolean x) throws SQLException { throw new SQLException("Method not implemented yet, sorry!"); }
	public void updateByte(int columnIndex, byte x) throws SQLException { throw new SQLException("Method not implemented yet, sorry!"); }
	public void updateByte(String columnName, byte x) throws SQLException { throw new SQLException("Method not implemented yet, sorry!"); }
	public void updateBytes(int columnIndex, byte[] x) throws SQLException { throw new SQLException("Method not implemented yet, sorry!"); }
	public void updateBytes(String columnName, byte[] x) throws SQLException { throw new SQLException("Method not implemented yet, sorry!"); }
	public void updateCharacterStream(int columnIndex, Reader x, int length) throws SQLException { throw new SQLException("Method not implemented yet, sorry!"); }
	public void updateCharacterStream(String columnName, Reader reader, int length) throws SQLException { throw new SQLException("Method not implemented yet, sorry!"); }
	public void updateClob(int columnIndex, Clob x) throws SQLException { throw new SQLException("Method not implemented yet, sorry!"); }
	public void updateClob(String columnName, Clob x) throws SQLException { throw new SQLException("Method not implemented yet, sorry!"); }
	public void updateDate(int columnIndex, java.sql.Date x) throws SQLException { throw new SQLException("Method not implemented yet, sorry!"); }
	public void updateDate(String columnName, java.sql.Date x) throws SQLException { throw new SQLException("Method not implemented yet, sorry!"); }
	public void updateDouble(int columnIndex, double x) throws SQLException { throw new SQLException("Method not implemented yet, sorry!"); }
	public void updateDouble(String columnName, double x) throws SQLException { throw new SQLException("Method not implemented yet, sorry!"); }
	public void updateFloat(int columnIndex, float x) throws SQLException { throw new SQLException("Method not implemented yet, sorry!"); }
	public void updateFloat(String columnName, float x) throws SQLException { throw new SQLException("Method not implemented yet, sorry!"); }
	public void updateInt(int columnIndex, int x) throws SQLException { throw new SQLException("Method not implemented yet, sorry!"); }
	public void updateInt(String columnName, int x) throws SQLException { throw new SQLException("Method not implemented yet, sorry!"); }
	public void updateLong(int columnIndex, long x) throws SQLException { throw new SQLException("Method not implemented yet, sorry!"); }
	public void updateLong(String columnName, long x) throws SQLException { throw new SQLException("Method not implemented yet, sorry!"); }
	public void updateNull(int columnIndex) throws SQLException { throw new SQLException("Method not implemented yet, sorry!"); }
	public void updateNull(String columnName) throws SQLException { throw new SQLException("Method not implemented yet, sorry!"); }
	public void updateObject(int columnIndex, Object x) throws SQLException { throw new SQLException("Method not implemented yet, sorry!"); }
	public void updateObject(int columnIndex, Object x, int scale) throws SQLException { throw new SQLException("Method not implemented yet, sorry!"); }
	public void updateObject(String columnName, Object x) throws SQLException { throw new SQLException("Method not implemented yet, sorry!"); }
	public void updateObject(String columnName, Object x, int scale) throws SQLException { throw new SQLException("Method not implemented yet, sorry!"); }
	public void updateRef(int columnIndex, Ref x) throws SQLException { throw new SQLException("Method not implemented yet, sorry!"); }
	public void updateRef(String columnName, Ref x) throws SQLException { throw new SQLException("Method not implemented yet, sorry!"); }
	public void updateRow() throws SQLException { throw new SQLException("Method not implemented yet, sorry!"); }
	public void updateShort(int columnIndex, short x) throws SQLException { throw new SQLException("Method not implemented yet, sorry!"); }
	public void updateShort(String columnName, short x) throws SQLException { throw new SQLException("Method not implemented yet, sorry!"); }
	public void updateString(int columnIndex, String x) throws SQLException { throw new SQLException("Method not implemented yet, sorry!"); }
	public void updateString(String columnName, String x) throws SQLException { throw new SQLException("Method not implemented yet, sorry!"); }
	public void updateTime(int columnIndex, Time x) throws SQLException { throw new SQLException("Method not implemented yet, sorry!"); }
	public void updateTime(String columnName, Time x) throws SQLException { throw new SQLException("Method not implemented yet, sorry!"); }
	public void updateTimestamp(int columnIndex, Timestamp x) throws SQLException { throw new SQLException("Method not implemented yet, sorry!"); }
	public void updateTimestamp(String columnName, Timestamp x) throws SQLException { throw new SQLException("Method not implemented yet, sorry!"); }

	// Chapter 14.2.3.3 Sun JDBC 3.0 Specification
	/**
	 * Reports whether the last column read had a value of SQL NULL. Note that
	 * you must first call one of the getter methods on a column to try to read
	 * its value and then call the method wasNull to see if the value read was
	 * SQL NULL.
	 *
	 * @return true if the last column value read was SQL NULL and false
	 *          otherwise
	 */
	public boolean wasNull() {
		return(lastColumnRead != -1 ? result[lastColumnRead] == null : false);
	}

	//== end methods of interface ResultSet

	protected void finalize() throws Throwable {
		close();
		super.finalize();
	}

	/**
	 * Adds a warning to the pile of warnings this ResultSet object has. If
	 * there were no warnings (or clearWarnings was called) this warning will
	 * be the first, otherwise this warning will get appended to the current
	 * warning.
	 *
	 * @param reason the warning message
	 */
	private void addWarning(String reason) {
		if (warnings == null) {
			warnings = new SQLWarning(reason);
		} else {
			warnings.setNextWarning(new SQLWarning(reason));
		}
	}
}
