\documentclass{article}

\begin{document}
\section{The MonetDB JDBC Driver}
The most obvious way to connect to a data source using the Java programming language
is by making use of the in Java defined JDBC framework.

MonetDB has a native Java JDBC driver type 4 which allows use of the MonetDB database in
a Java alike way.

This release is not a complete implementation of the JDBC interface. If you make
extensive use of JDBC semantics and rely on many of its features, please
read the release notes which are to be found in the \texttt{src/jdbc} directory of the sql
CVS tree.

This document will give a short description how to use the MonetDB JDBC driver in
Java applications.  A familiarity with the Java JDBC API is required to fully understand
this document.  Please note that you can find the complete JDBC API on Sun's web site
\texttt{http://java.sun.com/}.

\subsection{Requirements}
In order to use the MonetDB JDBC driver in Java applications you need (of course) a running MonetDB instance with the SQL module loaded.\\
The SQL module is a separate module in the CVS tree, and should be installed separately, since
it is not included in the main MonetDB module.

You should be able to issue the following command on the MonetDB prompt without errors:
\begin{quote}
\texttt{module(sql\_server);}
\end{quote}

\subsection{Getting the driver Jar}
If you compiled and installed MonetDB and the SQL module the regular way, you can find a
jar-archive in the directory \texttt{share/MonetDB/lib} called \texttt{MonetDB\_JDBC.jar} in the
installation root (chosen during the configure process).\\
\textbf{Note:} there also exists a file named \texttt{mapi.jar} in the mentioned directory, this
jar does NOT contain the JDBC driver.

\subsection{Compiling the driver (using ant, optional)}
The directory \texttt{src/jdbc} of the sql CVS tree contains all the files to build the driver using
Apache's Ant tool. Simply issuing the command \texttt{ant} should be sufficient to build the driver
jar-archive in the subdirectory \texttt{jars}. See the ant web site for more documentation on the
ant build-tool. \texttt{http://ant.apache.org/}

\subsection{Testing the driver using the JdbcClient utility}
Before you start developing your programs which use the MonetDB JDBC driver it is generally
a good idea to check if the driver actually works on your environment.\\
Follow the steps below to assure your setup is complete:
\begin{enumerate}
\item start MonetDB
\item load the SQL module using \texttt{module(sql\_server);}
\item run the JdbcClient utility using \texttt{java -jar \{path/to/MonetDB\_JDBC.jar\} -umonetdb} (with
 password monetdb)
\end{enumerate}
The last step should give you something like this:
\begin{verbatim}
% java -jar jars/MonetDB_JDBC.jar -umonetdb
password:

Welcome to the MonetDB interactive JDBC terminal!
Database: MonetDB 4.3.17 (4.3)
Driver: MonetDB Native Driver 0.4 beta release (0.4)
Type \q to quit, \h for a list of available commands
auto commit mode: on
monetdb->
\end{verbatim}

\subsection{Using the driver in your Java programs}
In order to use the MonetDB JDBC driver, the jar-archive has to be in the Java classpath.
Make sure this is actually the case.

Loading the driver in your Java program requires two lines of code, which can be for example:
\begin{verbatim}
Class.forName("nl.cwi.monetdb.jdbc.MonetDriver");
Connection con = DriverManager.getConnection("jdbc:monetdb://localhost/notused", "monetdb", "monetdb");
\end{verbatim}
The first line makes sure the Java ClassLoader has initialized (and loaded) the Driver class of the MonetDB
JDBC package, so it is registered with the DriverManager. The second line requests a Connection
object from the DriverManager which is suitable for MonetDB.

The string passed to the \verb"getConnection" method is defined as
\verb"jdbc:monetdb://<host>[:<port>]/<database>" where elements between
\verb"<" and \verb">" are required and elements between [ and ] are optional.

As obvious from the example above, currently the database name is not used, and does not affect
the connection in any way. This database element is reserved for future use.

\subsection{A sample Java program}
\begin{verbatim}
import java.sql.*;

/**
 * This example assumes there exist tables a and b filled with some data.
 * On these tables some queries are executed and the JDBC driver is tested
 * on it's accuracy and robustness against 'users'.
 *
 * @author Fabian Groffen
 */
public class MJDBCTest {
        public static void main(String[] args) throws Exception {
                // make sure the driver is loaded
                Class.forName("nl.cwi.monetdb.jdbc.MonetDriver");
                Connection con = DriverManager.getConnection("jdbc:monetdb://localhost/notused?debug=true", "monetdb", "monetdb");
                Statement st = con.createStatement();
                ResultSet rs;

                rs = st.executeQuery("SELECT a.var1, COUNT(b.id) as total FROM a, b WHERE a.var1 = b.id AND a.var1 = 'andb' GROUP BY a.var1 ORDER BY a.var1, total;");
                // get meta data and print columns with their type
                ResultSetMetaData md = rs.getMetaData();
                for (int i = 1; i <= md.getColumnCount(); i++) {
                        System.out.print(md.getColumnName(i) + ":" +
                                md.getColumnTypeName(i) + "\t");
                }
                System.out.println("");
                // print the data: only the first 5 rows, while there probably are
                // a lot more. This shouldn't cause any problems afterwards since the
                // result should get properly discarded on the next query
                for (int i = 0; rs.next() && i < 5; i++) {
                        for (int j = 1; j <= md.getColumnCount(); j++) {
                                System.out.print(rs.getString(j) + "\t");
                        }
                        System.out.println("");
                }

                // tell the driver to only return 5 rows, it can optimize on this
                // value, and will not fetch any more than 5 rows.
                st.setMaxRows(5);
                // we ask the database for 22 rows, while we set the JDBC driver to
                // 5 rows, this shouldn't be a problem at all...
                rs = st.executeQuery("select * from a limit 22");
                // read till the driver says there are no rows left
                for (int i = 0; rs.next(); i++) {
                        System.out.print("[" + rs.getString("var1") + "]");
                        System.out.print("[" + rs.getString("var2") + "]");
                        System.out.print("[" + rs.getInt("var3") + "]");
                        System.out.println("[" + rs.getString("var4") + "]");
                }

                // this close is not needed, should be done by next execute(Query) call
                // however if there can be some time between this point and the next
                // execute call, it is from a resource perspective better to close it.
                //rs.close();

                // unset the row limit; 0 means as much as the database sends us
                st.setMaxRows(0);
                // we only ask 10 rows
                rs = st.executeQuery("select * from b limit 10;");
                // and simply print them
                while (rs.next()) {
                        System.out.print(rs.getInt("rowid") + ", ");
                        System.out.print(rs.getString("id") + ", ");
                        System.out.print(rs.getInt("var1") + ", ");
                        System.out.print(rs.getInt("var2") + ", ");
                        System.out.print(rs.getString("var3") + ", ");
                        System.out.println(rs.getString("var4"));
                }

                // this close is not needed, as the Statement will close the last
                // ResultSet around when it's closed
                // again, if that can take some time, it's nicer to close immediately
                // the reason why these closes are commented out here, is to test if
                // the driver really cleans up it's mess like it should
                //rs.close();

                // perform a ResultSet-less query (with no trailing ; since that should
                // be possible as well and is JDBC standard)
                // Note that this method should return the number of updated rows. This
                // method however always returns -1, since Monet currently doesn't
                // support returning the affected rows.
                st.executeUpdate("delete from a where var1 = 'zzzz'");

                // closing the connection should take care of closing all generated
                // statements from it...
                // Don't forget to do it yourself if the connection is reused or much
                // longer alive, since the Statement object contains a lot of things
                // you probably want to reclaim if you don't need them anymore.
                //st.close();
                con.close();
        }
}
\end{verbatim}

\end{document}
