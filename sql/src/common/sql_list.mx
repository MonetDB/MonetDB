@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2007 CWI.
@' All Rights Reserved.

@f sql_list
@a N.J. Nes
@* 

@c
#include "sql_config.h"
#include <gdk.h>		/* for GDKmalloc() & GDKfree() */
#include "sql_list.h"

static node *
node_create(void *data)
{
	node *n = NEW(node);

	n->next = NULL;
	n->data = data;
	return n;
}

list *
list_create(fdestroy destroy)
{
	list *l = NEW(list);

	l->destroy = destroy;
	l->h = l->t = NULL;
	l->cnt = 0;
	return l;
}

static void
node_destroy(list *l, node *n)
{
	if (n->data && l->destroy)
		l->destroy(n->data);
	_DELETE(n);
}

void
list_destroy(list *l)
{
	if (l) {
		node *n = l->h;

		while (n) {
			node *t = n;

			n = n->next;
			node_destroy(l, t);
		}
		_DELETE(l);
	}
}

int
list_length(list *l)
{
	return l->cnt;
}

list *
list_append(list *l, void *data)
{
	node *n = node_create(data);

	if (l->cnt) {
		l->t->next = n;
	} else {
		l->h = n;
	}
	l->t = n;
	l->cnt++;
	return l;
}

list *
list_append_before(list *l, node *m, void *data)
{
	node *p = l->h;
	node *n = node_create(data);

	n->next = m;
	if (p == m){
		l->h = n;
	} else {
		while (p->next && p->next != m)
			p = p->next;
		p->next = n;
	}
	l->cnt++;
	return l;
}

list *
list_prepend(list *l, void *data)
{
	node *n = node_create(data);

	if (!l->cnt) {
		l->t = n;
	}
	n->next = l->h;
	l->h = n;
	l->cnt++;
	return l;
}

node *
list_remove_node(list *l, node *n)
{
	node *p = l->h;

	if (p != n)
		while (p && p->next != n)
			p = p->next;
	if (p == n) {
		l->h = n->next;
		p = NULL;
	} else {
		p->next = n->next;
	}
	if (n == l->t)
		l->t = p;
	node_destroy(l, n);
	l->cnt--;
	return p;
}

void
list_remove_data(list *s, void *data)
{
	node *n;

	/* maybe use compare func */
	for (n = s->h; n; n = n->next) {
		if (n->data == data) {
			n->data = NULL;
			list_remove_node(s, n);
			break;
		}
	}
}

void
list_move_data(list *s, list *d, void *data)
{
	node *n;

	for (n = s->h; n; n = n->next) {
		if (n->data == data) {
			n->data = NULL;	/* make sure data isn't destroyed */
			list_remove_node(s, n);
			break;
		}
	}
	list_append(d, data);
}

int
list_traverse(list *l, traverse_func f, void *clientdata)
{
	int res = 0, seqnr = 0;
	node *n = l->h;

	while (n && !res) {
		res = f(clientdata, seqnr++, n->data);
		n = n->next;
	}
	return res;
}

node *
list_find(list *l, void *key, fcmp cmp)
{
	node *n = NULL;

	if (key) {
		for (n = l->h; n; n = n->next) {
			if (cmp(n->data, key) == 0) {
				return n;
			}
		}
	}
	return NULL;
}

int
list_cmp(list *l1, list *l2, fcmp cmp)
{
	node *n, *m;
	int res = 0;

	if (l1 == l2)
		return 0;

	if (!l1 || !l2 || (list_length(l1) != list_length(l2)))
		return -1;

	for (n = l1->h, m = l2->h; res == 0 && n; n = n->next, m = m->next) {
		res = cmp(n->data, m->data);
	}
	return res;
}

list *
list_select(list *l, void *key, fcmp cmp, fdup dup)
{
	list *res = list_create(l->destroy);
	node *n = NULL;

	if (key) {
		for (n = l->h; n; n = n->next) {
			if (cmp(n->data, key) == 0) {
				list_append(res, dup(n->data));
			}
		}
	}
	return res;
}

/* order the list based on the compare function cmp */
list * 
list_order(list *l, fcmp cmp, fdup dup)
{
	list *res = list_create(l->destroy);
	node *m, *n = NULL;

	/* use simple insert sort */
	for (n = l->h; n; n = n->next) {
		int append = 1;
		for (m = res->h; m; m = m->next) {
			if (cmp(n->data, m->data) > 0) {
				list_append_before(res, m, dup(n->data));
				append = 0;
			}
		}
		if (append)
			list_append(res, dup(n->data));
	}
	return res;
}


list *
list_distinct(list *l, fcmp cmp, fdup dup)
{
	list *res = list_create(l->destroy);
	node *n = NULL;

	for (n = l->h; n; n = n->next) {
		if (!list_find(res, n->data, cmp)) {
			list_append(res, dup(n->data));
		}
	}
	return res;
}

void *
list_reduce(list *l, freduce red, fdup dup)
{
	void *res = NULL;
	node *n = l->h;

	if (n) {
		res = dup(n->data);
		for (n = n->next; n; n = n->next) {
			res = red(res, dup(n->data));
		}
	}
	return res;
}

list *
list_map(list *l, void *data, fmap map)
{
	list *res = list_create(l->destroy);

	node *n = l->h;

	while (n) {
		void *v = map(n->data, data);

		list_append(res, v);
		n = n->next;
	}
	return res;
}

list *
list_merge(list *l, list *data, fdup dup)
{
	if (data) {
		node *n = data->h;

		while (n) {
			if (dup)
				list_append(l, dup(n->data));
			else
				list_append(l, n->data);
			n = n->next;
		}
	}
	return l;
}

list *
list_merge_destroy(list *l, list *data, fdup dup)
{
	if (data) {
		node *n = data->h;

		while (n) {
			if (dup)
				list_append(l, dup(n->data));
			else
				list_append(l, n->data);
			n = n->next;
		}
	}
	
	list_destroy(data);

	return l;
}

list *
list_dup(list *l, fdup dup)
{
	list *res = list_create(l->destroy);

	return list_merge(res, l, dup);
}


#ifdef TEST
#include <stdio.h>
#include <string.h>

void
print_data(void *dummy, void *data)
{
	printf("%s ", (char *) data);
}

void
destroy_data(void *dummy, void *data)
{
	_DELETE(data);
}

int
main()
{
	list *l = list_create(NULL);

	printf("0 list_length %d\n", list_length(l));
	list_append_string(l, _strdup("niels"));
	printf("1 list_length %d\n", list_length(l));
	list_append_string(l, _strdup("nes"));
	printf("1 list_length %d\n", list_length(l));
	list_append_string(l, _strdup("lilian"));
	printf("1 list_length %d\n", list_length(l));
	list_append_string(l, _strdup("nes"));
	printf("1 list_length %d\n", list_length(l));
	list_append_string(l, _strdup("max"));
	printf("1 list_length %d\n", list_length(l));
	list_append_string(l, _strdup("nes"));
	printf("1 list_length %d\n", list_length(l));
	list_traverse(l, print_data, NULL);
	printf("\n");

	list_traverse(l, destroy_data, NULL);
	list_destroy(l);
}
#endif
