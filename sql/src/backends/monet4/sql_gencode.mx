@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f sql_gencode
@a N.J. Nes
@* 

@h
#ifndef _SQL_GENCODE_H_
#define _SQL_GENCODE_H_

#include "sql_server.h"
#include "sql_session.h"
#include "sql_statement.h"
#include "sql_backend.h"
#include "sql_scope.h"

sql_server_export int backend_dumpstmt(stmt *s, int *nr, backend *sql);
sql_server_export void backend_dumpproc(backend *be, int id, stmt *s);

#endif /*_SQL_GENCODE_H_*/

@c
#include <sql_gencode.h>
#include <sql_env.h>
#include <string.h>

sql_server_export int backend_dumpstmt_(stmt *s, int *nr, backend *sql);

@(
		if (mvc_debug_on(c->mvc,8192)) {
			char *sqzd_cmd = NULL;
			int misq_x = 0;
			CMDsqueezeStr2Str(&sqzd_cmd, cmd, &misq_x);
			if (sqzd_cmd && (sqzd_cmd != str_nil)) {
				/*_DELETE?*/free(cmd);
				cmd = sqzd_cmd;
			}
		}
@)


static void
write_head(backend *sql, int nr)
{
	(void) nr;		/* Stefan: unused!? */

	if (mvc_debug_on(sql->mvc, 2)) {
		char *t0 = "var t0 := usec();\n";
		int l = strlen(t0);

		stream_write(sql->out, t0, 1, l);
	}
}

static void
write_tail(backend *sql, int nr)
{
	if (mvc_debug_on(sql->mvc, 2)) {
		char dbg[BUFSIZ];
		int l = snprintf(dbg, BUFSIZ,
				 "var t1 := usec(); printf(\"%d %%lld\\n\", t1 - t0);\n", nr);

		assert(l < BUFSIZ);
		stream_write(sql->out, dbg, 1, l);
	}
}

static void
write_part(backend *sql, char *buf, int len)
{
	buf[len] = '\0';
	stream_write(sql->out, buf, 1, len);

	if (mvc_debug_on(sql->mvc, 8))
		 fwrite(buf, 1, len, stderr);
}

static void
write_command(backend *sql, char *buf)
{
	if (mvc_debug_on(sql->mvc, 1024 + 2048)) {
		char *s = _strdup(buf), *c = s;
		int ll = strlen(s) + 64, l = 0;
		char *v = NEW_ARRAY(char, ll);

		while ((c = strchr(c, '"')))
			*c = '`';
		c = s;
		while ((c = strchr(c, '\n')))
			*c = '\t';
		l += snprintf(v + l, ll - l, "printf(\"< %s >\\n\");\nfflush(stdout());\n", s);
		l += snprintf(v + l, ll - l, "var t0 := usec();\n");
		_DELETE(s);
		stream_write(sql->out, v, 1, l);
		_DELETE(v);
	}
}

static void
write_result(backend *sql, char *buf)
{
	if (mvc_debug_on(sql->mvc, 1024 + 2048)) {
		size_t l = 0;
		size_t buflen = BUFSIZ;
		char *v = NEW_ARRAY(char, buflen), *a = buf, *b, *y, z;

		l += snprintf(v + l, buflen - l, "var t1 := usec();\n");
		l += snprintf(v + l, buflen - l, "print(t1 - t0);\n");
		while (a && (y = strstr(a, " := "))) {
			z = *y;
			*y = '\0';
			if ((b = strrchr(a, ' ')))
				a = b;
			if (!(b = strrchr(a, '\n')))
				b = a;
			if (9 * strlen(b) + 512 > buflen - l) {
				buflen = 9 * strlen(b) + 512 + l;
				v = RENEW_ARRAY(char, v, buflen);
			}
			l += snprintf(v + l, buflen - l,
				      "if (type(%s) != 4) {"
				      "	print(%s);"
				      "} else {"
				      "	var x := count(%s);"
				      "	printf(\"| %%d * { %%s , %%s } |\\n\",x,head(%s),tail(%s));",
				      b, b, b, b, b);
			assert(l <= buflen);
			if (mvc_debug_on(sql->mvc, 2048)) {
				l += snprintf(v + l, buflen - l,
					      "	if (x < 40) {"
					      "		print(%s);"
					      "	} else {"
					      "		print(slice(%s,0,9));"
					      "		print(\"...\");"
					      "		print(sample(slice(%s,10,x - 11),10));"
					      "		print(\"...\");"
					      "		print(slice(%s,x - 10,x - 1));"
					      "	}", b, b, b, b);
				assert(l <= buflen);
			}
			l += snprintf(v + l, buflen - l, "}\nfflush(stdout());\n");
			assert(l <= buflen);
			stream_write(sql->out, v, 1, l);
			*y = z;
			a = strchr(y, ';');
		}
		_DELETE(v);
	}
}

static void
dump(backend *sql, char *buf, int len, int nr)
{
	if (len == -1)
		len = strlen(buf);
	write_head(sql, nr);
	write_command(sql, buf);
	write_part(sql, buf, len);
	write_result(sql, buf);
	write_tail(sql, nr);
}

static void
backend_dec_nr2(stmt *s)
{
	if (s) {
		if (s->nr2 == int_nil) {
			s->nr2 = s->ref.refcnt;
#ifndef NDEBUG
			printf("= sql_gencode.mx: backend_dec_nr2: usage count of statement %s (%d) was not initialized!\n", st_type2string(s->type), (int) s->type);
		} else if (s->nr2 == 0) {
			printf("= sql_gencode.mx: backend_dec_nr2: (result of) statement %s (%d) is used more often than its refcnt (%d) indicates!\n", st_type2string(s->type), (int) s->type, s->ref.refcnt);
#endif
		}
		s->nr2--;
	}
}

static void
backend_dump_nil(backend *sql, stmt *s)
{
	if (s) {
		backend_dec_nr2(s);
		if (s->nr2 == 0) {
#define BUFLEN 32
			char buf[BUFLEN];
			size_t len = 0;

			assert(s->nr >= 0);
			len = snprintf(buf, BUFLEN - 1, "s%d := nil;\n", s->nr);
			assert(len < BUFLEN);
			buf[len] = '\0';
			write_command(sql, buf);
			write_part(sql, buf, len);
		}
	}
}

void
mvc_dump_1(backend *sql, stmt *s, char *name, int *nr)
{
	int o1 = backend_dumpstmt_(s->op1.stval, nr, sql);
	size_t buflen = strlen(name) + 64;
	char *buf = NEW_ARRAY(char, buflen);
	size_t len = snprintf(buf, buflen,
			      "var s%d := mvc_%s(myc, s%d);\n",
			      -s->nr, name, o1);

	assert(len <= buflen);
	dump(sql, buf, len, -s->nr);
	_DELETE(buf);
	backend_dump_nil(sql, s->op1.stval);
}

void
mvc_dump_2(backend *sql, stmt *s, char *name, int *nr)
{
	int o1 = backend_dumpstmt_(s->op1.stval, nr, sql);
	int o2 = backend_dumpstmt_(s->op2.stval, nr, sql);
	size_t buflen = strlen(name) + 64;
	char *buf = NEW_ARRAY(char, buflen);
	size_t len = snprintf(buf, buflen,
			      "var s%d := mvc_%s(myc, s%d, s%d);\n",
			      -s->nr, name, o1, o2);

	assert(len <= buflen);
	dump(sql, buf, len, -s->nr);
	_DELETE(buf);
	backend_dump_nil(sql, s->op1.stval);
	backend_dump_nil(sql, s->op2.stval);
}

void
dump_1(backend *sql, stmt *s, char *name, int *nr)
{
	int o1 = backend_dumpstmt_(s->op1.stval, nr, sql);
	size_t buflen = strlen(name) + 64;
	char *buf = NEW_ARRAY(char, buflen);
	size_t len = snprintf(buf, buflen,
			      "var s%d := s%d.%s();\n",
			      -s->nr, o1, name);

	assert(len <= buflen);
	dump(sql, buf, len, -s->nr);
	_DELETE(buf);
	backend_dump_nil(sql, s->op1.stval);
}

void
dump_2(backend *sql, stmt *s, char *name, int *nr)
{
	int o1 = backend_dumpstmt_(s->op1.stval, nr, sql);
	int o2 = backend_dumpstmt_(s->op2.stval, nr, sql);
	size_t buflen = strlen(name) + 64;
	char *buf = NEW_ARRAY(char, buflen);
	size_t len = snprintf(buf, buflen,
			      "var s%d := %s(s%d, s%d);\n",
			      -s->nr, name, o1, o2);

	assert(len <= buflen);
	dump(sql, buf, len, -s->nr);
	_DELETE(buf);
	backend_dump_nil(sql, s->op1.stval);
	backend_dump_nil(sql, s->op2.stval);
}

void
dump_3(backend *sql, stmt *s, char *name, int *nr)
{
	int o1 = backend_dumpstmt_(s->op1.stval, nr, sql);
	int o2 = backend_dumpstmt_(s->op2.stval, nr, sql);
	int o3 = backend_dumpstmt_(s->op3.stval, nr, sql);
	size_t buflen = strlen(name) + 64;
	char *buf = NEW_ARRAY(char, buflen);
	size_t len = snprintf(buf, buflen,
			      "var s%d := %s(s%d, s%d, s%d);\n",
			      -s->nr, name, o1, o2, o3);

	assert(len <= buflen);
	dump(sql, buf, len, -s->nr);
	_DELETE(buf);
	backend_dump_nil(sql, s->op1.stval);
	backend_dump_nil(sql, s->op2.stval);
	backend_dump_nil(sql, s->op3.stval);
}

int
backend_dumpstmt_(stmt *s, int *nr, backend *sql)
{
	char *buf = NULL;
	size_t len = 0;
	node *n;

	assert(*nr);

	if (s) {
		if (s->nr2 == int_nil)
			s->nr2 = s->ref.refcnt;

		if (s->nr > 0)
			return s->nr;

		if (s->nr == 0)
			s->nr = -(*nr)++;

		switch (s->type) {
		case st_none:{
			int buflen = 64;
			buf = NEW_ARRAY(char, buflen + 1);

			strcpy(buf, "var none := \"none\";\n");
			dump(sql, buf, -1, -s->nr);
			_DELETE(buf);
		} break;
		case st_sql:
			mvc_dump_1(sql, s, "sql", nr);
			break;
		case st_var:{
			if (s->op1.sval) {
				size_t buflen = strlen(s->op1.sval) + 32;
				buf = NEW_ARRAY(char, buflen + 1);

				len = snprintf(buf, buflen, "var s%d := %s;\n", -s->nr, s->op1.sval);
				assert(len <= buflen);
				/* This is necessary because named st_var's are 
				 * also stored in the mvc param list 
				 */
				backend_dec_nr2(s);
			} else {
				size_t buflen = 32;
				buf = NEW_ARRAY(char, buflen + 1);

				len = snprintf(buf, buflen, "var s%d := A%d;\n", -s->nr, s->flag);
				assert(len <= buflen);
			}
			dump(sql, buf, len, -s->nr);
			_DELETE(buf);
			break;
		}
		case st_update_var:{
			mvc_dump_1(sql, s, "update_var", nr);
			break;
		}
		case st_seq_next:{
			mvc_dump_1(sql, s, "next_value", nr);
			break;
		}
		case st_temp:{
			size_t buflen = strlen(s->op4.typeval->type->base.name) + 64;
			buf = NEW_ARRAY(char, buflen + 1);

			len = snprintf(buf, buflen, "var s%d := new(void,%s).seqbase(oid(0));\n", -s->nr, s->op4.typeval->type->base.name);
			assert(len <= buflen);
			dump(sql, buf, len, -s->nr);
			_DELETE(buf);
			break;
		}
		case st_column:
			s->nr = -backend_dumpstmt_(s->op1.stval, nr, sql);
			backend_dec_nr2(s->op1.stval);
			break;
		case st_bat:
		case st_ubat:{
			char *type = (s->type == st_bat) ? "" : "_ubat";
			char *hname = NULL;
			size_t buflen = 128 + strlen(type) + strlen(s->op1.cval->t->s->base.name) + strlen(s->op1.cval->t->base.name) + strlen(s->op1.cval->base.name);

			if (s->h->type == st_basetable) {
				hname = s->h->op1.tval->base.name;
				buflen += strlen(hname);
			}
			buf = NEW_ARRAY(char, buflen + 1);

			len = snprintf(buf, buflen, "var s%d := mvc_bind%s(myc, \"%s\", \"%s\", \"%s\", %d)", -s->nr, type, s->op1.cval->t->s->base.name, s->op1.cval->t->base.name, s->op1.cval->base.name, s->flag);
			assert(len <= buflen);

			len += snprintf(buf + len, buflen - len, "; #%s\n", hname ? hname : "");
			assert(len <= buflen);
			if (mvc_debug_on(sql->mvc, 4)) {
				len += snprintf(buf + len, buflen - len, "s%d.info().print();", -s->nr);
				assert(len <= buflen);
			}
			/*dump(sql,buf,len,-s->nr); */
			write_head(sql, -s->nr);
			write_command(sql, buf);
			write_part(sql, buf, len);
			write_result(sql, buf);
			write_tail(sql, -s->nr);
			_DELETE(buf);
			break;
		}
		case st_dbat:{
			size_t buflen = 128 + strlen(s->op1.tval->s->base.name) + strlen(s->op1.tval->base.name);
			buf = NEW_ARRAY(char, buflen + 1);

			len = snprintf(buf, buflen, "var s%d := mvc_bind_dbat(myc, \"%s\", \"%s\", %d)", -s->nr, s->op1.tval->s->base.name, s->op1.tval->base.name, s->flag);
			assert(len <= buflen);

			len += snprintf(buf + len, buflen - len, ";\n");
			assert(len <= buflen);
			if (mvc_debug_on(sql->mvc, 4)) {
				len += snprintf(buf + len, buflen - len, "s%d.info().print();\n", -s->nr);
				assert(len <= buflen);
			}
			dump(sql, buf, len, -s->nr);
			_DELETE(buf);
			break;
		}
		case st_idxbat:{
			size_t buflen = 128 + strlen(s->op1.idxval->t->s->base.name) + strlen(s->op1.idxval->t->base.name) + strlen(s->op1.idxval->base.name);
			buf = NEW_ARRAY(char, buflen + 1);

			len = snprintf(buf, buflen, "var s%d := mvc_bind_idxbat(myc, \"%s\", \"%s\", \"%s\", %d)", -s->nr, s->op1.idxval->t->s->base.name, s->op1.idxval->t->base.name, s->op1.idxval->base.name, s->flag);
			assert(len <= buflen);

			len += snprintf(buf + len, buflen - len, ";\n");
			assert(len <= buflen);
			if (mvc_debug_on(sql->mvc, 4)) {
				len += snprintf(buf + len, buflen - len, "s%d.info().print();\n", -s->nr);
				assert(len <= buflen);
			}
			dump(sql, buf, len, -s->nr);
			_DELETE(buf);
			break;
		}
		case st_const:
			dump_2(sql, s, "project", nr);
			break;
		case st_mark:
			dump_2(sql, s, "sql_mark", nr);
			break;
		case st_gen_group:
			dump_1(sql, s, "group", nr);
			break;
		case st_reverse:
			dump_1(sql, s, "reverse", nr);
			break;
		case st_mirror:
			dump_1(sql, s, "mirror", nr);
			break;
		case st_limit:{
			int l = backend_dumpstmt_(s->op1.stval, nr, sql);
			int r1 = backend_dumpstmt_(s->op2.stval, nr, sql);
			int r2 = backend_dumpstmt_(s->op3.stval, nr, sql);
			if (s->flag) { /* topN direction */
				buf = NEW_ARRAY(char, BUFSIZ + 1);

				len = snprintf(buf, BUFSIZ, "var s%dT := s%d.pqueue_topn(s%d + s%d, %d);\n", -s->nr, l, r1, r2, s->flag-1);
				len += snprintf(buf+len, BUFSIZ-len, "var s%d := s%dT.slice(s%d, s%d + s%d - 1);\n", -s->nr, -s->nr, r1, r1, r2);
				dump(sql, buf, len, -s->nr);
			} else {
				buf = NEW_ARRAY(char, BUFSIZ + 1);

				len = snprintf(buf, BUFSIZ, "var s%d := s%d.slice(s%d, s%d + s%d - 1);\n", -s->nr, l, r1, r1, r2);
				dump(sql, buf, len, -s->nr);
			}
			_DELETE(buf);
			backend_dump_nil(sql, s->op1.stval);
			backend_dump_nil(sql, s->op2.stval);
			backend_dump_nil(sql, s->op3.stval);
			break;
		}
		case st_order:{
			int l = backend_dumpstmt_(s->op1.stval, nr, sql);
			buf = NEW_ARRAY(char, BUFSIZ + 1);

			if (s->flag)
				len = snprintf(buf, BUFSIZ, "var s%d := s%d.reverse().sort()", -s->nr, l);
			else
				len = snprintf(buf, BUFSIZ, "var s%d := s%d.reverse().sort_rev()", -s->nr, l);
			len += snprintf(buf + len, BUFSIZ - len, ".reverse();\n");
			dump(sql, buf, len, -s->nr);
			_DELETE(buf);
			backend_dump_nil(sql, s->op1.stval);
			break;
		}
		case st_reorder:{
			int l = backend_dumpstmt_(s->op1.stval, nr, sql);
			int r = backend_dumpstmt_(s->op2.stval, nr, sql);
			buf = NEW_ARRAY(char, BUFSIZ + 1);

			if (s->flag)
				len = snprintf(buf, BUFSIZ, "var s%d := s%d.CTrefine(s%d)", -s->nr, l, r);
			else
				len = snprintf(buf, BUFSIZ, "var s%d := s%d.CTrefine_rev(s%d)", -s->nr, l, r);
			len += snprintf(buf + len, BUFSIZ - len, ";\n");
			dump(sql, buf, len, -s->nr);
			_DELETE(buf);
			backend_dump_nil(sql, s->op1.stval);
			backend_dump_nil(sql, s->op2.stval);
			break;
		}

		case st_select:
		case st_uselect:{
			int l = backend_dumpstmt_(s->op1.stval, nr, sql);
			int r = backend_dumpstmt_(s->op2.stval, nr, sql);
			buf = NEW_ARRAY(char, BUFSIZ + 1);

			if (s->op2.stval->nrcols >= 1) {
				char *op = "=";

				switch (s->flag) {
				case cmp_equal:
					op = "=";
					break;
				case cmp_notequal:
					op = "!=";
					break;
				case cmp_lt:
					op = "<";
					break;
				case cmp_lte:
					op = "<=";
					break;
				case cmp_gt:
					op = ">";
					break;
				case cmp_gte:
					op = ">=";
					break;
				default:
					len = snprintf(buf, BUFSIZ, "error impossible\n");
				}
				len = snprintf(buf, BUFSIZ, "var s%d := [%s](s%d,s%d).uselect(TRUE);\n", -s->nr, op, l, r);
			} else {
				char *cmd;

				if (s->type == st_select)
					cmd = "select";
				else
					cmd = "uselect";
				switch (s->flag) {
				case cmp_like:{
					int e = backend_dumpstmt_(s->op3.stval, nr, sql);

#ifdef HAVE_LIBPCRE
					len = snprintf(buf, BUFSIZ, "var s%d := like_uselect_pcre(s%d, s%d, s%d);\n", -s->nr, l, r, e);
#else
					len = snprintf(buf, BUFSIZ, "var s%d := like_uselect(s%d, s%d, s%d);\n", -s->nr, l, r, e);
#endif
				} break;
				case cmp_notlike:{
					int e = backend_dumpstmt_(s->op3.stval, nr, sql);

					(void) (*nr)++;
#ifdef HAVE_LIBPCRE
					len = snprintf(buf, BUFSIZ, "var s%d := like_uselect_pcre(s%d, s%d, s%d);\n", *nr, l, r, e);
#else
					len = snprintf(buf, BUFSIZ, "var s%d := like_uselect(s%d, s%d, s%d);\n", *nr, l, r, e);
#endif
					len += snprintf(buf + len, BUFSIZ, "var s%d := s%d.kdiff(s%d);\n", -s->nr, l, *nr);
				} break;
				case cmp_equal:
					len = snprintf(buf, BUFSIZ, "var s%d := s%d.%s(s%d);\n", -s->nr, l, cmd, r);
					break;
				case cmp_notequal:
					(void) (*nr)++;
					len = snprintf(buf, BUFSIZ, "var s%d := s%d.uselect(s%d);\n", *nr, l, r);
					len += snprintf(buf + len, BUFSIZ, "var s%d := s%d.kdiff(s%d);\n", -s->nr, l, *nr);
					break;
				case cmp_lt:
					len = snprintf(buf, BUFSIZ, "var s%d := s%d.%s(%s(nil), s%d, FALSE, FALSE);\n", -s->nr, l, cmd, tail_type(s)->type->base.name, r);
					break;
				case cmp_lte:
					len = snprintf(buf, BUFSIZ, "var s%d := s%d.%s(%s(nil), s%d);\n", -s->nr, l, cmd, tail_type(s)->type->base.name, r);
					break;
				case cmp_gt:
					len = snprintf(buf, BUFSIZ, "var s%d := s%d.%s(s%d, %s(nil), FALSE, FALSE);\n", -s->nr, l, cmd, r, tail_type(s)->type->base.name);
					break;
				case cmp_gte:
					len = snprintf(buf, BUFSIZ, "var s%d := s%d.%s(s%d, %s(nil));\n", -s->nr, l, cmd, r, tail_type(s)->type->base.name);
					break;
				default:
					len = snprintf(buf, BUFSIZ, "error impossible\n");
				}
			}
			dump(sql, buf, len, -s->nr);
			_DELETE(buf);
			backend_dump_nil(sql, s->op1.stval);
			backend_dump_nil(sql, s->op2.stval);
			break;
		}
		case st_select2:
		case st_uselect2:{
			int l = backend_dumpstmt_(s->op1.stval, nr, sql);
			int r1 = backend_dumpstmt_(s->op2.stval, nr, sql);
			int r2 = backend_dumpstmt_(s->op3.stval, nr, sql);
			char *bits = NULL;
			char *cmd;

			if (s->type == st_select2)
				cmd = "select";
			else
				cmd = "uselect";
			switch (s->flag) {
			case 0:
				bits = ", FALSE, FALSE";
				break;
			case 1:
				bits = ", FALSE, TRUE";
				break;
			case 2:
				bits = ", TRUE, FALSE";
				break;
			case 3:
				bits = ", TRUE, TRUE";
				break;
			}
			buf = NEW_ARRAY(char, BUFSIZ + 1);

			len = snprintf(buf, BUFSIZ, "var s%d := s%d.%s(s%d, s%d%s);\n", -s->nr, l, cmd, r1, r2, bits);
			dump(sql, buf, len, -s->nr);
			_DELETE(buf);
			backend_dump_nil(sql, s->op1.stval);
			backend_dump_nil(sql, s->op2.stval);
			backend_dump_nil(sql, s->op3.stval);
			break;
		}
		case st_semijoin:
			dump_2(sql, s, "semijoin", nr);
			break;
		case st_diff:
			dump_2(sql, s, "sql_diff", nr);
			break;
		case st_union:
			dump_2(sql, s, "kunion", nr);
			break;
		case st_reljoin:{
			node *ln = NULL, *rn = NULL;
			buf = NEW_ARRAY(char, BUFSIZ + 1);

			if (list_length(s->op1.lval) == 1) {
				int l = backend_dumpstmt_(s->op1.lval->h->data, nr, sql);
				int r = backend_dumpstmt_(s->op2.lval->h->data, nr, sql);

				len = snprintf(buf, BUFSIZ, "var s%d := join(s%d,reverse(s%d));\n", -s->nr, l, r);
			} else {
				char x = '(';

				len = snprintf(buf, BUFSIZ, "var s%d := ds_link", -s->nr);
				for (ln = s->op1.lval->h, rn = s->op2.lval->h; ln && rn; ln = ln->next, rn = rn->next) {
					int l = backend_dumpstmt_(ln->data, nr, sql);
					int r = backend_dumpstmt_(rn->data, nr, sql);

					len += snprintf(buf + len, BUFSIZ - len, "%c s%d, s%d", x, l, r);
					x = ',';
				}
				len += snprintf(buf + len, BUFSIZ - len, " );\n");
			}
			dump(sql, buf, len, -s->nr);
			_DELETE(buf);
			for (ln = s->op1.lval->h, rn = s->op2.lval->h; ln && rn; ln = ln->next, rn = rn->next) {
				backend_dump_nil(sql, ln->data);
				backend_dump_nil(sql, rn->data);
			}
			break;
		}
		case st_outerjoin:
		case st_join:{
			int l = backend_dumpstmt_(s->op1.stval, nr, sql);
			int r = backend_dumpstmt_(s->op2.stval, nr, sql);
			char *jt = "join";

			if (s->type == st_outerjoin)
				jt = "outerjoin";
			buf = NEW_ARRAY(char, BUFSIZ + 1);

			switch (s->flag) {
			case cmp_equal:
				len = snprintf(buf, BUFSIZ, "var s%d := s%d.%s(s%d);\n", -s->nr, l, jt, r);

				break;
			case cmp_notequal:
				len = snprintf(buf, BUFSIZ, "var s%d := s%d.%s(s%d, \"!=\");\n", -s->nr, l, jt, r);

				break;
			case cmp_lt:
				len = snprintf(buf, BUFSIZ, "var s%d := s%d.%s(s%d, \"<\");\n", -s->nr, l, jt, r);

				break;
			case cmp_lte:
				len = snprintf(buf, BUFSIZ, "var s%d := s%d.%s(s%d, \"<=\");\n", -s->nr, l, jt, r);

				break;
			case cmp_gt:
				len = snprintf(buf, BUFSIZ, "var s%d := s%d.%s(s%d, \">\" );\n", -s->nr, l, jt, r);

				break;
			case cmp_gte:
				len = snprintf(buf, BUFSIZ, "var s%d := s%d.%s(s%d, \">=\" );\n", -s->nr, l, jt, r);

				break;
			case cmp_all:	/* aka cross table */
				len = snprintf(buf, BUFSIZ, "var s%d := s%d.project(0).join(s%d.reverse().project(0).reverse());\n", -s->nr, l, r);
				break;
			default:
				len = snprintf(buf, BUFSIZ, "error impossible\n");
			}
			if (mvc_debug_on(sql->mvc, 4)) {
				len += snprintf(buf + len, BUFSIZ - len, "s%d.info().print();\n", -s->nr);
			}
			dump(sql, buf, len, -s->nr);
			_DELETE(buf);
			backend_dump_nil(sql, s->op1.stval);
			backend_dump_nil(sql, s->op2.stval);
			break;
		}
		case st_group: {
			int l = backend_dumpstmt_(s->op1.stval, nr, sql);
			buf = NEW_ARRAY(char, BUFSIZ + 1);
			len = snprintf(buf, BUFSIZ,
				"var s%dg := s%d.CTgroup();\n", -s->nr, l);
			len += snprintf(buf + len, BUFSIZ - len,
				"var s%d := s%dg.map();\n", -s->nr, -s->nr);
			dump(sql, buf, len, -s->nr);
			_DELETE(buf);
			backend_dump_nil(sql, s->op1.stval);
			break;
		}
		case st_group_ext: {
			int g = backend_dumpstmt_(s->op1.stval, nr, sql);
			buf = NEW_ARRAY(char, BUFSIZ + 1);
			len = snprintf(buf, BUFSIZ,
				"var s%d := s%dg.extend().mirror();\n", -s->nr, g);
			dump(sql, buf, len, -s->nr);
			_DELETE(buf);
			backend_dump_nil(sql, s->op1.stval);
			break;
		}
		case st_derive: {
			int g = backend_dumpstmt_(s->op1.stval, nr, sql);
			int l = backend_dumpstmt_(s->op2.stval, nr, sql);
			buf = NEW_ARRAY(char, BUFSIZ + 1);
			len = snprintf(buf, BUFSIZ,
				"var s%dg := s%d.CTgroup(s%d);\n", -s->nr, g,l);
			len += snprintf(buf + len, BUFSIZ - len,
				"var s%d := s%dg.map();\n", -s->nr, -s->nr);
			dump(sql, buf, len, -s->nr);
			_DELETE(buf);
			backend_dump_nil(sql, s->op1.stval);
			backend_dump_nil(sql, s->op2.stval);
			break;
		}
		case st_unique:{
			int l = backend_dumpstmt_(s->op1.stval, nr, sql);
			buf = NEW_ARRAY(char, BUFSIZ + 1);

			buf[0] = 0;
			if (s->op2.stval) {
				int g = backend_dumpstmt_(s->op2.stval, nr, sql);

				len += snprintf(buf + len, BUFSIZ - len,
						/*"var s%dg := s%d.CTunique(s%d);\n", -s->nr, g, l); */
						"var s%dg := s%d.CTgroup(s%d);\n", -s->nr, g, l);
				len += snprintf(buf + len, BUFSIZ - len, "var s%de := s%dg.extend().mirror();\n", -s->nr, -s->nr);
				/*"var s%de := s%dg.reverse().kunique().mirror();\n", -s->nr, -s->nr); */
				len += snprintf(buf + len, BUFSIZ - len, "var s%d := s%d.semijoin(s%de);\n", -s->nr, l, -s->nr);
			} else {
				len += snprintf(buf + len, BUFSIZ - len, "var s%d := s%d.reverse().kunique().reverse();\n", -s->nr, l);
			}
			dump(sql, buf, len, -s->nr);
			_DELETE(buf);
			backend_dump_nil(sql, s->op1.stval);
			backend_dump_nil(sql, s->op2.stval);
			break;
		}
		case st_convert:{
			char *convert = s->op4.typeval->type->base.name;
			/* convert types and make sure they are rounded up correctly */
			int l = backend_dumpstmt_(s->op1.stval, nr, sql);
			size_t buflen = strlen(s->op4.funcval->func->imp) + 64;

			buf = NEW_ARRAY(char, buflen + 1);

			if (s->op4.typeval->type->eclass == EC_INTERVAL) {
				if (s->op4.typeval->type->localtype == TYPE_int)
					convert = "month_interval";
				else
					convert = "second_interval";
			}

			if (s->op1.stval->nrcols) {
				len = snprintf(buf, buflen, "var s%d := [%s](", -s->nr, convert);
			} else {
				len = snprintf(buf, buflen, "var s%d := %s(", -s->nr, convert);
			}

			if (s->op3.typeval->type->eclass == EC_DEC) 
				len += snprintf(buf+len, buflen-len, "%d, ", s->op3.typeval->scale);
	
			len += snprintf(buf+len, buflen-len, "s%d", l);

			if (s->op4.typeval->type->eclass == EC_DEC ||
			    s->op4.typeval->type->eclass == EC_INTERVAL)
				len += snprintf(buf+len, buflen-len, ", %d, %d", s->op4.typeval->digits, s->op4.typeval->scale);
			len += snprintf(buf+len, buflen-len, ");\n");
			assert(len <= buflen);
			dump(sql, buf, len, -s->nr);
			_DELETE(buf);
			backend_dump_nil(sql, s->op1.stval);
			break;
		}
		case st_op:{
			size_t buflen = strlen(s->op4.funcval->func->imp) + 32;
			buf = NEW_ARRAY(char, buflen + 1);

			len = snprintf(buf, buflen, "var s%d := %s();\n", -s->nr, s->op4.funcval->func->imp);
			assert(len <= buflen);
			dump(sql, buf, len, -s->nr);
			_DELETE(buf);
			break;
		}
		case st_unop:{
			int l = backend_dumpstmt_(s->op1.stval, nr, sql);
			size_t buflen;

			if (s->op1.stval->nrcols) {
				buflen = strlen(s->op4.funcval->func->imp) + 64;
				buf = NEW_ARRAY(char, buflen + 1);

				len = snprintf(buf, buflen, "var s%d := [%s](s%d);\n", -s->nr, s->op4.funcval->func->imp, l);
				assert(len <= buflen);
			} else {
				buflen = strlen(s->op4.funcval->func->imp) + 64;
				buf = NEW_ARRAY(char, buflen + 1);

				len = snprintf(buf, buflen, "var s%d := %s(s%d);\n", -s->nr, s->op4.funcval->func->imp, l);
				assert(len <= buflen);
			}
			dump(sql, buf, len, -s->nr);
			_DELETE(buf);
			backend_dump_nil(sql, s->op1.stval);
			break;
		}
		case st_binop:{
			int l = backend_dumpstmt_(s->op1.stval, nr, sql);
			int r = backend_dumpstmt_(s->op2.stval, nr, sql);
			size_t buflen = strlen(s->op4.funcval->func->imp) + 64;
			buf = NEW_ARRAY(char, buflen + 1);

			if (s->op1.stval->nrcols || s->op2.stval->nrcols) {
				len += snprintf(buf, buflen, "var s%d := [%s](s%d,s%d);\n", -s->nr, s->op4.funcval->func->imp, l, r);
				assert(len <= buflen);
			} else {
				len += snprintf(buf, buflen, "var s%d := %s(s%d,s%d);\n", -s->nr, s->op4.funcval->func->imp, l, r);
				assert(len <= buflen);
			}
			dump(sql, buf, len, -s->nr);
			_DELETE(buf);
			backend_dump_nil(sql, s->op1.stval);
			backend_dump_nil(sql, s->op2.stval);
			break;
		}
		case st_Nop:{
			int opslen = 0;
			char *ops;
			node *n;
			size_t buflen;

			backend_dumpstmt_(s->op1.stval, nr, sql);	/* dump operands */
			write_head(sql, -s->nr);
			if (s->nrcols) {
				stmt *h;

				buflen = 0;
				for (n = s->op1.stval->op1.lval->h, h = n->data; n; n = n->next) {
					stmt *op = n->data;

					if (op->nrcols > h->nrcols)
						h = op;
					buflen += 20;
				}

				ops = NEW_ARRAY(char, buflen);

				for (n = s->op1.stval->op1.lval->h; n; n = n->next) {
					stmt *op = n->data;
					int n = op->nr;

					opslen += snprintf(ops + opslen, buflen - opslen, "%cs%d", (opslen) ? ',' : ' ', n);
				}
				buflen = strlen(s->op4.funcval->func->imp) + opslen + 64;
				buf = NEW_ARRAY(char, buflen + 1);

				len = snprintf(buf, buflen, "var s%d := [%s](%s);\n", -s->nr, s->op4.funcval->func->imp, ops);
				assert(len <= buflen);
			} else {
				buflen = 0;
				for (n = s->op1.stval->op1.lval->h; n; n = n->next)
					buflen += 20;
				ops = NEW_ARRAY(char, buflen);

				for (n = s->op1.stval->op1.lval->h; n; n = n->next) {
					stmt *op = n->data;
					int n = op->nr;

					opslen += snprintf(ops + opslen, buflen - opslen, "%cs%d", (opslen) ? ',' : ' ', n);
				}
				buflen = strlen(s->op4.funcval->func->imp) + opslen + 64;
				buf = NEW_ARRAY(char, buflen + 1);

				len = snprintf(buf, BUFSIZ, "var s%d := %s(%s);\n", -s->nr, s->op4.funcval->func->imp, ops);
				assert(len <= buflen);
			}
			_DELETE(ops);
			write_part(sql, buf, len);
			write_command(sql, buf);
			write_result(sql, buf);
			write_tail(sql, -s->nr);
			_DELETE(buf);
			backend_dec_nr2(s->op1.stval);
			break;
		}
		case st_aggr:{
			int l = backend_dumpstmt_(s->op1.stval, nr, sql);
			size_t buflen = strlen(s->op4.aggrval->aggr->imp) + 64;
			buf = NEW_ARRAY(char, buflen + 1);

			if (s->flag) {
				int l2 = backend_dumpstmt_(s->op2.stval, nr, sql);

				len += snprintf(buf + len, buflen - len, "var s%d := %s(s%d, s%d);\n", -s->nr, s->op4.aggrval->aggr->imp, l, l2);
				assert(len <= buflen);
			} else if (s->op3.gval) {
				int g = backend_dumpstmt_(s->op2.stval, nr, sql);
				int e = backend_dumpstmt_(s->op3.stval, nr, sql);

				len += snprintf(buf + len, buflen - len, "var s%d := {%s}(s%d, s%d, s%d);\n", -s->nr, s->op4.aggrval->aggr->imp, l, g, e);
				assert(len <= buflen);
			} else {
				len += snprintf(buf + len, buflen - len, "var s%d := s%d.%s();\n", -s->nr, l, s->op4.aggrval->aggr->imp);
				assert(len <= buflen);
			}
			dump(sql, buf, len, -s->nr);
			_DELETE(buf);
			backend_dump_nil(sql, s->op1.stval);
			if (s->flag) {
				backend_dump_nil(sql, s->op2.stval);
			} else if (s->op3.gval) {
				backend_dump_nil(sql, s->op2.stval);
				backend_dump_nil(sql, s->op3.stval);
			}
			break;
		}
		case st_atom:{
			write_head(sql, -s->nr);
			buf = NEW_ARRAY(char, BUFSIZ + 1);

			len = snprintf(buf, BUFSIZ, "var s%d := ", -s->nr);
			write_command(sql, buf);
			write_part(sql, buf, len);
			atom_dump(s->op1.aval, sql->out);
			len = snprintf(buf, BUFSIZ, ";\n");
			write_part(sql, buf, len);
			len = snprintf(buf, BUFSIZ, "var s%d := ", -s->nr);
			write_result(sql, buf);
			write_tail(sql, -s->nr);
			_DELETE(buf);
			break;
		}
		case st_insert:{
			int l = backend_dumpstmt_(s->op1.stval, nr, sql);
			int r = backend_dumpstmt_(s->op2.stval, nr, sql);
			buf = NEW_ARRAY(char, BUFSIZ + 1);

			if (s->op2.stval->nrcols) {
				len = snprintf(buf, BUFSIZ, "var s%d := insert(s%d.access(BAT_WRITE),s%d);\n", -s->nr, l, r);
			} else {
				len = snprintf(buf, BUFSIZ, "var s%d := insert(s%d,s%d);\n", -s->nr, l, r);
			}
			dump(sql, buf, len, -s->nr);
			_DELETE(buf);
			backend_dump_nil(sql, s->op1.stval);
			backend_dump_nil(sql, s->op2.stval);
			break;
		}
		case st_append:{
			int l = backend_dumpstmt_(s->op1.stval, nr, sql);
			int r = backend_dumpstmt_(s->op2.stval, nr, sql);
			buf = NEW_ARRAY(char, BUFSIZ + 1);

			len = snprintf(buf, BUFSIZ, "var s%d := append(s%d.access(BAT_WRITE),s%d);\n", -s->nr, l, r);
			dump(sql, buf, len, -s->nr);
			_DELETE(buf);
			backend_dump_nil(sql, s->op1.stval);
			backend_dump_nil(sql, s->op2.stval);
			break;
		}
		case st_replace:{
			int l = backend_dumpstmt_(s->op1.stval, nr, sql);
			int r = backend_dumpstmt_(s->op2.stval, nr, sql);
			char *f = (s->op1.stval->type == st_bat ||
				   s->op1.stval->type == st_idxbat)?
				"inplace":"replace";
			buf = NEW_ARRAY(char, BUFSIZ + 1);

			len += snprintf(buf, BUFSIZ, "var s%d := %s(s%d.access(BAT_WRITE),s%d);\n", -s->nr, f, l, r);
			dump(sql, buf, len, -s->nr);
			_DELETE(buf);
			backend_dump_nil(sql, s->op1.stval);
			backend_dump_nil(sql, s->op2.stval);
			break;
		}
		case st_table_clear:{
			sql_table *t = s->op1.tval;
			size_t buflen = strlen(t->base.name) + strlen(t->s->base.name) + 64;
			buf = NEW_ARRAY(char, buflen + 1);

			len = snprintf(buf, buflen, "var s%d := mvc_clear_table(myc, \"%s\", \"%s\");\n", -s->nr, t->s->base.name, t->base.name);
			assert(len <= buflen);
			dump(sql, buf, len, -s->nr);
			_DELETE(buf);
			break;
		}
		case st_exception:{
			int l = backend_dumpstmt_(s->op1.stval, nr, sql);
			int r = backend_dumpstmt_(s->op2.stval, nr, sql);
			buf = NEW_ARRAY(char, BUFSIZ + 1);

			len += snprintf(buf, BUFSIZ, "if (bit(s%d)){ ERROR(s%d); }\n", l, r);
			dump(sql, buf, len, -s->nr);
			_DELETE(buf);
			backend_dump_nil(sql, s->op1.stval);
			backend_dump_nil(sql, s->op2.stval);
			break;
		}
		case st_alias:
			s->nr = -backend_dumpstmt_(s->op1.stval, nr, sql);
			backend_dec_nr2(s->op1.stval);
			break;
		case st_set:
		case st_list:{
			for (n = s->op1.lval->h; n; n = n->next) {
				(void) backend_dumpstmt_(n->data, nr, sql);
				backend_dec_nr2(n->data);
			}
			break;
		}
		case st_sets:{
			for (n = s->op1.lval->h; n; n = n->next) {
				list *l = n->data;
				node *m = l->h;

				while (m) {
					(void) backend_dumpstmt_(m->data, nr, sql);
					backend_dec_nr2(m->data);
					m = m->next;
				}
			}
			break;
		}
		case st_find:
			dump_2(sql, s, "find", nr);
			break;
		case st_bulkinsert:{
			char *tname = s->op1.stval->op1.tval->base.name;
			int sep = backend_dumpstmt_(s->op2.stval, nr, sql);
			int rsep = backend_dumpstmt_(s->op3.stval, nr, sql);
			size_t buflen = strlen(tname) + 512;

			buf = NEW_ARRAY(char, buflen + 1);

			if (s->op4.stval) {
				int file = backend_dumpstmt_(s->op4.stval, nr, sql);

				len += snprintf(buf + len, buflen - len, "var f%ds := open_rastream(iconv(s%d, \"UTF-8\", codeset()));\n", file, file);
				assert(len <= buflen);
				len += snprintf(buf + len, buflen - len, "var f%d := bstream_create(f%ds, 1024*1024);\n", file, file);
				assert(len <= buflen);
				len += snprintf(buf + len, buflen - len, "var s%d := mvc_import_table( myc, f%d, \"%s\", s%d, s%d, %d);\n", -s->nr, file, tname, sep, rsep, s->flag);
				assert(len <= buflen);
				len += snprintf(buf + len, buflen - len, "bstream_destroy(f%d);\n", file);
				assert(len <= buflen);
				len += snprintf(buf + len, buflen - len, "stream_close(f%ds);\n", file);
				assert(len <= buflen);
			} else {
				len += snprintf(buf + len, buflen - len, "var s%d := mvc_import_table( myc, Input, \"%s\", s%d, s%d, %d);\n", -s->nr, tname, sep, rsep, s->flag);
				assert(len <= buflen);
			}
			dump(sql, buf, len, -s->nr);
			_DELETE(buf);
			backend_dump_nil(sql, s->op2.stval);
			backend_dump_nil(sql, s->op3.stval);
			backend_dump_nil(sql, s->op4.stval);
			break;
		}
		case st_filter:
			s->nr = -backend_dumpstmt_(s->op1.stval, nr, sql);
			backend_dec_nr2(s->op1.stval);
			break;
		case st_ordered:{
			int l = backend_dumpstmt_(s->op1.stval, nr, sql);

			(void) backend_dumpstmt_(s->op2.stval, nr, sql);
			s->nr = -l;
			backend_dec_nr2(s->op1.stval);
			backend_dec_nr2(s->op2.stval);
			break;
		}
		case st_output:{
			stmt *order = NULL;
			stmt *lst = s->op1.stval;
			size_t buflen = BUFSIZ;

			backend_dumpstmt_(lst, nr, sql);

			write_head(sql, -s->nr);
			buf = NEW_ARRAY(char, buflen + 1);

			buf[0] = 0;
			len = 0;
			if (lst->type == st_ordered) {
				order = lst->op1.stval;
				lst = lst->op2.stval;
			}
			if (lst->type == st_list) {
				list *l = lst->op1.lval;
				int cnt = list_length(l);

				n = l->h;
				if (n) {
					if (!order) {
						order = n->data;
					}
				}
				if (buflen - len < 128) {
					buflen += BUFSIZ;
					buf = RENEW_ARRAY(char, buf, buflen);
				}
				len = snprintf(buf, buflen, "var s%d := mvc_result_table(myc, %d, s%d);\n", -s->nr, cnt, order->nr);
				assert(len <= buflen);
				write_command(sql, buf);
				write_part(sql, buf, len);
				len = 0;
				for (; n; n = n->next) {
					stmt *r = n->data;
					char *tname = table_name(r);
					char *tn = (tname) ? tname : "";
					char *cn = column_name(r);
					size_t sl;

					sl = strlen(tn) + strlen(cn) + strlen(tail_type(r)->type->sqlname);
					if (buflen - len < 128 + sl) {
						buflen += BUFSIZ + sl;
						buf = RENEW_ARRAY(char, buf, buflen);
					}
					len = snprintf(buf, buflen, "mvc_result_column(myc, \"%s\", \"%s\", \"%s\", %d, %d, s%d);\n", tn, cn, tail_type(r)->type->sqlname, tail_type(r)->digits, tail_type(r)->scale, r->nr);
					assert(len <= buflen);
					_DELETE(cn);
					if (tname)
						_DELETE(tname);
					write_command(sql, buf);
					write_part(sql, buf, len);
					len = 0;
				}
				if (buflen - len < 256) {
					buflen += BUFSIZ;
					buf = RENEW_ARRAY(char, buf, buflen);
				}
				len = snprintf(buf, buflen, "mvc_export_result(myc, Output, s%d);\n", -s->nr);
				assert(len <= buflen);
				/* send first part (or all) */
				len += snprintf(buf + len, buflen - len, "mvc_export_table(myc, Output, s%d, 0, %d);\n", -s->nr, sql->mvc->reply_size);

				assert(len <= buflen);
				write_command(sql, buf);
				write_part(sql, buf, len);
				len = 0;
			} else {
				fprintf(stderr, "not a valid output list %d %d %d\n", lst->type, st_list, st_ordered);
			}
			write_tail(sql, -s->nr);
			_DELETE(buf);
			backend_dec_nr2(s->op1.stval);
			break;
		}

			/* should not appear here */
		case st_relselect:
		case st_intersect:
			/* todo */

		case st_basetable:	/* relation(table) */
		case st_ptable:
		case st_pivot:
		case st_groupby:
			printf("backend_dumpstmt_: not implemented stmt %s\n", st_type2string(s->type));
			assert(0);
		}

		if (s->nr > 0)
			assert(s->nr <= 0);
		else
			s->nr = -s->nr;

		return s->nr;
	}
	return 0;
}

int
backend_dumpstmt(stmt *s, int *nr, backend *sql)
{
	int ret = 0;

	stream_write(sql->out, "{\n", 2, 1);
	if (mvc_debug_on(sql->mvc, 2 + 1024 + 2048)) {
		char *t0 = "var t00 := time();\n";
		int l = strlen(t0);

		stream_write(sql->out, t0, 1, l);
	}
	ret = backend_dumpstmt_(s, nr, sql);
	backend_dec_nr2(s);
	if (mvc_debug_on(sql->mvc, 2 + 1024 + 2048)) {
		char dbg[BUFSIZ];
		int l = snprintf(dbg, BUFSIZ,
				 "var t11 := time(); printf(\"# wall-clock: %%d ms\\n\", t11 - t00);\n");

		assert(l < BUFSIZ);
		stream_write(sql->out, dbg, 1, l);
	}
	stream_write(sql->out, "}\n", 2, 1);
	return ret;
}

void
backend_dumpproc(backend *be, int id, stmt *s)
{
	int nr = 1;
	int i = 0;
	char buf[BUFSIZ];
	node *n;

	i = snprintf(buf, BUFSIZ, "proc sql%d (", id);

	if (be->mvc->args) {
		int argc = 0;

		for (n = be->mvc->args->h; n; n = n->next, argc++) {
			atom *a = n->data;

			i += snprintf(buf + i, BUFSIZ - i, "%s A%d%c", a->tpe->type->base.name, argc, (n->next) ? ',' : ' ');
		}
	} else if (be->mvc->params) {
		int argc = 0;

		for (n = be->mvc->params->h; n; n = n->next, argc++) {
			var_ *v = n->data;

			i += snprintf(buf + i, BUFSIZ - i, "%s A%d%c", tail_type(v->s)->type->base.name, argc, (n->next) ? ',' : ' ');
		}
	}
	i += snprintf(buf + i, BUFSIZ - i, ") : void \n");
	stream_write(be->out, buf, i, 1);

	backend_dumpstmt(s, &nr, be);
}
