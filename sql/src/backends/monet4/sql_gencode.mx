@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2007 CWI.
@' All Rights Reserved.

@f sql_gencode
@a N.J. Nes
@* 

@h
#ifndef _SQL_GENCODE_H_
#define _SQL_GENCODE_H_

#include "sql_server.h"
#include "sql_session.h"
#include "sql_symbol.h"
#include "sql_statement.h"
#include "sql_backend.h"
#include "sql_scope.h"
#include "sql_qc.h"

sql_server_export backend *backend_create(mvc *c, int console);
sql_server_export void backend_destroy(backend *b);

sql_server_export int backend_call(backend *be, mvc *c, cq *q);
sql_server_export int backend_fastpath(backend *be, mvc *c, cq *q);
sql_server_export int backend_dump(backend *be, cq *q, stmt *s);
sql_server_export int backend_explain(backend *be, stmt *s, stream *out);
sql_server_export int backend_exec_prepared_stmt( backend *be, cq *q );

sql_server_export void monet4_freecode(backend_code code, backend_stack stk, int nr, char *name);

#endif /*_SQL_GENCODE_H_*/

@c
#include "sql_config.h"
#include <sql_gencode.h>
#include <sql_privileges.h>
#include <sql_env.h>
#include <string.h>
#include <sql_result.h>
#include <sql_semantic.h>

#include <sql_optimize.h>
#include <sql_rel2bin.h>

static int backend_dumpstmt(stmt *s, int *nr, backend *sql);
static int backend_dumpstmt_(stmt *s, int *nr, backend *sql);
static void backend_create_func(backend *be, sql_func *f);

@(
		if (mvc_debug_on(c->mvc,8192)) {
			char *sqzd_cmd = NULL;
			int misq_x = 0;
			CMDsqueezeStr2Str(&sqzd_cmd, cmd, &misq_x);
			if (sqzd_cmd && (sqzd_cmd != str_nil)) {
				/*_DELETE?*/free(cmd);
				cmd = sqzd_cmd;
			}
		}
@)


static void
write_head(backend *sql, int nr)
{
	(void) nr;		/* Stefan: unused!? */

	if (mvc_debug_on(sql->mvc, 2)) {
		char *t0 = "var t0 := usec();\n";
		int l = _strlen(t0);

		stream_write(sql->out, t0, 1, l);
	}
}

static void
write_tail(backend *sql, int nr)
{
	if (mvc_debug_on(sql->mvc, 2)) {
		char dbg[BUFSIZ];
		int l = snprintf(dbg, BUFSIZ,
				 "var t1 := usec(); printf(\"%d: %%lld us\\n\", t1 - t0);\n", nr);

		assert(l < BUFSIZ);
		stream_write(sql->out, dbg, 1, l);
	}
}

static void
write_part(backend *sql, char *buf, size_t len)
{
	buf[len] = '\0';
	stream_write(sql->out, buf, 1, len);

	if (mvc_debug_on(sql->mvc, 8))
		fprintf(stderr, "%.*s", (int) len, buf);
}

static void
write_command(backend *sql, char *buf)
{
	if (mvc_debug_on(sql->mvc, 1024 + 2048)) {
		char *s = _strdup(buf), *c = s;
		int ll = _strlen(s) + 64, l = 0;
		char *v = NEW_ARRAY(char, ll);

		while ((c = strchr(c, '"')))
			*c = '`';
		c = s;
		while ((c = strchr(c, '\n')))
			*c = '\t';
		l += snprintf(v + l, ll - l, "printf(\"< %s >\\n\");\nfflush(stdout());\n", s);
		l += snprintf(v + l, ll - l, "var t0 := usec();\n");
		_DELETE(s);
		stream_write(sql->out, v, 1, l);
		_DELETE(v);
	}
}

static void
write_result(backend *sql, char *buf)
{
	if (mvc_debug_on(sql->mvc, 1024 + 2048)) {
		size_t l = 0;
		size_t buflen = BUFSIZ;
		char *v = NEW_ARRAY(char, buflen), *a = buf, *b, *y, z;

		l += snprintf(v + l, buflen - l, "var t1 := usec();\n");
		l += snprintf(v + l, buflen - l, "printf(\"( %%.6f s )\\n\", (t1 - t0)/1000000.0);\n");
		while (a && (y = strstr(a, " := "))) {
			z = *y;
			*y = '\0';
			if ((b = strrchr(a, ' ')))
				a = b;
			if (!(b = strrchr(a, '\n')))
				b = a;
			if (9 * strlen(b) + 512 > buflen - l) {
				buflen = 9 * strlen(b) + 512 + l;
				v = RENEW_ARRAY(char, v, buflen);
			}
			l += snprintf(v + l, buflen - l,
				      "if (type(%s) != bat) {"
				      "	print(%s);"
				      "} else {"
				      "	var x := count(%s);"
				      "	printf(\"| %%d * { %%s , %%s } |\\n\",x,head(%s),tail(%s));",
				      b, b, b, b, b);
			assert(l <= buflen);
			if (mvc_debug_on(sql->mvc, 2048)) {
				l += snprintf(v + l, buflen - l,
					      "	if (x < 40) {"
					      "		print(%s);"
					      "	} else {"
					      "		print(slice(%s,0,9));"
					      "		print(\"...\");"
					      "		print(sample(slice(%s,10,x - 11),10));"
					      "		print(\"...\");"
					      "		print(slice(%s,x - 10,x - 1));"
					      "	}", b, b, b, b);
				assert(l <= buflen);
			}
			l += snprintf(v + l, buflen - l, "}\nfflush(stdout());\n");
			assert(l <= buflen);
			stream_write(sql->out, v, 1, l);
			*y = z;
			a = strchr(y, ';');
		}
		_DELETE(v);
	}
}

static void
dump(backend *sql, char *buf, int len, int nr)
{
	if (len == -1)
		len = _strlen(buf);
	write_head(sql, nr);
	write_command(sql, buf);
	write_part(sql, buf, len);
	write_result(sql, buf);
	write_tail(sql, nr);
}

static void
backend_dec_nr2(stmt *s)
{
	if (s) {
		if (s->nr2 == int_nil) {
			s->nr2 = s->ref.refcnt;
#ifndef NDEBUG
			printf("= sql_gencode.mx: backend_dec_nr2: usage count of statement %s (%d) was not initialized!\n", st_type2string(s->type), (int) s->type);
		} else if (s->nr2 == 0) {
			printf("= sql_gencode.mx: backend_dec_nr2: (result of) statement %s (%d) is used more often than its refcnt (%d) indicates!\n", st_type2string(s->type), (int) s->type, s->ref.refcnt);
#endif
		}
		s->nr2--;
		if (s->type == st_list || s->type == st_set) {
			node *n;
			for (n = s->op1.lval->h; n; n = n->next) 
				backend_dec_nr2(n->data);
		}
	}
}

static void
backend_dump_nil(backend *sql, stmt *s)
{
	if (s) {
		backend_dec_nr2(s);
		if (s->nr2 == 0) {
#define BUFLEN 32
			char buf[BUFLEN];
			size_t len = 0;

			assert(s->nr >= 0);
			len = snprintf(buf, BUFLEN - 1, "s%d := nil;\n", s->nr);
			assert(len < BUFLEN);
			buf[len] = '\0';
			write_command(sql, buf);
			write_part(sql, buf, len);
		}
	}
}

void
mvc_dump_1(backend *sql, stmt *s, char *name, int *nr)
{
	int o1 = backend_dumpstmt_(s->op1.stval, nr, sql);
	size_t buflen = strlen(name) + 64;
	char *buf = NEW_ARRAY(char, buflen);
	size_t len = snprintf(buf, buflen,
			   "var s%d := mvc_%s(myc, s%d);\n",
			   -s->nr, name, o1);

	assert(len <= buflen);
	dump(sql, buf, len, -s->nr);
	_DELETE(buf);
	backend_dump_nil(sql, s->op1.stval);
}

void
mvc_dump_2(backend *sql, stmt *s, char *name, int *nr)
{
	int o1 = backend_dumpstmt_(s->op1.stval, nr, sql);
	int o2 = backend_dumpstmt_(s->op2.stval, nr, sql);
	size_t buflen = strlen(name) + 64;
	char *buf = NEW_ARRAY(char, buflen);
	size_t len = snprintf(buf, buflen,
			   "var s%d := mvc_%s(myc, s%d, s%d);\n",
			   -s->nr, name, o1, o2);

	assert(len <= buflen);
	dump(sql, buf, len, -s->nr);
	_DELETE(buf);
	backend_dump_nil(sql, s->op1.stval);
	backend_dump_nil(sql, s->op2.stval);
}

void
dump_1(backend *sql, stmt *s, char *name, int *nr)
{
	int o1 = backend_dumpstmt_(s->op1.stval, nr, sql);
	size_t buflen = strlen(name) + 64;
	char *buf = NEW_ARRAY(char, buflen);
	size_t len = snprintf(buf, buflen,
			   "var s%d := s%d.%s();\n",
			   -s->nr, o1, name);

	assert(len <= buflen);
	dump(sql, buf, len, -s->nr);
	_DELETE(buf);
	backend_dump_nil(sql, s->op1.stval);
}

void
dump_2(backend *sql, stmt *s, char *name, int *nr)
{
	int o1 = backend_dumpstmt_(s->op1.stval, nr, sql);
	int o2 = backend_dumpstmt_(s->op2.stval, nr, sql);
	size_t buflen = strlen(name) + 64;
	char *buf = NEW_ARRAY(char, buflen);
	size_t len = snprintf(buf, buflen,
			   "var s%d := %s(s%d, s%d);\n",
			   -s->nr, name, o1, o2);

	assert(len <= buflen);
	dump(sql, buf, len, -s->nr);
	_DELETE(buf);
	backend_dump_nil(sql, s->op1.stval);
	backend_dump_nil(sql, s->op2.stval);
}

void
dump_3(backend *sql, stmt *s, char *name, int *nr)
{
	int o1 = backend_dumpstmt_(s->op1.stval, nr, sql);
	int o2 = backend_dumpstmt_(s->op2.stval, nr, sql);
	int o3 = backend_dumpstmt_(s->op3.stval, nr, sql);
	size_t buflen = strlen(name) + 64;
	char *buf = NEW_ARRAY(char, buflen);
	size_t len = snprintf(buf, buflen,
			   "var s%d := %s(s%d, s%d, s%d);\n",
			   -s->nr, name, o1, o2, o3);

	assert(len <= buflen);
	dump(sql, buf, len, -s->nr);
	_DELETE(buf);
	backend_dump_nil(sql, s->op1.stval);
	backend_dump_nil(sql, s->op2.stval);
	backend_dump_nil(sql, s->op3.stval);
}

#define SMALLBUFSIZ 64
static int
backend_dumpstmt_(stmt *s, int *nr, backend *sql)
{
	size_t buflen = SMALLBUFSIZ;
	char *buf = NULL;
	size_t len = 0;
	node *n;

	assert(*nr);

	if (s) {
		if (s->nr2 == int_nil)
			s->nr2 = s->ref.refcnt;

		if (s->nr > 0)
			return s->nr;

		if (s->nr == 0)
			s->nr = -(*nr)++;

		switch (s->type) {
		case st_none:{
			buflen = SMALLBUFSIZ;
			buf = NEW_ARRAY(char, buflen + 1);

			strcpy(buf, "var none := \"none\";\n");
			dump(sql, buf, -1, -s->nr);
			_DELETE(buf);
		} break;
		case st_sql:
			mvc_dump_1(sql, s, "sql", nr);
			break;
		case st_var:{
			if (s->op1.sval) {
				buflen = strlen(s->op1.sval) + 64;
				buf = NEW_ARRAY(char, buflen + 1);

				if (VAR_GLOBAL(s->flag)) { /* globals */
					if ((s->flag & VAR_DECLARE) == 0) {
						len = snprintf(buf, buflen, "var s%d := getVariable(myc, \"%s\");\n", -s->nr, s->op1.sval);
					} else { 
						int tt = tail_type(s)->type->localtype;
						len = snprintf(buf, buflen, "declareVariable(myc, \"%s\", %s(nil));\n", s->op1.sval, ATOMname(tt));
					}
				} else { 
					if ((s->flag & VAR_DECLARE) == 0) {
						len = snprintf(buf, buflen, "var s%d := %s;\n", -s->nr, s->op1.sval);
					} else {
						len = snprintf(buf, buflen, "var %s;\n", s->op1.sval);
					}
				}
				assert(len <= buflen);
			} else {
				buflen = 32;
				buf = NEW_ARRAY(char, buflen + 1);

				len = snprintf(buf, buflen, "var s%d := A%d;\n", -s->nr, s->flag);
				assert(len <= buflen);
			}
			dump(sql, buf, len, -s->nr);
			_DELETE(buf);
			break;
		}
		case st_temp:{
			buflen = strlen(s->op4.typeval.type->base.name) + SMALLBUFSIZ;
			buf = NEW_ARRAY(char, buflen + 1);

			len = snprintf(buf, buflen, "var s%d := new(void,%s).seqbase(oid(0));\n", -s->nr, s->op4.typeval.type->base.name);
			assert(len <= buflen);
			dump(sql, buf, len, -s->nr);
			_DELETE(buf);
			break;
		}
		case st_column:
			s->nr = -backend_dumpstmt_(s->op1.stval, nr, sql);
			backend_dec_nr2(s->op1.stval);
			break;
		case st_bat: {
			buflen = 128 + strlen(s->op1.cval->t->s->base.name) + strlen(s->op1.cval->t->base.name) + strlen(s->op1.cval->base.name);

			buf = NEW_ARRAY(char, buflen + 1);

			len = snprintf(buf, buflen, "var s%d := mvc_bind(myc, \"%s\", \"%s\", \"%s\", %d);\n", -s->nr, s->op1.cval->t->s->base.name, s->op1.cval->t->base.name, s->op1.cval->base.name, s->flag);
			assert(len <= buflen);
			dump(sql, buf, len, -s->nr); 
			_DELETE(buf);
			break;
		}
		case st_dbat:{
			buflen = 128 + strlen(s->op1.tval->s->base.name) + strlen(s->op1.tval->base.name);
			buf = NEW_ARRAY(char, buflen + 1);

			len = snprintf(buf, buflen, "var s%d := mvc_bind_dbat(myc, \"%s\", \"%s\", %d);\n", -s->nr, s->op1.tval->s->base.name, s->op1.tval->base.name, s->flag);
			assert(len <= buflen);
			dump(sql, buf, len, -s->nr);
			_DELETE(buf);
			break;
		}
		case st_idxbat:{
			buflen = 128 + strlen(s->op1.idxval->t->s->base.name) + strlen(s->op1.idxval->t->base.name) + strlen(s->op1.idxval->base.name);
			buf = NEW_ARRAY(char, buflen + 1);

			len = snprintf(buf, buflen, "var s%d := mvc_bind_idxbat(myc, \"%s\", \"%s\", \"%s\", %d);\n", -s->nr, s->op1.idxval->t->s->base.name, s->op1.idxval->t->base.name, s->op1.idxval->base.name, s->flag);
			assert(len <= buflen);
			dump(sql, buf, len, -s->nr);
			_DELETE(buf);
			break;
		}
		case st_const:
			dump_2(sql, s, "project", nr);
			break;
		case st_mark:
			dump_2(sql, s, "mark", nr);
			break;
		case st_gen_group:
			dump_1(sql, s, "group", nr);
			break;
		case st_reverse:
			dump_1(sql, s, "reverse", nr);
			break;
		case st_mirror:
			dump_1(sql, s, "mirror", nr);
			break;
		case st_limit:{
			int l = backend_dumpstmt_(s->op1.stval, nr, sql);
			int r1 = backend_dumpstmt_(s->op2.stval, nr, sql);
			int r2 = backend_dumpstmt_(s->op3.stval, nr, sql);
			if (s->flag) { /* topN direction */
				buf = NEW_ARRAY(char, BUFSIZ + 1);

				len = snprintf(buf, BUFSIZ, "var s%d := s%d.pqueue_topn(s%d + s%d, %d);\n", -s->nr, l, r1, r2, s->flag-1);
				if (s->op2.stval->op1.aval->data.val.ival) 
					len += snprintf(buf+len, BUFSIZ-len, "s%d := s%d.pqueue_topn(s%d, %d);\n", -s->nr, -s->nr, r2, (s->flag-1)?0:1);

				dump(sql, buf, len, -s->nr);
			} else {
				buf = NEW_ARRAY(char, BUFSIZ + 1);

				len = snprintf(buf, BUFSIZ, "var s%d := s%d.slice(s%d, s%d + s%d - 1);\n", -s->nr, l, r1, r1, r2);
				dump(sql, buf, len, -s->nr);
			}
			_DELETE(buf);
			backend_dump_nil(sql, s->op1.stval);
			backend_dump_nil(sql, s->op2.stval);
			backend_dump_nil(sql, s->op3.stval);
			break;
		}
		case st_order:{
			int l = backend_dumpstmt_(s->op1.stval, nr, sql);
			buf = NEW_ARRAY(char, BUFSIZ + 1);

			if (s->flag)
				len = snprintf(buf, BUFSIZ, "var s%d := s%d.reverse().sort()", -s->nr, l);
			else
				len = snprintf(buf, BUFSIZ, "var s%d := s%d.reverse().sort_rev()", -s->nr, l);
			len += snprintf(buf + len, BUFSIZ - len, ".reverse();\n");
			dump(sql, buf, len, -s->nr);
			_DELETE(buf);
			backend_dump_nil(sql, s->op1.stval);
			break;
		}
		case st_reorder:{
			int l = backend_dumpstmt_(s->op1.stval, nr, sql);
			int r = backend_dumpstmt_(s->op2.stval, nr, sql);
			buf = NEW_ARRAY(char, BUFSIZ + 1);

			if (s->flag)
				len = snprintf(buf, BUFSIZ, "var s%d := s%d.CTrefine(s%d)", -s->nr, l, r);
			else
				len = snprintf(buf, BUFSIZ, "var s%d := s%d.CTrefine_rev(s%d)", -s->nr, l, r);
			len += snprintf(buf + len, BUFSIZ - len, ";\n");
			dump(sql, buf, len, -s->nr);
			_DELETE(buf);
			backend_dump_nil(sql, s->op1.stval);
			backend_dump_nil(sql, s->op2.stval);
			break;
		}

		case st_select:
		case st_uselect:{
			int l = backend_dumpstmt_(s->op1.stval, nr, sql);
			int r = backend_dumpstmt_(s->op2.stval, nr, sql);
			buf = NEW_ARRAY(char, BUFSIZ + 1);

			if (s->op2.stval->nrcols >= 1) {
				char *op = "=";

				switch (s->flag) {
				case cmp_equal:
					op = "=";
					break;
				case cmp_notequal:
					op = "!=";
					break;
				case cmp_lt:
					op = "<";
					break;
				case cmp_lte:
					op = "<=";
					break;
				case cmp_gt:
					op = ">";
					break;
				case cmp_gte:
					op = ">=";
					break;
				case cmp_like:
					op = "like";
					break;
				case cmp_notlike:
					op = "notlike";
					break;
				default:
					len = snprintf(buf, BUFSIZ, "error impossible\n");
				}
				len = snprintf(buf, BUFSIZ, "var s%d := [%s](s%d,s%d).uselect(TRUE);\n", -s->nr, op, l, r);
			} else {
				char *cmd;

				if (s->type == st_select)
					cmd = "select";
				else
					cmd = "uselect";
				switch (s->flag) {
				case cmp_like:{
					int e = backend_dumpstmt_(s->op3.stval, nr, sql);

#ifdef HAVE_LIBPCRE
					len = snprintf(buf, BUFSIZ, "var s%d := like_uselect_pcre(s%d, s%d, s%d);\n", -s->nr, l, r, e);
#else
					len = snprintf(buf, BUFSIZ, "var s%d := like_uselect(s%d, s%d, s%d);\n", -s->nr, l, r, e);
#endif
				} break;
				case cmp_notlike:{
					int e = backend_dumpstmt_(s->op3.stval, nr, sql);

#ifdef HAVE_LIBPCRE
					len = snprintf(buf, BUFSIZ, "var sn%d := like_uselect_pcre(s%d, s%d, s%d);\n", -s->nr, l, r, e);
#else
					len = snprintf(buf, BUFSIZ, "var sn%d := like_uselect(s%d, s%d, s%d);\n", -s->nr, l, r, e);
#endif
					len += snprintf(buf + len, BUFSIZ, "var s%d := s%d.project(nil).kdiff(sn%d);\n", -s->nr, l, -s->nr);
				} break;
				case cmp_equal:
					len = snprintf(buf, BUFSIZ, "var s%d := s%d.%s(s%d);\n", -s->nr, l, cmd, r);
					break;
				case cmp_notequal:
					len = snprintf(buf, BUFSIZ, "var ns%d := s%d.uselect(s%d);\n", -s->nr, l, r);
					len += snprintf(buf + len, BUFSIZ, "var s%d := s%d.project(nil).kdiff(ns%d);\n", -s->nr, l, -s->nr);
					break;
				case cmp_lt:
					len = snprintf(buf, BUFSIZ, "var s%d := s%d.%s(%s(nil), s%d, FALSE, FALSE);\n", -s->nr, l, cmd, tail_type(s)->type->base.name, r);
					break;
				case cmp_lte:
					len = snprintf(buf, BUFSIZ, "var s%d := s%d.%s(%s(nil), s%d);\n", -s->nr, l, cmd, tail_type(s)->type->base.name, r);
					break;
				case cmp_gt:
					len = snprintf(buf, BUFSIZ, "var s%d := s%d.%s(s%d, %s(nil), FALSE, FALSE);\n", -s->nr, l, cmd, r, tail_type(s)->type->base.name);
					break;
				case cmp_gte:
					len = snprintf(buf, BUFSIZ, "var s%d := s%d.%s(s%d, %s(nil));\n", -s->nr, l, cmd, r, tail_type(s)->type->base.name);
					break;
				default:
					len = snprintf(buf, BUFSIZ, "error impossible\n");
				}
			}
			dump(sql, buf, len, -s->nr);
			_DELETE(buf);
			backend_dump_nil(sql, s->op1.stval);
			backend_dump_nil(sql, s->op2.stval);
			break;
		}
		case st_select2:
		case st_uselect2:
		case st_join2:{
			int l = backend_dumpstmt_(s->op1.stval, nr, sql);
			int r1 = backend_dumpstmt_(s->op2.stval, nr, sql);
			int r2 = backend_dumpstmt_(s->op3.stval, nr, sql);
			char *bits = NULL;
			char *cmd;

			if (s->type == st_select2)
				cmd = "select";
			else if (s->type == st_uselect2)
				cmd = "uselect";
			else
				cmd = "join";
			switch (s->flag) {
			case 0:
				bits = ", FALSE, FALSE";
				break;
			case 1:
				bits = ", FALSE, TRUE";
				break;
			case 2:
				bits = ", TRUE, FALSE";
				break;
			case 3:
				bits = ", TRUE, TRUE";
				break;
			}
			buf = NEW_ARRAY(char, BUFSIZ + 1);

			len = snprintf(buf, BUFSIZ, "var s%d := s%d.%s(s%d, s%d%s);\n", -s->nr, l, cmd, r1, r2, bits);
			dump(sql, buf, len, -s->nr);
			_DELETE(buf);
			backend_dump_nil(sql, s->op1.stval);
			backend_dump_nil(sql, s->op2.stval);
			backend_dump_nil(sql, s->op3.stval);
			break;
		}
		case st_semijoin:
			dump_2(sql, s, "semijoin", nr);
			break;
		case st_diff:
			dump_2(sql, s, "kdiff", nr);
			break;
		case st_union:
			dump_2(sql, s, "kunion", nr);
			break;
		case st_outerjoin:
		case st_join:{
			int l = backend_dumpstmt_(s->op1.stval, nr, sql);
			int r = backend_dumpstmt_(s->op2.stval, nr, sql);
			char *jt = "join";

			if (s->type == st_outerjoin)
				jt = "outerjoin";
			buf = NEW_ARRAY(char, BUFSIZ + 1);

			switch (s->flag) {
			case cmp_equal:
				len = snprintf(buf, BUFSIZ, "var s%d := s%d.%s(s%d);\n", -s->nr, l, jt, r);

				break;
			case cmp_notequal:
				len = snprintf(buf, BUFSIZ, "var s%d := s%d.%s(s%d, \"!=\");\n", -s->nr, l, jt, r);

				break;
			case cmp_lt:
				len = snprintf(buf, BUFSIZ, "var s%d := s%d.%s(s%d, \"<\");\n", -s->nr, l, jt, r);

				break;
			case cmp_lte:
				len = snprintf(buf, BUFSIZ, "var s%d := s%d.%s(s%d, \"<=\");\n", -s->nr, l, jt, r);

				break;
			case cmp_gt:
				len = snprintf(buf, BUFSIZ, "var s%d := s%d.%s(s%d, \">\" );\n", -s->nr, l, jt, r);

				break;
			case cmp_gte:
				len = snprintf(buf, BUFSIZ, "var s%d := s%d.%s(s%d, \">=\" );\n", -s->nr, l, jt, r);

				break;
			case cmp_all:	/* aka cross table */
				len = snprintf(buf, BUFSIZ, "var s%d := s%d.project(0).join(s%d.reverse().project(0).reverse());\n", -s->nr, l, r);
				break;
			default:
				len = snprintf(buf, BUFSIZ, "error impossible\n");
			}
			dump(sql, buf, len, -s->nr);
			_DELETE(buf);
			backend_dump_nil(sql, s->op1.stval);
			backend_dump_nil(sql, s->op2.stval);
			break;
		}
		case st_group: {
			int l = backend_dumpstmt_(s->op1.stval, nr, sql);
			buf = NEW_ARRAY(char, BUFSIZ + 1);
			len = snprintf(buf, BUFSIZ,
				"var s%dg := s%d.SQLgroup();\n", -s->nr, l);
			len += snprintf(buf + len, BUFSIZ - len,
				"var s%d := s%dg.map();\n", -s->nr, -s->nr);
			dump(sql, buf, len, -s->nr);
			_DELETE(buf);
			backend_dump_nil(sql, s->op1.stval);
			break;
		}
		case st_group_ext: {
			int g = backend_dumpstmt_(s->op1.stval, nr, sql);
			buf = NEW_ARRAY(char, BUFSIZ + 1);
			len = snprintf(buf, BUFSIZ,
				"var s%d := s%dg.extend().mirror();\n", -s->nr, g);
			dump(sql, buf, len, -s->nr);
			_DELETE(buf);
			backend_dump_nil(sql, s->op1.stval);
			break;
		}
		case st_derive: {
			int g = backend_dumpstmt_(s->op1.stval, nr, sql);
			int l = backend_dumpstmt_(s->op2.stval, nr, sql);
			buf = NEW_ARRAY(char, BUFSIZ + 1);
			len = snprintf(buf, BUFSIZ,
				"var s%dg := s%dg.CTgroup(s%d);\n", -s->nr, g,l);
			len += snprintf(buf + len, BUFSIZ - len,
				"var s%d := s%dg.map();\n", -s->nr, -s->nr);
			dump(sql, buf, len, -s->nr);
			_DELETE(buf);
			backend_dump_nil(sql, s->op1.stval);
			backend_dump_nil(sql, s->op2.stval);
			break;
		}
		case st_unique:{
			int l = backend_dumpstmt_(s->op1.stval, nr, sql);
			buf = NEW_ARRAY(char, BUFSIZ + 1);

			buf[0] = 0;
			if (s->op2.stval) {
				int g = backend_dumpstmt_(s->op2.stval, nr, sql);

				len += snprintf(buf + len, BUFSIZ - len,
						"var s%dg := s%d.CTgroup(s%d);\n", -s->nr, g, l);
				len += snprintf(buf + len, BUFSIZ - len, "var s%de := s%dg.extend().mirror();\n", -s->nr, -s->nr);
				len += snprintf(buf + len, BUFSIZ - len, "var s%d := s%d.semijoin(s%de);\n", -s->nr, l, -s->nr);
			} else {
				len += snprintf(buf + len, BUFSIZ - len, "var s%d := s%d.reverse().kunique().reverse();\n", -s->nr, l);
			}
			dump(sql, buf, len, -s->nr);
			_DELETE(buf);
			backend_dump_nil(sql, s->op1.stval);
			backend_dump_nil(sql, s->op2.stval);
			break;
		}
		case st_convert:{
			char *convert = s->op4.typeval.type->base.name;
			/* convert types and make sure they are rounded up correctly */
			int l = backend_dumpstmt_(s->op1.stval, nr, sql);
			buflen = SMALLBUFSIZ;

			/* external types have sqlname convert functions,
			   these can generate errors (fromstr cannot) */
			if (s->op4.typeval.type->eclass == EC_EXTERNAL)
				convert = s->op4.typeval.type->sqlname;
		
			if (s->op4.typeval.type->localtype ==
			    s->op3.typeval.type->localtype &&
			    s->op4.typeval.type->eclass ==
			    s->op3.typeval.type->eclass &&
			    s->op3.typeval.type->eclass != EC_INTERVAL &&
			    s->op3.typeval.type->eclass != EC_DEC 
			   ) {
				char b[128];
				len = snprintf(b, buflen, "var s%d := s%d;\n", -s->nr, l);
				dump(sql, b, len, -s->nr);
				backend_dump_nil(sql, s->op1.stval);
				break;
			}
			buf = NEW_ARRAY(char, buflen + 1);

			if (s->op4.typeval.type->eclass == EC_INTERVAL) {
				if (s->op4.typeval.type->localtype == TYPE_int)
					convert = "month_interval";
				else
					convert = "second_interval";
			}

			if (s->op1.stval->nrcols) {
				len = snprintf(buf, buflen, "var s%d := [%s](", -s->nr, convert);
			} else {
				len = snprintf(buf, buflen, "var s%d := %s(", -s->nr, convert);
			}

			/* convert to string is complex, we need full type info
			   and mvc for the timezone */
			if (EC_VARCHAR(s->op4.typeval.type->eclass) && 
			    !(s->op3.typeval.type->eclass == EC_STRING &&
			    s->op4.typeval.digits == 0) ) 
				len += snprintf(buf+len, buflen-len, "myc, %d, %u, %u, %d, ", s->op3.typeval.type->eclass, s->op3.typeval.digits, s->op3.typeval.scale, type_has_tz(&s->op3.typeval));
			else if (s->op3.typeval.type->eclass == EC_DEC) 
				len += snprintf(buf+len, buflen-len, "%u, ", s->op3.typeval.scale);
	
			len += snprintf(buf+len, buflen-len, "s%d", l);

			if (s->op4.typeval.type->eclass == EC_DEC ||
			    s->op4.typeval.type->eclass == EC_INTERVAL)
				len += snprintf(buf+len, buflen-len, ", %u, %u", s->op4.typeval.digits, s->op4.typeval.scale);
			/* convert to string, give error on to large strings */
			if (EC_VARCHAR(s->op4.typeval.type->eclass) && 
			    !(s->op3.typeval.type->eclass == EC_STRING &&
			    s->op4.typeval.digits == 0) )
				len += snprintf(buf+len, buflen-len, ", %u", s->op4.typeval.digits);
			len += snprintf(buf+len, buflen-len, ");\n");
			assert(len <= buflen);
			dump(sql, buf, len, -s->nr);
			_DELETE(buf);
			backend_dump_nil(sql, s->op1.stval);
			break;
		}
		case st_op:{
			char *fimp = sql_func_imp(s->op4.funcval->func);

			buflen = strlen(fimp) + 32;
			backend_create_func(sql, s->op4.funcval->func); 
			buf = NEW_ARRAY(char, buflen + 1);
			len = snprintf(buf, buflen, "var s%d := %s();\n", -s->nr, fimp);
			assert(len <= buflen);
			dump(sql, buf, len, -s->nr);
			_DELETE(buf);
			break;
		}
		case st_unop:{
			char *fimp = sql_func_imp(s->op4.funcval->func);
			int l = backend_dumpstmt_(s->op1.stval, nr, sql);

			backend_create_func(sql, s->op4.funcval->func); 
			if (s->op1.stval->nrcols) {
				buflen = strlen(fimp) + SMALLBUFSIZ;
				buf = NEW_ARRAY(char, buflen + 1);

				len = snprintf(buf, buflen, "var s%d := [%s](s%d);\n", -s->nr, fimp, l);
				assert(len <= buflen);
			} else {
				buflen = strlen(fimp) + SMALLBUFSIZ;
				buf = NEW_ARRAY(char, buflen + 1);

				len = snprintf(buf, buflen, "var s%d := %s(s%d);\n", -s->nr, fimp, l);
				assert(len <= buflen);
			}
			dump(sql, buf, len, -s->nr);
			_DELETE(buf);
			backend_dump_nil(sql, s->op1.stval);
			break;
		}
		case st_binop:{
			/* TODO use the rewriter to fix the 'round' function */
			sql_subtype *tpe = tail_type(s->op1.stval);
			char *fimp = sql_func_imp(s->op4.funcval->func);
			int l = backend_dumpstmt_(s->op1.stval, nr, sql);
			int r = backend_dumpstmt_(s->op2.stval, nr, sql);
			char dec_func[SMALLBUFSIZ];

			buflen = strlen(fimp) + SMALLBUFSIZ;
			buf = NEW_ARRAY(char, buflen + 1);
			dec_func[0] = 0;
			backend_create_func(sql, s->op4.funcval->func); 
			if (strcmp(fimp, "round")==0 &&
			    tpe->type->eclass == EC_DEC) {
				len = snprintf(dec_func, SMALLBUFSIZ, "%u,%u,",
				tpe->digits, tpe->scale);
				assert(len < SMALLBUFSIZ);
			}
			if (s->op1.stval->nrcols || s->op2.stval->nrcols) {
				len = snprintf(buf, buflen, "var s%d := [%s](s%d,%ss%d);\n", -s->nr, fimp, l, dec_func, r);
			} else {
				len = snprintf(buf, buflen, "var s%d := %s(s%d,%ss%d);\n", -s->nr, fimp, l, dec_func, r);
			}
			assert(len <= buflen);
			dump(sql, buf, len, -s->nr);
			_DELETE(buf);
			backend_dump_nil(sql, s->op1.stval);
			backend_dump_nil(sql, s->op2.stval);
			break;
		}
		case st_Nop:{
			char *fimp = sql_func_imp(s->op4.funcval->func);
			int opslen = 0;
			char *ops;
			node *n;
			int cnt = list_length(s->op1.stval->op1.lval);

			backend_create_func(sql, s->op4.funcval->func); 
			backend_dumpstmt_(s->op1.stval, nr, sql);	/* dump operands */
			write_head(sql, -s->nr);
			if (s->nrcols) {
				stmt *h;

				buflen = 1;
				if (cnt) {
					for (n = s->op1.stval->op1.lval->h, h = n->data; n; n = n->next) {
						stmt *op = n->data;
	
						if (op->nrcols > h->nrcols)
							h = op;
						buflen += 20;
					}
				}

				ops = NEW_ARRAY(char, buflen);
				ops[0] = 0;

				if (cnt) {
					for (n = s->op1.stval->op1.lval->h; n; n = n->next) {
						stmt *op = n->data;
						int n = op->nr;
	
						opslen += snprintf(ops + opslen, buflen - opslen, "%cs%d", (opslen) ? ',' : ' ', n);
					}
				}
				buflen = strlen(fimp) + opslen + SMALLBUFSIZ;
				buf = NEW_ARRAY(char, buflen + 1);

				len = snprintf(buf, buflen, "var s%d := [%s](%s);\n", -s->nr, fimp, ops);
				assert(len <= buflen);
			} else {
				buflen = 1;
				if (cnt) 
					for (n = s->op1.stval->op1.lval->h; n; n = n->next)
						buflen += 20;
				
				ops = NEW_ARRAY(char, buflen);
				ops[0] = 0;

				if (cnt) {
					for (n = s->op1.stval->op1.lval->h; n; n = n->next) {
						stmt *op = n->data;
						int n = op->nr;

						opslen += snprintf(ops + opslen, buflen - opslen, "%cs%d", (opslen) ? ',' : ' ', n);
					}
				}
				buflen = strlen(fimp) + opslen + SMALLBUFSIZ;
				buf = NEW_ARRAY(char, buflen + 1);

				len = snprintf(buf, BUFSIZ, "var s%d := %s(%s);\n", -s->nr, fimp, ops);
				assert(len <= buflen);
			}
			_DELETE(ops);
			write_part(sql, buf, len);
			write_command(sql, buf);
			write_result(sql, buf);
			write_tail(sql, -s->nr);
			_DELETE(buf);
			backend_dec_nr2(s->op1.stval);
			break;
		}
		case st_aggr:{
			int output_type_needed = 0;
			int l = backend_dumpstmt_(s->op1.stval, nr, sql);

			char *aggrfunc = s->op4.aggrval->aggr->imp;
			sql_subtype *tpe = tail_type(s);

			buflen = strlen(aggrfunc) + SMALLBUFSIZ;
			buf = NEW_ARRAY(char, buflen + 1);

			/* some aggr functions require bigger outputs types */
			if (tpe && strcmp(aggrfunc,"sum") == 0) 
				output_type_needed = 1;

			if (s->flag) {
				int l2 = backend_dumpstmt_(s->op2.stval, nr, sql);

				len += snprintf(buf + len, buflen - len, "var s%d := %s(s%d, s%d);\n", -s->nr, aggrfunc, l, l2);
				assert(len <= buflen);
			} else if (s->op3.gval) {
				int g = backend_dumpstmt_(s->op2.stval, nr, sql);
				int e = backend_dumpstmt_(s->op3.stval, nr, sql);

				if (!output_type_needed)
					len += snprintf(buf + len, buflen - len, "var s%d := {%s}(s%d, s%d, s%d);\n", -s->nr, aggrfunc, l, g, e);
				else
					len += snprintf(buf + len, buflen - len, "var s%d := {%s_%s}(s%d, s%d, s%d);\n", -s->nr, aggrfunc, ATOMname(tpe->type->localtype), l, g, e);
				assert(len <= buflen);
			} else {
				if (!output_type_needed)
					len += snprintf(buf + len, buflen - len, "var s%d := s%d.%s();\n", -s->nr, l, aggrfunc);
				else
					len += snprintf(buf + len, buflen - len, "var s%d := s%d.%s_%s();\n", -s->nr, l, aggrfunc, ATOMname(tpe->type->localtype));
				assert(len <= buflen);
			}
			dump(sql, buf, len, -s->nr);
			_DELETE(buf);
			backend_dump_nil(sql, s->op1.stval);
			if (s->flag) {
				backend_dump_nil(sql, s->op2.stval);
			} else if (s->op3.gval) {
				backend_dump_nil(sql, s->op2.stval);
				backend_dump_nil(sql, s->op3.stval);
			}
			break;
		}
		case st_atom:{
			write_head(sql, -s->nr);
			buf = NEW_ARRAY(char, BUFSIZ + 1);

			len = snprintf(buf, BUFSIZ, "var s%d := ", -s->nr);
			write_command(sql, buf);
			write_part(sql, buf, len);
			atom_dump(s->op1.aval, sql->out);
			len = snprintf(buf, BUFSIZ, ";\n");
			write_part(sql, buf, len);
			len = snprintf(buf, BUFSIZ, "var s%d := ", -s->nr);
			write_result(sql, buf);
			write_tail(sql, -s->nr);
			_DELETE(buf);
			break;
		}
		case st_append:{
			int l, r = backend_dumpstmt_(s->op2.stval, nr, sql);

			char *access = "";
			if (s->op1.stval->type != st_bat &&
			    s->op1.stval->type != st_idxbat)
				access=".access(BAT_WRITE)";
			l = backend_dumpstmt_(s->op1.stval, nr, sql);
			buf = NEW_ARRAY(char, BUFSIZ + 1);
			len = snprintf(buf, BUFSIZ, "var s%d := append(s%d%s,s%d);\n", -s->nr, l, access, r);
			dump(sql, buf, len, -s->nr);
			backend_dump_nil(sql, s->op1.stval);
			backend_dump_nil(sql, s->op2.stval);
			_DELETE(buf);
			break;
		}
		case st_append_col: 
		case st_update_col: {
			char *n = (s->type == st_append_col)?"append":"update";
			sql_column *c = s->op1.cval; 
			int r = backend_dumpstmt_(s->op2.stval, nr, sql);

			buflen = 128 + strlen(c->t->s->base.name) + strlen(c->t->base.name) + strlen(c->base.name);
			buf = NEW_ARRAY(char, buflen + 1);
			len = snprintf(buf, buflen, "var s%d := mvc_%s(myc, \"%s\", \"%s\", \"%s\", s%d);\n", -s->nr, n, c->t->s->base.name, c->t->base.name, c->base.name, r);
			assert(len <= buflen);
			dump(sql, buf, len, -s->nr);
			backend_dump_nil(sql, s->op2.stval);
			_DELETE(buf);
			break;
		} 
		case st_append_idx: 
		case st_update_idx: {
			char *n = (s->type == st_append_idx)?"append":"update";
			sql_idx *i = s->op1.idxval; 
			int r = backend_dumpstmt_(s->op2.stval, nr, sql);

			buflen = 128 + strlen(i->t->s->base.name) + strlen(i->t->base.name) + strlen(i->base.name);
			buf = NEW_ARRAY(char, buflen + 1);
			len = snprintf(buf, buflen, "var s%d := mvc_%s_idx(myc, \"%s\", \"%s\", \"%s\", s%d);\n", -s->nr, n, i->t->s->base.name, i->t->base.name, i->base.name, r);
			assert(len <= buflen);
			dump(sql, buf, len, -s->nr);
			backend_dump_nil(sql, s->op2.stval);
			_DELETE(buf);
			break;
		}
		case st_delete:{
			sql_table *t = s->op1.tval;
			int r = backend_dumpstmt_(s->op2.stval, nr, sql);

			buflen = strlen(t->base.name) + strlen(t->s->base.name) + SMALLBUFSIZ;
			buf = NEW_ARRAY(char, buflen + 1);
			len = snprintf(buf, buflen, "var s%d := mvc_delete(myc, \"%s\", \"%s\", s%d);\n", -s->nr, t->s->base.name, t->base.name, r);
			assert(len <= buflen);
			dump(sql, buf, len, -s->nr);
			_DELETE(buf);
			break;
		}
		case st_table_clear:{
			sql_table *t = s->op1.tval;

			buflen = strlen(t->base.name) + strlen(t->s->base.name) + SMALLBUFSIZ;
			buf = NEW_ARRAY(char, buflen + 1);

			len = snprintf(buf, buflen, "var s%d := mvc_clear_table(myc, \"%s\", \"%s\");\n", -s->nr, t->s->base.name, t->base.name);
			assert(len <= buflen);
			dump(sql, buf, len, -s->nr);
			_DELETE(buf);
			break;
		}
		case st_exception:{
			int l,r;
	
			l = backend_dumpstmt_(s->op1.stval, nr, sql);
			r = backend_dumpstmt_(s->op2.stval, nr, sql);
			buf = NEW_ARRAY(char, BUFSIZ + 1);

			len += snprintf(buf, BUFSIZ, "if (bit(s%d)){ ERROR(s%d); }\n", l, r);
			dump(sql, buf, len, -s->nr);
			_DELETE(buf);
			backend_dump_nil(sql, s->op1.stval);
			backend_dump_nil(sql, s->op2.stval);
			break;
		}
		case st_alias: {
			int l = backend_dumpstmt_(s->op1.stval, nr, sql);

			buflen = 32;
			buf = NEW_ARRAY(char, buflen + 1);
			len = snprintf(buf, buflen, "var s%d := s%d;\n", -s->nr, l);
			write_command(sql, buf);
			write_part(sql, buf, len);
			_DELETE(buf);
			backend_dec_nr2(s->op1.stval);
		} 	break;
		case st_set:
		case st_list:{
			for (n = s->op1.lval->h; n; n = n->next) {
				(void) backend_dumpstmt_(n->data, nr, sql);
			}
			break;
		}
		case st_sets:{
			for (n = s->op1.lval->h; n; n = n->next) {
				list *l = n->data;
				node *m = l->h;

				while (m) {
					(void) backend_dumpstmt_(m->data, nr, sql);
					backend_dec_nr2(m->data);
					m = m->next;
				}
			}
			break;
		}
		case st_rs_column:
			dump_2(sql, s, "find", nr);
			break;
		case st_bulkinsert:{
			char *tname = s->op1.stval->op1.tval->base.name;
			node *n = s->op2.lval->h;
			char *sep = n->data;
			char *rsep = n->next->data;
			char *ssep = sql_escape_ident(n->next->next->data);
			int nr_rec = *(int*)(n->next->next->next->data);
			int offset = *(int*)(n->next->next->next->next->data);

			buflen = strlen(tname) + 512;
			buf = NEW_ARRAY(char, buflen + 1);

			if (s->op4.stval) {
				int file = backend_dumpstmt_(s->op4.stval, nr, sql);

				len += snprintf(buf + len, buflen - len, "var f%ds := open_rastream(iconv(s%d, \"UTF-8\", codeset()));\n", file, file);
				assert(len <= buflen);
				len += snprintf(buf + len, buflen - len, "var f%d := bstream_create(f%ds, 1024*1024);\n", file, file);
				assert(len <= buflen);
				len += snprintf(buf + len, buflen - len, "var s%d := mvc_import_table( myc, f%d, \"%s\", \"%s\", \"%s\", \"%s\", %d, %d);\n", -s->nr, file, tname, sep, rsep, ssep, nr_rec, offset);
				assert(len <= buflen);
				len += snprintf(buf + len, buflen - len, "bstream_destroy(f%d);\n", file);
				assert(len <= buflen);
				len += snprintf(buf + len, buflen - len, "stream_close(f%ds);\n", file);
				assert(len <= buflen);
			} else {
				len += snprintf(buf + len, buflen - len, "var s%d := mvc_import_table( myc, Input, \"%s\", \"%s\", \"%s\", \"%s\", %d, %d);\n", -s->nr, tname, sep, rsep, ssep, nr_rec, offset);
				assert(len <= buflen);
			}
			dump(sql, buf, len, -s->nr);
			_DELETE(buf);
			_DELETE(ssep);
			backend_dump_nil(sql, s->op4.stval);
			break;
		}
		case st_filter:
			s->nr = -backend_dumpstmt_(s->op1.stval, nr, sql);
			backend_dec_nr2(s->op1.stval);
			break;
		case st_ordered:{
			int l = backend_dumpstmt_(s->op1.stval, nr, sql);

			(void) backend_dumpstmt_(s->op2.stval, nr, sql);
			s->nr = -l;
			backend_dec_nr2(s->op1.stval);
			backend_dec_nr2(s->op2.stval);
			break;
		}
		case st_affected_rows: {
			int l = backend_dumpstmt_(s->op1.stval, nr, sql);
			char *buf = NEW_ARRAY(char, SMALLBUFSIZ);
			size_t len = snprintf(buf, SMALLBUFSIZ,
					   "var s%d := mvc_affected_rows(myc, Output, s%d, \"\");\n",
					   -s->nr, l);
			dump(sql, buf, len, -s->nr);
			_DELETE(buf);
			backend_dump_nil(sql, s->op1.stval);
			break;
		}
		case st_output:{
			stmt *order = NULL;
			stmt *lst = s->op1.stval;

			backend_dumpstmt_(lst, nr, sql);

			write_head(sql, -s->nr);
			buflen = BUFSIZ;
			buf = NEW_ARRAY(char, buflen + 1);

			buf[0] = 0;
			len = 0;
			if (lst->type == st_ordered) {
				order = lst->op1.stval;
				lst = lst->op2.stval;
			}
			if (lst->type == st_list) {
				list *l = lst->op1.lval;
				int cnt = list_length(l);
				stmt *f;

				n = l->h;
				f = n->data;

				/* single value result, has a fast exit */
				if (cnt == 1 && !order && f->nrcols <= 0){
					stmt *c = n->data;
					sql_subtype *t = tail_type(c);
					char *tname = table_name(c);
					char *sname = schema_name(c);
					char *_empty = "";
					char *tn = (tname) ? tname : _empty;
					char *sn = (sname) ? sname : _empty;
					char *cn = column_name(c);
					char *ntn = sql_escape_ident(tn);
					char *nsn = sql_escape_ident(sn);
					char *ncn = sql_escape_ident(cn);

					len = snprintf(buf, buflen, "var s%d := mvc_export_value(myc, Output, %d, ", -s->nr, sql->mvc->type );
	
					len += snprintf(buf+len, buflen-len, "\"%s.%s\", \"%s\", \"%s\", %u, %u, %d, s%d, \"\");\n", nsn, ntn, ncn, t->type->sqlname, t->digits, t->scale, t->type->eclass, c->nr);
					write_command(sql, buf);
					write_part(sql, buf, len);
					len = 0;
					write_tail(sql, -s->nr);
					_DELETE(buf);
					if (tn != _empty)
						_DELETE(tn);
					if (sn != _empty)
						_DELETE(sn);
					_DELETE(cn);
					_DELETE(ntn);
					_DELETE(nsn);
					_DELETE(ncn);
					backend_dec_nr2(s->op1.stval);
					break;
				}
				if (n) {
					if (!order) {
						order = n->data;
					}
				}
				if (buflen - len < 128) {
					buflen += BUFSIZ;
					buf = RENEW_ARRAY(char, buf, buflen);
				}
				len = snprintf(buf, buflen, "var s%d := mvc_result_table(myc, %d, %d, s%d);\n", -s->nr, cnt, sql->mvc->type, order->nr);
				assert(len <= buflen);
				write_command(sql, buf);
				write_part(sql, buf, len);
				len = 0;
				for (; n; n = n->next) {
					size_t sl;
					stmt *c = n->data;
					char *tname = table_name(c);
					char *sname = schema_name(c);
					char *_empty = "";
					char *tn = (tname) ? tname : _empty;
					char *sn = (sname) ? sname : _empty;
					char *cn = column_name(c);
					char *ntn = sql_escape_ident(tn);
					char *nsn = sql_escape_ident(sn);
					char *ncn = sql_escape_ident(cn);

					sl = strlen(tn) + strlen(cn) + strlen(tail_type(c)->type->sqlname);
					if (buflen - len < 128 + sl) {
						buflen += BUFSIZ + sl;
						buf = RENEW_ARRAY(char, buf, buflen);
					}
					len = snprintf(buf, buflen, "mvc_result_column(myc, \"%s.%s\", \"%s\", \"%s\", %u, %u, s%d);\n", nsn, ntn, ncn, tail_type(c)->type->sqlname, tail_type(c)->digits, tail_type(c)->scale, c->nr);
					assert(len <= buflen);
					_DELETE(cn);
					_DELETE(nsn);
					_DELETE(ntn);
					_DELETE(ncn);
					if (tname)
						_DELETE(tname);
					if (sname)
						_DELETE(sname);
					write_command(sql, buf);
					write_part(sql, buf, len);
					len = 0;
				}
				if (buflen - len < 256) {
					buflen += BUFSIZ;
					buf = RENEW_ARRAY(char, buf, buflen);
				}
				len = snprintf(buf, buflen, "mvc_export_result(myc, Output, s%d, \"\");\n", -s->nr);
				assert(len <= buflen);

				assert(len <= buflen);
				write_command(sql, buf);
				write_part(sql, buf, len);
				len = 0;
			} else {
				fprintf(stderr, "not a valid output list %u\n", lst->type);
			}
			write_tail(sql, -s->nr);
			_DELETE(buf);
			backend_dec_nr2(s->op1.stval);
			break;
		}

		case st_table: {
			stmt *lst = s->op1.stval;

			backend_dumpstmt_(lst, nr, sql);

			write_head(sql, -s->nr);
			buflen = BUFSIZ;
			buf = NEW_ARRAY(char, buflen + 1);

			buf[0] = 0;
			len = 0;

			/* the column list */
			if (lst->type == st_list) {
				list *l = lst->op1.lval;
				int cnt = list_length(l);

				len = snprintf(buf, buflen, "var s%d := new(str, bat, %d);\n", -s->nr, cnt );

				write_command(sql, buf);
				write_part(sql, buf, len);
				len = 0;

				for (n = l->h; n; n = n->next) {
					size_t sl;
					stmt *c = n->data;
					char *cn = column_name(c);
					char *ncn = sql_escape_ident(cn);

					sl = strlen(cn);
					if (buflen - len < 128 + sl) {
						buflen += BUFSIZ + sl;
						buf = RENEW_ARRAY(char, buf, buflen);
					}
					len = snprintf(buf, buflen, "s%d.insert(\"%s\", s%d);\n", -s->nr, ncn, c->nr);
					assert(len <= buflen);
					_DELETE(cn);
					_DELETE(ncn);
					write_command(sql, buf);
					write_part(sql, buf, len);
					len = 0;
				}
			} else {
				fprintf(stderr, "not a valid column list %u\n", lst->type);
			}
			write_tail(sql, -s->nr);
			_DELETE(buf);
			backend_dec_nr2(s->op1.stval);
			break;
		}

		/* flow control statements */
		case st_while: {
			int c;
			buf = NEW_ARRAY(char, BUFSIZ + 1);

			len = snprintf(buf, BUFSIZ, "while (true) {\n");
			write_part(sql, buf, len);
			c = backend_dumpstmt_(s->op1.stval, nr, sql);

			len = snprintf(buf, BUFSIZ, "if (not(bit(s%d))) break;\n", c);
			write_part(sql, buf, len);
			(void) backend_dumpstmt_(s->op2.stval, nr, sql);
			len = snprintf(buf, BUFSIZ, "}\n");
			write_part(sql, buf, len);
			_DELETE(buf);
		} 	break;
		case st_if: {
			int c;

			c = backend_dumpstmt_(s->op1.stval, nr, sql);
			
			buf = NEW_ARRAY(char, BUFSIZ + 1);

			len = snprintf(buf, BUFSIZ, "if (bit(s%d)) {\n", c);
			write_part(sql, buf, len);
			(void) backend_dumpstmt_(s->op2.stval, nr, sql);
			if (s->op3.stval) {
				len = snprintf(buf, BUFSIZ, "} else {\n");
				write_part(sql, buf, len);
				(void) backend_dumpstmt_(s->op3.stval, nr, sql);
			}
			len = snprintf(buf, BUFSIZ, "}\n");
			write_part(sql, buf, len);
			backend_dump_nil(sql, s->op1.stval);
			_DELETE(buf);
		} 	break;
		case st_return: {
			int v = backend_dumpstmt_(s->op1.stval, nr, sql);
			buf = NEW_ARRAY(char, BUFSIZ + 1);
			len = snprintf(buf, BUFSIZ, "return s%d;\n", v);
			write_part(sql, buf, len);
			_DELETE(buf);
		} 	break;
		case st_assign: {
			int v = backend_dumpstmt_(s->op2.stval, nr, sql);

			buflen = strlen(s->op1.sval) + 32;
			buf = NEW_ARRAY(char, buflen + 1);
			if (VAR_GLOBAL(s->flag)) { /* globals */
				int vn = backend_dumpstmt_(s->op1.stval, nr, sql);
				len = snprintf(buf, buflen, "setVariable(myc, s%d, s%d);\n", vn, v);
			} else {
				char *vn = atom2string(s->op1.stval->op1.aval);
				len = snprintf(buf, buflen, "%s := s%d;\n", vn, v);
				_DELETE(vn);
			}
			assert(len <= buflen);
			write_part(sql, buf, len);
			backend_dump_nil(sql, s->op2.stval);
			_DELETE(buf);
		} 	break;

			/* should not appear here */
		case st_reljoin:
		case st_relselect:
		case st_intersect:
			/* todo */

		case st_basetable:	/* relation(table) */
		case st_ptable:
		case st_pivot:
		case st_connection:
			printf("backend_dumpstmt_: not implemented stmt %s\n", st_type2string(s->type));
			assert(0);
		}

		if (s->nr > 0)
			assert(s->nr <= 0);
		else
			s->nr = -s->nr;

		return s->nr;
	}
	return 0;
}

static int
backend_dumpstmt(stmt *s, int *nr, backend *sql)
{
	int ret = 0;
	mvc *c = sql->mvc;

	stream_write(sql->out, "{\n", 2, 1);
	if (mvc_debug_on(c, 2 + 1024 + 2048)) {
		char *t0 = "var t00 := time();\n";
		size_t l = strlen(t0);

		stream_write(sql->out, t0, 1, l);
	}
	ret = backend_dumpstmt_(s, nr, sql);
	backend_dec_nr2(s);
	if (mvc_debug_on(c, 2 + 1024 + 2048)) {
		char dbg[BUFSIZ];
		int l = snprintf(dbg, BUFSIZ,
				 "var t11 := time(); printf(\"# wall-clock: %%d ms\\n\", t11 - t00);\n");

		assert(l < BUFSIZ);
		stream_write(sql->out, dbg, 1, l);
	}

	if (c->cache && (c->type == Q_SCHEMA || c->type == Q_TRANS)) {
		char *msg = "mvc_schema_operation(myc, Output, \"\");\n";
		stream_write(sql->out, msg, strlen(msg), 1);
	}
	stream_write(sql->out, "}\n", 2, 1);
	return ret;
}

void
backend_dumpproc(backend *be, cq *q, stmt *s)
{
	int nr = 1;
	int i = 0;
	char buf[BUFSIZ];
	node *n;

	i = snprintf(buf, BUFSIZ, "proc %s (", q->name);

	if (be->mvc->argc) {
		int argc = 0;

		for (; argc < be->mvc->argc; argc++) {
			atom *a = be->mvc->args[argc];

			i += snprintf(buf + i, BUFSIZ - i, "%s A%d%c", atom_type(a)->type->base.name, argc, (argc < (be->mvc->argc-1)) ? ',' : ' ');
		}
	} else if (be->mvc->params) {
		int argc = 0;

		for (n = be->mvc->params->h; n; n = n->next, argc++) {
			sql_arg *a = n->data;

			i += snprintf(buf + i, BUFSIZ - i, "%s A%d%c", a->type.type->base.name, argc, (n->next) ? ',' : ' ');
		}
	}
	i += snprintf(buf + i, BUFSIZ - i, ") : void \n");
	stream_write(be->out, buf, i, 1);

	backend_dumpstmt(s, &nr, be);
}

Cntxt
backend_newstack(Cntxt stk)
{
	Cntxt procstk;

	procstk = CNTXTnew(stk);
	CNTXTuse(procstk);
	monet_cntxt[procstk].reuse = TRUE;

	return procstk;
}

static YYSTREE
milnode(int tok, int tpe, ptr valp)
{
	YYSTREE res = Myynode(tok, tpe);

	VALset(&res->yyval, tpe, valp);
	return res;
}

static YYSTREE
milnode2(ValPtr valp)
{
	YYSTREE res = Myynode(TOK_CONSTANT, valp->vtype);

	res->yyval = *valp;
	res->iscopy = 1;
	return res;
}

static YYSTREE
monet4_interpret(Cntxt procstk, mvc *c, cq *q, int *err)
{
	YYSTREE callnode;
	YYSTREE argtree;
	ValRecord v;

	v.vtype = TYPE_void;
	callnode = milnode(TOK_FUNCTION, TYPE_str, _strdup(q->name));
	argtree = Myynode(0, 0);
	if (c->argc) {
		int i;
		for (i = 0; i < c->argc; i++){
			atom *a = c->args[i];
			YYSTREE arg;
			sql_subtype *pt = q->params+i;

			/*
			if (atom_null(a)) {
				if (a->data.vtype == TYPE_str && a->data.val.sval == NULL) {
					a->data.val.sval = GDKstrdup(str_nil);
				}
			}
			*/
			
			if (!atom_cast(a, pt)) {
				char buf[BUFSIZ];

				snprintf(buf, BUFSIZ, "wrong argument for function call (expected %s instead of %s)\n", pt->type->sqlname, atom_type(a)->type->sqlname);
				sql_error(c, 003, buf);
				*err = -1;
				return NULL;
			}
			arg = milnode2(&a->data);
			argtree = Myyexpand(argtree, arg);
		}
	}
	Myyexpand(callnode, argtree);
	Myyexpand(callnode, Myynode(0, TYPE_int));
	callnode->yysons[1]->yyval.val.ival = (c->argc+1)*sizeof(ValRecord);
	*err = interpret(procstk, callnode, &v);
	CLEANUP(callnode);

	return callnode;
}


int backend_call( backend *be, mvc *c, cq *q ) 
{
	int err = 0;
	Cntxt procstk = backend_newstack((Cntxt) be->mvc->session->stk);
	YYSTREE callnode;

	be->mvc->type = q->type;
	callnode = monet4_interpret(procstk, c, q, &err);

	if (!err) {
		q->code = (backend_code) callnode;
		q->stk = (backend_stack) (ptrdiff_t) procstk;
	} else {
		be->mvc->session->status = err;
		monet4_freecode(callnode, (backend_stack) (ptrdiff_t) procstk, q->id, q->name);

		backend_freestack((backend_stack) (ptrdiff_t) procstk);
		qc_delete(be->mvc->qc, q);
	}
	return err;
}

int
backend_fastpath(backend *be, mvc *c, cq *q)
{
	int res = 0;
	Cntxt procstk = (Cntxt) ((ptrdiff_t)q->stk);
	YYSTREE callnode = (YYSTREE)q->code;
	ValRecord v;

	be->mvc->type = q->type;
	v.vtype = TYPE_void;
	if (c->argc) {
		int i;

		ValPtr argv = (ValPtr) callnode->yysons[1]->yyval.val.pval;
		callnode->yysons[1]->iscopy = 1;

		for (i = 1; i <= c->argc; i++) {
			atom *a = c->args[i-1];
			sql_subtype *pt = q->params+i-1;

			if (!atom_cast(a, pt)) {
				char buf[BUFSIZ];

				snprintf(buf, BUFSIZ, "wrong argument for fast call (expected %s instead of %s)\n", pt->type->sqlname, atom_type(a)->type->sqlname);
				sql_error(c, 003, buf);
				return -1;
			}
			/*
			if (atom_null(a)) {
				int t = argv[i].vtype;

				if (a->data.vtype != t) {
					a->data.vtype = t;
					if (ATOMstorage(t) < TYPE_str) {
						ptr p = ATOMnilptr(t);

						VALset(&a->data, t, p);
					} else {
						a->data.val.pval = NULL;
					}
				}
			} else if (a->data.vtype != argv[i].vtype && argv[i].vtype == TYPE_dbl) { 
				a->data.vtype = argv[i].vtype;
				a->data.val.dval = a->d;
			} else if (a->data.vtype != argv[i].vtype && argv[i].vtype == TYPE_flt) { 
				a->data.vtype = argv[i].vtype;
				a->data.val.fval = a->d;
			}
			*/
			/* cast DEC into FLT */
			argv[i] = a->data;
		}
	}
	res = interpret(procstk, callnode->yysons[1]->yysons[0], &v);
	CLEANUP(callnode);
	return res;
}

static int
backend_parse(Cntxt stack, char *cmd)
{
	int err = 0;

	if (cmd) {
		ValRecord v;

		v.vtype = TYPE_void;

		err = interpret_str(stack, cmd, &v);
	}
	return err;
}

void monet4_set_string(mvc *m, char *name, char *val)
{
	Cntxt c = (Cntxt) m->session->stk;
        Variable v = VARfind(&c, name);
	if (v != NULL && v->binding.vtype == TYPE_str) {
		if (v->binding.val.sval != NULL)
			GDKfree(v->binding.val.sval);
		v->binding.val.sval = _strdup(val);
	}
}


int backend_dump(backend *be, cq *q, stmt *s)
{
	int err = 0;
	mvc *c = be->mvc;
	char *cmd = NULL;

	if (!c->cache || s->type == st_none) {
		int nr = 1;

		backend_dumpstmt(s, &nr, be);
	} else {
		backend_dumpproc(be, q, s);
	}
	cmd = buffer_get_buf(be->outbuf);
	stream_flush(be->out);

	err = backend_parse((Cntxt) c->session->stk, cmd);

	/* beware to use free instead of _DELETE
	 * as the stream library is built without
	 * libbat i.e. it cannot use gdkmalloc */
	free(cmd);
	return err;
}

static void 
backend_create_func(backend *be, sql_func *f) 
{
	stmt *s;
	int i = 0, nr = 1;
	char *cmd = NULL, buf[BUFSIZ];
	mvc *c = be->mvc;


	/* nothing to do for internal and ready functions */
	if (!f->sql || f->sql > 1)
		return;
	f->sql++;
	be = backend_create(c, 0);
	s = scope_sqlparse(c, NULL, f->imp, m_execute);
	if (s) {
		stmt *opt;
		opt = optimize(c, s);
		stmt_destroy(s);
		s = rel2bin(c, opt);
		stmt_destroy(opt);
	}
	assert(s);

	i = snprintf(buf, BUFSIZ, "proc %s (", f->base.name);
	if (f->ops) {
		int argc = 0;
		node *n;

		for (n = f->ops->h; n; n = n->next, argc++) {
			sql_arg *a = n->data;

			if (a->name)
				i += snprintf(buf + i, BUFSIZ - i, "%s %s%c", a->type.type->base.name, a->name, (n->next) ? ',' : ' ');
			else
				i += snprintf(buf + i, BUFSIZ - i, "%s A%d%c", a->type.type->base.name, argc, (n->next) ? ',' : ' ');
		}
	}
	i += snprintf(buf + i, BUFSIZ - i, ") : ");
	if (f->res.type) { 
		i += snprintf(buf + i, BUFSIZ - i, "%s%s\n", 
			f->res.type->base.name, 
			(f->res.comp_type?"[void,BAT]":""));
	} else {
		i += snprintf(buf + i, BUFSIZ - i, "void\n");
	}
	stream_write(be->out, buf, i, 1);

	stream_write(be->out, "{\n", 2, 1);
	(void) backend_dumpstmt_(s, &nr, be);
	stmt_destroy(s);
	stream_write(be->out, "}\n", 2, 1);
	cmd = buffer_get_buf(be->outbuf);
	stream_flush(be->out);

	(void)backend_parse((Cntxt) c->session->stk, cmd);

/* #define PSM_DEBUG */
#ifdef PSM_DEBUG
	fprintf(stdout, "%s\n", cmd);
	fflush(stdout);
#endif /* PSM_DEBUG */
	
	/* beware to use free instead of _DELETE
	 * as the stream library is built without
	 * libbat i.e. it cannot use gdkmalloc */
	free(cmd);
	backend_destroy(be);
}


int
backend_explain(backend *be, stmt *s, stream *out)
{
	mvc *c = be->mvc;
	int t_id, nr = 1;
	BAT *b;
	char *cmd = NULL;

	if (!out) return 0;

	/* insert mil statements into a bat */
	if (c->args) {
		int i = 0;

		for (; i < c->argc; i++) {
			size_t len;
			atom *a = c->args[i];
			char buf[BUFSIZ];

			stream_write(be->out, "var ", 4, 1);
			len = snprintf(buf, BUFSIZ, "A%d", i);
			stream_write(be->out, buf, len, 1);
			stream_write(be->out, " := ", 4, 1);
			atom_dump(a, be->out);
			stream_write(be->out, ";\n", 2, 1);
		}
	}

	backend_dumpstmt_(s, &nr, be);
	cmd = buffer_get_buf(be->outbuf);
	stream_flush(be->out);

	/* discard the type of the original query (update, schema, etc)
	 * and set it to 'table', since we return a resultset here */
	c->type = Q_TABLE;

	strSplit(&b, cmd, "\n");
	/* beware to use free instead of _DELETE
 	 * as the stream library is built without
 	 * libbat i.e. it cannot use gdkmalloc */
	free(cmd);
	BATseqbase(b, 0);
	t_id = mvc_result_table(c, 1, c->type, b);
	mvc_result_column(c, ".", "statement", "varchar", -1, -1, b);
	BBPunfix(b->batCacheid);
	return(mvc_export_result(c, out, t_id, NULL));
}

int
backend_exec_prepared_stmt( backend *be, cq *q )
{
	mvc *c = be->mvc;
	int argc, parc; 

	argc = c->argc;
	parc = q->paramlen;

	if (argc != parc) {
		sql_error(c, 0002, "wrong number of arguments for prepared statement\n");
		return -1;
	} else if (c->argc) {
		int i;
		for (i = 0; i<argc; i++) {
			atom *arg = c->args[i];
			sql_subtype *pt = q->params+i;

			if (!atom_cast(arg, pt)) {
					char buf[BUFSIZ];

				snprintf(buf, BUFSIZ, "wrong argument for prepared statement (expected %s instead of %s)\n", pt->type->sqlname, atom_type(arg)->type->sqlname);
				sql_error(c, 003, buf);
				return -1;
			}
		}
	}
	return 0;
}

backend *
backend_create(mvc *c, int console)
{
	backend *b = NEW(backend);

	b->mvc = c;

	b->outbuf = buffer_create(BUFSIZ);
	b->out = buffer_wastream(b->outbuf, "SQLserver");
	b->console = console;
	return b;
}

void
backend_destroy(backend *b)
{
	if (b->out) {
		buffer_destroy(b->outbuf);
		stream_close(b->out);
		stream_destroy(b->out);
	}
	_DELETE(b);
}

