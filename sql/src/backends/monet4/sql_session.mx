@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f sql_session
@a N.J. Nes
@*

@* Session code

This small module contains the code to instantiate an SQL client.
This code strongly depends on the front-end/back-end setup.

@h
#ifndef _SQL_SESSION_H_
#define _SQL_SESSION_H_

#include "sql_server.h"
#include <sql_backend.h>
#include <monet_context.h>
#include <builtin.proto.h>
#include <str.h>

typedef struct backend {
	int console;
	int trace;
	mvc *mvc;

	buffer *outbuf;
	stream *out;
} backend;

extern int sqlclient(Cntxt stk, YYSTREE lt, ValPtr res);

extern void monet4_freestack(backend_stack stk);
extern void monet4_freecode(backend_code code, backend_stack stk, int nr);
extern void monet4_parse(backend_stack stk, char *code);

extern int sqlstatement(char *cmd, Cntxt stk);
extern int mvc_sql(mvc *c, str query);

#endif /*_SQL_SESSION_H_*/
@c
#include "sql_session.h"
#include "sql_server.h"
#include "sql_result.h"
#include "sql_gencode.h"	/* for backend_dumpproc() */
#include <sql_semantic.h>
#include <rel_semantic.h>
#include <rel_bin.h>
#include <sql_optimize.h>
#include <sql_privileges.h>
#include <sql_rel2bin.h>
#include <sql_scope.h>
#include <sql_qc.h>
#include <sql_parser.h>		/* for sqlparse() */
#include <sql_env.h>		/* explain,debug,reply_size,auto_commit etc */
#include <bat/bat_store.h>
#include <bat/res_table.h>

@= builtin_operand
{
	int _k = interpret(stk, arg(lt, @1), res);
	if (_k < 0) {
		return _k;
	}
	@3 = VALconvert(@2, res);
	if ((@3 == ILLEGALVALUE)  || (@2 == TYPE_bat && !@3)) {
		return handle_paramerror(res,@1,res->vtype,@2);
	}
}
@c

static backend *
backend_create(int trace, mvc *c, int console)
{
	backend *b = NEW(backend);

	b->mvc = c;

	b->outbuf = buffer_create(BUFSIZ);
	b->out = buffer_wastream(b->outbuf, "SQLserver");
	b->trace = trace;
	b->console = console;
	return b;
}

static void
backend_destroy(backend *b)
{
	if (b->out) {
		buffer_destroy(b->outbuf);
		stream_close(b->out);
		stream_destroy(b->out);
	}
	_DELETE(b);
}

static YYSTREE
milnode(int tok, int tpe, ptr valp)
{
	YYSTREE res = Myynode(tok, tpe);

	VALset(&res->yyval, tpe, valp);
	return res;
}

static YYSTREE
milnode2(int tok, ValPtr valp)
{
	YYSTREE res = Myynode(tok, valp->vtype);

	res->yyval = *valp;
	res->dealloc = 0;
	return res;
}

static int
backend_parse(Cntxt stack, char *cmd)
{
	int err = 0;

	if (cmd) {
		ValRecord v;

		v.vtype = TYPE_void;

		err = interpret_str(stack, cmd, &v);
	}
	return err;
}

void
monet4_parse(backend_stack stack, char *cmd)
{
	backend_parse((Cntxt) stack, cmd);
}


Cntxt
backend_newstack(Cntxt stk)
{
	Cntxt procstk;

	procstk = CNTXTnew(stk);
	CNTXTuse(procstk);
	monet_cntxt[procstk].reuse = TRUE;

	return procstk;
}

void
monet4_freestack(backend_stack stk)
{
	Cntxt procstk = (Cntxt) (ptrdiff_t) stk;

	monet_cntxt[procstk].reuse = FALSE;
	CNTXTclear(procstk);
	CNTXTfree1(procstk);
	CNTXTdelete(procstk);
}

static void
reset_arg_tree(YYSTREE args)
{
	while (args) {
		unsigned i;

		for (i = 0; i < args->cnt; i++) {
			if (args->yysons[i])
				reset_arg_tree(args->yysons[i]);

		}
		args->yyval.vtype = TYPE_void;
		args->yyval.len = 0;

		args = args->overflow;
	}
}

void
monet4_freecode(backend_code code, backend_stack stk, int nr)
{
	YYSTREE callnode = (YYSTREE) code;

	if (code) {
		Client client;
		char name[BUFSIZ];
		int i;
		int l = callnode->yysons[1]->cnt;
		ValPtr argv;

		/* clear default arguments */
		reset_arg_tree(callnode->yysons[0]);

		/* clear fastpath arguments */
		if (callnode->yysons[1]) {
			argv = (ValPtr) callnode->yysons[1]->yyval.val.pval;
			for (i = 1; i < l; i++) {
				argv[i].vtype = TYPE_void;
				argv[i].len = 0;
			}
		}

		/* cleanup proc */
		Myyfree(callnode);

		snprintf(name, BUFSIZ, "sql%d", nr);
		CNTXTclient((Cntxt) (ptrdiff_t) stk, &client);
		TBL_delproc(client, name);
	}
}

YYSTREE
monet4_interpret(Cntxt procstk, char *name, list *args, int *err)
{
	YYSTREE callnode;
	YYSTREE argtree;
	ValRecord v;

	v.vtype = TYPE_void;
	callnode = milnode(TOK_FUNCTION, TYPE_str, _strdup(name));
	argtree = Myynode(0, 0);
	if (args) {
		node *n;

		for (n = args->h; n; n = n->next) {
			atom *a = n->data;
			YYSTREE arg;

			if (atom_null(a)) {
				if (a->data.vtype == TYPE_str && a->data.val.sval == NULL) {
					a->data.val.sval = GDKstrdup(str_nil);
				}
			}
			arg = milnode2(TOK_CONSTANT, &a->data);
			argtree = Myyexpand(argtree, arg);
		}
	}
	Myyexpand(callnode, argtree);
	Myyexpand(callnode, Myynode(0, TYPE_int));
	*err = interpret(procstk, callnode, &v);

	return callnode;
}

int
backend_fastpath(Cntxt procstk, YYSTREE callnode, list *args)
{
	ValRecord v;
	node *n;

	v.vtype = TYPE_void;
	if (args) {
		int i;

		ValPtr argv = (ValPtr) callnode->yysons[1]->yyval.val.pval;

		for (i = 1, n = args->h; n; i++, n = n->next) {
			atom *a = n->data;

			if (atom_null(a)) {
				int t = argv[i].vtype;

				if (a->data.vtype != t) {
					a->data.vtype = t;
					if (ATOMstorage(t) < TYPE_str) {
						ptr p = ATOMnilptr(t);

						VALset(&a->data, t, p);
					} else {
						a->data.val.pval = NULL;
					}
				}
			}
			argv[i] = a->data;
		}
	}
	return interpret(procstk, callnode->yysons[1]->yysons[0], &v);
}

static int
error(stream *out, char *str)
{
	char *p;

	if (!out)
		out = GDKerr;

	if (stream_errnr(out))
		return -1;
	while ((p = strchr(str, '\n')) != NULL) {
		p++;		/* include newline */
		if (*str !='!' && stream_write(out, "!", 1, 1) != 1)
			return -1;
		if (stream_write(out, str, p - str, 1) != 1)
			 return -1;
		str = p;
	}
	if (str &&*str) {
		if (*str !='!' && stream_write(out, "!", 1, 1) != 1)
			return -1;
		if (stream_write(out, str, strlen(str), 1) != 1 || stream_write(out, "\n", 1, 1) != 1)
			 return -1;
	}
	return 0;
}

int
explain_cmd(mvc *c, char *cmd, stream *out)
{
	int t_id;
	BAT *b;

	if (!out) return 0;

	/* discard the type of the original query (update, schema, etc)
	 * and set it to 'table', since we return a resultset here */
	c->type = Q_TABLE;

	strSplit(&b, cmd, "\n");
	BATseqbase(b, 0);
	t_id = mvc_result_table(c, 1, b);
	mvc_result_column(c, "", "statement", "varchar", -1, -1, b);
	BBPunfix(b->batCacheid);
	return(mvc_export_result(c, out, t_id));
}

stmt *
sql_symbol2stmt(mvc *c)
{
	stmt *s = NULL;

	if (mvc_debug_on(c,16384)) {
		sql_rel *r;
		printf("# semantic relational algebra\n");
		r = rel_semantic(c, c->sym);
		if (!r) {
			printf("# falling back to direct mode \n");
			s = semantic(c, c->sym);
		} else 
			s = rel_bin(c, r);
	}  else {
		/*printf("# semantic binary algebra\n");*/
		s = semantic(c, c->sym);
	}

	if (s){
		stmt *opt;
/*
		if(i<=0){
			i *= 10;
			printf("\ndigraph %d {\nnode[shape=box,fontname=Helvetica];\nedge[labelfontname=Helvetica,labelfontcolor=red];\n", -i);
			(void)stmt_stmt2dot(s, i, &i, stdout);
			printf("}\n");
		}
		printf("# optimize\n");
*/
		opt = optimize(c, s);
		stmt_destroy(s);
		s = opt;
/*
		if(i<=0){
			i *= 10;
			printf("\ndigraph %d {\nnode[shape=box,fontname=Helvetica];\nedge[labelfontname=Helvetica,labelfontcolor=red];\n", -i);
			(void)stmt_stmt2dot(s, i, &i, stdout);
			printf("}\n");
		}
		printf("# rel2bin\n");
*/
		opt = rel2bin(c, s);
		stmt_destroy(s);
		s = opt;
/*
		if(i<=0){
			i *= 10;
			printf("\ndigraph %d {\nnode[shape=box,fontname=Helvetica];\nedge[labelfontname=Helvetica,labelfontcolor=red];\n", -i);
			(void)stmt_stmt2dot(s, i, &i, stdout);
			printf("}\n");
		}
*/
	}
	return s;
}

int
sqlcleanup(mvc *c, int err)
{
	sql_destroy_params(c);
	sql_destroy_args(c);

	/* some statements dynamically disable caching */
	c->sym = NULL;
	if (c->sa) 
		sa_destroy(c->sa);
	c->sa = sa_create();
	scanner_query_processed(&(c->scanner));
	return err;
}

static int
output_prepare(stream *out, mvc *c, cq *q)
{
	node *n;

	if (!out)
		return 0;
	/* indicate to client that a new SQL command starts here */
	if (stream_printf(out,
		"#-\n"
		"# " SZFMT " # querytype\n"
		"# prepare,	prepare,	prepare # table_name\n"
		"# type,	digits,	scale # name\n"
		"# varchar,	int,	int # type\n"
		"# 0,	0,	0 # length\n"
		"# %d # tuplecount\n"
		"# %d # id\n",
		Q_PREPARE,
		c->params ? list_length(c->params) : 0,
		q->id
	) < 0) {
		return -1;
	}

	if (c->params) {
		for (n = c->params->h; n; n = n->next) {
			var_ *v = n->data;
			sql_subtype *t = tail_type(v->s);

			if (t) {
				if (stream_printf(out,
					"[ \"%s\",	%d,	%d	]\n",
					t->type->sqlname,
					t->digits,
					t->scale
				) < 0) {
					return -1;
				}
				/* add to the query cache param list */
				list_append(q->params, sql_dup_subtype(t));
			} else {
				return -1;
			}
		}
	}
	return 0;
}

enum ex_t {
	ex_none,
	ex_plan,
	ex_profile
};

int
sqlexecute(backend *be, stream *out)
{
	char *query = NULL;
	lng T0 = 0, Tparse = 0, Tmil = 0, Texec = 0, T1 = 0;
	mvc *c = be->mvc;
	int err = 0;
	enum ex_t explain = ex_none;
	cq *q = NULL;

	c->type = Q_PARSE;

	if (!c->trans)
		mvc_trans(c);

	if (c->explain) {
		if (strcmp(c->explain, "plan") == 0)
			explain = ex_plan;
		else if (strcmp(c->explain, "profile") == 0)
			explain = ex_profile;
	}

	if (explain == ex_profile)
		T0 = GDKusec();

	/* sqlparse needs sql allocator to be available.  It can be NULL at
	 * this point if this is a recursive call. */
	if (!c->sa)
		c->sa = sa_create();

	if ((err = sqlparse(c)) ||
	    /* Only forget old errors on transaction boundaries */
	    (mvc_status(c) && c->type != Q_TRANS) || !c->sym) {
		if (!err)
			err = mvc_status(c);
		return sqlcleanup(c, err);
	}

	if (c->mode == m_explain)
		explain = ex_plan;
	if (c->mode == m_profile)
		explain = ex_profile;

	if (explain == ex_profile)
		Tparse = GDKusec();

	if (explain == ex_plan && c->sym->token == SQL_SET)
		explain = ex_none;

	if (c->mode == m_execute) {
		node *a, *p;
		int argc, parc, id = c->sym->data.lval->h->data.ival;

		q = qc_find(c->qc, id);
		if (!q) {
			error(out, "no prepared statement with the given id\n");
			err = -1;
			c->status = err;
			return sqlcleanup(c, err);
		}
		argc = c->args?list_length(c->args):0;
		parc = q->params?list_length(q->params):0;
		if (argc != parc) {
			error(out, "wrong number of arguments for prepared statement\n");
			err = -1;
			c->status = err;
			return sqlcleanup(c, err);
		} else {
			if (c->args)
				for (a = c->args->h, p = q->params->h; a && p; a = a->next, p = p->next) {
					atom *arg = a->data;
					sql_subtype *pt = p->data;

					if (!atom_cast(arg, pt)) {
						char buf[BUFSIZ];

						snprintf(buf, BUFSIZ, "wrong argument for prepared statement (expected %s instead of %s)\n", pt->type->sqlname, arg->tpe->type->sqlname);
						error(out, buf);
						err = -1;
						c->status = err;
						return sqlcleanup(c, err);
					}
				}
		}
	} else if (explain == ex_plan || !c->cache || !(q = qc_match(c->qc, c->sym, c->args, c->scanner.key))) {
		char *cmd = NULL;
		stmt *s = sql_symbol2stmt(c);

		if (!s && (err = mvc_status(c)))
			return sqlcleanup(c, err);
		assert(s);

		if (explain == ex_plan) {
			/* insert mil statements into a bat */
			if (c->args) {
				int i = 0;
				node *n;

				for (n = c->args->h; n; n = n->next, i++) {
					int len;
					atom *a = n->data;
					char buf[BUFSIZ];

					stream_write(be->out, "var ", 4, 1);
					len = snprintf(buf, BUFSIZ, "A%d", i);
					stream_write(be->out, buf, len, 1);
					stream_write(be->out, " := ", 4, 1);
					atom_dump(a, be->out);
					stream_write(be->out, ";\n", 2, 1);
				}
			}
		}

		if (explain == ex_plan || !c->cache) {
			int nr = 1;

			backend_dumpstmt(s, &nr, be);
		} else {
			backend_dumpproc(be, c->qc->id, s);
		}
		cmd = buffer_get_buf(be->outbuf);
		stream_flush(be->out);
		stmt_destroy(s);

		if (explain == ex_plan) {
			err = explain_cmd(c, cmd, out);
		} else {
			err = backend_parse(c->stk, cmd);
			if (c->cache) {
				q = qc_insert(c->qc, c->sa, c->sym, c->args, c->scanner.key, c->type, GDKstrdup(cmd));

				c->sa = NULL;
				c->sym = NULL;
			}
		}

		/* beware to use free instead of _DELETE
		 * as the stream library is built without
		 * libbat i.e. it cannot use gdkmalloc */
		free(cmd);

		if (err)
			return sqlcleanup(c, err);
	}

	if (explain == ex_profile) {
		query = sql_escape(QUERY(c->scanner));
		Tmil = GDKusec();
	}

	scanner_query_processed(&(c->scanner));

	if (q && c->mode == m_prepare) {
		if ((err = output_prepare(out, c, q))) {
			return sqlcleanup(c, err);
		}
	} else if (q && !q->code) {
		/* TODO change to backend_call(c, name, c->args, &err); */
		char buf[BUFSIZ];
		Cntxt procstk = backend_newstack(c->stk);
		YYSTREE callnode;

		snprintf(buf, BUFSIZ, "sql%d", q->id);

		c->type = q->type;
		callnode = monet4_interpret(procstk, buf, c->args, &err);

		if (!err) {
			q->code = (backend_code) callnode;
			q->stk = (backend_stack) (ptrdiff_t) procstk;
		} else {
			c->status = err;
			monet4_freecode(callnode, (backend_stack) (ptrdiff_t) procstk, q->id);

			backend_freestack((backend_stack) (ptrdiff_t) procstk);
			qc_delete(c->qc, q);
		}
	} else if (q) {
		c->type = q->type;
		err = backend_fastpath((Cntxt) (ptrdiff_t) q->stk, (YYSTREE) q->code, c->args);
	}
	if (explain == ex_profile)
		Texec = GDKusec();

	/*
	 * clear query cache after Transaction boundaries (commit/rollback)
	 * and on schema changes
	 */
	if (c->cache && (c->type == Q_TRANS || c->type == Q_SCHEMA || c->qc->id >100)) {
		if (c->qc)
			qc_destroy(c->qc);
		c->qc = qc_create();
	}

	if (explain == ex_profile) {
		char *e = c->explain;
		char buf[BUFSIZ];

		T1 = GDKusec();
		/* TODO use sql_prepare/execute */
		snprintf(buf, BUFSIZ, "insert into sys.history "
			 "values(now,'%s',%lld,%lld,%lld,%lld,USER);\n",
			 query, Tparse - T0, Tmil - Tparse, Texec - Tmil, T1 - T0);
		_DELETE(query);
		/* switch of explain to prevent recursion */
		c->explain = NULL;
		(void) mvc_sql(c, buf);
		c->explain = e;
	}

	if (!err && explain != ex_plan) {
		if (mvc_status(c) < 0) {
			error(out, "Error in result");
		} else if (c->cache && c->type != Q_RESULT && c->type != Q_UPDATE && !(q && c->mode == m_prepare)) {
			err = mvc_export_default(c, out);
		}
	}
	return sqlcleanup(c, err);
}

@-
Sidestepping SQL to directly executed a single MIL statement
in the same context.
@c
void
sidestepMil(Cntxt stk, char *cmd)
{
	ValRecord res;

	res.vtype = TYPE_void;
	interpret_str(stk, cmd, &res);
}

#define TRANS_ABORTED "!current transaction is aborted (please ROLLBACK)\n"

int
handle_error(mvc *m, stream *out, int pstatus)
{
	int go = 1;
	char *buf = GDKerrbuf;

	/* transaction already broken */
	if (m->type != Q_TRANS && pstatus < 0) {
		if (stream_write(out, TRANS_ABORTED, sizeof(TRANS_ABORTED) - 1, 1) != 1) {
			go = !go;
		}
	} else {
		if (error(out, m->errstr) < 0 || (buf && buf[0] && error(out, buf) < 0)) {
			go = !go;
		}
	}
	/* reset error buffers */
	m->errstr[0] = 0;
	if (buf)
		buf[0] = 0;
	return go;
}

@c
int
sqlclient2(mvc *m, Cntxt stk, bstream *in, stream *out, int trace, int console)
{
	int go = TRUE;
	char *errbuf;
	backend *sql;
	Variable v;

	int err;
	int language = 'S';
	prot oldmode;

	sql = backend_create(trace, m, console);

	/* add myc and Output, Input to the stack */
	v = VARnew(stk, "myc");
	v->binding.vtype = TYPE_mvc;
	v->binding.val.pval = m;

	v = VARnew(stk, "Output");
	v->binding.vtype = TYPE_Stream;
	v->binding.val.pval = out;

	v = VARnew(stk, "Input");
	v->binding.vtype = TYPE_Bstream;
	v->binding.val.pval = in;

	errbuf = GDKmalloc(GDKMAXERRLEN);
	errbuf[0] = '\0';
	GDKsetbuf(errbuf);

	in->eof = 1;		/* force prompt on first iteration */
	while (go) {
		int pstatus = 0;

		while (in->pos < in->len && (isspace((int) (in->buf[in->pos])) || in->buf[in->pos] == ';'))
			in->pos++;

		if (in->pos >= in->len) {
			ssize_t rd;

			assert(in->pos == in->len);

			if (in->eof || !isa_block_stream(in->s)) {
				language = (sql->console) ? 'S' : 0;

				/* auto_commit on end of statement */
				if (m->auto_commit && m->trans) {
					if (m->cache && (m->type == Q_TRANS || m->type == Q_SCHEMA || m->qc->id >100)) {
						if (m->qc)
							qc_destroy(m->qc);
						m->qc = qc_create();
					}
					if (mvc_commit(m, 0, NULL) < 0) {
						go = handle_error(m, out, pstatus);
						if (!go)
							break;
					}
				}

				if (stream_write(out, PROMPT1, sizeof(PROMPT1) - 1, 1) != 1 || stream_flush(out)) {
					go = FALSE;
					break;
				}
				in->eof = 0;
			}
			if ((rd = bstream_next(in)) <= 0) {
				if (rd == 0 && language != 0 && in->eof) {
					/* we hadn't seen the EOF before, so just try again
					   (this time with prompt) */
					continue;
				}
				go = FALSE;
				break;
			}
			if (go && !sql->console && language == 0)
				language = in->buf[in->pos++];
		}
		if (sql->console && strncmp(in->buf + in->pos, "quit", 4) == 0) {
			in->pos = in->len;	/* HACK: should use parsed lenght */
			go = FALSE;
			break;
		}
@-
To enable tracing of SQL execution using its MIL code
requires the same client context. This means that we should
have an escape from the sql parser and directly address the
MIL interpreter. This is accomplished with a prepend of the
query string with "M".
		if (mil && language == 'M') {
			sidestepMil(stk, in->buf+in->pos);
			in->pos = in->len; /* HACK: should use parsed lenght */
			continue;
		}
@c
		oldmode = m->scanner.mode;
		if (language == 's') {
			language = 'S';
			m->scanner.mode = LINE_1;
		}
		if (language != 'S' && language != 'X') {
			error(out, "!ERROR: Unrecognized language prefix");
			break;
		}
		if (language == 'X') {
			int n, id, off, len;

			n = sscanf(in->buf + in->pos, "export %d %d %d", &id, &off, &len);

			if (n == 2 || n == 3) {
				mvc_export_chunk(m, out, id, off, n == 3 ? len : m->reply_size);

				in->pos = in->len;	/* HACK: should use parsed lenght */
				continue;
			}
			if (sscanf(in->buf + in->pos, "close %d", &id) == 1) {
				res_table *t = res_tables_find(m->results, id);

				if (t)
					m->results = res_tables_remove(m->results, t);
				in->pos = in->len;	/* HACK: should use parsed lenght */
				continue;
			}
			error(out, "!ERROR: Unrecognized X command");
			break;
		}

		if (m->trans)
			pstatus = m->status;

		/* no transaction, reset status */
		if (!m->trans)
			m->status = 0;

		m->mode = m_normal;

		err = sqlexecute(sql, out);
		m->scanner.mode = oldmode;

		if (err) {	/* output error */
			if (m->auto_commit && m->trans) {
				/* rollback and skip rest */
				mvc_rollback(m, 0, NULL);
				in->pos = in->len;
				if (m->qc)
					qc_destroy(m->qc);
				m->qc = qc_create();
			}
			go = handle_error(m, out, pstatus);
		}
	}

	_DELETE(errbuf);
	GDKsetbuf(NULL);
	backend_destroy(sql);
	return GDK_SUCCEED;
}

int
sqlstatement(char *cmd, Cntxt stk)
{
	int err = 0;
	mvc *m;
	backend *sql;
	Variable v;
	bstream *rs;
	buffer *b;
	char *n;
	int len = strlen(cmd);

	b = (buffer*)GDKmalloc(sizeof(buffer));
	n = GDKmalloc(len + 1 + 1);
	strncpy(n, cmd, len);
	cmd = n;
	cmd[len] = '\n';
	cmd[len+1] = 0;
	len++;

	buffer_init(b, cmd, len);
	rs = bstream_create(buffer_rastream(b, "sqlstatement"), b->len);
	m = mvc_create(0, (backend_stack) stk, rs, GDKout);
	mvc_trans(m);		/* start transaction */
	m->user_id = m->role_id = USER_MONETDB;
	m->user = _strdup("monetdb");
	m->trans->schema = mvc_bind_schema(m, "sys");
	m->scanner.mode = LINE_1; 
	bstream_next(m->scanner.rs);
	sql = backend_create(0, m, 1);

	/* add myc and Output, Input to the stack */
	v = VARnew(stk, "myc");
	v->binding.vtype = TYPE_mvc;
	v->binding.val.pval = m;

	err = sqlexecute(sql, GDKout);
	if (err)
		GDKerror(m->errstr);
	backend_destroy(sql);
	GDKfree(cmd);
	GDKfree(b);

	mvc_commit(m, 0, NULL);
	res_tables_destroy(m->results);
	mvc_destroy(m);
	VARdel(stk, v);
	if (err)
		return GDK_FAIL;
	else
		return GDK_SUCCEED;
}

int
mvc_sql(mvc *m, char *cmd)
{
	Cntxt stk = (Cntxt) m->stk;
	mvc o = *m;

	int err = 0;
	backend *sql;
	Variable v;
	buffer *b;
	char *n;
	int len = strlen(cmd);

	sql = backend_create(0, m, 1);

	/* add myc and Output */
	v = VARnew(stk, "myc");
	v->binding.vtype = TYPE_mvc;
	v->binding.val.pval = m;

	v = VARnew(stk, "Output");
	v->binding.vtype = TYPE_Stream;
	v->binding.val.pval = NULL;

	m->qc = NULL;

	m->cache = 0;

	b = (buffer*)GDKmalloc(sizeof(buffer));
	n = GDKmalloc(len + 1 + 1);
	strncpy(n, cmd, len);
	cmd = n;
	cmd[len] = '\n';
	cmd[len+1] = 0;
	len++;
	buffer_init(b, cmd, len);
	scanner_init( &m->scanner, 
		bstream_create(buffer_rastream(b, "sqlstatement"), b->len),
		NULL);
	m->scanner.mode = LINE_1; 
	bstream_next(m->scanner.rs);

	m->params = NULL;
	m->args = NULL;
	m->sym = NULL;
	m->auto_commit = 0;

	err = sqlexecute(sql, NULL);
	backend_destroy(sql);
	GDKfree(cmd);
	GDKfree(b);
	bstream_destroy(m->scanner.rs);
	assert(m->qc == NULL);

	*m = o;
	VARdel(stk, v);
	if (err)
		return GDK_FAIL;
	else
		return GDK_SUCCEED;
}

@-
The new SQL client server works with a Mapi compliant front-end.
The routine below is called when someone knocks on the door for
an SQL connection.

To simplify the implementation, we will patch MAPIlisten to
recognize the call for SQLmapiclient and adhere to the Mapi protocol
to read an authentication line, i.e.
<username>:<password>:blocked
We assume that a new user-context has been set using a proper fork()
command. This means that the SQL client runs under the authentication of
the DBA.
@c
static int
sendProperty(stream *out, char *name, char *value)
{
	if (stream_write(out, "[ \"", 1, 3) != 3)
		return 0;
	while (*name) {
		switch (*name) {
		case '"':
			if (stream_write(out, "\\\"", 1, 2) != 2)
				return 0;
			break;
		case '\\':
			if (stream_write(out, "\\\\", 1, 2) != 2)
				return 0;
			break;
		default:
			if (stream_write(out, name, 1, 1) != 1)
				return 0;
			break;
		}
		name++;
	}
	if (stream_write(out, "\", \"", 1, 4) != 4)
		return 0;
	while (*value) {
		switch (*value) {
		case '"':
			if (stream_write(out, "\\\"", 1, 2) != 2)
				return 0;
			break;
		case '\\':
			if (stream_write(out, "\\\\", 1, 2) != 2)
				return 0;
			break;
		default:
			if (stream_write(out, value, 1, 1) != 1)
				return 0;
			break;
		}
		value++;
	}
	if (stream_write(out, "\" ]\n", 1, 4) != 4)
		return 0;
	return 1;
}

int
sqlclient(Cntxt stk, YYSTREE lt, ValPtr res)
{
	int trace = 0, ret = GDK_SUCCEED;
	ssize_t i = 0;
	char buf[BUFSIZ + 1];
	char *user, *passwd, *schema, *challenge;
	int blocked = 0;

	mvc *m;
	stream **In, **Out;
	stream *in, *out;
	bstream *rs;

	Thread sqlthread = THRget(THRgettid());
	Client client;

	CNTXTclient((Cntxt) (ptrdiff_t) stk, &client);

	if (lt->cnt != 2) {
		return handle_argerror(res, lt->cnt, 2);
	}
	@:builtin_operand(0,TYPE_Stream,In)@
	in = *In;
	@:builtin_operand(1,TYPE_Stream,Out)@
	out = *Out;

@-
Start analysis using the mapi-client protocol.
Use default setting for trace.
@c
	if (in == 0) {
		GDKsyserror("mapisqlclient:stream-r problems\n");
		closeClient(client, 0); 	
		return GDK_FAIL;
	}
	if (out == 0) {
		GDKsyserror("mapisqlclient:stream-w problems\n");
		closeClient(client, 0); 	
		return GDK_FAIL;
	}
	/* send challenge string, currently empty (disabled) */
	challenge = "::mserver_sql:4\n";
	/* temporarily misuse user variable */
	user = GDKmalloc(sizeof(char) * 100);
	snprintf(user, 100, "%2u%s", (unsigned int)strlen(challenge), challenge);
	stream_write(out, user, strlen(user), 1);
	GDKfree(user);
	/* get user name */
	memset(buf, 0, BUFSIZ);
	user = buf;
	if (stream_read(in, user, 1, 1) < 0) {
		closeClient(client, 0); 	
		return GDK_FAIL;
	}
	for (i = 0; i < BUFSIZ && *user != '\n'; i++) {
		user++;
		if (stream_read(in, user, 1, 1) < 0) {
			closeClient(client, 0); 	
			return GDK_FAIL;
		}
	}
	*user = 0;
	user = buf;
	passwd = strrchr(user, ':');
	if (passwd && strncmp(passwd, ":blocked", 8) == 0) {
		blocked = 1;
		*passwd = 0;
	}
	passwd = strrchr(user, ':');
	if (passwd && strncasecmp(passwd, ":sql", 4) == 0) {
		/* skip :sql only used for M5 */
		*passwd = 0;
	}

	passwd = strchr(user, ':');
	if (passwd) {
		*passwd = 0;
		passwd++;
		user = _strdup(buf);
		passwd = _strdup(passwd);
	} else {
		closeClient(client, 0); 	
		return GDK_FAIL;
	}

	if (blocked) {
		in = block_stream(stream_rstream(in));
		out = block_stream(stream_wstream(out));

		monetSetChannel(sqlthread, in, out);
	}

	if (out == 0) {
		GDKsyserror("mapisqlclient:stream-w problems\n");
		GDKfree(user);
		GDKfree(passwd);
		closeClient(client, 0); 	
		return GDK_FAIL;
	}
@-
The server should emit an identity message, e.g. the Mserver version
These lines should be eaten away into the prompt is encountered.
@c

	rs = bstream_create(in, isa_block_stream(in) ? (128 * BLOCK) : 0);
	m = mvc_create(1, (backend_stack) stk, rs, out);
	if (blocked)
		m->scanner.mode = BLOCKED;
	schema = mvc_login(m, user, passwd);
	GDKfree(user);
	GDKfree(passwd);

	if (!schema) {
		/* close the connection to the Monet server */
		if (error(out, "!ERROR: Schema authorization error") == 0 && stream_write(out, PROMPT1, sizeof(PROMPT1) - 1, 1) >= 0)
			stream_flush(out);
		res_tables_destroy(m->results);
		mvc_destroy(m);
		closeClient(client, 0); 	
		return GDK_FAIL;
	}
	/* Send the profile to the client for inspection */
	if (!sendProperty(out, "version", "4") || !sendProperty(out, "language", "sql") || !sendProperty(out, "schema", schema) || stream_flush(out) < 0) {
		res_tables_destroy(m->results);
		mvc_destroy(m);
		closeClient(client, 0); 	
		return GDK_FAIL;
	}

	ret = sqlclient2(m, stk, rs, out, trace, 0);
	res_tables_destroy(m->results);
	mvc_destroy(m);
	/* Make sure that the write- (out-) stream is closed first,
	 * as the related read- (in-) stream closes the shared
	 * socket; see also MonetDB/src/common/stream.mx:socket_close .
	 */
	bstream_destroy(rs);
	closeClient(client, 0); 	
	return ret;
}

int
sqlconsole(Cntxt stk, YYSTREE lt, ValPtr res)
{
	int ret = GDK_SUCCEED;
	char *schema;

	stream *in = GDKin, *out = GDKout;
	bstream *rs;
	mvc *m;

	if (lt->cnt != 0)
		return handle_argerror(res, lt->cnt, 0);

	rs = bstream_create(in, 0);
	m = mvc_create(1, (backend_stack) stk, rs, out);
	if (!m) {
		GDKerror("Couldn't start sqlconsole");
		return GDK_FAIL;
	}
	schema = mvc_login(m, "monetdb", "monetdb");

	if (!schema) {
		stream_printf(out, "!ERROR: Schema authorization error");
		stream_flush(out);
		res_tables_destroy(m->results);
		mvc_destroy(m);
		return GDK_FAIL;
	}
	sendProperty(out, "version", "4");
	sendProperty(out, "language", "sql");
	sendProperty(out, "schema", schema);
	stream_flush(out);

	ret = sqlclient2(m, stk, rs, out, 0, 1);
	res_tables_destroy(m->results);
	mvc_destroy(m);
	bstream_destroy(rs);
	return ret;
}

int
mvc_new(Cntxt stk, YYSTREE lt, ValPtr res)
{
	stream *in = GDKin, *out = GDKout;
	bstream *rs;
	mvc *m;

	if (lt->cnt != 0)
		return handle_argerror(res, lt->cnt, 0);

	rs = bstream_create(in, 0);
	m = mvc_create(1, (backend_stack) stk, rs, out);

	mvc_trans(m);		/* start transaction */
	m->user_id = m->role_id = USER_MONETDB;
	m->user = _strdup("monetdb");
	m->trans->schema = mvc_bind_schema(m, "sys");

	res->vtype = TYPE_mvc;
	res->val.pval = (ptr) m;
	return GDK_SUCCEED;
}

int
mvc_destroy_wrap(mvc *m, int *commit)
{
	if (*commit)
		mvc_commit(*(mvc **) m, 0, NULL);
	else
		mvc_rollback(*(mvc **) m, 0, NULL);
	res_tables_destroy(m->results);
	mvc_destroy(*(mvc **) m);
	return GDK_SUCCEED;
}
