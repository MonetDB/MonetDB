@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f sql_session
@a N.J. Nes
@*

@* Session code

This small module contains the code to instantiate an SQL client.
This code strongly depends on the front-end/back-end setup.

@h
#ifndef _SQL_SESSION_H_
#define _SQL_SESSION_H_

#include "sql_server.h"
#include <sql_backend.h>
#include <monet_context.h>
#include <builtin.proto.h>
#include <str.h>

typedef struct backend {
	int console;
	int trace;
	mvc *mvc;

	buffer *outbuf;
	stream *out;
} backend;

extern int sqlclient(Cntxt stk, YYSTREE lt, ValPtr res);

extern void monet4_parse(backend_stack stk, char *code);

extern int sqlstatement(char *cmd, Cntxt stk);
extern int mvc_sql(mvc *c, str query);

#endif /*_SQL_SESSION_H_*/
@c
#include "sql_session.h"
#include "sql_server.h"
#include "sql_result.h"
#include "sql_gencode.h"	/* for backend_dump() */
#include <sql_semantic.h>
#include <rel_semantic.h>
#include <rel_bin.h>
#include <sql_optimize.h>
#include <sql_privileges.h>
#include <sql_rel2bin.h>
#include <sql_scope.h>
#include <sql_qc.h>
#include <sql_parser.h>		/* for sqlparse() */
#include <sql_env.h>		/* explain,debug,reply_size,auto_commit etc */
#include <bat/bat_store.h>
#include <bat/res_table.h>

@= builtin_operand
{
	int _k = interpret(stk, arg(lt, @1), res);
	if (_k < 0) {
		return _k;
	}
	@3 = VALconvert(@2, res);
	if ((@3 == ILLEGALVALUE)  || (@2 == TYPE_bat && !@3)) {
		return handle_paramerror(res,@1,res->vtype,@2);
	}
}
@c

static backend *
backend_create(int trace, mvc *c, int console)
{
	backend *b = NEW(backend);

	b->mvc = c;

	b->outbuf = buffer_create(BUFSIZ);
	b->out = buffer_wastream(b->outbuf, "SQLserver");
	b->trace = trace;
	b->console = console;
	return b;
}

static void
backend_destroy(backend *b)
{
	if (b->out) {
		buffer_destroy(b->outbuf);
		stream_close(b->out);
		stream_destroy(b->out);
	}
	_DELETE(b);
}

static int
error(stream *out, char *str)
{
	char *p;

	if (!out)
		out = GDKerr;

	if (stream_errnr(out))
		return -1;
	while ((p = strchr(str, '\n')) != NULL) {
		p++;		/* include newline */
		if (*str !='!' && stream_write(out, "!", 1, 1) != 1)
			return -1;
		if (stream_write(out, str, p - str, 1) != 1)
			 return -1;
		str = p;
	}
	if (str &&*str) {
		if (*str !='!' && stream_write(out, "!", 1, 1) != 1)
			return -1;
		if (stream_write(out, str, strlen(str), 1) != 1 || stream_write(out, "\n", 1, 1) != 1)
			 return -1;
	}
	return 0;
}

stmt *
sql_symbol2stmt(mvc *c)
{
	stmt *s = NULL;

	if (mvc_debug_on(c,16384)) {
		sql_rel *r;
		printf("# semantic relational algebra\n");
		r = rel_semantic(c, c->sym);
		if (!r) {
			printf("# falling back to direct mode \n");
			s = semantic(c, c->sym);
		} else 
			s = rel_bin(c, r);
	}  else {
		/*printf("# semantic binary algebra\n");*/
		s = semantic(c, c->sym);
	}

	if (s){
		stmt *opt;
/*
		if(i<=0){
			i *= 10;
			printf("\ndigraph %d {\nnode[shape=box,fontname=Helvetica];\nedge[labelfontname=Helvetica,labelfontcolor=red];\n", -i);
			(void)stmt_stmt2dot(s, i, &i, stdout);
			printf("}\n");
		}
		printf("# optimize\n");
*/
		opt = optimize(c, s);
		stmt_destroy(s);
		s = opt;
/*
		if(i<=0){
			i *= 10;
			printf("\ndigraph %d {\nnode[shape=box,fontname=Helvetica];\nedge[labelfontname=Helvetica,labelfontcolor=red];\n", -i);
			(void)stmt_stmt2dot(s, i, &i, stdout);
			printf("}\n");
		}
		printf("# rel2bin\n");
*/
		opt = rel2bin(c, s);
		stmt_destroy(s);
		s = opt;
/*
		if(i<=0){
			i *= 10;
			printf("\ndigraph %d {\nnode[shape=box,fontname=Helvetica];\nedge[labelfontname=Helvetica,labelfontcolor=red];\n", -i);
			(void)stmt_stmt2dot(s, i, &i, stdout);
			printf("}\n");
		}
*/
	}
	return s;
}

int
sqlcleanup(mvc *c, int err)
{
	sql_destroy_params(c);
	sql_destroy_args(c);

	/* some statements dynamically disable caching */
	c->sym = NULL;
	if (c->sa) 
		sa_destroy(c->sa);
	c->sa = sa_create();
	c->status = err;
	scanner_query_processed(&(c->scanner));
	return err;
}

static int
output_prepare(stream *out, mvc *c, cq *q)
{
	node *n;

	if (!out)
		return 0;
	/* indicate to client that a new SQL command starts here */
	if (stream_printf(out,
		"#-\n"
		"# " SZFMT " # querytype\n"
		"# prepare,	prepare,	prepare # table_name\n"
		"# type,	digits,	scale # name\n"
		"# varchar,	int,	int # type\n"
		"# 0,	0,	0 # length\n"
		"# %d # tuplecount\n"
		"# %d # id\n",
		Q_PREPARE,
		c->params ? list_length(c->params) : 0,
		q->id
	) < 0) {
		return -1;
	}

	if (c->params) {
		for (n = c->params->h; n; n = n->next) {
			var_ *v = n->data;
			sql_subtype *t = tail_type(v->s);

			if (t) {
				if (stream_printf(out,
					"[ \"%s\",	%d,	%d	]\n",
					t->type->sqlname,
					t->digits,
					t->scale
				) < 0) {
					return -1;
				}
				/* add to the query cache param list */
				list_append(q->params, sql_dup_subtype(t));
			} else {
				return -1;
			}
		}
	}
	return 0;
}

void backend_profile( backend *be, char *query, lng parse, lng optimize, lng exec, lng total )
{
	mvc *c = be->mvc;
	int mode = c->mode;
	char *e = c->explain;

	char buf[BUFSIZ];

	/* TODO use sql_prepare/execute */
	snprintf(buf, BUFSIZ, "insert into sys.history "
		 "values(now,'%s',%lld,%lld,%lld,%lld,USER);\n",
		 query, parse, optimize, exec, total);
	_DELETE(query);

	/* switch of explain to prevent recursion */
	c->mode = m_normal;
	c->explain = NULL;
	(void) mvc_sql(c, buf);
	c->mode = mode;
	c->explain = e;
}

int
sqlexecute(backend *be, stream *out)
{
	char *query = NULL;
	lng T0 = 0, Tparse = 0, Tmil = 0, Texec = 0;
	mvc *c = be->mvc;
	int err = 0;
	cq *q = NULL;

	c->type = Q_PARSE;
	if (!c->trans)
		mvc_trans(c);
	if (!c->sa)
		c->sa = sa_create();

	if (c->mode == m_profile)
		T0 = GDKusec();

	if ((err = sqlparse(c)) ||
	    /* Only forget old errors on transaction boundaries */
	    (mvc_status(c) && c->type != Q_TRANS) || !c->sym) {
		if (!err) /* old or parse errors */
			err = mvc_status(c);
		return sqlcleanup(c, err);
	}

	if (c->mode == m_profile)
		Tparse = GDKusec();

	if ((c->mode == m_explain || c->mode == m_profile) && 
	    c->sym->token == SQL_SET)
		c->mode = m_normal;

	if (c->mode == m_execute) {
		q = qc_find(c->qc, c->sym->data.lval->h->data.ival);
		if (!q) {
			err = -1;
			sql_error(c, 2, "no prepared statement with the given id\n");
		} else {
			err = backend_exec_prepared_stmt( be, q );
		}
		if (err)
			return sqlcleanup(c, err);
	} else if (c->mode == m_explain || !c->cache || 
	           !(q = qc_match(c->qc, c->sym, c->args, c->scanner.key))) {
		stmt *s = sql_symbol2stmt(c);

		if (!s && (err = mvc_status(c))) /* semantic errors */
			return sqlcleanup(c, err);
		assert(s);
		if (c->mode == m_explain) {
			err = backend_explain(be, s, out);
		} else {
			err = backend_dump(be, s);
			if (!err && c->cache) {
				q = qc_insert(c->qc, c->sa, c->sym, c->args, c->scanner.key, c->type, NULL);

				c->sa = NULL;
				c->sym = NULL;
			}
		}
		stmt_destroy(s);
		if (err)
			return sqlcleanup(c, err);
	}

	if (c->mode == m_profile) {
		query = sql_escape(QUERY(c->scanner));
		Tmil = GDKusec();
	}

	scanner_query_processed(&(c->scanner));

	if (q && c->mode == m_prepare) {
		err = output_prepare(out, c, q);
	} else if (q && !q->code) {
		err = backend_call(be, q, c->args); 
	} else if (q) {
		err = backend_fastpath(be, q, c->args);
	}
	if (c->mode == m_profile)
		Texec = GDKusec();

	/*
	 * clear query cache after Transaction boundaries (commit/rollback)
	 * and on schema changes
	 */
	if (c->cache && (c->type == Q_TRANS || c->type == Q_SCHEMA || c->qc->id >100)) {
		if (c->qc)
			qc_destroy(c->qc);
		c->qc = qc_create();
	}

	if (!err && c->mode == m_profile) 
		backend_profile( be, query, Tparse - T0, Tmil - Tparse, Texec - Tmil, T0 - GDKusec());
/*
	if (!err && c->mode != m_explain) {
		if (mvc_status(c) < 0) 
			sql_error(c, 01, "Error in result");
	}
*/
	return sqlcleanup(c, err);
}

@-
Sidestepping SQL to directly executed a single MIL statement
in the same context.
@c
void
sidestepMil(Cntxt stk, char *cmd)
{
	ValRecord res;

	res.vtype = TYPE_void;
	interpret_str(stk, cmd, &res);
}

#define TRANS_ABORTED "!current transaction is aborted (please ROLLBACK)\n"

int
handle_error(mvc *m, stream *out, int pstatus)
{
	int go = 1;
	char *buf = GDKerrbuf;

	/* transaction already broken */
	if (m->type != Q_TRANS && pstatus < 0) {
		if (stream_write(out, TRANS_ABORTED, sizeof(TRANS_ABORTED) - 1, 1) != 1) {
			go = !go;
		}
	} else {
		if (error(out, m->errstr) < 0 || (buf && buf[0] && error(out, buf) < 0)) {
			go = !go;
		}
	}
	/* reset error buffers */
	m->errstr[0] = 0;
	if (buf)
		buf[0] = 0;
	return go;
}

@c
int
sqlclient2(mvc *m, Cntxt stk, bstream *in, stream *out, int trace, int console)
{
	int go = TRUE;
	char *errbuf;
	backend *sql;
	Variable v;

	int err;
	int language = 'S';
	prot oldmode;

	sql = backend_create(trace, m, console);

	/* add myc and Output, Input to the stack */
	v = VARnew(stk, "myc");
	v->binding.vtype = TYPE_mvc;
	v->binding.val.pval = m;

	v = VARnew(stk, "Output");
	v->binding.vtype = TYPE_Stream;
	v->binding.val.pval = out;

	v = VARnew(stk, "Input");
	v->binding.vtype = TYPE_Bstream;
	v->binding.val.pval = in;

	errbuf = GDKmalloc(GDKMAXERRLEN);
	errbuf[0] = '\0';
	GDKsetbuf(errbuf);

	in->eof = 1;		/* force prompt on first iteration */
	while (go) {
		int pstatus = 0;

		while (in->pos < in->len && (isspace((int) (in->buf[in->pos])) || in->buf[in->pos] == ';'))
			in->pos++;

		if (in->pos >= in->len) {
			ssize_t rd;

			assert(in->pos == in->len);

			if (in->eof || !isa_block_stream(in->s)) {
				language = (sql->console) ? 'S' : 0;

				/* auto_commit on end of statement */
				if (m->auto_commit && m->trans) {
					if (m->cache && (m->type == Q_TRANS || m->type == Q_SCHEMA || m->qc->id >100)) {
						if (m->qc)
							qc_destroy(m->qc);
						m->qc = qc_create();
					}
					if (mvc_status(m) < 0) {
						mvc_rollback(m, 0, NULL);
					} else if (mvc_commit(m, 0, NULL) < 0) {
						go = handle_error(m, out, pstatus);
						if (!go)
							break;
					}
				}

				if (stream_write(out, PROMPT1, sizeof(PROMPT1) - 1, 1) != 1 || stream_flush(out)) {
					go = FALSE;
					break;
				}
				in->eof = 0;
			}
			if ((rd = bstream_next(in)) <= 0) {
				if (rd == 0 && language != 0 && in->eof) {
					/* we hadn't seen the EOF before, so just try again
					   (this time with prompt) */
					continue;
				}
				go = FALSE;
				break;
			}
			if (go && !sql->console && language == 0)
				language = in->buf[in->pos++];
		}
		if (sql->console && strncmp(in->buf + in->pos, "quit", 4) == 0) {
			in->pos = in->len;	/* HACK: should use parsed lenght */
			go = FALSE;
			break;
		}
@-
To enable tracing of SQL execution using its MIL code
requires the same client context. This means that we should
have an escape from the sql parser and directly address the
MIL interpreter. This is accomplished with a prepend of the
query string with "M".
		if (mil && language == 'M') {
			sidestepMil(stk, in->buf+in->pos);
			in->pos = in->len; /* HACK: should use parsed lenght */
			continue;
		}
@c
		oldmode = m->scanner.mode;
		if (language == 's') {
			language = 'S';
			m->scanner.mode = LINE_1;
		}
		if (language != 'S' && language != 'X') {
			error(out, "!ERROR: Unrecognized language prefix");
			break;
		}
		if (language == 'X') {
			int n, id, off, len;

			n = sscanf(in->buf + in->pos, "export %d %d %d", &id, &off, &len);

			if (n == 2 || n == 3) {
				mvc_export_chunk(m, out, id, off, n == 3 ? len : m->reply_size);

				in->pos = in->len;	/* HACK: should use parsed lenght */
				continue;
			}
			if (sscanf(in->buf + in->pos, "close %d", &id) == 1) {
				res_table *t = res_tables_find(m->results, id);

				if (t)
					m->results = res_tables_remove(m->results, t);
				in->pos = in->len;	/* HACK: should use parsed lenght */
				continue;
			}
			error(out, "!ERROR: Unrecognized X command");
			break;
		}

		if (m->trans)
			pstatus = m->status;

		/* no transaction, reset status */
		if (!m->trans)
			m->status = 0;

		m->mode = m_normal;

		err = sqlexecute(sql, out);
		m->scanner.mode = oldmode;

				/* rollback and skip rest */
/*
			if (m->auto_commit && m->trans) {
				mvc_rollback(m, 0, NULL);
				in->pos = in->len;
				if (m->qc)
					qc_destroy(m->qc);
				m->qc = qc_create();
			}
*/
		if (err) {	/* output error */
			go = handle_error(m, out, pstatus);
		}
	}

	_DELETE(errbuf);
	GDKsetbuf(NULL);
	backend_destroy(sql);
	return GDK_SUCCEED;
}

int
sqlstatement(char *cmd, Cntxt stk)
{
	int err = 0;
	mvc *m;
	backend *sql;
	Variable v;
	bstream *rs;
	buffer *b;
	char *n;
	int len = strlen(cmd);

	b = (buffer*)GDKmalloc(sizeof(buffer));
	n = GDKmalloc(len + 1 + 1);
	strncpy(n, cmd, len);
	cmd = n;
	cmd[len] = '\n';
	cmd[len+1] = 0;
	len++;

	buffer_init(b, cmd, len);
	rs = bstream_create(buffer_rastream(b, "sqlstatement"), b->len);
	m = mvc_create(0, (backend_stack) stk, rs, GDKout);
	mvc_trans(m);		/* start transaction */
	m->user_id = m->role_id = USER_MONETDB;
	m->user = _strdup("monetdb");
	m->trans->schema = mvc_bind_schema(m, "sys");
	m->scanner.mode = LINE_1; 
	bstream_next(m->scanner.rs);
	sql = backend_create(0, m, 1);

	/* add myc and Output, Input to the stack */
	v = VARnew(stk, "myc");
	v->binding.vtype = TYPE_mvc;
	v->binding.val.pval = m;

	err = sqlexecute(sql, GDKout);
	if (err)
		GDKerror(m->errstr);
	backend_destroy(sql);
	GDKfree(cmd);
	GDKfree(b);

	mvc_commit(m, 0, NULL);
	res_tables_destroy(m->results);
	mvc_destroy(m);
	VARdel(stk, v);
	if (err)
		return GDK_FAIL;
	else
		return GDK_SUCCEED;
}

int
mvc_sql(mvc *m, char *cmd)
{
	Cntxt stk = (Cntxt) m->stk;
	mvc o = *m;

	int err = 0;
	backend *sql;
	Variable v;
	buffer *b;
	char *n;
	int len = strlen(cmd);

	sql = backend_create(0, m, 1);

	/* add myc and Output */
	v = VARnew(stk, "myc");
	v->binding.vtype = TYPE_mvc;
	v->binding.val.pval = m;

	v = VARnew(stk, "Output");
	v->binding.vtype = TYPE_Stream;
	v->binding.val.pval = NULL;

	m->qc = NULL;

	m->cache = 0;

	b = (buffer*)GDKmalloc(sizeof(buffer));
	n = GDKmalloc(len + 1 + 1);
	strncpy(n, cmd, len);
	cmd = n;
	cmd[len] = '\n';
	cmd[len+1] = 0;
	len++;
	buffer_init(b, cmd, len);
	scanner_init( &m->scanner, 
		bstream_create(buffer_rastream(b, "sqlstatement"), b->len),
		NULL);
	m->scanner.mode = LINE_1; 
	bstream_next(m->scanner.rs);

	m->params = NULL;
	m->args = NULL;
	m->sym = NULL;
	m->auto_commit = 0;

	err = sqlexecute(sql, NULL);
	backend_destroy(sql);
	GDKfree(cmd);
	GDKfree(b);
	bstream_destroy(m->scanner.rs);
	assert(m->qc == NULL);

	*m = o;
	VARdel(stk, v);
	if (err)
		return GDK_FAIL;
	else
		return GDK_SUCCEED;
}

@-
The new SQL client server works with a Mapi compliant front-end.
The routine below is called when someone knocks on the door for
an SQL connection.

To simplify the implementation, we will patch MAPIlisten to
recognize the call for SQLmapiclient and adhere to the Mapi protocol
to read an authentication line, i.e.
<username>:<password>:blocked
We assume that a new user-context has been set using a proper fork()
command. This means that the SQL client runs under the authentication of
the DBA.
@c
static int
sendProperty(stream *out, char *name, char *value)
{
	if (stream_write(out, "[ \"", 1, 3) != 3)
		return 0;
	while (*name) {
		switch (*name) {
		case '"':
			if (stream_write(out, "\\\"", 1, 2) != 2)
				return 0;
			break;
		case '\\':
			if (stream_write(out, "\\\\", 1, 2) != 2)
				return 0;
			break;
		default:
			if (stream_write(out, name, 1, 1) != 1)
				return 0;
			break;
		}
		name++;
	}
	if (stream_write(out, "\", \"", 1, 4) != 4)
		return 0;
	while (*value) {
		switch (*value) {
		case '"':
			if (stream_write(out, "\\\"", 1, 2) != 2)
				return 0;
			break;
		case '\\':
			if (stream_write(out, "\\\\", 1, 2) != 2)
				return 0;
			break;
		default:
			if (stream_write(out, value, 1, 1) != 1)
				return 0;
			break;
		}
		value++;
	}
	if (stream_write(out, "\" ]\n", 1, 4) != 4)
		return 0;
	return 1;
}

int
sqlclient(Cntxt stk, YYSTREE lt, ValPtr res)
{
	int trace = 0, ret = GDK_SUCCEED;
	ssize_t i = 0;
	char buf[BUFSIZ + 1];
	char *user, *passwd, *schema, *challenge;
	int blocked = 0;

	mvc *m;
	stream **In, **Out;
	stream *in, *out;
	bstream *rs;

	Thread sqlthread = THRget(THRgettid());
	Client client;

	CNTXTclient((Cntxt) (ptrdiff_t) stk, &client);

	if (lt->cnt != 2) {
		return handle_argerror(res, lt->cnt, 2);
	}
	@:builtin_operand(0,TYPE_Stream,In)@
	in = *In;
	@:builtin_operand(1,TYPE_Stream,Out)@
	out = *Out;

@-
Start analysis using the mapi-client protocol.
Use default setting for trace.
@c
	if (in == 0) {
		GDKsyserror("mapisqlclient:stream-r problems\n");
		closeClient(client, 0); 	
		return GDK_FAIL;
	}
	if (out == 0) {
		GDKsyserror("mapisqlclient:stream-w problems\n");
		closeClient(client, 0); 	
		return GDK_FAIL;
	}
	/* send challenge string, currently empty (disabled) */
	challenge = "::mserver_sql:4\n";
	/* temporarily misuse user variable */
	user = GDKmalloc(sizeof(char) * 100);
	snprintf(user, 100, "%2u%s", (unsigned int)strlen(challenge), challenge);
	stream_write(out, user, strlen(user), 1);
	GDKfree(user);
	/* get user name */
	memset(buf, 0, BUFSIZ);
	user = buf;
	if (stream_read(in, user, 1, 1) < 0) {
		closeClient(client, 0); 	
		return GDK_FAIL;
	}
	for (i = 0; i < BUFSIZ && *user != '\n'; i++) {
		user++;
		if (stream_read(in, user, 1, 1) < 0) {
			closeClient(client, 0); 	
			return GDK_FAIL;
		}
	}
	*user = 0;
	user = buf;
	passwd = strrchr(user, ':');
	if (passwd && strncmp(passwd, ":blocked", 8) == 0) {
		blocked = 1;
		*passwd = 0;
	}
	passwd = strrchr(user, ':');
	if (passwd && strncasecmp(passwd, ":sql", 4) == 0) {
		/* skip :sql only used for M5 */
		*passwd = 0;
	}

	passwd = strchr(user, ':');
	if (passwd) {
		*passwd = 0;
		passwd++;
		user = _strdup(buf);
		passwd = _strdup(passwd);
	} else {
		closeClient(client, 0); 	
		return GDK_FAIL;
	}

	if (blocked) {
		in = block_stream(stream_rstream(in));
		out = block_stream(stream_wstream(out));

		monetSetChannel(sqlthread, in, out);
	}

	if (out == 0) {
		GDKsyserror("mapisqlclient:stream-w problems\n");
		GDKfree(user);
		GDKfree(passwd);
		closeClient(client, 0); 	
		return GDK_FAIL;
	}
@-
The server should emit an identity message, e.g. the Mserver version
These lines should be eaten away into the prompt is encountered.
@c

	rs = bstream_create(in, isa_block_stream(in) ? (128 * BLOCK) : 0);
	m = mvc_create(1, (backend_stack) stk, rs, out);
	if (blocked)
		m->scanner.mode = BLOCKED;
	schema = mvc_login(m, user, passwd);
	GDKfree(user);
	GDKfree(passwd);

	if (!schema) {
		/* close the connection to the Monet server */
		if (error(out, "!ERROR: Schema authorization error") == 0 && stream_write(out, PROMPT1, sizeof(PROMPT1) - 1, 1) >= 0)
			stream_flush(out);
		res_tables_destroy(m->results);
		mvc_destroy(m);
		closeClient(client, 0); 	
		return GDK_FAIL;
	}
	/* Send the profile to the client for inspection */
	if (!sendProperty(out, "version", "4") || !sendProperty(out, "language", "sql") || !sendProperty(out, "schema", schema) || stream_flush(out) < 0) {
		res_tables_destroy(m->results);
		mvc_destroy(m);
		closeClient(client, 0); 	
		return GDK_FAIL;
	}

	ret = sqlclient2(m, stk, rs, out, trace, 0);
	res_tables_destroy(m->results);
	mvc_destroy(m);
	/* Make sure that the write- (out-) stream is closed first,
	 * as the related read- (in-) stream closes the shared
	 * socket; see also MonetDB/src/common/stream.mx:socket_close .
	 */
	bstream_destroy(rs);
	closeClient(client, 0); 	
	return ret;
}

int
sqlconsole(Cntxt stk, YYSTREE lt, ValPtr res)
{
	int ret = GDK_SUCCEED;
	char *schema;

	stream *in = GDKin, *out = GDKout;
	bstream *rs;
	mvc *m;

	if (lt->cnt != 0)
		return handle_argerror(res, lt->cnt, 0);

	rs = bstream_create(in, 0);
	m = mvc_create(1, (backend_stack) stk, rs, out);
	if (!m) {
		GDKerror("Couldn't start sqlconsole");
		return GDK_FAIL;
	}
	schema = mvc_login(m, "monetdb", "monetdb");

	if (!schema) {
		stream_printf(out, "!ERROR: Schema authorization error");
		stream_flush(out);
		res_tables_destroy(m->results);
		mvc_destroy(m);
		return GDK_FAIL;
	}
	sendProperty(out, "version", "4");
	sendProperty(out, "language", "sql");
	sendProperty(out, "schema", schema);
	stream_flush(out);

	ret = sqlclient2(m, stk, rs, out, 0, 1);
	res_tables_destroy(m->results);
	mvc_destroy(m);
	bstream_destroy(rs);
	return ret;
}

int
mvc_new(Cntxt stk, YYSTREE lt, ValPtr res)
{
	stream *in = GDKin, *out = GDKout;
	bstream *rs;
	mvc *m;

	if (lt->cnt != 0)
		return handle_argerror(res, lt->cnt, 0);

	rs = bstream_create(in, 0);
	m = mvc_create(1, (backend_stack) stk, rs, out);

	mvc_trans(m);		/* start transaction */
	m->user_id = m->role_id = USER_MONETDB;
	m->user = _strdup("monetdb");
	m->trans->schema = mvc_bind_schema(m, "sys");

	res->vtype = TYPE_mvc;
	res->val.pval = (ptr) m;
	return GDK_SUCCEED;
}

int
mvc_destroy_wrap(mvc *m, int *commit)
{
	if (*commit)
		mvc_commit(*(mvc **) m, 0, NULL);
	else
		mvc_rollback(*(mvc **) m, 0, NULL);
	res_tables_destroy(m->results);
	mvc_destroy(*(mvc **) m);
	return GDK_SUCCEED;
}
