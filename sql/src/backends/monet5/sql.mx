@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.

@f sql
@t SQL Scenario implementation
@a M Kersten 
@v 0
@* SQL support implementation
This module contains the wrappers around the SQL 
multi-version-catalogue and support routines copied
from the Version 4 code base.

@mal
module sql;

command sql():void 
address SQLlanguage
comment "Switch to processing SQL statements";

command eval(cmd:str):void 
address SQLstatement
comment "Execute a single sql statement";

command header(i:int) 
address SQLheader
comment "Generate a table header for an SQL frontend";
command column(i:any, v:str,t:str,digits:int,scale:int) 
address SQLcolumnsingle;
command column(b:bat, v:str,t:str,digits:int,scale:int) 
address SQLcolumn
comment "Rename a table column";

command assert(b:bit,msg:str):void
address SQLassert
comment "Generate an exception when b==true";

pattern output(a:any...)
address SQLoutput;
pattern output(a:bat[:any,:any]...)
address SQLoutputBats
comment "Overloading of the core print routines to obtain proper layout";

@- The SQL multi-version catalog
This module also contains the definitions for managing an SQL database schema in
version 5.  It is an adaptation of the original V4.3 code base. 
A main difference is that the global catalog is obtained from
the client record, rather then lookup the variable in a context stack.

The MAL operations below are used in the SQL->MAL compiler and
can be (spareingly) used to inspect it from a MIL console.
The 'mvc_' header is removed, because all commands are already
prepended by the 'sql.' module name.
The original code is retained, because it makes it
easier to later re-use part of the catalog code in a separately.
@mal
command createCatalog( debug:int ) :void 
address mvc_create_wrap
comment "Create multi version catalog";

command destroyCatalog() 
address mvc_destroy_wrap
comment "Destroy multi version catalog";

command login( user:str, passwd:str ):str
address mvc_login_wrap
comment "Login to an SQL database";

command update_var( varname:str ):void
address mvc_update_var_wrap
comment "Update a session variable";

command bind_ubat(sname:str, tname:str, 
		cname:str, access:int ) 
	:bat[:any$1,:any$2] 
address mvc_bind_ubat_wrap
comment "Bind bat with the updates to tname.cname 
	with specific access mode";

command bind_dbat(sname:str, tname:str, access:int)
		:bat[:any$1,:any$2] 
address mvc_bind_dbat_wrap
comment "Bind the table deletes bat, tname.delete 
	with specific access modes";

command bind_ibat(sname:str, tname:str, iname:str, access:int)
		:bat[:any$1,:any$2] 
address mvc_bind_ibat_wrap
comment "Bind the idx bat, tname.idx
	with specific accsess modes";

command bind(sname:str, tname:str, 
		cname:str, access:int )
	:bat[:any$1,:any$2] 
address mvc_bind_wrap
comment "Bind the bat tname.cname into the 
	focus with specific access mode";

@-
The Monet 5 code generator uses several SQL specific wrapper functions.
They are not present in V4
@mal
command exportTable(s:stream, res_id:int, 
		offset:int, nr:int ) 
address mvc_export_table
comment "Export a table (in order) to stream s 
	with the given tuple and record 
	seperators (sep/rsep)";

command exportResult(s:stream, res_id:int ) 
address mvc_export_result
comment "Export a table (in order) to stream s 
	with the given tuple and record 
	seperators (sep/rsep)";

command importTable( s:stream, tname:str, 
	sep:str, rsep:str, nr:int) :bat[:str,:any] 
address mvc_import_table_wrap
comment "Import a table from stream s with the 
	given tuple and seperators (sep/rsep)";

#command renumber(b1:bat[oid,any::1],o:oid):bat[oid,any::1] 
#address CMDrenumber
#comment "renumber the bat using the offset o.";

#command insert(b:bat[void,any::1],u:bat[void,any::1]):bat[void,any::1] 
#address CMDbatappendoidbat 
#comment "append the contents of u to b.";
#command replace(b:bat[void,any::1],u:bat[void,any::1]):bat[void,any::1] =
	#CMDbatreplaceoidbat 
#comment "inplace replace values on the give locations.";
@h
#ifndef _SQL_H
#define _SQL_H

#include <sql_mem.h>

#ifdef _MSC_VER
#ifndef LIBSQL
#define sql_export extern __declspec(dllimport)
#else
#define sql_export extern __declspec(dllexport)
#endif
#else
#define sql_export extern
#endif

#include "sql_mvc.h"
#include <sql_backend.h>
#include <mal_session.h>

#include <mal_function.h>
#include <mal_stack.h>
#include <mal_interpreter.h>
#include <mal_session.h>
#include <streams.h>
#include "sql_privileges.h"
#include "sql_semantic.h"
#include "sql_optimize.h"
#include "sql_rel2bin.h"
#include "sql_decimal.h"
#include "sql_string.h"
#include "sql_scope.h"
#include "sql_qc.h"
#include "sql_env.h"
@-
The backend structure collects the information needed to support
compilation and execution of the SQL code against the Monet Version 5
backend. Note that the back-end can be called upon by the front-end
to handle specific tasks, such as catalogue management (sql_mvc)
and query execution (sql_qc). For this purpose, the front-end needs
access to operations defined in the back-end, in particular for
freeing the stack and code segment.
@-
@h
typedef struct backend{
	int debug;
	int trace;
	mvc	*mvc;
	buffer 	*outbuf;
	stream 	*out;
	sql_schema *currSchema;
	sql_table *currTable;
	sql_column *currColumn;
	sql_key *currKey;
	sql_idx *currIndex;
	MalBlkPtr code;
@-
Some statistics are gathered during the execution of a query
and added to the SQL history table for post analysis when the
query has been succesfully executed.
@h
	long Tread, Tparse, Toptimize, Tschedule, Texec;
	str qry;
} backend;

extern backend *backend_create( int trace, mvc *c );
extern void backend_destroy( backend *b );

extern int sqlcleanup( mvc *c, int err, int cache);
extern stmt *sql_symbol2stmt( mvc *c );
#endif /* _SQL_H */

@-
First introduce the routines to be called by the front-end.
@c
#include "sql.h"
#include "sql_gencode.h"

backend *backend_create( int trace, mvc *c )
{
	backend *b = NEW(backend);

	b->debug=0;
	b->outbuf= NULL;
	b->out= NULL;
	b->trace = trace;
	b->mvc= c;
	b->currSchema = NULL;
	b->currTable = NULL;
	b->currColumn = NULL;
	b->currKey = NULL;
	b->currIndex = NULL;
	b->code= NULL;
	b->Tread= b->Tparse= b->Toptimize= b->Tschedule = b->Texec = 0;
	b->qry = NULL;
	return b;
}

void backend_destroy( backend *b )
{
	_DELETE(b);
}

void monet5_freestack( backend_stack stk){
	(void) stk;
#ifdef _SQL_SCENARIO_DEBUG
	stream_printf(GDKout,"monet5_freestack\n");
#endif
}
void monet5_parse( backend_stack stk, char *cmd){
	(void) stk; (void) cmd;
#ifdef _SQL_SCENARIO_DEBUG
	stream_printf(GDKout,"monet5_parse:%s\n",cmd);
#endif
}
void monet5_freecode(backend_code code, backend_stack stk, int nr){
	(void) code; (void) stk; (void)nr;
#ifdef _SQL_SCENARIO_DEBUG
	stream_printf(GDKout,"monet5_free:%d\n",nr);
#endif
}
	
@-
Stuff copied from the Monet 4 backend
Lookup the statement associated with a specific identifier
from the statement cache. Compile and optimize it for later
consumption, e.g. display
@c
stmt *sql_symbol2stmt( mvc *c ){
        stmt *s = semantic(c, c->sym);
        if (s){
                stmt *opt = optimize(c, s);
                stmt_destroy(s);
                s = rel2bin(c, opt);
                stmt_destroy(opt);
        }
        return s;
}
@-
After the SQL statement has been executed, its data structures
should be garbage collected. For successful actions we have to finish
the transaction as well, e.g. commit or rollback.
@c
int sqlcleanup( mvc *c, int err, int cache)
{
        sql_destroy_params(c);
        sql_destroy_args(c);

        /* some statements dynamically disable caching */
        c->cache = cache;
        if (c->sym) {
                symbol_destroy(c->sym);
                c->sym = NULL;
        }
        scanner_query_processed(&(c->scanner));
        if (c->auto_commit && c->trans) {
                if (err)
                        mvc_rollback(c, 0, NULL);
                else
                        mvc_commit(c, 0, NULL);
        }
        return err;
}

@-
The internal administration of the SQL compilation and execution state
is administered by a state descriptor accessible in each phase.
Failure to find the state descriptor aborts the session.

@= getContext
{	Client _client = getClient();
	if(_client == NULL ){
		return throwMessage("mvc","Can not access client record");
	} 
	if( _client->state[PARSER] == NULL){
		return throwMessage("mvc","PARSER not initialized\n");
	}
	if( _client->state[OPTIMIZE] == NULL){
		str schema;
		backend *be = _client->state[PARSER];

		(void)be;
printf("Re-establish context for client not expected\n");
		_client->state[OPTIMIZE] == mvc_create(0,0,NULL,GDKout);
		schema = mvc_login( _client->state[OPTIMIZE], 
				"monetdb", "monetdb" );
		if( !schema)
			return throwMessage("getContext","unknown schema for monetdb\n");
		else
			_DELETE(schema);
	}
	@1= ((mvc *) _client ->state[OPTIMIZE]);
}
@= setContext
{	Client _client = getClient();
	if(_client == NULL || _client ->state[OPTIMIZE]== 0 ){
		return throwMessage("mvc","Can not get access to @2 state");
	} 
	_client ->state[OPTIMIZE]= @1;
}
@= getBackend
{	Client _client= getClient();
	if(_client == NULL ){
		return throwMessage("be","Can not access client record");
	} 
	if( _client->state[PARSER] == NULL){
		return throwMessage("be","PARSER not initialized\n");
	}
	@1= ((backend*) _client->state[PARSER]);
}
@c

str mvc_create_wrap(int *ret, int *debug ){
	mvc *res = mvc_create( *debug,0, NULL,GDKout );
	@:setContext(res,mvc)@
	*ret = 0;
	return MAL_SUCCEED;
}

str mvc_destroy_wrap(int *ret ){
	mvc *c;
	@:getContext(c,mvc)@
	mvc_destroy( c );
	@:setContext(NULL,mvc)@
	*ret = 0;
	return MAL_SUCCEED;
}

str mvc_update_var_wrap( str *varname ){
	mvc *c;
	@:getContext(c,mvc)@
	if ( sql_update_var( c, *varname ) )
		return throwException(MALEXCEPTION,"mvc_update_var","error");
	return MAL_SUCCEED;
}


str mvc_login_wrap(str *r, str *user, str *passwd  ){
	mvc *c;
	@:getContext(c,mvc)@
	*r = mvc_login( c, *user, *passwd );
	if (*r != 0)
		return throwException(MALEXCEPTION,"mvc_login_wrap","error");
	return MAL_SUCCEED;
}

str mvc_bind_wrap(int *bid, str *sname, str *tname, str *cname, int *access){
	mvc *c;
	BAT *b;
	@:getContext(c,mvc)@

	b= mvc_bind( c, *sname, *tname, *cname, *access );
	if (b){
		*bid= b->batCacheid;
		return MAL_SUCCEED;
	}
	return throwException(MALEXCEPTION,"mvc_bind_wrap","error");
}

str mvc_bind_ubat_wrap(int *ret, str *sname, str *tname, str *cname, int *access ){
	mvc *c;
	BAT *b;
	@:getContext(c,mvc)@
	b = mvc_bind_ubat( c, *sname, *tname, *cname, *access );
	if (b){
		*ret= b->batCacheid;
		return MAL_SUCCEED;
	}
	return throwException(MALEXCEPTION,"mvc_bind_ubat_wrap","error");
}

str mvc_bind_dbat_wrap(int *ret, str *sname, str *tname, int *access ){
	mvc *c;
	BAT *b;
	@:getContext(c,mvc)@
	b = mvc_bind_dbat( c, *sname, *tname, *access );
	if (b){
		*ret= b->batCacheid;
		return MAL_SUCCEED;
	}
	return throwException(MALEXCEPTION,"mvc_bind_dbat_wrap","error");
}

str mvc_bind_ibat_wrap(int *ret, str *sname, str *tname, str *iname, int *access ){
	mvc *c;
	BAT *b;
	@:getContext(c,mvc)@
	b = mvc_bind_ibat( c, *sname, *tname, *iname, *access );
	if (b){
		*ret= b->batCacheid;
		return MAL_SUCCEED;
	}
	return throwException(MALEXCEPTION,"mvc_bind_ibat_wrap","error");
}

@-
The recurring structure to handle bat descriptors
@= getBATdescriptor
        if( BBPcheck(*@2,"@4")==0)
                return throwMessage("algebra.@4", "cannot access bat @2 in bbp");
        @3= (BAT*) BBPgetdesc(*@2);
        if( @3 == NULL) { *@1 = 0;
                return throwMessage("algebra.@4", "cannot access descriptor @2");
        }
        if( *@2 <0){ /* BAT reverse */ @3 = BATmirror(@3); }
@-
@c
@= dec_tostr
	char buf[32];
	@1 v = *(@1*)a;
	int scale = (int)(ptrdiff_t)extra, cur = 31, neg = (v<0)?1:0, i, done = 0;
	int l;

	if (v<0) v = -v;

	buf[cur--] = 0;
	if (scale){
		for(i=0; i<scale; i++){
			buf[cur--] = (v%10) + '0';
			v /= 10;
		}
		buf[cur--] = '.';
	}
	while(v){
		buf[cur--] = (v%10) + '0';
		v /= 10;
		done = 1;
	}
	if (!done)
		buf[cur--] = '0';
	if (neg)
		buf[cur--] = '-';
	l = (32-cur-1);
	if (*len < l){
		if (*Buf) GDKfree(*Buf);
		*len = l+1;
		*Buf = GDKmalloc(*len);
	}
	strcpy(*Buf, buf+cur+1);
	return l-1;
@c

int dec_tostr( void *extra, char **Buf, int *len, int type, ptr a){
	/* support dec map to sht, int and lng */
	if (type == TYPE_sht){
		@:dec_tostr(sht)@
	} else if (type == TYPE_int){
		@:dec_tostr(int)@
	} else if (type == TYPE_lng){
		@:dec_tostr(lng)@
	} else {
		GDKwarning("Decimal cannot be mapped to %s\n", ATOMname(type));
	}
	return 0;
}

@= dec_frstr
	sql_subtype *t = (sql_subtype*)extra;

	int i, neg = 0;
	char *p = s;
	@1 *r;
	@1 res = 0;
	if (*s == '-'){
		neg = 1;
		s++;
	} else if (*s == '+'){ 
		neg = 0;
		s++;
	}
	for( i = 0; i < (t->digits-t->scale) && *s != '.'; i++, s++){
		if (!*s || *s < '0' || *s > '9' ){
			GDKerror("decimal wrong format (%s)", p);
			return NULL;
		}
		res *= 10;
		res += (*s-'0');
	}
	if (*s){
		if (*s != '.'){
			GDKerror("decimal wrong format (%s)", p);
			return NULL;
		}
		s++;
		for( i = 0; *s && i < t->scale; i++, s++){
			if (*s < '0' || *s > '9' ){
				GDKerror("decimal wrong format (%s)", p);
				return NULL;
			}
			res *= 10;
			res += (*s-'0');
		}
	}
	if (*s){
		GDKerror("decimal wrong format (%s)", p);
		return NULL;
	}
 	r = (@1*)GDKmalloc(sizeof(@1));
	if (neg)
		*r = -res;
	else
		*r = res;
	return (ptr*)r;
@c

ptr *dec_frstr( void *extra, int type, char *s){
	/* support dec map to sht, int and lng */
	if (type == TYPE_sht){
		@:dec_frstr(sht)@
	} else if (type == TYPE_int){
		@:dec_frstr(int)@
	} else if (type == TYPE_lng){
		@:dec_frstr(lng)@
	} else {
		GDKwarning("Decimal cannot be mapped to %s\n", ATOMname(type));
	}
	return NULL;
}

str mvc_import_table_wrap( BAT **res, stream *s, char *tname, 
		char *sep, char *rsep, int sz)
{
	mvc *c;
	int cnt = 0;
	sql_trans *tr;
	sql_table *t;

	@:getContext(c)@
	tr = c->trans;
 	t = mvc_bind_table(c, tr->schema, tname);
	(void)s; (void)sep; (void)rsep; (void)sz; (void)t; (void)res;

	c->type = Q_UPDATE;
	c->status = cnt;
	return 0;
}

static res_table *find_export_table( mvc *m, int res_id ){
	res_table *r = m->results;

	for( ; r; r = r->next){
		if (r->id == res_id)
			return r;
	}
	return NULL;
}

str mvc_export_result( stream *s, int res_id )
{
	mvc *c;
	int i;
	res_table *t;
	
	@:getContext(c)@
 	t = find_export_table(c, res_id);
	c->type = Q_RESULT;

	stream_writeInt( s, Q_RESULT );
	stream_writeInt( s, t->nr_cols );
	stream_writeInt( s, t->id );
	
	for (i = 0; i < t->nr_cols; i++) 
	{
		res_col *c = t->cols+i;
		stream_write(s, c->name, strlen(c->name), 1);
		stream_write(s, ",", 1, 1);
		stream_write(s, c->type->type->sqlname, 
				strlen(c->type->type->sqlname), 1);
		stream_write(s, "\n", 1, 1);
	}
	stream_flush(s);
	return NULL;
}

static int mvc_export_row( mvc *m, stream *s, res_table *t ) 
{
	char *sep = "\t";
	char *rsep = "\n";

	int i;

	m->type = Q_RESULT;
	stream_writeInt( s, Q_TABLE );
	stream_writeInt( s, 1 );

	for (i = 0; i < t->nr_cols; i++) 
	{
		res_col *c = t->cols+i;
		if (i != 0)
			stream_write(s, sep, strlen(sep), 1);

		if (c->type->type->scale == SCALE_FIX){
			char *buf = NULL;
			int len = 0;
			int l = dec_tostr((void*)(ptrdiff_t)c->type->scale, &buf, &len,
					c->mtype, c->p);
			stream_write(s, buf, l, 1);
			_DELETE(buf);
		} else { 
			char *buf = NULL;
			int len = 0;
			int l = (*BATatoms[c->mtype].atomToStr)(&buf, &len, c->p);
			stream_write(s, buf, l, 1);
			_DELETE(buf);
		}
	}
	mvc_clean_result(m, t);
	stream_write(s, rsep, strlen(rsep), 1);
	stream_flush(s);
	return 0;
}

str mvc_export_table( stream *s, int res_id, int offset, int nr )
{
	mvc *c;
	char *sep = "\t";
	char *rsep = "\n";
	int clean = 0;
	res_table *t;

	@:getContext(c)@
 	t = find_export_table(c, res_id);
	(void)s; (void)offset; (void)nr;
	(void)sep; (void)rsep;
	if (clean)
		mvc_clean_result(c, t);
	return NULL;
}
