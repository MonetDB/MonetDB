@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f sql_user
@t SQL catalog management
@a N. Nes, F. Groffen
@+ SQL user
The SQL user and authorisation implementation differs per backend.  This
file implements the authorisation and user management based on the M5
system authorisation.
@h
#ifndef _SQL_USER_H_
#define _SQL_USER_H_
#include "sql.h"	/* includes sql_backend.h */

sql_export void monet5_user_init(backend_functions *be_funcs);
sql_export str  monet5_user_get_def_schema(mvc *m, oid user);

#endif /* _SQL_USER_H_ */

@c
#include "sql_user.h"
#include "sql_mvc.h"
#include "bat.h"
#include "mal_authorize.h"

static str
monet5_drop_user(str user)
{
	return AUTHremoveUser(&user);
}

static str
monet5_create_user(list *l, str user, str passwd, str fullname, int schema_id, int grantorid)
{
	oid uid = 0;
	bat bid = 0;
	BAT *scens;
	str ret;
	char buf[BUFSIZ];
	(void)l;

	/* prepare the scens BAT: it should contain the sql scenario */
	scens = BATnew(TYPE_str, TYPE_void, 1);
	BUNappend(scens, "sql", 0);
	bid = BBPcacheid(scens);
	/* add the user to the M5 authorisation administration */
	if ((ret = AUTHaddUser(&uid, &user, &passwd, &bid)) != MAL_SUCCEED) {
		BBPunfix(bid); 
		return ret;
	}
	BBPunfix(bid);

	/* create two SQL statements that insert the user in the SQL
	 * adminsitration */
	snprintf(buf, BUFSIZ, "INSERT INTO \"sys\".\"db_user_info\" VALUES('%s','%s',%d);", user, fullname, schema_id);
	list_append(l, stmt_sql(_strdup(buf)));
	snprintf(buf, BUFSIZ, "INSERT INTO \"sys\".\"auths\" VALUES(" SZFMT ", '%s', %d);", (size_t)store_next_oid(), user, grantorid);
	list_append(l, stmt_sql(_strdup(buf)));

	return(NULL);
}

static int
monet5_find_user(ptr mp, str user) {
	str tmp;
	bat b;
	BAT *users;
	bat bid = 0;
	BAT *scens;
	BUN p;
	(void)mp;	/* we don't need mvc, as we do a M5 backend call */
	
	/* prepare the scens BAT: it should contain the sql scenario */
	scens = BATnew(TYPE_str, TYPE_void, 1);
	BUNappend(scens, "sql", 0);
	bid = BBPcacheid(scens);
	if ((tmp = AUTHgetUsers(&b, &bid)) != MAL_SUCCEED) {
		BBPunfix(bid); 
		GDKfree(tmp);
		return(-1);
	}
	BBPunfix(bid);

	users = BATdescriptor(b);
	assert(users);
	p = BUNfnd(BATmirror(users), user);
	BBPunfix(b);

	/* yeah, I would prefer to return something different too */
	return(p == NULL ? -1 : 1);
}

static void
monet5_create_privileges(ptr _mvc, sql_schema *s)
{
	sql_table *t, *uinfo;
	mvc *m = (mvc *)_mvc;
	char *err = NULL;
	int schema_id = 0;
	oid monetdbuser = 0;

	/* create the authorisation related tables */
	t = mvc_create_table(m, s, "db_user_info", 1, SQL_PERSIST, 0, -1);
	mvc_create_column_(m, t, "id", "oid", 9);
	mvc_create_column_(m, t, "fullname", "varchar", 2048);
	mvc_create_column_(m, t, "default_schema", "int", 9);
	uinfo = t;

	t = mvc_create_view(m, s, "db_users", ";CREATE VIEW \"db_users\" (\"[system BAT]\") AS BATS", 1);
	err = sql_view_from_bat(m->session->tr, t, "M5system_auth_user");
	if (err != NULL) {
		GDKfree(err);
		sql_trans_drop_table(m->session->tr, t->s, t->base.name, 0);
	}

	t = mvc_create_view(m, s, "db_scens", ";CREATE VIEW \"db_scens\" (\"[system BAT]\") AS BATS", 1);
	err = sql_view_from_bat(m->session->tr, t, "M5system_auth_scen");
	if (err != NULL) {
		GDKfree(err);
		sql_trans_drop_table(m->session->tr, t->s, t->base.name, 0);
	}

	t = mvc_create_view(m, s, "users",
			"SELECT u.\"t\" AS \"name\", "
				"ui.\"fullname\", ui.\"default_schema\" "
			"FROM \"sys\".\"db_users\" AS u, "
				"\"sys\".\"db_user_info\" AS ui "
			"WHERE u.\"h\" = ui.\"id\" "
				"AND u.\"h\" NOT IN ("
					"SELECT s.\"h\" "
					"FROM \"sys\".\"db_scens\" AS s "
					"WHERE s.\"t\" NOT LIKE 'sql'"
				");", 1);
	mvc_create_column_(m, t, "name", "varchar", 1024);
	mvc_create_column_(m, t, "fullname", "varchar", 2024);
	mvc_create_column_(m, t, "default_schema", "int", 9);

	schema_id = sql_find_schema(m, "sys");
	assert(schema_id >= 0);

	table_insert(m->session->tr, uinfo, &monetdbuser, "MonetDB Administrator", &schema_id);
}

static int
monet5_schema_has_user(ptr _mvc, sql_schema *s)
{
	mvc *m = (mvc *)_mvc;
	ssize_t rid;
	sql_schema *sys = find_sql_schema(m->session->tr, "sys");
	sql_table *users = find_sql_table(sys, "db_user_info");
	sql_column *users_schema = find_sql_column(users, "default_schema");
	oid schema_id = s->base.id;

	rid = column_find_row(m->session->tr, users_schema, &schema_id, NULL);
	if (rid < 0)
		return FALSE;
	return TRUE;
}

static int
monet5_alter_user(ptr _mvc, str user, str passwd, oid schema_id)
{
	mvc *m = (mvc *)_mvc;
	ssize_t rid;
	sql_schema *sys = find_sql_schema(m->session->tr, "sys");
	sql_table *users = find_sql_table(sys, "db_users");
	sql_column *users_name = find_sql_column(users, "t");

	rid = column_find_row(m->session->tr, users_name, user, NULL);
	if (rid < 0)
		return FALSE;

	if (passwd != NULL) {
		str err = AUTHsetPassword(&user, &passwd);
		if (err != MAL_SUCCEED) {
			(void)sql_error(m, 02, "%s", err);
			return(FALSE);
		}
	}
	if (schema_id) {
		sql_table *info = find_sql_table(sys, "db_user_info");
		sql_column *users_schema = find_sql_column(info, "default_schema");

		column_update_value(m->session->tr, users_schema, rid, &schema_id);
	}
	return TRUE;
}

void
monet5_user_init(backend_functions *be_funcs)
{
	be_funcs->fcuser		= &monet5_create_user;
	be_funcs->fduser		= &monet5_drop_user;
	be_funcs->ffuser		= &monet5_find_user;
	be_funcs->fcrpriv		= &monet5_create_privileges;
	be_funcs->fshuser		= &monet5_schema_has_user;
	be_funcs->fauser		= &monet5_alter_user;
}

str
monet5_user_get_def_schema(mvc *m, oid user)
{
	ssize_t rid;
	oid schema_id;
	sql_schema *sys = NULL;
	sql_table *user_info = NULL;
	sql_column *users_schema = NULL;
	sql_table *schemas = NULL;
	sql_column *schemas_name = NULL;
	sql_column *schemas_id = NULL;
	sql_table *auths = NULL;
	sql_column *auths_name = NULL;

	void *p;

	str schema = NULL;
	str username = NULL;
	str err = NULL;

	if (m->debug)
		fprintf(stderr, "monet5_user_get_def_schema " OIDFMT "\n", user);

	if ((err = AUTHresolveUser(&username, &user)) != MAL_SUCCEED) {
		GDKfree(err);
		return(NULL);	/* don't reveal that the user doesn't exist */
	}

	mvc_trans(m);

	sys = find_sql_schema(m->session->tr, "sys");
	user_info = find_sql_table(sys, "db_user_info");
	users_schema = find_sql_column(user_info, "default_schema");
	p = column_find_value(m->session->tr, users_schema, user);
	schema_id = *(oid*)p;
	_DELETE(p);

	schemas = find_sql_table(sys, "schemas");
	schemas_name = find_sql_column(schemas, "name");
	schemas_id = find_sql_column(schemas, "id");
	auths = find_sql_table(sys, "auths");
	auths_name = find_sql_column(auths, "name");

	if ((rid = column_find_row(m->session->tr, schemas_id, &schema_id, NULL)) >= 0)
		schema = column_find_value(m->session->tr, schemas_name, rid);

	/* only set schema if user is found */
	rid = column_find_row(m->session->tr, auths_name, username, NULL);
	if (rid >= 0) {
		sql_column *auths_id = find_sql_column(auths, "id");
		p = column_find_value(m->session->tr, auths_id, rid);
		int id = *(int *) p;
		_DELETE(p);

		m->user_id = m->role_id = id;

		m->user = _strdup(username);
		m->role = _strdup(username);
	} else {
		schema = NULL;
	}

	if (!schema || !mvc_set_schema(m, schema)) {
		if (m->session->active)
			mvc_rollback(m, 0, NULL);
		return NULL;
	}
	/* only now we can initialize the sessions table */
	sql_sessions(m);
	mvc_rollback(m, 0, NULL);
	return schema;
}
