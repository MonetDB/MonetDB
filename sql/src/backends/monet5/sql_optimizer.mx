@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f sql_optimizer
@t SQL catalog management
@a N. Nes, M.L. Kersten
@+ SQL scenario
The SQL scenario implementation is a derivative of the MAL session scenario.

It is also the first version that uses state records attached to
the client record. They are initialized as part of the initialization 
phase of the scenario.

The SQL compiler uses only a small subset of the MAL language.
This involves ca 70 different operators, divided into the
catalog management (?) and query processing (?)
@{
[Make complete list of MAL instructions used in the compilation]
alarm.usec
algebra.count
algebra.ds_link
algebra.join
algebra.kunique
algebra.likeselect
algebra.tmark
algebra.outerjoin
algebra.semijoin
algebra.sintersect
algebra.slice
algebra.tunique
algebra.uselect
bat.append
batcalc.project
bat.insert
bat.mirror
bat.new
bat.replace
bat.reverse
bat.seqbase
bat.{setReadMode, setWriteMode}
bat.sort
bat.tsort
bbp.project
calc.{<,<=,=,!=,>,>=}
calc.{-.+.*,/,%}
calc.{oid,int,flt,dbl,str,chr,bit}
group.group 
group.refine
group.refine_reverse
io.printf
optimizer.multiplex
sql.assert
sql.bind
sql.bind_dbat
sql.bind_idxbat
sql.bind_ubat
sql_cache.???
sql.clear_table
sql.column
sql.columnBind
sql.eval
sql.output
sql.print
sql.update_var
str.codeset
stream.close
stream.openRead
str.iconv
??.{sum,min,max,count}
@}
@h
#ifndef _SQL_OPTIMIZER_H_
#define _SQL_OPTIMIZER_H_
#include "sql.h"

/* #define _SQL_OPTIMIZER_DEBUG  */

sql_export void addQueryToCache(Client c);
sql_export void optimizeQueryInCache(Client c);
sql_export str SQLoptimizer(Client c);
sql_export void SQLsetAccessMode(Client c);
sql_export void SQLmarkTOptimizer(Client c);

#endif /* _SQL_OPTIMIZER_H_ */

@-
The queries are stored in a cache after they have been
type checked and optimized.
@c
#include "mal_macro.h"
#include "mal_optimizer.h"
#include "mal_peephole.h"
#include "mal_debugger.h"
#include "sql_mvc.h"
#include "sql_optimizer.h"
#include "sql_scenario.h"
#include "sql_gencode.h"
#include "mal_namespace.h"

void
addQueryToCache(Client c)
{
	Module cache;
	backend *be = ((backend *) c->state[PARSER]);

	cache = findModule(c->nspace, putName("sql_cache",9));
	if (cache == 0) {
		return;
	}
	insertSymbol(cache, c->curprg);
	trimMalBlk(c->curprg->def);
	c->blkmode = 0;
	chkProgram(c->nspace, c->curprg->def);
#ifdef _SQL_OPTIMIZER_DEBUG
	printf("ADD QUERY TO CACHE\n");
	printFunction(GDKout,c->curprg->def,LIST_MAL_ALL);
#endif
@-
An error in the compilation should be reported to the user.
And if the debugging option is set, the debugger is called
to allow inspection.
@c
	if (c->curprg->def->errors) {
		mvc *m;
		m = ((mvc *) c->state[OPTIMIZE]);
		showErrors();


		if (c->listing)
			printFunction(c->fdout, c->curprg->def, c->listing);
		stream_flush(c->fdout);
		if ( m->debug )
			runMALDebugger(c->curprg);
		return;
	}
	if (be->mvc->factory)
		optimizeQueryInCache(c);
}

@-
The first step towards an SQL optimizer.
This version simply runs through the MAL script and re-orders the instructions
into catalog operations, query graph, and result preparation.
This distinction is used to turn the function into a factory, which would
enable re-entry when used as a cache-optimized query.
The second optimization is move access mode changes on the base tables
to the front of the plan.

We also apply the Alias Removal optimizer to trim the instruction list
by removing simple assignments.

@c
#define TOSMALL 3

str
SQLoptimizer(Client c)
{
	(void) c;
#ifdef _SQL_OPTIMIZER_DEBUG
	stream_printf(GDKout, "SQLoptimizer\n");
	printFunction(c->fdout, c->curprg->def, LIST_MAL_INSTR);
	stream_printf(GDKout, "done\n");
#endif
	return MAL_SUCCEED;
}

void
optimizeQueryInCache(Client c)
{
	MalBlkPtr mb;
	InstrPtr *ns, p;
	int t, v;
	int i, j, k, klim;/*, argseen=0;*/
	MALfcn setWriteMode = 0;
	Symbol s;
	long clk;

#ifdef _SQL_OPTIMIZER_DEBUG
	stream_printf(GDKout, "First call to SQL optimizer\n");
	printf("ABOUT TO CHANGE\n");
	printFunction(GDKout,c->curprg->def,LIST_MAL_ALL);
#endif
	resetOptimizerDebugger();
	optimizerDebug(c->curprg->def,"Parser output",1,0);
	SQLmarkTOptimizer(c);
@-
Reduce the program before other optimizations take place
@c
	MCoptimizerCommand(c->curprg->def, 0, 0, "algebra", "joinPath");
	ARoptimizer(c->curprg->def, 0, 0);
	CXoptimizer(c->curprg->def, 0, 0);
	AEoptimizer(c->curprg->def, 0, 0);
	s = findMALSymbol(getName("algebra",7),getName("joinPath",8));
	if(s) ORCAMprocessor(c->curprg->def,s);
	/* AMoptimizer(c->curprg->def, 0,0); */
	/*SQLsetAccessMode(c); done in libraries now */

	mb = c->curprg->def;
	if (mb->stop <= TOSMALL)
		return;

	s = findMALSymbol(getName("bat",3), getName("setWriteMode",12));
	if (s)
		setWriteMode = getSignature(s)->fcn;

@-
The first step is to collect all the sql bind operations and
to extract some compiler relevant properties from the catalogue.
@c
	clk= GDKusec();
	ns = (InstrPtr *) GDKmalloc(sizeof(InstrPtr) * (mb->stop * 2));
	k = 1;
	ns[0] = getInstrPtr(mb, 0);	/* its signature */
	ns[0]->token = FACTORYsymbol;
	for (i = 0; i < mb->stop; i++) {
		p = getInstrPtr(mb, i);
		if (functionName(p) && moduleName(p) && 
			strncmp(functionName(p), "bind", 4) == 0 && 
			strcmp(moduleName(p), "sql") == 0) {
			ns[k++] = p;
@-
At this stage of the implementation we experiment with collecting
information for a MAL specific optimizer. Aside from the size
of BATs, it is helpful to detect empty bats as early as possible.
The information is left behind as an ordinary call to an operator
supported by the cost model or optimizer.

We use knowledge on generation of bind() instructions.
@c
			if (strcmp(functionName(p), "bind_dbat") == 0 || 
			   (strcmp(functionName(p), "bind") == 0)) {
				int l = 0;
				InstrPtr qc;
				BAT *b = NULL;

@-
Watch out bind_dbat needs different binding. [costed me a day]
@c
				backend *be = ((backend *) c->state[PARSER]);

				if (strcmp(functionName(p), "bind_dbat") == 0)
					b = mvc_bind_dbat(be->mvc, 
							getVarLiteral(mb, p->argv[1]), 
							getVarLiteral(mb, p->argv[2]), 0);
				else
					b = mvc_bind(be->mvc, 
							getVarLiteral(mb, p->argv[1]), 
							getVarLiteral(mb, p->argv[2]), 
							getVarLiteral(mb, p->argv[3]), 0);
@-
Empty BATs can be symbolically optimized. Disabled for a while.
@c
				if ( FALSE /* b == NULL || (l= BATcount(b)) == 0 */ ) {
					qc = newInstruction(ASSIGNsymbol);
					setModuleId(qc, putName("optimizer",9));
					setFunctionId(qc, putName("RXemptyBAT",10));
					qc->argv[0] = newTmpVariable(mb, TYPE_void);
					qc->argv[1] = p->argv[0];
					qc->argc = 2;
					ns[k++] = qc;
					continue;
				}
				BBPunfix(b->batCacheid);
@-
Play around with setting a property. It should be extended
with setting the historgram property for the tail.
Such a histogram is nothing more then a BAT whose head is
an inclusive boundary value and the tail the corresponding
number of elements.
The kernel should provide some supportive routines for this
or the SQL catalogue manager could keep histograms
around for each column.
@c
				setVarProperty(mb, p->argv[0], "count", "=", TYPE_int, &l);
				/* setVarProperty(mb,p->argv[0],"histogram", 
				   TYPE_str, "r_c_histogram"); */
			}
		}
@-
Check if the relation is already made write-enabled in the plan.
It uses the knowledge that at this stage the plan is still a linear
sequence of instructions.
@c
		if (setWriteMode && p->fcn == setWriteMode) {
			for (j = 0; j < k; j++)
				if (ns[j]->fcn == setWriteMode && ns[j]->argv[1] == p->argv[1])
					break;
				else if (ns[j]->argv[0] == p->argv[1]) {
					ns[k++] = p;
					break;
				}
		}
@-
Finally, move all instructions out of the loop until you find a
reference an argument. This pre-supposes that the instructions
are invariant to multiple calls. In general this is not the case,
for consider a block that depends on the size of a BAT.
		if( argseen == 0){
			for(j=p->retc; j<p->argc; j++){
				for( k=0; k<sig->retc; k++)
				if( getArg(p,k)== getArg(sig,k)
					argseen=1;
			}
			if( argseen==0)
				ns[k++]= p;
		}
@c
	}
	klim = k;		/* remember the head */
@-
The prelude code has been generated, now we can inject the remaining
instructions, producing a syntactic correct MAL program again.
@c
	t = newConstant(mb, TYPE_bit, GDKstrdup("true"), 0);
	v = newVariable(mb, GDKstrdup("always"), TYPE_bit);
	p = newInstruction(ASSIGNsymbol);
	p->barrier = BARRIERsymbol;
	p->argv[0] = v;
	pushArgument(mb, p, t);
	ns[k++] = p;

	for (i = 1; i < mb->stop - 1; i++) {
		int doit = 0;

		p = getInstrPtr(mb, i);
		if (!(functionName(p) && moduleName(p) && 
			  strncmp(functionName(p), "bind", 4) == 0 && 
			  strcmp(moduleName(p), "sql") == 0))
			doit = 1;
@-
Skip it if the writeMode relates to a base table
@c
		if (setWriteMode)
			for (j = 0; j < klim; j++)
				if (ns[j] == p)
					doit = 0;
		if (doit)
			ns[k++] = p;
	}
@-
Finalize the factory loop
@c
	p = newInstruction(ASSIGNsymbol);
	p->barrier = YIELDsymbol;
	p->argv[0] = v;
	ns[k++] = p;
	p = newInstruction(ASSIGNsymbol);
	p->barrier = REDOsymbol;
	p->argv[0] = v;
	ns[k++] = p;
	p = newInstruction(ASSIGNsymbol);
	p->barrier = EXITsymbol;
	p->argv[0] = v;
	ns[k++] = p;
	ns[k++] = getInstrPtr(mb, i);

	mb->stop = k;
	GDKfree(mb->stmt);
	mb->stmt = ns;

	optimizerCheck(mb,"sql.factorize",1,GDKusec()-clk);
@-
At this stage we can once call upon the optimizers to do their work.
Static known information is known and stored in constant variables,
which can be used by the rewrite rules.
This all works under the assumption that the SQL layer properly invalidates
the cache when the underlying table is changed.
@c
#ifdef _SQL_OPTIMIZER_DEBUG
	printf("DONE CHANGES\n");
	printFunction(c->fdout, c->curprg->def, LIST_MAL_INSTR);
#endif
}

@-
The code produced by the SQL front-end only sets the access mode
when a BAT will become updated. In all other cases, it relies
on the M4 policy that intermediate results are considered
readonly. Readonly mode often improves processing speed.

To compensate for this behaviour, a final pass is made 
to inject the access modes in all places relevant.
In this case, we start with the mark operations, which
will be faster when the operand is read only.
Likewise, an append or insert requires write access.
@= setAccess
	if (p->fcnname && strcmp(p->fcnname,@1)==0) {
		q = newInstruction(ASSIGNsymbol);
		q->modname = putName("bat",3);
		q->fcnname = putName(@2,strlen(@2));
		q->argv[0] = newTmpVariable(mb,TYPE_any);
		q->argv[1] = p->argv[1];
		q->argc = 2;
		ns[k++] = q;
	}
@c
void
SQLsetAccessMode(Client c)
{
	MalBlkPtr mb;
	InstrPtr *ns, p, q;
	int k, i;

	mb = c->curprg->def;
	ns = (InstrPtr *) GDKmalloc(sizeof(InstrPtr) * mb->stop * 2);
	k = 0;
	for (i = 0; i < mb->stop; i++) {
		p = getInstrPtr(mb, i);
		@:setAccess("mark","setReadMode")@
		@:setAccess("append","setWriteMode")@
		@:setAccess("insert","setWriteMode")@
		@:setAccess("replace","setWriteMode")@
		ns[k++] = p;
	}
	mb->ssize = 2 * mb->stop;
	mb->stop = k;
	GDKfree(mb->stmt);
	mb->stmt = ns;
}
@-
The SQLkdiffOptimizer searches this important operator and splits
the dataflow graph into two sections with a switch on the size of
the second operand. In many situations it is empty, there are no
deleted tuples to consider. The effect is that we do not have
to reduce the table to elements that are still valid.

Beware, the SQL code may contain several kdiff statements.
One for each base table touched. They should all be split,
which leads to an explosion in the plan sizes
@c
void SQLkdiffOptimizer(Client c){
	MalBlkPtr mb;
	int limit,i,k,l,foundit=1,total=0, zero,cnt,lab;
	InstrPtr *old;
	InstrPtr q,p;
	int *map,mtop;
	long clk= GDKusec();

#ifdef _SQL_OPTIMIZER_DEBUG
	printf("START kdiff optimizer\n");
	printFunction(GDKout,c->curprg->def,LIST_MAL_ALL);
#endif
	while(foundit) {
		foundit=0;
		mb= c->curprg->def;
		setLifespan(mb);
		limit=mb->stop;
		old= mb->stmt;
		newMalBlkStmt(mb,mb->stop*2+5);

		for(i=0;i<limit; i++){
			p= old[i];
			if( moduleId(p) && strcmp(moduleName(p),"sql")==0 &&
			    strcmp(functionName(p),"kdiff")==0){
				total++;
				foundit++;
@-
The starting situation is to obtain the count and perform
an instruction copy until the endLifespan of the first operand.
	cnt:= algebra.count(t);
barrier doit:= c>0;
	....
exit	doit;
	..rest of code
@c
				q= newInstruction(ASSIGNsymbol);
				cnt= newTmpVariable(mb,TYPE_lng);
				setVarUsed(mb,cnt,TRUE);
				q->argv[0]=cnt;
				q->argv[1]= p->argv[2];
				q->argc=2;
				setModuleId(q,putName("algebra",7));
				setFunctionId(q,putName("count",5));
				pushInstruction(mb,q);

				q= newInstruction(ASSIGNsymbol);
				q->barrier= BARRIERsymbol;
				lab= newTmpVariable(mb,TYPE_bit);
				setVarUsed(mb,lab,TRUE);
				zero= newConstant(mb,TYPE_lng,GDKstrdup("0:lng"),FALSE);
				setVarUsed(mb,cnt,TRUE);
				setVarInitialized(mb,cnt);
				setVarUsed(mb,zero,TRUE);
				setModuleId(q,putName("calc",4));
				setFunctionId(q,putName(">",1));
				q->argv[0]=lab;
				q->argv[1]=cnt;
				q->argv[2]=zero;
				q->retc=1;
				q->argc=3;
				pushInstruction(mb,q);
@-
We have to perform the expensive kdiff anyway
@c
				q= newInstruction(ASSIGNsymbol);
				setModuleId(q,putName("algebra",7));
				setFunctionId(q,putName("kdiff",5));
				q->argv[0]= p->argv[0];
				q->retc=1;
				pushArgument(mb,q,p->argv[1]);
				pushArgument(mb,q,p->argv[2]);
				pushInstruction(mb,q);
				typeChecker(c->nspace,mb,q,TRUE);
				/* endLifespan = mb->var[p->argv[0]]->endLifespan;*/
				k= i; /* for later */
				for(i++;i< limit-1; i++){
					q= old[i];
/* just handle the first */
					pushInstruction(mb,q);
					if( moduleId(q) && strcmp(moduleName(q),"sql")==0 &&
						strcmp(functionName(q),"kdiff")==0){
						setModuleId(q,putName("algebra",7));
					}
				}
				i--;

				q= newInstruction(EXITsymbol);
				q->barrier= EXITsymbol;
				q->argv[0]= lab;
				pushInstruction(mb,q);

@-
Durig the second phase we copy the same sequence, but
now we have to remap the variables. In this process the
variable types may change, which means we have to keep
track of them.
@c
				q= newInstruction(ASSIGNsymbol);
				q->barrier= BARRIERsymbol;
				setModuleId(q,putName("calc",4));
				setFunctionId(q,putName("==",2)); 
				q->argv[0]=lab;
				q->argv[1]=cnt;
				q->argv[2]=zero;
				q->retc=1;
				q->argc=3;
				pushInstruction(mb,q);
@-
Now we don;t have to perform the expensive kdiff 
@c
				map= (int*) GDKmalloc(2 * sizeof(int)*mb->vtop);
				map[0]= getArg(p,0);
				map[1]= getArg(p,1);
				mtop=2;

				i=k; 
				for(i++;i< limit-1; i++){
					q= copyInstruction(old[i]);
/* just handle the first */
					if( moduleId(q) && strcmp(moduleName(q),"sql")==0 &&
						strcmp(functionName(q),"kdiff")==0){
						setModuleId(q,putName("algebra",7));
					}
					for(k=0;k<q->argc; k++)
					for(l=0;l<mtop; l+=2)
					if( getArg(q,k)== map[2*l] ){
						/* deal with the type compatibility issue */
						q->argv[k]= map[2*l+1];
						break;
					}
					pushInstruction(mb,q);
				}
				i--;

				q= newInstruction(EXITsymbol);
				q->barrier= EXITsymbol;
				q->argv[0]= lab;
				pushInstruction(mb,q);

				/* remove the old instruction */
				GDKfree(map);
				freeInstruction(p);
				continue;
			}
			/* just move the instruction into place */
			pushInstruction(mb,p);
		}
@-
The code is wrong, we should not try it more than once
		foundit= foundit || (i<limit);
@c
		foundit=0;
		GDKfree(old);
	}
	if( total) {
		optimizerCheck(mb,"sql.kdiff_replacement",1,GDKusec()-clk);
#ifdef _SQL_OPTIMIZER_DEBUG
		printf("FINAL STAGE errors=%d\n",mb->errors);
		printFunction(GDKout,mb,LIST_MAL_ALL);
#endif
	}
}
@- markT ->markH
More peephole optimizations. M5 contains more primitives to play with.
They are looked for here.
The sequence [markT,reverse] is replaced by markH.
Beware, we assume that the base is set to 0@0.
The sequence [group,tunique] is turning into a multi-assignment group
@c
void
SQLmarkTOptimizer(Client c){
	MalBlkPtr mb;

	mb= c->curprg->def;
	setLifespan(mb);
	/* PHoptimizer(mb,NULL,NULL); still erroneous */
}

@}
