@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2007 CWI.
@' All Rights Reserved.

@f embeddedclient
@a K.S. Mullender
@* Embedded MonetDB
The purpose of this Embedded MonetDB is to illustrate how the
code base can be easily linked with a stand-alone application.
The current implementation uses a minimalistic approach, i.e.
using the Mapi prototol to communicate between application thread
and the database kernel.
This communication is not optimized for speed. 

An area that has undergone some tweaking for performance improvement
are the large number of lock calls needed in the GDK kernel to safely run
multiple clients against the database. 
For direct linkage to an application we suggest to use the monet_embedded
option, which allows just one mapi connection to be set up. This allows
for removal of all lock calls in the kernel. This improves performance
between 25-50%.
@h
#ifndef _EMBEDDEDCLIENT_H_
#define _EMBEDDEDCLIENT_H_

#include "monet_options.h"

#ifdef WIN32
#ifndef LIBEMBEDDEDSQL5
#define embeddedclient_export extern __declspec(dllimport)
#else
#define embeddedclient_export extern __declspec(dllexport)
#endif
#else
#define embeddedclient_export extern
#endif

#include <streams.h>
#include <mapilib/Mapi.h>

#ifdef __cplusplus
extern "C" {
#endif

embeddedclient_export Mapi monetdb_sql(char *dbfarm, char *dbname);
embeddedclient_export Mapi embedded_sql(opt *set, int len);

#ifdef __cplusplus
}
#endif

#endif /* _EMBEDDEDCLIENT_H_ */
@c
#include <sql_config.h>
#include "embeddedclient.h"

#include "gdk.h"
#ifdef HAVE_PTHREAD_H
/* pthread.h on Windows includes config.h if HAVE_CONFIG_H is set */
#undef HAVE_CONFIG_H
#ifdef pid_t
#undef pid_t
#endif
#include <sched.h>
#include <pthread.h>
#endif

#include "mal.h"
#include "mal_session.h"
#include "mal_import.h"
#include "mal_client.h"
#include "mal_function.h"
#include "mal_authorize.h"

static void
Monet_init(opt **set, int setlen)
{
	/* determine Monet's kernel settings. */
	setlen = mo_add_option(set, setlen, opt_cmdline, "gdk_embedded", "yes");
	if (!GDKinit(*set, setlen))
		return;
	monet_daemon = GDKembedded;
}

static opt *embedded_set = NULL;
static int embedded_len = 0;

static void *
start_sql_server(void *arg)
{
	static int initialized = 0;
	stream *in, *out;
	char buf[128];

	if (!initialized) {
/* 		monet_singlethreaded = 1; */
		if (embedded_set == NULL) {
			int len = mo_builtin_settings(&embedded_set);
			embedded_len = mo_system_config(&embedded_set, len);
		}
		Monet_init(&embedded_set, embedded_len);
		/* you don;t need the commandline arguments anymore */
		mo_free_options(embedded_set, embedded_len);
		if (mal_init())
			return 0;
		{
			/* unlock the vault, first see if we can find the file which
			 * holds the secret */
			char* secret = alloca(sizeof(char) * 1024);
			FILE* secretf;
			size_t len;
			
			if (GDKgetenv("monet_vault_key") == NULL) {
				/* use a default (hard coded, non safe) key */
				secret = "Xas632jsi2whjds8";
			} else {
				if ((secretf = fopen(GDKgetenv("monet_vault_key"), "r")) == NULL) 
					return 0;
				len = fread(secret, 1, 1023, secretf);
				secret[len] = '\0';
				fclose(secretf);
			}
			if (AUTHunlockVault(&secret) != MAL_SUCCEED)
				return 0;
		}
		/* make sure the authorisation BATs are loaded */
		if (AUTHinitTables() != MAL_SUCCEED)
			return 0;
		MSinitClientPrg(mal_clients, "user","main");
		initialized = 1;
	}

	in = ((stream **) arg)[0];
	out = ((stream **) arg)[1];
	free(arg);
	snprintf(buf, sizeof(buf), 
		"include sql;\n"
		"in  := \"" PTRFMT "\":streams;\n"
		"out := \"" PTRFMT "\":streams;\n"
		"mserver.malclient(in, out);\n", PTRFMTCAST in, PTRFMTCAST out);
	callString(mal_clients, buf, 0);
	return NULL;
}

Mapi
embedded_sql(opt *set, int len)
{
	Mapi mid;
	pthread_t sqlthread;
	stream **server;

	if (set) {
		embedded_set = set;
		embedded_len = len;
	}
	server = mapi_embedded_init(&mid,"sql");

	pthread_create(&sqlthread, NULL, start_sql_server, (void *) server);

	mapi_start_talking(mid);

	return mid;
}

Mapi
monetdb_sql(char *dbfarm, char *dbname)
{
	Mapi mid;
	pthread_t sqlthread;
	stream **server;

	int len = mo_builtin_settings(&embedded_set);

	/* needed, to prevent the MonetDB config file to be used */  
	len = mo_add_option(&embedded_set, len, opt_config, "prefix", MONETDB5_PREFIX);
	len = mo_add_option(&embedded_set, len, opt_config, "config", MONETDB5_CONFFILE);

	embedded_len = mo_system_config(&embedded_set, len);
	embedded_len = mo_add_option(&embedded_set, embedded_len, opt_cmdline, "gdk_dbfarm", dbfarm);
	embedded_len = mo_add_option(&embedded_set, embedded_len, opt_cmdline, "gdk_dbname", dbname);

	server = mapi_embedded_init(&mid,"sql");

	pthread_create(&sqlthread, NULL, start_sql_server, (void *) server);

	mapi_start_talking(mid);

	return mid;
}
