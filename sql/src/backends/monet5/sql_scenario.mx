@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f sql_scenario
@t SQL catalog management
@a N. Nes, M.L. Kersten
@+ SQL scenario
The SQL scenario implementation is a derivative of the MAL session scenario.

It is also the first version that uses state records attached to
the client record. They are initialized as part of the initialization 
phase of the scenario.

@h
#ifndef _SQL_SCENARIO_H_
#define _SQL_SCENARIO_H_
#include "sql.h"

/* #define _SQL_SCENARIO_DEBUG */
/* #define _SQL_READER_DEBUG */
/* #define _SQL_PARSER_DEBUG  */

sql_export str SQLexitClient(Client c);
sql_export str SQLinitClient(Client c);
sql_export str SQLexit(Client c);
sql_export str SQLinit(Client c);
sql_export str SQLinitEnvironment(int *ret);

sql_export str SQLparser(Client c);
sql_export str SQLengine(Client c);

#endif /* _SQL_SCENARIO_H_ */

@+ Scenario routines
Before we are can process SQL statements the global catalog
should be initialized. Thereafter, each time a client enters
we update its context descriptor to denote an SQL scenario.
@c
#include "sql_scenario.h"
#include "sql_result.h"
#include "sql_gencode.h"
#include "sql_optimizer.h"
#include "sql_cache.h"
#include "sql_env.h"
#include "sql_readline.h"
#include "print.h"
#include "mal_parser.h"
#include <bat/res_table.h>
#include "mal_namespace.h"
#include "mal_debugger.h"
#include "bat.h"

static void pushCatchDefault(MalBlkPtr mb, str nme, int autocommit);

static int SQLinitialized;

static void
monet5_freestack(backend_stack stk)
{
	(void) stk;
#ifdef _SQL_SCENARIO_DEBUG
	stream_printf(GDKout, "#monet5_freestack\n");
#endif
}

static void
monet5_parse(backend_stack stk, char *cmd)
{
	(void) stk;
	(void) cmd;
#ifdef _SQL_SCENARIO_DEBUG
	stream_printf(GDKout, "#monet5_parse:%s\n", cmd);
#endif
}

static void
monet5_freecode(backend_code code, backend_stack stk, int nr)
{
	(void) code;
	(void) stk;
	(void) nr;
#ifdef _SQL_SCENARIO_DEBUG
	stream_printf(GDKout, "#monet5_free:%d\n", nr);
#endif
}

str
SQLinit(Client c)
{
#ifdef _SQL_SCENARIO_DEBUG
	stream_printf(GDKout, "#SQLinit Monet 5\n");
#endif
	if (SQLinitialized)
		return MAL_SUCCEED;
	SQLinitialized = FALSE;
	(void) c;		/* not used */
	backend_init(&monet5_freestack, &monet5_freecode, &monet5_parse);
	if (mvc_init(FALSE, 0) < 0) {
		return throwMessage("SQLinit", "Catalogue initialization failed\n");
	}
	SQLinitialized = TRUE;
	return MAL_SUCCEED;
}

str
SQLexit(Client c)
{
#ifdef _SQL_SCENARIO_DEBUG
	stream_printf(GDKout, "#SQLexit\n");
#endif
	(void) c;		/* not used */
	if( SQLinitialized == FALSE){
		return throwMessage("SQLexit",
			"Catalogue not available\n");
	}
	/* the SQL scenario support may never be finished
	mvc_exit();
	SQLinitialized= FALSE;
	*/
	return MAL_SUCCEED;
}

static int
sendProperty(stream *out, char *name, char *value)
{
	if (stream_write(out, "[ \"", 1, 3) != 3)
		return 0;
	while (*name) {
		switch (*name) {
		case '"':
			if (stream_write(out, "\\\"", 1, 2) != 2)
				return 0;
			break;
		case '\\':
			if (stream_write(out, "\\\\", 1, 2) != 2)
				return 0;
			break;
		default:
			if (stream_write(out, name, 1, 1) != 1)
				return 0;
			break;
		}
		name++;
	}
	if (stream_write(out, "\", \"", 1, 4) != 4)
		return 0;
	while (*value) {
		switch (*value) {
		case '"':
			if (stream_write(out, "\\\"", 1, 2) != 2)
				return 0;
			break;
		case '\\':
			if (stream_write(out, "\\\\", 1, 2) != 2)
				return 0;
			break;
		default:
			if (stream_write(out, value, 1, 1) != 1)
				return 0;
			break;
		}
		value++;
	}
	if (stream_write(out, "\" ]\n", 1, 4) != 4)
		return 0;
	return 1;
}
@-
It should become possible to initialize the SQL
from a MAL program to setup an environment to
debug independently of the parser plans
produced. This should not touch the IO parameters.
@c
str 
SQLinitAdmin(Client c)
{
	str msg;
	mvc *m;
	str schema;
	msg = SQLinit(c);
	if (msg != MAL_SUCCEED)
		return msg;
	
	if ((backend *) c->state[PARSER] == 0) {
		m = mvc_create(1, 0, c->fdin, c->fdout);
		/* replace user name with client record setting later on */
		schema = mvc_login(m, "monetdb", "monetdb");
		if (!schema) {
			return throwMessage("SQLparser", "No schema defined\n");
		} else {
			if (!sendProperty(c->fdout, "version", "5") ||
				!sendProperty(c->fdout, "language", "sql") ||
				!sendProperty(c->fdout, "schema", schema) ||
				stream_flush(c->fdout) < 0)
			{
				mvc_destroy(m);
				return throwMessage("SQLparser", "Disconnected\n");
			}
		}
		c->state[PARSER] = (void *) backend_create(0 /*debug */ , m, c);
	((backend*)c->state[PARSER])->language = 's';	/*expect SQL text first */
		c->state[OPTIMIZE] = m;
	} else {
		m = c->state[OPTIMIZE];
	}
	return MAL_SUCCEED;
}

str
SQLinitClient(Client c)
{
	str msg;

#ifdef _SQL_SCENARIO_DEBUG
	stream_printf(GDKout, "#SQLinitClient\n");
#endif

	msg = SQLinitAdmin(c);

	c->yycur = 0;		/* make sure we don't reuse the used input */
	c->fdin->eof = 1;	/* force prompt on first iteration */
	return msg;
}

str
SQLexitClient(Client c)
{
#ifdef _SQL_SCENARIO_DEBUG
	stream_printf(GDKout, "#SQLexitClient\n");
#endif
	if (SQLinitialized == FALSE) {
		return throwMessage("SQLinitClient", "Catalogue not available\n");
	}
	if ((backend *) c->state[PARSER] && (mvc *) c->state[OPTIMIZE]) {
		mvc_destroy((mvc *) c->state[OPTIMIZE]);
		backend_destroy((backend *) c->state[PARSER]);
		/* files are already closed */
		c->state[OPTIMIZE] = NULL;
		c->state[PARSER] = NULL;
	}
	return MAL_SUCCEED;
}

str
SQLsession(str *ret)
{
	str msg = MAL_SUCCEED;

	stream_printf(GDKout, "#Continue as SQL session\n");
	msg = setScenario(getClient(), "sql");
	*ret = 0;
	return msg;
}

@-
A statement received internally is simply appended for
execution
@c
str
SQLinitEnvironment(int *ret)
{
	(void) ret;
	return SQLinitAdmin(getClient());
}
@-
The SQLcompile operation can be used by separate
front-ends to benefit from the SQL functionality.
It expects a string and returns the name of the
corresponding MAL block as it is known in the
SQL_cache, where it can be picked up.
@c
#define _SQL_COMPILE 
str
SQLcompile(str *ret, str *expr, int *flag)
{
	int err = 0;
	mvc *m;
	backend *sql;
	bstream *rs;
	buffer *b;
	char *n;
	str msg= MAL_SUCCEED;
	Client c= getClient();
	int len = strlen(*expr);

	(void) ret;
	SQLinit(c);
#ifdef _SQL_COMPILE
	stream_printf(c->fdout, "#SQLstatement:flag=%d:%s\n", *flag, *expr);
#endif

	b = (buffer*)GDKmalloc(sizeof(buffer));
	n = GDKmalloc(len + 1 + 1);
	strncpy(n, *expr, len);
	n[len] = '\n';
	n[len+1] = 0;
	len++;

	buffer_init(b, n, len);
	rs = bstream_create(buffer_rastream(b, "sqlstatement"), b->len);
	m = mvc_create(0, 0, rs, GDKout);
	mvc_trans(m);		/* start transaction */
	m->user_id = m->role_id = USER_MONETDB;
	m->user = _strdup("monetdb");
	m->trans->schema = mvc_bind_schema(m, "sys");
	m->scanner.mode = LINE_1; 
	bstream_next(m->scanner.rs);
	sql = backend_create(0 /* debug */, m, c);

@-
System has been prepared to parse it and generate code
@c
	if ((err = sqlparse(m)) ){
		if( m->mode == m_debug){
			/* switch to differnt language mode */
			char oldlang= sql->language;
			sql->language= 'D';
			runMALDebugger(c->curprg);
			sql->language= oldlang;
		}
		err = mvc_status(m);
		sqlcleanup(m, err);
		*m->errstr = 0;
		msg = throwMessage("SQLparser", "Parser errors\n");
		goto endofcompile;
	}
@-
We have dealt with the first parsing step and advanced the input reader
to the next statement (if any).
Now is the time to also perform the semantic analysis, 
optimize and produce code.
We don;t search the cache for a previous incarnation.
@c
	{	stmt *s = sql_symbol2stmt(m);
		char buffer[128];
		Symbol prg;
		MalBlkPtr blk;

		if (!s && (err = mvc_status(m))) {
			stream_printf(c->fdout, "#%s\n", m->errstr);
			*m->errstr = 0;
			sqlcleanup(m, err);
			msg = throwMessage("SQLparser", "Semantic errors\n");
			goto endofcompile;
		}
		assert(s);
		/* generate MAL procedure code */
		snprintf(buffer,128,"sql_%d",m->qc->id);
		*ret= GDKstrdup(buffer);
		prg= newFunction(putName(buffer,strlen(buffer)), FUNCTIONsymbol);
		blk= prg->def;
		backend_dumpstmt(sql, blk, s);
		pushEndInstruction(blk);
#ifdef _SQL_COMPILE
		chkProgram(c->nspace, blk);
		printFunction(c->fdout, blk, c->listing);
#endif
		insertSymbol(c->nspace, prg);
	}
#ifdef _SQL_COMPILE
	stream_printf(c->fdout, "#parse result %d\n", err);
#endif
@-
We are done; a MAL procedure recides in the cache.
@c
endofcompile:
	backend_destroy(sql);
	GDKfree(n);
	GDKfree(b);

	if( *flag==0) {
#ifdef _SQL_COMPILE
		stream_printf(GDKout,"commit the catalogue\n");
#endif
		mvc_commit(m, 0, NULL); /* keep the changes */
	} else mvc_rollback(m, 0, NULL);
	res_tables_destroy(m->results);
	mvc_destroy(m);

	SQLexit(c);
	return msg;
}
str
SQLcompile0(str *ret, str *expr)
{
	int flag= -1;
	return SQLcompile(ret,expr,&flag);
}
@-
Implementation of the execution of a single SQL statement is postponed.
@c
str
SQLstatement(str *ret, str *cmd)
{
	int flag=0;

#ifdef _SQL_READER_DEBUG
	stream_printf(GDKout, "#SQLstatement:%s\n", *cmd);
#endif
	SQLcompile(ret,cmd,&flag);
	return MAL_SUCCEED;
}

static int
error(stream *out, char *str)
{
	char *p;

	if (!out)
		out = GDKerr;

	if (stream_errnr(out))
		return -1;
	while ((p = strchr(str, '\n')) != NULL) {
		p++;		/* include newline */
		if (*str !='!' && stream_write(out, "!", 1, 1) != 1)
			return -1;
		if (stream_write(out, str, p - str, 1) != 1)
			 return -1;
		str = p;
	}
	if (str &&*str) {
		if (*str !='!' && stream_write(out, "!", 1, 1) != 1)
			return -1;
		if (stream_write(out, str, strlen(str), 1) != 1 || stream_write(out, "\n", 1, 1) != 1)
			 return -1;
	}
	return 0;
}

#define TRANS_ABORTED "!current transaction is aborted (please ROLLBACK)\n"

int
handle_error(mvc *m, stream *out, int pstatus)
{
	int go = 1;
	char *buf = GDKerrbuf;

	/* transaction already broken */
	if (m->type != Q_TRANS && pstatus < 0) {
		if (stream_write(out, TRANS_ABORTED, sizeof(TRANS_ABORTED) - 1, 1) != 1) {
			go = !go;
		}
	} else {
		if (error(out, m->errstr) < 0 || (buf && buf[0] && error(out, buf) < 0)) {
			go = !go;
		}
	}
	/* reset error buffers */
	m->errstr[0] = 0;
	if (buf)
		buf[0] = 0;
	return go;
}


@-
The SQL reader collects a (sequence) of statements from the input
stream, but only when no unresolved 'nxt' character is visible.
In combination with SQLparser this ensures that all statements
are handled one by one.

The SQLreader is called from two places: the SQL parser and
the MAL debugger.
The former only occurs during the parsing phase and the
second only during exection.
This means we can safely change the language setting for
the duration of these calls.
@c
int SQLautocommit(Client c, mvc *m){
	if (m->auto_commit && m->trans) {
		if (m->cache && (m->type == Q_TRANS || 
			m->type == Q_SCHEMA || 
			m->qc->id >100)) {
			if (m->qc) 
				qc_destroy(m->qc);
			m->qc = qc_create();
		}
		if (mvc_status(m) < 0) {
			mvc_rollback(m, 0, NULL);
		} else if (mvc_commit(m, 0, NULL) < 0) {
				 	return handle_error(m, c->fdout, 0);
				}
			}
	return TRUE;
}

str
SQLreader(Client c)
{
	int go = TRUE;
	lng T0;
	backend *be = ((backend *) c->state[PARSER]);
	bstream *in = c->fdin;
	int language = be->language;	/* 'S' for SQL, 'D' from debugger */
	mvc *m = be->mvc;

#ifdef _SQL_READER_DEBUG
	stream_printf(GDKout, "#SQLparser: start reading SQL block\n");
	stream_flush(GDKout);
#endif
	if (!be || c->mode <= FINISHING)
		return throwMessage("SQLreader", "end of SQL input\n");

@- 
Continue processing any left-over input from the previous round.
@c
	T0 = GDKusec();
	while (in->pos < in->len &&
		(isspace((int) (in->buf[in->pos])) || in->buf[in->pos] == ';'))
		in->pos++;

#ifdef _SQL_READER_DEBUG
	stream_printf(GDKout, "#pos %d len %d\n", in->pos, in->len);
	stream_flush(GDKout);
#endif
	/* skip whitespace */
	while (in->pos < in->len && (isspace((int) (in->buf[in->pos])) || in->buf[in->pos] == ';'))
		in->pos++;
@-
Distinguish between console reading and MapiClient connections.
The former comes with readlin functionality.
@c
    if( c == mal_clients){
		/* The rules of auto_commit require us to finish 
		   and start a transaction on the start of a new statement */
/* Niels, final adjustments are needed to synchronize with the scanner
		go = SQLautocommit(c,m);
		if( go ) {
			c->fdin->pos=0;
			c->yycur = 0;
			go= SQLreadConsole(c);
			printf("got input:%d\n",go);
		}
		if( go < 0) go = TRUE;
		if( !go ){
			in->pos = in->len;	
			c->mode = FINISHING;
			return throwMessage("SQLreader", "end of SQL input\n");
		}
		if (be)
			be->Tread = GDKusec() - T0;
		return MAL_SUCCEED;
*/
    }

	if (go && in->pos >= in->len) {
		ssize_t rd;

		if (c->bak) {
			popClientInput(c);
			in = c->fdin;
			m->scanner.rs = c->fdin;
			c->fdin->pos += c->yycur;
			c->yycur = 0;
		}
		if (in->eof || !isa_block_stream(in->s)) {
			language = (be->console) ? 'S' : 0;

			/* The rules of auto_commit require us to finish 
			   and start a transaction on the start of a new statement */
			go = SQLautocommit(c,m);

			if (go && (stream_write(c->fdout, c->prompt, c->promptlength, 1) != 1 || stream_flush(c->fdout))) {
				go = FALSE;
			}
			in->eof = 0;
		}
		if (go && (rd = bstream_next(in)) <= 0) {
#ifdef _SQL_READER_DEBUG
			stream_printf(GDKout, "#rd %d  language %d eof %d\n", rd, language, in->eof);
			stream_flush(GDKout);
#endif
			if (be->language == 'D' && in->eof == 0) {
				return 0;
			}
			if (rd == 0 && language != 0 && in->eof && !be->console) {
				/* we hadn't seen the EOF before, so just try again
				   (this time with prompt) */
				SQLreader(c);
			} else {
				go = FALSE;
			}
		} else if (go && !be->console && language == 0) {
			be->language = in->buf[in->pos++];
		}
#ifdef _SQL_READER_DEBUG
		stream_printf(GDKout, "#SQL blk:%s\n", in->buf + in->pos);
#endif
	}
	if (!go || (strncmp(CURRENT(c), "quit", 4) == 0)) {
		in->pos = in->len;	/* skip rest of the input */
		c->mode = FINISHING;
		return throwMessage("SQLreader", "end of SQL input\n");
	}
	if (be)
		be->Tread = GDKusec() - T0;
	return 0;
}

@-
The SQL block is stored in the client input buffer, from which it
can be parsed by the SQL parser. The client structure contains
a small table of bounded tables. This should be reset before we
parse a new statement sequence.
@-
Before we parse the sql statement, we look for any variable settings
for specific commands.
The most important one is to prepare code to be handled by the debugger.
The current analysis is simple and fulfills our short-term needs.
A future version may analyze the parameter settings in more detail.
@c

void
SQLsetDebugger(Client c, mvc *m, int onoff)
{
	InstrPtr q;

	if (m == 0 || m->mode != m_debug)
		return;
	c->itrace='n';
	q = newInstruction(ASSIGNsymbol);
	moduleId(q) = putName("mdb",3);
	if( onoff)
		functionId(q) = putName("start",5);
	else functionId(q) = putName("stop",4);
	pushInstruction(c->curprg->def, q);
}

void
SQLsetTrace(Client c, int on)
{
	if (on)
		c->listing = (c->listing & LIST_INPUT) | LIST_MAL_INSTR;
	else
		c->listing &= LIST_INPUT;
}

void
SQLsetExplain(Client c)
{
	c->listing = (c->listing & LIST_INPUT) | LIST_MAL_ALL;
}

@-
The core part of the SQL interface, parse the query and
prepare the intermediate code.
@c

str
SQLparser(Client c)
{
	bstream *in = c->fdin;
	stream *out = c->fdout;
	str msg = 0;
	int err = 0;
	backend *be;
	mvc *m;
	MalBlkRecord oldstate;
	lng T0 = 0;
	int pstatus = 0;
	prot oldmode;

	oldstate = *c->curprg->def;
	be = ((backend *) c->state[PARSER]);
	if (be == 0) {
		GDKerror("SQL state descriptor missing\n");
		return throwMessage("SQLparser", "State decriptor missing\n");
	}
#ifdef _SQL_PARSER_DEBUG
	stream_printf(GDKout, "#SQL compilation \n");
	printf("debugger? %d %d\n", debugPlan(), be->mvc->mode);
#endif
	m = be->mvc;

	assert(m);

	m->type = Q_PARSE;
	if (!m->trans) 
		mvc_trans(m);
	pstatus = m->status;

	/* sqlparse needs sql allocator to be available.  It can be NULL at
	 * this point if this is a recursive call. */
	if (!m->sa)
		m->sa = sa_create();

	oldmode = m->scanner.mode;
	if (be->language == 's') {
		be->language = 'S';
		m->scanner.mode = LINE_1;
	}
	if (be->language != 'S' && be->language != 'X') {
		return throwMessage("SQLparser", "Unrecognized language prefix\n");
	}
	if (be->language == 'X') {
		int n, id, off, len;

		n = sscanf(in->buf + in->pos, "export %d %d %d", &id, &off, &len);

		if (n == 2 || n == 3) {
			mvc_export_chunk(m, out, id, off, n == 3 ? len : m->reply_size);

			in->pos = in->len;	/* HACK: should use parsed lenght */
			return NULL;
		}
		if (sscanf(in->buf + in->pos, "close %d", &id) == 1) {
			res_table *t = res_tables_find(m->results, id);

			if (t)
				m->results = res_tables_remove(m->results, t);
			in->pos = in->len;	/* HACK: should use parsed lenght */
			return NULL;
		}
		return throwMessage("SQLparser", "Unrecognized X command\n");
	}

	if (explainPerformance())
		T0 = GDKusec();

	m->mode = m_normal;
	if ((err = sqlparse(m)) && m->debug){
		/* switch to different language mode */
		char oldlang= be->language;
		be->language= 'D';
		runMALDebugger(c->curprg);
		be->language= oldlang;
	}
	if( err ||
	    /* Only forget old errors on transaction boundaries */
	    (mvc_status(m) && m->type != Q_TRANS) || !m->sym) {
		if (!err)
			err = mvc_status(m);
		msg = throwMessage("SQLparser", m->errstr);
		handle_error(m, c->fdout, pstatus);
		sqlcleanup(m, err);
		goto finalize;
	}
@-
We have dealt with the first parsing step and advanced the input reader
to the next statement (if any).
Now is the time to also perform the semantic analysis, optimize and produce code.
@c
	SQLsetDebugger(c, m, m->mode == m_debug);
	if (err == 0 && (!(be->q = qc_match(m->qc, m->sym, m->args, m->scanner.key)))) {
		stmt *s = sql_symbol2stmt(m);

		if (!s && (err = mvc_status(m))) {
			msg = throwMessage("SQLparser", m->errstr);
			handle_error(m, c->fdout, pstatus);
			sqlcleanup(m, err);
			goto finalize;
		}
		assert(s);
		/* generate and call the MAL code */
		if (!m->cache ){
			backend_dumpstmt(be, c->curprg->def, s);
/* Niels 
		} else
		if( (msg= sql_get_var(m,"optimizer"))== NULL || *msg == 0) {
			backend_callinline(be, c, s, m->args);
*/
		} else {
			/* generate a factory instantiation */
			backend_dumpproc(be, c, m->qc->id, s);
			be->q = qc_insert(m->qc, 
					  m->sa,      /* the allocator */
					  m->sym,     /* the sql symbol tree */
					  m->args,    /* the argument list */
					  m->scanner.key,	/* the statement hash key */
					  m->type,	/* the type of the statement */
					  _strdup("the mal block?"));

			be->q->code = (backend_code) c->curprg;
			m->sa = NULL;
			m->sym = NULL;
		} 
	}
#ifdef _SQL_PARSER_DEBUG
	else
		stream_printf(GDKout, "#parse result %d\n", err);
#endif
	if (be->q)
		backend_call(be, c, be->q->id, m->args);

@-
In the final phase we add any debugging control
@c
	/* turn off debugger */
	if( debugPlan())
		SQLsetDebugger(c, m, FALSE);

	if (explainPerformance()) {
		be->qry = sql_escape(QUERY(m->scanner));
		be->Tparse = GDKusec() - T0;
	}

	sqlcleanup(m, err);
@-
During the execution of the query exceptions can be raised.
The default action is to print them out at the end of the
query block.
@c
	if (err == 0) {
		pushCatchDefault(c->curprg->def, "sqlerror", m->auto_commit);
		pushEndInstruction(c->curprg->def);

		chkProgram(c->nspace, c->curprg->def);
		if (c->curprg->def->errors) {
			if( m->mode == m_debug){
				/* switch to differnt language mode */
				char oldlang= be->language;
				be->language= 'D';
				runMALDebugger(c->curprg);
				be->language= oldlang;
			}
			showErrors();
			/* restore the state */
			if (c->listing || explainPlan())
				printFunction(c->fdout, c->curprg->def, c->listing);
			resetInstructions(c->curprg->def, oldstate.stop);
			resetVariables(c->curprg->def, c->glb, oldstate.vtop);
			c->curprg->def->errors = 0;
			msg = throwMessage("SQLparser", "Semantic errors\n");
		}
	}
finalize:
	m->scanner.mode = oldmode;
	if (explainPlan()) {
		printFunction(c->fdout, c->curprg->def, c->listing);
	}
#ifdef _SQL_PARSER_DEBUG
	else {
		stream_printf(GDKout, "#SQL finished:%s\n", msg);
		printFunction(c->fdout, c->curprg->def, c->listing);
	}
#endif
@-
Gather the statistics for post analysis. It should preferably
be stored in an SQL table
@c
	return msg;
}

@-
Execution of the SQL program is delegated to the MALengine.
@c
str
SQLengine(Client c)
{
	str msg = MAL_SUCCEED;
	MalStkPtr oldglb = c->glb;
	backend *be = ((backend *) c->state[PARSER]);
	char oldlang= be->language;
	mvc *m = be->mvc;
	lng T0 = GDKusec();

	if (c->curprg->def->errors)
		return throwMessage("SQLengine", "Program contains errors\n");
#ifdef SQL_SCENARIO_DEBUG
	stream_printf(GDKout, "#Ready to execute SQL statement\n");
#endif

	if( m->mode == m_explain){
		printFunction(c->fdout, c->curprg->def, c->listing);
@-
If you want to see the detailed code, we have to pick it up from
the cache as well. This calls for finding the call to the
cached routine, which may be hidden . For now we take a shortcut.
@c
		if( be->q) {
			InstrPtr p;
			p = getInstrPtr(c->curprg->def,1);
			if( p->blk)
				printFunction(c->fdout, p->blk, c->listing);

		}
		c->curprg->def->errors = -1; /* don;t execute */
	} 
	c->glb = 0;
	be->language= 'D';
@-
The code below is copied from MALengine, which handles execution
in the context of a user global environment. We have a private
environment.
@c

	if( c->curprg->def->stop == 1 || MALcommentsOnly(c->curprg->def))
		msg= MAL_SUCCEED;
	else msg = (str) runMAL(c, c->curprg->def, 1, 0, 0, 0);
    if (msg) {
        GDKerror(msg);
        if (!c->listing)
            printFunction(c->fdout, c->curprg->def, c->listing);
        showErrors();
	if (msg) 
		m->status = -10;
    }
    resetInstructions(c->curprg->def, 1);
    resetVariables(c->curprg->def, 0, 0);
	be->language= oldlang;
@-
Any error encountered during execution should block further processing
unless auto_commit has been set.
@c
	c->glb = oldglb;
	if (explainPerformance()) {
		str ret;
		lng tot = be->Tparse;
		char buf[BUFSIZ], *qs, *stmt = buf;

		tot += be->Texec = GDKusec() - T0;
		qs = sql_escape(be->qry);
		snprintf(buf, BUFSIZ, "set explain = 'none';"
			 "insert into sys.history "
			 "values(now,'%s'," LLFMT ",0," LLFMT "," LLFMT" ,USER);\n"
			 "set explain = 'performance';",
			 qs, be->Tparse, be->Texec, tot);
		_DELETE(qs);
@-
This code causes a recursion, because the reset of the explain
triggers the history action. A better approach is to directly
update the history tables, without SQL intervention.
Then the SQL history table is just a view over a few basic bats.
@c
		stream_printf(GDKout, "#%s [parse %d]", be->qry, be->Tparse);
		stream_printf(GDKout, "[engine %d]", be->Texec);
		stream_printf(GDKout, "[total %d]\n", tot);
		if (be->qry)
			GDKfree(be->qry);
		be->qry = NULL;

		SQLstatement(&ret, &stmt);
	}

	/*
	 * clear query cache after Transaction boundaries (commit/rollback)
	 * and on schema changes
	 */
	if (m->cache && (m->type == Q_TRANS || m->type == Q_SCHEMA || m->qc->id >100)) {
		if (m->qc) {
			oid id;
			int ret = 0;

			for (id = 0; id <m->qc->id; id ++) {
				char buf[BUFSIZ], *nme = buf;
				snprintf(buf, BUFSIZ, "sql%d", (int) id);

				SQLCacheRemove(&ret, &nme);
			}
			(void) ret;
			qc_destroy(m->qc);
		}
		m->qc = qc_create();
	}

	return msg;
}

@-
Assertion errors detected during the execution of a code block
raises an exception.
@c
str
SQLassert(int *ret, bit *flg, str *msg)
{
	(void) ret;
	if (*flg)
		return throwException("SQLerror", "assert", *msg);
	return MAL_SUCCEED;
}

str
SQLassertInt(int *ret, int *flg, str *msg)
{
	(void) ret;
	if (*flg)
		return throwException("SQLerror", "assert", *msg);
	return MAL_SUCCEED;
}

str
SQLassertLng(int *ret, lng *flg, str *msg)
{
	(void) ret;
	if (*flg)
		return throwException("SQLerror", "assert", *msg);
	return MAL_SUCCEED;
}

@- Utilities
Catching errors is a recurring situation. The block below 
generates the default code block, ie catch it and print
the error. It should also deal with the auto_commit
situation. [todo]
For the time being we do not catch errors. They are
passed to the environment.
@c
static void
pushCatchDefault(MalBlkPtr mb, str nme, int autocommit)
{
/*
	InstrPtr p;
*/

/*	int i;*/
	(void) mb;
	(void) nme;
	(void) autocommit;

/*
	if (autocommit) {
		p = newInstruction(ASSIGNsymbol);
		moduleId(p) = putName("sql",3);
		functionId(p) = putName("commit",6);
		pushInstruction(mb, p);
	}
*/
/* no catch
	p= newInstruction(CATCHsymbol);
	i= findVariable(mb,nme);
	if( i< 0) i= newVariable(mb,GDKstrdup(nme),TYPE_str);
	getDestVar(p) = i;
	p->argc =1;
	p->retc = 1;
	pushInstruction(mb,p);

	p= newInstruction(ASSIGNsymbol);
	moduleId(p)= putName("io",2);
	functionId(p)= putName("print",5);
	pushArgumentId(mb, p, GDKstrdup(nme));
	pushInstruction(mb,p);
*/

/*
	if (autocommit) {
		p = newInstruction(ASSIGNsymbol);
		moduleId(p) = putName("sql",3);
		functionId(p) = putName("rollback",8);
		pushInstruction(mb, p);
	}
*/
/*       else {
		p= newInstruction(RAISEsymbol);
		p->barrier= RAISEsymbol;
		p->argv[0] = findVariable(mb,GDKstrdup("sqlerror"));
		i= newConstant(mb,TYPE_str,GDKstrdup("Transaction abort"),0);
		p= pushArgument(mb,p,i);
		pushInstruction(mb,p);
	}

	p= newInstruction(EXITsymbol);
	p->argv[0] = findVariable(mb,GDKstrdup(nme));
	p->barrier= EXITsymbol;
	pushInstruction(mb,p);
*/
}

@mal
# nothing special to do
