@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.monetdb.org/Legal/MonetDBLicense

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2011 MonetDB B.V.
All Rights Reserved.
@

@f gdk_scanselect
@a S. Manegold, N. J. Nes, M. L. Kersten, P. Boncz
@* Fast sequential scan
@-
This module provides BAT_scanselect, used by gdk_batop.mx's BAT_select to do
selections that cannot be done any better than doing a sequential scan. The
function needed to be "sourced-out" from gdk_batop.mx, as the fully expanded
code grows too large to be (conveniently) compiled in a single file (see
below).  This file is accompanied by gdk_scanselect_defs.mx where the
worker functions are defined that are called from the dispatcher which
is definend in this file.

@+ Background and Idea
In tests with Q1 of TPC-H showed, a range select that produces a big result
(~98% of its input) was much slower than expected. A profiler told us,
that the (CPU-)time was lost in BUNfastins, or more precisely in ATOMput:
Thought being expanded on the selection attribute's type to use
type-specific predicates/compare functions, storing the result BUNs in the
result BAT was done in a generic way. Hence, type-checking, etc. was done
for each result BUN twice (head & tail). This type check (performed by
ATOMput) turned out to be the major CPU bottleneck. On medusa (R12k/300),
the total cost of a uselect on [void,date] was made up by ~87% CPU
time and ~13% memory access time.

The idea to solve the problem was to expand the function's code also for the
type being store in the result, both head & tail. Thinking about it, we
thought why not completely eliminate all branches (except the actual
predicate, of course) from the inner loop (BATloop) --- we do have Mx,
so let's (ab?)use it!
This means

@itemize
@item
Expanding on whether we created the result BAT (at least) as big as
	the input BAT, or not (see BAT_select in gdk_batop.mx). In the first
	case ("nocheck"), we do not have to check for a "BAT overflow" in
	the inner loop.  
@item
Expanding on the output-tail-type which is either identical to
	input-tail-type or TYPE_void (uselect).
@item
Expand on output-head-type; usually inherited from input-head-type.
@item
Expanding on input-head-type for data read.  Taking special care of
	void/oid.
@item
Expanding on the type of predicate: either equi, or range.  The
	latter with both, one, or none of upper bound and lower bound.  In
	case of a range select we skip all nil.
@item
Expanding on input-tail-type for data read and comparison.  Most is
	straight forward.  Taking special care of equi selects on str when
	there are no doubles in the heap.
@end itemize
For more details, see the comment next to the code below.
@-
Well, to get this feasible (i.e., both the Mx code still readable tomorrow
and the generated C code compilable), we came up with some kind of "design
idea":

The toplevel BAT_scanselect get expanded by a set of cascading levels of Mx
macros that dispatch to the different alternatives. To give the compiler a
chance to "concentrate on the important parts", only branches are created,
here. The actual working block (i.e., the inner BATloop) are enclosed in
a separate function each. Each leaf of the decision tree calls the
respective function, and each function is called by exactly on leaf.

A second set of cascading levels of Mx macros take care of generating the
working functions. For convenience, the matching macros of both sets are
placed next to each other.

Altogether, we currently generate 1230(!) different scanselect loops. Some
compilers (e.g., gcc 2.95.3 on IRIX) try to inline all these functions into
the decision-/dispatching- tree, and fail with "Branch at has out of range
target". We "help" these compiler a bit by explicitly switching off
inlining for this file (it doesn't make sense here, anyway).

And finally, what do we achieve by all this effort?
Well, the on medusa, CPU costs are reduced by (up to) factor 8(!), resulting
in an overall improvement of about factor 4.5.
@{
@+ Implementation
@h
#ifndef _GDK_SCANSELECT_H
#define _GDK_SCANSELECT_H

@- "Tools"
First, we need some tools. These are the type-expanded replacements
for some generic macros from gdk.mx, gdk_bat.mx, and gdk_atom.mx.
Eventually, they should be moved there to be used in other places as well.

VOIDput & SIMPLEput should go to gdk_atoms where ATOMput is defined.
@h
#ifdef NOEXPAND_CHR
#ifndef NOEXPAND_BIT
#define NOEXPAND_BIT 1
#endif
#ifndef NOEXPAND_BTE
#define NOEXPAND_BTE 1
#endif
#endif

#ifdef NOEXPAND_INT
#ifndef NOEXPAND_FLT
#define NOEXPAND_FLT 1
#endif
#ifndef NOEXPAND_BAT
#define NOEXPAND_BAT 1
#endif
#if SIZEOF_OID == SIZEOF_INT && !defined(NOEXPAND_OID)
#define NOEXPAND_OID 1
#endif
#if SIZEOF_WRD == SIZEOF_INT && !defined(NOEXPAND_WRD)
#define NOEXPAND_WRD 1
#endif
#if SIZEOF_PTR == SIZEOF_INT && !defined(NOEXPAND_PTR)
#define NOEXPAND_PTR 1
#endif
#endif

#ifdef NOEXPAND_LNG
#ifndef NOEXPAND_DBL
#define NOEXPAND_DBL 1
#endif
#if SIZEOF_OID == SIZEOF_LNG && !defined(NOEXPAND_OID)
#define NOEXPAND_OID 1
#endif
#if SIZEOF_WRD == SIZEOF_LNG && !defined(NOEXPAND_WRD)
#define NOEXPAND_WRD 1
#endif
#if SIZEOF_PTR == SIZEOF_LNG && !defined(NOEXPAND_PTR)
#define NOEXPAND_PTR 1
#endif
#endif

#if defined(NOEXPAND_CHR) || defined(SKIP_TYPE_EXPANSIONS)
#define ATOM_PUT_CHR(tpe,hp,dst,p,src)		\
	if (tpe == TYPE_chr) {			\
		((chr*) dst)[p] = *(chr*) src;	\
	} else
#else
#define ATOM_PUT_CHR(tpe,hp,dst,p,src)
#endif
#if defined(NOEXPAND_BTE) || defined(SKIP_TYPE_EXPANSIONS)
#define ATOM_PUT_BTE(tpe,hp,dst,p,src)		\
	if (tpe == TYPE_bte) {			\
		*(bte*) dst = *(bte*) src;	\
	} else
#else
#define ATOM_PUT_BTE(tpe,hp,dst,p,src)
#endif
#if defined(NOEXPAND_SHT) || defined(SKIP_TYPE_EXPANSIONS)
#define ATOM_PUT_SHT(tpe,hp,dst,p,src)		\
	if (tpe == TYPE_sht) {			\
		((sht*) dst)[p] = *(sht*) src;	\
	} else
#else
#define ATOM_PUT_SHT(tpe,hp,dst,p,src)
#endif
#if defined(NOEXPAND_INT) || defined(SKIP_TYPE_EXPANSIONS)
#define ATOM_PUT_INT(tpe,hp,dst,p,src)		\
	if (tpe == TYPE_int) {			\
		((int*) dst)[p] = *(int*) src;	\
	} else
#else
#define ATOM_PUT_INT(tpe,hp,dst,p,src)
#endif
#if defined(NOEXPAND_LNG) || defined(SKIP_TYPE_EXPANSIONS)
#define ATOM_PUT_LNG(tpe,hp,dst,p,src)		\
	if (tpe == TYPE_lng) {			\
		((lng*) dst)[p] = *(lng*) src;	\
	} else
#else
#define ATOM_PUT_LNG(tpe,hp,dst,p,src)
#endif

#define FIXEDATOM_PUT(b,tpe,p,src,SRC)					\
	do {								\
		ATOM_PUT_CHR(tpe,(b)->SRC->vheap,(b)->SRC->heap.base,(p),(src)) \
		ATOM_PUT_SHT(tpe,(b)->SRC->vheap,(b)->SRC->heap.base,(p),(src)) \
		ATOM_PUT_INT(tpe,(b)->SRC->vheap,(b)->SRC->heap.base,(p),(src)) \
		ATOM_PUT_LNG(tpe,(b)->SRC->vheap,(b)->SRC->heap.base,(p),(src)) \
		if (tpe == TYPE_bat) {					\
			BBPincref(* (bat *) (src), TRUE);			\
			((bat*) (b)->SRC->heap.base)[p] = *(bat*) (src);			\
		} else {						\
			memcpy(SRC##loc((b),(p)), (src), (size_t) ATOMsize(tpe)); \
		}							\
	} while (0)
#define VARATOM_PUT(b,tpe,p,src,SRC) SRC##putvalue((b),SRC##loc((b),(p)),(src),1)
#define SIMPLE_PUT(b,tpe,p,src,SRC) ((tpe*)((b)->SRC->heap.base))[p] = *(tpe*)(src)
#define VOID_PUT(b,tpe,p,src,SRC)
#define VID_PUT(b,tpe,p,src,SRC) ((oid*)((b)->SRC->heap.base))[p] = (src)

@-
Type-specific
HT_bunfastins_nocheck_noinc, HT_bunfastins_nocheck & HT_bunfastins
should go to gdk.mx, and
HT_BUNfastins
should go to gdk_bat.mx
replacing their generic versions there.
@h
@= T_BUNfastins
#define @1@4_bunfastins_nocheck_noinc(b, p, h, t)		\
	do {							\
		@2_PUT(b,@3,p,h,H); \
		@5_PUT(b,@6,p,t,T); \
	} while (0)
#define @1@4_bunfastins_nocheck(b, p, h, t, hs, ts)		\
	do {							\
		(b)->H->heap.free += hs;			\
		(b)->T->heap.free += ts;			\
		(b)->batCount ++;				\
		@1@4_bunfastins_nocheck_noinc(b, p, h, t);	\
	} while (0)
#define @1@4_bunfastins(b, h, t)					\
	do {								\
		register BUN _p = BUNlast(b);				\
		if (BATcount(b) + 1 > BATcapacity(b)){			\
			if (BATextend(b, BATgrows(b)) == NULL)  	\
				goto bunins_failed; 			\
		}							\
		@1@4_bunfastins_nocheck(b, _p, h, t, Hsize(b), Tsize(b)); \
	} while (0)

@-
Expand on tail type
@= H_BUNfastins
	@:T_BUNfastins(@1,@2,@3,void,VOID,void)@
	@:T_BUNfastins(@1,@2,@3,chr,SIMPLE,chr)@
	@:T_BUNfastins(@1,@2,@3,bte,SIMPLE,bte)@
	@:T_BUNfastins(@1,@2,@3,sht,SIMPLE,sht)@
	@:T_BUNfastins(@1,@2,@3,int,SIMPLE,int)@
	@:T_BUNfastins(@1,@2,@3,flt,SIMPLE,flt)@
	@:T_BUNfastins(@1,@2,@3,oid,SIMPLE,oid)@
	@:T_BUNfastins(@1,@2,@3,wrd,SIMPLE,wrd)@
	@:T_BUNfastins(@1,@2,@3,lng,SIMPLE,lng)@
	@:T_BUNfastins(@1,@2,@3,dbl,SIMPLE,dbl)@
	@:T_BUNfastins(@1,@2,@3,fix,FIXEDATOM,(b)->ttype)@
	@:T_BUNfastins(@1,@2,@3,var,VARATOM,(b)->ttype)@
@-
Expand on head type
@h
@:H_BUNfastins(void,VOID,void)@
@:H_BUNfastins(chr,SIMPLE,chr)@
@:H_BUNfastins(bte,SIMPLE,bte)@
@:H_BUNfastins(sht,SIMPLE,sht)@
@:H_BUNfastins(int,SIMPLE,int)@
@:H_BUNfastins(flt,SIMPLE,flt)@
@:H_BUNfastins(oid,SIMPLE,oid)@
@:H_BUNfastins(wrd,SIMPLE,wrd)@
@:H_BUNfastins(lng,SIMPLE,lng)@
@:H_BUNfastins(dbl,SIMPLE,dbl)@
@:H_BUNfastins(vid,VID,vid)@
@:H_BUNfastins(fix,FIXEDATOM,(b)->htype)@
@:H_BUNfastins(var,VARATOM,(b)->htype)@

@-
For backward compatibility:
(also to be moved to gdk.mx and gdk_bat.mx, respectively)
@h

BAT *BAT_scanselect(BAT *b, BAT *bn, ptr tl, ptr th, bit li, bit hi, int equi, int nequi, int lval, int hval, int nocheck);

#endif /* _GDK_SCANSELECT_H */

@c
#include "monetdb_config.h"
#include "gdk.h"

#if defined(__sgi) && defined(__GNUC__) && (SIZEOF_VOID_P == 8)
#define SKIP_TYPE_EXPANSIONS
#endif
#include "gdk_scanselect.h"
#include "gdk_scanselect_defs_chr.h"
#include "gdk_scanselect_defs_bte.h"
#include "gdk_scanselect_defs_sht.h"
#include "gdk_scanselect_defs_int.h"
#include "gdk_scanselect_defs_flt.h"
#include "gdk_scanselect_defs_dbl.h"
#include "gdk_scanselect_defs_lng.h"
#include "gdk_scanselect_defs_str.h"
#include "gdk_scanselect_defs_fix.h"
#include "gdk_scanselect_defs_var.h"

@-
With all the expansions enabled, (our) GNU compiler (gcc 3.2.1)
on medusa (IRIX64) fails to produce (correctly) working 64-bit code.
Apparently, the jumps from the return statements in the leaves of the
decision tree to the end of the dispatcher function (BAT_scanselect())
get too long --- at least the Mserver segfaults on these returns.
An attempt to use labels and goto's to provide "stepping stones" did not
help.
Hence, we skip some type-expansions in this very case.
@c

@- The actual BAT_scanselect

@-
The templates for the inner loops that do the actual work.

Expanding on whether we created the result BAT (at least) as big as the
input BAT, or not (see BAT_select in gdk_batop.mx). In the first case
("nocheck"), we do not have to check for a "BAT overflow" in the inner loop.

@c
/*	@1: input-tail-type for working function name,
	    prefixed with predicate type (eq,lh,ln,nl,nn)
	@2: output-tail-type for bunfastins macro name
	@3: "tloc" / "tvar" specifying how to read the tail-input
	@4: the predicate
	@5: the tail to be store, being either the tail read ("v")
	    or in case of equi-str-select the search string ("tl")
	@6: input-head-type for working function name
	@7: output-head-type for bunfastins macro name
	@8: how to access the head-input: "BUNhloc(bi,p)", "BUNhvar(bi,p)",
	    or the oid counter ("&oid_ctr") in case we generate a void/oid
	    output-head from a void input-head
	@9: in case we generate a void/oid output-head from a void
	    input-head, this is the statement to inc the oid counter
	    ("oid_ctr++;"),
	    otherwise it's empty
*/

@= seqscan
	if (nocheck) {
		return seqscan_@1_@2_@3_@6_@7_nocheck_noinc(b, bn, tl, th, str_idx);
	} else {
		return seqscan_@1_@2_@3_@6_@7(b, bn, tl, th, str_idx);
	}
@-

Output-tail-type is either identical to input-tail-type or TYPE_void
(uselect).

@c
/*	@1: input-tail-type for working function name,
	    prefixed with predicate type (eq,lh,ln,nl,nn)
	@2: output-tail-type for bunfastins macro name
	@3: "tloc" / "tvar" specifying how to read the tail-input
	@4: the predicate
	@5: the tail to be store, being either the tail read ("v")
	    or in case of equi-str-select the search string ("tl")
	@6: input-head-type for working function name
	@7: output-head-type for bunfastins macro name
	@8: how to access the head-input: "BUNhloc(bi,p)", "BUNhvar(bi,p)",
	    or the oid counter ("&oid_ctr") in case we generate a void/oid
	    output-head from a void input-head
	@9: in case we generate a void/oid output-head from a void
	    input-head, this is the statement to inc the oid counter
	    ("oid_ctr++;"),
	    otherwise it's empty
*/
@= seqscanTTput
	if (bn->ttype == TYPE_void) {
		@:seqscan(@1,void,@3,@4,@5,@6,@7,@8,@9)@
	} else {
		@:seqscan(@1,@2,@3,@4,@5,@6,@7,@8,@9)@
	}
@-

Expand on output-head-type; usually inherited from input-head-type.

@c
/*	@1: input-tail-type for working function name,
	    prefixed with predicate type (eq,lh,ln,nl,nn)
	@2: output-tail-type for bunfastins macro name
	@3: "tloc" / "var" specifying how to read the tail-input
	@4: the predicate
	@5: the tail to be store, being either the tail read ("v")
	    or in case of equi-str-select the search string ("tl")
	@6: input-head-type for working function name
	@7: output-head-type for bunfastins macro name
	@8: how to access the head-input: "BUNhloc(bi,p)", "BUNhvar(bi,p)",
	    or the oid counter ("&oid_ctr") in case we generate a void/oid
	    output-head from a void input-head
	@9: in case we generate a void/oid output-head from a void
	    input-head, this is the statement to inc the oid counter
	    ("oid_ctr++;"),
	    otherwise it's empty
*/
@= seqscanHTput
#ifndef SKIP_TYPE_EXPANSIONS
#ifndef NOEXPAND_CHR
	if (AsHt == TYPE_chr) {
		@:seqscanTTput(@1,@2,@3,@4,@5,chr,chr,BUNhloc(bi,p),)@
	} else
#endif	/* NOEXPAND_CHR */
#ifndef NOEXPAND_BTE
	if (AsHt == TYPE_bte) {
		@:seqscanTTput(@1,@2,@3,@4,@5,bte,bte,BUNhloc(bi,p),)@
	} else
#endif	/* NOEXPAND_BTE */
#ifndef NOEXPAND_SHT
	if (AsHt == TYPE_sht) {
		@:seqscanTTput(@1,@2,@3,@4,@5,sht,sht,BUNhloc(bi,p),)@
	} else
#endif	/* NOEXPAND_SHT */
#ifndef NOEXPAND_INT
	if (bn->htype != TYPE_bat && (AsHt == TYPE_int || AsHt == TYPE_flt)) {
		/* ensure use of ATOMput for TYPE_bat */
		@:seqscanTTput(@1,@2,@3,@4,@5,int,int,BUNhloc(bi,p),)@
	} else
#endif	/* NOEXPAND_INT */
#ifndef NOEXPAND_LNG
	if (AsHt == TYPE_dbl || AsHt == TYPE_lng) {
		@:seqscanTTput(@1,@2,@3,@4,@5,lng,lng,BUNhloc(bi,p),)@
	} else
#endif	/* NOEXPAND_LNG */
#endif	/* SKIP_TYPE_EXPANSIONS */
	if (b->hvarsized) {
		@:seqscanTTput(@1,@2,@3,@4,@5,var,var,BUNhvar(bi,p),)@
	} else {
		@:seqscanTTput(@1,@2,@3,@4,@5,fix,fix,BUNhloc(bi,p),)@
	}
@-

Expanding on input-head-type for data read.
Taking special care of void/oid.

@c
/*	@1: input-tail-type for working function name,
	    prefixed with predicate type (eq,lh,ln,nl,nn)
	@2: output-tail-type for bunfastins macro name
	@3: "tloc" / "tvar" specifying how to read the tail-input
	@4: the predicate
	@5: the tail to be store, being either the tail read ("v")
	    or in case of equi-str-select the search string ("tl")
*/
@= seqscanHTget
	if (BAThvoid(b)) {
		/* input-head is void. we decide here, whether output-head
		 * sould be void or oid, and skip seqscanHTput */
		oid oid_ctr = b->hseqbase;
		if (oid_ctr == oid_nil) {
			/* avoid computing BUNpos many times over
			 * output-head is void, hence output-tail cannot be void,
			 * hence we can skip seqscanTTput */
			@:seqscan(@1,@2,@3,@4,@5,void,void,&oid_ctr,)@
		} else {
			/* increment instead of compute BUNpos */
			@:seqscanTTput(@1,@2,@3,@4,@5,oid,vid,oid_ctr,oid_ctr++;)@
		}
	} else {
		/* output-head is identical to input-head. */
		@:seqscanHTput(@1,@2,@3,@4,@5)@
	}
@-

Expanding on the type of predicate: either equi, or range.
The latter with both, one, or none of upper bound and lower bound.
In case of a range select we skip all nil.

@c
/*	@1: input-tail-type for working function name
	@2: output-tail-type for bunfastins macro name
	@3: "tloc" / "tvar" specifying how to read the tail-input
	@4: "simple" or "atom"
	@5: input-tail-type for comparison
	@6: in case of range selects with lower bound on types where nil != MIN:
		check for  v != nil
	    otherwise
		empty
	    as then @4_LE(tl ,v,@5) with tl != nil (i.e., tl > nil) already
	    ensures v != nil
*/
@= seqscanIF
	if (equi) {
		@:seqscanHTget(eq_@1,@2,@3,if ( @4_EQ(tl ,v,@5)                      ),v)@
	} else if (nequi && !hval) {
		@:seqscanHTget(ne_@1,@2,@3,if ( @4_NE(tl ,v,@5,@5_nil)                      ),v)@
	/* rangeselect => we always skip nil
	 * (explicitely by !@4_EQ(nil,v,@5) or @6
	 *  or implicitely by @4_LE(tl,v,@5)) */
	} else if (lval && hval) {
	    if (!nequi) {
		if (li && hi) {
			@:seqscanHTget(LH_@1,@2,@3,if ( @4_LE(tl ,v,@5) && @4_LE(v,th,@5) @6 ),v)@
		} else if (li && !hi) {
			@:seqscanHTget(Lh_@1,@2,@3,if ( @4_LE(tl ,v,@5) && @4_LT(v,th,@5) @6 ),v)@
		} else if (!li && hi) {
			@:seqscanHTget(lH_@1,@2,@3,if ( @4_LT(tl ,v,@5) && @4_LE(v,th,@5) @6 ),v)@
		} else {
			@:seqscanHTget(lh_@1,@2,@3,if ( @4_LT(tl ,v,@5) && @4_LT(v,th,@5) @6 ),v)@
		}
	    } else {
		if (li && hi) {
			@:seqscanHTget(HL_@1,@2,@3,if ( (!@4_EQ(nil,v,@5) && @4_LT(v,tl,@5)) || (@4_LT(th,v,@5) @6 )),v)@
		} else if (li && !hi) {
			@:seqscanHTget(hL_@1,@2,@3,if ( (!@4_EQ(nil,v,@5) && @4_LE(v,tl,@5)) || (@4_LT(th,v,@5) @6 )),v)@
		} else if (!li && hi) {
			@:seqscanHTget(Hl_@1,@2,@3,if ( (!@4_EQ(nil,v,@5) && @4_LT(v,tl,@5)) || (@4_LE(th,v,@5) @6 )),v)@
		} else {
			@:seqscanHTget(hl_@1,@2,@3,if ( (!@4_EQ(nil,v,@5) && @4_LE(v,tl,@5)) || (@4_LE(th,v,@5) @6 )),v)@
		}
	    }
	} else if (lval) {
		if (li) {
			@:seqscanHTget(Ln_@1,@2,@3,if ( @4_LE(tl ,v,@5)                   @6 ),v)@
		} else {
			@:seqscanHTget(ln_@1,@2,@3,if ( @4_LT(tl ,v,@5)                   @6 ),v)@
		}
	} else if (hval) {
		if (hi) {
			@:seqscanHTget(nH_@1,@2,@3,if (!@4_EQ(nil,v,@5) && @4_LE(v,th,@5)    ),v)@
		} else {
			@:seqscanHTget(nh_@1,@2,@3,if (!@4_EQ(nil,v,@5) && @4_LT(v,th,@5)    ),v)@
		}
	} else {
		@:seqscanHTget(nn_@1,@2,@3,if (!@4_EQ(nil,v,@5)                      ),v)@
	}
@-

Expanding on input-tail-type for data read and comparison.
Most is straight forward.
Taking special care of equi selects on str when there are no doubles in the
heap.
Adding test for v != nil for types where nil != MIN.

@= seqscanTTget
#ifndef SKIP_TYPE_EXPANSIONS
#ifndef NOEXPAND_CHR
	if (AsTt == TYPE_chr) {
		@:seqscanIF(chr,chr,tloc,simple,chr,)@
	} else
#endif	/* NOEXPAND_CHR */
#ifndef NOEXPAND_BTE
	if (AsTt == TYPE_bte) {
		@:seqscanIF(bte,bte,tloc,simple,bte,)@
	} else
#endif	/* NOEXPAND_BTE */
#ifndef NOEXPAND_SHT
	if (AsTt == TYPE_sht) {
		@:seqscanIF(sht,sht,tloc,simple,sht,)@
	} else
#endif	/* NOEXPAND_SHT */
#ifndef NOEXPAND_INT
	if (AsTt == TYPE_int && t != TYPE_bat) {
		/* ensure use of ATOMput for TYPE_bat */
		@:seqscanIF(int,int,tloc,simple,int,)@
	} else
#endif	/* NOEXPAND_INT */
#ifndef NOEXPAND_FLT
	if (AsTt == TYPE_flt) {
		@:seqscanIF(flt,int,tloc,simple,flt,)@
	} else
#endif	/* NOEXPAND_FLT */
#ifndef NOEXPAND_DBL
	if (AsTt == TYPE_dbl) {
		@:seqscanIF(dbl,lng,tloc,simple,dbl,)@
	} else
#endif	/* NOEXPAND_DBL */
#ifndef NOEXPAND_LNG
	if (AsTt == TYPE_lng) {
		@:seqscanIF(lng,lng,tloc,simple,lng,)@
	} else
#endif	/* NOEXPAND_LNG */
#endif	/* SKIP_TYPE_EXPANSIONS */
	if (b->tvarsized) {
		if (equi && t == TYPE_str && strElimDoubles(b->T->vheap)) {
			/* Single-valued sequential scans for strings are
			 * optimized when double elemination is in effect,
			 * by scanning for the correct integer index value.
			 * This is an equi select, so we assemble the
			 * predicate here and skip seqscanIF. */
			str_idx = strLocate(b->T->vheap, tl);
			if (b->T->width <= 2)
				str_idx -= GDK_VAROFFSET;
			@:seqscanHTget(eq_str,var,tloc,if((b->T->width==1?(var_t)*(unsigned char*)v:(b->T->width==2?(var_t)*(unsigned short*)v:(b->T->width==4?(var_t)*(unsigned int*)v:*(var_t*)v)))==str_idx),tl)@
		} else {
			@:seqscanIF(var,var,tvar,atom,t,&&!atom_EQ(nil,v,t))@
		}
	} else {
		@:seqscanIF(fix,fix,tloc,atom,t,&&!atom_EQ(nil,v,t))@
	}
@-

The dispatcher, called from BAT_select (gdk_batop.mx).

@c
BAT *
BAT_scanselect(BAT *b, BAT *bn, ptr tl, ptr th, bit li, bit hi, int equi, int nequi, int lval, int hval, int nocheck)
{
	int t = b->ttype;

#ifndef SKIP_TYPE_EXPANSIONS
#if !defined(NOEXPAND_CHR) || !defined(NOEXPAND_SHT) || !defined(NOEXPAND_INT) || !defined(NOEXPAND_LNG)
	int AsHt = ATOMstorage(bn->htype), AsTt = ATOMstorage(t);
#endif
#endif
	var_t str_idx = 0;

	@:seqscanTTget@

	/* return is called in the leave of the decision tree to shortcut
	 * the exit from this dispatcher function. */
}

@}
@-
