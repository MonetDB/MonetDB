@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2011 MonetDB B.V.
All Rights Reserved.
@

@f gdk_setop
@a Peter Boncz

@* Set Operations
Set operations are provided in two series:
@itemize
@item
k-@emph{operand}, which look only at the head column.
@item
s-@emph{operand} series, that look at the whole BUN.
@end itemize

Operands provided are:
@itemize
@item [s,k]unique
produces a copy of the bat, with double elimination
@item [s,k]union
produces a bat union.
@item [s,k]diff
produces bat difference.
@item [s,k]intersection
produce bat intersection.
@end itemize
Implementations typically take two forms: if the input relation(s) is/are
ordered, a merge-algorithm is used. Otherwise, hash-indices are produced
on demand for the hash-based versions.

The @emph{[k,s]intersect(l,r)} operations result in all BUNs of @emph{l} that
are also in @emph{r}. They do not do double-elimination over the @emph{l} BUNs.

The @emph{[k,s]diff(l,r)} operations result in all BUNs of @emph{l} that are
not in @emph{r}. They do not do double-elimination over the @emph{l} BUNs.

The @emph{[k,s]union(l,r)} operations result in all BUNs of @emph{l}, plus 
all BUNs of @emph{r} that are not in @emph{l}. They do not do double-elimination
over the @emph{l} nor @emph{r} BUNs.

Operations with double-elimination can be formed by performing @emph{[k,s]unique(l)} on their operands.

The @emph{kintersect(l,r)} is used also as implementation for the @emph{semijoin()}.
@{
@h
#ifndef _GDK_SETOP_H
#define _GDK_SETOP_H
#include "gdk.h"

#define HITk(t1,t2)             TRUE
#define HITs(t1,t2)             ((*cmp)(t1,t2) == 0)
#define TAILCHECKs(l,r)         TYPEerror(BATttype(l),	BATttype(r))
#define TAILCHECKk(l,r)         FALSE
#define EQUALs(t1,t2)           ((*cmp)(t1,t2) == 0 && (*cmp)(t1,tnil))
#define EQUALk(t1,t2)           TRUE
#define FLIPs(l,r)              TRUE
#define FLIPk(l,r)              FALSE

#define HITintersect(h,t)       bunfastins(bn,h,t)
#define HITdiff(h,t)
#define MISSintersect(h,t)
#define MISSdiff(h,t)           bunfastins(bn,h,t)

#define HITintersect_nocheck(h,t)       bunfastins_nocheck(bn,BUNlast(bn),h,t,Hsize(bn),Tsize(bn))
#define HITdiff_nocheck(h,t)
#define MISSintersect_nocheck(h,t)
#define MISSdiff_nocheck(h,t)           bunfastins_nocheck(bn,BUNlast(bn),h,t,Hsize(bn),Tsize(bn))

#define DHITintersect(h,t)       bnh[o] = *(h); bnt[o++] = t;
#define DHITdiff(h,t)
#define DMISSintersect(h,t)
#define DMISSdiff(h,t)           bnh[o] = *(h); bnt[o++] = t;

#define ENDintersect(h,t)
#define ENDdiff(h,t)            for(;p1<q1;p1++) bunfastins(bn,h,t)
#define RALIGNdiff(bn,l,r)      FALSE
#define RALIGNintersect(bn,l,r) ((BAThordered(l)&BAThordered(r)&1) && l->hkey\
				 && BATcount(bn)==BATcount(r))
#endif /* _GDK_SETOP_H */

@c
#include "monetdb_config.h"
#include "gdk.h"
#include "gdk_setop.h"
#include "gdk_search.h"

@+ Double Elimination
Comes in two flavors: looking at one column, or at two at-a-time.
Implementation is either merge- or hash-based.
@= mergeelim
	BATloop(b, p, q) {
		ptr h = BUNh@2(bi,p);
		ptr t = BUNt@3(bi,p);

		for (r = p + 1; r < q && @4 == 0; r++) {
			if (HIT@1(t, BUNt@3(bi, r)))
				goto next@2@3@5;
		}
		bunfastins(bn, h, t);
  next@2@3@5:;
	}
@= hashelim
	zz = BUNfirst(bn);
	if (!bn->H->hash) {
		if (BAThash(bn, BATcapacity(bn)) == NULL) {
			BBPreclaim(bn);
			return NULL;
		}
	}
	BATaccessBegin(b, USE_HEAD|USE_TAIL, MMAP_SEQUENTIAL);
	BATaccessBegin(bn, USE_HEAD|USE_TAIL|USE_HHASH, MMAP_SEQUENTIAL);
	BATloop(b, p, q) {
		ptr h = BUNh@2(bi, p);
		ptr t = BUNt@3(bi, p);
		int ins = 1;
		BUN yy;

		if (BATprepareHash(bn)) {
			BBPreclaim(bn);
			return NULL;
		}
		HASHloop@4(bni, bn->H->hash, yy, h) {
			if (HIT@1(t, BUNt@3(bni, yy))) {
				ins = 0;
				break;
			}
		}
		if (ins) {
			bunfastins(bn, h, t);
			if (bn->H->hash)
				HASHins@4(bn->H->hash, zz, h);
			zz++;
		}
	}
	BATaccessEnd(b, USE_HEAD|USE_TAIL, MMAP_SEQUENTIAL);
	BATaccessEnd(bn, USE_HEAD|USE_TAIL|USE_HHASH, MMAP_SEQUENTIAL);
@= elim
	{
		int (*cmp)(ptr, ptr) = BATatoms[b->ttype].atomCmp;
		BUN zz;
		BUN p, q, r;

		if (BAThordered(b) & 1) {
			ALGODEBUG THRprintf(GDKout, "#BATins_@1unique: BAThordered(b)\n");
			ALGODEBUG THRprintf(GDKout, "#BATins_@1unique: mergeelim\n");
			if (b->tvarsized) {
				@:mergeelim(@1,@2,var,@4,@3)@
			} else {
				@:mergeelim(@1,@2,loc,@4,@3)@
			}
		} else if (b->tvarsized) {
			ALGODEBUG THRprintf(GDKout, "#BATins_@1unique: hashelim\n");
			@:hashelim(@1,@2,var,@3)@
		} else {
			ALGODEBUG THRprintf(GDKout, "#BATins_@1unique: hashelim\n");
			@:hashelim(@1,@2,loc,@3)@
		}
		(void) cmp;
		break;
	}
@= elim_doubles
	switch (ATOMstorage(b->htype)) {
#ifndef NOEXPAND_CHR
	case TYPE_chr:
		@:elim(@1,loc,_chr,simple_CMP(h,BUNhloc(bi,r),chr))@
#endif
#ifndef NOEXPAND_BTE
	case TYPE_bte:
		@:elim(@1,loc,_bte,simple_CMP(h,BUNhloc(bi,r),bte))@
#endif
#ifndef NOEXPAND_SHT
	case TYPE_sht:
		@:elim(@1,loc,_sht,simple_CMP(h,BUNhloc(bi,r),sht))@
#endif
#ifndef NOEXPAND_INT
	case TYPE_int:
		@:elim(@1,loc,_int,simple_CMP(h,BUNhloc(bi,r),int))@
#endif
#ifndef NOEXPAND_FLT
	case TYPE_flt:
		@:elim(@1,loc,_flt,simple_CMP(h,BUNhloc(bi,r),flt))@
#endif
#ifndef NOEXPAND_DBL
	case TYPE_dbl:
		@:elim(@1,loc,_dbl,simple_CMP(h,BUNhloc(bi,r),dbl))@
#endif
#ifndef NOEXPAND_LNG
	case TYPE_lng:
		@:elim(@1,loc,_lng,simple_CMP(h,BUNhloc(bi,r),lng))@
#endif
	case TYPE_str:
		if (b->H->vheap->hashash) {
			@:elim(@1,var,_str_hv,GDK_STRCMP(h,BUNhvar(bi,r)))@
		}
		/* fall through */
	default:
		{
			int (*merge)(ptr, ptr) = BATatoms[b->htype].atomCmp;

			if (b->hvarsized) {
				@:elim(@1,var,var,((*merge)(h,BUNhvar(bi,r))))@
			} else {
				@:elim(@1,loc,loc,((*merge)(h,BUNhloc(bi,r))))@
			}
		}
	}
@c
BAT *
BATins_kunique(BAT *bn, BAT *b)
{
	bit unique = FALSE;
	BATiter bi = bat_iterator(b);
	BATiter bni = bat_iterator(bn);

	BATcheck(b, "BATins_kunique: src BAT required");
	BATcheck(bn, "BATins_kunique: dst BAT required");
	unique = (BATcount(bn) == 0);
	@:elim_doubles(k)@
	if (unique && bn->hkey == FALSE) {
		/* we inserted unique head-values into an empty BAT;
		   hence, the resulting BAT's head is (now) unique/key ... */
		BATkey(bn, TRUE);
	}
	bn->H->nonil = b->H->nonil;
	bn->T->nonil = b->T->nonil;
	return bn;
      bunins_failed:
	BBPreclaim(bn);
	return NULL;
}

static BAT *
BATins_sunique(BAT *bn, BAT *b)
{
	bit unique = FALSE;
	BUN fst1, fst2, last1, last2;
	BATiter bi = bat_iterator(b);
	BATiter bni = bat_iterator(bn);

	BATcheck(b, "BATins_sunique: src BAT required");
	BATcheck(bn, "BATins_sunique: dst BAT required");

	unique = (BATcount(bn) == 0);

	fst1 = BUNfirst(bn);
	fst2 = BUNfirst(b);

	last1 = (BUNlast(bn) - 1);
	last2 = (BUNlast(b) - 1);

	if (BATcount(b) &&
	    (BAThordered(b) & 1) &&
	    ATOMcmp(b->htype, BUNhead(bi, fst2), BUNhead(bi, last2)) == 0 &&
	    (BATcount(bn) == 0 ||
	     (ATOMcmp(bn->htype, BUNhead(bni, fst1), BUNhead(bi, fst2)) == 0 &&
	      (BAThordered(bn) & 1) &&
	      ATOMcmp(bn->htype, BUNhead(bni, fst1), BUNhead(bni, last1)) == 0))) {
		ALGODEBUG THRprintf(GDKout, "#BATins_sunique: BATins_kunique(BATmirror(bn), BATmirror(b))\n");
		return BATins_kunique(BATmirror(bn), BATmirror(b));
	}
	if (BATcount(b) &&
	    (BATtordered(b) & 1) &&
	    ATOMcmp(b->ttype, BUNtail(bi, fst2), BUNtail(bi, last2)) == 0 &&
	    (BATcount(bn) == 0 ||
	     (ATOMcmp(bn->ttype, BUNtail(bni, fst1), BUNtail(bi, fst2)) == 0 &&
	      (BATtordered(bn) & 1) &&
	      ATOMcmp(bn->ttype, BUNtail(bni, fst1), BUNtail(bni, last1)) == 0))) {
		ALGODEBUG THRprintf(GDKout, "#BATins_sunique: BATins_kunique(bn, b)\n");
		return BATins_kunique(bn, b);
	}
	if ((BATtordered(b) & 1) && ATOMstorage(b->ttype) < TYPE_str) {
		bni.b = bn = BATmirror(bn);
		bi.b = b = BATmirror(b);
	}

	@:elim_doubles(s)@
	if (unique && bn->batSet == FALSE) {
		/* we inserted unique BUNs into an empty BAT;
		   hence, the resulting BAT is (now) unique/set ... */
		BATset(bn, TRUE);
	}
	bn->H->nonil = b->H->nonil;
	bn->T->nonil = b->T->nonil;
	return bn;
      bunins_failed:
	BBPreclaim(bn);
	return NULL;
}


@- Unique
The routine @`BATsunique@5 removes duplicate BUNs,
The routine @`BATkunique@5 removes duplicate head entries.
@c
BAT *
BATkunique(BAT *b)
{
	BAT *bn;

	BATcheck(b, "BATkunique");

	if (b->hkey) {
		bn = BATcopy(b, b->htype, b->ttype, FALSE);
		if (bn == NULL)
			return NULL;
	} else {
		BUN cnt = BATcount(b);

		if (cnt > 10000) {
			BAT *tmp2 = NULL, *tmp1, *tmp0 = VIEWhead_(b, BAT_WRITE);

			if (tmp0) {
				tmp1 = BATsample(tmp0, 1000);
				if (tmp1) {
					tmp2 = BATkunique(tmp1);
					if (tmp2) {
						cnt = (BUN) ((((lng) BATcount(tmp2)) * cnt) / 900);
						BBPreclaim(tmp2);
					}
					BBPreclaim(tmp1);
				}
				BBPreclaim(tmp0);
			}
			if (tmp2 == NULL)
				return NULL;
		}
		bn = BATnew(BAThtype(b), BATttype(b), cnt);
		if (bn == NULL || BATins_kunique(bn, b) == NULL)
			return NULL;
	}

	/* property management */
	if (b->halign == 0) {
		b->halign = OIDnew(1);
	}
	BATkey(bn, TRUE);	/* this we accomplished */
	BATkey(BATmirror(bn), BATtkey(b));
	bn->hsorted = BAThordered(b);
	bn->tsorted = BATtordered(b);
	bn->H->nonil = b->H->nonil;
	bn->T->nonil = b->T->nonil;
	if (BATcount(bn) == BATcount(b)) {
		ALIGNset(bn, b);
	}
	return bn;
}

BAT *
BATukunique(BAT *b)
{
	BAT *v, *bn;

	BATcheck(b, "BATukunique");
	bn = BATkunique(v = VIEWhead(b));
	BBPreclaim(v);
	return bn;
}

BAT *
BATsunique(BAT *b)
{
	BAT *bn;

	BATcheck(b, "BATsunique");

	if (b->hkey || b->tkey || b->batSet) {
		bn = BATcopy(b, b->htype, b->ttype, FALSE);
	} else {
		BUN cnt = BATcount(b);

		if (cnt > 10000) {
			BAT *tmp2 = NULL, *tmp1 = BATsample(b, 1000);

			if (tmp1) {
				tmp2 = BATkunique(tmp1);
				if (tmp2) {
					cnt = BATcount(tmp2) * (cnt / 1000);
					BBPreclaim(tmp2);
				}
				BBPreclaim(tmp1);
			}
			if (tmp2 == NULL)
				return NULL;
		}
		bn = BATnew(BAThtype(b), BATttype(b), cnt);
		if (bn == NULL || BATins_sunique(bn, b) == NULL)
			return NULL;
	}

	/* property management */
	BATset(bn, TRUE);	/* this we accomplished */
	BATkey(bn, BAThkey(b));
	BATkey(BATmirror(bn), BATtkey(b));
	bn->hsorted = BAThordered(b);
	bn->tsorted = BATtordered(b);
	bn->H->nonil = b->H->nonil;
	bn->T->nonil = b->T->nonil;
	if (BATcount(bn) == BATcount(b)) {
		ALIGNset(bn, b);
	}
	return bn;
}

@}
@+ Difference and Intersect
Difference and Intersection are handled together. For each routine
there are two versions: @`BATkdiff@5(l,r) and @`BATkintersect@5(l,r) (which
look at the head column only), versus @`BATsdiff@5(l,r) and
@`BATsintersect@5(l,r) (looking at both columns).
TODO synced/key case..
@{

@= mergecheck
	BUN p1 = BUNfirst(l), p2 = BUNfirst(r);
	BUN q1 = BUNlast(l),  q2 = BUNlast(r);
	BATiter li = bat_iterator(l);
	BATiter ri = bat_iterator(r);

	ALGODEBUG THRprintf(GDKout, "#BATins_@1@2: mergecheck[@1, @2, @3, @4, @5];\n");
	if (p2 < q2)
		BATloop(l, p1, q1) {
			ptr  h = BUNh@2(li, p1);
			ptr  t = BUNtail(li, p1);
			ptr h2 = BUNh@2(ri, p2);
			int c;
			while ((c = @4) > 0) {
				if ((++p2) >= q2)
					goto end@2@3;
				h2 = BUNh@2(ri, p2);
			}
			if (c == 0) {
				h2 = hnil;
				if (@4) { /* check for not-nil (nils don't match anyway) */
					BUN pb = p2;

					for (;;) {
						if (EQUAL@5(t, BUNtail(ri, pb))) {
							HIT@1(h, t);
							break;
						}
						if ((++pb) >= q2) {
							MISS@1(h, t);
							break;
						}
						h2 = BUNh@2(ri, pb);
						if (@4) {
							MISS@1(h, t);
							break;
						}
					}
					continue;
				}
			}
			MISS@1(h, t);
		}
  end@2@3:;
	END@1(BUNh@2(li, p1), BUNtail(li, p1));
@= hashcheck
	BUN p1, q1;
	int ins;
	BUN s2;
	ptr h, t, h2 = hnil;
	BATiter li = bat_iterator(l);
	BATiter ri = bat_iterator(r);

	ALGODEBUG THRprintf(GDKout, "#BATins_@1@2: hashcheck[@1, @2, @3, @4, @5];\n");
	BATaccessBegin(r, USE_HEAD, MMAP_SEQUENTIAL);
	if (BATprepareHash(r)) {
		BATaccessEnd(r, USE_HEAD, MMAP_SEQUENTIAL);
		goto bunins_failed;
	}
	BATaccessEnd(r, USE_HEAD, MMAP_SEQUENTIAL);
	/* use MMAP_WILLNEED only if random access is not too scattered, *
	 * i.e., only if number of lookups is more than 10% of inner BAT */
	if (BATcount(l) > BATcount(r)/10)
		BATaccessBegin(r, USE_HEAD|USE_TAIL|USE_HHASH, MMAP_WILLNEED);
	BATaccessBegin(l, USE_HEAD|USE_TAIL, MMAP_SEQUENTIAL);
	BATloop(l, p1, q1) {
		h = BUNh@2(li, p1);
		t = BUNtail(li, p1);
		ins = TRUE;
		if (@6) /* check for not-nil (nils don't match anyway) */
			HASHloop@4(ri, r->H->hash, s2, h) {
				if (EQUAL@5(t, BUNtail(ri, s2))) {
					HIT@1(h, t);
					ins = FALSE;
					break;
				}
			}
		if (!ins)
			continue;
		MISS@1(h, t);
	}
	/* use MMAP_WILLNEED only if random access is not too scattered, *
	 * i.e., only if number of lookups is more than 10% of inner BAT */
	if (BATcount(l) > BATcount(r)/10)
		BATaccessEnd(r, USE_HEAD|USE_TAIL|USE_HHASH, MMAP_WILLNEED);
	BATaccessEnd(l, USE_HEAD|USE_TAIL, MMAP_SEQUENTIAL);
	(void)h2; /* in some cases the @6 check doesn't use the h2 */

@c
#define DIRECT_MAX 256

#define chr_EQ(x,y) simple_EQ(x,y,chr)
#define bte_EQ(x,y) simple_EQ(x,y,bte)
#define sht_EQ(x,y) simple_EQ(x,y,sht)
#define int_EQ(x,y) simple_EQ(x,y,int)
#define lng_EQ(x,y) simple_EQ(x,y,lng)
#define flt_EQ(x,y) simple_EQ(x,y,flt)
#define dbl_EQ(x,y) simple_EQ(x,y,dbl)

/* later add version for l void tail, remove general tail values then */
@= directcheck
	BUN p1, q1;
	int i;
	ptr h, h2 = hnil;
	BATiter li = bat_iterator(l);
	BATiter ri = bat_iterator(r);
	sht d[DIRECT_MAX];
	Hash hs, *H = &hs;
	int collision = 0;

	H -> mask = DIRECT_MAX-1;
	H -> type = BAThtype(l);

	ALGODEBUG THRprintf(GDKout, "#BATins_@1@2: directcheck[@1, @2, @3, @4, @5];\n");

	assert(l->htype == r->htype && r->htype != TYPE_void);

	memset(d, 0, sizeof(d));
	BATloop(r, p1, q1) {
		h = BUNh@2(ri,p1);
		i = (int) hash_@4(H, h);
		/* collision or check for not-nil (nils don't match anyway) */
		if (d[i] != 0 || !(@6)) {
			collision = 1;
			break;
		}
		d[i] = ((sht)p1)+1;
	}
	if (collision) {
		@:hashcheck(@1,@2,@3,_@4,@5,@6)@
	} else {
		if (!l->ttype && l->tseqbase != oid_nil) {
			oid b = l->tseqbase, *t = &b;
			@4 *h = (@4*)BUNhloc(li, BUNfirst(l));
			@4 *rh = (@4*)BUNhloc(ri, 0);
			@4 *bnh;
			oid *bnt;
			BUN o = BUNfirst(bn);

			ALGODEBUG THRprintf(GDKout, "#BATins_@1@2: directcheck[@1, @2, @3, _@4, @5][void tail]; " BUNFMT " " BUNFMT "\n", BATcount(l), BATcount(r));
			p1 = 0;
			q1 = BATcount(l);
			while(p1 < q1) {
				BUN r1;
				if (p1 + 1 > BATcapacity(bn)){	
					BATsetcount(bn, o);
					if (BATextend(bn, BATgrows(bn)) == NULL)
						goto bunins_failed; 
				}
				r1 = p1 + BATcapacity(bn) - BUNlast(bn);
				if (r1 > q1) r1 = q1;
				bnh = (@4*)Hloc(bn,0);
				bnt = (oid*)Tloc(bn,0);
				for (; p1<r1; p1++, b++){ 
					i = (int) hash_@4(H, h+p1);
					if (d[i] != 0 && @7(h+p1, rh+d[i]-1) &&
					    EQUAL@5(t, BUNtail(ri, d[i]-1))) {
						DHIT@1(h+p1, b);
					} else {
						DMISS@1(h+p1, b);
					}
				}
			}
			BATsetcount(bn, o);
			(void)t;
		} else { 
			@4 *h = (@4*)BUNhloc(li, 0);
			@4 *rh = (@4*)BUNhloc(ri, 0);

			ALGODEBUG THRprintf(GDKout, "#BATins_@1@2: directcheck[@1, @2, @3, _@4, @5]; " BUNFMT " " BUNFMT "\n", BATcount(l), BATcount(r));
			p1 = BUNfirst(l);
			q1 = BUNlast(l);
			while(p1 < q1) {
				BUN r1;
				if (BUNlast(bn) + 1 > BATcapacity(bn)){	
					if (BATextend(bn, BATcapacity(bn)+65536) == NULL)
						goto bunins_failed; 
				}
				r1 = p1 + BATcapacity(bn) - BUNlast(bn);
				if (r1 > q1) r1 = q1;
				for (; p1<r1; p1++) { 
					i = (int) hash_@4(H, h+p1);
					if (d[i] != 0 && @7(h+p1, rh+d[i]-1) &&
				    	    EQUAL@5(BUNtail(li,p1), BUNtail(ri, d[i]-1))) {
						HIT@1_nocheck(h+p1, BUNtail(li, p1));
					} else {
						MISS@1_nocheck(h+p1, BUNtail(li, p1));
					}
				}
			}
		}
	}
	(void)h2; /* in some cases the @6 check doesn't use the h2 */

@= voidcheck
	{
		BATiter li = bat_iterator(l);
		BATiter ri = bat_iterator(r);
		BUN p1 = BUNfirst(r), q1 = BUNlast(r);
		oid rl = * (oid *) BUNhead(ri, p1);
		oid rh = rl + BATcount(r);
		ptr h, t = NULL, t2 = NULL;

		(void) t2;

		ALGODEBUG THRprintf(GDKout, "#BATins_@1@2: voidcheck[@1, @2];\n");
		if (BAThdense(l)) {
			oid ll = * (oid *) BUNhead(li, (p1 = BUNfirst(l)));
			oid lh = ll + BATcount(l);
			BUN hit_start = (q1 = BUNlast(l)), hit_end = q1, w = BUNfirst(r);
			BUN off = p1;

			h = (ptr) &ll;

			if (rl >= ll && rl < lh) {
				hit_start = off + (rl - ll);
			} else if (rl < ll && rh > ll) {
				hit_start = p1;
				w += (ll - rl);
			}
			if (rh >= ll && rh < lh) {
				hit_end = off + (rh - ll);
			}
			while(p1 < hit_start) {
				t = BUNtail(li, p1);
				MISS@1(h, t);
				ll++;
				p1++;
			}
			while(p1 < hit_end) {
				t = BUNtail(li, p1);
				t2 = BUNtail(ri, w);
				if (EQUAL@2(t, t2)) {
					HIT@1(h, t);
				} else {
					MISS@1(h, t);
				}
				ll++;
				p1++;
				w++;
			}
			while (p1 < q1) {
				t = BUNtail(li, p1);
				MISS@1(h, t);
				ll++;
				p1++;
			}
		} else {
			BUN off = p1;

			BATloop(l, p1, q1) {
				oid o = * (oid *) BUNhloc(li, p1);

				h = (ptr) &o;
				t = BUNtail(li, p1);

				if (o >= rl && o < rh) {
					BUN w = off + (o - rl);

					t2 = BUNtail(ri, w);
					if (EQUAL@2(t, t2)) {
						HIT@1(h, t);
						continue;
					}
				}
				MISS@1(h, t);
			}
		}
	}

@= checkall
	if (BAThdense(l)) {
		@:hashcheck(@1,pos,@2,@3,@5,TRUE)@
	} else if (hash) {
		if (l->htype == TYPE_str && l->H->vheap->hashash) {
			@:hashcheck(@1,@2,@2,_str_hv,@5,@4)@
		} else {
			@:hashcheck(@1,@2,@2,@3,@5,@4)@
		}
	} else {
		@:mergecheck(@1,@2,@3,@4,@5)@
	}
	break;

@= check
	if (BAThdense(l)) {
		@:hashcheck(@1,pos,@2,_@3,@5,TRUE)@
	} else if (hash) {
		if (BATcount(r) < DIRECT_MAX) {
			@:directcheck(@1,@2,@2,@3,@5,@4,@6)@
		} else {
			@:hashcheck(@1,@2,@2,_@3,@5,@4)@
		}
	} else {
		@:mergecheck(@1,@2,_@3,@4,@5)@
	}
	break;

@= batcheck
static BAT*
BATins_@1@2(BAT *bn, BAT *l, BAT *r)
{
	int hash = TRUE, (*cmp)(ptr, ptr), (*merge)(ptr, ptr) = NULL;
	ptr hnil, tnil;

	/* determine how to do the intersect */
	if (BAThordered(l) & BAThordered(r) & 1) {
		hash = FALSE;
	} else if (FLIP@1(l, r)) {
		int flip = BATtordered(l) & BATtordered(r) & 1;

		if (flip) {
			hash = FALSE;
		} else {
			flip = r->H->hash == NULL && r->T->hash != NULL;
		}
		if (flip) {
			r = BATmirror(r);
			l = BATmirror(l);
			bn = BATmirror(bn);
		}
	}
	merge = BATatoms[l->htype].atomCmp;
	cmp = BATatoms[l->ttype].atomCmp;
	hnil = ATOMnilptr(l->htype);
	tnil = ATOMnilptr(l->ttype);
	(void) cmp;
	(void) tnil;
	(void) hnil;

	if (BAThdense(r)) {
		@:voidcheck(@2,@1)@
	} else {
		switch(ATOMstorage(r->htype)) {
#ifndef NOEXPAND_CHR
		case TYPE_chr:
			@:check(@2,loc,chr,simple_CMP(h,h2,chr),@1,chr_EQ)@
#endif
#ifndef NOEXPAND_BTE
		case TYPE_bte:
			@:check(@2,loc,bte,simple_CMP(h,h2,bte),@1,bte_EQ)@
#endif
#ifndef NOEXPAND_SHT
		case TYPE_sht:
			@:check(@2,loc,sht,simple_CMP(h,h2,sht),@1,sht_EQ)@
#endif
#ifndef NOEXPAND_INT
		case TYPE_int:
			@:check(@2,loc,int,simple_CMP(h,h2,int),@1,int_EQ)@
#endif
#ifndef NOEXPAND_FLT
		case TYPE_flt:
			@:check(@2,loc,flt,simple_CMP(h,h2,flt),@1,flt_EQ)@
#endif
#ifndef NOEXPAND_DBL
		case TYPE_dbl:
			@:check(@2,loc,dbl,simple_CMP(h,h2,dbl),@1,dbl_EQ)@
#endif
#ifndef NOEXPAND_LNG
		case TYPE_lng:
			@:check(@2,loc,lng,simple_CMP(h,h2,lng),@1,lng_EQ)@
#endif
		default:
			if (r->hvarsized) {
				@:checkall(@2,var,var,((*merge)(h,h2)),@1,0==cmp)@
			} else {
				@:checkall(@2,loc,loc,((*merge)(h,h2)),@1,0==cmp)@
			}
		}
	}
	return bn;
  bunins_failed:
	BBPreclaim(bn);
	return NULL;
}

BAT *
BAT@1@2(BAT *l, BAT *r)
{
	BUN	smaller;
	BAT	*bn;

	ERRORcheck(l == NULL, "BAT@1@2: left is null");
	ERRORcheck(r == NULL, "BAT@1@2: right is null");
	ERRORcheck(TYPEerror(BAThtype(l), BAThtype(r)), "BUN@1@2: incompatible head-types");
	ERRORcheck(TAILCHECK@1(l,r), "BUN@1@2: incompatible tail-types");

	if (BATcount(r) == 0) {
		return EMPTYr@2(l);
	} else if (BATcount(l) == 0) {
		return EMPTYl@2(l);
	}
	smaller = @2_size(l, r);
	bn = BATnew(BAThtype(l), BATttype(l), MAX(smaller,BATTINY));
	if (bn == NULL)
		return NULL;

	/* fill result bat bn */
	ALGODEBUG THRprintf(GDKout, "#BAT@1@2: BATins_@1@2(bn, l, r);\n");
	if (BATins_@1@2(bn, l, r) == NULL) {
		return NULL;
	}

	/* propagate alignment info */
	if (BATcount(bn) == BATcount(l)) {
		ALIGNset(bn, l);
	}
	if (RALIGN@2(bn, l, r)) {
		ALIGNsetH(bn, r);
	}
	bn->hsorted = BAThordered(l);
	bn->tsorted = BATtordered(l);
	if (BATcount(bn)) {
		BATkey(bn, BAThkey(l));
		BATkey(BATmirror(bn), BATtkey(l));
	} else {
		BATkey(bn, TRUE);
		BATkey(BATmirror(bn), TRUE);
	}
	bn->H->nonil = l->H->nonil;
	bn->T->nonil = l->T->nonil;
	return bn;
}
@c
#define EMPTYldiff(l) BATclone(l,10)
#define EMPTYrdiff(l) BATcopy(l, l->htype, l->ttype, FALSE)
#define EMPTYlintersect(l) BATclone(l,10)
#define EMPTYrintersect(l) EMPTYlintersect(l)

#define intersect_size(l,r) MIN(BATcount(l), BATcount(r))
#define diff_size(l,r) BATcount(l)

@:batcheck(s,intersect,)@
@:batcheck(s,diff,-)@
@:batcheck(k,intersect,)@
@:batcheck(k,diff,-)@


@+ Union
Union also consists of two versions: @`BATkunion@5(l,r), which
unites with double elimination over the head column only, and
@`BATsunion@5(l,r), that looks at both columns. Their
implementation uses the s/kdiff() and s/kunique() code for efficient
double elimination.
@c
#define KEYk	TRUE
#define KEYs	FALSE

static BAT *
BATmaterialize_(BAT *b, BUN size)
{
	BAT *bn = BATnew(TYPE_oid, b->ttype, size);
	BUN p, q;
	oid base;
	BATiter bi = bat_iterator(b);

	if (bn == NULL)
		return NULL;
	base = b->hseqbase;
	BATaccessBegin(b, USE_TAIL, MMAP_SEQUENTIAL);
	BATaccessBegin(bn, USE_HEAD | USE_TAIL, MMAP_SEQUENTIAL);
	if (base == oid_nil) {
		BATloop(b, p, q) {
			bunfastins(bn, &base, BUNtail(bi, p));
		}
	} else {
		BATloop(b, p, q) {
			bunfastins(bn, &base, BUNtail(bi, p));
			base++;
		}
	}
	BATaccessEnd(bn, USE_HEAD | USE_TAIL, MMAP_SEQUENTIAL);
	BATaccessEnd(b, USE_TAIL, MMAP_SEQUENTIAL);
	ALIGNsetH(bn, b);
	ALIGNsetT(bn, b);
	return bn;
      bunins_failed:
	BBPreclaim(bn);
	return NULL;
}

@:union(k)@
@:union(s)@

@= bndense
	/* r and l may be void */
	bn@1dense = (BAT@1dense(r) & BAT@1dense(l) & 1) && @1disjunct &&
			((* (@3 *) BUN@2(ri, BUNfirst(r)) - * (@3 *) BUN@2(li, BUNlast(l) - 1)) == (@3) 1);
	break;
@= union
BAT *
BAT@1union(BAT *l, BAT *r)
{
	int hdisjunct, tdisjunct, bnhdense, bntdense;
	BAT *bn, *b=0;
	BUN p,q;
	BATiter li, ri;

	BATcompatible(l, r);
	if (BATcount(l) == 0) {
		BAT* swap = l;

		l = r;
		r = swap;
	}
	li = bat_iterator(l);
 	ri = bat_iterator(r);
	if (BATcount(r) == 0) {
		return BATcopy(l, l->htype, l->ttype, FALSE);
	}
	if (l->htype == TYPE_void && l->hseqbase != oid_nil) {
		bn = BATmaterialize_(l, BATcount(l) + BATcount(r));
	} else if (l->ttype == TYPE_void && l->tseqbase != oid_nil) {
		bn = BATmirror(BATmaterialize_(BATmirror(l), BATcount(l) + BATcount(r)));
	} else {
		bn = BATcopy(l, l->htype, l->ttype, TRUE);
	}
	if (bn == NULL)
		return NULL;

	hdisjunct = (BAThordered(r) & BAThordered(l) & 1) &&
		    ATOMcmp(l->htype, BUNhead(li, BUNlast(l) - 1), BUNhead(ri, BUNfirst(r))) < 0;
	tdisjunct = (BATtordered(r) & BATtordered(l) & 1) &&
		    ATOMcmp(l->ttype, BUNtail(li, BUNlast(l) - 1), BUNtail(ri, BUNfirst(r))) < 0;

	/* for now, only oid can be dense;
	   later, bte, sht, int, wrd, lng might become dense, too */
	switch (bn->htype) {
	case TYPE_oid:
	case TYPE_void:
		@:bndense(h,head,oid)@
	default:
	        bnhdense = 0;
	}
	switch (bn->ttype) {
	case TYPE_oid:
	case TYPE_void:
		@:bndense(t,tail,oid)@
	default:
		bntdense = 0;
	}

	if (!hdisjunct) {
		b = r;
		ri.b = r = BAT@1diff(r, bn);
		if (r == NULL) {
			BBPreclaim(bn);
			return NULL;
		}
	}
	BATloop(r, p, q) {
		bunfastins(bn, BUNhead(ri, p), BUNtail(ri, p));
	}
	if (b) {
		BBPreclaim(r);
		r = b;
	}
	HASHdestroy(bn);

	/* set alignment info */
	if (!bnhdense) {
		bn->hseqbase = oid_nil;
		bn->hdense = 0;
	}
	if (!bntdense) {
		bn->tseqbase = oid_nil;
		bn->tdense = 0;
	}
	bn->hsorted = hdisjunct ? GDK_SORTED : FALSE;
	bn->tsorted = tdisjunct ? GDK_SORTED : FALSE;
	bn->talign = bn->halign = 0;
	if (!r->hkey)
		BATkey(bn, FALSE);
#if KEY@1 == KEYs
	if (bn->hkey && hdisjunct == FALSE)
		BATkey(bn, FALSE);
#endif
	BATkey(BATmirror(bn), tdisjunct ? BATtkey(l) && BATtkey(r) : 0);
	bn->H->nonil = l->H->nonil & r->H->nonil;
	bn->T->nonil = l->T->nonil & r->T->nonil;

	return bn;
  bunins_failed:
	BBPreclaim(bn);
	return NULL;
}
@}
@-
