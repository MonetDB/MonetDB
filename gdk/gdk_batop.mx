@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2011 MonetDB B.V.
All Rights Reserved.
@

@f gdk_batop
@a M. L. Kersten, P. Boncz, S. Manegold, N. Nes
@* Common BAT Operations
This module contains the following BAT algebra operations:
@itemize 
@item bulk updates
multi-insert, multi-delete, multi-replace
@item common aggregates
min, max and histogram
@item oid column manipulations
mark, number and split.
@item bat selections
select, slice, sample, fragment and restrict.
Note: non hash-/index-supported scanselects have been "outsourced"
to gdk_scanselect.mx as the fully expanded code grows too large to be
(conveniently) compiled in a single file.
@item bat partitioning
hash partition, range partitioning
@end itemize
We factor out all possible overhead by inlining code.
This includes the macros BUNhead and BUNtail,
which do a test to see whether the atom resides in the buns or in a
variable storage heap. The updateloop(dstbat, srcbat, operation) macro
invokes operation(dstbat, BUNhead(srcbat), BUNtail(srcbat)) on all buns
of the srcbat, but testing only once where they reside.
@{
@c
#include "monetdb_config.h"
#include "gdk.h"
#include "gdk_scanselect.h"

@= updateloop
{
	BATiter bi = bat_iterator(@2);
	BUN p1, p2;

	BATloop(@2, p1, p2) {
		@3(@1, BUNhead(bi, p1), BUNtail(bi, p1));
	}
}
@}

@+ BAT insert/delete/replace
The content of a BAT can be appended to (removed from) another using
@%BATins@ (@%BATdel@).
@{
@c
static BAT *
insert_string_bat(BAT *b, BAT *n, int append)
{
	BATiter ni;		/* iterators */
	int ht, tt;		/* head and tail types */
	size_t hoff = ~(size_t) 0, toff = ~(size_t) 0;	/* head and tail offsets */
	BUN p, q;		/* loop variables */
	oid o = 0;		/* in case we're appending */
	ptr hp, tp;		/* head and tail value pointers */
	unsigned char hbv, tbv;	/* head and tail value-as-bte */
	unsigned short hsv, tsv; /* head and tail value-as-sht */
#if SIZEOF_VAR_T == 8
	unsigned int hiv, tiv;	/* head and tail value-as-int */
#endif
	var_t hvv, tvv;		/* head and tail value-as-var_t */
	var_t v;		/* value */
	int nhw, ntw, bhw, btw;	/* shortcuts for {b,n}->{H,T}->width */

	assert(!append || b->H->type == TYPE_void || b->H->type == TYPE_oid);
	if (n->batCount == 0)
		return b;
	ni = bat_iterator(n);
	bhw = b->H->width;
	btw = b->T->width;
	nhw = n->H->width;
	ntw = n->T->width;
	hp = NULL;
	tp = NULL;
@= prep_strapp
	@1t = b->@1type;
	if (@1t == TYPE_str &&
	    (!GDK_ELIMDOUBLES(b->@2->vheap) || b->batCount == 0) &&
	    !GDK_ELIMDOUBLES(n->@2->vheap) &&
	    b->@2->vheap->hashash == n->@2->vheap->hashash &&
	    /* if needs to be kept unique, take slow path */
	    (b->@1key & BOUND2BTRUE) == 0 &&
	    /* if view, only copy if significant part of parent is used */
	    (VIEW@1parent(n) == 0 ||
	     BATcapacity(BBP_cache(VIEW@1parent(n))) < 2 * BATcount(n))) {
		/* append string heaps */
		@1off = b->batCount == 0 ? 0 : b->@2->vheap->free;
		/* make sure we get alignment right */
		@1off = (@1off + GDK_VARALIGN - 1) & ~(GDK_VARALIGN - 1);
		assert(((@1off >> GDK_VARSHIFT) << GDK_VARSHIFT) == @1off);
		if (HEAPextend(b->@2->vheap, @1off + n->@2->vheap->size) < 0) {
			@1off = ~ (size_t) 0;
			goto bunins_failed;
		}
		memcpy(b->@2->vheap->base + @1off, n->@2->vheap->base, n->@2->vheap->size);
		b->@2->vheap->free = @1off + n->@2->vheap->free;
		/* flush double-elimination hash table */
		memset(b->@2->vheap->base, 0, GDK_STRHASHSIZE);
		if (b->@2->width < SIZEOF_VAR_T &&
		    ((size_t) 1 << 8 * b->@2->width) < (b->@2->width <= 2 ? (b->@2->vheap->size >> GDK_VARSHIFT) - GDK_VAROFFSET : (b->@2->vheap->size >> GDK_VARSHIFT))) {
			/* offsets aren't going to fit */
			if (GDKupgradevarheap(b->@2, (var_t) (b->@2->vheap->size >> GDK_VARSHIFT), 0) == GDK_FAIL) {
				@1off = ~ (size_t) 0;
				goto bunins_failed;
			}
			b@1w = b->@2->width;
		}
		switch (b@1w) {
		case 1:
			@1t = TYPE_bte;
			break;
		case 2:
			@1t = TYPE_sht;
			break;
#if SIZEOF_VAR_T == 8
		case 4:
			@1t = TYPE_int;
			break;
#endif
		default:
			@1t = TYPE_var;
			break;
		}
		b->@2->varsized = 0;
		n->@2->varsized = 0;
		b->@2->type = @1t;
	}
@c
	if (!append) {
		@:prep_strapp(h,H)@
	} else if (b->H->type != TYPE_void) {
		hp = &o;
		o = MAXoid(b);
	}
	@:prep_strapp(t,T)@

	BATloop(n, p, q) {
@= read_strapp
		@1p = b->@2->type ? BUN@3(ni, p) : NULL;
		if (@1off != ~ (size_t) 0) {
			assert(@1p != NULL);
			switch (n@1w) {
			case 1:
				v = (var_t) * (unsigned char *) @1p + GDK_VAROFFSET;
				break;
			case 2:
				v = (var_t) * (unsigned short *) @1p + GDK_VAROFFSET;
				break;
#if SIZEOF_VAR_T == 8
			case 4:
				v = (var_t) * (unsigned int *) @1p;
				break;
#endif
			default:
				v = * (var_t *) @1p;
				break;
			}
			v = (var_t) ((((size_t) v << GDK_VARSHIFT) + @1off) >> GDK_VARSHIFT);
			assert(v >= GDK_VAROFFSET);
			assert(((size_t) v << GDK_VARSHIFT) < b->@2->vheap->free);
			switch (b@1w) {
			case 1:
				assert(v - GDK_VAROFFSET < ((var_t) 1 << 8));
				@1bv = (unsigned char) (v - GDK_VAROFFSET);
				@1p = (ptr) &@1bv;
				break;
			case 2:
				assert(v - GDK_VAROFFSET < ((var_t) 1 << 16));
				@1sv = (unsigned short) (v - GDK_VAROFFSET);
				@1p = (ptr) &@1sv;
				break;
#if SIZEOF_VAR_T == 8
			case 4:
				assert(v < ((var_t) 1 << 32));
				@1iv = (unsigned int) v;
				@1p = (ptr) &@1iv;
				break;
#endif
			default:
				@1vv = v;
				@1p = (ptr) &@1vv;
				break;
			}
		}
@c
		if (!append) {
			@:read_strapp(h,H,head)@
		}
		@:read_strapp(t,T,tail)@
		bunfastins(b, hp, tp);
		if (append)
			o++;
	}
	if (hoff != ~(size_t) 0) {
		b->H->varsized = 1;
		n->H->varsized = 1;
		b->H->type = TYPE_str;
	}
	if (toff != ~(size_t) 0) {
		b->T->varsized = 1;
		n->T->varsized = 1;
		b->T->type = TYPE_str;
	}
	return b;
      bunins_failed:
	if (hoff != ~(size_t) 0) {
		b->H->varsized = 1;
		n->H->varsized = 1;
		b->H->type = TYPE_str;
	}
	if (toff != ~(size_t) 0) {
		b->T->varsized = 1;
		n->T->varsized = 1;
		b->T->type = TYPE_str;
	}
	return NULL;
}

#define bunins(b,h,t) if (BUNins(b,h,t,force) == NULL) return NULL;
BAT *
BATins(BAT *b, BAT *n, bit force)
{
	BAT *tmp = NULL, *res = NULL;
	int fastpath = 0;
	int countonly;

	if (b == NULL || n == NULL || BATcount(n) == 0) {
		return b;
	}
	ALIGNins(b, "BATins", force);
	BATcompatible(b, n);

	countonly = (b->htype == TYPE_void && b->ttype == TYPE_void);

	if (BUNlast(b) + BATcount(n) > BUN_MAX) {
		GDKerror("BATins: combined BATs too large\n");
		return NULL;
	}

	if (b->htype != TYPE_void && (b->ttype == TYPE_void || (!b->H->hash && b->T->hash && ATOMstorage(b->ttype) == TYPE_int))) {	/* OIDDEPEND */
		return BATmirror(BATins(BATmirror(b), BATmirror(n), force));
	}

	if (BUNlast(b) + BATcount(n) > BATcapacity(b)) {
		/* if needed space exceeds a normal growth extend just
		 * with what's needed */
		BUN ncap = BUNlast(b) + BATcount(n);
		BUN grows = BATgrows(b);

		if (ncap > grows)
			grows = ncap;
		if (BATextend(b, grows) == NULL)
			goto bunins_failed;
	}

	if (b->htype == TYPE_void && b->hseqbase != oid_nil) {
		BATiter ni = bat_iterator(n);
		BUN t = (BUN) b->hseqbase + BATcount(b) - 1;
		oid h = *(oid *) BUNhead(ni, BUNfirst(n));

		if (BATcount(b) == 0 && (BATcount(n) == 1 || BAThdense(n))) {
			b->hseqbase = h;
			BATmirror(b)->tseqbase = h;
		} else if (t + 1 != (BUN) h || !BAThdense(n)) {
			b = BATmaterializeh(b);
			countonly = 0;
			if (b == NULL)
				return NULL;
		}
	}
	if (b->ttype == TYPE_void && b->tseqbase != oid_nil) {
		BATiter ni = bat_iterator(n);
		BUN t = (BUN) b->tseqbase + BATcount(b) - 1;
		oid h = *(oid *) BUNtail(ni, BUNfirst(n));

		if (BATcount(b) == 0 && (BATcount(n) == 1 || BATtdense(n))) {
			b->tseqbase = h;
			BATmirror(b)->hseqbase = h;
		} else if (t + 1 != (BUN) h || !BATtdense(n)) {
			b = BATmaterializet(b);
			countonly = 0;
			if (b == NULL)
				return NULL;
		}
	}
	if (b->T->hash == NULL && b->batSet == 0 &&
	    (b->tkey & BOUND2BTRUE) == 0 &&
	    ((b->hkey & BOUND2BTRUE) == 0 || n->hkey) &&
	    (b->H->hash == NULL || ATOMstorage(b->htype) == ATOMstorage(TYPE_oid))) {
		if ((b->hkey & BOUND2BTRUE)) {
			tmp = n = BATkdiff(n, b);
			if (n == NULL)
				return NULL;
		}
		fastpath = 1;
	}

	if (b->H->hash == NULL && b->hkey & BOUND2BTRUE) {
		if (BATcount(b) || (BATcount(n) && n->htype != TYPE_void && !n->hdense))
			BAThash(b, BATcount(b) + BATcount(n));
	}
	if (b->T->hash == NULL && b->tkey & BOUND2BTRUE) {
		if (BATcount(b) || (BATcount(n) && n->ttype != TYPE_void && !n->tdense))
			BAThash(BATmirror(b), BATcount(b) + BATcount(n));
	}
	BATaccessBegin(b, USE_HHASH | USE_THASH, MMAP_WILLNEED);
	BATaccessBegin(n, USE_HEAD | USE_TAIL, MMAP_SEQUENTIAL);
	b->batDirty = 1;
	if (fastpath) {
		BUN p, q, r = BUNlast(b);

		if (BATcount(b) == 0) {
			ALIGNset(b, n);
		} else if (BATcount(n)) {
			BUN last = BUNlast(b) - 1;
			BATiter ni = bat_iterator(n);
			BATiter bi = bat_iterator(b);
			int xx = ATOMcmp(b->htype, BUNhead(ni, BUNfirst(n)), BUNhead(bi, last));
			if ((BAThordered(b) & 1) && ((BAThordered(n) & 1) == 0 || xx < 0)) {
				b->hsorted = FALSE;
				b->H->nosorted = r;
				if (b->hdense & 1) {
					b->hdense = FALSE;
					b->H->nodense = r;
				}
			}
			if ((BAThordered(b) == (bit) GDK_SORTED_REV) && ((BAThordered(n) != (bit) GDK_SORTED_REV) || xx > 0)) {
				b->hsorted = FALSE;
				b->H->nosorted_rev = r;
			}
			if (b->hkey && (b->hkey & BOUND2BTRUE) == 0 && ((BAThordered(b) & 1) == 0 || n->hkey == 0 || xx == 0)) {	/* StM: GDK_SORTED_REV ? */
				BATkey(b, FALSE);
			}
			if (b->htype != TYPE_void && (b->hsorted & b->hdense & 1) && (BAThdense(n) == 0 || *(oid *) BUNhloc(bi, last) != 1 + *(oid *) BUNhead(ni, BUNfirst(n)))) {
				b->hdense = FALSE;
				b->H->nodense = r;
			}

			xx = ATOMcmp(b->ttype, BUNtail(ni, BUNfirst(n)), BUNtail(bi, last));
			if ((BATtordered(b) & 1) && ((BATtordered(n) & 1) == 0 || xx < 0)) {
				b->tsorted = FALSE;
				b->T->nosorted = r;
				if (b->tdense & 1) {
					b->tdense = FALSE;
					b->T->nodense = r;
				}
			}
			if ((BATtordered(b) == (bit) GDK_SORTED_REV) && ((BATtordered(n) != (bit) GDK_SORTED_REV) || xx > 0)) {
				b->tsorted = FALSE;
				b->T->nosorted_rev = r;
			}
			if ((BATtordered(b) & 1) == 0 || n->tkey == 0 || xx == 0) {	/* StM: GDK_SORTED_REV ? */
				if (b->tkey)
					BATkey(BATmirror(b), FALSE);
			}
			if (b->ttype != TYPE_void && (b->tsorted & b->tdense & 1) && (BATtdense(n) == 0 || *(oid *) BUNtloc(bi, last) != 1 + *(oid *) BUNtail(ni, BUNfirst(n)))) {
				b->tdense = FALSE;
				b->T->nodense = r;
			}
		}
		if (countonly) {
			BATsetcount(b, b->batCount + n->batCount);
		} else if ((b->htype == TYPE_str &&
			    (b->batCount == 0 || !GDK_ELIMDOUBLES(b->H->vheap)) &&
			    !GDK_ELIMDOUBLES(n->H->vheap) &&
			    b->H->vheap->hashash == n->H->vheap->hashash &&
			    VIEWhparent(n) == 0) ||
			   (b->ttype == TYPE_str &&
			    (b->batCount == 0 || !GDK_ELIMDOUBLES(b->T->vheap)) &&
			    !GDK_ELIMDOUBLES(n->T->vheap) &&
			    b->T->vheap->hashash == n->T->vheap->hashash &&
			    VIEWtparent(n) == 0)) {
			b = insert_string_bat(b, n, 0);
		} else if (b->htype == TYPE_void) {
			BATiter ni = bat_iterator(n);
			BATloop(n, p, q) {
				bunfastins_nocheck(b, r, NULL, BUNtail(ni, p), 0, Tsize(b));
				r++;
			}
		} else if (b->H->hash) {
			BUN i = BUNlast(b);
			BATiter ni = bat_iterator(n);

			BATloop(n, p, q) {
				ptr v = BUNhead(ni, p);

				bunfastins_nocheck(b, r, v, BUNtail(ni, p), Hsize(b), Tsize(b));
				HASHins_oid(b->H->hash, i, v);
				r++;
				i++;
			}
		} else {
			BATiter ni = bat_iterator(n);

			BATloop(n, p, q) {
				bunfastins_nocheck(b, r, BUNhead(ni, p), BUNtail(ni, p), Hsize(b), Tsize(b));
				r++;
			}
		}
		b->H->nonil &= n->H->nonil;
		b->T->nonil &= n->T->nonil;
	} else {
		@:updateloop(b,n,bunins)@
	}
	res = b;
      bunins_failed:
	BATaccessEnd(b, USE_HHASH | USE_THASH, MMAP_WILLNEED);
	BATaccessEnd(n, USE_HEAD | USE_TAIL, MMAP_SEQUENTIAL);
	if (tmp)
		BBPreclaim(tmp);
	return res;
}

BAT *
BATappend(BAT *b, BAT *n, bit force)
{
	BUN sz = BATcount(n);
	int fastpath = 1;

	if (b == NULL || n == NULL || sz == 0) {
		return b;
	}
	ALIGNapp(b, "BATappend", force);
	BATcompatible(b, n);

	if (BUNlast(b) + BATcount(n) > BUN_MAX) {
		GDKerror("BATappend: combined BATs too large\n");
		return NULL;
	}

	b->batDirty = 1;
	BATaccessBegin(b, USE_HHASH | USE_THASH, MMAP_WILLNEED);
	BATaccessBegin(n, USE_HEAD | USE_TAIL, MMAP_SEQUENTIAL);

	if (sz > BATcapacity(b) - BUNlast(b)) {
		/* if needed space exceeds a normal growth extend just
		 * with what's needed */
		BUN ncap = BUNlast(b) + sz;
		BUN grows = BATgrows(b);

		if (ncap > grows)
			grows = ncap;
		if (BATextend(b, grows) == NULL)
			goto bunins_failed;
	}

	/* append two void,void bats */
	if (b->ttype == TYPE_void && BATtdense(b)) {
		oid f = n->tseqbase;

		if (n->ttype != TYPE_void)
			f = *(oid *) BUNtloc(bat_iterator(n), BUNfirst(n));

		if (BATcount(b) == 0 && f != oid_nil)
			BATseqbase(BATmirror(b), f);
		if (BATtdense(n) && BATcount(b) + b->tseqbase == f) {
			if (b->htype != TYPE_void) {
				BUN r = BUNlast(b);
				oid m;

				f = MAXoid(b);
				f++;
				if (f + sz >= GDK_oid_max) {
					GDKerror("BATappend: overflow of head value\n");
					return 0;
				}
				m = (oid) (f + sz);
				for (; f < m; f++, r++) {
					bunfastins_nocheck(b, r, (ptr) &f, NULL, Hsize(b), 0);
				}
			} else {
				sz += BATcount(b);
				BATsetcount(b, sz);
			}
			return b;
		}
		/* we need to materialize the tail */
		b = BATmaterializet(b);
		if (b == NULL)
			return NULL;
	}

	/* a hash is useless for void bats */
	if (b->H->hash)
		HASHremove(b);

	if (b->T->hash && (2 * b->T->hash->mask) < (BATcount(b) + sz)) {
		HASHremove(BATmirror(b));
	}
	if (b->T->hash != NULL ||
	    b->batSet ||
	    (b->tkey & BOUND2BTRUE) != 0 ||
	    (b->H->hash != NULL && ATOMstorage(b->htype) != ATOMstorage(TYPE_oid)))
		fastpath = 0;

	if (fastpath) {
		BUN p, q, r = BUNlast(b);

		if (BATcount(b) == 0) {
			BATiter ni = bat_iterator(n);

			ALIGNsetH(BATmirror(b), BATmirror(n));
			b->tseqbase = n->tseqbase;

			if (n->tdense && n->ttype == TYPE_oid) {
				b->tseqbase = *(oid *) BUNtail(ni, BUNfirst(n));
			}
			b->tdense = n->tdense;
			b->T->nodense = n->T->nodense;
			b->tkey |= (n->tkey & TRUE);
			b->T->nokey[0] = n->T->nokey[0];
			b->T->nokey[1] = n->T->nokey[1];
			b->T->nonil = n->T->nonil;
		} else {
			BUN last = BUNlast(b) - 1;
			BATiter ni = bat_iterator(n);
			BATiter bi = bat_iterator(b);
			int xx = ATOMcmp(b->ttype, BUNtail(ni, BUNfirst(n)), BUNtail(bi, last));
			if ((BATtordered(b) & 1) && ((BATtordered(n) & 1) == 0 || xx < 0)) {
				b->tsorted = FALSE;
				b->T->nosorted = last;
				if (b->tdense & 1) {
					b->tdense = FALSE;
					b->T->nodense = last;
				}
			}
			if ((BATtordered(b) == (bit) GDK_SORTED_REV) && ((BATtordered(n) != (bit) GDK_SORTED_REV) || xx > 0)) {
				b->tsorted = FALSE;
				b->T->nosorted_rev = last;
			}
			if ((BATtordered(b) & 1) == 0 || n->tkey == 0 || xx == 0) {	/* StM: GDK_SORTED_REV ? */
				if (b->tkey)
					BATkey(BATmirror(b), FALSE);
			}
			if (b->ttype != TYPE_void && (b->tsorted & b->tdense & 1) && (BATtdense(n) == 0 || *(oid *) BUNtloc(bi, last) != 1 + *(oid *) BUNtail(ni, BUNfirst(n)))) {
				b->tdense = FALSE;
				b->T->nodense = last;
			}
		}
		if (b->ttype == TYPE_str &&
		    (b->batCount == 0 || !GDK_ELIMDOUBLES(b->T->vheap)) &&
		    !GDK_ELIMDOUBLES(n->T->vheap) &&
		    b->T->vheap->hashash == n->T->vheap->hashash &&
		    VIEWtparent(n) == 0) {
			b = insert_string_bat(b, n, 1);
			if (b == NULL)
				return NULL;
		} else if (b->htype == TYPE_void) {
			BATiter ni = bat_iterator(n);

			BATloop(n, p, q) {
				bunfastins_nocheck(b, r, NULL, BUNtail(ni, p), 0, Tsize(b));
				r++;
			}
		} else {
			oid o = MAXoid(b);
			BATiter ni = bat_iterator(n);

			o++;
			BATloop(n, p, q) {
				bunfastins_nocheck(b, r, &o, BUNtail(ni, p), Hsize(b), Tsize(b));
				o++;
				r++;
			}
		}
	} else {
		BUN p, q;
		BUN i = BUNlast(b);
		BAT *bm = BBP_cache(-b->batCacheid);
		BATiter ni = bat_iterator(n);

		if (b->tkey & BOUND2BTRUE) {

			b->tdense = b->tsorted = 0;
			if (b->hseqbase != oid_nil) {
				oid h = b->hseqbase + i;

				BATloop(n, p, q) {
					ptr t = BUNtail(ni, p);
					if (BUNfnd(bm, t) == BUN_NONE) {
						bunfastins(b, &h, t);
						if (b->T->hash) {
							HASHins(bm, i, t);
						}
						h++;
						i++;
					}
				}
			} else {
				oid on = oid_nil;

				BATloop(n, p, q) {
					ptr t = BUNtail(ni, p);
					if (BUNfnd(bm, t) == BUN_NONE) {
						bunfastins(b, &on, t);
						if (b->T->hash) {
							HASHins(bm, i, t);
						}
						i++;
					}
				}
				BATkey(b, FALSE);
				b->hdense = b->hsorted = 0;
			}
		} else if (b->hseqbase != oid_nil) {
			oid h;

			if (b->hseqbase + BATcount(b) + BATcount(n) >= GDK_oid_max) {
				GDKerror("BATappend: overflow of head value\n");
				return NULL;
			}
			h = (oid) (b->hseqbase + BATcount(b));

			BATloop(n, p, q) {
				ptr t = BUNtail(ni, p);

				bunfastins(b, &h, t);
				if (b->T->hash) {
					HASHins(bm, i, t);
				}
				i++;
				h++;
			}
			BATkey(BATmirror(b), FALSE);
			b->tdense = b->tsorted = 0;
		} else {
			oid on = oid_nil;

			BATloop(n, p, q) {
				ptr t = BUNtail(ni, p);

				bunfastins(b, &on, t);
				if (b->T->hash) {
					HASHins(bm, i, t);
				}
				i++;
			}
			BATkey(b, FALSE);
			BATkey(BATmirror(b), FALSE);
			b->hdense = b->hsorted = 0;
			b->tdense = b->tsorted = 0;
		}
	}
	b->H->nonil &= n->H->nonil;
	b->T->nonil &= n->T->nonil;
	BATaccessEnd(b, USE_HHASH | USE_THASH, MMAP_WILLNEED);
	BATaccessEnd(n, USE_HEAD | USE_TAIL, MMAP_SEQUENTIAL);
	return b;
      bunins_failed:
	BATaccessEnd(b, USE_HHASH | USE_THASH, MMAP_WILLNEED);
	BATaccessEnd(n, USE_HEAD | USE_TAIL, MMAP_SEQUENTIAL);
	return NULL;
}


#define bundel(b,h,t) do { if (BUNdel(b,h,t,force) == NULL) { GDKerror("BATdel: BUN does not occur.\n"); return NULL; } } while (0)
BAT *
BATdel(BAT *b, BAT *n, bit force)
{
	ERRORcheck(b == NULL, "set:BAT required\n");
	ERRORcheck(n == NULL, "set:BAT required\n");
	if (BATcount(n) == 0) {
		return b;
	}
	ALIGNdel(b, "BATdel", force);
	TYPEcheck(b->htype, n->htype);
	TYPEcheck(b->ttype, n->ttype);
	@:updateloop(b,n,bundel)@
	return b;
}

#define bundelhead(b,h,t) do { if (BUNdelHead(b,h,force) == NULL) return NULL; } while (0)
BAT *
BATdelHead(BAT *b, BAT *n, bit force)
{
	ERRORcheck(b == NULL, "set:BAT required\n");
	ERRORcheck(n == NULL, "set:BAT required\n");
	if (BATcount(n) == 0) {
		return b;
	}
	ALIGNdel(b, "BATdelHead", force);
	TYPEcheck(b->htype, n->htype);
	@:updateloop(b,n,bundelhead)@
	return b;
}

@-
The last in this series is a BATreplace, which replaces all the
buns mentioned.
@c
#define BUNreplace_force(a,b,c) BUNreplace(a,b,c,force)
BAT *
BATreplace(BAT *b, BAT *n, bit force)
{
	if (b == NULL || n == NULL || BATcount(n) == 0) {
		return b;
	}
	BATcompatible(b, n);
	@:updateloop(b,n,BUNreplace_force)@

	return b;
}

@}

@+ BAT Selections
The BAT selectors are among the most heavily used operators.
Their efficient implementation is therefore mandatory.

The interface supports seven operations: @%BATslice@, @%BATselect@,
@%BATfragment@, @%BATsample@, @%BATproject@, @%BATrestrict@.

@- BAT slice
This function returns a horizontal slice from a BAT. It optimizes
execution by avoiding to copy when the BAT is memory mapped (in this
case, an independent submap is created) or else when it is read-only,
then a VIEW bat is created as a result.

If a new copy has to be created, this function takes care to preserve
void-columns (in this case, the seqbase has to be recomputed in the result).

Note that the BATslice() is used indirectly as well as a special
case for BATselect (range selection on sorted column), BATrangesplit
(fragmentation on sorted column) and BATsemijoin (when two dense columns
are semijoined).

NOTE new semantics, the selected range is excluding the high value.
@{
@c
BAT *
BATslice(BAT *b, BUN l, BUN h)
{
	BUN low = l;
	BAT *bn;
	BATiter bni, bi = bat_iterator(b);

	BATcheck(b, "BATslice");
	if (h > BATcount(b))
		h = BATcount(b);
	if (h < l)
		h = l;
	l += BUNfirst(b);
	h += BUNfirst(b);

	if (l > BUN_MAX || h > BUN_MAX) {
		GDKerror("BATslice: boundary out of range\n");
		return NULL;
	}

@-
If the source BAT is readonly, then we can obtain a VIEW
that just reuses the memory of the source.
@c
	if (BAThrestricted(b) == BAT_READ && BATtrestricted(b) == BAT_READ) {
		BUN cnt = h - l;
		bn = VIEWcreate_(b, b, TRUE);
		bn->batFirst = bn->batDeleted = bn->batInserted = 0;
		bn->H->heap.base = (bn->htype) ? BUNhloc(bi, l) : NULL;
		bn->T->heap.base = (bn->ttype) ? BUNtloc(bi, l) : NULL;
		bn->H->heap.maxsize = bn->H->heap.size = headsize(bn, cnt);
		bn->T->heap.maxsize = bn->T->heap.size = tailsize(bn, cnt);
		BATsetcount(bn, cnt);
		BATsetcapacity(bn, cnt);
@-
We have to do it: create a new BAT and put everything into it.
@c
	} else {
		BUN p = (BUN) l;
		BUN q = (BUN) h;

		bn = BATnew(b->htype, b->ttype, h - l);
		if (bn == NULL) {
			return bn;
		}
		if (b->htype != b->ttype || b->htype != TYPE_void) {
			for (; p < q; p++) {
				bunfastins(bn, BUNhead(bi, p), BUNtail(bi, p));
			}
		} else {
			BATsetcount(bn, h - l);
		}
	}
	bni = bat_iterator(bn);
	bn->hsorted = BAThordered(b);
	bn->tsorted = BATtordered(b);
	BATkey(bn, BAThkey(b));
	BATkey(BATmirror(bn), BATtkey(b));
	bn->H->nonil = b->H->nonil;
	bn->T->nonil = b->T->nonil;
	if (BAThdense(b)) {
		bn->hdense = TRUE;
		BATseqbase(bn, (oid) (b->hseqbase + low));
	} else if (bn->hkey && bn->htype == TYPE_oid) {
		if (BATcount(bn) == 0) {
			bn->hdense = TRUE;
			BATseqbase(bn, 0);
		} else if ((bn->hsorted & 1) && *(oid *) BUNhloc(bni, BUNfirst(bn)) + BATcount(bn) - 1 == *(oid *) BUNhloc(bni, BUNlast(bn) - 1)) {
			bn->hdense = TRUE;
			BATseqbase(bn, *(oid *) BUNhloc(bni, BUNfirst(bn)));
		}
	}
	if (BATtdense(b)) {
		bn->tdense = TRUE;
		BATseqbase(BATmirror(bn), (oid) (b->tseqbase + low));
	} else if (bn->tkey && bn->ttype == TYPE_oid) {
		if (BATcount(bn) == 0) {
			bn->tdense = TRUE;
			BATseqbase(BATmirror(bn), 0);
		} else if ((bn->tsorted & 1) && *(oid *) BUNtloc(bni, BUNfirst(bn)) + BATcount(bn) - 1 == *(oid *) BUNtloc(bni, BUNlast(bn) - 1)) {
			bn->tdense = TRUE;
			BATseqbase(BATmirror(bn), *(oid *) BUNtloc(bni, BUNfirst(bn)));
		}
	}
	return bn;
      bunins_failed:
	BBPreclaim(bn);
	return NULL;
}

BAT *
BATslice2(BAT *b, BUN l1, BUN h1, BUN l2, BUN h2)
{
	BUN p, q;
	BAT *bn;
	BATiter bi = bat_iterator(b);
	int tt = b->ttype;

	BATcheck(b, "BATslice");
	if (h2 > BATcount(b))
		h2 = BATcount(b);
	if (h1 < l1)
		h1 = l1;
	if (h2 < l2)
		h2 = l2;
	l1 += BUNfirst(b);
	l2 += BUNfirst(b);
	h1 += BUNfirst(b);
	h2 += BUNfirst(b);

	if (l1 > BUN_MAX || l2 > BUN_MAX || h1 > BUN_MAX || h2 > BUN_MAX) {
		GDKerror("BATslice2: boundary out of range\n");
		return NULL;
	}

	if (tt == TYPE_void && b->T->seq != oid_nil)
		tt = TYPE_oid;
	bn = BATnew(ATOMtype(b->htype), tt, h1 - l1 + h2 - l2);
	if (bn == NULL)
		return bn;
	for (p = (BUN) l1, q = (BUN) h1; p < q; p++) {
		bunfastins(bn, BUNhead(bi, p), BUNtail(bi, p));
	}
	for (p = (BUN) l2, q = (BUN) h2; p < q; p++) {
		bunfastins(bn, BUNhead(bi, p), BUNtail(bi, p));
	}
	bn->hsorted = BAThordered(b);
	bn->tsorted = BATtordered(b);
	BATkey(bn, BAThkey(b));
	BATkey(BATmirror(bn), BATtkey(b));
	bn->H->nonil = b->H->nonil;
	bn->T->nonil = b->T->nonil;
	if (bn->hkey && bn->htype == TYPE_oid) {
		if (BATcount(bn) == 0) {
			bn->hdense = TRUE;
			BATseqbase(bn, 0);
		}
	}
	if (bn->tkey && bn->ttype == TYPE_oid) {
		if (BATcount(bn) == 0) {
			bn->tdense = TRUE;
			BATseqbase(BATmirror(bn), 0);
		}
	}
	return bn;
      bunins_failed:
	BBPreclaim(bn);
	return NULL;
}


@-  Value Selections
The string search is optimized for the degenerated case
that th = tl, and double elimination in the string heap.

We allow value selections on the nil atom. This is formally
not correct, as in MIL (nil = nil) != true.  However, we do
need an implementation for selecting nil (in MIL, this is done
through is the "isnil" predicate). So we implement it here.

@= valselect
	HASHloop@2(bi, b->H->hash, i, tl) {
		if (q < r)
			bunfastins_nocheck(bn, q, BUNt@1(bi, i), tl, Hsize(bn), Tsize(bn));
		q++;
	}
@= stringselect
	if (strElimDoubles(b->H->vheap)) {
		BUN p;
		size_t j;

		HASHloop_fstr(bi, b->H->hash, p, j, tl) {
			if (q < r)
				bunfastins_nocheck(bn, q, BUNt@1(bi, p), tl, Hsize(bn), Tsize(bn));
			q++;
		}
	} else {
		BUN p;

		HASHloop_str(bi, b->H->hash, p, tl) {
			if (q < r)
				bunfastins_nocheck(bn, q, BUNt@1(bi, p), tl, Hsize(bn), Tsize(bn));
			q++;
		}
	}
@= hashselect
	switch(ATOMstorage(b->htype)) {
#ifndef NOEXPAND_CHR
	case TYPE_chr:
		@:valselect(@1,_chr)@
		break;
#endif
#ifndef NOEXPAND_BTE
	case TYPE_bte:
		@:valselect(@1,_bte)@
		break;
#endif
#ifndef NOEXPAND_SHT
	case TYPE_sht:
		@:valselect(@1,_sht)@
		break;
#endif
#ifndef NOEXPAND_INT
	case TYPE_int:
		@:valselect(@1,_int)@
		break;
#endif
#ifndef NOEXPAND_FLT
	case TYPE_flt:
		@:valselect(@1,_flt)@
		break;
#endif
#ifndef NOEXPAND_DBL
	case TYPE_dbl:
		@:valselect(@1,_dbl)@
		break;
#endif
#ifndef NOEXPAND_LNG
	case TYPE_lng:
		@:valselect(@1,_lng)@
		break;
#endif
#ifndef NOEXPAND_STR
	case TYPE_str:
		@:stringselect(@1)@
		break;
#endif
	default:
		if (b->hvarsized) {
			@:valselect(@1,var)@
		} else {
			@:valselect(@1,loc)@
		}
		break;
	}
@c
static BAT *
BAT_hashselect(BAT *b, BAT *bn, ptr tl)
{
	int ht = bn->htype, tt = bn->ttype;
	BUN size = BATcount(bn);
	BUN i;

	BATcheck(b, "BAT_hashselect");
	b = BATmirror(b);
	if (BATprepareHash(b)) {
	      bunins_failed:
		BBPreclaim(bn);
		return NULL;
	}
	while (bn) {
		BUN q = BUNfirst(bn);
		BUN r;
		BATiter bi = bat_iterator(b);

		assert(BATcapacity(bn) <= BUN_MAX);
		r = (BUN) BATcapacity(bn);

		if (b->tvarsized) {
			@:hashselect(var)@
		} else {
			@:hashselect(loc)@
		}
		if (q <= r)
			break;
		size = (q - BUNfirst(bn));

		BBPreclaim(bn);
		bn = BATnew(ht, tt, size);
	}
	return bn;
}

@}
@- Range Selections
The routine @%BATselect@ locates the BAT subset whose tail component
satisfies the range condition T l <[=] tail <[=] h. Either boundary
is included in the result iff the respective bit parameter "li"/"hi"
is TRUE. A nil value in either dimension defines infinity.  The value
is set accordingly.

Range selections without lower or upper bound use the nil atom
to indicate this (this is somewhat confusing). Note, however, that
through the definition of MIL we do not want the nils to appear in
the result (as (nil @{<,=,>@} ANY) = bit(nil) != true).
@{
@c
BAT *
BAT_select_(BAT *b, ptr tl, ptr th, bit li, bit hi, bit tail, bit anti, bit preserve_order)
{
	int hval, lval, equi, nequi = anti, t, ht, tt, lnil = 0;
	BUN offset, batcnt, estimate = 0;
	ptr nil;
	BAT *bn;
	BUN p, q;

	BATcheck(b, "BATselect");
	BATcheck(tl, "BATselect: tl value required");
@-
Examine type, and values for lower- and higher-bound.
@c
	batcnt = BATcount(b);
	/* preliminarily determine result types */
	ht = BAThtype(b);
	tt = tail ? BATttype(b) : TYPE_void;

	t = b->ttype;
	nil = ATOMnilptr(t);
	lnil = ATOMcmp(t, tl, nil) == 0;
	lval = !lnil || (th == NULL);
	equi = ((th == NULL) || (lval && !ATOMcmp(t, tl, th)));
	if (equi) {
		if (th == NULL)
			hi = li;
		th = tl;
		hval = 1;	/* equi-select */
	} else {
		hval = ATOMcmp(t, th, nil) != 0;
	}
	if (nequi) {
		if (!lval != !hval) {
			/* one of the end points is nil and the other
			 * isn't: swap sub-ranges */
			ptr tv;
			bit ti;
			ti = li;
			li = hi;
			hi = ti;
			tv = tl;
			tl = th;
			th = tv;
			nequi = 0;
			equi = 0;
		} else if (!lval && !hval) {
			/* antiselect for nil-nil range: all non-nil
			 * values are in range, so we need to return
			 * all but, but we also don't want to return
			 * nils, so instead we return nothing. */
			return BATnew(ht, tt, 10);
		} else if (equi && lnil) {
			/* antiselect for nil value: turn into range
			 * select for nil-nil range (i.e. everything
			 * but nil) */
			equi = 0;
			nequi = 0;
			lval = 0;
			hval = 0;
		} else
			equi = 0;
	}

	if (hval && ((ATOMcmp(t, tl, th) > 0) || (equi && !(li && hi)))) {
		/* empty range */
		ALGODEBUG THRprintf(GDKout, "#BAT_select_(b=%s): empty range;\n", BATgetId(b));

		return BATnew(ht, tt, 10);
	}
	if (!equi && !lval && !hval && b->T->nonil && lnil)
		return BATcopy(b, ht, tt, FALSE);
	if (equi && lval && hval && b->T->nonil && lnil)
		return BATnew(ht, tt, 10);

@}
@- Slice Implementations
When the result is a dense slice of the BAT, we can optimize.
A slice does not need to copy the BAT selected on, it can just
give back a 'view' on the memory of the existing BAT. See BATslice().
@{
@c
	if (BATtordered(b) & 1) {
		BAT *v = tail ? b : VIEWhead_(b, b->batRestricted);
		BUN high = batcnt;
		BUN low = 0;

		if (BATtdense(b)) {
			/* Selections on voids are positional. */
			if (hval) {
				BUN h = (*(oid *) th) + (hi ? 1 : 0);

				if (h > b->tseqbase)
					h -= b->tseqbase;
				else
					h = 0;
				if (h < high)
					high = h;

			}
			if (lval) {
				if (*(oid *) tl != oid_nil) {
					BUN l = (*(oid *) tl) + (li ? 0 : 1);

					if (l > b->tseqbase)
						l -= b->tseqbase;
					else
						l = 0;
					if (l > low)
						low = l;
				} else {
					if (equi) {
						/* nil-equi select on dense columns is empty */
						high = low;
					}
				}
			}
		} else {
			/* Use probe-based binary search */
			offset = BUNfirst(b);
			if (lval) {
				if (li)
					p = SORTfndfirst(b, tl);
				else
					p = SORTfndlast(b, tl);
			} else {
				/* No lower bound, we must still exclude nils. They are in
				 * front, so we can still slice, by starting after them.
				 */
				p = SORTfndlast(b, nil);
			}
			low = p;
			if (low > offset)
				low -= offset;
			else
				low = 0;
			if (hval) {
				if (hi)
					q = SORTfndlast(b, th);
				else
					q = SORTfndfirst(b, th);
				high = q;
				if (high > offset)
					high -= offset;
				else
					high = 0;
			}
		}
		ALGODEBUG THRprintf(GDKout, "#BAT_select_(b=%s): BATslice(v=%s, low=" BUNFMT ", high=" BUNFMT ");\n", BATgetId(b), BATgetId(v), low, high);

		if (nequi) {
			BUN first = SORTfndlast(b, nil);
			bn = BATslice2(v, first, low, high, BUNlast(b));
		} else {
			bn = BATslice(v, low, high);
		}
		if (!tail) {
			BBPreclaim(v);
		}
		/* selected no nils */
		if (bn != NULL) {
			bn->H->nonil = b->H->nonil;
			bn->T->nonil = b->T->nonil & tail;
			if (!equi && !lval && !hval && lnil)
				bn->T->nonil = tail;
			else if (equi && !lnil)
				bn->T->nonil = tail;
		}
		return bn;
	}
@-
Use sampling to determine a good result size, when the bat is large.
@c
	if (BATtkey(b)) {
		estimate = 1;
	} else if (batcnt > 100000) {
		BUN _lo = batcnt / 2, _hi = _lo + 105;
		BAT *tmp1;
		ALGODEBUG THRprintf(GDKout, "#BAT_select_(b=%s): sampling: tmp1 = BATslice(b=%s, _lo=" BUNFMT ", _hi=" BUNFMT ");\n", BATgetId(b), BATgetId(b), _lo, _hi);

		tmp1 = BATslice(b, _lo, _hi);	/* slice keeps all parent properties */
		if (tmp1) {
			BAT *tmp2;
			ALGODEBUG THRprintf(GDKout, "#BAT_select_(b=%s): sampling: tmp2 = BAT_select_(tmp1=%s, tl, th, tail);\n", BATgetId(b), BATgetId(tmp1));

			tmp2 = BAT_select_(tmp1, tl, th, li, hi, tail, FALSE, FALSE);
			if (tmp2) {
				/* reserve 105% of what has been estimated */
				estimate = (BUN) ((((lng) BATcount(tmp2)) * (lng) batcnt) / LL_CONSTANT(100));
				BBPreclaim(tmp2);
			}
			BBPreclaim(tmp1);
		}
	} else {
		estimate = MAX(estimate, BATguess(b));
	}
@-
Create the result BAT and execute the select algorithm.
@c
	if (ht == TYPE_void && tt == TYPE_void) {
		ht = TYPE_oid;
	}
	bn = BATnew(ht, tt, estimate);
	if (bn) {
		int nocheck = (estimate >= batcnt);

		if (!preserve_order && equi && b->T->hash) {
			ALGODEBUG THRprintf(GDKout, "#BAT_select_(b=%s): BAT_hashselect(b=%s, bn=%s, tl); (using existing hash-table)\n", BATgetId(b), BATgetId(b), BATgetId(bn));

			bn = BAT_hashselect(b, bn, tl);
		} else if (!preserve_order
				&& equi
				&& b->batPersistence == PERSISTENT
				&& (size_t) ATOMsize(b->ttype) > sizeof(BUN) / 4
				&& estimate < batcnt / 100
				&& batcnt * (ATOMsize(b->ttype) + 2 * sizeof(BUN)) < (GDK_mem_maxsize / 2) /* MT_npages() * MT_pagesize() / (GDKnr_threads ? GDKnr_threads : 1) */ ) {
			/* Build a hash-table on the fly for equi-select on persistent BAT
			 * if tail-type is large (wide) and selectivity is low and BAT + hash-table fit in memory */
			ALGODEBUG THRprintf(GDKout, "#BAT_select_(b=%s): BAT_hashselect(b=%s, bn=%s, tl); (building hash-table on the fly)\n", BATgetId(b), BATgetId(b), BATgetId(bn));

			bn = BAT_hashselect(b, bn, tl);
		} else {
			ALGODEBUG THRprintf(GDKout, "#BAT_select_(b=%s): BAT_scanselect(b=%s, bn=%s, tl, th, equi=%d, nequi=%d, lval=%d, hval=%d, nocheck=%d);\n", BATgetId(b), BATgetId(b), BATgetId(bn), equi, nequi, lval, hval, nocheck);

			bn = BAT_scanselect(b, bn, tl, th, li, hi, equi, nequi, lval, hval, nocheck);
		}
	}
	if (bn == NULL) {
		return NULL;	/* error occurred */
	}
@-
Propagate alignment info. Key properties are inherited from the parent.
Hash changes the order; IDX yields ordered tail; scan respects original order.
@c
	if (BATcount(bn)) {
		BATkey(bn, BAThkey(b));
		BATkey(BATmirror(bn), BATtkey(b));
	} else {
		BATkey(bn, TRUE);
		BATkey(BATmirror(bn), TRUE);
	}
	if (equi && tail) {
		BATsetprop_wrd(bn, GDK_AGGR_CARD, (wrd) (BATcount(bn) > 0));
		if (b->ttype == TYPE_bit) {
			BATsetprop_wrd(bn, GDK_AGGR_SIZE, (*(bit *) tl == TRUE) ? (wrd) BATcount(bn) : 0);
		}
	}
	if (equi && b->T->hash) {
		bn->hsorted = bn->tsorted = FALSE;
	} else {
		if (BATcount(bn) == BATcount(b))
			ALIGNset(bn, b);
		bn->hsorted = BAThordered(b);
		bn->tsorted = BATtordered(b);
	}
	/* selected no nils */
	bn->H->nonil = b->H->nonil;
	bn->T->nonil = b->T->nonil & tail;
	if (!equi && !lval && !hval && lnil)
		bn->T->nonil = tail;
	else if (equi && !lnil)
		bn->T->nonil = tail;
	ALGODEBUG THRprintf(GDKout, "#BAT_select_(b=%s): %s: hkey=%d, tkey=%d, hsorted=%d, tsorted=%d.\n", BATgetId(b), BATgetId(bn), bn->hkey, bn->tkey, bn->hsorted, bn->tsorted);
	ESTIDEBUG THRprintf(GDKout, "#BAT_select_(b=%s): resultsize: estimated " BUNFMT ", got " BUNFMT ".\n", BATgetId(b), estimate, BATcount(bn));

	return bn;
}

BAT *
BAT_select(BAT *b, ptr h, ptr t, bit tail)
{
	return BAT_select_(b, h, t, TRUE, TRUE, tail, FALSE, FALSE);
}

BAT *
BATselect_(BAT *b, ptr h, ptr t, bit li, bit hi)
{
	return BAT_select_(b, h, t, li, hi, TRUE, FALSE, FALSE);
}

BAT *
BATuselect_(BAT *b, ptr h, ptr t, bit li, bit hi)
{
	return BAT_select_(b, h, t, li, hi, FALSE, FALSE, FALSE);
}

BAT *
BATantiuselect_(BAT *b, ptr h, ptr t, bit li, bit hi)
{
	return BAT_select_(b, h, t, li, hi, FALSE, TRUE, FALSE);
}

BAT *
BATselect(BAT *b, ptr h, ptr t)
{
	return BAT_select_(b, h, t, TRUE, TRUE, TRUE, FALSE, FALSE);
}

BAT *
BATuselect(BAT *b, ptr h, ptr t)
{
	return BAT_select_(b, h, t, TRUE, TRUE, FALSE, FALSE, FALSE);
}

@}
@- Top-N selection

The top-N elements can be easily obtained by trimming the
space. The auxiliary index structures are removed.
For non-variable size BATs it merely requires
adjustment of the free space labels. Other BATs require
a loop through the tuples to be deleted. [todo]
@{
@c
int
BATtopN(BAT *b, BUN topN)
{
	BATcheck(b, "BATtopN");
	if (topN > BATcount(b)) {
		GDKerror("BATtopN: not enough tuples in target\n");
	} else if (b->H->varsized || b->T->varsized) {
		HASHremove(b);
		while (BATcount(b) > topN)
			BUNdelete(b, BUNlast(b), FALSE);
	} else {
		HASHremove(b);
		BATsetcount(b, topN);
	}
	return 0;
}

@- Random Selections
@c
BAT *
BATsample(BAT *b, BUN size)
{
	BUN cnt, i, r = 0, n, j;
	BUN *choice = NULL, *dst;
	BAT *bn;
	BATiter bi = bat_iterator(b);
	BUN bun;

	BATcheck(b, "BATsample: source BAT required");

	assert(BATcount(b) <= BUN_MAX);

	if (size > BUN_MAX) {
		GDKerror("BATsample: sample too large\n");
		return NULL;
	}

	cnt = (BUN) BATcount(b);
	n = (BUN) MIN(size, BATcount(b));

	bn = BATnew(BAThtype(b), BATttype(b), n);
	BATcheck(bn, "BATsample: dest BAT required");

	if (n == 0)
		return bn;
	dst = choice = (BUN *) GDKmalloc(n * sizeof(BUN));
	if (choice == NULL)
		goto bunins_failed;

	if (n * 2 < BATcount(b)) {	/* nondense sample */
		char *vec = (char *) GDKzalloc(1 + (cnt / 8));

		if (vec == NULL)
			goto bunins_failed;
		for (j = 0; j < n; j++) {
			r += rand();
			i = r % cnt;
			for (;;) {
				int mask = 1 << (i & 7);

				if (vec[i >> 3] & mask) {
					if (++i == cnt)
						i = 0;
				} else {
					vec[i >> 3] |= mask;
					break;
				}
			}
			*dst++ = i;
		}
		GDKfree(vec);
	} else if (cnt < 65536) {
		unsigned short *vec = (unsigned short *) GDKmalloc(cnt * sizeof(unsigned short));

		if (vec == NULL)
			goto bunins_failed;
		for (i = 0; i < cnt; i++)
			vec[i] = (unsigned short) i;
		for (j = 0; j < n; j++) {
			r += rand();
			i = r % cnt;
			*dst++ = vec[i];
			vec[i] = vec[--cnt];
		}
		GDKfree(vec);
	} else {
		BUN *vec = (BUN *) GDKmalloc(cnt * sizeof(BUN));

		if (vec == NULL)
			goto bunins_failed;
		for (i = 0; i < cnt; i++)
			vec[i] = i;
		for (j = 0; j < n; j++) {
			r += rand();
			i = r % cnt;
			*dst++ = vec[i];
			vec[i] = vec[--cnt];
		}
		GDKfree(vec);
	}

	/* merge all positions into a sorted list */
	qsort((void *) choice, n, sizeof(BUN),
#if SIZEOF_BUN == SIZEOF_INT
	      (int (*)(const void *, const void *)) intCmp
#else
	      (int (*)(const void *, const void *)) lngCmp
#endif
	    );

	/* insert the sorted sample */
	bun = BUNfirst(b);
	for (j = 0; j < n; j++) {
		BUN p = bun + choice[j];

		bunfastins(bn, BUNhead(bi, p), BUNtail(bi, p));
	}
	GDKfree(choice);	/* clean up choice array of BUN positions */

	/* set sorted flags by hand, because we used BUNfastins() */
	bn->hsorted = BAThordered(b);
	bn->tsorted = BATtordered(b);
	BATkey(bn, BAThkey(b));
	BATkey(BATmirror(bn), BATtkey(b));
	bn->H->nonil = b->H->nonil;
	bn->T->nonil = b->T->nonil;
	return bn;
      bunins_failed:
	if (choice)
		GDKfree(choice);
	BBPreclaim(bn);
	return NULL;
}

@- Horizontal Fragmentation
@c
BAT *
BATfragment(BAT *b, ptr hl, ptr hh, ptr tl, ptr th)
{
	BATcheck(b, "BATfragment");
	if ((hl == NULL) && (hh == NULL)) {
		return BATselect(b, tl, th);
	}
	if ((BAThordered(b) & 1) == FALSE && (BATtordered(b) & 1)) {
		return BATmirror(BATrestrict(BATmirror(b), tl, th, hl, hh));
	}
	return BATrestrict(b, hl, hh, tl, th);
}

@
@}
@-
The baseline algorithm for fragment location is a two-phase process.
First we search on the 1st
dimension and collect the qualifying BUNs in a marking on the
stack. In the second phase, the tail is analyzed for all items
already marked and qualifying associations are copied into the result.
An index is exploited when possible.


@{
@= restrict1
	if (BAThordered(b)&1) {
		BUN p1, p2;

		b = BATmirror(b);
		SORTloop(b, p1, p2, hl, hh) {
			*m++ = p1;
		}
		b = BATmirror(b);
	} else {
		int lval = !@1_EQ(ATOMnilptr(t), hl, @2);
		int hval = !@1_EQ(ATOMnilptr(t), hh, @2);

		if (hval && lval && @1_GT(hl,hh,@2)) {
			GDKerror("BATrestrict: illegal head range.\n");
		} else {
			BATiter bi = bat_iterator(b);

			BATloop(b, p, l) {
				if ((!lval || @1_LE(hl, BUNh@3(bi, p), @2)) &&
				    (!hval || @1_LE(BUNh@3(bi, p), hh, @2))) {
					*m++ = p;
				}
			}
		}
	}
@
@= restrict2
	{
		tl = @1_EQ(ATOMnilptr(t), tl, @2) ? 0 : tl;
		th = @1_EQ(ATOMnilptr(t), th, @2) ? 0 : th;
		if (th && tl && @1_GT(tl, th, @2)) {
			GDKerror("BATrestrict: illegal tail range.\n");
		} else {
			BATiter bi = bat_iterator(b);

			for (; i < m; i++) {
				ptr v = BUNt@4(bi, *i);

				if ((!tl || @1_LE(tl, v, @2)) &&
				    (!th || @1_LE(v, th, @2))) {
					bunfastins(bn, BUNh@3(bi, *i), v);
				}
			}
		}
	}
	break;
@c
BAT *
BATrestrict(BAT *b, ptr hl, ptr hh, ptr tl, ptr th)
{
	BAT *bn;
	BUN p = 0, l;
	BUN *mark, *m, *i;
	BUN s;
	int t;

	BATcheck(hl, "BATrestrict: hl is null");
	BATcheck(hh, "BATrestrict: hh is null");
	BATcheck(tl, "BATrestrict: tl is null");
	BATcheck(th, "BATrestrict: th is null");
	bn = BATnew(BAThtype(b), BATttype(b), BATguess(b));
	ESTIDEBUG THRprintf(GDKout, "#BATrestrict: estimated resultsize: " BUNFMT "\n", BATguess(b));

	if (bn == NULL) {
		return NULL;
	}
	BATkey(bn, BAThkey(b));
	BATkey(BATmirror(bn), BATtkey(b));
	bn->hsorted = BAThordered(b);
	bn->tsorted = BATtordered(b);
	bn->H->nonil = b->H->nonil;
	bn->T->nonil = b->T->nonil;

	s = BATcount(b);
	if (s == 0) {
		ESTIDEBUG THRprintf(GDKout, "#BATrestrict: actual resultsize: " BUNFMT "\n", BATcount(bn));

		return bn;
	}
	if ((mark = (BUN *) GDKmalloc((unsigned) s * sizeof(BUN))) == NULL)
		goto bunins_failed;
	m = mark;
	i = mark;
	switch (ATOMstorage(t = b->htype)) {
#ifndef NOEXPAND_CHR
	case TYPE_chr:
		@:restrict1(simple,chr,loc)@
		break;
#endif
#ifndef NOEXPAND_BTE
	case TYPE_bte:
		@:restrict1(simple,bte,loc)@
		break;
#endif
#ifndef NOEXPAND_SHT
	case TYPE_sht:
		@:restrict1(simple,sht,loc)@
		break;
#endif
#ifndef NOEXPAND_INT
	case TYPE_int:
		@:restrict1(simple,int,loc)@
		break;
#endif
#ifndef NOEXPAND_FLT
	case TYPE_flt:
		@:restrict1(simple,flt,loc)@
		break;
#endif
#ifndef NOEXPAND_DBL
	case TYPE_dbl:
		@:restrict1(simple,dbl,loc)@
		break;
#endif
#ifndef NOEXPAND_LNG
	case TYPE_lng:
		@:restrict1(simple,lng,loc)@
		break;
#endif
	default:
		if (b->hvarsized) {
			@:restrict1(atom,t,var)@
		} else {
			@:restrict1(atom,t,loc)@
		}
		break;
	}

	/* second phase */
	if (b->hvarsized) {
		switch (ATOMstorage(t = b->ttype)) {
#ifndef NOEXPAND_CHR
		case TYPE_chr:
			@:restrict2(simple,chr,var,loc)@
			break;
#endif
#ifndef NOEXPAND_BTE
		case TYPE_bte:
			@:restrict2(simple,bte,var,loc)@
			break;
#endif
#ifndef NOEXPAND_SHT
		case TYPE_sht:
			@:restrict2(simple,sht,var,loc)@
			break;
#endif
#ifndef NOEXPAND_INT
		case TYPE_int:
			@:restrict2(simple,int,var,loc)@
			break;
#endif
#ifndef NOEXPAND_FLT
		case TYPE_flt:
			@:restrict2(simple,flt,var,loc)@
			break;
#endif
#ifndef NOEXPAND_DBL
		case TYPE_dbl:
			@:restrict2(simple,dbl,var,loc)@
			break;
#endif
#ifndef NOEXPAND_LNG
		case TYPE_lng:
			@:restrict2(simple,lng,var,loc)@
			break;
#endif
		default:
			if (b->tvarsized) {
				@:restrict2(atom,t,var,var)@
			} else {
				@:restrict2(atom,t,var,loc)@
			}
			break;
		}
	} else {
		switch (ATOMstorage(t = b->ttype)) {
#ifndef NOEXPAND_CHR
		case TYPE_chr:
			@:restrict2(simple,chr,loc,loc)@
			break;
#endif
#ifndef NOEXPAND_BTE
		case TYPE_bte:
			@:restrict2(simple,bte,loc,loc)@
			break;
#endif
#ifndef NOEXPAND_SHT
		case TYPE_sht:
			@:restrict2(simple,sht,loc,loc)@
			break;
#endif
#ifndef NOEXPAND_INT
		case TYPE_int:
			@:restrict2(simple,int,loc,loc)@
			break;
#endif
#ifndef NOEXPAND_FLT
		case TYPE_flt:
			@:restrict2(simple,flt,loc,loc)@
			break;
#endif
#if !defined(NOEXPAND_LNG) || !defined(NOEXPAND_DBL)
		case TYPE_dbl:
		case TYPE_lng:
			@:restrict2(simple,lng,loc,loc)@
			break;
#endif
		default:
			if (b->tvarsized) {
				@:restrict2(atom,t,loc,var)@
			} else {
				@:restrict2(atom,t,loc,loc)@
			}
			break;
		}
	}
	GDKfree(mark);

	/* propagate alignment info */
	if (BATcount(bn) == BATcount(b))
		ALIGNset(bn, b);

	ESTIDEBUG THRprintf(GDKout, "#BATrestrict: actual resultsize: " BUNFMT "\n", BATcount(bn));

	return bn;

      bunins_failed:
	GDKfree(mark);
	BBPreclaim(bn);
	return NULL;
}

@}
@+ BAT Sorting
@%BATsort@ returns a sorted copy. @%BATorder@ sorts the BAT itself.
@{
@c
#ifdef HAVE_RESTRICT
#define __r     restrict
#else
#ifdef HAVE___RESTRICT__
#define __r     __restrict__
#else
#define __r
#endif
#endif

@:sort(1,,,_rev,>)@
@:sort(GDK_SORTED_REV,_REV,_rev,,<)@

@= chk_order
	/* for [tpe,void], we have fast 128-at-a-time routines */
	if (b->hkey == 0) {
		/* sorted and key? */
		while (cur + 128 < end) {
			if (!chk_order_key@2_@1((@1 *) BUNhloc(bi,cur))) {
				key = FALSE;
				break;
			}
			cur += 128;
		}
	}
	/* sorted? */
	while (cur + 128 < end) {
		if (!chk_order@2_@1((@1 *) BUNhloc(bi,cur)))
			break;
		cur += 128;
	}
	/* finish remaining <128 tuples */
	if (cur < end) {
		@1 val, prv = *(@1*)BUNhloc(bi,cur);
		cur++;
		if (b->hkey == 0 && key) {
			/* sorted and key? */
			while (cur < end) {
				val = *(@1*)BUNhloc(bi,cur);
				if (prv @3= val) {
					key = FALSE;
					break;
				}
				prv = val;
				cur++;
			}
		}
		/* sorted? */
		while (cur < end) {
			val = *(@1*)BUNhloc(bi,cur);
			if (prv @3 val) {
				/* record negative position info */
				b->H->nosorted@2 = cur;
				return FALSE;
			}
			prv = val;
			cur++;
		}
	}

@= sort_key_tpe
static int
chk_order@1@3_@4(@4*__r col)
{
	int i, r = 1;

	for (i = 0; i < 128; i += 4) {
		r &= (col[i + 1] @2 col[i + 0]) &
		     (col[i + 2] @2 col[i + 1]) &
		     (col[i + 3] @2 col[i + 2]) &
		     (col[i + 4] @2 col[i + 3]);
	}
	return r;
}

@= sort_tpe
@:sort_key_tpe(_key,@2,@3,@1)@
@:sort_key_tpe(,@2=,@3,@1)@

@= sort
@:sort_tpe(chr,@5,@3)@
@:sort_tpe(bte,@5,@3)@
@:sort_tpe(sht,@5,@3)@
@:sort_tpe(int,@5,@3)@
@:sort_tpe(lng,@5,@3)@
@:sort_tpe(flt,@5,@3)@
@:sort_tpe(dbl,@5,@3)@

int
BATordered@3(BAT* b)
{
	BUN cnt = BATcount(b);
	bit key = (cnt < 2);

	if ((BAThordered(b) & @1) == 0 && cnt > 0) {
		int (*cmp)(ptr, ptr) = BATatoms[b->htype].atomCmp;
		BUN cur = BUNfirst(b);
		BUN end = BUNlast(b);
		BATiter bi = bat_iterator(b);

		key = TRUE;

		/* we may have negative information already; this saves a scan */
		if (b->H->nosorted@3 > cur && b->H->nosorted@3 < end && cmp(BUNhead(bi, (BUN) (b->H->nosorted@3 - 1)), BUNhead(bi, (BUN) b->H->nosorted@3)) @5 0) {
			return FALSE;
		}

		/* for [tpe,void] bats, we have fast 128-at-a-time routines */
		if (ATOMstorage(b->htype) == TYPE_chr) {
			@:chk_order(chr,@3,@5)@
		} else if (ATOMstorage(b->htype) == TYPE_bte) {
			@:chk_order(bte,@3,@5)@
		} else if (ATOMstorage(b->htype) == TYPE_sht) {
			@:chk_order(sht,@3,@5)@
		} else if (ATOMstorage(b->htype) == TYPE_int) {
			@:chk_order(int,@3,@5)@
		} else if (ATOMstorage(b->htype) == TYPE_lng) {
			@:chk_order(lng,@3,@5)@
		} else if (ATOMstorage(b->htype) == TYPE_flt) {
			@:chk_order(flt,@3,@5)@
		} else if (ATOMstorage(b->htype) == TYPE_dbl) {
			@:chk_order(dbl,@3,@5)@
		} else {
			/* check sortedness tuple-by-tuple */
			if (b->H->vheap) {
				char *base = Hbase(b);
				char *prv = base + BUNhvaroff(bi, cur);

				cur ++;
				if (b->hkey == 0) {
					/* sorted and key? */
					while (cur < end) {
						char *val = base + BUNhvaroff(bi, cur);

						if (cmp(prv, val) @5= 0) {
							key = FALSE;
							break;
						}
						prv = val;
						cur++;
					}
				}
				/* sorted? */
				while (cur < end) {
					char *val = base + BUNhvaroff(bi, cur);

					if (cmp(prv, val) @5 0) {
						/* record negative position info */
						b->H->nosorted@3 = cur;
						return FALSE;
					}
					prv = val;
					cur ++;
				}
			} else {
				BUN prv = cur;

				cur ++;
				if (b->hkey == 0) {
					/* sorted and key? */
					while (cur < end) {
						if (cmp(BUNhloc(bi,prv), BUNhloc(bi,cur)) @5= 0){
							key = FALSE;
							break;
						}
						prv = cur;
						cur ++;
					}
				}
				/* sorted? */
				while (cur < end) {
					if (cmp(BUNhloc(bi,prv), BUNhloc(bi,cur)) @5 0){
						/* record negative position info */
						b->H->nosorted@3 = cur;
						return FALSE;
					}
					prv = cur;
					cur ++;
				}
			}
		}
	}
	if (b->hkey == 0 && key) {
		b->batDirtydesc = TRUE;
		BATkey(b, TRUE);
	}
	/* it is sorted@3! set the properties */
	if ((b->hsorted & (bit) GDK_SORTED@2) == 0) {
		b->batDirtydesc = TRUE;
	}
	b->hsorted |= (bit) GDK_SORTED@2;
	return TRUE;
}

@:sort1(@1,@2,@3,@4,@5,,q)@
@:sort1(@1,@2,@3,@4,@5,s,s)@

@= sort1
BAT *
BAT@6sort@3(BAT *b)
{
	BAT *bn;
	int tt = 0;

	BATcheck(b, "BATsort@3");
 	tt = b->ttype;
	if (b->htype == TYPE_void && b->hseqbase == oid_nil) {
		/* b's head is void-nil, hence we return a read-only copy/view of b */
		return BATcopy(b, b->htype, b->ttype, FALSE);
	}
	if ((GDK_SORTED@2 == GDK_SORTED && b->htype == TYPE_void) || (b->htype != TYPE_void && BATordered@3(b))) {
		/* b is already ordered as desired, hence we return a read-only copy/view of b */
		return BATcopy(b, b->htype, b->ttype, FALSE);
	}
	if (BATcount(b) < 2) {
		BATiter bi = bat_iterator(b);

		/* with fewer than 2 BUNs, b is ordered, hence we return a read-only copy/view of b */
		b->hsorted = (bit) GDK_SORTED@2;
		if (b->htype == TYPE_oid) {
			oid h = * (oid *) BUNhloc(bi, BUNfirst(b));

			if (h != oid_nil) {
				b->hdense = 1;
				b->hseqbase = h;
			}
		}
		return BATcopy(b, b->htype, b->ttype, FALSE);
	}
	/* a void tail column 0,1,2,3,... must be materialized to oid before sorting */
	if (tt == TYPE_void && b->tseqbase != oid_nil) {
		tt = TYPE_oid;
	}
	if ((GDK_SORTED@2 == GDK_SORTED_REV && b->htype == TYPE_void) || 
	    (b->htype != TYPE_void && (b->hkey || '@7' != 's') && BATordered@4(b))) {
		/* b is ordered in the opposite direction, hence we return a reverted copy of b */
		/* a void head column must be materialized to oid before reverting */
		int ht = b->htype;

		if (ht == TYPE_void && b->hseqbase != oid_nil) {
			ht = TYPE_oid;
		}
		bn = BATrevert(BATcopy(b, ht, tt, TRUE));
		if (bn == NULL)
			return bn;

		return bn;
	}
	bn = BATcopy(b, b->htype, tt, TRUE);
	if (bn == NULL)
		return bn;
	return BAT@6order@3(bn);
}

BAT *
BAT@6order@3(BAT *b)
{
	BATcheck(b, "BATorder@3");
	if (b->htype == TYPE_void && b->hseqbase == oid_nil) {
		/* b's head is void-nil, hence we return b as is */
		return BATcopy(b, b->htype, b->ttype, FALSE);
	}
	if ((GDK_SORTED@2 == GDK_SORTED && b->htype == TYPE_void) || (b->htype != TYPE_void && BATordered@3(b))) {
		/* b is already ordered as desired, hence we return b as is */
		return b;
	}
	if (BATcount(b) < 2) {
		/* with less than 2 BUNs, b is ordered, hence we return b as is */
		b->hsorted = (bit) GDK_SORTED@2;
		return b;
	}
	if (b->ttype == TYPE_void && b->tseqbase != oid_nil) {
		/* materialize void-tail in-place */
		b = BATmaterializet(b);
		if (b == NULL)
			return NULL;
	}
	if ((GDK_SORTED@2 == GDK_SORTED_REV && b->htype == TYPE_void) || 
	    (b->htype != TYPE_void && (b->hkey || '@7' != 's') && BATordered@4(b))) {
		/* b is ordered in the opposite direction, hence we revert b */
		b = BATrevert(b);
		return b;
	}
	GDK@7sort@3(Hloc(b,BUNfirst(b)), Tloc(b,BUNfirst(b)), (b->H->vheap)?b->H->vheap->base:NULL, BATcount(b), Hsize(b), Tsize(b), b->htype);
	HASHdestroy(b);
	ALIGNdel(b, "BATorder@3", FALSE);
	b->hsorted = (bit) GDK_SORTED@2;
	b->tsorted = FALSE;
	b->hdense = FALSE;
	b->tdense = FALSE;
	b->batDirtydesc = b->H->heap.dirty = b->T->heap.dirty = TRUE;

	return b;
}
@}
@+ Reverse a BAT
@%BATrevert@ rearranges a BAT in reverse order on head.
@{
@c
BAT *
BATrevert(BAT *b)
{
	char *h, *t;
	BUN p, q;
	BATiter bi = bat_iterator(b);
	size_t s;

	BATcheck(b, "BATrevert");
	if ((b->htype == TYPE_void && b->hseqbase != oid_nil) || (b->ttype == TYPE_void && b->tseqbase != oid_nil)) {
		/* materialize void columns in-place */
		b = BATmaterialize(b);
		if (b == NULL)
			return NULL;
	}
	ALIGNdel(b, "BATrevert", FALSE);
	s = Hsize(b);
	if (s > 0) {
		h = (char *) GDKmalloc(s);
		if (!h) {
			return NULL;
		}
		for (p = BUNlast(b) ? BUNlast(b) - 1 : 0, q = BUNfirst(b); p > q; p--, q++) {
			char *ph = BUNhloc(bi, p);
			char *qh = BUNhloc(bi, q);

			memcpy(h, ph, s);
			memcpy(ph, qh, s);
			memcpy(qh, h, s);
		}
		GDKfree(h);
	}
	s = Tsize(b);
	if (s > 0) {
		t = (char *) GDKmalloc(s);
		if (!t) {
			return NULL;
		}
		for (p = BUNlast(b) ? BUNlast(b) - 1 : 0, q = BUNfirst(b); p > q; p--, q++) {
			char *pt = BUNtloc(bi, p);
			char *qt = BUNtloc(bi, q);

			memcpy(t, pt, s);
			memcpy(pt, qt, s);
			memcpy(qt, t, s);
		}
		GDKfree(t);
	}
	HASHdestroy(b);
	if (b->hsorted & GDK_SORTED)
		b->hsorted = GDK_SORTED_REV;
	else if (b->hsorted & GDK_SORTED_REV)
		b->hsorted = GDK_SORTED;
	else
		b->hsorted = FALSE;
	b->hdense = FALSE;
	if (b->tsorted & GDK_SORTED)
		b->tsorted = GDK_SORTED_REV;
	else if (b->tsorted & GDK_SORTED_REV)
		b->tsorted = GDK_SORTED;
	else
		b->tsorted = FALSE;
	b->tdense = FALSE;
	return b;
}

@
@}

@+ BAT partitioning
For distributed processing we support hash and range
partitioning operators: @%BATsplithash@ and @%BATsplitrange@.
@{
@-
The @%part_bat@ function creates a partition BAT.
@c
static BAT *
part_bat(BAT *b, int ht, int tt, BUN expected_size, int respect_order)
{
	BAT *bn = BATnew(ht, tt, (BUN) ((double) expected_size * BATMARGIN));

	if (bn) {
		BATkey(bn, BAThkey(b));
		BATkey(BATmirror(bn), BATtkey(b));
		bn->hsorted = (respect_order && (BAThordered(b) & 1)) ? GDK_SORTED : 0;
		bn->tsorted = (respect_order && (BATtordered(b) & 1)) ? GDK_SORTED : 0;
		bn->H->nonil = b->H->nonil;
		bn->T->nonil = b->T->nonil;
	}
	return bn;
}

@- hash partitioning
@c
#define BUNhash(bx,hx,tx)\
	/* assert(n <= 0x40000000); */\
	i = (int)(HASHprobe(&h,tx)%n); \
	if ((r = BUNfnd(bx, &i)) != BUN_NONE){\
		bat bid = *(bat*)BUNtloc(metabati,r); \
		bunfastins(BBPdescriptor(bid), hx, tx);\
	}

BAT *
BAThashsplit(BAT *b, BUN n, int unary)
{
	BAT *metabat, *bn, *bf;
	BUN r;
	Hash h;
	BUN cnt;
	int i = 0;

	/* assert(n <= 0x40000000); */
	BATcheck(b, "BAThashsplit");
	if (n > BATcount(b)) {
		PROPDEBUG THRprintf(GDKout, "#BAThashsplit: reduced number of ranges (" BUNFMT ") to number of tuples (" BUNFMT ").\n", n, BATcount(b));
		n = BATcount(b);
	}
	if (n < 1) {
		GDKerror("BAThashsplit: number of ranges must not be less than 1!\n");
		return 0;
	}

	metabat = BATnew(TYPE_int, TYPE_bat, n);
	if (metabat == NULL)
		return NULL;
	bn = unary ? VIEWhead_(b, b->batRestricted) : b;
	if (n <= 1) {
		if (BUNins(metabat, &i, &bn->batCacheid, FALSE) == NULL)
			goto bunins_failed;
	} else {
		BUN p, q;
		BATiter metabati;

		for (i = 2; i < (int) n; i *= 2)
			;
		h.mask = i - 1;
		h.type = BATttype(b);
		cnt = (BUN) (BATMARGIN * (double) BATbuncount(b) / (double) n);
		for (i = 0; i < (int) n; i++) {
			bf = part_bat(bn, BAThtype(bn), BATttype(bn), cnt, TRUE);
			if (bf == NULL) {
				BBPreclaim(metabat);
				return NULL;
			}
			if (BUNins(metabat, &i, &bf->batCacheid, FALSE) == NULL)
				goto bunins_failed;
		}
		metabati = bat_iterator(metabat);
		@:updateloop(metabat,b,BUNhash)@
		BATloop(metabat, p, q) {
			bat bt = *(bat *) BUNtail(metabati, p);

			BBPunfix(bt);
		}
	}
	return metabat;
      bunins_failed:
	BBPreclaim(metabat);
	return NULL;
}

@}
@-
Range partitioning ensures that identical values appear in one
partition only. The routine also tries to deliver partitions of
uniform size.
@{
@c
BAT *
BATrangesplit(BAT *b, BUN n, int unary)
{
	BAT *metabat, *slice, *histo, *bf = NULL, *bn, *m;
	int target, tpe, *sizes = NULL;
	int zz = 0;
	BUN yy = 0;
	ptr *seps = NULL, nilval;
	BUN r, s;
	BATiter histoi, bi = bat_iterator(b);
	dbl scale;
	BUN thorough = (n <= 1 || BATtvoid(b) || (BATtordered(b) & 1)) ? 1 : 10;

	BATcheck(b, "BATrangesplit");
	if (n > BATcount(b)) {
		PROPDEBUG THRprintf(GDKout, "#BATrangesplit: reduced number of ranges (" BUNFMT ") to number of tuples (" BUNFMT ").\n", n, BATcount(b));
		n = BATcount(b);
	}
	if (n < 1) {
		GDKerror("BAThashsplit: number of ranges must not be less than 1!\n");
		return 0;
	}

	/* assert(BATcount(b)/n <= 0x7fffffff); */
	bn = unary ? VIEWhead_(b, b->batRestricted) : b;
	m = BATmirror(b);
	metabat = BATnew(BATttype(b), TYPE_bat, n);
	BATcheck(metabat, "BATrangesplit 2");
	nilval = ATOMnilptr(BATttype(b));

@-
@}
We use sampling to determine bucket sizes.
Uniform bucket sizes are the ideal to be achieved.
If necessary though, we deliver less than n buckets.
@{
@c
	slice = BATsample(b, MIN(MAX(30 * n * thorough, 100 * thorough), BATcount(b)));
	histo = BAThistogram(slice);
	target = (int) (BATcount(b) / n);	/* see assert above */
	scale = ((dbl) BATcount(b)) / ((dbl) BATcount(slice));
	BBPreclaim(slice);
	if ((sizes = (int *) GDKmalloc(2 * n * sizeof(int))) == NULL)
		goto bunins_failed;
	if ((seps = (ptr *) GDKmalloc(2 * n * sizeof(ptr))) == NULL)
		goto bunins_failed;
@-
Use the histogram to determine good split boundaries on b.
@c
	BATorder(histo);
	histoi = bat_iterator(histo);
	BATloop(histo, r, s) {
		int cnt = *(int *) BUNtloc(histoi, r);
		int add = (int) (scale * cnt);

		if (zz + add > target) {
			if ((zz + add - target) < (target - zz)) {
				sizes[yy] = zz + add;
				seps[yy] = ATOMdup(histo->htype, BUNhead(histoi, r));
				add = 0;
			} else {
				sizes[yy] = zz;
				seps[yy] = ATOMdup(histo->htype, BUNhead(histoi, (r - 1)));
			}
			zz = 0;
			yy++;
		}
		zz += add;
	}
	if (yy) {
		if ((sizes[yy - 1] + zz - target) > (target - zz)) {
			sizes[yy] = zz;
		} else {
			yy--;	/* join with the last */
		}
	}
	seps[yy] = nilval;
	BBPreclaim(histo);

	if (n > 1 && n != yy + 1) {
		PROPDEBUG THRprintf(GDKout, "#rangesplit: delivering %lu instead of %lu fragments\n", yy + 1, n);
		n = yy + 1;
	}
@-
CASE 1: just one bucket.
This is done without copying b.
@c
	if (n <= 1) {
		if (BUNins(metabat, nilval, &bn->batCacheid, FALSE) == NULL)
			goto bunins_failed;

@-
CASE 2: sorted on fragmentation column.
We can again avoid copying, by giving slices (views) on the source BAT.
Virtual oids (void) is a special subcase with positional lookup instead
of binary search.
@c
	} else if (BATtvoid(b) || (BATtordered(b) & 1)) {
		BUN l, h = 0, o = BUNfirst(b);

		for (yy = 0; yy < n; yy++) {
			l = h;
			if (yy == n - 1) {
				r = BUNlast(m);
				h = r - o;
			} else if (BATtdense(b)) {
				h = ((*(oid *) seps[yy]) - b->tseqbase) + 1;
			} else {
				r = SORTfndlast(m, seps[yy]);
				h = r - o;
			}
			bf = BATslice(bn, l, h);	/* produces view bat */
			if (BUNins(metabat, seps[yy], &bf->batCacheid, FALSE) == NULL)
				goto bunins_failed;
		}

@-
CASE 3: full scan.
If it ain't sorted then we gotta scan the whole thing and split.
This is heavy stuff so we optimize execution according to datatype.
@
DELETED: simple walk-through list approach
		for(yy=0; yy<n-1; yy++) {
			if (@@1_LE(val, seps[yy], @@3)) break;
		}
		bunfastins(bats[yy], BUNhead(b,r), val);
@
We now use binary search for getting to the right bucket, so
that this routine also works efficiently on many buckets.

@= rangesplit
	BATloop(b, r, s) {
		ptr val = BUNt@2(bi, r);
		BUN lo = 0;
		BUN hi = n - 1;
		for (;;) {
			yy = (lo + hi) / 2;
			if (yy < n - 1 && @1_GT(val, seps[yy], @3)) {
				lo = yy + 1;
				if (lo >= hi) {
					yy = hi;
					break;
				}
			} else if (yy > 0 && @1_LE(val, seps[yy - 1], @3)) {
				hi = yy - 1;
				if (hi <= lo) {
					yy = lo;
					break;
				}
			} else {
				break;
			}
		}
		bunfastins(bats[yy], BUNhead(bi, r), val);
	}
@c
	} else {
		BAT **bats = (BAT **) GDKmalloc(n * sizeof(BAT *));

		if (bats == NULL)
			goto bunins_failed;
		for (yy = 0; yy < n; yy++) {
			bats[yy] = part_bat(bn, BAThtype(bn), bn->ttype, sizes[yy], TRUE);
			if (bats[yy] == NULL) {
				BBPreclaim(metabat);
				return NULL;
			}
			if (BUNins(metabat, seps[yy], &bats[yy]->batCacheid, FALSE) == NULL)
				goto bunins_failed;
		}
		switch (tpe = ATOMstorage(b->ttype)) {
#ifndef NOEXPAND_CHR
		case TYPE_chr:
			@:rangesplit(simple,loc,chr)@
			break;
#endif
#ifndef NOEXPAND_BTE
		case TYPE_bte:
			@:rangesplit(simple,loc,bte)@
			break;
#endif
#ifndef NOEXPAND_SHT
		case TYPE_sht:
			@:rangesplit(simple,loc,sht)@
			break;
#endif
#ifndef NOEXPAND_INT
		case TYPE_int:
			@:rangesplit(simple,loc,int)@
			break;
#endif
#ifndef NOEXPAND_FLT
		case TYPE_flt:
			@:rangesplit(simple,loc,flt)@
			break;
#endif
#ifndef NOEXPAND_DBL
		case TYPE_dbl:
			@:rangesplit(simple,loc,dbl)@
			break;
#endif
#ifndef NOEXPAND_LNG
		case TYPE_lng:
			@:rangesplit(simple,loc,lng)@
			break;
#endif
		default:
			if (b->tvarsized) {
				@:rangesplit(atom,var,tpe)@
			} else {
				@:rangesplit(atom,loc,tpe)@
			}
			break;
		}
		for (yy = 0; yy < n; yy++)
			BBPunfix(bats[yy]->batCacheid);
		GDKfree(bats);
	}
	for (yy = 0; yy < n - 1; yy++)
		GDKfree(seps[yy]);
	GDKfree(seps);
	GDKfree(sizes);

	return metabat;

      bunins_failed:
	GDKfree(seps);
	GDKfree(sizes);
	BBPreclaim(metabat);
	return NULL;
}

@}
@+ Introducing OID Columns
The @%BATmark@ operation is normally used to prepare a class of query
results. Likewise, @%BATnumber@ is heavily used in the SQL front-end.
@{
@c
BAT *
BATmark(BAT *b, oid oid_base)
{
	BAT *bn;

	BATcheck(b, "BATmark");
	bn = VIEWhead(b);
	if (bn) {
		BATseqbase(BATmirror(bn), oid_base);
		if (oid_base == oid_nil)
			bn->T->nonil = 0;
		if (BAThrestricted(b) != BAT_READ) {
			BAT *v = bn;

			bn = BATcopy(v, v->htype, v->ttype, TRUE);
			BBPreclaim(v);
		}
	}
	return bn;
}

#define BUNnumber(bx,hx,tx)	bunfastins_nocheck(bx, r, hx, (ptr)&i, Hsize(bx), Tsize(bx)); r++; i++;
BAT *
BATnumber(BAT *b)
{
/* 64bit: BATnumber should return a [any,wrd] bat instead of [any,int] */
	int i = 0;
	BAT *bn;
	BUN r;

	BATcheck(b, "BATnumber");
	/* assert(BATcount(b) <= MAXINT); */
	bn = BATnew(b->htype, TYPE_int, BATcount(b));
	if (bn == NULL)
		return NULL;
	r = BUNfirst(bn);
	@:updateloop(bn,b,BUNnumber)@
	ALIGNsetH(bn, b);
	BATsetprop_wrd(bn, GDK_AGGR_CARD, i);	/* 64bit: no (wrd) cast to remind us */
	bn->hsorted = BAThordered(b);
	bn->tsorted = GDK_SORTED;
	bn->H->nonil = b->H->nonil;
	bn->T->nonil = 1;
	return bn;
      bunins_failed:
	BBPreclaim(bn);
	return NULL;
}

BAT *
BATgroup(BAT *b, int start, int incr, int grpsize)
{
/* 64bit: this should probably use wrd instead of int */
	BUN p, q, r;
	int ngroups = 1, i = 0;
	BAT *bn;
	BATiter bi = bat_iterator(b);

	BATcheck(b, "BATgroup");
	bn = BATnew(b->htype, TYPE_int, BATcount(b));
	if (bn == NULL)
		return NULL;
	r = BUNfirst(bn);

	ALIGNsetH(bn, b);

	BATloop(b, p, q) {
		bunfastins_nocheck(bn, r, BUNhead(bi, p), (ptr) &start, Hsize(bn), Tsize(bn));
		r++;
		if (i == grpsize - 1) {
			start += incr;
			i = 0;
			ngroups++;
		} else {
			i++;
		}
	}
	if (i == 0)
		ngroups--;
	BATsetprop_wrd(bn, GDK_AGGR_CARD, ngroups);
	bn->hsorted = BAThordered(b);
	bn->tsorted = GDK_SORTED;
	bn->H->nonil = b->H->nonil;
	bn->T->nonil = 1;
	return bn;
      bunins_failed:
	BBPreclaim(bn);
	return NULL;
}

@= mark_grp_init
	BUN w;

	BUNfnd@1(w, gi, &v);
	if (w != BUN_NONE) {
		n = * (oid *) BUNtloc(gi, w);
	} else {
		n = oid_nil;
	}
@
@= mark_grp_loop4
	oid u = oid_nil;
	oid n = oid_nil;

	BATloop(b, p, q) {
		oid v = * (oid *) BUNt@3(bi, p);

		if (v != u) {
			@4
			u = v;
		} else if (n != oid_nil) {
			n++;
		}
		@2oid_bunfastins_nocheck_noinc(bn, r, BUNh@1(bi, p), &n);
		r++; 
	}
@
@= mark_grp_loop3
	BATloop(b, p, q) {
		oid n = oid_nil;
		BUN w;
		ptr v = BUNt@3(bi, p);

		BUNfnd@4(w, gci, v);
		if (w != BUN_NONE) {
			oid *m = (oid*) BUNtloc(gci, w);

			if (*m != oid_nil) {
				n = (*m)++;
			}
		}
		@2oid_bunfastins_nocheck_noinc(bn, r, BUNh@1(bi, p), &n);
		r++; 
	}
@
@= mark_grp_loop2
	if (gc) {
		BATiter gci = bat_iterator(gc);

		if (BAThdense(gc)) {
			@:mark_grp_loop3(@1,@2,@3,VOID)@
		} else {
			@:mark_grp_loop3(@1,@2,@3,OID)@
		}
	} else {
		if (s) {
			@:mark_grp_loop4(@1,@2,@3,n = *s;,s);
		} else {
			if (BAThdense(g)) {
				@:mark_grp_loop4(@1,@2,@3,@:mark_grp_init(VOID)@,VOID);
			} else {
				@:mark_grp_loop4(@1,@2,@3,@:mark_grp_init(OID)@,OID);
			}
		}
	}
@
@= mark_grp_loop1
	if (b->ttype == TYPE_void) {
		@:mark_grp_loop2(@1,@2,var)@
	} else {
		@:mark_grp_loop2(@1,@2,loc)@
	}
@
@= mark_grp_loop
{	BUN p, q, r = BUNfirst(bn);
	BATiter bi = bat_iterator(b);
	BATiter gi = bat_iterator(g);

	if (b->hvarsized) {
		@:mark_grp_loop1(var,var)@
	} else {
		@:mark_grp_loop1(loc,fix)@
	}
	BATsetcount(bn, BATcount(b));
}
@
@c
BAT *
BATmark_grp(BAT *b, BAT *g, oid *s)
{
	BAT *bn, *gc = NULL;
	bit trivprop = FALSE;

	BATcheck(b, "BATmark_grp");
	BATcheck(g, "BATmark_grp");
	ERRORcheck(b->ttype != TYPE_void && b->ttype != TYPE_oid,
		   "BATmark_grp: tail of BAT b must be oid.\n");
	ERRORcheck(g->htype != TYPE_void && g->htype != TYPE_oid,
		   "BATmark_grp: head of BAT g must be oid.\n");
	ERRORcheck(b->ttype == TYPE_void && b->tseqbase == oid_nil,
		   "BATmark_grp: tail of BAT b must not be nil.\n");
	ERRORcheck(g->htype == TYPE_void && g->hseqbase == oid_nil,
		   "BATmark_grp: head of BAT g must not be nil.\n");
	ERRORcheck(s && *s == oid_nil,
		   "BATmark_grp: base oid s must not be nil.\n");
	ERRORcheck(!s && g->ttype != TYPE_oid,
		   "BATmark_grp: tail of BAT g must be oid.\n");

	if (BATcount(b) == 0 || BATcount(g) == 1) {
		if (s) {
			return BATmark(b, *s);
		} else {
			BATiter gi = bat_iterator(g);
			return BATmark(b, *(oid *) BUNtloc(gi, BUNfirst(g)));
		}
	}

	if (!BATtordered(b)) {
		if (s) {
			BUN p, q, r;

			if (BAThdense(g)) {
				gc = BATnew(TYPE_void, TYPE_oid, BATcount(g));
				if (gc == NULL)
					return NULL;
				r = BUNfirst(gc);
				BATloop(g, p, q) {
					voidoid_bunfastins_nocheck_noinc(gc, r, NULL, s);
					r++;
				}
			} else {
				BATiter gi = bat_iterator(g);
				gc = BATnew(TYPE_oid, TYPE_oid, BATcount(g));
				if (gc == NULL)
					return NULL;
				r = BUNfirst(gc);
				BATloop(g, p, q) {
					oidoid_bunfastins_nocheck_noinc(gc, r, BUNhloc(gi, p), s);
					r++;
				}
			}
			BATsetcount(gc, BATcount(g));
			gc->hdense = BAThdense(g);
			if (BAThdense(gc)) {
				BATseqbase(gc, g->hseqbase);
				gc->hsorted = GDK_SORTED;
			} else {
				gc->hsorted = BAThordered(g);
			}
			BATkey(gc, TRUE);
			gc->H->nonil = gc->H->nonil;
			gc->T->nonil = 1;
		} else {
			gc = BATcopy(g, g->htype, g->ttype, TRUE);
			if (gc == NULL)
				return NULL;
		}
	}
	bn = BATnew(b->htype, TYPE_oid, BATcount(b));
	if (bn == NULL) {
		if (gc)
			BBPreclaim(gc);
		return NULL;
	}

	@:mark_grp_loop@

	trivprop = (BATcount(bn) < 2);
	ALIGNsetH(bn, b);
	bn->hsorted = (trivprop ? GDK_SORTED : BAThordered(b));
	bn->hdense = BAThdense(b) || (trivprop && b->htype == TYPE_oid);
	if (BAThdense(bn)) {
		BATseqbase(bn, b->hseqbase);
	}
	BATkey(bn, (bn->hdense || b->hkey != FALSE));
	bn->tsorted = (trivprop ? GDK_SORTED : FALSE);
	bn->tdense = trivprop;
	if (BATtdense(bn)) {
		BATiter bni = bat_iterator(bn);
		BATseqbase(BATmirror(bn), *(oid *) BUNtloc(bni, BUNfirst(bn)));
	}
	BATkey(BATmirror(bn), trivprop);
	bn->H->nonil = bn->H->nonil;
	bn->T->nonil = 1;

	if (gc)
		BBPreclaim(gc);
	return bn;
      bunins_failed:
	if (gc)
		BBPreclaim(gc);
	BBPreclaim(bn);
	return NULL;
}


BAT *
BATconst(BAT *b, int tailtype, ptr v)
{
	BAT *bn = NULL;
	BUN p, q, r;
	BUN cnt = BATcount(b);
	BATiter bi = bat_iterator(b);

	BATcheck(b, "BATconst");
	if (!v)
		return NULL;
	if (BAThrestricted(b) == BAT_READ &&
	    !ATOMvarsized(tailtype) && tailtype != TYPE_bat) {
		BAT *o = b;
		if (BUNfirst(b))
			b = BATslice(b, 0, BATcount(b));
		if (tailtype == TYPE_void) {
			oid seqbase = oid_nil;

			bn = VIEWhead(b);
			if (b != o)
				BBPunfix(b->batCacheid);
			BATseqbase(BATmirror(bn), seqbase);
			bn->T->nonil = 0;
			return bn;
		} else {
			BAT *bt = BATnew(TYPE_void, tailtype, cnt);

			if (!bt)
				return NULL;
			bt->T->nonil = (ATOMcmp(tailtype, v, ATOMnilptr(tailtype)) != 0);
			switch (ATOMsize(ATOMstorage(tailtype))) {
			case 1:{
				bte *d = (bte *) Tloc(bt, BUNfirst(bt)), V = *(bte *) v;
				for (r = 0; r < cnt; r++)
					d[r] = V;
				BATsetcount(bt, cnt);
				break;
			}
			case 2:{
				sht *d = (sht *) Tloc(bt, BUNfirst(bt)), V = *(sht *) v;
				for (r = 0; r < cnt; r++)
					d[r] = V;
				BATsetcount(bt, cnt);
				break;
			}
			case 4:{
				int *d = (int *) Tloc(bt, BUNfirst(bt)), V = *(int *) v;
				for (r = 0; r < cnt; r++)
					d[r] = V;
				BATsetcount(bt, cnt);
				break;
			}
			case 8:{
				lng *d = (lng *) Tloc(bt, BUNfirst(bt)), V = *(lng *) v;
				for (r = 0; r < cnt; r++)
					d[r] = V;
				BATsetcount(bt, cnt);
				break;
			}
			default:
				for (r = BUNfirst(bt), cnt += r; r < cnt; r++)
					bunfastins_nocheck(bt, r, NULL, v, 0, Tsize(bt));
			}
			bt->tsorted = GDK_SORTED;
			if (b->htype == TYPE_void) {
				bn = bt;
				BATseqbase(bn, b->hseqbase);
				ALIGNsetH(bn, b);
			} else {
				bn = VIEWcreate(b, bt);
				BBPunfix(bt->batCacheid);
			}
			if (b != o)
				BBPunfix(b->batCacheid);
			return bn;
		}
	}
	if (tailtype == TYPE_bat) {
		v = &((BAT *) v)->batCacheid;
	}
	bn = BATnew(b->htype, tailtype, BATcount(b));
	if (bn == NULL)
		return bn;
	r = BUNfirst(bn);
	BATloop(b, p, q) {
		bunfastins_nocheck(bn, r, BUNhead(bi, p), v, Hsize(bn), Tsize(bn));
		r++;
	}
	ALIGNsetH(bn, b);
	bn->tsorted = GDK_SORTED;
	bn->H->nonil = b->H->nonil;
	bn->T->nonil = (ATOMcmp(tailtype, v, ATOMnilptr(tailtype)) != 0);
	BATsetprop_wrd(bn, GDK_AGGR_CARD, (wrd) (BATcount(b) > 0));
	if (tailtype == TYPE_bit) {
		BATsetprop_wrd(bn, GDK_AGGR_SIZE, (*(bit *) v == TRUE) ? (wrd) BATcount(b) : 0);
	}
	return bn;
      bunins_failed:
	if (bn)
		BBPreclaim(bn);
	return NULL;
}

@}
@+ BAT Aggregates

We retain the size() and card() aggregate results in the column descriptor.
We would like to have such functionality in an extensible way for many aggregates,
for DD (1) we do not want to change the binary BAT format on disk and (2) aggr
and size are the most relevant aggregates.

It is all hacked into the aggr[3] records; three adjacent integers that
were left over in the column record. We refer to these as if it where an int aggr[3] array.
The below routines set and retrieve the aggregate values from the tail of the BAT, as many
aggregate-manipulating BAT functions work on tail.

The rules are as follows: aggr[0] contains the alignment ID of the column (if set i.e. nonzero).
Hence, if this value is nonzero and equal to b->talign, the precomputed aggregate values in
aggr[GDK_AGGR_SIZE] and aggr[GDK_AGGR_CARD] hold. However, only one of them may be set
at the time. This is encoded by the value int_nil, which cannot occur in these two aggregates.

This was now extended to record the property whether we know there is a nil value present
by mis-using the highest bits of both GDK_AGGR_SIZE and GDK_AGGR_CARD.
@{
@c
#define GDK_NIL_BIT 0x80000000	/* (1 << 31) */

void
PROPdestroy(PROPrec *p)
{
	PROPrec *n;

	while (p) {
		n = p->next;
		if (p->v.vtype == TYPE_str)
			GDKfree(p->v.val.sval);
		GDKfree(p);
		p = n;
	}
}

PROPrec *
BATgetprop(BAT *b, int idx)
{
	PROPrec *p = b->T->props;

	while (p) {
		if (p->id == idx)
			return p;
		p = p->next;
	}
	return NULL;
}

bit
BATgetprop_bit(BAT *b, int idx)
{
	PROPrec *p = BATgetprop(b, idx);

	return (p) ? p->v.val.cval[0] : bit_nil;
}

int
BATgetprop_int(BAT *b, int idx)
{
	PROPrec *p = BATgetprop(b, idx);

	return (p) ? p->v.val.ival : int_nil;
}

wrd
BATgetprop_wrd(BAT *b, int idx)
{
	PROPrec *p = BATgetprop(b, idx);

	return (p) ? p->v.val.wval : wrd_nil;
}

const char *
BATgetprop_str(BAT *b, int idx)
{
	PROPrec *p = BATgetprop(b, idx);

	return (p) ? p->v.val.pval : str_nil;
}

void
BATsetprop(BAT *b, int idx, int type, void *v)
{
	ValRecord vr;
	PROPrec *p = BATgetprop(b, idx);

	if (!p && (p = (PROPrec *) GDKmalloc(sizeof(PROPrec))) != NULL) {
		p->id = idx;
		p->next = b->T->props;
		p->v.vtype = 0;
		b->T->props = p;
	}
	if (p) {
		VALset(&vr, type, v);
		VALcopy(&p->v, &vr);
		b->batDirtydesc = TRUE;
	}
}

void
BATsetprop_bit(BAT *b, int idx, bit val)
{
	BATsetprop(b, idx, TYPE_bit, &val);
}

void
BATsetprop_int(BAT *b, int idx, int val)
{
	BATsetprop(b, idx, TYPE_int, &val);
}

void
BATsetprop_wrd(BAT *b, int idx, wrd val)
{
	BATsetprop(b, idx, TYPE_wrd, &val);
}

void
BATsetprop_str(BAT *b, int idx, str val)
{
	BATsetprop(b, idx, TYPE_str, val);
}

void
BATpropagate(BAT *dst, BAT *src, int idx)
{
	PROPrec *p = BATgetprop(src, idx);

	if (p)
		BATsetprop(dst, idx, p->v.vtype, VALget(&p->v));
}


@}
@-
The @%BAThistogram@ function calculates the frequency distribution of the
tail values in its operand bat. Notice, that updates on the result do
not affect the delta administration.
Construction of a histogram over a string (or complex object)
can be sped up using the reference information in the BUN
and bulk copying the heap.

There are separate versions for each type, and for each a
hash- and a merge-algorithms.
@{
@= histoloop_inner
	if (b->tkey) {
		yy = 1;
		BATloop(b, p, q)
			bunfastins(bn, BUNt@1(bi, p), &yy);
	} else if (!(BATtordered(b) & 1)) {
		BATiter bni = bat_iterator(bn);

		BATloop(b, p, q) {
			ptr v =  (ptr) BUNt@1(bi, p);

			if (BATprepareHash(bn))
				goto bunins_failed;
			HASHloop@2(bni, bn->H->hash, r, v)
				goto found@3@2;
			if (BUNins(bn, v, &yy, FALSE) == NULL)
				goto bunins_failed;
			r = BUNlast(bn) - 1;
found@3@2:		(* (int *) BUNtloc(bni, r))++;
		}
		HASHdestroy(bn);
	} else if (BATcount(b)) {
		ptr prev = (ptr) BUNt@1(bi, BUNfirst(b));

		BATloop(b, p, q) {
			ptr v = (ptr) BUNt@1(bi, p);

			if (@3_CMP(v, prev, @4) == 0) {
				yy++;
			} else {
				bunfastins(bn, prev, &yy);
				yy = 1;
			}
			prev = v;
		}
		bunfastins(bn, prev, &yy);
	}
@= histoloop
{
	BUN r;
	int yy = 0, tt = 0;
	BUN p, q;
	BATiter bi = bat_iterator(b);

	switch (ATOMstorage(tt=bn->htype)) {
#ifndef NOEXPAND_CHR
	case TYPE_chr:
		@:histoloop_inner(loc,_chr,simple,chr)@
		break;
#endif
#ifndef NOEXPAND_BTE
	case TYPE_bte:
		@:histoloop_inner(loc,_bte,simple,bte)@
		break;
#endif
#ifndef NOEXPAND_SHT
	case TYPE_sht:
		@:histoloop_inner(loc,_sht,simple,sht)@
		break;
#endif
#if !defined(NOEXPAND_INT) || !defined(NOEXPAND_FLT)
	case TYPE_int:
	case TYPE_flt:
		@:histoloop_inner(loc,_int,simple,int)@
		break;
#endif
#if !defined(NOEXPAND_LNG) || !defined(NOEXPAND_DBL)
	case TYPE_lng:
	case TYPE_dbl:
		@:histoloop_inner(loc,_lng,simple,lng)@
		break;
#endif
	case TYPE_str:
		if (b->T->vheap->hashash) {
			@:histoloop_inner(var,_str_hv,atom,tt)@
			break;
		}
		/* fall through */
	default:
		if (bn->hvarsized) {
			@:histoloop_inner(var,var,atom,tt)@
		} else {
			@:histoloop_inner(loc,loc,atom,tt)@
		}
		break;
	}
}
@c
BAT *
BAThistogram(BAT *b)
{
	BAT *bn;
	int tricky = 0;

	BATcheck(b, "BAThistogram");

	tricky = (b->ttype == TYPE_str && strElimDoubles(b->T->vheap));
	if (b->talign == 0) {
		b->talign = OIDnew(1);
	}
	bn = BATnew(tricky ? (b->T->width == 1 ? TYPE_bte : (b->T->width == 2 ? TYPE_sht : (b->T->width == 4 ? TYPE_int : TYPE_lng))) : b->ttype, TYPE_int, 200);
	if (bn == NULL) {
		return bn;
	}

	@:histoloop()@
@-
And now correct the interpretation of the values encountered
by bulk copying the heap as well
@c
	if (tricky) {
		bn->H->vheap = (Heap *) GDKzalloc(sizeof(Heap));
		if (bn->H->vheap == NULL)
			goto bunins_failed;
		bn->H->vheap->parentid = bn->batCacheid;
		if (b->T->vheap->filename) {
			char *nme = BBP_physical(bn->batCacheid);

			bn->H->vheap->filename = (str) GDKmalloc(strlen(nme) + 12);
			if (bn->H->vheap->filename == NULL)
				goto bunins_failed;
			GDKfilepath(bn->H->vheap->filename, NULL, nme, "hheap");
		}
		if (HEAPcopy(bn->H->vheap, b->T->vheap) < 0)
			goto bunins_failed;
		bn->htype = b->ttype;
		bn->hvarsized = 1;
		bn->H->width = b->T->width;
		bn->H->shift = b->T->shift;
	}
	bn->hsorted = (BATcount(bn) < 2 ? GDK_SORTED : BATtordered(b));
	bn->tsorted = (BATcount(bn) < 2 ? GDK_SORTED : FALSE);
	bn->halign = NOID_AGGR(b->talign);
	if (BATcount(bn) == BATcount(b))
		ALIGNsetH(bn, BATmirror(b));
	BATkey(bn, TRUE);
	BATkey(BATmirror(bn), BATcount(bn) < 2);
	bn->H->nonil = b->T->nonil;
	if (b->ttype == TYPE_bit) {
		BATiter bni = bat_iterator(bn);
		bit trueval = TRUE;
		BUN p = BUNfnd(bn, &trueval);

		BATsetprop_wrd(b, GDK_AGGR_SIZE, (p != BUN_NONE) ? *(int *) BUNtloc(bni, p) : 0);
	}
	BATsetprop_wrd(b, GDK_AGGR_CARD, (wrd) BATcount(bn));
	return bn;
      bunins_failed:
	BBPreclaim(bn);
	return NULL;
}

@-
The @%BATcount_no_nil@ function counts all BUN in a BAT that have a non-nil tail value.
@= cntloop
	BATloop(b, p, q) {
		if (!@1_EQ(nil, BUNt@2(bi, p),@3)) {
			cnt++;
		}
	}
@c
BUN
BATcount_no_nil(BAT *b)
{
	BUN cnt = 0;
	BUN p, q;
	BUN tt;
	ptr nil;
	BATiter bi = bat_iterator(b);

	BATcheck(b, "BATcnt");
	if (b->T->nonil) {
		return BATcount(b);
	}
	tt = b->ttype;
	nil = ATOMnilptr(tt);
	switch (ATOMstorage(tt)) {
#ifndef NOEXPAND_CHR
	case TYPE_chr:
		@:cntloop(simple,loc,chr)@
		break;
#endif
#ifndef NOEXPAND_BTE
	case TYPE_bte:
		@:cntloop(simple,loc,bte)@
		break;
#endif
#ifndef NOEXPAND_SHT
	case TYPE_sht:
		@:cntloop(simple,loc,sht)@
		break;
#endif
#ifndef NOEXPAND_INT
	case TYPE_int:
		@:cntloop(simple,loc,int)@
		break;
#endif
#ifndef NOEXPAND_FLT
	case TYPE_flt:
		@:cntloop(simple,loc,flt)@
		break;
#endif
#ifndef NOEXPAND_LNG
	case TYPE_lng:
		@:cntloop(simple,loc,lng)@
		break;
#endif
#ifndef NOEXPAND_DBL
	case TYPE_dbl:
		@:cntloop(simple,loc,dbl)@
		break;
#endif
	default:
		if (b->tvarsized) {
			@:cntloop(atom,var,tt)@
		} else {
			@:cntloop(atom,loc,tt)@
		}
		break;
	}
	return cnt;
}

@}
