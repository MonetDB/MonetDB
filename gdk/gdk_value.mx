@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2011 MonetDB B.V.
All Rights Reserved.
@

@f gdk_value
@a Martin L. Kersten & Peter Boncz
@v 2.0
@+ Value representation


When manipulating values, MonetDB puts them into value records.
The built-in types have a direct entry in the union. Others should
be represented as a pointer of memory in pval or as a string, which
is basically the same. In such cases the @%len@ field indicates
the size of this piece of memory.

MonetDB extenders will use value records for passing parameters to
their new operators. MonetDB algebraic commands receive an
(argc, argv) combination, where
argc is an integer indicating the size of the the argv array of value
records. On call, the first record, argv[0], is always empty. The
routine must place its return value - if any - there. The other
values are the parameters.

@{
Actually, the gdk value type defined here should become a built-in
type in the kernel. Next step will be to define the corresponding
extension module.
@}

@{
@+ Value operations
The following primitives are required to manipulate value records.
Note that binding a BAT requires upgrading its reference count.
The receiver of the value should have been cleared or represent
free space.
@c
#include "monetdb_config.h"
#include "gdk.h"
#include "gdk_private.h"

ValPtr
VALset(ValPtr v, int t, ptr p)
{
	switch (ATOMstorage(v->vtype = t)) {
	case TYPE_chr:
		v->val.cval[0] = *(chr *) p;
		v->val.cval[1] = 0;
		v->val.cval[2] = 0;
		v->val.cval[3] = 0;
		break;
	case TYPE_bte:
		v->val.btval = *(bte *) p;
		break;
	case TYPE_sht:
		v->val.shval = *(sht *) p;
		break;
	case TYPE_int:
		v->val.ival = *(int *) p;
		break;
	case TYPE_flt:
		v->val.fval = *(flt *) p;
		break;
	case TYPE_dbl:
		v->val.dval = *(dbl *) p;
		break;
	case TYPE_lng:
		v->val.lval = *(lng *) p;
		break;
	case TYPE_str:
		v->val.sval = (str) p;
		v->len = ATOMlen(t, p);
		break;
	case TYPE_ptr:
		v->val.pval = *(ptr *) p;
		v->len = ATOMlen(t, *(ptr *) p);
		break;
	default:
		v->val.pval = p;
		v->len = ATOMlen(t, p);
		break;
	}
	return v;
}

void *
VALget(ValPtr v)
{
	switch (ATOMstorage(v->vtype)) {
	case TYPE_chr:
		return (void *) &v->val.cval[0];
	case TYPE_bte:
		return (void *) &v->val.btval;
	case TYPE_sht:
		return (void *) &v->val.shval;
	case TYPE_void:
	case TYPE_int:
		return (void *) &v->val.ival;
	case TYPE_flt:
		return (void *) &v->val.fval;
	case TYPE_dbl:
		return (void *) &v->val.dval;
	case TYPE_lng:
		return (void *) &v->val.lval;
	case TYPE_str:
		return (void *) v->val.pval;
	}
	return NULL;
}

void
VALclear(ValPtr v)
{
	if (v->vtype == TYPE_str || ATOMextern(v->vtype)) {
		if (v->val.pval && v->val.pval != str_nil)
			GDKfree(v->val.pval);
	}
	VALempty(v);
}

void
VALempty(ValPtr v)
{
	v->len = 0;
	v->val.oval = oid_nil;
	v->vtype = TYPE_void;
}

ValPtr
VALcopy(ValPtr d, ValPtr s)
{
	if (!ATOMextern(s->vtype)) {
		*d = *s;
	} else if (s->val.pval == 0) {
		d->val.pval = ATOMnil(s->vtype);
		d->vtype = s->vtype;
	} else if (s->vtype == TYPE_str) {
		d->vtype = TYPE_str;
		d->val.sval = GDKstrdup(s->val.sval);
		d->len = strLen(d->val.sval);
	} else if (s->vtype == TYPE_bit) {
		d->vtype = s->vtype;
		d->len = 1;
		d->val.cval[0] = s->val.cval[0];
	} else {
		ptr p = s->val.pval;

		d->vtype = s->vtype;
		d->len = ATOMlen(d->vtype, p);
		d->val.pval = GDKmalloc(d->len);
		memcpy(d->val.pval, p, d->len);
	}
	return d;
}

ValPtr
VALinit(ValPtr d, int tpe, ptr s)
{
	if (ATOMextern(tpe) == 0) {
		d->vtype = tpe;
		memcpy(&d->val.ival, s, ATOMlen(tpe, s));
	} else if (s == 0) {
		GDKerror("VALinit:unsupported init\n");
		d->vtype = TYPE_int;
	} else if (tpe >= TYPE_str && ATOMstorage(tpe) == TYPE_str) {
		d->vtype = TYPE_str;
		d->val.sval = GDKstrdup(s);
		d->len = strLen(s);
	} else {
		d->vtype = tpe;
		d->len = ATOMlen(tpe, s);
		d->val.pval = GDKmalloc(d->len);
		memcpy(d->val.pval, s, d->len);
	}
	return d;
}

@-
VALprint shows the contents of a value record, but without
expanding the BAT contents.
@c
int
VALprint(stream *s, ValPtr res)
{
	int t = ATOMstorage(res->vtype);

	return ATOMprint(t, VALptr(res), s);
}


int
VALformat(char **buf, ValPtr res)
{
	int t = res->vtype;

	*buf = 0;
	return ATOMformat(t, VALptr(res), buf);
}

@-
The routine @%VALconvert@ transforms a value for interpretation
in a certain type. It uses some standard cast conventions to do this.
The result, a pointer to a value, is returned. If there are
illegal values, or type combinations involved, it gives
up with an ILLEGALVALUE.

@= valcheck
	((@3) @1 < (@3) GDK_@2_min || (@3) @1 > (@3) GDK_@2_max) ? @2_nil : (@2) @1
@= valcheck_r
	/* when converting from oid, there's no need to compare to GDK_@2_min,
	 * since source value is unsigned (i.e. >= 0) and all GDK_*_min values
	 * are <= 0 (in fact, compilers may warn about the test) */
	((@3) @1 > (@3) GDK_@2_max) ? @2_nil : (@2) @1
@= valcheck_l
	/* when converting to oid, there's no need to compare to GDK_@2_max
	 * for those types, where we know that GDK_@2_max <= GDK_oid_max
	 * (in fact, compilers may warn about the test) */
	((@3) @1 < (@3) GDK_@2_min) ? @2_nil : (@2) @1
@= valfconvert
	/* dbl always fits; flt almost always fits */
	switch (src_tpe) {
	case TYPE_bit:
	case TYPE_chr:
		@1 = (@2) src->val.cval[0];
		break;
	case TYPE_bte:
		@1 = (@2) src->val.btval;
		break;
	case TYPE_sht:
		@1 = (@2) src->val.shval;
		break;
	case TYPE_int:
		@1 = (@2) src->val.ival;
		break;
	case TYPE_oid:
		@1 = (@2) src->val.oval;
		break;
	case TYPE_wrd:
		@1 = (@2) src->val.wval;
		break;
	case TYPE_lng:
		@1 = (@2) src->val.lval;
		break;
	case TYPE_flt:
		@1 = (@2) src->val.fval;
		break;
	case TYPE_dbl:
		/* only need to do range check on dbl for dbl->flt conversion */
		if (src->val.dval < (dbl) GDK_@2_min || src->val.dval > (dbl) GDK_@2_max)
			@1 = @2_nil;
		else
			@1 = (@2) src->val.dval;
		break;
	case TYPE_bat:
		@1 = (@2) src->val.bval;
		break;
	}
@c
/* convert value in src and store in dst
   does not destroy src, but src and dst are allowed to point to the
   same location if the caller knows that that won't do any harm */
static ptr
VALconvert1(int typ, ValPtr src, ValPtr dst)
{
	int orig_src_tpe = src->vtype, src_tpe = src->vtype, dst_tpe = typ;
	ptr p;			/* what's going to be returned (may change for BATs */

	/* use base types for user types */
	if (src_tpe > TYPE_str)
		src_tpe = ATOMstorage(src_tpe);
	if (dst_tpe > TYPE_str)
		dst_tpe = ATOMstorage(dst_tpe);

	if (src != dst)
		*dst = *src;	/* copy already in case there is no conversion */

	/* we saved the original value of src->vtype, so we can
	   overwrite that (in case src==dst */
	dst->vtype = typ;
	p = VALptr(dst);

	if (src_tpe != dst_tpe && orig_src_tpe != typ && dst_tpe != TYPE_void) {
		if (src_tpe >= TYPE_str || dst_tpe >= TYPE_str) {
			if (ATOMcmp(src_tpe, ATOMnilptr(src_tpe), VALptr(src)) == 0) {
				VALset(dst, dst_tpe, ATOMnil(dst_tpe));
			} else {
				return ILLEGALVALUE;
			}
		} else if ((orig_src_tpe == TYPE_bat && src->val.bval == 0) ||
			   ATOMcmp(src_tpe, ATOMnilptr(src_tpe), VALptr(src)) == 0) {
			/* dst_tpe is a built-in type, so VALptr(dst)
			   (p) points to valid memory */
			memcpy(p, ATOMnilptr(dst_tpe), ATOMsize(dst_tpe));
		} else {
			switch (dst_tpe) {
			case TYPE_bat:
			{
				bat bid = (bat) 0;

				switch (src_tpe) {
				case TYPE_bit:
				case TYPE_chr:
					if (ABS(src->val.cval[0]) <= BBPsize)
						bid = (bat) src->val.cval[0];
					break;
				case TYPE_bte:
					if (ABS(src->val.btval) <= BBPsize)
						bid = (bat) src->val.btval;
					break;
				case TYPE_sht:
					if (ABS(src->val.shval) <= BBPsize)
						bid = (bat) src->val.shval;
					break;
				case TYPE_int:
					if (ABS(src->val.ival) <= BBPsize)
						bid = (bat) src->val.ival;
					break;
				case TYPE_oid:
					if (ABS(src->val.oval) <= BBPsize)
						bid = (bat) src->val.oval;
					break;
				case TYPE_wrd:
					if (ABS(src->val.wval) <= BBPsize)
						bid = (bat) src->val.wval;
					break;
				case TYPE_lng:
					if (ABS(src->val.lval) <= BBPsize)
						bid = (bat) src->val.lval;
					break;
				case TYPE_flt:
					if (ABS(src->val.fval) <= BBPsize)
						bid = (bat) src->val.fval;
					break;
				case TYPE_dbl:
					if (ABS(src->val.dval) <= BBPsize)
						bid = (bat) src->val.dval;
					break;
				}
				if (bid == 0 || !BBPvalid(bid)) {
					return ILLEGALVALUE;
				}
				dst->val.bval = bid;
				p = &dst->val.bval;
				break;
			}
			case TYPE_bit:
				/* bits are funny: true iff value != 0 */
				switch (src_tpe) {
				case TYPE_bit:
				case TYPE_chr:
					dst->val.cval[0] = (src->val.cval[0] != 0);
					break;
				case TYPE_bte:
					dst->val.cval[0] = (src->val.btval != 0);
					break;
				case TYPE_sht:
					dst->val.cval[0] = (src->val.shval != 0);
					break;
				case TYPE_int:
					dst->val.cval[0] = (src->val.ival != 0);
					break;
				case TYPE_bat:
					dst->val.cval[0] = (src->val.bval != 0);
					break;
				case TYPE_oid:
					dst->val.cval[0] = (src->val.oval != 0);
					break;
				case TYPE_wrd:
					dst->val.cval[0] = (src->val.wval != 0);
					break;
				case TYPE_lng:
					dst->val.cval[0] = (src->val.lval != 0);
					break;
				case TYPE_flt:
					dst->val.cval[0] = (src->val.fval != 0);
					break;
				case TYPE_dbl:
					dst->val.cval[0] = (src->val.dval != 0);
					break;
				}
				break;
			case TYPE_chr:
				switch (src_tpe) {
				case TYPE_bit:
				case TYPE_chr:
					dst->val.cval[0] = (chr) src->val.cval[0];
					break;
				case TYPE_bte:
					dst->val.cval[0] = (chr) src->val.btval;
					break;
				case TYPE_sht:
					dst->val.cval[0] = @:valcheck(src->val.shval,chr,lng)@;
					break;
				case TYPE_int:
					dst->val.cval[0] = @:valcheck(src->val.ival,chr,lng)@;
					break;
				case TYPE_bat:
					dst->val.cval[0] = @:valcheck(src->val.bval,chr,lng)@;
					break;
				case TYPE_oid:
					dst->val.cval[0] = @:valcheck_r(src->val.oval,chr,lng)@;
					break;
				case TYPE_wrd:
					dst->val.cval[0] = @:valcheck(src->val.wval,chr,lng)@;
					break;
				case TYPE_lng:
					dst->val.cval[0] = @:valcheck(src->val.lval,chr,lng)@;
					break;
				case TYPE_flt:
					dst->val.cval[0] = @:valcheck(src->val.fval,chr,dbl)@;
					break;
				case TYPE_dbl:
					dst->val.cval[0] = @:valcheck(src->val.dval,chr,dbl)@;
					break;
				}
				break;
			case TYPE_bte:
				switch (src_tpe) {
				case TYPE_bit:
				case TYPE_chr:
					dst->val.btval = (bte) src->val.cval[0];
					break;
				case TYPE_bte:
					dst->val.btval = (bte) src->val.btval;
					break;
				case TYPE_sht:
					dst->val.btval = @:valcheck(src->val.shval,bte,lng)@;
					break;
				case TYPE_int:
					dst->val.btval = @:valcheck(src->val.ival,bte,lng)@;
					break;
				case TYPE_bat:
					dst->val.btval = @:valcheck(src->val.bval,bte,lng)@;
					break;
				case TYPE_oid:
					dst->val.btval = @:valcheck_r(src->val.oval,bte,lng)@;
					break;
				case TYPE_wrd:
					dst->val.btval = @:valcheck(src->val.wval,bte,lng)@;
					break;
				case TYPE_lng:
					dst->val.btval = @:valcheck(src->val.lval,bte,lng)@;
					break;
				case TYPE_flt:
					dst->val.btval = @:valcheck(src->val.fval,bte,dbl)@;
					break;
				case TYPE_dbl:
					dst->val.btval = @:valcheck(src->val.dval,bte,dbl)@;
					break;
				}
				break;
			case TYPE_sht:
				switch (src_tpe) {
				case TYPE_bit:
				case TYPE_chr:
					dst->val.shval = (sht) src->val.cval[0];
					break;
				case TYPE_bte:
					dst->val.shval = (sht) src->val.btval;
					break;
				case TYPE_sht:
					dst->val.shval = (sht) src->val.shval;
					break;
				case TYPE_int:
					dst->val.shval = @:valcheck(src->val.ival,sht,lng)@;
					break;
				case TYPE_bat:
					dst->val.shval = @:valcheck(src->val.bval,sht,lng)@;
					break;
				case TYPE_oid:
					dst->val.shval = @:valcheck_r(src->val.oval,sht,lng)@;
					break;
				case TYPE_wrd:
					dst->val.shval = @:valcheck(src->val.wval,sht,lng)@;
					break;
				case TYPE_lng:
					dst->val.shval = @:valcheck(src->val.lval,sht,lng)@;
					break;
				case TYPE_flt:
					dst->val.shval = @:valcheck(src->val.fval,sht,dbl)@;
					break;
				case TYPE_dbl:
					dst->val.shval = @:valcheck(src->val.dval,sht,dbl)@;
					break;
				}
				break;
			case TYPE_int:
				switch (src_tpe) {
				case TYPE_bit:
				case TYPE_chr:
					dst->val.ival = (int) src->val.cval[0];
					break;
				case TYPE_bte:
					dst->val.ival = (int) src->val.btval;
					break;
				case TYPE_sht:
					dst->val.ival = (int) src->val.shval;
					break;
				case TYPE_int:
					dst->val.ival = (int) src->val.ival;
					break;
				case TYPE_bat:
					dst->val.ival = (int) src->val.bval;
					break;
				case TYPE_oid:
					dst->val.ival = @:valcheck_r(src->val.oval,int,lng)@;
					break;
				case TYPE_wrd:
#if SIZEOF_WRD == SIZEOF_INT
					dst->val.ival = (int) src->val.wval;
#else
					dst->val.ival = @:valcheck(src->val.wval,int,lng)@;
#endif
					break;
				case TYPE_lng:
					dst->val.ival = @:valcheck(src->val.lval,int,lng)@;
					break;
				case TYPE_flt:
					dst->val.ival = @:valcheck(src->val.fval,int,dbl)@;
					break;
				case TYPE_dbl:
					dst->val.ival = @:valcheck(src->val.dval,int,dbl)@;
					break;
				}
				break;
			case TYPE_oid:
				switch (src_tpe) {
				case TYPE_bit:
				case TYPE_chr:
					dst->val.oval = @:valcheck_l(src->val.cval[0],oid,lng)@;
					break;
				case TYPE_bte:
					dst->val.oval = @:valcheck_l(src->val.btval,oid,lng)@;
					break;
				case TYPE_sht:
					dst->val.oval = @:valcheck_l(src->val.shval,oid,lng)@;
					break;
				case TYPE_int:
					dst->val.oval = @:valcheck_l(src->val.ival,oid,lng)@;
					break;
				case TYPE_bat:
					dst->val.oval = @:valcheck_l(src->val.bval,oid,lng)@;
					break;
				case TYPE_oid:
					dst->val.oval = (oid) src->val.oval;
					break;
				case TYPE_wrd:
#if SIZEOF_WRD == SIZEOF_OID
					dst->val.oval = @:valcheck_l(src->val.wval,oid,lng)@;
#else
					dst->val.oval = @:valcheck(src->val.wval,oid,lng)@;
#endif
					break;
				case TYPE_lng:
					dst->val.oval = @:valcheck(src->val.lval,oid,lng)@;
					break;
				case TYPE_flt:
					dst->val.oval = @:valcheck(src->val.fval,oid,dbl)@;
					break;
				case TYPE_dbl:
					dst->val.oval = @:valcheck(src->val.dval,oid,dbl)@;
					break;
				}
				break;
			case TYPE_wrd:
				switch (src_tpe) {
				case TYPE_bit:
				case TYPE_chr:
					dst->val.wval = (wrd) src->val.cval[0];
					break;
				case TYPE_bte:
					dst->val.wval = (wrd) src->val.btval;
					break;
				case TYPE_sht:
					dst->val.wval = (wrd) src->val.shval;
					break;
				case TYPE_int:
					dst->val.wval = (wrd) src->val.ival;
					break;
				case TYPE_bat:
					dst->val.wval = (wrd) src->val.bval;
					break;
				case TYPE_oid:
					dst->val.wval = (wrd) src->val.oval;
					break;
				case TYPE_wrd:
					dst->val.wval = (wrd) src->val.wval;
					break;
				case TYPE_lng:
#if SIZEOF_LNG == SIZEOF_WRD
					dst->val.wval = (wrd) src->val.lval;
#else
					dst->val.wval = @:valcheck(src->val.lval,wrd,lng)@;
#endif
					break;
				case TYPE_flt:
					dst->val.wval = @:valcheck(src->val.fval,wrd,dbl)@;
					break;
				case TYPE_dbl:
					dst->val.wval = @:valcheck(src->val.dval,wrd,dbl)@;
					break;
				}
				break;
			case TYPE_lng:
				switch (src_tpe) {
				case TYPE_bit:
				case TYPE_chr:
					dst->val.lval = (lng) src->val.cval[0];
					break;
				case TYPE_sht:
					dst->val.lval = (lng) src->val.shval;
					break;
				case TYPE_bte:
					dst->val.lval = (lng) src->val.btval;
					break;
				case TYPE_int:
					dst->val.lval = (lng) src->val.ival;
					break;
				case TYPE_bat:
					dst->val.lval = (lng) src->val.bval;
					break;
				case TYPE_oid:
					dst->val.lval = (lng) src->val.oval;
					break;
				case TYPE_wrd:
					dst->val.lval = (lng) src->val.wval;
					break;
				case TYPE_lng:
					dst->val.lval = (lng) src->val.lval;
					break;
				case TYPE_flt:
					dst->val.lval = @:valcheck(src->val.fval,lng,dbl)@;
					break;
				case TYPE_dbl:
					dst->val.lval = @:valcheck(src->val.dval,lng,dbl)@;
					break;
				}
				break;
			case TYPE_flt:
				@:valfconvert(dst->val.fval,flt)@
				break;
			case TYPE_dbl:
				@:valfconvert(dst->val.dval,dbl)@
				break;
			}
		}
	}
	return p;
}

ptr
VALconvert(int typ, ValPtr t)
{
	int src_tpe = t->vtype, dst_tpe = typ;
	ptr p;
	ValRecord dst;

	/* use base types for user types */
	if (src_tpe > TYPE_str)
		src_tpe = ATOMstorage(src_tpe);
	if (dst_tpe > TYPE_str)
		dst_tpe = ATOMstorage(dst_tpe);

	/* first convert into a new location */
	p = VALconvert1(typ, t, &dst);
	/* then maybe free the old */
	if (src_tpe != dst_tpe &&
	    t->vtype != typ &&
	    dst_tpe != TYPE_void &&
	    (src_tpe >= TYPE_str || dst_tpe >= TYPE_str))
		VALclear(t);
	/* and finally copy the result */
	*t = dst;
	/* make sure we return the correct type (not the storage type) */
	t->vtype = typ;
	return p == ILLEGALVALUE ? p : VALptr(t);
}

int
VALcmp(ValPtr p, ValPtr q)
{

	int (*cmp) (ptr, ptr);
	int tpe;
	ptr nilptr, pp, pq;

	if (p == 0 || q == 0)
		return -1;
	if ((tpe = p->vtype) != q->vtype)
		return -1;

	if (tpe == TYPE_ptr)
		return 0;	/* ignore comparing C pointers */
	cmp = BATatoms[tpe].atomCmp;
	nilptr = ATOMnilptr(tpe);
	pp = VALget(p);
	pq = VALget(q);
	if (((*cmp) (pp, nilptr) == 0) && ((*cmp) (pq, nilptr) == 0))
		return 0;	/* eq nil val */
	if (((*cmp) (pp, nilptr) == 0) || ((*cmp) (pq, nilptr) == 0))
		return -1;
	return ((*cmp) (pp, pq));

}

@}
@
