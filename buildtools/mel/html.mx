@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2007 CWI.
@' All Rights Reserved.

@f html
@a Niels Nes

@h
#ifndef _HTML_H_
#define _HTML_H_

#include "language.h"

class html:public language {
      public:
	const char *get_name() const {
		return "html";
	}
	int generate_code(ostream & o, Symbol *root);

	ostream & gen_module(ostream & o, const Module & m);
	ostream & gen_dependency(ostream & o, const Dependency & m);
	ostream & gen_atom(ostream & o, const Atom & m);
	ostream & gen_atomops(ostream & o, const Atomops & m);
	ostream & gen_command(ostream & o, const Command & m);
	ostream & gen_operator(ostream & o, const Operator & m);
	ostream & gen_builtin(ostream & o, const Builtin & m);
	ostream & gen_iterator(ostream & o, const Iterator & m);
	ostream & gen_atom_arg(ostream & o, const AtomArg & m);
	ostream & gen_type_arg(ostream & o, const TypeArg & m);
	ostream & gen_var_arg(ostream & o, const VarArg & m);
	ostream & gen_bat_arg(ostream & o, const BatArg & m);
	ostream & gen_any_arg(ostream & o, const AnyArg & m);
	ostream & gen_prelude(ostream & o, const Prelude & m);
	ostream & gen_epilogue(ostream & o, const Epilogue & m);
      private:
	int result;
};

#endif //_HTML_H_

@C
#include <mel_config.h>
#include "html.h"
#include "ListIterator.h"

int
html::generate_code(ostream &o, Symbol *root)
{
	root->print(this, o);
	return 0;
}


ostream &
html::gen_module(ostream &o, const Module &d)
{

	o << "<html>\n";
	o << "<head>\n";
	o << "<!\n";
	o << " ! This module is generated using the mel -html utility\n";
	o << " !>\n";

	o << "<title> The" << d.Name() << " Module </title>\n";
	o << "</head>\n";

	o << "<body>\n";
	o << "<h1>The " << d.Name() << " Module </h1>\n";
	o << "<h3>Dependencies </h3>\n";
	o << "<ul>\n";
	if (d.Deps()) {
		ListIterator *iter = d.Deps()->iterator();
		Symbol *s = NULL;

		while (iter->next((void **)&s)) {
			s->print(this, o);
		}
	}
	o << "</ul>\n";
	o << "<h3>Definitions </h3>\n";
	o << "<ul>\n";
	if (d.Defs()) {
		ListIterator *iter = d.Defs()->iterator();
		Symbol *s = NULL;

		while (iter->next((void **)&s)) {
			s->print(this, o);
		}
	}
	o << "</ul>\n";
	o << "</body>\n";
	o << "</html>\n";
	return o;
}

ostream &
html::gen_dependency(ostream &o, const Dependency &d)
{
	o << " <li><a href=" << d.Name() << ".html> " << d.Name() << " </a>\n";
	return o;
}

ostream &
html::gen_atom(ostream &o, const Atom &d)
{
	o << " <li> Atom " << d.Name() << "\n";
	if (d.parent())
		o << " Parent = " << d.parent()->Name() << "\n";
	else {
		o << " Size   = " << d.size() << "\n";
		o << " Align  = " << d.align() << "\n";
	}

	o << "<h4>Commands </h4>\n";
	o << "<ul>\n";
	if (d.cmds()) {
		Ops **cmds = d.cmds();

		for (int i = OP_FIX; i <= OP_NEQUAL; i++) {
			Ops *s = cmds[i];

			if (s)
				s->print(this, o);
		}
	}
	o << "</ul>\n";
	return o;
}

ostream &
html::gen_atomops(ostream &o, const Atomops &d)
{
	o << "<li>";
	switch (d.operation()) {
	case OP_FIX:
		o << "FIX     = " << d.Name() << ";\n";
		break;
	case OP_UNFIX:
		o << "UNFIX   = " << d.Name() << ";\n";
		break;
	case OP_TOSTR:
		o << "TOSTR   = " << d.Name() << ";\n";
		break;
	case OP_FROMSTR:
		o << "FROMSTR = " << d.Name() << ";\n";
		break;
	case OP_READ:
		o << "READ    = " << d.Name() << ";\n";
		break;
	case OP_WRITE:
		o << "WRITE   = " << d.Name() << ";\n";
		break;
	case OP_COMP:
		o << "COMP    = " << d.Name() << ";\n";
		break;
	case OP_CONVERT:
		o << "CONVERT = " << d.Name() << ";\n";
		break;
	case OP_NEQUAL:
		o << "NEQUAL  = " << d.Name() << ";\n";
		break;
	case OP_DEL:
		o << "DEL     = " << d.Name() << ";\n";
		break;
	case OP_HASH:
		o << "HASH    = " << d.Name() << ";\n";
		break;
	case OP_NULL:
		o << "NULL    = " << d.Name() << ";\n";
		break;
	case OP_PUT:
		o << "PUT     = " << d.Name() << ";\n";
		break;
	case OP_LEN:
		o << "LENGTH  = " << d.Name() << ";\n";
		break;
	case OP_HEAP:
		o << "HEAP    = " << d.Name() << ";\n";
		break;
	case OP_HCONVERT:
		o << "HEAPCONVERT= " << d.Name() << ";\n";
		break;
	}
	return o;
}

ostream &
html::gen_command(ostream &o, const Command &d)
{
	o << "<li> Command " << d.Name() << " implemented with " << d.fcn() << "\n";
	o << "<p> " << d.hlp() << "\n";
	o << "<ul>";
	if (d.result()) {
		d.result()->Name("result");
		d.result()->print(this, o);
	}
	if (d.args()) {
		ListIterator *iter = d.args()->iterator();
		Symbol *s = NULL;

		while (iter->next((void **)&s)) {
			s->print(this, o);
		}
	}
	o << "</ul>\n\n";
	return o;
}

ostream &
html::gen_operator(ostream &o, const Operator &d)
{
	o << "<li> Operator " << d.Name() << " implemented with " << d.fcn() << "\n";
	o << "<p> " << d.hlp() << "\n";
	o << "<ul>";
	if (d.result()) {
		d.result()->Name("res");
		d.result()->print(this, o);
	}
	d.op1()->print(this, o);
	if (d.op2()) {
		d.op2()->print(this, o);
	}
	o << "</ul>\n\n";
	return o;
}

ostream &
html::gen_builtin(ostream &o, const Builtin &d)
{
	o << "<li> Builtin " << d.Name() << " implemented with " << d.fcn() << "\n";
	o << "<p> " << d.hlp() << "\n";
	o << "\n\n";
	return o;
}

ostream &
html::gen_iterator(ostream &o, const Iterator &d)
{
	o << "<li> Iterator " << d.Name() << " implemented with " << d.fcn() << "\n";
	o << "<p> " << d.hlp() << "\n";
	o << "<ul>";
	if (d.args()) {
		ListIterator *iter = d.args()->iterator();
		Symbol *s = NULL;

		while (iter->next((void **)&s)) {
			s->print(this, o);
		}
	}
	o << "</ul>\n\n";
	return o;
}

ostream &
html::gen_atom_arg(ostream &o, const AtomArg &d)
{
	o << "<li> " << d.arg()->Name() << " " << d.Name();
	o << "\n";
	return o;
}

ostream &
html::gen_type_arg(ostream &o, const TypeArg &d)
{
	o << "<li> ";
	switch (d.type()) {
	case TYPE_BIT:
		o << "bit";
		break;
	case TYPE_CHR:
		o << "chr";
		break;
	case TYPE_BTE:
		o << "bte";
		break;
	case TYPE_SHT:
		o << "sht";
		break;
	case TYPE_INT:
		o << "int";
		break;
	case TYPE_PTR:
		o << "ptr";
		break;
	case TYPE_OID:
		o << "oid";
		break;
	case TYPE_WRD:
		o << "wrd";
		break;
	case TYPE_FLT:
		o << "flt";
		break;
	case TYPE_DBL:
		o << "dbl";
		break;
	case TYPE_LNG:
		o << "lng";
		break;
	case TYPE_STR:
		o << "chr";
		break;
	}
	o << " " << d.Name();
	o << "\n";
	return o;
}

ostream &
html::gen_var_arg(ostream &o, const VarArg &)
{
	o << "<li> " << "...";
	o << "\n";
	return o;
}

ostream &
html::gen_bat_arg(ostream &o, const BatArg &d)
{
	o << "<li> BAT [";
	if (d.atom1()) {
		o << d.atom1()->Name();
		if (d.atom2())
			o << ", ";
	}
	if (d.atom2())
		o << d.atom2()->Name();
	o << "] " << d.Name();
	o << "\n";
	return o;
}

ostream &
html::gen_any_arg(ostream &o, const AnyArg &d)
{
	o << "<li> any";
	if (d.nr() > 0) {
		o << "::" << d.nr();
	}
	o << "\n";
	return o;
}

ostream &
html::gen_prelude(ostream &o, const Prelude &d)
{
	o << "<li> Prelude implemented with " << d.Name() << "\n";
	return o;
}

ostream &
html::gen_epilogue(ostream &o, const Epilogue &d)
{
	o << "<li> Epilogue implemented with " << d.Name() << "\n";
	return o;
}
