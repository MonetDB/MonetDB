@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2007 CWI.
@' All Rights Reserved.

@f link
@a Niels Nes

@h
#ifndef _LINK_H_
#define _LINK_H_

#include "language.h"
#include "list.h"
#include <string.h>

#ifdef NATIVE_WIN32
/* The POSIX name for this item is deprecated. Instead, use the ISO
   C++ conformant name: _strdup. See online help for details. */
#define strdup _strdup
#endif

class Link:public language {
      private:
	List *monet_mod_path;
      public:
	Link() {
		libsfx = strdup("");
	}
	const char *get_name() const {
		return "Link";
	}
	virtual int handle_args(int, char **);
	int generate_code(ostream &o, Symbol *root);

	ostream &gen_module(ostream &o, const Module &m);
	ostream &gen_dependency(ostream &o, const Dependency &m);

      public:
	char *libsfx;
};

#endif //_LINK_H_
@C
#include <mel_config.h>
#include "link.h"
#include "ListIterator.h"
#include <stdlib.h>

int
Link::handle_args(int argc, char **argv)
{
	int i = 0;

	while (i < argc) {
		if (argv[i][0] != '-') {
			cerr << "Unknown option " << argv[i] << "\n";
			return 0;
		}
		switch (argv[i][1]) {
		case 's':
			if (argv[i][2] == '\0') {
				i++;
				libsfx = strdup(argv[i]);
			} else {
				libsfx = strdup(argv[i] + 2);
			}
			break;
		default:
			cerr << "Unknown option " << argv[i] << "\n";
			return 0;
		}
		i++;
	}
	return 1;
}

int
Link::generate_code(ostream &o, Symbol *root)
{
	root->print(this, o);
	return 0;
}


ostream &
Link::gen_module(ostream &o, const Module &d)
{
	char *p, *q, *mod_path = getenv("MONETDB_MOD_PATH");
	monet_mod_path = new List (10);

	if (mod_path) {
		mod_path = strdup(mod_path);
		q = mod_path;
		while ((p = strchr(q, ':')) != NULL) {
			*p = '\0';
			monet_mod_path->insert(strdup(q));
			q = p + 1;
		}
		monet_mod_path->insert(strdup(q));
		delete(mod_path);
	}
	gen_list(o, d.Deps());
	return o;
}

static char *
basename(char *filename)
{
	char *p, *sep, *dot;

	for (p = filename, sep = NULL, dot = NULL; *p; p++) {
		if (*p == DIR_SEP
#ifdef WIN32
		    || *p == '/'
#endif
		    ) {
			sep = p;
			dot = NULL;
		} else if (*p == '.')
			dot = p;
	}
	if (sep)
		filename = sep + 1;
	if (dot)
		*dot = '\0';
	p = strdup(filename);
	if (dot)
		*dot = '.';
	return p;
}

static int
matchlen(char *dir, char *file)
{
	char *ds, *fs, *d, *f;
	int maxlen = 0;
	int len;

	for (ds = dir; *ds; ds++) {
		if (*ds != DIR_SEP
#ifdef WIN32
		    && *ds != '/'
#endif
		    )
			continue;
		for (fs = file; *fs; fs++) {
			if (*fs != DIR_SEP
#ifdef WIN32
			    && *fs != '/'
#endif
			    )
				continue;

			len = 0;
			for (d = ds, f = fs; *d && *f && *d == *f; d++, f++) {
				len++;
			}

			if (len > maxlen)
				maxlen = len;
		}
	}

	return maxlen;
}

ostream &
Link::gen_dependency(ostream &o, const Dependency &d)
{
	d.Module ()->print(this, o);
	char *bn = basename(d.filename());

	if (monet_mod_path) {
		char *ldir = NULL;
		int ldirlen = 0;
		ListIterator *li = monet_mod_path->iterator();
		char *dir;

		while (li->next((void **) &dir)) {
			int mlen = matchlen(dir, d.filename());

			if (mlen >= ldirlen) {
				ldirlen = mlen;
				if (ldir)
					delete(ldir);
				ldir = strdup(dir);
			}
		}
		o << ldir << "/lib_" << bn << "." << libsfx << " ";
	} else {
		o << "lib_" << bn << "." << libsfx << " ";
	}
	delete(bn);
	return o;
}
