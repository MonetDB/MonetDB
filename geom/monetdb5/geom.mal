# The contents of this file are subject to the MonetDB Public License
# Version 1.1 (the "License"); you may not use this file except in
# compliance with the License. You may obtain a copy of the License at
# http://www.monetdb.org/Legal/MonetDBLicense
#
# Software distributed under the License is distributed on an "AS IS"
# basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
# License for the specific language governing rights and limitations
# under the License.
#
# The Original Code is the MonetDB Database System.
#
# The Initial Developer of the Original Code is CWI.
# Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
# Copyright August 2008-2014 MonetDB B.V.
# All Rights Reserved.

module geom;

# @' overwrite lng needed for fixed size! Sizes are fixed in geom.prelude
atom mbr:lng;

command tostr() :str		address mbrTOSTR;
command fromstr() :mbr		address mbrFROMSTR;
command hash() :int		address mbrHASH;
command null() :int		address mbrNULL;
command cmp() :int		address mbrCOMP;
command read()			address mbrREAD;
command write()			address mbrWRITE;

command mbr(v:str) :mbr address mbrFromString;

atom wkb;

command tostr() :str		address wkbTOSTR;
command fromstr() :wkb		address wkbFROMSTR;
command hash() :int		address wkbHASH;
command null() :int		address wkbNULL;
command cmp() :int		address wkbCOMP;
command read()			address wkbREAD;
command write()			address wkbWRITE;
command put() :int		address wkbPUT;
command del() :int		address wkbDEL;
command length() :int		address wkbLENGTH;
command heap() :int		address wkbHEAP;

#command wkb{unsafe}(v:str) :wkb address wkbFromString;
command FromText{unsafe}(wkt:str, srid:int, type:int) :wkb	address wkbFromText;

module geom;

command hasZ{unsafe}(flags:int) :int address geoHasZ
comment "returns 1 if the geometry has z coordinate";
command hasM{unsafe}(flags:int) :int address geoHasM
comment "returns 1 if the geometry has m coordinate";
command getType{unsafe}(flags:int) :str address geoGetType
comment "returns the str representation of the geometry type";


command GeometryType{unsafe}(w:wkb, flag:int) :str address wkbGeometryType;
command NumRings{unsafe}(w:wkb, exterior:int) :int address wkbNumRings
comment "Returns the number of interior rings+exterior on the first polygon of the geometry";


#Geometry Constructors
command AsText(w:wkb) :str address wkbAsText
comment "Creates the text representation of the Geometry.";

function GeomFromText{unsafe}(wkt:str, srid:int) :wkb; 
	x := wkb.FromText(wkt,srid,0);
	return x;
end GeomFromText;
function PointFromText{unsafe}(wkt:str, srid:int) :wkb; 
	x := wkb.FromText(wkt,srid,1);
	return x;
end PointFromText;
function LineFromText{unsafe}(wkt:str, srid:int) :wkb;
	x := wkb.FromText(wkt,srid,2);
	return x;
end LineFromText;
function PolygonFromText{unsafe}(wkt:str, srid:int) :wkb;
	x := wkb.FromText(wkt,srid,3);
	return x;
end PolygonFromText;
function MPointFromText{unsafe}(wkt:str, srid:int) :wkb;
	x := wkb.FromText(wkt,srid,4);
	return x;
end MPointFromText;
function MLineFromText{unsafe}(wkt:str, srid:int) :wkb;
	x := wkb.FromText(wkt,srid,5);
	return x;
end MLineFromText;
function MPolyFromText{unsafe}(wkt:str, srid:int) :wkb;
	x := wkb.FromText(wkt,srid,6);
	return x;
end MPolyFromText;
function GeomCollFromText{unsafe}(wkt:str, srid:int) :wkb;
	x := wkb.FromText(wkt,srid,7);
	return x;
end GeomCollFromText;

function GeomFromText{unsafe}(wkt:str) :wkb; 
	x := wkb.FromText(wkt,0,0);
	return x;
end GeomFromText;
function PointFromText{unsafe}(wkt:str) :wkb; 
	x := wkb.FromText(wkt,0,1);
	return x;
end PointFromText;
function LineFromText{unsafe}(wkt:str) :wkb;
	x := wkb.FromText(wkt,0,2);
	return x;
end LineFromText;
function PolygonFromText{unsafe}(wkt:str) :wkb;
	x := wkb.FromText(wkt,0,3);
	return x;
end PolygonFromText;
function MPointFromText{unsafe}(wkt:str) :wkb;
	x := wkb.FromText(wkt,0,4);
	return x;
end MPointFromText;
function MLineFromText{unsafe}(wkt:str) :wkb;
	x := wkb.FromText(wkt,0,5);
	return x;
end MLineFromText;
function MPolyFromText{unsafe}(wkt:str) :wkb;
	x := wkb.FromText(wkt,0,6);
	return x;
end MPolyFromText;
function GeomCollFromText{unsafe}(wkt:str) :wkb;
	x := wkb.FromText(wkt,0,7);
	return x;
end GeomCollFromText;

#function GeomFromWKB{unsafe}(wkb_raw:????, srid:int) : wkb;
#	x := wkb.FromWKB(wkb_raw, srid, 0);
#	return x;
#end GeomFromWKB;


function NumInteriorRings{unsafe}(w:wkb) :int;
	x := NumRings(w, 0);
	return x;
end NumInteriorRings
function NRings{unsafe}(w:wkb) :int;
	x := NumRings(w, 1);
	return x;
end NRings;


command MakePoint{unsafe}(x:dbl, y:dbl) :wkb address geomMakePoint2D
comment "creates a point using the coordinates";
command MakePoint{unsafe}(x:dbl, y:dbl, z:dbl) :wkb address geomMakePoint3D
comment "creates a point using the coordinates";
#Gives error. I do not know how to create 4d point
command MakePoint{unsafe}(x:dbl, y:dbl, z:dbl, m:dbl) :wkb address geomMakePoint4D
comment "creates a point using the coordinates";
command MakePointM{unsafe}(x:dbl, y:dbl, m:dbl) :wkb address geomMakePointM
comment "creates a point using the coordinates";

#Geometry Accessors
function GeometryType1{unsafe}(w:wkb) :str;
	x := GeometryType(w, 0);
	return x;
end GeometryType1;
function GeometryType2{unsafe}(w:wkb) :str;
	x := GeometryType(w, 1);
	return x;
end GeometryType2;

command Boundary(w:wkb) :wkb address wkbBoundary
comment "Returns the closure of the combinatorial boundary of the Geometry.";
command CoordDim(w:wkb) :int address wkbCoordDim
comment " Return the coordinate dimension of the geometry";
command Dimension(w:wkb) :int address wkbDimension
comment "The inherent dimension of this Geometry object, which must be less than or equal to the coordinate dimension.";
command getSRID(w:wkb) :int address wkbGetSRID
comment "Returns the Spatial Reference System ID for this Geometry.";
command setSRID(w:wkb, srid:int) :wkb address wkbSetSRID
comment "Sets the Reference System ID for this Geometry.";
command X(g:wkb) :dbl address wkbGetCoordX
comment  "Return the X coordinate of the point, or NULL if not available. Input must be a point.";
command Y(g:wkb) :dbl address wkbGetCoordY
comment "Return the Y coordinate of the point, or NULL if not available. Input must be a point.";
command Z(g:wkb) :dbl address wkbGetCoordZ
comment "Return the Z coordinate of the point, or NULL if not available. Input must be a point.";
command StartPoint(w:wkb) :wkb address wkbStartPoint
comment "Returns the first point of a LINESTRING geometry as a POINT or NULL if the input parameter is not a LINESTRING";
command EndPoint(w:wkb) :wkb address wkbEndPoint
comment "Returns the last point of a LINESTRING geometry as a POINT or NULL if the input parameter is not a LINESTRING.";
command NumPoints(w:wkb) :int address wkbNumPoints
comment "The number of points in the Geometry. The geometry should be a linestring";
command PointN(w:wkb, n:int) :wkb address wkbPointN
comment "Returns the n-th point of the Geometry. Argument w should be Linestring.";
command Envelope(w:wkb) :wkb address wkbEnvelope
comment "The minimum bounding box for this Geometry, returned as a Geometry. The polygon is defined by the corner points of the bounding box ((MINX,MINY),(MAXX,MINY),(MAXX,MAXY),(MINX,MAXY)).";
command ExteriorRing(w:wkb) :wkb address wkbExteriorRing
comment "Returns a line string representing the exterior ring of the POLYGON geometry. Return NULL if the geometry is not a polygon.";
command InteriorRingN(w:wkb, n:int) :wkb address wkbInteriorRingN
comment "Return the Nth interior linestring ring of the polygon geometry. Return NULL if the geometry is not a polygon or the given N is out of range.";
command IsClosed(w:wkb) :bit address wkbIsClosed
comment "Returns TRUE if the LINESTRING's start and end points are coincident.";
command IsEmpty(w:wkb) :bit address wkbIsEmpty
comment "Returns true if this Geometry is an empty geometry.";
command IsRing(w:wkb) :bit address wkbIsRing
comment "Returns TRUE if this LINESTRING is both closed and simple.";
command IsSimple(w:wkb) :bit address wkbIsSimple
comment "Returns (TRUE) if this Geometry has no anomalous geometric points, such as self intersection or self tangency.";
command IsValid(w:wkb) :bit address wkbIsValid
comment "Returns true if the ST_Geometry is well formed.";
command IsValidReason(w:wkb) :str address wkbIsValidReason
comment "Returns text stating if a geometry is valid or not and if not valid, a reason why.";
command IsValidDetail(w:wkb) :str address wkbIsValidDetail
comment "Returns a valid_detail (valid,reason,location) row stating if a geometry is valid or not and if not valid, a reason why and a location where.";
command Area(w:wkb) :dbl address wkbArea
comment "Returns the area of the surface if it is a polygon or multi-polygon";
command Centroid(w:wkb) :wkb address wkbCentroid
comment "Computes the geometric center of a geometry, or equivalently, the center of mass of the geometry as a POINT.";
command Distance(a:wkb, b:wkb) :dbl address wkbDistance
comment "Returns the 2-dimensional minimum cartesian distance between the two geometries in projected units (spatial ref units.";
command Length(w:wkb) :dbl address wkbLength
comment "Returns the cartesian 2D length of the geometry if it is a linestrin or multilinestring";
command ConvexHull(w:wkb) :wkb address wkbConvexHull
comment "Returns a geometry that represents the convex hull of this geometry. The convex hull of a geometry represents the minimum convex geometry that encloses all geometries within the set.";
command Intersection(a:wkb, b:wkb) :wkb address wkbIntersection
comment "Returns a geometry that represents the point set intersection of the Geometries a, b";
command Union(a:wkb, b:wkb) :wkb address wkbUnion
comment "Returns a geometry that represents the point set union of the Geometries a, b";
command Difference(a:wkb, b:wkb) :wkb address wkbDifference
comment "Returns a geometry that represents that part of geometry A that does not intersect with geometry B";
command SymDifference(a:wkb, b:wkb) :wkb address wkbSymDifference
comment "Returns a geometry that represents the portions of A and B that do not intersect";
command Buffer(a:wkb, distance:dbl) :wkb address wkbBuffer
comment "Returns a geometry that represents all points whose distance from this geometry is less than or equal to distance. Calculations are in the Spatial Reference System of this Geometry.";
command Contains(a:wkb, b:wkb) :bit address wkbContains
comment "Returns true if and only if no points of B lie in the exterior of A, and at least one point of the interior of B lies in the interior of A.";
command Crosses(a:wkb, b:wkb) :bit address wkbCrosses
comment "Returns TRUE if the supplied geometries have some, but not all, interior points in common.";
command Disjoint(a:wkb, b:wkb) :bit address wkbDisjoint
comment "Returns true if these Geometries are 'spatially disjoint'";
command Equals(a:wkb, b:wkb) :bit address wkbEquals
comment "Returns true if the given geometries represent the same geometry. Directionality is ignored.";
command Intersects(a:wkb, b:wkb) :bit address wkbIntersects
comment "Returns true if these Geometries 'spatially intersect in 2D'";
command Overlaps(a:wkb, b:wkb) :bit address wkbOverlaps
comment " Returns TRUE if the Geometries intersect but are not completely contained by each other.";
command Relate(a:wkb, b:wkb, intersection_matrix_pattern:str) :bit address wkbRelate
comment "Returns true if the Geometry a 'spatially related' to Geometry b, by testing for intersection between the Interior, Boundary and Exterior of the two geometries as specified by the values in the intersectionPatternMatrix.";
command Touches(a:wkb, b:wkb) :bit address wkbTouches
comment "Returns TRUE if the geometries have at least one point in common, but their interiors do not intersect.";
command Within(a:wkb, b:wkb) :bit address wkbWithin
comment "Returns true if the geometry A is completely inside geometry B";
command GeometryN(g:wkb, n:int) :wkb address wkbGeometryN
comment "Returns the 1-based Nth geometry if the geometry is a GEOMETRYCOLLECTION, (MULTI)POINT, (MULTI)LINESTRING, MULTICURVE or (MULTI)POLYGON. Otherwise, return NULL";
command NumGeometries(g:wkb) :int address wkbNumGeometries
comment "Returns the number of geometries";

command Transform(g:wkb, srid:int, proj_src:str, proj_dest:str) :wkb address wkbTransform
comment "Transforms a geometry from one srid to another";




#function CurveFromText{unsafe}( wkt:str, srid:sht ) :wkb;
#	x := wkb.FromText(wkt,2);
#	return x;
#end CurveFromText;
#function SurfaceFromText{unsafe}( wkt:str, srid:sht ) :wkb;
#	x := wkb.FromText(wkt,3);
#	return x;
#end SurfaceFromText;
#function MultiCurveFromText{unsafe}( wkt:str, srid:sht ) :wkb;
#	x := wkb.FromText(wkt,5);
#	return x;
#end MultiCurveFromText;
#function MultiSurfaceFromText{unsafe}( wkt:str, srid:sht ) :wkb;
#	x := wkb.FromText(wkt,6);
#	return x;
#end MultiSurfaceFromText;
#function GeomFromText{unsafe}( wkt:str, srid:sht ) :wkb;
#	x := wkb.FromText(wkt,7);
#	return x;
#end GeomFromText;
#
#command mbroverlaps(a:mbr, b:mbr) :bit
#address mbroverlaps
#comment "Returns true if the two mbrs overlap";



#command mbr(:flt,:flt,:flt,:flt) :mbr
#address ordinatesMBR
#comment "Creates the mbr for the given (xmin,ymin) and (xmax,ymax).";

#command mbr(:wkb) :mbr
#address wkbMBR
#comment "Creates the mbr for the given wkb.";



# @+ ogc constructor functions
#command point(x:dbl,y:dbl) :wkb
#address wkbcreatepoint
#comment "Construct a point from two geometries";

#module batgeom;
#command point(x:bat[:oid,:dbl],y:bat[:oid,:dbl]) :bat[:oid,:wkb]
#address wkbcreatepoint_bat
#comment "Construct a point-BAT from two geometry-BATs";







command prelude():void	address geom_prelude;
command epilogue():void address geom_epilogue;

geom.prelude();

module calc;

command mbr{unsafe}(v:str) :mbr address mbrFromString;
command mbr(v:mbr) :mbr address mbrFromMBR;
command wkb{unsafe}(v:str) :wkb address wkbFromString;
command wkb(v:wkb) :wkb address wkbFromWKB;

command wkb(geo:wkb, columnType:int, columnSRID:int) :wkb address A_2_B
comment "Called when iserting values to a table in order to check if the inserted geometries are of the same type and srid required by the column definition"
#function point{unsafe}( wkt:str ) :wkb;
#	x := wkb.FromText(wkt,1);
#	return x;
#end point;
#function curve{unsafe}( wkt:str ) :wkb;
#	x := wkb.FromText(wkt,2);
#	return x;
#end curve;
#function linestring{unsafe}( wkt:str ) :wkb;
#	x := wkb.FromText(wkt,2);
#	return x;
#end linestring;
#function surface{unsafe}( wkt:str ) :wkb;
#	x := wkb.FromText(wkt,3);
#	return x;
#end surface;
#function polygon{unsafe}( wkt:str ) :wkb;
#	x := wkb.FromText(wkt,3);
#	return x;
#end polygon;
#function multipoint{unsafe}( wkt:str ) :wkb;
#	x := wkb.FromText(wkt,4);
#	return x;
#end multipoint;
#function multicurve{unsafe}( wkt:str ) :wkb;
#	x := wkb.FromText(wkt,5);
#	return x;
#end multicurve;
#function multilinestring{unsafe}( wkt:str ) :wkb;
#	x := wkb.FromText(wkt,5);
#	return x;
#end multilinestring;
#function multisurface{unsafe}( wkt:str ) :wkb;
#	x := wkb.FromText(wkt,6);
#	return x;
#end multisurface;
#function multipolygon{unsafe}( wkt:str ) :wkb;
#	x := wkb.FromText(wkt,6);
#	return x;
#end multipolygon;
#function geometry{unsafe}( wkt:str ) :wkb;
#	x := wkb.FromText(wkt,7);
#	return x;
#end geometry;
#function geomcollection{unsafe}( wkt:str ) :wkb;
#	x := wkb.FromText(wkt,7);
#	return x;
#end geomcollection;

module geom;
command calc.isnil(v:wkb):bit
address wkbIsnil
comment "Nil test for wkb value";


# wkbPoint := 1;
# wkbLineString := 2;
# wkbPolygon := 3;
# wkbMultiPoint := 4;
# wkbMultiLineString := 5;
# wkbMultiPolygon := 6;
# wkbGeometryCollection := 7;

