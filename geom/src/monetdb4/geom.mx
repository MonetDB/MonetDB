@' tHE COntents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2007 CWI.
@' All Rights Reserved.

@f geom
@a Wouter Scherphof, Niels Nes
@* The simple geom module

@m
.MODULE geom;

   .ATOM mbr [16];
     .FROMSTR = mbrFROMSTR;
     .TOSTR   = mbrTOSTR;
     .HASH    = mbrHASH;
     .COMP    = mbrCOMP;
     .NULL    = mbrNULL;
     .READ     = mbrREAD;
     .WRITE    = mbrWRITE;
   .END;

   .ATOM wkb;
     .TOSTR   = wkbTOSTR;
     .FROMSTR = wkbFROMSTR;

     .COMP     = wkbCOMP;
     .HASH     = wkbHASH;
     .NULL     = wkbNULL;
     .READ     = wkbREAD;
     .WRITE    = wkbWRITE;

     .PUT      = wkbPUT;
     .DEL      = wkbDEL;
     .LENGTH   = wkbLENGTH;
     .HEAP     = wkbHEAP;
   .END;

   .COMMAND wkb_from_text(str wkt, int tpe) : wkb = wkbFromText;
   "Try to creates the a wkb of type, tpe, from the given wkt."

   .COMMAND mbr(flt,flt,flt,flt) : mbr = ordinatesMBR;
   "Creates the mbr for the given (xmin,ymin) and (xmax,ymax)."
   
   .COMMAND mbr(wkb) : mbr = wkbMBR;
   "Creates the mbr for the given wkb."

@+ ogc basic methods
@m
   .COMMAND Dimension( wkb w) : int = wkbDimension;
   "The inherent dimension of this geometry object, which must be less than or equal
    to the coordinate dimension. 
    This specification is restricted to geometries in two-dimensional coordinate space."

   .COMMAND GeometryTypeId(wkb w) : int = wkbGeometryTypeId;
   "Returns the name of the instantiable subtype of Geometry of which this 
    Geometry instance is a member. The name of the instantiable subtype of Geometry is returned as string."

   .COMMAND SRID(wkb w) : int = wkbSRID;
   "Returns the Spatial Reference System ID for this Geometry."

   .COMMAND Envelope(wkb w): wkb = wkbEnvelope;
   "The minimum bounding box for this Geometry, returned as a Geometry. The
    polygon is defined by the corner points of the bounding box 
    ((MINX,MINY),(MAXX,MINY),(MAXX,MAXY),(MINX,MAXY))."

   .COMMAND IsEmpty(wkb w): bit = wkbIsEmpty;
   "Returns true if this Geometry is the empty geometry. If true, then this 
    Geometry represents the empty point set, for the coordinate space."

   .COMMAND IsSimple(wkb w): bit = wkbIsSimple;
   "Returns true if this Geometry has no anomalous geometric points, such as self
    intersection or self tangency. The description of each instantiable geometric class will include the specific
    conditions that cause an instance of that class to be classified as not simple."

   .COMMAND Boundary(wkb w): wkb = wkbBoundary;
   "Returns the closure of the combinatorial boundary of this Geometry." 

@+ ogc spatial relation methods
@m

   .COMMAND Equals(wkb a, wkb b) : bit = wkbEquals;
   	"Returns true if these Geometries are 'spatially equal'"

   .COMMAND Disjoint(wkb a, wkb b) : bit = wkbDisjoint;
   	"Returns true if these Geometries are 'spatially disjoint'"

   .COMMAND Intersect(wkb a, wkb b) : bit = wkbIntersect;
   	"Returns true if these Geometries 'spatially intersect'"

   .COMMAND Touches(wkb a, wkb b) : bit = wkbTouches;
   	"Returns true if these Geometries 'spatially touch' each other"

   .COMMAND Crosses(wkb a, wkb b) : bit = wkbCrosses;
   	"Returns true if the Geometry a 'spatially crosses' Geometry b"

   .COMMAND Within(wkb a, wkb b) : bit = wkbWithin;
   	"Returns true if the Geometry a 'spatially within' Geometry b"

   .COMMAND Contains(wkb a, wkb b) : bit = wkbContains;
   	"Returns true if the Geometry a 'spatially contains' Geometry b"

   .COMMAND Overlaps(wkb a, wkb b) : bit = wkbOverlaps;
   	"Returns true if the Geometry a 'spatially overlaps' Geometry b"

   .COMMAND Relate(wkb a, wkb b, str intersectionPatternMatrix) : bit = wkbRelate;
   	"Returns true if the Geometry a 'spatially related' to Geometry b, by testing for intersection between the
         Interior, Boundary and Exterior of the two geometries as specified by the values in the intersectionPatternMatrix."

@+ ogc Spatial Analysis methods
@m

   .COMMAND Area(wkb g) : dbl = wkbArea;
    	"Returns the area of the geometry."

   .COMMAND Length(wkb g) : dbl = wkbLength;
    	"Returns the length of the geometry."

   .COMMAND Distance(wkb a, wkb b) : dbl = wkbDistance;
    	"Returns the shortest distance between any two points in the two geometries
         as calculated in the spatial reference system of this Geometries."

   .COMMAND Buffer(wkb a, dbl distance) : wkb = wkbBuffer;
    	"Returns a geometry that represents all points whose distance from this geometry is less than
	or equal to distance. Calculations are in the Spatial Reference System of this Geometry."

   .COMMAND ConvexHull(wkb a) : wkb = wkbConvexHull;
	"Returns a geometry that represents the convex hull of this geometry."

   .COMMAND Intersection(wkb a, wkb b): wkb = wkbIntersection;
   	"Returns a geometry that represents the point set intersection of Geometry a with b."

   .COMMAND Union(wkb a, wkb b): wkb = wkbUnion;
   	"Returns a geometry that represents the point set union of Geometry a with b."

   .COMMAND Difference(wkb a, wkb b): wkb = wkbDifference;
   	"Returns a geometry that represents the point set difference of Geometry a with b."

   .COMMAND SymDifference(wkb a, wkb b): wkb = wkbSymDifference;
   	"Returns a geometry that represents the point set semmetric difference of Geometry a with b."

   .PRELUDE = geom_prelude;
   .EPILOGUE = geom_epilogue;
   
.END geom;

@h
#ifndef __geom_H__
#define __geom_H__

#include "libgeom.h"

/*
#define point wkb
#define curve wkb
#define line wkb
#define surface wkb
#define poly wkb
#define multipoint wkb
#define multicurve wkb
#define multiline wkb
#define multisurface wkb
#define multipoly wkb
*/

#include "geom.proto.h"

#endif /* __geom_H__ */

@c

#include <geom_config.h>
#include <gdk.h>

#include "geom.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <time.h>

bat*
geom_prelude(void)
{
	libgeom_init();
	return NULL;	
}

void
geom_epilogue(void)
{
	libgeom_exit();
}

/*
 * Implementation of fixed-sized atom mbr.
 */
static int
mbr_isnil(mbr *mbr)
{
	if (!mbr || mbr->xmin == flt_nil || mbr->ymin == flt_nil ||
	            mbr->xmax == flt_nil || mbr->ymax == flt_nil )
		return 1;
	return 0;
}

/* NULL: generic nil mbr. */
/* returns a pointer to a nil-mbr. */
mbr*
mbrNULL(void)
{
	static mbr mbrNIL;
	mbrNIL.xmin = flt_nil;
	mbrNIL.ymin = flt_nil;
	mbrNIL.xmax = flt_nil;
	mbrNIL.ymax = flt_nil;
	return (&mbrNIL);
}

/* FROMSTR: parse string to mbr. */
/* return number of parsed characters. */
int
mbrFROMSTR(
   char*	src,	/* IN: to-be-parsed string. */
   int*		len,	/* INOUT: length of area pointed to by atom [may need enlarging!] */
   mbr**	atom	/* INOUT: ptr to atom-ptr [may need (re-)alloc!] */
)
{
	int nil = 0;
	int nchars = 0; /* The number of characters parsed; the return value. */
	GEOSGeom geosMbr = NULL; /* The geometry object that is parsed from the src string. */
	
	if (strcmp(src, str_nil) == 0) 
		nil = 1;

	if (!nil && (geosMbr = GEOSGeomFromWKT(src)) == NULL)
		return 0;

	if (*len < (int)sizeof(mbr)) {
		if (*atom) GDKfree(*atom);
		*atom = GDKmalloc(*len = sizeof(mbr));
	}
	if (nil) {
		nchars = 3;
		**atom = *mbrNULL();
	} else if (getMbrGeos(*atom, geosMbr))
		nchars = strlen(src);
	if (geosMbr)
		GEOSGeom_destroy(geosMbr);
	return nchars;
}

#define MBR_WKTLEN 256

/* TOSTR: print atom in a string. */
/* return length of resulting string. */
int
mbrTOSTR(
   char**	dst,	/* INOUT: dst charbuffer [maybe 0, may need realloc]*/
   int*		len,	/* INOUT: length of buffer */
   mbr*	atom	/* IN: to-be-printed mbr. */
)
{
	static char tempWkt[MBR_WKTLEN];
	size_t dstStrLen = 3;
	
	if (!mbr_isnil(atom)) {
		snprintf(tempWkt, MBR_WKTLEN, "BOX (%f %f, %f %f)",
			atom->xmin, atom->ymin,
			atom->xmax, atom->ymax
		);
		dstStrLen = strlen(tempWkt);
	}
	
	if (*len < (int) dstStrLen + 1) { 
		if (*dst) GDKfree(*dst);
		*dst = GDKmalloc(*len = dstStrLen + 1);
	}
	
	if (dstStrLen > 3)
		strcpy(*dst, tempWkt);
	else
		strcpy(*dst, "nil");
	return dstStrLen;
}

/* HASH: compute a hash value. */
/* returns a positive integer hash value */
hash_t
mbrHASH(
   mbr*	atom	/* IN: to-be-hashed mbr. */
)
{
	return (hash_t) ( (((int) atom->xmin) * ((int) atom->ymin)) * (((int) atom->xmax) * ((int) atom->ymax)) );
}

/* COMP: compare two mbrs. */
/* returns int <0 if l<r, 0 if l==r, >0 else */
int
mbrCOMP(
   mbr*	l,	/* IN: first geom_point. */
   mbr*	r	/* IN: second geom_point. */
)
{
	/* simple lexicographical ordering on (x,y) */
	int res;
	if (l->xmin == r->xmin)
		res = (l->ymin < r->ymin)? -1: (l->ymin == r->ymin)? 0: 1;
	else 
		res = (l->xmin < r->xmin)? -1: 1;
	if (res == 0) {
		if (l->xmax == r->xmax)
			res = (l->ymax < r->ymax)? -1: (l->ymax == r->ymax)? 0: 1;
		else 
			res = (l->xmax < r->xmax)? -1: 1;
	}
	return res;
}

mbr *
mbrREAD(mbr *a, stream *s, size_t cnt)
{
	mbr *c;
	size_t i;
	int xmin, ymin, xmax, ymax;

	for(i=0, c = a;i<cnt;i++, c++) {
		if (!stream_readInt(s, &xmin) ||
		    !stream_readInt(s, &ymin) ||
		    !stream_readInt(s, &xmax) ||
		    !stream_readInt(s, &ymax) ) 
			return NULL;
		c->xmin = (flt)xmin;
		c->ymin = (flt)ymin;
		c->xmax = (flt)xmax;
		c->ymax = (flt)ymax;
	}
	return a;
}

void
mbrWRITE(mbr *c, stream *s, size_t cnt)
{
	size_t i;

	for(i=0;i<cnt;i++, c++) {
		if (!stream_writeInt(s, c->xmin) ||
		    !stream_writeInt(s, c->ymin) ||
		    !stream_writeInt(s, c->xmax) ||
		    !stream_writeInt(s, c->ymax))
			break;
	}
}

/*
 * Implementation of variable-sized atom wkb.
 */

static size_t
wkb_size(size_t len)
{
	if (len == ~(size_t) 0)
		len = 0;
	return sizeof(wkb) - 1 + len;
}

/* TOSTR: print atom in a string. */
/* return length of resulting string. */
int
wkbTOSTR(
   char**	dst,	/* INOUT: dst charbuffer [maybe 0, may need realloc]*/
   int*		len,	/* INOUT: length of buffer */
   wkb*	atom	/* IN: to-be-printed geom_geometry. */
)
{
	char* wkt = NULL;
	int dstStrLen = 3; /* "nil" */
	GEOSGeom geosGeometry = wkb2geos(atom);
	
	if (geosGeometry) {
		wkt = GEOSGeomToWKT(geosGeometry);
		dstStrLen = strlen(wkt);
		GEOSGeom_destroy(geosGeometry);
	}
	
	if (*len < dstStrLen + 1) { /* + 1 for the '\0' */
		if (*dst) GDKfree(*dst);
		*dst = GDKmalloc(*len = dstStrLen + 1);
	}
	
	if (wkt) {
		strcpy(*dst, wkt);
		free(wkt);
	} else {
		strcpy(*dst, "nil");
	}

	return dstStrLen;
}

/* FROMSTR: parse string to @1. */
/* return number of parsed characters. */
int
wkbFROMSTR(
   char*	src,	/* IN: to-be-parsed string. */
   int*		len,	/* INOUT: length of area pointed to by atom [may need enlarging!] */
   wkb**	atom	/* INOUT: ptr to atom-ptr [may need (re-)alloc!] */
)
{
	GEOSGeom geosGeometry = NULL; /* The geometry object that is parsed from the src string. */
	unsigned char* wkb = NULL; /* The "well known binary" serialization of the geometry object. */
	size_t wkbLen = 0; /* The length of the wkb string. */
	int nil = 0;

	if (strcmp(src, str_nil) == 0) 
		nil = 1;

	if (!nil && (geosGeometry = GEOSGeomFromWKT(src)) == NULL)
		return 0;
	
	if (!nil && GEOSGeomTypeId(geosGeometry) == -1) {
		GEOSGeom_destroy(geosGeometry);
		return 0;
	}

	if (!nil) {
		wkb = GEOSGeomToWKB_buf(geosGeometry, &wkbLen);
		GEOSGeom_destroy(geosGeometry);
	}
	if (*len < (int)wkb_size(wkbLen)) {
		if (*atom) GDKfree(*atom);
		*atom = GDKmalloc(*len = (int)wkb_size(wkbLen));
	}
	if (!wkb) {
		**atom = *wkbNULL();
	} else {
		(*atom)->len = wkbLen;
		memcpy(&(*atom)->data, wkb, wkbLen);
		free(wkb);
	}
	return strlen(src);
}

int
wkbFromText(wkb **w, str wkt, int *tpe) 
{
	int len = 0;

	*w = NULL;
	if (wkbFROMSTR(wkt, &len, w) && 
	    (wkb_isnil(*w) ||
	     *tpe == wkbGeometryCollection || *tpe == (((*w)->data[1])&0x0f)))
		return GDK_SUCCEED;
	if (!(*w))
		*w = (wkb*)GDKmalloc(sizeof(wkb));
	**w = *wkbNULL();
	return GDK_FAIL;
}

hash_t
wkbHASH(wkb *w)
{
	int i;
	hash_t h = 0;

	for (i = 0; i<(w->len-1); i+=2) {
		int a = w->data[i], b = w->data[i+1];
                h = (h << 3) ^ (h >> 11) ^ (h >> 17) ^ (b << 8) ^ a;
	}
	return h;
}

int
wkbCOMP(wkb *l, wkb *r)
{
	int len = l->len;

	if (len != r->len)
		return len-r->len;

	if (len == ~(int) 0)
		return (0);

	return memcmp(l->data, r->data, len);
}

wkb *
wkbNULL(void)
{
	static wkb nullval;

	nullval.len = ~(int) 0;
	return (&nullval);
}

void
wkbDEL(Heap *h, var_t *index)
{
	HEAP_free(h, *index);
}

wkb *
wkbREAD(wkb *a, stream *s, size_t cnt)
{
	int len;

	(void) cnt;
	assert(cnt == 1);
	if (!stream_readInt(s, &len))
		return NULL;
	if ((a = GDKmalloc(wkb_size(len))) == NULL)
		return NULL;
	a->len = len;
	if (len > 0 && stream_read(s, (char *) a->data, len, 1) != 1) {
		GDKfree(a);
		return NULL;
	}
	return a;
}

void
wkbWRITE(wkb *a, stream *s, size_t cnt)
{
	int len = a->len;

	(void) cnt;
	assert(cnt == 1);
	if (stream_writeInt(s, len) && len > 0) /* 64bit: check for overflow */
		stream_write(s, (char *) a->data, len, 1);
}

void
wkbCONVERT(wkb *b, int direction)
{
	(void) direction;
	b->len = normal_int_SWAP(b->len);
}

int
wkbLENGTH(wkb *p)
{
	return wkb_size(p->len);
}

void
wkbHEAP(Heap *heap, size_t capacity)
{
	HEAP_initialize(heap, capacity, 0, (int) sizeof(var_t));
}

var_t
wkbPUT(Heap *h, var_t *bun, wkb *val)
{
	char *base;

	*bun = HEAP_malloc(h, wkb_size(val->len));
	base = h->base;
	if (*bun)
		memcpy(&base[*bun], (char *) val, wkb_size(val->len));
	return *bun;
}

/* COMMAND mbr
 * Creates the mbr for the given geom_geometry.
 */
int
ordinatesMBR(
	mbr* res, /* INOUT. */
	flt* minX, /* IN. */
	flt* minY, /* IN. */
	flt* maxX, /* IN. */
	flt* maxY /* IN. */
)
{
	res->xmin = *minX;
	res->ymin = *minY;
	res->xmax = *maxX;
	res->ymax = *maxY;
	return GDK_SUCCEED;
}


/* COMMAND mbr
 * Creates the mbr for the given geom_geometry.
 */
int
wkbMBR(
	mbr* res, /* INOUT. */
	wkb* geom /* IN. */
)
{
	if (getMbrGeom(res, geom))
		return GDK_SUCCEED;
	return GDK_FAIL;
}

wkb *
geos2wkb( GEOSGeom geosGeometry )
{
	size_t wkbLen = 0; 
	unsigned char *w = GEOSGeomToWKB_buf(geosGeometry, &wkbLen);
	wkb *atom = GDKmalloc((int)wkb_size(wkbLen));

	if (!w) {
		*atom = *wkbNULL();
	} else {
		atom->len = wkbLen;
		memcpy(&atom->data, w, wkbLen);
		free(w);
	}
	return atom;
}

@= basic
int
@1( @2 *out, wkb *geom)
{
	int ret = GDK_FAIL;
	GEOSGeom geosGeometry = wkb2geos(geom);

	if (geosGeometry) { 
		if ((*out=@4(@3( geosGeometry))) != @5) {
			ret = GDK_SUCCEED;
		}
		GEOSGeom_destroy(geosGeometry);
	}
	return ret;
}
@c
@:basic(wkbDimension,int,GEOSGeom_getDimensions,,0)@
@:basic(wkbGeometryTypeId,int,GEOSGeomTypeId,,-1)@
@:basic(wkbSRID,int,GEOSGetSRID,,0)@
@:basic(wkbEnvelope,wkb*,GEOSEnvelope,geos2wkb,NULL)@
@:basic(wkbIsEmpty,bit,GEOSisEmpty,,2)@
@:basic(wkbIsSimple,bit,GEOSisSimple,,2)@
@:basic(wkbBoundary,wkb*,GEOSBoundary,geos2wkb,NULL)@

@= spatial
int
@1( bit *out, wkb *a, wkb *b)
{
	int ret = GDK_FAIL;
	GEOSGeom ga = wkb2geos(a);
	GEOSGeom gb = wkb2geos(b);

	if (ga && gb) { 
		*out= @2( ga, gb);
		ret = GDK_SUCCEED;
	}
	if (ga)
		GEOSGeom_destroy(ga);
	if (gb)
		GEOSGeom_destroy(gb);
	return ret;
}
@= spatial2
int
@1( bit *out, wkb *a, wkb *b, @3 @4)
{
	int ret = GDK_FAIL;
	GEOSGeom ga = wkb2geos(a);
	GEOSGeom gb = wkb2geos(b);

	if (ga && gb) { 
		*out= @2( ga, gb, @4);
		ret = GDK_SUCCEED;
	}
	if (ga)
		GEOSGeom_destroy(ga);
	if (gb)
		GEOSGeom_destroy(gb);
	return ret;
}
@c
@:spatial(wkbEquals,GEOSEquals)@
@:spatial(wkbDisjoint,GEOSDisjoint)@
@:spatial(wkbIntersect,GEOSIntersects)@
@:spatial(wkbTouches,GEOSTouches)@
@:spatial(wkbCrosses,GEOSCrosses)@
@:spatial(wkbWithin,GEOSWithin)@
@:spatial(wkbContains,GEOSContains)@
@:spatial(wkbOverlaps,GEOSOverlaps)@
@:spatial2(wkbRelate,GEOSRelatePattern,char*,pattern)@

@= analysis
int
@1( dbl *out, wkb *a)
{
	int ret = GDK_FAIL;
	GEOSGeom ga = wkb2geos(a);

	if (ga) { 
		if ( @2( ga, out) != 0)
			ret = GDK_SUCCEED;
		GEOSGeom_destroy(ga);
	}
	return ret;
}
@= analysis2
int
@1( dbl *out, wkb *a, wkb *b)
{
	int ret = GDK_FAIL;
	GEOSGeom ga = wkb2geos(a);
	GEOSGeom gb = wkb2geos(b);

	if (ga && gb) { 
		if ( @2( ga, gb, out) != 0)
			ret = GDK_SUCCEED;
	}
	if (ga)
		GEOSGeom_destroy(ga);
	if (gb)
		GEOSGeom_destroy(gb);
	return ret;
}
@= analysis3
int
@1( @2 *out, wkb *a, wkb *b)
{
	int ret = GDK_FAIL;
	GEOSGeom ga = wkb2geos(a);
	GEOSGeom gb = wkb2geos(b);

	if (ga && gb) { 
		if ( (*out=@4(@3( ga, gb))) != NULL)
			ret = GDK_SUCCEED;
	}
	if (ga)
		GEOSGeom_destroy(ga);
	if (gb)
		GEOSGeom_destroy(gb);
	return ret;
}
@c
@:analysis(wkbArea,GEOSArea)@
@:analysis(wkbLength,GEOSLength)@
@:analysis2(wkbDistance,GEOSDistance)@
@:basic(wkbConvexHull,wkb*,GEOSConvexHull,geos2wkb,NULL)@
@:analysis3(wkbIntersection,wkb*,GEOSIntersection,geos2wkb)@
@:analysis3(wkbUnion,wkb*,GEOSUnion,geos2wkb)@
@:analysis3(wkbDifference,wkb*,GEOSDifference,geos2wkb)@
@:analysis3(wkbSymDifference,wkb*,GEOSSymDifference,geos2wkb)@

@c
int
wkbBuffer( wkb **out, wkb *geom, dbl *distance)
{
	int ret = GDK_FAIL;
	GEOSGeom geosGeometry = wkb2geos(geom);

	if (geosGeometry) { 
		if ((*out=geos2wkb(GEOSBuffer( geosGeometry, *distance, -1))) != NULL) {
			ret = GDK_SUCCEED;
		}
		GEOSGeom_destroy(geosGeometry);
	}
	return ret;
}

@mil

const wkbPoint := 1;
const wkbLineString := 2;
const wkbPolygon := 3;
const wkbMultiPoint := 4;
const wkbMultiLineString := 5;
const wkbMultiPolygon := 6;
const wkbGeometryCollection := 7;

# Functions prescribed by OGC's SFA standard:

PROC AsText( wkb geom) : str
{
	return str(geom);
}
ADDHELP("AsText",
	"Wouter Scherphof", "December 04 2006",
	"As specified by OGC's SFA standard:\nReturns the 'well known text' representation of the given geometry.", "geom");

var wkb_nil := wkb(nil);
@= types
PROC @1FromText( str wkt, sht srid): wkb
{
	return wkb_from_text(wkt, @3);
}
ADDHELP("@1FromText",
	"Wouter Scherphof", "December 04 2006",
	"As specified by OGC's SFA standard:\nCreates a @1 from its 'well known text' representation.",
	"geom");
PROC @2( str wkt ): wkb
{
	return wkb_from_text(wkt, @3);
}
PROC @2( wkb w ): wkb
{
	#/* todo check type */
	#//return wkb_from_text(wkt, @3);
	return w;
}

@mil
@:types(Point,point,wkbPoint)@
@:types(Curve,curve,wkbLineString)@
@:types(Line,linestring,wkbLineString)@
@:types(Surface,surface,wkbPolygon)@
@:types(Poly,polygon,wkbPolygon)@
@:types(MultiPoint,multipoint,wkbMultiPoint)@
@:types(MultiCurve,multicurve,wkbMultiLineString)@
@:types(MultiLine,multilinestring,wkbMultiLineString)@
@:types(MultiSurface,multisurface,wkbMultiPolygon)@
@:types(MultiPoly,multipolygon,wkbMultiPolygon)@
@:types(Geom,geometry,wkbGeometryCollection)@
@:types(GeomCollection,geomcollection,wkbGeometryCollection)@
