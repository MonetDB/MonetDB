@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f gdk
@T
@' define titlepage @t The Goblin Database Kernel
@v Version 3.05
@a Martin L. Kersten & Peter Boncz

@* The Inner Core
The innermost library of the MonetDB database system is formed by
the library called GDK, an abbreviation of Goblin Database Kernel.
Its development was originally rooted in the design of a pure
active-object-oriented programming language, before development
was shifted towards a re-usable database kernel engine.

GDK is a C library that provides ACID properties on a DSM model
@tex
[@cite{Copeland85}]
@end tex
, using main-memory
database algorithms
@tex
[@cite{Garcia-Molina92}]
@end tex
 built on virtual-memory
OS primitives and multi-threaded parallelism.
Its implementation has undergone various changes over its decade
of development, many of which were driven by external needs to
obtain a robust and fast database system.

The coding scheme explored in GDK has also laid a foundation to
communicate over time experiences and to provide (hopefully)
helpful advice near to the place where the code-reader needs it.
Of course, over such a long time the documentation diverges from
reality. Especially in areas where the environment of this package
is being described.
Consider such deviations as historic landmarks, e.g. crystallization
of brave ideas and mistakes rectified at a later stage.

@+ Short Outline
The facilities provided in this implementation are:
@itemize
@item
GDK or Goblin Database Kernel routines for session management
@item
 BAT routines that define the primitive operations on the
database tables (BATs).
@item
 BBP routines to manage the BAT Buffer Pool (BBP).
@item
 ATOM routines to manipulate primitive types, define new types
using an ADT interface.
@item
 HEAP routines for manipulating heaps: linear spaces of memory
that are GDK's vehicle of mass storage (on which BATs are built).
@item
 DELTA routines to access inserted/deleted elements within a
transaction.
@item
 HASH routines for manipulating GDK's built-in linear-chained
hash tables, for accelerating lookup searches on BATs.
@item
 TM routines that provide basic transaction management primitives.
@item
 TRG routines that provided active database support. [DEPRECATED]
@item
 ALIGN routines that implement BAT alignment management.
@end itemize

The Binary Association Table (BAT) is the lowest level of storage
considered in the Goblin runtime system
@tex
[@cite{Goblin}]
@end tex
.  A BAT is a
self-descriptive main-memory structure that represents the @strong{binary
relationship} between two atomic types.
@
The association can be defined over:
@table @code
@item void:
 virtual-OIDs: a densely ascending column of OIDs (takes zero-storage).
@item bit:
 Booleans, implemented as one byte values.
@item chr:
A single character (8 bits @strong{integer}s).
DEPRECATED for storing text (Unicode not supported).
@item sht:
 Short integers (16-bit @strong{integer}s).
@item int:
 This is the C @strong{int} type (32-bit).
@item oid:
 Unique @strong{long int} values uses as object identifier. Highest bit cleared always.
	    Thus, oids-s are 31-bit numbers on 32-bit systems, and 63-bit numbers on 64-bit systems.
@item ptr:
Memory pointer values. DEPRECATED.  Can only be stored in transient BATs.
@item flt:
 The IEEE @strong{float} type.
@item dbl:
 The IEEE @strong{double} type.
@item lng:
 Longs: the C @strong{long long} type (64-bit integers).
@item str:
 UTF-8 strings (Unicode). A zero-terminated byte sequence.
@item bat:
 Bat descriptor. This allows for recursive adminstered tables, but
severely complicates transaction management. Therefore, they
CAN ONLY BE STORED IN TRANSIENT BATs.
[on the list to become depreciated,
@end table

This model can be used as a back-end model underlying other -higher
level- models, in order to achieve @strong{better performance} and
@strong{data independence} in one go. The relational model and
the object-oriented model can be mapped on BATs by vertically
splitting every table (or class) for each attribute. Each such a
column is then stored in a BAT with type @strong{bat[oid,attribute]}, where
the unique object identifiers link tuples in the different BATs.
Relationship attributes in the object-oriented model hence are
mapped to @strong{bat[oid,oid]} tables, being equivalent to the concept of
@emph{join indexes}
@tex
[@cite{Valduriez87}]
@end tex
.

The set of built-in types can be extended with user-defined types
through an ADT interface.  They are linked with the kernel to obtain
an enhanced library, or they are dynamically loaded upon request.

Types can be derived from other types. They represent something different
than that from which they are derived, but their internal storage management
is equal. This feature facilitates the work of extension programmers, by
enabling reuse of implementation code, but is also used to keep the GDK code
portable from 32-bits to 64-bits machines: the @strong{oid} and @strong{ptr} types
are derived from @strong{int} on 32-bits machines, but is derived from @strong{lng}
on 64 bits machines. This requires changes in only two lines of code each.

To accelerate lookup and search in BATs, GDK supports one built-in
search accelerator: hash tables. We choose an implementation efficient 
for main-memory: bucket chained hash 
@tex
[@cite{LehCar86,Analyti92}]
@end tex
. Alternatively, when the table is sorted, it will resort to merge-scan
operations or binary lookups.
@
BATs are built on the concept of heaps, which are large pieces of main
memory. They can also consist of virtual memory, in case the working
set exceeds main-memory. In this case, GDK supports operations that
cluster the heaps of a BAT, in order to improve performance of its
main-memory.


@- Rationale

The rationale for choosing a BAT as the building block for both
relational and object-oriented system is based on the following
observations:

@itemize
@item -
Given the fact that CPU speed and main-memory increase in
current workstation hardware for the last years has been exceeding
IO access speed increase, traditional disk-page oriented algorithms
do no longer take best advantage of hardware, in most database operations.

Instead of having a disk-block oriented kernel with a large memory
cache, we choose to build a main-memory kernel, that only under large data
volumes slowly degrades to IO-bound performance, comparable to
traditional systems
@tex
[@cite{boncz95,boncz96}]
@end tex
.

@item -
Traditional (disk-based) relational systems move too much data
around to save on (main-memory) join operations.

The fully decomposed store (DSM
@tex
[@cite{Copeland85})]
@end tex
assures that only those attributes of a relation that are needed,
will have to be accessed.

@item -
The data management issues for a binary association is much
easier to deal with than traditional @emph{struct}-based approaches
encountered in relational systems.

@item -
Object-oriented systems often maintain a double cache, one with the
disk-based representation and a C pointer-based main-memory structure.
This causes expensive conversions and replicated storage management.\\
GDK does not do such `pointer swizzling'. It used virtual-memory 
(@strong{mmap()}) and buffer management advice (@strong{madvise()}) OS primitives to
cache only once. Tables take the same form in memory as on disk,
making the use of this technique transparent
@tex
[@cite{oo7}]
@end tex
.
@end itemize

A RDBMS or OODBMS based on BATs strongly depends on our ability
to efficiently support tuples and to handle small joins, respectively.

The remainder of this document describes the Goblin Database kernel
implementation at greater detail. It is organized as follows:
@table @code
@item @strong{GDK Interface}:

It describes the global interface with which GDK sessions can be
started and ended, and environment variables used.

@item @strong{Binary Association Tables}:

As already mentioned, these are the primary data structure of GDK.
This chapter describes the kernel operations for creation, destruction
and basic manipulation of BATs and BUNs (i.e. tuples: Binary UNits).

@item @strong{BAT Buffer Pool:}

All BATs are registered in the BAT Buffer Pool. This directory is used
to guide swapping in and out of BATs. Here we find routines that guide
this swapping process.

@item @strong{GDK Extensibility:}

Atoms can be defined using an ADT interface.
with a unified interface. 
There is also an interface to extend the GDK library with
dynamically linked object code.

@item @strong{GDK Utilities:}

Memory allocation and error handling primitives are provided. Layers
built on top of GDK should use them, for proper system monitoring.
Thread management is also included here.

@item @strong{Transaction Management:}

For the time being, we just provide BAT-grained concurrency and global
transactions. Work is needed here.

@item @strong{BAT Alignment:}
Due to the mapping of multi-ary datamodels onto the BAT model,
we expect many correspondences among BATs, e.g.  @emph{bat(oid,attr1),..
bat(oid,attrN)} vertical decompositions. Frequent activities will be
to jump from one attribute to the other (`bunhopping'). If the head
columns are equal lists in two BATs, merge or even array lookups
can be used instead of hash lookups. The alignment interface makes
these relations explicitly manageable.

In GDK, complex data models are mapped with DSM on binary tables.
Usually, one decomposes @emph{N}-ary relations into @emph{N} BATs with
an @strong{oid} in the head column, and the attribute in the tail column.
There may well be groups of tables that have the same sets of 
@strong{oid}s, equally ordered. The alignment interface is intended to make
this explicit.  Implementations can use this interface to detect this
situation, and use cheaper algorithms (like merge-join, or even array
lookup) instead.

@item @strong{BAT Iterators:}

Iterators are C macros that generally encapsulate a complex for-loop.
They would be the equivalent of cursors in the SQL model. The macro
interface (instead of a function call interface) is chosen to achieve
speed when iterating main-memory tables.

@item @strong{Common BAT Operations:}

These are much used operations on BATs, such as aggregate functions
and relational operators. They are implemented in terms of BAT- and
BUN-manipulation GDK primitives.
@end table
@

@+ Interface Files
In this section we summarize the user interface to the GDK library.
It consist of a header file (gdk.h) and an object library (gdklib.a),
which implements the required functionality. The header file must be
included in any program that uses the library. The library must be
linked with such a program.

@- Database Context

The MonetDB environment settings are collected in a configuration
file. Amongst others it contains the location of the database
directory.
First, the database
directory is closed for other servers running at the same time.
Second, performance enhancements may take effect, such as locking
the code into memory (if the OS permits) and preloading the
data dictionary.
An error at this stage normally lead to an abort.
@{
@h
#ifndef _GDK_H_
#define _GDK_H_

#include <monet_utils.h>

/* standard includes upon which all configure tests depend */
#include <stdio.h>
#if HAVE_SYS_TYPES_H
# include <sys/types.h>
#endif
#if HAVE_SYS_STAT_H
# include <sys/stat.h>
#endif
#if STDC_HEADERS
# include <stdlib.h>
# include <stddef.h>
#else
# if HAVE_STDLIB_H
#  include <stdlib.h>
# endif
#endif
#if HAVE_STRING_H
# if !STDC_HEADERS && HAVE_MEMORY_H
#  include <memory.h>
# endif
# include <string.h>
#endif
#if HAVE_STRINGS_H
# include <strings.h>
#endif
#if HAVE_INTTYPES_H
# include <inttypes.h>
#else
# if HAVE_STDINT_H
#  include <stdint.h>
# endif
#endif
#if HAVE_UNISTD_H
# include <unistd.h>
#endif

#include <ctype.h>		/* isspace etc. */

#ifdef HAVE_SYS_FILE_H
# include <sys/file.h>
#endif
#ifdef HAVE_SYS_PARAM_H
# include <sys/param.h>		/* MAXPATHLEN */
#endif

#if HAVE_DIRENT_H
# include <dirent.h>
# define NAMLEN(dirent) strlen((dirent)->d_name)
#else
# define dirent direct
# define NAMLEN(dirent) (dirent)->d_namlen
# if HAVE_SYS_NDIR_H
#  include <sys/ndir.h>
# endif
# if HAVE_SYS_DIR_H
#  include <sys/dir.h>
# endif
# if HAVE_NDIR_H
#  include <ndir.h>
# endif
#endif

#if HAVE_SYS_WAIT_H
# include <sys/wait.h>
#endif
#ifndef WEXITSTATUS
# define WEXITSTATUS(stat_val) ((unsigned)(stat_val) >> 8)
#endif
#ifndef WIFEXITED
# define WIFEXITED(stat_val) (((stat_val) & 255) == 0)
#endif

#ifdef __cplusplus
extern "C" {
#endif

#include "gdk_system.h"
#include "gdk_posix.h"
#include <stream.h>

#undef MIN
#undef MAX
#define MAX(A,B)	((A)<(B)?(B):(A))
#define MIN(A,B)	((A)>(B)?(B):(A))

/* defines from ctype with casts that allow passing char values */
#define GDKisprint(c)   isprint((int) ((unsigned char) (c)))
#define GDKisspace(c)   isspace((int) ((unsigned char) (c)))
#define GDKisalnum(c)   isalnum((int) ((unsigned char) (c)))
#define GDKisgraph(c)   isgraph((int) ((unsigned char) (c)))
#define GDKisdigit(c)   (((unsigned char) (c)) >= '0' && ((unsigned char) (c)) <= '9')
#define GDKisxcntrl(c)  (((unsigned char) (c)) >= 128 && ((unsigned char) (c)) <= 160)
#define GDKisspecial(c) (((unsigned char) (c)) >= 161 && ((unsigned char) (c)) <= 191)
#define GDKisupperl(c)  (((unsigned char) (c)) >= 192 && ((unsigned char) (c)) <= 223)
#define GDKislowerl(c)  (((unsigned char) (c)) >= 224 && ((unsigned char) (c)) <= 255)

#define GDKPROP		6	/*      use one spare! */
#define MONETHOME	"MONETHOME"
#ifndef NATIVE_WIN32
#define BATDIR          "bat/"
#define DELDIR          "bat/DELETE_ME/"
#define BAKDIR          "bat/BACKUP/"
#define LEFTDIR         "bat/LEFTOVERS/"
#else
#define BATDIR          "bat\\"
#define DELDIR          "bat\\DELETE_ME\\"
#define BAKDIR          "bat\\BACKUP\\"
#define LEFTDIR         "bat\\LEFTOVERS\\"
#endif
#define DBLOGFILE	"MonetLog"

#ifdef MAXPATHLEN
#define PATHLENGTH 	MAXPATHLEN
#else
#define PATHLENGTH	256	/* maximum file pathname length */
#endif

@
@}

@- GDK session handling
@multitable @columnfractions 0.08 0.7
@item int
@tab GDKinit (char *db, char *dbfarm, int allocmap)
@item int
@tab GDKexit (int status)
@end multitable
@
The session is bracketed by @%GDKinit@ and @%GDKexit@. Initialization involves
setting up the administration for database access, such as memory allocation
for the database buffer pool.
During the exit phase any pending transaction is aborted and the database is
freed for access by other users.
A zero is returned upon encountering an erroneous situation.

@{
@- Definitions
The interface definitions for the application programs are shown
below.  The global variables should not be modified directly.
@h
#define NEG(A)	(((int)(A))>0?-((int)(A)):((int)(A)))
#define ABS(A)	(((int)(A))>0?((int)(A)):-((int)(A)))

#ifndef TRUE
#define TRUE	1
#define FALSE	0
#endif
#define BOUND2BTRUE	2	/* TRUE, and bound to be so */

#define IDLENGTH	64	/* maximum BAT id length */
#define OLDLENGTH	32	/* old max  BAT id length */
#define BATMARGIN	1.2	/* extra free margin for new heaps */
#define BATTINY		50	/* extra fixed margin for BATS */

#define TYPE_void	0
#define TYPE_bit	1
#define TYPE_chr	2
#define TYPE_sht	3
#define TYPE_bat	4	/* BAT id: index in BBPcache */
#define TYPE_int	5
#define TYPE_oid	6
#define TYPE_ptr	7	/* C pointer! */
#define TYPE_flt	8
#define TYPE_dbl	9
#define TYPE_lng	10
#define TYPE_str	11
#define TYPE_any	255	/* limit types to <255! */

typedef signed char bit;
typedef signed char chr;
typedef short sht;
#ifdef MONET_OID32
#define SIZEOF_OID	SIZEOF_INT
typedef unsigned int oid;
#else
#define SIZEOF_OID	SIZEOF_SIZE_T
typedef size_t oid;
#endif
typedef int bat;		/* Index into BBP */
typedef void *ptr;		/* Internal coding of types */
typedef float flt;
typedef double dbl;
typedef char *str;

#if SIZEOF_INT==8
#	define LL_CONSTANT(val)     (val)
#elif SIZEOF_LONG==8
#	define LL_CONSTANT(val)     (val##L)
#elif defined(HAVE_LONG_LONG)
#	define LL_CONSTANT(val)     (val##LL)
#elif defined(HAVE___INT64)
#	define LL_CONSTANT(val)     (val##i64)
#endif

/* Base types for all architectures.  These types work on IRIX (64 & 32)
   and for gcc on Linux. */
typedef unsigned char gdk_uint8;
typedef char gdk_int8;

typedef unsigned short gdk_uint16;
typedef short gdk_int16;

typedef unsigned int gdk_uint32;
typedef int gdk_int32;

#ifdef HAVE_LONG_LONG
typedef unsigned long long gdk_uint64;
typedef long long gdk_int64;
#endif

/* define printf formats for printing ptrdiff_t variables */
#if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901 && !defined(__svr4__) && !defined(WIN32) && !defined(__sgi)
#define PDFMT "%td"
#elif SIZEOF_PTRDIFF_T == SIZEOF_INT
#define PDFMT "%d"
#elif SIZEOF_PTRDIFF_T == SIZEOF_LONG
#define PDFMT "%ld"
#elif SIZEOF_PTRDIFF_T == SIZEOF_LONG_LONG || SIZEOF_PTRDIFF_T == SIZEOF___INT64
#define PDFMT LLFMT
#else
#error no definition for PDFMT
#endif

/* define printf format for printing pointer values */
#if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901
#define PTRFMT		"%p"
#define PTRFMTCAST		/* no cast needed */
#elif SIZEOF_VOID_P == SIZEOF_INT
#define PTRFMT		"%x"
#define PTRFMTCAST	(unsigned int)
#elif SIZEOF_VOID_P == SIZEOF_LONG
#define PTRFMT		"%lx"
#define PTRFMTCAST	(unsigned long)
#elif SIZEOF_VOID_P == SIZEOF_LONG_LONG
#define PTRFMT		"%llx"
#define PTRFMTCAST	(unsigned long long)
#elif SIZEOF_VOID_P == SIZEOF___INT64
#define PTRFMT		"%I64x"
#define PTRFMTCAST	(unsigned __int64)
#else
#error no definition for PTRFMT
#endif

typedef char *BUN;		/* pointer in some heap. */
typedef char long_str[IDLENGTH]; /* standard GDK static string */
typedef char short_str[OLDLENGTH]; /* old GDK small static string */

typedef oid hash_t;		/* type used for hash tables */
#if defined(MONET_OID32) || SIZEOF_INT==4
#define HASH_MAX INT_MAX
#else
#define HASH_MAX LLONG_MAX
#endif

typedef oid var_t;		/* type used for heap index of var-sized BAT */
#if SIZEOF_OID == SIZEOF_INT	/* a type compatible with var_t */
#define TYPE_var	TYPE_int
#else
#define TYPE_var	TYPE_lng
#endif

@- Checking and Error definitions:
@h
typedef enum { GDK_FAIL, GDK_SUCCEED } gdk_return;

gdk_export int GDKsilent;	/* should GDK shut up? */

#define FATALcheck(tst,	msg) if (tst) GDKfatal(msg);
#define ERRORcheck(tst,	msg) if (tst) { GDKerror(msg); return 0; }
#define WARNcheck(tst,	msg) if (tst) GDKwarning(msg)
#define BATcheck(tst,	msg) if (tst == NULL) {				\
				GDKerror("%s: BAT required.\n",msg);	\
				return 0;				\
			}

/* needed for mel */
#define ATOMextern(t)	(ATOMstorage(t) >= TYPE_str)

#define TYPEcastable(t1,t2)	(ATOMtype(t1)==ATOMtype(t2))
#define TYPEequal(t1,t2)	(ATOMtype(t1)==ATOMtype(t2))
#define TYPEcomp(t1,t2)	(ATOMstorage(ATOMtype(t1))==ATOMstorage(ATOMtype(t2)))
#define TYPEerror(t1,t2)	(!TYPEcomp(t1,t2))
#define TYPEcheck(t1,t2)						\
	if (TYPEerror(t1,t2)) {						\
		GDKerror("TYPEcheck: Incompatible types %s and %s.\n",	\
			ATOMname(t2), ATOMname(t1));			\
		return 0;						\
	} else if (!TYPEcomp(t1,t2)) {					\
		GDKwarning("Interpreting %s as %s.\n",			\
			ATOMname(t2), ATOMname(t1));			\
	}
#define BATcompatible(P1,P2) {						\
	ERRORcheck(P1 == NULL, "BATcompatible: BAT required\n");	\
	ERRORcheck(P2 == NULL, "BATcompatible: BAT required\n");	\
	if (TYPEerror(BAThtype(P1),BAThtype(P2)) ||			\
	    TYPEerror(BATttype(P1),BATttype(P2)))			\
	{								\
		GDKerror("Incompatible operands.\n");			\
		return 0;						\
	}								\
	if (BAThtype(P1) != BAThtype(P2) &&                             \
	    ATOMtype((P1)->htype) != ATOMtype((P2)->htype)) {		\
		GDKwarning("Interpreting %s as %s.\n",			\
			ATOMname(BAThtype(P2)), ATOMname(BAThtype(P1))); \
	}								\
	if (BATttype(P1) != BATttype(P2) &&                             \
	    ATOMtype((P1)->ttype) != ATOMtype((P2)->ttype)) {		\
		GDKwarning("Interpreting %s as %s.\n",			\
			ATOMname(BATttype(P2)), ATOMname(BATttype(P1))); \
	}								\
}
@h
typedef struct {
	size_t maxsize;		/* maximum realloc size (bytes) */
	size_t free;		/* index where free area starts. */
	size_t size;		/* size of the heap (bytes) */
	BUN base;		/* base pointer in memory. */
	sht storage;		/* storage status. */
	bit copied;		/* a copy of an existing map. */
	chr padding;		/* not used. */
	str filename;		/* file containing image of the heap */
} Heap;

typedef struct {
	int type;		/* type of index entity */
	size_t lim;		/* collision list size */
	hash_t mask;		/* number of hash buckets-1 (power of 2) */
	hash_t *hash;		/* hash table */
	hash_t *link;		/* collision list */
	Heap   *heap;		/* heap where the hash is stored */
} Hash;

@
@}

@+ Binary Association Tables
Having gone to the previous preliminary definitions, we will
now introduce the structure of Binary Association Tables (BATs)
in detail. They are the basic storage unit on which GDK is modelled.

The BAT holds an unlimited number of binary associations, called
BUNs (@strong{Binary UNits}).  The two attributes of a BUN are called
@strong{head} (left) and @strong{tail} (right) in the remainder of this
document.

@image{bat1}

The above figure shows what a BAT looks like. It consists of two
columns, called head and tail, such that we have always binary tuples
(BUNs). The overlooking structure is the @strong{BAT
record}.  It points to a heap structure called the @strong{BUN heap}.
This heap contains the atomic values inside the two columns. If they
are fixed-sized atoms, these atoms reside directly in the BUN heap. If
they are variable-sized atoms (such as string or polygon), however,
the columns has an extra heap for storing those (such
@strong{variable-sized atom heaps} are then
referred to as @strong{Head Heap}s and @strong{Tail Heap}s). The BUN heap then
contains integer byte-offsets (fixed-sized, of course) into a head-
or tail-heap.
@
The BUN heap contains a contiguous range of BUNs. It starts after
the @strong{first} pointer, and finishes at the end in the @strong{free}
area of the BUN. All BUNs after the @strong{inserted} pointer have been
added in the last transaction (and will be deleted on a transaction
abort). All BUNs between the @strong{deleted} pointer and the @strong{first}
have been deleted in this transaction (and will be reinserted at a
transaction abort).

@-
The location of a certain BUN in a BAT
may change between successive library routine invocations.  Therefore, one
should avoid keeping references into the BAT storage area for long
periods.
@
Passing values between the library routines and the enclosing C
program is primarily through value pointers of type @%ptr@. Pointers
into the BAT storage area should only be used for retrieval. Direct
updates of data stored in a BAT is forbidden. The user should adhere
to the interface conventions to guarantee the integrity rules and to
maintain the (hidden) auxiliary search structures.

@- GDK variant record type
When manipulating values, MonetDB puts them into value records.
The built-in types have a direct entry in the union. Others should
be represented as a pointer of memory in pval or as a string, which
is basically the same. In such cases the @%len@ field indicates
the size of this piece of memory.

@{
@h
typedef struct {
	bat id;
	int stamp;
} batrec;

typedef struct {
	union {			/* storage is first in the record */
		int ival;
		oid oval;
		sht shval;
		chr cval[4];
		flt fval;
		ptr pval;
		bat bval;
		batrec br;	/* bval + stamp */
		str sval;
		dbl dval;
		lng lval;
	} val;
	int vtype;
	int len;
} *ValPtr, ValRecord;

#define VALptr(v) (ATOMextern((v)->vtype)?(v)->val.pval:(ptr)&(v)->val.ival)
#define VALnil(v,t) VALset(v,t,ATOMextern(t)?ATOMnil(t):ATOMnilptr(t))

/* interface definitions */
gdk_export ValPtr VALnew(void);
gdk_export ptr VALconvert(int typ, ValPtr t);
gdk_export int VALformat(char **buf, ValPtr res);
gdk_export int VALprint(stream *fd, ValPtr res);
gdk_export ValPtr VALcopy(ValPtr dst, ValPtr src);
gdk_export ValPtr VALinit(ValPtr d, int tpe, ptr s);
gdk_export void VALempty(ValPtr v);
gdk_export void VALclear(ValPtr v);
gdk_export ValPtr VALset(ValPtr v, int t, ptr p);
gdk_export void *VALget(ValPtr v);
@}

@- The BAT record

The elements of the BAT structure are introduced in the remainder.
Instead of using the underlying types hidden beneath it, one should
use a @%BAT@ type that is supposed to look like this:
@example
typedef struct {
          /* static BAT properties */
          bat    batCacheid;       /* bat id: index in BBPcache */
          int    batPersistence;   /* persistence mode */
          bit    batCopiedtodisk;  /* BAT is saved on disk? */
          bit    batSet;           /* all tuples in the BAT are unique? */
          int    batStore;         /* multi-level storage mode */
          sht    batElmshift       /* log2 of width  */
          sht    batElmsize        /* width in byte of the BUNs */
          /* dynamic BAT properties */
          int    batHeat;          /* heat of BAT in the BBP */
          sht    batDirty;         /* BAT modified after last commit? */
          bit    batDirtydesc;     /* BAT descriptor specific dirty flag */
          bit    batDirtybuns;     /* BUN heap specific dirty flag */
          Heap*  batBuns;          /* Heap where the buns are stored */
          /* DELTA status */
          BUN    batDeleted;       /* first deleted BUN */
          BUN    batFirst;         /* empty BUN before the first alive BUN */
          BUN    batInserted;      /* first inserted BUN */
          size_t batCount;         /* Tuple count */
          /* Head properties */
          int    htype;            /* Head type number */
          str    hident;           /* name for head column */
          bit    hkey;             /* head values should be unique? */
          bit    hsorted;          /* are head values currently ordered? */
          bit    hvarsized;        /* for speed: head type is varsized? */
	  oid	 halign;	   /* alignment OID for head. */
          bit    hheapdirty;       /* head heap specific dirty flag */
          /* Head storage */
          int    hloc;             /* byte-offset in BUN for head elements */
          Heap   *hheap;           /* heap for varsized head values */
          Hash   *hhash;           /* linair chained hash table on head */
          /* Tail properties */
          int    ttype;            /* Tail type number */
          str    tident;           /* name for tail column */
          bit    tkey;             /* tail values should be unique? */
          bit    tsorted;          /* are tail values currently ordered? */
          bit    tvarsized;        /* for speed: tail type is varsized? */
	  oid	 talign;	   /* alignment OID for head. */
          bit    theapdirty;       /* tail heap specific dirty flag */
          /* Tail storage */
          int    tloc;             /* byte-offset in BUN for tail elements */
          Heap   theap;            /* heap for varsized tail values */
          Hash   thash;            /* linair chained hash table on tail */
 } BAT;
@end example

The internal structure of the @strong{BAT} record is in fact much more complex,
but GDK programmers should refrain of making use of that.

This reason for this complex structure is
to allow for a BAT to exist in two incarnations at the time: the
@emph{normal view} and the @emph{reversed view}. Each bat @emph{b} has a
 BATmirror(@emph{b}) which has the negative @strong{cacheid} of b in the BBP.

Since we don't want to pay cost to keep both views in line with each other
under BAT updates, we work with shared pieces of memory between
the two views. An update to one will thus automatically update the other.
in the same line, we allow @strong{synchronized BATs} (BATs with identical
head columns, and marked as such in the @strong{BAT Alignment} interface) now to
be clustered horizontally.

@image{bat2}
@

@{
@h
typedef struct {
	chr headtype;		/* type id. */
	chr tailtype;		/* type id. */
	unsigned short headloc;	/* offset into bun. */
	unsigned short tailloc;	/* offset into bun. */
	bit headkey;		/* duplicates allowed? */
	bit tailkey;		/* duplicates allowed? */
	bit headvarsized;	/* varsized(>0) or fixedsized(0). */
	bit tailvarsized;	/* varsized(>0) or fixedsized(0). */
	chr bunshift;		/* log2 of bunwidth */
	unsigned short bunwidth; /* byte-width of BUN array */
	oid hseq;		/* start of dense head sequence */
	oid tseq;		/* start of dense tail sequence */
} Dimensions;

typedef struct {
	MT_Id tid;		/* which thread created it */
	int stamp;		/* BAT recent creation stamp */

	sht persistence;	/* should the BAT persist on disk? */
	chr dirtyflushed;	/* saved dirty marker */
	chr copiedtodisk;	/* once written */
	chr set;		/* real set semantics */
	chr restricted;		/* access priviliges */
	chr dirty;		/* general dirty marker */
	chr descdirty;		/* bat descriptor dirty marker */
	chr bunsdirty;		/* bun heap dirty marker */
	chr sharecnt;		/* VIEW share count */
	bat parentid;		/* cache id of VIEW parent bat */

	char map_dirty;		/* new mmap mode present */
	char map_buns;		/* mmap mode for bun heap */
	char map_hheap;		/* mmap mode for head atom heap */
	char map_theap;		/* mmap mode for tail atom heap */
} BATrec;

typedef struct {
	/* bunheap data */
	Heap buns;		/* space for the buns. */
	/* delta status administration */
	BUN deleted;		/* start of deleted elements */
	BUN first;		/* to store next deletion */
	BUN inserted;		/* start of inserted elements */
	size_t count;		/* tuple count */
} BUNrec;

typedef struct PROPrec {
	int 	  id;
	ValRecord v;
	struct PROPrec *next;	/* simple chain of properties */
} PROPrec;

typedef struct {
	str   id;		/* label for head/tail column */
	Heap *vheap;		/* space for the head/tail column. */
	chr heapdirty;		/* specific heap dirty marker */
	bit sorted;		/* 0=false, 1=true; */
	bit dense;		/* 0=false, 1=true; */
	oid align;		/* OID for sync alignment */
	size_t nosorted_rev;	/* position that proves sorted_rev==FALSE */
	size_t nokey[2];	/* positions that prove key ==FALSE */
	size_t nosorted;	/* position that proves sorted==FALSE */
	size_t nodense;		/* position that proves dense==FALSE */
	PROPrec *props;		/* list of dynamic properties stored in the bat descriptor */
} COLrec;

typedef struct {
	/* static bat properties */
	sht GDKversion;		/* FIRST! */
	bat batCacheid;		/* index into BBP */
	Dimensions dims;	/* BAT dimensions */
	Heap *batBuns;		/* pointer to U->buns */

	/* static column properties */
	Hash *hhash;		/* head hash table */
	Hash *thash;		/* tail hash table */

	/* dynamic column properties */
	COLrec *H;		/* column info */
	COLrec *T;		/* column info */

	/* dynamic bat properties */
	BATrec *P;		/* cache and sort info */
	BUNrec *U;		/* cache and sort info */

	/* void hack fields */
	int void_tid;		/* thread that reads this bat */
	int void_cnt;		/* nr of reads */
	oid void_seq1;
	oid void_seq2;
} BAT;

@-
The different parts of which a BAT consists are physically stored
next to each other in the @%BATstore@ type.
@h
typedef struct {
	BAT B;			/* storage for BAT descriptor */
	COLrec H;		/* storage for head column */
	COLrec T;		/* storage for tail column */
	BATrec P;		/* storage for BATrec */
	BUNrec U;		/* storage for BUNrec */
} BATstore;

typedef int (*GDKfcn) ();

/* macros's to hide complexity of BAT structure */
#define batPersistence	P->persistence
#define batCopiedtodisk	P->copiedtodisk
#define batSet		P->set
#define batStore	P->store
#define batDirtyflushed	P->dirtyflushed
#define batDirty	P->dirty
#define batConvert	P->convert
#define batDirtydesc	P->descdirty
#define batDirtybuns	P->bunsdirty
#define hheapdirty	H->heapdirty
#define theapdirty	T->heapdirty
#define batFirst	U->first
#define batInserted	U->inserted
#define batDeleted	U->deleted
#define batCount	U->count
#define batParentid	P->parentid
#define batStamp	P->stamp
#define batSharecnt	P->sharecnt
#define batRestricted	P->restricted
#define batLastused	P->lastused
#define creator_tid	P->tid
#define batElmsize	dims.bunwidth
#define batElmshift	dims.bunshift
#define htype		dims.headtype
#define ttype		dims.tailtype
#define hloc		dims.headloc
#define tloc		dims.tailloc
#define hkey		dims.headkey
#define tkey		dims.tailkey
#define hvarsized	dims.headvarsized
#define tvarsized	dims.tailvarsized
#define hseqbase	dims.hseq
#define tseqbase	dims.tseq
#define hsorted		H->sorted
#define tsorted		T->sorted
#define hdense		H->dense
#define tdense		T->dense
#define hheap		H->vheap
#define theap		T->vheap
#define hident		H->id
#define tident		T->id
#define halign		H->align
#define talign		T->align

#define batMapdirty	P->map_dirty
#define batMapbuns	P->map_buns
#define batMaphheap	P->map_hheap
#define batMaptheap	P->map_theap
@
@}

@- Heap Management
Heaps are the low-level entities of mass storage in BATs. Currently,
they can either be stored on disk, loaded into memory, or memory mapped.
@multitable @columnfractions 0.08 0.7
@item int
@tab
 HEAPalloc (Heap *h, size_t nitems, size_t itemsize);
@item int
@tab
 HEAPfree (Heap *h);
@item int
@tab
 HEAPextend (Heap *h, size_t size);
@item int
@tab
 HEAPload (Heap *h, str nme,ext, int trunc);
@item int
@tab
 HEAPsave (Heap *h, str nme,ext);
@item int
@tab
 HEAPcopy (Heap *dst,*src);
@item int
@tab
 HEAPdelete (Heap *dst, str o, str ext);
@end multitable

@
These routines should be used to alloc free or extend heaps;
they isolate you from the different ways heaps can be accessed.
@{
@h
gdk_export int HEAPalloc(Heap *h, size_t nitems, size_t itemsize);
gdk_export int HEAPfree(Heap *h);
gdk_export int HEAPextend(Heap *h, size_t size);
gdk_export int HEAPload(Heap *h, str nme, str ext, int trunc);
gdk_export int HEAPsave(Heap *h, str nme, str ext);
gdk_export int HEAPcopy(Heap *dst, Heap *src);
gdk_export size_t HEAPsubcopy(Heap *dst, Heap *src, size_t size, size_t offset);
gdk_export int HEAPdelete(Heap *h, str o, str ext);
gdk_export size_t HEAPvmsize(Heap *h);
gdk_export size_t HEAPmemsize(Heap *h);
@}
@- Internal HEAP Chunk Management
Heaps are used in BATs to store data for variable-size atoms.
The implementor must manage malloc()/free() functionality for
atoms in this heap. A standard implementation is provided here.

@table @code
@item void
HEAP_initialize  (Heap* h, size\_t nbytes, size\_t nprivate, int align )
@item void
HEAP_destroy     (Heap* h)
@item int
HEAP_malloc      (Heap* heap, size\_t nbytes)
@item void
HEAP_free        (Heap *heap, size\_t block)
@item int
HEAP_private     (Heap* h)
@item void
HEAP_printstatus (Heap* h)
@item void
HEAP_check       (Heap* h)
@end table

The heap space starts with a private space that is left untouched by
the normal chunk allocation.  You can use this private space e.g. to
store the root of an rtree
@%HEAP_malloc@ allocates a chunk of memory on the heap, and returns an
index to it.  @%HEAP_free@ frees a previously allocated chunk
@%HEAP_private@ returns an integer index to private space.
@{
@h
/* structure used by HEAP_check functions */
typedef struct {
	size_t minpos;		/* minimum block byte-index */
	size_t maxpos;		/* maximum block byte-index */
	int alignment;		/* block index alignment */
	size_t *validmask;	/* bitmap with all valid byte-indices
				 * first bit corresponds with 'minpos';
				 * 2nd bit with 'minpos+alignment', etc
				 */
} HeapRepair;

gdk_export void HEAP_initialize(Heap *heap, /* nbytes -- Initial size of the heap. */
				size_t nbytes, /* alignment -- for objects on the heap. */
				size_t nprivate, /* nprivate -- Size of private space */
				int alignment /* alignment restriction for allocated chunks */
	);

gdk_export void HEAP_initialize_compact(Heap *heap, /* nbytes -- Initial size of the heap. */
					size_t nbytes, /* alignment -- for objects on the heap. */
					size_t nprivate, /* nprivate -- Size of private space */
					int alignment, /* alignment restriction for allocated chunks */
					int (*sizefcn) (ptr) /* BATatoms[].atomLen function */
	);

gdk_export var_t HEAP_malloc(Heap *heap, size_t nbytes);
gdk_export void HEAP_free(Heap *heap, var_t block);
gdk_export size_t HEAP_private(Heap *h);
gdk_export void HEAP_checkformat(Heap *h);
gdk_export int HEAP_check(Heap *h, HeapRepair *hr);
gdk_export void HEAP_init(Heap *heap, int tpe);
gdk_export int HEAP_mmappable(Heap *heap);

#define HEAP_index(HEAP,INDEX,TYPE)	((TYPE *)((char *) (HEAP)->base + (INDEX)))

@}
@- BAT construction
@multitable @columnfractions 0.08 0.7
@item @code{BAT* }
@tab BATnew (int headtype, int tailtype, size_t cap)
@item @code{BAT* }
@tab BATtmp (BAT *b, int mode)
@item @code{BAT* }
@tab BATextend (BAT *b, size_t newcap)
@end multitable
@
A temporary BAT is instantiated using @%BATnew@ with the type aliases of
the required binary association. The aliases include the built-in
types, such as @%TYPE_int@....@%TYPE_ptr@, and the atomic types introduced
by the user. The initial capacity to be accommodated within a BAT is
indicated by @%cap@.
Their extend is automatically incremented upon storage overflow.
Failure to create the BAT results in a NULL pointer.
@
The routine @%BATtmp@ creates an empty BAT storage area with the properties
inherited from its argument. However, its default retention period is the
transaction in which it is created.
@{
@h
#define BATDELETE	-9999

gdk_export BAT *BATnew(int hdtype, int tltype, size_t capacity);
gdk_export BAT *BATtmp(BAT *b, int mode);
gdk_export BAT *BATextend(BAT *b, size_t newcap);

/* internal */
gdk_export BAT *BATnewstorage(int ht, int tt, size_t cap);
gdk_export BAT *BATcreatedesc(int ht, int tt, int heapnames);
gdk_export int BATfree(BAT *b);
gdk_export void BATdestroy(BAT *b);
gdk_export int BATelmshift(BAT *b);
gdk_export void BATsetdims(BAT *b);
gdk_export int BBPreclaim(BAT *b);
@
@}



@- BUN manipulation
@multitable @columnfractions 0.08 0.7
@item BAT*
@tab BATins (BAT *b, ptr *c)
@item BAT*
@tab BATdel (BAT *b, ptr *c)
@item BAT*
@tab BUNins (BAT *b, ptr left, ptr right)
@item BAT*
@tab BUNreplace (BAT *b, ptr left, ptr right)
@item int
@tab BUNdel (BAT *b, ptr left, ptr right)
@item int
@tab BUNdelHead (BAT *b, ptr left)
@item BUN
@tab BUNfnd (BAT *b, ptr head)
@item void
@tab BUNfndOID (BUN result, BAT *b, oid *head)
@item void
@tab BUNfndSTD (BUN result, BAT *b, ptr head)
@item BUN
@tab BUNlocate (BAT *b, ptr head, ptr tail)
@item ptr
@tab BUNhead (BAT *b, BUN p)
@item ptr
@tab BUNtail (BAT *b, BUN p)
@end multitable
@
The BATs contain a number of fixed-sized slots to store the binary
associations.  These slots are called BUNs or BAT units. A BUN
variable is a pointer into the storage area of the BAT, but it has
limited validity. After a BAT modification, previously obtained BUNs
may no longer reside at the same location.
@
The association list does not contain holes.  This density permits
users to quickly access successive elements without the need to test
the items for validity. Moreover, it simplifies transport to disk and
other systems. The negative effect is that the user should be aware of
the evolving nature of the sequence, which may require copying the BAT
first.
@
The update operations come in three flavors. Element-wise updates
can use @%BUNins@, @%BUNreplace@, @%BUNdel@, and @%BUNdelHead@.
The batch update operations are @%BATins@ and @%BATdel@.
@
Only experts interested in speed may use @%BUNfastins@, since it skips most
consistency checks, does not update search accelerators, and does
not maintain properties such as the @%hsorted@ and @%tsorted@ flags. Beware!
@
The routine @%BUNfnd@ provides fast access to a single BUN providing
a value for the head of the binary association.
A very fast shortcut for @%BUNfnd@ if the selection type is known to be
integer or OID, is provided in the form of the macro @%BUNfndOID@.
@
To select on a tail, one should use the reverse view obtained by
@%BATmirror@.
@
The routines @%BUNhead@ and @%BUNtail@ return a pointer to the first
and second value in an association, respectively.  To guard against
side effects on the BAT, one should normally copy this value into a
scratch variable for further processing.

Behind the interface we use several macros to access the BUN fixed
part and the variable part. The BUN operators always require a BAT pointer
and BUN identifier.
@itemize
@item
BAThtype(b) and  BATttype(b) find out the head and tail type of a BAT.
@item
BUNfirst(b) returns a BUN pointer to the first BUN as a BAT.
@item
BUNlast(b) returns the BUN pointer directly after the last BUN
in the BAT.
@item
BUNsize(b) gives the size in bytes of each BUN.
@item
BUNindex(b, p) computes the index number of a given BUN.
@item
BUNptr(b, i) computes the address of the i-th BUN in the BAT.
@item
BUNhead(b, p) and BUNtail(b, p) return pointers to the
head-value and tail-value in a given BUN.
@item
BUNhloc(b, p) and BUNtloc(b, p) do the same thing, but knowing
in advance that the head-atom resp. tail-atom of a BAT is fixed size.
@item
BUNhvar(b, p) and BUNtvar(b, p) do the same thing, but knowing
in advance that the head-atom resp. tail-atom of a BAT is variable sized.
@end itemize
@{
@h
#define bunfastins_nocheck(b, p, h, t, s) {				\
		(b)->batBuns->free += s;				\
		(b)->batCount ++;				        \
		ATOMput((b)->htype, (b)->hheap, BUNhloc(b, p), h);	\
		ATOMput((b)->ttype, (b)->theap, BUNtloc(b, p), t);	\
	}

#define bunfastins(b, h, t) {						\
		REGISTER BUN _p = BUNlast(b);				\
		REGISTER size_t _bunsize = BUNsize(b);			\
		if ((b)->batBuns->free + _bunsize > (b)->batBuns->size) { \
			if (BATextend((b), BATgrows(b)) == NULL) goto bunins_failed; \
			_p = BUNlast(b);				\
		}							\
		bunfastins_nocheck(b, _p, h, t, _bunsize);		\
	}

gdk_export BAT *BUNfastins(BAT *b, ptr left, ptr right);
gdk_export BAT *BUNins(BAT *b, ptr left, ptr right);
gdk_export BAT *BATins(BAT *b, BAT *c);
gdk_export BAT *BUNdel(BAT *b, ptr left, ptr right);
gdk_export BAT *BUNdelHead(BAT *b, ptr left);
gdk_export BUN BUNdelete(BAT *b, BUN p);
gdk_export BAT *BATdel(BAT *b, BAT *c);
gdk_export BAT *BATdelHead(BAT *b, BAT *c);

gdk_export BAT *BUNreplace(BAT *b, ptr left, ptr right);
gdk_export BAT *BUNinplace(BAT *b, BUN p, ptr left, ptr right);
gdk_export BAT *BATreplace(BAT *b, BAT *n);

gdk_export BUN BUNlocate(BAT *b, ptr left, ptr right);
gdk_export BUN BUNfnd(BAT *b, ptr left);

#define BUNfndVOID(p,b,v)						\
	if ((*(oid*) (v) == oid_nil) != ((b)->hseqbase == oid_nil)) {	\
		/* (v == ni) XOR (seqbase == nil) ! */			\
		/* What about (v == nil) AND (seqbase == nil) ? */	\
		p = NULL;						\
	} else {							\
		REGISTER size_t _i = BUNindex((b),BUNfirst((b))) + (*(oid*) (v) - (b)->hseqbase); \
		p = BUNptr((b), _i);  if (p < BUNfirst(b) || p >= BUNlast(b)) p = NULL;	\
	}
#if SIZEOF_OID == SIZEOF_INT
#define BUNfndOID(p,b,v)			\
	if (BAThdense(b)) {			\
		BUNfndVOID(p,b,v);		\
	} else {				\
		HASHfnd_int(p,b,(int*)v);	\
	}
#else
#define BUNfndOID(p,b,v)			\
	if (BAThdense(b)) {			\
		BUNfndVOID(p,b,v);		\
	} else {				\
		HASHfnd_lng(p,b,(lng*)v);	\
	}
#endif
#define BUNfndSTD(p,b,v) ((p) = BUNfnd(b,v))

#define BAThtype(b)	((b)->htype == TYPE_void && (b)->hseqbase == oid_nil ?\
				TYPE_void : ATOMtype((b)->htype))
#define BATttype(b)	((b)->ttype == TYPE_void && (b)->tseqbase == oid_nil ?\
				TYPE_void : ATOMtype((b)->ttype))
#define BAThstore(b)	(BAThdense(b) ? TYPE_void : (b)->htype)
#define BATtstore(b)	(BATtdense(b) ? TYPE_void : (b)->ttype)
#define Bunbase(b)	((b)->batBuns->base)
#define Hbase(b)	((b)->hheap->base)
#define Tbase(b)	((b)->theap->base)

#define BUNhead(b,p)	((b)->hvarsized ? BUNhvar(b,p) : BUNhloc(b,p))
#define BUNtail(b,p)	((b)->tvarsized ? BUNtvar(b,p) : BUNtloc(b,p))

#define BUNsize(b)	((b)->dims.bunwidth)
#define BUNptr(b,i)	((BUN) ((char *) Bunbase(b) + ((b)->batElmshift < 0 ? \
				(i) * BUNsize(b) : (i) << (b)->batElmshift)))
#define BUNindex(b,p)	((size_t) ((b)->batElmshift < 0 ? \
				   (((char*)(p)-(char*)Bunbase(b))/BUNsize(b)) : \
				   (((char*)(p)-(char*)Bunbase(b)) >> (b)->batElmshift)))

#define BUNhloc(b,p)	((BUN) (((char *) (p)) + (b)->hloc))
#define BUNtloc(b,p)	((BUN) (((char *) (p)) + (b)->tloc))
#define BUNhvar(b,p)	((b)->htype?(BUN)((char *) Hbase(b)+*(var_t*)BUNhloc(b,p)):(BUN)BUNhpos(b,p))
#define BUNtvar(b,p)	((b)->ttype?(BUN)((char *) Tbase(b)+*(var_t*)BUNtloc(b,p)):(BUN)BUNtpos(b,p))

#define BUNfirst(b)	((BUN) (b)->batFirst)
#define BUNlast(b)	((BUN) ((char *) Bunbase(b) + (b)->batBuns->free))
#define BUNnext(b,p)	((BUN) ((char *) (p) + BUNsize(b)))
#define BUNprev(b,p)	((BUN) ((char *) (p) - BUNsize(b)))

#define BUNgetpos(b,p)	(((b)->batElmshift < 0)?\
				((p-BUNfirst(b)) / BUNsize(b)):\
				((p-BUNfirst(b)) >> (b)->batElmshift))
@
@}

@- BAT properties
@multitable @columnfractions 0.08 0.7
@item size_t
@tab BATcount (BAT *b)
@item size_t
@tab BATbuncount (BAT *b)
@item str
@tab BATrename (BAT *b, str nme)
@item BAT *
@tab BATkey (BAT *b, int onoff)
@item BAT *
@tab BATset (BAT *b, int onoff)
@item BAT *
@tab BATmode (BAT *b, int mode)
@item BAT *
@tab BATsetaccess (BAT *b, int mode)
@item int
@tab BATdirty (BAT *b)
@item int
@tab BATgetaccess (BAT *b)
@item int
@tab BATversion (BAT *b)
@end multitable
@
The function @%BATcount@ returns the number of associations
stored in the BAT.
@
The function @%BATbuncount@ returns the space that is occupied in
associations in the BAT. This is not the same as @%BATcount@,
since the first N associations may be unused or delta data.
@
The BAT is given a new logical name using @%BATrename@.
@
The integrity properties to be maintained for the BAT are controlled separately.
A key property indicates that duplicates
in the association dimension are not permitted. The BAT is turned into
a set of associations using @%BATset@. Key and set properties
are orthogonal integrity constraints.
The strongest reduction is obtained by making the BAT a set with key
restrictions on both dimensions.
@
The persistency indicator tells indicates the retention period of BATs.
The system support four modes:
PERSISTENT, TRANSIENT, and SESSION.
The PERSISTENT BATs are automatically saved upon session boundary or
transaction commit.
TRANSIENT BATs are removed upon transaction boundary.
SESSION BATs are removed at the end of a session.
They are normally used to maintain temporary results.
All BATs are initially TRANSIENT unless their mode is changed
using the routine @%BATmode@.
@
The BAT properties may be changed at any time using @%BATkey@, @%BATset@,
and @%BATmode@.

Valid BAT access properties can be set with @%BATsetaccess@ and @%BATgetaccess@:
BAT_READ, BAT_APPEND, and BAT_WRITE.
BATs can be designated to be read-only. In this case some
memory optimizations may be made (slice and fragment bats can point
to stable subsets of a parent bat).
A special mode is append-only. It is then allowed to insert BUNs
at the end of the BAT, but not to modify anything that already
was in there.
@{
@h
gdk_export str BATrename(BAT *b, str nme);
gdk_export size_t BATcount(BAT *b);
gdk_export size_t BATcount_no_nil(BAT *b);
gdk_export size_t BATbuncount(BAT *b);
gdk_export size_t BATguess(BAT *b);
gdk_export size_t BATgrows(BAT *b);
gdk_export BAT *BATkey(BAT *b, int onoff);
gdk_export BAT *BATset(BAT *b, int onoff);
gdk_export BAT *BATmode(BAT *b, int onoff);
gdk_export BAT *BATroles(BAT *b, str hnme, str tnme);
gdk_export BAT *BATcol_name(BAT *b, str tnme);
gdk_export int BATname(BAT *b, str nme);
gdk_export BAT *BATseqbase(BAT *b, oid o);
gdk_export BAT *BATsetaccess(BAT *b, int mode);
gdk_export int BATgetaccess(BAT *b);
gdk_export int BATcheckmodes(BAT *b, int persistent, int unloadable);


#define BATdirty(b)	((b)->batCopiedtodisk == 0 || (b)->batDirty ||	\
			(b)->batDirtydesc || (b)->batDirtybuns ||	\
			(b)->hheapdirty || (b)->theapdirty)

#define PERSISTENT	4096
#define SESSION		2048
#define TRANSIENT	1024

#define BAT_WRITE		0	/* all kinds of access allowed */
#define BAT_READ		1	/* only read-access allowed */
#define BAT_APPEND		2	/* only reads and appends allowed */

#define BATversion(b)	(b)->GDKversion
#define BATcapacity(b)	((size_t) (((b)->batElmshift<0)?		\
				   (((b)->batBuns->size)/BUNsize(b)):	\
				   (((b)->batBuns->size) >> (b)->batElmshift)))
@
@}

@- BAT manipulation
@multitable @columnfractions 0.08 0.7
@item BAT *
@tab BATclear (BAT *b)
@item BAT *
@tab BATcopy (BAT *b)
@item BAT *
@tab BATrcopy(BAT *b)
@item BAT *
@tab BATmark (BAT *b, oid base)
@item BAT *
@tab BATmark_grp (BAT *b, BAT *g)
@item BAT *
@tab BATnumber (BAT *b)
@item BAT *
@tab BATmirror (BAT *b)
@item BAT *
@tab BATreverse (BAT *b)
@item BAT *
@tab BATreset (BAT *b)
@end multitable
@
The routine @%BATclear@ removes the binary associations, leading
to an empty, but (re-)initialized BAT. Its properties are retained.
A temporary copy is obtained with @%BATcopy@. The new BAT has an unique name.
The routine @%BATmark@ creates a binary association that
introduces a new tail column of fresh densely ascending OIDs.
The base OID can be given explicitly, or if oid_nil is passed,
is chosen as a new unique range by the system.
A similar routine is @%BATnumber@, which copies the heads and
assigns an integer index to the tail.
It plays a crucial role in administration of query results.
@
The routine @%BATmirror@ returns the mirror image BAT (where tail is head
and head is tail) of that same BAT. This does not involve
a state change in the BAT (as previously): both views on the BAT
exist at the same time. 
@{
@h
gdk_export BAT *BATclear(BAT *b);
gdk_export BAT *BATcopy(BAT *b);
gdk_export BAT *BATrcopy(BAT *b);
gdk_export BAT *BATmark(BAT *b, oid base);
gdk_export BAT *BATnumber(BAT *b);
gdk_export BAT *BATgroup(BAT *b, int start, int incr, int grpsize);
@
@}


@- BAT Input/Output
@multitable @columnfractions 0.08 0.7
@item BAT *
@tab BATload (str name)
@item BAT *
@tab BATsave (BAT *b)
@item int
@tab BATmmap (BAT *b, int bn, int hh, int th )
@item int
@tab BATmadvise (BAT *b, int bn, int hh, int th )
@item int
@tab BATmmap_pin (BAT *b)
@item int
@tab BATmmap_unpin (BAT *b)
@item int
@tab BATdelete (BAT *b)
@item BAT *
@tab BATconvert (str name, int direction)
@end multitable
@-
A BAT created by @%BATnew@ is considered temporary until one calls the
routine @%BATsave@ or @%BATmode@.  This routine reserves disk space
and checks for name clashes in the BAT directory. It also makes the
BAT persistent. The empty BAT is initially marked as ordered on both
columns.
@
Failure to read or write the BAT results in a NULL, otherwise it
returns the BAT pointer.
@
The @%BATconvert@ converts a BAT that contains data saved on
hardware with a different byte order (little endian vs big endian),
into the correct format. Direction is either CONV_NTOH or CONV_HTON,
indication conversion from network to host or host to network format.
@
MonetDB now has a mmap trim thread that takes care of flushing the
memory mapped regions when MonetDB starts to consume too much
main memory. Heaps (that are randomly accessed) can be excluded
from this mechanism, by pinning them. BATmmap\_pin/unpin do
this for all heaps of a BAT.

@- Heap Storage Modes
The discriminative storage modes are memory-mapped, compressed, or 
loaded in memory.
The @strong{BATmmap()} changes the storage mode of each heap associated to 
a BAT.
As can be seen in the bat record, each BAT has one BUN-heap (@emph{bn}), and
possibly two heaps (@emph{hh} and @emph{th}) for variable-sized atoms.
@
The @%BATmadvise@ call works in the same way. Using the @%madvise()@ system
call it issues buffer management advise to the OS kernel, as for the
expected usage pattern of the memory in a heap.
@{
@h
/* Heap storage modes */
#define STORE_MODEMASK	0xFF	/* mask for below bits */
#define STORE_MEM	0	/* load into GDKmalloced memory */
#define STORE_MMAP	1	/* mmap() into virtual memory */
#define STORE_PRIV	2	/* BAT copy of copy-on-write mmap */

/* Flags to be ORed into above mode bits */
#define STORE_VARSIZE	0x100	/* variable sized */

/* Buffer management advise for heaps */
#define BUF_NORMAL	0	/* No further special treatment */
#define BUF_RANDOM	1	/* Expect random page references */
#define BUF_SEQUENTIAL	2	/* Expect sequential page references */
#define BUF_WILLNEED	3	/* Will need these pages */
#define BUF_DONTNEED	4	/* Don't need these pages */

gdk_export BAT *BATload(str nme);
gdk_export BAT *BATload_intern(bat bid);
gdk_export BAT *BATsave(BAT *b);
gdk_export int BATmmap(BAT *b, int bn, int hh, int th );
gdk_export int BATmmap_pin(BAT *b);
gdk_export int BATmmap_unpin(BAT *b);
gdk_export int BATmadvise(BAT *b, int bn, int hh, int th );
gdk_export int BATdelete(BAT *b);
gdk_export size_t BATvmsize(BAT *b, int dirty);
gdk_export size_t BATmemsize(BAT *b, int dirty);

gdk_export int GDKfdlocate(str nme, str mode, str ext);
gdk_export FILE *GDKfilelocate(str nme, str mode, str ext);
gdk_export void GDKfilepath(str path, str nme, str mode, str ext);
gdk_export int GDKcreatedir(str nme);
gdk_export int GDKremovedir(str nme);

gdk_export char *GDKload(str nme, str ext, size_t size, size_t chunk, int mode);
gdk_export int GDKsave(str nme, str ext, void *buf, size_t size, int mode);
gdk_export int GDKunlink(str dir, str nme, str extension);
gdk_export int GDKmove(str dir1, str nme1, str ext1, str dir2, str nme2, str ext2);
@
@}

@- Printing
@multitable @columnfractions 0.08 0.7
@item int
@tab BATprintf (stream *f, BAT *b)
@item int
@tab BATmultiprintf (stream *f, int argc, BAT *b[], int printoid, int order, int printorderby)
@end multitable

The functions to convert BATs into ASCII and the reverse use
internally defined formats. They are primarily meant for ease of
debugging and to a lesser extent for output processing.
Printing a BAT is done essentially by looping through its components,
printing each association.
If an index is available, it will be used.
@
The @%BATmultiprintf@ command assumes a set of BATs with
corresponding oid-s in the head columns. It performs the multijoin
over them, and prints the multi-column result on the file.

@{
@h
gdk_export int BATprint(BAT *b);
gdk_export int BATprintf(stream *f, BAT *b);
gdk_export int BATmultiprintf(stream *f, int argc, BAT *argv[], int printoid, int order, int printorderby);
@
@}

@- BAT clustering
@multitable @columnfractions 0.08 0.7
@item BAT *
@tab BATsort (BAT *b)
@item BAT *
@tab BATsort_rev (BAT *b)
@item BAT *
@tab BATorder (BAT *b)
@item BAT *
@tab BATorder_rev (BAT *b)
@item BAT *
@tab BATrevert (BAT *b)
@item int
@tab BATordered (BAT *b)
@end multitable
@
When working in a main-memory situation, clustering of data on disk-pages
is not important. Whenever mmap()-ed data is used intensively, reducing
the number of page faults is a hot issue.
@
The below functions rearrange data in MonetDB heaps (used for storing
BUNs var-sized atoms, or accelerators). Applying these clusterings will
allow that MonetDB's main-memory oriented algorithms work efficient  also
in such a disk-oriented context.
@
The @%BATsort@ functions returns a copy of the input BAT, sorted
in ascending order on the head column. @%BATordered@ starts a
check on the head values to see if their are ordered. The result
is returned and stored in the @%hsorted@ field of the BAT.
@%BATorder@ is similar to @%BATsort@, but sorts the BAT itself, rather
than returning a copy (BEWARE: this operation destroys the
delta information. TODO:fix). The @%BATrevert@ puts all the live
BUNs of a BAT in reverse order. It just reverses the sequence, so
this does not necessarily mean that they are sorted in reverse order!
@{
@h
#define GDK_SORTED_REV	128	/* reversely sorted */
#define GDK_SORTED	65	/* 65 = (32 bits radix_clustered)<<1 + 1 */

gdk_export BAT *BATsort(BAT *b);
gdk_export BAT *BATsort_rev(BAT *b);
gdk_export BAT *BATorder(BAT *b);
gdk_export BAT *BATorder_rev(BAT *b);
gdk_export BAT *BATrevert(BAT *b);
gdk_export int BATordered(BAT *b);
gdk_export int BATordered_rev(BAT *b);

gdk_export void GDKqsort(void *a, void *base, size_t n, int width, int tpe, int loc);
gdk_export void GDKqsort_rev(void *a, void *base, size_t n, int width, int tpe, int loc);

#define BAThordered(b)	(((b)->htype == TYPE_void)?GDK_SORTED:(b)->hsorted)
#define BATtordered(b)	(((b)->ttype == TYPE_void)?GDK_SORTED:(b)->tsorted)
#define BAThdense(b)	(BAThvoid(b) && (b)->hseqbase != oid_nil)
#define BATtdense(b)	(BATtvoid(b) && (b)->tseqbase != oid_nil)
#define BAThvoid(b)	(((b)->hdense&(b)->hsorted&1) || (b)->htype==TYPE_void)
#define BATtvoid(b)	(((b)->tdense&(b)->tsorted&1) || (b)->ttype==TYPE_void)
#define BAThkey(b)	(b->hkey != FALSE || BAThdense(b))
#define BATtkey(b)	(b->tkey != FALSE || BATtdense(b))

#define BATsetcount(b,cnt)	((b)->batCount = cnt)
@
@}

@+ BAT Buffer Pool
@multitable @columnfractions 0.08 0.7
@item int
@tab BBPfix (bat bi)
@item int
@tab BBPunfix (bat bi)
@item int
@tab BBPincref (bat bi, int logical)
@item int
@tab BBPdecref (bat bi, int logical)
@item void
@tab BBPhot (bat bi)
@item void
@tab BBPcold (bat bi)
@item str
@tab BBPname (bat bi)
@item bat
@tab BBPindex  (str nme)
@item BAT*
@tab BATdescriptor (bat bi)
@item bat
@tab BBPcacheid (BAT *b)
@end multitable
@
The BAT Buffer Pool module contains the code to manage the storage
location of BATs. It uses two tables @%BBPlogical@ and @%BBphysical@
to relate the BAT name with its corresponding file system name.
This information is retained in an ASCII file within the database home
directory for ease of inspection. It is loaded upon restart
of the server and saved upon transaction commit (if necessary).
@
The remaining BBP tables contain status information to load, swap and
migrate the BATs. The core table is
@%BBPcache@ which contains a pointer to the BAT descriptor with its heaps.
A zero entry means that the file resides on disk. Otherwise it has been read
or mapped into memory.
@
BATs loaded into memory are retained in a BAT buffer pool.  They
retain their position within the cache during their life cycle, which
make indexing BATs a stable operation.  Their descriptor can be
obtained using @%BBPcacheid@.
@
The @%BBPindex@ routine checks if a BAT with a certain name is
registered in the buffer pools. If so, it returns its BAT id.
The @%BATdescriptor@ routine has a  BAT id parameter, and returns
a pointer to the corresponding BAT record (after incrementing the reference
count). The BAT will be loaded into memory, if necessary.
@
@{
The structure of the BBP file obeys the tuple format for GDK.

The status and BAT persistency information is encoded in the status field.
@h
typedef struct {
	BAT *b[2];		/* if loaded: BAT* handle + reverse */
	str nme[2];		/* logical name + reverse */
	bat next[2];		/* next BBP slot in link list */
	BATstore *cache;	/* cached header info */
	str path;		/* dir + basename for storage */
	int refs;		/* in-memory references on which the loaded status of a BAT relies */
	int lrefs;		/* logical references on which the existence of a BAT relies */
	int lastused;		/* BBP LRU stamp */
	volatile int status;	/* status mask used for spin locking */
} BBPrec;

gdk_export bat BBPmaxsize;
gdk_export bat BBPlimit;
gdk_export bat BBP_free;
gdk_export int BBP_dirty;	/* BBP table dirty? */
gdk_export bat BBPsize;	/* current size of BBP tables */
gdk_export BBPrec *BBP;

/* fast defines without checks; internal use only  */
#define BBP_cache(i)    BBP[ABS(i)].b[(i)<0]
#define BBP_logical(i)  BBP[ABS(i)].nme[(i)<0]
#define BBP_next(i)     BBP[ABS(i)].next[(i)<0]
#define BBP_physical(i) BBP[ABS(i)].path
#define BBP_desc(i)	BBP[ABS(i)].cache
#define BBP_refs(i)     BBP[ABS(i)].refs
#define BBP_lrefs(i)    BBP[ABS(i)].lrefs
#define BBP_lastused(i) BBP[ABS(i)].lastused
#define BBP_status(i)   BBP[ABS(i)].status

/* macros that nicely check parameters */
#define BBPdirty(x)	 (BBP_dirty=(x))
#define BBPcacheid(b)	 ((b)->batCacheid)
#define BBPstatus(i)	 (BBPcheck((i),"BBPstatus")?BBP_status(i):-1)
#define BBPcurstamp()	 BBP_curstamp
#define BBPrefs(i)	 (BBPcheck((i),"BBPrefs")?BBP_refs(i):-1)
#define BBPcache(i)	 (BBPcheck((i),"BBPcache")?BBP_cache(i):(BAT*) NULL)
#define BBPname(i)	 (BBPcheck((i),"BBPname")?((i) > 0 || BBP_logical(i))?BBP_logical(i):BBP_logical(-(i)):"")
#define BBPvalid(i)      (BBP_logical(i) != NULL)
#define BATgetId(b)	 BBPname((b)->batCacheid)
#define BBPfix(i)	 BBPincref(i, FALSE)
#define BBPunfix(i)	 BBPdecref(i, FALSE)

#define BBPRENAME_ALREADY	-1
#define BBPRENAME_ILLEGAL	-2
#define BBPRENAME_LONG		-3

gdk_export void BBPlock(str s);

gdk_export int BBPrename(bat b, str s);
gdk_export int BBPincref(bat b, int logical);
gdk_export int BBPdecref(bat b, int logical);
gdk_export void BBPhot(bat b);
gdk_export void BBPcold(bat b);
gdk_export void BBPtrim(size_t memdelta, size_t vmdelta);
gdk_export void BBPunlock(str s);

gdk_export bat BBPindex(str nme);
gdk_export BAT *BBPdescriptor(bat b);
gdk_export str BBPlogical(bat b, str buf);
gdk_export str BBPphysical(bat b, str buf);
gdk_export int BBP_curstamp;
gdk_export BATstore *BBPgetdesc(bat i);
gdk_export BAT *BBPquickdesc(bat b, int delaccess);
@
@}

@+ GDK Extensibility
GDK can be extended with new atoms, search accelerators and storage
modes.

@- Atomic Type Descriptors
The atomic types over which the binary associations are maintained
are described by an atom descriptor.
 @multitable @columnfractions 0.08 0.7
@item void
@tab ATOMproperty    (str   nme, char *property, int (*fcn)()));
@item int
@tab ATOMindex       (char *nme));
@item int
@tab ATOMdump        ());
@item void
@tab ATOMdelete      (int id);
@item str
@tab ATOMname        (int id);
@item int
@tab ATOMsize        (int id);
@item int
@tab ATOMalign       (int id);
@item int
@tab ATOMvarsized    (int id);
@item ptr
@tab ATOMnilptr      (int id);
@item int
@tab ATOMfromstr     (int id, str s, int* len, ptr* v\_dst);
@item int
@tab ATOMtostr       (int id, str s, int* len, ptr* v\_dst);
@item int
@tab ATOMhash        (int id, ptr val, in mask);
@item int
@tab ATOMcmp         (int id, ptr val\_1, ptr val\_2);
@item int
@tab ATOMconvert     (int id, ptr v, int direction);
@item int
@tab ATOMfix         (int id, ptr v);
@item int
@tab ATOMunfix       (int id, ptr v);
@item int
@tab ATOMheap        (int id, Heap *hp, size\_t cap);
@item void
@tab ATOMheapconvert (int id, Heap *hp, int direction);
@item int
@tab ATOMheapcheck   (int id, Heap *hp, HeapRepair *hr);
@item int
@tab ATOMput         (int id, Heap *hp, BUN pos\_dst, ptr val\_src);
@item int
@tab ATOMdel         (int id, Heap *hp, BUN v\_src);
@item int
@tab ATOMlen         (int id, ptr val);
@item ptr
@tab ATOMnil         (int id);
@item int
@tab ATOMformat      (int id, ptr val, char** buf);
@item int
@tab ATOMprint       (int id, ptr val, stream *fd);
@item ptr
@tab ATOMdup         (int id, ptr val );
@end multitable
@
@- Atom Definition
User defined atomic types can be added to a running system with
the following interface:.

@itemize
@item @emph{ATOMproperty()} registers a new atom definition, if there is no 
atom registered yet under that name. 
It then installs the attribute of the named property.
Valid names are "size", "align", "null", "fromstr", "tostr", "cmp",
"hash", "put", "get", "del", "length" and "heap".

@item @emph{ATOMdelete()} unregisters an atom definition.

@item @emph{ATOMindex()} looks up the atom descriptor with a certain name.
@end itemize
@
@- Atom Manipulation

@itemize
@item The @emph{ATOMname()} operation retrieves the name of an atom using its id.

@item The @emph{ATOMsize()} operation returns the atoms fixed size.

@item The @emph{ATOMalign()} operation returns the atoms minimum alignment. If the
alignment info was not specified explicitly during atom install, it
assumes the maximum value of {1,2,4,8} smaller than the atom size.

@item  The @emph{ATOMnilptr()} operation returns a pointer to the nil-value of an
atom. We usually take one dedicated value halfway down the negative
extreme of the atom range (if such a concept fits), as the nil value.

@item  The @emph{ATOMnil()} operation returns a copy of the nil value,
allocated with GDKmalloc().

@item The @emph{ATOMheap()} operation creates a new var-sized atom heap in 'hp'
with capacity 'cap'.

@item The @emph{ATOMhash()} computes a hash index for a value. `val' is a direct
pointer to the atom value. Its return value should be an integer
between 0 and 'mask'.

@item The @emph{ATOMcmp()} operation computes two atomic values. Its parameters
are pointers to atomic values.

@item The @emph{ATOMlen()} operation computes the byte length for a value.  `val'
is a direct pointer to the atom value. Its return value should be an
integer between 0 and 'mask'.

@item The @emph{ATOMdel()} operation deletes a var-sized atom from its heap `hp'.
The integer byte-index of this value in the heap is pointed to by `val\_src'.

@item The @emph{ATOMput()} operation inserts an atom `src_val' in a BUN at
`dst_pos'. This involves copying the fixed sized part in the BUN. In
case of a var-sized atom, this fixed sized part is an integer
byte-index into a heap of var-sized atoms. The atom is then also
copied into that heap `hp'.

@item The @emph{ATOMfix()} and @emph{ATOMunfix()} operations do bookkeeping
on the number of references that a GDK application maintains to the atom.
In MonetDB, we use this to count the number of references by MIL variables
directly, or through BATs that have columns of these atoms. The only operator
for which this is currently relevant is BAT. The operators return the
POST reference count to the atom. BATs with fixable atoms may not be
stored persistently.

@item The @emph{ATOMfromstr()} parses an atom value from string `s'. The memory
allocation policy is the same as in @emph{ATOMget()}. The return value is
the number of parsed characters.

@item The @emph{ATOMprint()} prints an ASCII description of the atom value pointed
to by `val' on file descriptor `fd'. The return value is the number of
parsed characters.

@item The @emph{ATOMformat()} is similar to @emph{ATOMprint()}. It prints an atom on a
newly allocated string. It must later be freed with @strong{GDKfree}.
The number of characters written is returned. This is minimally the
size of the allocated buffer.

@item The @emph{ATOMdup()} makes a copy of the given atom. The storage
needed for this is allocated and should be removed by the user.
@end itemize

These wrapper functions correspond closely to the interface functions
one has to provide for a user-defined atom. They basically (with
exception of @emph{ATOMput()}, @emph{ATOMprint()} and @emph{ATOMformat()})
just have the atom id parameter prepended to them.
@
@{
@h
typedef struct {
	/* simple attributes */
	char name[IDLENGTH];
	int storage;		/* stored as another type? */
	short linear;		/* atom can be ordered linearly */
	short size;		/* fixed size of atom */
	short align;		/* alignment condition for values */
	short deleting;		/* set if unloading */
	int varsized;		/* variable-size or fixed-sized */

	/* automatically generated fields */
	ptr atomNull;		/* global nil value */

	/* generic (fixed + varsized atom) ADT functions */
	int (*atomFromStr) (str s, int *len, ptr *dst);
	int (*atomToStr) (str *s, int *len, ptr src);
	void *(*atomRead) (ptr a, stream *s, size_t cnt);
	int (*atomWrite) (ptr a, stream *s, size_t cnt);
	int (*atomCmp) (ptr v1, ptr v2);
	hash_t (*atomHash) (ptr v);
	/* optional functions */
	void (*atomConvert) (ptr v, int direction);
	int (*atomFix) (ptr atom);
	int (*atomUnfix) (ptr atom);

	/* varsized atom-only ADT functions */
	var_t (*atomPut) (Heap *, var_t *off, ptr src);
	void (*atomDel) (Heap *, var_t *atom);
	int (*atomLen) (ptr atom);
	void (*atomHeap) (Heap *, size_t);
	/* optional functions */
	void (*atomHeapConvert) (Heap *, int direction);
	int (*atomHeapCheck) (Heap *, HeapRepair *);
} atomDesc;

gdk_export atomDesc BATatoms[];
gdk_export int GDKatomcnt;

gdk_export void ATOMdelete(int id);
gdk_export void ATOMproperty(char *nme, char *property, GDKfcn fcn);
gdk_export int ATOMindex(char *nme);
gdk_export int ATOMisdescendant(int id, int parentid);
gdk_export int ATOMdump(void);

gdk_export int ATOMheap(int id, Heap *hp, size_t cap);
gdk_export str ATOMname(int id);
gdk_export int ATOMlen(int id, ptr v);
gdk_export ptr ATOMnil(int id);
gdk_export int ATOMcmp(int id, ptr v_1, ptr v_2);
gdk_export int ATOMprint(int id, ptr val, stream *fd);
gdk_export int ATOMformat(int id, ptr val, char **buf);

gdk_export ptr ATOMdup(int id, ptr val);
@
@}
@- Unique OIDs
@multitable @columnfractions 0.08 0.7
@item oid
@tab
OIDseed (oid seed);
@item oid
@tab
OIDnew (size_t inc);
@end multitable

OIDs are special kinds of unsigned integers because the system
guarantees uniqueness. For system simplicity and performance, OIDs
are now represented as (signed) integers; however this is hidden
in the system internals and shouldn't affect semantics.

@
The @%OIDnew(N)@ claims a range of N contiguous unique,
unused OIDs, and returns the starting value of this range.
The highest OIDBITS designate site. [ DEPRECATED]
@{
@h
gdk_export int OIDinit(void);
gdk_export oid OIDrand(void);
gdk_export oid OIDbase(oid base);
gdk_export oid OIDseed(oid seed);
gdk_export oid OIDnew(size_t inc);
gdk_export oid OIDread(str buf);
gdk_export int OIDwrite(stream *fp);
gdk_export int OIDdirty(void);
@
@}

@- Built-in Accelerator Functions

@multitable @columnfractions 0.08 0.7
@item BAT*
@tab
 BAThash (BAT *b, size_t masksize)
@item BAT *
@tab
 BAThashsplit (BAT *b, size_t n, int unary)
@item BAT *
@tab
 BATrangesplit  (BAT *b, int n)
@end multitable

The current BAT implementation supports one search accelerator:
hashing. The routine @%BAThash@ makes sure that a hash
accelerator on the head of the BAT exists. A zero is returned upon
failure to create the supportive structures.

The hash data structures are currently maintained during update operations.

A @%BAT@ can be redistributed over @%n@ buckets using a hash
function with @%BAThashsplit@. The return value is a list of BAT
pointers.  Similarly, a range partitioning based is supported.

@{
@h
gdk_export BAT *BAThash(BAT *b, size_t masksize);
gdk_export BAT *BAThashsplit(BAT *b, size_t n, int unary);
gdk_export BAT *BATrangesplit(BAT *b, size_t n, int unary);
gdk_export BAT *BAThashjoin(BAT *l, BAT *r, size_t estimate);

/* low level functions */
gdk_export BUN SORTfnd(BAT *b, ptr v);
gdk_export BUN SORTfndfirst(BAT *b, ptr v);
gdk_export BUN SORTfndlast(BAT *b, ptr v);

#define BATprepareHash(X) (((X)->hhash == NULL) && !BAThash(X, 0))
@
@}

@- Multilevel Storage Modes

We should bring in the compressed mode as the first, maybe built-in,
mode. We could than add for instance HTTP remote storage, SQL storage,
and READONLY (cd-rom) storage.

@+ GDK Utilities
Interfaces for memory management, error handling, thread management
and system information.

@- GDK memory management
@multitable @columnfractions 0.08 0.8
@item void*
@tab GDKmalloc (size_t size)
@item void*
@tab GDKzalloc (size_t size)
@item void*
@tab GDKmallocmax (size_t size, size_t *maxsize, int emergency)
@item void*
@tab GDKrealloc & (void* pold, size_t size)
@item void*
@tab GDKreallocmax (void* pold, size_t size, size_t *maxsize, int emergency)
@item void
@tab GDKfree (void* blk)
@item str
@tab GDKstrdup (str s)
@item void*
@tab GDKvmalloc (size_t size, size_t *maxsize, int emergency)
@item void* @tab
 GDKvmrealloc (void* pold, size_t oldsize, size_t newsize, size_t oldmax, size_t *maxsize, int emergency)
@item void @tab
 GDKvmfree (void* blk, size_t size, size_t maxsize)
@end multitable
@
These utilities are primarily used to maintain control over critical interfaces
to the C library.  Moreover, the statistic routines help in identifying
performance and bottlenecks in the current implementation.
@
Compiled with -DMEMLEAKS the GDK memory management log their activities,
and are checked on inconsistent frees and memory leaks.
@{
@h
#define GDK_HISTO_MAX_BIT             ((int) (sizeof(size_t)<<3))

/* we prefer to use vm_alloc routines on size > GDKmmap */
gdk_export void *GDKmmap(char *path, int mode, off_t off, size_t len, void *fixed);
gdk_export int GDKmunmap(void *addr, size_t len);

gdk_export ptr GDK_mem_start;	/* sbrk(0) at start of the program */
gdk_export size_t GDK_mem_bigsize; /* size after which we use VM rather than heap */
gdk_export size_t GDK_mem_maxsize; /* max allowed size of committed memory */
gdk_export size_t GDK_vm_minsize; /* smallest size allowed for a vm block */
gdk_export size_t GDK_vm_maxsize; /* max allowed size of reserverd vm */

gdk_export size_t GDKmem_inuse(void); /* RAM/swapmem that MonetDB is really using now */
gdk_export size_t GDKmem_cursize(void);	/* RAM/swapmem that MonetDB has claimed from OS */
gdk_export size_t GDKvm_cursize(void); /* current MonetDB VM address space usage */
gdk_export size_t GDKvm_heapsize(void);
gdk_export size_t GDKmem_heapsize(void);
gdk_export size_t GDKmem_heapinuse(void);

gdk_export void *GDKmalloc(size_t size);
gdk_export void *GDKzalloc(size_t size);
gdk_export void *GDKmallocmax(size_t size, size_t * maxsize, int emergency);
gdk_export void *GDKrealloc(void *pold, size_t size);
gdk_export void *GDKreallocmax(void *pold, size_t size, size_t * maxsize, int emergency);
gdk_export void GDKfree(void *blk);
gdk_export str GDKstrdup(const char *s);

gdk_export void *GDKvmalloc(size_t size, size_t * maxsize, int emergency);
gdk_export void *GDKvmrealloc(void *pold, size_t oldsize, size_t newsize, size_t oldmax, size_t * maxsize, int emergency);
gdk_export void GDKvmfree(void *blk, size_t size, size_t maxsize);
@
@}

@- GDK error handling
 @multitable @columnfractions 0.08 0.7
@item str
@tab
 GDKmessage
@item bit
@tab GDKsilent
@item int
@tab
 GDKfatal(str msg)
@item int
@tab
 GDKwarning(str msg)
@item int
@tab
 GDKerror (str msg)
@item int
@tab
 GDKgoterrors ()
@item int
@tab
 GDKsyserror (str msg)
@item str
@tab
 GDKerrbuf
 @item
@tab GDKsetbuf (str buf)
@end multitable

The error handling mechanism is not sophisticated yet. Experience should
show if this mechanism is sufficient.
Most routines return a pointer with zero to indicate an error.

The error messages are also copied to standard output unless
@%GDKsilent@ is set to a non-zero value.
The last error message is kept around in a global variable.

Error messages can also be collected in a user-provided buffer,
instead of being echoed to a stream. This is a thread-specific issue;
you want to decide on the error mechanism on a thread-specific basis.
This effect is established with @%GDKsetbuf@. The memory (de)allocation
of this buffer, that must at least be 1024 chars long, is entirely
by the user. A pointer to this buffer is kept in the pseudo-variable
@%GDKerrbuf@. Normally, this is a NULL pointer.
@
@{
@h
#define GDKMAXERRLEN	10240
#define GDKWARNING	"!WARNING: "
#define GDKERROR	"!ERROR: "
#define GDKMESSAGE	"!OS: "
#define GDKFATAL	"!FATAL: "

/* Data Distilleries uses ICU for internationalization of some MonetDB error messages */
#ifdef MONET_ICU_I18N
gdk_export void GDKvsnprintf(char *buf, int maxlen, const char *format, va_list ap);
#else
#define GDKvsnprintf(buf, maxlen, format, ap) vsnprintf(buf, maxlen, format, ap)
#endif

gdk_export void GDKaddbuf(const char *msg);
gdk_export int GDKwarning(const char *format, ...);
gdk_export int GDKerror(const char *format, ...);
gdk_export int GDKsyserror(const char *format, ...);
gdk_export int GDKfatal(const char *format, ...);
gdk_export int GDKerrorCount(void);
@
@h
#define BBPLOCKMASK     7

#include "gdk_delta.h"
#include "gdk_search.h"
#include "gdk_atoms.h"
#include "gdk_bbp.h"
#include "gdk_desc.h"
#include "gdk_utils.h"
#include "gdk_bat.h"

gdk_export MT_Lock GDKthreadLock;
gdk_export MT_Lock GDKswapLock[BBPLOCKMASK + 1];
gdk_export MT_Lock GDKhashLock[BBPLOCKMASK + 1];
gdk_export MT_Lock GDKunloadLock;
gdk_export MT_Cond GDKunloadCond;
gdk_export MT_Lock GDKcacheLock;
gdk_export MT_Lock GDKtrimLock;
gdk_export MT_Lock GDKtmLock;

#define CHECKDEBUG      if (GDKdebug&2)
#define MEMDEBUG        if (GDKdebug&4)
#define PROPDEBUG       if (GDKdebug&8)
#define IODEBUG         if (GDKdebug&16)
#define BATDEBUG        if (GDKdebug&32)
#define PARSEDEBUG      if (GDKdebug&64)
#define PARDEBUG        if (GDKdebug&128)
#define TRGDEBUG        if (GDKdebug&256)
#define TMDEBUG         if (GDKdebug&512)
#define TEMDEBUG        if (GDKdebug&1024)
#define DLDEBUG	        if (GDKdebug&2048)
#define PERFDEBUG	if (GDKdebug&4096)
#define DELTADEBUG	if (GDKdebug&8192)
#define LOADDEBUG	if (GDKdebug&16384)
#define YACCDEBUG	if (GDKdebug&32768)
/*
#define ?tcpip?		if (GDKdebug&65536)
#define ?monet_multiplex?	if (GDKdebug&131072)
#define ?ddbench?	if (GDKdebug&262144)
#define ?ddbench?	if (GDKdebug&524288)
#define ?ddbench?	if (GDKdebug&1048576)
*/
#define ALGODEBUG	if (GDKdebug&2097152)
#define ESTIDEBUG	if (GDKdebug&4194304)
#define XPROPDEBUG      if (GDKdebug&8388608)

gdk_export int GDKnrofthreads;
gdk_export int GDKdebug;
gdk_export int GDKembedded;
gdk_export int GDKprotected;
gdk_export void GDKprotect();
@}
@-
The GDKembedded variable is a property set in the configuration file
to indicate that the kernel is only allowed to run as a single process.
This can be used to remove all locking overhead.
The actual state of affairs is maintained in GDKprotected, which
is set when locking is required, e.g. when multiple threads become
active.
@{
@h
#define gdk_set_lock(X,Y)    if(GDKprotected ) MT_set_lock(X,Y)
#define gdk_unset_lock(X,Y)  if(GDKprotected ) MT_unset_lock(X,Y)
#define gdk_up_sema(X,Y)     if(GDKprotected ) MT_up_sema(X,Y)
#define gdk_down_sema(X,Y)   if(GDKprotected ) MT_down_sema(X,Y)
#define gdk_signal_cond(X,Y) if(GDKprotected ) MT_signal_cond(X,Y)
#define gdk_wait_cond(X,Y,Z) if(GDKprotected ) MT_wait_cond(X,Y,Z)
@}
@-
The kernel maintains a central table of all active threads.
They are indexed by their tid. The structure contains information on the
input/output file descriptors, which should be set before a
database operation is started. It ensures that output is delivered to the
proper client.
@
The Thread structure should be ideally made directly accessible to each
thread. This speeds up access to tid and file descriptors.
@{
@h
#define THREADS	64
#define THREADDATA	16

typedef struct threadStruct {
	int tid;		/* logical ID by MonetDB; val == index into this array + 1 (0 is invalid) */
	MT_Id pid;		/* physical thread id (pointer-sized) from the OS thread library */
	str name;
	ptr data[THREADDATA];
	size_t sp;
	void (*cleanup) (ptr thr);
} ThreadRec, *Thread;


gdk_export ThreadRec GDKthreads[THREADS];

gdk_export int THRgettid(void);
gdk_export Thread THRget(int tid);
gdk_export Thread THRnew(MT_Id pid, str name);
gdk_export void THRdel(Thread t);
gdk_export int THRinit(void);
gdk_export int THRexit(str nme);
gdk_export int THRcnt(void);
gdk_export void THRsetdata(int, ptr);
gdk_export void *THRgetdata(int);
gdk_export int THRhighwater(void);
gdk_export int THRprintf(stream *s, const char *format, ...);

gdk_export void *THRdata[16];

#define GDKstdout	((stream*)THRdata[0])
#define GDKstdin	((stream*)THRdata[1])

#define GDKout	        ((stream*)THRgetdata(0))
#define GDKin	        ((stream*)THRgetdata(1))
#define GDKerrbuf	((char*)THRgetdata(2))
#define GDKsetbuf(x)	THRsetdata(2,(ptr)(x))
#define GDKerr	        GDKout

#ifndef GDK_NOLINK
#ifdef __cplusplus
extern "C" {
#endif

static INLINE bat
BBPcheck(REGISTER bat x, REGISTER const char *y)
{
	if (x && x != bat_nil) {
		REGISTER bat z = ABS(x);

		if (z >= BBPsize || BBP[z].nme[0] == NULL) {
			GDKwarning("%s: range error %d\n", y, x);
		} else {
			return z;
		}
	}
	return 0;
}

static INLINE BAT *
BATdescriptor(REGISTER bat i)
{
	REGISTER BAT *b = NULL;

	if (BBPcheck(i, "BATdescriptor")) {
		BBPfix(i);
		b = BBP_cache(i);
		if (b == NULL)
			b = BBPdescriptor(i);
	}
	return b;
}

static INLINE ptr
BUNhpos(REGISTER BAT *b, REGISTER BUN p)
{
	oid *ip = &b->void_seq1;

	*ip = b->hseqbase;
	if (*ip != oid_nil) {
		*ip += BUNgetpos(b, p);
	}
	return (ptr) ip;
}

static INLINE ptr
BUNtpos(REGISTER BAT *b, REGISTER BUN p)
{
	oid *ip = &b->void_seq2;

	*ip = b->tseqbase;
	if (*ip != oid_nil) {
		*ip += BUNgetpos(b, p);
	}
	return (ptr) ip;
}

static INLINE BAT *
BATmirror(REGISTER BAT *b)
{
	return BBP_cache(-(b)->batCacheid);
}

#ifdef __cplusplus
}
#endif
#endif

@
@}

@+ Transaction Management
@multitable @columnfractions 0.08 0.7
@item int
@tab
 TMcommit ()
@item int
@tab
 TMabort ()
@item int
@tab
 TMsubcommit ()
@end multitable

MonetDB by default offers a global transaction environment.  
The global transaction involves all activities on all persistent 
BATs by all threads.  Each global transaction ends with either 
@%TMabort@ or @%TMcommit@, and immediately starts a new transaction.

@%TMcommit@ implements atomic commit to disk on the collection
of all persistent BATs. For all persistent BATs, the global
commit also flushes the delta status for these BATs 
(see @%BATcommit@/@%BATabort@). This allows to perform
@%TMabort@ quickly in memory (without re-reading all disk images 
from disk).  The collection of which BATs is persistent is also part
of the global transaction state. All BATs that where 
persistent at the last commit, but were made transient 
since then, are made persistent again by @%TMabort@. 
In other words, BATs that are deleted, are only
physically deleted at @%TMcommit@ time. Until that time,
rollback (@%TMabort@) is possible. 

Use of @%TMabort is currently NOT RECOMMENDED due to two bugs:

@begin itemize
@item
@%TMabort after a failed @%TMcommit@ does not
bring us back to the previous committed state; but to the
state at the failed @%TMcommit@.
@item
At runtime, @%TMabort@ does not undo BAT name changes,
whereas a cold MonetDB restart does.
@end itemize

In effect, the problems with @%TMabort@ reduce the functionality
of the global transaction mechanism to consistent
checkpointing at each @%TMcommit@. For many applications,
consistent checkpointingis enough.

Extension modules exist that provide fine grained locking (lock 
module) and Write Ahead Logging (sqlserver).  Applications that 
need more fine-grained transactions, should build this on top 
of these extension primitives. 

@%TMsubcommit@ is intended to quickly add or remove
BATs from the persistent set. In both cases, rollback
is not necessary, such that the commit protocol can be 
accelerated. It comes down to writing a new BBP.dir.

Its parameter is a BAT-of-BATs (in the tail); the persistence
status of that BAT is committed. We assume here that the 
calling thread has exclusive access to these bats.
An error is reported if you try to partially commit 
an already committed persistent BAT (it needs the 
rollback mechanism).
@{
@h
gdk_export int TMcommit(void);
gdk_export int TMabort(void);
gdk_export int TMsubcommit(BAT* bl);

@
@}

@- Delta Management
 @multitable @columnfractions 0.08 0.6
@item BAT *
@tab BATcommit (BAT *b)
@item BAT *
@tab BATfakeCommit (BAT *b)
@item BAT *
@tab BATundo (BAT *b)
@item BAT *
@tab BATprev (BAT *b)
@item BAT *
@tab BATalpha (BAT *b)
@item BAT *
@tab BATdelta (BAT *b)
@end multitable

The BAT keeps track of updates with respect to a 'previous state'.
Do not confuse 'previous state' with 'stable' or 'commited-on-disk', 
because these concepts are not always the same. In particular,
they diverge when BATcommit, BATfakecommit, and BATundo are
called explictly, bypassing the normal global @%TMcommit@ protocol 
(some applications need that flexibility).

@%BATcommit@ make the current BAT state the new 'stable state'.
This happens inside the global @%TMcommit@ on all persistent BATs
previous to writing all bats to persistent storage using a @:BBPsync@.

EXPERT USE ONLY: The routine @%BATfakeCommit@ updates the delta 
information on BATs and clears the dirty bit. This avoids any 
copying to disk.  Expert usage only, as it bypasses the global 
commit protocol, and changes may be lost after quitting or crashing 
MonetDB.

@%BATabort@ undo-s all changes since the previous state. The global
@:TMabort@ achieves a rollback to the previously committed state 
by doing BATabort on all persistent bats.

BUG: after a failed @%TMcommit@, @%TMabort@ does not do anything
because @%TMcommit@ does the @%BATcommit@s *before* attempting to 
sync to disk instead of *after& doing this. 

The previous state can also be queried. @%BATprev@ is a view 
on the current BAT as it was in the previous state.  @%BATalpha@ 
shows only the BUNs inserted since the previous state, and
@%BATdelta@ the deleted buns.

CAVEAT: @%BATprev@, @%BATalpha@ and @%BATdelta@ only return views 
if the underlying BATs are read-only (often not the case when BATs 
are being updated).  Otherwise, copies must be made anyway.
@{
@h
gdk_export BAT *BATcommit(BAT *b);
gdk_export BAT *BATfakeCommit(BAT *b);
gdk_export BAT *BATundo(BAT *b);
gdk_export BAT *BATalpha(BAT *b);
gdk_export BAT *BATdelta(BAT *b);
gdk_export BAT *BATprev(BAT *b);

@}
@+ BAT Alignment and BAT views
@multitable @columnfractions 0.08 0.7
@item int
@tab ALIGNsynced  & (BAT* b1, BAT* b2)
@item int
@tab ALIGNsync    & (BAT *b1, BAT *b2)
@item int
@tab ALIGNrelated & (BAT *b1, BAT *b2)
@item int
@tab ALIGNsetH    & ((BAT *dst, BAT *src)
\hline
@item BAT *
@tab BATpropcheck & (BAT *b, int mode)
\hline
@item BAT*
@tab VIEWcreate   & (BAT *b)
@item bat
@tab VIEWparent   & (BAT *b)
@item BAT*
@tab VIEWhead     & (BAT *b)
@item BAT*
@tab VIEWcombine  & (BAT *b)
@item BAT*
@tab VIEWreset    & (BAT *b)
@item BAT*
@tab BATmaterialize    & (BAT *b, size\_t size)
@end multitable
@
Alignments of two columns of a BAT means that the system knows
whether these two columns are exactly equal. Relatedness of two
BATs means that one pair of columns (either head or tail) of
both BATs is aligned. The first property is checked by @%ALIGNsynced@,
the latter by @%ALIGNrelated@.
@
The @%BATpropcheck@ examines a BAT and tries to set all applicable
properties (key,sorted,align,dense).
@
All algebraic BAT commands propagate the properties - including
alignment properly on their results.
@
VIEW BATs are BATs that lend their storage from a parent BAT.
They are just a descriptor that points to the data in this
parent BAT. A view is created with @%VIEWcreate@. The cache
id of the parent (if any) is returned by @%VIEWparent@ (otherwise
it returns 0).
@
VIEW bats are read-only!!
@
The @%VIEWcombine@ gives a view on a BAT that has two head
columns of the parent.
The @%VIEWhead@ constructs a BAT view that has the same
head column as the parent, but has a void column with seqbase=nil
in the tail. @%VIEWreset@ creates a normal BAT with the same contents
as its view parameter (it converts void columns with seqbase!=nil
to materialized oid columns).

The @%BATmaterialize@ materializes a VIEW (TODO) or void bat inplace. The
size parameter can be used to hint the new size. This is useful as
materialization is usually needed for updates.

@{
@h
gdk_export int ALIGNsynced(BAT *b1, BAT *b2);
gdk_export int ALIGNrelated(BAT *b1, BAT *b2);
gdk_export int ALIGNsetH(BAT *dst, BAT *src);

gdk_export BAT *BATpropcheck(BAT *b, int mode);

#define BATPROPS_QUICK  0	/* only derive easy (non-resource consuming) properties */
#define BATPROPS_ALL    1	/* derive all possible properties; no matter what cost (key=hash) */
#define BATPROPS_CHECK  3	/* BATPROPS_ALL, but start from scratch and report illegally set properties */

gdk_export BAT *VIEWcreate(BAT *b);
gdk_export BAT *VIEWcreate_(BAT *b, int stable);
gdk_export BAT *VIEWhead(BAT *b);
gdk_export BAT *VIEWhead_(BAT *b, int mode);
gdk_export BAT *VIEWcombine(BAT *b);
gdk_export BAT *VIEWreset(BAT *b);
gdk_export BAT *BATmaterialize(BAT *b, size_t size);
gdk_export void VIEWdestroy(BAT *b);
gdk_export void VIEWbounds(BAT *view, size_t l, size_t h);
gdk_export void VIEWunlink(BAT *b);

/* low level functions */
gdk_export int ALIGNundo(BAT *b);
gdk_export int ALIGNcommit(BAT *b);
gdk_export int ALIGNsetH(BAT *b1, BAT *b2);

#define ALIGNsetT(x,y)	ALIGNsetH(BATmirror(x),BATmirror(y))
#define ALIGNdel(x,y)	{ALIGNchk(x,y);(x)->halign=(x)->talign=0; }
#define ALIGNins(x,y)	{VIEWchk(x,y,BAT_READ);(x)->halign=(x)->talign=0; }
#define ALIGNdelH(x,y)	{ALIGNchk(x,y);(x)->halign=0;}
#define ALIGNdelT(x,y)	{ALIGNchk(x,y);(x)->talign=0;}
#define ALIGNset(x,y)	{ALIGNsetH(x,y);ALIGNsetT(x,y);}

#define BATrestricted(b) (VIEWparent(b)?BBP_cache(VIEWparent(b))->batRestricted:(b)->batRestricted)

/* The batRestricted field indicates whether a BAT is readonly.
 * we have modes: BAT_WRITE  = all permitted
 *                BAT_APPEND = append-only
 *                BAT_READ   = read-only
 * VIEW bats are always mapped read-only.
 */
#define	VIEWchk(x,y,z)							\
	if (((x)->batRestricted & (z)) || (x)->batSharecnt > 0) {	\
		GDKerror("%s: access denied to %s, aborting.\n", y, BATgetId(x)); \
		return 0;						\
	}

/* the parentid in a VIEW is correct for the normal view. We must correct
 * for the reversed view. A special case are the VIEWcombine bats, these
 * always refer to the same parent column (i.e. no correction needed)
 */
#define VIEWparent(x)	(((x)->H == (x)->T || (x)->batCacheid >= 0)?\
				(x)->batParentid:-(x)->batParentid)

/* VIEWparentcol(b) tells whether the head column was inherited from the parent
 * "as is". We must check whether the type was not overridden in the view.
 */
#define VIEWparentcol(b) ((VIEWparent(b) && (b)->htype			\
			   && (b)->htype == BBP_cache(VIEWparent(b))->htype \
			   && (b)->hloc == BBP_cache(VIEWparent(b))->hloc) \
			  ?VIEWparent(b):0)

#define ALIGNchk(x,y)	VIEWchk(x,y,BAT_APPEND|BAT_READ)
@
@}


@+ BAT Iterators
 @multitable @columnfractions 0.15 0.7
@item BATloop
@tab
 (BAT *b; BUN p, BUN q)
@item BATloopDEL
@tab
 (BAT *b; BUN p; BUN q; int dummy)
@item DELloop
@tab
 (BAT *b; BUN p, BUN q, int dummy)
@item HASHloop
@tab
 (BAT *b; Hash *h, size_t dummy; ptr value)
@item HASHloop_bit
@tab
 (BAT *b; Hash *h, size_t idx; bit *value, BUN w)
@item HASHloop_chr
@tab
 (BAT *b; Hash *h, size_t idx; char *value, BUN w)
@item HASHloop_sht
@tab
 (BAT *b; Hash *h, size_t idx; sht *value, BUN w)
@item HASHloop_bat
@tab
 (BAT *b; Hash *h, size_t idx; bat *value, BUN w)
@item HASHloop_ptr
@tab
 (BAT *b; Hash *h, size_t idx; ptr *value, BUN w)
@item HASHloop_int
@tab
 (BAT *b; Hash *h, size_t idx; int *value, BUN w)
@item HASHloop_oid
@tab
 (BAT *b; Hash *h, size_t idx; oid *value, BUN w)
@item HASHloop_flt
@tab
 (BAT *b; Hash *h, size_t idx; flt *value, BUN w)
@item HASHloop_lng
@tab
 (BAT *b; Hash *h, size_t idx; lng *value, BUN w)
@item HASHloop_dbl
@tab
 (BAT *b; Hash *h, size_t idx; dbl *value, BUN w)
@item  HASHloop_str
@tab
 (BAT *b; Hash *h, size_t idx; str value, BUN w)
@item HASHlooploc
@tab
 (BAT *b; Hash *h, size_t idx; ptr value, BUN w)
@item HASHloopvar
@tab
 (BAT *b; Hash *h, size_t idx; ptr value, BUN w)
@item SORTloop
@tab
 (BAT *b,p,q,tl,th,s)
@end multitable

The @emph{BATloop()} looks like a function call, but is actually a macro.
The following example gives an indication of how they are to be used:
@example
void
print\_a\_bat(BAT *b)
{
	BUN p, q;
	BATloop(b, p, q)
		printf("Element %3d has value %d\n",
			   *(int*) BUNhead(b, p), *(int*) BUNtail(b, p));
}
@end example

@- simple sequential scan
The first parameter is a BAT, the p and q are BUN pointers, where
p is the iteration variable.
@h
#define BATloop(r,	p, q) \
	for(q = BUNlast(r), p = BUNfirst(r);p < q; p = BUNnext(r, p))
#define BATloopFast(r,	p, q, x) \
	for(q = BUNlast(r), x = BUNsize(r), p = BUNfirst(r); p < q; p += x)

@- batloop where the current element can be deleted/updated
Normally it is @#strictly forbidden@ to update the BAT over which
is being iterated, or delete the current element. This can only
be done with the specialized batloop below. When doing a delete,
do not forget to update the current pointer with a p = @%BUNdelete@(b,p)
(the delete may modify the current pointer p).
After the delete/update has taken place, the pointer p is in an
inconsistent state till the next iteration of the batloop starts.
@h
#define BATloopDEL(r, p, q, x)						\
	for(p = BUNfirst(r), q = BUNlast(r), x = BUNsize(r); p < q;	\
	    q=MIN(q,BUNlast(r)), p += x)

@- sequential scan over deleted BUNs
Stable BUNS that were deleted, are conserved to transaction end. You may
inspect these data items.
Again, the b is a BAT, p and q are BUNs, where p is the iteration variable.
@h
#define DELloop(b, p, q, x)						\
	for (q = (b)->batFirst, p = (b)->batDeleted, x=BUNsize(b); p < q; p += x)

@- hash-table supported loop over BUNs
The first parameter `b' is a BAT, the second (`h') should point to
`b->hhash', and `v' a pointer to an atomic value (corresponding to the
head column of `b'). The 'hb' is an integer index, pointing out the
`hb'-th BUN. You should translate this index with @%BUNptr(b,hb)@ to
obtain a BUN from the iteration variable.
@h
#define HASHloop(b, h, hb, v)						\
	for (hb = h->hash[HASHprobe(h, v)]; hb != HASH_MAX; hb = h->link[hb])	\
		if (ATOMcmp(h->type, v, BUNhead(b, BUNptr(b, hb))) == 0)
#define HASHloop_str(b,	h, hb, v)					\
	for (hb = h->hash[strHash(v)&h->mask]; hb != HASH_MAX; hb = h->link[hb])	\
		if (strcmp(v, BUNhvar(b, BUNptr(b, hb))) == 0)
@-
For string search, we can optimize if the string heap has eliminated
all doubles. This is the case when not too many different strings are
stored in the heap. You can check this with the macro @%strElimDoubles()@
If so, we can just compare integer index numbers instead of strings:
@h
#define HASHloop_fstr(b, h, hb, idx, v)					\
	for (hb = h->hash[strHash(v)&h->mask], idx = strLocate((b)->hheap,v); \
	     hb != HASH_MAX; hb = h->link[hb])					\
		     if (*(var_t*) BUNhloc(b, BUNptr(b, hb)) == idx)
@
The following example shows how the hashloop is used:

@example
void
print_books(BAT *author\_books, str author)
{
        BAT *b = author\_books;
        size_t i;

        printf("%s\n==================\n", author);
        HASHloop(b, (b)->hhash, i, author)
			printf("%s\n", ((str) BUNtail(b, BUNptr(b,i)));
}
@end example
@
Note that for optimization purposes, we could have used a
@%HASHloop_str@ instead, and also a @%BUNtvar@ instead of
a @%BUNtail@ (since we know the tail-type of @%author_books@
is string, hence variable-sized). However, this would make the code
less general.

@- specialized hashloops
HASHloops come in various flavors, from the general @%HASHloop@, as
above, to specialized versions (for speed) where the type is known
(e.g. @%HASHloop_int@), or the fact that the atom is fixed-sized
(@%HASHlooploc@) or variable-sized (@%HASHloopvar@).
@
These hashloops have one extra parameter, a BUN pointer 'w' (again for
speed) which already points at the current BUN (i.e. w == @%BUNptr(b,hb)@).
@h
#define HASHlooploc(b,	h, hb, v, w)					\
	for (hb = h->hash[HASHprobe(h, v)]; hb != HASH_MAX; hb = h->link[hb])	\
		if ((w=BUNptr(b, hb)) != NULL && ATOMcmp(h->type, v, BUNhloc(b, w)) == 0)
#define HASHloopvar(b,	h, hb, v, w)					\
	for (hb = h->hash[HASHprobe(h, v)]; hb != HASH_MAX; hb = h->link[hb])	\
		if ((w=BUNptr(b, hb)) != NULL && ATOMcmp(h->type, v, BUNhvar(b, w)) == 0)
@
@{
@h
@:hashloop(bit,chr,simple,chr,hloc)@
@:hashloop(chr,chr,simple,chr,hloc)@
@:hashloop(sht,sht,simple,sht,hloc)@
@:hashloop(int,int,simple,int,hloc)@

#if SIZEOF_OID == SIZEOF_INT
@:hashloop(oid,int,simple,int,hloc)@	/* OIDDEPEND */
#else
@:hashloop(oid,lng,simple,lng,hloc)@	/* OIDDEPEND */
#endif
@:hashloop(bat,int,simple,int,hloc)@

#if SIZEOF_VOID_P == SIZEOF_INT
@:hashloop(ptr,int,simple,int,hloc)@
#else /* SIZEOF_VOID_P == SIZEOF_LNG */
@:hashloop(ptr,lng,simple,lng,hloc)@
#endif
@:hashloop(flt,int,simple,int,hloc)@
@:hashloop(lng,lng,simple,lng,hloc)@
@:hashloop(dbl,lng,simple,lng,hloc)@
@:hashloop(any,any,atom,(b)->htype,head)@

@= hashloop
#define HASHloop_@1(b,h,hb,v,w)						\
	for (hb = h->hash[hash_@2(h,v)]; hb != HASH_MAX; hb = h->link[hb])		\
		if ((w=BUNptr(b, hb)) != NULL && @3_EQ(v, BUN@5(b, w), @4))
@}
@- loop over a BAT with ordered tail
Here we loop over a BAT with an ordered tail column (see for instance
@%BATsort@). Again, 'p' and 'q' are iteration variables, where 'p'
points at the current BUN. 'tl' and 'th' are pointers to atom
corresponding to the minimum (included) and maximum (included) bound
in the selected range of BUNs. A nil-value means that there is no bound.
The 's' finally is an integer denoting the bunsize, used for speed.
@h
#define SORTloop(b,p,q,tl,th,s)						\
	if (!(BATtordered(b)&1)) GDKerror("SORTloop: BAT not sorted.\n"); \
	else for (p = (ATOMcmp((b)->ttype,tl,ATOMnilptr((b)->ttype))?	\
		     SORTfndfirst(b,tl):BUNfirst(b)),			\
		  q = (ATOMcmp((b)->ttype,th,ATOMnilptr((b)->ttype))?	\
		     SORTfndlast(b,th):BUNlast(b)),			\
		  s = BUNsize(b); p < q; p += s)
@-
@{
@h
@:sortloop(chr,chr,chr,simple,&chr_nil)@
@:sortloop(sht,sht,sht,simple,&sht_nil)@
@:sortloop(int,int,int,simple,&int_nil)@
@:sortloop(flt,flt,flt,simple,&flt_nil)@
@:sortloop(lng,lng,lng,simple,&lng_nil)@
@:sortloop(dbl,dbl,dbl,simple,&dbl_nil)@
@:sortloop(loc,loc,(b)->ttype,atom,ATOMnilptr((b)->ttype))@
@:sortloop(var,var,(b)->ttype,atom,ATOMnilptr((b)->ttype))@

@= sortloop
#define SORTloop_@1(b,p,q,tl,th,s)					\
	if (!(BATtordered(b)&1)) GDKerror("SORTloop_@1: BAT not sorted.\n"); \
	else for (p = @4_EQ(tl,@5,@3)?BUNfirst(b):SORTfndfirst_@2(b,tl), \
		  q = @4_EQ(th,@5,@3)?BUNfirst(b):SORTfndlast_@2(b,th),	\
		  s = BUNsize(b); p < q; p += s)
@}
@h

/* OIDDEPEND */
#if SIZEOF_OID == SIZEOF_INT
#define SORTfnd_oid(b,v)	SORTfnd_int(b,v)
#define SORTfndfirst_oid(b,v)	SORTfndfirst_int(b,v)
#define SORTfndlast_oid(b,v)	SORTfndlast_int(b,v)
#define SORTloop_oid(b,p,q,tl,th,s) SORTloop_int(b,p,q,tl,th,s)
#else
#define SORTfnd_oid(b,v)	SORTfnd_lng(b,v)
#define SORTfndfirst_oid(b,v)	SORTfndfirst_lng(b,v)
#define SORTfndlast_oid(b,v)	SORTfndlast_lng(b,v)
#define SORTloop_oid(b,p,q,tl,th,s) SORTloop_lng(b,p,q,tl,th,s)
#endif
#define SORTloop_bit(b,p,q,tl,th,s) SORTloop_chr(b,p,q,tl,th,s)
@

@+ Common BAT Operations
Much used, but not necessarily kernel-operations on BATs.

@- BAT aggregates
@multitable @columnfractions 0.08 0.7
@item BAT*
@tab
 BAThistogram & (BAT *b)
@item BAT*
@tab
 BATsample& (BAT* b,size\_t n)
@end multitable

The routine @%BAThistogram@ produces a new BAT with a frequency distribution
of the tail of its operand.

The routine @%BATsample@ returns a random sample on n BUNs of a BAT.

For each BAT we maintain its dimensions as separately accessible
properties. They can be used to improve query processing at higher levels.

@{
@h

#define GDK_AGGR_SIZE 1
#define GDK_AGGR_CARD 2
#define GDK_AGGR_HASNIL 3

gdk_export void PROPdestroy(PROPrec *p);
gdk_export bit BATgetprop_bit(BAT *b, int idx);
gdk_export int BATgetprop_int(BAT *b, int idx);
gdk_export str BATgetprop_str(BAT *b, int idx);
gdk_export void BATsetprop_bit(BAT *b, int idx, bit val);
gdk_export void BATsetprop_int(BAT *b, int idx, int val);
gdk_export void BATsetprop_str(BAT *b, int idx, str val);
gdk_export void BATpropagate(BAT *dst, BAT *src, int idx);
gdk_export BAT *BATsample(BAT *b, size_t n);
gdk_export BAT *BAThistogram(BAT *b);
gdk_export size_t BATtopN(BAT *b, size_t topN);	/* used in monet5/src/modules/kernel/algebra.mx */

@}
@- Alignment transformations
Some classes of algebraic operators transform a sequence in an input BAT
always in the same way in the output result. An example are the @{X@}()
function (including histogram(b), which is identical to @{count@}(b.reverse)).
That is to say, if synced(b2,b2) => synced(@{X@}(b1),@{Y@}(b2))

Another example is b.fetch(position-bat). If synced(b2,b2) and the same
position-bat is fetched with, the results will again be synced.
This can be mimicked by transforming the @emph{alignment-id} of the input
BAT with a one-way function onto the result.

We use @strong{output->halign = NOID_AGGR(input->halign)} for the
@strong{output = @{X@}(input)} case, and
@strong{output->align = NOID_MULT(input1->align,input2->halign)} for
the fetch.
@{
@h
#define AGGR_MAGIC	111
#define NOID(x)		((oid)(x))
#define NOID_AGGR(x)	NOID_MULT(AGGR_MAGIC,x)
#define NOID_MULT(x,y)	NOID( (lng)(y)*(lng)(x) )


@}
@- BAT relational operators
 @multitable @columnfractions 0.08 0.7
@item BAT *
@tab BATjoin (BAT *l, BAT *r, size\_t estimate)
@item BAT *
@tab BATouterjoin (BAT *l, BAT *r, size\_t estimate)
@item BAT *
@tab BATbandjoin (BAT *l, BAT *r, ptr c1, ptr c2)
@item BAT *
@tab BATthetajoin (BAT *l, BAT *r, int mode, size\_t estimate)
@item BAT *
@tab BATsemijoin (BAT *l, BAT *r)
@item BAT *
@tab BATselect (BAT *b, ptr tl, ptr th)
@item BAT *
@tab BATfragment (BAT *b, ptr l, ptr h, ptr L, ptr H)
@item \hline
@item BAT *
@tab BATsunique (BAT *b)
@item BAT *
@tab BATkunique (BAT *b)
@item BAT *
@tab BATsunion (BAT *b, BAT *c)
@item BAT *
@tab BATkunion (BAT *b, BAT *c)
@item BAT *
@tab BATsintersect (BAT *b, BAT *c)
@item BAT *
@tab BATkintersect (BAT *b, BAT *c)
@item BAT *
@tab BATsdiff (BAT *b, BAT *c)
@item BAT *
@tab BATkdiff (BAT *b, BAT *c)
@end multitable
@
The BAT library comes with a full-fledged collection of relational
operators. The two selection operators @%BATselect@ and
@%BATfragment@ produce a partial copy of the BAT. The former performs
a search on the tail; the latter considers both dimensions.  The
@%BATselect@ operation takes two inclusive ranges as search arguments.
Interpretation of a NULL argument depends on the position, i.e. a
domain lower or upper bound.
@
The operation @%BATsort@ sorts the BAT on the header and produces a new
BAT. A side effect is the clustering of the BAT store on the sort key.
@
The @%BATjoin@ over R[A, B] and S[C, D] performs an equi-join over B
and C. It results in a BAT over A and D.  The @%BATouterjoin@
implements a left outerjoin over the BATs involved.  The
@%BATbandjoin@ produces the associations [A, D] such that S.C-c1 <=
R.b <= S.C + c2.  The special case c1 = 0 and c2 = infinite leads to a
thetajoin.  The @%BATsemijoin@ over R[A, B] and S[C, D] produces the
subset of R[A, B] that satisfies the semijoin over A and C.
@
The full-materialization policy intermediate results in MonetDB means that a
join can produce an arbitrarily large result and choke the system. The Data
Distilleries tool therefore first computes the join result size before the
actual join (better waste time than crash the server). To exploit that perfect
result size knowledge, an result-size estimate parameter was added to all
equi-join implementations.
TODO: add this for semijoin/select/unique/diff/intersect
@
The routine @%BATsunique@ considers both dimensions in the double
elimination it performs; it produces a set.
The routine @%BATtunique@ considers only the head column,
and produces a unique head column.
@
BATs that satisfy the set property can be further processed with the
set operations @%BATsunion@, @%BATsintersect@, and @%BATsdiff@.
The same operations are also available in versions that only
look at the head column:@%BATkunion@, @%BATkdiff@, and
@%BATkintersect@ (which shares its implementation with @%BATsemijoin@).
@{
@- modes for thethajoin
@h
#define JOIN_EQ	0
#define JOIN_LT	-1
#define JOIN_LE	-2
#define JOIN_GT	1
#define JOIN_GE	2
#define JOIN_BAND 3

gdk_export BAT *BATfragment(BAT *b, ptr hl, ptr hh, ptr tl, ptr th);
gdk_export BAT *BAT_select_(BAT *b, ptr tl, ptr th, bit li, bit hi, bit tail, bit preserve_order);
gdk_export BAT *BAT_select(BAT *b, ptr tl, ptr th, bit tail);
gdk_export BAT *BATselect_(BAT *b, ptr tl, ptr th, bit li, bit hi);
gdk_export BAT *BATuselect_(BAT *b, ptr tl, ptr th, bit li, bit hi);
gdk_export BAT *BATselect(BAT *b, ptr tl, ptr th);
gdk_export BAT *BATuselect(BAT *b, ptr tl, ptr th);
gdk_export BAT *BATrestrict(BAT *b, ptr hl, ptr hh, ptr tl, ptr th);

gdk_export BAT *BATconst(BAT *l, int tt, ptr val);
gdk_export BAT *BATthetajoin(BAT *l, BAT *r, int mode, size_t estimate);
gdk_export BAT *BATleftthetajoin(BAT *l, BAT *r, int mode, size_t estimate);
gdk_export BAT *BATnlthetajoin(BAT *l, BAT *r, int mode, size_t estimate);
gdk_export BAT *BATbandjoin(BAT *l, BAT *r, ptr c1, ptr c2);	/* should bandjoin remain in the kernel? */
gdk_export BAT *BATsemijoin(BAT *l, BAT *r);
gdk_export BAT *BATmergejoin(BAT *l, BAT *r, size_t estimate);
gdk_export BAT *BATleftmergejoin(BAT *l, BAT *r, size_t estimate);
gdk_export BAT *BATjoin(BAT *l, BAT *r, size_t estimate);
gdk_export BAT *BATantijoin(BAT *l, BAT *r);
gdk_export BAT *BATleftjoin(BAT *l, BAT *r, size_t estimate);
gdk_export BAT *BATouterjoin(BAT *l, BAT *r, size_t estimate);
gdk_export BAT *BATcross(BAT *l, BAT *r);

gdk_export BAT *BATslice(BAT *b, size_t low, size_t high);
gdk_export BAT *BATfetch(BAT *b, BAT *s);
gdk_export BAT *BATfetchjoin(BAT *b, BAT *s, size_t estimate);
gdk_export BAT *BATleftfetchjoin(BAT *b, BAT *s, size_t estimate);

gdk_export BAT *BATins_kunique(BAT *bn, BAT *b);
gdk_export BAT *BATsunique(BAT *b);
gdk_export BAT *BATkunique(BAT *b);
gdk_export BAT *BATukunique(BAT *b);
gdk_export BAT *BATsintersect(BAT *b, BAT *c);
gdk_export BAT *BATkintersect(BAT *b, BAT *c);
gdk_export BAT *BATsunion(BAT *b, BAT *c);
gdk_export BAT *BATkunion(BAT *b, BAT *c);
gdk_export BAT *BATsdiff(BAT *b, BAT *c);
gdk_export BAT *BATkdiff(BAT *b, BAT *c);

/* generic n-ary multijoin beast, with defines to interpret retval */
#define MULTIJOIN_SORTED(r)	((char*) &r)[0]
#define MULTIJOIN_KEY(r)	((char*) &r)[1]
#define MULTIJOIN_SYNCED(r)	((char*) &r)[2]
#define MULTIJOIN_LEAD(r)	((char*) &r)[3]

typedef void (*ColFcn) (ptr, ptr);
typedef void (*RowFcn) (ptr, ptr *);

gdk_export int BATmultijoin(int argc, BAT *argv[], RowFcn tuple_fcn, ptr tuple_data, ColFcn value_fcn[], ptr value_data[], int orderspec);

#ifdef __cplusplus
}
#endif
@

@h
@{
#define ILLEGALVALUE	((ptr)-1L)
#define MAXPARAMS	32

#endif /* _GDK_H_ */
@
@}
@T
%\bibliographystyle{plain}
\bibliography{gdk}
@}
