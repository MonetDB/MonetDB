@f gdk_utils
@a M. L. Kersten, P. Boncz

@* Utilities
The utility section contains functions to initialize the Monet database
system, memory allocation details, and a basic system logging scheme.

@h
#ifndef _GDK_UTILS_H_
#define _GDK_UTILS_H_

gdk_export void GDKenvironment(str db, str monetrc);
gdk_export str expandFile(str fname);
gdk_export void GDKlog       (char *format, ...);
gdk_export void GDKlockHome  ();
gdk_export void GDKunlockHome();
gdk_export int  GDKgetHome   ();

gdk_export lng  GDKusec      ();
gdk_export int  GDKms        ();
gdk_export int  GDKcsec      ();
gdk_export int  GDKsec       ();

#endif /* _GDK_UTILS_H_ */
@c
#ifndef GDK_NOLINK
#include "gdk.h"
#include "gdk_utils.h"
#include "gdk_posix.h"

#else /* GDK_NOLINK */

#undef GDKmalloc
#undef GDKrealloc
#undef GDKfree

#define GDKmalloc(size)	malloc(size)
#define GDKrealloc(buf,size)	realloc(buf,size)
#define GDKfree(buf)	free(buf)
#endif

char	GDKdbfarmStr[PATHLENGTH] = { "dbfarm" };
char	GDKdbnameStr[PATHLENGTH] = { 0 };
char	GDKdirStr[PATHLENGTH] = { 0 };
char	GDKdistrStr[PATHLENGTH] = MONET_PREFIX;
char	GDKmonetrcStr[PATHLENGTH] = { 0 };
char    GDKarchStr[PATHLENGTH]= HOST;
char    GDKversionStr[PATHLENGTH]=VERSION;

#ifdef HAVE_FCNTL_H
#include <fcntl.h>
#endif

#if TIME_WITH_SYS_TIME
# include <sys/time.h>
# include <time.h>
#else
# if HAVE_SYS_TIME_H
#  include <sys/time.h>
# else
#  include <time.h>
# endif
#endif

#ifdef HAVE_PWD_H
# include <pwd.h>
#endif

#ifdef __CYGWIN32__
extern int gethostname(char *s, int len);
#endif

#ifndef HAVE_SETENV
#ifdef HAVE_PUTENV
int setenv(char *name, char *value, int overwrite) {
        int ret = 0;
        if (overwrite || getenv(name) == NULL) {
                char *p = (char*) GDKmalloc(2+strlen(name)+strlen(value));
                strcpy(p, name);
                strcat(p, "=");
                strcat(p, value);
                ret = putenv(p);
                /* GDKfree(p); */
        }
        return ret;
}
#endif
#endif

@- Monet configuration file
Parse a possible .monet.conf file lying around in the current directory,
the home directory of the user, or passed around as the preferred one
to extract pre-settings of system variables.
Un-recognized parameters are simply skipped, because they  may be
picked up by other components of the system.
The consequence is that making a typing error in the configuration file
may be unnoticed for a long time.
Syntax errors are immediately flagged, though.

Since the GDK kernel moves into the database directory, we need
to keep the absolute path to the .monet.conf file for top-levels
to access its information.
@c
#define MONETRC  ".monet.conf"

str expandFile(str fname){
	static char name[PATHLENGTH];

	SLASH_2_DIR_SEP(fname);
	if( strncmp("...",fname,3)==0 && fname[3]==DIR_SEP ) {
		sprintf(name,"%s%s",MONET_PREFIX,fname+3);
		return GDKstrdup(name);
	} else return fname;
}
void GDKusage(){
	fprintf(stderr,"usage: <program> [-db <db_name>] [-monetrc <file>]\n");
	fprintf(stderr,"<program>\tprogram using the GDK library\n");
	fprintf(stderr,"<db-name>\tdatabase to open\n");
	fprintf(stderr,"<file>\t\tsystem variable settings\n");
	fprintf(stderr,"\t\tdefault: .monet.conf in current/home directory\n");
	fprintf(stderr,"Other arguments are dealt with in the application startup routine\n");
}

void GDKenvironment(str db, str monetrc)
{
	char buf[2*PATHLENGTH];
	char pwd[PATHLENGTH];
	FILE *fd= NULL;

	if( db != NULL && strchr(db,DIR_SEP) ) {
		strcpy(GDKdbnameStr,db);
		strcpy(GDKdirStr,db);
		return;
	}

	if( monetrc) {
		fd= fopen(monetrc,"r");
		strcpy(GDKmonetrcStr,monetrc);
	}
	if(fd == NULL) {
		fd = fopen(MONETRC,"r");
		strcpy(GDKmonetrcStr,MONETRC);
	}
	if( fd == NULL){
		str home= getenv("HOME");
		if( home != NULL){
			sprintf(buf,"%s%c%s",home, DIR_SEP, MONETRC);
			fd= fopen(buf,"r");
			if(fd!=NULL) strcpy(GDKmonetrcStr,buf);
		}
	}
	while(fd!=NULL && fgets(buf,2*PATHLENGTH,fd) != NULL){
		str s,t, val;

		for(s=buf; *s && isspace(*s); s++) ;
		if( *s=='#') continue;	/* commentary */
		if( *s== 0) continue;   /* empty line */
		
		val = strchr(s,'=');
		if( val == NULL) {
			GDKerror("GDKenvironment:syntax error in monetrc\n");
			continue;
		}
		*val=0;

		for(t=s; *t && !isspace(*t); t++) ;
		*t =0;

		/* skip any leading blancs in the value part */
		for(val++; *val && isspace(*val) ;val++) ;
		/* search first blanc, rest is commentary */
		for(t=val;*t;t++) if( isspace(*t) || *t=='#') break;
		*t=0;

		/* This list may be extended later */
		if( strcmp(s,"gdk_debug")==0)
			GDKdebug=atoi(val);
		else
		if( strcmp(s,"gdk_mmap")==0)
			GDK_mem_bigsize =((lng) atoi(val)) << 10;
		else
		if( strcmp(s,"gdk_dbfarm")==0)
			strcpy(GDKdbfarmStr, expandFile(val));
		else
		if( strcmp(s,"gdk_dbname")==0)
			strcpy(GDKdbnameStr, val);
		else
		if( strcmp(s,"gdk_oidseed")==0)
			OIDseed(atoi(val) << SERVERBITS);
	}
	if( fd != NULL) (void) fclose(fd);
	if( db == NULL && GDKdbnameStr[0]==0) {
		fprintf(stderr,"ERROR:database name missing\n");
		GDKusage();
		exit(-1);
	}
	if( db != NULL) strcpy(GDKdbnameStr,db);

	if( GDKdbfarmStr[0]){
		sprintf(GDKdirStr,"%s%c%s",GDKdbfarmStr,DIR_SEP,GDKdbnameStr);
	} else	strcpy(GDKdirStr,GDKdbnameStr);
	/* handle monetrc */
	if( MT_path_absolute(GDKmonetrcStr)) return; /* absolute path */
	/* make relative path absolute */
        if (getcwd(pwd, PATHLENGTH-1)  == NULL ){
                perror("pwd");
                GDKfatal("GDKenvironment: could not determine current directory\n");
        }
	sprintf(buf,"%s%c%s",pwd,DIR_SEP,GDKmonetrcStr);
	if( strlen(buf) >PATHLENGTH-1){
		GDKfatal("GDKenvironment: path to monetrc file too long\n");
	}
	strcpy(GDKmonetrcStr,buf);
}

@+ System logging
Per database a log file can be maintained for collection
of system management information. Its contents is driven
by the upper layers, which encode information such as
who logged on and how long the session went on.
The lower layers merely store error information on the file.
It should not be used for crash recovery, because this should be
dealt with on a per client basis.

@-
A system log can be maintained in the database to keep track
of session and crash information. It should be regulary be
refreshed to avoid disk overflow.
@c
#ifndef GDK_NOLINK
#define GDKLOCK	".gdk_lock"

static FILE* GDKlockFile = 0; 

#define GDKLOGOFF	"LOGOFF"
#define GDKFOUNDDEAD	"FOUND	DEAD"
#define GDKLOGON	"LOGON"
#define GDKCRASH	"CRASH"

@-
Single-lined comments can now be logged safely, together with process, thread
and user ID, and the current time.
@c
/* VARARGS */
void GDKlog(char *format, ...) {
	va_list	ap; 
	char	*p= 0, buf[1024];
	int	mustopen = GDKgetHome();
	time_t	tm = time(0);

	if (MT_system_lock == NULL) return;

	va_start (ap,format); 
	vsprintf(buf, format, ap); 
	va_end (ap); 

	/* remove forbidden characters from message */
	for(p=buf; (p=strchr(p,'\n')) != NULL; *p = ' ');
	for(p=buf; (p=strchr(p,'\@')) != NULL; *p = ' ');

	fseek(GDKlockFile, 0, SEEK_END);
	fprintf(GDKlockFile, "%s \@ USR=%d PID=%d THR=%d TIME=%s", buf, 
		(int) getuid(), (int) getpid(), (int) MT_getpid(), ctime(&tm));
	fflush(GDKlockFile);

	if (mustopen) GDKunlockHome();
}

@+ Interrupt handling
The current version simply catches signals and prints a warning.
It should be extended to cope with the specifics of the interrupt
received.
@c
#include <signal.h>
void BATSIGignore(int nr) {
	GDKsyserror("! ERROR signal %d caught by thread %d\n", nr, (int) MT_getpid()); 

}

void BATSIGabort(int nr) {
	GDKfatal("signal %d caught by thread %d\n", nr, (int) MT_getpid()); 
}

void BATSIGpipe() {
	int	pid;
	int	status; 

	while ((pid = waitpid(-1, &status, WNOHANG)) > 0)
	PARDEBUG THRprintf(GDKerr, "BROKEN PIPE \n"); 
	(void) signal(SIGPIPE, (void (*)()) BATSIGpipe); 
}


int BATSIGcrash() {
	static int crash = 0;
	if (!crash++) {
		GDKlog(GDKCRASH);
		MT_global_exit(1);
	}
	return 0;
}

int BATSIGinit() {
	(void) signal(SIGINT,  (void (*)()) BATSIGabort); 
/*
	(void) signal(SIGBUS,  (void (*)()) BATSIGcrash); 
	(void) signal(SIGSEGV, (void (*)()) BATSIGcrash); 
*/
	(void) signal(SIGPIPE, (void (*)()) BATSIGpipe); 
	(void) signal(SIGHUP,  (void (*)()) MT_exit_thread);
	return 0;
}

@+ Memory management
Memory management in GDK mostly relies on the facilities offered by the 
underlying OS.  The below routines monitor the available memory resources
which consist of physical swapspace and logical vm space.
@T
There are three kinds of memory, that affect these two resources in different ways: 
\begin{description}

\item[memory mapping] which ask for a logical region of virtual memory space.
In principal, no physical memory is needed to keep the system afloat here,
as the memory mapped file is swapped onto a disk object that already exists.

Actually, there are two kings of memory mapping used in GDK, namely 
read-only direct mapped and writeable copy-on write. For the dirty
pages, the latter actually also consumes physical memory resources, 
but that is ignored here for simplicity.

\item[anonymous virtual memory]
This is virtual memory that is mapped on the swapfile. Hence, this consumes
both logical VM space resources and physical memory space.

\item[malloced memory] 
comes from the heap and directly consumes physical memory resources.
\end{description}

We check the resource consumption with preset target values, and if these 
are exceeded, the routine BBPtrim is called that will unload the
least recently used BATs in order to decrease memory usage.

The malloc routine checks the memory consumption every 1000 calls,
or for calls larger that 50000 bytes. Consequently, at least every
50MB increase, alloc memory is checked. The VM calls always check
the memory consumption.
@h
/* default setting to administer everything */
#define GDK_MEM_NULLALLOWED
#ifdef DDI_PATCH
#define GDK_MEM_KEEPHISTO
#define GDK_VM_KEEPHISTO
#endif

#if (defined(WIN32))
#define GDK_MEM_BIGSIZE LL_CONSTANT(32768)   /* very fragile malloc */
#elif (defined(__sgi) || defined(_AIX))
#define GDK_MEM_BIGSIZE LL_CONSTANT(131072)  /* offload malloc fragmentation pressure */
#else
#define GDK_MEM_BIGSIZE LL_CONSTANT(33554432)/* robust malloc: use up till 32MB */
#endif

#if SIZEOF_LONG==8
#define GDK_VM_MAXSIZE	LL_CONSTANT(137438953472) /* :-) a 64-bit OS: 128 GB */
#elif defined(WIN32) 
#define GDK_VM_MAXSIZE	LL_CONSTANT(536870912) /* :-( New Technology DOS extender: 512MB */
#else
#define GDK_VM_MAXSIZE	LL_CONSTANT(1610612736) /* :-| a 32-bit OS: 1.5GB */
#endif

#define SEG_SIZE(x,y)   ((x)+(((x)&((1<<(y))-1))?(1<<(y))-((x)&((1<<(y))-1)):0))
#define MAX_BIT         ((int) (sizeof(long)<<3))
@c
	 ptr	GDK_mem_start = NULL; 
volatile lng	GDK_mem_cursize = LL_CONSTANT(0);
	 lng	GDK_mem_maxsize = LL_CONSTANT(0);
	 lng	GDK_mem_bigsize = GDK_MEM_BIGSIZE;
volatile lng	GDK_vm_cursize = LL_CONSTANT(0);
	 lng	GDK_vm_minsize = 131072;
	 lng	GDK_vm_maxsize = GDK_VM_MAXSIZE;
#ifdef GDK_VM_KEEPHISTO
	 BAT*	GDK_vm_histo = NULL;
volatile int GDK_vm_nallocbuf[MAX_BIT<<2] = { 0 };
volatile int* GDK_vm_nallocs = GDK_vm_nallocbuf;
#endif
#ifdef GDK_MEM_KEEPHISTO
	 BAT*	GDK_mem_histo = NULL;
volatile int	GDK_nmallocbuf[MAX_BIT<<2] = { 0 };
volatile int*	GDK_nmallocs = GDK_nmallocbuf;
#endif

lng GDKmem_heapsize() {
	lng heapsize = (((char*) sbrk(0)) - ((char*) GDK_mem_start));
	return (lng) SEG_SIZE(heapsize,MT_VMUNITLOG);
}

#ifdef GDK_MEM_SIMPLE
lng GDKmem_heapinuse() {
	/* we do not keep statistics ourselves; so we ask malloinfo */
	struct mallinfo m = MT_mallinfo();
        return (lng) (m.usmblks + m.uordblks);
}
#else 
lng	GDK_heap_inuse = LL_CONSTANT(0);

lng GDKmem_heapinuse() {
	return GDK_heap_inuse;
}
#endif

static int GDK_vm_allocs = 0;
static int GDK_mem_allocs = 0;

/* histogram update macro */
#define GDKmallidx(idx,size)\
{ int _mask;\
  if (size < 128) {\
    _mask = (1<<6);\
    idx = 7;\
  } else {\
    _mask = (1<<(MAX_BIT-1));\
    idx = MAX_BIT;\
  }\
  while(idx-- > 4) {\
        if (_mask&size) break;\
        _mask >>=1;\
  }\
  idx <<= 2;\
}

/* at least each 50M of memory increase, BBPtrim is run */
#define CHKMEM(meminc, vminc) {\
	int memchk = (meminc>LL_CONSTANT(0) && (++GDK_mem_allocs>=1000 || meminc>LL_CONSTANT(50000)));\
	int vmchk = (vminc>LL_CONSTANT(0) && (++GDK_vm_allocs>=10 || vminc>LL_CONSTANT(5000000)));\
	if (memchk || vmchk) GDKmemchk(memchk, vmchk);\
}
	
void GDKmemchk(int memchk, int vmchk) {
	lng memtarget = memchk?(GDKmem_inuse() - GDK_mem_maxsize):0;
	lng vmtarget = vmchk?(GDKvm_cursize() - GDK_vm_maxsize):0;
	MEMDEBUG {
		THRprintf(GDKerr, "GDKmemchk (memcur=%u,memmax=%u) (vmcur=%u,vmmax=%u)\n",
			(unsigned int) GDKmem_inuse(), (unsigned int) GDK_mem_maxsize, 
			(unsigned int) GDK_vm_cursize, (unsigned int) GDK_vm_maxsize);
	}
	if (memtarget < LL_CONSTANT(0)) {
		memtarget = LL_CONSTANT(0);
	}
	if (vmtarget < LL_CONSTANT(0)) {
		vmtarget = LL_CONSTANT(0);
	}
	if (memtarget > 0 || vmtarget > 0) {
		BBPtrim(memtarget, vmtarget);
	}
	GDK_mem_allocs = GDK_vm_allocs = 0;
}

void GDKmeminc(lng memdelta, lng vmdelta) {
	long segsize = (lng) SEG_SIZE(vmdelta,MT_VMUNITLOG);

	GDK_mem_cursize += memdelta;
#ifdef GDK_VM_KEEPHISTO
{	int idx;
        GDKmallidx(idx, segsize);
        GDK_vm_nallocs[idx]++; }
#endif
        GDK_vm_cursize += segsize;
	CHKMEM(memdelta,vmdelta);
}

void GDKmemdec(lng memdelta, lng vmdelta) {
	long segsize = (lng) SEG_SIZE(vmdelta,MT_VMUNITLOG);

	GDK_mem_cursize -= memdelta;
#ifdef GDK_VM_KEEPHISTO
{	int idx;
        GDKmallidx(idx, segsize);
        GDK_vm_nallocs[idx]--; }
#endif
        GDK_vm_cursize -= segsize;
}

@- Malloc 
@T
Malloc normally maps through directly to the OS provided malloc/free/realloc
calls. Where possible, we want to use the -lmalloc library on Unix systems, 
because it allows to influence the memory allocation strategy. This can prevent
fragmentation and greatly help enhance performance.

The only "added-value" of the GDKmalloc/GDKfree/GDKrealloc over the standard OS
primitives is that the GDK versions try to do recovery from failure to malloc by 
initiating a BBPtrim (to unload BAts and make space in the memory). This basic 
behaviour is obtained by defining GDK\MEM\_SIMPLE. 

A number of different strategies are available using different switches, however:
\begin{description}

\item[zero sized blocks]
Normally, GDK gives fatal errors on illegal block sizes.
This can be overridden with  GDK\_MEM\_NULLALLOWED.

\item[resource tracking]
Many malloc interfaces lack a routine that tells the size of a blobk
by the pointer. We need this information for correct malloc statistics.

Some systems (like cygnus) already store the blocksize in front of
the pointer (and do not have alignment problemes described below). In
that case, we save the overhead of redoing this ourselves by defining 
GDK\_MEM\_QUERYSIZE.

\item[outstanding block histograms]
In order to solve the problem, we allocate extra memory in front of the 
returned block. With te resource tracking in place, we keep a total of 
allocated bytes.  Also, if GDK\_MEM\_KEEPHISTO is defined, we keep a histogram 
of the outsanding blocks on the log2 of the blocksize (similarly for virtual.
memory blocks; define GDK\_VM\_KEEPHISTO).

\item[ensuring 8-byte alignment]
While doing the resource tracking, we can in one go solve the problem
of 32-bit systems that return non-8 bytes algigned pointers. This is
encoded by storing a size + 1 (we always normalize sizes to multiples of 
8, so this is easily recognized). This check is done automatically when
GDK\_MEM\_SIMPLE is {\bf not} enabled.

\item[redirection to anonymous VM]
Sometimes, fragmentation problems arise on mallocs that are not tuneable.
In that case, it makes sense to redirect large block requests (taken to be
larger than GDK\_mem\_bigsize) to anonymous virtual memory. The seamless
implmentation of this stores the {\bf negative} blocksize in front of the
pointer (as well as the VM maxsize), so the malloc primitives can recognize
these redirected blocks.This behavior is enabled by defining GDK\_MEM\_VMREDIRECT.
\end{description}
@c
#ifdef GDK_MEM_QUERYSIZE
#define GDK_MEM_BLKSIZE(p) GDK_MEM_QUERYSIZE(p)
#else
#define GDK_MEM_BLKSIZE(p) ((unsigned int*) (p))[-1]
#endif

static 
void GDKmemdump() {
	struct mallinfo m = MT_mallinfo();

	THRprintf(GDKerr, "\n!mallinfo.arena = %d\n", m.arena);
	THRprintf(GDKerr, "!mallinfo.ordblks = %d\n", m.ordblks);
	THRprintf(GDKerr, "!mallinfo.smblks = %d\n", m.smblks);
	THRprintf(GDKerr, "!mallinfo.hblkhd = %d\n", m.hblkhd);
	THRprintf(GDKerr, "!mallinfo.hblks = %d\n", m.hblks);
	THRprintf(GDKerr, "!mallinfo.usmblks = %d\n", m.usmblks);
	THRprintf(GDKerr, "!mallinfo.fsmblks = %d\n", m.fsmblks);
	THRprintf(GDKerr, "!mallinfo.uordblks = %d\n", m.uordblks);
	THRprintf(GDKerr, "!mallinfo.fordblks = %d\n", m.fordblks);
#ifdef GDK_MEM_KEEPHISTO
	if (GDK_mem_histo) {	
		BUN p,q;
		THRprintf(GDKerr, "!memory histogram\n");
		BATloop(GDK_mem_histo, p, q) {
			THRprintf(GDKerr, "! %d %d\n", 
				*(int*) BUNhloc(GDK_mem_histo,p), 
				*(int*) BUNtloc(GDK_mem_histo,p));
		}
	}
#endif
#ifdef GDK_VM_KEEPHISTO
	if (GDK_vm_histo) {	
		BUN p,q;
		THRprintf(GDKerr, "\n!virtual memory histogram\n");
		BATloop(GDK_vm_histo, p, q) {
			THRprintf(GDKerr, "! %d %d\n", 
				*(int*) BUNhloc(GDK_vm_histo,p), 
				*(int*) BUNtloc(GDK_vm_histo,p));
		}
	}
#endif
}

static
void GDKmemfail(str s, int len, lng memtarget, lng vmtarget) {
	int bak = GDKdebug;

	/* bumped your nose against the wall; try to prevent repetition by adjusting maxsizes */
	if (memtarget) {
		lng newmax = 0.7 * GDKmem_inuse();
		if (newmax < GDK_mem_maxsize) GDK_mem_maxsize = newmax;
	}
	if (vmtarget) {
		lng newmax = 0.7 * GDKvm_cursize();
		if (newmax < GDK_vm_maxsize) GDK_vm_maxsize = newmax;
	}

        if (GDKthreadLock) MT_set_lock(GDKthreadLock, "GDKmemfail");
	THRprintf(GDKerr, "%s(%d) fail => BBPtrim(enter) usage[mem=%u,vm=%u]\n", s, len, 
			(unsigned int) GDKmem_inuse(), (unsigned int) GDKvm_cursize());
	GDKmemdump();
	GDKdebug |= 4;
        if (GDKthreadLock) MT_unset_lock(GDKthreadLock, "GDKmemfail");

        BBPtrim(memtarget, vmtarget);

        if (GDKthreadLock) MT_set_lock(GDKthreadLock, "GDKmemfail");
	GDKdebug = MIN(GDKdebug,bak);
	THRprintf(GDKerr, "%s(%d) fail => BBPtrim(ready) usage[mem=%u,vm=%u]\n", s, len, 
			(unsigned int) GDKmem_inuse(), (unsigned int) GDKvm_cursize());
	GDKmemdump();
        if (GDKthreadLock) MT_unset_lock(GDKthreadLock, "GDKmemfail");
}


#if defined(GDK_MEM_QUERYSIZE) || defined(GDK_MEM_SIMPLE)
#define GDKmalloc_prefixsize(s,size) 					\
	s = (long*) malloc(size)
#else
#define GDKmalloc_prefixsize(s, size) {					\
	long realsize = size + ((size&3)?12-(size&3):8);		\
	char *p = (char *) malloc((size_t) realsize);			\
	if (p == NULL) {						\
		s = NULL;						\
	} else if (((long) p) & 4) { /* misaligned */			\
		s = (long*) (p + 4); /* place 4 bytes before it */ 	\
		s[-1] = realsize + 1;  /* 1 is a marker */		\
	} else {							\
		s = (long*) (p + 8); /* place 8 bytes before it */ 	\
		s[-1] = realsize;					\
	}								\
}
#endif


void* GDKmalloc(size_t size) {
	long *s;

#ifdef GDK_MEM_NULLALLOWED
        if (size == 0) {
		return NULL;
	}
#endif
        if (size <= 0) {
                GDKfatal("GDKmalloc called with size %u", size);
        }
	CHKMEM(((lng)size),LL_CONSTANT(0));

#ifdef GDK_MEM_VMREDIRECT
	if (size > GDK_mem_bigsize) {
		long maxsize = (size += 16);
		char *p = (char*) GDKvmalloc((size_t) size, (size_t*) &maxsize);
		MT_alloc_register(p, maxsize, 'S');
		s = (long*) (p + 16);
		s[-2] = maxsize;
		s[-1] = -((long) size);
	} else 
#endif
	GDKmalloc_prefixsize(s, size);

       	if (s == NULL) {
		GDKmemfail("GDKmalloc", size, BBPTRIM_ALL, 0);
		GDKmalloc_prefixsize(s, size);
		if (s == NULL) { 
			MT_alloc_print();
               		GDKfatal("GDKmalloc failed for %u bytes",size);
		} else {
			THRprintf(GDKerr, "GDKmalloc: recovery ok. Continuing..\n");
		}
	}
#ifndef GDK_MEM_SIMPLE
{	long realsize = GDK_MEM_BLKSIZE(s);
	if (realsize > 0) {	
#ifdef GDK_MEM_KEEPHISTO
		int idx;
		GDKmallidx(idx, realsize);
		GDK_nmallocs[idx]++; 
#endif
		GDK_heap_inuse += realsize;
	}}
#endif
        return (void*) s;
}
 
void GDKfree (void *blk) {
	long size, *s = (long*) blk;

        if (s == NULL) return;
	size = GDK_MEM_BLKSIZE(s);
	if (size > 0) {
#ifdef GDK_MEM_KEEPHISTO
		int idx;
		GDKmallidx(idx,size);
		GDK_nmallocs[idx]--;
/*		if (GDK_mallocs[idx]-- <= 0) {
			GDKwarning("free(%p): unused pointer\n", blk);
		} else */
#endif
		GDK_heap_inuse -= size; 
	}
#ifdef GDK_MEM_VMREDIRECT
	if (size < 0) {
		long maxsize = s[-2];
		size = -size;
		MT_alloc_register(((char*) s) - 16, maxsize, 's');
		GDKvmfree(((char*) s)- 16, (size_t) size, (size_t) maxsize);
	} else
#endif
#ifndef GDK_MEM_QUERYSIZE
	if (size&1) {
		free(((char*) s) - 4);
	} else {
		free(((char*) s) - 8);
	}
#else
	free(blk);
#endif
}

ptr GDKrealloc(void* blk, size_t size) {
        if (blk == NULL) {
		return GDKmalloc(size);
	}
#ifdef GDK_MEM_NULLALLOWED
        if (size == 0) {
		GDKfree(blk);
		return NULL;
	}
#endif
        if (size <= 0) {
                GDKfatal("GDKrealloc called with size %u", size);
        }
#ifdef GDK_MEM_SIMPLE
        CHKMEM(((lng)size),LL_CONSTANT(0));
        blk = realloc(blk, size);
#else
{       long cpysize, *s = (long*) blk;
        long oldsize = GDK_MEM_BLKSIZE(s);
#ifdef GDK_MEM_VMREDIRECT
	if (oldsize < 0) {
		cpysize = MIN(((long) size), (-oldsize) - 16);
	} else 
#endif
#ifdef GDK_MEM_QUERYSIZE
	cpysize = MIN(((long) size), oldsize);
#else
	if (oldsize&1) {
		cpysize = MIN(((long) size), oldsize - 5);
	} else {
		cpysize = MIN(((long) size), oldsize - 8);
	}
#endif
	/* the bad news is that the alignment problems on 32-bit systems prevent us from using realloc 
         * the good news is that we know our block sizes; so we can at least copy it to the new location
         */
        blk = (void* ) GDKmalloc(size);
        memcpy(blk, s, cpysize);
        GDKfree(s);
}
#endif
        return blk;
}

char *GDKstrdup(char *s) {
        int l = strLen(s);
        char *n = (char *) GDKmalloc(l);
        memcpy(n,s, l);
        return n;
}
 

@- virtual memory
allocations affect only the logical VM resources.
@c
void *GDKmmap(char* path, int mode, size_t off, size_t len, void *fixed) {
        void *ret = MT_mmap(path, mode, off, len, fixed);
        if (ret == (void*) -1) {
                GDKmemfail("GDKmmap", len, 0, BBPTRIM_ALL);
                ret = MT_mmap(path, mode, off, len, fixed);
                if (ret != (void*) -1) {
                    THRprintf(GDKerr, "GDKmmap: recovery ok. Continuing..\n");
                }
        }
        if (ret != (void*) -1) {
                MT_alloc_register(ret, len, 'M');
                GDKmeminc(len, len);
        }
        return (void*) ret;
}

int GDKmunmap(void* addr, size_t size) {
        int ret;
        MT_alloc_register(addr, size, 'm');
        ret = MT_munmap(addr, size);
        if (ret == 0) {
                GDKmemdec(size, size);
        }
        return ret;
}

 
@- VM alloc
this affects both physical and logical memory resources.
@c
void* GDKvmalloc(size_t size, size_t *maxsize) {
	void *ret = MT_vmalloc(size, maxsize);
        if (ret == NULL) {
                GDKmemfail("GDKvmalloc", size, BBPTRIM_ALL, BBPTRIM_ALL);
                ret = MT_vmalloc(size, maxsize);
                if (ret == NULL) {
                        MT_alloc_print();
                        GDKfatal("GDKvmalloc failed for %u bytes",size);
                } else {
                        THRprintf(GDKerr, "GDKvmalloc(%d): recovery ok. Continuing..\n", size);
                }
        }
        if (ret != NULL) {
                GDKmeminc(size, *maxsize);
	}
	return ret;
}

void* GDKvmrealloc(void* pold, size_t oldsize, size_t newsize, size_t oldmax, size_t *maxsize) {
	void *ret = MT_vmrealloc(pold, oldsize, newsize, maxsize);
        if (ret == NULL) {
                GDKmemfail("GDKvrealloc", newsize, BBPTRIM_ALL, BBPTRIM_ALL);
                ret = MT_vmrealloc(pold, oldsize, newsize, maxsize);
                if (ret == NULL) {
                        MT_alloc_print();
                        GDKfatal("GDKvrealloc failed for %u bytes (from %u)", newsize, oldsize);
                } else  {
                        THRprintf(GDKerr, "GDKvmrealloc(%d): recovery ok. Continuing..\n", newsize);
                }
        }
        if (ret != NULL) {
                GDKmemdec(oldsize,oldmax);
                GDKmeminc(newsize,*maxsize);
	}
	return ret;
}

void GDKvmfree(void* blk, size_t size, size_t maxsize){
	MT_vmfree(blk, maxsize);
	GDKmemdec(size, maxsize);
}

@+ Session Initialization
The parameter @%db@ is followed by the database name relative to
the environment variable dbfarm.
The parameter @%monetrc@ tells that the system variables setting
should be overruled by the specification given in the file argument.
This format is only necessary to temporarely experiment with variable settings,
without disturbing a system/site default setting.

The interface code to the operating system is highly dependent on
the processing environment. It can be filtered away with compiletime flags.
Suicide is necessary due to some system implementation errors.

The kernel requires file descriptors for I/O with the user.
They are thread specific and should be obtained by a function.

The arguments relevant for the kernel are extracted from the list. 
Their value is turned into a blanc space.
@c
#ifndef HAVE_TM_ZONE
int GDKtime_zero = 0;
#else
struct timezone GDKtime_zero = { 0 };
#endif
int GDKtime_startsec, GDKrecovery = 0; 

#define clr(X) {int k; for(k=0;argv[X][k];k++) argv[X][k]=0;}

int GDKinit(int argc, char** argv) {
	struct timeval tp;
	int 	i;
	str 	home = 0; 
	str 	db = 0; 
	str	dbhome, monetrc=0;

	errno = 0;
	for (i = 0; i < argc; i++) {
		if (argv[i][0] != '-')
			continue;
		switch(argv[i][1]) {
		case 'm': if ( strcmp("-monetrc",argv[i])== 0){
				clr(i);
				monetrc= GDKstrdup(argv[++i]);
				clr(i);
			}
			break;
		case 'd': if (strcmp("-db", argv[i]) == 0) {
				clr(i);
				db = GDKstrdup(argv[++i]); 
				clr(i);
			}
			break; 
		case 'r': if (strcmp("-recover", argv[i]) == 0){
				GDKrecovery = 1; 
				clr(i);
			  }
			break;
		}
	}
	GDKenvironment(db,monetrc);
	if (GDKdbnameStr[0] == 0) {
	    fprintf(stderr, 
		"GDKhomeScan: %s:  database name missing.\n",
		home);
	}
	if (GDKdirStr[0] == 0) {
	    fprintf(stderr,
		"GDKhomeScan: %s: directory name missing.\n",
		home); 
	}
	PROPDEBUG GDKdebug |= 2; 
	MT_init_posix();
	THRinit();
	BATSIGinit(); 
	GDKlockHome(); 

	/* init time */
	gettimeofday(&tp, &GDKtime_zero);
	GDKtime_startsec = tp.tv_sec;

	if (GDK_mem_start == NULL) {
		GDK_mem_start = (ptr) sbrk(0); 
	}
	GDKthreadLock = MT_create_lock(); 
	for(i=0; i<= BBPLOCKMASK; i++) {
		GDKstatusLock[i] = MT_create_lock(); 
		GDKswapLock[i] = MT_create_lock(); 
		GDKidxLock[i] = MT_create_lock(); 
		GDKhashLock[i] = MT_create_lock(); 
	}
	GDKcacheLock = MT_create_lock(); 
	GDKtrimLock = MT_create_lock(); 

	/* Mserver intends to rob 85% of all memory as a default */
 	GDK_mem_maxsize = ((lng) MT_npages()) * ((lng) MT_pagesize())*0.85; 

	GDKremovedir(DELDIR);  
	BBPinit(); 
#ifdef GDK_MEM_KEEPHISTO
	GDK_mem_histo = BATnew(TYPE_lng,TYPE_int,MAX_BIT);
	BATrename(GDK_mem_histo, "monet_histo_mem");
	BATmode(GDK_mem_histo, TRANSIENT);
	for(i=3; i<22; i++) {
		lng j = 1<<i;
		BUNins(GDK_mem_histo, (ptr)&j, (ptr)(GDK_nmallocs+(4*i)));
	}
        BATfakeCommit(GDK_mem_histo);
	GDK_nmallocs = ((int*) GDK_mem_histo->batBuns->base) - 6;
#endif
#ifdef GDK_VM_KEEPHISTO
#ifdef __CYGWIN32__
	GDKmallidx(i, 67108864);
	GDK_vm_nallocs[i]++; 
#endif
	GDK_vm_histo = BATnew(TYPE_lng,TYPE_int,MAX_BIT);
	BATrename(GDK_vm_histo, "monet_histo_vm");
	BATmode(GDK_vm_histo, TRANSIENT);
	for(i=12; i<31; i++) {
		lng j = 1<<i;
		BUNins(GDK_vm_histo, &j, GDK_vm_nallocs+(4*i));
	}
	BATfakeCommit(GDK_vm_histo);
	GDK_vm_nallocs = ((int*) GDK_vm_histo->batBuns->base) - 42; 
#endif
	return 0;
}

@- 
Upon closing the session, all persistent BATs should be saved and
the transcient BATs should be removed.
The buffer pool manager takes care of this.
@c
int GDKstopped = 1;

void GDKexit() {
        if (GDKthreadLock) MT_set_lock(GDKthreadLock, "GDKexit");
        if (GDKstopped == 0) {
                GDKstopped++; /* shouldn't there be a lock here? */
                GDKnrofthreads = 0;
                if (GDKthreadLock) MT_unset_lock(GDKthreadLock, "GDKexit");
		(void) GDKgetHome();
		BBPexit(); 
		GDKlog(GDKLOGOFF);
		GDKunlockHome(); 
		MT_global_exit(0); 
	} 
	if (GDKthreadLock) MT_unset_lock(GDKthreadLock, "GDKexit");
}

@
All semaphores used by the application should be mentioned here.
They are initialized during system initialization.
@c
int		GDKdebug = 2; 

MT_Lock		GDKthreadLock = NULL; 
MT_Lock		GDKstatusLock[BBPLOCKMASK+1]; 
MT_Lock		GDKswapLock[BBPLOCKMASK+1]; 
MT_Lock		GDKidxLock[BBPLOCKMASK+1]; 
MT_Lock		GDKhashLock[BBPLOCKMASK+1]; 
MT_Lock		GDKcacheLock, GDKtrimLock; 

@+ Concurrency control
Concurrency control requires actions at several levels of the system.
First, it should be ensured that each database  is controlled by a single
server process (group). Subsequent attempts should be stopped.
This is regulated throught file locking against ".gdk_lock".
Furthermore, the server process is moved to the database directory
for improved speed.
@c
@-
Before the locks and threads are initiated, we cannot use the 
normal routines yet. So we have a local fatal here instead of GDKfatal. 
@c
void GDKlockHome() {
	char *p=0, buf[1024], host[PATHLENGTH];
@-
Go there and obtain the global database lock.
@c
	if (chdir(GDKdirStr) < 0 ){
	    GDKfatal("GDKlockHome: could not move to %s\n", GDKdirStr);
	}
	if (GDKrecovery  && unlink(GDKLOCK) < 0) {
	    GDKfatal("GDKlockHome: unlock DB failed\n"); 
	}
	umask(0000);
	if (MT_lockf(GDKLOCK, F_TLOCK, 4, 1) < 0) {
	    GDKlockFile = 0;
	    GDKfatal("GDKlockHome: Database lock '%s' denied\n", GDKLOCK); 
	}
	if ((GDKlockFile = fopen(GDKLOCK, "rb+")) == NULL) {
	    GDKfatal("GDKlockHome: Could not open %s\n", GDKLOCK); 
	}
	if (fgets(buf, 1024, GDKlockFile) && (p=strchr(buf, ':'))) *p = 0;
	if (p) {
	    sprintf(host, " from '%s'", buf);
	} else {
	    GDKwarning("GDKlockHome: ignoring empty or invalid %s.\n", GDKLOCK);
	    host[0] = 0;
	}
@-
We have the lock, are the only process currently allowed in this section.
@c
	MT_init();
	OIDinit();
@-
Print the new process list in the global lockfile.
@c
	fseek(GDKlockFile, 0, SEEK_SET);
	ftruncate(fileno(GDKlockFile), 0);
	fflush(GDKlockFile);
	GDKlog(GDKLOGON);
@-
In shared mode, we allow more parties to join. Release the lock. 
@c
	GDKstopped = 0;
}

void GDKunlockHome() {
	if (GDKlockFile) {
		MT_lockf(GDKLOCK, F_ULOCK, 4, 1); 
		fclose(GDKlockFile); 
		GDKlockFile = 0; 
	}
}
@-
Really really get the lock. Now!!
@c
int GDKgetHome() {
	if (GDKlockFile) return 0;
	if (MT_system_lock==NULL) return 0;
	while ((GDKlockFile = fopen(GDKLOCK, "r+")) == NULL) {
		GDKerror("GDKgetHome: PANIC on open %s. sleep(1)\n", GDKLOCK);
		sleep(1);
	}
	if (MT_lockf(GDKLOCK, F_TLOCK, 4, 1) < 0){
		GDKwarning("GDKgetHome: blocking on lock '%s'.\n", GDKLOCK);
		MT_lockf(GDKLOCK, F_LOCK, 4, 1);
	}
	return 1;
}

@+ Error handling
Errors come in three flavors: warnings, non-fatal and fatal errors.
A fatal error leaves a core dump behind after trying to
safe the content of the relation.
A non-fatal error returns a message to the user
and aborts the current transaction.
Fatal errors are also recorded on the system log for post-mortem
analysis.
@c
int GDKsilent = 0;

void GDKaddbuf(char *message) {
	char *buf = GDKerrbuf;

	if (buf) {
		char *dst = buf + strlen(buf);
		int maxlen = GDKMAXERRLEN - (dst - buf);
		strncpy(dst, message, maxlen);
		dst[maxlen - 1] = '\0';
	} else if (!GDKsilent) {
                THRprintf(GDKerr, message); 
	}
}

/*VARARGS*/
int GDKwarning(char *format, ...) {
	char message[GDKMAXERRLEN];	
	int len = strlen(GDKWARNING);
	va_list ap; 

	strcpy(message, GDKWARNING);
	va_start(ap, format); 
	vsnprintf(message + len, GDKMAXERRLEN-(len+2), format, ap); 
	va_end (ap); 

	GDKaddbuf(message);

	return 0;
}


/*VARARGS*/
int GDKerror(char *format, ...) {
	char message[GDKMAXERRLEN];	
	int len = strlen(GDKERROR);
	va_list ap; 

	strcpy(message, GDKERROR);
	va_start(ap, format); 
	vsnprintf(message + len, GDKMAXERRLEN-(len+2), format, ap); 
	va_end(ap); 

	GDKaddbuf(message);

	return 0;
}

/*VARARGS*/
int GDKsyserror(char *format, ...)
{
        char message[GDKMAXERRLEN];
        int len = strlen(GDKERROR);

        int     err = errno;
        va_list ap;

	strcpy(message, GDKERROR);
	va_start(ap,format); 
	vsnprintf(message + len, GDKMAXERRLEN-(len+2), format, ap); 
	va_end(ap); 
	if (err > 0 && err < 1024) {
		char *osmsg = strerror(err);
		int len1  = strlen(message);
		int len2  = len1 + strlen(GDKMESSAGE);
		int len3  = len2 + strlen(osmsg);

		if (len3 + 2 < GDKMAXERRLEN) {
			strcpy(message + len1, GDKMESSAGE);
			strcpy(message + len2, osmsg);
			message[len3] = '\n';
			message[len3+1] = 0;
		}
	}
	GDKaddbuf(message);

	errno = 0;
	return err;
}

/*VARARGS*/
int GDKfatal(char *format, ...) {
	char message[GDKMAXERRLEN];	
	int len = strlen(GDKFATAL);
	va_list ap; 
	FILE *fd=stderr;

	GDKdebug |= 16;
	BATSIGinit();	
	strcpy(message, GDKFATAL);
	va_start(ap, format); 
	vsnprintf(message + len, GDKMAXERRLEN-(len+2), format, ap); 
	va_end(ap); 

	if (GDKsilent == 0) {
            fputs(message, fd); 
	    fputs("\n", fd);
            fflush(fd); 
	}
@-
Real errors should be saved in the lock file for post-crash inspection.
@c
	if (GDKstopped) {
        	fflush(stderr);
		MT_exit_thread(1);
        	/* exit(1); */
	} else {
		GDKlog(message);
#ifdef COREDUMP
        	abort(); 
#else
        	GDKexit(); 
	}
#endif
	return -1;
}

@- Timers
The following relative timers are available for inspection.
Note that they may consume recognizable overhead.
@c

lng GDKusec() {
	struct timeval tp;
	gettimeofday(&tp, &GDKtime_zero);
        return ((lng) (tp.tv_sec-GDKtime_startsec))*
		LL_CONSTANT(1000000) + (lng) tp.tv_usec;
}


int GDKms() {
	struct timeval tp;
	gettimeofday(&tp, &GDKtime_zero);
        return (tp.tv_sec-GDKtime_startsec)*1000 + tp.tv_usec/1000;
}

int GDKcsec() {
	struct timeval tp;
	gettimeofday(&tp, &GDKtime_zero);
        return (tp.tv_sec-GDKtime_startsec)*100 + tp.tv_usec/10000;
}


int GDKsec() {
	struct timeval tp;
	gettimeofday(&tp, &GDKtime_zero);
	return tp.tv_sec - GDKtime_startsec;
}


@+ Logical Thread management

All semaphores used by the application should be mentioned here.
They are initialized during system initialization.

@- 
The first action upon thread creation is to add it to the pool
of known threads. This should be done by the thread itself.
Subsequently, the thread descriptor can be obtained usign @%THRget@.
Note that the users should have gained exclusive access already.
A new entry is initialized automatically when not found.
Its file descriptors are the same as for the server and should be
subsequently reset.
@c
int		GDKnrofthreads; 
ThreadRec 	GDKthreads[THREADS]; 
void *		THRdata[THREADDATA] = { 0 };

Thread THRget(MT_Id tid) {
	return (GDKthreads+(int)tid-1);
}

static INLINE 
unsigned long THRsp(){
	int l = 0;
	unsigned long sp = (unsigned long)(&l);
	
	return sp;
}

Thread THRnew(MT_Id pid, str name) {
	MT_Id tid = 0;
 	Thread 	t;
	Thread	s; 

	MT_set_lock(GDKthreadLock, "THRnew"); 
	for (s = GDKthreads, t = s + THREADS; s < t; s++) {
		if (s->pid == pid) {
			MT_unset_lock(GDKthreadLock, "THRnew"); 
			GDKwarning("THRnew:duplicate %d\n", pid); 
			return s; 
		}
	}
	for (s = GDKthreads, t = s + THREADS; s < t; s++) {
		if (s->pid == 0) {
			break; 
		}
	}
	if (s == t) {
		MT_unset_lock(GDKthreadLock, "THRnew"); 
		GDKfatal("THRnew:too many threads\n"); 
	}

	tid = s->tid;
	memset((char*) s, 0, sizeof(*s)); 
	s->pid = pid; 
	s->tid = tid;
	s->data[1] = stdin; 
	s->data[0] = stdout; 
	s->name = name; 
	s->cleanup = NULL;
	s->sp = THRsp();
	PARDEBUG THRprintf(GDKerr, "%lu sp = %lu\n", 
			(unsigned long) s->tid, (unsigned long) pid, s->sp); 
	PARDEBUG THRprintf(GDKerr, "nrofthreads %d\n", GDKnrofthreads); 
	GDKnrofthreads++; 
	MT_alloc_register(&tid, 1, '0'+ ((int) tid) - 1);
	MT_unset_lock(GDKthreadLock, "THRnew"); 

	return s; 
}

void THRdel(Thread t) {	
	if (t < GDKthreads || t > GDKthreads + THREADS) {
		GDKfatal("THRdel\n"); 
	}
	MT_set_lock(GDKthreadLock, "THRdel"); 
	if (t->cleanup) {
		(*t->cleanup)(t);
	}
	PARDEBUG 
	THRprintf(GDKerr, "pid = %lu, disconnected, %d left\n", 
		(unsigned long) t->pid, GDKnrofthreads); 
	t->pid = 0; 
	GDKnrofthreads--; 
	MT_unset_lock(GDKthreadLock, "THRdel"); 
}
@- 
The easiest way to terminate a thread is to identify its name
A zero is returned when the thread could not be found
@c
static Thread GDK_find_thread(MT_Id pid){
   	Thread t, s;
	for (t = GDKthreads, s = t + THREADS; t < s; t++) {
		if (t->pid && t->pid == pid ){
			return t; 
		}
	}
   	return NULL;
}

int THRexit(str nme) {
	Thread	t;
	Thread	s; 

	for (t = GDKthreads, s = t + THREADS; t < s; t++) {
		if (t->pid && t->name && strcmp(t->name, nme) == 0) {
			MT_Id victim = t->pid; 
			THRdel(t); 
			MT_kill_thread(victim); 
			return 1; 
		}
	}
	return 0; 
}

int THRcnt() {
	return GDKnrofthreads; 
}

int THRhighwater() {
	unsigned long c = THRsp();
	Thread s;
	unsigned long diff;

	s = GDK_find_thread(MT_getpid());
	if (s== NULL) return 0;
	diff = (c<s->sp)?s->sp-c:c-s->sp;
	if (diff > (THREAD_STACK_SIZE-2048)){
		return 1;
	}
	return 0;
}

@{
@- 
I/O is organized per thread, because users may gain access through
the internet.
The code below should be improved to gain speed.
@c

int THRinit() {
	int i = 0;
	THRdata[0] = (void*) stdout;
	THRdata[1] = (void*) stdin;
	for ( i = 0; i<THREADS; i++ ){
		GDKthreads[i].tid = (MT_Id)(i+1);
	}
	return 0;
}

void THRsetdata(int n, ptr val) {
	Thread s = GDK_find_thread(MT_getpid());
	if (s) s->data[n] = val;
}

void*  THRgetdata(int n) {
	Thread s = GDK_find_thread(MT_getpid());
	return (s?s->data[n]:THRdata[n]);
}

MT_Id THRgettid(){
	Thread s = GDK_find_thread(MT_getpid());
	return (s?s->tid:(MT_Id)1);
}

static char THRprintbuf[1024];

/*VARARGS*/
int THRprintf(FILE *fp, char *format, ...) {
	str p = THRprintbuf; 
        va_list ap;
	*p = 0;
	if (MT_system_lock) {
		MT_set_lock(MT_system_lock, "THRprintf");
	}
	if (*format != '!') {
	        *p++ = '#';
	} else {
	        *p++ = '!'; format++;
	}
	if (GDKdebug&1) {
		sprintf(p, "%02d ", (int) THRgettid());
		while(*p) p++;
	}
        va_start (ap,format);
               vsprintf (p, format, ap);
        va_end (ap);
	fputs(THRprintbuf, fp);
	fflush(fp);
	if (MT_system_lock) {
		MT_unset_lock(MT_system_lock, "THRprintf");
	}
        return 0;
}

#endif
