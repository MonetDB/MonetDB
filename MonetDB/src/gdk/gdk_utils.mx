@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f gdk_utils
@a M. L. Kersten, P. Boncz

@* Utilities
The utility section contains functions to initialize the Monet database
system, memory allocation details, and a basic system logging scheme.
@-
@{
@h
#ifndef _GDK_UTILS_H_
#define _GDK_UTILS_H_

gdk_export void GDKlog(const char *format, ...);
gdk_export void GDKlockHome(void);
gdk_export void GDKunlockHome(void);
gdk_export int GDKgetHome(void);
gdk_export void GDKprotect();

gdk_export lng GDKusec(void);
gdk_export int GDKms(void);

gdk_export int gdk_alloc_map;
gdk_export BAT *GDKenv;

@c
#ifndef GDK_NOLINK
#include "gdk.h"

#else /* GDK_NOLINK */

#undef GDKmalloc
#undef GDKrealloc
#undef GDKfree
#undef GDKcalloc

#define GDKmalloc(size)	malloc(size)
#define GDKrealloc(buf,size)	realloc(buf,size)
#define GDKfree(buf)	free(buf)
#define GDKcalloc(nmemb,size) calloc(nmemb,size);
#endif

int gdk_alloc_map = 1;
char GDKdbfarmStr[PATHLENGTH] = { "dbfarm" };
char GDKdbnameStr[PATHLENGTH] = { 0 };

BAT *GDKenv = NULL;

#ifdef HAVE_FCNTL_H
#include <fcntl.h>
#endif

#ifdef HAVE_FTIME
#include <sys/timeb.h>
#endif

#if TIME_WITH_SYS_TIME
# include <sys/time.h>
# include <time.h>
#else
# if HAVE_SYS_TIME_H
#  include <sys/time.h>
# else
#  include <time.h>
# endif
#endif

#ifdef HAVE_PWD_H
# include <pwd.h>
#endif
@}
@+ Monet configuration file
Parse a possible MonetDB.conf file (either in the default location
<prefix>/etc/MonetDB.conf, or as specified by either an environment variable
$MONETDB_CONFIG, or by command line option -c/--config)
to extract pre-settings of system variables.
Un-recognized parameters are simply skipped, because they  may be
picked up by other components of the system.
The consequence is that making a typing error in the configuration file
may be unnoticed for a long time.
Syntax errors are immediately flagged, though.

Since the GDK kernel moves into the database directory, we need
to keep the absolute path to the MonetDB.conf file for top-levels
to access its information.
@{
@c

void
GDKusage()
{
	fprintf(stderr, "usage: <program> [--dbname=<db_name>] [--config=<file>]\n");
	fprintf(stderr, "<program>\tprogram using the GDK library\n");
	fprintf(stderr, "<db-name>\tdatabase to open\n");
	fprintf(stderr, "<file>\t\tsystem variable settings\n");
	fprintf(stderr, "\t\tdefault: MonetDB.conf in <prefix>/etc\n");
	fprintf(stderr, "Other arguments are dealt with in the application startup routine\n");
}

static int
GDKenvironment(str dbname, str dbfarm)
{
	if (dbname == 0) {
		fprintf(stderr, "GDKenvironment: database name missing.\n");
		return 0;
	}
	if (dbfarm == 0) {
		fprintf(stderr, "GDKenvironment: dbfarm missing.\n");
		return 0;
	}

	if (!MT_path_absolute(dbfarm)) {
		fprintf(stderr, "GDKenvironment: wrong directory %s.\n", dbfarm);
		return 0;
	}

	strncpy(GDKdbnameStr, dbname, PATHLENGTH);
	strncpy(GDKdbfarmStr, dbfarm, PATHLENGTH);
	return 1;
}

@h
gdk_export char *GDKgetenv(const char *name);

@c
char *
GDKgetenv(const char *name)
{
	BUN b = BUNfnd(GDKenv, (ptr) name);

	if (b)
		return BUNtail(GDKenv, b);
	return NULL;
}

@h
gdk_export int GDKgetenv_isyes(const char *name);

@c
int
GDKgetenv_isyes(const char *name)
{
	char *val = GDKgetenv(name);

	if (val && strcasecmp(val, "yes") == 0) {
		return 1;
	}
	return 0;
}

@h
gdk_export void GDKsetenv(str name, str value);

@c
void
GDKsetenv(str name, str value)
{
	BUNins(GDKenv, name, value);
	BATfakeCommit(GDKenv);
}

@}

@+ System logging
Per database a log file can be maintained for collection
of system management information. Its contents is driven
by the upper layers, which encode information such as
who logged on and how long the session went on.
The lower layers merely store error information on the file.
It should not be used for crash recovery, because this should be
dealt with on a per client basis.

@-
A system log can be maintained in the database to keep track
of session and crash information. It should regularly be
refreshed to avoid disk overflow.
@{
@c
#define GDKLOCK	".gdk_lock"

static FILE *GDKlockFile = 0;

#define GDKLOGOFF	"LOGOFF"
#define GDKFOUNDDEAD	"FOUND	DEAD"
#define GDKLOGON	"LOGON"
#define GDKCRASH	"CRASH"

@-
Single-lined comments can now be logged safely, together with process, thread
and user ID, and the current time.
@c
/* VARARGS */
void
GDKlog(const char *format, ...)
{
	va_list ap;
	char *p = 0, buf[1024];
	int mustopen = GDKgetHome();
	time_t tm = time(0);

	if (MT_system_lock == NULL)
		return;

	va_start(ap, format);
	vsprintf(buf, format, ap);
	va_end(ap);

	/* remove forbidden characters from message */
	for (p = buf; (p = strchr(p, '\n')) != NULL; *p = ' ')
		;
	for (p = buf; (p = strchr(p, '\@')) != NULL; *p = ' ')
		;

	fseek(GDKlockFile, 0, SEEK_END);
#ifndef HAVE_GETUID
#define getuid() 0
#endif
	fprintf(GDKlockFile, "%s \@ USR=%d PID=%d THR=" SZFMT " TIME=%s", buf, (int) getuid(), (int) getpid(), (size_t) MT_getpid(), ctime(&tm));
	fflush(GDKlockFile);

	if (mustopen)
		GDKunlockHome();
}

@}
@+ Interrupt handling
The current version simply catches signals and prints a warning.
It should be extended to cope with the specifics of the interrupt
received.
@{
@c
#ifndef NATIVE_WIN32
#include <signal.h>
RETSIGTYPE
BATSIGignore(int nr)
{
	GDKsyserror("! ERROR signal %d caught by thread %lx\n", nr, (size_t) MT_getpid());
}

RETSIGTYPE
BATSIGabort(int nr)
{
	GDKfatal("BATSIGabort: signal %d caught by thread %lx\n", nr, (size_t) MT_getpid());
}

RETSIGTYPE
BATSIGinterrupt(int nr)
{
	GDKexit(nr);
}

#ifdef SIGCHLD
RETSIGTYPE
BATSIGchild(int nr)
{
	int status;

	(void) nr;

	while (waitpid(-1, &status, WNOHANG) > 0)
		;
	PARDEBUG THRprintf(GDKerr, "CHILD EXITED \n");

	(void) signal(SIGPIPE, BATSIGchild);
}
#endif


RETSIGTYPE
BATSIGcrash(int nr)
{
	static int crash = 0;

	if (!crash++) {
		GDKerror("BATSIGcrash: Mserver internal error (%s), please restart.\n" "(One potential cause could be that your disk might be full...)\n",
#ifdef SIGBUS
			 nr == SIGBUS ? "Bus error" :
#endif
			 (nr == SIGSEGV ? "Segmentation fault" : "unknown"));
		GDKlog(GDKCRASH);
		MT_global_exit(1);
	}
}

int
BATSIGinit(void)
{
#ifdef SIGBUS
	(void) signal(SIGBUS, BATSIGcrash);
#endif
	(void) signal(SIGSEGV, BATSIGcrash);
#ifdef SIGCHLD
	(void) signal(SIGCHLD, BATSIGchild);
#endif
/* HACK to pacify compiler */
#if (defined(__INTEL_COMPILER) && (SIZEOF_VOID_P > SIZEOF_INT))
#undef  SIG_IGN			/*((__sighandler_t)1 ) */
#define SIG_IGN   ((__sighandler_t)1L)
#endif

#ifdef SIGPIPE
	(void) signal(SIGPIPE, SIG_IGN);
#endif
#ifdef __SIGRTMIN
	(void) signal(__SIGRTMIN + 1, SIG_IGN);
#endif
#ifdef SIGHUP
	(void) signal(SIGHUP, MT_exit_thread);
#endif
#ifdef SIGINT
	(void) signal(SIGINT, BATSIGinterrupt);
#endif
#ifdef SIGTERM
	(void) signal(SIGTERM, BATSIGinterrupt);
#endif
	return 0;
}
#endif	/* NATIVE_WIN32 */

@}
@+ Memory management
Memory management in GDK mostly relies on the facilities offered by the
underlying OS.  The below routines monitor the available memory resources
which consist of physical swap space and logical vm space.
There are three kinds of memory, that affect these two resources in different ways:
@table @samp

@item memory mapping
 which ask for a logical region of virtual memory space.
In principal, no physical memory is needed to keep the system afloat here,
as the memory mapped file is swapped onto a disk object that already exists.

Actually, there are two kings of memory mapping used in GDK, namely
read-only direct mapped and writable copy-on write. For the dirty
pages, the latter actually also consumes physical memory resources,
but that is ignored here for simplicity.

@item anonymous virtual memory
This is virtual memory that is mapped on the swap file. Hence, this consumes
both logical VM space resources and physical memory space.

@item malloced memory
comes from the heap and directly consumes physical memory resources.
@end table

We check the resource consumption with preset target values, and if these
are exceeded, the routine BBPtrim is called that will unload the
least recently used BATs in order to decrease memory usage.

The malloc routine checks the memory consumption every 1000 calls,
or for calls larger that 50000 bytes. Consequently, at least every
50MB increase, alloc memory is checked. The VM calls always check
the memory consumption.
@{
@h
/* default setting to administer everything */
#define GDK_MEM_NULLALLOWED

#if SIZEOF_VOID_P==8
#define GDK_VM_MAXSIZE	LL_CONSTANT(137438953472)	/* :-) a 64-bit OS: 128 GB */
#elif defined(WIN32)
#define GDK_VM_MAXSIZE	LL_CONSTANT(536870912)	/* :-( New Technology DOS extender: 512MB */
#else
#define GDK_VM_MAXSIZE	LL_CONSTANT(1610612736)	/* :-| a 32-bit OS: 1.5GB */
#endif
@c
size_t GDK_mem_maxsize = GDK_VM_MAXSIZE;
size_t GDK_mem_bigsize = GDK_VM_MAXSIZE;
size_t GDK_vm_minsize = GDK_VM_MAXSIZE;
size_t GDK_vm_maxsize = GDK_VM_MAXSIZE;

int GDK_vm_allocs = 0;
int GDK_mem_allocs = 0;

/* at least each 50M of memory increase, BBPtrim is run */
#define CHKMEM(meminc, vminc) do {					\
	int memchk = (meminc>0 && (++GDK_mem_allocs>=1000 || meminc>LL_CONSTANT(50000))); \
	int vmchk = (vminc>0 && (++GDK_vm_allocs>=10 || vminc>LL_CONSTANT(5000000))); \
	if (memchk || vmchk) GDKmemchk(memchk, vmchk);			\
} while (0)

#define SEG_SIZE(x,y)   ((x)+(((x)&((1<<(y))-1))?(1<<(y))-((x)&((1<<(y))-1)):0))
#define MAX_BIT         ((int) (sizeof(ssize_t)<<3))

/* histogram update macro */
#define GDKmallidx(idx,size)				\
	{						\
		int _mask;				\
		if (size < 128) {			\
			_mask = (1<<6);			\
			idx = 7;			\
		} else {				\
			_mask = (1<<(MAX_BIT-1));	\
			idx = MAX_BIT;			\
		}					\
		while(idx-- > 4) {			\
			if (_mask&size) break;		\
			_mask >>=1;			\
		}					\
	}

volatile size_t GDK_mallocedbytes_estimate = 0;
static ssize_t GDK_mem_cursize = 0;
static ssize_t GDK_vm_cursize = 0;

#ifdef GDK_MEM_TRACE
static int mtrace = 0;
#endif

size_t
GDKvm_heapsize(void)
{
#ifdef _CYGNUS_H_
	return ((size_t) (96 << 20));
#else
	size_t ret = GDKmem_heapsize();

#ifdef __linux__
	/* on linux, malloc may also use mmapped space, so the bytes-in-malloc may be much bigger than the sbrk() region */
	ret = MAX(GDK_mallocedbytes_estimate, ret);
#endif
	return ret;
#endif
}

size_t
GDKmem_heapsize(void)
{
	size_t heapsize = (MT_heapcur() - MT_heapbase);

	return (size_t) SEG_SIZE(heapsize, MT_VMUNITLOG);
}

size_t
GDKmem_inuse()
{
	/* RAM/swapmem that Monet is really using now */
	ssize_t mem_cursize = GDK_mem_cursize;
	size_t mem_mallocedbytes_estimate = GDK_mallocedbytes_estimate;

	if (mem_cursize < 0)
		mem_cursize = GDK_mem_cursize = 0;

	return mem_cursize + mem_mallocedbytes_estimate;
}

size_t
GDKmem_cursize()
{
	/* RAM/swapmem that Monet has claimed from OS */
	ssize_t mem_cursize = GDK_mem_cursize;

	if (mem_cursize < 0)
		mem_cursize = GDK_mem_cursize = 0;

	return mem_cursize + GDKmem_heapsize();
}

size_t
GDKvm_cursize()
{
	/* current Monet VM address space usage */
	ssize_t vm_cursize = GDK_vm_cursize;

	if (vm_cursize < 0)
		vm_cursize = GDK_vm_cursize = 0;

	return vm_cursize + GDKvm_heapsize();
}

#ifdef GDK_VM_KEEPHISTO
volatile ssize_t GDK_vm_nallocs[MAX_BIT] = { 0 };
#endif
#ifdef GDK_MEM_KEEPHISTO
volatile ssize_t GDK_nmallocs[MAX_BIT] = { 0 };
#endif

size_t
GDKmem_heapinuse(void)
{
	return GDK_mallocedbytes_estimate;
}

volatile int GDK_heapcheck_last = 0;

INLINE void
GDKmem_heapcheck(int t)
{
	/* correct heap estimate with the real thing */
	struct mallinfo m = MT_mallinfo();

	GDK_mallocedbytes_estimate = (size_t) (m.usmblks + m.uordblks + m.hblkhd);
	GDK_heapcheck_last = t;
}

@- heapinc(size_t _memdelta, void* _blk)
@= heapinc
	{
		size_t _memdelta = (size_t) @1;
#ifdef GDK_MEM_TRACE
		void*  _blk = (void*) @2;

		if (mtrace) {
			int _idx = add_stack(stackBat);
			add_mem(memBat,_blk,_idx);
		}
#endif
		GDK_mallocedbytes_estimate += _memdelta;
#ifdef GDK_MEM_KEEPHISTO
		{
			int _idx;
			GDKmallidx(_idx, _memdelta);
			GDK_nmallocs[_idx]++;
		}
#endif
	}

@- heapdec(size_t memdelta, void* _blk)
@= heapdec
	{
		size_t _memdelta = (size_t) @1;
#ifdef GDK_MEM_TRACE
		void*  _blk = (void*) @2;

		if (mtrace) {
			del_mem(memBat,_blk);
		}
#endif
		if (_memdelta > GDK_mallocedbytes_estimate) {
			/* clearly, the stats are off: it should never become less-than-zero */
			GDKmem_heapcheck(GDKms());
		} else {
			GDK_mallocedbytes_estimate -= _memdelta;
		}
#ifdef GDK_MEM_KEEPHISTO
		{
			int _idx;
			GDKmallidx(_idx, _memdelta);
			GDK_nmallocs[_idx]--;
		}
#endif
	}

@- meminc(size_t memdelta, size_t vmdelta)
@= meminc
	{
		size_t _memdelta = (size_t) @1;
		size_t _vmdelta = (size_t) SEG_SIZE(@2,MT_VMUNITLOG);

		gdk_set_lock(GDKthreadLock, "GDKmeminc");
		GDK_mem_cursize += _memdelta;
#ifdef GDK_VM_KEEPHISTO
		{
			int _idx;
			GDKmallidx(_idx, _vmdelta);
			GDK_vm_nallocs[_idx]++;
		}
#endif
		GDK_vm_cursize += _vmdelta;
		gdk_unset_lock(GDKthreadLock, "GDKmeminc");
	}

@- memdec(size_t memdelta, size_t vmdelta)
@= memdec
	{
		size_t _memdelta = (size_t) @1;
		size_t _vmdelta = (size_t) SEG_SIZE(@2,MT_VMUNITLOG);

		gdk_set_lock(GDKthreadLock, "GDKmemdec");
		GDK_mem_cursize -= _memdelta;
#ifdef GDK_VM_KEEPHISTO
		{
			int _idx;
			GDKmallidx(_idx, _vmdelta);
			GDK_vm_nallocs[_idx]--;
		}
#endif
		GDK_vm_cursize -= _vmdelta;
		gdk_unset_lock(GDKthreadLock, "GDKmemdec");
	}
@c
void
GDKmemdump(void)
{
	struct mallinfo m = MT_mallinfo();

	THRprintf(GDKerr, "\n!mallinfo.arena = " SSZFMT "\n", (ssize_t) m.arena);
	THRprintf(GDKerr, "!mallinfo.ordblks = " SSZFMT "\n", (ssize_t) m.ordblks);
	THRprintf(GDKerr, "!mallinfo.smblks = " SSZFMT "\n", (ssize_t) m.smblks);
	THRprintf(GDKerr, "!mallinfo.hblkhd = " SSZFMT "\n", (ssize_t) m.hblkhd);
	THRprintf(GDKerr, "!mallinfo.hblks = " SSZFMT "\n", (ssize_t) m.hblks);
	THRprintf(GDKerr, "!mallinfo.usmblks = " SSZFMT "\n", (ssize_t) m.usmblks);
	THRprintf(GDKerr, "!mallinfo.fsmblks = " SSZFMT "\n", (ssize_t) m.fsmblks);
	THRprintf(GDKerr, "!mallinfo.uordblks = " SSZFMT "\n", (ssize_t) m.uordblks);
	THRprintf(GDKerr, "!mallinfo.fordblks = " SSZFMT "\n", (ssize_t) m.fordblks);
#ifdef GDK_MEM_KEEPHISTO
	{
		int i;

		THRprintf(GDKerr, "!memory histogram\n");
		for (i = 3; i < GDK_HISTO_MAX_BIT - 1; i++) {
			size_t j = 1 << i;

			THRprintf(GDKerr, "! " SZFMT " " SZFMT "\n", j, GDK_nmallocs[i]);
		}
	}
#endif
#ifdef GDK_VM_KEEPHISTO
	{
		int i;

		THRprintf(GDKerr, "\n!virtual memory histogram\n");
		for (i = 12; i < GDK_HISTO_MAX_BIT - 1; i++) {
			size_t j = 1 << i;

			THRprintf(GDKerr, "! " SZFMT " " SZFMT "\n", j, GDK_vm_nallocs[i]);
		}
	}
#endif
}


void
GDKmemchk(int memchk, int vmchk)
{
	size_t memtarget = GDKmem_inuse();
	size_t vmtarget = GDKvm_cursize();

	MEMDEBUG {
		/* Protect from being called recursivly because THRprintf
		   allocates memory */
		static int printing[THREADS];
		int tid = THRgettid();

		if (!printing[tid - 1]) {
			printing[tid - 1] = TRUE;
			THRprintf(GDKerr, "GDKmemchk (memcur=" SZFMT ",memmax=" SZFMT ") (vmcur=" SZFMT ",vmmax=" SZFMT ")\n", memtarget, GDK_mem_maxsize, GDKvm_cursize(), GDK_vm_maxsize);
			printing[tid - 1] = FALSE;
		}
	}
	memtarget = (memchk && memtarget > GDK_mem_maxsize) ? memtarget - GDK_mem_maxsize : 0;
	vmtarget = (vmchk && vmtarget > GDK_vm_maxsize) ? vmtarget - GDK_vm_maxsize : 0;
	if (memtarget > 0 || vmtarget > 0) {
		if (memtarget > 0) {
			int t = GDKms();

			/* check max every 10 secs, and only if its incorrectness bothers us (i.e. causes BBPtrim) */
			if ((t - GDK_heapcheck_last) > 10000) {
				GDKmem_heapcheck(t);	/* correct thread-unsafe estimate */
			}
		}
		BBPtrim(memtarget, vmtarget);
		GDK_mem_allocs = GDK_vm_allocs = 0;
	} else {
		if (memchk)
			GDK_mem_allocs = 0;
		if (vmchk)
			GDK_vm_allocs = 0;
	}
}

@}

@+ Stack tracing

Very simple malloc tracing implementation that allows to retain on which stack frame
a malloc was done. This is code originally developed by DD, and
is used only  by them.
Two bats are used: stackBat and memBat.
StackBat contains a DAG of all methods used for memory allocation.
MemBat contains a mapping from allocated memory addresses to an index
in the stackBat which indicates the place the memory is allocated.
@{
@c
#ifdef GDK_MEM_TRACE

static BAT *stackBat = NULL;
static BAT *memBat = NULL;
typedef ptr mem_t;

char *
stack_test(int i, int j)
{
	if (--i == 0)
		return (char *) GDKmalloc(j);

	return stack_test(i, j);
}


void
mtrace_test()
{
	char *t = stack_test(1, 1);

	GDKfree(t);
	GDKfree(t);		/* double delete */
	t = stack_test(2, 2);
	t = GDKrealloc(t, 20);	/* leaked */
}


int
GDKmtrace(bit *enable)
{
	if (*enable) {
		if (memBat == NULL) {
			memBat = BATnew(TYPE_ptr, TYPE_int, 16384);
			if (memBat == NULL)
				return GDK_FAIL;
			stackBat = BATnew(TYPE_ptr, TYPE_ptr, 16384);
			if (stackBat == NULL)
				return GDK_FAIL;
			BBPrename(memBat->batCacheid, "mem_trace");
			BBPrename(stackBat->batCacheid, "mem_stack");
			memBat->hsorted = memBat->tsorted = 0;
			BATkey(memBat, TRUE);
			stackBat->hsorted = stackBat->tsorted = 0;
			BATset(stackBat, TRUE);
		}
		mtrace++;
	} else if (mtrace > 0)
		mtrace--;

	memBat->batDirty = TRUE;
	stackBat->batDirty = TRUE;

	if (*enable == bit_nil) {
		printf("testing mtrace:\n");
		mtrace_test();
		--mtrace;
	}

	return GDK_SUCCEED;
}


BUN
add_dag(BAT *b, BUN p, mem_t current, mem_t parent)
{
	const static int bunsize = sizeof(mem_t) + sizeof(mem_t);
	BUN last = BUNlast(b);

	while (p != last) {
		if ((*(mem_t *) BUNhloc(b, p)) == current && (*(mem_t *) BUNtloc(b, p)) == parent)
			return p;
		p += bunsize;
	}

	if (b->batBuns->free + bunsize > b->batBuns->size) {
		int tmp = mtrace;

		mtrace = 0;
		if (BATextend(b, BATgrows(b)) == NULL)
			return BUNlast(b);
		mtrace = tmp;
		last = BUNlast(b);
	}
	bunfastins_nocheck(b, last, &current, &parent, bunsize);
	return last;
}


#define MAX_STACK_ADDR 16
#define STACK_LIST(STACK_ENTRY)						\
	STACK_ENTRY(1) STACK_ENTRY(2) STACK_ENTRY(3)			\
	STACK_ENTRY(4) STACK_ENTRY(5) STACK_ENTRY(6) STACK_ENTRY(7)	\
	STACK_ENTRY(8) STACK_ENTRY(9) STACK_ENTRY(10) STACK_ENTRY(11)	\
	STACK_ENTRY(12) STACK_ENTRY(13) STACK_ENTRY(14) STACK_ENTRY(15)

#define STACK_READ(X)						\
	if (continue_stack_trace &&				\
	    ((mem_t)__builtin_frame_address((X)) != 0L) &&	\
	    ((X) < MAX_STACK_ADDR)) {				\
		parent = current;				\
		current = (mem_t)__builtin_return_address((X)); \
		if(parent)					\
			p = add_dag(b, p, current, parent);	\
	} else if (continue_stack_trace) {			\
		continue_stack_trace = FALSE;			\
	}

int
add_stack(BAT *b)
{
	mem_t current = 0, parent = 0;
	bit continue_stack_trace = TRUE;
	BUN p = BUNfirst(b);

	STACK_LIST(STACK_READ);
	return BUNindex(b, p);
}

#define __USE_GNU 1
#include <dlfcn.h>
void
print_address(ptr address)
{
	Dl_info dlip;
	char *filename;

	dladdr(address, &dlip);

	filename = 0;		/* strrchr(dlip.dli_fname,'/'); */
	printf(PTRFMT "\t%s\t%s\n", PTRFMTCAST address, dlip.dli_sname, filename ? filename + 1 : dlip.dli_fname);
}

int
GDKmprint(int *pidx)
{
	int idx = *pidx;
	BUN p = BUNptr(stackBat, idx), first = BUNfirst(stackBat);
	const static int bunsize = sizeof(mem_t) + sizeof(mem_t);
	mem_t *a;

	if (p == NULL)
		printf("No stack for index %d\n", idx);

	a = (mem_t *) BUNhloc(stackBat, p);
	print_address(*a);
	a = (mem_t *) BUNtloc(stackBat, p);
	print_address(*a);

	while (p > first) {
		p -= bunsize;
		if (*(mem_t *) BUNhloc(stackBat, p) == *a) {
			a = (mem_t *) BUNtloc(stackBat, p);
			print_address(*a);
		}
	}

	return GDK_SUCCEED;
}


void
add_mem(BAT *b, mem_t mem, int idx)
{
	REGISTER BUN last;
	const static int bunsize = sizeof(mem_t) + sizeof(int);

	if (b->batBuns->free + bunsize > b->batBuns->size) {
		int tmp = mtrace;

		mtrace = 0;
		if (BATextend(b, BATgrows(b)))
			return;
		mtrace = tmp;
	}
	last = BUNlast(b);
	bunfastins_nocheck(b, last, &mem, &idx, bunsize);
}


void
del_mem(BAT *b, mem_t mem)
{
	REGISTER BUN first = BUNfirst(b), p = BUNlast(b);
	const static int bunsize = sizeof(mem_t) + sizeof(int);

	for (p -= bunsize; p >= first; p -= bunsize) {
		if (*(mem_t *) BUNhloc(b, p) == mem) {
			int idx = -*(int *) BUNtloc(b, p);

			if (idx > 0) {
				printf("Double deletion of memory " PTRFMT ", " "size: " SSZFMT ", stack:%d\n", PTRFMTCAST(void *)mem, ((ssize_t *) mem)[-1], idx);

				if (mtrace > 1)
					GDKmprint(&idx);
			} else {
				BUNdelete(b, p);
				/* BUNinplace(b,p,&mem,&idx); */
			}
			return;
		}
	}
	printf("Free of unknown memory " PTRFMT ", size: " SSZFMT "\n", PTRFMTCAST(void *) mem, ((ssize_t *) mem)[-1]);
}
#else
int
GDKmtrace(bit *enable)
{
	(void) enable;
	return GDK_SUCCEED;
}

int
GDKmprint(int *pidx)
{
	(void) pidx;
	return GDK_SUCCEED;
}
#endif
@}

@+ Malloc
Malloc normally maps through directly to the OS provided malloc/free/realloc
calls. Where possible, we want to use the -lmalloc library on Unix systems,
because it allows to influence the memory allocation strategy. This can prevent
fragmentation and greatly help enhance performance.

The "added-value" of the GDKmalloc/GDKfree/GDKrealloc over the standard OS
primitives is that the GDK versions try to do recovery from failure to malloc by
initiating a BBPtrim. Also, big requests are redirected to anonymous virtual
memory. Finally, additional information on block sizes is kept (helping efficient
reallocations) as well as some debugging that guards against duplicate frees.

A number of different strategies are available using different switches, however:
@table @samp

@item zero sized blocks
Normally, GDK gives fatal errors on illegal block sizes.
This can be overridden with  GDK_MEM_NULLALLOWED.

@item resource tracking
Many malloc interfaces lack a routine that tells the size of a block
by the pointer. We need this information for correct malloc statistics.

@item outstanding block histograms
In order to solve the problem, we allocate extra memory in front of the
returned block. With the resource tracking in place, we keep a total of
allocated bytes.  Also, if GDK_MEM_KEEPHISTO is defined, we keep a histogram
of the outstanding blocks on the log2 of the block size (similarly for virtual.
memory blocks; define GDK_VM_KEEPHISTO).

@item ensuring 8-byte alignment
While doing the resource tracking, we can in one go solve the problem
of 32-bit systems that return non-8 bytes aligned pointers. This is
encoded by storing a size + 1 (we always normalize sizes to multiples of
8, so this is easily recognized). This check only done if
GDK_MEM_MISALIGN is @strong{not} enabled.

@item redirection to anonymous VM
Sometimes, fragmentation problems arise on mallocs that are not tunable.
In that case, it makes sense to redirect large block requests (taken to be
larger than GDK_mem_bigsize) to anonymous virtual memory. The seamless
implementation of this stores the @strong{negative} block size in front of the
pointer (as well as the VM maxsize), so the malloc primitives can recognize
these redirected blocks.This behavior is enabled by defining GDK_MEM_VMREDIRECT.
@end table
@{
@c
void
GDKmemfail(str s, size_t len, size_t memtarget, size_t vmtarget)
{
	int bak = GDKdebug;

	/* bumped your nose against the wall; try to prevent repetition by adjusting maxsizes */
	if (memtarget < 0.3 * GDKmem_inuse()) {
		size_t newmax = (size_t) (0.7 * (double) GDKmem_inuse());

		if (newmax < GDK_mem_maxsize)
			GDK_mem_maxsize = newmax;
	}
	if (vmtarget < 0.3 * GDKvm_cursize()) {
		size_t newmax = (size_t) (0.7 * (double) GDKvm_cursize());

		if (newmax < GDK_vm_maxsize)
			GDK_vm_maxsize = newmax;
	}

	if (GDKthreadLock)
		gdk_set_lock(GDKthreadLock, "GDKmemfail");
	THRprintf(GDKerr, "%s(" SZFMT ") fail => BBPtrim(enter) usage[mem=" SZFMT ",vm=" SZFMT "]\n", s, len, GDKmem_inuse(), GDKvm_cursize());
	GDKmemdump();
	GDKdebug |= 4;
	if (GDKthreadLock)
		gdk_unset_lock(GDKthreadLock, "GDKmemfail");

	BBPtrim(memtarget, vmtarget);

	if (GDKthreadLock)
		gdk_set_lock(GDKthreadLock, "GDKmemfail");
	GDKdebug = MIN(GDKdebug, bak);
	THRprintf(GDKerr, "%s(" SZFMT ") fail => BBPtrim(ready) usage[mem=" SZFMT ",vm=" SZFMT "]\n", s, len, GDKmem_inuse(), GDKvm_cursize());
	GDKmemdump();
	if (GDKthreadLock)
		gdk_unset_lock(GDKthreadLock, "GDKmemfail");
}

/* the blocksize is stored in the ssize_t before it. Negative size <=> VM memory */
#define GDK_MEM_BLKSIZE(p) ((ssize_t*) (p))[-1]

#ifndef GDK_MEM_MISALIGN

/* allocate 8 bytes extra (so it stays 8-bytes aligned) and put realsize in front */
#define GDKmalloc_prefixsize(s,size) {					\
	s = (ssize_t *) malloc(size + 8);				\
	if (s != NULL) {						\
		assert((((size_t) s)&7) == 0); /* no MISALIGN */	\
		s = (ssize_t*) ((char*) s + 8);				\
		s[-1] = (ssize_t) (size + 8);				\
	}								\
}

#else
/* work around old stupid libc mallocs that give 4-byte aligned pointers */
#define GDKmalloc_prefixsize(s,size) {					\
	s = (ssize_t *) malloc(size+8);					\
	if (((size_t) s) & 4) { /* misaligned */			\
		assert(sizeof(size_t) == 4); /* not on 64-bits */	\
		s = (ssize_t*) ((char*) s + 4);				\
		s[-1] = (ssize_t) (size + 9);  /* 1-bit is a marker */	\
	} else if (s != NULL) {						\
		s = (ssize_t*) ((char*) s + 8);				\
		s[-1] = (ssize_t) (size + 8);				\
	}								\
}
#endif


void *
GDKmallocmax(size_t size, size_t * maxsize, int emergency)
{
	ssize_t *s;

	if (size == 0) {
#ifdef GDK_MEM_NULLALLOWED
		return NULL;
#else
		GDKfatal("GDKmallocmax: called with size " SZFMT "", size);
#endif
	}
	size = (size + 3) & ~3;	/* round up to a multiple of four */
	if (size > GDK_mem_bigsize) {
		size_t newsize = size + sizeof(size_t) + sizeof(size_t);
		size_t newmax = MAX(*maxsize, newsize);

		s = (ssize_t *) GDKvmalloc(newsize, &newmax, emergency);
		if (s == 0 && emergency == 0)
			return s;
		MT_alloc_register(s, *maxsize, 'S');
		s += 2;
		s[-2] = (ssize_t) newmax;
		s[-1] = -((ssize_t) size);
		*maxsize = newmax - (sizeof(size_t) + sizeof(size_t));
		return (void *) s;
	}
	CHKMEM(size, 0);
	GDKmalloc_prefixsize(s, size);
	if (s == NULL) {
		GDKmemfail("GDKmalloc", size, BBPTRIM_ALL, 0);
		GDKmalloc_prefixsize(s, size);
		if (s == NULL) {
			if (emergency)
				return NULL;
			MT_alloc_print();
			GDKfatal("GDKmallocmax: failed for %u bytes", size);
		} else {
			THRprintf(GDKerr, "GDKmallocmax: recovery ok. Continuing..\n");
		}
	}
	*maxsize = size;
	@:heapinc(size+8,s)@
	return (void *) s;
}

void *
GDKmalloc(size_t size)
{
	return GDKmallocmax(size, &size, 1);
}

void *
GDKzalloc(size_t size)
{
	void *p = GDKmallocmax(size, &size, 1);
	if (p)
		memset(p,0,size);
	return p;
}

void
GDKfree(void *blk)
{
	ssize_t size, *s = (ssize_t *) blk;

	if (s == NULL)
		return;

	size = GDK_MEM_BLKSIZE(s);

	/* check against duplicate free */
	assert((size & 2) == 0);
	s[-1] |= 2;

	if (size < 0) {
		size_t maxsize = (size_t) s[-2];

		size = -size;
		MT_alloc_register((char *) (s - 2), maxsize, 's');
		GDKvmfree((char *) (s - 2), (size_t) size, maxsize);
	} else {
#ifdef GDK_MEM_MISALIGN
		if (size & 1)
			free(((char *) s) - 4);
		else
#endif
			free(((char *) s) - 8);
		@:heapdec(size,s)@
	}
}

ptr
GDKreallocmax(void *blk, size_t size, size_t * maxsize, int emergency)
{
	ssize_t oldsize, *s = (ssize_t *) blk;

	if (s == NULL) {
		return GDKmallocmax(size, maxsize, emergency);
	}
#ifdef GDK_MEM_NULLALLOWED
	if (size == 0) {
		GDKfree(blk);
		*maxsize = 0;
		return NULL;
	}
#endif
	if (size <= 0) {
		GDKfatal("GDKreallocmax: called with size %u", size);
	}
	/* round up to a multiple of four */
	size = (size + 3) & ~3;
	oldsize = GDK_MEM_BLKSIZE(s);

	/* check against duplicate free */
	assert((oldsize & 2) == 0);

	if (oldsize < 0) {
		size_t newsize = size + sizeof(size_t) + sizeof(size_t);
		size_t oldmax = (size_t) s[-2];
		size_t newmax = MAX(*maxsize, newsize);

		s = (ssize_t *) GDKvmrealloc((ptr) (s - 2), (size_t) - oldsize, newsize, oldmax, &newmax, emergency);
		if (s == NULL && !emergency)
			return NULL;
		s[0] = newmax;
		s[1] = -((ssize_t) size);
		*maxsize = newmax - (sizeof(size_t) + sizeof(size_t));
		return (ptr) (s + 2);
	}
#ifndef GDK_MEM_MISALIGN
	if (size <= GDK_mem_bigsize) {
		size_t newsize = size + 8;

		blk = realloc(((char *) blk) - 8, newsize);
		if (blk != NULL) {
			/* place 8 bytes before it */
			assert((((size_t) blk) & 4) == 0);
			blk = ((char *) blk) + 8;
			((ssize_t *) blk)[-1] = (ssize_t) newsize;

			/* adapt statistics */
			@:heapinc(newsize,blk)@
			@:heapdec(oldsize,s)@
			*maxsize = size;
			return blk;
		}
	}
	/* alloc&copy due too failed realloc (may be very big heap that needs vm) */
#else
	/* alloc&copy because we cannot trust realloc due to misalignment */
	if (oldsize & 1)
		oldsize = MIN(size, (size_t) oldsize - 5);
	else
#endif
		oldsize = MIN(size, (size_t) (oldsize - 8));
	blk = (void *) GDKmallocmax(size, maxsize, emergency);
	if (blk) {
		memcpy(blk, s, oldsize);
		GDKfree(s);
	}
	return (void *) blk;
}

ptr
GDKrealloc(void *blk, size_t size)
{
	return GDKreallocmax(blk, size, &size, 1);
}

void *
GDKcalloc(size_t nmemb, size_t size)
{
	if (nmemb && size) {
		size_t n = nmemb * size;	/* wdk XXX: overflow? */
		void *res = GDKmalloc(n);

		if (res) {
			return memset(res, 0, n);
		}
	}
	return 0;
}


char *
GDKstrdup(const char *s)
{
	int l = strLen(s);
	char *n = (char *) GDKmalloc(l);

	memcpy(n, s, l);
	return n;
}


@- virtual memory
allocations affect only the logical VM resources.
@c
void *
GDKmmap(char *path, int mode, off_t off, size_t len, void *fixed)
{
	void *ret = MT_mmap(path, mode, off, len, fixed);

	if (ret == (void *) -1L && fixed == NULL) {
		GDKmemfail("GDKmmap", len, 0, BBPTRIM_ALL);
		ret = MT_mmap(path, mode, off, len, fixed);
		if (ret != (void *) -1L) {
			THRprintf(GDKerr, "GDKmmap: recovery ok. Continuing..\n");
		}
	}
	if (ret != (void *) -1L) {
		MT_alloc_register(ret, len, 'M');
		@:meminc(0,len)@
		CHKMEM(0, len);
	}
	return (void *) ret;
}

int
GDKmunmap(void *addr, size_t size)
{
	int ret;

	MT_alloc_register(addr, size, 'm');
	ret = MT_munmap(addr, size);
	if (ret == 0) {
		@:memdec(0,size)@
	}
	return ret;
}


@- VM alloc
this affects both physical and logical memory resources.
The emergency flag can be set to force a fatal error if needed.
Otherwise, the caller is able to deal with the lack of memory.
@c
void *
GDKvmalloc(size_t size, size_t * maxsize, int emergency)
{
	void *ret = MT_vmalloc(size, maxsize);

	if (ret == NULL) {
		GDKmemfail("GDKvmalloc", size, BBPTRIM_ALL, BBPTRIM_ALL);
		ret = MT_vmalloc(size, maxsize);
		if (ret == NULL) {
			if (emergency == 0)
				return NULL;
			MT_alloc_print();
			GDKfatal("GDKvmalloc: failed for %u bytes", size);
		} else {
			THRprintf(GDKerr, "GDKvmalloc(" SZFMT "): recovery ok. Continuing..\n", size);
		}
	}
	if (ret != NULL) {
		@:meminc(size,*maxsize)@
		CHKMEM(size, *maxsize);
	}
	return ret;
}

void *
GDKvmrealloc(void *pold, size_t oldsize, size_t newsize, size_t oldmax, size_t * newmax, int emergency)
{
	void *ret = MT_vmrealloc(pold, oldsize, newsize, oldmax, newmax);

	if (ret == NULL) {
		GDKmemfail("GDKvrealloc", newsize, BBPTRIM_ALL, BBPTRIM_ALL);
		ret = MT_vmrealloc(pold, oldsize, newsize, oldmax, newmax);
		if (ret == NULL) {
			if (emergency == 0)
				return NULL;
			MT_alloc_print();
			GDKfatal("GDKvrealloc: failed for %u bytes (from %u)", newsize, oldsize);
		} else {
			THRprintf(GDKerr, "GDKvmrealloc(" SZFMT "): recovery ok. Continuing..\n", newsize);
		}
	}
	if (ret != NULL) {
		@:memdec(oldsize,oldmax)@
		@:meminc(newsize,*newmax)@
		CHKMEM(newsize, *newmax);
	}
	return ret;
}

void
GDKvmfree(void *blk, size_t size, size_t maxsize)
{
	MT_vmfree(blk, maxsize);
	@:memdec(size,maxsize)@
}

@}

@+ Session Initialization
The parameter @emph{db} is followed by the database name relative to
the environment variable dbfarm.
The parameter @emph{monetrc} tells that the system variables setting
should be overruled by the specification given in the file argument.
This format is only necessary to temporarily experiment with variable settings,
without disturbing a system/site default setting.

The interface code to the operating system is highly dependent on
the processing environment. It can be filtered away with compile-time flags.
Suicide is necessary due to some system implementation errors.

The kernel requires file descriptors for I/O with the user.
They are thread specific and should be obtained by a function.

The arguments relevant for the kernel are extracted from the list.
Their value is turned into a blanc space.
@{
@h
gdk_export int GDKrecovery;

@c
int GDKtime_startsec, GDKrecovery = 0;

@h
gdk_export int GDKinit(char *dbname, char *dbfarm, int alloc_map);

@c
void
GDKprotect()
{
	int i;

	if (GDKthreadLock == 0) {
		TMDEBUG printf("# GDKlocks created\n");

		GDKthreadLock = MT_create_lock();
		for (i = 0; i <= BBPLOCKMASK; i++) {
			GDKswapLock[i] = MT_create_lock();
			GDKhashLock[i] = MT_create_lock();
		}
		GDKcacheLock = MT_create_lock();
		GDKunloadLock = MT_create_lock();
		GDKunloadCond = MT_create_cond();
		GDKtrimLock = MT_create_lock();
		GDKtmLock = MT_create_lock();
		GDKprotected = 1;
	}
}

#ifndef WIN32
void
GDKvmtrim(void *limit)
{
	int wait = 1;

	do {
		stream *fp = NULL;

		if (wait) MT_sleep_ms(5000);
		MEMDEBUG {
			fp = GDKerr;
			THRprintf(fp, "GDKvmtrim(" LLFMT ")\n", (long long) *(size_t *) limit);
		}
		wait = !MT_mmap_trim(*(size_t *) limit, fp);
	} while (!GDKstopped);
}
#endif

int
GDKinit(char *dbname, char *dbfarm, int alloc_map)
{
	gdk_alloc_map = alloc_map;
	errno = 0;
	if (!GDKenvironment(dbname, dbfarm))
		return 0;

	stream_init();
	MT_init_posix(alloc_map);
	THRinit();
#ifndef NATIVE_WIN32
	BATSIGinit();
#endif
	GDKlockHome();

	/* init time */
#ifdef HAVE_GETTIMEOFDAY
	{
		struct timeval tp;

		gettimeofday(&tp, NULL);
		GDKtime_startsec = tp.tv_sec;
	}
#else
#ifdef HAVE_FTIME
	{
		struct timeb tb;

		ftime(&tb);
		GDKtime_startsec = tb.time;
	}
#endif
#endif

	if (GDKembedded)
		GDKprotected = 0;

	/* Mserver intends to rob 95% of all memory as a default */
	GDK_mem_maxsize = (size_t) ((double) MT_npages() * (double) MT_pagesize() * 0.815);

	GDKmemchk(TRUE, TRUE);
	GDKremovedir(DELDIR);
	BBPinit();
	GDKenv = BATnew(TYPE_str, TYPE_str, 100);
	if (GDKenv == NULL)
		GDKfatal("GDKinit: Could not create environment BAT");
	BATrename(GDKenv, "monet_environment");
	BATmode(GDKenv, TRANSIENT);
#ifndef WIN32
	if (!GDKembedded) {
		MT_Id t;

		MT_create_thread(&t, GDKvmtrim, &GDK_mem_maxsize);
	}
#endif
	return 1;
}

@-
Upon closing the session, all persistent BATs should be saved and
the transient BATs should be removed.
The buffer pool manager takes care of this.
@h
gdk_export int GDKstopped;

@c
int GDKstopped = 1;

@h
gdk_export void GDKexit(int status);

@c
void
GDKexit(int status)
{
	if (GDKthreadLock)
		gdk_set_lock(GDKthreadLock, "GDKexit");
	if (GDKstopped == 0) {
		GDKstopped++;	/* shouldn't there be a lock here? */
		GDKnrofthreads = 0;
		if (GDKthreadLock)
			gdk_unset_lock(GDKthreadLock, "GDKexit");

		/* Kill all threads except myself */
		if (status == 0) {
			MT_Id pid = MT_getpid();
			Thread t, s;

			for (t = GDKthreads, s = t + THREADS; t < s; t++) {
				if (t->pid) {
					MT_Id victim = t->pid;

					if (t->pid != pid)
						MT_kill_thread(victim);
				}
			}
		}
		(void) GDKgetHome();
		BBPexit();
		GDKlog(GDKLOGOFF);
		GDKunlockHome();
		MT_global_exit(status);
	}
	if (GDKthreadLock)
		gdk_unset_lock(GDKthreadLock, "GDKexit");
}

@
All semaphores used by the application should be mentioned here.
They are initialized during system initialization.
@c
int GDKdebug = 0;
int GDKembedded = 0;
int GDKprotected = 0;

MT_Lock GDKthreadLock = NULL;
MT_Lock GDKswapLock[BBPLOCKMASK + 1];
MT_Lock GDKhashLock[BBPLOCKMASK + 1];
MT_Lock GDKcacheLock, GDKtrimLock;
MT_Lock GDKunloadLock;
MT_Lock GDKtmLock;
MT_Cond GDKunloadCond;

@}

@+ Concurrency control
Concurrency control requires actions at several levels of the system.
First, it should be ensured that each database  is controlled by a single
server process (group). Subsequent attempts should be stopped.
This is regulated through file locking against ".gdk_lock".
Furthermore, the server process is moved to the database directory
for improved speed.
@-
Before the locks and threads are initiated, we cannot use the
normal routines yet. So we have a local fatal here instead of GDKfatal.
@{
@c
void
GDKlockHome(void)
{
	char *p = 0, buf[1024], host[PATHLENGTH];
	char GDKdirStr[PATHLENGTH];

@-
Go there and obtain the global database lock.
@c
	/* The DIR_SEP at the end of the path is needed for a succesfull
	   call to GDKcreatedir */

	snprintf(GDKdirStr, PATHLENGTH, "%s%c%s%c", GDKdbfarmStr, DIR_SEP, GDKdbnameStr, DIR_SEP);

	if (chdir(GDKdirStr) < 0) {
		if (!GDKcreatedir(GDKdirStr) || chdir(GDKdirStr) < 0)
			GDKfatal("GDKlockHome: could not move to %s\n", GDKdirStr);
		GDKwarning("GDKlockHome: created directory %s\n", GDKdirStr);
	}
	if (GDKrecovery && unlink(GDKLOCK) < 0) {
		GDKfatal("GDKlockHome: unlock DB failed\n");
	}
	umask(0000);
	if (MT_lockf(GDKLOCK, F_TLOCK, 4, 1) < 0) {
		GDKlockFile = 0;
		GDKfatal("GDKlockHome: Database lock '%s' denied\n", GDKLOCK);
	}
	if ((GDKlockFile = fopen(GDKLOCK, "rb+")) == NULL) {
		GDKfatal("GDKlockHome: Could not open %s\n", GDKLOCK);
	}
	if (fgets(buf, 1024, GDKlockFile) && (p = strchr(buf, ':')))
		*p = 0;
	if (p) {
		sprintf(host, " from '%s'", buf);
	} else {
		GDKwarning("GDKlockHome: ignoring empty or invalid %s.\n", GDKLOCK);
		host[0] = 0;
	}
@-
We have the lock, are the only process currently allowed in this section.
@c
	MT_init();
	OIDinit();
@-
Print the new process list in the global lock file.
@c
	fseek(GDKlockFile, 0, SEEK_SET);
	ftruncate(fileno(GDKlockFile), 0);
	fflush(GDKlockFile);
	GDKlog(GDKLOGON);
@-
In shared mode, we allow more parties to join. Release the lock.
@c
	GDKstopped = 0;
}

void
GDKunlockHome(void)
{
	if (GDKlockFile) {
		MT_lockf(GDKLOCK, F_ULOCK, 4, 1);
		fclose(GDKlockFile);
		GDKlockFile = 0;
	}
}

@-
Really really get the lock. Now!!
@c
int
GDKgetHome(void)
{
	if (GDKlockFile)
		return 0;
	if (MT_system_lock == NULL)
		return 0;
	while ((GDKlockFile = fopen(GDKLOCK, "r+")) == NULL) {
		GDKerror("GDKgetHome: PANIC on open %s. sleep(1)\n", GDKLOCK);
		MT_sleep_ms(1000);
	}
	if (MT_lockf(GDKLOCK, F_TLOCK, 4, 1) < 0) {
		GDKwarning("GDKgetHome: blocking on lock '%s'.\n", GDKLOCK);
		MT_lockf(GDKLOCK, F_LOCK, 4, 1);
	}
	return 1;
}

@}

@+ Error handling
Errors come in three flavors: warnings, non-fatal and fatal errors.
A fatal error leaves a core dump behind after trying to
safe the content of the relation.
A non-fatal error returns a message to the user
and aborts the current transaction.
Fatal errors are also recorded on the system log for post-mortem
analysis.
In non-silent mode the errors are immediately sent to output,
which makes it hard for upper layers to detect if an error
was produced in the process. To facilitate such testing,
a global error count is maintained on a thread basis,
which can be read out by the function GDKerrorCount();
@{
@c
int GDKsilent = 0;
static int THRerrorcount[THREADDATA];

/* do the real work for GDKaddbuf below. */
static void
doGDKaddbuf(const char *prefix, const char *message, size_t messagelen, const char *suffix)
{
	char *buf = GDKerrbuf;

	THRerrorcount[THRgettid()]++;
	if (buf) {
		char *dst = buf + strlen(buf);
		size_t maxlen = GDKMAXERRLEN - (dst - buf) - 1;

		if (prefix && *prefix && dst < buf + GDKMAXERRLEN) {
			size_t preflen;

			strncpy(dst, prefix, maxlen);
			dst[maxlen] = '\0';
			preflen = strlen(dst);
			maxlen -= preflen;
			dst += preflen;
		}
		if (maxlen > messagelen)
			maxlen = messagelen;
		strncpy(dst, message, maxlen);
		dst += maxlen;
		if (suffix && *suffix && dst < buf + GDKMAXERRLEN) {
			size_t sufflen;

			maxlen = buf + GDKMAXERRLEN - dst - 1;
			strncpy(dst, suffix, maxlen);
			dst[maxlen] = '\0';
			sufflen = strlen(dst);
			maxlen -= sufflen;
			dst += sufflen;
		}
		*dst = '\0';
	} else if (!GDKsilent) {
		/* construct format string because the format string
		   must start with ! */
		char format[32];

		snprintf(format, sizeof(format), "%s%%.*s%s", prefix ? prefix : "", suffix ? suffix : "");
		THRprintf(GDKerr, format, (int) messagelen, message);
	}
}

/* print an error or warning message, making sure the message ends in
   a newline, and also that every line in the message (if there are
   multiple), starts with an exclamation point.
   One of the problems complicating this whole issue is that each line
   should be printed using a single call to THRprintf, and moreover,
   the format string should start with a "!".  This is because
   THRprintf adds a "#" to the start of the printed text if the format
   string doesn't start with "!".
   Another problem is that we're religious about bounds checking.
   It would probably also not be quite as bad if we could write in the
   message buffer.
 */
void
GDKaddbuf(const char *message)
{
	const char *p, *q;
	char prefix[16];

	if (message == NULL || *message == '\0')	/* empty message, nothing to do */
		return;
	p = message;
	strcpy(prefix, "!");	/* default prefix */
	while (p && *p) {
		if (*p == '!') {
			size_t preflen;

			/* remember last ! prefix (e.g. "!ERROR: ")
			   for any subsequent lines that start without ! */
			message = p;
			/* A prefix consists of a ! immediately
			   followed by some text, followed by a : and
			   a space.  Anything else results in no
			   prefix being remembered */
			while (*++p && *p != ':' && *p != '\n' && *p != ' ')
				;
			if (*p == ':' && *++p == ' ') {
				/* found prefix, now remember it */
				preflen = (size_t) (p - message) + 1;
				if (preflen > sizeof(prefix) - 1)
					preflen = sizeof(prefix) - 1;
				strncpy(prefix, message, preflen);
				prefix[preflen] = 0;
			} else {
				/* there is a ! but no proper prefix */
				strcpy(prefix, "!");
				preflen = 1;
			}
			p = message + preflen;
		}

		/* find end of line */
		q = strchr(p, '\n');
		if (q) {
			/* print line including newline */
			q++;
			doGDKaddbuf(prefix, p, (size_t) (q - p), "");
		} else {
			/* no newline at end of buffer: print all the
			   rest and add a newline */
			doGDKaddbuf(prefix, p, strlen(p), "\n");
			/* we're done since there were no more newlines */
			break;
		}
		p = q;
	}
}

/*VARARGS*/ int
GDKwarning(const char *format, ...)
{
	char message[GDKMAXERRLEN];
	size_t len = strlen(GDKWARNING);
	va_list ap;

	if (!strncmp(format,GDKWARNING,len)) {
		len = 0;
	} else {
		strcpy(message, GDKWARNING);
	}
	va_start(ap, format);
	vsnprintf(message + len, GDKMAXERRLEN - (len + 2), format, ap);
	va_end(ap);

	GDKaddbuf(message);

	return 0;
}


/*VARARGS*/ int
GDKerror(const char *format, ...)
{
	char message[GDKMAXERRLEN];
	size_t len = strlen(GDKERROR);
	va_list ap;

	if (!strncmp(format,GDKERROR,len)) {
		len = 0;
	} else {
		strcpy(message, GDKERROR);
	}
	va_start(ap, format);
	vsnprintf(message + len, GDKMAXERRLEN - (len + 2), format, ap);
	va_end(ap);

	GDKaddbuf(message);

	return 0;
}

/*VARARGS*/ int
GDKsyserror(const char *format, ...)
{
	char message[GDKMAXERRLEN];
	size_t len = strlen(GDKERROR);

	int err = errno;
	va_list ap;

	if (!strncmp(format,GDKERROR,len)) {
		len = 0;
	} else {
		strcpy(message, GDKERROR);
	}
	va_start(ap, format);
	vsnprintf(message + len, GDKMAXERRLEN - (len + 2), format, ap);
	va_end(ap);
	if (err > 0 && err < 1024) {
		char *osmsg = strerror(err);
		size_t len1 = strlen(message);
		size_t len2 = len1 + strlen(GDKMESSAGE);
		size_t len3 = len2 + strlen(osmsg);

		if (len3 + 2 < GDKMAXERRLEN) {
			strcpy(message + len1, GDKMESSAGE);
			strcpy(message + len2, osmsg);
			message[len3] = '\n';
			message[len3 + 1] = 0;
		}
	}
	GDKaddbuf(message);

	errno = 0;
	return err;
}

/*VARARGS*/ int
GDKfatal(const char *format, ...)
{
	char message[GDKMAXERRLEN];
	size_t len = strlen(GDKFATAL);
	va_list ap;
	FILE *fd = stderr;

	GDKdebug |= 16;
#ifndef NATIVE_WIN32
	BATSIGinit();
#endif
	if (!strncmp(format,GDKFATAL,len)) {
		len = 0;
	} else {
		strcpy(message, GDKFATAL);
	}
	va_start(ap, format);
	vsnprintf(message + len, GDKMAXERRLEN - (len + 2), format, ap);
	va_end(ap);

	if (GDKsilent == 0) {
		fputs(message, fd);
		fputs("\n", fd);
		fflush(fd);
	}
@-
Real errors should be saved in the lock file for post-crash inspection.
@c
	if (GDKstopped) {
		fflush(stderr);
		MT_exit_thread(1);
		/* exit(1); */
	} else {
		GDKlog(message);
#ifdef COREDUMP
		abort();
#else
		GDKexit(1);
	}
#endif
	return -1;
}

int
GDKerrorCount(void)
{
	return THRerrorcount[THRgettid()];
}


@- Timers
The following relative timers are available for inspection.
Note that they may consume recognizable overhead.
@c

lng
GDKusec(void)
{
#ifdef HAVE_GETTIMEOFDAY
	struct timeval tp;

	gettimeofday(&tp, NULL);
	return ((lng) (tp.tv_sec - GDKtime_startsec)) * LL_CONSTANT(1000000) + (lng) tp.tv_usec;
#else
#ifdef HAVE_FTIME
	struct timeb tb;

	ftime(&tb);
	return ((lng) (tb.time - GDKtime_startsec)) * LL_CONSTANT(1000000) + ((lng) tb.millitm) * LL_CONSTANT(1000);
#endif
#endif
}


int
GDKms(void)
{
#ifdef HAVE_GETTIMEOFDAY
	struct timeval tp;

	gettimeofday(&tp, NULL);
	return (tp.tv_sec - GDKtime_startsec) * 1000 + tp.tv_usec / 1000;
#else
#ifdef HAVE_FTIME
	struct timeb tb;

	ftime(&tb);
	return (tb.time - GDKtime_startsec) * 1000 + tb.millitm;
#endif
#endif
}

@}

@+ Logical Thread management

All semaphores used by the application should be mentioned here.
They are initialized during system initialization.

@-
The first action upon thread creation is to add it to the pool
of known threads. This should be done by the thread itself.
Subsequently, the thread descriptor can be obtained using @%THRget@.
Note that the users should have gained exclusive access already.
A new entry is initialized automatically when not found.
Its file descriptors are the same as for the server and should be
subsequently reset.
@{
@c
int GDKnrofthreads;
ThreadRec GDKthreads[THREADS];
void *THRdata[THREADDATA] = { 0 };

Thread
THRget(int tid)
{
	assert(0 < tid && tid <= THREADS);
	return (GDKthreads + tid - 1);
}

static INLINE size_t
THRsp(void)
{
	int l = 0;
	size_t sp = (size_t) (&l);

	return sp;
}

static Thread
GDK_find_thread(MT_Id pid)
{
	Thread t, s;

	for (t = GDKthreads, s = t + THREADS; t < s; t++) {
		if (t->pid && t->pid == pid) {
			return t;
		}
	}
	return NULL;
}

Thread
THRnew(MT_Id pid, str name)
{
	MT_Id tid = 0;
	Thread t;
	Thread s = GDK_find_thread(pid);

	gdk_set_lock(GDKthreadLock, "THRnew");
	if (s == NULL) {
		for (s = GDKthreads, t = s + THREADS; s < t; s++) {
			if (s->pid == pid) {
				gdk_unset_lock(GDKthreadLock, "THRnew");
				GDKwarning("THRnew:duplicate %d\n", pid);
				return s;
			}
		}
		for (s = GDKthreads, t = s + THREADS; s < t; s++) {
			if (s->pid == 0) {
				break;
			}
		}
		if (s == t) {
			gdk_unset_lock(GDKthreadLock, "THRnew");
			GDKfatal("THRnew: too many threads\n");
		}
		tid = s->tid;
		memset((char *) s, 0, sizeof(*s));
		s->pid = pid;
		s->tid = tid;
		s->data[1] = THRdata[1];
		s->data[0] = THRdata[0];
		s->cleanup = NULL;
		s->sp = THRsp();

		PARDEBUG THRprintf(GDKerr, "%x " SZFMT " sp = " SZFMT "\n", s->tid, (size_t) pid, s->sp);
		PARDEBUG THRprintf(GDKerr, "nrofthreads %d\n", GDKnrofthreads);

		GDKnrofthreads++;
		MT_alloc_register(&tid, 1, (char) ('0' + ((int) tid) - 1));
	}
	s->name = name;
	gdk_unset_lock(GDKthreadLock, "THRnew");

	return s;
}

void
THRdel(Thread t)
{
	if (t < GDKthreads || t > GDKthreads + THREADS) {
		GDKfatal("THRdel: illegal call\n");
	}
	gdk_set_lock(GDKthreadLock, "THRdel");
	if (t->cleanup) {
		(*t->cleanup) (t);
	}
	PARDEBUG THRprintf(GDKerr, "pid = " SZFMT ", disconnected, %d left\n", (size_t) t->pid, GDKnrofthreads);
	t->pid = 0;
	GDKnrofthreads--;
	gdk_unset_lock(GDKthreadLock, "THRdel");
}

@-
The easiest way to terminate a thread is to identify its name
A zero is returned when the thread could not be found
@c
int
THRexit(str nme)
{
	Thread t;
	Thread s;

	for (t = GDKthreads, s = t + THREADS; t < s; t++) {
		if (t->pid && t->name && strcmp(t->name, nme) == 0) {
			MT_Id victim = t->pid;

			THRdel(t);
			MT_kill_thread(victim);
			return 1;
		}
	}
	return 0;
}

int
THRcnt(void)
{
	return GDKnrofthreads;
}

int
THRhighwater(void)
{
	size_t c = THRsp();
	Thread s = GDK_find_thread(MT_getpid());
	size_t diff = (c < s->sp) ? s->sp - c : c - s->sp;

	if (diff > (THREAD_STACK_SIZE - 2048)) {
		return 1;
	}
	return 0;
}

@-
I/O is organized per thread, because users may gain access through
the network.
The code below should be improved to gain speed.
@c

int
THRinit(void)
{
	int i = 0;

	THRdata[0] = (void *) file_wastream(stdout, "stdout");
	THRdata[1] = (void *) file_rastream(stdin, "stdin");
	for (i = 0; i < THREADS; i++) {
		GDKthreads[i].tid = (MT_Id) (i + 1);
	}
	return 0;
}

void
THRsetdata(int n, ptr val)
{
	Thread s = GDK_find_thread(MT_getpid());

	if (s)
		s->data[n] = val;
}

void *
THRgetdata(int n)
{
	Thread s = GDK_find_thread(MT_getpid());

	return (s ? s->data[n] : THRdata[n]);
}

int
THRgettid(void)
{
	Thread s = GDK_find_thread(MT_getpid());

	return s ? s->tid : 1;
}

static char THRprintbuf[BUFSIZ];

/*VARARGS*/ int
THRprintf(stream *s, const char *format, ...)
{
	str bf = THRprintbuf, p = 0;
	size_t bfsz = BUFSIZ;
	int n = 0;
	ptrdiff_t m = 0;
	char c;
	va_list ap;

	if (!s)
		return -1;

	if (MT_system_lock) {
		gdk_set_lock(MT_system_lock, "THRprintf");
	}
	if (*format != '!') {
		c = '#';
	} else {
		c = '!';
		format++;
	}

@= THRprintf_va_vsnprintf
	p = bf;
	*p++ = c;
	if (GDKdebug&1) {
		sprintf(p, "%02d ", THRgettid());
		while (*p)
			p++;
	}
	m = p-bf;
	va_start(ap, format);
	/* this could actually fail (return -1) for reasons other than
	   not enough buffer space; the code does not deal with this fact
	   (one reason for failure could be non-UTF-8 strings being
	   printed in a UTF-8 locale) */
	n = vsnprintf(p, bfsz-m, format, ap);
	va_end(ap);
@c
	@:THRprintf_va_vsnprintf@
	while (n < 0 || (size_t) n >= bfsz - m) {
		if (n >= 0)	/* glibc 2.1 */
			bfsz = m + n + 1;	/* precisely what is needed */
		else		/* glibc 2.0 */
			bfsz *= 2;	/* twice the old size */
		if (bf != THRprintbuf)
			free(bf);
		bf = (str) malloc(bfsz);
		assert(bf != NULL);
		@:THRprintf_va_vsnprintf@
	}
	p += n;

	n = 0;
	if (stream_write(s, bf, p - bf, 1) != 1 || stream_flush(s) != 0)
		n = -1;
	if (bf != THRprintbuf)
		free(bf);
	if (MT_system_lock) {
		gdk_unset_lock(MT_system_lock, "THRprintf");
	}
	return n;
}

@h
#endif /* _GDK_UTILS_H_ */
@}
