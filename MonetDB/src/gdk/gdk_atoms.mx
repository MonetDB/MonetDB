@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f gdk_atoms
@a M. L. Kersten, P. Boncz
@* Atomic types
The Binary Association Table library assumes efficient implementation of
the atoms making up the binary association.
This section describes the preliminaries for handling
both built-in and user-defined atomic types. 
New types, such as point and polygons, can be readily added to this
collection.
@-
@{
@h
#ifndef _GDK_ATOMS_H_
#define _GDK_ATOMS_H_
#include "gdk.h"

#define MAXATOMS	128

@- comparison macro's
In order to get maximum performance, we extensively use out-factoring
of typechecks using Mx macros. To catch diverging code in one Mx macro
we use the following #defines for comparing atoms:
@h
#define simple_CMP(x,y,tpe)     (simple_LT(x,y,tpe)?-1:simple_GT(x,y,tpe))
#define simple_EQ(x,y,tpe)      ((*(tpe*) (x)) == (*(tpe*) (y)))
#define simple_LT(x,y,tpe)      ((*(tpe*) (x))  < (*(tpe*) (y)))
#define simple_GT(x,y,tpe)      ((*(tpe*) (x))  > (*(tpe*) (y)))
#define simple_LE(x,y,tpe)      ((*(tpe*) (x)) <= (*(tpe*) (y)))
#define simple_GE(x,y,tpe)      ((*(tpe*) (x)) >= (*(tpe*) (y)))
#define atom_CMP(x,y,id)        (*BATatoms[id].atomCmp)(x,y)
#define atom_EQ(x,y,id)         ((*BATatoms[id].atomCmp)(x,y) == 0)
#define atom_LT(x,y,id)         ((*BATatoms[id].atomCmp)(x,y) < 0)
#define atom_GT(x,y,id)         ((*BATatoms[id].atomCmp)(x,y) > 0)
#define atom_LE(x,y,id)         ((*BATatoms[id].atomCmp)(x,y) <= 0)
#define atom_GE(x,y,id)         ((*BATatoms[id].atomCmp)(x,y) >= 0)
#define simple_HASH(v,tpe,dst)  ((dst) *(tpe *) (v))
#define atom_HASH(v,id,dst)     ((dst) (*BATatoms[id].atomHash)(v))

@- maximum atomic string lengths
@h
#define bitStrlen	8
#define chrStrlen	8
#define shtStrlen	12
#define intStrlen	24
#define oidStrlen	24
#define ptrStrlen	24
#define lngStrlen	48
#define fltStrlen	48
#define dblStrlen	96

@- 
The system comes with the traditional atomic types: int (4 bytes), bool(1 
byte) and str (variable). In addition, we support the notion of an OID 
type, which ensures uniqueness of its members.
This leads to the following type descriptor table.
@h

#ifdef __cplusplus
extern "C" {
#endif
gdk_export int voidFromStr(str src, int *len, void **dst);
gdk_export int voidToStr(str *dst, int *len, void *src);
gdk_export void *voidRead(void *a, stream *s, size_t cnt);
gdk_export int voidWrite(void *a, stream *s, size_t cnt);

gdk_export int lngFromStr(str src, int *len, lng **dst);
gdk_export int lngToStr(str *dst, int *len, lng *src);
gdk_export lng *lngRead(lng *a, stream *s, size_t cnt);
gdk_export int lngWrite(lng *a, stream *s, size_t cnt);
int lngCmp(lng *r, lng *l);
void lngConvert(lng *s);
hash_t lngHash(lng *l);

gdk_export int intFromStr(str src, int *len, int **dst);
gdk_export int intToStr(str *dst, int *len, int *src);
gdk_export int *intRead(int *a, stream *s, size_t cnt);
gdk_export int intWrite(int *a, stream *s, size_t cnt);
gdk_export int intCmp(int *r, int *l);
void intConvert(int *s);
hash_t intHash(int *i);

gdk_export int batFromStr(str src, int *len, bat **dst);
gdk_export int batToStr(str *dst, int *len, bat *src);
gdk_export bat *batRead(bat *a, stream *s, size_t cnt);
gdk_export int batWrite(bat *a, stream *s, size_t cnt);

gdk_export int ptrFromStr(str src, int *len, ptr **dst);
gdk_export int ptrToStr(str *dst, int *len, ptr *src);
gdk_export ptr *ptrRead(ptr *a, stream *s, size_t cnt);
gdk_export int ptrWrite(ptr *a, stream *s, size_t cnt);

gdk_export int bitFromStr(str src, int *len, bit **dst);
gdk_export int bitToStr(str *dst, int *len, bit *src);
gdk_export bit *bitRead(bit *a, stream *s, size_t cnt);
gdk_export int bitWrite(bit *a, stream *s, size_t cnt);

gdk_export int OIDfromStr(str src, int *len, oid **dst);
gdk_export int OIDtoStr(str *dst, int *len, oid *src);
gdk_export oid *oidRead(oid *a, stream *s, size_t cnt);
gdk_export int oidWrite(oid *a, stream *s, size_t cnt);

gdk_export int shtFromStr(str src, int *len, sht **dst);
gdk_export int shtToStr(str *dst, int *len, sht *src);
gdk_export sht *shtRead(sht *a, stream *s, size_t cnt);
gdk_export int shtWrite(sht *a, stream *s, size_t cnt);
void shtConvert(sht *s);
int shtCmp(sht *r, sht *l);
hash_t shtHash(sht *s);

gdk_export int chrFromStr(str src, int *len, chr **dst);
gdk_export int chrToStr(str *dst, int *len, chr *src);
gdk_export chr *chrRead(chr *a, stream *s, size_t cnt);
gdk_export int chrWrite(chr *a, stream *s, size_t cnt);
int chrCmp(chr *r, chr *l);
hash_t chrHash(chr *c);

gdk_export int fltFromStr(str src, int *len, flt **dst);
gdk_export int fltToStr(str *dst, int *len, flt *src);
gdk_export flt *fltRead(flt *a, stream *s, size_t cnt);
gdk_export int fltWrite(flt *a, stream *s, size_t cnt);
int fltCmp(flt *r, flt *l);

gdk_export int dblFromStr(str src, int *len, dbl **dst);
gdk_export int dblToStr(str *dst, int *len, dbl *src);
gdk_export dbl *dblRead(dbl *a, stream *s, size_t cnt);
gdk_export int dblWrite(dbl *a, stream *s, size_t cnt);
int dblCmp(dbl *r, dbl *l);

gdk_export int GDKstrFromStr(unsigned char *src, unsigned char *dst, int len);
gdk_export int strFromStr(str src, int *len, str *dst);
gdk_export int strToStr(str *dst, int *len, str src);
gdk_export str strRead(str a, stream *s, size_t cnt);
gdk_export int strWrite(str a, stream *s, size_t cnt);
gdk_export hash_t strHash(str s);
gdk_export var_t strPut(Heap *b, var_t *off, str src);
gdk_export void strHeap(Heap *d, size_t cap);
gdk_export int strLen(const char *s);
gdk_export int strCmp(str l, str r);
gdk_export int strNil(str s);
gdk_export void strHeapConvert(Heap *h, int directon);
gdk_export int strElimDoubles(Heap *h);
gdk_export var_t strLocate(Heap *h, str v);
gdk_export int strCmpNoNil(unsigned char *l, unsigned char *r);

#ifdef __cplusplus
}
#endif
@- inline comparison routines
Return 0 on l==r, < 0 iff l < r, >0 iff l > r  
@c
#include "gdk.h"
#include <math.h>		/* for INFINITY and NAN */

int
chrCmp(chr *l, chr *r)
{
	return simple_CMP(l, r, chr);
}

int
shtCmp(sht *l, sht *r)
{
	return simple_CMP(l, r, sht);
}

int
intCmp(int *l, int *r)
{
	return simple_CMP(l, r, int);
}

int
fltCmp(flt *l, flt *r)
{
	return simple_CMP(l, r, flt);
}

int
lngCmp(lng *l, lng *r)
{
	return simple_CMP(l, r, lng);
}

int
dblCmp(dbl *l, dbl *r)
{
	return simple_CMP(l, r, dbl);
}

@- inline hash routines
Return some positive integer derived from one atom value.
@c
hash_t
chrHash(chr *v)
{
	return (hash_t) *(unsigned char *) v;
}

hash_t
shtHash(sht *v)
{
	return (hash_t) mix_sht(*(unsigned short *) v);
}

hash_t
intHash(int *v)
{
	return (hash_t) mix_int(*(unsigned int *) v);
}

hash_t
lngHash(lng *v)
{
	return (hash_t) mix_int(((unsigned int *) v)[0] ^ ((unsigned int *) v)[1]);
}

@+ Standard Atoms
@c
INLINE void
shtConvert(sht *s)
{
	*s = short_int_SWAP(*s);
}
INLINE void
intConvert(int *s)
{
	*s = normal_int_SWAP(*s);
}
INLINE void
lngConvert(lng *s)
{
	*s = long_long_SWAP(*s);
}
INLINE int
batFix(bat *b)
{
	return BBPincref(*b, TRUE);
}
INLINE int
batUnfix(bat *b)
{
	return BBPdecref(*b, TRUE);
}

atomDesc BATatoms[MAXATOMS] = {
	{"void",
#if SIZEOF_OID == SIZEOF_INT
	 TYPE_void, 1, 0, /* sizeof(@`void@7) */ 0, 0, 1, (ptr) &int_nil,
	 (int (*)(str, int *, ptr *)) OIDfromStr, (int (*)(str *, int *, ptr)) OIDtoStr,
	 (void *(*)(void *, stream *, size_t)) voidRead, (int (*)(void *, stream *, size_t)) voidWrite,
	 (int (*)(ptr, ptr)) intCmp,
	 (hash_t (*)(ptr)) intHash, 0,
#else
	 TYPE_void, 1, 0, /* sizeof(@`void@7) */ 0, 0, 1, (ptr) &lng_nil,
	 (int (*)(str, int *, ptr *)) OIDfromStr, (int (*)(str *, int *, ptr)) OIDtoStr,
	 (void *(*)(void *, stream *, size_t)) voidRead, (int (*)(void *, stream *, size_t)) voidWrite,
	 (int (*)(ptr, ptr)) lngCmp,
	 (hash_t (*)(ptr)) lngHash, 0,
#endif
	 0, 0,
	 0, 0,
	 0, 0,
	 0, 0},
	{"bit", TYPE_chr, 1, sizeof(bit), sizeof(@`bit@7), 0, 0, (ptr) &chr_nil,
	 (int (*)(str, int *, ptr *)) bitFromStr, (int (*)(str *, int *, ptr)) bitToStr,
	 (void *(*)(void *, stream *, size_t)) bitRead, (int (*)(void *, stream *, size_t)) bitWrite,
	 (int (*)(ptr, ptr)) chrCmp,
	 (hash_t (*)(ptr)) chrHash, 0,
	 0, 0,
	 0, 0,
	 0, 0,
	 0, 0},
	{"chr", TYPE_chr, 1, sizeof(chr), sizeof(@`chr@7), 0, 0, (ptr) &chr_nil,
	 (int (*)(str, int *, ptr *)) @`chrFromStr@5, (int (*)(str *, int *, ptr)) @`chrToStr@5,
	 (void *(*)(void *, stream *, size_t)) chrRead, (int (*)(void *, stream *, size_t)) chrWrite,
	 (int (*)(ptr, ptr)) chrCmp,
	 (hash_t (*)(ptr)) chrHash, 0,
	 0, 0,
	 0, 0,
	 0, 0,
	 0, 0},
	{"sht", TYPE_sht, 1, sizeof(sht), sizeof(@`sht@7), 0, 0, (ptr) &sht_nil,
	 (int (*)(str, int *, ptr *)) @`shtFromStr@5, (int (*)(str *, int *, ptr)) @`shtToStr@5,
	 (void *(*)(void *, stream *, size_t)) shtRead, (int (*)(void *, stream *, size_t)) shtWrite,
	 (int (*)(ptr, ptr)) shtCmp,
	 (hash_t (*)(ptr)) shtHash, (void (*)(ptr, int)) shtConvert,
	 0, 0,
	 0, 0,
	 0, 0,
	 0, 0},
	{"BAT", TYPE_int, 1, sizeof(bat), sizeof(@`bat@7), 0, 0, (ptr) &int_nil,
	 (int (*)(str, int *, ptr *)) batFromStr, (int (*)(str *, int *, ptr)) batToStr,
	 (void *(*)(void *, stream *, size_t)) batRead, (int (*)(void *, stream *, size_t)) batWrite,
	 (int (*)(ptr, ptr)) intCmp,
	 (hash_t (*)(ptr)) intHash, (void (*)(ptr, int)) intConvert,
	 (int (*)(ptr)) batFix, (int (*)(ptr)) batUnfix,
	 0, 0,
	 0, 0,
	 0, 0},
	{"int", TYPE_int, 1, sizeof(int), sizeof(@`int@7), 0, 0, (ptr) &int_nil,
	 (int (*)(str, int *, ptr *)) intFromStr, (int (*)(str *, int *, ptr)) @`intToStr@5,
	 (void *(*)(void *, stream *, size_t)) intRead, (int (*)(void *, stream *, size_t)) intWrite,
	 (int (*)(ptr, ptr)) intCmp,
	 (hash_t (*)(ptr)) intHash, (void (*)(ptr, int)) intConvert,
	 0, 0,
	 0, 0,
	 0, 0,
	 0, 0},
	{"oid",
#if SIZEOF_OID == SIZEOF_INT
	 TYPE_int, 1, sizeof(oid), sizeof(@`oid@7), 0, 0, (ptr) &int_nil,
	 (int (*)(str, int *, ptr *)) OIDfromStr, (int (*)(str *, int *, ptr)) OIDtoStr,
	 (void *(*)(void *, stream *, size_t)) intRead, (int (*)(void *, stream *, size_t)) intWrite,
	 (int (*)(ptr, ptr)) intCmp,
	 (hash_t (*)(ptr)) intHash, (void (*)(ptr, int)) intConvert,
#else
	 TYPE_lng, 1, sizeof(oid), sizeof(@`oid@7), 0, 0, (ptr) &lng_nil,
	 (int (*)(str, int *, ptr *)) OIDfromStr, (int (*)(str *, int *, ptr)) OIDtoStr,
	 (void *(*)(void *, stream *, size_t)) lngRead, (int (*)(void *, stream *, size_t)) lngWrite,
	 (int (*)(ptr, ptr)) lngCmp,
	 (hash_t (*)(ptr)) lngHash, (void (*)(ptr, int)) lngConvert,
#endif
	 0, 0,
	 0, 0,
	 0, 0,
	 0, 0},
	{"ptr",
#if SIZEOF_VOID_P == SIZEOF_INT
	 TYPE_int, 1, sizeof(ptr), sizeof(@`ptr@7), 0, 0, (ptr) &int_nil,
	 (int (*)(str, int *, ptr *)) @`ptrFromStr@5, (int (*)(str *, int *, ptr)) @`ptrToStr@5,
	 (void *(*)(void *, stream *, size_t)) ptrRead, (int (*)(void *, stream *, size_t)) ptrWrite,
	 (int (*)(ptr, ptr)) intCmp,
	 (hash_t (*)(ptr)) intHash, (void (*)(ptr, int)) intConvert,
#else /* SIZEOF_VOID_P == SIZEOF_LNG */
	 TYPE_lng, 1, sizeof(ptr), sizeof(@`ptr@7), 0, 0, (ptr) &lng_nil,
	 (int (*)(str, int *, ptr *)) @`ptrFromStr@5, (int (*)(str *, int *, ptr)) @`ptrToStr@5,
	 (void *(*)(void *, stream *, size_t)) ptrRead, (int (*)(void *, stream *, size_t)) ptrWrite,
	 (int (*)(ptr, ptr)) lngCmp,
	 (hash_t (*)(ptr)) lngHash, (void (*)(ptr, int)) lngConvert,
#endif
	 0, 0,
	 0, 0,
	 0, 0,
	 0, 0},
	{"flt", TYPE_flt, 1, sizeof(flt), sizeof(@`flt@7), 0, 0, (ptr) &flt_nil,
	 (int (*)(str, int *, ptr *)) @`fltFromStr@5, (int (*)(str *, int *, ptr)) @`fltToStr@5,
	 (void *(*)(void *, stream *, size_t)) fltRead, (int (*)(void *, stream *, size_t)) fltWrite,
	 (int (*)(ptr, ptr)) fltCmp,
	 (hash_t (*)(ptr)) intHash, (void (*)(ptr, int)) intConvert,
	 0, 0,
	 0, 0,
	 0, 0,
	 0, 0},
	{"dbl", TYPE_dbl, 1, sizeof(dbl), sizeof(@`dbl@7), 0, 0, (ptr) &dbl_nil,
	 (int (*)(str, int *, ptr *)) @`dblFromStr@5, (int (*)(str *, int *, ptr)) @`dblToStr@5,
	 (void *(*)(void *, stream *, size_t)) dblRead, (int (*)(void *, stream *, size_t)) dblWrite,
	 (int (*)(ptr, ptr)) dblCmp,
	 (hash_t (*)(ptr)) lngHash, (void (*)(ptr, int)) lngConvert,
	 0, 0,
	 0, 0,
	 0, 0,
	 0, 0},
	{"lng", TYPE_lng, 1, sizeof(lng), sizeof(@`lng@7), 0, 0, (ptr) &lng_nil,
	 (int (*)(str, int *, ptr *)) lngFromStr, (int (*)(str *, int *, ptr)) lngToStr,
	 (void *(*)(void *, stream *, size_t)) lngRead, (int (*)(void *, stream *, size_t)) lngWrite,
	 (int (*)(ptr, ptr)) lngCmp,
	 (hash_t (*)(ptr)) lngHash, (void (*)(ptr, int)) lngConvert,
	 0, 0,
	 0, 0,
	 0, 0,
	 0, 0},
	{"str", TYPE_str, 1, sizeof(var_t), sizeof(var_t), 0, 1, (ptr) &chr_nil,
	 (int (*)(str, int *, ptr *)) strFromStr, (int (*)(str *, int *, ptr)) strToStr,
	 (void *(*)(void *, stream *, size_t)) strRead, (int (*)(void *, stream *, size_t)) strWrite,
	 (int (*)(ptr, ptr)) strCmp,
	 (hash_t (*)(ptr)) strHash, 0,
	 0, 0,
	 (var_t (*)(Heap *, var_t *, ptr)) strPut, 0,
	 (int (*)(ptr)) strLen, strHeap,
	 (void (*)(Heap *, int)) strHeapConvert, 0},
};
int GDKatomcnt = TYPE_str + 1;

@
@}
@+ Atomic Type Interface
The collection of built-in types supported for BATs can be extended easily.
In essence, the user should specify conversion routines from values stored
anywhere in memory to its equivalent in the BAT, and vice verse.
Some routines are required for coercion and to support the BAT
administration.

A new type is incrementally build using the 
routine @%ATOMproperty(id, property, value)@.
The parameter @%id@ denotes the type name; an entry is created if the type
is so far unknown. The @%property@ argument is a string identifying the
type description property to be updated. Valid property
names are @%size, tostr, fromstr, put, get, cmp, eq, del, hash, null@,
@%new@, and @%heap@.

The size describes the amount of space to be reserved in the BUN.

The routine @%put@ takes a pointer to a memory resident copy and prepares
a persistent copy in the BAT passed. 
The inverse operation is @%get@. 
A new value can be directly included into the BAT using @%new@, which should
prepare a null-value representation.
A value is removed from the BAT
store using @%del@, which can take care of garbage collection and 
BAT administration. 

The pair @%tostr@ and @%fromstr@ should convert a reference to a persistent
value to a memory resident string equivalent. @%FromStr@ takes a 
string and applies a @%put@ to store it within a BAT. 
They are used to prepare for readable output/input and to support coercion.

The routines @%cmp@ and @%eq@ are comparison routines used to build access 
structures. The @%null@ returns a reference to a null value representation.
@- 
The incremental atom construction uses hardwired properties.
This should be improved later on.

@{
@c
void
ATOMdelete(int id)
{
	memset(BATatoms + id, 0, sizeof(atomDesc));

	if (id == GDKatomcnt - 1)
		GDKatomcnt--;
}

static int
align(int n)
{
	if (n == 0)
		return 0;
	/* successively check bits from the bottom to see if one is set */
	if (n & 1)
		return 1;
	if (n & 2)
		return 2;
	if (n & 4)
		return 4;
	return 8;
}

void
ATOMproperty(str id, str property, GDKfcn arg)
{
	int t;

	gdk_set_lock(GDKthreadLock, "ATOMproperty");
	t = ATOMindex(id);

	if (t < 0) {
		t = -t;
		if (t == GDKatomcnt) {
			GDKatomcnt++;
		}
		FATALcheck(GDKatomcnt == MAXATOMS, "ATOMproperty:too many types");
		FATALcheck(strlen(id) >= IDLENGTH, "ATOMproperty:name too long");
		memset(BATatoms + t, 0, sizeof(atomDesc));
		strcpy(BATatoms[t].name, id);
		BATatoms[t].size = sizeof(int);	/* default */
		BATatoms[t].align = sizeof(int);	/* default */
		BATatoms[t].linear = 1;	/* default */
		BATatoms[t].storage = t;	/* default */
		BATatoms[t].deleting = 1;	/* not yet usable */
	}
	if (strcmp("size", property) == 0) {
		if ((int) (ssize_t) arg) {
			BATatoms[t].size = (int) (ssize_t) arg;
			BATatoms[t].varsized = 0;
			BATatoms[t].align = align((int) (ssize_t) arg);
		} else {
			BATatoms[t].size = sizeof(var_t);
			BATatoms[t].varsized = 1;
			BATatoms[t].align = sizeof(var_t);
		}
	} else if (strcmp("linear", property) == 0) {
		BATatoms[t].linear = (int) (ssize_t) arg;
	} else if (strcmp("align", property) == 0) {
		BATatoms[t].align = (int) (ssize_t) arg;
	} else if (strcmp("storage", property) == 0) {
		int tpe = (int) (ssize_t) arg;

		BATatoms[t] = BATatoms[tpe];	/* copy from example */
		strcpy(BATatoms[t].name, id);	/* restore name */
	} else if (strcmp("fromstr", property) == 0) {
		BATatoms[t].atomFromStr = (int (*)(char *, int *, void **)) arg;
	} else if (strcmp("tostr", property) == 0) {
		BATatoms[t].atomToStr = (int (*)(char **, int *, void *)) arg;
	} else if (strcmp("read", property) == 0) {
		BATatoms[t].atomRead = (void *(*)(void *, stream *, size_t)) arg;
	} else if (strcmp("write", property) == 0) {
		BATatoms[t].atomWrite = (int (*)(void *, stream *, size_t)) arg;
	} else if (strcmp("fix", property) == 0) {
		BATatoms[t].atomFix = (int (*)(void *)) arg;
	} else if (strcmp("unfix", property) == 0) {
		BATatoms[t].atomUnfix = (int (*)(void *)) arg;
	} else {
#define atomset(dst,val) oldval = (ptr) dst; if (val == NULL || dst == val) goto out; dst = val;
		ptr oldval = NULL;

		if (strcmp("heap", property) == 0) {
			BATatoms[t].size = sizeof(var_t);
			BATatoms[t].varsized = 1;
			BATatoms[t].align = sizeof(var_t);
			atomset(BATatoms[t].atomHeap, (void (*)(Heap *, size_t)) arg);
		} else if (strcmp("heapconvert", property) == 0) {
			atomset(BATatoms[t].atomHeapConvert, (void (*)(Heap *, int)) arg);
		} else if (strcmp("check", property) == 0) {
			atomset(BATatoms[t].atomHeapCheck, (int (*)(Heap *, HeapRepair *)) arg);
		} else if (strcmp("del", property) == 0) {
			atomset(BATatoms[t].atomDel, (void (*)(Heap *, var_t *)) arg);
		} else if (strcmp("convert", property) == 0) {
			atomset(BATatoms[t].atomConvert, (void (*)(void *, int)) arg);
		} else if (strcmp("put", property) == 0) {
			atomset(BATatoms[t].atomPut, (var_t (*)(Heap *, var_t *, void *)) arg);
		} else if (strcmp("null", property) == 0) {
			ptr atmnull = ((ptr (*)(void)) arg) ();

			atomset(BATatoms[t].atomNull, atmnull);
		}
		if (oldval)
			goto out;

		/* these ADT functions *must* be equal for overloaded types */
		if (strcmp("cmp", property) == 0) {
			atomset(BATatoms[t].atomCmp, (int (*)(void *, void *)) arg);
		} else if (strcmp("hash", property) == 0) {
			atomset(BATatoms[t].atomHash, (hash_t (*)(void *)) arg);
		} else if (strcmp("length", property) == 0) {
			atomset(BATatoms[t].atomLen, (int (*)(void *)) arg);
		}
		if (BATatoms[t].storage != t)
			GDKerror("ATOMproperty: %s overload of %s violates inheritance from %s.\n", ATOMname(t), property, ATOMname(BATatoms[t].storage));
/*
*/
		BATatoms[t].storage = t;	/* critical redefine: undo remapping */
	}
  out:
	gdk_unset_lock(GDKthreadLock, "ATOMproperty");
}

int
ATOMindex(str nme)
{
	int t, j = GDKatomcnt;

	for (t = 0; t < GDKatomcnt; t++) {
		if (!BATatoms[t].name[0]) {
			if (j == GDKatomcnt)
				j = t;
		} else if (strcmp(nme, BATatoms[t].name) == 0) {
			return t;
		}

	}
	if (strcmp(nme, "bat") == 0) {
		return TYPE_bat;
	}
	return -j;
}

char *
ATOMname(int t)
{
	return (t >= 0 && t < GDKatomcnt && BATatoms[t].name) ? BATatoms[t].name : "null";
}

int
ATOMisdescendant(int tpe, int parent)
{
	int cur = -1;

	while (cur != tpe) {
		cur = tpe;
		if (cur == parent)
			return TRUE;
		tpe = BATatoms[tpe].storage;
	}
	return FALSE;
}

int
ATOMdump(void)
{
	int t;

	for (t = 0; t < GDKatomcnt; t++) {
		stream_printf(GDKout, "%2d '%9s' (%3d) ", t, BATatoms[t].name, BATatoms[t].size);
		if (BATatoms[t].atomFromStr) {
			stream_printf(GDKout, "\"FromStr\" ");
		}
		if (BATatoms[t].atomToStr) {
			stream_printf(GDKout, "\"ToStr\" ");
		}
		if (BATatoms[t].atomCmp) {
			stream_printf(GDKout, "\"Cmp\" ");
		}
		if (BATatoms[t].atomNull) {
			stream_printf(GDKout, "\"Null\" ");
		}
		if (BATatoms[t].atomHash) {
			stream_printf(GDKout, "\"Hash\" ");
		}
		if (BATatoms[t].atomPut) {
			stream_printf(GDKout, "\"Put\" ");
		}
		if (BATatoms[t].atomDel) {
			stream_printf(GDKout, "\"Del\" ");
		}
		if (BATatoms[t].atomLen) {
			stream_printf(GDKout, "\"Len\" ");
		}
		if (BATatoms[t].atomConvert) {
			stream_printf(GDKout, "\"Convert\" ");
		}
		if (BATatoms[t].atomHeap) {
			stream_printf(GDKout, "\"NewHeap\" ");
		}
		stream_printf(GDKout, "\n");
	}
	return 0;
}

@}

@- nil values
All types have a single value designated as a NIL value. It designates
a missing value and it is ignored (forbidden) in several primitives.
The current policy is to use the smallest value in any ordered domain.
The routine atomnil returns a pointer to the nil value representation.
@{
@h
#include <limits.h>		/* for *_MIN and *_MAX */
#include <float.h>		/* for FLT_MAX and DBL_MAX */
#ifndef LLONG_MAX
#ifdef LONGLONG_MAX
#define LLONG_MAX LONGLONG_MAX
#define LLONG_MIN LONGLONG_MIN
#else
#define LLONG_MAX LL_CONSTANT(9223372036854775807)
#define LLONG_MIN (-LL_CONSTANT(9223372036854775807) - LL_CONSTANT(1))
#endif
#endif
#define GDK_bit_max ((bit) 1)
#define GDK_bit_min ((bit) 0)
#define GDK_chr_max ((chr) SCHAR_MAX)
#define GDK_chr_min ((chr) SCHAR_MIN)
#define GDK_sht_max ((sht) SHRT_MAX)
#define GDK_sht_min ((sht) SHRT_MIN)
#define GDK_int_max INT_MAX
#define GDK_int_min INT_MIN
#define GDK_flt_max ((flt) FLT_MAX)
#define GDK_flt_min (-GDK_flt_max)
#define GDK_lng_max ((lng) LLONG_MAX)
#define GDK_lng_min ((lng) LLONG_MIN)
#define GDK_dbl_max ((dbl) DBL_MAX)
#define GDK_dbl_min (-GDK_dbl_max)
/* GDK_oid_max see below */
#define GDK_oid_min ((oid) 0)
/* representation of the nil */ gdk_export chr chr_nil;
gdk_export short sht_nil;
gdk_export int int_nil;
gdk_export flt flt_nil;
gdk_export dbl dbl_nil;
gdk_export lng lng_nil;
gdk_export char str_nil[2];

/* derived NIL values - OIDDEPEND */
#define bit_nil	((bit) chr_nil)
#if SIZEOF_VOID_P == SIZEOF_INT
#define ptr_nil	((ptr) int_nil)
#else /* SIZEOF_VOID_P == SIZEOF_LNG */
#define ptr_nil	((ptr) lng_nil)
#endif
#define bat_nil	((bat) int_nil)
#if SIZEOF_OID == SIZEOF_INT
#define oid_nil	((oid) int_nil)
#define GDK_oid_max ((oid) GDK_int_max)
#else
#define oid_nil	((oid) lng_nil)
#define GDK_oid_max ((oid) GDK_lng_max)
#endif
#define void_nil	oid_nil
@c
chr chr_nil = GDK_chr_min;
sht sht_nil = GDK_sht_min;
int int_nil = GDK_int_min;
flt flt_nil = GDK_flt_min;
dbl dbl_nil = GDK_dbl_min;
lng lng_nil = GDK_lng_min;
char str_nil[2] = { GDK_chr_min, 0 };

ptr
ATOMnil(int t)
{
	ptr src = ATOMnilptr(t);
	int len = ATOMlen(ATOMtype(t), src);
	ptr dst = GDKmalloc(len);

	memcpy(dst, src, len);
	return dst;
}

@}
@- Derived types
In all algorithms across GDK, you will find switches on the types
( chr, sht, int, flt, dbl, lng, str). They respectively represent 
an octet, a 16-bit int, a 32-bit int, a 32-bit float, a 64-bit double,
a 64-bit int, and a pointer-sized location of a char-buffer (ended by 
a zero char).

In contrast, the types (bit, ptr, bat, oid) are derived types. They 
do not occur in the switches. The @%ATOMstorage@ macro maps them respectively
onto a @code{ chr}, @code{ int} (pointers are 32-bit), @code{ int}, and
@code{ int}. OIDs are 32-bit.

This approach makes it tractable to switch to 64-bits OIDs,
or to a fully 64-bits OS easily. One only has to map the @code{ oid}
and @code{ ptr} types to @code{ lng} instead of @code{ int}. 

Derived types mimic their fathers in many ways. They inherit the @code{ size},
@code{ varsized}, @code{ linear}, @code{ null} and @code{ align} properties of their 
father.  The same goes for the ADT functions HASH, CMP, PUT, NULL,
DEL, LEN, and HEAP. So, a derived type differs in only two ways
from its father:
@table @code
@item [string representation]
the only two ADT operations specific for a derived type are FROMSTR
and TOSTR.
@item [identity]
(a @code{ bit} is really of a different type than @code{ chr}). The set of
operations on derived type values or BATs of such types may differ
from the sets of operations on the father type. 
@end table
@{
@h
/* use "do ... while(0)" so that lhs can safely be used in if statements */
#define ATOMstorage(t)		BATatoms[t].storage
#define ATOMsize(t)		BATatoms[t].size
#define ATOMalign(t)		BATatoms[t].align
#define ATOMfromstr(t,s,l,src)	BATatoms[t].atomFromStr(src,l,s)
#define ATOMnilptr(t)		BATatoms[t].atomNull
#define ATOMhash(t,src)		BATatoms[t].atomHash(src)
#define ATOMdel(t,hp,src)	do if (BATatoms[t].atomDel) BATatoms[t].atomDel(hp,src); while (0)
#define ATOMvarsized(t)		((t != TYPE_void) && BATatoms[t].varsized)
#define ATOMlinear(t)		BATatoms[t].linear
#define ATOMtype(t)		((t == TYPE_void)?TYPE_oid:t)
#define ATOMfix(t,v)		do if (BATatoms[t].atomFix) BATatoms[t].atomFix(v); while (0)
#define ATOMunfix(t,v)		do if (BATatoms[t].atomUnfix) BATatoms[t].atomUnfix(v); while (0)
#define ATOMconvert(t,v,d)	do if (BATatoms[t].atomConvert) BATatoms[t].atomConvert(v,d); while (0)
#define ATOMheapConvert(t,hp,d)	do if (BATatoms[t].atomHeapConvert) BATatoms[t].atomHeapConvert(hp,d); while (0)

#define CONV_HTON               1
#define CONV_NTOH               0

@- 
In case that atoms are added to a bat, their logical reference count
should be incremented (and decremented if deleted). Notice that BATs 
with atomic types that have logical references (e.g. BATs of BATs but 
also BATs of ODMG odSet) can never be persistent, as this would make
the commit tremendously complicated.
@h
#define ATOMput(P1, P2, p3, p4)						\
{									\
	int t_ = (P1);							\
	ptr P3 = (ptr) (p3);						\
	ptr P4 = (ptr) (p4);						\
									\
	if (t_ == TYPE_oid || t_ == TYPE_ptr || t_ > TYPE_str)		\
		t_ = ATOMstorage(t_);					\
	if (t_ <= TYPE_bat) {						\
		if (t_ <= TYPE_chr) {					\
			if (t_ != TYPE_void)				\
				*(chr *) (P3) = *(chr *) (P4);		\
		} else if (t_ == TYPE_sht) {				\
			*(sht *) (P3) = *(sht *) (P4);			\
		} else if (t_ == TYPE_bat) {				\
			BBPincref(*(bat *) (P4), TRUE);			\
			*(bat *) (P3) = *(bat *) (P4);			\
		}							\
	} else {							\
		if (t_ <= TYPE_flt) {					\
			*(int *) (P3) = *(int *) (P4);			\
		} else if (t_ <= TYPE_lng) {				\
			*(lng *) (P3) = *(lng *) (P4);			\
		} else if (t_ == TYPE_str) {				\
			if (strPut(P2, (var_t *) (P3), (str) (P4)) == 0) \
				goto bunins_failed;			\
		} else {						\
			if (BATatoms[t_].atomPut) {			\
				if ((*BATatoms[t_].atomPut) (P2, (var_t *) P3, P4) == 0) \
					goto bunins_failed;		\
			} else {					\
				memcpy(P3, P4, ATOMsize(P1));		\
			}						\
			ATOMfix(t_, P4);				\
		}							\
	}								\
}

#define ATOMreplace(P1,	P2, P3, P4)					\
{									\
	int t_ = (P1);							\
									\
	if (t_ == TYPE_oid || t_ == TYPE_ptr || t_ > TYPE_str)		\
		t_ = ATOMstorage(t_);					\
	if (t_ <= TYPE_bat) {						\
		if (t_ <= TYPE_chr) {					\
			if (t_ != TYPE_void)				\
				*(chr *) (P3) = *(chr *) (P4);		\
		} else if (t_ == TYPE_sht) {				\
			*(sht *) (P3) = *(sht *) (P4);			\
		} else if (t_ == TYPE_bat) {				\
			BBPincref(*(bat *) (P4), TRUE);			\
			BBPdecref(*(bat *) (P3), TRUE);			\
			*(bat *) (P3) = *(bat *) (P4);			\
		}							\
	} else {							\
		if (t_ <= TYPE_flt) {					\
			*(int *) (P3) = *(int *) (P4);			\
		} else if (t_ <= TYPE_lng) {				\
			*(lng *) (P3) = *(lng *) (P4);			\
		} else if (t_ == TYPE_str) {				\
			if (strPut(P2, (var_t *) (P3), (str) (P4)) == 0) \
				goto bunins_failed;			\
		} else if (BATatoms[t_].atomPut) {			\
			var_t loc_ = *(var_t *) (P3);			\
									\
			if ((*BATatoms[t_].atomPut) (P2, &loc_, P4) == 0) \
				goto bunins_failed;			\
			ATOMunfix(t_, P3);				\
			if (BATatoms[t_].atomDel) {			\
				ATOMdel(t_, P2, (var_t *) P3);		\
			}						\
			*(P3) = loc_;					\
			ATOMfix(t_, P4);				\
		} else {						\
			ATOMunfix(t_, P3);				\
			memcpy(P3, P4, ATOMsize(P1));			\
			ATOMfix(t_, P4);				\
		}							\
	}								\
}

#define GDK_STRHASHTABLE	(1<<10)
#define GDK_STRHASHMASK		(GDK_STRHASHTABLE-1)
#define GDK_STRHASHSIZE		(GDK_STRHASHTABLE * sizeof(var_t))
#define GDK_ELIMDOUBLES(h)	((h)->free < GDK_ELIMLIMIT)
#define GDK_ELIMLIMIT		(1<<GDK_ELIMPOWER)
#define GDK_ELIMBASE(x)		(((x) >> GDK_ELIMPOWER) << GDK_ELIMPOWER)
#if SIZEOF_SIZE_T == SIZEOF_INT
#define GDK_ELIMPOWER		18	/* makes for a max 256KB hash table 
					 * ie 256 string bytes per hash bucket 
					 * ~ 16 strings of UP4(8<=len<=11)=12 + 4 bytes 
					 */
#else
#define GDK_ELIMPOWER		19	/* makes for a max 512KB hash table 
					 * ie 512 string bytes per hash bucket 
					 * ~ 21 strings of UP8(8<=len<=15)=16 + 8 bytes 
					 */
#endif

@- Atomic ADT functions
@c
int
ATOMlen(int t, ptr src)
{
	int (*l) () = BATatoms[t].atomLen;

	return (l) ? (*l) (src) : ATOMsize(t);
}

int
ATOMheap(int t, Heap *hp, size_t cap)
{
	void (*h) (Heap *, size_t) = BATatoms[t].atomHeap;

	if (h) {
		(*h) (hp, cap);
		if (hp->base == NULL)
			return -1;
	}
	return 0;
}

int
ATOMcmp(int t, ptr l, ptr r)
{
	switch (ATOMstorage(t)) {
#ifndef NOEXPAND_CHR
	case TYPE_chr:
		return simple_CMP(l, r, chr);
#endif
#ifndef NOEXPAND_SHT
	case TYPE_sht:
		return simple_CMP(l, r, sht);
#endif
#ifndef NOEXPAND_INT
	case TYPE_int:
		return simple_CMP(l, r, int);
#endif
#ifndef NOEXPAND_FLT
	case TYPE_flt:
		return simple_CMP(l, r, flt);
#endif
#ifndef NOEXPAND_LNG
	case TYPE_lng:
		return simple_CMP(l, r, lng);
#endif
#ifndef NOEXPAND_DBL
	case TYPE_dbl:
		return simple_CMP(l, r, dbl);
#endif
	default:
		return (l == r) ? 0 : atom_CMP(l, r, t);
	}
}

@
Atom print avoids coercion to strings for built-in types.
The comparison against the NULL value is hard coded for speed.
@c
#define LINE_LEN	60

int
ATOMprint(int t, ptr p, stream *s)
{
	int (*tostr) (str *, int *, ptr);

	if (p && (t >= 0) && (t < GDKatomcnt) && (tostr = BATatoms[t].atomToStr)) {
		if (t != TYPE_bat && t < TYPE_str) {
			char buf[dblStrlen], *addr = buf;	/* use memory from stack */
			int sz = dblStrlen, l = (*tostr) (&addr, &sz, p);

			stream_write(s, buf, l, 1);
			return l;
		} else {
			str buf = 0;
			int sz = 0, l = (*tostr) (&buf, &sz, p);

			l = stream_write(s, buf, l, 1);
			GDKfree(buf);
			return l;
		}
	}
	return (int) stream_write(s, "nil", 1, 3);
}


int
ATOMformat(int t, ptr p, char **buf)
{
	int (*tostr) (str *, int *, ptr);

	if (p && (t >= 0) && (t < GDKatomcnt) && (tostr = BATatoms[t].atomToStr)) {
		int sz = 0, l = (*tostr) (buf, &sz, p);

		return l;
	}
	strcpy(*buf = GDKmalloc(4), "nil");
	return 3;
}

ptr
ATOMdup(int t, ptr p)
{
	int len = ATOMlen(t, p);
	ptr n = GDKmalloc(len);

	memcpy(n, p, len);
	return n;
}

@* Builtin Atomic Operator Implementations

@+ Atom-from-String Conversions 
These routines convert from string to atom. They are used during 
conversion and BAT import. In order to avoid unnecessary malloc()/free()
sequences, the conversion functions have a meta 'dst' pointer to a
destination region, and an integer* 'len' parameter, that denotes the 
length of that region (a char region for ToStr functions, an atom region
from FromStr conversions). Only if necessary will the conversion
routine do a GDKfree()/GDKmalloc() sequence, and increment the 'len'.
Passing a pointer to a nil-ptr as 'dst' and/or a *len==0 is valid; the 
conversion function will then alloc some region for you.
@= atommem
	if (!*dst) {
		*dst = (@1 *) GDKmalloc(*len = @2);
	} else if (*len < (int) @2) {
		GDKfree(*dst);
		*dst = (@1 *) GDKmalloc(*len = @2);
	}
@= atomtostr
int
@1ToStr(char ** dst, int *len, @1 *src)
{
	@:atommem(char,@1Strlen)@
	if (*src == @1_nil) {
		strcpy(*dst, "nil");
		return 3;
	}
	snprintf(*dst, *len, @2, (@3) *src);
	return (int) strlen(*dst);
}
@c
#define num08(x)	((x) >= '0' && (x) <= '7')
#define num10(x)	GDKisdigit(x)
#define num16(x)	(GDKisdigit(x) || ((x)  >= 'a' && (x)  <= 'f') || ((x)  >= 'A' && (x)  <= 'F'))
#define base10(x)	((x) - '0')
#define base08(x)	((x) - '0')
#define base16(x)	(((x) >= 'a' && (x) <= 'f') ? ((x) - 'a' + 10) : ((x) >= 'A' && (x) <= 'F') ? ((x) - 'A' + 10) : (x) - '0')
#define mult08(x)	((x) << 3)
#define mult16(x)	((x) << 4)
#define mult10(x)	((x) + (x) + ((x) << 3))
#define mult7(x)	(((x) << 3) - (x))

int
voidFromStr(str src, int *len, void **dst)
{
	(void) src;
	(void) len;
	(void) dst;
	return 0;
}

int
voidToStr(str *dst, int *len, void *src)
{
	(void) src;
	@:atommem(char,3)@

	strcpy(*dst, "nil");
	return 3;
}

void *
voidRead(void *a, stream *s, size_t cnt)
{
	(void) s;
	(void) cnt;
	return a;
}

int
voidWrite(void *a, stream *s, size_t cnt)
{
	(void) a;
	(void) s;
	(void) cnt;
	return GDK_SUCCEED;
}

int
chrFromStr(char *src, int *len, chr **dst)
{
	unsigned char *p = (unsigned char *) src;
	unsigned int base = 0;
	int error = 0;

	@:atommem(chr,sizeof(chr))@

	while (GDKisspace(*p))
		p++;
	if (p[0] == 'n' && p[1] == 'i' && p[2] == 'l') {
		base = chr_nil;
		p += 3;
	} else if (p[0] != '\'' || p[1] == 0) {
		/* check for a UTF-8 byte-sequence without quotes. */
		int inc = 0;

		if (p[0] < 0xC0) {
			base = p[0];
			inc = (p[0] < 0x80);
		} else if (p[0] < 0xE0) {
			base = (p[0] - 0xC0) << 6;
			if (base && (p[1] & 0xC0) != 0x80) {
				base |= (p[1] & 0x3F);
				inc = 2;
			}
		} else if (p[0] < 0xF0) {
			base = (p[0] - 0xE0) << 12;
			if (base && (p[1] & 0xC0) != 0x80) {
				base |= (p[1] & 0x3F) << 6;
				if (base && (p[2] & 0xC0) != 0x80) {
					base |= (p[2] & 0x3F);
					inc = 3;
				}
			}
		} else {
			base = (p[0] - 0xF0) << 18;
			if ((p[1] & 0xC0) == 0x80) {
				base |= (p[1] & 0x3F) << 12;
				if (base && (p[2] & 0xC0) == 0x80) {
					base |= (p[2] & 0x3F) << 6;
					if (base && (p[3] & 0xC0) != 0x80) {
						base |= p[3] & 0x3F;
						inc = 4;
					}
				}
			}
		}
		/* notice we do parse large UTF-8 chars but return nil for them */
		error = (inc == 0 || base > 255);
		p += inc;
	} else {
		/* 'old' latin-1 chr between single quotes */
		if (p[1] == '\\' && num08(p[2])) {
			p += 2;
			while (error == 0) {
				base = mult08(base) + base08(*p);
				if (base >= 128)
					error = 1;
				p++;
				if (!num08(*p))
					break;
			}
		} else {
			base = p[1];
			p += 2;
		}
		if (*p != '\'') {
			error = 1;
			p = (unsigned char *) src;
		}
	}
	**dst = error ? chr_nil : (chr) base;
	return p - (unsigned char *) src;
}


int
chrToStr(str *dst, int *len, chr *src)
{
	@:atommem(char,chrStrlen)@

	if (*src == chr_nil) {
		strcpy(*dst, "nil");
		return 3;
	} else {
		str p = *dst;

		*p++ = '\'';
		if (*src & 0x80) {
			*p++ = 0xC0 | ((*src >> 6) & 0x3);
			*p++ = 0x80 | (*src & 0x3F);
			*p++ = '\'';
			*p = 0;
		} else {
			if (0 <= *src && *src < ' ') {
				snprintf(p, chrStrlen - 3,
					 "\\%03o", * (unsigned char *) src);
				p += 4;
			} else if (*src == '\\' || *src == '\'') {
				*p++ = '\\';
				*p++ = *src;
			} else {
				*p++ = *src;
			}
			*p++ = '\'';
			*p = 0;
		}
		return (int) (p - *dst);
	}
	return 1;
}

chr *
chrRead(chr *a, stream *s, size_t cnt)
{
	stream_read(s, (char *) a, 1, cnt);
	return stream_errnr(s) ? NULL : a;
}

int
chrWrite(chr *a, stream *s, size_t cnt)
{
	if (stream_write(s, (char *) a, 1, cnt) == (ssize_t) cnt)
		return GDK_SUCCEED;
	else
		return GDK_FAIL;
}

int
bitFromStr(str src, int *len, bit **dst)
{
	char *p = src;

	@:atommem(bit,sizeof(bit))@

	while (GDKisspace(*p))
		p++;
	**dst = bit_nil;
	if (*p == '0') {
		**dst = FALSE;
		p++;
	} else if (*p == '1') {
		**dst = TRUE;
		p++;
	} else if (p[0] == 't' && p[1] == 'r' && p[2] == 'u' && p[3] == 'e') {
		**dst = TRUE;
		p += 4;
	} else if (p[0] == 'f' && p[1] == 'a' && p[2] == 'l' && p[3] == 's' && p[4] == 'e') {
		**dst = FALSE;
		p += 5;
	} else if (p[0] == 'n' && p[1] == 'i' && p[2] == 'l') {
		p += 3;
	}
	return (int) (p - src);
}

int
bitToStr(char **dst, int *len, bit *src)
{
	@:atommem(char,6)@

	if (*src == chr_nil) {
		strcpy(*dst, "nil");
		return 3;
	} else if (*src) {
		strcpy(*dst, "true");
		return 4;
	}
	strcpy(*dst, "false");
	return 5;
}

bit *
bitRead(bit *a, stream *s, size_t cnt)
{
	stream_read(s, (char *) a, 1, cnt);
	return stream_errnr(s) ? NULL : a;
}

int
bitWrite(bit *a, stream *s, size_t cnt)
{
	if (stream_write(s, (char *) a, 1, cnt) == (ssize_t) cnt)
		return GDK_SUCCEED;
	else
		return GDK_FAIL;
}

int
batFromStr(char *src, int *len, bat **dst)
{
	char *s, *t, *r = src;
	int c, sign = 1;
	bat bid;

	@:atommem(bat,sizeof(bat))@

	while (GDKisspace(*r))
		r++;
	if (*r == '<')
		r++;
	if (*r == '~') {
		r++;
		sign = -1;
	}
	t = r;
	while ((c = *t) && (c == '_' || GDKisalnum(c)))
		t++;
	s = (char *) alloca((unsigned) (1 + t - r));
	strncpy(s, r, t - r);
	s[t - r] = 0;
	bid = BBPindex(s);
	**dst = bid == 0 ? bat_nil : sign * bid;
	return (int) (t + (c == '>') - src);
}

int
batToStr(char **dst, int *len, bat *src)
{
	bat b = *src;
	int i;
	str s;

	if (b == bat_nil || (s = BBPname(b)) == NULL || *s == 0) {
		@:atommem(char,4)@

		strcpy(*dst, "nil");
		return 3;
	}
	i = (int) (strlen(s) + 4);
	@:atommem(char,i)@

	snprintf(*dst, *len, "<%s%s>", b < 0 ? "~" : "", s);
	return (int) strlen(*dst);
}

bat *
batRead(bat *a, stream *s, size_t cnt)
{
	stream_readIntArray(s, (int *) a, cnt);	/* bat==int */
	return stream_errnr(s) ? NULL : a;
}

int
batWrite(bat *a, stream *s, size_t cnt)
{
	/* bat==int */
	return stream_writeIntArray(s, (int *) a, cnt) ? GDK_SUCCEED : GDK_FAIL;
}


@= numfromstr
int
@1FromStr(char* src, int * len, @1 **dst)
{
	int sign = 1, error = 0;
	@1 base = 0;
	str q, p = src;

	@:atommem(@1,sizeof(@1))@
	while (GDKisspace(*p))
		p++; 
	if (p[0] == 'n' && p[1] == 'i' && p[2] == 'l') {
		base = @1_nil; p += 3;
	} else {
		if (*p == '-' || *p == '+') {
			if (*p++ == '-')
				sign = -1;
		}
		if (!num10(*p)) {
			error = 1;
			p = src;
		}
		while (*p == '0')
			p++;
		for (q = p; num10(*p); p++) {
			base = mult10(base) + base10(*p);
		}
		if (p - q > @2 || (p - q == @2 && strncmp(q, "@3", @2) > 0)) {
			error = 1; /* overflow */
		}
		if (sizeof(@1) == 8 && p[0] == 'L' && p[1] == 'L') {
			p += 2;
		}
	}
	**dst = error ? @1_nil : sign * base;
	return (int) (p - src);
}
@c

@= atom_io
 @1 *@1Read(@1 *a, stream *s, size_t cnt)
{
	stream_read@2Array(s, (@3*)a, cnt);
	return stream_errnr(s) ? NULL : a;
}
int @1Write(@1 *a, stream *s, size_t cnt)
{
	return stream_write@2Array(s, (@3*)a, cnt) ? GDK_SUCCEED : GDK_FAIL;
}
@c

@:numfromstr(sht,5,32767)@
@:atomtostr(sht,"%hd",sht)@
@:atom_io(sht,Sht,sht)@

@:numfromstr(int,10,2147483647)@
@:atomtostr(int,"%d",int)@
@:atom_io(int,Int,int)@

@:numfromstr(lng,19,9223372036854775807)@
@:atomtostr(lng,LLFMT,lng)@

@c
@:atom_io(lng,Lng,lng)@

@
int
lngToStr(char **dst, int *len, lng *src)
{
	char *p;
	int l=0;
   
	@:atommem(char,lngStrlen)@
	if (*src == lng_nil) {
		strcpy(*dst, "nil");
		return 3;
	} 
	sprintf(*dst, LLFMT, *src);
	return strlen(*dst);
}
@c
int
ptrFromStr(char *src, int *len, ptr **dst)
{
	int error = 0;
	size_t base = 0;
	str p = src;

	@:atommem(ptr,sizeof(ptr))@

	while (GDKisspace(*p))
		p++;
	if (p[0] == 'n' && p[1] == 'i' && p[2] == 'l') {
		error = 1;
		p += 3;
	} else {
		if (p[0] == '0' && (p[1] == 'x' || p[1] == 'X')) {
			p += 2;
		}
		if (!num16(*p)) {
			error = 1;
			p = src;
		}
		while (error == 0) {
			size_t val = mult16(base) + base16(*p);

			if (val < base)
				error = 1;
			base = val;
			p++;
			if (!num16(*p))
				break;
		}
	}
	**dst = error ? ((ptr) ptr_nil) : ((ptr) base);
	return (int) (p - src);
}
@:atomtostr(ptr,SZFMT,size_t)@

#if SIZEOF_VOID_P == SIZEOF_INT
@:atom_io(ptr,Int,int)@
#else /* SIZEOF_VOID_P == SIZEOF_LNG */
@:atom_io(ptr,Lng,lng)@
#endif

int
dblFromStr(char *src, int *len, dbl **dst)
{
	char *p = src;
	double d;

	/* alloc memory */
	@:atommem(dbl,sizeof(dbl))@

	/* on overflow, strtod returns HUGE_VAL and sets errno to
	   ERANGE; on underflow, it returns 0 and also sets errno to
	   ERANGE.  We accept 0, but not HUGE_VAL. */
	errno = 0;
	d = strtod(src, &p);
	if (p == src || (errno == ERANGE && d != 0)) {
		**dst = dbl_nil;	/* default return value is nil */
		p = src;
	} else {
		**dst = (dbl) d;
	}
	return (int) (p - src);
}
@:atomtostr(dbl,"%.17g",double)@
@:atom_io(dbl,Lng,lng)@

#if HAVE_STRTOF && !HAVE_DECL_STRTOF
extern float strtof(const char *, char **);
#endif

int
fltFromStr(char *src, int *len, flt **dst)
{
#ifdef HAVE_STRTOF
	char *p = src;
#endif
	int n = 0;
	float f;

	/* alloc memory */
	@:atommem(flt,sizeof(flt))@

#ifdef HAVE_STRTOF
	/* on overflow, strtof returns HUGE_VALF and sets errno to
	   ERANGE; on underflow, it returns 0 and also sets errno to
	   ERANGE.  We accept 0, but not HUGE_VALF. */
	errno = 0;
	f = strtof(src, &p);
	n = (int) (p - src);
	if (n == 0 || (errno == ERANGE && f != 0)
#ifdef INFINITY
	    || f == INFINITY
#endif
#ifdef NAN
#ifndef __PGI
	    || f == NAN
#endif
#endif
	    )
#else /* no strtof, try sscanf */
	if (sscanf(src, "%f%n", &f, &n) <= 0 || n <= 0
#ifdef INFINITY
	    || f == INFINITY
#endif
#ifdef NAN
#ifndef __PGI
	    || f == NAN
#endif
#endif
	    )
#endif
	{
		**dst = flt_nil;	/* default return value is nil */
		n = 0;
	} else {
		**dst = (flt) f;
	}
	return n;
}

@:atomtostr(flt,"%.9g",float)@
@:atom_io(flt,Int,int)@

@}

@+ String Atom Implementation
The Built-in type string is partly handled in an atom extension
library. The main reason is to limit the number of built-in types
in the BAT library kernel. Moreover, an extra indirection for a string is less
harmful than for manipulation of, e.g. an int.

The internal representation of strings is without escape sequences.
When the string is printed we should add the escapes back into it.

The current escape policy is that single- and double-quote can be prepended by a
backslash. Furthermore, the backslash may be followed by three
octal digits to denote a character.

@- Automatic Double Elimination

Because in many typical situations lots of double string values occur
in tables, the string insertion provides automatic double elimination.
To do this, a GDK_STRHASHTABLE(=1024) bucket hashtable is hidden in the first 
4096 (8192 on 64-bit architectures) bytes of the string heap, consisting of integer offsets of the first 
string hashing to that bucket in the heap. Furthermore, the first 4(8) bytes 
before each string in the heap is an integer offset to the next string hashing 
to the same number.

However, in many other situations the cardinality of string columns is large,
or the string values might even be unique. In those cases, our fixed-size hash 
table will start to overflow quickly. Therefore, after the hash table is full
(this is measured very simplistically by looking whether the string heap exceeds a 
heap size = GDK_ELIMLIMIT -- done this way to keep compatibility with old bat images) 
we flush the hash table. If one views the string heaps as consecutive chunks
of size GDK_ELIMLIMIT bytes, then all strings within one chunk are double-eliminated.
There is a macro GDK_ELIMBASE(offset) that computes the base of the chunk in which
a certain byte-offset falls.
@-
This is a departure from our previous policy of not looking at the hash tables at 
all after overflow occurred. The advantage of the new approach is that if we have 
a value distribution that is skewed (ie some values are very frequent), these 
values will always be double eliminated, saving a considerable amount of space. 
Disadvantage of the approach is that we always have to reserve space for the next 
pointer (4(8) byte integer offset) that is stored right in front of the string (and 
consequently have to keep all string chunks and offsets aligned to 4(8)). All this 
translates into some wasted space. However, if there are that many different strings 
that the hash table overflows, the strings must be relatively long and the relative 
storage overhead should be low.
@-
Notice that this mechanism enables to keep a certain linear storage property
in the string heaps. This is important if we want to take a BATslice on a BAT
by simply loading or @strong{mmap()}ping slices of the BAT files on disk into memory.
This is relevant in order to process a very large BAT iteratively by taking slices
in order to reduce memory consumption. Notice that if there are few different string 
values, the hash table has not overflowed, and the string heap size will be small 
(i.e. < GDK_ELIMLIMIT), so in those cases it is not a problem to load the entire string heap.
If the hash table @strong{has} overflowed, we want to be able to only map a slice of the 
string heap as well. Now, given that the first string in the BAT-slice is called F1 
and its heap offset is O1 and the last string in the slice is F2 and its 
offset is O2, then the slice we should take from the string heap is: 
@example
GDK_ELIMBASE(F1) .. MAX(GDK_ELIMBASE(F2)+GDK_ELIMLIMIT), O2+strlen(F2))
@end example
The routine strElimDoubles() can be used to check whether all 
strings are still being double-eliminated in the original hash-table.
Only then we know that unequal offset-integers in the BUN array means
guaranteed different strings in the heap. This optimization is made at some 
points in the GDK. Make sure you check GDK_ELIMDOUBLES before assuming this!
@{
@c
int
strElimDoubles(Heap *h)
{
	return GDK_ELIMDOUBLES(h);
}

@}
@- String Comparison, NILs and UTF-8

Using the char* type for strings is handy as this is the type of any 
constant strings 
in a C/C++ program. Therefore, MonetDB uses this definition for @%str@. 
However, different compilers and platforms use either signed or unsigned 
characters for the @%char@ type.
It is required that string ordering in MonetDB is consistent over 
platforms though.

As for the choice how strings should be ordered, our support for UTF-8 actually imposes that it
should follow `unsigned char' doctrine (like in the AIX native compiler). In this semantics, though
we have to take corrective action to ensure that str(nil) is the smallest value of the domain.
@{
@h
#define GDK_STRNIL(s)    ((s) == NULL || *(chr*) (s) == GDK_chr_min)
#define GDK_STRLEN(s)    ((GDK_STRNIL(s)?1:strlen(s))+1)
#define GDK_STRCMP(l,r)  (GDK_STRNIL(l)?(GDK_STRNIL(r)?0:-1):GDK_STRNIL(r)?1: \
			  (*(unsigned char*)(l) < *(unsigned char*)(r))?-1: \
			  (*(unsigned char*)(l) > *(unsigned char*)(r))?1: \
			  strCmpNoNil((unsigned char*)(l),(unsigned char*)(r)))
@c
int
strNil(str s)
{
	return GDK_STRNIL(s);
}

int
strLen(const char *s)
{
	return (int) GDK_STRLEN(s);
}

int
strCmp(str l, str r)
{
	return GDK_STRCMP(l, r);
}

int
strCmpNoNil(unsigned char *l, unsigned char *r)
{
	while (*l == *r) {
		if (*l == 0)
			return 0;
		l++;
		r++;
	}
	return (*l < *r) ? -1 : 1;
}

void
strHeap(Heap *d, size_t cap)
{
	size_t size;
	var_t *h, *e;

	cap = MAX(cap, BATTINY);
	size = (GDK_STRHASHTABLE + 1) * sizeof(var_t) + MIN(GDK_ELIMLIMIT, cap * 12);
	if (HEAPalloc(d, size, 1) >= 0) {
		d->free = GDK_STRHASHTABLE * sizeof(var_t);
		h = (var_t *) d->base;
		for (e = h; e < h + GDK_STRHASHTABLE; e++) {
			*e = 0;
		}
	}
}


@- Hash Function 
@T
The string hash function is a very simple hash function that xors and 
rotates all characters together. 

@h
#define GDK_ROTATE(x,y,z,m) ((((x) << (y)) & ~(m)) | (((x) >> (z)) & (m)))

@c
#define GDK_STRHASH(x,y) {						\
		str _s = (str) (x);					\
		for((y)=0; *_s; _s++) {					\
			(y) = GDK_ROTATE(y, 4, SIZEOF_OID*8-4, 15) ^ *_s; \
		}							\
	}

hash_t
strHash(str s)
{
	hash_t res;

	GDK_STRHASH(s, res);
	return res;
}

@- 
The @%strPut@ routine. The routine @%strLocate@ can be used to identify
the location of a string in the heap if it exists. Otherwise it returns
zero.
@c
var_t
strLocate(Heap *h, str v)
{
	var_t *htab = (var_t *) h->base;
	var_t *l, *e = htab + (strHash(v) & GDK_STRHASHMASK);

	if (*e) {
		for (l = e; *l && *l < h->free; l = (var_t *) ((char *) h->base + *l)) {
			str x = (str) ((char *) h->base + *l + sizeof(var_t));

			if (GDK_STRCMP(v, x) == 0) {
				return *l + (var_t) sizeof(var_t);
			}
		}
	}
	return 0;
}

/* convert the integers in the implicit hash table structure */
void
strHeapConvert(Heap *h, int dir)
{
	var_t *htab = (var_t *) h->base;
	var_t *l, i, j;

	if (dir == CONV_HTON) {
		for (i = 0; i < GDK_STRHASHTABLE; i++) {
			for (l = htab + i; (j = *l) != 0 && j < h->free; l = (var_t *) (h->base + j)) {
				*l = normal_vart_SWAP(j);
			}
		}
	} else {
		for (i = 0; i < GDK_STRHASHTABLE; i++) {
			for (l = htab + i; (j = *l) != 0 && j < h->free; l = (var_t *) (h->base + *l)) {
				*l = normal_vart_SWAP(j);
			}
		}
	}
}

var_t
strPut(Heap *h, var_t *dst, str v)
{
	var_t *l;
	size_t i = GDK_STRLEN(v);
	hash_t off;

	/* round up to var_t-byte alignment + var_t (next pointer) */
	size_t len = ((i + sizeof(var_t) - 1) & ~(sizeof(var_t) - 1)) + sizeof(var_t);
	size_t elimlimit = GDK_ELIMBASE(h->free) + GDK_ELIMLIMIT;

	/* search hash-table, if double-elimination is still in place */
	off = strHash(v) & GDK_STRHASHMASK;
	for (l = ((var_t *) h->base) + off; *l && *l < h->free; l = (var_t *) (h->base + *l)) {
		str x = (str) (h->base + *l + sizeof(var_t));

		if (GDK_STRCMP(v, x) == 0) {
			*dst = *l + (var_t) sizeof(var_t);	/* already in heap; do not insert! */
			return *dst;
		}
	}

	/* flush the hash table if it becomes too big (implies !GDK_ELIMDOUBLES) */
	if (h->free + len >= elimlimit) {
		memset(h->base, 0, GDK_STRHASHSIZE);
	}

	/* check heap for space (limited to a certain maximum after which nils are inserted) */
	if (h->free + len >= h->size) {
		/* Something really strange happens here, In a special case
		   (Pentium II Klamath, gcc version 2.96 20000731,
		   GNU assembler version 2.10.90 using BFD version 2.10.0.18)
		   the fldl instruction to load BATMARGIN goes SOMETIMES
		   (but reproducable) wrong (the register is filled with
		   -NaN iso 1.5 (BATMARGIN)). So replaced this code:
		   size_t newsize = len + h->size * BATMARGIN;
		 */
		float batmargin = (float) BATMARGIN;
		float hnewsize = h->size * batmargin;
		size_t newsize = len + (size_t) hnewsize;

		assert(newsize);

		if (h->free + len < h->maxsize) {
			/* if there is reserved space, first use the reserved space */
			newsize = MIN(newsize, h->maxsize);
		}
		if (HEAPextend(h, newsize) < 0) {
			return 0;
		}
	}

	/* insert string in hash table and copy into the heap */
	l = (var_t *) (h->base + h->free);
	*(l++) = ((var_t *) h->base)[off];
	((var_t *) h->base)[off] = h->free;
	*dst = h->free + sizeof(var_t);
	h->free += len;
	memcpy((char *) l, v, i);

	return *dst;
}

@-
Convert an "" separated string to a GDK string value, checking that the input is correct UTF-8.
@c

/*
   UTF-8 encoding is as follows:
U-00000000 - U-0000007F: 0xxxxxxx
U-00000080 - U-000007FF: 110xxxxx 10xxxxxx
U-00000800 - U-0000FFFF: 1110xxxx 10xxxxxx 10xxxxxx
U-00010000 - U-001FFFFF: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
U-00200000 - U-03FFFFFF: 111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
U-04000000 - U-7FFFFFFF: 1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
*/
/* To be correctly coded UTF-8, the sequence should be the shortest
   possible encoding of the value being encoded.  This means that for
   an encoding of length n+1 (1 <= n <= 5), at least one of the bits in
   utf8chkmsk[n] should be non-zero (else the encoding could be
   shorter).
*/
static int utf8chkmsk[] = {
	0x0000007f,
	0x00000780,
	0x0000f800,
	0x001f0000,
	0x03e00000,
	0x7c000000,
};

int
GDKstrFromStr(unsigned char *dst, unsigned char *src, int len)
{
	unsigned char *p = dst, *cur = src, *end = src + len;
	int escaped = FALSE, mask = 0, n, c, utf8char = 0;

	/* copy it in, while performing the correct escapes */
	/* n is the number of follow-on bytes left in a multi-byte
	   UTF-8 sequence */
	for (cur = src, n = 0; cur < end || escaped; cur++) {
		/* first convert any \ escapes and store value in c */
		if (escaped) {
			if (*cur == 'n') {
				c = '\n';
			} else if (*cur == 't') {
				c = '\t';
			} else if ((cur[0] >= '0' && cur[0] <= '3') && (cur[1] >= '0' && cur[1] <= '7') && (cur[2] >= '0' && cur[2] <= '7')) {
				c = ((cur[0] & 7) << 6) | ((cur[1] & 7) << 3) | (cur[2] & 7);
				cur += 2;
			} else {
				c = *cur;
			}
			escaped = FALSE;
		} else if (*cur == '\\') {
			escaped = TRUE;
			continue;
		} else {
			c = *cur;
		}
		if (n > 0) {
			/* we're still expecting follow-up bytes in a
			   UTF-8 sequence */
			if ((c & 0xC0) != 0x80) {
				/* incorrect UTF-8 sequence: byte is
				   not 10xxxxxx */
				return -1;
			}
			utf8char = (utf8char << 6) | (c & 0x3F);
			n--;
			if (n == 0) {
				/* this was the last byte in the sequence */
				if ((utf8char & mask) == 0) {
					/* incorrect UTF-8 sequence:
					   not shortest possible */
					return -1;
				}
			}
		} else if (c >= 0x80) {
			int m;

			/* start of multi-byte UTF-8 character */
			for (n = 0, m = 0x40; c & m; n++, m >>= 1)
				;
			/* n now is number of 10xxxxxx bytes that should follow */
			if (n == 0 || n >= 6) {
				/* incorrect UTF-8 sequence */
				/* n==0: c == 10xxxxxx */
				/* n>=6: c == 1111111x */
				return -1;
			}
			mask = utf8chkmsk[n];
			/* collect the Unicode code point in utf8char */
			utf8char = c & ~(0xFFC0 >> n);	/* remove non-x bits */
		}
		*p++ = c;
	}
	if (n > 0) {
		/* incomplete UTF-8 sequence */
		return -1;
	}
	*p++ = 0;
	return len;
}

int
strFromStr(char *src, int *len, char **dst)
{
	unsigned char *p, *start = NULL, *cur = (unsigned char *) src;
	int res, l = 1, escaped = FALSE;

	while (GDKisspace(*cur))
		cur++;
	if (*cur != '"') {
		if (*dst != NULL && *dst != str_nil) {
			GDKfree(*dst);
		}
		*dst = GDKstrdup(str_nil);
		*len = 2;
		return strncmp((char *) cur, "nil", 3) ? 0 : (int) (((char *) cur + 3) - src);
	}

	/* scout the string to find out its length and whether it was properly quoted */
	for (start = ++cur; *cur != '"' || escaped; cur++) {
		if (*cur == 0) {
			goto error;
		} else if (*cur == '\\' && escaped == FALSE) {
			escaped = TRUE;
		} else {
			escaped = FALSE;
			l++;
		}
	}

	/* alloc new memory */
	p = (unsigned char *) *dst;
	if (p != NULL && (char *) p != str_nil && *len < l) {
		GDKfree(p);
		p = NULL;
	}
	if (p == NULL || (char *) p == str_nil)
		p = GDKmalloc(*len = l);
	*dst = (char *) p;

	if ((res = GDKstrFromStr((unsigned char *) *dst, start, cur - start)) >= 0)
		return res;

  error:
	if (*dst && *dst != str_nil)
		GDKfree(*dst);
	*dst = GDKstrdup(str_nil);
	*len = 2;
	return 0;
}

@-
Convert a GDK string value to something printable.
@c
/*
#define allowed_chr(ch) ((ch)==0 || GDKisgraph((ch)) || GDKisspace((ch)) || \
		         GDKisspecial((ch)) || GDKisupperl((ch)) || GDKislowerl((ch)))
*/
#define allowed_chr(ch)	(!(0 < (ch) && (ch) < 32) && (ch) != '\377')

int
strToStr(char **dst, int *len, char *src)
{
	int l = 1;

	if (GDK_STRNIL((str) src)) {
		@:atommem(char,4)@

		strcpy(*dst, "nil");
		return 3;
	} else {
		char *s, *r = (char *) src;
		int cur = 0, end, sz = 0;

		for (end = 0; src[end]; end++)
			if (src[end] == '\t' || src[end] == '\n' || src[end] == '\\' || src[end] == '"') {
				sz += 2;
			} else if (!allowed_chr(src[end])) {
				sz += 4;
			} else {
				sz++;
			}
		@:atommem(char,sz+3)@

		for (s = *dst; cur < end; cur++)
			if (r[cur] == '\t') {
				s[l++] = '\\';
				s[l++] = 't';
			} else if (r[cur] == '\n') {
				s[l++] = '\\';
				s[l++] = 'n';
			} else if (r[cur] == '\\') {
				s[l++] = '\\';
				s[l++] = '\\';
			} else if (r[cur] == '"') {
				s[l++] = '\\';
				s[l++] = '"';
			} else if (!allowed_chr(r[cur])) {
				sprintf(s + l, "\\%03o", (unsigned char) r[cur]);
				l += 4;
			} else {
				s[l++] = r[cur];
			}
		s[0] = s[l++] = '"';
		s[l] = 0;
	}
	return l;
}

str
strRead(str a, stream *s, size_t cnt)
{
	int len;

	(void) cnt;
	assert(cnt == 1);
	if (!stream_readInt(s, &len))
		return NULL;
	if ((a = GDKmalloc(len + 1)) == NULL)
		return NULL;
	if (len && stream_read(s, a, len, 1) != 1) {
		GDKfree(a);
		return NULL;
	}
	a[len] = 0;
	return a;
}

int
strWrite(str a, stream *s, size_t cnt)
{
	size_t len = strlen(a);

	(void) cnt;
	assert(cnt == 1);
	if (stream_writeInt(s, (int) len) && stream_write(s, a, len, 1) == 1)
		return GDK_SUCCEED;
	else
		return GDK_FAIL;
}

@+ Unique OIDs
The basic type OID represents unique values. Refinements should be
considered to link oids in time order.

Values start from the "seqbase" (usually 0@@0). A nil seqbase makes the 
entire column nil.  Monet's BUN accessmethods BUNhead(b,p)/BUNtail(b,p) 
instantiate a value on-the-fly by looking at the position p in BAT b.
@c
@{
oid	GDKoid, GDKflushed;
@-
Init the shared array of oid bases.
@c
int
OIDinit(void)
{
	GDKflushed = GDKoid = 0;
	return 0;
}

@-
Make up some new OID for a specified database, based on the current time.
@c
oid
OIDrand(void)
{
	return 1000000;
}

@-
Initialize the current OID number to be starting at 'o'. 
@c
oid
OIDbase(oid o)
{
	gdk_set_lock(MT_system_lock, "OIDbase");
	GDKoid = o;
	gdk_unset_lock(MT_system_lock, "OIDbase");
	return o;
}

oid
OIDseed(oid o)
{
	oid t, p = GDKoid;

	gdk_set_lock(MT_system_lock, "OIDseed");
	t = OIDrand();
	if (o > t)
		t = o;
	if (p >= t)
		t = p;
	gdk_unset_lock(MT_system_lock, "OIDseed");
	return t;
}

@-
Initialize a sequence of OID seeds (for a sequence of database)
as stored in a string.
@c
oid
OIDread(str s)
{
	oid new = 0, *p = &new;
	int l = sizeof(oid);

	while (GDKisspace(*s))
		s++;
	while (GDKisdigit(*s)) {
		s += OIDfromStr(s, &l, &p);
		while (GDKisspace(*s))
			s++;
		new = OIDseed(new);
	}
	return new;
}

@-
Write the current sequence of OID seeds to a file in string format.
@c
int
OIDwrite(stream *s)
{
	int ret = 0;

	gdk_set_lock(MT_system_lock, "OIDwrite");
	if (GDKoid) {
		GDKflushed = GDKoid;
		ATOMprint(TYPE_oid, &GDKflushed, s);
		if (stream_errnr(s) || stream_write(s, " ", 1, 1) <= 0)
			ret = -1;
	}
	gdk_unset_lock(MT_system_lock, "OIDwrite");
	return ret;
}

int
OIDdirty(void)
{
	if (GDKoid && GDKoid > GDKflushed) {
		return TRUE;
	}
	return FALSE;
}

@-
Reserve a range of unique OIDs 
@c
oid
OIDnew(size_t inc)
{
	oid ret;

	gdk_set_lock(MT_system_lock, "OIDnew");
	if (!GDKoid)
		GDKoid = OIDrand();
	ret = GDKoid;
	GDKoid += inc;
	gdk_unset_lock(MT_system_lock, "OIDnew");
	return ret;
}

@-
String conversion routines. 
@c
int
OIDfromStr(char *src, int *len, oid **dst)
{
#if SIZEOF_OID == SIZEOF_INT
	int ui, *uip = &ui;
	int l = (int) sizeof(int);
#else
	lng ui, *uip = &ui;
	int l = (int) sizeof(lng);
#endif
	int pos = 0;
	str p = src;

	@:atommem(oid,sizeof(oid))@

	**dst = oid_nil;
	while (GDKisspace(*p))
		p++;
	if (GDKisdigit(*p)) {
#if SIZEOF_OID == SIZEOF_INT
		pos = intFromStr(p, &l, &uip);
#else
		pos = lngFromStr(p, &l, &uip);
#endif
		if (pos > 0 && p[pos] == '@') {
			while (GDKisdigit(p[pos]))
				pos++;
		}
		if (pos > 0 && ui >= 0) {
			**dst = ui;
		}
		p += pos;
	}
	return (int) (p - src);
}

int
OIDtoStr(char **dst, int *len, oid *src)
{
	@:atommem(char,oidStrlen)@

	if (*src == oid_nil) {
		strcpy(*dst, "nil");
		return 3;
	}
	snprintf(*dst, *len, SZFMT "@0", (size_t) * src);
	return (int) strlen(*dst);
}

@-
Sometimes a bat descriptor is loaded before the dynamic module defining
the atom is loaded. To support this an extra set of unknown atoms is kept.
These can be accessed via the ATOMunknown interface. Adding atoms to this
set is done via the ATOMunknown_add function. Finding an (negative) atom index
can be done via ATOMunknown_find, which simply adds the atom if its not in
the unknown set. The index van be used to find the name of an unknown 
ATOM via ATOMunknown_name. Once an atom becomes known, ie the module 
defining it is loaded, it should be removed from the unknown set using
ATOMunknown_del. 

@h
extern int ATOMunknown_add( str nme );
extern int ATOMunknown_del( int a );
gdk_export int ATOMunknown_find( str nme );
extern str ATOMunknown_name( int a );

@c
static str unknown[MAXATOMS] = { NULL };

int 
ATOMunknown_add( str nme ) 
{
	int i = 1;
	for (;i<MAXATOMS; i++) {
		if (!unknown[i]) {
			unknown[i] = GDKstrdup(nme);
			return -i;
		}
	}
	assert(0);
	return 0;
}

int
ATOMunknown_del( int i) 
{
	assert(unknown[-i]);
	GDKfree(unknown[-i]);
	unknown[-i] = NULL;
	return 0;
}

int
ATOMunknown_find( str nme ) 
{
	int i = 1;
	for (;i<MAXATOMS; i++) {
		if (unknown[i] && strcmp(unknown[i], nme) == 0) {
			return -i;
		}
	}
	return ATOMunknown_add(nme);
}

str
ATOMunknown_name( int i )
{
	assert(unknown[-i]);
	return unknown[-i];
}
@
@}

@h
#endif /* _GDK_ATOMS_H_ */

