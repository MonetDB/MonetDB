@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f gdk_system
@a Niels Nes, Peter Boncz
@+ Threads
This file contains the threads implementation based on the Posix 
thread library interface, consisting of Posix standard thread 
functions. 
@{
@- Pthread Definitions
@h
#ifndef _GDK_SYSTEM_H_
#define _GDK_SYSTEM_H_

#ifdef NATIVE_WIN32
#ifndef LIBGDK
#define gdk_export extern __declspec(dllimport)
#else
#define gdk_export extern __declspec(dllexport)
#endif
#else
#define gdk_export extern
#endif

#ifdef HAVE_UNISTD_H
# include <unistd.h>		/* io functions */
#endif
#ifdef HAVE_IO_H
# include <io.h>
#endif
#ifdef HAVE_FCNTL_H
#include <fcntl.h>
#endif

@- pthreads Includes and Definitions
@h
#include <sys/types.h>
#ifdef HAVE_SIGNAL_H
# include <signal.h>
#endif

typedef void *MT_Lock;
typedef void *MT_Sema;
typedef void *MT_Cond;
typedef size_t MT_Id;

#if SIZEOF_VOID_P == 4
/* "limited" stack size on 32-bit systems */
/* to avoid address space fragmentation   */
#define THREAD_STACK_SIZE	((size_t)  512*1024)
#else
/* "increased" stack size on 64-bit systems    */
/* since some compilers seem to require this   */
/* for burg-generated code in pathfinder       */
/* and address space fragmentation is no issue */
#define THREAD_STACK_SIZE	((size_t)4*512*1024)
#endif

#define MAXLOCKS	256
#define MAXSEMAS	64

@- Environment Specific Defines
Define your error reporting routine @%MT_error(str message)@.
@h
#define MT_error	GDKsyserror
#define MT_warning	GDKwarning
@-
Define your error integer debug flag @%MT_debug@.
@h
#define MT_debug	GDKdebug
gdk_export int GDKdebug;

@-
Define your debug printing stream @%MT_out@.
@h
gdk_export void *THRgetdata(int);

#define MT_out		stderr

@- Global Variables
The are part of the interface (i.e. you may use them).
@h
gdk_export MT_Lock MT_system_lock;	/* system administration lock */

@+ Interface Definition
The routines that are available for use for thread and process management.
@-
Init the package. Must be called once before any of the other operations.
@h
gdk_export void MT_init(void);

@-
Set which signals should be blocked, ignores  SIGQUIT, SIGALRM
@h
#ifdef HAVE_PTHREAD_SIGMASK
gdk_export void MT_thread_sigmask(sigset_t * new_mask, sigset_t * orig_mask);
#endif

@-
Create a new thread executing 'function' with single parameter 'arg'. 
May return an error, in which case no thread is created.
@h
gdk_export int MT_create_thread(MT_Id *t, void (*function) (void *), void *arg);

@-
Exit the current thread. The status will be ignored, unless some thread
wait()-s for you to finish.
a wait()
@h
gdk_export void MT_exit_thread(int status);

@-
Exit the process. All threads are terminated.
@h
gdk_export void MT_global_exit(int status);

@-
Ask your thread id.
@h
gdk_export MT_Id MT_getpid(void);


@-
Kill a thread.
@h
gdk_export int MT_kill_thread(MT_Id t);

@-
Destroy an inter-process lock;
@h
gdk_export void MT_destroy_lock(MT_Lock l);

@-
Create a new thread-lock. Initial status: unset.
@h
gdk_export MT_Lock MT_create_lock(void);

@-
Set a lock. The calling thread in this process blocks till the lock is set.
@h
gdk_export void MT_set_lock(MT_Lock l, char *name);

@-
Unset a lock.
@h
gdk_export void MT_unset_lock(MT_Lock l, char *name);

@-
Try a lock. Returns error (EBUSY) if the lock was already 
set. Else, the lock is set.
@h
gdk_export int MT_try_lock(MT_Lock l);

@-
Dump info about the lock named 'name' on stream 'fp'.
@h
gdk_export void MT_dump_lock(MT_Lock l, FILE *fp, char *name);

@- Mthreads Macro Implementations

@-
Create a counting thread semaphore, set the number of resources.
@h
gdk_export MT_Sema MT_create_sema(int nresources);


@-
Destroy a counting thread semaphore;
@h
gdk_export void MT_destroy_sema(MT_Sema s);

@-
Increment a semaphore.
@h
gdk_export void MT_up_sema(MT_Sema s, char *name);

@-
Decrement a semaphore. If it already has value 0, the thread is
blocked until a decrement is possible again.
@h
gdk_export void MT_down_sema(MT_Sema s, char *name);

@-
Try to decrement a semaphore. If it already has value 0, an error
(EBUSY) is returned. Else, the semaphore is decremented.
[obsolete] gdk_export int 	MT_try_sema(MT_Sema s);

@-
Dump info about the semaphore named 'name' on stream 'fp'.
@h
gdk_export void MT_dump_sema(MT_Sema s, FILE *fp, char *name);

@-
Create a thread condition variable.
@h
gdk_export MT_Cond MT_create_cond(void);

@-
Destroy a counting thread semaphore;
@h
gdk_export void MT_destroy_cond(MT_Cond c);

@-
Signal a condition variable.
@h
gdk_export void MT_signal_cond(MT_Cond c, char *name);

@-
Wait on the condition variable. This needs a lock to avoid race conditions
on the condition variable.
@h
gdk_export void MT_wait_cond(MT_Cond c, MT_Lock l, char *name);

@-
Check if some process is still alive.
@h
gdk_export int MT_alive(int pid);

@-
Allocate anonymous virtual memory.
@h
#define MT_geterrno()		errno
#define MT_seterrno(x)		errno=x

gdk_export size_t _MT_npages;
gdk_export size_t _MT_pagesize;

#define MT_pagesize()	_MT_pagesize
#define MT_npages()	_MT_npages

#endif /*_GDK_SYSTEM_H_*/


@- Mthreads Routine implementations
@c
#include "gdk.h"

#ifdef HAVE_PTHREAD_H
/* don't re-include config.h; on Windows, don't redefine pid_t in an
   incompatible way 
 */
#undef HAVE_CONFIG_H
#ifdef pid_t
#undef pid_t
#endif
#include <sched.h>
#include <pthread.h>
#ifndef WIN32
/* Linux gprof messes up on multithreaded programs */
#ifdef PROFILE
#define pthread_create gprof_pthread_create
#endif
#endif
#endif


#ifdef HAVE_SEMAPHORE_H
# include <semaphore.h>
#endif

/* new pthread interface, where the thread id changed to a struct */
#ifdef PTW32_VERSION
#define PTW32 1
#endif

#if !(defined(HAVE_SYSCONF) && defined(_SC_PHYS_PAGES)) && defined(HAVE_GETRLIMIT) && defined(HAVE_SYS_RESOURCE_H)
# include <sys/resource.h>
#endif

#if defined(_AIX) || defined(__APPLE_CC__)
typedef struct {
	int cnt;
	pthread_mutex_t mutex;
	pthread_cond_t cond;
} pthread_sema_t;
#else
#define pthread_sema_t sem_t
#endif

MT_Lock MT_system_lock = NULL;	/* system administration lock */

pthread_mutex_t MT_firstlock[MAXLOCKS];
pthread_sema_t MT_firstsema[MAXSEMAS];
pthread_cond_t MT_firstcond[MAXSEMAS];

int MT_curlock = 0, MT_nextlock[MAXLOCKS];
ptrdiff_t MT_cursema = 0, MT_nextsema[MAXSEMAS];
ptrdiff_t MT_curcond = 0, MT_nextcond[MAXSEMAS];

size_t _MT_pagesize = 0;	/* variable holding memory size */
size_t _MT_npages = 0;		/* variable holding page size */

void
MT_init(void)
{
	static pthread_mutex_t l;
	int i;

#ifdef HAVE_GETSYSTEMINFO
	{
		SYSTEM_INFO sysInfo;

		GetSystemInfo(&sysInfo);
		_MT_pagesize = sysInfo.dwPageSize;
	}
#else
#if defined(HAVE_SYSCONF) && defined(_SC_PAGESIZE)
	_MT_pagesize = sysconf(_SC_PAGESIZE);
#endif
#endif
	if (_MT_pagesize <= 0)
		_MT_pagesize = 4096;	/* default */

#ifdef HAVE_GLOBALMEMORYSTATUSEX
	{
		MEMORYSTATUSEX memStatEx;

		memStatEx.dwLength = sizeof(memStatEx);
		if (GlobalMemoryStatusEx(&memStatEx))
			_MT_npages = memStatEx.ullTotalPhys / _MT_pagesize;
	}
#endif
#ifdef HAVE_GLOBALMEMORYSTATUS
	if (_MT_npages <= 0) {
		MEMORYSTATUS memStat;

		GlobalMemoryStatus(&memStat);
		_MT_npages = memStat.dwTotalPhys / _MT_pagesize;
	}
#endif
#if defined(HAVE_SYSCONF) && defined(_SC_PHYS_PAGES)
	_MT_npages = sysconf(_SC_PHYS_PAGES);
#else
#ifdef HAVE_GETRLIMIT
	{
		struct rlimit rl;

		getrlimit(RLIMIT_RSS, &rl);
		_MT_npages = rl.rlim_cur / _MT_pagesize;
	}
#endif
#endif
	for (i = 1; i < MAXLOCKS; i++) {
		MT_nextlock[i - 1] = i;
	}
	MT_nextlock[MAXLOCKS - 1] = -1;

	for (i = 1; i < MAXSEMAS; i++) {
		MT_nextsema[i - 1] = (ptrdiff_t) i;
		MT_nextcond[i - 1] = (ptrdiff_t) i;
	}
	MT_nextsema[MAXSEMAS - 1] = (ptrdiff_t) -1;
	MT_nextcond[MAXSEMAS - 1] = (ptrdiff_t) -1;

	pthread_mutex_init(&l, 0);
	MT_system_lock = (MT_Lock) &l;
}

#ifdef HAVE_PTHREAD_SIGMASK
void
MT_thread_sigmask(sigset_t * new_mask, sigset_t * orig_mask)
{
	(void) sigdelset(new_mask, SIGQUIT);
	(void) sigdelset(new_mask, SIGALRM);	/* else sleep doesn't work */
	(void) pthread_sigmask(SIG_SETMASK, new_mask, orig_mask);
}
#endif

int
MT_create_thread(MT_Id *t, void (*f) (void *), void *arg)
{
#ifdef HAVE_PTHREAD_SIGMASK
	sigset_t new_mask, orig_mask;
#endif
	pthread_attr_t attr;
	pthread_t newt;
	int ret;

#ifdef HAVE_PTHREAD_SIGMASK
	(void) sigfillset(&new_mask);
	MT_thread_sigmask(&new_mask, &orig_mask);
#endif
	pthread_attr_init(&attr);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 4 * THREAD_STACK_SIZE);
	ret = pthread_create(&newt, &attr, (void *(*)(void *)) f, arg);
	if (ret == 0)
#ifdef PTW32
		*t = (MT_Id) (((size_t) newt.p) + 1);	/* use pthread-id + 1 */
#else
		*t = (MT_Id) (((size_t) newt) + 1);	/* use pthread-id + 1 */
#endif
#ifdef HAVE_PTHREAD_SIGMASK
	MT_thread_sigmask(&orig_mask, NULL);
#endif
	return ret;
}

void
MT_global_exit(int s)
{
	exit(s);
}


void
MT_exit_thread(int s)
{
	int st = s;

	pthread_exit(&st);
}


int
MT_kill_thread(MT_Id t)
{
#ifdef HAVE_PTHREAD_KILL
	thread_t id = (thread_t) (t - 1);

	return pthread_kill((pthread_t) id, SIGHUP);
#else
	(void) t;
	return -1;		/* XXX */
#endif
}

MT_Lock
MT_create_lock(void)
{
	pthread_mutex_t *new_mutex;

	MT_set_lock(MT_system_lock, "MT_create_lock");
	if (MT_curlock == -1) {
		fprintf(MT_out, "MT_create_lock: ran out of locks.\n");
		MT_global_exit(-1);
	}
	new_mutex = MT_firstlock + MT_curlock;
	MT_curlock = MT_nextlock[MT_curlock];
	MT_unset_lock(MT_system_lock, "MT_create_lock");
	pthread_mutex_init(new_mutex, 0);

	return (MT_Lock) new_mutex;
}


void
MT_destroy_lock(MT_Lock l)
{
	int idx = (int) (((pthread_mutex_t *) l) - MT_firstlock);

	if (l == NULL)
		return;
	pthread_mutex_destroy(l);
	MT_set_lock(MT_system_lock, "MT_destroy_lock");
	MT_nextlock[idx] = MT_curlock;
	MT_curlock = idx;
	MT_unset_lock(MT_system_lock, "MT_destroy_lock");
}

void
MT_set_lock(MT_Lock l, char *name)
{
	int t = 0;

	if (MT_debug & 1024) {
		fprintf(MT_out, "MT_set_lock(" SZFMT "\@%s) " PTRFMT " %d\n", (size_t) MT_getpid(), name, PTRFMTCAST(void *)l, t);

		fflush(MT_out);
	}
	(void) pthread_mutex_lock((pthread_mutex_t *) l);
}

void
MT_unset_lock(MT_Lock l, char *name)
{
	int t = 0;

	if (MT_debug & 1024) {
		fprintf(MT_out, "MT_unset_lock(" SZFMT "\@%s) " PTRFMT " %d\n", (size_t) MT_getpid(), name, PTRFMTCAST(void *)l, t);

		fflush(MT_out);
	}
	t = pthread_mutex_unlock((pthread_mutex_t *) l);
}

int
MT_try_lock(MT_Lock l)
{
	if (MT_debug & 1024) {
		fprintf(MT_out, "MT_try_lock:" SZFMT " " PTRFMT "\n", (size_t) MT_getpid(), PTRFMTCAST(void *)l);

		fflush(MT_out);
	}
	if (l == NULL)
		return 0;
	return pthread_mutex_trylock(l);
}


void
MT_dump_lock(MT_Lock l, FILE *fp, char *name)
{
	(void) l;
	fprintf(fp, "%s: MT_dump_lock() not implemented.\n", name);
}

#if defined(_AIX) || defined(__APPLE_CC__)
static void
pthread_sema_init(pthread_sema_t *s, int flag, int nresources)
{
	(void) flag;
	s->cnt = nresources;
	pthread_mutex_init(&(s->mutex), 0);
	pthread_cond_init(&(s->cond), 0);
}

static void
pthread_sema_destroy(pthread_sema_t *s)
{
	pthread_mutex_destroy(&(s->mutex));
	pthread_cond_destroy(&(s->cond));
}

static void
pthread_sema_post(pthread_sema_t *s)
{
	int status = pthread_mutex_lock(&(s->mutex));

	if (s->cnt++ < 0) {
		/* wackup sleeping thread */
		status = pthread_cond_signal(&(s->cond));
	}
	status = pthread_mutex_unlock(&(s->mutex));
}

static void
pthread_sema_wait(pthread_sema_t *s)
{
	int status = pthread_mutex_lock(&(s->mutex));

	if (--s->cnt < 0) {
		/* thread goes to sleep */
		status = pthread_cond_wait(&(s->cond), &(s->mutex));
	}
	status = pthread_mutex_unlock(&(s->mutex));
}
#else
#define pthread_sema_post	sem_post
#define pthread_sema_wait	sem_wait
#define pthread_sema_init	sem_init
#define pthread_sema_destroy	sem_destroy
#endif

void
MT_up_sema(MT_Sema s, char *name)
{
	(void) pthread_sema_post((pthread_sema_t *) s);
	if (MT_debug & 1024) {
		fprintf(MT_out, "MT_up_sema(" SZFMT "\@%s) " PTRFMT "\n", (size_t) MT_getpid(), name, PTRFMTCAST(void *)s);

		fflush(MT_out);
	}
}

void
MT_down_sema(MT_Sema s, char *name)
{
	(void) pthread_sema_wait((pthread_sema_t *) s);
	if (MT_debug & 1024) {
		fprintf(MT_out, "MT_down_sema(" SZFMT "\@%s) " PTRFMT "\n", (size_t) MT_getpid(), name, PTRFMTCAST(void *)s);

		fflush(MT_out);
	}
}

MT_Sema
MT_create_sema(int nresources)
{
	pthread_sema_t *new_sema;

	MT_set_lock(MT_system_lock, "MT_create_sema");
	if (MT_cursema == -1) {
		fprintf(MT_out, "MT_create_sema: ran out of semaphores.\n");
		MT_global_exit(-1);
	}
	new_sema = MT_firstsema + MT_cursema;
	MT_cursema = MT_nextsema[MT_cursema];
	MT_unset_lock(MT_system_lock, "MT_create_sema");

	(void) pthread_sema_init(new_sema, 0, nresources);
	return (MT_Sema) new_sema;
}


void
MT_destroy_sema(MT_Sema s)
{
	ptrdiff_t idx = ((pthread_sema_t *) s) - MT_firstsema;

	if (s == NULL)
		return;
	(void) pthread_sema_destroy(s);

	MT_set_lock(MT_system_lock, "MT_destroy_sema");
	MT_nextsema[idx] = MT_cursema;
	MT_cursema = idx;
	MT_unset_lock(MT_system_lock, "MT_destroy_sema");
}

void
MT_dump_sema(MT_Sema s, FILE *fp, char *name)
{
	(void) s;
	fprintf(fp, "%s: MT_dump_sema() not implemented.\n", name);
}

void
MT_signal_cond(MT_Cond c, char *name)
{
	(void) pthread_cond_signal((pthread_cond_t *) c);
	if (MT_debug & 1024) {
		fprintf(MT_out, "MT_signal_cond(" SZFMT "\@%s) " PTRFMT "\n", (size_t) MT_getpid(), name, PTRFMTCAST(void *)c);

		fflush(MT_out);
	}
}

void
MT_wait_cond(MT_Cond c, MT_Lock l, char *name)
{
	(void) pthread_cond_wait((pthread_cond_t *) c, (pthread_mutex_t *) l);
	if (MT_debug & 1024) {
		fprintf(MT_out, "MT_cond_wait(" SZFMT "\@%s) " PTRFMT PTRFMT "\n", (size_t) MT_getpid(), name, PTRFMTCAST(void *)c, PTRFMTCAST(void *)l);

		fflush(MT_out);
	}
}

MT_Cond
MT_create_cond()
{
	pthread_cond_t *new_cond;

	MT_set_lock(MT_system_lock, "MT_create_cond");
	if (MT_curcond == -1) {
		fprintf(MT_out, "MT_create_cond: ran out of condition.\n");
		MT_global_exit(-1);
	}
	new_cond = MT_firstcond + MT_curcond;
	MT_curcond = MT_nextcond[MT_curcond];
	MT_unset_lock(MT_system_lock, "MT_create_cond");

	(void) pthread_cond_init(new_cond, NULL);
	return (MT_Cond) new_cond;
}


void
MT_destroy_cond(MT_Cond c)
{
	ptrdiff_t idx = ((pthread_cond_t *) c) - MT_firstcond;

	if (c == NULL)
		return;
	(void) pthread_cond_destroy(c);

	MT_set_lock(MT_system_lock, "MT_destroy_cond");
	MT_nextcond[idx] = MT_curcond;
	MT_curcond = idx;
	MT_unset_lock(MT_system_lock, "MT_destroy_cond");
}


MT_Id
MT_getpid(void)
{
#ifdef PTW32
	return (MT_Id) (((size_t) pthread_self().p) + 1);
#else
	return (MT_Id) (((size_t) pthread_self()) + 1);
#endif
}

int
MT_alive(int pid)
{
#ifdef HAVE_KILL
	return kill(pid, 0) == 0;
#else
	(void)pid;
	return 0;
#endif
}

@}
@-
