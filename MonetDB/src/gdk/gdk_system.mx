@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.

@f gdk_system
@a Niels Nes, Peter Boncz
@+ Threads
@T
This file contains the threads implementation based on the posix 
thread library interface, consisting of posix standaard thread 
functions. 

@- Pthread Definitions
@h
#ifndef _GDK_SYSTEM_H_
#define _GDK_SYSTEM_H_

#ifdef _MSC_VER
#ifndef LIBGDK
#define gdk_export extern __declspec(dllimport) 
#else
#define gdk_export extern __declspec(dllexport) 
#endif
#else
#define gdk_export extern 
#endif

#ifdef HAVE_UNISTD_H
# include <unistd.h>     /* io functions */
#endif
#ifdef HAVE_IO_H
# include <io.h>
#endif
#ifdef HAVE_FCNTL_H
#include <fcntl.h>
#endif

@- pthreads Includes and Definitions
@h
#include <sys/types.h>
#ifdef HAVE_SIGNAL_H
# include <signal.h>
#endif

#ifdef HAVE_PTHREAD_H
/* don't re-include config.h; on Windows, don't redefine pid_t in an
   incompatible way 
 */
#undef HAVE_CONFIG_H
#ifdef pid_t
#undef pid_t
#endif
# include <pthread.h>
#endif

#ifdef HAVE_SEMAPHORE_H
# include <semaphore.h>
#endif

typedef void    *MT_Lock;
typedef void    *MT_Sema;
typedef size_t	MT_Id;

#define THREAD_STACK_SIZE	((size_t)512*1024)

#define MAXLOCKS	256
#define MAXSEMAS	64

@- Environment Specific Defines
Define your error reporting routine @%MT_error(str message)@.
@h
#define MT_error	GDKsyserror	
#define MT_warning	GDKwarning	
@-
Define your error integer debug flag @%MT_debug@.
@h
#define MT_debug	GDKdebug
gdk_export int GDKdebug;
@-
Define your debug printing stream @%MT_out@.
@h
gdk_export void *THRgetdata	(int);
#define MT_out		stderr

@- Global Variables
The are part of the interface (i.e. you may use them).
@h
gdk_export MT_Lock	MT_system_lock;	/* system administration lock */

@+ Interface Definition
The routines that are available for use for thread and process management.
@-
Init the package. Must be called once before any of the other operations.
@h
 gdk_export void 	MT_init (void);

@-
Set which signals should be blocked, ignores  SIGINT, SIGQUIT, SIGALRM
@h
#ifdef HAVE_PTHREAD_SIGMASK
gdk_export void MT_thread_sigmask( sigset_t *new_mask, sigset_t *orig_mask );
#endif

@-
Create a new thread executing 'function' with single parameter 'arg'. 
May return an error, in which case no thread is created.
@h
gdk_export int 	MT_create_thread(MT_Id *t, void (*function)(void *), void *arg);

@-
Exit the current thread. The status will be ignored, unless some thread
wait()-s for you to finish.
a wait()
@h
gdk_export void 	MT_exit_thread(int status);

@-
Exit the process. All threads are terminated.
@h
gdk_export void 	MT_global_exit(int status);

@-
Ask your thread id.
@h
gdk_export MT_Id 	MT_getpid(void);


@-
Kill a thread.
@h
gdk_export int 	MT_kill_thread(MT_Id t);

@-
Destroy an inter-process lock;
@h
gdk_export void	MT_destroy_lock(MT_Lock l);     

@-
Create a new thread-lock. Initial status: unset.
@h
gdk_export MT_Lock	MT_create_lock(void);

@-
Set a lock. The calling thread in this process blocks till the lock is set.
@h
gdk_export void 	MT_set_lock(MT_Lock l, char *name);
 
@-
Unset a lock.
@h
gdk_export void 	MT_unset_lock(MT_Lock l, char *name);
 
@-
Try a lock. Returns error (EBUSY) if the lock was already 
set. Else, the lock is set.
@h
gdk_export int	MT_try_lock(MT_Lock l);

@-
Dump info about the lock named 'name' on stream 'fp'.
@h
gdk_export void 	MT_dump_lock(MT_Lock l, FILE *fp, char *name);

@- Mthreads Macro Implementations

@-
Create a counting thread semaphore, set the number of resources.
@h
gdk_export MT_Sema	MT_create_sema(int nresources);     


@-
Destroy a counting thread semaphore;
@h
gdk_export void	MT_destroy_sema(MT_Sema s);     

@-
Increment a semaphore.
@h
gdk_export void	MT_up_sema(MT_Sema s, char *name);
 
@-
Decrement a semaphore. If it already has value 0, the thread is
blocked until a decrement is possible again.
@h
gdk_export void	MT_down_sema(MT_Sema s, char *name);

@-
Try to decrement a semaphore. If it already has value 0, an error
(EBUSY) is returned. Else, the semaphore is decremented.
@h
gdk_export int 	MT_try_sema(MT_Sema s);

@-
Dump info about the semaphore named 'name' on stream 'fp'.
@h
gdk_export void 	MT_dump_sema(MT_Sema s, FILE *fp, char *name);

@-
Check if some process is still alive.
@h
gdk_export int 	MT_alive(int pid);

@-
Allocate anonymous virtual memory.
@h
#define MT_geterrno()		errno
#define MT_seterrno(x)		errno=x

gdk_export size_t _MT_npages;
gdk_export size_t _MT_pagesize;
 
#define MT_pagesize()	_MT_pagesize
#define MT_npages()	_MT_npages

#endif /*_GDK_SYSTEM_H_*/


@- Mthreads Routine implemtations
@c
#include "gdk.h"

#if !(defined(HAVE_SYSCONF) && defined(_SC_PHYS_PAGES)) && defined(HAVE_GETRLIMIT) && defined(HAVE_SYS_RESOURCE_H)
# include <sys/resource.h>
#endif

MT_Lock		MT_system_lock = NULL;		/* system administration lock */

pthread_mutex_t	MT_firstlock[MAXLOCKS];
sem_t		MT_firstsema[MAXSEMAS];

int MT_curlock=0, MT_nextlock[MAXLOCKS];
ptrdiff_t MT_cursema=0, MT_nextsema[MAXSEMAS];

size_t     _MT_pagesize = 0;               /* variable holding memory size */
size_t     _MT_npages = 0;                 /* variable holding page size */
 
void MT_init(void) {
	static pthread_mutex_t l;
	int i;

#ifdef HAVE_GETSYSTEMINFO
	{
	SYSTEM_INFO sysInfo;
	GetSystemInfo(&sysInfo);
	_MT_pagesize = sysInfo.dwPageSize;
	}
#else
#if defined(HAVE_SYSCONF) && defined(_SC_PAGESIZE)
        _MT_pagesize = sysconf(_SC_PAGESIZE);
#endif
#endif
	if (_MT_pagesize <= 0)
		_MT_pagesize = 4096;   /* default */ 

#ifdef HAVE_GLOBALMEMORYSTATUSEX
	{
		MEMORYSTATUSEX memStatEx;
		if (GlobalMemoryStatusEx(&memStatEx))
			_MT_npages = memStatEx.allAvailPhys / _MT_pagesize;
	}
#endif
#ifdef HAVE_GLOBALMEMORYSTATUS
	if (_MT_npages <= 0) {
		MEMORYSTATUS memStat;
		GlobalMemoryStatus(&memStat);
		_MT_npages = memStat.dwAvailPhys / _MT_pagesize;
	}
#endif
#if defined(HAVE_SYSCONF) && defined(_SC_PHYS_PAGES)
	_MT_npages = sysconf(_SC_PHYS_PAGES);
#else
#ifdef HAVE_GETRLIMIT
        {
		struct rlimit rl;
		getrlimit(RLIMIT_RSS, &rl);
		_MT_npages = rl.rlim_cur / _MT_pagesize;
        }
#endif
#endif
	
	pthread_mutex_init(&l, 0);
	for(i=1; i<MAXLOCKS; i++) {
		MT_nextlock[i-1] = i;
	}
	MT_nextlock[MAXLOCKS-1] = -1;

	for(i=1; i<MAXSEMAS; i++) {
		MT_nextsema[i-1] = (ptrdiff_t) i;
	}
	MT_nextsema[MAXSEMAS-1] = (ptrdiff_t) -1;

	MT_system_lock = (MT_Lock) &l;
}

#ifdef HAVE_PTHREAD_SIGMASK
void 	MT_thread_sigmask( sigset_t *new_mask, sigset_t *orig_mask ){
        (void)sigdelset(new_mask, SIGINT);
        (void)sigdelset(new_mask, SIGQUIT);
        (void)sigdelset(new_mask, SIGALRM); /* else sleep doesn't work */
        (void)pthread_sigmask(SIG_SETMASK, new_mask, orig_mask);
}
#endif

int	MT_create_thread (MT_Id *t, void (*f)(void *), void *arg) {
#ifdef HAVE_PTHREAD_SIGMASK
	sigset_t new_mask, orig_mask;
#endif
	pthread_attr_t attr;
	pthread_t newt;
	int  ret;

#ifdef HAVE_PTHREAD_SIGMASK
        (void)sigfillset(&new_mask);
	MT_thread_sigmask(&new_mask, &orig_mask);
#endif
	pthread_attr_init(&attr);
#ifdef PTHREAD_CREATE_DETACHED
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
#endif
        pthread_attr_setstacksize(&attr, 4*THREAD_STACK_SIZE );
	ret = pthread_create(&newt, &attr, (void *(*)(void *)) f, arg);
        if (ret == 0) *t = (MT_Id) (((int) newt) + 1); /* use pthread-id + 1 */
#ifdef HAVE_PTHREAD_SIGMASK
	MT_thread_sigmask(&orig_mask, NULL);
#endif
	return ret;
}

void MT_global_exit(int s) {
#ifdef HAVE_PTHREAD_KILL_OTHER_THREADS_NP
	/*(void) kill(0, SIGHUP);*/
	pthread_kill_other_threads_np();
#endif
#ifndef NATIVE_WIN32
	/* HACK ALERT
	   The execl is to get around a problem on several Unix systems.
	   When you run Mserver mapi.mil and attempt to shutdown the
	   server from another process (e.g. Mshutdown.py), the server
	   doesn't actually exit right away because not all threads
	   are terminated.  By executing another process, the whole
	   process (i.e. with all its threads) is replaced by the new
	   program.  If this new program does nothing, other than
	   exit, we effectively exit the server.

	   In case of profiling (ie gdk_alloc_map=no) we need to exit 
           correctly without losing the proper image, so in that case we 
	   don't apply this Hack.
	 */
	if (gdk_alloc_map) { 
		if (s)
			execl("/bin/false", "false", (char *) 0);
		else
			execl("/bin/true", "true", (char *) 0);
	}
#endif
	exit(s);
}


void MT_exit_thread(int s) {
	int st=0;
	(void) s;
	pthread_exit(&st);
}


int MT_kill_thread (MT_Id t) {
#ifdef HAVE_PTHREAD_KILL
	thread_t id = (thread_t)(t-1);
	return pthread_kill((pthread_t)id, SIGHUP);
#else
	(void) t;
	return -1;		/* XXX */
#endif
}

MT_Lock	MT_create_lock(void) {
	pthread_mutex_t *new_mutex;

	MT_set_lock(MT_system_lock, "MT_create_lock");
	if (MT_curlock == -1) {
	    fprintf(MT_out, "MT_create_lock: ran out of locks.\n");
	    MT_global_exit(-1);
	}
	new_mutex = MT_firstlock + MT_curlock;
	MT_curlock = MT_nextlock[MT_curlock];
	MT_unset_lock(MT_system_lock, "MT_create_lock");
	pthread_mutex_init(new_mutex, 0);

	return (MT_Lock) new_mutex;
}


void MT_destroy_lock (MT_Lock l) {
	int idx = (int) (((pthread_mutex_t*) l) - MT_firstlock);
	if (l == NULL) return;
	pthread_mutex_destroy(l);
	MT_set_lock(MT_system_lock, "MT_destroy_lock");
	MT_nextlock[idx] = MT_curlock;
	MT_curlock = idx;
	MT_unset_lock(MT_system_lock, "MT_destroy_lock");
}

void MT_set_lock(MT_Lock l, char *name){
    	int t = 0;
    	if (MT_debug & 1024) {
        	fprintf(MT_out,"MT_set_lock(" SZFMT "\@%s) " PTRFMT " %d\n", 
			(size_t)MT_getpid(), name, PTRFMTCAST (void *)l, t);
        	fflush(MT_out);
    	}
	(void)pthread_mutex_lock((pthread_mutex_t*)l);
}

void MT_unset_lock(MT_Lock l, char *name)	{
   	int t = 0;
    	if (MT_debug & 1024) {
        	fprintf(MT_out,"MT_unset_lock(" SZFMT "\@%s) " PTRFMT " %d\n", 
			(size_t)MT_getpid(), name, PTRFMTCAST (void *)l,t);
        	fflush(MT_out);
	}   
 	t = pthread_mutex_unlock((pthread_mutex_t*)l);
}
 
int MT_try_lock (MT_Lock l) {
	if (MT_debug & 1024) {
		fprintf(MT_out,"MT_try_lock:" SZFMT " " PTRFMT "\n", 
			(size_t)MT_getpid(), PTRFMTCAST (void *) l);
		fflush(MT_out);
	}
	if (l == NULL) return 0;
	return pthread_mutex_trylock(l);
}


void MT_dump_lock (MT_Lock l, FILE *fp, char* name) {
	(void) l;
	fprintf(fp, "%s: MT_dump_lock() not implemented.\n", name);
}

void MT_up_sema(MT_Sema s, char *name){
	(void)sem_post((sem_t*)s);
    	if (MT_debug &  1024) {
        	fprintf(MT_out,"MT_up_sema(" SZFMT "\@%s) " PTRFMT "\n", 
			(size_t)MT_getpid(), name, PTRFMTCAST (void *)s);
        	fflush(MT_out);
    	}
}
 
void MT_down_sema(MT_Sema s, char *name){
	(void)sem_wait((sem_t*)s);
    	if (MT_debug &  1024) {
        	fprintf(MT_out,"MT_down_sema(" SZFMT "\@%s) " PTRFMT "\n", 
			(size_t)MT_getpid(), name, PTRFMTCAST (void *)s);
        	fflush(MT_out);
	}   
}

int MT_try_sema (MT_Sema s){
	if (MT_debug & 1024) {
		fprintf(MT_out,"MT_try_sema:" SZFMT " " PTRFMT "\n", 
			(size_t) MT_getpid(), PTRFMTCAST (void *) s);
		fflush(MT_out);
	}
	if (s == NULL) return 0;
	return (sem_trywait((sem_t*)s));
}


MT_Sema	MT_create_sema (int nresources) {
	sem_t *new_sema;

	MT_set_lock(MT_system_lock, "MT_create_sema");
	if (MT_cursema == -1) {
	    fprintf(MT_out, "MT_create_sema: ran out of semaphores.\n");
	    MT_global_exit(-1);
	}
	new_sema = MT_firstsema + MT_cursema;
	MT_cursema = MT_nextsema[MT_cursema];
	MT_unset_lock(MT_system_lock, "MT_create_sema");

	(void)sem_init( new_sema, 0, nresources );
	return (MT_Sema) new_sema;
}


void	MT_destroy_sema (MT_Sema s) {
	ptrdiff_t idx = ((sem_t*) s) - MT_firstsema;

	if (s == NULL) return;
	(void)sem_destroy( s );

	MT_set_lock(MT_system_lock, "MT_destroy_sema");
	MT_nextsema[idx] = MT_cursema;
	MT_cursema = idx;
	MT_unset_lock(MT_system_lock, "MT_destroy_sema");
}

void 	MT_dump_sema (MT_Sema s, FILE *fp, char *name) {
	(void) s;
	fprintf(fp, "%s: MT_dump_sema() not implemented.\n",name);
}

MT_Id MT_getpid(void){
	return (MT_Id)(((size_t)pthread_self())+1);
}

int MT_alive(int pid) {
#ifdef HAVE_KILL
	return kill(pid, 0) == 0;
#else
	return 0;
#endif
}

