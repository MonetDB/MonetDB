@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f gdk_relop
@a M. L. Kersten, P. Boncz, S. Manegold
@* BAT relational operators
The basic relational operators are implemented for BATs.
Particular attention has been paid to speed-up processing
joins, such that navigational access and object re-assembly
are not being harmed too much.
@{
@c
#include "gdk.h"

#define SAMPLE_TRESHOLD_LOG 17
#define SAMPLE_SLICE_SIZE 1000
@}
@+ Join Algorithms
All join related operations have the same prelude to check
domain compatibility and to creates the BAT to hold the result.

We do some dynamic effort to estimate the result size. Good
estimates enhance performance and reduce the memory hunger of the join.
Method: we sample on l, and join on the whole r. This macro is called by
the physical join algorithms, hence we already decided on the algorithm
and join method, so the initial costs on r (e.g. hash creation) would have
to be paid anyway, and are reused later in the real join phase.

Sampling was made more robust by using a logarithmic number of slices
taken at equal-spaced intervals across l. The results are then analyzed
and checked for outliers. If outliers are present, a real sample is taken
and executed with the generic join algorithm to obtain an better estimate.

On small joins we just assume 1-N joins with a limited (=3) hit rate.
@{
@= joincheck
	ERRORcheck(l == NULL, "@1: invalid left operand");
	ERRORcheck(r == NULL, "@1: invalid right operand");
	ERRORcheck(TYPEerror(@2, @3), "@1: type conflict\n");
@= joinestimate
	if (@3 == (size_t) oid_nil) {
		size_t _lcount = BATcount(l);
		size_t _rcount = BATcount(r);
		size_t _slices = 0;

		/* limit estimate with simple bounds first; only spend effort if the join result might be big */
		if (@1 == JOIN_EQ) {
			if (l->tkey)
				@3 = r->hkey ? MIN(_rcount, _lcount) : _rcount;
			else if (r->hkey)
				@3 = _lcount;
		}
		if (@3 == oid_nil) {
			size_t _heuristic = 3 * MIN(_lcount, _rcount);

			if (_heuristic <= (1 << SAMPLE_TRESHOLD_LOG))
				@3 = _heuristic;
		}
		if (@3 == oid_nil) {
			size_t _idx;

			for (_idx = _lcount; _idx > 0; _idx >>= 1)
				_slices++;
		}
		if (_slices > SAMPLE_TRESHOLD_LOG) {
			/* use cheapo sampling by taking a number of slices and joining those with the algo */
			size_t _idx = 0, _tot = 0, _step, _lo, _avg, _sample, *_cnt;
			BAT *_tmp1 = l, *_tmp2, *_tmp3 = NULL;

			_step = _lcount / (_slices -= SAMPLE_TRESHOLD_LOG);
			_sample = _slices * SAMPLE_SLICE_SIZE;
			_cnt = (size_t *) alloca(_slices * sizeof(size_t));
			for (_lo = 0; _idx < _slices; _lo += _step) {
				size_t _size = 0, _hi = _lo + SAMPLE_SLICE_SIZE;

				l = BATslice(_tmp1, _lo, _hi);	/* slice keeps all parent properties */
				if (l == NULL)
					return NULL;
				_tmp2 = @2;	/* @2 = e.g. BATXjoin(l,r) */
				if (_tmp2) {
					_size = BATcount(_tmp2);
					BBPreclaim(_tmp2);
				}
				_tot += (_cnt[_idx++] = _size);
				BBPreclaim(l);
			}
			/* do outlier detection on sampling results; this guards against skew */
			if (@1 == JOIN_EQ) {
				for (_avg = _tot / _slices, _idx = 0; _idx < _slices; _idx++) {
					size_t _diff = _cnt[_idx] - _avg;

					if (_avg > _cnt[_idx])
						_diff = _avg - _cnt[_idx];
					if (_diff > MAX(SAMPLE_SLICE_SIZE, _avg))
						break;
				}
				if (_idx < _slices) {
					/* outliers detected, compute a real sample on at most 1% of the data */
					_sample = MIN(_lcount / 100, (1 << SAMPLE_TRESHOLD_LOG) / 3);
					_tmp2 = BATsample(_tmp1, _sample);
					if (_tmp2) {
						_tmp3 = BATjoin(_tmp2, r, oid_nil);	/* might be expensive */
						if (_tmp3) {
							_tot = BATcount(_tmp3);
							BBPreclaim(_tmp3);
						}
						BBPreclaim(_tmp2);
					}
					if (_tmp3 == NULL)
						return NULL;
				}
			}
			/* overestimate always by 5% */
			@3 = (size_t) ((double) (((lng) _tot) * ((lng) _lcount)) / (0.95 * (double) _sample));
			l = _tmp1;
		} else {
			@3 = MAX(_lcount,_rcount);
		}
	}
@= joinbat
	{
		size_t _estimate = @3;

		@:joinestimate(@1, @2, _estimate)@
		bn = BATnew(BAThtype(l), BATttype(r), _estimate);
		if (bn == NULL) {
			return bn;
		}
	}
@}
@- Merge join
In the case that both join columns are ordered, we can do a merging
(@%BATmergejoin@). The merge is opportunistic in that it tries to do
merge between l and r, but if for a long time no matching tuples are
found in r, it uses binary search. It also allows joining of an
unsorted l with a sorted r; in that case it always uses binary search.
@{
@= mergejoin
	if (((!BATtvoid(l)) || l->tseqbase != oid_nil) &&
	    ((!BAThvoid(r)) || r->hseqbase != oid_nil || nil_on_miss)) {
		while (l_start < l_last) {
			ptr v2, v1 = BUNt@2(l, l_start);
			int neq = 1;

			/* lookup range in l */
			l_end = l_start;
			if (l_key) {
				l_end += l_next;
			} else
				do {
					if ((l_end += l_next) >= l_last)
						break;
					v2 = BUNt@2(l, l_end);
				} while (@1_EQ(v1, v2, @4));

			/* lookup value in r (if not nil, that is) */
			if (!@1_EQ(v1, nil, @4)) {
				if (r_scan > 0) {
					/* first try scanning; but give up after a while */
					for (r_lim = MIN(r_last, r_end + r_scan); r_end < r_lim; r_end += r_next) {
						v2 = BUNh@3(r, r_end);
						neq = @1_CMP(v1, v2, @4);
						if (neq <= 0)
							break;
					}
					r_start = r_end;
				}
				if (neq == 1) {
					/* use binary search after failed scan or if scanning is impossible (l not sorted) */
					if (r_scan < 0 || r_start < r_last) {
						/* if merge not ended (or if no merge at all) */
						r_start = (BUN) SORTfndfirst_@4(rr, v1);
					}
					if (r_start < r_last) {
						v2 = BUNh@3(r, r_start);
						neq = !@1_EQ(v1, v2, @4);
					} else if (r_scan >= 0) {
						/* r is already at end => break off merge join */
						break;
					}
				}
			}
			if (neq == 0) {
				/* lookup range in r */
				r_end = r_start + r_next;
				if (r_key == 0)
					while (r_end < r_last) {
						v2 = BUNh@3(r, r_end);
						if (!@1_EQ(v1, v2, @4))
							break;
						r_end += r_next;
					}
				/* generate match-product as join result */
				for (; l_start < l_end; l_start += l_next)
					for (r_cur = r_start; r_cur < r_end; r_cur += r_next)
						bunfastins(bn, BUNhead(l, l_start), BUNtail(r, r_cur));
			} else if (nil_on_miss) {
				/* outerjoin inserts nils on a miss */
				hasnils = 1;
				for (; l_start < l_end; l_start += l_next)
					bunfastins(bn, BUNhead(l, l_start), nil_on_miss);
			} else {
				l_start = l_end;	/* no match found in equi-join */
			}
		}
	}
@c
/* serves both normal equi-join (nil_on_miss==NULL) and outerjoin (nil_on_miss=nil) */
static BAT *
mergejoin(BAT *l, BAT *r, BAT *bn, ptr nil_on_miss, size_t estimate)
{
	ptr nil = ATOMnilptr(r->htype);
	int r_scan = -1;	/* no scanning in r */
	BAT *rr = BATmirror(r);
	BUN l_last, r_last;	/* last BUN of the BAT */
	BUN l_start, r_start;	/* start of current chunk  */
	BUN l_end, r_end;	/* end of current chunk */
	int r_next = BUNsize(r);
	int l_next = BUNsize(l);
	int l_key = l->tkey;
	int r_key = r->hkey;
	BUN r_cur, r_lim;
	int loc, var, hasnils = 0;

	if (BATtordered(l) & 1) {
		int i, logr = 4;

		/* 4*log2(r.count) = estimation of the cost of binary search in units of scan comparisons */
		for (i = BATcount(r); i > 0; logr++)
			i >>= 1;
		r_scan = logr * BUNsize(r);	/* opportunistic scan window in r */
	}
	if (!(BAThordered(r) & 1)) {
		GDKerror("mergejoin: right input is not sorted.\n");
		return NULL;
	}
	if (bn == NULL) {
		@:joinbat(JOIN_EQ,mergejoin(l,r,NULL,nil_on_miss,oid_nil),estimate)@
	}

	/* the algorithm */
	loc = ATOMstorage(l->ttype);

	l_last = BUNlast(l);
	r_last = BUNlast(r);
	l_start = l_end = BUNfirst(l);
	r_start = r_end = BUNfirst(r);

	switch (loc) {
#ifndef NOEXPAND_CHR
	case TYPE_chr:
		@:mergejoin(simple,loc,loc,chr)@;

		break;
#endif
#ifndef NOEXPAND_SHT
	case TYPE_sht:
		@:mergejoin(simple,loc,loc,sht)@;

		break;
#endif
#ifndef NOEXPAND_INT
	case TYPE_int:
		@:mergejoin(simple,loc,loc,int)@;

		break;
#endif
#ifndef NOEXPAND_FLT
	case TYPE_flt:
		@:mergejoin(simple,loc,loc,flt)@;

		break;
#endif
#ifndef NOEXPAND_LNG
	case TYPE_lng:
		@:mergejoin(simple,loc,loc,lng)@;

		break;
#endif
#ifndef NOEXPAND_DBL
	case TYPE_dbl:
		@:mergejoin(simple,loc,loc,dbl)@;

		break;
#endif
	default:
		if (l->tvarsized) {
			var = ATOMstorage(l->ttype);

			if (r->hvarsized) {
				@:mergejoin(atom,var,var,var)@
			} else {
				loc = ATOMstorage(r->htype);
				@:mergejoin(atom,var,loc,loc)@
			}
		} else {
			loc = ATOMstorage(l->ttype);
			if (r->hvarsized) {
				var = ATOMstorage(r->htype);
				@:mergejoin(atom,loc,var,var)@
			} else {
				@:mergejoin(atom,loc,loc,loc)@
			}
		}
		break;
	}

	if (nil_on_miss) {
		for (; l_start < l_last; l_start += l_next)
			bunfastins(bn, BUNhead(l, l_start), nil_on_miss);
	}

	/* propagate properties */
	bn->hsorted = BAThordered(l);
	bn->tsorted = FALSE;
	if (r->hkey) {
		if (BATcount(bn) == BATcount(l)) {
			ALIGNsetH(bn, l);
		} else if (l->hkey) {
			BATkey(bn, TRUE);
		}
	}
	if (l->tkey) {
		bn->tsorted = BATtordered(r) & BATtordered(l) & 1;
		if (!nil_on_miss) {
			if (BATcount(bn) == BATcount(r)) {
				ALIGNsetT(bn, r);
			} else if (r->tkey) {
				BATkey(BATmirror(bn), TRUE);
			}
		} else if (hasnils) {
			bn->tsorted = 0;	/* nils destroy the ordering */
		}
	}
	return bn;
      bunins_failed:
	BBPreclaim(bn);
	return NULL;
}

static BAT *
batmergejoin(BAT *l, BAT *r, size_t estimate, bit swap)
{
	@:joincheck(BATmergejoin,l->ttype,r->htype)@
	if (swap && (((BAThordered(r) & 1) == 0) || ((BATtordered(l) & 1) && (BATcount(l) > BATcount(r))))) {
		/* reverse join if required (r not sorted) or if l is larger (quick jump through l with binary search) */
		BAT *bn = mergejoin(BATmirror(r), BATmirror(l), NULL, NULL, estimate);

		return bn ? BATmirror(bn) : NULL;
	}
	return mergejoin(l, r, NULL, NULL, estimate);
}

BAT *
BATmergejoin(BAT *l, BAT *r, size_t estimate)
{
	/* allows swapping of left and right input for faster processing */
	return batmergejoin(l, r, estimate, TRUE);
}

BAT *
BATleftmergejoin(BAT *l, BAT *r, size_t estimate)
{
	/* do not swap left and right input,
	   and hence maintain order of left head in result */
	return batmergejoin(l, r, estimate, FALSE);
}

@- hash join
These macros encode the core of the join algorithm. They are
the fast inner loops, optimized towards their type.

@= hashjoin
	{
		int xx;
		hash_t yy;

		BATloopFast(l, p, q, xx) {
			v = BUN@3(l,p);
			if (@1_EQ(v,nil,@2)) {
				continue; /* skip nil */
			}
			HASHloop_@2(r, r->hhash, yy, v, w) {
				bunfastins(bn, BUNhead(l,p), BUNtail(r,w));
			}
		}
		/* set sorted flags by hand, because we used BUNfastins() */
		bn->hsorted = BAThordered(l);
		bn->tsorted = FALSE;
		break;
	}
@c
BAT *
BAThashjoin(BAT *l, BAT *r, size_t estimate)
{
	ptr v, nil = ATOMnilptr(r->htype);
	BUN p, q, w;
	int any;
	BAT *bn = NULL;

	@:joincheck(BAThashjoin,l->ttype,r->htype)@
	@:joinbat(JOIN_EQ,BAThashjoin(l,r,oid_nil),estimate)@

	BATmmap_pin(r);
	if (BATprepareHash(r))
		return NULL;
	switch (any = ATOMstorage(l->ttype)) {
#ifndef NOEXPAND_CHR
	case TYPE_chr:
		@:hashjoin(simple,chr,tloc)@
#endif
#ifndef NOEXPAND_SHT
	case TYPE_sht:
		@:hashjoin(simple,sht,tloc)@
#endif
#if !defined(NOEXPAND_INT) || !defined(NOEXPAND_FLT)
	case TYPE_int:
	case TYPE_flt:
		@:hashjoin(simple,int,tloc)@
#endif
#if !defined(NOEXPAND_DBL) || !defined(NOEXPAND_LNG)
	case TYPE_dbl:
	case TYPE_lng:
		@:hashjoin(simple,lng,tloc)@
#endif
	default:
	      @:hashjoin(atom,any,tail);@
	}
	BATmmap_unpin(r);

	/* propagate alignment info */
	bn->hsorted = BAThordered(l);
	if (BAThkey(r)) {
		if (BATcount(bn) == BATcount(l))
			ALIGNsetH(bn, l);
		if (BAThkey(l))
			BATkey(bn, TRUE);
	}
	ESTIDEBUG THRprintf(GDKout, "BAThashjoin: actual resultsize: " SZFMT "\n", BATcount(bn));

	return bn;
      bunins_failed:
	BBPreclaim(bn);
	BATmmap_unpin(r);
	return NULL;

}

@}

@- Fetch-join
The @`BATfetchjoin@5(l,r) does a join on the basis of positional lookup.
It looks up index numbers from the second parameter in first parameter BAT.
The right parameter may contain OIDs, in which case their base is
subtracted.

In a typical join(BAT[any::1,oid) L, BATvoid,any::2] R) : BAT[any::1,any::2]
we expect each tuple of L to hit exactly once in R. Now if any::1=void
this void column can be carried over to the result. We do that.

However, it is possible that an tail-oid is out of range with respect
to R; in that case some tuples will be missing and we cannot carry on
producing a void column. In that case, we have to switch back
on-the-fly to the non-dense implementation.

The aftermath -- property setting -- is relatively straightforward here.
@{
@c
#define HLATOMput(bn, dst) ATOMput(bn->htype, bn->hheap, dst, BUNhloc(l,l_cur))
#define HVATOMput(bn, dst) ATOMput(bn->htype, bn->hheap, dst, BUNhvar(l,l_cur))
#define TLATOMput(bn, dst) ATOMput(bn->ttype, bn->theap, dst, BUNtloc(r,r_cur))
#define TVATOMput(bn, dst) ATOMput(bn->ttype, bn->theap, dst, BUNtvar(r,r_cur))

@= SIMPLEput
#define H@1put(bn,dst)	*(@1*) (dst) = *(@1*) (BUNhloc(l,l_cur))
#define T@1put(bn,dst)	*(@1*) (dst) = *(@1*) (BUNtloc(r,r_cur))
@c
@:SIMPLEput(chr)@
@:SIMPLEput(sht)@
@:SIMPLEput(int)@
@:SIMPLEput(lng)@

@= bunfastins_nocheck_
	H@1put(bn, BUNhloc(bn, dst));
	T@2put(bn, BUNtloc(bn, dst));
@c
@= fetchjoin
BAT *
densefetchjoin_@1_@2(BAT *bn, BAT *l, BAT *r)
{
	BUN l_cur, l_end, r_cur, dst;
	ssize_t offset;
	size_t base, xx;
	int yy, zz;
	BAT *ret = NULL;

	zz = BUNsize(bn);
	yy = BUNsize(r);
	dst = BUNfirst(bn);
	base = BUNindex(r, BUNfirst(r));
	offset = (ssize_t) (base - r->hseqbase);
	r_cur = BUNptr(r, offset + *(oid *) BUNtail(l, BUNfirst(l)));

	ALGODEBUG THRprintf(GDKout, "BATfetchjoin: densefetchjoin(@1,@2);\n");

	BATloopFast(l, l_cur, l_end, xx) {
		@:bunfastins_nocheck_(@1,@2)@
		r_cur += yy;
		dst += zz;
	}
	ret = bn;
      bunins_failed:
 	bn->batBuns->free = dst - bn->batBuns->base;
	BATsetcount(bn,bn->batBuns->free/zz);
	if (!ret)
		BBPreclaim(bn);
	return ret;
}

BAT *
orderedfetchjoin_@1_@2(BAT *bn, BAT *l, BAT *r)
{
	BUN l_cur, l_end, r_cur, dst;
	ssize_t offset;
	size_t base, xx, yy;
	int zz;
	BAT *ret = NULL;

	zz = BUNsize(bn);
	dst = BUNfirst(bn);
	base = BUNindex(r, BUNfirst(r));
	offset = (ssize_t) (base - r->hseqbase);

	ALGODEBUG THRprintf(GDKout, "BATfetchjoin: orderedfetchjoin(@1,@2);\n");

	BATloopFast(l, l_cur, l_end, xx) {
		yy = offset + *(oid *) BUNtail(l, l_cur);
		r_cur = BUNptr(r, yy);
		@:bunfastins_nocheck_(@1,@2)@
		dst += zz;
	}
	ret = bn;
      bunins_failed:
	bn->batBuns->free = dst - bn->batBuns->base;
	BATsetcount(bn,bn->batBuns->free/zz);
	if (!ret)
		BBPreclaim(bn);
	return ret;
}

BAT *
defaultfetchjoin_@1_@2(BAT *bn, BAT *l, BAT *r)
{
	BUN l_cur, l_end, r_cur, dst;
	ssize_t offset;
	size_t xx, yy, base, end;
	int zz;
	BAT *ret = NULL;

	zz = BUNsize(bn);

	dst = BUNfirst(bn);
	base = BUNindex(r, BUNfirst(r));
	offset = (ssize_t) (base - r->hseqbase);
	end = base + BATcount(r);

	BATmmap_pin(r);
	ALGODEBUG THRprintf(GDKout, "BATfetchjoin: defaultfetchjoin(@1,@2);\n");

	BATloopFast(l, l_cur, l_end, xx) {
		yy = offset + *(oid *) BUNtail(l, l_cur);
		if (yy < base || yy >= end) {
			continue;
		}
		r_cur = BUNptr(r, yy);
		@:bunfastins_nocheck_(@1,@2)@
		dst += zz;
	}
	BATmmap_unpin(r);
	ret = bn;
      bunins_failed:
	BATmmap_unpin(r);
	bn->batBuns->free = dst - bn->batBuns->base;
	BATsetcount(bn,bn->batBuns->free/zz);
	if (!ret)
		BBPreclaim(bn);
	return ret;
}
@c
@= fetchjoin2
	@:fetchjoin(@1,chr)@
	@:fetchjoin(@1,sht)@
	@:fetchjoin(@1,int)@
	@:fetchjoin(@1,lng)@
	@:fetchjoin(@1,VATOM)@
	@:fetchjoin(@1,LATOM)@
@c
@:fetchjoin2(chr)@
@:fetchjoin2(sht)@
@:fetchjoin2(int)@
@:fetchjoin2(lng)@

@:fetchjoin2(VATOM)@
@:fetchjoin2(LATOM)@
@c

@= fetchjoin_switch_rtt
	if (ATOMstorage(rtt) == TYPE_chr) {
		bn = @1fetchjoin_@2_chr(bn,l,r);
	} else if (ATOMstorage(rtt) == TYPE_sht) {
		bn = @1fetchjoin_@2_sht(bn,l,r);
	} else if (rtt != TYPE_bat &&
		   (ATOMstorage(rtt) == TYPE_int || ATOMstorage(rtt) == TYPE_flt
#if SIZEOF_OID == SIZEOF_INT
		    || ATOMstorage(rtt) == TYPE_oid
#endif
			   )) {
		/* ensure use of ATOMput for TYPE_bat */
		bn = @1fetchjoin_@2_int(bn,l,r);
	} else if (ATOMstorage(rtt) == TYPE_lng || ATOMstorage(rtt) == TYPE_dbl
#if SIZEOF_OID == SIZEOF_LNG
		   || ATOMstorage(lht) == TYPE_oid
#endif
		) {
		bn = @1fetchjoin_@2_lng(bn,l,r);
	} else if (r->tvarsized) {
		bn = @1fetchjoin_@2_VATOM(bn,l,r);
	} else {
		bn = @1fetchjoin_@2_LATOM(bn,l,r);
	}
@c
@= fetchjoin_switch_lht
	if (ATOMstorage(lht) == TYPE_chr) {
		@:fetchjoin_switch_rtt(@1,chr)@
	} else if (ATOMstorage(lht) == TYPE_sht) {
		@:fetchjoin_switch_rtt(@1,sht)@
	} else if (lht != TYPE_bat &&
		   (ATOMstorage(lht) == TYPE_int || ATOMstorage(lht) == TYPE_flt
#if SIZEOF_OID == SIZEOF_INT
		    || ATOMstorage(lht) == TYPE_oid
#endif
			   )) {
		/* ensure use of ATOMput for TYPE_bat */
		@:fetchjoin_switch_rtt(@1,int)@
	} else if (ATOMstorage(lht) == TYPE_lng || ATOMstorage(lht) == TYPE_dbl
#if SIZEOF_OID == SIZEOF_LNG
		   || ATOMstorage(lht) == TYPE_oid
#endif
		) {
		@:fetchjoin_switch_rtt(@1,lng)@
	} else if (l->hvarsized) {
		@:fetchjoin_switch_rtt(@1,VATOM)@
	} else {
		@:fetchjoin_switch_rtt(@1,LATOM)@
	}
@c
@= densevoidfetchjoin
	ALGODEBUG THRprintf(GDKout, "BATfetchjoin: densevoidfetchjoin(@1,@2,@3);\n");
	r_cur = BUNptr(r, offset + *(oid*) BUNtloc(l,BUNfirst(l)));
	yy = BUNsize(r);
	BATloopFast(l, l_cur, l_end, xx) {
		@3put(@2, bn->theap, dst, BUN@1(r, r_cur));
		r_cur += yy;
		dst += zz;
	}
@c
@= orderedvoidfetchjoin
	ALGODEBUG THRprintf(GDKout, "BATfetchjoin: orderedvoidfetchjoin(@1,@2,@3);\n");
	BATloopFast(l, l_cur, l_end, xx) {
		size_t yy = offset + *(oid*) BUNtloc(l,l_cur);

		r_cur = BUNptr(r, yy);
		@3put(@2, bn->theap, dst, BUN@1(r, r_cur));
		dst += zz;
	}
@c
@= defaultvoidfetchjoin
	ALGODEBUG THRprintf(GDKout, "BATfetchjoin: defaultvoidfetchjoin(@1,@2,@3);\n");
	BATloopFast(l, l_cur, l_end, xx) {
		size_t yy = offset + *(oid*) BUNtloc(l,l_cur);

		if (yy < base || yy >= end) {
			bn->batBuns->free = dst - bn->batBuns->base;
			BATsetcount(bn,bn->batBuns->free/zz);
			BBPreclaim(bn);
			nondense = 1;
			break;
		}
		r_cur = BUNptr(r, yy);
		@3put(@2, bn->theap, dst, BUN@1(r, r_cur));
		dst += zz;
	}
	if (nondense) {
		/* not (yet?) completely typ-optimized ! */
		ALGODEBUG THRprintf(GDKout, "BATfetchjoin: defaultvoidfetchjoin(@1,@2,@3): discovered non-density, resuming with non-void head\n");
		bn = BATnew(BAThtype(l), ATOMtype(tpe), BATcount(l));
		if (bn == NULL)
			return bn;
		dst = BUNfirst(bn);
		zz = BUNsize(bn);
		BATloopFast(l, l_cur, l_end, xx) {
			size_t yy = offset + *(oid*) BUNtail(l,l_cur);

			if (yy < base || yy >= end) {
				continue;
			}
			r_cur = BUNptr(r, yy);
			ATOMput(bn->htype, bn->hheap, BUNhloc(bn, dst), BUNhead(l, l_cur));
			@3put(@2, bn->theap, BUNtloc(bn, dst), BUN@1(r, r_cur));
			dst += zz;
		}
	}
@c
@= voidfetchjoin
	if (BATtdense(l)) {
		/* dense => ordered, i.e., we did check the bounderies already above */
		/* and we can do a "synchronized walk" through l & r */
		ALGODEBUG THRprintf(GDKout, "BATfetchjoin: BAThvoid(l) && !BATtvoid(l) && BATtdense(l)\n");
		@:densevoidfetchjoin(@1,@2,@3)@
	} else if (BATtordered(l)&1) {
		/* we did check the bounderies already above */
		ALGODEBUG THRprintf(GDKout, "BATfetchjoin: BAThvoid(l) && !BATtvoid(l) && !BATtdense(l) && BATtordered(l)&1\n");
		@:orderedvoidfetchjoin(@1,@2,@3)@
	} else {
		ALGODEBUG THRprintf(GDKout, "BATfetchjoin: BAThvoid(l) && !BATtvoid(l) && !BATtdense(l) && !BATtordered(l)&1\n");
		@:defaultvoidfetchjoin(@1,@2,@3)@
	}
@c
#define SIMPLEput(tpe,hp,dst,src) *(tpe*) (dst) = *(tpe*) (src)

static BAT *
batfetchjoin(BAT *l, BAT *r, size_t estimate, bit swap)
{
	int xx, yy, zz, lht, rtt;
	size_t base, end;
	ssize_t offset;
	size_t lcount,rcount;
	BUN r_cur, l_cur, l_end, dst;
	oid seqbase;
	BAT *ret = NULL, *bn = NULL, *l_orig = l;

	BATcheck(l, "BATfetchjoin: l");
	BATcheck(r, "BATfetchjoin: r");

	if (estimate == oid_nil) {
		estimate = BATcount(l);
	}
	lcount= BATcount(l);
	rcount= BATcount(r);

	if (swap) {
		if (!BAThdense(r)) {
			ERRORcheck(!BATtdense(l), "BATfetchjoin: one join column must be dense");
			ALGODEBUG THRprintf(GDKout, "BATfetchjoin: BATmirror(BATfetchjoin(BATmirror(r),BATmirror(l)));\n");

			return BATmirror(BATfetchjoin(BATmirror(r), BATmirror(l), estimate));
		}
	} else {
		ERRORcheck(!BAThdense(r), "BATfetchjoin: head column of right input must be dense");
	}
	if ( (lcount == 0) || (rcount == 0) ){
		/* below range checking do not support empty bats. so treat them separately (easy) */
		bn = BATnew(l->htype, r->ttype, 0);
		bn->hsorted = bn->tsorted = GDK_SORTED;
		BATkey(bn, TRUE);
		BATkey(BATmirror(bn), TRUE);
		if (bn->htype == TYPE_void || bn->htype == TYPE_oid) {
			bn->hdense = TRUE;
			BATseqbase(bn, l->hseqbase);
		}
		if (bn->ttype == TYPE_void || bn->ttype == TYPE_oid) {
			bn->tdense = TRUE;
			BATseqbase(BATmirror(bn), l->tseqbase);
		}
		return bn;
	} else if (BATtordered(l) & 1) {
		/* optimization to be able to carry over more void head columns */
		/* (only needed if neither operand is empty) */
		ssize_t r_lo = *(ssize_t *) BUNhead(r, BUNfirst(r));
		ssize_t r_hi = *(ssize_t *) BUNhead(r, BUNlast(r) - BUNsize(r));
		ssize_t l_lo = *(ssize_t *) BUNtail(l, BUNfirst(l));
		ssize_t l_hi = *(ssize_t *) BUNtail(l, BUNlast(l) - BUNsize(l));
		ALGODEBUG THRprintf(GDKout, "BATfetchjoin: BATtordered(l)&1\n");
		ALGODEBUG THRprintf(GDKout, "r_lo=" SSZFMT ", r_hi=" SSZFMT ", l_lo=" SSZFMT ", l_hi=" SSZFMT ".\n", r_lo, r_hi, l_lo, l_hi);

		if (r_lo > l_lo || r_hi < l_hi) {
			ALGODEBUG THRprintf(GDKout, "shrinking!\n");
			ALGODEBUG THRprintf(GDKout, "BATfetchjoin: l = BATselect(l, &r_lo, &r_hi);\n");

			l = BATselect(l, &r_lo, &r_hi);	/* sorted, so it will be a slice */
			if (l == NULL)
				return NULL;
		}
	}
	ALGODEBUG THRprintf(GDKout, "BATfetchjoin: 1\n");

	base = BUNindex(r, BUNfirst(r));
	offset = (ssize_t) (base - r->hseqbase);
	end = base + rcount;
	/* only BUNhead crashes on empty bats with TYPE != virtual oid */
	seqbase =
	    (l->htype ==
	     TYPE_void) ? l->hseqbase : (lcount ? (l->htype ==
							TYPE_int ? (oid) *(int *) BUNhead(l, BUNfirst(l)) : (l->htype == TYPE_oid ? *(oid *) BUNhead(l, BUNfirst(l)) : (l->htype == TYPE_lng ? (oid) *(lng *) BUNhead(l, BUNfirst(l)) : oid_nil))) : oid_nil);

	ALGODEBUG THRprintf(GDKout, "BATfetchjoin: 2\n");

	if (!BAThvoid(l)) {
		ALGODEBUG THRprintf(GDKout, "BATfetchjoin: !BAThvoid(l)\n");

		/* default case: no void column to propagate */
		lht = l->htype;
		rtt = r->ttype;

		if (ATOMstorage(rtt) == TYPE_str /*&& GDK_ELIMDOUBLES(r->theap)*/) {
			if (!rcount || (lcount<<8) > rcount) 
				rtt = TYPE_var;	/* insert double-eliminated strings as ints */
		}
		bn = BATnew(BAThtype(l), ATOMtype(rtt), estimate);
		if (bn == NULL)
			goto ready;
		ESTIDEBUG THRprintf(GDKout, "BATfetchjoin: estimated resultsize: " SZFMT "\n", lcount);

		dst = BUNfirst(bn);
		zz = BUNsize(bn);
		/* TODO: apply the "string trick" (see below) here too */
		if (BATtdense(l)) {
			/* dense => ordered, i.e., we did check the bounderies already above */
			/* and we can do a "synchronized walk" through l & r */
			ALGODEBUG THRprintf(GDKout, "BATfetchjoin: !BAThvoid(l) && BATtdense(l)\n");

			@:fetchjoin_switch_lht(dense)@
		} else if (BATtordered(l) & 1) {
			/* we did check the bounderies already above */
			ALGODEBUG THRprintf(GDKout, "BATfetchjoin: !BAThvoid(l) && !BATtdense(l) && BATtordered(l)&1\n");

			@:fetchjoin_switch_lht(ordered)@
		} else {
			ALGODEBUG THRprintf(GDKout, "BATfetchjoin: !BAThvoid(l) && !BATtdense(l) && !BATtordered(l)&1\n");

			@:fetchjoin_switch_lht(default)@
		}
		/* handle string trick */
		if (rtt == TYPE_var && ATOMstorage(r->ttype) == TYPE_str) {
			BAT *bm = BATmirror(bn);

			bn->theap = (Heap*)GDKzalloc(sizeof(Heap));
			if (bn->theap && r->theap->filename) {
				char *nme = BBP_physical(bn->batCacheid);
				
				bn->theap->filename = (str) GDKmalloc(strlen(nme) + 12);
				GDKfilepath(bn->theap->filename, NULL, nme, "theap");
			}
			if (HEAPcopy(bn->theap, r->theap) < 0) {
				BBPreclaim(bn);
				goto ready;
			}
			bn->ttype = bm->htype = r->ttype;
			bn->tvarsized = bm->hvarsized = 1;
		}
		bn->hsorted = (BATtordered(l) & BAThordered(r) & 1) ? BAThordered(l) : 0;
	} else if (!BATtvoid(l)) {
		/* propagation of void columns in the result */
		int nondense = 0;
		int tpe = r->ttype;
		BAT *ret = NULL;
		ALGODEBUG THRprintf(GDKout, "BATfetchjoin: BAThvoid(l) && !BATtvoid(l)\n");

		if (ATOMstorage(tpe) == TYPE_str /*&& GDK_ELIMDOUBLES(r->theap)*/) {
			if (!rcount || (lcount<<8) > rcount) 
				tpe = TYPE_var;	/* insert double-eliminated strings as ints */
		}
		bn = BATnew(TYPE_void, ATOMtype(tpe), estimate);
		if (bn == NULL)
			goto ready;
		ESTIDEBUG THRprintf(GDKout, "BATfetchjoin: estimated resultsize: " SZFMT "\n", lcount);

		dst = BUNfirst(bn);
		zz = BUNsize(bn);

		if (ATOMstorage(tpe) == TYPE_chr) {
			@:voidfetchjoin(tloc,chr,SIMPLE)@
		} else if (ATOMstorage(tpe) == TYPE_sht) {
			@:voidfetchjoin(tloc,sht,SIMPLE)@
		} else if (tpe != TYPE_bat && (ATOMstorage(tpe) == TYPE_int || ATOMstorage(tpe) == TYPE_flt)) {
			/* ensure use of ATOMput for TYPE_bat */
			@:voidfetchjoin(tloc,int,SIMPLE)@
		} else if (ATOMstorage(tpe) == TYPE_lng || ATOMstorage(tpe) == TYPE_dbl) {
			@:voidfetchjoin(tloc,lng,SIMPLE)@
		} else if (r->tvarsized) {
			@:voidfetchjoin(tvar,bn->ttype,ATOM)@
		} else {
			@:voidfetchjoin(tloc,bn->ttype,ATOM)@
		}
		ret = bn;
	      bunins_failed:
		bn->batBuns->free = dst - bn->batBuns->base;
		BATsetcount(bn,bn->batBuns->free/zz);
		if (ret == NULL) {
			BBPreclaim(bn);
			goto ready;
		}
		/* handle string trick */
		if (tpe == TYPE_var && ATOMstorage(r->ttype) == TYPE_str) {
			BAT *bm = BATmirror(bn);

			bn->theap = (Heap*)GDKzalloc(sizeof(Heap));
			if (bn->theap && r->theap->filename) {
				char *nme = BBP_physical(bn->batCacheid);
				
				bn->theap->filename = (str) GDKmalloc(strlen(nme) + 12);
				GDKfilepath(bn->theap->filename, NULL, nme, "theap");
			}
			if (HEAPcopy(bn->theap, r->theap) < 0) {
				BBPreclaim(bn);
				goto ready;
			}
			bn->ttype = bm->htype = r->ttype;
			bn->tvarsized = bm->hvarsized = 1;
		}
		if (nondense) {
			bn->hsorted = (BATtordered(l) & BAThordered(r) & 1) ? BAThordered(l) : 0;
		} else {
			BATseqbase(bn, seqbase);
			if (seqbase != oid_nil)
				BATkey(bn, TRUE);
			bn->hsorted = GDK_SORTED;
		}
	} else if (l->tseqbase != oid_nil) {
		/* execute using slice */
		BAT *v = BATmirror(VIEWhead(BATmirror(r)));
		oid lo_val = MAX(l->tseqbase, r->hseqbase);
		oid hi_val = MIN(l->tseqbase + lcount, r->hseqbase + rcount);
		size_t lo_pos = lo_val - r->hseqbase;
		size_t hi_pos = hi_val;

		if (hi_pos > r->hseqbase)
			hi_pos -= r->hseqbase;
		else
			hi_pos = 0;
		ALGODEBUG THRprintf(GDKout, "BATfetchjoin: BAThvoid(l) && BATtvoid(l) && l->tseqbase != oid_nil  =>  bn = BATslice(BATmirror(VIEWhead(BATmirror(r))), lo_pos=" SZFMT ", hi_pos=" SZFMT ");\n", lo_pos, hi_pos);

		bn = BATslice(v, lo_pos, hi_pos);
		if (seqbase != oid_nil)
			seqbase += lo_val - l->tseqbase;
		BATseqbase(bn, seqbase);
		BBPunfix(v->batCacheid);
	} else {
		/* nil join column => empty result */
		ALGODEBUG THRprintf(GDKout, "BATfetchjoin: BAThvoid(l) && BATtvoid(l) && l->tseqbase == oid_nil\n");

		bn = BATnew(ATOMtype(l->htype), ATOMtype(r->ttype), 10);
		if (bn == NULL)
			goto ready;
		ESTIDEBUG THRprintf(GDKout, "BATfetchjoin: estimated resultsize: %d\n", 10);
	}
	/* property propagation */
	if ( BATcount(bn) == lcount) {
		ALIGNsetH(bn, l);	/* BAThkey(r), remember? */
	} else {
		bn->hsorted = l->hsorted;
	}
	bn->tsorted = (BATtordered(l) & BATtordered(r) & 1) ? GDK_SORTED : 0;
	if (BATtkey(l)) {
		/* if BATtkey(l) elements of r match at most once */
		if ((BATtordered(l) & 1) && BATcount(bn) == rcount) {
			ALIGNsetT(bn, r);
		} else {
			BATkey(BATmirror(bn), BATtkey(r));
		}
	}
	ret = bn;
      ready:
	if (l != l_orig) {
		BBPreclaim(l);	/* was created as a temporary (slice) select on l */
	}
	ESTIDEBUG THRprintf(GDKout, "BATfetchjoin: actual resultsize: " SZFMT "\n", BATcount(bn));

	return ret;
}

BAT *
BATfetchjoin(BAT *l, BAT *r, size_t estimate)
{
	/* allows swapping of left and right input for faster processing */
	return batfetchjoin(l, r, estimate, TRUE);
}

BAT *
BATleftfetchjoin(BAT *l, BAT *r, size_t estimate)
{
	/* do not swap left and right input,
	   and hence maintain order of left head in result */
	return batfetchjoin(l, r, estimate, FALSE);
}

@-
This routine does the join optimization. TODO: it should be expressed in MIL.
@c
static BAT *
batjoin(BAT *l, BAT *r, size_t estimate, bit swap)
{
	size_t i, lsize, rsize, lcount, rcount;
	int lfetch, rfetch, must_hash;
	lng logr, logl;

	ERRORcheck(l == NULL, "BATjoin: invalid left operand");
	ERRORcheck(r == NULL, "BATjoin: invalid right operand");
	ERRORcheck(TYPEerror(l->ttype, r->htype), "BATjoin: type conflict\n");
	lcount= BATcount(l);
	rcount= BATcount(r);

	if ( (lcount == 0) || (rcount == 0) ){
		BAT *bn = BATnew(l->htype, r->ttype, 0);
		bn->hsorted = bn->tsorted = GDK_SORTED;
		BATkey(bn, TRUE);
		BATkey(BATmirror(bn), TRUE);
		if (bn->htype == TYPE_void || bn->htype == TYPE_oid) {
			bn->hdense = TRUE;
			BATseqbase(bn, l->hseqbase);
		}
		if (bn->ttype == TYPE_void || bn->ttype == TYPE_oid) {
			bn->tdense = TRUE;
			BATseqbase(BATmirror(bn), l->tseqbase);
		}
		return bn;
	}
@-
collect statistics that help us decide what to do
@c
	lsize = l->batBuns->size + (l->hheap ? l->hheap->size : 0) + (l->theap ? l->theap->size : 0);
	rsize = r->batBuns->size + (r->hheap ? r->hheap->size : 0) + (r->theap ? r->theap->size : 0);
	for (logr = 4, i = rcount; i > 0; logr++)
		i >>= 1;
	for (logl = 4, i = lcount; i > 0; logl++)
		i >>= 1;

	rfetch = BAThdense(r);
	lfetch = BATtdense(l);
	/* in case of fetchjoin, make sure we propagate a non-join void column */
	if (lfetch && rfetch) {
		if (BAThvoid(l) && !BATtvoid(r))
			lfetch = 0;
		if (swap && BATtvoid(r) && !BAThvoid(l))
			rfetch = 0;
	}
	must_hash = (swap && (rsize < lsize)) ? l->thash != NULL : r->hhash != NULL;
@-
In special cases (equal join columns, void join columns, or ordered
join columns), we take special action.
@c
	if (swap && lfetch && !(rfetch && lcount < rcount)) {
		ALGODEBUG THRprintf(GDKout, "BATjoin: BATmirror(BATfetchjoin(BATmirror(r), BATmirror(l), " SZFMT "));\n", estimate);

		return BATmirror(BATfetchjoin(BATmirror(r), BATmirror(l), estimate));
	} else if (rfetch) {
		ALGODEBUG THRprintf(GDKout, "BATjoin: BATfetchjoin(l, r, " SZFMT ");\n", estimate);

		return batfetchjoin(l, r, estimate, swap);
	}
@-
If both are ordered we do merge-join, or if hash-join is not possible right
away and one input is ordered and the other is much smaller, we do nested
loop binary search (both implemented by BATmergejoin).
@c
	if ((BATtordered(l) & BAThordered(r) & 1) || (must_hash && (((BATtordered(l) & 1) && ((lng) lcount > logl * (lng) rcount) && swap) || ((BAThordered(r) & 1) && ((lng) rcount > logr * (lng) lcount))))) {
		ALGODEBUG THRprintf(GDKout, "BATjoin: BATmergejoin(l,r," SZFMT ");\n", estimate);

		return batmergejoin(l, r, estimate, swap);
	}
@-
hash join: the bread&butter join of monet
@c
	if (swap && (rsize < lsize)) {	/* assume largest fits memory */
		ALGODEBUG THRprintf(GDKout, "BATjoin: BATmirror(BAThashjoin(BATmirror(r), BATmirror(l)," SZFMT "));\n", estimate);

		return BATmirror(BAThashjoin(BATmirror(r), BATmirror(l), estimate));
	}
	ALGODEBUG THRprintf(GDKout, "BATjoin: BAThashjoin(l,r," SZFMT ");\n", estimate);

	return BAThashjoin(l, r, estimate);
}

BAT *
BATjoin(BAT *l, BAT *r, size_t estimate)
{
	/* allows swapping of left and right input for faster processing */
	BAT *b = batjoin(l, r, estimate, TRUE);

	BATpropcheck(b, BATPROPS_ALL);
	return b;
}

BAT *
BATleftjoin(BAT *l, BAT *r, size_t estimate)
{
	/* do not swap left and right input,
	   and hence maintain order of left head in result */
	BAT *b = batjoin(l, r, estimate, FALSE);

	BATpropcheck(b, BATPROPS_ALL);
	return b;
}

@
@}
@+  Outerjoin
The left outerjoin between two BAT is also supported. The code is
identical to the hashjoin algorithm with the extension to insert a BUN
if no match can be found.
@{
@= outerjoinloop
{
	ptr v, nilh = ATOMnilptr(r->htype), nilt = ATOMnilptr(r->ttype);
	hash_t xx;
	int yy;
	BUN p, q, w;

	BATloopFast(l, p, q, yy) {
		size_t i = 0;

		v = (ptr) BUNtail(l, p);
		if (!@1_EQ(v, nilh, @2))
			HASHloop_@2(r, r->hhash, xx, v, w) {
				bunfastins(bn, BUNhead(l, p), BUNtail(r, w));
				i++;
			}
		if (i == 0) {
			bunfastins(bn, BUNhead(l, p), nilt);
		}
	}
}
break;
@
@-
The baseline join algorithm creates a hash on the smallest element and
probes it using the larger one. [TODO]
@c
BAT *
BATouterjoin(BAT *l, BAT *r, size_t estimate)
{
	BAT *bn = NULL;

	@:joincheck(BATouterjoin,l->ttype,r->htype)@
	if (BAThdense(l) && BAThkey(r)) {
		if (estimate == oid_nil)
			estimate = BATcount(l);
		bn = BATnew(TYPE_void, ATOMtype(r->ttype), estimate);
		if (bn == NULL)
			return bn;
		ESTIDEBUG THRprintf(GDKout, "BATouterjoin: estimated resultsize: " SZFMT "\n", estimate);

		BATseqbase(bn, l->hseqbase);
	}
	if (BAThdense(r) == FALSE && BAThordered(r) & 1) {
		/* use the merge-join; it takes care of the rest */
		bn = mergejoin(l, r, bn, ATOMnilptr(r->ttype), estimate);
		ESTIDEBUG THRprintf(GDKout, "BATouterjoin: actual resultsize: " SZFMT "\n", BATcount(bn));

		return bn;
	} else if (bn == NULL) {
		@:joinbat(JOIN_EQ,BATouterjoin(l,r,oid_nil),estimate)@
	}
	BATmmap_pin(r);
	if (BAThdense(r)) {
		/* positional algorithm: hash on void column would give error and is stupid */
		ptr nilt = ATOMnilptr(r->ttype);
		bit nonil = TRUE;
		BUN p, q, w, s = BUNfirst(bn);
		int yy, xx = BUNsize(bn);
		BATloopFast(l, p, q, yy) {
			oid v = *(oid *) BUNtail(l, p);
			ptr t = nilt;

			if (v != oid_nil) {
				BUNfndVOID(w, r, &v);
				if (w)
					t = BUNtail(r, w);
			}
			nonil &= (t != nilt);
			bunfastins_nocheck(bn, s, BUNhead(l, p), t, xx);
			s += xx;
		}
		bn->tsorted = ((BATtordered(l) & BATtordered(r) & 1) && nonil) ? GDK_SORTED : 0;
	} else {
		/* hash based algorithm (default) */
		int any = ATOMstorage(r->htype);

		if (BATprepareHash(r)) {
			BBPreclaim(bn);
			return NULL;
		}
		switch (any) {
#ifndef NOEXPAND_CHR
		case TYPE_chr:
			@:outerjoinloop(simple,chr)@
#endif
#ifndef NOEXPAND_SHT
		case TYPE_sht:
			@:outerjoinloop(simple,sht)@
#endif
#if !defined(NOEXPAND_INT) || !defined(NOEXPAND_FLT)
		case TYPE_int:
		case TYPE_flt:
			@:outerjoinloop(simple,int)@
#endif
#if !defined(NOEXPAND_DBL) || !defined(NOEXPAND_LNG)
		case TYPE_dbl:
		case TYPE_lng:
			@:outerjoinloop(simple,lng)@
#endif
		default:
			@:outerjoinloop(atom,any)@
		}
		bn->tsorted = 0;
	}
	BATmmap_unpin(r);
	/* set sorted flags by hand, because we used BUNfastins() */
	if (r->hkey) {
		ALIGNsetH(bn, l);	/* always 1 hit, so columns are equal */
	} else {
		bn->hsorted = BAThordered(l);
	}
	ESTIDEBUG THRprintf(GDKout, "BATouterjoin: actual resultsize: " SZFMT "\n", BATcount(bn));

	return bn;
      bunins_failed:
	BATmmap_unpin(r);
	BBPreclaim(bn);
	return NULL;
}

@
@}

@+ ThetaJoin
Current predicates supported are: JOIN_EQ, JOIN_LT,
JOIN_GE, JOIN_LE and JOIN_GT. The JOIN_EQ will pass the control to the
normal @:BATjoin@ equijoin. The is and index-based join: if an index
is not present, it will be created on the smallest relation.

We do lots of code-inlining: first of all on join type (4), and
furthermore on left-tail (equal right-head) type (5), which are the
join columns.  We factor out more by splitting on storage strategy
(variable-sized/fixed-size) of both the left-head, and right tail
columns (2*2).

In the end, this results in 4*5*2*2 = 80 different inner loops.

@c
BAT *
BATthetajoin(BAT *l, BAT *r, int op, size_t estimate)
{
	size_t _lcount = BATcount(l);
	size_t _rcount = BATcount(r);
	size_t _estimate = _lcount * _rcount;

	@:joincheck(BATthetajoin,l->ttype,r->htype)@
	if (estimate < _estimate)
		_estimate = estimate;
	if (op == JOIN_EQ) {
		/* exploit all equi-join optimizations */
		ALGODEBUG THRprintf(GDKout, "BATthetajoin(l,r,JOIN_EQ): BATjoin(l, r);\n");

		return BATjoin(l, r, _estimate);
	}
	return BATnlthetajoin(l, r, op, _estimate);
}

BAT *
BATleftthetajoin(BAT *l, BAT *r, int op, size_t estimate)
{
	size_t _lcount = BATcount(l);
	size_t _rcount = BATcount(r);
	size_t _estimate = _lcount * _rcount;

	@:joincheck(BATleftthetajoin,l->ttype,r->htype)@
	if (estimate < _estimate)
		_estimate = estimate;
	if (op == JOIN_EQ) {
		/* exploit all equi-join optimizations */
		ALGODEBUG THRprintf(GDKout, "BATleftthetajoin(l,r,JOIN_EQ): BATleftjoin(l, r);\n");

		return BATleftjoin(l, r, _estimate);
	}
	return BATnlthetajoin(l, r, op, _estimate);
}

/* nested loop join; finally MonetDB can enjoy the virtues of this algorithm as well! */
@= nlthetajoin_unroll8
	@:nlthetajoin_@2(@1)@ ri += rsz; @:nlthetajoin_@2(@1)@ ri += rsz;
	@:nlthetajoin_@2(@1)@ ri += rsz; @:nlthetajoin_@2(@1)@ ri += rsz;
	@:nlthetajoin_@2(@1)@ ri += rsz; @:nlthetajoin_@2(@1)@ ri += rsz;
	@:nlthetajoin_@2(@1)@ ri += rsz; @:nlthetajoin_@2(@1)@ ri += rsz;
@= nlthetajoin_void
	{ cur->r = off++; cur += (v @1 ra[ri]); } 
@= nlthetajoin_oid
	{ cur->r = *(oid*) (((BUN)(ra+ri))+off); cur += (v @1 ra[ri]); }
@= nlthetajoin_impl
static int nlthetajoin_@2_@1(BAT *bn, BAT *l, BAT *r) {
	dst_t *cur = (dst_t*) (bn->batBuns->base + bn->batBuns->free);
	dst_t *lim = (dst_t*) (bn->batBuns->base + bn->batBuns->size);
	size_t li=0, lsz = BUNsize(l)/sizeof(@1), lhi = BATcount(l)*lsz;
	size_t ri=0, rsz = BUNsize(r)/sizeof(@1), rhi = (MAX(8,BATcount(r))-8)*rsz;
	@1 *la = (@1*) BUNtloc(l,BUNfirst(l));
	@1 *ra = (@1*) BUNhloc(r,BUNfirst(r));

	for(ri=li=0; li<lhi; li+=lsz, ri=0) {
		ssize_t off = (r->ttype == TYPE_void)?((ssize_t) r->tseqbase):r->tloc - r->hloc;
		ssize_t len = cur - (dst_t*) bn->batBuns->base;
		@1 v = la[li];
		oid o;
		if (v == @1_nil) continue;

		/* unroll 8 times, factor out cur->l and memory re-allocation checking */
		while(1) {
			if (cur+8 >= lim) {
				bn->batBuns->free = ((BUN) cur) - bn->batBuns->base;
				BATsetcount(bn,bn->batBuns->free/BUNsize(bn));
				if (BATextend(bn, 8 + BATcount(bn) * (((dbl) lhi)/(li+1))) == NULL) return 1;
				cur = (dst_t*) (bn->batBuns->base + bn->batBuns->free);
				lim = (dst_t*) (bn->batBuns->base + bn->batBuns->size);
			}
			if (ri >= rhi) break;
			if (r->ttype == TYPE_void) {
				@:nlthetajoin_unroll8(@3,void)@
			} else {
				@:nlthetajoin_unroll8(@3,oid)@
			}
		}
		/* do rest in more expensive loop */
		if (r->ttype == TYPE_void) {
			size_t cnt = BATcount(r)*rsz;
			for(; ri < cnt; ri+=rsz) @:nlthetajoin_void(@3)@
		} else {
			size_t cnt = BATcount(r)*rsz;
			for(; ri < cnt; ri+=rsz) @:nlthetajoin_oid(@3)@
		}

		/* fill in the left oids for the generated result tuples */
 		o = *(oid*) BUNhead(l, ((BUN)(la+li))-l->tloc);
		len -= cur - (dst_t*) bn->batBuns->base;
		while(len < 0) cur[len++].l = o;
	}
	bn->batBuns->free = ((BUN) cur) - bn->batBuns->base;
	BATsetcount(bn,bn->batBuns->free/BUNsize(bn));
	return 0;
}
@= nlthetajoin_call
	case TYPE_@1: if (nlthetajoin_@2_@1(bn,l,r)) goto bunins_failed; break;
@= nlthetajoin_tpe
#ifndef NOEXPAND_CHR
	@:nlthetajoin_@1(chr,@2,@3)@
#endif
#ifndef NOEXPAND_SHT
	@:nlthetajoin_@1(sht,@2,@3)@
#endif
#ifndef NOEXPAND_INT
	@:nlthetajoin_@1(int,@2,@3)@
#endif
#ifndef NOEXPAND_LNG
	@:nlthetajoin_@1(lng,@2,@3)@
#endif
#ifndef NOEXPAND_FLT
	@:nlthetajoin_@1(flt,@2,@3)@
#endif
#ifndef NOEXPAND_DBL
	@:nlthetajoin_@1(dbl,@2,@3)@
#endif
@c
typedef struct { oid l,r; } dst_t;
@:nlthetajoin_tpe(impl,gt,>)@
@:nlthetajoin_tpe(impl,ge,>=)@
@:nlthetajoin_tpe(impl,lt,<)@
@:nlthetajoin_tpe(impl,le,<=)@
BAT *
BATnlthetajoin(BAT *l, BAT *r, int op, size_t estimate) {
	int optimize = (l->htype == TYPE_oid || BAThdense(l)) && (r->ttype == TYPE_oid || BATtdense(r));
	BAT *bn = BATnew(ATOMtype(l->htype), ATOMtype(r->ttype), estimate+128);
	int lo = 0, hi = 0;

	if (bn == NULL) return NULL;

	if (op == JOIN_GT) {
		lo = 1;
		hi = GDK_int_max;
		if (optimize) switch(ATOMstorage(l->ttype)) { @:nlthetajoin_tpe(call,gt)@ default: optimize=0; }
	} else if (op == JOIN_GE) {
		lo = 0;
		hi = GDK_int_max;
		if (optimize) switch(ATOMstorage(l->ttype)) { @:nlthetajoin_tpe(call,ge)@ default: optimize=0; }
	} else if (op == JOIN_LT) {
		lo = GDK_int_min;
		hi = -1;
		if (optimize) switch(ATOMstorage(l->ttype)) { @:nlthetajoin_tpe(call,lt)@ default: optimize=0; }
	} else if (op == JOIN_LE) {
		lo = GDK_int_min;
		hi = 0;
		if (optimize) switch(ATOMstorage(l->ttype)) { @:nlthetajoin_tpe(call,le)@ default: optimize=0; }
	}
	if (!optimize) {
		int lx, rx, (*cmp) (ptr, ptr) = BATatoms[l->ttype].atomCmp;
		ptr nil = ATOMnilptr(l->ttype);
		BUN rp, rq, lp, lq;
		BATloopFast(l, lp, lq, lx) {
			ptr v = (ptr) BUNtail(l, lp);
			if ((*cmp) (v, nil) == 0) {
				continue;
			}
			BATloopFast(r, rp, rq, rx) {
				ptr w = (ptr) BUNhead(r, rp);
				int c = (*cmp) (v, w);
	
				if ((c >= lo) & (c <= hi)) {
					bunfastins(bn, BUNhead(l, lp), BUNtail(r, rp));
				}
			}
		}
	}
	bn->hsorted = l->hsorted;
	bn->tsorted = 0;
	return bn;
      bunins_failed:
	BBPreclaim(bn);
	return NULL;
}

@}

@+ Bandjoin
A non-equi join of two relations R and S is called a Band-join if
the join predicate requires the values of R to fall within a given range.
This kind of joins is encountered in real world domains, such as those
involved with time and distance.

The boundary conditions for the bandjoin are constants or a NULL value.
The latter enables encoding of arbitrary theta joins using the more
general bandjoin.
Incidentally note that c1 = c2 = 0 leads to an equi-join.

The straight forward implementation uses a nested loop.
The current implementation does not optimize processing, because
the impact of the choices is not yet clear.

The hash indexing routines have been extended with a Band argument.
@{
@c
BAT *
BATbandjoin(BAT *l, BAT *r, ptr c1, ptr c2)
{
	BAT *bn;
	BUN p, q;
	BUN v, w;

	@:joincheck(BATbandjoin,l->ttype,r->htype)@
	@:joinbat(JOIN_BAND,BATbandjoin(l,r,c1,c2),oid_nil)@
	switch (ATOMstorage(r->htype)) {
	case TYPE_chr:
		@:bandjoin(chr)@

	case TYPE_sht:
		@:bandjoin(sht)@

	case TYPE_int:
		@:bandjoin(int)@

	case TYPE_flt:
		@:bandjoin(flt)@

	case TYPE_dbl:
		@:bandjoin(dbl)@

	case TYPE_lng:
		@:bandjoin(lng)@

	default:
		GDKerror("BATbandjoin: type not implemented\n");
		return NULL;
	}
	/* set sorted flags by hand, because we used BUNfastins() */
	bn->hsorted = BAThordered(l);
	bn->tsorted = FALSE;

	ESTIDEBUG THRprintf(GDKout, "BATbandjoin: actual resultsize: " SZFMT "\n", BATcount(bn));

	return bn;
}

@
@}
@-
The easiest case is to implement a nested loop for band operations.
Choice point is to determine the status of the NULL values in the final
result.
@{
@= bandjoin
{
	int xx, yy;
	@1 *x1;
	@1 *x2;

	BATloopFast(l, p, q, xx) {
		x1 = (@1 *) BUNtloc(l, p);
		BATloopFast(r, v, w, yy) {
			x2 = (@1 *) BUNhloc(r, v);
			if ((*x1 >= *x2 -  *(@1 *) c1) &&
			    (*x1 <= *x2 + *(@1 *) c2)) {
				if (BUNfastins(bn, BUNhead(l,p), BUNtail(r, v)) == NULL) {
					BBPreclaim(bn);
					return NULL;
				}
			}
		}
	}
	break;
}
@
@}
@+ Semijoin

The @%BATsemijoin@ performs a semijoin over @%l@ and @%r@. It returns
a subset of @%l@ that matches at least one element in @%r@.
The result inherits the integrity properties.

Various algorithms exist. The main one BATkintersect() resides
outside this file, in the set-operations implementation (gdk_setop).
Other variants for the semijoin include the fetch-semijoin
(for dense join columns), the reverse semijoin that loops over r
instead of l, and semijoin using binary search in r.
@{
@= semijoinbat
	bn = BATnew(BAThtype(@1), BATttype(@1), MAX(BATTINY, MIN(BATcount(l), BATcount(r))));
	ESTIDEBUG THRprintf(GDKout, "%s.semijoinbat: estimated resultsize: " SZFMT "\n",@4,MAX(BATTINY, MIN(BATcount(l), BATcount(r))));
	if (bn == NULL) {
		return bn;
	}
	BATkey(bn, BAThkey(@1));
	BATkey(BATmirror(bn), BATtkey(@1));
	bn->hsorted = @2;
	bn->tsorted = @3;
@}
@-
In the sorted cases with a low semijoin hit-rate, we do lookup using
probe-based binary search, instead of a full merge scan.
Normal merge-semijoin with a full scan on both is handled by kintersect
(default exit) if both relations are large or if their sizes do not
differ significantly.
@{
@= binsemijoin
{
	BUN lp, lq;
	int xx;
	ptr nil = ATOMnilptr(l->htype);

	if (cpy == l) {
		BATloopFast(l, lp, lq, xx) {
			ptr v = BUNh@1(l,lp);

			if (!@3_EQ(v, nil, @2) && SORTfnd_@2(r, v)) {
				bunfastins(bn, v, BUNtail(l,lp));
			}
		}
	} else {
		BATloopFast(l, lp, lq, xx) {
			BUN rp, rq;
			ptr v = BUNh@1(l,lp);

			if (!@3_EQ(v, nil, @2)) {
				int yy;

				SORTloop_@2(BATmirror(r), rp, rq, v, v, yy) {
					bunfastins(bn, v, BUNtail(r,rp));
				}
			}
		}
	}
}
break;
@c
BAT *
BATbinsemijoin(BAT *l, BAT *r, BAT *cpy)
{
	BAT *bn, *del = NULL;
	int loc, var;

	@:joincheck(BATbinsemijoin,l->htype,r->htype)@
	@:semijoinbat(cpy,TRUE,(l==cpy&&(BATtordered(l)&1)),"BATbinsemijoin")@

	if (!(BAThordered(r) & 1)) {
		del = r = BATsort(r);
		if (del == NULL)
			return NULL;
	}

	BATmmap_pin(r);
	switch (loc = var = ATOMstorage(l->htype)) {
#ifndef NOEXPAND_CHR
	case TYPE_chr:
		@:binsemijoin(loc,chr,simple)@
#endif
#ifndef NOEXPAND_SHT
	case TYPE_sht:
		@:binsemijoin(loc,sht,simple)@
#endif
#ifndef NOEXPAND_INT
	case TYPE_int:
		@:binsemijoin(loc,int,simple)@
#endif
#ifndef NOEXPAND_FLT
	case TYPE_flt:
		@:binsemijoin(loc,flt,simple)@
#endif
#ifndef NOEXPAND_DBL
	case TYPE_dbl:
		@:binsemijoin(loc,dbl,simple)@
#endif
#ifndef NOEXPAND_LNG
	case TYPE_lng:
		@:binsemijoin(loc,lng,simple)@
#endif
	default:
		if (l->hvarsized) {
			if (r->hvarsized) {
				@:binsemijoin(var,var,atom)@
			} else {
				@:binsemijoin(var,loc,atom)@
			}
		} else {
			if (r->hvarsized) {
				@:binsemijoin(loc,var,atom)@
			} else {
				@:binsemijoin(loc,loc,atom)@
			}
		}
	}
	BATmmap_unpin(r);

	/* propagate properties */
	bn->hsorted = l->hsorted;
	bn->tsorted = 0;
	if (BATcount(bn) == BATcount(l)) {
		if (l == cpy) {
			ALIGNset(bn, l);
		} else if (BAThkey(l) && BAThkey(r)) {
			ALIGNsetH(bn, l);
		}
	}
	if (del)
		BBPreclaim(del);
	ESTIDEBUG THRprintf(GDKout, "BATbinsemijoin: actual resultsize: " SZFMT "\n", BATcount(bn));

	return bn;
      bunins_failed:
	BATmmap_unpin(r);
	BBPreclaim(bn);
	return NULL;
}

@-
The reverse semijoin is only better if the other side (r) is much
smaller than l, and iff you already have the hash table on l. It uses hash tables on
both relations: on r to check that no item is processed twice (not necessary to check
iff BAThkey(r) and one on l to find the matching tuples.
@{
@= revsemijoin
{
	int xx;
	hash_t yy;
	BUN lp = 0, rp = 0, rq = 0, rr = 0;
	ptr nil = ATOMnilptr(l->htype);

	if (merge) {
		ALGODEBUG THRprintf(GDKout, "BATrevsemijoin: merge\n");
		BATloopFast(r, rp, rq, xx) {
			ptr v = BUN@3(r,rp);

			rr = rp + xx;
			if (rr < rq && @1_EQ(v,BUN@3(r,rr),@2))
				continue;
			if (!@1_EQ(v, nil, @2)) {
				HASHloop_@2(l, l->hhash, yy, v, lp)
					bunfastins(bn, v, BUNtail(l, lp));
			}
		}
	} else if (rdoubles) {
		ALGODEBUG THRprintf(GDKout, "BATrevsemijoin: rdoubles\n");
		BATloopFast(r, rp, rq, xx) {
			ptr v = BUN@3(r,rp);

			HASHloop_@2(r, r->hhash, yy, v, rr)
				break;
			if (rr != rp)
				continue;
			if (!@1_EQ(v, nil, @2)) {
				HASHloop_@2(l, l->hhash, yy, v, lp)
					bunfastins(bn, v, BUNtail(l, lp));
			}
		}
	} else {
		BATloopFast(r, rp, rq, xx) {
			ptr v = BUN@3(r,rp);
			if (!@1_EQ(v, nil, @2)) {
				HASHloop_@2(l, l->hhash, yy, v, lp)
					bunfastins(bn, v, BUNtail(l, lp));
			}
		}
	}
}
break;
@c
BAT *
BATrevsemijoin(BAT *l, BAT *r)
{
	int any, rdoubles = (BAThkey(r) == 0), merge = rdoubles & BAThordered(r);
	BAT *bn;

	@:joincheck(BATrevsemijoin,l->htype,r->htype)@
	@:semijoinbat(l,FALSE,FALSE,"BATrevsemijoin")@
	if (BATprepareHash(l))
		return NULL;
	if (rdoubles && BATprepareHash(r))
		return NULL;

	BATmmap_pin(l);
	switch (any = ATOMstorage(l->htype)) {
#ifndef NOEXPAND_CHR
	case TYPE_chr:
		@:revsemijoin(simple,chr,hloc)@
#endif
#ifndef NOEXPAND_SHT
	case TYPE_sht:
		@:revsemijoin(simple,sht,hloc)@
#endif
#if !defined(NOEXPAND_INT) || !defined(NOEXPAND_FLT)
	case TYPE_int:
	case TYPE_flt:
		@:revsemijoin(simple,int,hloc)@
#endif
#if !defined(NOEXPAND_DBL) || !defined(NOEXPAND_LNG)
	case TYPE_dbl:
	case TYPE_lng:
		@:revsemijoin(simple,lng,hloc)@
#endif
	default:
	      @:revsemijoin(atom,any,head)@
	}
	BATmmap_unpin(l);
	/* propagate properties */
	bn->hsorted = bn->tsorted = 0;
	if (BAThkey(r) && BATtkey(l) && BATcount(bn) == BATcount(r)) {
		ALIGNsetH(bn, r);
	}
	ESTIDEBUG THRprintf(GDKout, "BATrevsemijoin: actual resultsize: " SZFMT "\n", BATcount(bn));

	return bn;
      bunins_failed:
	BATmmap_unpin(l);
	BBPreclaim(bn);
	return NULL;
}

@}
@-
The positional semijoin performs a semijoin using positional lookup.
This implementation is dirty as it also allows fetches with
hard integer positions, rather than oid matching on a dense-oid column.
@{
@c
static BAT *
BATfetchsemijoin(BAT *l, BAT *r, BAT *cpy, int denselookup)
{
	int xx;
	size_t base, end, yy;
	ssize_t offset;
	BUN l_cur, l_end, r_cur;
	BAT *bn;

	BATcheck(l, "BATfetchsemijoin: l");
	BATcheck(r, "BATfetchsemijoin: r");

	if (denselookup && !BAThdense(r)) {
		GDKerror("BATfetchsemijoin: left column must be dense.\n");
		return NULL;
	} else if (ATOMstorage(l->htype) != ATOMstorage(TYPE_oid)) {
		GDKerror("BATfetchsemijoin: illegal index type %s.\n", ATOMname(l->htype));
		return NULL;
	}
	if (denselookup && BAThvoid(l)) {
		/* redirect semijoin on two dense regions to a select (and hence to BATslice) */
		oid min = oid_nil, max = oid_nil;
		BAT *other = (cpy == l) ? r : l;

		if (BATcount(other)) {
			min = *(oid *) BUNhead(l, BUNfirst(other));
			max = *(oid *) BUNhead(l, BUNlast(other) - BUNsize(other));
		}
		return BATmirror(BAT_select(BATmirror(cpy), &min, &max, TRUE));
	}
	base = BUNindex(r, BUNfirst(r));
	end = base + BATcount(r);
	bn = BATnew(BAThtype(cpy), BATttype(cpy), MIN(BATcount(r), BATcount(l)));
	if (bn == NULL)
		return bn;
	ESTIDEBUG THRprintf(GDKout, "BATfetchsemijoin: estimated resultsize: " SZFMT "\n", MIN(BATcount(r), BATcount(l)));

	if (bn == NULL) {
		return NULL;
	}
	if (denselookup) {
		offset = (ssize_t) (base - r->hseqbase);	/* translate oid to BUN position */
	} else {
		offset = (ssize_t) base;	/* fetch by hard BUNindex */
	}

	/* iterate l; positional fetch in r */
	if (!BAThordered(l))	/* StM: (!(BAThordered(l)&1)) ? */
		BATmmap_pin(r);
	BATloopFast(l, l_cur, l_end, xx) {
		yy = offset + *(oid *) BUNhloc(l, l_cur);
		if (yy < base || yy >= end) {
			continue;
		}
		r_cur = BUNptr(r, yy);
		if (cpy == r) {
			bunfastins(bn, BUNhead(r, r_cur), BUNtail(r, r_cur));
		} else {
			bunfastins(bn, BUNhead(r, r_cur), BUNtail(l, l_cur));
		}
	}
	if (!BAThordered(l))	/* StM: (!(BAThordered(l)&1)) ? */
		BATmmap_unpin(r);

	/* property propagation */
	bn->hsorted = (BAThordered(l) & BAThordered(r) & 1 ? GDK_SORTED : FALSE);
	bn->tsorted = (bn->hsorted & BATtordered(cpy) & 1  ? GDK_SORTED : FALSE);


	if (denselookup && BATcount(bn) == BATcount(l)) {
		ALIGNsetH(bn, l);
	} else {
		BATkey(bn, BAThkey(l) && BAThkey(r));
	}
	if (BAThkey(l)) {
		if (BATcount(bn) == BATcount(cpy) && (BAThordered(r) & BAThordered(l) & 1)) {
			ALIGNsetT(bn, cpy);
		} else {
			BATkey(BATmirror(bn), BATtkey(cpy));
		}
	}
	ESTIDEBUG THRprintf(GDKout, "BATfetchsemijoin: actual resultsize: " SZFMT "\n", BATcount(bn));

	return bn;
      bunins_failed:
	if (!BAThordered(l))	/* StM: (!(BAThordered(l)&1)) ? */
		BATmmap_unpin(r);
	BBPreclaim(bn);
	return NULL;
}

BAT *
BATfetch(BAT *l, BAT *r)
{
	return BATfetchsemijoin(r, l, l, FALSE);
}

@-
The BATsemijoin chooses between various alternatives.
TODO: this should be moved to MIL.
@c
BAT *
BATsemijoin(BAT *l, BAT *r)
{
	int reverse1, reverse2;
	size_t countr, countl, i;
	lng logr, logl;
	BAT *bn, *tmp = NULL;

	ERRORcheck(l == NULL, "BATsemijoin");
	ERRORcheck(r == NULL, "BATsemijoin");
	ERRORcheck(TYPEerror(l->htype, r->htype), "BATsemijoin: type conflict\n");

@- algorithm selection
We have 10 algorithms implementing semijoin. Their conditions are checked in order
of efficiency. Some algorithms reverse the semijoin (loop over r, lookup in l).
To do that r should be unique. To that end, doubles may sometimes be eliminated from r.
@c
	for (logr = 4, i = countr = BATcount(r); i > 0; logr++)
		i >>= 1;
	for (logl = 4, i = countl = BATcount(l); i > 0; logl++)
		i >>= 1;
	reverse1 = countr < countl && (BAThkey(r) || (lng) countr * 8 < (lng) countl);
	reverse2 = (lng) countr *logl < (lng) countl && (BAThkey(r)
							 || (lng) countr * (logl + 8) < (lng) countl);

	if (ALIGNsynced(l, r)) {
		ALGODEBUG THRprintf(GDKout, "BATsemijoin: BATrcopy(l);\n");

		bn = BATrcopy(l);
	} else if ((BAThordered(l) & 1) && BAThdense(r)) {
		oid lo = r->hseqbase;
		oid hi = r->hseqbase + countr - 1;
		ALGODEBUG THRprintf(GDKout, "BATsemijoin: BATmirror(BATselect(BATmirror(l), &lo, &hi));\n");

		bn = BATmirror(BATselect(BATmirror(l), &lo, &hi));
	} else if (BAThdense(r)) {
		ALGODEBUG THRprintf(GDKout, "BATsemijoin: BATfetchsemijoin(l, r, l);\n");

		bn = BATfetchsemijoin(l, r, l, TRUE);
	} else if (BAThdense(l) && reverse1) {
		if (!BAThkey(r)) {
			BAT *v = VIEWhead_(r, BAT_WRITE);

			tmp = r = BATkunique(v);
			BBPreclaim(v);
		}
		ALGODEBUG THRprintf(GDKout, "BATsemijoin: BATfetchsemijoin(r, l, l);\n");

		bn = BATfetchsemijoin(r, l, l, TRUE);
	} else if (l->hhash && reverse1) {
		ALGODEBUG THRprintf(GDKout, "BATsemijoin: BATrevsemijoin(l,r);\n");

		bn = BATrevsemijoin(l, r);
	} else if ((BAThordered(r) & 1) && countl * logr < countr) {
		ALGODEBUG THRprintf(GDKout, "BATsemijoin: BATbinsemijoin(l, r, l);\n");

		bn = BATbinsemijoin(l, r, l);
	} else if ((BAThordered(l) & 1) & reverse2) {
		if (!BAThkey(r)) {
			BAT *v = VIEWhead_(r, BAT_WRITE);

			tmp = r = BATkunique(v);
			BBPreclaim(v);
		}
		ALGODEBUG THRprintf(GDKout, "BATsemijoin: BATbinsemijoin(r, l, l);\n");

		bn = BATbinsemijoin(r, l, l);
	} else {
		ALGODEBUG THRprintf(GDKout, "BATsemijoin: BATkintersect(l, r);\n");

		bn = BATkintersect(l, r);	/* merge-semijoin or nested hashlookup in r */
	}
	if (tmp) {
		BBPreclaim(tmp);
	}
	return bn;
}

@}
@+ AntiJoin
This operation computes the cross product of two BATs, returning only the
head-value from the 'left' operand and then tail-value from the 'right'
provided the tail-head pair do not (!) match.
@{
@= antijoin2
BAT*
antijoin_@1_@2(BAT *bn, BAT *l, BAT *r)
{
	BUN l_cur, l_end, r_cur, r_end, dst;
	int l_sz, r_sz, bn_sz;
	int (*cmp) (ptr, ptr) = BATatoms[l->ttype].atomCmp;
	ptr nil = ATOMnilptr(l->ttype);


	bn_sz = BUNsize(bn);
	dst = BUNfirst(bn);

	ALGODEBUG THRprintf(GDKout, "BATantijoin: antijoin_@1_@2();\n");
	BATloopFast(l, l_cur, l_end, l_sz) {
		ptr v = (ptr) BUNtail(l, l_cur);
		BATloopFast(r, r_cur, r_end, r_sz) {
			ptr w = (ptr) BUNhead(r, r_cur);
			int c = (*cmp) (v, w);
			if ((*cmp) (v, nil) != 0 && (*cmp) (w, nil) != 0 && c != 0 ) {
				@:bunfastins_nocheck_(@1,@2)@
				dst += bn_sz;
			}
		}
	}
	bn->batBuns->free = dst - bn->batBuns->base;
	BATsetcount(bn,bn->batBuns->free/bn_sz);
	return bn;

bunins_failed:
	BBPreclaim(bn);
	return NULL;
}
@= antijoin1
	@:antijoin2(@1,chr)@
	@:antijoin2(@1,sht)@
	@:antijoin2(@1,int)@
	@:antijoin2(@1,lng)@
	@:antijoin2(@1,VATOM)@
	@:antijoin2(@1,LATOM)@
@c
@:antijoin1(chr)@
@:antijoin1(sht)@
@:antijoin1(int)@
@:antijoin1(lng)@

@:antijoin1(VATOM)@
@:antijoin1(LATOM)@
@c

@= antijoin_switch_rtt
{
	int rtt = r->ttype;
	int rts = ATOMstorage(rtt);

	if (rts == TYPE_chr) {
		bn = antijoin_@1_chr(bn,l,r);
	} else if (rts == TYPE_sht) {
		bn = antijoin_@1_sht(bn,l,r);
	} else if (rtt != TYPE_bat &&
		   (rts == TYPE_int || rts == TYPE_flt
#if SIZEOF_OID == SIZEOF_INT
		    || rts == TYPE_oid
#endif
		   )) {
		/* ensure use of ATOMput for TYPE_bat */
		bn = antijoin_@1_int(bn,l,r);
	} else if (rts == TYPE_lng || rts == TYPE_dbl
#if SIZEOF_OID == SIZEOF_LNG
		   || ATOMstorage(lht) == TYPE_oid
#endif
) {
		bn = antijoin_@1_lng(bn,l,r);
	} else if (r->tvarsized) {
		bn = antijoin_@1_VATOM(bn,l,r);
	} else {
		bn = antijoin_@1_LATOM(bn,l,r);
	}
}
@c
@= antijoin_switch_lht
{
	int lht = l->htype;
	int lhs = ATOMstorage(lht);

	if (lhs == TYPE_chr) {
		@:antijoin_switch_rtt(chr)@
	} else if (lhs == TYPE_sht) {
		@:antijoin_switch_rtt(sht)@
	} else if (lht != TYPE_bat &&
		   (lhs == TYPE_int || lhs == TYPE_flt
#if SIZEOF_OID == SIZEOF_INT
		    || lhs == TYPE_oid
#endif
		   )) {
		/* ensure use of ATOMput for TYPE_bat */
		@:antijoin_switch_rtt(int)@
	} else if (lhs == TYPE_lng || lhs == TYPE_dbl
#if SIZEOF_OID == SIZEOF_LNG
		   || lhs == TYPE_oid
#endif
		   ) {
		@:antijoin_switch_rtt(lng)@
	} else if (l->hvarsized) {
		@:antijoin_switch_rtt(VATOM)@
	} else {
		@:antijoin_switch_rtt(LATOM)@
	}
}
@c
BAT *
BATantijoin(BAT *l, BAT *r)
{
	BAT *bn;
	size_t lc, rc, sz;

	ERRORcheck(l == NULL, "BATantijoin: invalid left operand");
	ERRORcheck(r == NULL, "BATantijoin: invalid right operand");
	lc = BATcount(l);
	rc = BATcount(r);
	sz = lc * rc;

	if (sz > 0) {
		/* try to keep void columns where possible */
		if (rc == 1)
			return BATconst(l, BATttype(r), BUNtail(r, BUNfirst(r)));
		if (lc == 1)
			return BATmirror(BATconst(BATmirror(r), BAThtype(l), BUNhead(l, BUNfirst(l))));
	}

	bn = BATnew(BAThtype(l), BATttype(r), sz);
	if (bn == NULL) {
		return bn;
	}
	if (sz == 0)
		return bn;

	BATmmap_pin(r);
	@:antijoin_switch_lht@
	BATmmap_unpin(r);

	if (bn) {
		bn->hsorted = l->hsorted;
		bn->tsorted = (lc == 1 ? r->tsorted : FALSE);
		bn->hdense = (rc == 1 ? l->hdense : FALSE);
		bn->tdense = (lc == 1 ? r->tdense : FALSE);
		BATkey(bn, (rc == 1 ? l->hkey : FALSE));
		BATkey(BATmirror(bn), (lc == 1 ? r->tkey : FALSE));
		if (!bn->batDirty)
			bn->batDirty = TRUE;
	}

	return bn;
}

@+ Cross Product
This operation computes the cross product of two BATs, returning only the
head-value from the 'left' operand and then tail-value from the 'right'
operand.
@{
@= cross2
BAT*
cross_@1_@2(BAT *bn, BAT *l, BAT *r)
{
	BUN l_cur, l_end, r_cur, r_end, dst;
	int l_sz, r_sz, bn_sz;

	bn_sz = BUNsize(bn);
	dst = BUNfirst(bn);

	ALGODEBUG THRprintf(GDKout, "BATcross: cross_@1_@2();\n");
	BATloopFast(l, l_cur, l_end, l_sz) {
		BATloopFast(r, r_cur, r_end, r_sz) {
			@:bunfastins_nocheck_(@1,@2)@
			dst += bn_sz;
		}
	}
	bn->batBuns->free = dst - bn->batBuns->base;
	BATsetcount(bn,bn->batBuns->free/bn_sz);
	return bn;

bunins_failed:
	BBPreclaim(bn);
	return NULL;
}
@= cross1
	@:cross2(@1,chr)@
	@:cross2(@1,sht)@
	@:cross2(@1,int)@
	@:cross2(@1,lng)@
	@:cross2(@1,VATOM)@
	@:cross2(@1,LATOM)@
@c
@:cross1(chr)@
@:cross1(sht)@
@:cross1(int)@
@:cross1(lng)@

@:cross1(VATOM)@
@:cross1(LATOM)@
@c

@= cross_switch_rtt
{
	int rtt = r->ttype;
	int rts = ATOMstorage(rtt);

	if (rts == TYPE_chr) {
		bn = cross_@1_chr(bn,l,r);
	} else if (rts == TYPE_sht) {
		bn = cross_@1_sht(bn,l,r);
	} else if (rtt != TYPE_bat &&
		   (rts == TYPE_int || rts == TYPE_flt
#if SIZEOF_OID == SIZEOF_INT
		    || rts == TYPE_oid
#endif
		   )) {
		/* ensure use of ATOMput for TYPE_bat */
		bn = cross_@1_int(bn,l,r);
	} else if (rts == TYPE_lng || rts == TYPE_dbl
#if SIZEOF_OID == SIZEOF_LNG
		   || ATOMstorage(lht) == TYPE_oid
#endif
) {
		bn = cross_@1_lng(bn,l,r);
	} else if (r->tvarsized) {
		bn = cross_@1_VATOM(bn,l,r);
	} else {
		bn = cross_@1_LATOM(bn,l,r);
	}
}
@c
@= cross_switch_lht
{
	int lht = l->htype;
	int lhs = ATOMstorage(lht);

	if (lhs == TYPE_chr) {
		@:cross_switch_rtt(chr)@
	} else if (lhs == TYPE_sht) {
		@:cross_switch_rtt(sht)@
	} else if (lht != TYPE_bat &&
		   (lhs == TYPE_int || lhs == TYPE_flt
#if SIZEOF_OID == SIZEOF_INT
		    || lhs == TYPE_oid
#endif
		   )) {
		/* ensure use of ATOMput for TYPE_bat */
		@:cross_switch_rtt(int)@
	} else if (lhs == TYPE_lng || lhs == TYPE_dbl
#if SIZEOF_OID == SIZEOF_LNG
		   || lhs == TYPE_oid
#endif
		   ) {
		@:cross_switch_rtt(lng)@
	} else if (l->hvarsized) {
		@:cross_switch_rtt(VATOM)@
	} else {
		@:cross_switch_rtt(LATOM)@
	}
}
@c
BAT *
BATcross(BAT *l, BAT *r)
{
	BAT *bn;
	size_t lc, rc, sz;

	ERRORcheck(l == NULL, "BATcross: invalid left operand");
	ERRORcheck(r == NULL, "BATcross: invalid right operand");
	lc = BATcount(l);
	rc = BATcount(r);
	sz = lc * rc;

	if (sz > 0) {
		/* try to keep void columns where possible */
		if (rc == 1)
			return BATconst(l, BATttype(r), BUNtail(r, BUNfirst(r)));
		if (lc == 1)
			return BATmirror(BATconst(BATmirror(r), BAThtype(l), BUNhead(l, BUNfirst(l))));
	}

	bn = BATnew(BAThtype(l), BATttype(r), sz);
	if (bn == NULL) {
		return bn;
	}
	if (sz == 0)
		return bn;

	BATmmap_pin(r);
	@:cross_switch_lht@
	BATmmap_unpin(r);

	if (bn) {
		bn->hsorted = l->hsorted;
		bn->tsorted = (lc == 1 ? r->tsorted : FALSE);
		bn->hdense = (rc == 1 ? l->hdense : FALSE);
		bn->tdense = (lc == 1 ? r->tdense : FALSE);
		BATkey(bn, (rc == 1 ? l->hkey : FALSE));
		BATkey(BATmirror(bn), (lc == 1 ? r->tkey : FALSE));
		if (!bn->batDirty)
			bn->batDirty = TRUE;
	}

	return bn;
}

@}
@+ Cartesian product
The matching algorithms tries to construct non-empty matches on all head
columns. Each time this succeeds, it calls the Cartesian routine to
construct a join result that consists of the Cartesian product of these
matches.

The matching tuples can be encoded in two ways:
@table @samp
@item clustered
 here we have two BUN pointers 'hi' and 'lo' that point
to a consecutive range of BUNs in a BAT that match.
@item nonclustered here we have a hit pointer that points to an array
of BUN  pointers that match.
@end table
@{
The below structures are used for keeping track of the matching process.
@c
typedef struct _column_t {
	BAT *b;			/* BAT of this column */
	BUN cur;		/* current BUN in b */
	size_t nhits;		/* number of matched BUNs */

	/* clustered */
	BUN lo;			/* first BUN that matches */
	BUN hi;			/* past last BUN that matches */
	/* nonclustered */
	BUN *hit;		/* BUN array pointer */
	size_t hitsize;		/* size of hit array */

	/* properties */
	ssize_t offset;		/* BUNindex of BUNfirst  */
	struct _column_t *sync;	/* iff > 0: column with synchronous BAT */
	size_t size;		/* size of the BAT */
	char binsearch;		/* sparse matching expected? */
	char ordered;		/* merge matching */
} column_t;

typedef struct {
	RowFcn tuple_fcn;	/* function to invoke per match */
	ptr tuple_data;		/* application-specific data */
	ColFcn *value_fcn;	/* for each col: function to invoke per value */
	ptr *value_data;	/* for each col: application-specific data */
	column_t *c;		/* array of columns */
	int argc;		/* size of c */
} table_t;

static void
column_result(table_t *t, int i)
{
	if (++i > t->argc) {
		/* end of recursion: invoke tuple-match routine */
		t->tuple_fcn(t->tuple_data, t->value_data);
	} else {
		/* recurse over all matches on this column */
		column_t *c = t->c + (i - 1);
		BUN q, *p = c->hit;
		size_t j;

		if (p == NULL) {	/* clustered */
			for (q = c->lo; q < c->hi; q += BUNsize(c->b)) {
				t->value_fcn[i] (t->value_data[i], BUNtail(c->b, q));
				column_result(t, i);
			}
		} else {
			for (j = 0; j < c->nhits; j++, p++) {
				t->value_fcn[i] (t->value_data[i], BUNtail(c->b, *p));
				column_result(t, i);
			}
		}
	}
}

@}
@* MultiColumn Joins
Computes the n-ary equijoin over the head columns of multiple BATs.
This function is complex, and uses nested functions calls,
for the specific stuff, it uses the stack for generating the
Cartesian product on each hit tuple. Most of all, it emits tuples one
at a time, in a pipeline rather than bulk fashion. For all these reasons,
it is not main-memory efficient. It does things that MonetDB actually
specifically was designed to avoid.

USE THIS FUNCTION ONLY WHEN YOU REALLY REALLY HAVE TO:
@table @code
@item  -
printing a multicolumn table to a watching end-user is one such example
@item -
the unoptimized [X](bat,bat,..) MIL multiplex construct is another example
@end table
@+ multijoin entry routine
The multijoin will cause a cascade of value_fcn() calls putting
values in to place, rounded off each time by a tuple_fcn() that is
executed on each produced tuple. If this corresponds 1-1 with
the elements of one of the parameter BAT, the 'result' of the
operation would be aligned with it.

The return value of this operation contains this status information.
It is an integer, of which all 4 bytes are used:
@table @code
@item ret[0] == 1,
if a mergejoin was used, 0 otherwise
@item ret[1] == 1,
if all bats had the key property set, 0 otherwise
@item ret[2] == 1
if there was a 1-1 join, 0 otherwise
@item ret[3] ==
the parameter number of the BAT which was used as leader
@end table
@{
@c
#define COLSIZE(c)\
	(((c)->b->htype!=TYPE_void || (c)->b->hseqbase!=oid_nil)?(c)->size:0)
#define REALLOCBUNS(c,n) if (c->hitsize <= n)\
	c->hit = (BUN*) GDKrealloc(c->hit, (c->hitsize+=n)*sizeof(BUN))

#define LEAD_INTERRUPT_END  1
#define LEAD_TRAVERSE_SSK   3	/* seq, sorted, key */
#define LEAD_TRAVERSE_SNK   4	/* seq, nonsorted, key */
#define LEAD_TRAVERSE_SEQ   6	/* enforced seq (for order purposes) */
#define LEAD_TRAVERSE_SRT   9	/* traverse by sorted chunk */

int
BATmultijoin(int argc, BAT *argv[], RowFcn tuple_fcn, ptr tuple_data, ColFcn value_fcn[], ptr value_data[], int orderby)
{
	column_t *lead_col, *c = (column_t *) alloca(argc * (int) sizeof(column_t));
	column_t **reorder = (column_t **) alloca(argc * (int) sizeof(column_t *));
	int status = 0, algo = LEAD_TRAVERSE_SEQ;
	int i, k;
	BUN p, q, r;
	table_t t;

@-
Init the table descriptor.
@c
	memset(c, 0, argc * sizeof(column_t));
	t.tuple_data = tuple_data;
	t.value_data = value_data;
	t.tuple_fcn = tuple_fcn;
	t.value_fcn = value_fcn;
	t.argc = argc;
	t.c = c;
@-
order columns by their size (smallest first)
@c
	for (i = 0; i < argc; i++) {
		int j;

		c[i].b = argv[i];
		c[i].nhits = 1;	/* default value */
		c[i].offset = (ssize_t) BUNindex(c[i].b, BUNfirst(c[i].b));
		c[i].size = BATcount(c[i].b);

		/* positional lookup possible => ignore other alternatives */
		if (!BAThdense(c[i].b)) 
			c[i].ordered = BAThordered(c[i].b) & 1;

		/* insertion sort on size */
		for (j = 0; j < i; j++) {
			if (COLSIZE(reorder[j]) > COLSIZE(c + i)) {
				for (k = i; k > j; k--) {
					reorder[k] = reorder[k - 1];
				}
				break;
			}
		}
		reorder[j] = c + i;
	}
@}
@- handle explicit ordering requests
An 'orderby' specification tells that the multijoin should match in the
order of one specific BAT parameter.

Notice that we *respect* the ordering of the orderby column rather than we
sort it explicitly (ie; you should order the most significant column beforehand).
This allows for both for join results ordered on some tail column as results
ordered on head column, or even 'reverse' or other specific orderings.
One such specific ordering is the SQL ORDER BY multi-column ordering that
can be obtained with the CTorderby command from the xtables module.
@{
@c
	if (orderby) {		/* order on tail of some column */
		int lead = orderby - 1;

		for (i = 0; i < argc; i++)
			if (reorder[i] == c + lead)
				break;
		while (--i >= 0) {
			reorder[i + 1] = reorder[i];
		}
		reorder[0] = c + lead;
	}
	lead_col = reorder[0];
@}
@- lead column traversal mode
The default action is to do LEAD_TRAVERSE_SEQ: 1-by-1 traversal of the lead_col,
and for each head value use the best possible matching algorithm.
A local optimization is to signal a sorted head column in the lead column,
so we can switch to LEAD_TRAVERSE_SRT; if double lead values occur we do them
in one match iteration.

We record in MULTIJOIN_SORTED(status) whether the chosen traversal method
visits the head values in the lead column in order. This is important
for the matching algorithms of the other columns (only if the head
values are visited in order, merge algorithms may be employed).
@{
@c
	if (BAThordered(lead_col->b) & 1) {
		if (!BAThkey(lead_col->b)) {
			algo = LEAD_TRAVERSE_SRT;
		}
		MULTIJOIN_SORTED(status) = TRUE;
	}
	lead_col->hi = lead_col->cur = BUNfirst(lead_col->b);
	q = BUNlast(lead_col->b);
	MULTIJOIN_KEY(status) = BAThkey(lead_col->b);
	MULTIJOIN_LEAD(status) = lead_col - c;
	MULTIJOIN_SYNCED(status) = 1;
	if (algo == LEAD_TRAVERSE_SEQ && BAThkey(lead_col->b)) {
		algo = (BAThordered(lead_col->b) & 1) ? LEAD_TRAVERSE_SSK : LEAD_TRAVERSE_SNK;
	}
@}

@- matching algorithms for the other columns
Finally, the issue of choosing matching-algorithms for the other columns
is treated. There are a number of possibilities. If a column is
synced with a previous column, this is registered, so it can copy the
matching results of that previous column. If not, we use the fact that a
column is ordered and if not, has an binary index on it. Both cases
fall into two sub cases: merge-lookup or binary-search; depending on
whether we visit the head elements in order (MULTIJOIN_SORTED(status)).
If none of this is the case, we do hash-lookup using an on-the-fly hash-table.
@{
@c
	for (k = 1; k < argc; k++) {
		column_t *n = reorder[k];
		int j;

		for (j = (algo == LEAD_TRAVERSE_SEQ); j < k; j++) {
			if (ALIGNsynced(reorder[j]->b, n->b)) {
				n->sync = (struct _column_t *) reorder[j];
				n->offset -= reorder[j]->offset;
			}
		}
		if (!BAThkey(n->b)) {
			MULTIJOIN_KEY(status) = 0;
			MULTIJOIN_SYNCED(status) = 0;
		}
		if (!MULTIJOIN_SORTED(status)) {
			if (n->size < 4 * lead_col->size) {
				n->ordered = FALSE;
			} else {
				n->binsearch = TRUE;
			}
		} else if (n->size > 40 * lead_col->size) {
			n->binsearch = TRUE;
		}
		if (n->ordered) {
			n->cur = BUNfirst(n->b);
		} else if (!BAThkey(n->b) && n->sync == NULL) {
			if (BATprepareHash(n->b)) {
				GDKerror("BATmultijoin: could not hash '%s'\n", BATgetId(n->b));
				return 0;
			}
			n->hitsize = 20;
			n->hit = (BUN *) GDKmalloc(n->hitsize * sizeof(BUN));
		}
	}

@- the matching phase
We optimize in the case that the head-columns are OID. Below
macro's help to separate the two cases cleanly.
@c
#define OIDcmp(v1,v2)	simple_CMP(v1,v2,oid)
#define STDcmp(v1,v2)	(*cmp)(v1,v2)

	if (ATOMstorage(lead_col->b->htype) == ATOMstorage(TYPE_oid)) {
		@:multijoin(hloc,OID,_oid,_oid)@
	} else {
		int (*cmp) (ptr, ptr) = BATatoms[lead_col->b->htype].atomCmp;

		@:multijoin(head,STD,_any)@
	}
@-
Cleanup & exit.
@c
	for (i = 0; i < argc; i++) {
		if (c[i].hitsize)
			GDKfree(c[i].hit);
	}
	return status;
}

@}
@+ The Matching Algorithm
In multi-column join, all Monet accelerators are put to use when
equi-lookup is done on a number of head columns.  In order of
preference, it:

@itemize
@item
    does positional lookup on @emph{ virtual oid} columns (void).
@item
    reuses lookup info on @emph{ synced columns}.
@item
    uses merge scan on @emph{ ordered columns}.
@item
    uses binary tree leaf scan on @emph{ indexed columns}.
@item
    uses hash lookup in other cases. If a hash-table does not
exist; it is created on the fly.
@end itemize

The algorithm goes one by one, for unique head values in the smallest-sized
BAT. The strategy is for each column to find a range of BUNs that match it.

The algorithm is intelligent in that it processes the columns in order
of cardinality. If a column has no matches, you can cut off the matching
process for the current ID (head value) and go to the next. Smallest BATs
first means highest miss probability first.

Another optimization is that when a column has a cardinality much larger
than the smallest column, you can expect sparse matching (e.g. you selected
1% tuples out of a 1M tuple BAT, and re-joins both with this routine). In
those cases the merge algorithms use binary search instead of mergescan.

In non-empty matching ranges are found in all head columns, a recursive
routine is used to go over all combinations of matching BUNs. This recursive
routine calls for every match (the Cartesian product) a special-purpose
routine that is passed all matching BUN pointers. This sequence of calls
represents the result of the multijoin.

Normally you want to perform an action on each value (like formatting or
copying), but many values reoccur in the same place when the Cartesian product
over all columns is formed.  For instance, when we have 5 attributes in which
each has 2 matches on the current id, we have 2*2*2*2*2=32 result tuples for
this one id. A simple-minded strategy would then do 32*5 value actions, when
processing these result tuples. This multijoin reduces that to just 32, by
calling whenever a value is 'changed' in the result-tuple-under-construction,
a value specific function, provided by the user. Since each column can have
a different value function, this also allows for factoring out type-checking
overhead.
@{
@= multijoin
	while (algo) {
		ptr h;		/* points to current ID */

		/*
		 * find the next leader bun
		 */
		p = lead_col->hi;
		if (p >= q)
			break;
		h = BUNhead(lead_col->b, p);

		/* FIND MATCHING COLUMN RANGES
		 * For each column, find all matches for this head value
		 */
		for (i = 0; i < argc; i++) {
			column_t *m, *n = reorder[i];	/* use BATcount() order */
			BAT *b = n->b;

			/* one-by-one traversal of the lead column? => no matching done.
			 */
			if (n == lead_col) {
				if (argc > 1 && ATOMcmp(b->htype, h, ATOMnilptr(b->htype)) == 0) {
					n->lo = n->hi = p + BUNsize(b);
					break;
				} else if (algo <= LEAD_TRAVERSE_SEQ) {
					n->lo = p;
					n->hi = p + BUNsize(b);
					continue;
				}
			}
			/* Synced lookup
			 * If some BAT is synced with a BAT we already handled ('parent'),
			 * we can simply copy and convert the BUNlists of the parent.
			 */
			if ((m = n->sync) != NULL) {
				if (m->hit) {
					size_t j;

					REALLOCBUNS(n, m->nhits);
					for (j = 0; j < m->nhits; j++) {
						n->hit[j] = BUNptr(n->b, n->offset + BUNindex(m->b, m->hit[j]));
					}
					n->nhits = m->nhits;
				} else {
					n->lo = BUNptr(n->b, n->offset + BUNindex(m->b, m->lo));
					n->hi = BUNptr(n->b, n->offset + BUNindex(m->b, m->hi));
				}
				/* Sorted lookup
				 * We perform a merge scan over the tail column.
				 */
			} else if (n->ordered) {
				BUN last = BUNlast(b);
				int xx = BUNsize(b);

				if (n->binsearch) {
					n->cur = (BUN) SORTfndfirst@4(BATmirror(b), h);
					if (n->cur >= last)
						break;	/* NOT FOUND */
				} else {
					int yy = 1;

					for (; n->cur < last; n->cur += xx)
						if ((yy = @2cmp(BUN@1(b, n->cur), h)) >= 0)
							 break;

					if (yy != 0)
						break;	/* NOT FOUND */
				}
				n->lo = n->cur;
				for (n->nhits = 1; (n->cur += xx) < last; n->nhits++) {
					if (@2cmp(BUN@1(b, n->cur), h))
						 break;
				}
				if (n->cur >= last && (algo & LEAD_INTERRUPT_END))
					algo = 0;
				n->hi = n->cur;
				/* Single Hash lookup
				 */
			} else if (BAThkey(n->b)) {
				BUNfnd@2(n->cur, b, h);
				if (!n->cur)
					break;	/* NOT FOUND */
				n->lo = n->cur;
				n->hi = n->cur + BUNsize(b);
				/* Multiple Hash lookup
				 */
			} else {
				hash_t j;

				n->nhits = 0;
				HASHloop@3(b, b->hhash, j, h, r) {
					REALLOCBUNS(n, n->nhits + 1);
					n->hit[n->nhits++] = r;
				}
				if (n->nhits == 0)
					break;	/* NOT FOUND */
			}
		}
		/* Recursively print the Cartesian product of all match collections of h.
		 */
		if (i >= argc) {
			t.value_fcn[0] (t.value_data[0], h);
			column_result(&t, 0);
		} else {
			MULTIJOIN_SYNCED(status) = 0;	/* a miss occurred somewhere! */
		}
	}
	if (lead_col->hi < q) {
		MULTIJOIN_SYNCED(status) = 0;	/* an interrupt occurred! */
	}
@}
