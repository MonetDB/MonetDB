@f gdk_tm
@a M. L. Kersten, P. Boncz

@* Transaction management
The Transaction Manager maintains the buffer of (permanent) BATS held resident.
Entries from the BAT buffer are always accessed by BAT id.
A BAT becomes permanent by assigning a name with @%BATrename@.
Access to the transaction table is regulated by a semaphore.
@{
@h
#ifndef _GDK_TM_H_
#define _GDK_TM_H_
#include "gdk.h"

#define SYSTRANSACTION	"tmp"
#define MAXTM		10

#endif /* _GDK_TM_H_ */
@c
#include "gdk_tm.h"
#include "gdk_bbp.h"

char			TMname[MAXTM][IDLENGTH] = { SYSTRANSACTION }; 

int TMnew(str s) {
	fprintf(GDKout, "begin transaction %s\n", s); 
	strcpy(TMname[0], s); 

	return 0; 
}

int TMresume(str s) {
	strcpy(TMname[0], s); 
	return 0;
}

str TMcntxt() {
	return TMname[0]; 
}
@
@}
@- 
Upon transaction commit all dirty BATs should be saved on disk.
Dirty bats on disc are only loaded if needed; in most cases
it is enough to handle the (cached) BAT descriptor. 
@{
@
TMfakeCommit updates the BBP_status to a new transaction. It collects old bats which
can be destroyed. The resulting array of bat's can be given to TMkill to destroy these
bats.
@c
int *TMfakeCommit(){
	int i, nkills=0, maxkills = 1024, *kills = GDKmalloc((maxkills+1)*sizeof(int));

        /* succeeded: adapt BBPstatus of all bats while we're still locked */
        for (i = 1; i < BBPsize; i++) {
		if (BBP_status(i)&BBPPERSISTENT) {
			BBP_status_on(i, BBPEXISTING, "TMfakeCommit");
		} else if ((BBP_status(i)&BBPDELETED) && BBP_refs(i) <= 0) {
			/* We cannot kill here, because some complex accelerators (histolink)
                         * need BBP locks in their delete sequence. Hence we must postpone 
                         * their destruction until after the commit has released all locks.
                         */
			if (nkills >= maxkills) {
				kills = (int*) GDKrealloc(kills, ((maxkills*=2)+1)*sizeof(int));
			}
			kills[nkills++] = i;
			BBP_refs(i) = 1; /* make unkillable; so nobody else can kill it */
                        BBP_status_on(i, BBPUNLOADING, "TMfakeCommit"); /* make unloadable */
		}
		BBP_status_off(i, BBPDELETED|BBPSWAPPED|BBPNEW, "TMfakeCommit");
        }
	kills[nkills] = 0;
	return kills;
}


void TMkill(int *kills){
	int *killbuf = kills;
	while(*kills){
                BAT *b = BBPquickdesc(*kills, FALSE);

                if (BBP_cache(*kills)) {
			/* those that quickdesc decides to load => proper unfix */
                        BBPunfix(*kills);
                } else {
                        /* the unloaded ones are deleted without loading */
                        BATdelete(b); /* delete disk images */
                        BBPclear(*kills, TRUE); /* clear with locking */
                }
		kills++;
        }
	if (killbuf) {
		GDKfree(killbuf);
	}
}

int TMcommit() {
	int i, ret = 0, *kills = NULL;

	/* Acquire commit lock */
	MT_set_lock(GDKtmLock, "TMcommit"); 
	
        /* commit the delta status of each BAT */
        for (i = 1; i < BBPsize; i++)  
	if (BBP_status(i) & BBPPERSISTENT) {
		BAT *b;
		BBPfix(i);
		b = BBPcache(i);
		if (b == NULL && (BBP_status(i)&BBPSWAPPED)) {
			b = BBPquickdesc(i, FALSE);
			if (b == NULL) { 
				ret = 1; 
				BBPunfix(i);
				break; 
			}
		}
		if (b) BATcommit(b);
		BBPunfix(i);
	}

        /* atomic write of all dirty BATs and BBP.dir */
	if (ret == 0) ret = BBPsync(TRUE);
	if (ret == 0) kills = TMfakeCommit();
	MT_unset_lock(GDKtmLock, "TMcommit"); 
	/* outside the lock: now kill all ex-persistent bats */
	if (ret == 0) TMkill(kills);
	return ret;
}

@- 
Transaction abort is cheap. We use the delta statuses
to go back to the previous version of each BAT. Also
for BATs that are currently swapped out. Persistent BATs 
that were made transient in this transaction become
persistent again.
@c
int TMabort() {
	int i; 

	MT_set_lock(GDKtmLock, "TMabort"); 
	for (i = 1; i < BBPsize; i++) { 
		if (BBP_status(i) & BBPNEW) {
			BAT *b = BBPcache(i);
			if (b == NULL) {
				b = BATload_intern(i);
			}
			if (b) {
				b->batPersistence &= ~PERSISTENT;
				b->batPersistence |= TRANSIENT;
				b->batDirtydesc = 1;
			}
		}
	}
	for (i = 1; i < BBPsize; i++) { 
		if (BBP_status(i) & (BBPPERSISTENT|BBPDELETED|BBPSWAPPED)) {
			BAT *b = BBPcache(i);
			if (b == NULL) {
				b = BATload_intern(i);
			}
			ALIGNundo(b);
			BATundo(b); 
			if (BBP_status(i)&BBPDELETED) {
				b->batPersistence &= ~TRANSIENT;
				BBP_status_on(i, BBPEXISTING, "TMabort");
				b->batPersistence |= PERSISTENT;
				b->batDirtydesc = 1;
			}					
		}
		BBP_status_off(i, BBPDELETED|BBPSWAPPED|BBPNEW, "TMabort");
	}
	MT_unset_lock(GDKtmLock, "TMabort"); 
	return 0; 
}
@}
