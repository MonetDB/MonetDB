@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f gdk_value
@a Martin L. Kersten & Peter Boncz
@v 2.0 
@+ Value representation

 
When manipulating values, MonetDB puts them into value records.
The built-in types have a direct entry in the union. Others should 
be represented as a pointer of memory in pval or as a string, which
is basically the same. In such cases the @%len@ field indicates
the size of this piece of memory.

MonetDB extenders will use value records for passing parameters to
their new operators. MonetDB algebraic commands receive an 
(argc, argv) combination, where
argc is an integer indicating the size of the the argv array of value 
records. On call, the first record, argv[0], is always empty. The
routine must place its return value - if any - there. The other
values are the parameters.

@{
Actually, the gdk value type defined here should become a built-in
type in the kernel. Next step will be to define the corresponding
extension module.
@}

@{
@+ Value operations
The following primitives are required to manipulate value records.
Note that binding a BAT requires upgrading its reference count.
The receiver of the value should have been cleared or represent
free space.
@c
#include "gdk.h"

ValPtr VALnew(void){
	ValPtr v = (ValPtr) GDKmalloc(sizeof(ValRecord));
	VALempty(v);
	return v;
}

ValPtr VALset(ValPtr v, int t, ptr p){
	switch(ATOMstorage(v->vtype = t)) {
	case TYPE_bit:
	case TYPE_chr: v->val.cval[0] = *(chr*) p; 
		       v->val.cval[1] = 0;
		       v->val.cval[2] = 0;
		       v->val.cval[3] = 0;
		       break;
	case TYPE_sht: v->val.shval = *(sht*) p; break;
	case TYPE_int: v->val.ival = *(int*) p; break;
	case TYPE_flt: v->val.fval = *(flt*) p; break;
	case TYPE_dbl: v->val.dval = *(dbl*) p; break;
	case TYPE_lng: v->val.lval = *(lng*) p; break;
	default:       v->val.pval = p;
		       v->len = ATOMlen(t, p);
	}
	return v;
}

void *VALget(ValPtr v){
	switch(ATOMstorage(v->vtype)) {
	case TYPE_bit:
	case TYPE_chr: return (void *) &v->val.cval[0];
	case TYPE_sht: return (void *) &v->val.shval;
	case TYPE_void:
	case TYPE_int: return (void *) &v->val.ival;
	case TYPE_flt: return (void *) &v->val.fval;
	case TYPE_dbl: return (void *) &v->val.dval;
	case TYPE_lng: return (void *) &v->val.lval;
	case TYPE_str: return (void *) v->val.pval;
	}
	return NULL;
}

void VALclear(ValPtr v){
	if (v->vtype == TYPE_str || ATOMextern(v->vtype)) {
                if(v->val.pval && v->val.pval != str_nil) 
			GDKfree(v->val.pval);
        }
	VALempty(v);
}

void VALempty(ValPtr v){
	v->len = 0;
	v->val.oval = oid_nil;
	v->vtype = TYPE_void;
}

ValPtr VALcopy(ValPtr d, ValPtr s){
	if (!ATOMextern(s->vtype)) {
		*d = *s;
	} else if (s->val.pval == 0) {
                d->val.pval = ATOMnil(s->vtype);
                d->vtype = s->vtype;
	} else if (s->vtype == TYPE_str) {
		d->vtype = TYPE_str;
		d->val.sval = GDKstrdup(s->val.sval);
		d->len = strLen(d->val.sval);
	} else if (s->vtype == TYPE_bit) {
                d->vtype = s->vtype;
                d->len = 1;
		d->val.cval[0] =s->val.cval[0];
	} else {
                ptr p = s->val.pval;
                d->vtype = s->vtype;
                d->len = ATOMlen(d->vtype,p);
                d->val.pval = GDKmalloc(d->len);
		memcpy(d->val.pval, p, d->len);
	}
	return d;
}
@-
VALprint shows the contents of a value record, but without
expanding the BAT contents.
@c
int VALprint(stream *s, ValPtr res){
	int t = ATOMstorage(res->vtype);
	return ATOMprint(t, VALptr(res), s);
}	


int VALformat(char **buf, ValPtr res){
	int t = res->vtype;
	*buf = 0;
	return ATOMformat(t, VALptr(res), buf);
}

@-
The routine @%VALconvert@ transforms a value for interpretation
in a certain type. It uses some standard cast conventions to do this.
The result, a pointer to a value, is returned. If there are
illegal values, or type combinations involved, it gives
up with an ILLEGALVALUE.

@= valcheck
	((@3) @1 < (@3) GDK_@2_min || (@3) @1 > (@3) GDK_@2_max) ? @2_nil : (@2) @1
@= valcheck_r
	/* when converting from oid, there's no need to compare to GDK_@2_min,
	 * since source value is unsigned (i.e. >= 0) and all GDK_*_min values
	 * are <= 0 (in fact, compilers may warn about the test) */
	((@3) @1 > (@3) GDK_@2_max) ? @2_nil : (@2) @1
@= valcheck_l
	/* when converting to oid, there's no need to compare to GDK_@2_max
	 * for those types, where we know that GDK_@2_max <= GDK_oid_max
	 * (in fact, compilers may warn about the test) */
	((@3) @1 < (@3) GDK_@2_min) ? @2_nil : (@2) @1
@= valfconvert
	/* dbl always fits; flt almost always fits */
	switch (src_tpe) {
	case TYPE_bit:
	case TYPE_chr:
		@1 = (@2) t->val.cval[0];
  		break;
	case TYPE_sht:
		@1 = (@2) t->val.shval;
		break;
	case TYPE_int:
		@1 = (@2) t->val.ival;
		break;
	case TYPE_oid:
		@1 = (@2) t->val.oval;
		break;
	case TYPE_lng:
		@1 = (@2) t->val.lval;
		break;
	case TYPE_flt:
		@1 = (@2) t->val.fval;
		break;
	case TYPE_dbl:
		/* only need to do range check on dbl for dbl->flt conversion */
		if (t->val.dval < (dbl) GDK_@2_min || t->val.dval > (dbl) GDK_@2_max)
			@1 = @2_nil;
		else
			@1 = (@2) t->val.dval;
		break;
	case TYPE_bat:
		@1 = (@2) t->val.bval;
		break;
	}
@c
ptr VALconvert(int typ, ValPtr t)
{
	int src_tpe = t->vtype, dst_tpe = typ;
	ptr p = VALptr(t);

	/* use base types for user types */
	if (src_tpe > TYPE_str)
		src_tpe = ATOMstorage(src_tpe);
	if (dst_tpe > TYPE_str)
		dst_tpe = ATOMstorage(dst_tpe);

	if (src_tpe != dst_tpe && t->vtype != typ && dst_tpe != TYPE_void) { 
		if (src_tpe >= TYPE_str || dst_tpe >= TYPE_str) { 
			if (ATOMcmp(src_tpe, ATOMnilptr(src_tpe), p) == 0) {
				VALclear(t);
				VALset(t, dst_tpe, p = ATOMnil(dst_tpe));
			} else { 
				return ILLEGALVALUE; 
			}
		} else if ((t->vtype == TYPE_bat && t->val.bval == 0) ||
	    	           ATOMcmp(src_tpe, ATOMnilptr(src_tpe), p) == 0) {
			memcpy(p, ATOMnilptr(dst_tpe), ATOMsize(dst_tpe));
		} else {
			switch (dst_tpe) {
			case TYPE_bat:
			{
				bat bid = (bat) 0;
				switch (src_tpe) {
				case TYPE_bit:
				case TYPE_chr:
					if (ABS(t->val.cval[0]) <= BBPsize)
						bid = (bat) t->val.cval[0];
					break;
				case TYPE_sht:
					if (ABS(t->val.shval) <= BBPsize)
						bid = (bat) t->val.shval;
					break;
				case TYPE_int:
					if (ABS(t->val.ival) <= BBPsize)
						bid = (bat) t->val.ival;
					break;
				case TYPE_oid:
					if (ABS(t->val.oval) <= BBPsize)
						bid = (bat) t->val.oval;
					break;
				case TYPE_lng:
					if (ABS(t->val.lval) <= BBPsize)
						bid = (bat) t->val.lval;
					break;
				case TYPE_flt:
					if (ABS(t->val.fval) <= BBPsize)
						bid = (bat) t->val.fval;
					break;
				case TYPE_dbl:
					if (ABS(t->val.dval) <= BBPsize)
						bid = (bat) t->val.dval;
					break;
				}
				if (bid == 0 || BBP_logical(bid) == NULL) {
					bid = 0;
					p = ILLEGALVALUE;
				} else {
					p = (ptr) BATdescriptor(bid);
				}
				t->val.bval = bid;
				break;
			}
			case TYPE_bit:
				/* bits are funny: true iff value != 0 */
				switch (src_tpe) {
				case TYPE_bit:
				case TYPE_chr:
					t->val.cval[0] = (t->val.cval[0] != 0);
					break;
				case TYPE_sht:
					t->val.cval[0] = (t->val.shval != 0);
					break;
				case TYPE_int:
					t->val.cval[0] = (t->val.ival != 0);
					break;
				case TYPE_bat:
					t->val.cval[0] = (t->val.bval != 0);
					break;
				case TYPE_oid:
					t->val.cval[0] = (t->val.oval != 0);
					break;
				case TYPE_lng:
					t->val.cval[0] = (t->val.lval != 0);
					break;
				case TYPE_flt:
					t->val.cval[0] = (t->val.fval != 0);
					break;
				case TYPE_dbl:
					t->val.cval[0] = (t->val.dval != 0);
					break;
				}
				break;
			case TYPE_chr:
				switch (src_tpe) {
				case TYPE_bit:
				case TYPE_chr:
					t->val.cval[0] = (chr) t->val.cval[0];
					break;
				case TYPE_sht:
					t->val.cval[0] = @:valcheck(t->val.shval,chr,lng)@;
					break;
				case TYPE_int:
					t->val.cval[0] = @:valcheck(t->val.ival,chr,lng)@;
					break;
				case TYPE_bat:
					t->val.cval[0] = @:valcheck(t->val.bval,chr,lng)@;
					break;
				case TYPE_oid:
					t->val.cval[0] = @:valcheck_r(t->val.oval,chr,lng)@;
					break;
				case TYPE_lng:
					t->val.cval[0] = @:valcheck(t->val.lval,chr,lng)@;
					break;
				case TYPE_flt:
					t->val.cval[0] = @:valcheck(t->val.fval,chr,dbl)@;
					break;
				case TYPE_dbl:
					t->val.cval[0] = @:valcheck(t->val.dval,chr,dbl)@;
					break;
				}
				break;
			case TYPE_sht:
				switch (src_tpe) {
				case TYPE_bit:
				case TYPE_chr:
					t->val.shval = (sht) t->val.cval[0];
					break;
				case TYPE_sht:
					t->val.shval = (sht) t->val.shval;
					break;
				case TYPE_int:
					t->val.shval = @:valcheck(t->val.ival,sht,lng)@;
					break;
				case TYPE_bat:
					t->val.shval = @:valcheck(t->val.bval,sht,lng)@;
					break;
				case TYPE_oid:
					t->val.shval = @:valcheck_r(t->val.oval,sht,lng)@;
					break;
				case TYPE_lng:
					t->val.shval = @:valcheck(t->val.lval,sht,lng)@;
					break;
				case TYPE_flt:
					t->val.shval = @:valcheck(t->val.fval,sht,dbl)@;
					break;
				case TYPE_dbl:
					t->val.shval = @:valcheck(t->val.dval,sht,dbl)@;
					break;
				}
				break;
			case TYPE_int:
				switch (src_tpe) {
				case TYPE_bit:
				case TYPE_chr:
					t->val.ival = (int) t->val.cval[0];
					break;
				case TYPE_sht:
					t->val.ival = (int) t->val.shval;
					break;
				case TYPE_int:
					t->val.ival = (int) t->val.ival;
					break;
				case TYPE_bat:
					t->val.ival = (int) t->val.bval;
					break;
				case TYPE_oid:
					t->val.ival = @:valcheck_r(t->val.oval,int,lng)@;
					break;
				case TYPE_lng:
					t->val.ival = @:valcheck(t->val.lval,int,lng)@;
					break;
				case TYPE_flt:
					t->val.ival = @:valcheck(t->val.fval,int,dbl)@;
					break;
				case TYPE_dbl:
					t->val.ival = @:valcheck(t->val.dval,int,dbl)@;
					break;
				}
				break;
			case TYPE_oid:
				switch (src_tpe) {
				case TYPE_bit:
				case TYPE_chr:
					t->val.oval = @:valcheck_l(t->val.cval[0],oid,lng)@;
					break;
				case TYPE_sht:
					t->val.oval = @:valcheck_l(t->val.shval,oid,lng)@;
					break;
				case TYPE_int:
					t->val.oval = @:valcheck_l(t->val.ival,oid,lng)@;
					break;
				case TYPE_bat:
					t->val.oval = @:valcheck_l(t->val.bval,oid,lng)@;
					break;
				case TYPE_oid:
					t->val.oval = (oid) t->val.oval;
					break;
				case TYPE_lng:
					t->val.oval = @:valcheck(t->val.lval,oid,lng)@;
					break;
				case TYPE_flt:
					t->val.oval = @:valcheck(t->val.fval,oid,dbl)@;
					break;
				case TYPE_dbl:
					t->val.oval = @:valcheck(t->val.dval,oid,dbl)@;
					break;
				}
				break;
			case TYPE_lng:
				switch (src_tpe) {
				case TYPE_bit:
				case TYPE_chr:
					t->val.lval = (lng) t->val.cval[0];
					break;
				case TYPE_sht:
					t->val.lval = (lng) t->val.shval;
					break;
				case TYPE_int:
					t->val.lval = (lng) t->val.ival;
					break;
				case TYPE_bat:
					t->val.lval = (lng) t->val.bval;
					break;
				case TYPE_oid:
					t->val.lval = (lng) t->val.oval;
					break;
				case TYPE_lng:
					t->val.lval = (lng) t->val.lval;
					break;
				case TYPE_flt:
					t->val.lval = @:valcheck(t->val.fval,lng,dbl)@;
					break;
				case TYPE_dbl:
					t->val.lval = @:valcheck(t->val.dval,lng,dbl)@;
					break;
				}
				break;
			case TYPE_flt:
				@:valfconvert(t->val.fval,flt)@;
				break;
			case TYPE_dbl:
				@:valfconvert(t->val.dval,dbl)@;
				break;
			}
		}
	}
	t->vtype = typ;
	return p;
}

@}
@
