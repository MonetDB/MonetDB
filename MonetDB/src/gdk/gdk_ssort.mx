@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2007 CWI.
@' All Rights Reserved.

@f gdk_ssort
@a Sjoerd Mullender
@* Ssort
This file implements a stable sort algorithm.  The algorithm is a
straight copy of the listsort function in the Python 2.5 source code,
heavily modified to fit into the MonetDB environment.
@{
@c
#include "monetdb_config.h"
#include "gdk.h"

/* The maximum number of entries in a MergeState's pending-runs stack.
   This is enough to sort arrays of size up to about
       32 * phi ** MAX_MERGE_PENDING
   where phi ~= 1.618.  85 is ridiculously large enough, good for an array
   with 2**64 elements. */
#define MAX_MERGE_PENDING 85

/* When we get into galloping mode, we stay there until both runs win less
   often than MIN_GALLOP consecutive times.  See listsort.txt for more info. */
#define MIN_GALLOP 7

/* Avoid malloc for small temp arrays. */
#define MERGESTATE_TEMP_SIZE (256 * sizeof(void *))

/* One MergeState exists on the stack per invocation of mergesort.  It's just
   a convenient way to pass state around among the helper functions. */
struct slice {
	void *base;
	ssize_t len;
};

typedef struct {
	/* The comparison function. */
	int (*compare)(ptr, ptr);
	char *base;
	int width;
	int loc;
	/* Temporary storage for a single entry. If an entry is at
	   most 2 lng's, we don't need to allocate anything. */
	void *t;
	char tempstorage[2 * sizeof(lng)];

	/* This controls when we get *into* galloping mode.  It's
	   initialized to MIN_GALLOP.  merge_lo and merge_hi tend to
	   nudge it higher for random data, and lower for highly
	   structured data. */
	ssize_t min_gallop;

	/* 'a' is temp storage to help with merges.  It contains room
	   for alloced entries. */
	void **a;
	ssize_t alloced;

	/* A stack of n pending runs yet to be merged.  Run #i starts
	   at address base[i] and extends for len[i] elements.  It's
	   always true (so long as the indices are in bounds) that

		pending[i].base + pending[i].len == pending[i+1].base

	   so we could cut the storage for this, but it's a minor
	   amount, and keeping all the info explicit simplifies the
	   code. */
	int n;
	struct slice pending[MAX_MERGE_PENDING];

	/* 'a' points to this when possible, rather than muck with
	   malloc. */
	char temparray[MERGESTATE_TEMP_SIZE];
} MergeState;

/* Free all the temp memory owned by the MergeState.  This must be called
   when you're done with a MergeState, and may be called before then if
   you want to free the temp memory early. */
static void
merge_freemem(MergeState *ms)
{
	assert(ms != NULL);
	if (ms->a != (void *) ms->temparray)
		GDKfree(ms->a);
	ms->a = (void *) ms->temparray;
	ms->alloced = MERGESTATE_TEMP_SIZE;
}

/* Ensure enough temp memory for 'need' array slots is available.
   Returns 0 on success and -1 if the memory can't be gotten. */
static int
merge_getmem(MergeState *ms, ssize_t need)
{
	assert(ms != NULL);
	need *= ms->width;
	if (need <= ms->alloced)
		return 0;
	/* Don't realloc!  That can cost cycles to copy the old data, but
	   we don't care what's in the block.
	 */
	merge_freemem(ms);
	ms->a = GDKmalloc(need);
	if (ms->a) {
		ms->alloced = need;
		return 0;
	}
	GDKerror("GDKssort: not enough memory\n");
	merge_freemem(ms);	/* reset to sane state */
	return -1;
}

#define PTRADD(p, n, w)		((void *) ((char *) (p) + (n) * (w)))

#define COPY(d,s,w) do {					\
		switch (w) {					\
		case sizeof(bte):				\
			* (bte *) (d) = * (bte *) (s);		\
			break;					\
		case sizeof(sht):				\
			* (sht *) (d) = * (sht *) (s);		\
			break;					\
		case sizeof(int):				\
			* (int *) (d) = * (int *) (s);		\
			break;					\
		case sizeof(lng):				\
			* (lng *) (d) = * (lng *) (s);		\
			break;					\
		case 2 * sizeof(lng):				\
			* (lng *) (d) = * (lng *) (s);		\
			* ((lng *) (d) + 1) = * ((lng *) (s) + 1);	\
			break;					\
		default:					\
			memcpy((d), (s), (size_t) (w));		\
			break;					\
		}						\
	} while (0)

#define ISLT_any(X, Y, ms)  (((ms)->base ? (*(ms)->compare)((ms)->base + * (var_t *) PTRADD((X), (ms)->loc, 1), (ms)->base + * (var_t *) PTRADD((Y), (ms)->loc, 1)) : (*(ms)->compare)(PTRADD((X), (ms)->loc, 1), PTRADD((Y), (ms)->loc, 1))) < 0)
#define ISLT_any_rev(X, Y, ms)  (((ms)->base ? (*(ms)->compare)((ms)->base + * (var_t *) PTRADD((X), (ms)->loc, 1), (ms)->base + * (var_t *) PTRADD((Y), (ms)->loc, 1)) : (*(ms)->compare)(PTRADD((X), (ms)->loc, 1), PTRADD((Y), (ms)->loc, 1))) > 0)
@= islt
#define ISLT_@1@2(X, Y, ms)	(* (@1 *) PTRADD((X), (ms)->loc, 1) @3 * (@1 *) PTRADD((Y), (ms)->loc, 1))
@c
@:islt(chr,,<)@
@:islt(chr,_rev,>)@
@:islt(bte,,<)@
@:islt(bte,_rev,>)@
@:islt(sht,,<)@
@:islt(sht,_rev,>)@
@:islt(int,,<)@
@:islt(int,_rev,>)@
@:islt(lng,,<)@
@:islt(lng,_rev,>)@
@:islt(flt,,<)@
@:islt(flt,_rev,>)@
@:islt(dbl,,<)@
@:islt(dbl,_rev,>)@
@:islt(oid,,<)@
@:islt(oid,_rev,>)@

/* Reverse a slice of a list in place, from lo up to (exclusive) hi. */
static void
reverse_slice(void *lo, void *hi, MergeState *ms)
{
	void *t;
	int width;

	assert(lo && hi);
	assert(ms);

	t = ms->t;
	width = ms->width;

	hi = PTRADD(hi, -1, width);
	while (lo < hi) {
		COPY(t, lo, width);
		COPY(lo, hi, width);
		COPY(hi, t, width);
		lo = PTRADD(lo, 1, width);
		hi = PTRADD(hi, -1, width);
	}
}

#define MERGE_GETMEM(MS, NEED) ((NEED) * (MS)->width <= (MS)->alloced ? 0 :	\
				merge_getmem(MS, NEED))

@= ssort
/* binarysort is the best method for sorting small arrays: it does
   few compares, but can do data movement quadratic in the number of
   elements.
   [lo, hi) is a contiguous slice of a list, and is sorted via
   binary insertion.  This sort is stable.
   On entry, must have lo <= start <= hi, and that [lo, start) is already
   sorted (pass start == lo if you don't know!). */
static void
binarysort_@1@2(void *lo, void *hi, void *start, MergeState *ms)
{
	register void *l, *p, *r;

	assert(lo <= start && start <= hi);
	/* assert [lo, start) is sorted */
	if (lo == start)
		start = PTRADD(start, 1, ms->width);
	/* [lo,start) is sorted, insert start (the pivot) into this
	   area, finding its position using binary search. */
	for (; start < hi; start = PTRADD(start, 1, ms->width)) {
		/* set l to where start belongs */
		l = lo;
		r = start;
		/* ms->t is the pivot */
		COPY(ms->t, r, ms->width);
		/* Invariants:
		   pivot >= all in [lo, l).
		   pivot  < all in [r, start).
		   The second is vacuously true at the start.
		 */
		assert(l < r);
		do {
			p = PTRADD(l, (((char *) r - (char *) l) / ms->width) >> 1, ms->width);
			if (ISLT_@1@2(ms->t, p, ms))
				r = p;
			else
				l = PTRADD(p, 1, ms->width);
		} while (l < r);
		assert(l == r);
		/* The invariants still hold, so pivot >= all in [lo, l) and
		   pivot < all in [l, start), so pivot belongs at l.  Note
		   that if there are elements equal to pivot, l points to the
		   first slot after them -- that's why this sort is stable.
		   Slide over to make room.
		   Caution: using memmove is much slower under MSVC 5;
		   we're not usually moving many slots. */
		for (p = start, r = PTRADD(p, -1, ms->width); p > l; p = r, r = PTRADD(p, -1, ms->width))
			COPY(p, r, ms->width);
		COPY(l, ms->t, ms->width);
	}
}

/* Locate the proper position of key in a sorted vector; if the vector contains
   an element equal to key, return the position immediately to the left of
   the leftmost equal element.  [gallop_right() does the same except returns
   the position to the right of the rightmost equal element (if any).]

   "a" is a sorted vector with n elements, starting at a[0].  n must be > 0.

   "hint" is an index at which to begin the search, 0 <= hint < n.  The closer
   hint is to the final result, the faster this runs.

   The return value is the int k in 0..n such that

	a[k-1] < key <= a[k]

   pretending that *(a-1) is minus infinity and a[n] is plus infinity.  IOW,
   key belongs at index k; or, IOW, the first k elements of a should precede
   key, and the last n-k should follow key.

   Returns -1 on error.  See listsort.txt for info on the method. */
static ssize_t
gallop_left_@1@2(void *key, void *a, ssize_t n, ssize_t hint, MergeState *ms)
{
	ssize_t ofs;
	ssize_t lastofs;
	ssize_t k;

	assert(key && a && n > 0 && hint >= 0 && hint < n);

	a = PTRADD(a, hint, ms->width);
	lastofs = 0;
	ofs = 1;
	if (ISLT_@1@2(a, key, ms)) {
		/* a[hint] < key -- gallop right, until
		   a[hint + lastofs] < key <= a[hint + ofs]
		 */
		const ssize_t maxofs = n - hint;	/* &a[n-1] is highest */
		while (ofs < maxofs) {
			if (ISLT_@1@2(PTRADD(a, ofs, ms->width), key, ms)) {
				lastofs = ofs;
				ofs = (ofs << 1) + 1;
				if (ofs <= 0)	/* int overflow */
					ofs = maxofs;
			} else	/* key <= a[hint + ofs] */
				break;
		}
		if (ofs > maxofs)
			ofs = maxofs;
		/* Translate back to offsets relative to &a[0]. */
		lastofs += hint;
		ofs += hint;
	} else {
		/* key <= a[hint] -- gallop left, until
		   a[hint - ofs] < key <= a[hint - lastofs]
		 */
		const ssize_t maxofs = hint + 1;	/* &a[0] is lowest */
		while (ofs < maxofs) {
			if (ISLT_@1@2(PTRADD(a, -ofs, ms->width), key, ms))
				break;
			/* key <= a[hint - ofs] */
			lastofs = ofs;
			ofs = (ofs << 1) + 1;
			if (ofs <= 0)	/* int overflow */
				ofs = maxofs;
		}
		if (ofs > maxofs)
			ofs = maxofs;
		/* Translate back to positive offsets relative to &a[0]. */
		k = lastofs;
		lastofs = hint - ofs;
		ofs = hint - k;
	}
	a = PTRADD(a, -hint, ms->width);

	assert(-1 <= lastofs && lastofs < ofs && ofs <= n);
	/* Now a[lastofs] < key <= a[ofs], so key belongs somewhere to the
	   right of lastofs but no farther right than ofs.  Do a binary
	   search, with invariant a[lastofs-1] < key <= a[ofs].
	 */
	++lastofs;
	while (lastofs < ofs) {
		ssize_t m = lastofs + ((ofs - lastofs) >> 1);

		if (ISLT_@1@2(PTRADD(a, m, ms->width), key, ms))
			lastofs = m + 1; /* a[m] < key */
		else
			ofs = m;	/* key <= a[m] */
	}
	assert(lastofs == ofs);		/* so a[ofs-1] < key <= a[ofs] */
	return ofs;
}

/* Exactly like gallop_left(), except that if key already exists in a[0:n],
   finds the position immediately to the right of the rightmost equal value.

   The return value is the int k in 0..n such that

	a[k-1] <= key < a[k]

   or -1 if error.

   The code duplication is massive, but this is enough different given that
   we're sticking to "<" comparisons that it's much harder to follow if
   written as one routine with yet another "left or right?" flag. */
static ssize_t
gallop_right_@1@2(void *key, void *a, ssize_t n, ssize_t hint, MergeState *ms)
{
	ssize_t ofs;
	ssize_t lastofs;
	ssize_t k;

	assert(key && a && n > 0 && hint >= 0 && hint < n);

	a = PTRADD(a, hint, ms->width);
	lastofs = 0;
	ofs = 1;
	if (ISLT_@1@2(key, a, ms)) {
		/* key < a[hint] -- gallop left, until
		   a[hint - ofs] <= key < a[hint - lastofs]
		 */
		const ssize_t maxofs = hint + 1;	/* &a[0] is lowest */
		while (ofs < maxofs) {
			if (ISLT_@1@2(key, PTRADD(a, -ofs, ms->width), ms)) {
				lastofs = ofs;
				ofs = (ofs << 1) + 1;
				if (ofs <= 0)	/* int overflow */
					ofs = maxofs;
			} else	/* a[hint - ofs] <= key */
				break;
		}
		if (ofs > maxofs)
			ofs = maxofs;
		/* Translate back to positive offsets relative to &a[0]. */
		k = lastofs;
		lastofs = hint - ofs;
		ofs = hint - k;
	} else {
		/* a[hint] <= key -- gallop right, until
		   a[hint + lastofs] <= key < a[hint + ofs]
		*/
		const ssize_t maxofs = n - hint;	/* &a[n-1] is highest */
		while (ofs < maxofs) {
			if (ISLT_@1@2(key, PTRADD(a, ofs, ms->width), ms))
				break;
			/* a[hint + ofs] <= key */
			lastofs = ofs;
			ofs = (ofs << 1) + 1;
			if (ofs <= 0)	/* int overflow */
				ofs = maxofs;
		}
		if (ofs > maxofs)
			ofs = maxofs;
		/* Translate back to offsets relative to &a[0]. */
		lastofs += hint;
		ofs += hint;
	}
	a = PTRADD(a, -hint, ms->width);

	assert(-1 <= lastofs && lastofs < ofs && ofs <= n);
	/* Now a[lastofs] <= key < a[ofs], so key belongs somewhere to the
	   right of lastofs but no farther right than ofs.  Do a binary
	   search, with invariant a[lastofs-1] <= key < a[ofs].
	 */
	++lastofs;
	while (lastofs < ofs) {
		ssize_t m = lastofs + ((ofs - lastofs) >> 1);

		if (ISLT_@1@2(key, PTRADD(a, m, ms->width), ms))
			ofs = m;	/* key < a[m] */
		else
			lastofs = m+1;	/* a[m] <= key */
	}
	assert(lastofs == ofs);		/* so a[ofs-1] <= key < a[ofs] */
	return ofs;
}

/* Merge the two runs at stack indices i and i+1.
   Returns 0 on success, -1 on error. */
static ssize_t
merge_at_@1@2(MergeState *ms, ssize_t i)
{
	void *pa, *pb;
	ssize_t na, nb;
	ssize_t k;

	assert(ms != NULL);
	assert(ms->n >= 2);
	assert(i >= 0);
	assert(i == ms->n - 2 || i == ms->n - 3);

	pa = ms->pending[i].base;
	na = ms->pending[i].len;
	pb = ms->pending[i + 1].base;
	nb = ms->pending[i + 1].len;
	assert(na > 0 && nb > 0);
	assert(PTRADD(pa, na, ms->width) == pb);

	/* Record the length of the combined runs; if i is the 3rd-last
	   run now, also slide over the last run (which isn't involved
	   in this merge).  The current run i+1 goes away in any case.
	 */
	ms->pending[i].len = na + nb;
	if (i == ms->n - 3)
		ms->pending[i + 1] = ms->pending[i + 2];
	--ms->n;

	/* Where does b start in a?  Elements in a before that can be
	   ignored (already in place).
	 */
	k = gallop_right_@1@2(pb, pa, na, 0, ms);
	pa = PTRADD(pa, k, ms->width);
	na -= k;
	if (na == 0)
		return 0;

	/* Where does a end in b?  Elements in b after that can be
	   ignored (already in place).
	 */
	nb = gallop_left_@1@2(PTRADD(pa, na - 1, ms->width), pb, nb, nb-1, ms);
	if (nb <= 0)
		return nb;

	/* Merge what remains of the runs, using a temp array with
	   min(na, nb) elements.
	 */
	if (na <= nb) {
/* Merge the na elements starting at pa with the nb elements starting at pb
   in a stable way, in-place.  na and nb must be > 0, and pa + na == pb.
   Must also have that *pb < *pa, that pa[na-1] belongs at the end of the
   merge, and should have na <= nb.  See listsort.txt for more info.
   Return 0 if successful, -1 if error. */
		void *dest;
		ssize_t min_gallop = ms->min_gallop;

		assert(ms && pa && pb && na > 0 && nb > 0 && PTRADD(pa, na, ms->width) == pb);
		if (MERGE_GETMEM(ms, na) < 0)
			return -1;
		COPY(ms->a, pa, na * ms->width);
		dest = pa;
		pa = ms->a;

		COPY(dest, pb, ms->width);
		dest = PTRADD(dest, 1, ms->width);
		pb = PTRADD(pb, 1, ms->width);
		--nb;
		if (nb == 0)
			goto SucceedA;
		if (na == 1)
			goto CopyB;

		for (;;) {
			ssize_t acount = 0;	/* # of times A won in a row */
			ssize_t bcount = 0;	/* # of times B won in a row */

			/* Do the straightforward thing until (if ever) one run
			   appears to win consistently.
			 */
			for (;;) {
				assert(na > 1 && nb > 0);
				k = ISLT_@1@2(pb, pa, ms);
				if (k) {
					COPY(dest, pb, ms->width);
					dest = PTRADD(dest, 1, ms->width);
					pb = PTRADD(pb, 1, ms->width);
					++bcount;
					acount = 0;
					--nb;
					if (nb == 0)
						goto SucceedA;
					if (bcount >= min_gallop)
						break;
				} else {
					COPY(dest, pa, ms->width);
					dest = PTRADD(dest, 1, ms->width);
					pa = PTRADD(pa, 1, ms->width);
					++acount;
					bcount = 0;
					--na;
					if (na == 1)
						goto CopyB;
					if (acount >= min_gallop)
						break;
				}
			}

			/* One run is winning so consistently that galloping may
			   be a huge win.  So try that, and continue galloping until
			   (if ever) neither run appears to be winning consistently
			   anymore.
			 */
			++min_gallop;
			do {
				assert(na > 1 && nb > 0);
				min_gallop -= min_gallop > 1;
				ms->min_gallop = min_gallop;
				k = gallop_right_@1@2(pb, pa, na, 0, ms);
				acount = k;
				if (k) {
					COPY(dest, pa, k * ms->width);
					dest = PTRADD(dest, k, ms->width);
					pa = PTRADD(pa, k, ms->width);
					na -= k;
					if (na == 1)
						goto CopyB;
					/* na==0 is impossible now if the comparison
					   function is consistent, but we can't assume
					   that it is.
					 */
					if (na == 0)
						goto SucceedA;
				}
				COPY(dest, pb, ms->width);
				dest = PTRADD(dest, 1, ms->width);
				pb = PTRADD(pb, 1, ms->width);
				--nb;
				if (nb == 0)
					goto SucceedA;

				k = gallop_left_@1@2(pa, pb, nb, 0, ms);
				bcount = k;
				if (k) {
					memmove(dest, pb, k * ms->width);
					dest = PTRADD(dest, k, ms->width);
					pb = PTRADD(pb, k, ms->width);
					nb -= k;
					if (nb == 0)
						goto SucceedA;
				}
				COPY(dest, pa, ms->width);
				dest = PTRADD(dest, 1, ms->width);
				pa = PTRADD(pa, 1, ms->width);
				--na;
				if (na == 1)
					goto CopyB;
			} while (acount >= MIN_GALLOP || bcount >= MIN_GALLOP);
			++min_gallop;	/* penalize it for leaving galloping mode */
			ms->min_gallop = min_gallop;
		}
	SucceedA:
		if (na)
			COPY(dest, pa, na * ms->width);
		return 0;
	CopyB:
		assert(na == 1 && nb > 0);
		/* The last element of pa belongs at the end of the merge. */
		memmove(dest, pb, nb * ms->width);
		COPY(PTRADD(dest, nb, ms->width), pa, ms->width);
		return 0;
	} else {
/* Merge the na elements starting at pa with the nb elements starting at pb
   in a stable way, in-place.  na and nb must be > 0, and pa + na == pb.
   Must also have that *pb < *pa, that pa[na-1] belongs at the end of the
   merge, and should have na >= nb.  See listsort.txt for more info.
   Return 0 if successful, -1 if error. */
		void *dest;
		void *basea;
		void *baseb;
		ssize_t min_gallop = ms->min_gallop;

		assert(ms && pa && pb && na > 0 && nb > 0 && PTRADD(pa, na, ms->width) == pb);
		if (MERGE_GETMEM(ms, nb) < 0)
			return -1;
		dest = PTRADD(pb, nb - 1, ms->width);
		COPY(ms->a, pb, nb * ms->width);
		basea = pa;
		baseb = ms->a;
		pb = PTRADD(ms->a, nb - 1, ms->width);
		pa = PTRADD(pa, na - 1, ms->width);

		COPY(dest, pa, ms->width);
		dest = PTRADD(dest, -1, ms->width);
		pa = PTRADD(pa, -1, ms->width);
		--na;
		if (na == 0)
			goto SucceedB;
		if (nb == 1)
			goto CopyA;

		for (;;) {
			ssize_t acount = 0;	/* # of times A won in a row */
			ssize_t bcount = 0;	/* # of times B won in a row */

			/* Do the straightforward thing until (if ever) one run
			   appears to win consistently.
			 */
			for (;;) {
				assert(na > 0 && nb > 1);
				k = ISLT_@1@2(pb, pa, ms);
				if (k) {
					COPY(dest, pa, ms->width);
					dest = PTRADD(dest, -1, ms->width);
					pa = PTRADD(pa, -1, ms->width);
					++acount;
					bcount = 0;
					--na;
					if (na == 0)
						goto SucceedB;
					if (acount >= min_gallop)
						break;
				} else {
					COPY(dest, pb, ms->width);
					dest = PTRADD(dest, -1, ms->width);
					pb = PTRADD(pb, -1, ms->width);
					++bcount;
					acount = 0;
					--nb;
					if (nb == 1)
						goto CopyA;
					if (bcount >= min_gallop)
						break;
				}
			}

			/* One run is winning so consistently that galloping may
			   be a huge win.  So try that, and continue galloping until
			   (if ever) neither run appears to be winning consistently
			   anymore.
			 */
			++min_gallop;
			do {
				assert(na > 0 && nb > 1);
				min_gallop -= min_gallop > 1;
				ms->min_gallop = min_gallop;
				k = gallop_right_@1@2(pb, basea, na, na - 1, ms);
				k = na - k;
				acount = k;
				if (k) {
					dest = PTRADD(dest, -k, ms->width);
					pa = PTRADD(pa, -k, ms->width);
					memmove(PTRADD(dest, 1, ms->width),
						PTRADD(pa, 1, ms->width),
						k * ms->width);
					na -= k;
					if (na == 0)
						goto SucceedB;
				}
				COPY(dest, pb, ms->width);
				dest = PTRADD(dest, -1, ms->width);
				pb = PTRADD(pb, -1, ms->width);
				--nb;
				if (nb == 1)
					goto CopyA;

				k = gallop_left_@1@2(pa, baseb, nb, nb - 1, ms);
				k = nb - k;
				bcount = k;
				if (k) {
					dest = PTRADD(dest, -k, ms->width);
					pb = PTRADD(pb, -k, ms->width);
					memmove(PTRADD(dest, 1, ms->width),
						PTRADD(pb, 1, ms->width),
						k * ms->width);
					nb -= k;
					if (nb == 1)
						goto CopyA;
					/* nb==0 is impossible now if the comparison
					   function is consistent, but we can't assume
					   that it is.
					 */
					if (nb == 0)
						goto SucceedB;
				}
				COPY(dest, pa, ms->width);
				dest = PTRADD(dest, -1, ms->width);
				pa = PTRADD(pa, -1, ms->width);
				--na;
				if (na == 0)
					goto SucceedB;
			} while (acount >= MIN_GALLOP || bcount >= MIN_GALLOP);
			++min_gallop;	/* penalize it for leaving galloping mode */
			ms->min_gallop = min_gallop;
		}
	SucceedB:
		if (nb)
			COPY(PTRADD(dest, 1 - nb, ms->width), baseb, nb * ms->width);
		return 0;
	CopyA:
		assert(nb == 1 && na > 0);
		/* The first element of pb belongs at the front of the merge. */
		dest = PTRADD(dest, -na, ms->width);
		pa = PTRADD(pa, -na, ms->width);
		memmove(PTRADD(dest, 1, ms->width),
			PTRADD(pa, 1, ms->width),
			na * ms->width);
		COPY(dest, pb, ms->width);
		return 0;
	}
}

@c
#ifndef NOEXPAND_CHR
@:ssort(chr,)@
@:ssort(chr,_rev)@
#endif
#ifndef NOEXPAND_BTE
@:ssort(bte,)@
@:ssort(bte,_rev)@
#endif
#ifndef NOEXPAND_SHT
@:ssort(sht,)@
@:ssort(sht,_rev)@
#endif
#ifndef NOEXPAND_INT
@:ssort(int,)@
@:ssort(int,_rev)@
#endif
#ifndef NOEXPAND_LNG
@:ssort(lng,)@
@:ssort(lng,_rev)@
#endif
#ifndef NOEXPAND_FLT
@:ssort(flt,)@
@:ssort(flt,_rev)@
#endif
#ifndef NOEXPAND_DBL
@:ssort(dbl,)@
@:ssort(dbl,_rev)@
#endif
#ifndef NOEXPAND_OID
@:ssort(oid,)@
@:ssort(oid,_rev)@
#endif
@:ssort(any,)@
@:ssort(any,_rev)@

static ssize_t
merge_compute_minrun(ssize_t n)
{
	ssize_t r = 0;		/* becomes 1 if any 1 bits are shifted off */

	assert(n >= 0);
	while (n >= 16) {
		r |= n & 1;
		n >>= 1;
	}
	return n + r;
}

@= do_ssort
		do {
			int descending;
			ssize_t n;

			/* Identify next run. */
			{
/* Return the length of the run beginning at lo, in the slice [lo,
   hi).  lo < hi is required on entry.  "A run" is the longest
   ascending sequence, with

	lo[0] <= lo[1] <= lo[2] <= ...

   or the longest descending sequence, with

	lo[0] > lo[1] > lo[2] > ...

   Boolean descending is set to 0 in the former  case, or to 1 in the
   latter.  For its intended use in a stable mergesort, the strictness
   of the defn of "descending" is needed so that the caller can safely
   reverse a descending sequence without violating stability (strict >
   ensures there are no equal elements to get out of order). */
				void *nlo;
				void *olo;

				assert(lo < hi);
				descending = 0;
				olo = lo;
				nlo = PTRADD(lo, 1, width);
				if (nlo == hi) {
					n = 1;
				} else {
					n = 2;
					if (ISLT_@1@2(nlo, olo, &ms)) {
						descending = 1;
						for (olo = nlo, nlo = PTRADD(nlo, 1, width);
						     nlo < hi;
						     olo = nlo, nlo = PTRADD(nlo, 1, width), ++n) {
							if (!ISLT_@1@2(nlo, olo, &ms))
								break;
						}
					}
					else {
						for (olo = nlo, nlo = PTRADD(nlo, 1, width);
						     nlo < hi;
						     olo = nlo, nlo = PTRADD(nlo, 1, width), ++n) {
							if (ISLT_@1@2(nlo, olo, &ms))
								break;
						}
					}
				}
			}
			if (descending)
				reverse_slice(lo, PTRADD(lo, n, width), &ms);
			/* If short, extend to min(minrun, nremaining). */
			if (n < minrun) {
				ssize_t force = nremaining <= minrun ? nremaining : minrun;

				binarysort_@1@2(lo, PTRADD(lo, force, width), PTRADD(lo, n, width), &ms);
				n = force;
			}
			/* Push run onto pending-runs stack, and maybe merge. */
			assert(ms.n < MAX_MERGE_PENDING);
			ms.pending[ms.n].base = lo;
			ms.pending[ms.n].len = n;
			ms.n++;
			{
/* Examine the stack of runs waiting to be merged, merging adjacent runs
   until the stack invariants are re-established:

   1. len[-3] > len[-2] + len[-1]
   2. len[-2] > len[-1]

   See listsort.txt for more info.

   Returns 0 on success, -1 on error. */
				struct slice *p = ms.pending;

				while (ms.n > 1) {
					ssize_t i = ms.n - 2;

					if (i > 0 && p[i - 1].len <= p[i].len + p[i + 1].len) {
						if (p[i - 1].len < p[i + 1].len)
							--i;
						if (merge_at_@1@2(&ms, i) < 0)
							goto fail;
					} else if (p[i].len <= p[i + 1].len) {
						 if (merge_at_@1@2(&ms, i) < 0)
							goto fail;
					} else
						break;
				}
			}
			/* Advance to find next run. */
			lo = PTRADD(lo, n, width);
			nremaining -= n;
		} while (nremaining > 0);
		assert(lo == hi);

		{
/* Regardless of invariants, merge all runs on the stack until only one
   remains.  This is used at the end of the mergesort.

   Returns 0 on success, -1 on error. */
			struct slice *p = ms.pending;

			while (ms.n > 1) {
				ssize_t n = ms.n - 2;

				if (n > 0 && p[n - 1].len < p[n + 1].len)
			      		--n;
				if (merge_at_@1@2(&ms, n) < 0)
					goto fail;
			}
		}
@c

@= GDKsort
/* Stable sort an array "a".
   "nitems" is the number of items to sort; "width" is the size of the
   items, "tpe" is the type of the key within the items, "loc" is the
   location (offset) of the key within the item.  If "base" is
   non-NULL, the key is actually an offset relative to "base" and the
   actual key is found at that offset (MonetDB var-sized atoms).
 */
int
GDKssort@1(void *a, void *base, size_t nitems, int width, int tpe, int loc)
{
	MergeState ms;
	ssize_t nremaining;
	int result = -1;
	void *lo, *hi;
	ssize_t minrun;

	assert(a);
	assert(width > 0);
	assert(0 <= loc && loc < width);

	ms.a = (void *) ms.temparray;
	ms.alloced = MERGESTATE_TEMP_SIZE;
	ms.n = 0;
	ms.min_gallop = MIN_GALLOP;
	ms.compare = BATatoms[tpe].atomCmp;
	ms.base = base;
	ms.width = width;
	ms.loc = loc;
	ms.t = (size_t) width <= sizeof(ms.tempstorage) ? ms.tempstorage : alloca(width);

	nremaining = nitems;

	if (nremaining < 2)
		goto succeed;

	/* March over the array once, left to right, finding natural
	   runs, and extending short natural runs to minrun
	   elements. */
	lo = a;
	hi = PTRADD(lo, nremaining, width);
	minrun = merge_compute_minrun(nremaining);
	switch (tpe) {
#ifndef NOEXPAND_CHR
	case TYPE_chr:
		@:do_ssort(chr,@1)@
		break;
#endif
#ifndef NOEXPAND_BTE
	case TYPE_bte:
		@:do_ssort(bte,@1)@
		break;
#endif
#ifndef NOEXPAND_SHT
	case TYPE_sht:
		@:do_ssort(sht,@1)@
		break;
#endif
#ifndef NOEXPAND_INT
	case TYPE_int:
		@:do_ssort(int,@1)@
		break;
#endif
#ifndef NOEXPAND_LNG
	case TYPE_lng:
		@:do_ssort(lng,@1)@
		break;
#endif
#ifndef NOEXPAND_FLT
	case TYPE_flt:
		@:do_ssort(flt,@1)@
		break;
#endif
#ifndef NOEXPAND_DBL
	case TYPE_dbl:
		@:do_ssort(dbl,@1)@
		break;
#endif
#ifndef NOEXPAND_OID
	case TYPE_oid:
		@:do_ssort(oid,@1)@
		break;
#endif
	default:
		@:do_ssort(any,@1)@
		break;
	}
	assert(ms.n == 1);
	assert(ms.pending[0].base == a);
	assert(ms.pending[0].len == (ssize_t) nitems);

  succeed:
	result = 0;
  fail:
	merge_freemem(&ms);
	return result;
}

@c
@:GDKsort()@
@:GDKsort(_rev)@

@}
