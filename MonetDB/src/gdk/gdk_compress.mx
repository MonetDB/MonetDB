@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.

@f gdk_compress
@a Spencer Thomas, Joseph Orost, James A. Woods, Peter Boncz
@* Compression
@T
{\tt compress()} reads a compressed file and decompresses it to memory.
{\tt decompress()} writes a region of memory compressed to a file. 
Earlier versions did a {\tt popen()} to the UNIX compress utility for this
purpose. 

Rationales for introducing this code: 
\begin{itemize}
\item because the Solaris {\tt popen()} is thread-unsafe, it had to be
dropped anyway.  
\item {\tt fork()} and pipe I/O are brothers in crime of inefficiency.  
These routines are not big, save a {\tt fork()} and an I/O step.
\end{itemize} 
@T
This implementation as compared to the previous version saves a fixed
cost of 100 milliseconds for the {\tt fork()}, and about 20\% processing time
per Kb, because we don't have to use a pipe any more.

The code stems from the Berkeley compress-distribution, taken apart
and put together again (the interface of the functions was changed to
suit our needs, and the package as made thread-safe).
That is why we display the following copyright notice here: 
@T
\bigskip 
{\scriptsize

Copyright (c) 1985, 1986 The Regents of the University of
California.  All rights reserved.

This code is derived from software contributed to Berkeley by
James A. Woods, derived from original work by Spencer Thomas
and Joseph Orost.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
@T
\begin{enumerate}
\item Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
\item Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
\item All advertising materials mentioning features or use of this software
   must display the following acknowledgement:
   This product includes software developed by the University of
   California, Berkeley and its contributors.
\item Neither the name of the University nor the names of its contributors
   may be used to endorse or promote products derived from this software
   without specific prior written permission.
\end{enumerate}}
@
@h
@{
#ifndef _COMPRESS_H_
#define _COMPRESS_H_
#include <ctype.h>
#include <stdlib.h>

typedef int	code_int;
typedef int	count_int;
typedef	unsigned char	char_type;

@-
General defines.
@h
#define BITS	16
#define INIT_BITS	9	/* initial number of bits/code */
#define HSIZE		69001   /* 95% occupancy */
#define FIRST		257 	/* first free entry */
#define CLEAR		256	/* table clear output code */
#define CHECK_GAP	10000	/* ratio check interval */

#undef MIN
#define MIN(x,y)	(((x)<(y))?(x):(y))
#define MAXCODE(n_bits)	((1	<< (n_bits)) - 1)

@-
Defines for third byte of header.
@h
#define BIT_MASK	0x1f
#define BLOCK_MASK	0x80

@-
@T
This struct contains all non-read-only global variables from the
original program. In the current situation, they are local variables
to both compress() and decompress(). Both functions pass pointers to
these structs to the routines they call.
This change makes the compression package thread-safe.
A pointer to this structure, named {\tt global}, is present in every
context.
@h
typedef struct { 
    char_type      buf[BITS];        /* space for buffered IO. */
    int            block_compress;   /* are we block-compressing? */
    size_t         maxbits;	     /* user settable max # bits/code */
    size_t         n_bits;	     /* number of bits/code */
    code_int       maxcode;          /* should NEVER generate this code */
    code_int       highestcode;	     /* maximum code, given n_bits */
    count_int      htab[HSIZE];      /* hash table */
    unsigned short codetab[HSIZE];   /* hash table */
    code_int       free_ent;	     /* first unused entry */
    int      in_count;	     /* length of input */
    int      bytes_out;	     /* length of compressed output */
    int            clear_flg;
    int      ratio;
    size_t         offset;
    size_t         size;
    count_int      checkpoint;
} globals_t; 

#ifdef __cplusplus
extern "C" {
#endif
   extern ssize_t compress(char_type* ptr,char_type* end_ptr,FILE* fp_out);
   extern ssize_t decompress(FILE *fp_in,char_type* ptr);
#ifdef __cplusplus
}
#endif

@c
@{
@{
@{
@{
/*
 * Copyright (c) 1985, 1986 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * James A. Woods, derived from original work by Spencer Thomas
 * and Joseph Orost.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * compress.c - File compression ala IEEE Computer, June 1984.
 *
 * Authors:	Spencer W. Thomas	(decvax!utah-cs!thomas)
 *		Jim McKie		(decvax!mcvax!jim)
 *		Steve Davies		(decvax!vax135!petsd!peora!srd)
 *		Ken Turkowski		(decvax!decwrl!turtlevax!ken)
 *		James A. Woods		(decvax!ihnp4!ames!jaw)
 *		Joe Orost		(decvax!vax135!petsd!joe)
 */
@}
@}
@}
@}
#include "gdk.h"
#ifdef HAVE_SYS_PARAM_H
# include <sys/param.h>
#endif
#include <signal.h>
#ifdef HAVE_UTIME_H
# include <utime.h>
#else
# ifdef HAVE_SYS_UTIME_H
#  include <sys/utime.h>
# endif
#endif
#include <errno.h>
#ifdef HAVE_UNISTD_H
# include <unistd.h>
#endif
#ifdef HAVE_IO_H
# include <io.h>
#endif
#include <stdio.h>
#include "gdk_compress.h"

@-
Read-only globals.
@c 
static char_type magic_header[] = { "\037\235" };     
static char_type lmask[9] = 
      { 0xff, 0xfe, 0xfc, 0xf8, 
        0xf0, 0xe0, 0xc0, 0x80, 0x00};
static char_type rmask[9] = 
      { 0x00, 0x01, 0x03, 0x07, 
        0x0f, 0x1f, 0x3f, 0x7f, 0xff};

static code_int getcode(globals_t *, FILE *);
static void output(globals_t *, code_int, FILE *);
@
@}

@+ compress()
 
Algorithm:  use open addressing double hashing (no chaining) on the 
prefix code / next character combination.  We do a variant of Knuth's
algorithm D (vol. 3, sec. 6.4) along with G. Knott's relatively-prime
secondary probe.  Here, the modular division first probe is gives way
to a faster exclusive-or manipulation.  Also do block compression with
an adaptive reset, whereby the code table is cleared when the compression
ratio decreases, but after the table fills.  The variable-length output
codes are re-sized at this point, and a special CLEAR code is generated
for the decompressor.  Late addition:  construct the table according to
file size for noticeable speed improvement on small files.  Please direct
questions about this implementation to ames! jaw.
@c
@{
#define htabof(i)	global.htab[i]
#define codetabof(i)	global.codetab[i]

void writeerr(char *);
void cl_hash(globals_t *, count_int);
void cl_block(globals_t *, FILE *);

ssize_t compress(char_type *ptr, char_type *end_ptr, FILE *fp_out)
{
    register int fcode;
    register code_int i = 0;
    register int c;
    register code_int ent;
    register int disp;
    register code_int hsize_reg;
    register int hshift;
    globals_t global;

@-
Init globals.
@c
    global.maxcode = 1 << BITS; 
    global.maxbits = BITS;
    global.block_compress = BLOCK_MASK;
    global.offset = 0;
    global.size = 0;
    global.bytes_out = 3;
    global.clear_flg = 0;
    global.ratio = 0;
    global.in_count = 1;
    global.checkpoint = CHECK_GAP;
    global.highestcode = MAXCODE(global.n_bits = INIT_BITS);
    global.free_ent = ((global.block_compress) ? FIRST : 256 );
  
@-
Emit magic number.
@c 
    putc(magic_header[0], fp_out);
    putc(magic_header[1], fp_out);
    putc((char)(global.maxbits | global.block_compress), fp_out);
    if(ferror(fp_out)) writeerr("magic");

    ent = *ptr;

    hshift = 0;
    for ( fcode = HSIZE;  fcode < 65536L; fcode *= 2L )
    	hshift++;
@-
Set hash code range bound.
@c
    hshift = 8 - hshift;

    hsize_reg = HSIZE;
@-
Clear hash table.
@c
    cl_hash(&global, (count_int) hsize_reg);

    while (++ptr < end_ptr) {
	c = *ptr;
	global.in_count++;
	fcode = (int) (((int) c << global.maxbits) + ent);
@-
We use xor hashing.
@c
 	i = ((c << hshift) ^ ent);

	if ( htabof (i) == fcode ) {
	    ent = codetabof (i);
	    continue;
	} else if ( (int)htabof (i) < 0 )
@-
Empty slot.
@c
	    goto nomatch; 
@-
Go do secondary hash (after G. Knott).
@c
 	disp = hsize_reg - i;
	if ( i == 0 )
	    disp = 1;
probe:
	if ( (i -= disp) < 0 )
	    i += hsize_reg;

	if ( htabof (i) == fcode ) {
	    ent = codetabof (i);
	    continue;
	}
	if ( (int)htabof (i) > 0 ) 
	    goto probe;
@-
Make a new entry in the hash table.
@c
nomatch:
	output (&global, (code_int) ent, fp_out );
 	ent = c;
	if ( global.free_ent < global.maxcode ) {
 	    codetabof (i) = (unsigned short) global.free_ent++;
	    htabof (i) = fcode;
	}
	else if ( (count_int)global.in_count >= global.checkpoint && 
			global.block_compress )
	    cl_block (&global, fp_out);
    }
@-
Put out the final code.
@c
    output(&global, (code_int)ent, fp_out );
    output(&global, (code_int)-1, fp_out );

    return (ssize_t) global.bytes_out;
}

@{
@{
@- output()

Inputs:	code:	A n_bits-bit integer.  If == -1, then EOF.  This assumes
		that n_bits =< (int)wordsize - 1.

Outputs:	Outputs code to the file.

Assumptions:    Chars are 8 bits long.

Algorithm:
	Maintain a BITS character int buffer (so that 8 codes will
fit in it exactly). When the buffer fills up empty it and start over.
@c
static void 
output(globals_t *global, code_int code, FILE *fp_out)
{
    register size_t off = global->offset, r_off=off;
    register size_t n_bits= global->n_bits, bits=n_bits;
    register char_type * bp = global->buf;

    if ( code >= 0 ) {
@-
Get to the first byte.
@c
	bp += (r_off >> 3);
	r_off &= 7;
@-
Since code is always >= 8 bits, only need to mask the first
hunk on the left.
@c
	*bp = (char_type) ((*bp & rmask[r_off]) | ((code << r_off) & lmask[r_off]));
	bp++;
	bits -= (8 - r_off);
	code >>= 8 - r_off;
@-
Get any 8 bit parts in the middle (<=1 for up to 16 bits). 
@c
	if ( bits >= 8 ) {
	    *bp++ = (char_type) code;
	    code >>= 8;
	    bits -= 8;
	}
@-
Last bits. 
@c
	if(bits)
	    *bp = (char_type) code;
	off += n_bits;
	if ( off == (n_bits << 3) ) {
	    bp = global->buf;
	    bits = n_bits;
	    global->bytes_out += bits;
	    do {
		putc(*bp++, fp_out);
		if (ferror(fp_out))
			writeerr("output");
	    } while(--bits);
	    off = 0;
	}
@-
If the next entry is going to be too big for the code size,
then increase it, if possible.
@c
	if ( global->free_ent > global->highestcode || (global->clear_flg > 0))
	{
@-
Write the whole buffer, because the input side won't
discover the size increase until after it has read it.
@c
	    if ( off != 0 ) {
		if( fwrite( global->buf, 1, n_bits, fp_out ) != n_bits)
			writeerr("output2");
		global->bytes_out += n_bits;
	    }
	    off = 0;

	    if ( global->clear_flg ) {
    	        global->highestcode = MAXCODE (n_bits = INIT_BITS);
	        global->clear_flg = 0;
	    } else {
	    	n_bits++;
	    	if ( n_bits == global->maxbits )
		    global->highestcode = global->maxcode;
	    	else
		    global->highestcode = MAXCODE(n_bits);
	    }

	}
    } else {
@-
At EOF, write the rest of the buffer.
@c
	if ( off != 0 ) {
		off = (off + 7) / 8;
		if( fwrite( global->buf, 1, off, fp_out ) != off )
			writeerr("output_rest");
		global->bytes_out += off;
	}
	off = 0;
	(void)fflush( fp_out );
	if( ferror( fp_out ) )
		writeerr("output_rest2");
    }
    global->offset = off;
    global->n_bits = n_bits;
}
@
@}
@}
@}

@+ decompress()
This routine adapts to the codes in the
file building the "string" table on-the-fly; requiring no table to
be stored in the compressed file.  See the definitions above.

@c
@{
#define tab_prefixof(i)	global.codetab[i]
#define tab_suffixof(i)	((char_type	*)(global.htab))[i]
#define de_stack	((char_type	*)&tab_suffixof(1<<BITS))

ssize_t decompress(FILE *fp_in, char_type *ptr)
{
    register char_type *stackp;
    register int finchar;
    register code_int code, oldcode, incode;
    char_type *start=ptr;
    globals_t global;

@-
Collect magic number.
@c
    if ((getc(fp_in) != (magic_header[0] & 0xFF))
     || (getc(fp_in) != (magic_header[1] & 0xFF))) {
	fprintf(stderr, "input not in compressed format\n");
        return -1;
    }

@-
Init globals.
@c
    global.clear_flg = 0;
    global.ratio = 0;
    global.size = 0;
    global.offset = 0;
    global.checkpoint = CHECK_GAP;
    global.maxbits = getc(fp_in);        
    global.block_compress = (int) (global.maxbits & BLOCK_MASK);
    global.maxbits &= BIT_MASK;
    global.maxcode = 1 << global.maxbits;
    global.highestcode = MAXCODE(global.n_bits = INIT_BITS);
    global.free_ent = ((global.block_compress) ? FIRST : 256 );

    if(global.maxbits > BITS) {
	fprintf(stderr,
	"input compressed with " SZFMT " bits, can only handle %d bits\n",
	 global.maxbits, BITS);
	return -1;
    }
@-
As above, initialize the first 256 entries in the table.
@c
    for ( code = 255; code >= 0; code-- ) {
	tab_prefixof(code) = 0;
	tab_suffixof(code) = (char_type)code;
    }

    finchar = oldcode = getcode(&global, fp_in);
    if(oldcode == -1)  /* EOF already? */
	return 0;

    /* First code must be 8 bits = char. */
    *ptr++ = (char_type)finchar;

    stackp = de_stack;

    while ( (code = getcode(&global, fp_in)) > -1 ) {
	if ( (code == CLEAR) && global.block_compress ) {
	    for ( code = 255; code >= 0; code-- )
		tab_prefixof(code) = 0;
	    global.clear_flg = 1;
	    global.free_ent = FIRST - 1;
	    if ( (code = getcode (&global, fp_in)) == -1 )	
		break; /* O, untimely death! */
	}
	incode = code;
	/* Special case for KwKwK string. */
	if ( code >= global.free_ent ) {
            *stackp++ = finchar;
	    code = oldcode;
	}
@-
Generate output characters in reverse order.
@c
	while ( code >= 256 ) {
	    *stackp++ = tab_suffixof(code);
	    code = tab_prefixof(code);
	}
	*stackp++ = finchar = tab_suffixof(code);
@-
And emit them in forward order.
@c
	do {
	     *ptr++ = *--stackp;
	} while ( stackp > de_stack );
	/* Generate the new entry. */
	if ( (code=global.free_ent) < global.maxcode ) {
	    tab_prefixof(code) = (unsigned short)oldcode;
	    tab_suffixof(code) = finchar;
	    global.free_ent = code+1;
	} 
	/* Remember previous code. */
	oldcode = incode;
    }
    return (ssize_t) (ptr - start);
}


@{

@- getcode()
Read one code from the standard input.  If EOF, return -1.

Inputs: 	stdin

Outputs: 	code or -1 is returned.
@c
static code_int getcode(globals_t *global, FILE *fp_in)
 {
    register code_int code;
    register size_t r_off, bits;
    register char_type *bp = global->buf;

    if ( global->clear_flg > 0 || global->offset >= global->size ||
	 global->free_ent > global->highestcode ) {
@-
If the next entry will be too big for the current code
size, then we must increase the size.  This implies reading
a new buffer full, too.
@c
	if ( global->free_ent > global->highestcode ) {
	    global->n_bits++;
	    if ( global->n_bits == global->maxbits )
	    /* Won't get any bigger now. */
		global->highestcode = global->maxcode; 
	    else
		global->highestcode = MAXCODE(global->n_bits);
	}
	if ( global->clear_flg > 0) {
    	    global->highestcode = MAXCODE (global->n_bits = INIT_BITS);
	    global->clear_flg = 0;
	}
	global->size = fread( global->buf, 1, global->n_bits, fp_in );
	if ( global->size == 0 && feof(fp_in) )
	    return -1; /* End of file. */
	global->offset = 0;
@-
Round size down to integral number of codes.
@c
	global->size = (global->size << 3) - (global->n_bits - 1);
    }
    r_off = global->offset;
    bits = global->n_bits;
    /* Get to the first byte. */
    bp += (r_off >> 3);
    r_off &= 7;
    /* Get first part (low order bits). */
    code = (*bp++ >> r_off);
    bits -= (8 - r_off);
    r_off = 8 - r_off; 
    /* Get any 8 bit parts in the middle (<=1 for up to 16 bits). */
    if ( bits >= 8 ) {
        code |= *bp++ << r_off;
        r_off += 8;
        bits -= 8;
    }
    /* High order bits. */
    code |= (*bp & rmask[bits]) << r_off;
    global->offset += global->n_bits;

    return code;
}


void writeerr(char *str)
{
	fprintf(stderr, "compress: %s :%s\n", 
 			str, strerror(errno));
}



void cl_block(globals_t *global, FILE *fp_out)
{
    register int rat;

    global->checkpoint = global->in_count + CHECK_GAP;

    if(global->in_count > 0x007fffff) { 
        /* Shift will overflow. */
	rat = global->bytes_out >> 8;
	if(rat == 0) {  
	    /* Don't divide by zero. */
	    rat = 0x7fffffff;
	} else {
	    rat = global->in_count / rat;
	}
    } else {
    /* 8 fractional bits. */
	rat = (global->in_count << 8) / global->bytes_out;	
    }
    if ( rat > global->ratio ) { 
	global->ratio = rat;
    } else {
	global->ratio = 0;
 	cl_hash (global, (count_int) HSIZE );
	global->free_ent = FIRST;
	global->clear_flg = 1;
	output (global, (code_int) CLEAR, fp_out );
    }
}

@{
@{
@{
@{

void cl_hash(globals_t *global, count_int hsize)
{
	register count_int *htab_p = global->htab+hsize;
	register int i;
	register int m1 = -1;

@-
An efficient? way to clear the hash table.
@c
	i = hsize - 16;
 	do {
		*(htab_p-16) = m1;
		*(htab_p-15) = m1;
		*(htab_p-14) = m1;
		*(htab_p-13) = m1;
		*(htab_p-12) = m1;
		*(htab_p-11) = m1;
		*(htab_p-10) = m1;
		*(htab_p-9) = m1;
		*(htab_p-8) = m1;
		*(htab_p-7) = m1;
		*(htab_p-6) = m1;
		*(htab_p-5) = m1;
		*(htab_p-4) = m1;
		*(htab_p-3) = m1;
		*(htab_p-2) = m1;
		*(htab_p-1) = m1;
		htab_p -= 16;
	} while ((i -= 16) >= 0);
    	for ( i += 16; i > 0; i-- )
		*--htab_p = m1;
}

@- main()
For debug purposes only. 
Don't forget: mv a.out zip; rm unzip; ln zip unzip
@c
#ifdef MAIN
main(int argc, char **argv)
{
	struct stat st;
	size_t size;
	char *ptr;
	FILE *fp_in, *fp_out;

	if ((argc!=3) || 
            (!(fp_in=fopen(argv[1],"rb"))) ||
            (!(fp_out=fopen(argv[2],"wb")))) {
		fprintf(stderr, "usage: %s in-file out-file\n", argv[0]);
		exit(1);
	}
        stat(argv[1], &st);
	size = 5*st.st_size;
 	if (!(ptr=GDKmalloc(size))) {
		fprintf(stderr, "fatal: could not malloc " SZFMT " bytes.\n", 
			size);
		exit(1);
	} 
	if (strcmp(argv[0],"zip")) {
	    size = decompress(fp_in, ptr);
	    fwrite(ptr, 1, size, fp_out); 
  	} else {
	    fread(ptr, 1, st.st_size, fp_in);
	    compress(ptr, ptr+st.st_size, fp_out);
	}
	fclose(fp_in);
	fclose(fp_out);
}
@}
@}
@}
@}
#endif
@h
#endif /* _COMPRESS_H_ */
@}


