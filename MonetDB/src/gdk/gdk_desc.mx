@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f gdk_desc
@a Peter Boncz
@v 1.0
@+ BAT Descriptor Versions
Changes to the BAT descriptors cause problems, as persistent
BATs with older descriptor versions may still be around. BAT versions
are marked in the first field of a BAT. Apart from the current BAT
format, we keep recognizing two historic formats.

Changes in the BAT image are not only introduced by developers,
but also by different systems. Two factors are of influence:
32- or 64-bit operating systems, and little-endian or big-endian
hardware. Both issues are resolved by code in this file.

The 32- vs 64-bit issue is resolved by saving the 32-bit
image. 64-bit versions transform this when they get
loaded and saved.

The little-endian and big-endian problem is resolved using a lazy approach.
Intel saves BATs in different format than Sun, but when one loads the other,
they do on-the-fly conversions using the new routine @%BATconvert@.
This routine uses little/big-endian conversion functionality newly
introduced to the atom ADT (atomConvert and atomHeapConvert).
@h
#ifndef _GDK_DESC_H_
#define _GDK_DESC_H_
@+ BAT versions
Three BAT formats are currently supported:
@h
#define GDKLIBRARY	980714	/* new 64-bits BAT */

#define GDKversionOK(x)	((x)==GDKLIBRARY)

@
If BATs need to be added to an old BBP directory, we might need
to save BATs in the old format. This is currently controlled
by the below function:
@
We also use these numbers, which are always the first 32-int the
BAT image, to check whether the image is in big endian or little endian format.
@{
@c
#include "gdk.h"

@+ BAT Conversion functions
These functions save/load a BAT descriptor to/from disk.
@h
int BATsavedesc(BAT *b, str nme);
BAT *BATloaddesc(str nme);

@
Convert a BAT that contains little-endian data into big endian (or vice versa).
@h
gdk_export BAT *BATconvert(BAT *b, int direction);


@- defines
@h
@{
typedef unsigned int normal_int;

#define strcpy_COPY(x,y)	strcpy(x,y);
#define short_int_COPY(x)	x
#define normal_int_COPY(x)	x
#define normal_bat_COPY(x)	x
#define long_long_COPY(x)	x
#define normal_oid_COPY(x)	x
#define normal_sizet_COPY(x)	x
#define normal_hasht_COPY(x)	x
#define normal_BUN_COPY(x)	x

#define strcpy_SWAP(x,y)
#define normal_bat_SWAP(x)	((bat) normal_int_SWAP((int) x))
#if SIZEOF_OID == SIZEOF_INT
#define normal_oid_SWAP(x)	((oid) normal_int_SWAP((int)x))
#else
#define normal_oid_SWAP(x)	((oid) long_long_SWAP((lng)x))
#endif
#if SIZEOF_SIZE_T == SIZEOF_INT
#define normal_sizet_SWAP(x)	((size_t) normal_int_SWAP((int)x))
#define normal_vart_SWAP(x)	((var_t) normal_int_SWAP((int)x))
#define normal_hasht_SWAP(x)	((hash_t) normal_int_SWAP((int)x))
#define normal_BUN_SWAP(x)	((BUN) normal_int_SWAP((int)x))
#else
#define normal_sizet_SWAP(x)	((size_t) long_long_SWAP((lng)x))
#define normal_vart_SWAP(x)	((var_t) long_long_SWAP((lng)x))
#define normal_hasht_SWAP(x)	((hash_t) long_long_SWAP((lng)x))
#define normal_BUN_SWAP(x)	((BUN) long_long_SWAP((lng)x))
#endif

#endif /* _GDK_DESC_H_ */
@}

@- 64 vs 32 BIT conversion
The current BAT descriptor structures now work with full 64-bit
pointers, directly in the format. We still support loading and saving
of old BATs that use the 32-bit format(s). The old definitions
are below (in a shortened format). We have macros that copy all
relevant fields from a (new) 64-bit BAT structure to an (old) 32-bit
BAT, and vice versa.
@{
@c
@= Hash_ALL
                (@2)->type = normal_int_@5(((@4))->type);
                 (@2)->lim = normal_sizet_@5(((@4))->lim);
                (@2)->mask = normal_hasht_@5(((@4))->mask);
                (@2)->hash = (hash_t *) ((@4)->hash?-1L:0);
                (@2)->link = (hash_t *) ((@4)->link?-1L:0);

@= IDX_ALL
                (@2)->root = (Tnode *) ((@4)->root?-1L:0);
               (@2)->stack = (Tnode *) ((@4)->stack?-1L:0);
                (@2)->free = (Tnode *) ((@4)->free?-1L:0);
                (@2)->base = (BUN *) ((@4)->base?-1L:0);
               (@2)->first = (BUN *) ((@4)->first?-1L:0);
                (@2)->last = (BUN *) ((@4)->last?-1L:0);

@= Heap_ALL
              (@2)->offset = normal_sizet_@5(((@4))->offset);
             (@2)->maxsize = normal_sizet_@5(((@4))->maxsize);
                (@2)->free = normal_sizet_@5(((@4))->free);
                (@2)->size = normal_sizet_@5(((@4))->size);
             (@2)->storage = short_int_@5(((@4))->storage);
                (@2)->base = (str) ((@4)->base?-1L:0);
            (@2)->filename = (str) ((@4)->filename?-1L:0);

@= BUNrec_ALL
        @:Heap_ALL(@1,&(@2)->buns,@3,&(@4)->buns,@5)@
             (@2)->deleted = normal_BUN_@5((@4)->deleted);
                (@2)->hole = normal_BUN_@5((@4)->hole);
            (@2)->inserted = normal_BUN_@5((@4)->inserted);
            (@2)->sharecnt = normal_int_@5((@4)->sharecnt);
@= COLrec_ALL
        strcpy_@5((@2)->id,(@4)->id)
        strcpy_@5((@2)->atom,(@4)->atom)
        strcpy_@5((@2)->accname,(@4)->accname)
        @:Heap_ALL(@1,&(@2)->heap,@3,&(@4)->heap,@5)@
        @:Hash_ALL(@1,&(@2)->hash,@3,&(@4)->hash,@5)@
        @:IDX_ALL(@1,(&(@2)->idx),@3,(&(@4)->idx),@5)@
        @:Heap_ALL(@1,&(@2)->accelerator,@3,&(@4)->accelerator,@5)@
           (@2)->heapdirty = (@4)->heapdirty;
            (@2)->accdirty = (@4)->accdirty;
             (@2)->acctype = short_int_@5((@4)->acctype);
              (@2)->sorted = (@4)->sorted;
               (@2)->align = normal_oid_@5((@4)->align);
        (@2)->nosorted_rev = normal_oid_@5((@4)->nosorted_rev);
            (@2)->nokey[0] = normal_sizet_@5((@4)->nokey[0]);
            (@2)->nokey[1] = normal_sizet_@5((@4)->nokey[1]);
            (@2)->nosorted = normal_sizet_@5((@4)->nosorted);
             (@2)->nodense = normal_sizet_@5((@4)->nodense);
               (@2)->dense = (@4)->dense;
     (@2)->accCopiedtodisk = normal_int_@5((@4)->accCopiedtodisk);
             (@2)->aggr[0] = normal_int_@5((@4)->aggr[0]);
             (@2)->aggr[1] = normal_int_@5((@4)->aggr[1]);
             (@2)->aggr[2] = normal_int_@5((@4)->aggr[2]);

@= Dimensions_ALL
             (@2).headtype = short_int_@5((@4).headtype);
             (@2).tailtype = short_int_@5((@4).tailtype);
              (@2).headloc = normal_int_@5((@4).headloc);
              (@2).tailloc = normal_int_@5((@4).tailloc);
              (@2).headkey = (@4).headkey;
              (@2).tailkey = (@4).tailkey;
         (@2).headvarsized = (@4).headvarsized;
         (@2).tailvarsized = (@4).tailvarsized;
             (@2).bunshift = short_int_@5((@4).bunshift);
             (@2).bunwidth = short_int_@5((@4).bunwidth);
		 (@2).hseq = normal_oid_@5((@4).hseq);
		 (@2).tseq = normal_oid_@5((@4).tseq);

@= BAT_ALL
	(@2)->GDKversion = normal_int_@5((@4)->GDKversion);
	(@2)->batCacheid = normal_bat_@5((@4)->batCacheid);
	@:Dimensions_ALL(@1,(@2)->dims,@3,(@4)->dims,@5)@

@= BATrec_ALL
        strcpy_@5((@2)->id,(@4)->id)
        (@2)->dirtyflushed = (@4)->dirtyflushed;
        (@2)->copiedtodisk = (@4)->copiedtodisk;
               (@2)->stamp = normal_int_@5((@4)->stamp);
         (@2)->persistence = short_int_@5((@4)->persistence);
                 (@2)->set = short_int_@5((@4)->set);
          (@2)->restricted = short_int_@5((@4)->restricted);
          (@2)->keeparound = (@4)->keeparound;
               (@2)->dirty = (@4)->dirty;
           (@2)->descdirty = (@4)->descdirty;
           (@2)->bunsdirty = (@4)->bunsdirty;
            (@2)->parentid = normal_bat_@5((@4)->parentid);

@= BATstore_ALL
	@:BAT_ALL(@1,&(@2)->B,@3,&(@4)->B,@5)@
	@:COLrec_ALL(@1,&(@2)->H,@3,&(@4)->H,@5)@
	@:COLrec_ALL(@1,&(@2)->T,@3,&(@4)->T,@5)@
	@:BATrec_ALL(@1,&(@2)->P,@3,&(@4)->P,@5)@
	@:BUNrec_ALL(@1,&(@2)->U,@3,&(@4)->U,@5)@
	strcpy_@5((@2)->fullid,@4->fullid)

@- misc remappings
Absolute pointers need to be mapped to byte offsets when a BAT is saved.
That is where the DELTA macros are for.

@+ implementations
@- BATsavedesc
@c
int
BATsavedesc(BAT *b, str nme)
{
	BATstore *bs = (BATstore *) b;
	int ret = 0;

	DELTAsave(b);
	if (b->GDKversion == GDKLIBRARY) {
		ret = GDKsave(nme, "desc", (void *) bs, sizeof(BATstore), STORE_MEM);
	}
	/* a saved bat could still be used so reset the delta status */
	DELTAload(b);
	return (ret < 0) ? ret : 0;
}

@- BATloaddesc
@c
BAT *
BATloaddesc(str nme)
{
	BATstore *src = (BATstore *) GDKload(nme, "desc", sizeof(BATstore),
					     sizeof(BATstore), STORE_MEM);
	BATstore *dst = src;
	int ver, conv = FALSE;
	BAT *b;

	if (src == NULL) {
		return NULL;
	}
	ver = src->B.GDKversion;
	if (!GDKversionOK(ver)) {
		ver = normal_int_SWAP(ver);
		conv = TRUE;
	}
	if (!GDKversionOK(ver)) {
		GDKerror("GDKload: incompatible version %d.\n", src->B.GDKversion);
		GDKfree(src);
		return NULL;
	}
	if (conv) {
		@:BATstore_ALL(normal_int,dst,normal_int,dst,SWAP,load)@
	}
	b = (BAT *) dst;
	b->H = &dst->H;
	b->T = &dst->T;
	b->P = &dst->P;
	b->U = &dst->U;
	b->batBuns = &b->U->buns;
	b->batBuns->base = NULL;
	b->batBuns->filename = NULL;
	b->H->heap.base = NULL;
	b->H->accelerator.base = NULL;
	b->T->heap.base = NULL;
	b->T->accelerator.base = NULL;
	b->batId = dst->fullid;
	b->batCopiedtodisk = 1;
	b->batElmshift = BATelmshift(b);
	b->batConvert = conv;

	return b;
}

@}
@- big endian vs little endian
This function uses the byte order conversion ADT functions
to convert a little endian BAT to big endian (or vice versa).
@{
@= swap
	{
		@2 *_p = (@2*) @3, _i=*_p;
		*_p = @1_SWAP(_i);
	}
@c
static int
batswap(BAT *b, int direction)
{
	void (*fcn) (ptr, int) = BATatoms[b->htype].atomConvert;
	BUN p, q;
	int xx;

	switch (ATOMstorage(b->htype)) {
	case TYPE_void:
	case TYPE_chr:
		break;
	case TYPE_sht:
		DELloop(b, p, q, xx) @:swap(short_int,sht,BUNhloc(b,p))@
		BATloopFast(b, p, q, xx) @:swap(short_int,sht,BUNhloc(b,p))@

		break;
	case TYPE_int:
	case TYPE_flt:
		DELloop(b, p, q, xx) @:swap(normal_int,int,BUNhloc(b,p))@
		BATloopFast(b, p, q, xx) @:swap(normal_int,int,BUNhloc(b,p))@

		break;
	case TYPE_lng:
	case TYPE_dbl:
		DELloop(b, p, q, xx) @:swap(long_long,lng,BUNhloc(b,p))@
		BATloopFast(b, p, q, xx) @:swap(long_long,lng,BUNhloc(b,p))@

		break;
	default:
		ATOMheapConvert(b->htype, &b->hheap, direction);
		DELloop(b, p, q, xx) {
			@:swap(normal_int,int,BUNhloc(b,p))@

			if (fcn != NULL)
				(*fcn) (BUNhead(b, p), direction);
		}
		BATloopFast(b, p, q, xx) {
			@:swap(normal_int,int,BUNhloc(b,p))@

			if (fcn != NULL)
				(*fcn) (BUNhead(b, p), direction);
		}
	}
	return TRUE;
}

BAT *
BATconvert(BAT *b, int direction)
{
	if (batswap(b, direction)) {
		if (!batswap(BATmirror(b), direction)) {
			batswap(b, direction == CONV_HTON ? CONV_NTOH : CONV_HTON);
		}
	}
	b->batDirty = 1;
	return b;
}

@}
