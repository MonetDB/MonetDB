@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f gdk_batop
@a M. L. Kersten, P. Boncz, S. Manegold
@* Common BAT Operations
This module contains the following BAT algebra operations:
@itemize
@item[bulk updates]
multi-insert, multi-delete, multi-replace
@item[common aggregates]
min, max and histogram
@item[oid column manipulations]
mark, number and split.
@item[bat selections]
select, slice, sample, fragment and restrict.
Note: non hash-/index-supported scanselects have been "outsourced"
to gdk_scanselect.mx as the fully expanded code grows too large to be
(conveniently) compiled in a single file.
@item[bat partitioning]
hash partition, range partitioning
@end itemize
We factor out all possible overhead by inlining code.
This includes the macros BUNhead and BUNtail,
which do a test to see whether the atom resides in the buns or in a
variable storage heap. The updateloop(dstbat, srcbat, operation) macro
invokes operation(dstbat, BUNhead(srcbat), BUNtail(srcbat)) on all buns
of the srcbat, but testing only once where they reside.
@{
@c
#include "gdk.h"
#include "gdk_scanselect.h"

@= updateloop
{
	BUN p, q;
	int xx;

	BATloopFast(@2, p, q, xx) {
		@3(@1, BUNhead(@2, p), BUNtail(@2, p));
	}
}
@}

@+ BAT insert/delete/replace
The content of a BAT can be appended to (removed from) another using
@%BATins@ (@%BATdel@).
@{
@c
#define bunins(b,h,t) if (BUNins(b,h,t) == NULL) return NULL;
BAT *
BATins(BAT *b, BAT *n)
{
	BAT *tmp = NULL, *res = NULL;
	ssize_t needed = 0;
	int fastpath = 0;

	if (b == NULL || n == NULL || BATcount(n) == 0) {
		return b;
	}
	ALIGNins(b, "BATins");
	BATcompatible(b, n);

	if (b->htype != TYPE_void && (b->ttype == TYPE_void || (!b->hhash && b->thash && ATOMstorage(b->ttype) == TYPE_int))) {	/* OIDDEPEND */
		return BATmirror(BATins(BATmirror(b), BATmirror(n)));
	}

	if (b->htype == TYPE_void && b->hseqbase != oid_nil) {
		oid t = *(oid *) BUNhead(b, BUNlast(b) - BUNsize(b));
		oid h = *(oid *) BUNhead(n, BUNfirst(n));

		if ((t + 1) != h || !BAThdense(n)) {
			b = BATmaterialize(b, BATcount(b) + BATcount(n));
			if (b == NULL)
				return NULL;
		}
	}
	if (b->thash == NULL && b->batSet == 0 && (b->tkey & BOUND2BTRUE) == 0 && (b->hhash == NULL || ATOMstorage(b->htype) == TYPE_int)) {
		if ((b->hkey & BOUND2BTRUE)) {
			tmp = n = BATkdiff(n, b);
			if (n == NULL)
				return NULL;
		}
		fastpath = 1;
	}

	needed = BATcount(n) - (((b)->batBuns->size - (b)->batBuns->free) / BUNsize(b));
	if (needed > 0) {
		/* if needed exceeds a normal growth extend just with needed */
		size_t ncap = BATcapacity(b) + needed;
		size_t grows = BATgrows(b);

		if (ncap > grows)
			grows = ncap;
		if (BATextend(b, grows) == NULL)
			fastpath = 0;
	}

	if (b->hhash && 2 * b->hhash->mask < BATcount(b) + BATcount(n)) {
		HASHremove(b);
	}
	if (b->thash && 2 * b->thash->mask < BATcount(b) + BATcount(n)) {
		HASHremove(BATmirror(b));
	}
	if (b->hhash == NULL && b->hkey & BOUND2BTRUE) {
		BAThash(b, BATcount(b) + BATcount(n));
	}
	if (b->thash == NULL && b->tkey & BOUND2BTRUE) {
		BAThash(BATmirror(b), BATcount(b) + BATcount(n));
	}
	if (fastpath) {
		BUN p, q, r = BUNlast(b);
		int xx, yy = BUNsize(b);

		if (BATcount(b) == 0) {
			ALIGNset(b, n);
		} else if (BATcount(n)) {
			BUN last = BUNlast(b) - BUNsize(b);
			size_t idx = BUNindex(b, BUNlast(b));

			xx = ATOMcmp(b->htype, BUNhead(n, BUNfirst(n)), BUNhead(b, last));
			if ((BAThordered(b) & 1) && ((BAThordered(n) & 1) == 0 || xx < 0)) {
				b->hsorted = FALSE;
				b->H->nosorted = idx;
				if (b->hdense & 1) {
					b->hdense = FALSE;
					b->H->nodense = idx;
				}
			}
			if ((BAThordered(b) == (bit)GDK_SORTED_REV) && ((BAThordered(n) != (bit)GDK_SORTED_REV) || xx > 0)) {
				b->hsorted = FALSE;
				b->H->nosorted_rev = idx;
			}
			if ((BAThordered(b) & 1) == 0 || n->hkey == 0 || xx == 0) {	/* StM: GDK_SORTED_REV ? */
				if (b->hkey)
					BATkey(b, FALSE);
			}
			if (b->htype != TYPE_void && (b->hsorted & b->hdense & 1) && (BAThdense(n) == 0 || *(oid *) BUNhloc(b, last) != 1 + *(oid *) BUNhead(n, BUNfirst(n)))) {
				b->hdense = FALSE;
				b->H->nodense = idx;
			}

			xx = ATOMcmp(b->ttype, BUNtail(n, BUNfirst(n)), BUNtail(b, last));
			if ((BATtordered(b) & 1) && ((BATtordered(n) & 1) == 0 || xx < 0)) {
				b->tsorted = FALSE;
				b->T->nosorted = idx;
				if (b->tdense & 1) {
					b->tdense = FALSE;
					b->T->nodense = idx;
				}
			}
			if ((BATtordered(b) == (bit)GDK_SORTED_REV) && ((BATtordered(n) != (bit)GDK_SORTED_REV) || xx > 0)) {
				b->tsorted = FALSE;
				b->T->nosorted_rev = idx;
			}
			if ((BATtordered(b) & 1) == 0 || n->tkey == 0 || xx == 0) {	/* StM: GDK_SORTED_REV ? */
				if (b->tkey)
					BATkey(BATmirror(b), FALSE);
			}
			if (b->ttype != TYPE_void && (b->tsorted & b->tdense & 1) && (BATtdense(n) == 0 || *(oid *) BUNtloc(b, last) != 1 + *(oid *) BUNtail(n, BUNfirst(n)))) {
				b->tdense = FALSE;
				b->T->nodense = idx;
			}
		}
		if (b->htype == TYPE_void) {
			BATloopFast(n, p, q, xx) {
				bunfastins_nocheck(b, r, NULL, BUNtail(n, p), yy);
				r += yy;
			}
		} else if (b->hhash) {
			size_t i = BUNindex(b, BUNlast(b));

			BATloopFast(n, p, q, xx) {
				ptr v = BUNhloc(n, p);

				bunfastins_nocheck(b, r, v, BUNtail(n, p), yy);
				HASHins_int(b->hhash, (hash_t) i, v);
				r += yy;
				i++;
			}
		} else {
			BATloopFast(n, p, q, xx) {
				bunfastins_nocheck(b, r, BUNhead(n, p), BUNtail(n, p), yy);
				r += yy;
			}
		}
		b->batDirty = 1;
	} else {
		@:updateloop(b,n,bunins)@
	}
	res = b;
      bunins_failed:
	if (tmp)
		BBPreclaim(tmp);
	return res;
}

BAT *
BATdel(BAT *b, BAT *n)
{
	ERRORcheck(b == NULL, "set:BAT required\n");
	ERRORcheck(n == NULL, "set:BAT required\n");
	if (BATcount(n) == 0) {
		return b;
	}
	ALIGNdel(b, "BATdel");
	TYPEcheck(b->htype, n->htype);
	TYPEcheck(b->ttype, n->ttype);
	@:updateloop(b,n,BUNdel)@
	return b;
}

#define bundelhead(b,h,t) BUNdelHead(b,h)
BAT *
BATdelHead(BAT *b, BAT *n)
{
	ERRORcheck(b == NULL, "set:BAT required\n");
	ERRORcheck(n == NULL, "set:BAT required\n");
	if (BATcount(n) == 0) {
		return b;
	}
	ALIGNdel(b, "BATdelHead");
	TYPEcheck(b->htype, n->htype);
	@:updateloop(b,n,bundelhead)@
	return b;
}

@-
The last in this series is a BATreplace, which replaces all the
buns mentioned.
@c
#define bunreplace(b,h,t) if (BUNreplace(b,h) == NULL) return NULL;
BAT *
BATreplace(BAT *b, BAT *n)
{
	if (b == NULL || n == NULL || BATcount(n) == 0) {
		return b;
	}
	ALIGNdel(b, "BATreplace");
	BATcompatible(b, n);
	@:updateloop(b,n,BUNreplace)@

	return b;
}

@}

@+ BAT Selections
The BAT selectors are among the most heavily used operators.
Their efficient implementation is therefore mandatory.

The interface supports seven operations: @%BATslice@, @%BATselect@,
@%BATfragment@, @%BATsample@, @%BATproject@, @%BATrestrict@.

@- BAT slice
This function returns a horizontal slice from a BAT. It optimizes
execution by avoiding to copy when the BAT is memory mapped (in this
case, an independent submap is created) or else when it is read-only,
then a VIEW bat is created as a result.

If a new copy has to be created, this function takes care to preserve
void-columns (in this case, the seqbase has to be recomputed in the result).

Note that the BATslice() is used indirectly as well as a special
case for BATselect (range selection on sorted column), BATrangesplit
(fragmentation on sorted column) and BATsemijoin (when two dense columns
are semijoined).

NOTE new semantics, the selected range is excluding the high value.
@{
@c
BAT *
BATslice(BAT *b, size_t l, size_t h)
{
	size_t low = l;
	int xx;
	BAT *bn;

	BATcheck(b, "BATslice");
	if (h > BATcount(b))
		h = BATcount(b);
	if (h < l)
		h = l;
	l += BUNindex(b, BUNfirst(b));
	h += BUNindex(b, BUNfirst(b));

@-
If the source BAT is readonly, then we can obtain a VIEW
that just reuses the memory of the source.
@c
	if (BATrestricted(b) == BAT_READ) {
		bn = VIEWcreate_(b, TRUE);
		bn->batBuns->base = BUNptr(b, l);
		bn->batFirst = bn->batDeleted = bn->batInserted = bn->batBuns->base;
		bn->batBuns->maxsize = bn->batBuns->size = bn->batBuns->free = BUNptr(b, h) - bn->batBuns->base;
		BATsetcount(bn, bn->batBuns->free/BUNsize(bn));
@-
We have to do it: create a new BAT and put everything into it.
@c
	} else {
		BUN p = BUNptr(b, l);
		BUN q = BUNptr(b, h);

		bn = BATnew(b->htype, b->ttype, h - l);
		if (bn == NULL) {
			return bn;
		}
		if (b->htype != b->ttype || b->htype != TYPE_void) {
			for (xx = BUNsize(b); p < q; p += xx) {
				bunfastins(bn, BUNhead(b, p), BUNtail(b, p));
			}
		} else {
			BATsetcount(bn, h-l);
			bn->batBuns->free = (h-l);
		}
	}
	bn->hsorted = BAThordered(b);
	bn->tsorted = BATtordered(b);
	BATkey(bn, BAThkey(b));
	BATkey(BATmirror(bn), BATtkey(b));
	if (BAThdense(b)) {
		BATseqbase(bn, b->hseqbase + low);
	}
	if (BATtdense(b)) {
		BATseqbase(BATmirror(bn), b->tseqbase + low);
	}
	return bn;
      bunins_failed:
	BBPreclaim(bn);
	return NULL;
}

@-  Value Selections
The string search is optimized for the degenerated case
that th = tl, and double elimination in the string heap.

We allow value selections on the nil atom. This is formally
not correct, as in MIL (nil = nil) != true.  However, we do
need an implementation for selecting nil (in MIL, this is done
through is the "isnil" predicate). So we implement it here.

@= valselect
	HASHloop@2(b, b->hhash, i, tl, p) {
		if (q < r)
			bunfastins_nocheck(bn, q, BUNt@1(b, p), tl, bs);
		q += bs;
	}
@= stringselect
	if (strElimDoubles(b->hheap)) {
		size_t j;

		HASHloop_fstr(b, b->hhash, i, j, tl) {
			p = BUNptr(b, i);
			if (q < r)
				bunfastins_nocheck(bn, q, BUNt@1(b, p), tl, bs);
			q += bs;
		}
	} else {
		HASHloop_str(b, b->hhash, i, tl) {
			p = BUNptr(b, i);
			if (q < r)
				bunfastins_nocheck(bn, q, BUNt@1(b, p), tl, bs);
			q += bs;
		}
	}
@= hashselect
	switch(ATOMstorage(b->htype)) {
#ifndef NOEXPAND_CHR
	case TYPE_chr:
		@:valselect(@1,_chr)@
		break;
#endif
#ifndef NOEXPAND_SHT
	case TYPE_sht:
		@:valselect(@1,_sht)@
		break;
#endif
#ifndef NOEXPAND_INT
	case TYPE_int:
		@:valselect(@1,_int)@
		break;
#endif
#ifndef NOEXPAND_FLT
	case TYPE_flt:
		@:valselect(@1,_flt)@
		break;
#endif
#ifndef NOEXPAND_DBL
	case TYPE_dbl:
		@:valselect(@1,_dbl)@
		break;
#endif
#ifndef NOEXPAND_LNG
	case TYPE_lng:
		@:valselect(@1,_lng)@
		break;
#endif
#ifndef NOEXPAND_STR
	case TYPE_str:
		@:stringselect(@1)@
		break;
#endif
	default:
		if (b->hvarsized) {
			@:valselect(@1,var)@
		} else {
			@:valselect(@1,loc)@
		}
		break;
	}
@c
BAT *
BAT_hashselect(BAT *b, BAT *bn, ptr tl)
{
	int ht = bn->htype, tt = bn->ttype;
	size_t size = BATcount(bn);
	hash_t i;

	BATcheck(b, "BAT_hashselect");
	b= BATmirror(b);
	if (BATprepareHash(b)) {
	      bunins_failed:
		BBPreclaim(bn);
		return NULL;
	}
	while (bn) {
		BUN p, q = BUNfirst(bn);
		BUN r = (BUN) ((char *) Bunbase(bn) + bn->batBuns->size);
		int bs = BUNsize(bn);

		if (b->tvarsized) {
			@:hashselect(var)@
		} else {
			@:hashselect(loc)@
		}
		if (q <= r)
			break;
		size = (q - BUNfirst(bn)) / bs;

		BBPreclaim(bn);
		bn = BATnew(ht, tt, size);
	}
	return bn;
}

@}
@- Range Selections
The routine @%BATselect@ locates the BAT subset whose tail component
satisfies the range condition T l <[=] tail <[=] h. Either boundary
is included in the result iff the respective bit parameter "li"/"hi"
is TRUE. A nil value in either dimension defines infinity.  The value
is set accordingly.

Range selections without lower or upper bound use the nil atom
to indicate this (this is somewhat confusing). Note, however, that
through the definition of MIL we do not want the nils to appear in
the result (as (nil @{<,=,>@} ANY) = bit(nil) != true).
@{
@c
BAT *
BAT_select_(BAT *b, ptr tl, ptr th, bit li, bit hi, bit tail, bit preserve_order)
{
	int hval, lval, equi, t, ht, tt;
	size_t offset, batcnt, estimate = 0;
	ptr nil;
	BAT *bn;
	BUN p, q;

	BATcheck(b, "BATselect: \n");
	BATcheck(tl, "BATselect: tl value required\n");
@-
Examine type, and values for lower- and higher-bound.
@c
	batcnt = BATcount(b);
	t = b->ttype;
	nil = ATOMnilptr(t);
	lval = ATOMcmp(t, tl, nil) || (th == NULL);
	equi = ((th == NULL) || (lval && !ATOMcmp(t, tl, th)));
	if (equi) {
		if (th == NULL)
			hi = li;
		th = tl;
		hval = 1;	/* equi-select */
	} else {
		hval = ATOMcmp(t, th, nil);
	}

	/* preliminarily determine result types */
	ht = BAThtype(b);
	tt = tail ? BATttype(b) : TYPE_void;

	if (hval && ((ATOMcmp(t, tl, th) > 0) || (equi && !(li && hi)))) {
		/* empty range */
		ALGODEBUG THRprintf(GDKout, "BAT_select_(b=%s): empty range;\n", BATgetId(b));

		return BATnew(ht, tt, 10);
	}

@}
@- Slice Implementations
When the result is a dense slice of the BAT, we can optimize.
A slice does not need to copy the BAT selected on, it can just
give back a 'view' on the memory of the existing BAT. See BATslice().
@{
@c
	if (BATtordered(b) & 1) {
		BAT *v = tail ? b : VIEWhead_(b, b->batRestricted);
		size_t high = batcnt;
		size_t low = 0;

		if (BATtdense(b)) {
			/* Selections on voids are positional. */
			if (hval) {
				size_t h = (*(oid *) th) + (hi ? 1 : 0);

				if (h > b->tseqbase)
					h -= b->tseqbase;
				else
					h = 0;
				if (h < high)
					high = h;

			}
			if (lval) {
				size_t l = (*(oid *) tl) + (li ? 0 : 1);

				if (l > b->tseqbase)
					l -= b->tseqbase;
				else
					l = 0;
				if (l > low)
					low = l;
			}
		} else {
			/* Use probe-based binary search */
			offset = BUNindex(b, BUNfirst(b));
			if (lval) {
				if (li)
					p = SORTfndfirst(b, tl);
				else
					p = SORTfndlast(b, tl);
			} else {
				/* No lower bound, we must still exclude nils. They are in
				 * front, so we can still slice, by starting after them.
				 */
				p = SORTfndlast(b, nil);
			}
			low = BUNindex(b, p);
			if (low > offset)
				low -= offset;
			else
				low = 0;
			if (hval) {
				if (hi)
					q = SORTfndlast(b, th);
				else
					q = SORTfndfirst(b, th);
				high = BUNindex(b, q);
				if (high > offset)
					high -= offset;
				else
					high = 0;
			}
		}
		ALGODEBUG THRprintf(GDKout, "BAT_select_(b=%s): BATslice(v=%s, low=" SZFMT ", high=" SZFMT ");\n", BATgetId(b), BATgetId(v), low, high);

		bn = BATslice(v, low, high);
		if (!tail) {
			BBPreclaim(v);
		}
		return bn;
	}
@-
Use sampling to determine a good result size, when the bat is large.
@c
	if (BATtkey(b)) {
		estimate = 1;
	} else if (batcnt > 100000) {
		size_t _lo = batcnt / 2, _hi = _lo + 105;
		BAT *tmp1;
		ALGODEBUG THRprintf(GDKout, "BAT_select_(b=%s): sampling: tmp1 = BATslice(b=%s, _lo=" SZFMT ", _hi=" SZFMT ");\n", BATgetId(b), BATgetId(b), _lo, _hi);

		tmp1 = BATslice(b, _lo, _hi);	/* slice keeps all parent properties */
		if (tmp1) {
			BAT *tmp2;
			ALGODEBUG THRprintf(GDKout, "BAT_select_(b=%s): sampling: tmp2 = BAT_select_(tmp1=%s, tl, th, tail);\n", BATgetId(b), BATgetId(tmp1));

			tmp2 = BAT_select_(tmp1, tl, th, li, hi, tail, FALSE);
			if (tmp2) {
				/* reserve 105% of what has been estimated */
				estimate = (size_t) ((((lng) BATcount(tmp2)) * (lng) batcnt) / LL_CONSTANT(100));
				BBPreclaim(tmp2);
			}
			BBPreclaim(tmp1);
		}
	} else {
		estimate = MAX(estimate, BATguess(b));
	}
@-
Create the result BAT and execute the select algorithm.
@c
	if (ht == TYPE_void && tt == TYPE_void) {
		ht = TYPE_oid;
	}
	bn = BATnew(ht, tt, estimate);
	if (bn) {
		int nocheck = (estimate >= batcnt);

		if (!preserve_order && equi && b->thash) {
			ALGODEBUG THRprintf(GDKout, "BAT_select_(b=%s): BAT_hashselect(b=%s, bn=%s, tl); (using existing hash-table)\n", BATgetId(b), BATgetId(b), BATgetId(bn));

			bn = BAT_hashselect(b, bn, tl);
		} else if (!preserve_order && equi && ATOMsize(b->ttype) > 1 && estimate * 100 < batcnt && batcnt * 2 * sizeof(int) < (GDK_mem_maxsize / 4)) {
			/* Build a hash-table on the fly for equi-select if the selectivity is low
			 * and it is not too big */
			ALGODEBUG THRprintf(GDKout, "BAT_select_(b=%s): BAT_hashselect(b=%s, bn=%s, tl); (building hash-table on the fly)\n", BATgetId(b), BATgetId(b), BATgetId(bn));

			bn = BAT_hashselect(b, bn, tl);
		} else {
			ALGODEBUG THRprintf(GDKout, "BAT_select_(b=%s): BAT_scanselect(b=%s, bn=%s, tl, th, equi=%d, lval=%d, hval=%d, nocheck=%d);\n", BATgetId(b), BATgetId(b), BATgetId(bn), equi, lval, hval, nocheck);

			bn = BAT_scanselect(b, bn, tl, th, li, hi, equi, lval, hval, nocheck);
		}
	}
	if (bn == NULL) {
		return NULL;	/* error occurred */
	}
@-
Propagate alignment info. Key properties are inherited from the parent.
Hash changes the order; IDX yields ordered tail; scan respects original order.
@c
	if (BATcount(bn)) {
		BATkey(bn, b->hkey);
		BATkey(BATmirror(bn), b->tkey);
	} else {
		BATkey(bn, TRUE);
		BATkey(BATmirror(bn), TRUE);
	}
	if (equi && tail) {
		BATsetprop_int(bn, GDK_AGGR_CARD, BATcount(bn) > 0);
		if (b->ttype == TYPE_bit) {
			BATsetprop_int(bn, GDK_AGGR_SIZE, (*(bit *) tl == TRUE) ? BATcount(bn) : 0);
		}
	}
	if (equi && b->thash) {
		bn->hsorted = bn->tsorted = FALSE;
	} else {
		if (BATcount(bn) == BATcount(b))
			ALIGNset(bn, b);
		bn->hsorted = BAThordered(b);
		bn->tsorted = BATtordered(b);
	}
	ALGODEBUG THRprintf(GDKout, "BAT_select_(b=%s): %s: hkey=%d, tkey=%d, hsorted=%d, tsorted=%d.\n", BATgetId(b), BATgetId(bn), bn->hkey, bn->tkey, bn->hsorted, bn->tsorted);
	ESTIDEBUG THRprintf(GDKout, "BAT_select_(b=%s): resultsize: estimated " SZFMT ", got " SZFMT ".\n", BATgetId(b), estimate, BATcount(bn));

	return bn;
}

BAT *
BAT_select(BAT *b, ptr h, ptr t, bit tail)
{
	return BAT_select_(b, h, t, TRUE, TRUE, tail, FALSE);
}

BAT *
BATselect_(BAT *b, ptr h, ptr t, bit li, bit hi)
{
	return BAT_select_(b, h, t, li, hi, TRUE, FALSE);
}

BAT *
BATuselect_(BAT *b, ptr h, ptr t, bit li, bit hi)
{
	return BAT_select_(b, h, t, li, hi, FALSE, FALSE);
}

BAT *
BATselect(BAT *b, ptr h, ptr t)
{
	return BAT_select_(b, h, t, TRUE, TRUE, TRUE, FALSE);
}

BAT *
BATuselect(BAT *b, ptr h, ptr t)
{
	return BAT_select_(b, h, t, TRUE, TRUE, FALSE, FALSE);
}

@}
@- Top-N selection

The top-N elements can be easily obtained by trimming the
space. The auxiliary index structures are removed.
For non-variable size BATs it merely requires
adjustment of the free space labels. Other BATs require
a loop through the tuples to be deleted. [todo]
@{
@c
size_t
BATtopN(BAT *b, size_t topN)
{
	BATcheck(b, "BATtopN");
	if (topN > BATcount(b)) {
		GDKerror("BATtopN: not enough tuples in target\n");
	} else if (topN * BUNsize(b) > b->batBuns->size) {
		GDKerror("BATtopN: not enough capacity to keep result\n");
	} else if (b->dims.headvarsized || b->dims.tailvarsized) {
		HASHremove(b);
		while (BATcount(b) > topN)
			BUNdelete(b, BUNlast(b));
	} else {
		HASHremove(b);
		b->batBuns->free = BUNptr(b, topN) - Bunbase(b);
		BATsetcount(b, topN);
	}
	return 0;
}

@- Random Selections
@c
BAT *
BATsample(BAT *b, size_t size)
{
	size_t cnt, i, r = 0, n, j;
	size_t *choice, *dst;
	BAT *bn;

	BATcheck(b, "BATsample: source BAT");

	cnt = BATcount(b);
	n = MIN(size, BATcount(b));

	bn = BATnew(BAThtype(b), BATttype(b), n);
	BATcheck(bn, "BATsample: dest BAT");

	if (n == 0)
		return bn;
	dst = choice = (size_t *) GDKmalloc(n * sizeof(size_t));

	if (n * 2 < BATcount(b)) {	/* nondense sample */
		char *vec = (char *) GDKzalloc(1 + (cnt / 8));

		for (j = 0; j < n; j++) {
			r += rand();
			i = r % cnt;
			for (;;) {
				int mask = 1 << (i & 7);

				if (vec[i >> 3] & mask) {
					if (++i == cnt)
						i = 0;
				} else {
					vec[i >> 3] |= mask;
					break;
				}
			}
			*dst++ = i;
		}
		GDKfree(vec);
	} else if (cnt < 65536) {
		unsigned short *vec = (unsigned short *) GDKmalloc(cnt * sizeof(unsigned short));

		for (i = 0; i < cnt; i++)
			vec[i] = (unsigned short) i;
		for (j = 0; j < n; j++) {
			r += rand();
			i = r % cnt;
			*dst++ = vec[i];
			vec[i] = vec[--cnt];
		}
		GDKfree(vec);
	} else {
		size_t *vec = (size_t *) GDKmalloc(cnt * sizeof(size_t));

		for (i = 0; i < cnt; i++)
			vec[i] = i;
		for (j = 0; j < n; j++) {
			r += rand();
			i = r % cnt;
			*dst++ = vec[i];
			vec[i] = vec[--cnt];
		}
		GDKfree(vec);
	}

	/* merge all positions into a sorted list */
	qsort((void *) choice, n, sizeof(size_t),
#if SIZEOF_SIZE_T == SIZEOF_INT
	      (int (*)(const void *, const void *)) intCmp
#else
	      (int (*)(const void *, const void *)) lngCmp
#endif
	    );

	/* insert the sorted sample */
	cnt = BUNindex(b, BUNfirst(b));
	for (j = 0; j < n; j++) {
		BUN p = BUNptr(b, cnt + choice[j]);

		bunfastins(bn, BUNhead(b, p), BUNtail(b, p));
	}
	GDKfree(choice);	/* clean up choice array of BUN positions */

	/* set sorted flags by hand, because we used BUNfastins() */
	bn->hsorted = BAThordered(b);
	bn->tsorted = BATtordered(b);
	BATkey(bn, b->hkey);
	BATkey(BATmirror(bn), b->tkey);
	return bn;
      bunins_failed:
	BBPreclaim(bn);
	return NULL;
}

@- Horizontal Fragmentation
@c
BAT *
BATfragment(BAT *b, ptr hl, ptr hh, ptr tl, ptr th)
{
	BATcheck(b, "BATfragment:BAT required\n");
	if ((hl == NULL) && (hh == NULL)) {
		return BATselect(b, tl, th);
	}
	if ((BAThordered(b) & 1) == FALSE && (BATtordered(b) & 1)) {
		return BATmirror(BATrestrict(BATmirror(b), tl, th, hl, hh));
	}
	return BATrestrict(b, hl, hh, tl, th);
}

@
@}
@-
The baseline algorithm for fragment location is a two-phase process.
First we search on the 1st
dimension and collect the qualifying BUNs in a marking on the
stack. In the second phase, the tail is analyzed for all items
already marked and qualifying associations are copied into the result.
An index is exploited when possible.


@{
@= restrict1
	if (BAThordered(b)&1) {
		int offset;
		BUN p,q;

		b= BATmirror(b);
		SORTloop(b, p, q, hl, hh, offset) {
			*m++ = p;
		}
		b= BATmirror(b);
	} else {
		int lval = !@1_EQ(ATOMnilptr(t),hl,@2);
		int hval = !@1_EQ(ATOMnilptr(t),hh,@2);

		if (hval && lval && @1_GT(hl,hh,@2)) {
			GDKerror("BATrestrict: illegal head range.\n");
		} else {
			int xx;

			BATloopFast(b, p, l, xx) {
				if ((!lval || @1_LE(hl, BUNh@3(b, p),@2)) &&
				    (!hval || @1_LE(BUNh@3(b, p), hh,@2))) {
					*m++ = p;
				}
			}
		}
	}
@
@= restrict2
	{
		tl = @1_EQ(ATOMnilptr(t),tl,@2) ? 0 : tl;
		th = @1_EQ(ATOMnilptr(t),th,@2) ? 0 : th;
		if (th && tl && @1_GT(tl,th,@2)) {
			GDKerror("BATrestrict: illegal tail range.\n");
		} else {
			for (; i < m; i++) {
				ptr v = BUNt@4(b, *i);

				if ((!tl || @1_LE(tl, v, @2)) &&
				    (!th || @1_LE(v, th, @2))) {
					bunfastins(bn, BUNh@3(b, *i), v);
				}
			}
		}
	}
	break;
@c
BAT *
BATrestrict(BAT *b, ptr hl, ptr hh, ptr tl, ptr th)
{
	BAT *bn;
	BUN p = NULL, l;
	BUN *mark, *m, *i;
	size_t s;
	int t;

	BATcheck(hl, "BATrestrict:hl is null");
	BATcheck(hh, "BATrestrict:hh is null");
	BATcheck(tl, "BATrestrict:tl is null");
	BATcheck(th, "BATrestrict:th is null");
	bn = BATnew(BAThtype(b), BATttype(b), BATguess(b));
	ESTIDEBUG THRprintf(GDKout, "BATrestrict: estimated resultsize: " SZFMT "\n", BATguess(b));

	if (bn == NULL) {
		return NULL;
	}
	BATkey(bn, b->hkey);
	BATkey(BATmirror(bn), b->tkey);
	bn->hsorted = BAThordered(b);
	bn->tsorted = BATtordered(b);

	s = BATcount(b);
	if (s == 0) {
		ESTIDEBUG THRprintf(GDKout, "BATrestrict: actual resultsize: " SZFMT "\n", BATcount(bn));

		return bn;
	}
	mark = (BUN *) GDKmalloc((unsigned) s * sizeof(BUN));
	m = mark;
	i = mark;
	switch (ATOMstorage(t = b->htype)) {
#ifndef NOEXPAND_CHR
	case TYPE_chr:
		@:restrict1(simple,chr,loc)@

		break;
#endif
#ifndef NOEXPAND_SHT
	case TYPE_sht:
		@:restrict1(simple,sht,loc)@

		break;
#endif
#ifndef NOEXPAND_INT
	case TYPE_int:
		@:restrict1(simple,int,loc)@

		break;
#endif
#ifndef NOEXPAND_FLT
	case TYPE_flt:
		@:restrict1(simple,flt,loc)@

		break;
#endif
#ifndef NOEXPAND_DBL
	case TYPE_dbl:
		@:restrict1(simple,dbl,loc)@

		break;
#endif
#ifndef NOEXPAND_LNG
	case TYPE_lng:
		@:restrict1(simple,lng,loc)@

		break;
#endif
	default:
		if (b->hvarsized) {
			@:restrict1(atom,t,var)@
		} else {
			@:restrict1(atom,t,loc)@
		}
		break;
	}

	/* second phase */
	if (b->hvarsized) {
		switch (ATOMstorage(t = b->ttype)) {
#ifndef NOEXPAND_CHR
		case TYPE_chr:
			@:restrict2(simple,chr,var,loc)@

			break;
#endif
#ifndef NOEXPAND_SHT
		case TYPE_sht:
			@:restrict2(simple,sht,var,loc)@

			break;
#endif
#ifndef NOEXPAND_INT
		case TYPE_int:
			@:restrict2(simple,int,var,loc)@

			break;
#endif
#ifndef NOEXPAND_FLT
		case TYPE_flt:
			@:restrict2(simple,flt,var,loc)@

			break;
#endif
#ifndef NOEXPAND_DBL
		case TYPE_dbl:
			@:restrict2(simple,dbl,var,loc)@

			break;
#endif
#ifndef NOEXPAND_LNG
		case TYPE_lng:
			@:restrict2(simple,lng,var,loc)@

			break;
#endif
		default:
			if (b->tvarsized) {
				@:restrict2(atom,t,var,var)@
			} else {
				@:restrict2(atom,t,var,loc)@
			}
			break;
		}
	} else {
		switch (ATOMstorage(t = b->ttype)) {
#ifndef NOEXPAND_CHR
		case TYPE_chr:
			@:restrict2(simple,chr,loc,loc)@

			break;
#endif
#ifndef NOEXPAND_SHT
		case TYPE_sht:
			@:restrict2(simple,sht,loc,loc)@

			break;
#endif
#ifndef NOEXPAND_INT
		case TYPE_int:
			@:restrict2(simple,int,loc,loc)@

			break;
#endif
#ifndef NOEXPAND_FLT
		case TYPE_flt:
			@:restrict2(simple,flt,loc,loc)@

			break;
#endif
#if !defined(NOEXPAND_LNG) || !defined(NOEXPAND_DBL)
		case TYPE_dbl:
		case TYPE_lng:
			@:restrict2(simple,lng,loc,loc)@

			break;
#endif
		default:
			if (b->tvarsized) {
				@:restrict2(atom,t,loc,var)@
			} else {
				@:restrict2(atom,t,loc,loc)@
			}
			break;
		}
	}
	GDKfree(mark);

	/* propagate alignment info */
	if (BATcount(bn) == BATcount(b))
		ALIGNset(bn, b);

	ESTIDEBUG THRprintf(GDKout, "BATrestrict: actual resultsize: " SZFMT "\n", BATcount(bn));

	return bn;

      bunins_failed:
	GDKfree(mark);
	BBPreclaim(bn);
	return NULL;
}

@}
@+ BAT Sorting
@%BATsort@ returns a sorted copy. @%BATorder@ sorts the BAT itself.
@{
@c
#ifdef HAVE_RESTRICT
#define __r     restrict
#else
#ifdef HAVE___RESTRICT__
#define __r     __restrict__
#else
#define __r
#endif
#endif

@:sort(1,,,_rev,>)@
@:sort(GDK_SORTED_REV,_REV,_rev,,<)@

@= sort_tpe
static int
chk_order@3_@1(@1*__r col)
{
	size_t i, r = 1;

	for (i = 0; i < 128; i += 4) {
		r &= (col[i+1] @2= col[i+0]) &
		     (col[i+2] @2= col[i+1]) &
		     (col[i+3] @2= col[i+2]) &
		     (col[i+4] @2= col[i+3]);
	}
	return r;
}

@= sort
@:sort_tpe(chr,@5,@3)@
@:sort_tpe(sht,@5,@3)@
@:sort_tpe(int,@5,@3)@
@:sort_tpe(lng,@5,@3)@
@:sort_tpe(flt,@5,@3)@
@:sort_tpe(dbl,@5,@3)@

static int
chk_order@3_oid_oid(oid*__r col)
{
	size_t i, r = 1;

	for (i = 0; i < 256; i += 8) {
		r &= (col[i+2] @5= col[i+0]) &
		     (col[i+4] @5= col[i+2]) &
		     (col[i+6] @5= col[i+4]) &
		     (col[i+8] @5= col[i+6]);
	}
	return r;
}

int
BATordered@3(BAT* b)
{
	size_t cnt = BATcount(b);

	if ((BAThordered(b) & @1) == 0 && cnt > 0) {
		int (*cmp) (ptr, ptr) = BATatoms[b->htype].atomCmp;
		char *cur = (char *) BUNhloc(b, BUNfirst(b));
		char *end = (char *) BUNhloc(b, BUNlast(b));
		int xx = BUNsize(b);

		/* we may have negative information already; this saves a scan */
		if (b->H->nosorted@3 > BUNindex(b, cur) && b->H->nosorted@3 < BUNindex(b, end) && cmp(BUNhead(b, BUNptr(b, b->H->nosorted@3 - 1)), BUNhead(b, BUNptr(b, b->H->nosorted@3))) @5 0) {
			return FALSE;
		}

		/* for [tpe,void] and [OID,OID] bats, we have fast 128-at-a-time routines */
		if (ATOMstorage(b->htype) == ATOMstorage(TYPE_oid) && BUNsize(b) == 2 * ATOMsize(TYPE_oid)) {
			while (cur + 256 * sizeof(oid) < end) {
				if (!chk_order@3_oid_oid((oid *) cur))
					break;
				cur += 256 * sizeof(oid);
			}
		} else if (ATOMstorage(b->htype) == TYPE_chr && BUNsize(b) == sizeof(chr)) {
			while (cur + 128 * sizeof(chr) < end) {
				if (!chk_order@3_chr((chr *) cur))
					break;
				cur += 128 * sizeof(chr);
			}
		} else if (ATOMstorage(b->htype) == TYPE_sht && BUNsize(b) == sizeof(sht)) {
			while (cur + 128 * sizeof(sht) < end) {
				if (!chk_order@3_sht((sht *) cur))
					break;
				cur += 128 * sizeof(sht);
			}
		} else if (ATOMstorage(b->htype) == TYPE_int && BUNsize(b) == sizeof(int)) {
			while (cur + 128 * sizeof(int) < end) {
				if (!chk_order@3_int((int *) cur))
					break;
				cur += 128 * sizeof(int);
			}
		} else if (ATOMstorage(b->htype) == TYPE_lng && BUNsize(b) == sizeof(lng)) {
			while (cur + 128 * sizeof(lng) < end) {
				if (!chk_order@3_lng((lng *) cur))
					break;
				cur += 128 * sizeof(lng);
			}
		} else if (ATOMstorage(b->htype) == TYPE_flt && BUNsize(b) == sizeof(flt)) {
			while (cur + 128 * sizeof(flt) < end) {
				if (!chk_order@3_flt((flt *) cur))
					break;
				cur += 128 * sizeof(flt);
			}
		} else if (ATOMstorage(b->htype) == TYPE_dbl && BUNsize(b) == sizeof(dbl)) {
			while (cur + 128 * sizeof(dbl) < end) {
				if (!chk_order@3_dbl((dbl *) cur))
					break;
				cur += 128 * sizeof(dbl);
			}
		}

		/* check sortedness tuple-by-tuple */
		if (b->hheap) {
			BUN base = b->hheap->base;
			char *prv = base + *(var_t *) cur;

			cur += xx;
			while (cur < end) {
				char *val = base + *(var_t *) cur;

				if (cmp(prv, val) @5 0) {
					/* record negative position info */
					b->H->nosorted@3 = BUNindex(b, cur);
					return FALSE;
				}
				prv = val;
				cur += xx;
			}
		} else {
			char *prv = cur;

			cur += xx;
			while (cur < end) {
				if (cmp(prv, cur) @5 0) {
					/* record negative position info */
					b->H->nosorted@3 = BUNindex(b, cur);
					return FALSE;
				}
				prv = cur;
				cur += xx;
			}
		}
	}
	/* it is sorted@3! set the properties */
	if ((b->hsorted & (bit) GDK_SORTED@2) == 0) {
		b->batDirtydesc = TRUE;
	}
	b->hsorted |= (bit) GDK_SORTED@2;
	return TRUE;
}

BAT *
BATsort@3(BAT *b)
{
	BAT *bn;
	int tt = b->ttype;

	BATcheck(b, "BATsort@3: BAT");
	if (b->htype == TYPE_void && b->hseqbase == oid_nil) {
		/* b's head is void-nil, hence we return a read-only copy/view of b */
		return BATrcopy(b);
	}
	if ((GDK_SORTED@2 == GDK_SORTED && b->htype == TYPE_void) || (b->htype != TYPE_void && BATordered@3(b))) {
		/* b is already ordered as desired, hence we return a read-only copy/view of b */
		return BATrcopy(b);
	}
	if (BATcount(b) < 2) {
		/* with less than 2 BUNs, b is ordered, hence we return a read-only copy/view of b */
		b->hsorted = (bit) GDK_SORTED@2;
		return BATrcopy(b);
	}
	/* a void tail column 0,1,2,3,... must be materialized to oid before sorting */
	if (tt == TYPE_void && b->tseqbase != oid_nil) {
		tt = TYPE_oid;
	}
	if ((GDK_SORTED@2 == GDK_SORTED_REV && b->htype == TYPE_void) || (b->htype != TYPE_void && BATordered@4(b))) {
		/* b is ordered in the opposite direction, hence we return a reverted copy of b */
		/* a void head column must be materialized to oid before reverting */
		int ht = b->htype;

		if (ht == TYPE_void && b->hseqbase != oid_nil) {
			ht = TYPE_oid;
		}
		bn = BATrevert(batcopy(b, ht, tt, TRUE));
		if (bn == NULL)
			return bn;

		bn->hsorted = (bit) GDK_SORTED@2;
		return bn;
	}
	bn = batcopy(b, b->htype, tt, TRUE);
	if (bn == NULL)
		return bn;
	return BATorder@3(bn);
}

BAT *
BATorder@3(BAT *b)
{
	BATcheck(b, "BATorder@3: BAT");
	if (b->htype == TYPE_void && b->hseqbase == oid_nil) {
		/* b's head is void-nil, hence we return b as is */
		return BATrcopy(b);
	}
	if ((GDK_SORTED@2 == GDK_SORTED && b->htype == TYPE_void) || (b->htype != TYPE_void && BATordered@3(b))) {
		/* b is already ordered as desired, hence we return b as is */
		return b;
	}
	if (BATcount(b) < 2) {
		/* with less than 2 BUNs, b is ordered, hence we return b as is */
		b->hsorted = (bit) GDK_SORTED@2;
		return b;
	}
	if (b->ttype == TYPE_void && b->tseqbase != oid_nil) {
		GDKwarning("void tail column will become nil during order@3.\nTo keep it, please materialize it to oid, first.\n");
		/* ignore the void case here */
		b->tseqbase = oid_nil;
		BATmirror(b)->hseqbase = oid_nil;
	}
	if ((GDK_SORTED@2 == GDK_SORTED_REV && b->htype == TYPE_void) || (b->htype != TYPE_void && BATordered@4(b))) {
		/* b is ordered in the opposite direction, hence we revert b */
		b = BATrevert(b);
		b->hsorted = (bit) GDK_SORTED@2;
		return b;
	}
	GDKqsort@3(BUNfirst(b), (b->hheap)?b->hheap->base:NULL, BATcount(b), BUNsize(b), b->htype, b->hloc);
	HASHdestroy(b);
	ALIGNdel(b, "BATorder@3");
	b->hsorted = (bit) GDK_SORTED@2;
	b->tsorted = FALSE;
	b->hdense = FALSE;
	b->batDirtydesc = b->batDirtybuns = TRUE;

	return b;
}
@}
@+ Reverse a BAT
@%BATrevert@ rearranges a BAT in reverse order on head.
@{
@c
BAT *
BATrevert(BAT *b)
{
	int xx;
	char *buf;
	BUN p, q;

	BATcheck(b, "BATrevert");
	if ((b->htype == TYPE_void && b->hseqbase != oid_nil) || (b->ttype == TYPE_void && b->tseqbase != oid_nil)) {
		GDKwarning("Cannot reverse order on void columns.\nPlease materialize them to oid, first.\n");
		return b;
	}
	ALIGNdel(b, "BATrevert");
	xx = BUNsize(b);
	buf = (char *) GDKmalloc(xx);
	for (p = BUNlast(b) - xx, q = BUNfirst(b); p > q; p -= xx, q += xx) {
		memcpy(buf, p, xx);
		memcpy(p, q, xx);
		memcpy(q, buf, xx);
	}
	HASHdestroy(b);
	b->hsorted = b->tsorted = FALSE;
	GDKfree(buf);
	return b;
}

@
@}

@+ BAT partitioning
For distributed processing we support hash and range
partitioning operators: @%BATsplithash@ and @%BATsplitrange@.
@{
@-
The @%part_bat@ function creates a partition BAT.
@c
BAT *
part_bat(BAT *b, int ht, int tt, size_t expected_size, int respect_order)
{
	BAT *bn = BATnew(ht, tt, (size_t) ((double) expected_size * BATMARGIN));

	if (bn) {
		BATkey(bn, b->hkey);
		BATkey(BATmirror(bn), b->tkey);
		bn->hsorted = (respect_order && (BAThordered(b) & 1)) ? GDK_SORTED : 0;
		bn->tsorted = (respect_order && (BATtordered(b) & 1)) ? GDK_SORTED : 0;
	}
	return bn;
}

@- hash partitioning
@c
#define BUNhash(bx,hx,tx)\
	/* assert(n <= 0x40000000); */\
	i = (int)(HASHprobe(&h,tx)%n); \
	if ((r = BUNfnd(bx, &i)) != NULL){\
		bat bid = *(bat*)BUNtloc(bx,r); \
		bunfastins(BBPdescriptor(bid), hx, tx);\
	}

BAT *
BAThashsplit(BAT *b, size_t n, int unary)
{
	BAT *metabat, *bn, *bf;
	BUN r;
	Hash h;
	size_t cnt;
	int i = 0;

	/* assert(n <= 0x40000000); */
	BATcheck(b, "BAThashsplit");
	if (n > BATcount(b)) {
		GDKwarning("BAThashsplit: reduced number of ranges (" SZFMT ") to number of tuples (" SZFMT ").", n, BATcount(b));
		n = BATcount(b);
	}
	if (n < 1) {
		GDKerror("BAThashsplit: number of ranges must not be less than 1!\n");
		return 0;
	}

	metabat = BATnew(TYPE_int, TYPE_bat, n);
	if (metabat == NULL)
		return NULL;
	bn = unary ? VIEWhead_(b, b->batRestricted) : b;
	if (n <= 1) {
		if (BUNins(metabat, &i, &bn->batCacheid) == NULL)
			goto bunins_failed;
	} else {
		BUN p, q;

		for (i = 2; i < (int) n; i *= 2)
			;
		h.mask = i - 1;
		h.type = BATttype(b);
		cnt = (size_t) (BATMARGIN * (double) BATbuncount(b) / (double) n);
		for (i = 0; i < (int) n; i++) {
			bf = part_bat(bn, BAThtype(bn), BATttype(bn), cnt, TRUE);
			if (bf == NULL) {
				BBPreclaim(metabat);
				return NULL;
			}
			if (BUNins(metabat, &i, &bf->batCacheid) == NULL)
				goto bunins_failed;
		}
		@:updateloop(metabat,b,BUNhash)@
		BATloop(metabat, p, q) {
			bat bf = *(bat *) BUNtail(metabat, p);

			BBPunfix(bf);
		}
	}
	return metabat;
      bunins_failed:
	BBPreclaim(metabat);
	return NULL;
}

@}
@-
Range partitioning ensures that identical values appear in one
partition only. The routine also tries to deliver partitions of
uniform size.
@{
@c
BAT *
BATrangesplit(BAT *b, size_t n, int unary)
{
	BAT *metabat, *slice, *histo, *bf = NULL, *bn, *m;
	int target, tpe, *sizes;
	int xx, zz = 0;
	size_t yy = 0;
	ptr *seps, nilval;
	BUN r, s;
	dbl scale;
	size_t thorough = (n <= 1 || BATtvoid(b) || (BATtordered(b) & 1)) ? 1 : 10;

	BATcheck(b, "BATrangesplit");
	if (n > BATcount(b)) {
		GDKwarning("BATrangesplit: reduced number of ranges (" SZFMT ") to number of tuples (" SZFMT ").", n, BATcount(b));
		n = BATcount(b);
	}
	if (n < 1) {
		GDKerror("BAThashsplit: number of ranges must not be less than 1!\n");
		return 0;
	}

	/* assert(BATcount(b)/n <= 0x7fffffff); */
	bn = unary ? VIEWhead_(b, b->batRestricted) : b;
	m = BATmirror(b);
	metabat = BATnew(BATttype(b), TYPE_bat, n);
	BATcheck(metabat, "BATrangesplit 2");
	nilval = ATOMnilptr(BATttype(b));

@-
@}
We use sampling to determine bucket sizes.
Uniform bucket sizes are the ideal to be achieved.
If necessary though, we deliver less than n buckets.
@{
@c
	slice = BATsample(b, MIN(MAX(30 * n * thorough, 100 * thorough), BATcount(b)));
	histo = BAThistogram(slice);
	target = (int) (BATcount(b) / n);	/* see assert above */
	scale = ((dbl) BATcount(b)) / ((dbl) BATcount(slice));
	BBPreclaim(slice);
	sizes = (int *) GDKmalloc(2 * n * sizeof(int));
	seps = (ptr *) GDKmalloc(2 * n * sizeof(ptr));
@-
Use the histogram to determine good split boundaries on b.
@c
	BATorder(histo);
	BATloopFast(histo, r, s, xx) {
		int cnt = *(int *) BUNtloc(histo, r);
		int add = (int) (scale * cnt);

		if (zz + add > target) {
			if ((zz + add - target) < (target - zz)) {
				sizes[yy] = zz + add;
				seps[yy] = ATOMdup(histo->htype, BUNhead(histo, r));
				add = 0;
			} else {
				sizes[yy] = zz;
				seps[yy] = ATOMdup(histo->htype, BUNhead(histo, (r - xx)));
			}
			zz = 0;
			yy++;
		}
		zz += add;
	}
	if ((sizes[yy - 1] + zz - target) > (target - zz)) {
		sizes[yy] = zz;
	} else {
		yy--;		/* join with the last */
	}
	seps[yy] = nilval;
	BBPreclaim(histo);

	if (n > 1 && n != yy + 1) {
		GDKwarning("rangesplit: delivering %lu instead of %lu fragments\n", yy + 1, n);
		n = yy + 1;
	}
@-
CASE 1: just one bucket.
This is done without copying b.
@c
	if (n <= 1) {
		if (BUNins(metabat, nilval, &bn->batCacheid) == NULL)
			goto bunins_failed;

@-
CASE 2: sorted on fragmentation column.
We can again avoid copying, by giving slices (views) on the source BAT.
Virtual oids (void) is a special subcase with positional lookup instead
of binary search.
@c
	} else if (BATtvoid(b) || (BATtordered(b) & 1)) {
		size_t l, h = 0, o = BUNindex(b, BUNfirst(b));

		for (yy = 0; yy < n; yy++) {
			l = h;
			if (yy == n - 1) {
				r = BUNlast(m);
				h = BUNindex(b, r) - o;
			} else if (BATtdense(b)) {
				h = ((*(oid *) seps[yy]) - b->tseqbase) + 1;
			} else {
				r = SORTfndlast(m, seps[yy]);
				h = BUNindex(b, r) - o;
			}
			bf = BATslice(bn, l, h);	/* produces view bat */
			if (BUNins(metabat, seps[yy], &bf->batCacheid) == NULL)
				goto bunins_failed;
		}

@-
CASE 3: full scan.
If it ain't sorted then we gotta scan the whole thing and split.
This is heavy stuff so we optimize execution according to datatype.
@
DELETED: simple walk-through list approach
		for(yy=0; yy<n-1; yy++) {
			if (@@1_LE(val, seps[yy], @@3)) break;
		}
		bunfastins(bats[yy], BUNhead(b,r), val);
@
We now use binary search for getting to the right bucket, so
that this routine also works efficiently on many buckets.

@= rangesplit
	BATloopFast(b, r, s, xx) {
		ptr val = BUNt@2(b,r);
		size_t lo = 0;
		size_t hi = n-1;
		for (;;) {
			yy = (lo+hi)/2;
			if (yy < n-1 && @1_GT(val, seps[yy], @3)) {
				lo = yy + 1;
				if (lo >= hi) {
					yy = hi;
					break;
				}
			} else if (yy > 0 && @1_LE(val, seps[yy-1], @3)) {
				hi = yy - 1;
				if (hi <= lo) {
					yy = lo;
					break;
				}
			} else {
				break;
			}
		}
		bunfastins(bats[yy], BUNhead(b,r), val);
	}
@c
	} else {
		BAT **bats = (BAT **) GDKmalloc(n * sizeof(BAT *));

		for (yy = 0; yy < n; yy++) {
			bats[yy] = part_bat(bn, BAThtype(bn), bn->ttype, sizes[yy], TRUE);
			if (bats[yy] == NULL) {
				BBPreclaim(metabat);
				return NULL;
			}
			if (BUNins(metabat, seps[yy], &bats[yy]->batCacheid) == NULL)
				goto bunins_failed;
		}
		switch (tpe = ATOMstorage(b->ttype)) {
#ifndef NOEXPAND_CHR
		case TYPE_chr:
			@:rangesplit(simple,loc,chr)@

			break;
#endif
#ifndef NOEXPAND_SHT
		case TYPE_sht:
			@:rangesplit(simple,loc,sht)@

			break;
#endif
#ifndef NOEXPAND_INT
		case TYPE_int:
			@:rangesplit(simple,loc,int)@

			break;
#endif
#ifndef NOEXPAND_FLT
		case TYPE_flt:
			@:rangesplit(simple,loc,flt)@

			break;
#endif
#ifndef NOEXPAND_DBL
		case TYPE_dbl:
			@:rangesplit(simple,loc,dbl)@

			break;
#endif
#ifndef NOEXPAND_LNG
		case TYPE_lng:
			@:rangesplit(simple,loc,lng)@

			break;
#endif
		default:
			if (b->tvarsized) {
				@:rangesplit(atom,var,tpe)@
			} else {
				@:rangesplit(atom,loc,tpe)@
			}

			break;
		}
		for (yy = 0; yy < n; yy++)
			BBPunfix(bats[yy]->batCacheid);
		GDKfree(bats);
	}
	for (yy = 0; yy < n - 1; yy++)
		GDKfree(seps[yy]);
	GDKfree(seps);
	GDKfree(sizes);

	return metabat;

      bunins_failed:
	BBPreclaim(metabat);
	return NULL;
}

@}
@+ Introducing OID Columns
The @%BATmark@ operation is normally used to prepare a class of query
results. Likewise, @%BATnumber@ is heavily used in the SQL front-end.
@{
@c
BAT *
BATmark(BAT *b, oid oid_base)
{
	BAT *bn;

	BATcheck(b, "BATmark");
	bn = VIEWhead(b);
	if (bn) {
		BATseqbase(BATmirror(bn), oid_base);
		if (BATrestricted(b) != BAT_READ) {
			BAT *v = bn;

			bn = BATcopy(v);
			BBPreclaim(v);
		}
	}
	return bn;
}

#define BUNnumber(bx,hx,tx)	bunfastins_nocheck(bx, r, hx, (ptr)&i, yy); r += yy; i++;
BAT *
BATnumber(BAT *b)
{
	int i = 0, yy;
	BAT *bn;
	BUN r;

	BATcheck(b, "BATnumber");
	/* assert(BATcount(b) <= MAXINT); */
	bn = BATnew(b->htype, TYPE_int, BATcount(b));
	if (bn == NULL)
		return NULL;
	r = BUNfirst(bn);
	yy = BUNsize(bn);
	@:updateloop(bn,b,BUNnumber)@
	ALIGNsetH(bn, b);
	BATsetprop_int(bn, GDK_AGGR_CARD, i);
	bn->hsorted = BAThordered(b);
	bn->tsorted = GDK_SORTED;
	return bn;
      bunins_failed:
	BBPreclaim(bn);
	return NULL;
}

BAT *
BATgroup(BAT *b, int start, int incr, int grpsize)
{
	BUN p, q, r;
	int ngroups = 1, i = 0, xx, yy;
	BAT *bn;

	BATcheck(b, "BATgroup");
	bn = BATnew(b->htype, TYPE_int, BATcount(b));
	if (bn == NULL)
		return NULL;
	r = BUNfirst(bn);
	yy = BUNsize(bn);

	ALIGNsetH(bn, b);

	BATloopFast(b, p, q, xx) {
		bunfastins_nocheck(bn, r, BUNhead(b, p), (ptr) &start, yy);
		r += yy;
		if (i == grpsize - 1) {
			start += incr;
			i = 0;
			ngroups++;
		} else {
			i++;
		}
	}
	if (i == 0)
		ngroups--;
	BATsetprop_int(bn, GDK_AGGR_CARD, ngroups);
	bn->hsorted = BAThordered(b);
	bn->tsorted = GDK_SORTED;
	return bn;
      bunins_failed:
	BBPreclaim(bn);
	return NULL;
}

BAT *
BATconst(BAT *b, int tailtype, ptr v)
{
	BAT *bn;
	BUN p, q, r;
	int xx, yy;

	BATcheck(b, "BATconst");
	if (BATrestricted(b) == BAT_READ && (tailtype == TYPE_void || (tailtype == TYPE_oid && *(oid *) v == oid_nil))) {
		oid seqbase = (tailtype == TYPE_void) ? oid_nil : *(oid *) v;

		bn = VIEWhead(b);
		BATseqbase(BATmirror(bn), seqbase);
		return bn;
	}
	if (tailtype == TYPE_bat) {
		v = &((BAT *) v)->batCacheid;
	} else if (tailtype == TYPE_void && b->htype == TYPE_void) {
		tailtype = TYPE_oid;
		v = ATOMnilptr(TYPE_oid);
	}
	bn = BATnew(b->htype, tailtype, BATcount(b));
	if (bn == NULL) {
		return bn;
	}
	r = BUNfirst(bn);
	yy = BUNsize(bn);
	BATloopFast(b, p, q, xx) {
		bunfastins_nocheck(bn, r, BUNhead(b, p), v, yy);
		r += yy;
	}
	ALIGNsetH(bn, b);
	bn->tsorted = GDK_SORTED;
	BATsetprop_int(bn, GDK_AGGR_CARD, BATcount(b) > 0);
	if (tailtype == TYPE_bit) {
		BATsetprop_int(bn, GDK_AGGR_SIZE, (*(bit *) v == TRUE) ? BATcount(b) : 0);
	}
	return bn;
      bunins_failed:
	BBPreclaim(bn);
	return NULL;
}

@}
@+ BAT Aggregates

We retain the size() and card() aggregate results in the column descriptor.
We would like to have such functionality in an extensible way for many aggregates,
for DD (1) we do not want to change the binary BAT format on disk and (2) aggr
and size are the most relevant aggregates.

It is all hacked into the aggr[3] records; three adjacent integers that
were left over in the column record. We refer to these as if it where an int aggr[3] array.
The below routines set and retrieve the aggregate values from the tail of the BAT, as many
aggregate-manipulating BAT functions work on tail.

The rules are as follows: aggr[0] contains the alignment ID of the column (if set i.e. nonzero).
Hence, if this value is nonzero and equal to b->talign, the precomputed aggregate values in
aggr[GDK_AGGR_SIZE] and aggr[GDK_AGGR_CARD] hold. However, only one of them may be set
at the time. This is encoded by the value int_nil, which cannot occur in these two aggregates.

This was now extended to record the property whether we know there is a nil value present
by mis-using the highest bits of both GDK_AGGR_SIZE and GDK_AGGR_CARD.
@{
@c
#define GDK_NIL_BIT 0x80000000	/* (1 << 31) */

void
PROPdestroy(PROPrec *p)
{
	PROPrec *n;
	while(p){
		n = p->next;
		if (p->v.vtype == TYPE_str)
			GDKfree(p->v.val.sval);
		GDKfree(p);
		p = n;
	}
}

static PROPrec *
BATgetprop(BAT *b, int idx)
{
	PROPrec *p = b->T->props;
	while(p) {
		if (p->id == idx)
			return p;
		p = p -> next;
	}
	return NULL;
}

bit
BATgetprop_bit(BAT *b, int idx)
{
	PROPrec *p = BATgetprop(b, idx); 
	return (p)?p->v.val.cval[0]:bit_nil;
}

int
BATgetprop_int(BAT *b, int idx)
{
	PROPrec *p = BATgetprop(b, idx); 
	return (p)?p->v.val.ival:int_nil;
}

str
BATgetprop_str(BAT *b, int idx)
{
	PROPrec *p = BATgetprop(b, idx); 
	return (p)?p->v.val.pval:str_nil;
}

static void 
BATsetprop( BAT *b, int idx, int type, void *v)
{
	ValRecord vr;
	PROPrec *p = BATgetprop(b, idx);

	if (!p) {
		p = (PROPrec*)GDKmalloc(sizeof(PROPrec));
		p->id = idx;
		p->next = b->T->props;
		b->T->props = p;
	}
	VALset(&vr, type, v);
	VALcopy(&p->v, &vr);
	b->batDirtydesc = TRUE;
}

void
BATsetprop_bit(BAT *b, int idx, bit val)
{
	BATsetprop(b, idx, TYPE_bit, &val);
}

void
BATsetprop_int(BAT *b, int idx, int val)
{
	BATsetprop(b, idx, TYPE_int, &val);
}

void
BATsetprop_str(BAT *b, int idx, str val)
{
	BATsetprop(b, idx, TYPE_str, val);
}

void
BATpropagate(BAT *dst, BAT *src, int idx) 
{
	PROPrec *p = BATgetprop(src, idx);
	if (p) BATsetprop(dst, idx, p->v.vtype, VALget(&p->v));
}


@}
@-
The @%BAThistogram@ function calculates the frequency distribution of the
tail values in its operand bat. Notice, that updates on the result do
not affect the delta administration.
Construction of a histogram over a string (or complex object)
can be sped up using the reference information in the BUN
and bulk copying the heap.

There are separate versions for each type, and for each a
hash- and a merge-algorithms.
@{
@= histoloop_inner
	if (b->tkey) {
		yy=1;
		BATloopFast(b, p, q, xx)
			bunfastins(bn, BUNt@1(b,p), &yy);
	} else if (!(BATtordered(b)&1)) {
		BATloopFast(b, p, q, xx) {
			ptr v =  (ptr) BUNt@1(b,p);

			if (BATprepareHash(bn))
				goto bunins_failed;
			HASHloop@2(bn, bn->hhash, tt, v, r)
				goto found@3@2;
			if (BUNins(bn, v, &yy) == NULL)
				goto bunins_failed;
			r = BUNlast(bn) - BUNsize(bn);
found@3@2:		(*(int*) BUNtloc(bn,r))++;
		}
		HASHdestroy(bn);
	} else if (BATcount(b)) {
		ptr prev = (ptr) BUNt@1(b, BUNfirst(b));

		BATloopFast(b, p, q, xx) {
			ptr v = (ptr) BUNt@1(b,p);

			if (@3_CMP(v, prev, @4) == 0) {
				yy++;
			} else {
				bunfastins(bn, prev, &yy);
				yy = 1;
			}
			prev = v;
		}
		bunfastins(bn, prev, &yy);
	}
@= histoloop
{
	hash_t tt;
	int xx, yy = 0;
	BUN p, q, r;

	switch(ATOMstorage(tt=bn->htype)) {
#ifndef NOEXPAND_CHR
	case TYPE_chr:
		@:histoloop_inner(loc,_chr,simple,chr)@
		break;
#endif
#ifndef NOEXPAND_SHT
	case TYPE_sht:
		@:histoloop_inner(loc,_sht,simple,sht)@
		break;
#endif
#if !defined(NOEXPAND_INT) || !defined(NOEXPAND_FLT)
	case TYPE_int:
	case TYPE_flt:
		@:histoloop_inner(loc,_int,simple,int)@
		break;
#endif
#if !defined(NOEXPAND_LNG) || !defined(NOEXPAND_DBL)
	case TYPE_lng:
	case TYPE_dbl:
		@:histoloop_inner(loc,_lng,simple,lng)@
		break;
#endif
	default:
		if (bn->hvarsized) {
			@:histoloop_inner(var,var,atom,tt)@
		} else {
			@:histoloop_inner(loc,loc,atom,tt)@
		}
		break;
	}
}
@c
BAT *
BAThistogram(BAT *b)
{
	BAT *bn;
	int tricky = 0;

	BATcheck(b, "BAThistogram");

	tricky = (b->ttype == TYPE_str && strElimDoubles(b->theap));
	if (b->talign == 0) {
		b->talign = OIDnew(1);
	}
	bn = BATnew(tricky ? TYPE_var : b->ttype, TYPE_int, 200);
	if (bn == NULL) {
		return bn;
	}

	@:histoloop()@
@-
And now correct the interpretation of the values encountered
by bulk copying the heap as well
@c
	if (tricky) {
		BAT *bm;

		bn->hheap = (Heap*)GDKzalloc(sizeof(Heap));
		if (bn->hheap && b->theap->filename) {
			char *nme = BBP_physical(bn->batCacheid);
			
			bn->hheap->filename = (str) GDKmalloc(strlen(nme) + 12);
			GDKfilepath(bn->hheap->filename, NULL, nme, "hheap");
		}
		if (HEAPcopy(bn->hheap, b->theap) < 0) {
		      bunins_failed:
			BBPreclaim(bn);
			return NULL;
		}
		bm = BATmirror(bn);
		bm->ttype = bn->htype = b->ttype;
		bm->tvarsized = bn->hvarsized = 1;
	}
	bn->hsorted = (BATcount(bn) < 2 ? GDK_SORTED : BATtordered(b));
	bn->tsorted = (BATcount(bn) < 2 ? GDK_SORTED : FALSE);
	bn->halign = NOID_AGGR(b->talign);
	if (BATcount(bn) == BATcount(b)) {
		BAT *bm = BATmirror(b);
		ALIGNsetH(bn, bm);
	}
	BATkey(bn, TRUE);
	BATkey(BATmirror(bn), BATcount(bn) < 2);
	if (b->ttype == TYPE_bit) {
		bit trueval = TRUE;
		BUN p = BUNfnd(bn, &trueval);

		BATsetprop_int(b, GDK_AGGR_SIZE, p ? *(int *) BUNtloc(bn, p) : 0);
	}
	BATsetprop_int(b, GDK_AGGR_CARD, BATcount(bn));
	return bn;
}

@-
The @%BATcount_no_nil@ function counts all BUN in a BAT that have a non-nil tail value.
@= cntloop
	BATloopFast(b, p, q, xx) {
		if (!@1_EQ(nil,BUNt@2(b, p),@3)) {
			cnt++;
		}
	}
@c
size_t
BATcount_no_nil(BAT *b)
{
	size_t cnt = (size_t) 0;
	BUN p, q;
	int xx;
	hash_t tt;
	ptr nil;

	BATcheck(b, "BATcnt");
	tt = b->ttype;
	nil = ATOMnilptr(tt);
	switch (ATOMstorage(tt)) {
#ifndef NOEXPAND_CHR
	case TYPE_chr:
		@:cntloop(simple,loc,chr)@

		break;
#endif
#ifndef NOEXPAND_SHT
	case TYPE_sht:
		@:cntloop(simple,loc,sht)@

		break;
#endif
#ifndef NOEXPAND_INT
	case TYPE_int:
		@:cntloop(simple,loc,int)@

		break;
#endif
#ifndef NOEXPAND_FLT
	case TYPE_flt:
		@:cntloop(simple,loc,flt)@

		break;
#endif
#ifndef NOEXPAND_LNG
	case TYPE_lng:
		@:cntloop(simple,loc,lng)@

		break;
#endif
#ifndef NOEXPAND_DBL
	case TYPE_dbl:
		@:cntloop(simple,loc,dbl)@

		break;
#endif
	default:
		if (b->hvarsized) {
			@:cntloop(atom,var,tt)@
		} else {
			@:cntloop(atom,loc,tt)@
		}
		break;
	}
	return cnt;
}

@}
