@f gdk_posix
@a Niels Nes, Peter Boncz
@* System Independent Layer

GDK is built on POSIX. Exceptions are made for memory mapped files and 
anonynmous virtual memory, for which somewhat higher-level functions are 
defined here.

Most of this file concerns itself with emulation POSIX functionality on 
the WIN32 native platform.
@h
#ifndef GDK_POSIX_H
#define GDK_POSIX_H

#include "gdk_system.h"

#ifdef HAVE_CONFIG_H 
#include "config.h"
#endif

#include <sys/types.h>

#ifdef HAVE_MALLOC_H
# include <malloc.h>	/* mallopt, mallinfo, and  malloc, free etc. */
#endif

#if TIME_WITH_SYS_TIME
# include <sys/time.h>
# include <time.h>
#else
# if HAVE_SYS_TIME_H
#  include <sys/time.h>
# else
#  include <time.h>
# endif
#endif

#define NOMALLOPT 	/* we assume no mallopt if there is no mallinfo */

#if (defined(WIN32) && (!defined(__CYGWIN__)) && (!defined(__CYGWIN32__)))
# define NATIVE_WIN32 1
#endif

#ifndef HAVE_MALLINFO
#define M_MXFAST	1  /* set size of blocks to be fast */
#define M_NLBLKS	2  /* set number of block in a holding block */
#define M_GRAIN		3  /* set number of sizes mapped to one, for */
                           /* small blocks */
#define M_KEEP		4  /* retain contents of block after a free */
                           /* until another allocation */
struct mallinfo  {
        int arena;      /* total space in arena */
        int ordblks;    /* number of ordinary blocks */
        int smblks;     /* number of small blocks */
        int hblks;      /* number of holding blocks */
        int hblkhd;     /* space in holding block headers */
        int usmblks;    /* space in small blocks in use */
        int fsmblks;    /* space in free small blocks */
        int uordblks;   /* space in ordinary blocks in use */
        int fordblks;   /* space in free ordinary blocks */
        int keepcost;   /* cost of enabling keep option */
};
typedef struct mallinfo mallinfo_t;

#define mallinfo() 		{0}
#define mallopt(cmd,value)	0

#endif /* ! HAVE_MALLINFO */

gdk_export struct mallinfo MT_mallinfo();

@- locking, sleep, vsnprintf, snprintf
@h
#define F_TLOCK 2 /* test and lock a region for exclusive use */
#define F_ULOCK 0 /* unlock a previously locked region */
#define F_LOCK 1 /* lock a region for exclusive use */

gdk_export int 	MT_lockf(char *filename, int mode, size_t off, int len);
gdk_export void MT_sleep_ms(unsigned int ms);

#ifndef HAVE_VSNPRINTF
#define vsnprintf(buf,size,format,ap) vsprintf(buf,format,ap)
#endif

#ifndef HAVE_SNPRINTF
#define snprintf(buf,size,format,ap) sprintf(buf,format,ap)
#endif

@- virtual memory
@h
#define MT_VMUNITLOG 	16
#define MT_VMUNITSIZE 	(1 << MT_VMUNITLOG)

gdk_export int MT_alloc_register(void *p, unsigned int size, char mode);
gdk_export int MT_alloc_print();

/* the new mmap modes, mimick default MADV_* madvise POSIX constants */
#define MMAP_NORMAL     	0               /* no further special treatment */
#define MMAP_RANDOM     	1               /* expect random page references */
#define MMAP_SEQUENTIAL 	2               /* expect sequential page references */
#define MMAP_WILLNEED   	3               /* will need these pages */
#define MMAP_DONTNEED   	4               /* don't need these pages */

#define MMAP_READ		1024		/* region is readable (default if ommitted) */
#define MMAP_WRITE		2048		/* region may be written into */
#define MMAP_COPY		4096		/* writable, but changes never reach file */
#define MMAP_ASYNC		8192		/* asynchronous writes (default if ommitted) */
#define MMAP_SYNC		16384		/* writing is done synchronously */ 

/* in order to be sure of madvise and msync modes, pass them to mmap() call as well */

/* a hook function to add any initialization required for the MT_ functionality */
gdk_export void MT_init_posix();

gdk_export void* MT_mmap(char *path, int mode, size_t off, size_t len, void *fixed);
gdk_export int   MT_munmap(void* p, size_t off);
gdk_export int   MT_msync(void* p, size_t len, int mode);
gdk_export int   MT_madvise(void* p, size_t len, int advise);

gdk_export void *MT_vmalloc(size_t size, size_t *maxsize);
gdk_export void  MT_vmfree(void *p, size_t size);
gdk_export void *MT_vmrealloc(void *voidptr, size_t oldsize, size_t newsize, size_t *maxsize);
gdk_export int   MT_path_absolute(char *path);

@- Posix under WIN32 
@T
WIN32 actually supports many posix functions directly.  Some it does not, though. 

For some functionality we move in Monet from posix calls to MT\_\*() calls, which translate easier 
to WIN32.  Examples are MT\_mmap() , MT\_sleep\_ms() and MT\_path\_absolute(). Why? In the case
of mmap() it is much easier for WIN32 to get a filename parameter rather than a file-descriptor. 
That is the reason in the case of mmap() to go for a MT\_mmap() solution.

For some other funtionality, we do not need to abandon the posix interface, though. Two cases can
be distuinguished:
\begin{itemize}
\item missing functions in WIN32, which are directly implemented (e.g. dlopen()/dlsym()/dlclose()).
\item posix functions in WIN32 whose functionlity should be changed a bit. Examples are 
      stat()/rename()/mkdir()/rmdir() who under WIN32 do not work if the path ends with a directory 
      separator, but should work according to posix. We remap such functions using a define
      to an equivalent win\_\*() function (which in its implementation calls through to the WIN32
      function).
\end{itemize}
@h
#ifdef NATIVE_WIN32
#define DIR_SEP '\\' 
#define DIR_SEP_STR "\\" 
#define PATH_SEP ';'
#define PATH_SEP_STR ";"
#define SO_EXT ".dll"

#define RTLD_LAZY	1
#define RTLD_NOW	2
#define RTLD_GLOBAL	4

gdk_export void*	dlopen (const char *__file, int __mode);
gdk_export int		dlclose (void *__handle);
gdk_export void*	dlsym (void * __handle, const char * __name);
gdk_export char*	dlerror (void);
gdk_export int 		gettimeofday(struct timeval *tv, int *ignore_zone);

#define _errno		win_errno
#define ftruncate	win_ftruncate
#define opendir		win_opendir
#define readdir		win_readdir
#define rewinddir	win_rewinddir
#define closedir	win_closedir
#define stat		win_stat
#define mkdir		win_mkdir
#define rmdir		win_rmdir

#define NAME_MAX 255

struct DIR {
  char    	*dir_name;
  int       	just_opened;
  unsigned int  find_file_handle;
  char		*find_file_data;
};

typedef struct DIR DIR;
struct direct {
  char  d_name[NAME_MAX + 1];
  int   d_namelen;
};

gdk_export int *win_errno();
gdk_export int win_ftruncate (int  fd, unsigned int size);
gdk_export DIR* win_opendir (const char *dirname);
gdk_export struct direct* win_readdir (DIR *dir);
gdk_export void win_rewinddir (DIR *dir);
gdk_export int win_closedir (DIR *dir);
gdk_export int win_stat(const char*, struct stat *);
gdk_export int win_rmdir(const char*);
gdk_export int win_mkdir(const char*, const int mode);

#define GDK_MEM_QUERYSIZE(p) _msize(p)

#else /* UNIX (or CYGWIN) */

#define DIR_SEP '/' 
#define DIR_SEP_STR "/" 
#define PATH_SEP ':'
#define PATH_SEP_STR ":"
#define SO_EXT ".so"

#ifdef WIN32 /* but not native, hence CYGWIN specific defines */

#define GDK_MEM_QUERYSIZE(p)	((unsigned int*) (p))[-1]
#define sem_init	win_sem_init
#define sem_destroy	win_sem_destroy
#define sem_wait	win_sem_wait
#define sem_trywait	win_sem_trywait
#define sem_post	win_sem_post

#endif 
#endif 

#define SLASH_2_DIR_SEP(s) {char *t; for(t=strchr(s, (int)'/'    ); t; t=strchr(t+1, (int)'/'    )) *t=DIR_SEP;}
#define DIR_SEP_2_SLASH(s) {char *t; for(t=strchr(s, (int)DIR_SEP); t; t=strchr(t+1, (int)DIR_SEP)) *t='/'    ;}

#endif /* GDK_POSIX_H */
@c
#include "gdk_posix.h"

static void MT_alloc_init();

#include <stdio.h>

#ifdef HAVE_SYS_MMAN_H
# include <sys/mman.h>
#endif

#ifdef HAVE_FCNTL_H
# include <fcntl.h>
#endif

#include <errno.h>

#ifndef HAVE_MADVISE
# define madvise(x,y,z)	0
# ifndef MADV_RANDOM
#  define MADV_RANDOM	0
# endif
#endif 

#ifndef MAP_NORESERVE
# define MAP_NORESERVE 		MAP_PRIVATE
#endif 

#define MMAP_ADVISE		7
#define MMAP_WRITABLE		(MMAP_WRITE|MMAP_COPY)

#ifndef NATIVE_WIN32

char* MT_membase = NULL;

void MT_init_posix(){
	MT_membase = (char*) sbrk(0);
	MT_alloc_init();
}

void* MT_mmap(char *path, int mode, size_t off, size_t len, void *fixed){
	FILE *fp = fopen(path, (mode&MMAP_WRITABLE)?"rb+":"rb" );
	void *ret = (void*) -1;
	if (fp) {
	    ret = mmap(fixed, len, 
		((mode&MMAP_WRITABLE)?PROT_WRITE:0)|PROT_READ, 
		((mode&MMAP_COPY)?MAP_PRIVATE:MAP_SHARED)|(fixed?MAP_FIXED:0),
	        fileno(fp), off);
	    fclose(fp);
	    if (ret != (void*) -1 && (mode&MMAP_ADVISE)) {
		madvise(fixed+off, len, mode&MMAP_ADVISE);
	    }
        }
	return ret;
}

int MT_munmap(void* p, size_t off) {
	return munmap(p, off);
} 

int MT_msync(void* p, size_t len, int mode) {
	return msync(p, len, (mode&MMAP_SYNC)?MS_SYNC:MS_ASYNC);
} 

int MT_madvise(void* p, size_t len, int advise) {
	return madvise(p, len, advise); 
}

struct mallinfo 
MT_mallinfo(){
	struct mallinfo _ret;
#ifdef HAVE_MALLINFO
	_ret = mallinfo();
#else
	memset(&_ret, 0, sizeof(_ret));
#endif
	if (_ret.uordblks + _ret.fordblks > _ret.arena) {
		MT_alloc_register(MT_membase, _ret.arena, 'H');
	}
	return _ret;
}

int MT_path_absolute(char *pathname) {
	return (*pathname == DIR_SEP);
}

#ifdef WIN32
#include <windows.h>
#endif

#else /* WIN32 native */

#ifndef BUFSIZ
#define BUFSIZ 1024
#endif

#undef _errno		
#undef ftruncate
#undef opendir		
#undef readdir		
#undef rewinddir		
#undef closedir		
#undef stat		
#undef mkdir		
#undef rmdir		

#undef NAME_MAX

#include <windows.h>

#include <direct.h>
#include <ctype.h>
#ifdef _MSC_VER
#include <io.h>
#endif /* _MSC_VER */

#define _errno			win_errno


#define MT_SMALLBLOCK 256

void MT_init_posix(){
	WSADATA w;
	int sockopt = SO_SYNCHRONOUS_NONALERT;

	_set_sbh_threshold(MT_SMALLBLOCK);
	if (WSAStartup(0x0101, &w) != 0){
		GDKerror("MT_init: winsock initialisation failed %d\n", 
			WSAGetLastError());
	}
	if ( setsockopt(INVALID_SOCKET, SOL_SOCKET, SO_OPENTYPE, 
		(char*)&sockopt, sizeof(sockopt)) < 0){
		GDKerror("MT_init: winsock set sockopt failed %d\n", 
			WSAGetLastError());
		WSACleanup();
	}
	MT_alloc_init();
}

void* MT_mmap(char *path, int mode, size_t off, size_t len, void* fixed) {
	void *ret = NULL;
	int mode0 = GENERIC_READ;
	int mode1 = FILE_SHARE_READ;
	int mode2 = mode & MMAP_ADVISE;
	int mode3 = PAGE_READONLY;
	int mode4 = FILE_MAP_READ;
        SECURITY_ATTRIBUTES sa;
        HANDLE h1, h2;

	if (mode & MMAP_WRITABLE) {
		mode0 |= GENERIC_WRITE;
		mode1 |= FILE_SHARE_WRITE;
	}
        if (mode2 == MMAP_RANDOM || mode2 == MMAP_DONTNEED) {
                mode2 = FILE_FLAG_RANDOM_ACCESS;
        } else if (mode2 == MMAP_SEQUENTIAL || mode2 == MMAP_WILLNEED) {
                mode2 = FILE_FLAG_SEQUENTIAL_SCAN;
        } else {
                mode2 = FILE_FLAG_NO_BUFFERING;
        }
	if (mode & MMAP_SYNC) {
		mode2 |= FILE_FLAG_WRITE_THROUGH;
	}
	if (mode & MMAP_COPY) {
		mode3 = PAGE_WRITECOPY;
		mode4 = FILE_MAP_COPY;
	} else if (mode & MMAP_WRITE) {
		mode3 = PAGE_READWRITE;
		mode4 = FILE_MAP_WRITE;
	}
        sa.nLength = sizeof(SECURITY_ATTRIBUTES);
        sa.bInheritHandle = TRUE;
        sa.lpSecurityDescriptor = 0;

        h1 = CreateFile(path, mode0, mode1, &sa, OPEN_ALWAYS, mode2, NULL);
        if (h1 == NULL) {
                return (void*) -1;
        }

        h2 = CreateFileMapping(h1, &sa, mode3, (off+len) >> 32, (unsigned int) (off+len), NULL);
        if (h2 == NULL) {
                CloseHandle(h1);
                return (void*) -1;
        }
	if (fixed) {
        	ret = MapViewOfFileEx(h2, mode4, off >> 32, (unsigned int) off, len, fixed);
	} else {
        	ret = MapViewOfFile(h2, mode4, off >> 32, (unsigned int) off, len);
 	}
        if (ret == NULL) {
		ret = (void*) -1;
        }
        CloseHandle(h1);
        CloseHandle(h2);
	return ret;
}

int MT_munmap(void* p, size_t dummy) {
	return UnmapViewOfFile(p);
} 

int MT_msync(void* p, size_t len, int mode) {
	return FlushViewOfFile(p, len);
} 

int MT_madvise(void *p, size_t len, int advise) {
	return 0; /* would -1 be better? */
}




/* TODO */
struct mallinfo MT_mallinfo() {
	struct mallinfo _ret; 
	_HEAPINFO hinfo;
	int heapstatus;

	hinfo._pentry = NULL;
	memset(&_ret, 0, sizeof(struct mallinfo));

	while( (heapstatus = _heapwalk( &hinfo ) ) == _HEAPOK ) { 
		_ret.arena += hinfo._size;
		if (hinfo._size > MT_SMALLBLOCK) {
			_ret.smblks++;
			if (hinfo._useflag == _USEDENTRY) {
				_ret.usmblks += hinfo._size;
				MT_alloc_register(hinfo._pentry, hinfo._size, 'H');
			} else {
				_ret.fsmblks += hinfo._size;
				MT_alloc_register(hinfo._pentry, hinfo._size, 'h');
			}
		} else {
			_ret.ordblks++;
			if (hinfo._useflag == _USEDENTRY) {
				_ret.uordblks += hinfo._size;
				MT_alloc_register(hinfo._pentry, hinfo._size, 'H');
			} else {
				_ret.fordblks += hinfo._size;
				MT_alloc_register(hinfo._pentry, hinfo._size, 'h');
			}
		}
	}
	if (heapstatus == _HEAPBADPTR || 
	    heapstatus == _HEAPBADBEGIN ||
	    heapstatus == _HEAPBADNODE)
	{
	
		GDKerror("mallinfo(): heap is corrupt.");
	}
	_heapmin();
	return _ret;
}

int MT_path_absolute(char *pathname) {
	char *drive_end = strchr(pathname, ':');
	char *path_start = strchr(pathname, '\\');

	if (path_start == NULL) {
		return 0;
	}
	return (path_start == pathname || drive_end == (path_start-1));
}


int win_ftruncate (int  fd, unsigned int size)
{
  HANDLE hfile;
  unsigned int curpos;

  if (fd < 0) return -1;
  
  hfile = (HANDLE) _get_osfhandle (fd);
  curpos = SetFilePointer (hfile, 0, NULL, FILE_CURRENT);
  if (curpos == 0xFFFFFFFF
      || SetFilePointer (hfile, size, NULL, FILE_BEGIN) == 0xFFFFFFFF
      || !SetEndOfFile (hfile))
    {
      int error = GetLastError ();
      if (error && error != ERROR_INVALID_HANDLE) 
	SetLastError(ERROR_OPEN_FAILED); /* enforce EIO */
      return -1;
    }

  return 0;
}

DIR* win_opendir (const char *dirname)
{
  DIR *result = NULL;
  char *mask;
  unsigned int k;

  if (dirname == NULL) return NULL;

  result = (DIR*)malloc(sizeof(DIR));
  result->find_file_data = malloc(sizeof(WIN32_FIND_DATA));
  result->dir_name = strdup (dirname);
  
  k = strlen (result->dir_name);
  if (k && result->dir_name[k - 1] == '\\')
    {
      result->dir_name[k - 1] = '\0';
      k--;
    }
  mask = malloc(strlen(result->dir_name) + 3);
  sprintf( mask, "%s\\*", result->dir_name);

  result->find_file_handle = (unsigned int) FindFirstFile (mask,
					     (LPWIN32_FIND_DATA) result->find_file_data);
  free (mask);

  if (result->find_file_handle == (unsigned int) INVALID_HANDLE_VALUE)
    {
      free (result->dir_name);
      free (result->find_file_data);
      free (result);
      SetLastError(ERROR_OPEN_FAILED); /* enforce EIO */
      return NULL;
    }
  result->just_opened = TRUE;

  return result;
}

static
char*
basename (const char    *file_name)
{
  register char *base;
  
  if (file_name == NULL) return NULL;
  
  base = strrchr (file_name, '\\');
  if (base)
    return base + 1;

  if (isalpha (file_name[0]) && file_name[1] == ':')
    return (char*) file_name + 2;

  return (char*) file_name;
}


struct direct* win_readdir (DIR *dir)
{
  static struct direct result;

  if (dir == NULL) return NULL;

  if (dir->just_opened)
    dir->just_opened = FALSE;
  else
    {
      if (!FindNextFile ((HANDLE) dir->find_file_handle,
			 (LPWIN32_FIND_DATA) dir->find_file_data))
	{
	  int error = GetLastError ();
	  if (error) {
            if (error != ERROR_NO_MORE_FILES) 
	      SetLastError(ERROR_OPEN_FAILED); /* enforce EIO */
	    return NULL;
	  }
	}
    }
  strcpy (result.d_name, basename (((LPWIN32_FIND_DATA) dir->find_file_data)->cFileName));
  result.d_namelen = strlen(result.d_name);
      
  return &result;
}

void win_rewinddir (DIR *dir)
{
  char *mask;

  if (dir == NULL) return;

  if (!FindClose ((HANDLE) dir->find_file_handle))
    printf("win_rewinddir(): FindClose() failed\n");

  mask = malloc(strlen(dir->dir_name) + 3);
  sprintf (mask, "%s\\*", dir->dir_name);
  dir->find_file_handle = (unsigned int) FindFirstFile (mask,
					  (LPWIN32_FIND_DATA) dir->find_file_data);
  free (mask);

  if (dir->find_file_handle == (unsigned int) INVALID_HANDLE_VALUE)
    {
      SetLastError(ERROR_OPEN_FAILED); /* enforce EIO */
      return;
    }
  dir->just_opened = TRUE;
}  

int win_closedir (DIR *dir)
{
  if (dir == NULL) return -1;

  if (!FindClose ((HANDLE) dir->find_file_handle))
    {
      SetLastError(ERROR_OPEN_FAILED); /* enforce EIO */
      return -1;
    }

  free (dir->dir_name);
  free (dir->find_file_data);
  free (dir);

  return 0;
}

static int nodays[12] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };  

#define LEAPYEAR(y) ((((y)%4)==0 && ((y)%100)!=0) || ((y)%400)==0)
#define NODAYS(m,y) (((m)!=2)?nodays[(m)-1]:LEAPYEAR(y)?29:28)

int gettimeofday(struct timeval *tv, int *ignore_zone) {
	unsigned int year, day, month;
	SYSTEMTIME st;

	GetSystemTime(&st);
	for(year=1970; year<st.wYear; year++)
		day += LEAPYEAR(year)?366:365;

	for(month=1; month < st.wMonth; month++)
		day += NODAYS(month,st.wYear);

	day += st.wDay;
	tv->tv_sec = 60*(day*24*60 + st.wMinute) + st.wSecond;
	tv->tv_usec = 1000*st.wMilliseconds;
	return 0;
}

void *dlopen(const char *__file, int __mode){
  if (__file != NULL){
  	HINSTANCE handle = LoadLibrary (__file);
  	return (void*)handle;
  }
  return NULL;
}

int dlclose(void *__handle){
  if (__handle != NULL){
  	HINSTANCE handle = (HINSTANCE)__handle;
  	return FreeLibrary (handle);
  }
  return -1;
}

void *dlsym(void * __handle, const char * __name){
  if (__handle != NULL){
  	HINSTANCE handle = (HINSTANCE)__handle;
  	return (void*)GetProcAddress (handle, __name);
  }
}

char *dlerror(void){
  return strerror(errno);
}

FILE *win_fdopen(int fd, char *flag){
	int lfd;
	if (*flag == 'r'){
	    if ((lfd = _open_osfhandle( fd, _O_BINARY|_O_RDONLY)) == -1){
		printf("fdopen could not open_osfhandle\n");
		return NULL;
            }
	}
	if (*flag == 'w'){
	    if ((lfd = _open_osfhandle( fd, _O_BINARY|_O_WRONLY)) == -1){
		printf("fdopen could not open_osfhandle\n");
		return NULL;
            }
	}
	printf("fdopen %d %d\n", fd, lfd );
	return _fdopen(lfd, flag);
}

/* dir manipulations fail in WIN32 if file name contains trailing slashes; work around this */
static char* reduce_dir_name(const char* src, char* dst, const int cap) {
        int len = strlen(src);
        char *buf = dst;
        if (len >= cap) buf = malloc(len+1);
        while(--len > 0 && src[len-1] != ':' && src[len] == DIR_SEP);
        for(buf[++len]=0; --len>=0; buf[len]=src[len]);
        return buf;
}

int win_stat(const char* pathname, struct stat *st) {
	char buf[128], *p = reduce_dir_name(pathname, buf, 128);
	int ret = stat(p, st);
	if (p != buf) free(p);
	return ret;
}

int win_rmdir(const char* pathname) {
	char buf[128], *p = reduce_dir_name(pathname, buf, 128);
	int ret = rmdir(p);
	if (p != buf) free(p);
	return ret;
}

int win_mkdir(const char* pathname, const int mode) {
	char buf[128], *p = reduce_dir_name(pathname, buf, 128);
	int ret = mkdir(p);
	if (p != buf) free(p);
	return ret;
}

typedef struct {
    int w;		 /* windows version of error */
    const char *s;	 /* text of windows version */
    int e;		 /* errno version of error */
} win_errmap_t;

win_errmap_t win_errmap[] = {
  { ERROR_INVALID_FUNCTION, "ERROR_INVALID_FUNCTION", EBADRQC  },
  { ERROR_FILE_NOT_FOUND, "ERROR_FILE_NOT_FOUND", ENOENT  },
  { ERROR_PATH_NOT_FOUND, "ERROR_PATH_NOT_FOUND", ENOENT  },
  { ERROR_TOO_MANY_OPEN_FILES, "ERROR_TOO_MANY_OPEN_FILES", EMFILE  },
  { ERROR_ACCESS_DENIED, "ERROR_ACCESS_DENIED", EACCES  },
  { ERROR_INVALID_HANDLE, "ERROR_INVALID_HANDLE", EBADF  },
  { ERROR_NOT_ENOUGH_MEMORY, "ERROR_NOT_ENOUGH_MEMORY", ENOMEM  },
  { ERROR_INVALID_DATA, "ERROR_INVALID_DATA", EINVAL  },
  { ERROR_OUTOFMEMORY, "ERROR_OUTOFMEMORY", ENOMEM  },
  { ERROR_INVALID_DRIVE, "ERROR_INVALID_DRIVE", ENODEV  },
  { ERROR_NOT_SAME_DEVICE, "ERROR_NOT_SAME_DEVICE", EXDEV  },
  { ERROR_NO_MORE_FILES, "ERROR_NO_MORE_FILES", ENMFILE  },
  { ERROR_WRITE_PROTECT, "ERROR_WRITE_PROTECT", EROFS  },
  { ERROR_BAD_UNIT, "ERROR_BAD_UNIT", ENODEV  },
  { ERROR_SHARING_VIOLATION, "ERROR_SHARING_VIOLATION", EACCES  },
  { ERROR_LOCK_VIOLATION, "ERROR_LOCK_VIOLATION", EACCES  },
  { ERROR_SHARING_BUFFER_EXCEEDED, "ERROR_SHARING_BUFFER_EXCEEDED", ENOLCK  },
  { ERROR_HANDLE_EOF, "ERROR_HANDLE_EOF", ENODATA  },
  { ERROR_HANDLE_DISK_FULL, "ERROR_HANDLE_DISK_FULL", ENOSPC  },
  { ERROR_NOT_SUPPORTED, "ERROR_NOT_SUPPORTED", ENOSYS  },
  { ERROR_REM_NOT_LIST, "ERROR_REM_NOT_LIST", ENONET  },
  { ERROR_DUP_NAME, "ERROR_DUP_NAME", ENOTUNIQ  },
  { ERROR_BAD_NETPATH, "ERROR_BAD_NETPATH", ENXIO  },
  { ERROR_FILE_EXISTS, "ERROR_FILE_EXISTS", EEXIST  },
  { ERROR_CANNOT_MAKE, "ERROR_CANNOT_MAKE", EPERM  },
  { ERROR_INVALID_PARAMETER, "ERROR_INVALID_PARAMETER", EINVAL  },
  { ERROR_NO_PROC_SLOTS, "ERROR_NO_PROC_SLOTS", EAGAIN  },
  { ERROR_BROKEN_PIPE, "ERROR_BROKEN_PIPE", EPIPE  },
  { ERROR_OPEN_FAILED, "ERROR_OPEN_FAILED", EIO  },
  { ERROR_NO_MORE_SEARCH_HANDLES, "ERROR_NO_MORE_SEARCH_HANDLES", ENFILE  },
  { ERROR_CALL_NOT_IMPLEMENTED, "ERROR_CALL_NOT_IMPLEMENTED", ENOSYS  },
  { ERROR_INVALID_NAME, "ERROR_INVALID_NAME", ENOENT  },
  { ERROR_WAIT_NO_CHILDREN, "ERROR_WAIT_NO_CHILDREN", ECHILD  },
  { ERROR_CHILD_NOT_COMPLETE, "ERROR_CHILD_NOT_COMPLETE", EBUSY  },
  { ERROR_DIR_NOT_EMPTY, "ERROR_DIR_NOT_EMPTY", ENOTEMPTY  },
  { ERROR_SIGNAL_REFUSED, "ERROR_SIGNAL_REFUSED", EIO  },
  { ERROR_BAD_PATHNAME, "ERROR_BAD_PATHNAME", EINVAL  },
  { ERROR_SIGNAL_PENDING, "ERROR_SIGNAL_PENDING", EBUSY  },
  { ERROR_MAX_THRDS_REACHED, "ERROR_MAX_THRDS_REACHED", EAGAIN  },
  { ERROR_BUSY, "ERROR_BUSY", EBUSY  },
  { ERROR_ALREADY_EXISTS, "ERROR_ALREADY_EXISTS", EEXIST  },
  { ERROR_NO_SIGNAL_SENT, "ERROR_NO_SIGNAL_SENT", EIO  },
  { ERROR_FILENAME_EXCED_RANGE, "ERROR_FILENAME_EXCED_RANGE", EINVAL  },
  { ERROR_META_EXPANSION_TOO_LONG, "ERROR_META_EXPANSION_TOO_LONG", EINVAL  },
  { ERROR_INVALID_SIGNAL_NUMBER, "ERROR_INVALID_SIGNAL_NUMBER", EINVAL  },
  { ERROR_THREAD_1_INACTIVE, "ERROR_THREAD_1_INACTIVE", EINVAL  },
  { ERROR_BAD_PIPE, "ERROR_BAD_PIPE", EINVAL  },
  { ERROR_PIPE_BUSY, "ERROR_PIPE_BUSY", EBUSY  },
  { ERROR_NO_DATA, "ERROR_NO_DATA", EPIPE  },
  { ERROR_PIPE_NOT_CONNECTED, "ERROR_PIPE_NOT_CONNECTED", ECOMM  },
  { ERROR_MORE_DATA, "ERROR_MORE_DATA", EAGAIN  },
  { ERROR_DIRECTORY, "ERROR_DIRECTORY", EISDIR  },
  { ERROR_PIPE_CONNECTED, "ERROR_PIPE_CONNECTED", EBUSY  },
  { ERROR_PIPE_LISTENING, "ERROR_PIPE_LISTENING", ECOMM  },
  { ERROR_NO_TOKEN, "ERROR_NO_TOKEN", EINVAL  },
  { ERROR_PROCESS_ABORTED, "ERROR_PROCESS_ABORTED", EFAULT  },
  { ERROR_BAD_DEVICE, "ERROR_BAD_DEVICE", ENODEV  },
  { ERROR_BAD_USERNAME, "ERROR_BAD_USERNAME", EINVAL  },
  { ERROR_NOT_CONNECTED, "ERROR_NOT_CONNECTED", ENOLINK  },
  { ERROR_OPEN_FILES, "ERROR_OPEN_FILES", EAGAIN  },
  { ERROR_ACTIVE_CONNECTIONS, "ERROR_ACTIVE_CONNECTIONS", EAGAIN  },
  { ERROR_DEVICE_IN_USE, "ERROR_DEVICE_IN_USE", EAGAIN  },
  { ERROR_INVALID_AT_INTERRUPT_TIME, "ERROR_INVALID_AT_INTERRUPT_TIME", EINTR},
  { ERROR_IO_DEVICE, "ERROR_IO_DEVICE", EIO },
};

#define GDK_WIN_ERRNO_TLS 13

int *win_errno(){
  /* get address of thread-local POSIX errno; refresh its value from WIN32 error code */
  int i, err = GetLastError() & 0xff;
  int *result = TlsGetValue(GDK_WIN_ERRNO_TLS);

  if (result == NULL) {
	result = (int*) malloc(sizeof(int));
	*result = 0;
	TlsSetValue(GDK_WIN_ERRNO_TLS, result);
  }
  for (i = 0; win_errmap[i].w != 0; ++i) {
      if (err == win_errmap[i].w) {
         *result = win_errmap[i].e;
         break;
      }
  }
  SetLastError(err);
  return result;
} 
#endif

#ifndef WIN32

#define MT_PAGESIZE(s)		((((s-1)/MT_pagesize())+1)*MT_pagesize())

void *MT_vmalloc(size_t size, size_t *maxsize) {
        int fd = open("/dev/zero", O_RDWR, 0666);
        char *q, *r = (char*) -1;

        if (fd < 0) {
                return NULL;
        }
        size = MT_PAGESIZE(size);
        *maxsize = MT_PAGESIZE(*maxsize);
        if (*maxsize > size) {
                r = (char*) mmap(NULL, *maxsize, PROT_NONE, 
				MAP_PRIVATE|MAP_NORESERVE, fd, 0);
        }
        if (r == (char*) -1) {
                *maxsize = size;
                q = (char*) mmap(NULL, size, PROT_READ|PROT_WRITE, 
				MAP_PRIVATE, fd, 0);
        } else {
                q = (char*) mmap(r, size, PROT_READ|PROT_WRITE, 
				MAP_PRIVATE|MAP_FIXED, fd, 0);
        }
        close(fd);
        return (void*) ((q == (char*) -1)?NULL:q);
}

void MT_vmfree(void *p, size_t size) {
        size = MT_PAGESIZE(size);
        munmap(p, size);
}

void *MT_vmrealloc(void *voidptr, size_t oldsize, size_t newsize, size_t *maxsize) {
        char *p=(char*)voidptr;
        char *q = (char*) -1;

        oldsize = MT_PAGESIZE(oldsize);
        newsize = MT_PAGESIZE(newsize);
        *maxsize = MT_PAGESIZE(*maxsize);

        if (oldsize > newsize) {
                munmap(p+oldsize, oldsize-newsize);
        }
        if (oldsize >= newsize) {
                return p;
        }
        if (newsize < *maxsize) {
                int fd = open("/dev/zero", O_RDWR, 0666);
                if (fd >= 0) {
                        q = (char*) mmap(p+oldsize, newsize-oldsize,
                                PROT_READ|PROT_WRITE,
                                MAP_PRIVATE|MAP_FIXED, fd, oldsize);
                        close(fd);
                }
        }
        if (q == (char*) -1) {
                int oldmaxsize = *maxsize;
                q = p; p = (char*) MT_vmalloc(newsize, maxsize);
                if (p != NULL) {
                        memcpy(p, q, oldsize);
                        MT_vmfree(q, oldmaxsize);
                }
        }
        return p;
}

int MT_lockf(char *filename, int mode, size_t off, int len){
	int ret, fd = open(filename, O_CREAT|O_RDWR, 0662);
	if (fd < 0) return fd;
	ret = lseek(fd, off, SEEK_SET) || lockf(fd, mode, len);
	close(fd);
	return ret;
}

void MT_sleep_ms(unsigned int ms) {
        struct timespec ts;
        ts.tv_sec = ms/1000;
        ts.tv_nsec = 1000000*(ms%1000);
        while(nanosleep(&ts, &ts) == -1 && errno == EINTR);
}

#else  /* WIN32 */

#define MT_PAGESIZE(s)		(((((s)-1) >> 12) + 1) << 12)
#define MT_SEGSIZE(s)		((((((s)-1) >> 16) & 65535) + 1) << 16)

#ifndef MEM_TOP_DOWN
#define MEM_TOP_DOWN 0
#endif

void *MT_vmalloc(size_t size, size_t *maxsize) {
       	void *p, *a = NULL;
	int mode = 0;
	size = MT_PAGESIZE(size);
	if (*maxsize < size) {
		*maxsize = size;
	}
	*maxsize = MT_SEGSIZE(*maxsize);
	if (*maxsize < 1000000)	{
		mode = MEM_TOP_DOWN; /* help NT in keeping memory defragmented */
	}
	if (*maxsize > size) {
		a = (void*) VirtualAlloc(NULL, *maxsize, MEM_RESERVE|mode, PAGE_NOACCESS);
		if (a == NULL) {
			*maxsize = size;
		}
	}
	p = (void*) VirtualAlloc(a, size, MEM_COMMIT|mode, PAGE_READWRITE);
	if (p == NULL) {
		fprintf(MT_out, "VirtualAlloc(%x,%d,MEM_COMMIT,PAGE_READWRITE): failed\n", (unsigned int) a, size);
	}
	return p; 
}
 

void MT_vmfree(void *p, size_t size) {
	if (VirtualFree(p, size, MEM_DECOMMIT) == 0)
	fprintf(MT_out, "VirtualFree(%x,%d,MEM_DECOMMIT): failed\n", (unsigned int) p, size);
	if (VirtualFree(p, 0, MEM_RELEASE) == 0)
	fprintf(MT_out, "VirtualFree(%x,0,MEM_RELEASE): failed\n", (unsigned int) p);
}

void* MT_vmrealloc(void* v, size_t oldsize, size_t newsize, size_t *maxsize)
{
	char *a, *p = (char*) v;
	size_t oldmaxsize = *maxsize;

	oldsize = MT_PAGESIZE(oldsize);
	newsize = MT_PAGESIZE(newsize);
	if(oldsize < newsize) {
		if (*maxsize < newsize) {
			*maxsize = newsize;
		}
 		a = (char*) VirtualAlloc(p, newsize, MEM_COMMIT, PAGE_READWRITE);
		if (a != p) {
			if (a == NULL) {
				a = MT_vmalloc(newsize, maxsize);
			}
			if (a != NULL) {
				memcpy(a, p, oldsize);
				MT_vmfree(p, oldmaxsize);
			} 
		} p = a;
	} else if (oldsize > newsize) {
 		int ret = VirtualFree(p+newsize, oldsize-newsize, MEM_DECOMMIT);
 		if (ret == 0) fprintf(MT_out, "VirtualFree(%x,%d,MEM_DECOMMIT): failed\n", (unsigned int) p+newsize, oldsize-newsize);
	} 
	return p;
}

int MT_lockf(char *filename, int mode, size_t off, int len) {
	int ret = 1, illegalmode = 0;
	OVERLAPPED ov;
	OSVERSIONINFO os;
	HANDLE fh = CreateFile(filename, 
			GENERIC_READ|GENERIC_WRITE, 0,
			NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
	    
	os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	GetVersionEx(&os);
	memset(&ov, 0, sizeof(ov));
	ov.Offset = (unsigned int) off;
	ov.OffsetHigh = off >> 32;

	if (fh == NULL) {
	    return -1;
        } 
        if (mode == F_ULOCK) {
	    if (os.dwPlatformId != VER_PLATFORM_WIN32_WINDOWS)
	    ret = UnlockFileEx(fh, 0, 0, len, &ov);
        } else if(mode == F_TLOCK) {
	    if (os.dwPlatformId != VER_PLATFORM_WIN32_WINDOWS)
	    ret = LockFileEx(fh, LOCKFILE_FAIL_IMMEDIATELY|LOCKFILE_EXCLUSIVE_LOCK, 0, 0, len, &ov);
        } else if(mode == F_LOCK) {
	    if (os.dwPlatformId != VER_PLATFORM_WIN32_WINDOWS)
	    ret = LockFileEx(fh, LOCKFILE_EXCLUSIVE_LOCK, 0, 0, len, &ov);
        } else {
	    illegalmode = 1;
	}
	CloseHandle(fh);
	if (illegalmode) {
	    SetLastError(ERROR_INVALID_DATA);
	}
        return ret?0:-1;
}

void MT_sleep_ms(unsigned int ms) {
        sleep(ms);
}


/* this one actually has not been fixed in CYGWIN, hence we do it ourselves */
#undef rename
int win_rename(char* src, char* dst) {
	char srcbuf[128], *p = reduce_dir_name(src, srcbuf, 128);
	char dstbuf[128], *q = reduce_dir_name(src, dstbuf, 128);
	int ret = rename(p,q);
	if (p != srcbuf) free(p);
	if (q != dstbuf) free(q);
	return ret;
}

@-
cygnus1.1.X has a bug in the semaphore routines. we work around it by directly using the WIN32 primitives.
@c
#ifndef NATIVE_WIN32

#undef sem_init
#undef sem_destroy
#undef sem_wait
#undef sem_trywait
#undef sem_post

int win_sem_init (sem_t * sem, int pshared, unsigned int value) {
	*sem = (sem_t) CreateSemaphore(NULL, value, 128, NULL);
	return (*sem)?0:-1;
}

int win_sem_destroy (sem_t * sem) {
	return CloseHandle((HANDLE) *sem)?0:-1;
}

int win_sem_wait (sem_t * sem) {
	return (WaitForSingleObject((HANDLE) *sem, (unsigned int) INFINITE) != WAIT_FAILED)?0:-1;
}

int win_sem_trywait (sem_t * sem) {
	return (WaitForSingleObject((HANDLE) *sem, 0) == 0)?0:EBUSY;
}

int win_sem_post (sem_t * sem) {
	return (ReleaseSemaphore((HANDLE) *sem, 1, NULL) == 0)?-1:0;
}
#endif
#endif

@- memory fragmentation monitoring
@T
On 32-bits systems, Monet's aggressive use of virtual memory may bring it into
trouble as the limits of what is addreassable in a 32-bits system are reached 
(an 32-bits OS only allows 2 to 4GB of memory to be used). In order to aid debugging
situations where VM allocs fail (due to memory fragmentation), a monitoring
system was established. To this purpose, a map is made for the VM addresses
between 0 and 3GB, in tiles of MT\_VMUNITSIZE (64KB). These tiles have a byte
value from the following domain:

\begin{verbatim}
0-9 - thread stack space of thread <num>
B - in use for a large BAT heap.
b - free (last usage was B)
S - in use for a malloc block
s - free (last usage was S)
P - in use for the BBP array
p - free (last usage was P)
M - in use as memory mapped region
m - free (last usage was M)
C - in use as MIL context buffer
c - free (last usage was M)
\end{verbatim}

The MT\_alloc\_printmap condenses the map by printing a char for each MB,
hence combining info from 16 tiles. On NT, we can check in real-time which 
tiles are actually in use (in case our own tile administration is out-of-sync 
with reality, eg due to a memory leak). This real-life usage is printed in a 
second line with encodingw .=free, *=inuse, X=unusable. On Unix systems,
*=inuse is not testable (unless with complicated signal stuff). On 64-bits
systems, this administation is disfunctional. 
@c
unsigned char MT_alloc_map[49600]= { 0 };

int MT_alloc_register(void *addr, unsigned int size, char mode) {
#if SIZEOF_LONG==4
        unsigned int p = (unsigned int) addr;
        if (p > 0 && p < 3*((unsigned int) 1024*1024*1024) && size > 0) {
                unsigned int i, base = ((int) p) >> 16;
                size = (size-1) >> 16;
                for(i=0; i<=size; i++)
                        MT_alloc_map[base+i] = (MT_alloc_map[base+i]&128) | mode;
        }
#endif
        return 0;
}

#define INUSEMODE(x) ((x >= '0' && x <= ('9'+4)) || (x >= 'A' && x <= 'Z'))

int MT_alloc_print() {
#if SIZEOF_LONG==4
        char *p = NULL;
        int i, j, k;

        for(i=0; i<31; i++) {
                fprintf(MT_out, "%02d00MB ", i);
                for(j=0; j<100; j++) {
                        int mode = '.';
                        for(k=0; k<16; k++)  {
                                int m = MT_alloc_map[k + 16*(j + 100*i)]&127;
                                if (mode == '.' || INUSEMODE(m)) mode = m;
                        }
                        fprintf(MT_out, "%c", mode);
                }
#ifdef WIN32
                fprintf(MT_out, "\n       ");
                for(j=0; j<100; j++) {
                        int mode = '.';
                        for(k=0; k<16; k++,p+=1<<16)
                                if (!IsBadReadPtr(p, 1)) {
                                        mode = '*';
                                } else if (MT_alloc_map[k + 16*(j + 100*i)]&128) {
                                        mode = 'X';
                                }
                        fprintf(MT_out, "%c", mode);
                }
#endif
                fprintf(MT_out, "\n");
        }
#endif
        return 0;
}

static void MT_alloc_init() {
#if SIZEOF_LONG==4
        char* p = NULL;
        int i;
        for(i=0; i<49600; i++, p+=MT_VMUNITSIZE) {
		int mode = '.';
#ifdef WIN32
                if (!VirtualAlloc(p, MT_VMUNITSIZE, MEM_RESERVE, PAGE_NOACCESS)) {
			mode |= 128;
                } else {
                        VirtualFree(p, 0, MEM_RELEASE);
                }
#else
		int fd = open("/dev/zero", O_RDWR, 0666);
                void *q = (char*) mmap(p, MT_VMUNITSIZE, PROT_NONE, MAP_NORESERVE, fd, 0);
		close(fd);
		if (q != p) mode |= 128;
		if (q != (char*) -1) munmap(q, MT_VMUNITSIZE);
#endif
                MT_alloc_map[i] = mode;
        }
#endif
}

