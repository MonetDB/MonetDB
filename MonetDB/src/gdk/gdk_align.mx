@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f gdk_align
@a Peter Boncz
@* BAT Alignment 
For BATs that result from a n-ary relational scheme it may help to
align the BATs on their head value. In particular, it permits
replacing a hash-join by a merge-join, which is significantly faster
on large tables. Especially if the BATs involved cause page activity
or when you can not afford the large hash structures to speed-up processing.
@-
For orthogonality, we support alignment between arbitrary columns (head or tail).
@-
All standard GDK set-calls update the alignment info in their respective 
ways. For example, the routine @emph{BUNclustercopy} shuffles the first argument, 
such that the BUNs are in the same order as those in the second argument. 
This operation will mark both columns of the first @emph{BAT} as synced with
the second (likewise, @emph{BATcopy()}, which makes a copy, instead of in-place 
shuffling, has the same alignment effect, @emph{BATmark()} marks the tail column 
as synced with the head of the original @emph{BAT}, and for instance 
@emph{BATsemijoin()} marks both return columns as aligned with its left parameter).
@
Each alignment sequence is given a unique identifier, so as to easily
detect this situation. It is retained in the @emph{BAT descriptor}.
@+ Alignment Design Considerations
Alignment primitives require the right hooks to be inserted in 
several places in the GDK, apart form this file:
@itemize
@item @emph{ BUN update operations}. 
The updated BATs have to be marked as 
un-aligned.
@item @emph{ set operations}. 
For most relational operations some
statements can be made about the size and order of the BATs 
they produce. This information can be formalized by indicating alignment
information automatically.
@item @emph{ transaction operations}. 
Alignment statuses must be 
kept consistent under database commits and aborts.
@end itemize
@
As for performance, the most important observation to make is that 
operations that do not need alignment, will suffer most from
overheads introduced in the BUN update mechanism. For this reason,
the alignment-delete operation has to be very cheap. It is
captured by the @emph{ALIGNdel} macro, and just zaps one character
field in the @emph{BAT} record.
@
@{
@+ Alignment Implementation
The @emph{BAT} record is equipped with an @emph{batAlign} field that keeps
both information about the head and tail column. The leftmost
4 bits are for the head, the rightmost 4 for the tail. This
has been done to make the zap ultra-cheap.

Both head and tail column contain an OID in the @emph{halign} and @emph{talign}
fields respectively to mark their alignment group. All BATs with the
same OID in this field (and the ALIGN_SYNCED bit on) are guaranteed
by the system to have equal head columns. As an exception, they
might also have TYPE_void head columns (a virtual column). 
In such a case, the tail values correspond to the head values
that would have been there in a non-virtual column, continuing
the same head-sequence as the other BATs in the sync group.
@c
#include "gdk.h"

int
ALIGNcommit(BAT *b)
{
	BATcheck(b, "ALIGNcommit: bat required");
	if (!b->halign) {
		b->halign = OIDnew(1);
	}
	if (!b->talign) {
		b->talign = OIDnew(1);
	}
	return 0;
}

int
ALIGNundo(BAT *b)
{
	BATcheck(b, "ALIGNundo: bat required");
	return 0;
}

int
ALIGNsetH(BAT *b1, BAT *b2)
{
	BATcheck(b1, "ALIGNsetH: bat 1 required");
	BATcheck(b2, "ALIGNsetH: bat 2 required");

	if (b2->halign == 0) {
		b2->halign = OIDnew(1);
		b2->batDirtydesc = TRUE;
	} else {
		/* propagate GDK_AGGR information */
		BATpropagate(b1, b2, GDK_AGGR_SIZE);
		BATpropagate(b1, b2, GDK_AGGR_CARD);
		BATpropagate(b1, b2, GDK_AGGR_HASNIL);
	}
	if (BAThvoid(b2)) {
		if (b1->htype != TYPE_void)
			b1->hdense = TRUE;
		BATseqbase(b1, b2->hseqbase);
	}
	BATkey(b1, b2->hkey != FALSE);
	b1->hsorted = BAThordered(b2);
	b1->halign = b2->halign;
	b1->batDirtydesc = TRUE;
	return 0;
}

@-
The routines @emph{ALIGN_synced} and @emph{ALIGN_ordered}
allow to simply query the alignment status of the two head columns
of two BATs.
@c
int
ALIGNsynced(BAT *b1, BAT *b2)
{
	BATcheck(b1, "ALIGNsynced: bat 1 required");
	BATcheck(b2, "ALIGNsynced: bat 2 required");

	/* first try to prove head columns are not in sync */
	if (BATcount(b1) != BATcount(b2))
		return 0;
	if (ATOMtype(BAThtype(b1)) != ATOMtype(BAThtype(b2)))
		return 0;
	if (BAThvoid(b1) && BAThvoid(b2))
		return (b1->hseqbase == b2->hseqbase);

	/* then try that they are */
	if (b1->batCacheid == b2->batCacheid)
		return 1;	/* same bat. trivial case */
	if (BATcount(b1) == 0)
		return 1;	/* empty bats of same type. trivial case */
	if (b1->halign && b1->halign == b2->halign)
		return 1;	/* columns marked as equal by algorithmics */
	if (VIEWparentcol(b1) && ALIGNsynced(BBPcache(VIEWparent(b1)), b2))
		return 1;	/* view on same bat --- left recursive def.. */
	if (VIEWparentcol(b2) && ALIGNsynced(b1, BBPcache(VIEWparent(b2))))
		return 1;	/* view on same bat --- right recursive def.. */

	return 0;		/* we simply don't know */
}

@-
BATs are related if one pair of columns match. This means that
there is some 1-1 correspondence in their BUNs.
@c
int
ALIGNrelated(BAT *b1, BAT *b2)
{
	BATcheck(b1, "ALIGNrelated: bat 1 required");
	BATcheck(b2, "ALIGNrelated: bat 2 required");
	return (ALIGNsynced(b1, b2) || ALIGNsynced(BATmirror(b1), b2) || ALIGNsynced(b1, BATmirror(b2)) || ALIGNsynced(BATmirror(b1), BATmirror(b2)));
}


@+ View BATS
The general routine for getting a 'view' BAT upon another 
BAT is @emph{VIEWcreate}. On this @emph{#read-only} BAT (there is kernel
support for this), you can then make vertical slices. 
Use @emph{VIEWhead} for this. 
@
It is possible to create a view on a writable BAT. Updates
in the parent are then automatically reflected in the VIEW.
Note that the VIEW bat itself can never be modified.
@
Horizontal views should only be given out on a view BAT, but
only if it is dead sure the parent BAT is read-only.
This because they cannot physically share the batBuns heap
with the parent, as they need a modified version.
@c
BAT *
VIEWcreate_(BAT *b, int slice_view)
{
	BAT *bn;
	bat parent;

	BATcheck(b, "VIEWcreate_: bat required");
	bn = BATcreatedesc(b->htype, b->ttype, FALSE);
	parent = VIEWparent(b);

	if (parent == 0) {
		parent = b->batCacheid;
	}
	bn->batParentid = parent;
	if (parent < 0)
		parent = -parent;

	BBPshare(parent);
	gdk_set_lock(GDKhashLock[ABS(parent) & BBPLOCKMASK], "VIEWcreate_");
@-
the H and T column descriptors are fully copied. We need copies
because in case of a mark, we are going to override a column with 
a void. Take care to zero the accelerator data, though. 
@c
	bn->dims = b->dims;
	*bn->H = *b->H;
	*bn->T = *b->T;
	*bn->U = *b->U;
	bn->H->props = bn->T->props = NULL;
@-
The b->P structure cannot be shared and must be copied individually.
@c
	bn->batSet = b->batSet;
	bn->batDirty = BATdirty(b);
	bn->batCopiedtodisk = FALSE;
	bn->batRestricted = BAT_READ;
@-
The U record may be shared with the parent; in that case, the
search accelerators of the parent can be used. If, however, we 
want to take a horizontal fragment (stable=false), this cannot 
be done, and we need to put different information in U (so we can't 
use a copy.
@c
	if (slice_view || VIEWparent(b)) {
		/* slices are unequal to their parents; cannot use accs */
		bn->hhash = bn->thash = NULL;
	} else {
		/* equal pointers to parent mean view uses acc of parent */
		bn->hhash = b->hhash;
		bn->thash = b->thash;
	}
	gdk_unset_lock(GDKhashLock[ABS(parent) & BBPLOCKMASK], "VIEWcreate_");
	BBPcacheit(bn);
	return bn;
}

BAT *
VIEWcreate(BAT *b)
{
	return VIEWcreate_(b, FALSE);
}

@-
The @#VIEWhead@ routine effortlessly projects out the tail column.
@c 
BAT *
VIEWhead(BAT *b)
{
	BAT *bn = VIEWcreate(b);
	BAT *bm = BATmirror(bn);
	BATstore *bs = (BATstore *) bn;

	if (bn == NULL || bm == NULL)
		return NULL;
	bn->T = &bs->T;

	if (bn->T != bm->H)
		*bn->T = *bm->H;
	bm->H = bn->T;
	bn->ttype = bm->htype = TYPE_void;
	bn->tvarsized = bm->hvarsized = 1;
	bn->thash = bm->hhash = NULL;
	BATseqbase(bm, oid_nil);

	return bn;
}

BAT *
VIEWhead_(BAT *b, int mode)
{
	BAT *bn = VIEWhead(b);

	if (bn)
		bn->batRestricted = mode;
	return bn;
}

@-
the @#VIEWcombine@ routine effortlessly produces a view with double
vision on the head column.
@c
BAT *
VIEWcombine(BAT *b)
{
	BAT *bn = VIEWcreate(b);
	BAT *bm = BATmirror(bn);

	if (bn == NULL || bm == NULL)
		return NULL;
	bm->H = bn->T = bn->H;
	bn->ttype = bm->htype = bn->htype;
	bn->tloc = bm->hloc = bn->hloc;
	bn->ttype = bm->htype = bn->htype;
	bn->tkey = bm->hkey = bn->hkey;
	bn->tseqbase = bm->hseqbase = bn->hseqbase;
	bn->tvarsized = bm->hvarsized = bn->hvarsized;
	bn->thash = bm->hhash = bn->hhash;

	return bn;
}

@-
The @#BATmaterialize@ routine produces in-place materialized version of
a void bat (which should have been a VIEW) (later we should add the code 
for VIEWs).
@c
BAT *
BATmaterialize(BAT *b, size_t size)
{
	BAT *bm, *ret = NULL;

	BATcheck(b, "BATmaterialize: bat required");
	{
		int ht = b->htype, tt = b->ttype, vid = 0;
		size_t cnt = MAX(BATcount(b), size);
		Heap buns = *b->batBuns, *hh = b->hheap, *th = b->theap;
		int bunwidth = b->dims.bunwidth, hlc = b->hloc, tlc = b->tloc;
		int newbw = 0;
		BUN p = BUNfirst(b), q = BUNlast(b);
		char *nme = BBP_physical(b->batCacheid);
		int committed = BBP_status(b->batCacheid) & BBPEXISTING;

		ALGODEBUG THRprintf(GDKout, "BATmaterialize(%d," SZFMT ");\n", (int) b->batCacheid, size);

		if (BAThdense(b) && ht == TYPE_void) {
			vid |= 1;
			ht = TYPE_oid;
		}
		if (BATtdense(b) && tt == TYPE_void) {
			vid |= 2;
			tt = TYPE_oid;
		}
		if (vid == 0) {	/* no voids */
			return b;
		}

		/* cleanup possible ACC's */
		HASHdestroy(b);

		/* guess new bunwidth before setting the new dimensions, +3 to allow chr-on-int alignment */
		b->batBuns->filename = NULL;
		if (HEAPalloc(b->batBuns, cnt + 3, 2 * MAX(sizeof(oid), b->dims.bunwidth)) < 0) {
			*b->batBuns = buns;
			return NULL;
		}
		if (hh) {
			b->hheap = (Heap*)GDKmalloc(sizeof(Heap));
			*b->hheap = *hh;
			b->hheap->filename = NULL;
			if (ATOMheap(ht, b->hheap, cnt) < 0) {
				HEAPfree(b->batBuns);
				*b->batBuns = buns;
				b->hheap = hh;
				return NULL;
			}
		}
		if (th) {
			b->theap = (Heap*)GDKmalloc(sizeof(Heap));
			*b->theap = *th;
			b->theap->filename = NULL;
			if (ATOMheap(tt, b->theap, cnt) < 0) {
				HEAPfree(b->batBuns);
				HEAPfree(b->hheap);
				GDKfree(b->hheap);
				*b->batBuns = buns;
				b->hheap = hh;
				b->theap = th;
				return NULL;
			}
		}

		/* point of no return */
		b->htype = ht;
		b->ttype = tt;
		BATsetdims(b);
		DELTAinit(b);
		newbw = BUNsize(b);
		b->batDirty = TRUE;
		b->batDirtydesc = TRUE;
		b->batDirtybuns = TRUE;

		bm = BATmirror(b);
		bm->dims.headtype = b->dims.tailtype;
		bm->dims.tailtype = b->dims.headtype;
		bm->dims.headloc = b->dims.tailloc;
		bm->dims.tailloc = b->dims.headloc;
		bm->dims.headkey = b->dims.tailkey;
		bm->dims.tailkey = b->dims.headkey;
		bm->dims.headvarsized = b->dims.tailvarsized;
		bm->dims.tailvarsized = b->dims.headvarsized;
		bm->dims.bunwidth = b->dims.bunwidth;
		bm->dims.bunshift = b->dims.bunshift;
		bm->dims.hseq = b->dims.tseq;
		bm->dims.tseq = b->dims.hseq;
		bm->hhash = b->thash;
		bm->thash = b->hhash;

		/* set the correct dense info */
		if (vid & 1) 	
			b->hdense = TRUE;
		if (vid & 2) 	
			b->tdense = TRUE;
		if (vid == 1) {
			oid h = b->hseqbase;
			BUN r = BUNlast(b);

			if (!b->tvarsized) {
				for (; p < q; p += bunwidth, h++, r += newbw)
					bunfastins_nocheck(b, r, (ptr) &h, p + tlc, newbw);
			} else if (tt == TYPE_void) {
				for (; p < q; p += bunwidth, h++, r += newbw)
					bunfastins_nocheck(b, r, (ptr) &h, NULL, newbw);
			} else {
				char *tbase = th->base;

				for (; p < q; p += bunwidth, h++, r += newbw)
					bunfastins_nocheck(b, r, (ptr) &h, tbase + (*(var_t *) (p + tlc)), newbw);
			}
		} else if (vid == 2) {
			oid t = b->tseqbase;
			BUN r = BUNlast(b);

			if (!b->hvarsized) {
				for (; p < q; p += bunwidth, t++, r += newbw)
					bunfastins_nocheck(b, r, p + hlc, (ptr) &t, newbw);
			} else if (ht == TYPE_void) {
				for (; p < q; p += bunwidth, t++, r += newbw)
					bunfastins_nocheck(b, r, NULL, (ptr) &t, newbw);
			} else {
				char *hbase = hh->base;

				for (; p < q; p += bunwidth, t++, r += newbw)
					bunfastins_nocheck(b, r, hbase + (*(var_t *) (p + hlc)), (ptr) &t, newbw);
			}
		} else { /* void, void case */
			oid h = b->hseqbase;
			oid t = b->tseqbase;
			int f = 0, c = BATcount(b);
			BUN r = BUNlast(b);

			for (; f < c; f++, h++, t++)
				bunfastins_nocheck(b, r, (ptr) &h, (ptr) &t, newbw);
		}
		ret = b;
	      bunins_failed:
		/* cleanup the old heaps */
		/* if X.priv exists and X not, move it to X (X must be the stable image) */
		HEAPfree(&buns);
		if (committed && buns.storage != STORE_MEM)
			GDKmove(BATDIR, nme, "buns.priv", BATDIR, nme, "buns"); 
		if (hh) {
			HEAPfree(hh);
			if (committed && hh->storage != STORE_MEM)
				GDKmove(BATDIR, nme, "hheap.priv", BATDIR, nme, "hheap"); 
			GDKfree(hh);
		}
		if (th) {
			HEAPfree(th);
			if (committed && th->storage != STORE_MEM)
				GDKmove(BATDIR, nme, "theap.priv", BATDIR, nme, "theap"); 
			GDKfree(th);
		}
	}
	return ret;
}

@-
The @#VIEWunlink@ routine cuts a reference to the parent. Part of the view
destroy sequence.
@c 
void
VIEWunlink(BAT *b)
{
	if (b) {
		BAT *p = BBP_cache(VIEWparent(b));
		BAT *m = BATmirror(b);

		if (p == NULL)
			return;

		/* unlink heaps shared with parent */
		if (b->hheap && (b->hheap == p->hheap || b->hheap == p->theap)){
			b->hheap = m->theap = NULL;
		}
		if (b->theap && (b->theap == p->hheap || b->theap == p->theap)){
			b->theap = m->hheap = NULL;
		}

		/* unlink properties shared with parent */
		if (b->H->props && (b->H->props == p->H->props || b->H->props == p->T->props)){
			b->H->props = m->T->props = NULL;
		}
		if (b->T->props && (b->T->props == p->H->props || b->T->props == p->T->props)){
			b->T->props = m->H->props = NULL;
		}

		/* unlink hash accelerators shared with parent */
		if (b->hhash && (b->hhash == p->hhash || b->hhash == p->thash)){
			b->hhash = m->thash = NULL;
		}
		if (b->thash && (b->thash == p->hhash || b->thash == p->thash)){
			b->thash = m->hhash = NULL;
		}
	}
}

@-
Materialize a view into a normal BAT. If it is a slice, we really
want to reduce storage of the new BAT.
@c
BAT *
VIEWreset(BAT *b)
{
	bat parent = VIEWparent(b);

	if (b && parent) {
		Heap buns, hh, th;
		BAT *n = ((b) = BBP_cache(ABS((b)->batCacheid)));
		BAT *m = BATmirror(n);
		BAT *v;
		BATstore *bs = (BATstore *) n;
		var_t cnt = BATcount(b);
		int ht = (n->htype == TYPE_void && n->ttype == TYPE_void) ? TYPE_oid : n->htype;
		str nme = BBP_physical(n->batCacheid);

		/* alloc heaps */
		memset(&buns, 0, sizeof(Heap));
		buns.filename = (str) GDKmalloc(strlen(nme) + 12);
		sprintf(buns.filename, "%s.buns", nme);
		if (HEAPalloc(&buns, cnt + 1, BUNsize(n)) < 0) {
			GDKfree(buns.filename);
			buns.filename = NULL;
			return NULL;
		}
		memset(&hh, 0, sizeof(Heap));
		if (n->hheap) {
			hh.filename = (str) GDKmalloc(strlen(nme) + 12);
			sprintf(hh.filename, "%s.hheap", nme);
			if (ATOMheap(ht, &hh, cnt) < 0) {
				HEAPfree(&buns);
				GDKfree(hh.filename);
				return NULL;
			}
		}
		memset(&th, 0, sizeof(Heap));
		if (n->theap) {
			th.filename = (str) GDKmalloc(strlen(nme) + 12);
			sprintf(th.filename, "%s.theap", nme);
			if (ATOMheap(n->ttype, &th, cnt) < 0) {
				HEAPfree(&buns);
				HEAPfree(&hh);
				GDKfree(th.filename);
				return NULL;
			}
		}
	
		v = VIEWcreate(b);

		/* cut the link to your parents */
		VIEWunlink(n);
		BBPunshare(parent);
		n->batParentid = 0;
		n->batRestricted = BAT_WRITE;

		/* copy the heap data into their normal position */
		bs->U = *n->U;
		bs->P = *n->P;
		bs->H = *n->H;
		bs->T = *n->T;

		/* make sure everything points there */
		m->U = n->U = &(bs->U);
		m->P = n->P = &(bs->P);
		m->T = n->H = &(bs->H);
		m->H = n->T = &(bs->T);
		n->batBuns = m->batBuns = &n->U->buns;

		n->GDKversion = m->GDKversion = GDKLIBRARY;

		/* copy the heaps */
		*n->batBuns = buns;

		/* unshare from parents heap */
		if (hh.base) { 
			n->hheap = (Heap*)GDKmalloc(sizeof(Heap));
			*n->hheap = hh;
		}
		if (th.base) { 
			n->theap = (Heap*)GDKmalloc(sizeof(Heap));
			*n->theap = th;
		}

		/* modify dimensions to let disappear projected out columns */
		m->ttype = n->htype = ht;

		BATsetdims(n);
		m->dims.tailtype = n->dims.headtype;
		m->dims.headtype = n->dims.tailtype;
		m->dims.tailloc = n->dims.headloc;
		m->dims.headloc = n->dims.tailloc;
		m->dims.tailvarsized = n->dims.headvarsized;
		m->dims.headvarsized = n->dims.tailvarsized;
		m->dims.bunshift = n->dims.bunshift;
		m->dims.bunwidth = n->dims.bunwidth;
		m->dims.hseq = n->dims.tseq;
		m->dims.tseq = n->dims.hseq;
		n->batSharecnt = 0;
		n->batCopiedtodisk = 0;
		n->batDirty = 1;

		/* make the BAT empty and insert all again */
		DELTAinit(n);

		/* insert all of v in b, and quit */
		BATins(b, v);
		BBPreclaim(v);
	}
	return b;
}

@-
The remainder are utilities to manipulate the BAT view and
not to forget some details in the process.
It expects a position range in the underlying BAT and
compensates for outliers.
@c
void
VIEWbounds(BAT *view, size_t l, size_t h)
{
	BAT *b;

	if (view == NULL) {
		GDKerror("VIEWbounds: bat required");
		return;
	}
	b = BATdescriptor(view->batParentid);
	if (l < BUNindex(b, BUNfirst(b)))
		l = BUNindex(b, BUNfirst(b));
	view->batBuns->base = BUNptr(b, l);
	view->batFirst = view->batDeleted = view->batInserted = view->batBuns->base;
	if (BUNlast(b) < BUNptr(b, h + 1)) 
		h = BUNindex(b, BUNlast(b))-1;
	view->batBuns->maxsize = view->batBuns->size = view->batBuns->free = BUNptr(b, h + 1) - view->batBuns->base;
	BATsetcount(view, h + 1 - l);

	view->hsorted = BAThordered(b);
	view->tsorted = BATtordered(b);

	BATkey(view, BAThkey(b));
	BATkey(BATmirror(view), BATtkey(b));
	if (BAThdense(b)) {
		BATseqbase(view, b->hseqbase + l);
	}
	if (BATtdense(b)) {
		BATseqbase(BATmirror(view), b->tseqbase + l);
	}
}

@-
Destroy a view.
@c
void
VIEWdestroy(BAT *v)
{
	BAT *b = ((v) = BBP_cache(ABS((v)->batCacheid)));
	BAT *m = BATmirror(b);

	if (b) {
		VIEWunlink(b);
		HASHdestroy(b);
	}

	/* free memory private to this view */
	if (m != NULL) {
		GDKfree(m);
		BBP_cache(-b->batCacheid) = NULL;
	}
}

@}
