@t MAL iterator code
@a M. Kersten
@v 0.0
@* Introduction

This module contains the framework for the construction of iterators.
Iterators enumerate elements in a collection defined by a few paramaters,
e.g. a lower/upper bound, or a bat. An iterator is initialized in the first
call by recognizing that the control variable lies outside the intended
collection.

Iterators appear as ordinary function calls in the MAL code and
always return a boolean, to indicate that an element is available for
consumption. Initialization of the iterator representation depends
on its kind.

The state of the iterator should be encoded in its arguments, which
may be modified as a side-effect of calling the iterator.
[we may need to include R/W information in the typing scheme]
@h
#ifndef _MAL_SQUEEZE_H
/*
 * The contents of this file are subject to the Monet Public
 * License Version 1.1 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy of
 * the License at http://www.monetsolutions.com/Download/Licensing/MonetPL-1.1.
html
 * 
 * Software distributed under the License is distributed on an "AS
 * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 * 
 * The Original Code is the Monet Database System.
 * 
 * The Initial Developer of the Original Code is CWI.
 * Portions created by CWI are Copyright (C) 1997-2001 CWI.  
 * All Rights Reserved.
 * 
 * Contributor(s): Martin Kersten <Martin.Kersten@cwi.nl>
 */

#define _MAL_ITERATOR_H

#include "mal_instruction.h"

#define DEBUG_MAL_ITERATOR 1
#endif /*  _MAL_ITERATOR_H*/
@+ Foreach iterators
The most common class of iterators encountered in a programming
environment is the for-loop. It contains a for-loop variable,
a starting point and a limit. Changing the for-loop variable
within the for-loop body is considered bad code and should be avoided
to simplify data-flow analysis.

We assume that the range boundaries comply with the underlying domain.

@= forloopRange
int @1Forloop(bit *res, @1 *i, @1 *first, @1 *last){
	@1 v = *i;
	if( v < *first || v >= *last) 
		*i = *first;
	else	*i = ++v;
	*res= *i < *last;
	return 0;
}
@-
The alternative iterator uses a step-value to walk through the sequence.

@= forloopStep
int @1ForloopStep(bit *res, @1 *i, @1 *first, @1 *last, @1 *step){
	@1 v = *i;
	if( v < *first || v >= *last) 
		*i = *first;
	else	*i = v + *step;
	*res= *i >= *first && *i < *last;
	return 0;
}
@c
#include "mal_iterator.h"

@:forloopRange(lng)@
@:forloopRange(chr)@
@:forloopRange(int)@
@:forloopRange(sht)@

@:forloopStep(lng)@
@:forloopStep(chr)@
@:forloopStep(int)@
@:forloopStep(sht)@
@:forloopStep(flt)@
@:forloopStep(dbl)@

@-
There are a few atomairy storage types we have to introduce here:
OID, str, void, bit, ptr
