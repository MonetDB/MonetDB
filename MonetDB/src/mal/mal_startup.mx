@t MAL startup
@a M. Kersten
@v 0.0
@+ Serving Clients

For the time being we distinguish two classes of clients.
The primary client is the 'Admin', which runs directly
against the server. 
It works as a console and will be the recipient of major error messages.

Secondary lients gain access to the Monet server through a internet connection.
Access through the internet requires a Monet client program at the
source, but ordinary telnet connections can be applied when the internet
port number of the database server is publicised.

Each user has a separate scope, but the secondary clients have shared
access to the definitions available to the administrator.
The global scope and private scopes are separated by an a priori known
scope name "MAL_scope". 

@h
/*
 * The contents of this file are subject to the Monet Public
 * License Version 1.1 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy of
 * the License at http://www.monetsolutions.com/Download/Licensing/MonetPL-1.1.
html
 * 
 * Software distributed under the License is distributed on an "AS
 * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 * 
 * The Original Code is the Monet Database System.
 * 
 * The Initial Developer of the Original Code is CWI.
 * Portions created by CWI are Copyright (C) 1997-2001 CWI.  
 * All Rights Reserved.
 * 
 * Contributor(s): Martin Kersten <Martin.Kersten@cwi.nl>
 */
#ifndef _MAL_STARTUP_H
#define _MAL_STARTUP_H

#include "mal_function.h"
#include "mal_client.h"
#include "mal_stack.h"

#define SRVINIT "startup.mal"
#define SRVORIGIN "share/Monet/startup.mal"

mal_export int malStartupAdmin(int listing);
mal_export void serveClient(void *dummy);
mal_export void resetClientPrg(Client cntxt);
mal_export void closeClientPrg(Client cntxt, int flag);
mal_export void chkClientPrg(Client cntxt);
mal_export void scheduleClient(str user, int socket);
#endif /*  _MAL_STARTUP_H*/
@-
The startup script for databases recides in the administrator's
directory of each database. Upon need, its location can be overruled 
using the configuration scripts.
If initialization of the server is successful, then the MAL_scope symbol
position is being returned as the namespace entry point for the client.
@c
#include "mal_startup.h"

void startupPrelude(Client c, str fnme1, str fnme2)
{	char buf[PATHLENGTH];
	FILE *fd;

	sprintf(buf,"%s/%s",GDKdirStr,fnme1);
	SLASH_2_DIR_SEP(buf);
	if( (fd= fopen(buf,"r")) == NULL){
		sprintf(buf,"%s/%s",GDKdistrStr,fnme2);
		SLASH_2_DIR_SEP(buf);
		if( (fd= fopen(buf,"r")) == NULL){
			GDKerror("FATAL:server file '%s' missing\n",fnme2);
			return;
		}
	} 
	fclose(fd);
	malImport(c,buf,0);
}

int malStartupAdmin(int listing){
	Client c;
	int oldtrace;
	c= initClient(GDKstrdup("Admin"),NULL,0);
        oldtrace = c->itrace;    /* no debugging in startup ! */
        c->itrace =0;
	c->nspace= newScope(NULL, GDKstrdup("Admin"));
	initLibraries();
	startupPrelude(c,SRVINIT,SRVORIGIN);
	mal_scope = c->nspace->outer;
        c->itrace = oldtrace;
	/* showScopeTrail(stdout,c->nspace);*/
	return 1;
}
@+ Client main routine
Every client has a 'main' function to collect the statements.
Once the END instruction has been found, it is added to the
symbol table and a fresh container is being constructed.
Note, this scheme makes testing for recursive function calls a
little more difficult. Therefore, type checking should be performed
afterwards.

In interactive mode,  the closing statement is never reached.
The 'main' procedure is typically cleaned between successive external
messages except for its variables, which are considerd global.
@c

void resetClientPrg(Client cntxt){
        InstrPtr p;
        MalBlkPtr mb;

        cntxt->curprg = newFunction(GDKstrdup("main"));
        mb = cntxt->curprg->def;
        p = getSignature(cntxt->curprg);
        p->modname= GDKstrdup(cntxt->nspace->name);
        setVarType(mb,findVariable(mb,"main"), TYPE_int);
}
void closeClientPrg(Client cntxt, int flag){
        InstrPtr p;
        MalBlkPtr mb;
	int i;

	mb = cntxt->curprg->def;
	i = mb->stop-1;
	/* ignore empty MAL function blocks */
	p = getInstrPtr(mb,0);
	if( !(i==0 && p->token == FUNCTIONsymbol)){
		insertSymbol(cntxt->nspace,cntxt->curprg);
	} else{
		/* garbage collect prg ? no just empty file*/
		return;
	}
	if( flag){
		p = getInstrPtr(mb,i);
		if( p->token != ENDDEFsymbol)
			pushEndInstruction(mb);
	}
	trimMalBlk(mb);
	chkClientPrg(cntxt);
	resetClientPrg(cntxt);
}
@-
After the parser finishes, we have to look for semantic errors,
such as flow of control problems and possible typeing conflicts.
The nesting of BARRIER and CATCH statements with their associated
flow of control primitives LEAVE and RETRY should form a valid
hierarchy. Failure to comply is considered a structural error
and leads to flagging the function as erroneous.

Also check general conformaty of the ML block structure.
It should start with a signature and finish with and ENDDEFsymbol
@c
void chkClientPrg(Client cntxt)
{
        InstrPtr p;
        MalBlkPtr mb;
	int i, signature= FALSE;

        mb = cntxt->curprg->def;
	for(i=0;i<mb->stop;i++) {
		p= getInstrPtr(mb,i);
		if(p== NULL) continue;
		typeChecker(cntxt->nspace,mb,p, TYPE_FIXED);
		switch(p->token){
		case FUNCTIONsymbol: case COMMANDsymbol:
		case PATTERNsymbol: case HANDLERsymbol:
			if( i) {
			str msg=instruction2str(mb,p);
			GDKerror("SYNTAX ERROR: signature misplaced\n!%s\n",msg);
			GDKfree(msg);
			} else signature = TRUE;
			break;
		case ENDsymbol:
			chkEnd(mb,p);
			break;
		case CATCHsymbol:
			chkCatch(mb,p);
			break;
		case LEAVEsymbol:
		case REDOsymbol:
			chkLabel(mb,p);
		}
		if( p->barrier == BARRIERsymbol)
			chkBarrier(mb,p);
	}
	if( signature == FALSE){
		str msg=instruction2str(mb,p);
		GDKerror("SYNTAX ERROR: signature missing\n!%s\n",msg);
		printFunction(stdout,mb);
		GDKfree(msg);
	}
}
@+ Client authorization
The default method to interact with the database server is to
connect using a port number. The first line received should contain
authorization information, such as user name and a possible session key.

No encryption scheme is performed yet.

An example initialization string would be "guest:23" which indicates access
of the client named 'guest' to a session previously started under identity 23.
@c
void scheduleClient(str user, int socket)
{
	str mode;
	int key=0;
	Client c;
	int i;
	MT_Id p;
	Thread t;

	mode = strchr(user,':');
	if(mode && *mode){
		*mode= 0;
		mode++;
		mode= strchr(mode,':');
		if( mode){
			key= atol(mode+1);
		}
	}
	mode = strchr(user,'\n');
	if( mode) *mode =0;
	c= initClient(GDKstrdup(user),NULL,socket);
	c->nspace= newScope(NULL,GDKstrdup(user));
	c->nspace->outer = mal_scope;
	c->sessionkey = key;
	resetClientPrg(c);
	/*showScopeTrail(stdout,c->nspace);*/

	if( (i= MT_create_thread(&p, serveClient, (void *)c)) < 0) {
		GDKerror("initClient: can not fork new client\n");
		return;
	}
}
@+ Client services
After the client initialization has been finished, we
can start the interaction protocol. This involves parsing the
input in the context of an already defined procedure and upon
success, its execution.

In essence, this calls for an incremental parsing operation, 
because we should wait until a complete basic block has been detected.
Test, first collect the instructions before we take them all.
@-
In interactive mode, we should remove the instructions before
accepting new ones. The function signature remains the same
and the symbol table should also not be affected.
Aside from removing instruction, we should also condense the
variable stack, i.e. removing at least the temporary variables,
but maybe everything beyond a previous defined pont.
[also clear the stack! ]
@c
void    resetMalBlk(MalBlkPtr mb, MalStkPtr glb){
        InstrPtr p;
        int i,j;

        for(i=1;i<mb->stop;i++){
                p= getInstrPtr(mb,i); 
                freeInstruction(p);
		mb->stmt[i] = NULL;
        }
	for(i=j=0; i< mb->vtop; ){
		if(getVarName(mb,i)[0]==TMPMARKER ) {
			freeVariable(mb,i);
			garbageElement(&glb->stk[i]);
			i++;
		} else {
			if(i!=j){
				copyVar(mb,j,i);
				glb->stk[j]= glb->stk[i];
			}
			i++; j++;
		}
		
	}
	mb->vtop = j;
	mb->stop =1;
	mb->errors = 0;
}
@c
void serveClient(void *dummy)
{	MalBlkPtr mb;
	MalStkPtr glb;
	Client c= (Client) dummy;

	if( !isAdministrator(c) ) initClientThread(c);
@-
A stack frame is initialized to keep track of global variables.
@c
	mb= c->curprg->def;
	newStack(glb,MAXGLOBALS);
	glb->stktop =mb->vtop;
	glb->blk = mb;

	processInput(c,glb);
        garbageCollector(mb,glb);

	if( c->mode > FINISHING){
		if( isAdministrator(c)){
			OIDflushdelta =0;
			TMcommit();
			closeClient(c);
		}
		closeClient(c);
	}
}
