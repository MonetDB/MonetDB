@t MAL main file
@a M. Kersten
@v 0.0
@+ MAL interpretation

Startup of the Monet engine consists of two steps. First, the
system kernel libraries are loaded.
The global symbol table is initialized with pre-compiled commands
and pattern definitions.
Second, for each service thread we execute a script with predefined
MAL procedures.

The information for the first phase consists of commands 
signatures bound to actual routine implementations.
The corresponding libraries may be statically linked or dynamically loaded.
Failure to find the startup-files terminates to session, because
there is no way to activate a linked procedure.

After the initialization phase, the system prohibits dynamic loading of
C- modules by casual users. For the time being we even forbid it,
it should be part of the system startup.
The rational behind this design decision is that the free load/drop
feature of Monet V4 was hardly used and severely complicates the code.
In particular, upon each access to the global symbol table we have to be
prepaired that concurrent threads my be actively changing its structure.
Especially, dropping modules may cause sever problems by not being
able to detect references kept around.
This danger required all accesses to global information to be packaged
in a critical section, which was known to be a performance hindrence.
@h
#ifndef _MAL_H
#define _MAL_H

#include "gdk.h"

#ifdef _MSC_VER
#ifndef LIBMONET
#define mal_export extern __declspec(dllimport)
#else
#define mal_export extern __declspec(dllexport)
#endif
#else
#define mal_export extern
#endif

mal_export int             mal_listing;
mal_export int             mal_xlisting;
mal_export int             mal_debug;
mal_export int             mal_trace;
mal_export MT_Lock	mal_contextLock;

/*#define MALprofiler 1		activate the profiler */
#undef MALprofiler

#define STRUCT_ALIGNED

#endif /*  _MAL_H*/
@c
#include "mal.h"
#include "mal_client.h"
#include "mal_linker.h"
#include "mal_startup.h"

int             mal_listing= 0;
int             mal_xlisting= 0;
int             mal_debug= 0;
int             mal_trace= 0;
MT_Lock		mal_contextLock=0;
@-
Initialization of the MAL context
The compiler directive STRUCT_ALIGNED tells that the
fields in the VALrecord all start at the same offset.
This knowledge avoids low-level type decodings, but should
be assured at least once.
@c

void tstAligned()
{
	int allAligned=0;
	ValRecord v;
	ptr val, base;
	base = (ptr) & v.val.ival; 
	val= (ptr) & v.val.ival; if(val != base){allAligned = -1; return;}
	val= (ptr) & v.val.bval; if(val != base){allAligned = -1; return;}
	val= (ptr) & v.val.cval[0]; if(val != base){allAligned = -1; return;}
	val= (ptr) & v.val.shval; if(val != base){allAligned = -1; return;}
	val= (ptr) & v.val.br.id; if(val != base){allAligned = -1; return;}
	val= (ptr) & v.val.ival; if(val != base){allAligned = -1; return;}
	val= (ptr) & v.val.oval; if(val != base){allAligned = -1; return;}
	val= (ptr) & v.val.pval; if(val != base){allAligned = -1; return;}
	val= (ptr) & v.val.fval; if(val != base){allAligned = -1; return;}
	val= (ptr) & v.val.dval; if(val != base){allAligned = -1; return;}
	val= (ptr) & v.val.lval; if(val != base){allAligned = -1; return;}
	val= (ptr) & v.val.sval; if(val != base){allAligned = -1; return;}
	allAligned = 1;
#ifdef STRUCT_ALIGNED
	if(allAligned<0)
		GDKfatal("Recompile with STRUCT_ALIGNED flag disabled\n");
#else
	if(allAligned>0)
		GDKfatal("Recompile with STRUCT_ALIGNED flag enabled\n");
#endif
}
int mal_init(){
	mal_contextLock= MT_create_lock();
	tstAligned();
	initScope();
        if( malStartupAdmin(mal_listing) == 0) return -1;
	initLibraries(FALSE);
	return 0;
}

int mal_exit(Client cntxt){
#ifdef MALprofiler
	profileReport( cntxt->nspace,1,stdout);
#endif
	freeScopeList(mal_scope);
	GDKexit();
}
