# Mil compiler Version 1.0)
# Copyright (c) 1993-2002, CWI. All rights reserved.

# Predefined code segment
#The compiler can not guarantee an accurate compilation,
#because MIL unlike MAL is a dynamically typed language.
#A few guidelines to maximize usefullness.
#- make the type of variables explicit, in particular 'nil'
#- upon advice of M2m to remap identifiers, change it in your program directly
#- positional arguments, ie $1,$2,..., can not be compiled in isolation
#
#
#Perhaps someone will develop a complete MIL interpreter
#on top of the MAL kernel in the future
#
##line 224 "/ufs/mk/monet_5-0/src/modules/atoms/decimal.mx"
#module(xtables,alarm,decimal,mmath);
#
	aa_a := decimal_minrepeat(20);
#decimal_minrepeat(20);
#
#
#
##line 230 "/ufs/mk/monet_5-0/src/modules/atoms/decimal.mx"
	dec_nil:= decimal("nil");
#var   dec_nil := decimal("nil");
	dec_zero:= decimal("-0000000000000000000000000000000000E-8989");
#var  dec_zero := decimal("-0000000000000000000000000000000000E-8989");
	dec_tiny:= decimal("+0.000000000000000000000000001122");
#var  dec_tiny := decimal("+0.000000000000000000000000001122");
	nec_tiny:= decimal("-11220000000000E-40");
#var  nec_tiny := decimal("-11220000000000E-40");
	dec_small:= decimal(2244);
#var dec_small := decimal(2244);
	nec_small:= decimal("-22440000000000E-10");
#var nec_small := decimal("-22440000000000E-10");
	dec_num:= decimal("+4488E15");
#var   dec_num := decimal("+4488E15");
	nec_num:= decimal("-44880000000000E5");
#var   nec_num := decimal("-44880000000000E5"); 
	dec_big:= decimal("+1122E40");
#var   dec_big := decimal("+1122E40");
	nec_big:= decimal("-11220000000000E30");
#var   nec_big := decimal("-11220000000000E30"); 
	dec_huge:= decimal("+22440000000000E9000");
#var  dec_huge := decimal("+22440000000000E9000");
	nec_huge:= decimal("-2244E9010");
#var  nec_huge := decimal("-2244E9010");
#
	dec_bat:= new(str,decimal,10);
#var dec_bat := new(str,decimal,10);
	ba_a := insert(dec_bat,"dec_nil",dec_nil);
#dec_bat.insert("dec_nil", dec_nil);
	ca_a := insert(dec_bat,"dec_zero",dec_zero);
#dec_bat.insert("dec_zero", dec_zero);
	da_a := insert(dec_bat,"dec_tiny",dec_tiny);
#dec_bat.insert("dec_tiny", dec_tiny);
	ea_a := insert(dec_bat,"nec_tiny",nec_tiny);
#dec_bat.insert("nec_tiny", nec_tiny);
	fa_a := insert(dec_bat,"dec_small",dec_small);
#dec_bat.insert("dec_small", dec_small);
	ga_a := insert(dec_bat,"nec_small",nec_small);
#dec_bat.insert("nec_small", nec_small);
	ha_a := insert(dec_bat,"dec_num",dec_num);
#dec_bat.insert("dec_num", dec_num);
	ia_a := insert(dec_bat,"nec_num",nec_num);
#dec_bat.insert("nec_num", nec_num);
	ja_a := insert(dec_bat,"dec_big",dec_big);
#dec_bat.insert("dec_big", dec_big);
	ka_a := insert(dec_bat,"nec_big",nec_big);
#dec_bat.insert("nec_big", nec_big);
	la_a := insert(dec_bat,"dec_huge",dec_huge);
#dec_bat.insert("dec_huge", dec_huge);
	ma_a := insert(dec_bat,"nec_huge",nec_huge);
#dec_bat.insert("nec_huge", nec_huge);
#
## test conversion to simple scalars
	dec_prc:= multiplex.script("getprecision",dec_bat);
#var dec_prc := [getprecision](dec_bat);
	dec_scl:= multiplex.script("getscale",dec_bat);
#var dec_scl := [getscale](dec_bat);
	dec_flt:= multiplex.script("flt",dec_bat);
#var dec_flt := [flt](dec_bat);
	dec_int:= multiplex.script("int",dec_bat);
#var dec_int := [int](dec_bat);
	dec_lng:= multiplex.script("lng",dec_bat);
#var dec_lng := [lng](dec_bat);
	dec_dbl:= multiplex.script("dbl",dec_bat);
#var dec_dbl := [dbl](dec_bat);
#
	na_a := bbp.setColumn(dec_bat,"value");
#print(dec_bat.col_name("value"), 
	oa_a := bbp.setColumn(dec_prc,"precision");
#      dec_prc.col_name("precision"), 
	pa_a := bbp.setColumn(dec_scl,"scale");
	qa_a := print(na_a,oa_a,pa_a);
#      dec_scl.col_name("scale"));
#
	ra_a := bbp.setColumn(dec_bat,"value");
#print(dec_bat.col_name("value"), 
	sa_a := bbp.setColumn(dec_int,"int");
#      dec_int.col_name("int"), 
	ta_a := bbp.setColumn(dec_lng,"lng");
	ua_a := print(ra_a,sa_a,ta_a);
#      dec_lng.col_name("lng"));
#
	va_a := bbp.setColumn(dec_bat,"value");
#print(dec_bat.col_name("value"), 
	wa_a := bbp.setColumn(dec_flt,"flt");
#      dec_flt.col_name("flt"), 
	xa_a := bbp.setColumn(dec_dbl,"dbl");
	ya_a := print(va_a,wa_a,xa_a);
#      dec_dbl.col_name("dbl"));
#
## test reverse conversion
	ab_a := bbp.setColumn(dec_bat,"decimal");
#print(dec_bat.col_name("decimal"), 
	bb_a := multiplex.script("decimal",dec_int);
	cb_a := bbp.setColumn(bb_a,"from_int");
#      [decimal](dec_int).col_name("from_int"), 
	db_a := multiplex.script("decimal",dec_lng);
	eb_a := bbp.setColumn(db_a,"from_lng");
	fb_a := print(ab_a,cb_a,eb_a);
#      [decimal](dec_lng).col_name("from_lng"));
#
	gb_a := bbp.setColumn(dec_bat,"decimal");
#print(dec_bat.col_name("decimal"), 
	hb_a := multiplex.script("decimal",dec_flt);
	ib_a := bbp.setColumn(hb_a,"from_flt");
	jb_a := print(gb_a,ib_a);
#      [decimal](dec_flt).col_name("from_flt"));
#
	kb_a := bbp.setColumn(dec_bat,"decimal");
#print(dec_bat.col_name("decimal"), 
	lb_a := multiplex.script("decimal",dec_dbl);
	mb_a := bbp.setColumn(lb_a,"from_dbl");
	nb_a := print(kb_a,mb_a);
#      [decimal](dec_dbl).col_name("from_dbl"));
#
## test set_scale and set_precision
	ob_a := bbp.setColumn(dec_bat,"decimal");
#print(dec_bat.col_name("decimal"), 
	pb_a := multiplex.script("setscale",dec_bat,0);
	qb_a := bbp.setColumn(pb_a,"setscale(0)");
#      [setscale](dec_bat,0).col_name("setscale(0)"),
	rb_a := multiplex.script("setscale",dec_bat,10);
	sb_a := bbp.setColumn(rb_a,"setscale(10)");
#      [setscale](dec_bat,10).col_name("setscale(10)"),
	tb_a := -(dec_scl,5);
	ub_a := multiplex.script("setscale",dec_bat,tb_a);
	vb_a := bbp.setColumn(ub_a,"setscale(-5)");
	wb_a := print(ob_a,qb_a,sb_a,vb_a);
#      [setscale](dec_bat, ([-](dec_scl,5))).col_name("setscale(-5)"));
#
	xb_a := bbp.setColumn(dec_bat,"decimal");
#print(dec_bat.col_name("decimal"), 
	yb_a := multiplex.script("setprecision",dec_bat,0);
	ac_a := bbp.setColumn(yb_a,"setprecision(0)");
#      [setprecision](dec_bat,0).col_name("setprecision(0)"),
	bc_a := multiplex.script("setprecision",dec_bat,10);
	cc_a := bbp.setColumn(bc_a,"setprecision(10)");
#      [setprecision](dec_bat,10).col_name("setprecision(10)"),
	dc_a := -(dec_prc,5);
	ec_a := multiplex.script("setprecision",dec_bat,dc_a);
	fc_a := bbp.setColumn(ec_a,"setprecision(-5)");
	gc_a := print(xb_a,ac_a,cc_a,fc_a);
#      [setprecision](dec_bat, [-](dec_prc,5)).col_name("setprecision(-5)"));
#
	hc_a := bbp.setColumn(dec_bat,"decimal");
#print(dec_bat.col_name("decimal"), 
	ic_a := multiplex.script("addscale",dec_bat,-5);
	jc_a := bbp.setColumn(ic_a,"addscale(-5)");
#      [addscale](dec_bat,-5).col_name("addscale(-5)"),
	kc_a := multiplex.script("addscale",dec_bat,5);
	lc_a := bbp.setColumn(kc_a,"addscale(5)");
	mc_a := print(hc_a,jc_a,lc_a);
#      [addscale](dec_bat,5).col_name("addscale(5)"));
#
## test binary operators
	nc_a := reverse(dec_bat);
	oc_a := project(nc_a,0@0);
	dec_zero_bat:= reverse(oc_a);
#var dec_zero := project(dec_bat.reverse,0@0).reverse;
	pc_a := reverse(dec_zero_bat);
	dec_cart:= join(pc_a,dec_zero_bat);
#var dec_cart := join(dec_zero.reverse,dec_zero);
	qc_a := reverse(dec_cart);
	rc_a := mark(qc_a,0@0);
	dec_bat1:= reverse(rc_a);
#var dec_bat1 := dec_cart.reverse.mark(0@0).reverse;
	sc_a := mark(dec_cart,0@0);
	dec_bat2:= reverse(sc_a);
#var dec_bat2 := dec_cart.mark(0@0).reverse;
	tc_a := multiplex.script("getprecision",dec_bat1);
	dec_raise:= -(tc_a,10);
#var dec_raise := [-]([getprecision](dec_bat1),10);
	uc_a := multiplex.script("getprecision",dec_bat1);
	dec_prec:= -(uc_a,1);
#var dec_prec := [-]([getprecision](dec_bat1),1);
#
	vc_a := bbp.setColumn(dec_bat1,"decimal1");
#print(dec_bat1.col_name("decimal1"),
	wc_a := bbp.setColumn(dec_raise,"raise");
#      dec_raise.col_name("raise"),
	xc_a := multiplex.script("pow",dec_bat1,dec_raise);
	yc_a := bbp.setColumn(xc_a,"pow");
	ad_a := print(vc_a,wc_a,yc_a);
#      [pow](dec_bat1,dec_raise).col_name("pow"));
#
	bd_a := bbp.setColumn(dec_bat1,"decimal1");
#print(dec_bat1.col_name("decimal1"),
	cd_a := bbp.setColumn(dec_raise,"raise");
#      dec_raise.col_name("raise"),
	dd_a := bbp.setColumn(dec_prec,"precision");
#      dec_prec.col_name("precision"),
	ed_a := multiplex.script("pow",dec_bat1,dec_raise,dec_prec);
	fd_a := bbp.setColumn(ed_a,"pow");
	gd_a := print(bd_a,cd_a,dd_a,fd_a);
#      [pow](dec_bat1,dec_raise,dec_prec).col_name("pow"));
#
	hd_a := bbp.setColumn(dec_bat1,"decimal1");
#print(dec_bat1.col_name("decimal1"),
	id_a := bbp.setColumn(dec_bat2,"decimal2");
#      dec_bat2.col_name("decimal2"),
	jd_a := multiplex.tactics("*",dec_bat1,dec_bat2);
	kd_a := bbp.setColumn(jd_a,"*");
	ld_a := print(hd_a,id_a,kd_a);
#      [*](dec_bat1,dec_bat2).col_name("*"));
#
	md_a := bbp.setColumn(dec_bat1,"decimal1");
#print(dec_bat1.col_name("decimal1"),
	nd_a := bbp.setColumn(dec_bat2,"decimal2");
#      dec_bat2.col_name("decimal2"),
	od_a := multiplex.tactics("/",dec_bat1,dec_bat2);
	pd_a := bbp.setColumn(od_a,"/");
	qd_a := print(md_a,nd_a,pd_a);
#      [/](dec_bat1,dec_bat2).col_name("/"));
#
	rd_a := bbp.setColumn(dec_bat1,"decimal1");
#print(dec_bat1.col_name("decimal1"),
	sd_a := bbp.setColumn(dec_bat2,"decimal2");
#      dec_bat2.col_name("decimal2"),
	td_a := multiplex.script("divide",dec_bat1,dec_bat2,10);
	ud_a := bbp.setColumn(td_a,"divide");
	vd_a := print(rd_a,sd_a,ud_a);
#      [divide](dec_bat1,dec_bat2,10).col_name("divide"));
#
	wd_a := bbp.setColumn(dec_bat1,"decimal1");
#print(dec_bat1.col_name("decimal1"),
	xd_a := bbp.setColumn(dec_bat2,"decimal2");
#      dec_bat2.col_name("decimal2"),
	yd_a := bbp.setColumn(dec_prec,"precision");
#      dec_prec.col_name("precision"),
	ae_a := multiplex.script("divide",dec_bat1,dec_bat2,dec_prec);
	be_a := bbp.setColumn(ae_a,"divide");
	ce_a := print(wd_a,xd_a,yd_a,be_a);
#      [divide](dec_bat1,dec_bat2,dec_prec).col_name("divide"));
#
	de_a := bbp.setColumn(dec_bat1,"decimal1");
#print(dec_bat1.col_name("decimal1"),
	ee_a := bbp.setColumn(dec_bat2,"decimal2");
#      dec_bat2.col_name("decimal2"),
	fe_a := +(dec_bat1,dec_bat2);
	ge_a := bbp.setColumn(fe_a,"+");
	he_a := print(de_a,ee_a,ge_a);
#      [+](dec_bat1,dec_bat2).col_name("+"));
#
	ie_a := bbp.setColumn(dec_bat1,"decimal1");
#print(dec_bat1.col_name("decimal1"),
	je_a := bbp.setColumn(dec_bat2,"decimal2");
#      dec_bat2.col_name("decimal2"),
	ke_a := -(dec_bat1,dec_bat2);
	le_a := bbp.setColumn(ke_a,"-");
	me_a := print(ie_a,je_a,le_a);
#      [-](dec_bat1,dec_bat2).col_name("-"));
#
	ne_a := bbp.setColumn(dec_bat1,"decimal1");
#print(dec_bat1.col_name("decimal1"),
	oe_a := bbp.setColumn(dec_bat2,"decimal2");
#      dec_bat2.col_name("decimal2"),
	pe_a := multiplex.script("=",dec_bat1,dec_bat2);
	qe_a := bbp.setColumn(pe_a,"=");
	re_a := print(ne_a,oe_a,qe_a);
#      [=](dec_bat1,dec_bat2).col_name("="));
#
	se_a := bbp.setColumn(dec_bat1,"decimal1");
#print(dec_bat1.col_name("decimal1"),
	te_a := bbp.setColumn(dec_bat2,"decimal2");
#      dec_bat2.col_name("decimal2"),
	ue_a := multiplex.script("!=",dec_bat1,dec_bat2);
	ve_a := bbp.setColumn(ue_a,"!=");
	we_a := print(se_a,te_a,ve_a);
#      [!=](dec_bat1,dec_bat2).col_name("!="));
#
	xe_a := bbp.setColumn(dec_bat1,"decimal1");
#print(dec_bat1.col_name("decimal1"),
	ye_a := bbp.setColumn(dec_bat2,"decimal2");
#      dec_bat2.col_name("decimal2"),
	af_a := multiplex.script("<",dec_bat1,dec_bat2);
	bf_a := bbp.setColumn(af_a,"<");
	cf_a := print(xe_a,ye_a,bf_a);
#      [<](dec_bat1,dec_bat2).col_name("<"));
#
	df_a := bbp.setColumn(dec_bat1,"decimal1");
#print(dec_bat1.col_name("decimal1"),
	ef_a := bbp.setColumn(dec_bat2,"decimal2");
#      dec_bat2.col_name("decimal2"),
	ff_a := multiplex.script("<=",dec_bat1,dec_bat2);
	gf_a := bbp.setColumn(ff_a,"<=");
	hf_a := print(df_a,ef_a,gf_a);
#      [<=](dec_bat1,dec_bat2).col_name("<="));
#
	if_a := bbp.setColumn(dec_bat1,"decimal1");
#print(dec_bat1.col_name("decimal1"),
	jf_a := bbp.setColumn(dec_bat2,"decimal2");
#      dec_bat2.col_name("decimal2"),
	kf_a := multiplex.script(">",dec_bat1,dec_bat2);
	lf_a := bbp.setColumn(kf_a,">");
	mf_a := print(if_a,jf_a,lf_a);
#      [>](dec_bat1,dec_bat2).col_name(">"));
#
	nf_a := bbp.setColumn(dec_bat1,"decimal1");
#print(dec_bat1.col_name("decimal1"),
	of_a := bbp.setColumn(dec_bat2,"decimal2");
#      dec_bat2.col_name("decimal2"),
	pf_a := multiplex.script(">=",dec_bat1,dec_bat2);
	qf_a := bbp.setColumn(pf_a,">=");
	rf_a := print(nf_a,of_a,qf_a);
#      [>=](dec_bat1,dec_bat2).col_name(">="));
#
## test unary operators
	dec_abs:= multiplex.script("abs",dec_bat);
#var dec_abs := [abs](dec_bat);
	dec_neg:= multiplex.script("-",dec_bat);
#var dec_neg := [-](dec_bat);
#
	sf_a := bbp.setColumn(dec_bat,"decimal");
#print(dec_bat.col_name("decimal"),
	tf_a := multiplex.script("isnil",dec_bat);
	uf_a := bbp.setColumn(tf_a,"isnil");
#      [isnil](dec_bat).col_name("isnil"),
	vf_a := bbp.setColumn(dec_abs,"[abs]");
#      dec_abs.col_name("[abs]"),
	wf_a := bbp.setColumn(dec_neg,"[-]");
	xf_a := print(sf_a,uf_a,vf_a,wf_a);
#      dec_neg.col_name("[-]"));
#
## test sorting
	yf_a := reverse(dec_bat);
	ag_a := sort(yf_a);
	bg_a := reverse(ag_a);
	cg_a := bbp.setColumn(bg_a,"sorted dec");
	dg_a := print(cg_a);
#dec_bat.reverse.sort.reverse.col_name("sorted dec").print;
	eg_a := reverse(dec_abs);
	fg_a := sort(eg_a);
	gg_a := reverse(fg_a);
	hg_a := bbp.setColumn(gg_a,"sorted abs(dec)");
	ig_a := print(hg_a);
#dec_abs.reverse.sort.reverse.col_name("sorted abs(dec)").print;
#
## test hash-join
	jg_a := reverse(dec_abs);
	kg_a := join(dec_abs,jg_a);
	lg_a := print(kg_a);
#dec_abs.join(dec_abs.reverse).print;
#
#
#
#
##line 389 "/ufs/mk/monet_5-0/src/modules/atoms/decimal.mx"
function pow(base:int, raise:int):int;
#proc pow(int base, int raise) : int {
	#printf("pow (%d,",base);
	#printf("%d)= ",raise);
	mg_a := dbl(base);
	ng_a := dbl(raise);
	og_a := pow(mg_a,ng_a);
	pg_a := int(og_a);
	#printf("%d\n",pg_a);
	return pg_a;
#    return int(pow(dbl(base),dbl(raise)));
end function;
#}
function int(i:int):int;
	return i;
end function;
#proc int(int i) : int return i;
#
function arith_perftest(b:bat[any::1,any::2], div:any::2, s:str#proc arith_perftest(bat[any::1,any::2] b, any::2 div, str s) {
):void;
	t:= alarm.time();
	reduce:= multiplex.tactics("/",b,div);
#  var t := time, reduce := [/](b,div); 
	qg_a := printf("[/](%s)",s);
#        printf("[/](%s)",s);
	x:= alarm.time();
	rg_a := -(x,t);
	sg_a := printf(" = %dms\n",rg_a);
#        printf(" = %dms\n",time-t);
#
	t := alarm.time();
#  t := time; 
	tg_a := printf("join(%s",s);
#        printf("join(%s",s);
	ug_a := reverse(b);
	vg_a := join(b,ug_a);
	wg_a := count(vg_a);
	xg_a := printf("=%d) = ",wg_a);
#        printf("=%d) = ",join(b,b.reverse).count);
	x:= alarm.time();
	yg_a := -(x,t);
	ah_a := printf("%d ms\n",yg_a);
#        printf("%d ms\n",time - t);
#print(vg_a);
	t := alarm.time();
#  t := time; 
	bh_a := printf("group(%s",s);
#        printf("group(%s",s);
#print("div"); print(div);
#print("reduce");print(reduce);
	(histo,ch_a) := group(reduce);
#print("histo");print(histo); #print("grouping"); print(ch_a);
	dh_a := tunique(ch_a);
	eh_a := count(dh_a);
	fh_a := printf("=%d",eh_a);
#        printf("=%d",CTgroup(reduce).tunique.count);
	xx:= alarm.time();
	gh_a := -(xx,t);
	hh_a := printf(") = %d ms\n",gh_a);
#print(dh_a);
#        printf(") = %d ms\n",time-t);
#
	t := alarm.time();
#  t := time; 
	ih_a := printf("[*](%s=",s);
#	printf("[*](%s=",s);
	jh_a := multiplex.tactics("*",b,div);
	kh_a := count(jh_a);
	lh_a := printf("=%d) = ",kh_a);
#        printf("=%d) = ",[*](b,div).count);
	x:= alarm.time();
	mh_a := -(x,t);
	nh_a := printf("%d ms\n",mh_a);
#print(jh_a);
#        printf("%d ms\n",time-t);
#
	t := alarm.time();
#  t := time; 
	oh_a := printf("[-](%s",s);
#	printf("[-](%s",s);
	ph_a := multiplex.tactics("-",b,b);
	qh_a := count(ph_a);
	rh_a := printf("=%d)",qh_a);
#        printf("=%d)",[-](b,b).count);
	x:= alarm.time();
	sh_a := -(x,t);
	th_a := printf(" = %d ms\n",sh_a);
#        printf(" = %d ms\n",time-t);
#print(ph_a);
	t := alarm.time();
#  t := time; 
	uh_a := printf("[+](%s",s);
#        printf("[+](%s",s);
	vh_a := multiplex.tactics("+",b,b);
	wh_a := count(vh_a);
	xh_a := printf("=%d) = ",wh_a);
#        printf("=%d) = ", [+](b,b).count);
	x:= alarm.time();
	yh_a := -(x,t);
	ai_a := printf(" %d ms\n",yh_a);
#        printf(" %d ms\n",time-t);
	bi_a := count(b);
barrier	ci_a:= <(bi_a,1000000);
#  if (b.count < 1000000) {
	t := alarm.time();
#     t := time; 
	di_a := printf("[pow](%s",s);
#        printf("[pow](%s",s);
	ei_a := multiplex.tactics("int",reduce);
	fi_a := multiplex.tactics("pow",b,ei_a);
	gi_a := count(fi_a);
	hi_a := printf("=%d)",gi_a);
#        printf("=%d)",[pow](b,[int](reduce)).count);
#print(ei_a); print(fi_a);
	x:= alarm.time();
	ii_a := -(x,t);
	ji_a := printf(" = %d ms\n",ii_a);
#        printf(" = %d ms\n",time-t);
	t := alarm.time();
	ki_a := reverse(b);
	li_a := sort(ki_a);
#     t := time; b.reverse.sort; 
	mi_a := printf("sort(%s) = ",s);
#print(li_a);
#	printf("sort(%s) = ",s);
	x:= alarm.time();
	ni_a := -(x,t);
	oi_a := printf(" %d ms\n",ni_a);
#        printf(" %d ms\n",time-t);
#
#  }
end	ci_a;
end function;
#}
#
function arith_perftest(b:bat[any::1,decimal], div:decimal, s:str#proc arith_perftest(bat[any::1,decimal] b, decimal div, str s) {
):void;
print("DECIMAL variant");
	t:= alarm.time();
	reduce:= decimal.bulkdivide(b,div);
#  var t := time, reduce := [/](b,div); 
	qg_a := printf("[/](%s)",s);
#        printf("[/](%s)",s);
	x:= alarm.time();
	rg_a := -(x,t);
	sg_a := printf(" = %dms\n",rg_a);
#        printf(" = %dms\n",time-t);
#
	t := alarm.time();
#  t := time; 
	tg_a := printf("join(%s",s);
#        printf("join(%s",s);
	ug_a := reverse(b);
	vg_a := join(b,ug_a);
	wg_a := count(vg_a);
	xg_a := printf("=%d) = ",wg_a);
#        printf("=%d) = ",join(b,b.reverse).count);
	x:= alarm.time();
	yg_a := -(x,t);
	ah_a := printf("%d ms\n",yg_a);
#        printf("%d ms\n",time - t);
#print(vg_a);
	t := alarm.time();
#  t := time; 
	bh_a := printf("group(%s",s);
#        printf("group(%s",s);
#print("div"); print(div);
#print("reduce");print(reduce);
	(histo,ch_a) := group(reduce);
#print("histo");print(histo); #print("grouping"); print(ch_a);
	dh_a := tunique(ch_a);
	eh_a := count(dh_a);
	fh_a := printf("=%d",eh_a);
#        printf("=%d",CTgroup(reduce).tunique.count);
	xx:= alarm.time();
	gh_a := -(xx,t);
	hh_a := printf(") = %d ms\n",gh_a);
#print(dh_a);
#        printf(") = %d ms\n",time-t);
#
	t := alarm.time();
#  t := time; 
	ih_a := printf("[*](%s=",s);
#	printf("[*](%s=",s);
	jh_a := multiplex.tactics("*",b,div);
	kh_a := count(jh_a);
	lh_a := printf("=%d) = ",kh_a);
#        printf("=%d) = ",[*](b,div).count);
	x:= alarm.time();
	mh_a := -(x,t);
	nh_a := printf("%d ms\n",mh_a);
#print(jh_a);
#        printf("%d ms\n",time-t);
#
	t := alarm.time();
#  t := time; 
	oh_a := printf("[-](%s",s);
#	printf("[-](%s",s);
	ph_a := multiplex.tactics("-",b,b);
	qh_a := count(ph_a);
	rh_a := printf("=%d)",qh_a);
#        printf("=%d)",[-](b,b).count);
	x:= alarm.time();
	sh_a := -(x,t);
	th_a := printf(" = %d ms\n",sh_a);
#        printf(" = %d ms\n",time-t);
#print(ph_a);
	t := alarm.time();
#  t := time; 
	uh_a := printf("[+](%s",s);
#        printf("[+](%s",s);
	vh_a := multiplex.tactics("+",b,b);
	wh_a := count(vh_a);
	xh_a := printf("=%d) = ",wh_a);
#        printf("=%d) = ", [+](b,b).count);
	x:= alarm.time();
	yh_a := -(x,t);
	ai_a := printf(" %d ms\n",yh_a);
#        printf(" %d ms\n",time-t);
	bi_a := count(b);
barrier	ci_a:= <(bi_a,1000000);
#  if (b.count < 1000000) {
	t := alarm.time();
#     t := time; 
	di_a := printf("[pow](%s",s);
#        printf("[pow](%s",s);
	ei_a := multiplex.tactics("int",reduce);
	fi_a := multiplex.tactics("pow",b,ei_a);
	gi_a := count(fi_a);
	hi_a := printf("=%d)",gi_a);
#        printf("=%d)",[pow](b,[int](reduce)).count);
#print(ei_a); print(fi_a);
	x:= alarm.time();
	ii_a := -(x,t);
	ji_a := printf(" = %d ms\n",ii_a);
#        printf(" = %d ms\n",time-t);
	t := alarm.time();
	ki_a := reverse(b);
	li_a := sort(ki_a);
#     t := time; b.reverse.sort; 
	mi_a := printf("sort(%s) = ",s);
#print(li_a);
#	printf("sort(%s) = ",s);
	x:= alarm.time();
	ni_a := -(x,t);
	oi_a := printf(" %d ms\n",ni_a);
#        printf(" %d ms\n",time-t);
#
#  }
end	ci_a;
end function;
#}
#
	i:= 10000;
#var i := 10000;
	int_10K:= new(void,int,10000);
#var int_10K  := new(void,int,10000);
barrier	pi_a:= true;
	i:= i-1;
	ri_a := i;
	si_a := >=(ri_a,0);
barrier	qi_a:= si_a;
#while((i :-= 1) >= 0) {
	zz:= nil:void;
	ti_a := insert(int_10K,zz,i);
#        int_10K.insert(nil,i);
redo	pi_a;
end	qi_a;
end	pi_a;
#}
	ui_a := bat.setSequenceBase(int_10K,0@0);
#int_10K.seqbase(0@0);
#
	vi_a := printf("#~BeginVariableOutput~#\n");
	wi_a := arith_perftest(int_10K,101,"int_10K");
	xi_a := printf("#~EndVariableOutput~#\n");
#printf("#~BeginVariableOutput~#\n"); arith_perftest(int_10K, 101, "int_10K"); printf("#~EndVariableOutput~#\n");
#
	int_100K:= new(void,int,100000);
#var int_100K := new(void,int,100000);
barrier	dj_a:= true;
	i:= i+1;
	fj_a := i;
	gj_a := <(fj_a,10);
barrier	ej_a:= gj_a;
#while((i :+= 1) < 10) {
	hj_a := -(9,i);
	base:= *(hj_a,10000);
#        var base := (9 - i) * 10000;
	ij_a := +(int_10K,base);
	jj_a := insert(int_100K,ij_a);
#        int_100K.insert([+](int_10K,base));
redo	dj_a;
end	ej_a;
end	dj_a;
#}
	kj_a := bat.setSequenceBase(int_100K,0@0);
#int_100K.seqbase(0@0);
#
	lj_a := printf("#~BeginVariableOutput~#\n");
	mj_a := arith_perftest(int_100K,1001,"int_100K");
	nj_a := printf("#~EndVariableOutput~#\n");
#printf("#~BeginVariableOutput~#\n"); arith_perftest(int_100K, 1001, "int_100K"); printf("#~EndVariableOutput~#\n");

	dec_10K:= multiplex.script("decimal",int_10K);
#var dec_10K := [decimal](int_10K);
	yi_a := printf("#~BeginVariableOutput~#\n");
	aj_a := decimal("101");
	bj_a := arith_perftest(dec_10K,aj_a,"dec_10K");
	cj_a := printf("#~EndVariableOutput~#\n");
#printf("#~BeginVariableOutput~#\n"); arith_perftest(dec_10K, decimal("101"), "dec_10K"); printf("#~EndVariableOutput~#\n");
#
#
	dec_100K:= multiplex.script("decimal",int_100K);
#var dec_100K := [decimal](int_100K);
	oj_a := printf("#~BeginVariableOutput~#\n");
	pj_a := decimal("1001");
	qj_a := arith_perftest(dec_100K,pj_a,"dec_100K");
	rj_a := printf("#~EndVariableOutput~#\n");
#printf("#~BeginVariableOutput~#\n"); arith_perftest(dec_100K, decimal("1001"), "dec_100K"); printf("#~EndVariableOutput~#\n");
#
#	int_1M:= new(void,int,1000000);
##var int_1M := new(void,int,1000000);
#barrier	sj_a:= true;
#	i:= i-1;
#	uj_a := i;
#	vj_a := >=(uj_a,0);
#barrier	tj_a:= vj_a;
##while((i :-= 1) >= 0) {
#	base:= *(i,100000);
##        var base := i * 100000;
#	wj_a := +(int_100K,base);
#	xj_a := insert(int_1M,wj_a);
##        int_1M.insert([+](int_100K,base));
#redo	sj_a;
#end	tj_a;
#end	sj_a;
##}
#	yj_a := bat.setSequenceBase(int_1M,0@0);
##int_1M.seqbase(0@0);
##
#	ak_a := printf("#~BeginVariableOutput~#\n");
#	bk_a := arith_perftest(int_1M,10001,"int_1M");
#	ck_a := printf("#~EndVariableOutput~#\n");
##printf("#~BeginVariableOutput~#\n"); arith_perftest(int_1M, 10001, "int_1M"); printf("#~EndVariableOutput~#\n");
##
#	dec_1M:= multiplex.script("decimal",int_1M);
##var dec_1M := [decimal](int_1M);
#	dk_a := printf("#~BeginVariableOutput~#\n");
#	ek_a := decimal("10001");
#	fk_a := arith_perftest(dec_1M,ek_a,"dec_1M");
#	gk_a := printf("#~EndVariableOutput~#\n");
##printf("#~BeginVariableOutput~#\n"); arith_perftest(dec_1M, decimal("10001"), "dec_1M"); printf("#~EndVariableOutput~#\n");
##
##quit;
##
##
###line 445 "/ufs/mk/monet_5-0/src/modules/atoms/decimal.mx"
##
##Identifer 'col_name' mapped to 'bbp.setColumn'
##Identifer 'seqbase' mapped to 'bat.setSequenceBase'
##Identifer 'CTgroup' mapped to 'group'
