@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f Mapi
@a M.L. Kersten, K.S. Mullender
@v 2.0
@d August 2003
@* The MonetDB Application Programming Interface

The easiest way to extend the functionality of MonetDB is to construct
an independent application, which communicates with a running server
using a database driver with a simple API and a textual protocol.  The
effectiveness of such an approach has been demonstrated by the wide
use of database API implementations, such as Perl DBI, PHP, ODBC,...

The database driver implementation given in this document focuses on
developing applications in C/C++. The command collection has been
chosen to align with common practice, i.e. queries follow a prepare,
execute, and fetch_row paradigm. The output is considered a regular
table. An example of a mini application below illustrates the main
operations.
@T
\begin{verbatim}
#include <Mapi.h>
#include <stdio.h>

#define die(dbh,hdl) (hdl?mapi_explain_query(hdl,stderr):		\
                          dbh?mapi_explain(dbh,stderr):			\
                              fprintf(stderr,"command failed\n"),	\
                      exit(-1))

int main(int argc, char **argv)
{
    Mapi dbh;
    MapiHdl hdl = NULL;

    dbh = mapi_connect("localhost", 45123, "monetdb", "monetdb", "sql");
    if (mapi_error(dbh))
        die(dbh, hdl);

    if ((hdl = mapi_query(dbh, "create table emp(name varchar(20), age int)")) == NULL
        || mapi_error(dbh) != MOK)
        die(dbh, hdl);
    if (mapi_close_handle(hdl) != MOK)
        die(dbh, hdl);
    if ((hdl = mapi_query(dbh, "insert into emp values('John', 23)")) == NULL
        || mapi_error(dbh) != MOK)
        die(dbh, hdl);
    mapi_close_handle(hdl);
    if (mapi_error(dbh) != MOK)
        die(dbh, hdl);
    if ((hdl = mapi_query(dbh, "insert into emp values('Mary', 22)")) == NULL
        || mapi_error(dbh) != MOK)
        die(dbh, hdl);
    mapi_close_handle(hdl);
    if (mapi_error(dbh) != MOK)
        die(dbh, hdl);
    if ((hdl = mapi_query(dbh, "select * from emp")) == NULL
        || mapi_error(dbh) != MOK)
        die(dbh, hdl);

    while (mapi_fetch_row(hdl)) {
        char *nme = mapi_fetch_field(hdl, 0);
        char *age = mapi_fetch_field(hdl, 1);
        printf("%s is %s\n", nme, age);
    }
    if (mapi_error(dbh) != MOK)
        die(dbh, hdl);
    mapi_close_handle(hdl);
    if (mapi_error(dbh) != MOK)
        die(dbh, hdl);
    mapi_disconnect(dbh);

    return 0;
}
\end{verbatim}

The mapi\_connect() operation establishes a communication channel with
a running server on the local machine. The user name is "monetdb" with
password "monetdb".
The query language interface is either "sql" of "mil".  Future
versions are expected to recognize also "xcore" and "xquery", and the
experimental languages "ram" and "mal".

Errors on the interaction can be captured using mapi\_error(),
possibly followed by a request to dump a short error message
explanation on a standard file location. It has been abstracted away
in a macro.

Provided we can establish a connection, the interaction proceeds as in
many similar application development packages. Queries are shipped for
execution using mapi\_query() and an answer table can be consumed one
row at a time. In many cases these functions suffice.

The tabular data exchange model is primarily meant to support sql
(mil, mal). For xml and xcore the engine is expected to generate an
XPath-like token stream from which the application can build the
internal representation of the document (e.g. a DOM-tree).

The Mapi interface provides caching of rows at the client side.
mapi\_query() will load tuples into the cache, after which they can be
read repeatedly using mapi\_fetch\_row() or directly accessed
(mapi\_seek\_row()). This facility is particularly handy when small,
but stable query results are repeatedly used in the client program.

To ease communication between application code and the cache entries,
the user can bind the C-variables both for input and output to the
query parameters, and output columns, respectively.  The query
parameters are indicated by '?' and may appear anywhere in the query
template.

@+ Caveats
The Mapi library expects complete lines from the server as answers to
query actions. Incomplete lines leads to Mapi waiting forever on the
server. Thus formatted printing is discouraged in favor of tabular
printing as offered by the table.print() commands.

@+ Compilation
The Mapi application uses include files found in the MonetDB
distribution directory or at a central location on your machine.
Assuming the location of the distribution is marked in the environment
variable $MONETDB_PREFIX, the following actions are needed to get a
working program.
@T
\begin{verbatim}
cc sample.c -I$MONETDB_PREFIX \
        -I$MONETDB_PREFIX/include/common \
        -I$MONETDB_PREFIX/include/mapi  \
        -L$MONETDB_PREFIX/lib \
        -lMapi -lutils -lstream \
        -Wl,--rpath -Wl,$MONETDB_PREFIX/lib/MonetDB:$MONETDB_PREFIX/lib \
        -o sample
\end{verbatim}

The location of the libraries in 4.3 are slightly different.

@+ Command Summary
The quick reference guide to the Mapi library is given below.  More
details on their constraints and defaults are given in the next
section.


@T
\begin{tabular}{l l}
mapi\_bind()	&	Bind string C-variable to a field\\
mapi\_bind\_numeric()	& Bind numeric C-variable to field\\
mapi\_bind\_var()	&	Bind typed C-variable to a field\\
mapi\_cache\_freeup()	& Forcefully shuffle fraction for cache refreshment\\
mapi\_cache\_limit()	& Set the tuple cache limit\\
mapi\_cache\_shuffle()	& Set shuffle fraction for cache refreshment\\
mapi\_clear\_bindings()	& Clear all field bindings\\
mapi\_clear\_params()	& Clear all parameter bindings\\
mapi\_close\_handle()	&	Close query handle and free resources\\
mapi\_connect()	&	Connect to a Mserver \\
mapi\_connect\_ssl()	& Connect to a Mserver using Secure Socket Layer (SSL)\\
mapi\_destroy()	&	Free handle resources\\
mapi\_disconnect()	& Disconnect from server\\
mapi\_error()	&	Test for error occurrence\\
mapi\_execute()	&	Execute a query\\
mapi\_execute\_array()	&Execute a query using string arguments\\
mapi\_explain()	&	Display error message and context on stream\\
mapi\_explain\_query()	&	Display error message and context on stream\\
mapi\_fetch\_all\_rows()	&	Fetch all answers from server into cache\\
mapi\_fetch\_field()	&Fetch a field from the current row\\
mapi\_fetch\_field\_array()	& Fetch all fields from the current row\\
mapi\_fetch\_line()	&	Retrieve the next line\\
mapi\_fetch\_reset()	&	Set the cache reader to the beginning\\
mapi\_fetch\_row()	&	Fetch row of values\\
mapi\_finish()	&	Terminate the current query\\
mapi\_get\_dbname()	&	Database being served\\
mapi\_get\_field\_count()	& Number of fields in current row\\
mapi\_get\_host()	&	Host name of server\\
mapi\_get\_language()	& Query language name\\
mapi\_get\_mapi\_version()	& Mapi version name\\
mapi\_get\_monet\_versionId()	& MonetDB version identifier\\
mapi\_get\_monet\_version()	& MonetDB version name\\
mapi\_get\_motd()	&	Get server welcome message\\
mapi\_get\_row\_count()	&	Number of rows in cache or -1\\
mapi\_get\_trace()	&	Get trace flag\\
mapi\_get\_user()	&	Current user name\\
mapi\_next\_result()	&	Go to next result set\\
mapi\_ping()	&	Test server for accessibility\\
mapi\_prepare()	&	Prepare a query for execution\\
mapi\_prepare\_array()	&	Prepare a query for execution using arguments\\
mapi\_query()	&	Send a query for execution\\
mapi\_query\_array()	& Send a query for execution with arguments\\
mapi\_query\_handle()	&	Send a query for execution\\
mapi\_quick\_query\_array()	& Send a query for execution with arguments\\
mapi\_quick\_query()	&	Send a query for execution\\
mapi\_quick\_response()	&	Quick pass response to stream\\
mapi\_quote()	& Escape characters\\
mapi\_reconnect()	& Reconnect with a clean session context\\
mapi\_rows\_affected()	& Obtain number of rows changed\\
mapi\_seek\_row()	&	Move row reader to specific location in cache\\
mapi\_setAutocommit()	&	Set auto-commit flag\\
mapi\_stream\_query()	& Send query and prepare for reading tuple stream\\
mapi\_table()	&	Get current table name\\
mapi\_timeout()	&	Set timeout for long-running queries[TODO]\\
mapi\_trace()	&	Set trace flag\\
mapi\_trace\_log()	& Keep log of interaction\\
mapi\_virtual\_result()	& Submit a virtual result set\\
mapi\_unquote()	&	remove escaped characters\\
\end{tabular}
@+ Mapi Library
The routines to build a MonetDB application are grouped in the library
MonetDB Application Programming Interface, or shorthand Mapi.

The protocol information is stored in a Mapi interface descriptor
(mid).  This descriptor can be used to ship queries, which return a
MapiHdl to represent the query answer.  The application can set up
several channels with the same or a different Mserver. It is the
programmer's responsibility not to mix the descriptors in retrieving
the results.

The application may be multi-threaded as long as the user respects the
individual connections represented by the database handlers.

The interface assumes a cautious user, who understands and has
experience with the MIL programming language model. It should also be
clear that references returned by the API point directly into the
administrative structures of Mapi.  This means that they are valid
only for a short period, mostly between successive mapi_fetch_row
commands. It also means that it the values are to retained, they have
to be copied.  A defensive programming style is advised.

Upon an error, the routines mapi_explain and mapi_explain_query
give information about the context of the failed call, including the
expression shipped and any response received.  The side-effect is
clearing the error status.
@- Error Message
Almost every call can fail since the connection with the database
server can fail at any time.  Functions that return a handle (either
Mapi or MapiHdl) may return NULL on failure, or they may return the
handle with the error flag set.  If the function returns a non-NULL
handle, always check for errors with mapi_error.

@T
Functions that return MapiMsg indicate success and failure with the
following codes.\\

\begin{tabular}{l l}
MOK  & No error \\
MERROR  & Mapi internal error.\\
MTIMEOUT  & Error communicating with the server.\\
\end{tabular}

When these functions return MERROR or MTIMEOUT, an explanation of the
error can be had by calling one of the functions mapi\_error\_str(),
mapi\_explain(), or mapi\_explain\_query().

To check for error messages from the server, call mapi\_result\_error().
This function returns NULL if there was no error, or the error message
if there was.  A user-friendly message can be printed using
map\_explain\_result().  Typical usage is:

\begin{verbatim}
do {
    if ((error = mapi_result_error(hdl)) != NULL)
        mapi_explain_result(hdl, stderr);
    while ((line = mapi_fetch_line(hdl)) != NULL)
        /* use output */;
} while (mapi_next_result(hdl) == 1);
\end{verbatim}
@+ Function Reference
@- Connecting and Disconnecting
@T
\begin{description}
\item[Mapi mapi\_connect(const char *host, int port, const char *username, const char *password, const char *lang)]:
Setup a connection with a Mserver at a {\em host}:{\em port} and login
with {\em username} and {\em password}. If host == NULL, the local
host is accessed.  If host starts with a '/' and the system supports it,
host is actually the name of a UNIX domain socket, and port is ignored.
If port == 0, a default port is used.  If username == NULL,
the username of the owner of the client application
containing the Mapi code is used.  If password == NULL, the password
is omitted.  The preferred query language is any of
\{sql,mil,mal,xcore,xquery\}\\ On success, the function returns a
pointer to a structure with administration about the connection.

\item[Mapi mapi\_connect\_ssl(const char *host, int port, const char *username, const char *password, const char *lang)]:
Setup a connection with a Mserver at a {\em host}:{\em port} and login
with {\em username} and {\em password}. The connection is made using
the Secure Socket Layer (SSL) and hence all data transfers to and from
the server are encrypted. The parameters are the same as in
mapi\_connect.

\item[MapiMsg mapi\_disconnect(Mapi mid)]:
Terminate the session described by {\em mid}.  The only possible uses
of the handle after this call is mapi\_destroy() and mapi\_reconnect().
Other uses lead to failure.

\item[MapiMsg mapi\_destroy(Mapi mid)]:
Terminate the session described by {\em mid} if not already done so,
and free all resources. The handle cannot be used anymore.

\item[MapiMsg mapi\_reconnect(Mapi mid)]:
Close the current channel (if still open) and re-establish a fresh
connection. This will remove all global session variables.

\item[MapiMsg mapi\_ping(Mapi mid)]:
Test availability of the server. Returns zero upon success.
\end{description}
@- Sending Queries
@T
\begin{description}
\item[MapiHdl mapi\_query(Mapi mid, const char *Command)]:
Send the Command to the database server represented by mid.  This
function returns a query handle with which the results of the query
can be retrieved.  The handle should be closed with
mapi\_close\_handle().  The command response is buffered for
consumption, c.f. mapi\_fetch\_row().

\item[MapiMsg mapi\_query\_handle(MapiHdl hdl, const char *Command)]:
Send the Command to the database server represented by hdl, reusing
the handle from a previous query.  If Command is zero it takes the
last query string kept around.  The command response is buffered for
consumption, e.g. mapi\_fetch\_row().

\item[MapiHdl mapi\_query\_array(Mapi mid, const char *Command, char **argv)]:
Send the Command to the database server replacing the placeholders (?) 
by the string arguments presented.

\item[MapiHdl mapi\_quick\_query(Mapi mid, const char *Command, FILE *fd)]:
Similar to mapi\_query, except that the response of the server is copied
immediately to the file indicated.

\item[MapiHdl mapi\_quick\_query\_array(Mapi mid, const char *Command, char **argv, FILE *fd)]:
Similar to mapi\_query\_array, except that the response of the server
is not analyzed, but shipped immediately to the file indicated.

\item[MapiHdl mapi\_stream\_query(Mapi mid, const char *Command, int windowsize)]:
Send the request for processing and fetch a limited number of tuples
(determined by the window size) to assess any erroneous situation.
Thereafter, prepare for continual reading of tuples from the stream,
until an error occurs. Each time a tuple arrives, the cache is shifted
one.

\item[MapiHdl mapi\_prepare(Mapi mid, const char *Command)]:
Move the query to a newly allocated query handle (which is returned).
Possibly interact with the back-end to prepare the query for
execution.

\item[MapiMsg mapi\_execute(MapiHdl hdl)]:
Ship a previously prepared command to the backend for execution. A
single answer is pre-fetched to detect any runtime error. MOK is
returned upon success.

\item[MapiMsg mapi\_execute\_array(MapiHdl hdl, char **argv)]:
Similar to mapi\_execute but replacing the placeholders for the string
values provided.

\item[MapiMsg mapi\_finish(MapiHdl hdl)]:
Terminate a query.  This routine is used in the rare cases that
consumption of the tuple stream produced should be prematurely
terminated. It is automatically called when a new query using the same
query handle is shipped to the database and when the query handle is
closed with mapi\_close\_handle().

\item[MapiMsg mapi\_virtual\_result(MapiHdl hdl, int columns, const char **columnnames, const char **columntypes, const int *columnlengths, int tuplecount, const char ***tuples)]:
Submit a table of results to the library that can then subsequently be
accessed as if it came from the server.
columns is the number of columns of the result set and must be greater
than zero.
columnnames is a list of pointers to strings giving the names of the
individual columns.  Each pointer may be NULL and columnnames may be
NULL if there are no names.
tuplecount is the length (number of rows) of the result set.  If
tuplecount is less than zero, the number of rows is determined by a NULL
pointer in the list of tuples pointers.
tuples is a list of pointers to row values.  Each row value is a list of
pointers to strings giving the individual results.  If one of these
pointers is NULL it indicates a NULL/nil value.
\end{description}
@- Getting Results
@T
\begin{description}
\item[int mapi\_num\_fields(Mapi mid)]:
Return the number of fields in the current row.

\item[int mapi\_num\_rows(Mapi mid)]:
If possible, return the number of rows in the last select call.  A -1
is returned if this information is not available.

\item[int mapi\_rows\_affected(MapiHdl hdl)]:
Return the number of rows affected by a database update command
(INSERT/DELETE/REPLACE).

\item[int mapi\_fetch\_row(MapiHdl hdl)]:
Retrieve a row from the server.  The text retrieved is kept around in
a buffer linked with the query handle from which selective fields can
be extracted.  It returns the number of fields recognized.  A zero is
returned upon encountering end of sequence or error. This can be
analyzed in using mapi\_error().

\item[int mapi\_fetch\_all\_rows(MapiHdl hdl)]:
All rows are cached at the client side first. Subsequent calls to
mapi\_fetch\_row() will take the row from the cache. The number or
rows cached is returned.

\item[int mapi\_quick\_response(MapiHdl hdl, FILE *fd)]:
Read the answer to a query and pass the results verbatim to a
stream. The result is not analyzed or cached.

\item[MapiMsg mapi\_seek\_row(MapiHdl hdl, int rownr, int whence)]:
Reset the row pointer to the requested row number.  If whence is
MAPI\_SEEK\_SET (0), rownr is the absolute row number (0 being the
first row); if whence is MAPI\_SEEK\_CUR (1), rownr is relative to the
current row; if whence is MAPI\_SEEK\_END (2), rownr is relative to
the last row.

\item[MapiMsg mapi\_fetch\_reset(MapiHdl hdl)]:
Reset the row pointer to the first line in the cache.  This need not
be a tuple.  This is mostly used in combination with fetching all
tuples at once.

\item[char **mapi\_fetch\_field\_array(MapiHdl hdl)]:
Return an array of string pointers to the individual fields.  A zero
is returned upon encountering end of sequence or error. This can be
analyzed in using mapi\_error().

\item[char *mapi\_fetch\_field(MapiHdl hdl, int fnr)]:
Return a pointer a C-string representation of the value returned.  A
zero is returned upon encountering an error or when the database value
is NULL; this can be analyzed in using mapi\_error().

\item[MapiMsg mapi\_next\_result(MapiHdl hdl)]:
Go to the next result set, discarding the rest of the output of the
current result set.
\end{description}
@- Errors
@T
\begin{description}
\item[MapiMsg mapi\_error(Mapi mid)]:
Return the last error code or 0 if there is no error.

\item[char *mapi\_error\_str(Mapi mid)]:
Return a pointer to the last error message.

\item[char *mapi\_result\_error(MapiHdl hdl)]:
Return a pointer to the last error message from the server.

\item[MapiMsg mapi\_explain(Mapi mid, FILE *fd)]:
Write the error message obtained from Mserver to a file.

\item[MapiMsg mapi\_explain\_query(MapiHdl hdl, FILE *fd)]:
Write the error message obtained from Mserver to a file.

\item[MapiMsg mapi\_explain\_result(MapiHdl hdl, FILE *fd)]:
Write the error message obtained from Mserver to a file.
\end{description}
@- Parameters
@T
\begin{description}
\item[MapiMsg mapi\_bind(MapiHdl hdl, int fldnr, char **val)]:
Bind a string variable with a field in the return table.  Upon a
successful subsequent mapi\_fetch\_row the indicated field is stored
in the space pointed to by val.  Returns an error if the field
identified does not exist.

\item[MapiMsg mapi\_bind\_var(MapiHdl hdl, int fldnr, int type, void *val)]:
Bind a variable to a field in the return table.  Upon a successful
subsequent mapi\_fetch\_row, the indicated field is converted to the
given type and stored in the space pointed to by val.  The types
recognized are {MAPI\_TINY, MAPI\_UTINY, MAPI\_SHORT, MAPI\_USHORT,
MAPI\_INT, MAPI\_UINT, MAPI\_LONG, MAPI\_ULONG, MAPI\_LONGLONG,
MAPI\_ULONGLONG, MAPI\_CHAR, MAPI\_VARCHAR, MAPI\_FLOAT, MAPI\_DOUBLE,
MAPI\_DATE, MAPI\_TIME, MAPI\_DATETIME}.  The binding operations
should be performed after the mapi\_execute command.  Subsequently all
rows being fetched also involve delivery of the field values in the
C-variables using proper conversion. For variable length strings a
pointer is set into the cache.

\item[MapiMsg mapi\_bind\_numeric(MapiHdl hdl, int fldnr, int scale, int precision, void *val)]:
Bind to a numeric variable, internally represented by MAPI\_INT
Describe the location of a numeric parameter in a query template.

\item[MapiMsg mapi\_clear\_bindings(MapiHdl hdl)]:
Clear all field bindings.

\item[MapiMsg mapi\_param(MapiHdl hdl, int fldnr, char **val)]:
Bind a string variable with the n-th placeholder in the query
template.  No conversion takes place.

\item[MapiMsg mapi\_param\_type(MapiHdl hdl, int fldnr, int ctype, int sqltype, void *val)]:
Bind a variable whose type is described by ctype to a parameter whose
type is described by sqltype.

\item[MapiMsg mapi\_param\_numeric(MapiHdl hdl, int fldnr, int scale, int precision, void *val)]:
Bind to a numeric variable, internally represented by MAPI\_INT.

\item[MapiMsg mapi\_param\_string(MapiHdl hdl, int fldnr, int sqltype, char *val, int *sizeptr)]:
Bind a string variable, internally represented by MAPI\_VARCHAR, to a
parameter.  The sizeptr parameter points to the length of the string
pointed to by val.  If sizeptr == NULL or *sizeptr == -1, the string
is NULL-terminated.

\item[MapiMsg mapi\_clear\_params(MapiHdl hdl)]:
Clear all parameter bindings.
\end{description}
@- Miscellaneous
@T
\begin{description}
\item[MapiMsg mapi\_setAutocommit(Mapi mid, int autocommit)]:
Set the autocommit flag (default is off).  This only has an effect
when the language is SQL.  In that case, a commit statement is added
to the end of each query sent to the server.

\item[MapiMsg mapi\_cache\_limit(Mapi mid, int maxrows)]:
A limited number of tuples are pre-fetched after each execute().  If
maxrows is negative, all rows will be fetched before the application
is permitted to continue. Once the cache is filled, a number of tuples
are shuffled to make room for new ones, but taking into account
non-read elements.  Filling the cache quicker than reading leads to an
error.

\item[MapiMsg mapi\_cache\_shuffle(MapiHdl hdl, int percentage)]:
Make room in the cache by shuffling percentage tuples out of the
cache.  It is sometimes handy to do so, for example, when your
application is stream-based and you process each tuple as it arrives
and still need a limited look-back.  This percentage can be set
between 0 to 100.  Making shuffle= 100% (default) leads to paging
behavior, while shuffle==1 leads to a sliding window over a tuple
stream with 1% refreshing.

\item[MapiMsg mapi\_cache\_freeup(MapiHdl hdl, int percentage)]:
Forcefully shuffle the cache making room for new rows.  It ignores the
read counter, so rows may be lost.

\item[char * mapi\_quote(const char *str, int size)]:
Escape special characters such as $\backslash$n, $\backslash$t in str with
backslashes.  The returned value is a newly allocated string which
should be freed by the caller.

\item[char * mapi\_unquote(const char *name)]:
The reverse action of mapi\_quote(), turning the database
representation into a C-representation. The storage space is
dynamically created and should be freed after use.

\item[MapiMsg  mapi\_trace(Mapi mid, int flag)]:
Set the trace flag to monitor interaction with the server.

\item[int mapi\_get\_trace(Mapi mid)]:
Return the current value of the trace flag.

\item[MapiMsg  mapi\_trace\_log(Mapi mid, const char *fname)]:
Log the interaction between the client and server for offline
inspection. Beware that the log file overwrites any previous log. It
is not intended for recovery.
\end{description}
The remaining operations are wrappers around the data structures
maintained. Note that column properties are derived from the table
output returned from the server.
\begin{description}
\item[ char *mapi\_get\_name(MapiHdl hdl, int fnr)]:
\item[ char *mapi\_get\_type(MapiHdl hdl, int fnr)]:
\item[ char *mapi\_get\_table(MapiHdl hdl, int fnr)]:
\item[ int mapi\_get\_len(Mapi mid, int fnr)]:

\item[ char *mapi\_get\_dbname(Mapi mid)]:
\item[ char *mapi\_get\_host(Mapi mid)]:
\item[ char *mapi\_get\_user(Mapi mid)]:
\item[ char *mapi\_get\_lang(Mapi mid)]:
\item[ char *mapi\_get\_version(Mapi mid)]:
\item[ int mapi\_get\_versionId(Mapi mid)]:
\item[ char *mapi\_get\_motd(Mapi mid)]:

%\item[MapiMsg mapi\_timeout(Mapi mid, int timeout)]:
%Sets the time out time in milli seconds for all subsequent
%Mapi commands. Default value is 0, wait indefinitely.

\item[char **mapi\_tables(Mapi mid)]:
Return a list of accessible database tables.

\item[char **mapi\_fields(Mapi mid)]:
Return a list of accessible tables fields. This can also be obtained
by inspecting the field descriptor returned by mapi\_fetch\_field.
\end{description}
@
@{
@+ Implementation
@c
#include "monet_utils.h"
#include   "Mapi.h"

#ifdef HAVE_UNISTD_H
# include <unistd.h>
#endif
#include  <stdio.h>
#ifdef HAVE_PWD_H
#include  <pwd.h>
#endif
#include  <sys/types.h>

#ifdef HAVE_SYS_SOCKET_H
# include <sys/socket.h>
#endif
#ifdef NATIVE_WIN32
# include <winsock.h>
#endif
#ifdef HAVE_SYS_UN_H
#include <sys/un.h>
#endif

#include  <signal.h>
#include  <string.h>
#include  <memory.h>

#if TIME_WITH_SYS_TIME
# include <sys/time.h>
# include <time.h>
#else
# if HAVE_SYS_TIME_H
#  include <sys/time.h>
# else
#  include <time.h>
# endif
#endif

@h
#ifndef _MAPI_H_INCLUDED
#define _MAPI_H_INCLUDED

#include <stdio.h>		/* for FILE * */
#include <stream.h>		/* for stream */

#define MAPI_AUTO	0	/* automatic type detection */
#define MAPI_TINY	1
#define MAPI_UTINY	2
#define MAPI_SHORT	3
#define MAPI_USHORT	4
#define MAPI_INT	5
#define MAPI_UINT	6
#define MAPI_LONG	7
#define MAPI_ULONG	8
#define MAPI_LONGLONG	9
#define MAPI_ULONGLONG	10
#define MAPI_CHAR	11
#define MAPI_VARCHAR	12
#define MAPI_FLOAT	13
#define MAPI_DOUBLE	14
#define MAPI_DATE	15
#define MAPI_TIME	16
#define MAPI_DATETIME	17
#define MAPI_NUMERIC	18

#define PLACEHOLDER	'?'

#define MAPI_SEEK_SET	0
#define MAPI_SEEK_CUR	1
#define MAPI_SEEK_END	2

typedef int MapiMsg;

#define MOK		0
#define MERROR		(-1)
#define MTIMEOUT	(-2)
#define MMORE		(-3)
#define MSERVER		(-4)

#define LANG_MAL	0
#define LANG_MIL	1
#define LANG_SQL	2
#define LANG_XCORE	3
#define LANG_XQUERY	4
@-
The table field information is extracted from the table headers
obtained from the server. This list may be extended in the future.
The type of both the 'param' and 'binding'
variables refer to their underlying C-type. They are used for
automatic type coercion between back-end and application.
@c

#define MAPIBLKSIZE	256	/* minimum buffer shipped */

/* information about the columns in a result set */
struct MapiColumn {
	char *tablename;
	char *columnname;
	char *columntype;
	int columnlength;
};

/* information about bound columns */
struct MapiBinding {
	void *outparam;		/* pointer to application variable */
	int outtype;		/* type of application variable */
	int precision;
	int scale;
};

/* information about statement parameters */
struct MapiParam {
	void *inparam;		/* pointer to application variable */
	int *sizeptr;		/* if string, points to length of string or -1 */
	int intype;		/* type of application variable */
	int outtype;		/* type of value */
	int precision;
	int scale;
};

@-
The row cache contains a string representation of each (non-error) line
received from the backend. After a mapi_fetch_row() or mapi_fetch_field()
this string has been indexed from the anchor table, which holds a pointer
to the start of the field. A sliced version is recognized by looking
at the fldcnt table, which tells you the number of fields recognized.
Lines received from the server without 'standard' line headers are
considered a single field.
@c
struct MapiRowBuf {
	int rowlimit;		/* maximum number of rows to cache */
	int shuffle;		/* percentage of rows to shuffle upon overflow */
	int limit;		/* current storage space limit */
	int writer;
	int reader;
	int first;		/* row # of first tuple */
	int *fldcnt;		/* actual number of fields in each row */
	char **rows;		/* string representation of rows received */
	int tuplecount;		/* number of tuples in the cache */
	int *tupleindex;	/* index of tuple rows */
	int *tuplerev;		/* reverse map of tupleindex */
	char ***anchors;	/* corresponding field pointers */
};

struct BlockCache {
	char *buf;
	int lim;
	int nxt;
	int end;
	int eos;		/* end of sequence */
};

/* A connection to a server is represented by a struct MapiStruct.  An
   application can have any number of connections to any number of
   servers.  Connections are completely independent of each other.
*/
@h
typedef struct MapiStruct *Mapi;

@c
struct MapiStruct {
	char *server;		/* server version */
	char *mapiversion;	/* mapi version */
	char *hostname;
	int port;
#ifdef HAVE_OPENSSL
	int secure;
#endif
	char *username;
	char *password;
	char *language;
	char *database;		/* to obtain from server */
	int languageId;
	int versionId;		/* Monet 4 or 5 */
	char *motd;		/* welcome message from server */

	int trace;		/* Trace Mapi interaction */
	int blocked;		/* blocked mode */
	char* noexplain;	/* on error, don't explain, only print result */
	MapiMsg error;		/* Error occurred */
	char *errorstr;		/* pointer to constant string */
	const char *action;	/* pointer to constant string */

	struct BlockCache blk;
	int connected;
	MapiHdl first;		/* start of doubly-linked list */
	MapiHdl active;		/* set when not all rows have been received */

	int cachelimit;		/* default maximum number of rows to cache */

	stream *tracelog;	/* keep a log for inspection */
	stream *from, *to;
};

/* this definition is a straight copy from sql_query.mx */
typedef enum sql_query_t {
	Q_END = 0,
	Q_PARSE = 1,
	Q_RESULT = 2,
	Q_TABLE = 3,
	Q_UPDATE = 4,
	Q_DATA = 5,
	Q_SCHEMA = 6,
	Q_TRANS = 7,
	Q_DEBUG = 8,
	Q_DEBUGP = 9,
	Q_PREPARE = 10
} sql_query_t;

struct MapiResultSet {
	struct MapiResultSet *next;
	struct MapiStatement *hdl;
	int tableid;		/* SQL id of current result set */
	int querytype;		/* type of SQL query */
	int row_count;
	int fieldcnt;
	int maxfields;
	char *errorstr;		/* error from server */
	struct MapiColumn *fields;
	struct MapiRowBuf cache;
};

@h
typedef struct MapiStatement *MapiHdl;

@c
struct MapiStatement {
	struct MapiStruct *mid;
	char *template;		/* keep parameterized query text around */
	char *query;
	int maxbindings;
	struct MapiBinding *bindings;
	int maxparams;
	struct MapiParam *params;
	struct MapiResultSet *result, *active, *lastresult;
	int needmore;		/* need more input */
	int *pending_close;
	int npending_close;
	MapiHdl prev, next;
};

@-
All external calls to the library should pass the mapi-check
routine. It assures a working connection and proper reset of
the error status of the Mapi structure.
@c
#define mapi_check(X,C)							\
	do {								\
		assert(X);						\
		if ((X)->connected == 0) {				\
			mapi_setError((X), "Connection lost", (C), MERROR); \
			return (X)->error;				\
		}							\
		mapi_clrError(X);					\
	} while (0)
#define mapi_check0(X,C)						\
	do {								\
		assert(X);						\
		if ((X)->connected == 0) {				\
			mapi_setError((X), "Connection lost", (C), MERROR); \
			return 0;					\
		}							\
		mapi_clrError(X);					\
	} while (0)
#define mapi_hdl_check(X,C)						\
	do {								\
		assert(X);						\
		assert((X)->mid);					\
		if ((X)->mid->connected == 0) {				\
			mapi_setError((X)->mid, "Connection lost", (C), MERROR); \
			return (X)->mid->error;				\
		}							\
		mapi_clrError((X)->mid);				\
	} while (0)
#define mapi_hdl_check0(X,C)						\
	do {								\
		assert(X);						\
		assert((X)->mid);					\
		if ((X)->mid->connected == 0) {				\
			mapi_setError((X)->mid, "Connection lost", (C), MERROR); \
			return 0;					\
		}							\
		mapi_clrError((X)->mid);				\
	} while (0)
@h
#ifdef __cplusplus
extern "C" {
#endif

#ifdef NATIVE_WIN32
#ifndef LIBMAPI
#define mapi_export extern __declspec(dllimport)
#else
#define mapi_export extern __declspec(dllexport)
#endif
#else
#define mapi_export extern
#endif

/* three structures used for communicating date/time information */
/* these structs are deliberately compatible with the ODBC versions
   SQL_DATE_STRUCT, SQL_TIME_STRUCT, and SQL_TIMESTAMP_STRUCT */
typedef struct {		/* used by MAPI_DATE */
	short year;
	unsigned short month;
	unsigned short day;
} MapiDate;

typedef struct {		/* used by MAPI_TIME */
	unsigned short hour;
	unsigned short minute;
	unsigned short second;
} MapiTime;

typedef struct {		/* used by MAPI_DATETIME */
	short year;
	unsigned short month;
	unsigned short day;
	unsigned short hour;
	unsigned short minute;
	unsigned short second;
	unsigned int fraction;	/* in 1000 millionths of a second (10e-9) */
} MapiDateTime;

/* connection-oriented functions */
mapi_export Mapi mapi_mapi(const char *host, int port, const char *username, const char *password, const char *lang);
mapi_export MapiMsg mapi_destroy(Mapi mid);
mapi_export MapiMsg mapi_start_talking(Mapi mid);
mapi_export Mapi mapi_connect(const char *host, int port, const char *username, const char *password, const char *lang);
mapi_export Mapi mapi_connect_ssl(const char *host, int port, const char *username, const char *password, const char *lang);
mapi_export stream **mapi_embedded_init(Mapi *midp, char *lang);
mapi_export MapiMsg mapi_disconnect(Mapi mid);
mapi_export MapiMsg mapi_reconnect(Mapi mid);
mapi_export MapiMsg mapi_ping(Mapi mid);

mapi_export MapiMsg mapi_error(Mapi mid);
mapi_export char *mapi_error_str(Mapi mid);
mapi_export void mapi_noexplain(Mapi mid, char *errorprefix);
mapi_export MapiMsg mapi_explain(Mapi mid, FILE *fd);
mapi_export MapiMsg mapi_explain_query(MapiHdl hdl, FILE *fd);
mapi_export MapiMsg mapi_explain_result(MapiHdl hdl, FILE *fd);
mapi_export MapiMsg mapi_trace(Mapi mid, int flag);
mapi_export int mapi_get_trace(Mapi mid);
mapi_export MapiMsg mapi_trace_log(Mapi mid, const char *nme);
mapi_export MapiMsg mapi_setAutocommit(Mapi mid, int autocommit);
mapi_export char *mapi_result_error(MapiHdl hdl);
mapi_export MapiMsg mapi_next_result(MapiHdl hdl);
mapi_export int mapi_more_results(MapiHdl hdl);
mapi_export MapiHdl mapi_new_handle(Mapi mid);
mapi_export MapiMsg mapi_close_handle(MapiHdl hdl);
mapi_export MapiMsg mapi_bind(MapiHdl hdl, int fnr, char **ptr);
mapi_export MapiMsg mapi_bind_var(MapiHdl hdl, int fnr, int type, void *ptr);
mapi_export MapiMsg mapi_bind_numeric(MapiHdl hdl, int fnr, int scale, int precision, void *ptr);
mapi_export MapiMsg mapi_clear_bindings(MapiHdl hdl);
mapi_export MapiMsg mapi_param_type(MapiHdl hdl, int fnr, int ctype, int sqltype, void *ptr);
mapi_export MapiMsg mapi_param_string(MapiHdl hdl, int fnr, int sqltype, char *ptr, int *sizeptr);
mapi_export MapiMsg mapi_param(MapiHdl hdl, int fnr, char **ptr);
mapi_export MapiMsg mapi_param_numeric(MapiHdl hdl, int fnr, int scale, int precision, void *ptr);
mapi_export MapiMsg mapi_clear_params(MapiHdl hdl);
mapi_export MapiHdl mapi_prepare(Mapi mid, const char *cmd);
mapi_export MapiMsg mapi_prepare_handle(MapiHdl hdl, const char *cmd);
mapi_export MapiMsg mapi_virtual_result(MapiHdl hdl, int columns, const char **columnnames, const char **columntypes, const int *columnlengths, int tuplecount, const char ***tuples);
mapi_export MapiMsg mapi_execute(MapiHdl hdl);
mapi_export MapiMsg mapi_execute_array(MapiHdl hdl, char **val);
mapi_export MapiMsg mapi_fetch_reset(MapiHdl hdl);
mapi_export MapiMsg mapi_finish(MapiHdl hdl);
mapi_export MapiHdl mapi_prepare_array(Mapi mid, const char *cmd, char **val);
mapi_export MapiHdl mapi_query(Mapi mid, const char *cmd);
mapi_export MapiMsg mapi_query_handle(MapiHdl hdl, const char *cmd);
mapi_export MapiHdl mapi_query_prep(Mapi mid);
mapi_export MapiMsg mapi_query_part(MapiHdl hdl, const char *cmd, size_t size);
mapi_export MapiMsg mapi_query_done(MapiHdl hdl);
mapi_export MapiHdl mapi_quick_query(Mapi mid, const char *cmd, FILE *fd);
mapi_export MapiHdl mapi_query_array(Mapi mid, const char *cmd, char **val);
mapi_export MapiHdl mapi_quick_query_array(Mapi mid, const char *cmd, char **val, FILE *fd);
mapi_export MapiHdl mapi_stream_query(Mapi mid, const char *cmd, int windowsize);
mapi_export MapiMsg mapi_cache_limit(Mapi mid, int limit);
mapi_export MapiMsg mapi_cache_shuffle(MapiHdl hdl, int percentage);
mapi_export MapiMsg mapi_cache_freeup(MapiHdl hdl, int percentage);
mapi_export MapiMsg mapi_quick_response(MapiHdl hdl, FILE *fd);
mapi_export MapiMsg mapi_seek_row(MapiHdl hdl, int rowne, int whence);

mapi_export MapiMsg mapi_timeout(Mapi mid, int time);
mapi_export int mapi_fetch_row(MapiHdl hdl);
mapi_export int mapi_fetch_all_rows(MapiHdl hdl);
mapi_export int mapi_get_field_count(MapiHdl hdl);
mapi_export int mapi_get_row_count(MapiHdl hdl);
mapi_export int mapi_rows_affected(MapiHdl hdl);

mapi_export char *mapi_fetch_field(MapiHdl hdl, int fnr);
mapi_export MapiMsg mapi_store_field(MapiHdl hdl, int fnr, int outtype, void *outparam);
mapi_export char **mapi_fetch_field_array(MapiHdl hdl);
mapi_export char *mapi_fetch_line(MapiHdl hdl);
mapi_export char *mapi_get_lang(Mapi mid);
mapi_export char *mapi_get_dbname(Mapi mid);
mapi_export char *mapi_get_host(Mapi mid);
mapi_export char *mapi_get_user(Mapi mid);
mapi_export char *mapi_get_mapi_version(Mapi mid);
mapi_export char *mapi_get_monet_version(Mapi mid);
mapi_export int mapi_get_monet_versionId(Mapi mid);
mapi_export char *mapi_get_motd(Mapi mid);
mapi_export int mapi_is_blocked(Mapi mid);
mapi_export int mapi_is_connected(Mapi mid);
mapi_export char *mapi_get_table(MapiHdl hdl, int fnr);
mapi_export char *mapi_get_name(MapiHdl hdl, int fnr);
mapi_export char *mapi_get_type(MapiHdl hdl, int fnr);
mapi_export int mapi_get_len(MapiHdl hdl, int fnr);
mapi_export int mapi_get_querytype(MapiHdl hdl);
mapi_export int mapi_get_tableid(MapiHdl hdl);
mapi_export char *mapi_quote(const char *msg, int size);
mapi_export char *mapi_unquote(char *msg);

mapi_export void mapi_setBlocking(int b);
#ifdef __cplusplus
}
#endif
#endif				/* _MAPI_H_INCLUDED */
@
@+ Mapi Functions.
The application interface commands are described below.
They have been developed to ease interaction.

@c
static Mapi mapi_new(void);
static int mapi_extend_bindings(MapiHdl hdl, int minbindings);
static int mapi_extend_params(MapiHdl hdl, int minparams);
static MapiMsg mapi_setError(Mapi mid, const char *msg, const char *action, MapiMsg error);
static void close_connection(Mapi mid);
static MapiMsg read_into_cache(MapiHdl hdl, int lookahead);
static int unquote(char *msg, char **start, char **next);
static int mapi_slice_row(struct MapiResultSet *result, int cr);
static void mapi_store_bind(struct MapiResultSet *result, int cr);

#ifndef HAVE_GETLOGIN
#define getlogin() "win32"
#endif

#ifdef HAVE_OPENSSL
static SSL_CTX *mapi_ssl_ctx = 0;
#endif

static int mapi_initialized = 0;

#ifdef HAVE_LONG_LONG
typedef unsigned long long mapi_uint64;
typedef long long mapi_int64;
#else
#ifdef HAVE___INT64
typedef unsigned __int64 mapi_uint64;
typedef __int64 mapi_int64;
#endif
#endif

#define check_stream(mid,s,msg,f,e)					\
	do {								\
		if ((s) == NULL || stream_errnr(s)) {			\
			close_connection(mid);			\
			mapi_setError((mid), (msg), (f), MTIMEOUT);	\
			return (e);					\
		}							\
	} while (0)
#define REALLOC(p,c)	((p) = ((p) ? realloc((p),(c)*sizeof(*(p))) : malloc((c)*sizeof(*(p)))))

@+ Blocking
The server side code works with a common/stream package, a fast buffered IO scheme.
However, this package is not always available for every language runtime system.
For those cases a simple line-based protocol is also supported by the server.

To enable debugging in either blocked and line mode the user can set a global
variable before initiating a connection.
@c
static int blocked = 1;		/* the default */
void
mapi_setBlocking(int b)
{
	blocked = b != 0;
}

@+ Error Handling
All externally visible functions should first call mapi_clrError (usually
though a call to one of the check macros above) to clear the error flag.
When an error is detected, the library calls mapi_setError to set the error
flag.  The application can call mapi_error or mapi_error_str to check for
errors, and mapi_explain or mapi_explain_query to print a formatted error
report.
@c
static void
mapi_clrError(Mapi mid)
{
	assert(mid);
	if (mid->errorstr)
		free(mid->errorstr);
	mid->action = 0;	/* contains references to constants */
	mid->error = 0;
	mid->errorstr = 0;
}

static MapiMsg
mapi_setError(Mapi mid, const char *msg, const char *action, MapiMsg error)
{
	assert(msg);
	REALLOC(mid->errorstr, strlen(msg) + 1);
	strcpy(mid->errorstr, msg);
	mid->error = error;
	mid->action = action;
	return mid->error;
}

MapiMsg
mapi_error(Mapi mid)
{
	assert(mid);
	return mid->error;
}

char *
mapi_error_str(Mapi mid)
{
	assert(mid);
	return mid->errorstr;
}

static void
clean_print(char *msg, const char *prefix, FILE *fd)
{
	int len = strlen(prefix);

	while(msg && *msg) {
		/* cut by line */
		char *p = strchr(msg, '\n');
		if (p)
			*p = 0;

		/* skip over prefix */
		if (strncmp(msg,prefix,len) == 0)
			msg += len;

		/* output line */
		fputs(msg, fd); 
		fputc('\n', fd); 
		msg = p;
	}
}

static void
indented_print(const char *msg, const char *prefix, FILE *fd)
{
	/* for multiline error messages, indent all subsequent
	   lines with the space it takes to print "ERROR = " */
	const char *s, *p, *q;

	s = prefix;
	p = msg;
	while (p && *p) {
		fprintf(fd, "%s", s);
		s = "        ";
		q = strchr(p, '\n');
		if (q) {
			q++;	/* also print the newline */
			fprintf(fd, "%.*s", (int) (q - p), p);
		} else {
			/* print bit after last newline,
			   adding one ourselves */
			fprintf(fd, "%s\n", p);
			break;	/* nothing more to do */
		}
		p = q;
	}
}

void
mapi_noexplain(Mapi mid, char *errorprefix)
{
	assert(mid);
	mid->noexplain = errorprefix;
}

MapiMsg
mapi_explain(Mapi mid, FILE *fd)
{
	assert(mid);
        if (mid->noexplain == NULL) {
		fprintf(fd, "MAPI  = %s\@%s:%d\n", mid->username, mid->hostname, mid->port);
		if (mid->action)
			fprintf(fd, "ACTION= %s\n", mid->action);
		if (mid->errorstr)
			indented_print(mid->errorstr, "ERROR = ", fd);
	} else if (mid->errorstr) {
		clean_print(mid->errorstr, mid->noexplain, fd);
	}
	fflush(fd);
	mapi_clrError(mid);
	return MOK;
}

MapiMsg
mapi_explain_query(MapiHdl hdl, FILE *fd)
{
	Mapi mid;

	assert(hdl);
	mid = hdl->mid;
	assert(mid);
        if (mid->noexplain == NULL) {
		fprintf(fd, "MAPI  = %s\@%s:%d\n", mid->username, mid->hostname, mid->port);
		if (mid->action)
			fprintf(fd, "ACTION= %s\n", mid->action);
		if (hdl->query)
			indented_print(hdl->query, "QUERY = ", fd);
		if (mid->errorstr)
			indented_print(mid->errorstr, "ERROR = ", fd);
	} else if (mid->errorstr) {
		clean_print(mid->errorstr, mid->noexplain, fd);
	}
	fflush(fd);
	mapi_clrError(mid);
	return MOK;
}

MapiMsg
mapi_explain_result(MapiHdl hdl, FILE *fd)
{
	Mapi mid;

	if (hdl == NULL || hdl->result == NULL || hdl->result->errorstr == NULL)
		return MOK;
	assert(hdl);
	assert(hdl->result);
	assert(hdl->result->errorstr);
	mid = hdl->mid;
	assert(mid);
        if (mid->noexplain == NULL) {
		fprintf(fd, "MAPI  = %s\@%s:%d\n", mid->username, mid->hostname, mid->port);
		if (mid->action)
			fprintf(fd, "ACTION= %s\n", mid->action);
		if (hdl->query)
			indented_print(hdl->query, "QUERY = ", fd);
		indented_print(hdl->result->errorstr, "ERROR = ", fd);
	} else {
		clean_print(hdl->result->errorstr, mid->noexplain, fd);
	}
	fflush(fd);
	return MOK;
}

MapiMsg
mapi_trace(Mapi mid, int flag)
{
	mapi_clrError(mid);
	mid->trace = flag;
	return MOK;
}

int
mapi_get_trace(Mapi mid)
{
	mapi_check0(mid, "mapi_get_trace");
	return mid->trace;
}

MapiMsg
mapi_trace_log(Mapi mid, const char *nme)
{
	mapi_clrError(mid);
	mid->tracelog = open_wastream(nme);
	if (mid->tracelog == NULL || stream_errnr(mid->tracelog)) {
		if (mid->tracelog)
			stream_destroy(mid->tracelog);
		mid->tracelog = NULL;
		return mapi_setError(mid, "Could not create log file", "mapi_trace_log", MERROR);
	}
	return MOK;
}

/* send a dummy request to the server to see whether the connection is
   still alive */
MapiMsg
mapi_ping(Mapi mid)
{
	MapiHdl hdl = NULL;

	mapi_check(mid, "mapi_ping");
	switch (mid->languageId) {
	case LANG_SQL:
		hdl = mapi_query(mid, "select true;");
		break;
	case LANG_MAL:
	case LANG_MIL:
		hdl = mapi_query(mid, "print(1);");
		break;
	}
	if (hdl)
		mapi_close_handle(hdl);
	return mapi_error(mid);
}

/* set or unset the autocommit flag in the server */
MapiMsg
mapi_setAutocommit(Mapi mid, int autocommit)
{
	MapiHdl hdl;

	mapi_check(mid, "mapi_setAutocommit");
	if (mid->languageId != LANG_SQL) {
		mapi_setError(mid, "autocommit only supported in SQL", "mapi_setAutocommit", MERROR);
		return MERROR;
	}
	if (autocommit)
		hdl = mapi_query(mid, "set auto_commit = true");
	else
		hdl = mapi_query(mid, "set auto_commit = false");
	if (hdl == NULL || mapi_error(mid)) {
		if (hdl)
			mapi_close_handle(hdl);
		return MERROR;
	}
	return mapi_close_handle(hdl);
}

/* allocate a new structure to represent a result set */
static struct MapiResultSet *
new_result(MapiHdl hdl)
{
	struct MapiResultSet *result;

	assert((hdl->lastresult == NULL && hdl->result == NULL) || (hdl->result != NULL && hdl->lastresult != NULL && hdl->lastresult->next == NULL));

	if (hdl->mid->trace)
		printf("allocating new result set\n");
	/* append a newly allocated struct to the end of the linked list */
	result = malloc(sizeof(*result));
	result->next = NULL;
	if (hdl->lastresult == NULL)
		hdl->result = hdl->lastresult = result;
	else {
		hdl->lastresult->next = result;
		hdl->lastresult = result;
	}

	result->hdl = hdl;
	result->tableid = -1;
	result->querytype = -1;
	result->errorstr = NULL;

	result->row_count = 0;

	result->fieldcnt = 0;
	result->maxfields = 0;
	result->fields = NULL;

	result->cache.rowlimit = hdl->mid->cachelimit;
	result->cache.shuffle = 100;
	result->cache.limit = 0;
	result->cache.writer = 0;
	result->cache.reader = -1;
	result->cache.first = 0;
	result->cache.rows = NULL;
	result->cache.tuplecount = 0;
	result->cache.tupleindex = NULL;
	result->cache.tuplerev = NULL;
	result->cache.anchors = NULL;
	result->cache.fldcnt = NULL;

	return result;
}

/* close a result set, discarding any unread results */
static MapiMsg
close_result(MapiHdl hdl)
{
	struct MapiResultSet *result;
	Mapi mid;
	int i;

	result = hdl->result;
	if (result == NULL)
		return MERROR;
	mid = hdl->mid;
	assert(mid != NULL);
	if (mid->trace)
		printf("closing result set\n");
	if (result->tableid >= 0 && result->querytype != Q_PREPARE) {
		if (mid->active && !mid->active->needmore && read_into_cache(mid->active, 0) != MOK)
			return MERROR;
		assert(hdl->npending_close == 0 || (hdl->npending_close > 0 && hdl->pending_close != NULL));
		if (mid->active) {
			/* can't write "X" commands now, so save for later */
			REALLOC(hdl->pending_close, hdl->npending_close + 1);
			hdl->pending_close[hdl->npending_close] = result->tableid;
			hdl->npending_close++;
		} else if (mid->to != NULL) {
			/* first close saved up to-be-closed tables */
			for (i = 0; i < hdl->npending_close; i++) {
				mid->active = hdl;
				if (stream_printf(mid->to, "X" "close %d\n", hdl->pending_close[i]) < 0 || stream_flush(mid->to)) {
					close_connection(mid);
					mapi_setError(mid, stream_error(mid->to), "mapi_close_handle", MTIMEOUT);
					break;
				}
				read_into_cache(hdl, 0);
			}
			hdl->npending_close = 0;
			if (hdl->pending_close)
				free(hdl->pending_close);
			hdl->pending_close = NULL;
			if (mid->to != NULL) {
				mid->active = hdl;
				if (stream_printf(mid->to, "X" "close %d\n", result->tableid) < 0 || stream_flush(mid->to)) {
					close_connection(mid);
					mapi_setError(mid, stream_error(mid->to), "mapi_close_handle", MTIMEOUT);
				} else
					read_into_cache(hdl, 0);
			}
		}
		result->tableid = -1;
	}
	if (mid->active == hdl && hdl->active == result && read_into_cache(hdl, -1) != MOK)
		return MERROR;
	assert(hdl->active != result);
	if (result->fields) {
		for (i = 0; i < result->maxfields; i++) {
			if (result->fields[i].tablename)
				free(result->fields[i].tablename);
			if (result->fields[i].columnname)
				free(result->fields[i].columnname);
			if (result->fields[i].columntype)
				free(result->fields[i].columntype);
		}
		free(result->fields);
	}
	result->fields = NULL;
	result->maxfields = result->fieldcnt = 0;
	if (result->cache.rows) {
		for (i = 0; i < result->cache.writer; i++)
			if (result->cache.rows[i])
				free(result->cache.rows[i]);
		free(result->cache.rows);
		result->cache.rows = NULL;
		if (result->cache.tupleindex)
			free(result->cache.tupleindex);
		result->cache.tupleindex = NULL;
		if (result->cache.tuplerev)
			free(result->cache.tuplerev);
		result->cache.tuplerev = NULL;
	}
	if (result->cache.anchors) {
		for (i = 0; i < result->cache.writer; i++)
			if (result->cache.anchors[i])
				free(result->cache.anchors[i]);
		free(result->cache.anchors);
		result->cache.anchors = NULL;
	}
	if (result->cache.fldcnt)
		free(result->cache.fldcnt);
	result->cache.fldcnt = NULL;
	if (result->errorstr)
		free(result->errorstr);
	result->errorstr = NULL;
	result->hdl = NULL;
	hdl->result = result->next;
	if (hdl->result == NULL)
		hdl->lastresult = NULL;
	result->next = NULL;
	free(result);
	return MOK;
}

static void
add_error(struct MapiResultSet *result, char *error)
{
	/* concatenate the error messages */
	size_t size = result->errorstr ? strlen(result->errorstr) : 0;

	REALLOC(result->errorstr, size + strlen(error) + 2);
	strcpy(result->errorstr + size, error);
	strcat(result->errorstr + size, "\n");
}

char *
mapi_result_error(MapiHdl hdl)
{
	return hdl->result ? hdl->result->errorstr : NULL;
}

/* Go to the next result set, if any, and close the current result
   set.  This function returns 1 if there are more result sets after
   the one that was closed, otherwise, if more input is needed, return
   MMORE, else, return MOK */
MapiMsg
mapi_next_result(MapiHdl hdl)
{
	mapi_hdl_check(hdl, "mapi_next_result");

	while (hdl->result != NULL) {
		if (close_result(hdl) != MOK)
			return MERROR;
		if (hdl->result &&
		    (hdl->result->querytype == -1 ||
		     hdl->result->querytype == Q_TABLE ||
		     hdl->result->querytype == Q_UPDATE ||
		     hdl->result->errorstr != NULL))
			return 1;
	}
	return hdl->needmore ? MMORE : MOK;
}

int
mapi_more_results(MapiHdl hdl)
{
	struct MapiResultSet *result;

	mapi_hdl_check(hdl, "mapi_more_results");

	if ((result = hdl->result) == 0) {
		/* there are no results at all */
		return 0;
	}
	if (result->querytype == Q_TABLE &&
	    hdl->mid->active == hdl) {
		/* read until next result (if any) */
		read_into_cache(hdl, -1);
	}
	if (hdl->needmore) {
		/* assume the application will provide more data and
		   that we will then have a result */
		return 1;
	}
	while (result->next) {
		result = result->next;
		if (result->querytype == -1 ||
		    result->querytype == Q_TABLE ||
		    result->querytype == Q_UPDATE ||
		    result->errorstr != NULL)
			return 1;
	}
	/* no more results */
	return 0;
}

MapiHdl
mapi_new_handle(Mapi mid)
{
	MapiHdl hdl;

	mapi_check0(mid, "mapi_new_handle");

	hdl = malloc(sizeof(*hdl));
	assert(hdl);
	if (hdl == NULL) {
		mapi_setError(mid, "Memory allocation failure", "mapi_new_handle", MERROR);
		return NULL;
	}
	hdl->mid = mid;
	hdl->template = NULL;
	hdl->query = NULL;
	hdl->maxbindings = 0;
	hdl->bindings = NULL;
	hdl->maxparams = 0;
	hdl->params = NULL;
	hdl->result = NULL;
	hdl->lastresult = NULL;
	hdl->active = NULL;
	hdl->needmore = 0;
	hdl->pending_close = NULL;
	hdl->npending_close = 0;
	/* add to doubly-linked list */
	hdl->prev = NULL;
	hdl->next = mid->first;
	mid->first = hdl;
	if (hdl->next)
		hdl->next->prev = hdl;
	return hdl;
}

/* close all result sets on the handle but don't close the handle itself */
static MapiMsg
finish_handle(MapiHdl hdl)
{
	Mapi mid;
	int i;

	if (hdl == NULL)
		return MERROR;
	mid = hdl->mid;
	if (mid->active == hdl && !hdl->needmore && read_into_cache(hdl, 0) != MOK)
		return MERROR;
	if (mid->to) {
		if (hdl->needmore) {
			assert(mid->active == NULL || mid->active == hdl);
			hdl->needmore = 0;
			mid->active = hdl;
			stream_flush(mid->to);
			check_stream(mid, mid->to, "write error on stream", "finish_handle", mid->error);
			read_into_cache(hdl, 0);
		}
		for (i = 0; i < hdl->npending_close; i++) {
			mid->active = hdl;
			if (stream_printf(mid->to, "X" "close %d\n", hdl->pending_close[i]) < 0 || stream_flush(mid->to)) {
				close_connection(mid);
				mapi_setError(mid, stream_error(mid->to), "finish_handle", MTIMEOUT);
				break;
			}
			read_into_cache(hdl, 0);
		}
	}
	hdl->npending_close = 0;
	if (hdl->pending_close)
		free(hdl->pending_close);
	hdl->pending_close = NULL;
	while (hdl->result) {
		if (close_result(hdl) != MOK)
			return MERROR;
		if (hdl->needmore) {
			assert(mid->active == NULL || mid->active == hdl);
			hdl->needmore = 0;
			mid->active = hdl;
			stream_flush(mid->to);
			check_stream(mid, mid->to, "write error on stream", "finish_handle", mid->error);
			read_into_cache(hdl, 0);
		}
	}
	return MOK;
}

/* Close a statement handle, discarding any unread output. */
MapiMsg
mapi_close_handle(MapiHdl hdl)
{
	/* don't use mapi_check_hdl: it's ok if we're not connected */
	mapi_clrError(hdl->mid);

	if (finish_handle(hdl) != MOK)
		return MERROR;
	hdl->npending_close = 0;
	if (hdl->pending_close)
		free(hdl->pending_close);
	hdl->pending_close = NULL;
	if (hdl->bindings)
		free(hdl->bindings);
	hdl->bindings = NULL;
	hdl->maxbindings = 0;
	if (hdl->params)
		free(hdl->params);
	hdl->params = NULL;
	hdl->maxparams = 0;
	if (hdl->query)
		free(hdl->query);
	hdl->query = NULL;
	if (hdl->template)
		free(hdl->template);
	hdl->template = NULL;
	/* remove from doubly-linked list */
	if (hdl->prev)
		hdl->prev->next = hdl->next;
	if (hdl->next)
		hdl->next->prev = hdl->prev;
	if (hdl->mid->first == hdl)
		hdl->mid->first = hdl->next;
	hdl->prev = NULL;
	hdl->next = NULL;
	hdl->mid = NULL;
	free(hdl);
	return MOK;
}

/* Allocate a new connection handle. */
static Mapi
mapi_new(void)
{
	Mapi mid;

	mid = malloc(sizeof(*mid));
	if (mid == NULL)
		return NULL;
	assert(mid);

	/* initialize everything to 0 */
	memset(mid, 0, sizeof(*mid));

	/* then fill in some details */
	mid->blocked = blocked;
	mid->error = MOK;
	mid->hostname = strdup("localhost");
	mid->server = NULL;
	mid->language = strdup("mil");
	mid->languageId = LANG_MIL;
	mid->versionId = 4;
	mid->noexplain = NULL;
	mid->motd = NULL;
	mid->mapiversion = strdup("mapi 1.0");
	mid->username = strdup("anonymous");
	mid->password = strdup("unknown");

	mid->cachelimit = 1000;
	mid->tracelog = NULL;
	mid->blk.eos = 0;
	mid->blk.buf = malloc(BLOCK + 1);
	mid->blk.buf[BLOCK] = 0;
	mid->blk.buf[0] = 0;
	mid->blk.nxt = 0;
	mid->blk.end = 0;
	mid->blk.lim = BLOCK;

	mid->first = NULL;
	return mid;
}

/* Allocate a new connection handle and fill in the information needed
   to connect to a server, but don't connect yet. */
Mapi
mapi_mapi(const char *host, int port, const char *username, const char *password, const char *lang)
{
	Mapi mid;

	if (!mapi_initialized) {
		mapi_initialized = 1;
		if (stream_init() < 0)
			return NULL;
	}

	mid = mapi_new();
	if (mid == NULL)
		return NULL;

	if (host) {
		free(mid->hostname);
		mid->hostname = strdup(host);
	}
	if (port == 0) {
		char *def;

		if ((def = getenv("MAPIPORT")) != NULL)
			port = atoi(def);
	}
	if (port == 0) {
		port = 50000;	/* hardwired default */
	}
	if (username) {
		free(mid->username);
		mid->username = strdup(username);
	}
	if (password == 0)
		password = getlogin();
	if (password) {
		free(mid->password);
		mid->password = strdup(password);
	}

	mid->port = port;
#ifdef HAVE_OPENSSL
	mid->secure = 0;
#endif

	if (lang == NULL) 
		lang = "mil";
	free(mid->language);
	mid->language = strdup(lang);

	if (strcmp(lang, "mil") == 0)
		mid->languageId = LANG_MIL;
	if (strcmp(lang, "mal") == 0)
		mid->languageId = LANG_MAL;
	if (strcmp(lang, "sql") == 0)
		mid->languageId = LANG_SQL;
	if (strcmp(lang, "xcore") == 0)
		mid->languageId = LANG_XCORE;
	if (strcmp(lang, "xquery") == 0)
		mid->languageId = LANG_XQUERY;

	return mid;
}

/* Close a connection and free all memory associated with the
   connection handle. */
MapiMsg
mapi_destroy(Mapi mid)
{
	mapi_clrError(mid);

	while (mid->first)
		mapi_close_handle(mid->first);
	if (mid->connected)
		(void) mapi_disconnect(mid);
	if (mid->blk.buf)
		free(mid->blk.buf);
	if (mid->errorstr)
		free(mid->errorstr);
	if (mid->hostname)
		free(mid->hostname);
	if (mid->username)
		free(mid->username);
	if (mid->password)
		free(mid->password);
	if (mid->language)
		free(mid->language);
	if (mid->mapiversion)
		free(mid->mapiversion);
	if (mid->database)
		free(mid->database);
	if (mid->server)
		free(mid->server);
	free(mid);
	return MOK;
}

@+ Channel Constructor
The first call of an application is to establish a connection with
an already server. The username and password are sent as part of
the initialization sequence.
@c
#ifdef HAVE_OPENSSL
static char *
ssl_error(int err, int ret)
{
	char *errstr;
	char buf[120];
	unsigned long e;

	switch (err) {
	case SSL_ERROR_ZERO_RETURN:
		errstr = "TLS/SSL connection has been closed";
		break;
	case SSL_ERROR_WANT_READ:
		errstr = "The operation did not complete (read)";
		break;
	case SSL_ERROR_WANT_WRITE:
		errstr = "The operation did not complete (write)";
		break;
	case SSL_ERROR_WANT_X509_LOOKUP:
		errstr = "The operation did not complete (X509 lookup)";
		break;
	case SSL_ERROR_WANT_CONNECT:
		errstr = "The operation did not complete (connect)";
		break;
	case SSL_ERROR_SYSCALL:
		e = ERR_get_error();
		if (e == 0) {
			if (ret == 0) {
				errstr = "EOF occurred in violation of protocol";
			} else if (ret == -1) {
				/* the underlying BIO reported an I/O error */
				errstr = "I/O error";
			} else {	/* possible? */
				errstr = "Some I/O error occurred";
			}
		} else {
			errstr = ERR_error_string(e, buf);
		}
		break;
	case SSL_ERROR_SSL:
		e = ERR_get_error();
		if (e != 0)
			errstr = ERR_error_string(e, buf);
		else {		/* possible? */
			errstr = "A failure in the SSL library occurred";
		}
		break;
	default:
		errstr = "Invalid error code";
	}
	return strdup(errstr);
}
#endif /* HAVE_OPENSSL */

/* (Re-)establish a connection with the server. */
static MapiMsg
connect_to_server(Mapi mid)
{
	struct sockaddr_in server;

#ifdef HAVE_SYS_UN_H
	struct sockaddr_un userver;
#endif
	struct sockaddr *serv;
	size_t servsize;
	int s;

#ifdef HAVE_OPENSSL
	SSL *ssl = NULL;
#endif

	if (mid->connected)
		close_connection(mid);

#ifdef HAVE_SYS_UN_H
	if (
#ifdef HAVE_OPENSSL
		   !mid->secure &&
#endif
		   mid->hostname && mid->hostname[0] == '/') {
		if (strlen(mid->hostname) >= sizeof(userver.sun_path)) {
			return mapi_setError(mid, "path name too long", "mapi_reconnect", MERROR);
		}
		userver.sun_family = AF_UNIX;
		strncpy(userver.sun_path, mid->hostname, sizeof(userver.sun_path));
		serv = (struct sockaddr *) &userver;
		servsize = sizeof(userver);
	} else
#endif
	{
		struct hostent *hp;

		hp = gethostbyname(mid->hostname);
		if (hp == NULL) {
			return mapi_setError(mid, "gethostbyname failed", "mapi_reconnect", MERROR);
		}
		memset(&server, 0, sizeof(server));
		memcpy(&server.sin_addr, hp->h_addr, hp->h_length);
		server.sin_family = hp->h_addrtype;
		server.sin_port = htons((unsigned short) (mid->port & 0xFFFF));
		serv = (struct sockaddr *) &server;
		servsize = sizeof(server);
	}

#ifdef HAVE_OPENSSL
	if (mid->secure && mapi_ssl_ctx == NULL) {
		mapi_ssl_ctx = SSL_CTX_new(SSLv23_method());
		if (mapi_ssl_ctx == 0) {
			char *errstr = ssl_error(SSL_ERROR_SSL, 0);

			mapi_setError(mid, errstr, "mapi_reconnect", MERROR);
			free(errstr);
			return mid->error;
		}
		SSL_CTX_set_verify(mapi_ssl_ctx, SSL_VERIFY_NONE, NULL);
	}
#endif
	s = socket(serv->sa_family, SOCK_STREAM, IPPROTO_TCP);
	if (s < 0) {
		return mapi_setError(mid, "Open socket failed", "mapi_reconnect", MERROR);
	}

	if (connect(s, serv, servsize) < 0) {
#ifdef NATIVE_WIN32
		fprintf(stderr, "!ERROR mapi_reconnect: connect: error %d\n", WSAGetLastError());
#else
		perror("!ERROR mapi_reconnect: connect");
#endif
		return mapi_setError(mid, "Setup connection failed", "mapi_reconnect", MERROR);
	}
#ifdef HAVE_OPENSSL
	if (mid->secure) {
		if ((ssl = SSL_new(mapi_ssl_ctx)) == 0) {
			char *errstr = ssl_error(SSL_ERROR_SSL, 0);

			mapi_setError(mid, errstr, "mapi_reconnect", MERROR);
			free(errstr);
			close(s);
			return mid->error;
		}
		if (!SSL_set_fd(ssl, s)) {
			char *errstr = ssl_error(SSL_ERROR_SSL, 0);

			mapi_setError(mid, errstr, "mapi_reconnect", MERROR);
			free(errstr);
			SSL_free(ssl);
			close(s);
			return mid->error;
		}
		SSL_set_connect_state(ssl);

		for (;;) {
			int ret, err;
			char *errstr;

			ret = SSL_connect(ssl);
			err = SSL_get_error(ssl, ret);
			switch (err) {
			case SSL_ERROR_WANT_READ:
			case SSL_ERROR_WANT_WRITE:
				/* try again */
				continue;
			case SSL_ERROR_NONE:
				/* successful connect */
				break;
			case SSL_ERROR_WANT_CONNECT:
			case SSL_ERROR_WANT_ACCEPT:
			case SSL_ERROR_WANT_X509_LOOKUP:
			default:
				/* some error occurred */
				SSL_free(ssl);
				close(s);
				errstr = ssl_error(err, ret);
				mapi_setError(mid, errstr, "mapi_reconnect", MERROR);
				free(errstr);
				return mid->error;
			}
			break;
		}

		mid->to = ssl_wastream(ssl, "Mapi client write");
		mid->from = ssl_rastream(ssl, "Mapi client read");
	} else
#endif
	{
		mid->to = socket_wastream(s, "Mapi client write");
		mid->from = socket_rastream(s, "Mapi client read");
	}
	check_stream(mid, mid->to, "Cannot open socket for writing", "mapi_reconnect", mid->error);
	check_stream(mid, mid->from, "Cannot open socket for reading", "mapi_reconnect", mid->error);

	mid->connected = 1;

	return MOK;
}

MapiMsg
mapi_start_talking(Mapi mid)
{
	char buf[BLOCK];
	size_t len;
	MapiHdl hdl;

	/* consume server challenge */
	len = stream_read(mid->from, buf, 1, 2);
	check_stream(mid, mid->from, "Connection terminated", "mapi_start_talking", (mid->blk.eos = 1, mid->error));
	buf[2] = 0;
	len = atoi(buf);
	assert(len < BLOCK);
	stream_read(mid->from, buf, 1, len);
	check_stream(mid, mid->from, "Connection terminated", "mapi_start_talking", (mid->blk.eos = 1, mid->error));
	buf[len] = 0;
	/* buf at this point looks like ":challenge:servertype:protover" */
	{
		char* chal;
		char* server;
		char* protover;
		char errbuf[BLOCK];

		chal = buf + 1;
		server = strchr(chal, ':');
		if (server == NULL) {
			mapi_setError(mid, "Challenge string is not valid", "mapi_start_talking", MERROR);
			return(mid->error);
		}
		*server++ = '\0';
		protover = strchr(server, ':');
		if (protover == NULL) {
			mapi_setError(mid, "Challenge string is not valid", "mapi_start_talking", MERROR);
			return(mid->error);
		}
		*protover++ = '\0';

		errbuf[0] = 0;
		switch (mid->languageId) {
		case LANG_MIL:
			if (strcmp(server, "mserver_mil") != 0) {
				snprintf(errbuf, BLOCK, "MIL language chosen, but server reports %s", server);
				close_connection(mid);
				return mapi_setError(mid, errbuf, "mapi_start_talking", MERROR);
			}
			break;
		case LANG_MAL:
			if (strcmp(server, "mserver_mal") != 0) {
				snprintf(errbuf, BLOCK, "MAL language chosen, but server reports %s", server);
				close_connection(mid);
				return mapi_setError(mid, errbuf, "mapi_start_talking", MERROR);
			}
			break;
		case LANG_SQL:
			if (strcmp(server, "mserver_sql") != 0) {
				snprintf(errbuf, BLOCK, "SQL language chosen, but server reports %s", server);
				close_connection(mid);
				return mapi_setError(mid, errbuf, "mapi_start_talking", MERROR);
			}
			break;
		case LANG_XQUERY:
			if (strcmp(server, "mserver_xquery") != 0) {
				snprintf(errbuf, BLOCK, "XQuery language chosen, but server reports %s", server);
				close_connection(mid);
				return mapi_setError(mid, errbuf, "mapi_start_talking", MERROR);
			}
			break;
		}
		/* just don't do anything with the challenge */
	}

	if (mid->blocked) {
		snprintf(buf, BLOCK, "%s:%s:%s:blocked\n", mid->username, mid->password, mid->language);
	} else {
		snprintf(buf, BLOCK, "%s:%s:%s\n", mid->username, mid->password, mid->language);
	}
	if (mid->trace) {
		printf("sending first request [%d]:%s", BLOCK, buf);
		fflush(stdout);
	}
	len = strlen(buf);
	stream_write(mid->to, buf, 1, len);
	check_stream(mid, mid->to, "Could not send initial byte sequence", "mapi_start_talking", mid->error);
	stream_flush(mid->to);
	check_stream(mid, mid->to, "Could not send initial byte sequence", "mapi_start_talking", mid->error);
	if (mid->blocked) {
		mid->to = stream_wstream(mid->to);
		check_stream(mid, mid->to, stream_error(mid->to), "mapi_start_talking", mid->error);
		mid->to = block_stream(mid->to);
		check_stream(mid, mid->to, stream_error(mid->to), "mapi_start_talking", mid->error);

		mid->from = stream_rstream(mid->from);
		check_stream(mid, mid->from, stream_error(mid->from), "mapi_start_talking", mid->error);
		mid->from = block_stream(mid->from);
		check_stream(mid, mid->from, stream_error(mid->from), "mapi_start_talking", mid->error);
	}

	/* consume the welcome message from the server */
	hdl = mapi_new_handle(mid);
	mid->active = hdl;
	read_into_cache(hdl, 0);
	if (mapi_error(mid)) {
		mapi_explain(mid, stdout);
		return mid->error;
	}
	if (hdl->result && hdl->result->cache.rows) {
		int i;
		size_t motdlen = 0;
		struct MapiResultSet *result = hdl->result;

		for (i = 0; i < result->cache.writer; i++)
			if (result->cache.rows[i] && result->cache.rows[i][0] == '#')
				motdlen += strlen(result->cache.rows[i]) + 1;
		if (motdlen > 0) {
			mid->motd = malloc(motdlen + 1);
			*mid->motd = 0;
			for (i = 0; i < result->cache.writer; i++)
				if (result->cache.rows[i] && result->cache.rows[i][0] == '#') {
					strcat(mid->motd, result->cache.rows[i]);
					strcat(mid->motd, "\n");
				}
		}
		mid->versionId = strcmp("Mserver 5.0", result->cache.rows[0]) == 0 ? 5 : 4;
	}
	mapi_close_handle(hdl);

	if (mid->trace)
		printf("connection established\n");
	if (mid->languageId == LANG_MAL)
		return mid->error;

	/* tell server about cachelimit */
	mapi_cache_limit(mid, mid->cachelimit);
	return mid->error;
}

MapiMsg
mapi_reconnect(Mapi mid)
{
	MapiMsg rc;

	rc = connect_to_server(mid);
	if (rc == MOK)
		rc = mapi_start_talking(mid);
	return rc;
}

/* Create a connection handle and connect to the server using the
   specified parameters. */
Mapi
mapi_connect(const char *host, int port, const char *username, const char *password, const char *lang)
{
	Mapi mid;

	mid = mapi_mapi(host, port, username, password, lang);
	if (mid && mid->error == MOK)
		mapi_reconnect(mid);	/* actually, initial connect */
	return mid;
}

/* Create a connection handle and connect to the server using the
   specified parameters.  Use SSL (Secure Socket Layer) to encrypt all
   data transfers with the server. */
Mapi
mapi_connect_ssl(const char *host, int port, const char *username, const char *password, const char *lang)
{
	Mapi mid = mapi_mapi(host, port, username, password, lang);

#ifdef HAVE_OPENSSL
	mid->secure = 1;
	if (mid && mid->error == MOK)
		mapi_reconnect(mid);	/* actually, initial connect */
#else
	mapi_setError(mid, "SSL connections not supported", "mapi_connect_ssl", MERROR);
#endif
	return mid;
}

stream **
mapi_embedded_init(Mapi *midp, char *lang)
{
	Mapi mid;
	stream **streams;

	mid = mapi_mapi(NULL, -1, "monetdb", "monetdb", lang);
	if (mid == NULL)
		return NULL;
	streams = malloc(2 * sizeof(*streams));
	if (rendezvous_streams(&streams[0], &mid->to, "to server") == 0 || rendezvous_streams(&mid->from, &streams[1], "from server") == 0) {
		mapi_destroy(mid);
		return NULL;
	}
	mid->connected = 1;
	*midp = mid;
	return streams;
}

@
Disconnection from the server leads to removal of the
Mapi structure. Subsequent access may lead to a crash.
@c
static void
close_connection(Mapi mid)
{
	MapiHdl hdl;
	struct MapiResultSet *result;

	mid->connected = 0;
	mid->active = NULL;
	for (hdl = mid->first; hdl; hdl = hdl->next) {
		hdl->active = NULL;
		for (result = hdl->result; result; result = result->next)
			result->tableid = -1;
	}
	/* finish channels */
	/* Make sure that the write- (to-) stream is closed first,
	 * as the related read- (from-) stream closes the shared
	 * socket; see also src/common/stream.mx:socket_close .
	 */
	if (mid->to) {
		stream_close(mid->to);
		stream_destroy(mid->to);
		mid->to = 0;
	}
	if (mid->from) {
		stream_close(mid->from);
		stream_destroy(mid->from);
		mid->from = 0;
	}
}

MapiMsg
mapi_disconnect(Mapi mid)
{
	mapi_check(mid, "mapi_disconnect");

	close_connection(mid);
	return MOK;
}

@-
Binding placeholders and column names provide some convenience
for bulk interacting with a server.
@c
#define testBinding(hdl,fnr,funcname)					\
	do {								\
		mapi_hdl_check(hdl, funcname);				\
		if (fnr < 0) {						\
			return mapi_setError(hdl->mid,			\
					     "Illegal field number",	\
					     funcname, MERROR);		\
		}							\
		/* make sure there is enough space */			\
		if (fnr >= hdl->maxbindings)				\
			mapi_extend_bindings(hdl, fnr);			\
	} while (0)

#define testParam(hdl, fnr, funcname)					\
	do {								\
		mapi_hdl_check(hdl, funcname);				\
		if (fnr < 0) {						\
			return mapi_setError(hdl->mid,			\
					     "Illegal param number",	\
					     funcname, MERROR);		\
		}							\
		if (fnr >= hdl->maxparams)				\
			mapi_extend_params(hdl, fnr);			\
	} while (0)

MapiMsg
mapi_bind(MapiHdl hdl, int fnr, char **ptr)
{
	testBinding(hdl, fnr, "mapi_bind");
	hdl->bindings[fnr].outparam = ptr;

	hdl->bindings[fnr].outtype = MAPI_AUTO;
	return MOK;
}

MapiMsg
mapi_bind_var(MapiHdl hdl, int fnr, int type, void *ptr)
{
	testBinding(hdl, fnr, "mapi_bind_var");
	hdl->bindings[fnr].outparam = ptr;

	if (type >= 0 && type < MAPI_NUMERIC)
		hdl->bindings[fnr].outtype = type;
	else
		return mapi_setError(hdl->mid, "Illegal SQL type identifier", "mapi_bind_var", MERROR);
	return MOK;
}

MapiMsg
mapi_bind_numeric(MapiHdl hdl, int fnr, int scale, int prec, void *ptr)
{
	if (mapi_bind_var(hdl, fnr, MAPI_NUMERIC, ptr))
		 return hdl->mid->error;

	hdl->bindings[fnr].scale = scale;
	hdl->bindings[fnr].precision = prec;
	return MOK;
}

MapiMsg
mapi_clear_bindings(MapiHdl hdl)
{
	mapi_hdl_check(hdl, "mapi_clear_bindings");
	if (hdl->bindings)
		memset(hdl->bindings, 0, hdl->maxbindings * sizeof(*hdl->bindings));
	return MOK;
}

MapiMsg
mapi_param_type(MapiHdl hdl, int fnr, int ctype, int sqltype, void *ptr)
{
	testParam(hdl, fnr, "mapi_param_type");
	hdl->params[fnr].inparam = ptr;

	if (ctype >= 0 && ctype < MAPI_NUMERIC)
		hdl->params[fnr].intype = ctype;
	else
		return mapi_setError(hdl->mid, "Illegal SQL type identifier", "mapi_param_type", MERROR);
	hdl->params[fnr].sizeptr = NULL;
	hdl->params[fnr].outtype = sqltype;
	hdl->params[fnr].scale = 0;
	hdl->params[fnr].precision = 0;
	return MOK;
}

MapiMsg
mapi_param_string(MapiHdl hdl, int fnr, int sqltype, char *ptr, int *sizeptr)
{
	testParam(hdl, fnr, "mapi_param_type");
	hdl->params[fnr].inparam = (void *) ptr;

	hdl->params[fnr].intype = MAPI_VARCHAR;
	hdl->params[fnr].sizeptr = sizeptr;
	hdl->params[fnr].outtype = sqltype;
	hdl->params[fnr].scale = 0;
	hdl->params[fnr].precision = 0;
	return MOK;
}

MapiMsg
mapi_param(MapiHdl hdl, int fnr, char **ptr)
{
	return mapi_param_type(hdl, fnr, MAPI_AUTO, MAPI_AUTO, ptr);
}

MapiMsg
mapi_param_numeric(MapiHdl hdl, int fnr, int scale, int prec, void *ptr)
{
	if (mapi_param_type(hdl, fnr, MAPI_NUMERIC, MAPI_NUMERIC, ptr))
		 return hdl->mid->error;

	hdl->params[fnr].scale = scale;
	hdl->params[fnr].precision = prec;
	return MOK;
}

MapiMsg
mapi_clear_params(MapiHdl hdl)
{
	mapi_hdl_check(hdl, "mapi_clear_params");
	if (hdl->params)
		memset(hdl->params, 0, hdl->maxparams * sizeof(*hdl->params));
	return MOK;
}

@-
The routine mapi_check ensures that no 'false' newlines are sent to the server,
because this may lead to a synchronization error easily.
@-
The query string could contain commentary lines, marked as starting
with a '#'. They should be silently removed.
Likewise for all end of line commentaries, provided '#' is not
part of a string literal.
@c
static void
mapi_check_query(MapiHdl hdl)
{
	char *c, bracket = 0, *comm = 0;

	assert(hdl->query);
	for (c = hdl->query; *c; c++) {
		if (*c == '\'' || *c == '"') {
			if (bracket == *c)
				bracket = 0;
			else if (bracket == 0)
				bracket = *c;
		}
		if (*c == '#' && bracket == 0) {
			comm = c;
			while (*c && *c != '\n')
				c++;
		}
		if (*c == '\n' && !hdl->mid->blocked) {
			mapi_setError(hdl->mid, "Newline in query string not allowed", "mapi_check_query", MERROR);
			*c = ' ';
		}
	}
	if (comm) {
		/* remove comment and white space before comment start */
		while (--comm >= hdl->query && isspace((int) (unsigned char) *comm))
			;
		*++comm = 0;
	}
}

MapiMsg
mapi_timeout(Mapi mid, int time)
{
	mapi_check(mid, "mapi_timeout");
	if (mid->trace)
		printf("Set timeout to %d\n", time);
	return mapi_setError(mid, "Operation not yet implemented", "mapi_timeout", MERROR);
}

@-
The routine mapi_query is one of the most heavily used ones.
It sends a complete statement for execution
(i.e., ending in a newline; possibly including additional newlines).
Interaction with the server is sped up using block based interaction.
The query is retained in the Mapi structure to repeat shipping.
@c
static MapiHdl
prepareQuery(MapiHdl hdl, const char *cmd)
{
	if (hdl && cmd) {
		size_t len = strlen(cmd);

		if (hdl->query)
			free(hdl->query);
		hdl->query = malloc(len + 1);
		assert(hdl->query);
		strcpy(hdl->query, cmd);
		if (hdl->template) {
			free(hdl->template);
			hdl->template = NULL;
		}
		if (strchr(cmd, PLACEHOLDER)) {
			hdl->template = malloc(len + 1);
			assert(hdl->template);
			strcpy(hdl->template, cmd);
		}
		mapi_check_query(hdl);
	}
	return hdl;
}

MapiHdl
mapi_prepare(Mapi mid, const char *cmd)
{
	mapi_check0(mid, "mapi_prepare");
	return prepareQuery(mapi_new_handle(mid), cmd);
}

MapiMsg
mapi_prepare_handle(MapiHdl hdl, const char *cmd)
{
	mapi_hdl_check(hdl, "mapi_prepare");
	if (finish_handle(hdl) != MOK)
		return MERROR;
	prepareQuery(hdl, cmd);
	return hdl->mid->error;
}

static MapiMsg
mapi_prepare_array_internal(MapiHdl hdl, char **val)
{
	int i;

	for (i = 0; val[i]; i++) {
		if (i >= hdl->maxparams)
			mapi_extend_params(hdl, i + 1);
		hdl->params[i].inparam = val[i];
		hdl->params[i].intype = MAPI_AUTO;
		hdl->params[i].outtype = MAPI_AUTO;
		hdl->params[i].sizeptr = NULL;
		hdl->params[i].scale = 0;
		hdl->params[i].precision = 0;
	}
	return MOK;
}

MapiHdl
mapi_prepare_array(Mapi mid, const char *cmd, char **val)
{
	MapiHdl hdl;

	mapi_check0(mid, "mapi_prepare_array");
	hdl = prepareQuery(mapi_new_handle(mid), cmd);
	mapi_prepare_array_internal(hdl, val);
	return hdl;
}

@-
Building the query string using replacement of values requires
some care to not overflow the space allocated.
@c
#define checkSpace(len)						\
	do {							\
		/* note: k==strlen(hdl->query) */		\
		if (k+len >= lim) {				\
			lim = k + len + MAPIBLKSIZE;		\
			hdl->query= realloc(hdl->query, lim);	\
			assert(hdl->query);			\
		}						\
	} while (0)

static void
mapi_param_store(MapiHdl hdl)
{
	char *val, buf[MAPIBLKSIZE];
	char *p = hdl->template, *q;
	int i;
	size_t k;
	size_t lim;

	if (hdl->template == 0)
		return;

	lim = strlen(hdl->template) + MAPIBLKSIZE;
	REALLOC(hdl->query, lim);
	assert(hdl->query);
	hdl->query[0] = 0;
	k = 0;

	q = strchr(hdl->template, PLACEHOLDER);
	i = 0;
	/* loop invariant: k == strlen(hdl->query) */
	while (q && i < hdl->maxparams) {
		if (q > p && *(q - 1) == '\\') {
			q = strchr(q + 1, PLACEHOLDER);
			continue;
		}

		strncpy(hdl->query + k, p, q - p);
		k += q - p;
		hdl->query[k] = 0;

		if (hdl->params[i].inparam == 0) {
			checkSpace(5);
			strcpy(hdl->query + k, hdl->mid->languageId == LANG_SQL ? "NULL" : "nil");
		} else {
			void *src = hdl->params[i].inparam;	/* abbrev */

			switch (hdl->params[i].intype) {
			case MAPI_TINY:
				checkSpace(5);
				sprintf(hdl->query + k, "%d", *(signed char *) src);
				break;
			case MAPI_UTINY:
				checkSpace(5);
				sprintf(hdl->query + k, "%u", *(unsigned char *) src);
				break;
			case MAPI_SHORT:
				checkSpace(10);
				sprintf(hdl->query + k, "%d", *(short *) src);
				break;
			case MAPI_USHORT:
				checkSpace(10);
				sprintf(hdl->query + k, "%u", *(unsigned short *) src);
				break;
			case MAPI_INT:
				checkSpace(20);
				sprintf(hdl->query + k, "%d", *(int *) src);
				break;
			case MAPI_UINT:
				checkSpace(20);
				sprintf(hdl->query + k, "%u", *(unsigned int *) src);
				break;
			case MAPI_LONG:
				checkSpace(20);
				sprintf(hdl->query + k, "%ld", *(long *) src);
				break;
			case MAPI_ULONG:
				checkSpace(20);
				sprintf(hdl->query + k, "%lu", *(unsigned long *) src);
				break;
			case MAPI_LONGLONG:
				checkSpace(30);
				sprintf(hdl->query + k, LLFMT, *(mapi_int64 *) src);
				break;
			case MAPI_ULONGLONG:
				checkSpace(30);
				sprintf(hdl->query + k, ULLFMT, *(mapi_uint64 *) src);
				break;
			case MAPI_FLOAT:
				checkSpace(30);
				sprintf(hdl->query + k, "%.9g", *(float *) src);
				break;
			case MAPI_DOUBLE:
				checkSpace(20);
				sprintf(hdl->query + k, "%.17g", *(double *) src);
				break;
			case MAPI_DATE:
				checkSpace(50);
				sprintf(hdl->query + k, "DATE '%04d-%02u-%02u'", ((MapiDate *) src)->year, ((MapiDate *) src)->month, ((MapiDate *) src)->day);
				break;
			case MAPI_TIME:
				checkSpace(60);
				sprintf(hdl->query + k, "TIME '%02u:%02u:%02u'", ((MapiTime *) src)->hour, ((MapiTime *) src)->minute, ((MapiTime *) src)->second);
				break;
			case MAPI_DATETIME:
				checkSpace(110);
				sprintf(hdl->query + k, "TIMESTAMP '%04d-%02u-%02u %02u:%02u:%02u.%09u'", ((MapiDateTime *) src)->year, ((MapiDateTime *) src)->month, ((MapiDateTime *) src)->day, ((MapiDateTime *) src)->hour,
					((MapiDateTime *) src)->minute, ((MapiDateTime *) src)->second, ((MapiDateTime *) src)->fraction);
				break;
			case MAPI_CHAR:
				buf[0] = *(char *) src;
				buf[1] = 0;
				val = mapi_quote(buf, 1);
				checkSpace(strlen(val)+3);
				sprintf(hdl->query + k, "'%s'", val);
				free(val);
				break;
			case MAPI_VARCHAR:
				val = mapi_quote((char *) src, hdl->params[i].sizeptr ? *hdl->params[i].sizeptr : -1);
				checkSpace(strlen(val)+3);
				sprintf(hdl->query + k, "'%s'", val);
				free(val);
				break;
			default:
				strcpy(hdl->query + k, src);
				break;
			}
		}
		k += strlen(hdl->query + k);

		i++;
		p = q + 1;
		q = strchr(p, PLACEHOLDER);
	}
	checkSpace(strlen(p)+1);
	strcpy(hdl->query + k, p);
	if (hdl->mid->trace)
		printf("param_store: result=%s\n", hdl->query);
	return;
}

/* Read one more line from the input stream and return it.  This
   returns a pointer into the input buffer, so the data needs to be
   copied if it is to be retained. */
static char *
read_line(Mapi mid)
{
	char *reply;
	char *nl;
	char *s;		/* from where to search for newline */

	if (mid->active == NULL)
		return 0;

	/* check if we need to read more blocks to get a new line */
	mid->blk.eos = 0;
	s = mid->blk.buf + mid->blk.nxt;
	while ((nl = strchr(s, '\n')) == NULL && !mid->blk.eos) {
		if (mid->blk.lim - mid->blk.end < BLOCK) {
			char *newbuf;
			int len;

			len = mid->blk.lim;
			if (mid->blk.nxt <= BLOCK) {
				/* extend space */
				len += BLOCK;
			}
			if (mid->blk.nxt > 0) {
				newbuf = malloc(len + 1);
				memcpy(newbuf, mid->blk.buf + mid->blk.nxt, mid->blk.end - mid->blk.nxt + 1);
				free(mid->blk.buf);
				mid->blk.buf = newbuf;
				mid->blk.end -= mid->blk.nxt;
				mid->blk.nxt = 0;
			} else {
				/* avoid repeated "malloc(); memcpy(); free();"
				 * with VERY LONG lines (e.g., XML results in MonetDB/XQuery)
				 */
				mid->blk.buf = realloc(mid->blk.buf, len + 1);
			}
			mid->blk.lim = len;
		}

		s = mid->blk.buf + mid->blk.end;

		if (mid->blocked) {
			ssize_t len;

			/* fetch one more block */
			if (mid->trace)
				printf("fetch next block: start at:%d\n", mid->blk.end);
			len = stream_read(mid->from, mid->blk.buf + mid->blk.end, 1, BLOCK);
			check_stream(mid, mid->from, "Connection terminated", "read_line", (mid->blk.eos = 1, (char *) 0));
			mid->blk.buf[mid->blk.end + len] = 0;
			if (mid->trace) {
				printf("got next block: length:" SSZFMT "\n", len);
				printf("text:%s\n", mid->blk.buf + mid->blk.end);
			}
			mid->blk.end += len;
		} else {
			/* fetch one more line */
			while (stream_read(mid->from, mid->blk.buf + mid->blk.end, 1, 1) == 1) {
				if (mid->blk.buf[mid->blk.end++] == '\n')
					break;
				if (mid->blk.end == mid->blk.lim)
					break;
			}
			check_stream(mid, mid->from, "Connection terminated", "read_line", (mid->blk.eos = 1, (char *) 0));
			mid->blk.buf[mid->blk.end] = 0;
		}
	}
	if (mid->trace) {
		printf("got complete block: \n");
		printf("text:%s\n", mid->blk.buf + mid->blk.nxt);
	}

	/* we have a complete line in the buffer */
	assert(nl);
	*nl++ = 0;
	reply = mid->blk.buf + mid->blk.nxt;
	mid->blk.nxt = nl - mid->blk.buf;

	if (mid->trace)
		printf("read_line:%s\n", reply);
	return reply;
}

static int
slice_row(char *reply, char *null, char ***anchorsp, int length)
{
	/* This function does the actual work for splicing a real,
	   multi-column row into columns.  It should only be called
	   when the string starts with '[' and there is a matching
	   ']'. */
	char *start;
	char **anchors;
	int i;

	reply++;		/* skip over initial '[' */
	i = 0;
	anchors = length == 0 ? NULL : malloc(length * sizeof(*anchors));
	do {
		if (i >= length) {
			length = i + 1;
			REALLOC(anchors, length);
		}
		if (!unquote(reply, &start, &reply) && null && strcmp(start, null) == 0) {
			/* indicate NULL/nil with NULL pointer */
			start = NULL;
		}
		anchors[i++] = start ? strdup(start) : NULL;
		while (*reply && isspace((int) (unsigned char) *reply))
			reply++;
	} while (*reply && *reply != ']');
	*anchorsp = anchors;
	return i;
}

static struct MapiResultSet *
parse_header_line(MapiHdl hdl, char *line, struct MapiResultSet *result)
{
	char *tag, *etag;
	int i, n;
	char **anchors;

	if (strcmp(line, "#-") == 0) {
		/* start of new SQL result */
		return NULL;
	}

	if (result == NULL)
		result = new_result(hdl);

	line = strdup(line);	/* make copy we can play with */

	etag = strrchr(line, '#');
	if (etag == 0 || etag == line) {
		/* not a useful header line */
		free(line);
		return result;
	}

	*line = '[';		/* fake a value row */
	*etag = ']';

	n = slice_row(line, NULL, &anchors, 10);

	tag = etag + 1;
	while (*tag && isspace((int) (unsigned char) *tag))
		tag++;

	if (n > result->fieldcnt) {
		REALLOC(result->fields, n);
		memset(result->fields + result->fieldcnt, 0, (n - result->fieldcnt) * sizeof(*result->fields));
		result->fieldcnt = n;
	}

	if (strcmp(tag, "name") == 0) {
		for (i = 0; i < n; i++) {
			if (anchors[i]) {
				if (result->fields[i].columnname)
					free(result->fields[i].columnname);
				result->fields[i].columnname = anchors[i];
				anchors[i] = NULL;
			}
		}
	} else if (strcmp(tag, "type") == 0) {
		for (i = 0; i < n; i++) {
			if (anchors[i]) {
				if (result->fields[i].columntype)
					free(result->fields[i].columntype);
				result->fields[i].columntype = anchors[i];
				anchors[i] = NULL;
			}
		}
	} else if (strcmp(tag, "length") == 0) {
		for (i = 0; i < n; i++) {
			if (anchors[i])
				result->fields[i].columnlength = atoi(anchors[i]);
		}
	} else if (strcmp(tag, "table_name") == 0) {
		for (i = 0; i < n; i++) {
			if (anchors[i]) {
				if (result->fields[i].tablename)
					free(result->fields[i].tablename);
				result->fields[i].tablename = anchors[i];
				anchors[i] = NULL;
			}
		}
	} else if (strcmp(tag, "tuplecount") == 0) {
		if (anchors[0])
			result->row_count = atoi(anchors[0]);
	} else if (strcmp(tag, "id") == 0) {
		if (anchors[0])
			result->tableid = atoi(anchors[0]);
	} else if (strcmp(tag, "querytype") == 0) {
		if (anchors[0]) {
			result->querytype = atoi(anchors[0]);
			if (result->querytype == Q_UPDATE ||
			    result->querytype == Q_TRANS) {
				result->fieldcnt = 1;
				result->row_count = 1;
			}
		}
	}

	/* clean up */
	free(line);
	for (i = 0; i < n; i++)
		if (anchors[i])
			free(anchors[i]);
	free(anchors);

	return result;
}

static MapiMsg
mapi_cache_freeup_internal(struct MapiResultSet *result, int k)
{
	int i;			/* just a counter */
	int n = 0;		/* # of tuples being deleted from front */

	result->cache.tuplecount = 0;
	for (i = 0; i < result->cache.writer - k; i++) {
		if (result->cache.rows[i]) {
			if (result->cache.rows[i][0] == '[' ||
			    result->cache.rows[i][0] == '=')
				n++;
			free(result->cache.rows[i]);
		}
		result->cache.rows[i] = result->cache.rows[i + k];
		result->cache.rows[i + k] = 0;
		if (result->cache.anchors[i])
			free(result->cache.anchors[i]);
		result->cache.anchors[i] = result->cache.anchors[i + k];
		result->cache.anchors[i + k] = 0;
		result->cache.fldcnt[i] = result->cache.fldcnt[i + k];
		if (result->cache.rows[i] &&
		    (result->cache.rows[i][0] == '[' ||
		     result->cache.rows[i][0] == '=')) {
			result->cache.tuplerev[i] = result->cache.tuplecount;
			result->cache.tupleindex[result->cache.tuplecount++] = i;
		}
	}
	/* after the previous loop, i == result->cache.writer - k, and
	   the last (result->cache.writer - k) cache entries have been
	   cleared already , so we don't need to go the Full Monty
	   here */
	for ( /*i = result->cache.writer - k */ ; i < k /*result->cache.writer */ ; i++) {
		if (result->cache.rows[i]) {
			if (result->cache.rows[i][0] == '[' ||
			    result->cache.rows[i][0] == '=')
				n++;
			free(result->cache.rows[i]);
		}
		result->cache.rows[i] = 0;
		if (result->cache.anchors[i])
			free(result->cache.anchors[i]);
		result->cache.anchors[i] = 0;
		result->cache.fldcnt[i] = 0;
	}
	result->cache.reader -= k;
	if (result->cache.reader < 0)
		result->cache.reader = -1;
	result->cache.writer -= k;
	if (result->cache.writer < 0)	/* "cannot happen" */
		result->cache.writer = 0;
	result->cache.first += n;

	return MOK;
}

static void
mapi_extend_cache(struct MapiResultSet *result)
{
	int incr, newsize, oldsize = result->cache.limit, i;

	/* extend row cache */
	if (oldsize == 0)
		incr = 1000;
	else
		incr = oldsize * 2;
	if (incr > 200000)
		incr = 20000;
	newsize = oldsize + incr;
	if (result->cache.rowlimit > 0 && newsize > result->cache.rowlimit) {
		newsize = result->cache.rowlimit;
		incr = newsize - oldsize;
		if (incr <= 0) {
			if (result->cache.reader >= 0) {
				/* flush all read entries */
				mapi_cache_freeup_internal(result, result->cache.reader + 1);
				/* since we've made space, we can return */
				return;
			}
			/* not enough space, so increase limit */
			result->cache.rowlimit += 100;
			mapi_extend_cache(result);	/* try again */
			return;
		}
	}

	REALLOC(result->cache.rows, newsize);
	assert(result->cache.rows);
	memset(result->cache.rows + oldsize, 0, incr * sizeof(*result->cache.rows));

	REALLOC(result->cache.tupleindex, newsize);
	assert(result->cache.tupleindex);
	for (i = oldsize; i < newsize; i++)
		result->cache.tupleindex[i] = -1;

	REALLOC(result->cache.tuplerev, newsize + 1);
	assert(result->cache.tuplerev);
	for (i = oldsize; i <= newsize; i++)
		result->cache.tuplerev[i] = -1;

	REALLOC(result->cache.anchors, newsize);
	assert(result->cache.anchors);
	memset(result->cache.anchors + oldsize, 0, incr * sizeof(*result->cache.anchors));

	REALLOC(result->cache.fldcnt, newsize);
	assert(result->cache.fldcnt);
	memset(result->cache.fldcnt + oldsize, 0, incr * sizeof(*result->cache.fldcnt));

	result->cache.limit = newsize;
}

/* store a line in the cache */
static void
add_cache(struct MapiResultSet *result, char *line)
{
	/* manage the row cache space first */
	if (result->cache.writer >= result->cache.limit)
		mapi_extend_cache(result);

	result->cache.rows[result->cache.writer] = line;
	result->cache.tuplerev[result->cache.writer] = result->cache.tuplecount;
	result->cache.tuplerev[result->cache.writer + 1] = result->cache.tuplecount + 1;
	if (*line == '[' || *line == '=') {
		result->cache.tupleindex[result->cache.tuplecount++] = result->cache.writer;
		if (result->row_count < result->cache.first + result->cache.tuplecount)
			result->row_count = result->cache.first + result->cache.tuplecount;
	}
	result->cache.writer++;
}

/* Read ahead and cache data read.  Depending on the second argument,
   reading may stop at the first non-header and non-error line, or at
   a prompt.
   This function is called either after a command has been sent to the
   server (in which case the second argument is 1), when the
   application asks for a result tuple that hadn't been cached yet (in
   which case the second argument is also 1), or whenever all pending
   data needs to be read in order to send a new command to the server
   (in which case the second argument is 0).
   Header lines result tuples are stored in the cache.  Certain header
   lines may cause a new result set to be created in which case all
   subsequent lines are added to that result set.
*/
static MapiMsg
read_into_cache(MapiHdl hdl, int lookahead)
{
	char *line, *copy;
	Mapi mid;
	struct MapiResultSet *result;

	mid = hdl->mid;
	assert(mid->active == hdl);
	if (hdl->needmore) {
		hdl->needmore = 0;
		stream_flush(mid->to);
		check_stream(mid, mid->to, "write error on stream", "read_into_cache", mid->error);
	}
	if ((result = hdl->active) == NULL)
		result = hdl->result;	/* may also be NULL */
	for (;;) {
		line = read_line(mid);
		if (line == NULL)
			return mid->error;
		switch (*line) {
		case PROMPTBEG:
			mid->active = NULL;
			hdl->active = NULL;
			/* set needmore flag if line equals PROMPT2 up
			   to newline */
			copy = PROMPT2;
			while (*line) {
				if (*line != *copy)
					return mid->error;
				line++;
				copy++;
			}
			if (*copy == '\n' || *copy == 0) {
				hdl->needmore = 1;
				mid->active = hdl;
			}
			return mid->error;
		case '!':
			/* start a new result set if we don't have one
			   yet (obviously), or if we've already seen
			   normal output for the current one */
			if (result == NULL || result->cache.writer > 0) {
				result = new_result(hdl);
				hdl->active = result;
			}
			add_error(result, line);
			if (!mid->error) 
				mid->error = MSERVER;
			break;
		case '#':
			if (lookahead < 0)
				lookahead = 1;
			copy = strdup(line);
			result = parse_header_line(hdl, line, result);
			hdl->active = result;
			if (result)
				add_cache(result, copy);
			else
				free(copy);
			break;
		default:
			if (result == NULL) {
				result = new_result(hdl);
				hdl->active = result;
			}
			add_cache(result, strdup(line));
			if (lookahead > 0 &&
			    (result->querytype == -1 /* unknown (not SQL) */ ||
			     result->querytype == Q_TABLE))
				return mid->error;
			break;
		}
	}
}

MapiMsg
mapi_virtual_result(MapiHdl hdl, int columns, const char **columnnames, const char **columntypes, const int *columnlengths, int tuplecount, const char ***tuples)
{
	Mapi mid;
	struct MapiResultSet *result;
	int i, n;
	const char **tuple;
	char **anchors;

	if (columns <= 0)
		return MERROR;
	mid = hdl->mid;
	if (mid->active && read_into_cache(mid->active, 0) != MOK)
		return MERROR;
	assert(mid->active == NULL);
	finish_handle(hdl);
	assert(hdl->result == NULL);
	assert(hdl->active == NULL);
	hdl->active = result = new_result(hdl);
	result->fieldcnt = columns;
	REALLOC(result->fields, columns);
	memset(result->fields, 0, columns * sizeof(*result->fields));
	result->querytype = Q_TABLE;
	for (i = 0; i < columns; i++) {
		if (columnnames && columnnames[i])
			result->fields[i].columnname = strdup(columnnames[i]);
		if (columntypes && columntypes[i])
			result->fields[i].columntype = strdup(columntypes[i]);
		if (columnlengths)
			result->fields[i].columnlength = columnlengths[i];
	}
	if (tuplecount > 0) {
		result->row_count = tuplecount;
		result->cache.rowlimit = tuplecount;
	}

	for (tuple = *tuples++, n = 0; tuplecount < 0 ? tuple !=NULL : n < tuplecount; tuple = *tuples++, n++) {
		add_cache(result, strdup("[ ]"));
		result->cache.fldcnt[n] = columns;
		anchors = malloc(columns * sizeof(*anchors));
		result->cache.anchors[n] = anchors;
		for (i = 0; i < columns; i++)
			anchors[i] = tuple[i] ? strdup(tuple[i]) : NULL;
	}
	hdl->active = NULL;
	return mid->error;
}

#define MAXQUERYSIZE	(100*1024)
#define QUERYBLOCK	(16*1024)

static MapiMsg
mapi_execute_internal(MapiHdl hdl)
{
	size_t size;
	char *cmd;
	Mapi mid;

	mid = hdl->mid;
	if (mid->active && read_into_cache(mid->active, 0) != MOK)
		return MERROR;
	assert(mid->active == NULL);
	finish_handle(hdl);
	mapi_param_store(hdl);
	cmd = hdl->query;
	size = strlen(cmd);

	if (mid->trace) {
		printf("mapi_query:" SZFMT ":%s\n", size, cmd);
	}
	if (mid->languageId == LANG_SQL) {
		if (size > MAXQUERYSIZE) {
			/* If the query is large and we don't do
			   anything about it, deadlock may occur: the
			   client (we) blocks writing the query while
			   the server blocks writing the initial
			   results.  Therefore we split up large
			   queries into smaller batches.  The split is
			   done simplistically, but we are prepared to
			   receive the secondary prompt.  We cache the
			   results of all but the last batch.
			   There is  a problem  if auto-commit is  on:
			   the server  commits on batch boundaries, so
			   if one of our batches  ends at the end of a
			   (sub)query, the server commits prematurely.
			   Another problem is when the query we
			   received is incomplete.  We should tell the
			   server that there is no more, but we
			   don't. */
			size_t i = 0;

			while (i < size) {
				mid->active = hdl;
				stream_write(mid->to, "S", 1, 1);
				check_stream(mid, mid->to, "write error on stream", "mapi_execute", mid->error);
				do {
					size_t n;

					hdl->needmore = 0;
					if ((n = QUERYBLOCK) > size - i)
						n = size - i;
					stream_write(mid->to, cmd + i, 1, n);
					check_stream(mid, mid->to, "write error on stream", "mapi_execute", mid->error);
					stream_flush(mid->to);
					check_stream(mid, mid->to, "write error on stream", "mapi_execute", mid->error);
					i += n;
					if (read_into_cache(hdl, 0) != MOK)
						return mid->error;
					if (i >= size && hdl->needmore) {
						hdl->needmore = 0;
						stream_flush(mid->to);
						check_stream(mid, mid->to, "write error on stream", "mapi_execute", mid->error);
					}
				} while (hdl->needmore);
			}
			return MOK;
		} else {
			/* indicate to server this is a SQL command */
			stream_write(mid->to, "s", 1, 1);
		}
	}
	stream_write(mid->to, cmd, 1, size);
	check_stream(mid, mid->to, "write error on stream", "mapi_execute", mid->error);
	/* all SQL statements should end with a semicolon */
	/* for the other languages it is assumed that the statements are correct */
	if (mid->languageId == LANG_SQL) {
		stream_write(mid->to, ";", 1, 1);
		check_stream(mid, mid->to, "write error on stream", "mapi_execute", mid->error);
	}
	stream_write(mid->to, "\n", 1, 1);
	check_stream(mid, mid->to, "write error on stream", "mapi_execute", mid->error);
	stream_flush(mid->to);
	check_stream(mid, mid->to, "write error on stream", "mapi_execute", mid->error);
	mid->active = hdl;
	return read_into_cache(hdl, 1);
}

MapiMsg
mapi_execute(MapiHdl hdl)
{
	int ret;

	mapi_hdl_check(hdl, "mapi_execute");
	ret = mapi_execute_internal(hdl);
	return ret;
}

MapiMsg
mapi_execute_array(MapiHdl hdl, char **val)
{
	int ret;

	mapi_hdl_check(hdl, "mapi_execute_array");
	ret = mapi_prepare_array_internal(hdl, val);
	if (ret == MOK)
		ret = mapi_execute_internal(hdl);
	if (ret == MOK)
		ret = read_into_cache(hdl, 1);
	return ret;
}

MapiHdl
mapi_query(Mapi mid, const char *cmd)
{
	int ret;
	MapiHdl hdl;

	mapi_check0(mid, "mapi_query");
	hdl = prepareQuery(mapi_new_handle(mid), cmd);
	ret = mid->error;
	if (ret == MOK)
		ret = mapi_execute_internal(hdl);
	return hdl;
}

MapiMsg
mapi_query_handle(MapiHdl hdl, const char *cmd)
{
	int ret;

	mapi_hdl_check(hdl, "mapi_query_handle");
	if (finish_handle(hdl) != MOK)
		return MERROR;
	prepareQuery(hdl, cmd);
	ret = hdl->mid->error;
	if (ret == MOK)
		ret = mapi_execute_internal(hdl);
	return ret;
}

MapiHdl
mapi_query_array(Mapi mid, const char *cmd, char **val)
{
	int ret;
	MapiHdl hdl;

	mapi_check0(mid, "mapi_query_array");
	hdl = prepareQuery(mapi_new_handle(mid), cmd);
	ret = hdl->mid->error;
	if (ret == MOK)
		ret = mapi_prepare_array_internal(hdl, val);
	if (ret == MOK)
		ret = mapi_execute_internal(hdl);
	return hdl;
}

MapiHdl
mapi_query_prep(Mapi mid)
{
	mapi_check0(mid, "mapi_query_prep");
	if (mid->active && read_into_cache(mid->active, 0) != MOK)
		return NULL;
	assert(mid->active == NULL);
	if (mid->languageId == LANG_SQL) {
		/* indicate to server this is a SQL command */
		stream_write(mid->to, "S", 1, 1);
	}
	return (mid->active = mapi_new_handle(mid));
}

MapiMsg
mapi_query_part(MapiHdl hdl, const char *query, size_t size)
{
	Mapi mid;

	mapi_hdl_check(hdl, "mapi_query_part");
	mid = hdl->mid;
	assert(mid->active == NULL || mid->active == hdl);
	mid->active = hdl;
	/* remember the query just for the error messages */
	if (hdl->query == NULL) {
		size_t sz = size;

		if (sz > 512)
			sz = 512;
		hdl->query = malloc(sz + 1);
		strncpy(hdl->query, query, sz);
		hdl->query[sz] = 0;
	}

	if (mid->trace) {
		printf("mapi_query_part:" SZFMT ":%.*s\n", size, (unsigned int)size, query);
	}
	hdl->needmore = 0;
	stream_write(mid->to, (char *) query, 1, size);
	check_stream(mid, mid->to, "write error on stream", "mapi_query_part", mid->error);
	return MOK;
}

MapiMsg
mapi_query_done(MapiHdl hdl)
{
	int ret;
	Mapi mid;

	mapi_hdl_check(hdl, "mapi_query_done");
	mid = hdl->mid;
	assert(mid->active == NULL || mid->active == hdl);
	mid->active = hdl;
	hdl->needmore = 0;
	stream_flush(mid->to);
	check_stream(mid, mid->to, "write error on stream", "mapi_query_done", mid->error);
	ret = mid->error;
	if (ret == MOK)
		ret = read_into_cache(hdl, 1);
	return ret == MOK && hdl->needmore ? MMORE : ret;
}

@-
To speed up interaction with a terminal front-end,
the user can issue the quick_*() variants.
They will not analyze the result for errors or
header information, but simply through the output
received from the server to the stream indicated.
@c
MapiHdl
mapi_quick_query(Mapi mid, const char *cmd, FILE *fd)
{
	int ret;
	MapiHdl hdl;

	mapi_check0(mid, "mapi_quick_query");
	hdl = prepareQuery(mapi_new_handle(mid), cmd);
	ret = hdl->mid->error;
	if (ret == MOK)
		ret = mapi_execute_internal(hdl);
	if (ret == MOK)
		ret = mapi_quick_response(hdl, fd);
	if (mid->trace)
		printf("mapi_quick_query return:%d\n", ret);
	return hdl;
}

MapiHdl
mapi_quick_query_array(Mapi mid, const char *cmd, char **val, FILE *fd)
{
	int ret;
	MapiHdl hdl;

	mapi_check0(mid, "mapi_quick_query_array");
	hdl = prepareQuery(mapi_new_handle(mid), cmd);
	ret = hdl->mid->error;
	if (ret == MOK)
		ret = mapi_prepare_array_internal(hdl, val);
	if (ret == MOK)
		ret = mapi_execute_internal(hdl);
	if (ret == MOK) {
		/* look ahead to detect errors */
		ret = mapi_quick_response(hdl, fd);
	}
	if (mid->trace)
		printf("mapi_quick_query return:%d\n", ret);
	return hdl;
}

@-
Stream queries are requests to the database engine that produce a stream
of answers of indefinite length. Elements are eaten away using the normal way.
The stream ends upon encountering of the prompt.
A stream query can not rely on upfront caching.
The stream query also ensures that the cache contains a window
over the stream by shuffling tuples once it is filled.
@c
MapiHdl
mapi_stream_query(Mapi mid, const char *cmd, int windowsize)
{
	MapiHdl hdl;
	int cachelimit = mid->cachelimit;

	mapi_check0(mid, "mapi_stream_query");

	mid->cachelimit = windowsize;
	hdl = mapi_query(mid, cmd);
	mid->cachelimit = cachelimit;
	if (hdl != NULL)
		mapi_cache_shuffle(hdl, 100);
	return hdl;
}

MapiMsg
mapi_cache_limit(Mapi mid, int limit)
{
	/* clean out superflous space TODO */
	mapi_check(mid, "mapi_cache_limit");
	mid->cachelimit = limit;
/* 	if (hdl->cache.rowlimit < hdl->cache.limit) { */
	/* TODO: decide what to do here */
	/* 		hdl->cache.limit = hdl->cache.rowlimit; *//* arbitrarily throw away cache lines */
/* 		if (hdl->cache.writer > hdl->cache.limit) { */
/* 			hdl->cache.writer = hdl->cache.limit; */
/* 			if (hdl->cache.reader > hdl->cache.writer) */
/* 				hdl->cache.reader = hdl->cache.writer; */
/* 		} */
/* 	} */
	if (mid->languageId == LANG_SQL) {
		MapiHdl hdl = mapi_new_handle(mid);

		if (mid->active && read_into_cache(mid->active, 0) != MOK)
			return MERROR;
		if (mid->active)
			return MOK;
		if (stream_printf(mid->to, "s" "set reply_size=%d;\n", limit) < 0 || stream_flush(mid->to))
			check_stream(mid, mid->to, stream_error(mid->to), "mapi_cache_limit", mid->error);
		mid->active = hdl;
		mapi_close_handle(hdl);	/* reads away any output */
	}
	return MOK;
}

MapiMsg
mapi_cache_shuffle(MapiHdl hdl, int percentage)
{
	/* clean out superflous space TODO */
	mapi_hdl_check(hdl, "mapi_cache_shuffle");
	if (percentage < 0 || percentage > 100) {
		return mapi_setError(hdl->mid, "Illegal percentage", "mapi_cache_shuffle", MERROR);
	}
	if (hdl->result)
		hdl->result->cache.shuffle = percentage;
	return MOK;
}

MapiMsg
mapi_fetch_reset(MapiHdl hdl)
{
	mapi_hdl_check(hdl, "mapi_fetch_reset");
	if (hdl->result)
		hdl->result->cache.reader = -1;
	return MOK;
}

MapiMsg
mapi_seek_row(MapiHdl hdl, int rownr, int whence)
{
	struct MapiResultSet *result;

	mapi_hdl_check(hdl, "mapi_seek_row");
	result = hdl->result;
	switch (whence) {
	case MAPI_SEEK_SET:
		break;
	case MAPI_SEEK_CUR:
		rownr += result->cache.tuplerev[result->cache.reader + 1];
		break;
	case MAPI_SEEK_END:
		if (hdl->mid->active && read_into_cache(hdl->mid->active, 0) != MOK)
			return MERROR;
		rownr += result->row_count;
		break;
	default:
		return mapi_setError(hdl->mid, "Illegal whence value", "mapi_seek_row", MERROR);
	}
	if (rownr > result->row_count && hdl->mid->active && read_into_cache(hdl->mid->active, 0) != MOK)
		return MERROR;
	if (rownr < 0 || rownr > result->row_count)
		return mapi_setError(hdl->mid, "Illegal row number", "mapi_seek_row", MERROR);
	if (result->cache.first <= rownr && rownr < result->cache.first + result->cache.tuplecount) {
		/* we've got the requested tuple in the cache */
		result->cache.reader = result->cache.tupleindex[rownr - result->cache.first] - 1;
	} else {
		/* we don't have the requested tuple in the cache
		   reset the cache and at the next fetch we'll get the data */
		if (mapi_cache_freeup(hdl, 100) == MOK) {
			result->cache.first = rownr;
		}
	}
	return hdl->mid->error;
}

/* Make space in the cache for new tuples, ignore the read pointer */
MapiMsg
mapi_cache_freeup(MapiHdl hdl, int percentage)
{
	struct MapiResultSet *result;
	int k;			/* # of cache lines to be deleted from front */

	mapi_hdl_check(hdl, "mapi_cache_freeup");
	result = hdl->result;
	if (result == NULL || (result->cache.writer == 0 && result->cache.reader == -1))
		return MOK;
	if (percentage < 0 || percentage > 100)
		percentage = 100;
	k = (result->cache.writer * percentage) / 100;
	if (k < 1)
		k = 1;
	return mapi_cache_freeup_internal(result, k);
}

@-
The routine mapi_fetch_line forms the basic interaction with the server.
It simply retrieves the next line and stores it in the row cache.
The field anchor structure is prepared for subsequent use by
mapi_fetch_row.
The content received is analyzed further by mapi_getRow()

@c
static char *
mapi_fetch_line_internal(MapiHdl hdl)
{
	Mapi mid;
	struct MapiResultSet *result;
	char *reply;

	/* try to read a line from the cache */
	if ((result = hdl->result) == NULL || result->cache.writer <= 0 || result->cache.reader + 1 >= result->cache.writer) {
		mid = hdl->mid;
		if (mid->active != hdl || hdl->needmore)
			return NULL;

		if (read_into_cache(hdl, 1) != MOK)
			return NULL;
		if ((result = hdl->result) == NULL || result->cache.writer <= 0 || result->cache.reader + 1 >= result->cache.writer)
			return NULL;
	}
	reply = result->cache.rows[++result->cache.reader];
	if (hdl->bindings && (*reply == '[' || *reply == '=')) {
		mapi_slice_row(result, result->cache.reader);
		mapi_store_bind(result, result->cache.reader);
	}
	return reply;
}

char *
mapi_fetch_line(MapiHdl hdl)
{
	char *reply;
	struct MapiResultSet *result;

	mapi_hdl_check0(hdl, "mapi_fetch_line");
	reply = mapi_fetch_line_internal(hdl);
	if (reply == NULL && (result = hdl->result) != NULL && hdl->mid->languageId == LANG_SQL && hdl->mid->active == NULL && result->row_count > 0 && result->cache.first + result->cache.tuplecount < result->row_count) {
		hdl->mid->active = hdl;
		hdl->active = result;
		if (stream_printf(hdl->mid->to, "X" "export %d %d\n", result->tableid, result->cache.first + result->cache.tuplecount) < 0 || stream_flush(hdl->mid->to))
			check_stream(hdl->mid, hdl->mid->to, stream_error(hdl->mid->to), "mapi_fetch_line", NULL);
		reply = mapi_fetch_line_internal(hdl);
	}
	return reply;
}

@-
To synchronize on a prompt, the low level routine mapi_finish can be used.
It discards all output received.
@c
MapiMsg
mapi_finish(MapiHdl hdl)
{
	mapi_hdl_check(hdl, "mapi_finish");
	return finish_handle(hdl);
}

@-
If the answer to a query should be simply passed on towards a client,
i.e. a stream, it pays to use the mapi_quick_response() routine.
The stream is only checked for occurrence of an error indicator
and the prompt.
The best way to use this shortcut execution is calling
mapi_quick_query(), otherwise we are forced to first
empty the row cache.

@c
MapiMsg
mapi_quick_response(MapiHdl hdl, FILE *fd)
{
	char *line;

	mapi_hdl_check(hdl, "mapi_quick_response");
	do {
		if ((line = mapi_result_error(hdl)) != NULL)
			mapi_explain_result(hdl, fd);
		while ((line = mapi_fetch_line(hdl)) != NULL)
			fprintf(fd, "%s\n", line);
	} while (mapi_next_result(hdl) == 1);
	return hdl->mid->error ? hdl->mid->error : (hdl->needmore ? MMORE : MOK);
}

@-
The routine mapi_get_row retrieves lines from the channel until
it finds either a valid row, or encounters an error.
In passing, it interprets comment lines to detect table headers.
It returns with 0 upon encountering the prompt
(MOK) or an error. The row cache buffer is extended until the limit
is reached.

TODO, header line does not appear in cache, reuse of old line is erroneous
@c
@-
Unquoting of a string is done in place. It returns the start
of the unquoted part section.
@c
/* msg is a string consisting comma-separated values.  The list of
   values is terminated by ] or by the end-of-string NULL byte.
   Values can be quoted strings or unquoted values.  Upon return,
   *start points to the start of the first value which is stripped of
   leading and trailing white space, and if it was a quoted string,
   also of the quotes.  Also, backslash-escaped characters in the
   quoted string are replaced by the values the escapes represent.
   *next points to either the start of the next value (i.e. after the
   separating comma, possibly to the leading white space of the next
   value), or to the trailing ] or NULL byte if this was the last
   value.
   msg is *not* a const string: it is altered by this function.
   The function returns true if the string was quoted.
*/
static int
unquote(char *msg, char **start, char **next)
{
	char *p = msg, *s;
	char quote;

	/* first skip over leading white space */
	while (*p && isspace((int) (unsigned char) *p))
		p++;
	quote = *p;
	if (quote == '\'' || quote == '"') {
		/* get quoted string and remove trailing bracket first */
		p++;
		*start = p;
		s = p;
		while (*p && *p != quote) {
			if (*p == '\\') {
				p++;
				switch (*p) {
					/* later
					   case '0': case '1': case '2': case '3': case '4':
					   case '5': case '6': case '7': case '8': case '9':
					 */
				case 'n':
					*s = '\n';
					break;
				case 't':
					*s = '\t';
					break;
				case 'r':
					*s = '\r';
					break;
				case 'f':
					*s = '\f';
					break;
				case '0':
				case '1':
				case '2':
				case '3':
					/* this could be the start of
					   an octal sequence, check it
					   out */
					if (p[1] && p[2] && p[1] >= '0' && p[1] <= '7' && p[2] >= '0' && p[2] <= '7') {
						*s = ((p[0] - '0') << 6) | ((p[1] - '0') << 3) | (p[2] - '0');
						p += 2;
						break;
					}
					/* fall through */
				default:
					*s = *p;
					break;
				}
				p++;
			} else {
				*s = *p++;
			}
			s++;
		}
		*s = 0;		/* close string */
		p++;		/* skip over end-of-string quote */
		/* skip over trailing junk (presumably white space) */
		while (*p && *p != ',' && *p != ']')
			p++;
		if (*p == ',')
			p++;
		*next = p;
		return 1;
	} else {
		/* p points at first non-white space character */
		*start = p;	/* record start of value */
		/* find separator or terminator */
		while (*p && *p != ',' && *p != '\t' && *p != ']')
			p++;
		/* search back over trailing white space */
		for (s = p - 1; s > *start && isspace((int) (unsigned char) *s); s--)
			;
		if (s < *start || !isspace((int) (unsigned char) *s))	/* gone one too far */
			s++;
		if (*p == ',' || *p == '\t') {
			/* there is more to come; skip over separator */
			p++;
		}
		/* make sure value is NULL terminated */
		/* If the value is the last one before ] and there is
		   no trailing white space, s points to the ']' which
		   now gets squashed.  However in this case p==s, so
		   *p will be 0 as well, and thus **next will be 0,
		   terminating the loop in our caller. */
		*s = 0;
		*next = p;
		return 0;
	}
}

@-
The (un)quote routines should use dynamic storage.
@c
char *
mapi_unquote(char *msg)
{
	char *start, *next;
	size_t size;

	unquote(msg, &start, &next);
	size = strlen(start);
	next = malloc(size + 1);
	strcpy(next, start);
	return next;
}

char *
mapi_quote(const char *msg, int size)
{
	char *s = malloc(strlen(msg) * 2 + 1);	/* we absolutely don't need more than this (until we start producing octal escapes */
	char *t = s;

	/* the condition is tricky: if initially size < 0, we must
	   continue until a NULL byte, else, size gives the number of
	   bytes to be copied */
	while (size < 0 ? *msg : size > 0) {
		if (size > 0)
			size--;
		switch (*msg) {
		case '\n':
			*t++ = '\\';
			*t++ = 'n';
			break;
		case '\t':
			*t++ = '\\';
			*t++ = 't';
			break;
		case PLACEHOLDER:
			*t++ = '\\';
			*t++ = PLACEHOLDER;
			break;
		case '\\':
			*t++ = '\\';
			*t++ = '\\';
			break;
		case '\0':
			*t++ = '\\';
			*t++ = '0';
			break;
		default:
			*t++ = *msg;
			break;
		}
		msg++;
		/* also deal with binaries */
	}
	*t = 0;
	return s;
}

@-
The low level routine mapi_slice_row breaks the last row received into pieces
and binds the field descriptors with their location. All escaped characters
are immediately replaced, such that we end with a list of C-strings.
It overwrites the contents of the row buffer, because de-escaping
only reduces the size.
It also silently extends the field descriptor table.
@c
@= extend
static int
mapi_extend_@1(MapiHdl hdl, int min@1)
{
	/* extend the @1 table */
	int nm = hdl->max@1 + 32;

	if (nm <= min@1)
		 nm = min@1 + 32;
	REALLOC(hdl->@1, nm);
	assert(hdl->@1);
	/* clear new entries */
	memset(hdl->@1 + hdl->max@1, 0, (nm - hdl->max@1) * sizeof(*hdl->@1));
	hdl->max@1 = nm;
	return MOK;
}
@c
@:extend(bindings)@
@:extend(params)@
@-
The values of a row are delivered to any bounded variable before
fetch_row returns. Automatic conversion based on common types
simplifies the work for the programmers.
@c
#if HAVE_STRTOF && !HAVE_DECL_STRTOF
extern float strtof(const char *, char **);
#endif
#if HAVE_STRTOLL && !HAVE_DECL_STRTOLL
extern long long strtoll(const char *, char **, int);
#endif
#if HAVE_STRTOLL && !HAVE_DECL_STRTOLL
extern unsigned long long strtoull(const char *, char **, int);
#endif

static MapiMsg
store_field(struct MapiResultSet *result, int cr, int fnr, int outtype, void *dst)
{
	char *val;

	val = result->cache.anchors[cr][fnr];

	if (val == 0) {
		return mapi_setError(result->hdl->mid, "Field value undefined or nil", "mapi_store_field", MERROR);
	}

	/* auto convert to C-type */
	switch (outtype) {
	case MAPI_TINY:
		*(signed char *) dst = (signed char) strtol(val, NULL, 0);
		break;
	case MAPI_UTINY:
		*(unsigned char *) dst = (unsigned char) strtoul(val, NULL, 0);
		break;
	case MAPI_SHORT:
		*(short *) dst = (short) strtol(val, NULL, 0);
		break;
	case MAPI_USHORT:
		*(unsigned short *) dst = (unsigned short) strtoul(val, NULL, 0);
		break;
	case MAPI_NUMERIC:
	case MAPI_INT:
		*(int *) dst = (int) strtol(val, NULL, 0);
		break;
	case MAPI_UINT:
		*(unsigned int *) dst = (unsigned int) strtoul(val, NULL, 0);
		break;
	case MAPI_LONG:
		*(long *) dst = strtol(val, NULL, 0);
		break;
	case MAPI_ULONG:
		*(unsigned long *) dst = strtoul(val, NULL, 0);
		break;
#ifdef HAVE_STRTOLL
	case MAPI_LONGLONG:
		*(mapi_int64 *) dst = strtoll(val, NULL, 0);
		break;
#endif
#ifdef HAVE_STRTOULL
	case MAPI_ULONGLONG:
		*(mapi_uint64 *) dst = strtoull(val, NULL, 0);
		break;
#endif
	case MAPI_CHAR:
		*(char *) dst = *val;
		break;
#ifdef HAVE_STRTOF
	case MAPI_FLOAT:
		*(float *) dst = strtof(val, NULL);
		break;
#endif
#ifdef HAVE_STRTOD
	case MAPI_DOUBLE:
		*(double *) dst = strtod(val, NULL);
		break;
#endif
	case MAPI_DATE:
		sscanf(val, "%hd-%hu-%hu", &((MapiDate *) dst)->year, &((MapiDate *) dst)->month, &((MapiDate *) dst)->day);
		break;
	case MAPI_TIME:
		sscanf(val, "%hu:%hu:%hu", &((MapiTime *) dst)->hour, &((MapiTime *) dst)->minute, &((MapiTime *) dst)->second);
		break;
	case MAPI_DATETIME:{
		int n;

		((MapiDateTime *) dst)->fraction = 0;
		sscanf(val, "%hd-%hu-%hu %hu:%hu:%hu%n", &((MapiDateTime *) dst)->year, &((MapiDateTime *) dst)->month, &((MapiDateTime *) dst)->day, &((MapiDateTime *) dst)->hour, &((MapiDateTime *) dst)->minute, &((MapiDateTime *) dst)->second, &n);
		if (val[n] == '.') {
			unsigned int fac = 1000000000;
			unsigned int nsec = 0;

			for (n++; isdigit((int) val[n]); n++) {
				fac /= 10;
				nsec += (val[n] - '0') * fac;
			}
			((MapiDateTime *) dst)->fraction = nsec;
		}
		break;
	}
	case MAPI_AUTO:
	case MAPI_VARCHAR:
	default:
		*(char **) dst = val;
	}
	return MOK;
}

MapiMsg
mapi_store_field(MapiHdl hdl, int fnr, int outtype, void *dst)
{
	struct MapiResultSet *result;

	mapi_hdl_check(hdl, "mapi_store_field");

	if ((result = hdl->result) == NULL) {
		return mapi_setError(hdl->mid, "No data read", "mapi_store_field", MERROR);
	}

	if (fnr < 0 || fnr >= result->fieldcnt) {
		return mapi_setError(hdl->mid, "Illegal field number", "mapi_store_field", MERROR);
	}

	return store_field(result, result->cache.reader, fnr, outtype, dst);
}

static void
mapi_store_bind(struct MapiResultSet *result, int cr)
{
	int i;
	MapiHdl hdl = result->hdl;

	for (i = 0; i < hdl->maxbindings; i++)
		if (hdl->bindings[i].outparam)
			store_field(result, cr, i, hdl->bindings[i].outtype, hdl->bindings[i].outparam);
}

static int
mapi_slice_row(struct MapiResultSet *result, int cr)
{
	char *p;
	int i = 0;

	p = result->cache.rows[cr];
	if (p == NULL)
		return mapi_setError(result->hdl->mid, "Current row missing", "mapi_slice_row", MERROR);
	if (result->cache.fldcnt[cr])
		return result->cache.fldcnt[cr];	/* already sliced */

	if (*p != '[') {
		/* nothing to slice */
		i = 1;
		REALLOC(result->cache.anchors[cr], 1);
		/* skip initial '=' if present */
		if (*p == '=')
			p++;
		result->cache.anchors[cr][0] = strdup(p);
	} else {
		/* work on a copy to preserve the original */
		p = strdup(p);
		i = slice_row(p, result->hdl->mid->languageId == LANG_SQL ? "NULL" : "nil", &result->cache.anchors[cr], result->fieldcnt);
		free(p);
	}
	if (i > result->fieldcnt) {
		result->fieldcnt = i;
		if (i > result->maxfields) {
			REALLOC(result->fields, i);
			memset(result->fields + result->maxfields, 0, (i - result->maxfields) * sizeof(*result->fields));
			result->maxfields = i;
		}
	}
	result->cache.fldcnt[cr] = i;
	return i;
}

@-
The rows presented are broken down into pieces to
simplify access later on.
@c
int
mapi_fetch_row(MapiHdl hdl)
{
	char *reply;
	int n;
	struct MapiResultSet *result;

	mapi_hdl_check(hdl, "mapi_fetch_row");
	do {
		if ((reply = mapi_fetch_line(hdl)) == NULL)
			return 0;
	} while (*reply != '[' && *reply != '=');
	result = hdl->result;
	assert(result != NULL);
	if ((n = result->cache.fldcnt[result->cache.reader]) == 0) {
		n = mapi_slice_row(result, result->cache.reader);
		/* no need to call mapi_store_bind since
		   mapi_fetch_line would have done that if needed */
	}
	return n;
}

@-
All rows can be cached first as well.
@c
int
mapi_fetch_all_rows(MapiHdl hdl)
{
	Mapi mid;
	struct MapiResultSet *result;

	mapi_hdl_check(hdl, "mapi_fetch_all_rows");

	mid = hdl->mid;
	for (;;) {
		if ((result = hdl->result) != NULL && mid->languageId == LANG_SQL && mid->active == NULL && result->row_count > 0 && result->cache.first + result->cache.tuplecount < result->row_count) {
			mid->active = hdl;
			hdl->active = result;
			if (stream_printf(mid->to, "X" "export %d %d\n", result->tableid, result->cache.first + result->cache.tuplecount) < 0 || stream_flush(mid->to))
				check_stream(mid, mid->to, stream_error(mid->to), "mapi_fetch_line", 0);
		}
		if (mid->active)
			read_into_cache(mid->active, 0);
		else
			break;
	}
	return result ? result->cache.tuplecount : 0;
}

char *
mapi_fetch_field(MapiHdl hdl, int fnr)
{
	int cr;
	struct MapiResultSet *result;

	mapi_hdl_check0(hdl, "mapi_fetch_field");

	if ((result = hdl->result) == NULL ||
	    (cr = result->cache.reader) < 0 ||
	    (result->cache.rows[cr][0] != '[' &&
	     result->cache.rows[cr][0] != '=')) {
		mapi_setError(hdl->mid, "Must do a successful mapi_fetch_row first", "mapi_fetch_field", MERROR);
		return 0;
	}
	assert(result->cache.fldcnt != NULL);
	if (fnr >= 0) {
		/* slice if needed */
		if (result->cache.fldcnt[cr] == 0)
			mapi_slice_row(result, cr);
		if (fnr < result->cache.fldcnt[cr])
			return result->cache.anchors[cr][fnr];
	}
	mapi_setError(hdl->mid, "Illegal field number", "mapi_fetch_field", MERROR);
	return 0;
}

char **
mapi_fetch_field_array(MapiHdl hdl)
{
	int cr;
	struct MapiResultSet *result;

	mapi_hdl_check0(hdl, "mapi_fetch_field_array");

	if ((result = hdl->result) == NULL || (cr = result->cache.reader) < 0) {
		mapi_setError(hdl->mid, "Must do a successful mapi_fetch_row first", "mapi_fetch_field_array", MERROR);
		return 0;
	}
	assert(result->cache.fldcnt != NULL);
	/* slice if needed */
	if (result->cache.fldcnt[cr] == 0)
		mapi_slice_row(result, cr);
	return result->cache.anchors[cr];
}

int
mapi_get_field_count(MapiHdl hdl)
{
	mapi_hdl_check(hdl, "mapi_get_field_count");
	if (hdl->result && hdl->result->fieldcnt == 0) {
		/* no rows have been sliced yet, and there was no
		   header, so try to figure out how many columns there
		   are for ourselves */
		int i;

		for (i = 0; i < hdl->result->cache.writer; i++)
			if (hdl->result->cache.rows[i][0] == '[' ||
			    hdl->result->cache.rows[i][0] == '=')
				mapi_slice_row(hdl->result, i);
	}
	return hdl->result ? hdl->result->fieldcnt : 0;
}

int
mapi_get_row_count(MapiHdl hdl)
{
	mapi_hdl_check(hdl, "mapi_get_row_count");
	return hdl->result ? hdl->result->row_count : 0;
}

char *
mapi_get_name(MapiHdl hdl, int fnr)
{
	struct MapiResultSet *result;

	mapi_hdl_check0(hdl, "mapi_get_name");
	if ((result = hdl->result) != 0 && fnr >= 0 && fnr < result->fieldcnt)
		return result->fields[fnr].columnname;
	mapi_setError(hdl->mid, "Illegal field number", "mapi_get_name", MERROR);
	return 0;
}

char *
mapi_get_type(MapiHdl hdl, int fnr)
{
	struct MapiResultSet *result;

	mapi_hdl_check0(hdl, "mapi_get_type");
	if ((result = hdl->result) != 0 && fnr >= 0 && fnr < result->fieldcnt) {
		if (result->fields[fnr].columntype == NULL)
			return "unknown";
		return result->fields[fnr].columntype;
	}
	mapi_setError(hdl->mid, "Illegal field number", "mapi_get_type", MERROR);
	return 0;
}

char *
mapi_get_table(MapiHdl hdl, int fnr)
{
	struct MapiResultSet *result;

	mapi_hdl_check0(hdl, "mapi_get_table");
	if ((result = hdl->result) != 0 && fnr >= 0 && fnr < result->fieldcnt)
		return result->fields[fnr].tablename;
	mapi_setError(hdl->mid, "Illegal field number", "mapi_get_table", MERROR);
	return 0;
}

int
mapi_get_len(MapiHdl hdl, int fnr)
{
	struct MapiResultSet *result;

	mapi_hdl_check0(hdl, "mapi_get_len");
	if ((result = hdl->result) != 0 && fnr >= 0 && fnr < result->fieldcnt)
		return result->fields[fnr].columnlength;
	mapi_setError(hdl->mid, "Illegal field number", "mapi_get_len", MERROR);
	return 0;
}

int
mapi_get_querytype(MapiHdl hdl)
{
	struct MapiResultSet *result;

	mapi_hdl_check0(hdl, "mapi_get_querytype");
	if ((result = hdl->result) != 0)
		return result->querytype;
	mapi_setError(hdl->mid, "No query result", "mapi_get_querytype", MERROR);
	return 0;
}

int
mapi_get_tableid(MapiHdl hdl)
{
	struct MapiResultSet *result;

	mapi_hdl_check0(hdl, "mapi_get_tableid");
	if ((result = hdl->result) != 0)
		return result->tableid;
	mapi_setError(hdl->mid, "No query result", "mapi_get_tableid", MERROR);
	return 0;
}

int
mapi_rows_affected(MapiHdl hdl)
{
	struct MapiResultSet *result;

	mapi_hdl_check(hdl, "mapi_rows_affected");
	if ((result = hdl->result) == NULL)
		return 0;
	if (result->querytype == Q_UPDATE) {
		int i;

		for (i = 0; result->cache.rows[i][0] != '[' && result->cache.rows[i][0] != '='; i++)
			;
		if (result->cache.fldcnt[i] == 0)
			mapi_slice_row(result, i);
		return atoi(result->cache.anchors[i][0]);
	}
	return result->row_count;
}

char *
mapi_get_dbname(Mapi mid)
{
	mapi_check0(mid, "mapi_get_dbname");
	return mid->database ? mid->database : "";
}

char *
mapi_get_host(Mapi mid)
{
	mapi_check0(mid, "mapi_get_host");
	return mid->hostname;
}

char *
mapi_get_user(Mapi mid)
{
	mapi_check0(mid, "mapi_get_user");
	return mid->username;
}

char *
mapi_get_lang(Mapi mid)
{
	mapi_check0(mid, "mapi_get_lang");
	return mid->language;
}

char *
mapi_get_mapi_version(Mapi mid)
{
	mapi_check0(mid, "mapi_get_mapi_version");
	return mid->mapiversion;
}

char *
mapi_get_monet_version(Mapi mid)
{
	mapi_check0(mid, "mapi_get_monet_version");
	return mid->server ? mid->server : "";
}

int
mapi_get_monet_versionId(Mapi mid)
{
	mapi_check0(mid, "mapi_get_monet_versionId");
	return mid->versionId;
}

char *
mapi_get_motd(Mapi mid)
{
	mapi_check0(mid, "mapi_get_motd");
	return mid->motd;
}

int
mapi_is_blocked(Mapi mid)
{
	mapi_check0(mid, "mapi_is_blocked");
	return mid->blocked;
}

int
mapi_is_connected(Mapi mid)
{
	return mid->connected;
}

@}
