@f mapi
@a N.J. Nes P. Boncz
@t Monets Simple Internet Interface
@v 1.1

This module contains a simple interface for internet connections.

@m
.MODULE mapi;

.COMMAND listen()  = MAPIlisten_default;
	"start a Mapi server with the default port number."
.COMMAND listen(int port, int maxusers) = MAPIlisten; 
	"start a Mapi server."

.END mapi;

@h
#ifndef MAPI_H
#define MAPI_H

#define MAPIPORT	50000
#define MAPIMAXUSERS 	5
/* #include <mapi.proto.h>*/

#endif /* MAPI_H */
@c
#include "mapi.h"
#include <monet.h>
#include  <sys/types.h> 
#include  <sys/socket.h> 

#define SOCKPTR struct sockaddr *

int MAPIlisten(int *port, int *maxusers){
	struct sockaddr_in server;
	int 	sock;
#ifdef AIX
	size_t 	length;
#else
	int 	length;
#endif
	int    	on = 1;
	int 	msgsock;
	int	i = 0;

	sock = socket(AF_INET, SOCK_STREAM, 0);
	if (sock < 0) {
		GDKsyserror("creation of stream socket failed\n");
		return GDK_FAIL;
	}
@-
Set server port and allow internet connections from any workstation.
Bind the socket to the server port.
The port id should be obtained from the Homes file.
@c
	if (*port == 0)
		*port = MAPIPORT;
	server.sin_family = AF_INET;
	server.sin_addr.s_addr = INADDR_ANY;
	server.sin_port = htons((unsigned short)((*port)&0xFFFF));
   	for (i=0;i<8;i++)
	    server.sin_zero[i]=0;
 
	setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (char*) &on, sizeof on);

	length = sizeof(server);
	if (bind(sock, (SOCKPTR)&server, length) < 0) {
		GDKsyserror("binding to stream socket (%d) failed\n", *port);
		return GDK_FAIL;
	}
@-
Get the new information for the server socket and start listening.
@c
	if (getsockname(sock, (SOCKPTR)&server, &length) < 0) {
		GDKsyserror("getting socket name\n");
		return GDK_FAIL;
	}
	listen(sock, *maxusers); 

	PARDEBUG {
		THRprintf(GDKerr, "Internet started at %d\n", server.sin_port);
	}
	do {
#ifdef AIX
       		msgsock = accept(sock, 0, (size_t)0);
#else
       		msgsock = accept(sock, 0, (int *)0);
#endif

		if (msgsock == -1) {
			if (MT_geterrno() != EINTR) {
				GDKsyserror("monetServer: accept failed\n");
				return GDK_FAIL;
	    		}
		} else if (msgsock > 0) {
			int i;
			char *name = (char*) alloca(BUFSIZ), *user = name;
			FILE *fdin = fdopen(msgsock, "r");
			FILE *fdout = fdopen(msgsock, "w");

			if (fdin == 0){
				GDKsyserror("monetServer: fdin problems\n");
				continue;
			}
			if (fdout == 0){
				GDKsyserror("monetServer: fdout problems\n");
				continue;
			}
			/* get user name */
			for(i=0, *user=fgetc(fdin); i<BUFSIZ && *user != '\n'; i++){
				user++;
				*user = fgetc(fdin);
			}
			*user = 0;
			fprintf(stderr,"create a client context \n");
			if (0 == 0) {
				fprintf(fdout, "Failed to init client for user %s\n", name );
				fflush(fdout);
				(void) fclose(fdin);
				(void) fclose(fdout);
				close(msgsock);
				continue;
			}
		}
	} while (1);
	return GDK_SUCCEED;
}

int MAPIlisten_default(){
	int port = MAPIPORT;
	int maxusers = MAPIMAXUSERS;
	return MAPIlisten(&port, &maxusers);
}


@mil
module(unix,str,mapi);

proc get_mapi_port() := {
	var mapi_port := getenv("MAPIPORT");
	var port := 0;
	var p := search( mapi_port, ":" );
	if (p >= 0){
		port := int(string(mapi_port, p+1));
	} else {
		mapi_port := getenv("MONETPORT");
		p := search( mapi_port, ":" );
		if (p >= 0){
			port := int(string(mapi_port, p+1));
		}
	}
	return port;
}
fork(listen(get_mapi_port(),5));
