@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f monet_tbl
@a Peter Boncz, Jonas S Karlsson, Niels J Nes
@v 2.0
@t Function Table and Module Management
@* Introduction
The dictionary maintained by Monet is geared towards administration of the
functions, atomary types and modules.

The information on modules is stored in a system global area.
Upon start of a server session its contents is obtained for use.
No concurrency control is currently applied to the module database.

This code is heavily used to map identifiers to internal values and
vice versa. 
@h
#ifndef _MONET_TBL_H
#define _MONET_TBL_H

#include <assert.h>

#define BUNtailfnd(tp,  bt, bn, vl)	((bn=BUNfnd(bt, vl))?(tp *) BUNtail(bt,bn):0)

#ifdef __cplusplus
extern "C" {
#endif

/* Generic initialization/cleanup routines */
m_export void  TBL_init(void);
m_export void  TBL_protect();
m_export void  TBL_initclient(Client c, Client father);
m_export void  TBL_exitclient(Client c);

m_export void  TBL_newproc(Client c, str nme, str mod, YYSTREE body, YYSTREE sig, YYSTREE ret);
m_export void  TBL_delproc(Client client, str nme);

m_export int   TBL_M_client_install(Client client, oid mid);
m_export int   TBL_M_incref(Client client, oid mid);

/* old info functions */
m_export ptr   TBL_unpacked(ptr imp);
m_export char* TBL_search(str name, int *t, int guess_if_notfound, int cur_is_ident, int no_command, int next_is_ident);
m_export str   TBL_getname(ptr imp);
m_export str   TBL_fndname(ptr imp);
m_export int   TBL_getparams(ptr imp, str argv[]);
m_export BAT*  TBL_getdir(void);
m_export char* TBL_atomname(int atm);
m_export void  TBL_printsigs(str s, int stk, str nme);
m_export int   TBL_formatsig(str s, oid fid);
m_export int   TBL_procreturn(int argc, ValPtr argv, ValPtr res, YYSTREE t);
m_export void* TBL_iterator(Cntxt stk, str name, int argc, ValPtr argv);
m_export oid   TBL_loadmod(Client client, str module, str parmod, int level, str *initstr);
m_export int   TBL_unloadmod(Client client, str module, int level);

m_export BAT *TBL_fcn_nme;
m_export BAT *TBL_fcn_fcn;
m_export BAT *TBL_fcn_mid;
m_export BAT *TBL_fcn_imp;
m_export BAT *TBL_fcn_tpe;
m_export BAT *TBL_fcn_sig;
m_export BAT *TBL_fcn_dsc;
m_export BAT *TBL_fcn_aut;
m_export BAT *TBL_fcn_dat;
m_export BAT *TBL_fcn_pro;
m_export BAT *TBL_fcn_cnt;
m_export BAT *TBL_mod_nme;
m_export BAT *TBL_mod_cnt;
m_export BAT *TBL_mod_hdl;
m_export BAT *TBL_mod_atm;
m_export BAT *TBL_mod_acc;
m_export BAT *TBL_mod_dep;
m_export BAT *TBL_mod_use;
m_export BAT *TBL_mod_load;
m_export BAT *TBL_mod_drop;
m_export BAT *TBL_mod_proc;
m_export BAT *TBL_mod_var;

m_export ptr TBL_module_handle(oid);
m_export oid TBL_module_lookup(str);
m_export void *DL_sym(void *, const char *);
@
Declarations of Installing interface for modules.
@h
typedef struct TBLinstall_t {
	Client	client;
	str *	initstr;
	int	level;
	oid	curmid;
} TBLinstall;

m_export void
TBL_Install_Depend( TBLinstall *i, /* Passed on from "module"_Install */
   oid mid,
   str user, /* Passed on from TBL_Install */
   str name);

m_export oid /* An oid is generated */
TBL_Install_Info( TBLinstall *i, /* Passed on from "module"_Install */
  str owner,
  str name);

m_export void
TBL_Install_Atom(
  oid mid,
  str name,
  int size,	/* 0 == not fixed size */
  int align);	/* 0 == not fixed size */

m_export void
TBL_Install_Accelerator(
  oid mid,
  str name);

m_export void TBL_Install_DropRefs(oid mid, bat* batrefs);

/* I think the types from parsing are only availiable as strings
   so we better input them as such */

void 
TBL_Deinstall_Function(
  oid pid);

typedef struct TBLfcn_t {
   	str name;
	int token;
	ptr fcn;
	ptr unpack;
	ptr check;
	ptr oldsig;
	str help;
	str args[MAXPARAMS];
	str res;
} TBLfcn;

m_export void TBL_Install_Functions( oid mid, TBLfcn *fcns, str user, str date );
/* install all functions for the given module */

m_export oid /* An oid is generated */
TBL_Install_Function(
  oid mid,
  str name,
  int tpe, /* some sort of type? fcn_table[i].token */
  ptr orig, ptr pack_imp, ptr type_imp, /* functionpointers! */
  str signature,
  str help,
  str author,
  str date);

m_export void TBL_Install_Function_Vararg( /* Called after _Function */
  oid fid,
  str tpe);

@- function arguments
This one would have to be called several times, once for each argument 
@h
m_export void TBL_Install_Function_Arg( /* Called after _Function / _Vararg */
  oid fid,
  str tpe);

m_export void TBL_Install_Function_Res( /* After _Arg */
  oid fid,
  str tpe);

m_export void TBL_Install_MilVar(Client client, str mod, ptr v);

@- function resolution
@h
#define TBL_RESOLVE_NOFCN (-3) /* no function with this name and # params exists */
#define TBL_RESOLVE_NOSIG (-2) /* no function with this exact signature exists */
#define TBL_RESOLVE_NOTPE (-1) /* actual parameters contain illegal (no-loaded) type */

m_export int 
TBL_normal_resolve(
  str name, 
  int argc, 
  ValPtr Argv, 
  monet_sig_t *sig, 
  Cntxt stk);

m_export int 
TBL_multiplex_resolve(
  str name,
  int argc,
  ValPtr Argv,
  monet_sig_t *sig,
  Cntxt stk);

m_export int 
TBL_setaggr_resolve(
  str name,
  int argc, 
  ValPtr Argv, 
  monet_sig_t *sig,
  Cntxt stk);

@c
#include "monet.h"
#include "searchpath.h"

#include <stdio.h>
#include <string.h>

#define dlPRINT(text)	DLDEBUG	THRprintf(GDKerr, text)
#define dlFPRINTF	DLDEBUG	THRprintf

#define WARNING(s1,	s2)	GDKwarning((s1),(s2));
#define FATAL(x,	y) 	GDKfatal((x),(y));

#define ERROR(progname,	filename, lineno) { THRprintf(GDKerr, "Mserver: "); }

static void TBL_Insert_Depend( oid mid, str name );

BAT *TBL_fcn_nme = NULL;  /* BAT(oid, str): (function name, FID). */
BAT *TBL_fcn_fcn = NULL;  /* BAT(oid, ptr): (FID, implementation fcn). */
BAT *TBL_fcn_mid = NULL;  /* BAT(oid, oid): (FID, MID). */
BAT *TBL_fcn_imp = NULL;  /* BAT(oid, ptr): (FID, packed implementation) */
BAT *TBL_fcn_tpe = NULL;  /* BAT(oid, int): (FID, token). */
BAT *TBL_fcn_sig = NULL;  /* BAT(oid, str): (FID, fcn signature text). */
BAT *TBL_fcn_dsc = NULL;  /* BAT(oid, str): (FID, fcn description text). */
BAT *TBL_fcn_aut = NULL;  /* BAT(oid, str): (FID, fcn author name). */
BAT *TBL_fcn_dat = NULL;  /* BAT(oid, str): (FID, fcn creation date). */
BAT *TBL_fcn_pro = NULL;  /* BAT(oid, str): (FID, type sequence). */
BAT *TBL_fcn_cnt = NULL;  /* BAT(oid, int): (FID, reference count (procs)). */
BAT *TBL_mod_nme = NULL;  /* BAT(oid, str): (MID, module name).	*/
BAT *TBL_mod_cnt = NULL;  /* BAT(oid, int): (MID, reference count). */
BAT *TBL_mod_hdl = NULL;  /* BAT(oid, ptr): (MID, OS dynlink handle). */
BAT *TBL_mod_atm = NULL;  /* BAT(oid, str): (MID, atom name). */
BAT *TBL_mod_acc = NULL;  /* BAT(oid, str): (MID, accelerator name). */
BAT *TBL_mod_dep = NULL;  /* BAT(oid, str): (MID, depends-of module name). */
BAT *TBL_mod_use = NULL;  /* BAT(oid, int): (which clients use a mod). */
BAT *TBL_mod_load = NULL; /* BAT(oid, str): (MID, mil-script). */
BAT *TBL_mod_drop = NULL; /* BAT(oid, int): (MID, batid). */
BAT *TBL_mod_proc = NULL; /* BAT(str, oid): (modname, oid). */
BAT *TBL_mod_var = NULL; /* BAT(str, ptr): (modname, ptr). */

oid 	TBL_top_mid;
MT_Lock TBL_protector, TBL_writelock;
MT_Sema TBL_barrier;
int     TBL_readers = 0, TBL_writer = 0;

@- read-write locking
@T
The function tables are concurrently read by the parser and (multiple)
interpreter threads. When modules are loaded/dropped or procedures 
defined, the parser thread may also write these tables. 

Reading is much more frequent than writing, and as interpreter
threads do this possibly in parallel, we first used a read-write locking
scheme that permits either one writer or multiple readers.
\begin{verbatim}
set_readlock
	lock(protector)
	if (nreaders++ == 0) set_writelock()
	unlock(protector)
unset_readlock
	lock(protector)
	if (--nreaders == 0) unset_writelock()
	unlock(protector)
set_writelock
	sema_down(barrier);
unset_writelock
	sema_up(barrier);
\end{verbatim}
In this approach, the probability that a reader had to set the semaphore was 
almost 100\%. Given the fact that locks are much cheaper than semaphores (on NT),
we switched an {\bf optimized} locking scheme, in which read-only access only
uses mutex locking.
\begin{verbatim}
set_readlock
	lock(writelock)
	lock(protector)
	nreaders++
	unlock(protector)
	unlock(writelock)
unset_readlock
	lock(protector)
	if (--nreaders == 0 and wr_waiting) sema_up(barrier);
	unlock(protector)
set_writelock
	lock(writelock)
	lock(protector)
	wr_waiting = (nreaders > 0);
	unlock(protector)
	if (wr_waiting) sema_down(barrier);
unset_writelock
	wr_waiting = 0;
	unlock(writelock)
\end{verbatim}
In a nutshell: there is a global writelock ('writelock') that stops 
readers from entering when there is a writer. If the readers are first,
an entering writer goes to sleep on a semaphore ('barrier') and is woken
up by the last reader. Crucial counter variables are protected by a 
short-term lock ('protector').
@c
#define TBL_set_readlock() {					\
    monet_set_lock(TBL_writelock, "TBL_set_readlock(writelock)");	\
    monet_set_lock(TBL_protector, "TBL_set_readlock(protector)");	\
    TBL_readers++;						\
    monet_unset_lock(TBL_protector, "TBL_set_readlock(protector)");\
    monet_unset_lock(TBL_writelock, "TBL_set_readlock(writelock)");}
#define TBL_unset_readlock() {					\
    monet_set_lock(TBL_protector, "TBL_unset_readlock(protector)");\
    if (--TBL_readers == 0 && TBL_writer) 			\
		monet_up_sema(TBL_barrier, "TBL_unset_readlock");	\
    monet_unset_lock(TBL_protector, "TBL_unset_readlock(protector)");	}
#define TBL_set_writelock() {					\
    monet_set_lock(TBL_writelock, "TBL_set_writelock(writelock)");	\
    monet_set_lock(TBL_protector, "TBL_set_writelock(protector)");	\
    TBL_writer = TBL_readers;					\
    monet_unset_lock(TBL_protector, "TBL_set_writelock(protector)");\
    if (TBL_writer) 						\
	monet_down_sema(TBL_barrier, "TBL_set_writelock");		}
#define TBL_unset_writelock() {					\
    monet_set_lock(TBL_protector, "TBL_unset_writelock(protector)");	\
    TBL_writer = 0;						\
    monet_unset_lock(TBL_protector, "TBL_unset_writelock(protector)");\
    monet_unset_lock(TBL_writelock, "TBL_unset_writelock");	}


@+ Dynamic Loading  

@- Module Filename Convention 
The file is assumed to be in directory: module_dir (set to
$PREFIX/lib/ ?)  The file is assumed to have either of these file
names, searched in the following order; <module>-<database>_<user>.so,
<module>-<database>.so, <module>_<user>.so, <module>.soo .

The function returns the dlopen handle (!=0) if the module existed. If
there is no initfunction a library is loaded nothing more should be
done. In case there is a initfunction we call it.  This function will
install the functions etc..

@- Module Loading Interface 
The DL_ interface offers a UNIX dl* 'dynamic loading'-like interface
that can either be implemented using dynamic loading or with static 
loading. In case of static loading, libs and functions should first
be registered with the DL_register_* functions.
@h
m_export void*	DL_reglib(str path, void* dynamic_handle, int maxsize);
m_export int	DL_regfcn(void* tbl, ptr fcnptr, str name);

#ifdef __cplusplus
}
#endif
#endif /* _MONET_TBL_H */
@c
#ifndef STATIC

#ifdef HAVE_DLFCN_H
# include <dlfcn.h>
#endif

#else

#define RTLD_LAZY	1       
#define RTLD_NOW	2       
#define RTLD_GLOBAL	4       
#define RTLD_NOW_REPORT_ERROR	8

#endif

#define DL_TABLE_MAXLIBS 128

typedef struct {
	str		name;
	ptr		value;
} dlentry;

typedef struct {
	void*		dynamic_handle;
	int		size;
	dlentry		entry[1]; /* extended to just the right length */
} dltable;

int	 DL_errno = 0;
#ifndef STATIC
static const char *DL_errmsg;
#endif
str	 DL_mod[DL_TABLE_MAXLIBS] = { 0 };
dltable* DL_table[DL_TABLE_MAXLIBS] = { 0 };

void *DL_reglib(str nme, void* dynamic_handle, int maxsize) {
	int i;

	for(i=0; i<DL_TABLE_MAXLIBS; i++)  
	    if (DL_mod[i] == NULL) {
		dltable* tbl = (dltable*) 
			GDKmalloc(sizeof(dltable)+(maxsize-1)*sizeof(dlentry));
		DL_mod[i] = GDKstrdup(nme);
		DL_table[i] = tbl; 
		tbl->dynamic_handle = dynamic_handle;
		tbl->size = 0;
		return tbl;
	    }
	GDKfatal("DL_reglib: too many libs");
	return NULL;
}

int DL_regfcn(void* handle, ptr fcnptr, str name) {
	dltable *tbl = (dltable*) handle;
	tbl->entry[tbl->size].value = fcnptr;
	tbl->entry[tbl->size++].name = GDKstrdup(name);
	return 0;
}


void* DL_open(char* nme, int mode) { 
	dltable* tbl = NULL;
	int i;

	DL_errno = 0;
#ifndef STATIC
	DL_errmsg = NULL;

/* AIX requires RTLD_MEMBER to load a module that is a member of an archive.  */
#ifdef RTLD_MEMBER
        mode |= RTLD_MEMBER;
#endif
#endif
	for(i=0; i<DL_TABLE_MAXLIBS; i++) 
		if (DL_mod[i] && strcmp(DL_mod[i], nme) == 0) {
			tbl = DL_table[i];
		}

	if (tbl == NULL) {
#ifndef STATIC
		char *fullname;
		if ((fullname = MSP_locate_module(nme)) != NULL) {
			void *hdl;
			if ((hdl = dlopen(fullname, mode)) != NULL) {
				tbl = (dltable*) DL_reglib(nme, hdl, 0);
			} else {
				int en = errno;
    				GDKerror("DL_open: dlopen(%s,%d) -> Error #%d: %s.\n", fullname, mode, en, strerror(en));
				DL_errmsg = dlerror();
			}
			GDKfree(fullname);
		} else
			DL_errmsg = "library not found";
#else 
		(void) mode;
		DL_errno = 1;
#endif
	}
	return (void*) tbl; 
}

void* DL_sym(void* handle, const char *nme) { 
	dltable *tbl = (dltable*) handle;
	int i;

	DL_errno = 0;
#ifndef STATIC
	if (tbl->dynamic_handle) {
		return dlsym(tbl->dynamic_handle, nme);
	}
#endif
	for(i=0; i<tbl->size; i++) {
		if (strcmp(tbl->entry[i].name, nme) == 0) {
			return (void*) tbl->entry[i].value;
		}
	}
	DL_errno = 2;
	return NULL; 
}


int DL_close(void *handle) { 
	int ret = 0;
#ifndef STATIC
	dltable* tbl = (dltable*) handle;
	int i;
	if (tbl->dynamic_handle) {
		ret = dlclose(tbl->dynamic_handle);
		for(i=0; i<DL_TABLE_MAXLIBS; i++) {
			if (DL_table[i] == tbl) {
				GDKfree(DL_mod[i]);
				DL_table[i] = NULL;
				DL_mod[i] = NULL;
			}
		}
		GDKfree(tbl);
	}
#else
	(void) handle;
#endif
	return ret; 
}


static short_str DL_errormsg[3] =
	{ "no error occured (STATIC)", "library not found (STATIC)", 
          "function name unknown (STATIC)" };


const char *DL_error(void) { 
#ifndef STATIC
	if (DL_errmsg != NULL)
		return DL_errmsg;
	if (DL_errno == 0) return dlerror();
#endif
	return DL_errormsg[DL_errno]; 
}


ptr TBL_openmod(Client client, str module) {
    ptr ret=0;
    (void) client;
    if (module) {      
        ret=(ptr)DL_open(module, (RTLD_NOW|RTLD_GLOBAL));
    } else {
            if (!ret) GDKerror("TBL_openmod: locate module: %s.\n", module);
            return 0;
    }

    if (!ret) GDKerror("TBL_openmod: DL_open: %s.\n", DL_error());
    return ret; /* none found */
}


ptr TBL_module_handle(oid mid) {
  char *p;
  return (p=BUNfnd(TBL_mod_hdl, &mid))?*(int**)BUNtloc(TBL_mod_hdl,p):0;
}


oid TBL_module_lookup(str module) {
  BUN bun; /* stupid temp storage? */
  oid * midp = BUNtailfnd(oid, BATmirror(TBL_mod_nme), bun, module);

  return midp?*midp:0;
}

int TBL_M_cinstalled(Client client, oid mid) {
  int cid = client - monet_clients;
  return (!!(BUNlocate(BATmirror(TBL_mod_use), &cid, &mid)));
}

#define BATfakeAbort(b)	((b) && ((b)->batInserted = BUNfirst(b)))

int TBL_M_lock(Client c) {
  dlPRINT("  -->TBL_M_lock\n");
  TBL_set_writelock();
  BATfakeAbort(TBL_fcn_nme);
  BATfakeAbort(TBL_fcn_fcn);
  BATfakeAbort(TBL_fcn_mid);
  BATfakeAbort(TBL_fcn_imp);
  BATfakeAbort(TBL_fcn_tpe);
  BATfakeAbort(TBL_fcn_sig);
  BATfakeAbort(TBL_fcn_dsc);
  BATfakeAbort(TBL_fcn_aut);
  BATfakeAbort(TBL_fcn_dat);
  BATfakeAbort(TBL_fcn_pro);
  BATfakeAbort(TBL_fcn_cnt);
  BATfakeAbort(TBL_mod_nme);
  BATfakeAbort(TBL_mod_cnt);
  BATfakeAbort(TBL_mod_hdl);
  BATfakeAbort(TBL_mod_atm);
  BATfakeAbort(TBL_mod_acc);
  BATfakeAbort(TBL_mod_dep);
  BATfakeAbort(TBL_mod_use);
  BATfakeAbort(TBL_mod_load);
  BATfakeAbort(TBL_mod_drop);
  BATfakeAbort(TBL_mod_proc);
  BATfakeAbort(TBL_mod_var);
  if (c != NULL) {
	BATfakeAbort(c->acctbl);
	BATfakeAbort(c->atomtbl);
  }
  dlPRINT("  <--TBL_M_lock\n");
  return 1;
}

int TBL_M_unlock(Client c) {
  dlPRINT("  -->TBL_M_unlock\n");
  BATfakeCommit(TBL_fcn_nme);
  BATfakeCommit(TBL_fcn_fcn);
  BATfakeCommit(TBL_fcn_mid);
  BATfakeCommit(TBL_fcn_imp);
  BATfakeCommit(TBL_fcn_tpe);
  BATfakeCommit(TBL_fcn_sig);
  BATfakeCommit(TBL_fcn_dsc);
  BATfakeCommit(TBL_fcn_aut);
  BATfakeCommit(TBL_fcn_dat);
  BATfakeCommit(TBL_fcn_pro);
  BATfakeCommit(TBL_fcn_cnt);
  BATfakeCommit(TBL_mod_nme);
  BATfakeCommit(TBL_mod_cnt);
  BATfakeCommit(TBL_mod_hdl);
  BATfakeCommit(TBL_mod_atm);
  BATfakeCommit(TBL_mod_acc);
  BATfakeCommit(TBL_mod_dep);
  BATfakeCommit(TBL_mod_use);
  BATfakeCommit(TBL_mod_load);
  BATfakeCommit(TBL_mod_drop);
  BATfakeCommit(TBL_mod_proc);
  BATfakeCommit(TBL_mod_var);
  if (c) {
    if (BATdirty(c->fcntbl)) {
	/* Restore correct hash-list order for function resolution..
	 * (1) order on oid => have functions in order of definition
	 * (2) then rehash => last-defined first in hash-list
	 */
	BATorder(BATmirror(c->fcntbl));
	if (BATprepareHash(c->fcntbl)) assert(0);	
    	BATfakeCommit(c->fcntbl);
    }
    BATfakeCommit(c->acctbl);
    BATfakeCommit(c->atomtbl);
  }
  TBL_unset_writelock();
  dlPRINT("  <--TBL_M_unlock\n");
  return 1;
}


@+ Misc Information Functions
@- TBL_unpacked
Return the implementation routine hidden behind its pack function.
@c
ptr TBL_unpacked(ptr imp) {
	BAT 	*b = BATmirror(TBL_fcn_imp);
	BUN	bun;
	oid	*fid;
	ptr* 	s=0;

	TBL_set_readlock();
	fid = BUNtailfnd(oid, b, bun, &imp);   
	if (fid) s = BUNtailfnd(ptr, TBL_fcn_fcn, bun, fid);
	TBL_unset_readlock();
	return (s)?*s:0;
}

@- TBL_getparams
We have info registered about the function prototype of each
implementation. Normally, this is hidden by the _chk and _pack
routines. The information is kept for those who want to use the
unpacked implementations directly (for optimization purposes).
@c
static int getparams(oid fid, str argv[]) {
	str *s = argv, *t = s;
	hash_t i;
	int j = 0;
	BUN p;

	if (BATprepareHash(TBL_fcn_pro)) assert(0);	
	HASHloop_oid(TBL_fcn_pro, TBL_fcn_pro->hhash, i, &fid, p) {
		*(t++) = (str) BUNtvar(TBL_fcn_pro, p); 
		j++;
	}
	while(++s < --t) {
		str swap = *s;
		*s = *t; *t = swap;
	}
	return j;
}

int TBL_getparams(ptr imp, str argv[]) {
	BAT *b = BATmirror(TBL_fcn_imp);
	BUN p;
	int nparams;

	TBL_set_readlock();
	nparams = getparams(*BUNtailfnd(oid, b, p, &imp), argv);
	TBL_unset_readlock();

	return nparams;
}

@- TBL_checkparams
@T
This routine checks whether a set of actual parameters make a match 
with the signature of a certain registered MIL operator. Signatures
are registered in the {\tt monet\_fcn\_pro} system BAT, which
contains function oids and strings. This BAT contains sequences
of the same OIDS. 

The sequence of strings in the tail contains the
successive parameters of the operator. The first string identifies the
return type, the second identifies the first parameter type, the third
its second parameter, etc.

The types are denoted by their usual MIL atomic type name. BATs are
spelled in lowercase, concatenated by two (comma separated) types for 
their head and tail (enclosed by square brackets). For instance
'bat[oid,flt]' identifies a BAT withs OIDs in the head and floats
in the tail. Wildcard types are denoted with 'any', and -- like in MEL --
free type variables with 'any::<NUM>'. Finally, there is now support
for constant values to be used in overloading like 'str(inbox)'. This
identifies a string value "inbox".

This routine makes all generated and compiled type-checking routines
unnecessary, which has two advantages:
\begin{itemize}
\item the code size of the compiled modules will shrink considerably
\item at run-time, new signatures can be added. This enables the 
      overloading mechanism to work on MIL procs as well.
\end{itemize}

When these routines are called, you are supposed to hold a readlock
on the TBL database!
@c
typedef struct {
        /* basic info about the params */
	int argc;               /* number of actual params + 1 */
        ValPtr argv;            /* array with actual params */
        str tps[1+MAXPARAMS];     /* string type names of actual params */
        str htps[1+MAXPARAMS];    /* (if tps[i]==bat) string head type name */
        str ttps[1+MAXPARAMS];    /* (if tps[i]==bat) string tail type name */
        
        /* any resolution handling */
	int anynums;		/* number of instantiated any vars */
	int anynum[1+MAXPARAMS];  /* tag number of the any var */
	str anyval[1+MAXPARAMS];  /* instantiated type of any var */
} paramcheck_t;

#define ATOM_LOOKUP(nme, tpe, atomtbl) {		\
	int _tpe = tpe;					\
	BUN _p = BUNfnd(atomtbl, &_tpe);		\
	if (_p == NULL) return TBL_RESOLVE_NOTPE;	\
	nme = (str) BUNtail(atomtbl, _p);		\
}

int TBL_checkparams_init(paramcheck_t *pt, int argc, ValPtr argv, BAT *atomtbl) {
	int i;
	pt->argc = argc;
	pt->argv = argv;
	for(i=1; i<argc; i++) {
		ATOM_LOOKUP(pt->tps[i], argv[i].vtype, atomtbl);

		pt->htps[i] = pt->ttps[i] = NULL;

		if (argv[i].vtype == TYPE_bat) { 
                        bat bid = argv[i].val.bval;
			int htpe = 0, ttpe = 0;
			BAT *b;
			BBPfix(bid);
		     	b = BBPquickdesc(ABS(bid),FALSE); 
			if (b) {
                                /* swap head/tail types in case of mirrored bats */
				htpe = (bid>0)?b->htype:b->ttype;
				ttpe = (bid>0)?b->ttype:b->htype;
			}
			BBPunfix(bid);
			if (b) {
				ATOM_LOOKUP(pt->htps[i], htpe, atomtbl);
				ATOM_LOOKUP(pt->ttps[i], ttpe, atomtbl);
			}
		}
	} 
	return 0;
}

#define same_type(s1,s2)	((strcmp(s1, s2) == 0) || (s1[0]=='v' && s1[1]=='o'\
	 		   && s1[2]=='i' && s1[3]=='d' && !s1[4] && s2[0]=='o'\
			   && s2[1]=='i' && s2[2]=='d' && !s2[3]))

static INLINE 
int TBL_checkparam(paramcheck_t *pt, ValPtr v1, str tp1, str tp2) {
	int j, k;
	(void) v1;

	/* simple 1-1 match */
	if (same_type(tp1, tp2)) {
		return TRUE;
	}

	/* wildcard type (any) in signature? */
	if (tp2[0]=='a' && tp2[1]=='n' && tp2[2]=='y') {
	    if (tp2[3] == 0) {
		return TRUE;
	    }
	    if (tp2[3] == ':') {
		k = atoi(tp2+5);
		for(j=0; j < pt->anynums; j++) 
		if (pt->anynum[j]==k) {
			return same_type(tp1, pt->anyval[j]);
		}
		if (tp1[0]=='v' && tp1[1]=='o' && tp1[2]=='i' && 
		    tp1[3]=='d' && !tp1[4]) tp1++;
		pt->anyval[pt->anynums] = tp1;
		pt->anynum[pt->anynums++] = k;
		return TRUE;
	    }
	}
	return FALSE;
}

int TBL_checkparams(paramcheck_t *pt, oid op){
	str params[1+MAXPARAMS], v;
	int i, j, nparams = getparams(op, params);

	pt->anynums = 0;

	/* check for too many actual params (including varargs check!) */
	if (nparams > 1 && params[nparams-1][0] == '*') { 
		if (pt->argc < nparams) {
			nparams--; /* zero params */
		} else {
			v = ++(params[nparams-1]); /* eat away the '*' */ 
			while(nparams < pt->argc) 
				params[nparams++] = v; /* fill other params */
		}
	} else if (pt->argc > nparams) {
		return TBL_RESOLVE_NOFCN; 
	}
	if (pt->argc < nparams) {
		return TBL_RESOLVE_NOFCN;
	}
	
	/* do the check between signature and actual params */    
	for(i=1; i < nparams; i++) {
		str param = params[i];	
		if (param[0]=='B' && param[1]=='A' && 
                    param[2]=='T' && param[3]=='[') 
		{
			char tpe[IDLENGTH];
			if (pt->htps[i] == NULL) 
				return TBL_RESOLVE_NOSIG; /* quick bat check */

			for(v=tpe, j=4; param[j] != ','; j++, v++)
				*v = param[j];
			*v = 0; 
			if (!TBL_checkparam(pt, NULL, pt->htps[i], tpe)) {
				return TBL_RESOLVE_NOSIG;
			}
			for(v=tpe, j++; param[j] != ']'; j++, v++)
				*v = param[j];
			*v = 0;
			if (!TBL_checkparam(pt, NULL, pt->ttps[i], tpe)) {
				return TBL_RESOLVE_NOSIG;  
			}
		} else if (!TBL_checkparam(pt, pt->argv+i, pt->tps[i], param)) {
			return TBL_RESOLVE_NOSIG;  
		}
	}

	/* FOUND! now resolve the returntype to an actual type number */
	v = params[0];
	if (v[0] == 'a' && v[1] == 'n' && v[2] == 'y') {
		if (v[3] == ':' && v[4] == ':') {
			for(i=0, j = atoi(v+5); i<pt->anynums; i++) 
			    if (j == pt->anynum[i]) {
				v = pt->anyval[i];
				goto ready;
			    }
		}
		return 0;
	} 
ready:  if (v[0] == 'B' && v[1] == 'A' && v[2] == 'T') {
		return TYPE_bat;
	}
	i = ATOMindex(v);
	return (i<0)?0:i;
}
@- TBL_getname
For debugging purposes it may become necessary to locate the string
associated with a pointer in the fcntable.
@c
str TBL_getname(ptr imp) {
	BAT 	*b = BATmirror(TBL_fcn_imp);
	BUN	bun;
	oid	*fid;
	str 	s=0;

	TBL_set_readlock();
	if ((fid = BUNtailfnd(oid, b, bun, &imp)) == 0) {
	    GDKerror("TBL_getname: non-existing function %p.\n", imp);
	} else if ((s = BUNtailfnd(char, TBL_fcn_nme, bun, fid)) == 0) {
	    GDKerror("TBL_getname: no name for function %lu.\n", *fid);
	}
	TBL_unset_readlock();
	return s;
}
/* used in lex_name() */
str TBL_fndname(ptr imp) {
	BAT 	*b = BATmirror(TBL_fcn_imp);
	BUN	bun;
	oid	*fid;
	str 	s=0;

	TBL_set_readlock();
	if ((fid = BUNtailfnd(oid, b, bun, &imp)) == 0) {
	    ;
	} else if ((s = BUNtailfnd(char, TBL_fcn_nme, bun, fid)) == 0) {
	    ;
	}
	TBL_unset_readlock();
	return s;
}

@- TBL_getddir
Obtains a list of modules by looking at what files are present in the
module directory.
@c
BAT* TBL_getdir(void) {
#ifndef STATIC 
    char *name,*basename;
    size_t liblen = strlen("lib");
#endif
    BAT *b = BATnew(TYPE_int, TYPE_str, 100);
    int i = 0;
  
    if (b == NULL) return NULL;  

#ifndef STATIC 
    MSP_rewind_module_list();
    for (;;) {
            name=MSP_next_module(".mil");
            if (!name) break;
            basename=strrchr(name,DIR_SEP)+1;
	    if (strncmp(basename,"lib",liblen)==0)
	       basename+=liblen;
            if (BUNins(b, &i, basename) == NULL) assert(0);
            i++;
    }
#else 
    for(i=0; i<DL_TABLE_MAXLIBS; i++)  
    	if (DL_mod[i] != NULL) {
            if (BUNins(b, &i, DL_mod[i]+1) == NULL) assert(0);
        }
#endif
    return b;
}

@- TBL_atomname
Atom names may be qualified by leading underscores. These are
considered internal and removed.
@c
char *TBL_atomname(int atm) {
	char *s = ATOMname(atm), *t=s; 
	while(*t) {
		if (*t++ == '_') return t;
	}
	return s;
}


@+ Interface for Extension Modules
@- TBL_Install_Info
We expect this function NOT to be called if the module is already
in use. (That is <name>_Module_Install should not even be called.)
@c
size_t TBL_fcn_pro_size = 0;
oid TBL_oid = 10000; /* we cannot use the db oids, as the user may change
		 	the current number. This will turn around the order 
			of the functions in the function tables, corrupting
			the order in which function resolution should happen */

oid /* An oid is generated */
TBL_Install_Info( TBLinstall *inst, str owner, str name) {
	oid mid = 0;

	dlFPRINTF(GDKerr, "  TBL_Install_Info(%s, %s) = " SZFMT "\n", owner, name, (size_t) mid);
@-
if it is already loaded then we delete it, this implies
that the TBL_Install_Info is the same as reload (delete)
so dependencies should not reinstall modules?
SHOULD NEVER OCCUR UNDER NEW 'RECURSIVE LOADING' POLICY! <= P. Boncz
@c
	if ((mid=TBL_module_lookup(name))) {
		WARNING("TBL_Install_Info: The module %s will be reloaded.\n", name);
		TBL_unloadmod(inst->client, name, inst->level+1);
	}

	mid = TBL_oid++;

	if (BUNins(TBL_mod_nme, &mid, name) == NULL) assert(0);
	{
		int zero = 0;
		if (BUNins(TBL_mod_cnt, &mid, &zero) == NULL) assert(0);
	}
  	return mid;
}

@+ MIL Procedure Management

@- MIL Proc Ref counting
@T
While MIL procs are typically introduced by MIL modules, they can be typed in at anytime 
in a MIL session (not belonging to any specific module). They are represented as parsed
MIL trees, with their root in TBL\_fcn\_imp and shared in all client fcntbl-s. As a consequence, 
we must do indiviual refcounting for them (i.e. they cannot use the module refcnt mechanism). 

The following rules apply:
\begin{itemize}
\item each client having the proc in its fcntbl adds a refcnt
\item each module that defines the proc adds a refcnt
\end{itemize}

Thus, procs introduces by a module that are explicitly 'undef-ed' by the user keep existing. 
Thus, a second user that loads the module (logical load only, as he is the second user) still 
gets this proc as expected.
@c
void TBL_incproc(oid pid) {
	int cnt = *(int*) BUNtail(TBL_fcn_cnt, BUNfnd(TBL_fcn_cnt, &pid));
	cnt++;
	if (BUNreplace(TBL_fcn_cnt, &pid, &cnt) == NULL) assert(0);
}

void TBL_decproc(oid pid) {
	int cnt = *(int*) BUNtail(TBL_fcn_cnt, BUNfnd(TBL_fcn_cnt, &pid));
	if (cnt > 1) {
		cnt--;
		if (BUNreplace(TBL_fcn_cnt, &pid, &cnt) == NULL) assert(0);
	} else {
		/* remove last reference: free MIL tree, remove from TBL structures */
		YYSTREE *x = (YYSTREE*) BUNtloc(TBL_fcn_imp, BUNfnd(TBL_fcn_imp, &pid));
		if (x && *x) {
	    		GDKfree((*x)->yyval.val.pval); /* free disguised name */
	    		Myyfree((*x));
		}
		TBL_Deinstall_Function(pid);
	}
}

@- TBL_newproc 
registers a new MIL procedure.
@c
#define PROC_TYPE1(t)	((sht*) (&t->yyval.len))[0]
#define PROC_TYPE2(t)	((sht*) (&t->yyval.len))[1]
	
static 
int format_type(YYSTREE t, str *p) {
	int ret = 32768;
	str s = *p;

	if (t == NULL) {
		strcpy(s, "any"); 
	} else if (t->token == TOK_ANY) {
		strcpy(s, "any"); 
		if (t->yyval.val.ival >= 0) {
			sprintf(s+3, "::%d", t->yyval.val.ival);
		}
		ret = t->yyval.val.ival;
	} else {
		strcpy(s, t->yyval.val.sval);
	}
	*p += strlen(s);
	return ret; 
}

void TBL_newproc(Client client, str nme, str mod, YYSTREE body, YYSTREE sig, YYSTREE ret) {
	int j, tpe = TOK_PROC;
	oid pid = TBL_oid++;

	TBL_M_lock(NULL);
	TBL_fcn_pro_size++;
	if (body == sig) {
		/* forward definitions will never actually match */
		if (BUNins(TBL_fcn_pro, &pid, "<predefinition>") == NULL) assert(0);  
	} else {
		sht anynum, *any1 = NULL, *any2 = NULL;
		char returntpe[128];

		PROC_TYPE1(body) = PROC_TYPE2(body) = 0;
		if (ret) {
			char *p=returntpe;
			format_type(ret, &p); 

			/* analyze the return type specification */
			if (ret->token==TOK_ATOM) {
				PROC_TYPE1(body) = ATOMindex(ret->yyval.val.sval); 
				if (PROC_TYPE1(body) == TYPE_bat) {
					*(p++) = '[';
					format_type(ret->yysons[0], &p);
					*(p++) = ',';
					format_type(ret->yysons[1], &p);
					*(p++) = ']'; *(p++) = 0;
					if (ret->yysons[0]->token == TOK_ATOM) {
						PROC_TYPE1(body) += 8192 + ATOMindex(ret->yysons[0]->yyval.val.sval);
					} else { /* TOK_ANY */
						PROC_TYPE1(body) = ret->yysons[0]->yyval.val.ival;
						any1 = &PROC_TYPE1(body);
					}
					if (ret->yysons[1]->token == TOK_ATOM) {
						PROC_TYPE2(body) += 8192 + ATOMindex(ret->yysons[1]->yyval.val.sval);
					} else { /* TOK_ANY */
						PROC_TYPE1(body) = ret->yysons[1]->yyval.val.ival;
						any2 = &PROC_TYPE1(body);
					}
				} else { /* simple atom */
					PROC_TYPE1(body) += 8192;
				}
			} else { /* TOK_ANY */
				PROC_TYPE1(body) = ret->yyval.val.ival; 
				any1 = &PROC_TYPE1(body);
			}
	    
		} else {
			strcpy(returntpe, "any");
		} 

		/* insert a signature in TBL_fcn_pro */
		if (sig == NULL) {
			if (BUNins(TBL_fcn_pro, &pid, "*any") == 0) assert(0); 
		} else {
			YYSTREE cur=sig;
			for(j=1; cur; cur=cur->overflow) {
				unsigned i;
				for(i=0; i<cur->cnt; i++,j++) {
					char tpenme[512], *p=tpenme;
					YYSTREE t = cur->yysons[i];

					if (t->token == TOK_RANGETEMP) {
						*(p++) = '*';
						t = t->yysons[0];
					} 
			
					/* the any stuff resolves any::X expressions in
					   the return type specification, when we encounter
					   the any::X in the signature */
					anynum = format_type(t, &p);
					if (t->token==TOK_ATOM && strcmp(t->yyval.val.sval, "BAT")==0) {
						*(p++) = '[';
						anynum = format_type(t->yysons[0], &p);
						if (any1 && *any1==anynum) *any1 = 2048+j;
						if (any2 && *any2==anynum) *any2 = 2048+j;
						*(p++) = ',';
						anynum = format_type(t->yysons[1], &p);
						if (any1 && *any1==anynum) *any1 = 1024+j;
						if (any2 && *any2==anynum) *any2 = 1024+j;
						*(p++) = ']'; *(p++) = 0; 
					} else {
						if (any1 && *any1==anynum) *any1 = 4096+j;
						if (any2 && *any2==anynum) *any2 = 4096+j;
						if (t->cnt > 0) t = t->yysons[0];
						if (t->token == TOK_STRING) {
							*(p++) = '('; 
							strcpy(p, t->yyval.val.sval); 
							p += strlen(p);
							*(p++) = ')'; *(p++) = 0; 
						}
					}
					if (BUNins(TBL_fcn_pro, &pid, tpenme) == NULL) assert(0); 
				}
			}
		} 
		if ((any1 && *any1 < 1024) || (any2 && *any2 < 1024)) {
			if (any1 && *any1 < 1024) PROC_TYPE1(body) = 4096;
			if (any2 && *any2 < 1024) PROC_TYPE2(body) = 4096;
		}
		if (BUNins(TBL_fcn_pro, &pid, returntpe) == NULL) assert(0); 
	}
	j = 1; /* initial reference count */
	if (mod) {
		if (BUNins(TBL_mod_proc, mod, &pid) == NULL) assert(0);
		j++; /* extra reference if it belongs to a module */
	}
	if (BUNins(TBL_fcn_cnt, &pid, &j) == NULL) assert(0);
	if (BUNins(TBL_fcn_nme, &pid, nme) == NULL) assert(0);
	if (BUNins(TBL_fcn_imp, &pid, &body) == NULL) assert(0);
	if (BUNins(TBL_fcn_tpe, &pid, &tpe) == NULL) assert(0);
	if (BUNins(client->fcntbl, nme, &pid) == NULL) assert(0);

	/* use this space only once, so disguise name str as a ptr */
	body->yyval.vtype = TYPE_ptr; 
	body->yyval.len = 0; 

	TBL_M_unlock(client);
}

@- TBL_delproc 
forcedly removes it from a client fcntbl.

depending on its refcnt, the proc may continue to exist for other clients
and for the module it was defined in.
@c
void TBL_delproc(Client client, str nme) {
	int i;
	TBL_M_lock(client);
	if (BATprepareHash(client->fcntbl)) assert(0);	
	HASHloop_str(client->fcntbl, client->fcntbl->hhash, i, nme) {
		BUN p = BUNptr(client->fcntbl, i);
		oid pid = *(oid*) BUNtloc(client->fcntbl, p);
		if (*(int*) BUNtloc(TBL_fcn_tpe, BUNfnd(TBL_fcn_tpe, &pid)) == TOK_PROC) {
			TBL_decproc(pid);
			if (BUNdelete(client->fcntbl, p) == NULL) assert(0);
		}
	}
	TBL_M_unlock(client);
}

@+ Initialization
Most dictionary tables are created once and loaded upon system 
restart. By keeping the reference count at one we are assured that 
they remain fixed in memory for the duration of the session.
@c
static BAT *TBL_create(Client client, str nme, int cnt, int htpe, int ttpe, int hmode, int tmode) {
	BAT *b = BATnew(htpe, ttpe, cnt);
	char buf[128], *user = client->user;
	Variable v;

	if (b == NULL) GDKfatal("TBL_create: could not allocate.");
	if (hmode) BATkey(b,hmode);
	if (tmode) BATkey(BATmirror(b),tmode);

	/* the batname is prefixed with the client user name to make in easy to spot 
         * in the BBP dir list. Note that this rename may fail if such a bat already 
	 * exists (very rare and contrived though)
	 */
   	sprintf(buf, "%s_%s", user?user:"monet", nme);
	BBPrename(b->batCacheid, buf);

	/* whereas the batname is for debugging, each client sees his bat using the 
         * alias monet_X using a MIL variable.
         */
	if (user) {
   		sprintf(buf, "monet_%s", nme);
		v = VARnew((Cntxt) (client-monet_clients), buf); 
   		v->binding.val.bval = b->batCacheid;
   		v->binding.vtype = TYPE_bat;
   		v->binding.len = 0;
   		BBPincref(b->batCacheid, TRUE);
   		VARfreeze(v);
   		VARfixate(v);
	}
	return b;
}

static BAT *TBL_fathercopy( Client client, Client father, str nme ){
	char buf[128];
	Variable v;
	BAT *b = NULL;

   	sprintf(buf, "monet_%s", nme);
	v = VARfind(&father->stk, buf);
	if (v){ /* dirty replacement of the client bats */
		Variable n = VARnew(client->stk, v->name);
		BAT *o = BATdescriptor(v->binding.val.bval);
		n->constant = TRUE;
		n->frozen = TRUE;
		n->binding.vtype = TYPE_bat;
		b = BATcopy(o);
		BBPincref(b->batCacheid, TRUE);
		BBPdecref(o->batCacheid, FALSE);
   		n->binding.val.bval = b->batCacheid;
	} else {
		GDKerror("TBL_fathercopy: variable %s not found\n",  buf );
	}
	return b;
}

@- TBL_Init
The TBL initialization creates a set of function tables. 
Subsequently the starting address of all built-in functions is stored,
(and documentary information) [Should be removed or used as a view]
Since all code will move to modules this function will be come obsolute.
@= TBL_create
 	TBL_@1_@2 = TBL_create(monet_clients,"@1_@2",@5,TYPE_@3,TYPE_@4,@6,@7);
@c
void TBL_protect(){
	if( TBL_protector == NULL){
		TMDEBUG printf("# TBL locks created\n");
		TBL_protector = MT_create_lock();
		TBL_writelock = MT_create_lock();
		TBL_barrier = MT_create_sema(0);
	}
}
void TBL_init(void) {
	TBL_M_lock(NULL);

@- Empty the function table.
Since the BBP will no longer store these tables only creation is needed
@c
 	@:TBL_create(fcn,fcn,oid,ptr,600,BOUND2BTRUE,TRUE)@	
 	@:TBL_create(fcn,imp,oid,ptr,600,BOUND2BTRUE,FALSE)@	
 	@:TBL_create(fcn,tpe,oid,int,600,BOUND2BTRUE,FALSE)@	
 	@:TBL_create(fcn,mid,oid,oid,600,BOUND2BTRUE,FALSE)@	
	if (BATprepareHash(TBL_fcn_mid)) assert(0);	
 	@:TBL_create(fcn,sig,oid,str,100,BOUND2BTRUE,FALSE)@	
 	@:TBL_create(fcn,dsc,oid,str,500,BOUND2BTRUE,FALSE)@	
 	@:TBL_create(fcn,aut,oid,str,500,BOUND2BTRUE,FALSE)@	
 	@:TBL_create(fcn,dat,oid,str,500,BOUND2BTRUE,FALSE)@	
 	@:TBL_create(fcn,nme,oid,str,600,BOUND2BTRUE,FALSE)@	
 	@:TBL_create(fcn,pro,oid,str,2400,FALSE,FALSE)@	
 	@:TBL_create(fcn,cnt,oid,int,600,BOUND2BTRUE,FALSE)@	
	
@- Look up the module table.  
@c
        @:TBL_create(mod,nme,oid,str,40,BOUND2BTRUE,BOUND2BTRUE)@
        @:TBL_create(mod,cnt,oid,int,40,BOUND2BTRUE,FALSE)@
        @:TBL_create(mod,atm,oid,str,40,FALSE,FALSE)@
        @:TBL_create(mod,acc,oid,str,40,FALSE,FALSE)@
        @:TBL_create(mod,hdl,oid,ptr,40,BOUND2BTRUE,TRUE)@
        @:TBL_create(mod,dep,oid,str,40,FALSE,FALSE)@
        @:TBL_create(mod,use,oid,int,40,FALSE,FALSE)@
        @:TBL_create(mod,load,oid,str,40,BOUND2BTRUE,FALSE)@
        @:TBL_create(mod,drop,oid,int,40,FALSE,FALSE)@
        @:TBL_create(mod,proc,str,oid,200,FALSE,FALSE)@
        @:TBL_create(mod,var,str,ptr,200,FALSE,FALSE)@
@-
The function tables have been updated with session specific
information. This is for the moment sufficient. The tables are not
saved on disk so no commit is needed.
@c
#ifdef MKMODS
	TEM_init();
#endif
	TBL_M_unlock(NULL);
}

@+ Loading and Dropping Modules
@c
oid TBL_M_load(TBLinstall *inst, Client client, str module) {
	ptr hdl = NULL;
	oid mid = 0;
	char mod_init_name[PATHLENGTH];
	oid (*mod_init)(TBLinstall *, str) = NULL;;

	dlFPRINTF(GDKerr, "  TBL_M_load(%s)\n", module);
	if (!(hdl = TBL_openmod(client, module))) {
		GDKerror("TBL_loadmod: module load %s cancelled.\n", module);
		return 0;
	}

	sprintf(mod_init_name, "%s_Module_Install", module);
	mod_init = (oid (*)(TBLinstall *, str))DL_sym(hdl, mod_init_name);
	if (mod_init == NULL) {
		dlFPRINTF(GDKerr, "    No function %s\n", mod_init_name);
		GDKerror("TBL_M_load: %s not a module.\n", module);
		return 0;
	}

	dlFPRINTF(GDKerr, "    Calling %s\n", mod_init_name);
	mid = (*mod_init)(inst, client->user);
	if (mid == 0 ) {
		/* Not ok, an error is returned! */
		/* we should bail out! */
		GDKerror("TBL_M_load: %s_Module_Install experienced an error!\n", module);
		DL_close(hdl);
		return 0;
	}
	if (BUNdelHead(TBL_mod_hdl, &mid) == NULL) assert(0);
	if (BUNins(TBL_mod_hdl, &mid, &hdl) == NULL) assert(0);
	dlPRINT("TBL_M_load: Everything is ok, let's return...\n");
	return mid;
}

oid TBL_load_script(TBLinstall *inst, Client client, str module, str *initscript) {
	oid mid = 0;
	char *fullname;

	if (strcmp(module,"main") == 0){
		mid = TBL_Install_Info( inst, client->user, module);
		dlPRINT("TBL_M_load: Everything is ok, let's return...\n");
	} else if ((fullname = MSP_locate_script(module)) != NULL) {
		*initscript = monet_load_script(fullname, module);
		mid = TBL_Install_Info( inst, client->user, module);
		dlPRINT("TBL_M_load: Everything is ok, let's return...\n");
	}
	return mid;
}

int TBL_M_client_install(Client client, oid mid) {
	char *nme, s[80];
	BAT *fcn_mid = BATmirror(TBL_fcn_mid);
	hash_t i;
	int aid, j;
	oid fid;
	BUN r;

	dlPRINT("  TBL_M_client_install");

	/* Install all atoms in user atomtbl.
	 */
	if (BATprepareHash(TBL_mod_atm)) assert(0); 
	HASHloop_oid(TBL_mod_atm, TBL_mod_atm->hhash, i, &mid, r) {
		nme = (char *) BUNtail(TBL_mod_atm, r);
		for(j=0; nme[j] && nme[j] != '='; j++) s[j] = nme[j];
		s[j] = 0;
		if ((aid = ATOMindex(s)) < 0) {
			GDKerror("TBL_M_client_install: atom '%s' unknown.\n", s);
		} else {
			if (BUNins(client->atomtbl, s, &aid) == NULL) assert(0);
		}
	}

	/* Install all accelerators in user acctble
	 */
	if (BATprepareHash(TBL_mod_acc)) assert(0); 
	HASHloop_oid(TBL_mod_acc, TBL_mod_acc->hhash, i, &mid, r) {
		nme = (char *) BUNtail(TBL_mod_acc, r);
		for(j=0; nme[j] && nme[j] != '='; j++) s[j] = nme[j];
		s[j] = 0;
		if ((aid = ACCindex(s)) < 0) {
			GDKerror("TBL_M_client_instal: accelerator '%s' unknown.\n", s);
		} else {
			if (BUNins(client->acctbl, s, &aid) == NULL) assert(0);
		}
	}

	/* Install all functions and operations in user fcntbl.
	 */
	if (BATprepareHash(fcn_mid)) assert(0);
	assert(fcn_mid->hhash_heap);
	HASHloop_oid(fcn_mid, fcn_mid->hhash, i, &mid, r) {
		fid = * (oid *) BUNtail(fcn_mid, r);
		if (BUNins(client->fcntbl, BUNtailfnd(char, TBL_fcn_nme, r, &fid), &fid) == NULL) assert(0);
	}
	return 1;
}

static int countusage(Client client, oid mid) {
	int xx, yy=0, cid = client - monet_clients;
	BUN p, q;
	BATloopFast(TBL_mod_use, p, q, xx) 
		if (*(oid*)BUNhloc(TBL_mod_use,p) == mid && 
	    		*(int*)BUNtloc(TBL_mod_use,p) == cid) yy++;
	return yy;
}

int TBL_M_directloaded(Client client, oid mid, str module) {
	int xx, yy=0, zz=0;
	BUN p, q;

	/* count the number of times we reference the module */
	zz = countusage(client, mid);

	/* count the number of references stemming from dependencies */
	BATloopFast(TBL_mod_dep, p, q, xx) 
		if (strCmp(module,BUNtvar(TBL_mod_dep,p)) == 0)
		   	yy += countusage(client, *(oid*)BUNhloc(TBL_mod_dep,p));

	if (zz > yy) 
		return TRUE; 
	if (zz < yy) 
		GDKwarning("TBL_M_directloaded: %s relative refcounts are wrong (%d!=%d)!\n", module, zz, yy);

	return FALSE;
}

static int TBL_M_clientrefs(oid mid, Client c) {
	int xx, yy=0, cid = c - monet_clients;
	BUN p, q;

	BATloopFast(TBL_mod_use, p, q, xx)
		if (*(oid*)BUNhloc(TBL_mod_use,p) == mid && *(int*) BUNtloc(TBL_mod_use, p) == cid)
			yy++;
	return yy;
}

int TBL_M_countref(oid mid) {
	int xx, yy=0;
	BUN p, q;

	/*debug*/
	BATloopFast(TBL_mod_use, p, q, xx) 
		if (*(oid*)BUNhloc(TBL_mod_use,p) == mid) yy++;

	xx = *BUNtailfnd(int, TBL_mod_cnt, p, &mid);

	/*debug*/
	if (xx != yy) 
		GDKwarning("TBL_M_countref: mod(" SZFMT ") refcnt %d: should be %d.\n",(size_t) mid,xx,yy);

	return yy;
}

int TBL_M_incref(Client client, oid mid) {
    	int cid = client - monet_clients;
	int i = TBL_M_countref(mid);

	if (BUNins(TBL_mod_use, &mid, &cid) == NULL) assert(0);
	i++;
	if (BUNreplace(TBL_mod_cnt, &mid, &i) == NULL) assert(0);
	dlFPRINTF(GDKerr, "  TBL_M_incref = %d\n", i);

	return 1;
}

int TBL_M_decref(Client client, oid mid) {
    	int cid = client - monet_clients;
	int i = TBL_M_countref(mid);

	if (i <= 0) {
		GDKwarning("TBL_M_decref: mod(" SZFMT ") cannot decrease refcnt\n", (size_t) mid);
	} else {
		BUN p = BUNlocate(TBL_mod_use, &mid, &cid);
		assert(p);
		if (BUNdelete(TBL_mod_use, p) == NULL) assert(0);
		if (--i == 0) {
			if (BUNdelHead(TBL_mod_nme, &mid) == NULL) assert(0);
			if (BUNdelHead(TBL_mod_cnt, &mid) == NULL) assert(0);
		} else {
			if (BUNreplace(TBL_mod_cnt, &mid, &i) == NULL) assert(0);
		}
	}
	dlFPRINTF(GDKerr, "  TBL_M_decref = %d\n", i);
	return i;
}

void TBL_inc_mod_use(Client client, Client father){
    	int cid = father - monet_clients;
	BAT *modules_used;
	BUN p,q;
	int xx;

	modules_used = BATselect(TBL_mod_use, &cid, &cid);
	BATloopFast(modules_used, p, q, xx) { 
	    oid mid = *(oid*) BUNhloc(modules_used,p); 
	    TBL_M_incref(client, mid);
	}

	BBPreclaim(modules_used);
}


@- TBL_loadmod:
@T
byuser == cinstalled to the client
\begin{verbatim}
loaded	byuser	level	ACTION (in order!)
------- ------- ------- ----------------------------------------------
0	X	0	lock/       load/cinstall/incref/unlock
0	X	>0	            load/cinstall/incref
1	0	X	                 cinstall/incref
1	1	0	lock/                     incref/unlock
1	1	>0	                                 incref
\end{verbatim}
\begin{description}
\item[lock]	lock(tbl\_writelock)
\item[unlock]	unlock(tbl\_writelock)
\item[load]	openmod/mod\_inst
\item[unload]	TBL\_unload (includes decref,cunstall)
\item[cinstall]	copy TBL\_ to client->
\item[mod\_inst]	dlsym/<name>\_Module\_Install (that calls TBL\_Inst\_Depend)
\item[cinstall]	copies to client->xx tables and returns MIL init script.
\end{description}
@
@c


oid TBL_loadmod(Client client, str module, str parmod, int level, str *initstr) {
	/* State */
	TBLinstall inst;
	int loaded = 0;
	int cinstalled = 0;

	/* handles */
	oid mid = 0;

	dlFPRINTF(GDKerr, "TBL_loadmod(,%s,%d,)\n", module, level);
@
Save some state for recursive calls, without explicit arguments
@c
  
	/* identify as father */
	while (client->father != -1) {
		client = monet_clients + client->father; 
	}
	inst.client = client;
	inst.initstr = initstr;
	inst.level = level;
@
Lets do the things in the right order, see above!
@c
	if (level == 0) TBL_M_lock(NULL);

	mid = TBL_module_lookup(module);
	loaded = (mid != 0);
  
	dlFPRINTF(GDKerr, "  loaded = %d\n", loaded);
	if (!loaded) {
		if (module[0] == '_'){
			mid = TBL_M_load(&inst, client, module); /* generates a mid! */
		} else {
			mid = TBL_load_script(&inst, client, module, initstr);	
		}
		loaded = (mid != 0);
	} else {
		/* load the (already known) dependency modules, just to add fcns, atoms and accelerators to the parsing tables */
		BAT *b = BAT_select(BATmirror(TBL_mod_dep), &mid, &mid, FALSE); 	
		BUN p, q;
		BATloop(b, p, q) {
			TBL_loadmod(client, (str) BUNhvar(b,p), module, level+1, initstr);
		}
		BBPreclaim(b);
	}
	dlFPRINTF(GDKerr, "  loaded = %d, mid = " SZFMT "\n", loaded, (size_t) mid);

	if (loaded) {
		cinstalled = TBL_M_cinstalled(client, mid);
		if (parmod) {
			oid pmid = TBL_module_lookup(parmod);
			TBL_Insert_Depend(pmid, module );
		}
		dlFPRINTF(GDKerr, "  installed = %d\n", cinstalled);
		if (!cinstalled) { 
			dlPRINT("TBL_loadmod: loaded but not installed! Installing...\n");
			cinstalled = TBL_M_client_install(client, mid);
			dlFPRINTF(GDKerr, "  installed = %d\n", cinstalled);
		}
		TBL_M_incref(client, mid);
	}
	if (level == 0) TBL_M_unlock(client);
	return (cinstalled != 0);
}



@- TBL_unloadmod

We now check before unloading that there are no MIL variables or loaded BATs of object
types (atoms, accelerators) introduced by the module-to-be-dropped. If there are any, the drop fails.
@c
static int unloadmod_exit(int ret, Client father, int *tpes, int *accs) {
	if (father) TBL_M_unlock(father);
	GDKfree(tpes);
	GDKfree(accs);
	return ret;
}

static int unloadmod_bat(BAT* b, oid mid) {
	int xx, yy = 0;
	if (BBP_refs(b->batCacheid) > 0) {
		BUN p, q;
		BATloopFast(TBL_mod_drop, p, q, xx) {
			if (*(oid*) BUNhloc(TBL_mod_drop,p) == mid &&
			    ABS(*(bat*) BUNtloc(TBL_mod_drop,p)) == ABS(b->batCacheid))
			{
				yy++;
			}
		}
		return MAX(0, BBP_refs(b->batCacheid) - yy); 
	}
	return BBPreclaim(b);
}

static int unloadmod_check_use(oid mid, str module, int ntpes, int *tpes, int naccs, int *accs) {
        int i, j;
	BUN p, q;
	str foundvar;

	if (ntpes == 0 && naccs == 0) return 0;

	/* look in all MIL variable contexts for values of soon obsolete types */
	foundvar = VARfindinstance(&i, &j, ntpes, tpes);
	if (foundvar) {
		Client c;
		CNTXTclient(i, &c);
		GDKerror("unloadmod_check_use: drop(%s) failed: live variable %s of type %s in %s context %d.\n",
			module, foundvar, ATOMname(j), c->user, i);
		GDKfree(foundvar);
		return -1; /* will not be able to drop module */
	}

	/* Go through the entire BBP, looking for soon obsolete types and accelerators */
	BBPlock("drop"); /* wait for all unloads to finish and block all trims and BAT load decisions */
        for(i=1; i < BBPsize; i++) {
		if (BBP_logical(i)) {
                	BAT *b = (BBP_status(i)&BBPLOADING)?BBPdescriptor(i):BBP_cache(i);
			if (b == NULL) continue; /* if not loaded; it is not a problem.. */ 

			/* bat exists, is loaded, check for forbidden types and unload if possible */
			for(j=0; j<ntpes; j++) { 
                    		if (BAThtype(b) == tpes[j] || BATttype(b) == tpes[j])  {
					int cnt = unloadmod_bat(b, mid);
					if (cnt == 0) {
						break;
					} else if (cnt > 0) {
						GDKerror("unloadmod_check_use: drop(%s) failed: %s[%s,%s] has %d reference%s.\n",
							module, BBP_logical(i), ATOMname(b->htype), 
							ATOMname(b->ttype), cnt, cnt>1?"s":"");
					} else {
						GDKerror("unloadmod_check_use: drop(%s) failed: %s[%s,%s] could not be unloaded due to write errors.\n",
							module, BBP_logical(i), ATOMname(b->htype), ATOMname(b->ttype));
					} 
					BBPunlock("drop");
					return -1; /* will not be able to drop module */
				}
			}
			if (j != ntpes) continue;
			for(j=0; j<naccs; j++) { 
                    		if (b->hacctype == accs[j] || b->tacctype == accs[j])  {
					int cnt = unloadmod_bat(b, mid);
					if (cnt == 0) {
						break;
					} else if (cnt > 0) {
						GDKerror("unloadmod_check_use: drop(%s) failed: %s with %s accelerator has %d reference%s.\n",
							module, BBP_logical(i), ACCname(accs[j]), 
							cnt, cnt>1?"s":"");
					} else {
						GDKerror("unloadmod_check_use: drop(%s) failed: %s with %s accelerator could not be unloaded due to write errors.\n",
							module, BBP_logical(i), ACCname(accs[j]));
					} 
					BBPunlock("drop");
					return -1; /* will not be able to drop module */
				}
			}
		}
        }
	/* OK: drop can go through.*/
	for(i=0; i<ntpes; i++) BATatoms[tpes[i]].deleting = 1; /* block BAT loads of these atoms */
	for(i=0; i<naccs; i++) BATaccelerators[accs[i]].deleting = 1; /* block BAT loads of these accs */

	/* start unload for all prologue bats such that they cannot receive new refcounts */
	BATloop(TBL_mod_drop, p, q) {
		if (*(oid*) BUNhloc(TBL_mod_drop,p ) == mid) {
			bat bid = ABS(*(bat*) BUNtloc(TBL_mod_drop,p));
			BBP_status_on(bid, BBPUNLOADING, "TBL_unloadmod");
		}
	}
	if (BUNdelHead(TBL_mod_drop, &mid) == NULL) assert(0);
	BBPunlock("drop"); /* others can try to load BATs again */
	return 0; 
}


int TBL_unloadmod(Client client, str module, int level) {
	Client father = client;
	BAT *fcn_mid = BATmirror(TBL_fcn_mid);
	BAT *b, *fcntbl = BATmirror(client->fcntbl); 
       	char s[80], *nme, *r;
	int refcnt = 0;
	oid fid, mid; 
	hash_t i;
	int j, maccs=80, mtpes=80, naccs=0, ntpes=0;
	int *accs = (int*) GDKmalloc(maccs*sizeof(int));
	int *tpes = (int*) GDKmalloc(mtpes*sizeof(int));
	int (*addr)(void);
	ptr hdl = NULL;
	BUN p, q;

  	/* identify as father
         */
	while (father->father != -1) {
		father = monet_clients + father->father; 
  	}

	if (level==0) TBL_M_lock(father);
@-
Look up the module.
@c
  	mid = TBL_module_lookup(module);
  	if (mid == 0) {
		int cid = father - monet_clients;
		snprintf(s, 80, "_%s", module);
  		mid = TBL_module_lookup(s);
  		if (mid && BUNlocate(TBL_mod_use, &mid, &cid)) 
			GDKerror("TBL_unloadmod: module %s does not exist (maybe you mean %s?).\n", module, s); 
		else
			GDKerror("TBL_unloadmod: module %s does not exist.\n", module); 

		return unloadmod_exit(0, level?NULL:father, accs, tpes);
	}
@-
Check if it is in use already.
@c
	if (level == 0) {
		int cid = father - monet_clients;
		r = BUNlocate(TBL_mod_use, &mid, &cid);
		if (r == NULL) {
			GDKerror("TBL_unloadmod: %s was not loaded.\n", module);
			return unloadmod_exit(0, father, accs, tpes);
		}
		if (!TBL_M_directloaded(father, mid, module)) {
			GDKerror("TBL_unloadmod: others need %s.\n", module);
			return unloadmod_exit(0, father, accs, tpes);
		}
	}
@-
preparation phase (only meaningful for C-modules) */
@c
	/* find out which atoms and accelerators belong to it */
	if (BATprepareHash(TBL_mod_atm)) assert(0); 
	HASHloop_oid(TBL_mod_atm, TBL_mod_atm->hhash, i, &mid, r) {
		nme = (char *) BUNtail(TBL_mod_atm, r);
		for(j=0; nme[j] && nme[j] != '='; j++) s[j] = nme[j];
		s[j] = 0;
		r = (char *) BUNfnd(father->atomtbl, s);
		assert(r);
		tpes[ntpes++] = *(int*) BUNtloc(father->atomtbl, r);
		if (ntpes == mtpes) 
			tpes = (int*) GDKrealloc(tpes, (mtpes*=2)*sizeof(int));
	}
	if (BATprepareHash(TBL_mod_acc)) assert(0); 
	HASHloop_oid(TBL_mod_acc, TBL_mod_acc->hhash, i, &mid, r) {
		nme = (char *) BUNtail(TBL_mod_acc, r);
		for(j=0; nme[j] && nme[j] != '='; j++) s[j] = nme[j];
		s[j] = 0;
		r = (char *) BUNfnd(father->acctbl, s);
		assert(r);
		accs[naccs++] = *(int*) BUNtloc(father->acctbl, r);
		if (naccs == maccs) 
			 accs = (int*) GDKrealloc(accs, (maccs*=2)*sizeof(int));
	}
@-
check if the C-module is physically dropped that none of its atoms or accelerators is in use
@c
  	if (TBL_M_countref(mid) == 1 && unloadmod_check_use(mid, module, ntpes, tpes, naccs, accs)) {
		return unloadmod_exit(level, level?NULL:father, accs, tpes); /* NO GO */
	}
@-
decrease the refount of the module. we are ready if it isn't zero (LOGICAL DROP).
@c
	refcnt = TBL_M_decref(father, mid); 
@-
drop will go through; 
@c
	if (TBL_M_clientrefs(mid, client) == 0) {
		/* LOGICAL DROP */
		if (*module != '_') {
			/* decrease references to MIL procs and remove from client fcntbl */
			if (BATprepareHash(TBL_mod_proc)) assert(0);
			HASHloop_str(TBL_mod_proc, TBL_mod_proc->hhash, j, module) {
				fid = *(oid*) BUNtloc(TBL_mod_proc,BUNptr(TBL_mod_proc, j));
				BUNfndOID(r, fcntbl, &fid);
				if (r) {
					TBL_decproc(fid);
					if (BUNdelete(fcntbl, r) == NULL) assert(0);
				}
			}
		} else {
			/* delete all the C-modules's atoms, accelerators and functions */
			for(j=0; j<ntpes; j++)
				if (BUNdelHead(BATmirror(father->atomtbl), tpes+j) == NULL) assert(0);
			for(j=0; j<naccs; j++)
				if (BUNdelHead(BATmirror(father->acctbl), accs+j) == NULL) assert(0);

			if (BATprepareHash(fcn_mid)) assert(0);
			HASHloop_oid(fcn_mid, fcn_mid->hhash, i, &mid, r) {
				fid = * (oid *) BUNtail(fcn_mid, r);
				BUNfndOID(r,fcntbl, &fid);
				if (r && BUNdelete(fcntbl, r) == NULL) assert(0);
			}
		}
	}
	b = BAT_select(BATmirror(TBL_mod_dep), &mid, &mid, FALSE);
	if (refcnt == 0) { 
		/* PHYSICAL DROP */
		if (*module != '_') {
			/* MIL-modules kill the procs they introduced as well as the load-script variables */	
			if (BATprepareHash(TBL_mod_proc)) assert(0);
			HASHloop_str(TBL_mod_proc, TBL_mod_proc->hhash, j, module) {
				oid pid = *(oid*) BUNtloc(TBL_mod_proc,BUNptr(TBL_mod_proc, j));
				if ((r = BUNfnd(TBL_fcn_nme, &pid)) != NULL) {
					int cnt = *(int*) BUNtail(TBL_fcn_cnt, BUNfnd(TBL_fcn_cnt, &pid));
					if (cnt != 1) GDKwarning("drop(%s): MIL proc '%s' has %d dangling references.\n", 
								module, BUNtail(TBL_fcn_nme,r), cnt-1);
					TBL_decproc(pid);
				}
			} 
			if (BATprepareHash(TBL_mod_var)) assert(0);
			HASHloop_str(TBL_mod_var, TBL_mod_var->hhash, j, module) {
				p = BUNptr(TBL_mod_var, j);
				VARdel(client->stk, *(ptr*) BUNtloc(TBL_mod_var,p));
			}
			if (BUNdelHead(TBL_mod_proc, module) == NULL) assert(0);
			if (BUNdelHead(TBL_mod_var, module) == NULL) assert(0);
	    	} else {
			/* C-module: call C epilogue, dlcose, drop dependencies and deinstall it */
			BAT *b2 = BAT_select(TBL_fcn_mid, &mid, &mid, FALSE);
			BUNfndOID(p,TBL_mod_hdl,&mid);
			if (p != NULL) hdl = *(ptr*) BUNtloc(TBL_mod_hdl,p);

			/* Call the internal deletion routine, and dlclose.  */
			if (hdl != NULL) {
				char mod_del_name[PATHLENGTH];
				sprintf(mod_del_name, "%s_Module_Delete", module);
				addr = (int (*)(void)) DL_sym(hdl, mod_del_name);
				if (addr != NULL) (*addr)();
				if (BUNdelete(TBL_mod_hdl, p) == NULL) assert(0);
				DL_close(hdl);
			}		

			/* delete all function references in the TBL_ bats */
			BATloop(b2, p, q) {
				TBL_Deinstall_Function(*(oid*) BUNhloc(b2,p));
			}
			BBPreclaim(b2);
		}
		if (BUNdelHead(TBL_mod_dep, &mid) == NULL) assert(0);
	}

	/* drop all dependency modules */
	BATloop(b,p,q) {
	    if (TBL_unloadmod(client, BUNhead(b,p),level+1) == 0)
		GDKwarning("TBL_unloadmod: module %s: dependencies.\n", module);
	}
	BBPreclaim(b);

	/* drop succeeded */
	return unloadmod_exit(1, level?NULL:father, accs, tpes); 
}

@+ Function Resolution
@- TBL_search
The parser uses the routine TBL_search to locate the internal value
of an identifier. 
@c
char* TBL_search(str s, int *t, int guess_if_notfound, int cur_is_ident, int no_command, int next_is_ident) {
	char *assignop=NULL, *p, *v, *name = s, *ret = 0;
	Client c = ll_client;

	TBL_set_readlock();
	if ( name != NULL ) {
	    p = BUNfnd(c->atomtbl, name);
	    if (p != NULL) {
		int tpe = *((int *) BUNtail(c->atomtbl, p));
	    	str atm = BATatoms[tpe].name; 
	    	strcpy(s, atm);
	    	*t = TOK_ATOM;
		TBL_unset_readlock();
	    	return atm;
	    }
#ifdef MKMODS
            p = (char*) TEMsearch(t);
            if (p != NULL) {
	    	*t = TOK_TRG;
		TBL_unset_readlock();
	    	return s;
            }
#endif
	}

again:	
	if ( name != NULL ) {
	    p = BUNfnd(c->fcntbl, name);
	    if (p != NULL) {
		oid fid = *((oid *) BUNtail(c->fcntbl, p));
		*t = *BUNtailfnd(int, TBL_fcn_tpe, v, &fid);

		if (*t == TOK_BUILTIN) {
		    ret = (char *) *BUNtailfnd(ptr, TBL_fcn_imp, v, &fid);
		} else if (no_command == 0 && (cur_is_ident == 0 || 
		           (next_is_ident == 0 || *t == TOK_OPERATOR0 || *t == TOK_OPERATOR || *t == TOK_OPERATOR1))) 
		{
		    /* we refuse only if we know the following cannot be a command
                       or if we see a command followed by an identifier */ 
		    ret = BUNhvar(c->fcntbl, p);
		}
	    }
 	} 
@-
We recognize '+=' (and similar for other operators than +) as an TOK_ASSIGNOP.
@c
	if (assignop) {
		GDKfree(assignop);
		if (*t != TOK_OPERATOR0 && *t != TOK_OPERATOR  && *t != TOK_OPERATOR1 && *t != TOK_COMMAND) {
		    ret = NULL;
		} else {
		    *t = TOK_ASSIGNOP;
		}
	} else if (ret == NULL && name[strlen(name)-1] == '=') {
		name = assignop = GDKstrdup(*name==':'?name+1:name);
	        name[strlen(name)-1] = 0;
		goto again;
	}
	TBL_unset_readlock();

@-
if not found, the default is to say it is an identifier. 
However, with the command-hint passed, we guess it is a command.
@c
	if (ret == NULL && guess_if_notfound && no_command == 0 && next_is_ident == 0) {
		ret = s;
		*t = next_is_ident?TOK_OPERATOR:TOK_COMMAND;
	}
	return ret;
}

@- TBL_normal_resolve
The routine TBL_normal_resolve searches the table of function definitions
for one that matches the signature of the call. The first function that
matches is returned.
The type check is a function call derived from the module spec. 
@c
int TBL_normal_resolve(str name, int argc, ValPtr argv, 
                       monet_sig_t *sig, Cntxt stk)
{
	hash_t i;
	int ret = TBL_RESOLVE_NOFCN;
	paramcheck_t pt;
        Client  c;
	BAT *atomtbl, *fcntbl;
 
        CNTXTclient(stk, &c);
	fcntbl = c->fcntbl;
	atomtbl = BATmirror(c->atomtbl);
@- 
Try to resolve the function to an address.
@c
	TBL_set_readlock();
	if (BATprepareHash(fcntbl)) assert(0);
	if (TBL_checkparams_init(&pt, argc, argv, atomtbl) < 0) {
		TBL_unset_readlock();
		return TBL_RESOLVE_NOTPE;
	}
	HASHloop_str(fcntbl, fcntbl->hhash, i, name) {
		int j=0, tpe;
		BUN p = BUNptr(fcntbl, i);
		oid fid = * (oid *) BUNtail(fcntbl, p);

		BUNfndOID(p,TBL_fcn_tpe,&fid);
		tpe = *(int*) BUNtloc(TBL_fcn_tpe,p);

		if (tpe == TOK_ITERATOR) {
		    continue;
		}

		BUNfndOID(p, TBL_fcn_pro, &fid);
		if (p && (j=TBL_checkparams(&pt,fid)) < 0) {
			if (j == TBL_RESOLVE_NOSIG) ret = TBL_RESOLVE_NOSIG;
			continue;
		}
		if (BUNfnd(atomtbl, &j) == NULL)
			break; /* matches, but return type not allowed */
@-
Found IT: substitute name by address.  
@c
		BUNfndOID(p, TBL_fcn_imp, &fid);
		sig->pack_fcn = *(PackFcn*) BUNtloc(TBL_fcn_imp,p);
		sig->ret_tpe = j;

		if (tpe == TOK_PROC) {
		    sig->fast_fcn = (GDKfcn) sig->pack_fcn;
		} else {
		    BUNfndOID(p, TBL_fcn_fcn, &fid);
		    if (p == NULL) {
                	sig->fast_fcn = NULL;
		    } else {
                	sig->fast_fcn = *(GDKfcn*) BUNtloc(TBL_fcn_fcn,p);
		    } 	
		} 	
		TBL_unset_readlock();
		return (tpe==TOK_OPERATOR0 || tpe==TOK_OPERATOR || tpe==TOK_OPERATOR1)?TOK_COMMAND:tpe; /* simplify */
	}
	TBL_unset_readlock();

	return ret;
}

@- multiplex Analysis Of The BAT Parameters
Do basic check on parameters. Look at the tail types in order to derive
a function signature. Check that all head types correspond. We also want
to discover if all the input BAT parameters are sorted or in sync. This
may enable the use optimizations. Constants passed into the multiplex
operator are a special case.
@c
#define RETURN(x)	tok=x; goto ready;

int TBL_multiplex_resolve(str name, int argc, ValPtr argv, 
			  monet_sig_t *sig, Cntxt stk)
{
	int optimize = FALSE, optimize_true = TRUE;
	int consts = 0, i=0, tok=TOK_COMMAND, tpe = TBL_RESOLVE_NOFCN;
        batrec swap[1+MAXPARAMS];
        BAT *assignbat = NULL;
 
        if (argc <= 1 || argc >= MAXPARAMS) {
                GDKerror("interpret: 0 param multiplex operator.\n");
		return TBL_RESOLVE_NOFCN;
        }
        sig->array_opt = sig->merge_opt = 0;
	sig->ret_tpe = TBL_RESOLVE_NOFCN; 
        for(i=1; i < argc; i++) {
            swap[i].id = 0;
            swap[i].stamp = 0;
            if (argv[i].vtype == TYPE_bat && argv[i].len != int_nil) {
                BAT *b = BATdescriptor(argv[i].val.bval);
                int z = 0;
                ptr p = ATOMnilptr(b->ttype);

		if (b->ttype == TYPE_void) {
			optimize_true = FALSE;
		} 
                argv[i].vtype = ATOMtype(b->ttype);
                swap[i].id = argv[i].val.br.id;
                swap[i].stamp = argv[i].val.br.stamp;
 
                /* we might need a real value for function resolution! */
                if (b->ttype == TYPE_bat) {
                    p = (BATcount(b) <= 0)?((ptr) &z):BUNtloc(b, BUNfirst(b));
                }
                VALset(argv+i, b->ttype, p);
 
                if (tpe < 0) {
                    tpe = b->htype;
            	    if (i == 1 && sig->assignop) {
			assignbat = b;
            	    }
                } else if (ATOMtype(tpe) != ATOMtype(b->htype)) {
		    argc = i+1;
		    RETURN(TBL_RESOLVE_NOSIG);
                }
		BBPunfix(b->batCacheid);
	    } else {
	        consts++;
	    }
        }
@-
At least one BAT should be there..
@c
        if (tpe < 0) {
            GDKerror("[%s%s]: needs at least one BAT param.\n", name,
							sig->assignop?"=":"");
	    RETURN(TBL_RESOLVE_NOSIG);
        }
        tpe = ATOMstorage(ATOMtype(tpe));
@- 
For the [A?B:C] multiplex operators, certain restrictions exist on the type
(BIT) and number of their parameters (2 or 3).
@c
        if (sig->special) {
            if (argv[1].vtype != TYPE_bit) {
                GDKerror("[%s%s]: first param must be a BIT vector.\n", name, 
							sig->assignop?"=":"");
	        RETURN(TBL_RESOLVE_NOSIG);
            }
            if ((sig->special==1)?(argc != 4):(argc != 3)) {
                GDKerror("[%s%s]: wrong number of params.\n", name, 
						sig->assignop?"=":"");
	        RETURN(TBL_RESOLVE_NOSIG);
	    }
            if ((sig->special==1) && ATOMtype(argv[3].vtype) != ATOMtype(argv[2].vtype)) {
	        RETURN(TBL_RESOLVE_NOSIG);
            }
            sig->ret_tpe = ATOMtype(argv[2].vtype); /* store return type here */
	    if (sig->special == 1) {
	    	sig->pack_fcn = CMDifthenelse;
	    	sig->fast_fcn = interpret_ifthenelse;
	    } else if (sig->special == 2) {
	    	sig->pack_fcn = CMDifthen;
	    	sig->fast_fcn = interpret_ifthen;
	    } else if (sig->special == 3) {
	    	sig->pack_fcn = CMDifelse;
	    	sig->fast_fcn = interpret_ifelse;
	    }
        } else if ((tok=TBL_normal_resolve(name, argc, argv, sig, stk)) < 0) {
	    RETURN(tok);
        } 
@-
constraints for assigment-multiplexing: first must be identically typed BAT
@c
        if (sig->assignop) {
	    if (assignbat == NULL) {
                GDKerror("[%s=]: assignment to non-bat parameter.\n", name);
		RETURN (TBL_RESOLVE_NOFCN);
	    } else if (assignbat->ttype != sig->ret_tpe) {
                GDKerror("[%s=]: assignment of bat[%s,%s] to bat[% s,%s]\n", 
		    name, ATOMname(assignbat->htype), ATOMname(sig->ret_tpe), 
		    ATOMname(assignbat->htype), ATOMname(assignbat->ttype));
		RETURN (TBL_RESOLVE_NOFCN);
	    }
        }
@- optimization check
@T
The generic multiplex implementation fills an (argc,argv) array
of @%ValRecord@ structures before each tuple call. That tuple call 
then reconstructs the original atomic values from its (argc,argv)
parameters. 

We pick collection of interesting cases to optimize, and leave the
(argc,argv) way as a generic implementation for all non-optimizwed cases.
These cases are:
\begin{itemize}
\item unary, binary or 3-ary operators,
\item returning a fixed sized atomic type (BAT is forbidden too).
\item without ANY-type overloading or varargs as actual parameters.
\item that lookup is easy (all head columns unique and either all synced 
      or all sorted).
\end{itemize}
The last condition can only be checked at run-time. It actually splits the
optimizations in two classes: namely array-lookup or merge-lookup.
Both have differnt run-time constraints. we compute now whether
our other criteria allow for execution of thexe optimizations, 
and store the results in resp. sig->array\_opt and sig->merge\_opt.
@c
	if (sig->special) {
		optimize = optimize_true;
	} else if (tok != TOK_PROC && sig->fast_fcn && argc <= 3 &&
		(BATatoms[sig->ret_tpe].atomFix == NULL) &&
	        sig->ret_tpe != TYPE_void && ATOMvarsized(sig->ret_tpe) == 0)
	{
		str t_argv[1+MAXPARAMS];
        	int t_argc = TBL_getparams((ptr)sig->pack_fcn, t_argv);

        	for(i=1; i<t_argc; i++) {
            		if (ATOMindex(t_argv[i]) < 0) {
                		break; /* recognizes simple atoms only! */
            		}
		} 

        	if (i == t_argc) { /* passed the test? */
			optimize = optimize_true;
		}
        }
	if (optimize) {
        	sig->array_opt = !ATOMvarsized(tpe);
        	sig->merge_opt = (consts==0) && (tpe == ATOMstorage(TYPE_oid));
	}
@- 
Ready With Resolution
@c
ready:	for(i=1; i < argc; i++) {
                if (swap[i].id) {
                        argv[i].vtype = TYPE_bat;
                        argv[i].val.br.id = swap[i].id;
                        argv[i].val.br.stamp = swap[i].stamp;
                }
        }
        return tok;
}

static int TBL_setaggr_cleanup( int res, BAT *b, BAT *e){
	if (b) BBPunfix(b->batCacheid);
	if (e) BBPunfix(e->batCacheid);
	return res;
}

int TBL_setaggr_resolve(str nme, int argc, ValPtr argv, 
                        monet_sig_t *sig, Cntxt stk)
{
        ValRecord param[2];
        BAT *extent = NULL, *b = NULL, *tmp = NULL;
	int tok;
 
        if (argc > 3  || argc < 2){
		GDKerror("{%s}(Y):  1 or 2 params expected.\n", nme); 
		return TBL_setaggr_cleanup(TBL_RESOLVE_NOFCN, b, extent);
        }
        if (argv[1].vtype != TYPE_bat || !(b=BATdescriptor(argv[1].val.bval))){
                GDKerror("{%s}(Y): must have BAT params\n", nme); 
		return TBL_setaggr_cleanup(TBL_RESOLVE_NOSIG, b, extent);
        }
        if (b->ttype == TYPE_void && b->tseqbase == oid_nil) {
		GDKerror("{%s}(Y): void tailtype not allowed.\n", nme); 
		return TBL_setaggr_cleanup(TBL_RESOLVE_NOFCN, b, extent);
        }
        if (argc == 3) {
            if (argv[2].vtype != TYPE_bat ||
                !(extent=BATdescriptor(argv[2].val.bval)))
            {
                GDKerror("{%s}(Y): must have BAT params\n", nme); 
		return TBL_setaggr_cleanup(TBL_RESOLVE_NOSIG, b, extent);
            }
            if (TYPEerror(b->htype, extent->htype)) {
                GDKerror("{%s}(Y): incompatible extent.\n", nme); 
		return TBL_setaggr_cleanup(TBL_RESOLVE_NOSIG, b, extent);
            }
            if (extent->hkey == FALSE) {
		BATpropcheck(extent, BATPROPS_ALL); /* try to derive hkey */
	    }
            if (extent->hkey == FALSE) {
                GDKerror("{%s}(Y): extent must contain unique values.\n", nme);
		return TBL_setaggr_cleanup(TBL_RESOLVE_NOFCN, b, extent);
            }
        }
        tmp = BATnew(BATttype(b), BATttype(b), 1);
	if (tmp == NULL) return TBL_setaggr_cleanup(-4, b, extent);
        param[1].vtype = TYPE_bat;
        param[1].val.bval = tmp->batCacheid;
 
        tok = TBL_normal_resolve(nme, 2, param, sig, stk);
        BBPreclaim(tmp);
	if (tok < 0) return TBL_setaggr_cleanup(tok, b, extent);
	    
	if (sig->ret_tpe == 0) {
                GDKerror("{%s}(Y): 'any' return types not allowed.\n", nme);
		return TBL_setaggr_cleanup(TBL_RESOLVE_NOFCN, b, extent);
	}
	return TBL_setaggr_cleanup(tok, b, extent);
}

@- TBL_printsigs
prints all signatures of known commands/procs with a certain name.
@c
static ptrdiff_t formatsig(str s, str nme, oid fid){
	str src = s;
	BUN p;

	BUNfndOID(p, TBL_fcn_sig, &fid);
	if (p) {
		/* precooked */
		strcpy(s, BUNtvar(TBL_fcn_sig,p)); 
	} else {
		BUNfndOID(p, TBL_fcn_pro, &fid);
		strcpy(s,nme); s += strlen(s); *s++ = '(';
		if (p == NULL) {
			/* no signature restrictions */
			strcpy(s, "..any..) : any"); s += strlen(s); 
		} else {
			/* construct signature on the fly */
			str argv[1+MAXPARAMS];
			int k, argc = getparams(fid, argv);
			for(k=1; k<argc; k++) {
				str param = argv[k];
				if (k > 1) { 
					*s++ = ','; *s++ = ' '; 
				}
				if (*argv[k] == '*') {
					*s++ = '.'; *s++ = '.'; 
					param++;
				}
				strcpy(s, param); s += strlen(s);
				if (*argv[k] == '*') {
					*s++ = '.'; *s++ = '.'; 
				}
			}
			*s++ = ')'; *s++ = ' '; *s++ = ':'; *s++ = ' '; 
			strcpy(s, argv[0]); s += strlen(s); 
		}
	}
	return s-src;
} 

void TBL_printsigs(str s, int stk, str nme) {
	hash_t 	i;
	int	j = 0;
	BAT*	b;
        Client  c;
 
        CNTXTclient(stk, &c);
        b = c->fcntbl;
	TBL_set_readlock();
	if (BATprepareHash(b) == 0) 
	HASHloop_str(b, b->hhash, i, nme) {
		BUN p = BUNptr(b, i);
		oid fid = *(oid*) BUNtloc(b, p);
		if (j++ == 0) {
			sprintf(s, "!MAYBE YOU MEAN:\n");
			s += strlen(s);
		}
		*s++ = '!'; 
		*s++ = '\t';
		s += formatsig(s, nme, fid);
		*s++ = '\n'; 
	}
	*s++ = 0;
	TBL_unset_readlock();
}

@- TBL_formatsig
@c
int TBL_formatsig(str s, oid fid){
	BUN p;

	TBL_set_readlock();
	BUNfndOID(p, TBL_fcn_nme, &fid);
	if (p == NULL) {
		TBL_unset_readlock();
		return FALSE;
	}
	(void) formatsig(s, BUNtvar(TBL_fcn_nme,p), fid);
	TBL_unset_readlock();
	return TRUE;
}


@- TBL_iterator
Like TBL_search, but intened to do lookup for iterators.
@c
void *TBL_iterator(Cntxt stk, str name, int argc, ValPtr argv){
	paramcheck_t pt;
        Client  c;
	hash_t i;
 
        CNTXTclient(stk, &c);
 
	TBL_set_readlock();
	if (BATprepareHash(c->fcntbl) == 0)
	if (TBL_checkparams_init(&pt, argc, argv, BATmirror(c->atomtbl)) >= 0)
		HASHloop_str(c->fcntbl, c->fcntbl->hhash, i, name) 
	{
		char *v = BUNptr(c->fcntbl, i);
		oid fid = * (oid *) BUNtail(c->fcntbl, v);
		int tpe = *BUNtailfnd(int, TBL_fcn_tpe, v, &fid);

		if (tpe != TOK_ITERATOR) continue;

		if (TBL_checkparams(&pt,fid) >= 0) {
			TBL_unset_readlock();
	    		GDKfree(name);
			return *BUNtailfnd(void*, TBL_fcn_imp, v, &fid);
		}
 	} 
	TBL_unset_readlock();
	return (void *) 0;
}

@- TBL_procreturn
@T
We now allow the user to specify a procedure return value.
This does not add much functionality, but allows for an
extra check on a procedure return value (TBL\_procreturn).

The procedure body is a MIL block that has as yyval a string with
the PROC name, and in the len /*HACK*/ field we find an int that is 
a concatenation of two short integers 'type1' and 'type2':
- type1=type2=0 means 'any' (no check necessary)
- type2=0 means an atomic type (its number in type1)
- else we have a bat[type1,type2]
@
The type1,type2 are shorts consisting of a number, and a mask:
- 8192 => MIL type number
- 4096 => equal to type of 'num'th actual parameter
- 2048 => equal to head-type of BAT that is 'num'th actual parameter
- 1024 => equal to tail-type of BAT that is 'num'th actual parameter
@c
static  
int check_type(int argc, ValPtr argv, int tpe, int mask) {
	int kind = mask&15360;
	int num = mask&1023;

	if (kind == 8192) { /* direct type */
		return TYPEcastable(tpe,num); 
	} 
	if (argc <= num) {
		return 0;
	}
	if (kind == 4096) { /* any-normal */
		if (num == 0) return 1;
		return TYPEcastable(argv[num].vtype, tpe);
	} 
	if (argv[num].vtype != TYPE_bat) {
		return 0;
	}
	if (kind == 2048) { 
		BAT *b = BBPdescriptor(argv[num].val.bval);
		return b && TYPEcastable(tpe, BAThtype(b)); /* any-head */
	}
	if (kind == 1024) { 
		BAT *b = BBPdescriptor(argv[num].val.bval);
		return b && TYPEcastable(tpe, BATttype(b)); /* any-tail */
	}
	return 0; /* illegal kind */
}

int TBL_procreturn(int argc, ValPtr argv, ValPtr res, YYSTREE t) {
	if (PROC_TYPE1(t) == 0 && PROC_TYPE2(t) == 0) {
		return 1;
	} else if (res->vtype == TYPE_bat) {
		BAT *b = BBPdescriptor(res->val.bval);
		return b && check_type(argc, argv, BAThtype(b), PROC_TYPE1(t)) 
                         && check_type(argc, argv, BATttype(b), PROC_TYPE2(t));
	} else if (PROC_TYPE2(t)) {
		return 0;
	} 
	return check_type(argc, argv, res->vtype, PROC_TYPE1(t));
}


@+ Client Managament
@-
Each user gets a private function, atom, and accelerator table. They are 
initialized with the built-in functions and atomary types. They are extended 
later on when the user loads a module.

Both tables are session and user specific. 
@c

#define TBL_SIZE	750

void TBL_initclient(Client client, Client father) {
	BUN 	p, q;
	int	i, xx;

	TBL_M_lock(client);
	if (monet_clients != client){
		client->fcntbl = TBL_fathercopy(client, father, "fcntbl");
		client->acctbl = TBL_fathercopy(client, father, "acctbl"); 
		client->atomtbl = TBL_fathercopy(client, father, "atomtbl"); 

		/* for all procs in the client fcntbl, increment their refcnt */
		BATloopFast(client->fcntbl, p, q, xx) {
			oid pid = *(oid*) BUNtloc(client->fcntbl, p);
			if (*(int*) BUNtail(TBL_fcn_tpe, BUNfnd(TBL_fcn_tpe, &pid)) == TOK_PROC) {
		    		TBL_incproc(pid);
			}
		}
		if (father) 
		    TBL_inc_mod_use(client, father); /* inc mod use counters */
	} else {
		client->fcntbl = TBL_create(client, "fcntbl", TBL_SIZE, TYPE_str, TYPE_oid, 0, BOUND2BTRUE);

		/* Create the client acc-table, and fill it 
	 	 * with the standard types.
	 	 */
		client->acctbl = TBL_create(client, "acctbl", TBL_SIZE, TYPE_str, TYPE_int, BOUND2BTRUE, BOUND2BTRUE);
		i = ACC_hash; 
		if (BUNins(client->acctbl, "hash", &i) == NULL) assert(0);
		i = ACC_index;
		if (BUNins(client->acctbl, "index", &i) == NULL) assert(0);

		/* Create the client atom-table, and fill it 
	 	 * with the standard types.
	 	 */
		client->atomtbl = TBL_create(client, "atomtbl", TBL_SIZE, TYPE_str, TYPE_int, BOUND2BTRUE, 0);
		i = TYPE_void;
		if (BUNins(client->atomtbl, "void", &i) == NULL) assert(0);
		i = TYPE_bit; 
		if (BUNins(client->atomtbl, "bit", &i) == NULL) assert(0);
		i = TYPE_chr; 
		if (BUNins(client->atomtbl, "chr", &i) == NULL) assert(0);
		i = TYPE_sht; 
		if (BUNins(client->atomtbl, "sht", &i) == NULL) assert(0);
		i = TYPE_bat; 
		if (BUNins(client->atomtbl, "bat", &i) == NULL) assert(0);
		if (BUNins(client->atomtbl, "BAT", &i) == NULL) assert(0);
		i = TYPE_int; 
		if (BUNins(client->atomtbl, "int", &i) == NULL) assert(0);
		i = TYPE_oid; 
		if (BUNins(client->atomtbl, "oid", &i) == NULL) assert(0);
		i = TYPE_ptr; 
		if (BUNins(client->atomtbl, "ptr", &i) == NULL) assert(0);
		i = TYPE_flt; 
		if (BUNins(client->atomtbl, "flt", &i) == NULL) assert(0);
		i = TYPE_dbl; 
		if (BUNins(client->atomtbl, "dbl", &i) == NULL) assert(0);
		i = TYPE_lng; 
		if (BUNins(client->atomtbl, "lng", &i) == NULL) assert(0);
		i = TYPE_str; 
		if (BUNins(client->atomtbl, "str", &i) == NULL) assert(0);
	}
	TBL_M_unlock(client);

#ifdef MKMODS
	TEM_initclient(client);
#endif
}

@-
We would like to deallocate all MIL proc trees.  Procs depend on functions in modules. 
So the procs must be deleted before the (hard) module unload. However, those procs defined 
by the module (load script) - as opposed to user procs - might well be used in the 
module drop script. So, if we would delete the procs before the drop, the drop script 
will give syntax errors.

Thus, we first execute the drop scripts of the modules to be unloaded. Then, we
delete all procs, and finally we drop the modules (with level=1). Due to the level==1, 
it will not execute the drop scripts again. 
@c
void TBL_exitclient(Client client) {
	BAT	*b, *bn;
	BUN 	p, q, r;
	int	xx, cid = client - monet_clients;

#ifdef MKMODS
	TEM_exitclient(client);
#endif
	TBL_M_lock(client);

	/* Unload all loaded modules in reverse loading order. */
	bn = BATselect(TBL_mod_use, &cid, &cid);
	assert(bn);
	b = BATsort(bn);
	assert(b);
	b = BATsetaccess(b, BAT_WRITE);
	assert(b);
	b = BATrevert(b);
	assert(b);
	BATloopFast(b, p, q, xx) { 
	    oid mid = *(oid*) BUNhloc(b,p); 
	    if (BUNlocate(TBL_mod_use, BUNhloc(b,p), &cid)) {
	   	str module = BUNtailfnd(char,TBL_mod_nme,r,&mid);
	    	if (TBL_M_directloaded(client, mid, module))
		    TBL_unloadmod(client, module, 1);
	    }
	}
	BBPreclaim(b);
	BBPreclaim(bn);

	/* Unload any remaining procs in your fcn table.  */
	BATloopFast(client->fcntbl, p, q, xx) {
		oid pid = *(oid*) BUNtloc(client->fcntbl, p);
		if (*(int*) BUNtail(TBL_fcn_tpe, BUNfnd(TBL_fcn_tpe, &pid)) == TOK_PROC) {
			TBL_decproc(*(oid*) BUNtloc(client->fcntbl, p));
		}
	}

	/* Clean up all client parser BATs */
	BBPunfix(client->fcntbl->batCacheid);
	BBPunfix(client->atomtbl->batCacheid);
	BBPunfix(client->acctbl->batCacheid);
	client->fcntbl = client->atomtbl = client->acctbl = 0;
	TBL_M_unlock(NULL);
}

@- TBL_Install_Depend 
is called from the generated code in the routine <modulename>_Module_Install. 
It is called one time for each module that it is dependent on.
@c

static void TBL_Insert_Depend( oid mid, str name ) {
	if (BUNlocate(TBL_mod_dep, &mid, name) == NULL) {
		if (BUNins(TBL_mod_dep, &mid, name) == NULL) assert(0);  
	}
}

void TBL_Install_Depend(TBLinstall *inst, oid mid, str user, str name) {
	(void) user;
	/* use parent module NULL else circular dependencies are added */
	if (!TBL_loadmod(inst->client, name, NULL, inst->level+1, inst->initstr)) {
		GDKwarning("TBL_Install_Depend: requires module %s, not loaded!\n", name);
	} else {
		TBL_Insert_Depend(mid, name);
	}
}


@- TBL_Install_Atom
@c
void 
TBL_Install_Atom(
	oid mid,
	str name,
	int size,	/* 0 == not fixed size */
	int align)	/* 0 == not fixed size */
{
	str extended = GDKmalloc(strlen(name)+16);

	dlFPRINTF(GDKerr, "  TBL_Install_Atom(%s)\n", name);
	if ((size == 0) && (align == 0)) { /* fixed */
		sprintf(extended, "%s=*", name);
		if (BUNins(TBL_mod_atm, &mid, extended) == NULL) assert(0);
	} else {
		sprintf(extended, "%s=%d,%d", name, size, ABS(align));
		if (BUNins(TBL_mod_atm, &mid, extended) == NULL) assert(0);
	}
	GDKfree(extended);
}

@- TBL_Install_Accelerator
@c
void 
TBL_Install_Accelerator(oid mid, str name) {
	dlFPRINTF(GDKerr, "  TBL_Install_Accelerator(%s)\n", name);
	if (BUNins(TBL_mod_acc, &mid, name) == NULL) assert(0);
}

@- TBL_Install_Functions
@c
void TBL_Install_Functions( oid mid, TBLfcn *fcns, str user, str date ){
   	TBLfcn *cur = fcns;
   	while( cur->name ){
		oid fid = TBL_Install_Function( mid, cur->name, cur->token,
			cur->fcn, cur->unpack, cur->check, cur->oldsig,
			cur->help, user, date);
		str *arg = cur->args;
		while( *arg ){
			TBL_Install_Function_Arg( fid, *arg );
			arg++;
		}
		if (cur->res)
			TBL_Install_Function_Res( fid, cur->res );
		cur++;
	}
}

@- TBL_Install_Function
@c
/* I think the types from parsing are only availiable as strings
   so we better input them as such */

/* An oid is generated */
oid 
TBL_Install_Function(
	oid mid,
	str name,
	int tpe, /* some sort of type? fcn_table[i].token */
	ptr orig, ptr pack_imp, ptr type_imp, /* functionpointers! */
	str signature,
	str help,
	str author,
	str date)
{
	int zero = 0;
	oid fid = TBL_oid++;
	(void) type_imp;

	dlFPRINTF(GDKerr, "  TBL_Install_Function(" SZFMT ",%s) = " SZFMT "\n", (size_t) mid, name, (size_t) fid);

	if (name[0] == 'b' && name[1] =='a' && name[2] == 't' && name[3] == 0) {
		name = "BAT"; /* sorry */ 
	}
	if (BUNins(TBL_fcn_nme, &fid, name) == NULL) assert(0); /* or &name */
	if (BUNins(TBL_fcn_fcn, &fid, &orig) == NULL) assert(0); /* correct??? */
	if (BUNins(TBL_fcn_tpe, &fid, &tpe) == NULL) assert(0);
	if (BUNins(TBL_fcn_mid, &fid, &mid) == NULL) assert(0);
	if (BUNins(TBL_fcn_dsc, &fid, help) == NULL) assert(0);
	if (BUNins(TBL_fcn_aut, &fid, author) == NULL) assert(0);
	if (BUNins(TBL_fcn_dat, &fid, date) == NULL) assert(0);
	if (BUNins(TBL_fcn_cnt, &fid, &zero) == NULL) assert(0);
@-
We want to save pointer to the real function
for example use in a different interpreter 
if (orig) BUNins(TBL_fcn_org, &fid, &orig); 
Its done in TBL_unpacked()
@c
	if (pack_imp && BUNins(TBL_fcn_imp, &fid, &pack_imp) == NULL) assert(0);
	if (signature && BUNins(TBL_fcn_sig, &fid, signature) == NULL) assert(0);
	TBL_fcn_pro_size++;

	return fid;
}

void TBL_Deinstall_Function(oid pid) {
	if (BUNdelHead(TBL_fcn_nme, &pid) == NULL) assert(0);
	if (BUNdelHead(TBL_fcn_fcn, &pid) == NULL) assert(0);
	if (BUNdelHead(TBL_fcn_mid, &pid) == NULL) assert(0);
	if (BUNdelHead(TBL_fcn_imp, &pid) == NULL) assert(0);
	if (BUNdelHead(TBL_fcn_tpe, &pid) == NULL) assert(0);
	if (BUNdelHead(TBL_fcn_sig, &pid) == NULL) assert(0);
	if (BUNdelHead(TBL_fcn_dsc, &pid) == NULL) assert(0);
	if (BUNdelHead(TBL_fcn_aut, &pid) == NULL) assert(0);
	if (BUNdelHead(TBL_fcn_dat, &pid) == NULL) assert(0);
	if (BUNdelHead(TBL_fcn_cnt, &pid) == NULL) assert(0);

	/* periodically clean up TBL_fcn_pro */
	if (BATcount(TBL_fcn_nme)+100 < TBL_fcn_pro_size) {
		BAT *b = BATrcopy(TBL_fcn_pro);
		BUN p, q, r;
		int xx;

		if (BATclear(TBL_fcn_pro) == NULL) {
			assert(0);
		}
		BATloopFast(b, p, q, xx) {
			oid pid = *(oid*) BUNhead(b,p);
			BUNfndOID(r, TBL_fcn_nme, &pid);
			if (r && BUNfastins(TBL_fcn_pro, &pid, BUNtvar(b,p)) == NULL) assert(0);
		}
		TBL_fcn_pro->hsorted = TBL_fcn_pro->tsorted = 0; 
		BBPreclaim(b);
		TBL_fcn_pro_size = BATcount(TBL_fcn_nme);
	}
}

/* Called after _Function */
void TBL_Install_Function_Vararg(oid fid, str tpe) {
	dlFPRINTF(GDKerr, "    TBL_Install_Function_Vararg(" SZFMT ",%s)\n", (size_t) fid, tpe);
	if (BUNins(TBL_fcn_pro, &fid, tpe) == NULL) assert(0);
}


/* Called after _Function / _Vararg 
   This one would have to be called several times, once for each argument */
void TBL_Install_Function_Arg(oid fid, str tpe) {
	dlFPRINTF(GDKerr, "    TBL_Install_Function_Arg(" SZFMT ",%s)\n", (size_t) fid, tpe);
	if (BUNins(TBL_fcn_pro, &fid, tpe) == NULL) assert(0);
}

/* After _Arg */
void TBL_Install_Function_Res(oid fid, str tpe) {
	dlFPRINTF(GDKerr, "    TBL_Install_Function_Res(" SZFMT ",%s)\n", (size_t) fid, tpe);
	if (BUNins(TBL_fcn_pro, &fid, tpe) == NULL) assert(0);
}

/* Use the output of the prelude function to register BAT hotfixes required by the module */
void TBL_Install_DropRefs(oid mid, bat* batrefs) {
	if (batrefs == NULL)
		return;
	while(*batrefs) {
		dlFPRINTF(GDKerr, "  TBL_Install_DropRefs(" SZFMT ",%s)\n", (size_t) mid, BBP_logical(*batrefs));
		if (BUNins(TBL_mod_drop, &mid, batrefs) == NULL) assert(0); 
		batrefs++;
	}
}

void TBL_Install_MilVar(Client client, str mod, ptr v) {
	TBL_M_lock(client);
	if (BUNins(TBL_mod_var, mod, &v) == NULL) assert(0);
	TBL_M_unlock(client);
}
