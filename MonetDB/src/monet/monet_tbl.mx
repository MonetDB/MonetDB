@f monet_tbl
@a Peter Boncz, Jonas S Karlsson, Niels J Nes
@v 2.0
@t Function Table and Module Management
@* Introduction
The dictionary maintained by Monet is geared towards administration of the
functions, atomary types and modules.

The information on modules is stored in a system global area.
Upon start of a server session its contents is obtained for use.
No concurrency control is currently applied to the module database.

This code is heavily used to map identifiers to internal values and
vice versa. 
@h
#ifndef _MONET_TBL_H
#define _MONET_TBL_H

#include "monet.h"

#ifdef __cplusplus
extern "C" {
#endif

/* Generic initialization/cleanup routines */
m_export void  TBL_init();
m_export void  TBL_initclient(Client c);
m_export void  TBL_exitclient(Client c);

            
m_export void  TBL_newproc(Client c, str nme, 
			 YYSTREE body, YYSTREE sig, YYSTREE ret);
m_export void  TBL_delproc(Client client, str nme, int pid, int lock);


/* old info functions */
m_export ptr   TBL_unpacked(ptr imp);
m_export char* TBL_search(str name, int *t, int command_hint);
m_export str   TBL_getname(ptr imp);
m_export int   TBL_getparams(ptr imp, str argv[]);
m_export BAT*  TBL_getdir();
m_export char* TBL_atomname(int atm);
m_export void  TBL_printsigs(str s, int stk, str nme);
m_export int   TBL_formatsig(str s, oid fid);
m_export int   TBL_procreturn(int argc, ValPtr argv, ValPtr res, YYSTREE t);
m_export void* TBL_iterator(Cntxt stk, str name, int argc, ValPtr argv);
m_export oid   TBL_loadmod(Client client, str module, int level, str *initstr);
m_export int   TBL_unloadmod(Client client, str module, int level);

m_export BAT *TBL_fcn_nme;
m_export BAT *TBL_fcn_fcn;
m_export BAT *TBL_fcn_mid;
m_export BAT *TBL_fcn_imp;
m_export BAT *TBL_fcn_tpe;
m_export BAT *TBL_fcn_sig;
m_export BAT *TBL_fcn_dsc;
m_export BAT *TBL_fcn_aut;
m_export BAT *TBL_fcn_dat;
m_export BAT *TBL_fcn_pro;
m_export BAT *TBL_fcn_cnt;
m_export BAT *TBL_mod_nme;
m_export BAT *TBL_mod_cnt;
m_export BAT *TBL_mod_hdl;
m_export BAT *TBL_mod_atm;
m_export BAT *TBL_mod_acc;
m_export BAT *TBL_mod_dep;
m_export BAT *TBL_mod_use;
m_export BAT *TBL_mod_load;
m_export BAT *TBL_mod_drop;
@
Declarations of Installing interface for modules.
@h
typedef struct TBLinstall_t {
	Client	client;
	str *	initstr;
	int	level;
	oid	curmid;
} TBLinstall;

m_export void
TBL_Install_Depend( TBLinstall *i, /* Passed on from "module"_Install */
   oid mid,
   str user, /* Passed on from TBL_Install */
   str name);

m_export oid /* An oid is generated */
TBL_Install_Info( TBLinstall *i, /* Passed on from "module"_Install */
  str owner,
  str name);

m_export void
TBL_Install_Atom(
  oid mid,
  str name,
  int size,	/* 0 == not fixed size */
  int align);	/* 0 == not fixed size */

m_export void
TBL_Install_Accelerator(
  oid mid,
  str name);

/* I think the types from parsing are only availiable as strings
   so we better input them as such */

void 
TBL_Deinstall_Function(
  oid pid);

typedef struct TBLfcn_t {
   	str name;
	int token;
	ptr fcn;
	ptr unpack;
	ptr check;
	ptr oldsig;
	str help;
	str args[MAXPARAMS];
	str res;
} TBLfcn;

m_export void TBL_Install_Functions( oid mid, TBLfcn *fcns, str user, str date );
/* install all functions for the given module */

m_export oid /* An oid is generated */
TBL_Install_Function(
  oid mid,
  str name,
  int tpe, /* some sort of type? fcn_table[i].token */
  ptr orig, ptr pack_imp, ptr type_imp, /* functionpointers! */
  str signature,
  str help,
  str author,
  str date);

m_export void TBL_Install_Function_Vararg( /* Called after _Function */
  oid fid,
  str tpe);

@- function arguments
This one would have to be called several times, once for each argument 
@h
m_export void TBL_Install_Function_Arg( /* Called after _Function / _Vararg */
  oid fid,
  str tpe);

m_export void TBL_Install_Function_Res( /* After _Arg */
  oid fid,
  str tpe);

m_export void TBL_Install_LoadMIL(
  oid mid,
  str mil);

m_export void TBL_Install_DropMIL(
  oid mid,
  str mil);

@- function resolution
@h
m_export int 
TBL_normal_resolve(
  str name, 
  int argc, 
  ValPtr Argv, 
  monet_sig_t *sig, 
  Cntxt stk);

m_export int 
TBL_multiplex_resolve(
  str name,
  int argc,
  ValPtr Argv,
  monet_sig_t *sig,
  Cntxt stk);

m_export int 
TBL_setaggr_resolve(
  str name,
  int argc, 
  ValPtr Argv, 
  monet_sig_t *sig,
  Cntxt stk);

@c
#include "monet.h"
#include "searchpath.h"

#include <stdio.h>
#include <string.h>

#define dlPRINT(text)	DLDEBUG	THRprintf(GDKerr, text)
#define dlFPRINTF	DLDEBUG	THRprintf

#define WARNING(s1,	s2)	GDKwarning((s1),(s2));
#define FATAL(x,	y) 	GDKfatal((x),(y));

#define ERROR(progname,	filename, lineno) { THRprintf(GDKerr, "Mserver: "); }


BAT *TBL_fcn_nme = NULL;  /* BAT(oid, str): (function name, FID). */
BAT *TBL_fcn_fcn = NULL;  /* BAT(oid, ptr): (FID, implementation fcn). */
BAT *TBL_fcn_mid = NULL;  /* BAT(oid, oid): (FID, MID). */
BAT *TBL_fcn_imp = NULL;  /* BAT(oid, ptr): (FID, packed implementation) */
BAT *TBL_fcn_tpe = NULL;  /* BAT(oid, int): (FID, token). */
BAT *TBL_fcn_sig = NULL;  /* BAT(oid, str): (FID, fcn signature text). */
BAT *TBL_fcn_dsc = NULL;  /* BAT(oid, str): (FID, fcn description text). */
BAT *TBL_fcn_aut = NULL;  /* BAT(oid, str): (FID, fcn author name). */
BAT *TBL_fcn_dat = NULL;  /* BAT(oid, str): (FID, fcn creation date). */
BAT *TBL_fcn_pro = NULL;  /* BAT(oid, str): (FID, type sequence). */
BAT *TBL_fcn_cnt = NULL;  /* BAT(oid, int): (FID, reference count (procs)). */
BAT *TBL_mod_nme = NULL;  /* BAT(oid, str): (MID, module name).	*/
BAT *TBL_mod_cnt = NULL;  /* BAT(oid, int): (MID, reference count). */
BAT *TBL_mod_hdl = NULL;  /* BAT(oid, ptr): (MID, OS dynlink handle). */
BAT *TBL_mod_atm = NULL;  /* BAT(oid, str): (MID, atom name). */
BAT *TBL_mod_acc = NULL;  /* BAT(oid, str): (MID, accelerator name). */
BAT *TBL_mod_dep = NULL;  /* BAT(oid, str): (MID, depends-of module name). */
BAT *TBL_mod_use = NULL;  /* BAT(oid, ptr): (which clients use a mod). */
BAT *TBL_mod_load = NULL; /* BAT(oid, str): (MID, mil-script). */
BAT *TBL_mod_drop = NULL; /* BAT(oid, str): (MID, mil-script). */

oid 	TBL_top_mid;
MT_Lock TBL_protector, TBL_writelock;
MT_Sema TBL_barrier;
int     TBL_readers = 0, TBL_writer = 0;

@- read-write locking
@T
The function tables are concurrently read by the parser and (multiple)
interpreter threads. When modules are loaded/dropped or procedures 
defined, the parser thread may also write these tables. 

Reading is much more frequent than writing, and as interpreter
threads do this possibly in parallel, we first used a read-write locking
scheme that permits either one writer or multiple readers.
\begin{verbatim}
set_readlock
	lock(protector)
	if (nreaders++ == 0) set_writelock()
	unlock(protector)
unset_readlock
	lock(protector)
	if (--nreaders == 0) unset_writelock()
	unlock(protector)
set_writelock
	sema_down(barrier);
unset_writelock
	sema_up(barrier);
\end{verbatim}
In this approach, the probability that a reader had to set the semaphore was 
almost 100\%. Given the fact that locks are much cheaper than semaphores (on NT),
we switched an {\bf optimized} locking scheme, in which read-only access only
uses mutex locking.
\begin{verbatim}
set_readlock
	lock(writelock)
	lock(protector)
	nreaders++
	unlock(protector)
	unlock(writelock)
unset_readlock
	lock(protector)
	if (--nreaders == 0 and wr_waiting) sema_up(barrier);
	unlock(protector)
set_writelock
	lock(writelock)
	lock(protector)
	wr_waiting = (nreaders > 0);
	unlock(protector)
	if (wr_waiting) sema_down(barrier);
unset_writelock
	wr_waiting = 0;
	unlock(writelock)
\end{verbatim}
In a nutshell: there is a global writelock ('writelock') that stops 
readers from entering when there is a writer. If the readers are first,
an entering writer goes to sleep on a semaphore ('barrier') and is woken
up by the last reader. Crucial counter variables are protected by a 
short-term lock ('protector').
@c
#define TBL_set_readlock() {					\
    MT_set_lock(TBL_writelock, "TBL_set_readlock(writelock)");	\
    MT_set_lock(TBL_protector, "TBL_set_readlock(protector)");	\
    TBL_readers++;						\
    MT_unset_lock(TBL_protector, "TBL_set_readlock(protector)");\
    MT_unset_lock(TBL_writelock, "TBL_set_readlock(writelock)");}
#define TBL_unset_readlock() {					\
    MT_set_lock(TBL_protector, "TBL_unset_readlock(protector)");\
    if (--TBL_readers == 0 && TBL_writer) 			\
		MT_up_sema(TBL_barrier, "TBL_unset_readlock");	\
    MT_unset_lock(TBL_protector, "TBL_unset_readlock(protector)");	}
#define TBL_set_writelock() {					\
    MT_set_lock(TBL_writelock, "TBL_set_writelock(writelock)");	\
    MT_set_lock(TBL_protector, "TBL_set_writelock(protector)");	\
    TBL_writer = TBL_readers;					\
    MT_unset_lock(TBL_protector, "TBL_set_writelock(protector)");\
    if (TBL_writer) 						\
	MT_down_sema(TBL_barrier, "TBL_set_writelock");		}
#define TBL_unset_writelock() {					\
    MT_set_lock(TBL_protector, "TBL_unset_writelock(protector)");	\
    TBL_writer = 0;						\
    MT_unset_lock(TBL_protector, "TBL_unset_writelock(protector)");\
    MT_unset_lock(TBL_writelock, "TBL_unset_writelock");	}


@+ Dynamic Loading  

@- Module Filename Convention 
The file is assumed to be in directory: module_dir (set to
$PREFIX/lib/ ?)  The file is assumed to have either of these file
names, searched in the following order; <module>-<database>_<user>.so,
<module>-<database>.so, <module>_<user>.so, <module>.soo .

The function returns the dlopen handle (!=0) if the module existed. If
there is no initfunction a library is loaded nothing more should be
done. In case there is a initfunction we call it.  This function will
install the functions etc..

@- Module Loading Interface 
The DL_ interface offers a UNIX dl* 'dynamic loading'-like interface
that can either be implemented using dynamic loading or with static 
loading. In case of static loading, libs and functions should first
be registered with the DL_register_* functions.
@h
m_export void*	DL_reglib(str path, void* dynamic_handle, int maxsize);
m_export int	DL_regfcn(void* tbl, ptr fcnptr, str name);

#ifdef __cplusplus
}
#endif
#endif /* _MONET_TBL_H */
@c
#ifndef STATIC

#ifdef HAVE_DLFCN_H
# include <dlfcn.h>
#endif

#else

#define RTLD_LAZY	1       
#define RTLD_NOW	2       
#define RTLD_GLOBAL	4       
#define RTLD_NOW_REPORT_ERROR	8

#endif

#define DL_TABLE_MAXLIBS 128

typedef struct {
	str		name;
	ptr		value;
} dlentry;

typedef struct {
	void*		dynamic_handle;
	int		size;
	dlentry		entry[1]; /* extended to just the right length */
} dltable;

int	 DL_errno = 0;
str	 DL_mod[DL_TABLE_MAXLIBS] = { 0 };
dltable* DL_table[DL_TABLE_MAXLIBS] = { 0 };

void *DL_reglib(str nme, void* dynamic_handle, int maxsize) {
	int i;

	for(i=0; i<DL_TABLE_MAXLIBS; i++)  
	    if (DL_mod[i] == NULL) {
		dltable* tbl = (dltable*) 
			GDKmalloc(sizeof(dltable)+(maxsize-1)*sizeof(dlentry));
		DL_mod[i] = GDKstrdup(nme);
		DL_table[i] = tbl; 
		tbl->dynamic_handle = dynamic_handle;
		tbl->size = 0;
		return tbl;
	    }
	GDKfatal("DL_reglib: too many libs");
	return NULL;
}

int DL_regfcn(void* handle, ptr fcnptr, str name) {
	dltable *tbl = (dltable*) handle;
	tbl->entry[tbl->size].value = fcnptr;
	tbl->entry[tbl->size++].name = GDKstrdup(name);
	return 0;
}


void* DL_open(char* nme, int mode) { 
	dltable* tbl = NULL;
	int i;

	DL_errno = 0;
	for(i=0; i<DL_TABLE_MAXLIBS; i++) 
		if (DL_mod[i] && strcmp(DL_mod[i], nme) == 0) {
			tbl = DL_table[i];
		}

	if (tbl == NULL) {
#ifndef STATIC
		char *fullname = MSP_locate_module(nme);
		void* hdl = dlopen(fullname, mode);
		if (hdl) {
			tbl = (dltable*) DL_reglib(nme, hdl, 0);
			tbl->dynamic_handle = hdl;
		}
		GDKfree(fullname);
#else 
		DL_errno = 1;
#endif
	}
	return (void*) tbl; 
}

void* DL_sym(void* handle, const char *nme) { 
	dltable *tbl = (dltable*) handle;
	int i;

	DL_errno = 0;
#ifndef STATIC
	if (tbl->dynamic_handle) {
		return dlsym(tbl->dynamic_handle, nme);
	}
#endif
	for(i=0; i<tbl->size; i++) {
		if (strcmp(tbl->entry[i].name, nme) == 0) {
			return (void*) tbl->entry[i].value;
		}
	}
	DL_errno = 2;
	return NULL; 
}


int DL_close(void *handle) { 
	int ret = 0;
#ifndef STATIC
	dltable* tbl = (dltable*) handle;
	int i;
	if (tbl->dynamic_handle) {
		ret = dlclose(tbl->dynamic_handle);
		for(i=0; i<DL_TABLE_MAXLIBS; i++) {
			if (DL_table[i] == tbl) {
				GDKfree(DL_mod[i]);
				DL_table[i] = NULL;
				DL_mod[i] = NULL;
			}
		}
		GDKfree(tbl);
	}
#endif
	return ret; 
}


static short_str DL_errormsg[3] =
	{ "no error occured (STATIC)", "library not found (STATIC)", 
          "function name unknown (STATIC)" };


char *DL_error() { 
#ifndef STATIC
	if (DL_errno == 0) return dlerror();
#endif
	return DL_errormsg[DL_errno]; 
}


ptr TBL_openmod(Client client, str module) {
    ptr ret=0;
    if (module) {      
        ret=(ptr)DL_open(module, (RTLD_NOW|RTLD_GLOBAL));
    } else {
            if (!ret) GDKerror("locate module: %s.\n", module);
            return 0;
    }

    if (!ret) GDKerror("DL_open: %s.\n", DL_error());
    return ret; /* none found */
}


ptr TBL_module_handle(int mid) {
  char *p;
  return (p=BUNfnd(TBL_mod_hdl, &mid))?*(int**)BUNtloc(TBL_mod_hdl,p):0;
}


int TBL_module_lookup(str module) {
  BUN bun; /* stupid temp storage? */
  int * midp = BUNtailfnd(int, BATmirror(TBL_mod_nme), bun, module);

  return midp?*midp:0;
}

int TBL_M_cinstalled(Client client, int mid) {
  return (!!(BUNlocate(BATmirror(TBL_mod_use), &client, &mid)));
}

#define BATfakeAbort(b)	if (b) ((b)->batInserted = BUNfirst(b))

int TBL_M_lock(Client c) {
  dlPRINT("  -->TBL_M_lock\n");
  TBL_set_writelock();
  BATfakeAbort(TBL_fcn_nme);
  BATfakeAbort(TBL_fcn_fcn);
  BATfakeAbort(TBL_fcn_mid);
  BATfakeAbort(TBL_fcn_imp);
  BATfakeAbort(TBL_fcn_tpe);
  BATfakeAbort(TBL_fcn_sig);
  BATfakeAbort(TBL_fcn_dsc);
  BATfakeAbort(TBL_fcn_aut);
  BATfakeAbort(TBL_fcn_dat);
  BATfakeAbort(TBL_fcn_pro);
  BATfakeAbort(TBL_fcn_cnt);
  BATfakeAbort(TBL_mod_nme);
  BATfakeAbort(TBL_mod_cnt);
  BATfakeAbort(TBL_mod_hdl);
  BATfakeAbort(TBL_mod_atm);
  BATfakeAbort(TBL_mod_acc);
  BATfakeAbort(TBL_mod_dep);
  BATfakeAbort(TBL_mod_use);
  BATfakeAbort(TBL_mod_load);
  BATfakeAbort(TBL_mod_drop);
  if (c != NULL) {
	BATfakeAbort(c->acctbl);
	BATfakeAbort(c->atomtbl);
  }
  dlPRINT("  <--TBL_M_lock\n");
  return 1;
}

int TBL_M_unlock(Client c) {
  dlPRINT("  -->TBL_M_unlock\n");
  BATfakeCommit(TBL_fcn_nme);
  BATfakeCommit(TBL_fcn_fcn);
  BATfakeCommit(TBL_fcn_mid);
  BATfakeCommit(TBL_fcn_imp);
  BATfakeCommit(TBL_fcn_tpe);
  BATfakeCommit(TBL_fcn_sig);
  BATfakeCommit(TBL_fcn_dsc);
  BATfakeCommit(TBL_fcn_aut);
  BATfakeCommit(TBL_fcn_dat);
  BATfakeCommit(TBL_fcn_pro);
  BATfakeCommit(TBL_fcn_cnt);
  BATfakeCommit(TBL_mod_nme);
  BATfakeCommit(TBL_mod_cnt);
  BATfakeCommit(TBL_mod_hdl);
  BATfakeCommit(TBL_mod_atm);
  BATfakeCommit(TBL_mod_acc);
  BATfakeCommit(TBL_mod_dep);
  BATfakeCommit(TBL_mod_use);
  BATfakeCommit(TBL_mod_load);
  BATfakeCommit(TBL_mod_drop);
  if (c) {
    if (BATdirty(c->fcntbl)) {
	/* Restore correct hash-list order for function resolution..
	 * (1) order on oid => have functions in order of definition
	 * (2) then rehash => last-defined first in hash-list
	 */
	BATorder(BATmirror(c->fcntbl));
	(void) BATprepareHash(c->fcntbl);	
    	BATfakeCommit(c->fcntbl);
    }
    BATfakeCommit(c->acctbl);
    BATfakeCommit(c->atomtbl);
  }
  TBL_unset_writelock();
  dlPRINT("  <--TBL_M_unlock\n");
  return 1;
}


@+ Misc Information Functions
@- TBL_unpacked
Return the implementation routine hidden behind its pack function.
@c
ptr TBL_unpacked(ptr imp) {
	BAT 	*b = BATmirror(TBL_fcn_imp);
	BUN	bun;
	oid	*fid;
	ptr* 	s=0;

	TBL_set_readlock();
	fid = BUNtailfnd(oid, b, bun, &imp);   
	if (fid) s = BUNtailfnd(ptr, TBL_fcn_fcn, bun, fid);
	TBL_unset_readlock();
	return (s)?*s:0;
}

@- TBL_getparams
We have info registered about the function prototype of each
implementation. Normally, this is hidden by the _chk and _pack
routines. The information is kept for those who want to use the
unpacked implementations directly (for optimization purposes).
@c
static int getparams(oid fid, str argv[]) {
	str *s = argv, *t = s;
	int i, j = 0;
	BUN p;

	(void) BATprepareHash(TBL_fcn_pro);
	HASHloop_oid(TBL_fcn_pro, TBL_fcn_pro->hhash, i, &fid, p) {
		*(t++) = (str) BUNtvar(TBL_fcn_pro, p); 
		j++;
	}
	while(++s < --t) {
		str swap = *s;
		*s = *t; *t = swap;
	}
	return j;
}

int TBL_getparams(ptr imp, str argv[]) {
	BAT *b = BATmirror(TBL_fcn_imp);
	BUN p;
	int nparams;

	TBL_set_readlock();
	nparams = getparams(*BUNtailfnd(oid, b, p, &imp), argv);
	TBL_unset_readlock();

	return nparams;
}

@- TBL_checkparams
@T
This routine checks whether a set of actual parameters make a match 
with the signature of a certain registered MIL operator. Signatures
are registered in the {\tt monet\_fcn\_pro} system BAT, which
contains function oids and strings. This BAT contains sequences
of the same OIDS. 

The sequence of strings in the tail contains the
successive parameters of the operator. The first string identifies the
return type, the second identifies the first parameter type, the third
its second parameter, etc.

The types are denoted by their usual MIL atomic type name. BATs are
spelled in lowercase, concatenated by two (comma separated) types for 
their head and tail (enclosed by square brackets). For instance
'bat[oid,flt]' identifies a BAT withs OIDs in the head and floats
in the tail. Wildcard types are denoted with 'any', and -- like in MEL --
free type variables with 'any::<NUM>'. Finally, there is now support
for constant values to be used in overloading like 'str(inbox)'. This
identifies a string value "inbox".

This routine makes all generated and compiled type-checking routines
unnecessary, which has two advantages:
\begin{itemize}
\item the code size of the compiled modules will shrink considerably
\item at run-time, new signatures can be added. This enables the 
      overloading mechanism to work on MIL procs as well.
\end{itemize}

When these routines are called, you are supposed to hold a readlock
on the TBL database!
@c
typedef struct {
        /* basic info about the params */
	int argc;               /* number of actual params + 1 */
        ValPtr argv;            /* array with actual params */
        str tps[MAXPARAMS];     /* string type names of actual params */
        str htps[MAXPARAMS];    /* (if tps[i]==bat) string head type name */
        str ttps[MAXPARAMS];    /* (if tps[i]==bat) string tail type name */
        
        /* any resolution handling */
	int anynums;		/* number of instantiated any vars */
	int anynum[MAXPARAMS];  /* tag number of the any var */
	str anyval[MAXPARAMS];  /* instantiated type of any var */
} paramcheck_t;

void TBL_checkparams_init(paramcheck_t *pt, int argc, ValPtr argv) {
	BAT *b; int i;

	pt->argc = argc;
	pt->argv = argv;
	for(i=1; i<argc; i++) {
		pt->tps[i] = ATOMname(argv[i].vtype);

		if (argv[i].vtype != TYPE_bat || 
		    (b=BATdescriptor(argv[i].val.bval)) == NULL) 
		{ 
			pt->htps[i] = pt->ttps[i] = NULL;
			continue;
		}
		pt->htps[i] = ATOMname(b->htype);
		pt->ttps[i] = ATOMname(b->ttype);
	} 
}

#define same_type(s1,s2)	((strcmp(s1, s2) == 0) || (s1[0]=='v' && s1[1]=='o'\
	 		   && s1[2]=='i' && s1[3]=='d' && !s1[4] && s2[0]=='o'\
			   && s2[1]=='i' && s2[2]=='d' && !s2[3]))

static INLINE 
int TBL_checkparam(paramcheck_t *pt, ValPtr v1, str tp1, str tp2) {
	int j, k;

	/* simple 1-1 match */
	if (same_type(tp1, tp2)) {
		return TRUE;
	}

	/* wildcard type (any) in signature? */
	if (tp2[0]=='a' && tp2[1]=='n' && tp2[2]=='y') {
	    if (tp2[3] == 0) {
		return TRUE;
	    }
	    if (tp2[3] == ':') {
		k = atoi(tp2+5);
		for(j=0; j < pt->anynums; j++) 
		if (pt->anynum[j]==k) {
			return same_type(tp1, pt->anyval[j]);
		}
		if (tp1[0]=='v' && tp1[1]=='o' && tp1[2]=='i' && 
		    tp1[3]=='d' && !tp1[4]) tp1++;
		pt->anyval[pt->anynums] = tp1;
		pt->anynum[pt->anynums++] = k;
		return TRUE;
	    }
	}
	return FALSE;
}

int TBL_checkparams(paramcheck_t *pt, oid op){
	str params[MAXPARAMS+1], v;
	int i, j, nparams = getparams(op, params);

	pt->anynums = 0;

	/* check for too many actual params (including varargs check!) */
	if (nparams > 1 && params[nparams-1][0] == '*') { 
		if (pt->argc < nparams) {
			nparams--; /* zero params */
		} else {
			v = ++(params[nparams-1]); /* eat away the '*' */ 
			while(nparams < pt->argc) 
				params[nparams++] = v; /* fill other params */
		}
	} else if (pt->argc > nparams) {
		return -1; 
	}
	if (pt->argc < nparams) {
		return -1;
	}
	
	/* do the check between signature and actual params */    
	for(i=1; i < nparams; i++) {
		str param = params[i];	
		if (param[0]=='B' && param[1]=='A' && 
                    param[2]=='T' && param[3]=='[') 
		{
			char tpe[IDLENGTH];
			if (pt->htps[i] == NULL) 
				return -2; /* quick bat check */

			for(v=tpe, j=4; param[j] != ','; j++, v++)
				*v = param[j];
			*v = 0; 
			if (!TBL_checkparam(pt, NULL, pt->htps[i], tpe)) {
				return -2;
			}
			for(v=tpe, j++; param[j] != ']'; j++, v++)
				*v = param[j];
			*v = 0;
			if (!TBL_checkparam(pt, NULL, pt->ttps[i], tpe)) {
				return -2;  
			}
		} else if (!TBL_checkparam(pt, pt->argv+i, pt->tps[i], param)) {
			return -2;  
		}
	}

	/* FOUND! now resolve the returntype to an actual type number */
	v = params[0];
	if (v[0] == 'a' && v[1] == 'n' && v[2] == 'y') {
		if (v[3] == ':' && v[4] == ':') {
			for(i=0, j = atoi(v+5); i<pt->anynums; i++) 
			    if (j == pt->anynum[i]) {
				v = pt->anyval[i];
				goto ready;
			    }
		}
		return 0;
	} 
ready:  if (v[0] == 'B' && v[1] == 'A' && v[2] == 'T') {
		return TYPE_bat;
	}
	i = ATOMindex(v);
	return (i<0)?0:i;
}
@- TBL_getname
For debugging purposes it may become necessary to locate the string
associated with a pointer in the fcntable.
@c
str TBL_getname(ptr imp) {
	BAT 	*b = BATmirror(TBL_fcn_imp);
	BUN	bun;
	oid	*fid;
	str 	s=0;

	TBL_set_readlock();
	if ((fid = BUNtailfnd(oid, b, bun, &imp)) == 0) {
	    GDKerror("TBL_getname: inexistent function %p.\n", imp);
	} else if ((s = BUNtailfnd(char, TBL_fcn_nme, bun, fid)) == 0) {
	    GDKerror("TBL_getname: no name for function %d.\n", fid);
	}
	TBL_unset_readlock();
	return s;
}

@- TBL_getddir
Obtains a list of modules by looking at what files are present in the
module directory.
@c
BAT* TBL_getdir() {
    BAT *b = BATnew(TYPE_int, TYPE_str, 100);
    int i = 0;
   
#ifndef STATIC 
    char *name,*basename;
    int liblen = strlen("lib_");

    MSP_rewind_module_list();
    while(TRUE) {
            name=MSP_next_module();
            if (!name) break;
            basename=strrchr(name,DIR_SEP)+1;
	    if (strncmp(basename,"lib_",liblen)==0)
	       basename+=liblen;
            BUNins(b, &i, basename);
            i++;
    }
#else 
    for(i=0; i<DL_TABLE_MAXLIBS; i++)  
    	if (DL_mod[i] != NULL) {
            BUNins(b, &i, DL_mod[i]);
        }
#endif
    return b;
}

@- TBL_atomname
Atom names may be qualified by leading underscores. These are
considered internal and removed.
@c
char *TBL_atomname(int atm) {
	char *s = ATOMname(atm), *t=s; 
	while(*t) {
		if (*t++ == '_') return t;
	}
	return s;
}


@+ Interface for Extension Modules
@- TBL_Install_Info
We expect this function NOT to be called if the module is already
in use. (That is <name>_Module_Install should not even be called.)
@c
int TBL_fcn_pro_size = 0;
oid TBL_oid = 10000; /* we cannot use the db oids, as the user may change
		 	the current number. This will turn around the order 
			of the functions in the function tables, corrupting
			the order in which function resolution should happen */

oid /* An oid is generated */
TBL_Install_Info( TBLinstall *inst, str owner, str name) {
  oid mid = 0;

  dlFPRINTF(GDKerr, "  TBL_Install_Info(%s, %s) = %d\n", owner, name, mid);
@-
if it is already loaded then we delete it, this implies
that the TBL_Install_Info is the same as reload (delete)
so dependencies should not reinstall modules?
SHOULD NEVER OCCUR UNDER NEW 'RECURSIVE LOADING' POLICY! <= P. Boncz
@c
  if ((mid=TBL_module_lookup(name))) {
    	WARNING("TBL_Install_Info: The module %s will be reloaded.\n", name);
      	TBL_unloadmod(inst->client, name, inst->level+1);
  }

  mid = TBL_oid++;

  BUNins(TBL_mod_nme, &mid, name);
  {
    int zero = 0;
    BUNins(TBL_mod_cnt, &mid, &zero);
  }

  return mid;
}


@+ Initialization
Most dictionary tables are created once and loaded upon system 
restart. By keeping the reference count at one we are assured that 
they remain fixed in memory for the duration of the session.

@= TBL_create
   TBL_@1_@2 = TBL_create(monet_clients, "@1_@2", BATnew(TYPE_@3, TYPE_@4, @5));
   if (@6) BATkey(TBL_@1_@2,@6);
   if (@7) BATkey(BATmirror(TBL_@1_@2),@7);
@= VAR_create
   sprintf(buf, "%s_%s", @1, nme);
   v = VARnew(client-monet_clients, buf); 
   v->binding.val.bval = b->batCacheid;
   v->binding.vtype = TYPE_bat;
   v->binding.len = 0;
   VARfreeze(v);
   VARfixate(v);
@c
BAT *TBL_create(Client client, str nme, BAT *b) {
	char buf[128];
	Variable v;

	BATmode(b, TRANSIENT);
	@:VAR_create("monet")@
	BBPrename(b->batCacheid, buf);
	if (client == monet_clients && strchr(nme,'_') == NULL) {
		@:VAR_create("adm")@
	}
	return b;
}

BAT *TBL_lookup( Client client, str nme ){
	char buf[128];
	Variable v;
	BAT *b = NULL;

   	sprintf(buf, "monet_%s", nme);
	v = VARfind(&monet_cntxt[client->stk].outer, buf);
	if (v){ /* dirty replacement of the client bats */
		BAT *o = BATdescriptor(v->binding.val.bval);
		b = BATcopy(o);
		BBPunfix(o->batCacheid);
   		v->binding.val.bval = b->batCacheid;
	} else {
		GDKerror("variable %s not found\n",  buf );
	}
	return b;
}

@- TBL_Init
The TBL initialization creates a set of function tables. 
Subsequently the starting address of all built-in functions is stored,
(and documentary information) [Should be removed or used as a view]
Since all code will move to modules this function will be come obsolute.
@c
void TBL_init() {
        TBL_protector = MT_create_lock();
        TBL_writelock = MT_create_lock();
        TBL_barrier = MT_create_sema(0);

	TBL_M_lock(NULL);

@- Empty the function table.
Since the BBP will no longer store these tables only creation is needed
@c
 	@:TBL_create(fcn,fcn,oid,ptr,600,BOUND2BTRUE,TRUE)@	
 	@:TBL_create(fcn,imp,oid,ptr,600,BOUND2BTRUE,FALSE)@	
 	@:TBL_create(fcn,tpe,oid,int,600,BOUND2BTRUE,FALSE)@	
 	@:TBL_create(fcn,mid,oid,oid,600,BOUND2BTRUE,FALSE)@	
	(void) BATprepareHash(BATmirror(TBL_fcn_mid));
 	@:TBL_create(fcn,sig,oid,str,100,BOUND2BTRUE,FALSE)@	
 	@:TBL_create(fcn,dsc,oid,str,500,BOUND2BTRUE,FALSE)@	
 	@:TBL_create(fcn,aut,oid,str,500,BOUND2BTRUE,FALSE)@	
 	@:TBL_create(fcn,dat,oid,str,500,BOUND2BTRUE,FALSE)@	
 	@:TBL_create(fcn,nme,oid,str,600,BOUND2BTRUE,FALSE)@	
 	@:TBL_create(fcn,pro,oid,str,2400,FALSE,FALSE)@	
 	@:TBL_create(fcn,cnt,oid,int,600,BOUND2BTRUE,FALSE)@	
	
@- Look up the module table.  
@c
        @:TBL_create(mod,nme,oid,str,40,BOUND2BTRUE,TRUE)@
        @:TBL_create(mod,cnt,oid,int,40,BOUND2BTRUE,FALSE)@
        @:TBL_create(mod,atm,oid,str,40,FALSE,FALSE)@
        @:TBL_create(mod,acc,oid,str,40,FALSE,FALSE)@
        @:TBL_create(mod,hdl,oid,ptr,40,BOUND2BTRUE,TRUE)@
        @:TBL_create(mod,dep,oid,str,40,FALSE,FALSE)@
        @:TBL_create(mod,use,oid,ptr,40,FALSE,FALSE)@
        @:TBL_create(mod,load,oid,str,40,BOUND2BTRUE,FALSE)@
        @:TBL_create(mod,drop,oid,str,40,BOUND2BTRUE,FALSE)@

@-
The function tables have been updated with session specific
information. This is for the moment sufficient. The tables are not
saved on disk so no commit is needed.
@c
#ifdef MKMODS
	TEM_init();
#endif
	TBL_M_unlock(NULL);
}

@+ Loading and Dropping Modules
@c
oid TBL_M_load(TBLinstall *inst, Client client, str module) {
  ptr hdl;
  int mid = 0;

  dlFPRINTF(GDKerr, "  TBL_M_load(%s)\n", module);
  if (!(hdl = TBL_openmod(client, module))) {
    GDKerror("TBL_loadmod: module load %s cancelled.\n", module);
    return 0;
  }
  if (hdl) {
    char mod_init_name[PATHLENGTH];
    int	(*mod_init)();

    sprintf(mod_init_name, "%s_Module_Install", module);
    mod_init = (int(*)())DL_sym(hdl, mod_init_name);
    if (mod_init != NULL) {
      dlFPRINTF(GDKerr, "    Calling %s\n", mod_init_name);
      mid= (*mod_init)(inst, client->user);
      if (mid == 0 ) {
	/* Not ok, an error is returned! */
	/* we should bail out! */
	GDKerror("TBL_M_load: %s_Module_Install experienced an error!\n", module);
	DL_close(hdl);
	return 0;
      }
    } else {  /* is not a "module" */
      dlFPRINTF(GDKerr, "    No function %s\n", mod_init_name);
    }
  }    
  if (!hdl) {
    GDKerror("TBL_M_load: module %s does not exist.\n", module);
    return 0;
  }
  
  BUNdelHead(TBL_mod_hdl, &mid);
  BUNins(TBL_mod_hdl, &mid, &hdl);
  dlPRINT("TBL_M_load: Everything is ok, let's return...\n");
  return mid;
}

int TBL_M_client_install(Client client, int mid) {
  int i, aid;
  char *nme;
  char s[80];
  char *usr = client->user;
  BAT *fcn_mid = BATmirror(TBL_fcn_mid);
  oid fid;
  BUN b;

  dlPRINT("  TBL_M_client_install");

  /* Install all atoms in user atomtbl.
   */
  (void) BATprepareHash(TBL_mod_atm); 
  HASHloop_oid(TBL_mod_atm, TBL_mod_atm->hhash, i, &mid, b) {
    char *p;

    nme = BUNtailptr(char, TBL_mod_atm, b, i);
    sprintf(s, "%s_%s", usr, nme);
    /*sprintf(s, "%s", nme);*/
    if ((p = strchr(s, '=')) != NULL) *p = 0;
    nme = s+strlen(usr)+1; 
    if ((aid = ATOMindex(nme)) < 0) {
      GDKerror("TBL_M_client_install: atom '%s' unknown.\n", nme);
    } else {
      BUNins(client->atomtbl, nme, &aid);
    }
  }

  /* Install all accelerators in user acctble
   */
  (void) BATprepareHash(TBL_mod_acc); 
  HASHloop_oid(TBL_mod_acc, TBL_mod_acc->hhash, i, &mid, b) {
    nme = BUNtailptr(char, TBL_mod_acc, b, i);
    sprintf(s, "%s_%s", usr, nme);
    nme = s+strlen(usr)+1; 
    if ((aid = ACCindex(nme)) < 0) {
      GDKerror("TBL_M_client_instal: accelerator '%s' unknown.\n", nme);
    } else {
      BUNins(client->acctbl, nme, &aid);
    }
  }

  /* Install all functions and operations in user fcntbl.
   */
  (void) BATprepareHash(fcn_mid);
  HASHloop_oid(fcn_mid, fcn_mid->hhash, i, &mid, b) {
    fid = *BUNtailptr(oid, fcn_mid, b, i);
    BUNins(client->fcntbl, 
	   BUNtailfnd(char, TBL_fcn_nme, b, &fid), &fid);
  }
  return 1;
}

int TBL_M_directloaded(Client client, oid mid, str module) {
  int xx, yy=0, zz=0;
  BUN p, q;

  /* count the number of *our* dependencies to 'module' */
  BATloopFast(TBL_mod_dep, p, q, xx) 
	if (strCmp(module,BUNtvar(TBL_mod_dep,p)) == 0 &&
  	    BUNlocate(TBL_mod_use,BUNhloc(TBL_mod_dep,p),&client) != NULL) yy++;

  /* count the number of times we ourselves have loaded 'module' */
  BATloopFast(TBL_mod_use, p, q, xx) 
	if (*(oid*)BUNhloc(TBL_mod_use,p) == mid && 
	    *(Client*)BUNtloc(TBL_mod_use,p) == client) zz++;

  if (zz > yy) return TRUE; 
  if (zz < yy) 
  GDKwarning("TBL_M_directloaded: %s relative refcounts are wrong (%d!=%d)!\n",
		module, zz, yy);
  return FALSE;
}

int TBL_M_countref(int mid) {
  int xx, yy=0;
  BUN p, q;

/*debug*/
  BATloopFast(TBL_mod_use, p, q, xx) 
	if (*(int*)BUNhloc(TBL_mod_use,p) == mid) yy++;

  xx = *BUNtailfnd(int, TBL_mod_cnt, p, &mid);

/*debug*/
  if (xx != yy) 
  GDKwarning("TBL_M_countref: mod(%d) refcnt %d: should be %d.\n",mid,xx,yy);

  return yy;
}

int TBL_M_incref(Client client, int mid) {
  int i = TBL_M_countref(mid);

  BUNins(TBL_mod_use, &mid, &client);
  i++;
  BUNreplace(TBL_mod_cnt, &mid, &i);
  dlFPRINTF(GDKerr, "  TBL_M_incref = %d\n", i);

  return 1;
}

int TBL_M_decref(Client client, int mid) {
  int i = TBL_M_countref(mid);

  if (i <= 0) {
	GDKwarning("TBL_M_incref: mod(%d) cannot decrease refcnt\n", mid);
  } else {
	BUN p = BUNlocate(TBL_mod_use, &mid, &client);
	BUNdelete(TBL_mod_use, p);
	if (--i == 0) {
		BUNdelHead(TBL_mod_nme, &mid);
		BUNdelHead(TBL_mod_cnt, &mid);
	} else {
		BUNreplace(TBL_mod_cnt, &mid, &i);
	}
  }
  dlFPRINTF(GDKerr, "  TBL_M_decref = %d\n", i);
  return i;
}


@- TBL_M_initscript 
finds the possible load MIL script
for the module, adds it at the end of the string,
reallocating if it is too short. Since this
routine is called after "installing" all dependencies
the order of the substrings (MIL load scripts) will be correct.
@c
int TBL_M_initscript(int mid, str *initstr) {
  char *p = BUNfnd(TBL_mod_load,&mid);
  int i, j;
  BUN b;

  /* Lookup MIL init script, and add it to the
   * end of the present initscript.
   * since it is added
   */
  if (p != NULL) {
    b = (char *) BUNtvar(TBL_mod_load,p);
    i = (*initstr)?strlen(*initstr):0;
    j = strlen(b) + 1;
    *initstr = GDKrealloc((int*)(*initstr), i+j+1);
    memcpy((*initstr)+i, b, j);
    (*initstr)[i+j-1] = '\n';
    (*initstr)[i+j] = 0;
  }
  dlFPRINTF(GDKerr, "  TBL_M_initscript\n----\n");
  return 1;
}

@- TBL_loadmod:
@T
byuser == cinstalled to the client
\begin{verbatim}
loaded	byuser	level	ACTION (in order!)
------- ------- ------- ----------------------------------------------
0	X	0	lock/       load/cinstall/incref/unlock
0	X	>0	            load/cinstall/incref
1	0	X	                 cinstall/incref
1	1	0	lock/                     incref/unlock
1	1	>0	                                 incref
\end{verbatim}
\begin{description}
\item[lock]	lock(tbl\_writelock)
\item[unlock]	unlock(tbl\_writelock)
\item[load]	openmod/mod\_inst
\item[unload]	TBL\_unload (includes decref,cunstall)
\item[cinstall]	copy TBL\_ to client->
\item[mod\_inst]	dlsym/<name>\_Module\_Install (that calls TBL\_Inst\_Depend)
\item[cinstall]	copies to client->xx tables and returns MIL init script.
\begin{description}
@
@c


oid TBL_loadmod(Client client, str module, int level, str *initstr) {
  /* State
   */
  TBLinstall inst;
  int loaded = 0;
  int byme = 0;
  int cinstalled = 0;

  /* handles
   */
  oid mid = 0;

  dlFPRINTF(GDKerr, "TBL_loadmod(,%s,%d,)\n", module, level);
@
Save some state for recursive calls, without explicit arguments
@c
  /* identify as father
   */
  while (client->father != -1) {
	client = monet_clients + client->father; 
  }
  inst.client = client;
  inst.initstr = initstr;
  inst.level = level;

@
Lets do the things in the right order, see above!
@c
  if (level == 0) TBL_M_lock(NULL);

  mid = TBL_module_lookup(module);
  loaded = (mid != 0);
  if(!loaded)
	byme = 1;
  
  dlFPRINTF(GDKerr, "  loaded = %d\n", loaded);

  cinstalled = TBL_M_cinstalled(client, mid);

  dlFPRINTF(GDKerr, "  installed = %d\n", cinstalled);

  if (!loaded) {
    mid = TBL_M_load(&inst, client, module); /* generates a mid! */
    loaded = (mid != 0);
  }
  dlFPRINTF(GDKerr, "  loaded = %d, mid = %d\n", loaded, mid);

  if (!loaded)
    goto xit;

  if (loaded && !cinstalled) {
    dlPRINT("TBL_loadmod: loaded but not installed! Installing...\n");
    cinstalled = TBL_M_client_install(client, mid);
    dlFPRINTF(GDKerr, "  installed = %d\n", cinstalled);
  }

  TBL_M_incref(client, mid);

  if (loaded && cinstalled && byme)
  	TBL_M_initscript(mid, initstr);

 xit:
  if (level == 0) TBL_M_unlock(client);
  return (cinstalled != 0);
}


@- TBL_unloadmod
@c
/* TODO: make safe for multithreading; refuse to unload if dependent BATs are pinned */
static void purge_dependent_bats(int ntpes, int *tpes, int naccs, int *accs) {
        int i, j, mbats=80, nbats=0, *bats=(int*) GDKmalloc(mbats*sizeof(int));

        for(j=1; j < BBPsize; j++) {
                BAT *b = BBP_cache(j);
                if (b == NULL) continue;
		for(i=0; i<ntpes; i++) 
                    if ((BATttype(b) == tpes[i]) || (BAThtype(b) == tpes[i]))
                        goto doswap;
		for(i=0; i<naccs; i++) 
                    if ((b->tacctype == accs[i]) || (b->hacctype == accs[i]))
                        goto doswap;
                continue;
doswap:         if (BBP_plevel(b->batCacheid)) {
                        BBPfree(b);
                } else {
			bats[nbats++] = ABS(b->batCacheid);
			if (nbats == mbats) 
			 bats = (int*) GDKrealloc(bats, (mbats*=2)*sizeof(int));
                }
        }
	VARpurge(nbats, bats, ntpes, tpes);
	GDKfree(bats);
}


int TBL_unloadmod(Client client, str module, int level) {
	Client father = client;
	BAT *fcn_mid = BATmirror(TBL_fcn_mid);
	BAT *b, *fcntbl = BATmirror(client->fcntbl); 
       	char *nme, *r, *p, *q;
	int i, ret = level, refcnt = 0;
	oid aid, fid, mid; 
	int maccs=80, mtpes=80, naccs=0, ntpes=0;
	int *accs = (int*) GDKmalloc(maccs*sizeof(int));
	int *tpes = (int*) GDKmalloc(mtpes*sizeof(int));
	int (*addr)();

  	/* identify as father
         */
	while (father->father != -1) {
		father = monet_clients + father->father; 
  	}

	if (level==0) TBL_M_lock(father);
@-
Look up the module.
@c
  	mid = TBL_module_lookup(module);
  	if (mid == 0) {
		GDKerror("TBL_unloadmod: module %s does not exist.\n", 
			module); ret=0; goto xit;
	}
@-
Check if it is in use already.
@c
	if (level == 0) {
		r = BUNlocate(TBL_mod_use, &mid, &father);
		if (r == NULL) {
			GDKerror("TBL_unloadmod: %s was not loaded.\n", module);
       	    		goto xit;
		}
		if (!TBL_M_directloaded(father, mid, module)) {
			GDKerror("TBL_unloadmod: others need %s.\n", module);
			goto xit;
		}
	}
	if ((refcnt = TBL_M_decref(father, mid)) > 0 )
		goto xit;

@-
Delete all the modules's functions from user table.
@c
	(void) BATprepareHash(fcn_mid);
	HASHloop_oid(fcn_mid, fcn_mid->hhash, i, &mid, r) {
		fid = *BUNtailptr(oid, fcn_mid, r, i);
		BUNfndOID(r,fcntbl, &fid);
		if (r != NULL) {
			BUNdelete(fcntbl, r);
		}
	}
@-
Delete all the modules's atoms from user table.
@c
	(void) BATprepareHash(TBL_mod_atm); 
	HASHloop_oid(TBL_mod_atm, TBL_mod_atm->hhash, i, &mid, r) {
	   	char buf[PATHLENGTH];
		strcpy(buf, BUNtailptr(char, TBL_mod_atm, r, i));
		if ((p = strchr(buf, '=')) != NULL) *p = 0;
		r = (char *) BUNfnd(father->atomtbl, buf);
		if (r != NULL) {
			aid = *(int*) BUNtloc(father->atomtbl, r);
			BUNdelete(father->atomtbl, r);
			if (BUNfnd(father->atomtbl, buf) == NULL) {
				tpes[ntpes++] = aid;
				if (ntpes == mtpes) 
					tpes = (int*) GDKrealloc(tpes, (mtpes*=2)*sizeof(int));
			}
		}
	}
@-
Delete all the modules's accelerators from user table.
@c
	(void) BATprepareHash(TBL_mod_acc); 
	HASHloop_oid(TBL_mod_acc, TBL_mod_acc->hhash, i, &mid, r) {
		nme = BUNtailptr(char, TBL_mod_acc, r, i);
		r = (char *) BUNfnd(father->acctbl, nme);
		if (r != NULL) {
			accs[naccs++] = *(int*) BUNtloc(father->acctbl, r);
			if (naccs == maccs) 
			 accs = (int*) GDKrealloc(accs, (maccs*=2)*sizeof(int));
			BUNdelete(father->acctbl, r);
		}
	}
	purge_dependent_bats(ntpes, tpes, naccs, accs);
@-
If there are no more users loading it, delete it from memory.
@c
        if (refcnt == 0) {
		ptr hdl = NULL;
	
		b = BAT_select(TBL_fcn_mid, &mid, &mid, FALSE);
		BUNfndOID(p,TBL_mod_hdl,&mid);
		if (p != NULL) hdl = *(ptr*) BUNtloc(TBL_mod_hdl,p);

		/* Call the internal deletion routine.  */
		if (hdl != NULL) {
     		    char mod_del_name[PATHLENGTH];
     		    sprintf(mod_del_name, "%s_Module_Delete", module);
		    addr = (int (*)()) DL_sym(hdl, mod_del_name);
		    if (addr != NULL) (*addr)();
		    BUNdelete(TBL_mod_hdl, p);
		    DL_close(hdl);
		}		

		/* delete all function references in the TBL_ bats */
		BATloop(b, p, q) {
			TBL_Deinstall_Function(*(oid*) BUNhloc(b,p));
		}
		BBPreclaim(b);
	}
@-
Now drop all dependency modules 
@c
	b = BAT_select(BATmirror(TBL_mod_dep), &mid, &mid, FALSE);
	BUNdelHead(TBL_mod_dep, &mid);
	BATloop(b,p,q) {
	    if (TBL_unloadmod(client, BUNhead(b,p),level+1) == 0)
		GDKwarning("TBL_unloadmod: module %s: dependencies.\n", module);
	}
	BBPreclaim(b);
@-
Everything OK.
@c
	ret = 1;
xit:	if (level==0) {
		TBL_M_unlock(father);
	}
	GDKfree(accs);
	GDKfree(tpes);
	return ret;
}

void TBL_drop(Client client, str module, int level) {
	Client father = client;
	char *p;
	oid mid;

	/* Go ahead with module drop: first execute the MIL exit script
         */
	BUNfndOID(p,TBL_mod_drop, &mid);
	if (p != NULL) {
		ValRecord v;
	   	TBL_M_unlock(father);
		interpret_str(client->maxstk, BUNtvar(TBL_mod_drop,p), &v);
	   	TBL_M_lock(father);
	}
}

@+ Function Resolution
@- TBL_search
The parser uses the routine TBL_search to locate the internal value
of an identifier. 
@c
char *TBL_search(str s, int *t, int command_hint) {
	char *assignop=NULL, *p, *v, *name = s, *ret = 0;
	Client c, lookup = ll_client;
	int tpe = ATOMindex(s);

	if (tpe >= 0) {
	    str atm = BATatoms[tpe].name; 
	    strcpy(s, atm);
	    *t = TOK_ATOM;
	    return atm;
	}
	TBL_set_readlock();
again:	c = lookup;
	if ( name != NULL ) {
	    p = BUNfnd(c->fcntbl, name);
	    if (p != NULL) {
		oid fid = *((oid *) BUNtail(c->fcntbl, p));
		*t = *BUNtailfnd(int, TBL_fcn_tpe, v, &fid);

		if (*t == TOK_BUILTIN) {
		    ret = (char *) *BUNtailfnd(ptr, TBL_fcn_imp, v, &fid);
		} else { 
		    ret = BUNhvar(c->fcntbl, p);
		}
	    } else if (c->fcntbl != monet_clients->fcntbl) { 
		/* check adm tables as well */
 	        lookup = monet_clients;
		goto again;
	    }
 	} 
@-
We recognize '+=' (and similar for other operators than +) as an TOK_ASSIGNOP.
@c
	if (assignop) {
		GDKfree(assignop);
		if (*t != TOK_OPERATOR && *t != TOK_COMMAND) {
		    ret = NULL;
		} else {
		    *t = TOK_ASSIGNOP;
		}
	} else if (ret == NULL && name[strlen(name)-1] == '=') {
		name = assignop = GDKstrdup(*name==':'?name+1:name);
	        name[strlen(name)-1] = 0;
		c = ll_client;
		goto again;
	}
@-
if not found, the default is to say it is an identifier. 
However, with the command-hint passed, we guess it is a command.
@c
	if (ret == NULL && command_hint && tpe < 0) {
		ret = s;
		*t = TOK_COMMAND;
	}
	TBL_unset_readlock();
	return ret;
}

@- TBL_normal_resolve
The routine TBL_ntormal_resolve searches the table of function definitions
for one that matches the signature of the call. The first function that
matches is returned.
The type check is a function call derived from the module spec. 
@c
int TBL_normal_resolve(str name, int argc, ValPtr argv, 
                       monet_sig_t *sig, Cntxt stk)
{
	int	ret = -1;
	str	v;
	paramcheck_t pt;
        Client  c, lookup;
 
        CNTXTclient(stk, &lookup);
@- 
Try to resolve the function to an address.
@c
	TBL_set_readlock();
	TBL_checkparams_init(&pt, argc, argv);

again:  c = lookup;
	{   BAT *b = c->fcntbl;
	    int	i,j, tpe;
	    BUN p;

	    (void) BATprepareHash(b);
	    HASHloop_str(b, b->hhash, i, name) {
		oid fid = *BUNtailptr(oid, b, v, i);

		BUNfndOID(p,TBL_fcn_tpe,&fid);
		tpe = *(int*) BUNtloc(TBL_fcn_tpe,p);

		if (tpe == TOK_ITERATOR) {
		    continue;
		}

		BUNfndOID(p, TBL_fcn_pro, &fid);
		if (p && (j=TBL_checkparams(&pt,fid)) < 0) {
			if (j == -2) ret = -2;
			continue;
		}
@-
Found IT: substitute name by address.  
@c
		BUNfndOID(p, TBL_fcn_imp, &fid);
		sig->pack_fcn = *(PackFcn*) BUNtloc(TBL_fcn_imp,p);
		sig->ret_tpe = j;

		if (tpe == TOK_PROC) {
		    sig->fast_fcn = (GDKfcn) sig->pack_fcn;
		} else {
		    BUNfndOID(p, TBL_fcn_fcn, &fid);
		    if (p == NULL) {
                	sig->fast_fcn = NULL;
		    } else {
                	sig->fast_fcn = *(GDKfcn*) BUNtloc(TBL_fcn_fcn,p);
		    } 	
		} 	
		TBL_unset_readlock();
		return (tpe==TOK_OPERATOR)?TOK_COMMAND:tpe; /* simplify */
	    }
	    if (c->fcntbl != monet_clients->fcntbl) { 
		/* check adm tables as well */
 	        lookup = monet_clients;
		goto again;
	    }
	}
	TBL_unset_readlock();

	return ret;
}

@- multiplex Analysis Of The BAT Parameters
Do basic check on parameters. Look at the tail types in order to derive
a function signature. Check that all head types correspond. We also want
to discover if all the input BAT parameters are sorted or in sync. This
may enable the use optimizations. Constants passed into the multiplex
operator are a special case.
@c
#define RETURN(x)	tok=x; goto ready;

int TBL_multiplex_resolve(str name, int argc, ValPtr argv, 
			  monet_sig_t *sig, Cntxt stk)
{
	int optimize = FALSE, optimize_true = TRUE;
	int consts = 0, i=0, tok=TOK_COMMAND, tpe = -1;
        lng swap[MAXPARAMS];
        BAT *assignbat = NULL;
 
        if (argc <= 1) {
                GDKerror("interpret: 0 param multiplex operator.\n");
		return -1;
        }
        sig->array_opt = sig->merge_opt = 0;
	sig->ret_tpe = -1; 
        for(i=1; i < argc; i++) {
            swap[i] = 0;
            if (argv[i].vtype == TYPE_bat && argv[i].len != int_nil) {
                BAT *b = BATdescriptor(argv[i].val.bval);
                int z = 0;
                ptr p = ATOMnilptr(b->ttype);

		if (b->ttype == TYPE_void) {
			optimize_true = FALSE;
		} 
                argv[i].vtype = ATOMtype(b->ttype);
                swap[i] = argv[i].val.lval;
 
                /* we might need a real value for function resolution! */
                if (b->ttype == TYPE_bat) {
                    p = (BATcount(b) <= 0)?((ptr) &z):BUNtloc(b, BUNfirst(b));
                }
                VALset(argv+i, b->ttype, p);
 
                if (tpe < 0) {
                    tpe = b->htype;
            	    if (i == 1 && sig->assignop) {
			assignbat = b;
            	    }
                } else if (ATOMtype(tpe) != ATOMtype(b->htype)) {
		    argc = i+1;
		    RETURN(-2);
                }
	    } else {
	        consts++;
	    }
        }
@-
At least one BAT should be there..
@c
        if (tpe < 0) {
            GDKerror("[%s%s]: needs at least one BAT param.\n", name,
							sig->assignop?"=":"");
	    RETURN(-2);
        }
        tpe = ATOMstorage(ATOMtype(tpe));
@- 
For the [A?B:C] multiplex operators, certain restrictions exist on the type
(BIT) and number of their parameters (2 or 3).
@c
        if (sig->special) {
            if (argv[1].vtype != TYPE_bit) {
                GDKerror("[%s%s]: first param must be a BIT vector.\n", name, 
							sig->assignop?"=":"");
	        RETURN(-2);
            }
            if ((sig->special==1)?(argc != 4):(argc != 3)) {
                GDKerror("[%s%s]: wrong number of params.\n", name, 
						sig->assignop?"=":"");
	        RETURN(-2);
	    }
            if ((sig->special==1) && ATOMtype(argv[3].vtype) != ATOMtype(argv[2].vtype)) {
	        RETURN(-2);
            }
            sig->ret_tpe = ATOMtype(argv[2].vtype); /* store return type here */
	    if (sig->special == 1) {
	    	sig->pack_fcn = CMDifthenelse;
	    	sig->fast_fcn = interpret_ifthenelse;
	    } else if (sig->special == 2) {
	    	sig->pack_fcn = CMDifthen;
	    	sig->fast_fcn = interpret_ifthen;
	    } else if (sig->special == 3) {
	    	sig->pack_fcn = CMDifelse;
	    	sig->fast_fcn = interpret_ifelse;
	    }
        } else if ((tok=TBL_normal_resolve(name, argc, argv, sig, stk)) < 0) {
	    RETURN(tok);
        } 
@-
constraints for assigment-multiplexing: first must be identically typed BAT
@c
        if (sig->assignop) {
	    if (assignbat == NULL) {
                GDKerror("[%s=]: assignment to non-bat parameter.\n", name);
		RETURN (-1);
	    } else if (assignbat->ttype != sig->ret_tpe) {
                GDKerror("[%s=]: assignment of bat[%s,%s] to bat[% s,%s]\n", 
		    name, ATOMname(assignbat->htype), ATOMname(sig->ret_tpe), 
		    ATOMname(assignbat->htype), ATOMname(assignbat->ttype));
		RETURN (-1);
	    }
        }
@- optimization check
@T
The generic multiplex implementation fills an (argc,argv) array
of @%ValRecord@ structures before each tuple call. That tuple call 
then reconstructs the original atomic values from its (argc,argv)
parameters. 

We pick collection of interesting cases to optimize, and leave the
(argc,argv) way as a generic implementation for all non-optimizwed cases.
These cases are:
\begin{itemize}
\item unary, binary or 3-ary operators,
\item returning a fixed sized atomic type (BAT is forbidden too).
\item without ANY-type overloading or varargs as actual parameters.
\item that lookup is easy (all head columns unique and either all synced 
      or all sorted).
\end{itemize}
The last condition can only be checked at run-time. It actually splits the
optimizations in two classes: namely array-lookup or merge-lookup.
Both have differnt run-time constraints. we compute now whether
our other criteria allow for execution of thexe optimizations, 
and store the results in resp. sig->array\_opt and sig->merge\_opt.
@c
	if (sig->special) {
		optimize = optimize_true;
	} else if (tok != TOK_PROC && sig->fast_fcn && argc <= 3 &&
		(BATatoms[sig->ret_tpe].atomFix == NULL) &&
	        sig->ret_tpe != TYPE_void && ATOMvarsized(sig->ret_tpe) == 0)
	{
		str t_argv[MAXPARAMS+1];
        	int t_argc = TBL_getparams((ptr)sig->pack_fcn, t_argv);

        	for(i=1; i<t_argc; i++) {
            		if (ATOMindex(t_argv[i]) < 0) {
                		break; /* recognizes simple atoms only! */
            		}
		} 

        	if (i == t_argc) { /* passed the test? */
			optimize = optimize_true;
		}
        }
	if (optimize) {
        	sig->array_opt = !ATOMvarsized(tpe);
        	sig->merge_opt = (consts==0) && (tpe == ATOMstorage(TYPE_oid));
	}
@- 
Ready With Resolution
@c
ready:	for(i=1; i < argc; i++) {
                if (swap[i]) {
                        argv[i].vtype = TYPE_bat;
                        argv[i].val.lval = swap[i];
                }
        }
        return tok;
}


int TBL_setaggr_resolve(str nme, int argc, ValPtr argv, 
                        monet_sig_t *sig, Cntxt stk)
{
        ValRecord param[2];
        BAT *extent, *b, *tmp;
	int tok;
 
        if (argc > 3  || argc < 2){
		GDKerror("{%s}(Y):  1 or 2 params expected.\n", nme); 
		return -1;
        }
        if (argv[1].vtype != TYPE_bat || !(b=BATdescriptor(argv[1].val.bval))){
                GDKerror("{%s}(Y): must have BAT params\n", nme); 
		return -2;
        }
        if (b->ttype == TYPE_void && b->tseqbase == oid_nil) {
		GDKerror("{%s}(Y): void tailtype not allowed.\n", nme); 
		return -1;
        }
        if (argc == 3) {
            if (argv[2].vtype != TYPE_bat ||
                !(extent=BATdescriptor(argv[2].val.bval)))
            {
                GDKerror("{%s}(Y): must have BAT params\n", nme); 
		return -2;
            }
            if (TYPEerror(b->htype, extent->htype)) {
                GDKerror("{%s}(Y): incompatible extent.\n", nme); 
		return -2;
            }
            if (extent->hkey == FALSE) {
		BATpropcheck(extent); /* try to derive hkey */
	    }
            if (extent->hkey == FALSE) {
                GDKerror("{%s}(Y): extent must contain unique values.\n", nme);
		return -1;
            }
        }
        tmp = BATnew(BATttype(b), BATttype(b), 1);
        param[1].vtype = TYPE_bat;
        param[1].val.bval = tmp->batCacheid;
 
        tok = TBL_normal_resolve(nme, 2, param, sig, stk);
        BBPreclaim(tmp);
	if (tok < 0) return tok;
	    
	if (sig->ret_tpe == 0) {
                GDKerror("{%s}(Y): 'any' return types not allowed.\n", nme);
		return -1;
	}
        return tok;
}

@- TBL_printsigs
prints all signatures of known commands/procs with a certain name.
@c
static int formatsig(str s, str nme, oid fid){
	str src = s;
	BUN p;

	BUNfndOID(p, TBL_fcn_sig, &fid);
	if (p) {
		/* precooked */
		strcpy(s, BUNtvar(TBL_fcn_sig,p)); 
	} else {
		BUNfndOID(p, TBL_fcn_pro, &fid);
		strcpy(s,nme); s += strlen(s); *s++ = '(';
		if (p == NULL) {
			/* no signature restrictions */
			strcpy(s, "..any..) : any"); s += strlen(s); 
		} else {
			/* construct signature on the fly */
			str argv[MAXPARAMS+1];
			int k, argc = getparams(fid, argv);
			for(k=1; k<argc; k++) {
				str param = argv[k];
				if (k > 1) { 
					*s++ = ','; *s++ = ' '; 
				}
				if (*argv[k] == '*') {
					*s++ = '.'; *s++ = '.'; 
					param++;
				}
				strcpy(s, param); s += strlen(s);
				if (*argv[k] == '*') {
					*s++ = '.'; *s++ = '.'; 
				}
			}
			*s++ = ')'; *s++ = ' '; *s++ = ':'; *s++ = ' '; 
			strcpy(s, argv[0]); s += strlen(s); 
		}
	}
	return s-src;
} 

void TBL_printsigs(str s, int stk, str nme) {
	int 	i, j = 0;
	BAT*	b;
        Client  c;
 
        CNTXTclient(stk, &c);
        b = c->fcntbl;
	TBL_set_readlock();
	(void) BATprepareHash(b);
	HASHloop_str(b, b->hhash, i, nme) {
		BUN p = BUNptr(b, i);
		oid fid = *(oid*) BUNtloc(b, p);
		if (j++ == 0) {
			sprintf(s, "!MAYBE YOU MEAN:\n");
			s += strlen(s);
		}
		*s++ = '!'; 
		*s++ = '\t';
		s += formatsig(s, nme, fid);
		*s++ = '\n'; 
	}
	*s++ = 0;
	TBL_unset_readlock();
}

@- TBL_formatsig
@c
int TBL_formatsig(str s, oid fid){
	BUN p;

	TBL_set_readlock();
	BUNfndOID(p, TBL_fcn_nme, &fid);
	if (p == NULL) {
		TBL_unset_readlock();
		return FALSE;
	}
	formatsig(s, BUNtvar(TBL_fcn_nme,p), fid);
	TBL_unset_readlock();
	return TRUE;
}


@- TBL_iterator
Like TBL_search, but intened to do lookup for iterators.
@c
void *TBL_iterator(Cntxt stk, str name, int argc, ValPtr argv){
	paramcheck_t pt;
        Client  c, lookup;
	char *v;
	int i;
 
        CNTXTclient(stk, &lookup);
 
	TBL_set_readlock();
	TBL_checkparams_init(&pt, argc, argv);
again:  c = lookup;
	(void) BATprepareHash(c->fcntbl);
	HASHloop_str(c->fcntbl, c->fcntbl->hhash, i, name) {
		oid fid = *BUNtailptr(oid, c->fcntbl, v, i);
		int tpe = *BUNtailfnd(int, TBL_fcn_tpe, v, &fid);

		if (tpe == TOK_ITERATOR) {
		    if (TBL_checkparams(&pt,fid) >= 0) {
			TBL_unset_readlock();
	    		GDKfree(name);
			return *BUNtailfnd(void*, TBL_fcn_imp, v, &fid);
	       	    } 
		}
 	} 
	if (c->fcntbl != monet_clients->fcntbl) { 
		/* check adm tables as well */
 	        lookup = monet_clients;
		goto again;
	}
	TBL_unset_readlock();
	return (void *) 0;
}

@+ MIL Procedure Management
@- TBL_newproc
registers a new MIL procedure.
@c
#define PROC_TYPE1(t)	((sht*) (&t->yyval.len))[0]
#define PROC_TYPE2(t)	((sht*) (&t->yyval.len))[1]
	
static 
int format_type(YYSTREE t, str *p) {
	int ret = 32768;
	str s = *p;

	if (t == NULL) {
		strcpy(s, "any"); 
	} else if (t->token == TOK_ANY) {
		strcpy(s, "any"); 
		if (t->yyval.val.ival >= 0) {
			sprintf(s+3, "::%d", t->yyval.val.ival);
		}
		ret = t->yyval.val.ival;
	} else {
		strcpy(s, t->yyval.val.sval);
	}
	*p += strlen(s);
	return ret; 
}

void TBL_newproc(Client client, str nme, YYSTREE body, YYSTREE sig, YYSTREE ret) {
	int i, j, tpe = TOK_PROC;
	oid pid = TBL_oid++;
        int zero = 1;

	TBL_M_lock(NULL);
	TBL_fcn_pro_size++;
	if (body == sig) {
	    /* forward definitions will never actually match */
	    BUNins(TBL_fcn_pro, &pid, "<predefinition>");  
	} else { 
	    sht anynum, *any1 = NULL, *any2 = NULL;
	    char returntpe[128];

	    PROC_TYPE1(body) = PROC_TYPE2(body) = 0;
	    if (ret) {
		char *p=returntpe;
		format_type(ret, &p); 

		/* analyze the return type specification */
		if (ret->token==TOK_ATOM) {
		    PROC_TYPE1(body) = ATOMindex(ret->yyval.val.sval); 
		    if (PROC_TYPE1(body) == TYPE_bat) {
			*(p++) = '[';
			format_type(ret->yysons[0], &p);
			*(p++) = ',';
			format_type(ret->yysons[1], &p);
			*(p++) = ']'; *(p++) = 0;
		        if (ret->yysons[0]->token == TOK_ATOM) {
			    PROC_TYPE1(body) += 8192 + ATOMindex(ret->yysons[0]->yyval.val.sval);
			} else { /* TOK_ANY */
			    PROC_TYPE1(body) = ret->yysons[0]->yyval.val.ival;
			    any1 = &PROC_TYPE1(body);
			}
		        if (ret->yysons[1]->token == TOK_ATOM) {
			    PROC_TYPE2(body) += 8192 + ATOMindex(ret->yysons[1]->yyval.val.sval);
			} else { /* TOK_ANY */
			    PROC_TYPE1(body) = ret->yysons[1]->yyval.val.ival;
			    any2 = &PROC_TYPE1(body);
			}
		    } else { /* simple atom */
			PROC_TYPE1(body) += 8192;
		    }
		} else { /* TOK_ANY */
		    PROC_TYPE1(body) = ret->yyval.val.ival; 
		    any1 = &PROC_TYPE1(body);
		}
	    } else {
	        strcpy(returntpe, "any");
	    } 

	    /* insert a signature in TBL_fcn_pro */
	    if (sig == NULL) {
		BUNins(TBL_fcn_pro, &pid, "*any"); 
	    } else {
	        YYSTREE cur=sig; 
		for(j=1; cur; cur=cur->overflow) {
		    for(i=0; i<cur->cnt; i++,j++) {
			char tpenme[512], *p=tpenme;
			YYSTREE t = cur->yysons[i];

			if (t->token == TOK_RANGETEMP) {
			    *(p++) = '*';
			    t = t->yysons[0];
			} 
			/* the any stuff resolves any::X expressions in
                           the return type specification, when we encounter
                           the any::X in the signature */
			anynum = format_type(t, &p);
			if (t->token==TOK_ATOM && strcmp(t->yyval.val.sval, "BAT")==0) {
                            *(p++) = '[';
			    anynum = format_type(t->yysons[0], &p);
			    if (any1 && *any1==anynum) *any1 = 2048+j;
			    if (any2 && *any2==anynum) *any2 = 2048+j;
			    *(p++) = ',';
			    anynum = format_type(t->yysons[1], &p);
			    if (any1 && *any1==anynum) *any1 = 1024+j;
			    if (any2 && *any2==anynum) *any2 = 1024+j;
			    *(p++) = ']'; *(p++) = 0; 
			} else {
			    if (any1 && *any1==anynum) *any1 = 4096+j;
			    if (any2 && *any2==anynum) *any2 = 4096+j;
			    if (t->cnt > 0) t = t->yysons[0];
			    if (t->token == TOK_STRING) {
				*(p++) = '('; 
				strcpy(p, t->yyval.val.sval); 
				p += strlen(p);
				*(p++) = ')'; *(p++) = 0; 
			    }
			}
			BUNins(TBL_fcn_pro, &pid, tpenme); 
 	    	    }
		}
 	    } 
	    if ((any1 && *any1 < 1024) || (any2 && *any2 < 1024)) {
	        if (any1 && *any1 < 1024) PROC_TYPE1(body) = 4096;
	        if (any2 && *any2 < 1024) PROC_TYPE2(body) = 4096;
	    }
	    BUNins(TBL_fcn_pro, &pid, returntpe); 
	}
	BUNins(client->fcntbl, nme, &pid);
	BUNins(TBL_fcn_nme, &pid, nme);
	BUNins(TBL_fcn_imp, &pid, &body);
	BUNins(TBL_fcn_tpe, &pid, &tpe);
	BUNins(TBL_fcn_cnt, &pid, &zero);

	/* use this space only once, so disguise name str as a ptr */
	body->yyval.vtype = TYPE_ptr; 
	body->yyval.len = 0; 

	TBL_M_unlock(client);
}

void TBL_incproc(Client client) {
   	int xx, yy = TOK_PROC;
        BAT *tb, *bb, *cb = BATmirror(client->fcntbl);
	BUN p,q;

	TBL_M_lock(client);
	/* first select procs from function table */
        tb = BATsemijoin(TBL_fcn_tpe, cb);
        bb = BATuselect(tb, &yy, &yy);
	BBPreclaim(tb);

	BATloopFast(bb, p, q, xx) {
	    	oid pid = *(oid*) BUNhloc(bb, p);
	    	int cnt = *(int*)BUNtail(TBL_fcn_cnt,BUNfnd(TBL_fcn_cnt, &pid));

		cnt++;
  		BUNreplace(TBL_fcn_cnt, &pid, &cnt);
	}
	BBPreclaim(bb);

	TBL_M_unlock(client);
}

@- TBL_delproc
deletes a MIL procedure. If pid is less than 0 all procs with the 
given name are deleted.
@c
void TBL_delproc(Client client, str nme, int pid, int lock) {
   	int xx, yy = TOK_PROC;
        BAT *sb, *tb, *bb, *cb = BATmirror(client->fcntbl);
	BUN p,q,r;

  
	if (lock) TBL_M_lock(client);
	sb = BATuselect(cb, nme, nme);
        tb = BATsemijoin(TBL_fcn_tpe, sb);
	BBPreclaim(sb);
        bb = BATuselect(tb, &yy, &yy);
	BBPreclaim(tb);

	if (pid < 0){
	  BATloopFast(bb, p, q, xx) {
	    oid pid = *(oid*) BUNhloc(bb, p);
	    BUN s = BUNfnd(cb, &pid);
	    int cnt = *(int*)BUNtail(TBL_fcn_cnt,BUNfnd(TBL_fcn_cnt, &pid));

	    if (cnt == 1){
		YYSTREE *x = (YYSTREE*)
			BUNtloc(TBL_fcn_imp,BUNfnd(TBL_fcn_imp,&pid));

		if (x && *x) {
	    		/* free disguised name */
	    		GDKfree((*x)->yyval.val.pval); 
	    		yyfree((*x));
		}
	    	BUNdelete(cb, BUNfnd(cb, &pid));
	    	TBL_Deinstall_Function(pid);
	    } else {
		cnt--;
  		BUNreplace(TBL_fcn_cnt, &pid, &cnt);
	    }
 	  }
	} else {
	  if (BUNfnd(bb, &pid)){
	    int cnt = *(int*)BUNtail(TBL_fcn_cnt,BUNfnd(TBL_fcn_cnt, &pid));
	    if (cnt == 1){
		YYSTREE *x = (YYSTREE*)
			BUNtloc(TBL_fcn_imp,BUNfnd(TBL_fcn_imp,&pid));

		if (x && *x) {
	    		/* free disguised name */
	    		GDKfree((*x)->yyval.val.pval); 
	    		yyfree((*x));
		}
	    	BUNdelete(cb, BUNfnd(cb, &pid));
	    	TBL_Deinstall_Function(pid);
	    } else {
		cnt--;
  		BUNreplace(TBL_fcn_cnt, &pid, &cnt);
	    }
	  }
	}
	BBPreclaim(bb);
	if (lock) TBL_M_unlock(client);
}

@- TBL_procreturn
@T
We now allow the user to specify a procedure return value.
This does not add much functionality, but allows for an
extra check on a procedure return value (TBL\_procreturn).

The procedure body is a MIL block that has as yyval a string with
the PROC name, and in the len /*HACK*/ field we find an int that is 
a concatenation of two short integers 'type1' and 'type2':
- type1=type2=0 means 'any' (no check necessary)
- type2=0 means an atomic type (its number in type1)
- else we have a bat[type1,type2]
@
The type1,type2 are shorts consisting of a number, and a mask:
- 8192 => MIL type number
- 4096 => equal to type of 'num'th actual parameter
- 2048 => equal to head-type of BAT that is 'num'th actual parameter
- 1024 => equal to tail-type of BAT that is 'num'th actual parameter
@c
static  
int check_type(int argc, ValPtr argv, int tpe, int mask) {
	int kind = mask&15360;
	int num = mask&1023;

	if (kind == 8192) { /* direct type */
		return TYPEcastable(tpe,num); 
	} 
	if (argc <= num) {
		return 0;
	}
	if (kind == 4096) { /* any-normal */
		if (num == 0) return 1;
		return TYPEcastable(argv[num].vtype, tpe);
	} 
	if (argv[num].vtype != TYPE_bat) {
		return 0;
	}
	if (kind == 2048) { 
		BAT *b = BATdescriptor(argv[num].val.bval);
		return b && TYPEcastable(tpe, BAThtype(b)); /* any-head */
	}
	if (kind == 1024) { 
		BAT *b = BATdescriptor(argv[num].val.bval);
		return b && TYPEcastable(tpe, BATttype(b)); /* any-tail */
	}
	return 0; /* illegal kind */
}

int TBL_procreturn(int argc, ValPtr argv, ValPtr res, YYSTREE t) {
	if (PROC_TYPE1(t) == 0 && PROC_TYPE2(t) == 0) {
		return 1;
	} else if (res->vtype == TYPE_bat) {
		BAT *b = BATdescriptor(res->val.bval);
		return b && check_type(argc, argv, BAThtype(b), PROC_TYPE1(t)) 
                         && check_type(argc, argv, BATttype(b), PROC_TYPE2(t));
	} else if (PROC_TYPE2(t)) {
		return 0;
	} 
	return check_type(argc, argv, res->vtype, PROC_TYPE1(t));
}


@+ Client Managament
@-
Each user gets a private function, atom, and accelerator table. They are 
initialized with the built-in functions and atomary types. They are extended 
later on when the user loads a module.

Both tables are session and user specific. 
@c

#define TBL_SIZE	750

void TBL_initclient(Client client) {
	int	i;

	if (monet_clients != client){
		client->fcntbl = TBL_lookup(client, "fcntbl");
		client->acctbl = TBL_lookup(client, "acctbl"); 
		client->atomtbl = TBL_lookup(client, "atomtbl"); 
		TBL_incproc(client); /* inc reference counts to functions */
	} else {
		client->fcntbl = TBL_create(client, "fcntbl", 
				    BATnew(TYPE_str, TYPE_oid, TBL_SIZE));

		/* Create the client acc-table, and fill it 
	 	 * with the standard types.
	 	 */
		client->acctbl = TBL_create(client, "acctbl", 
			     	    BATnew(TYPE_str, TYPE_int, TBL_SIZE));
		i = ACC_hash; BUNins(client->acctbl, "hash", &i);
		i = ACC_index;BUNins(client->acctbl, "index", &i);

		/* Create the client atom-table, and fill it 
	 	 * with the standard types.
	 	 */
		client->atomtbl = TBL_create(client, "atomtbl", 
				     BATnew(TYPE_str, TYPE_int, TBL_SIZE));
		i = TYPE_void;BUNins(client->atomtbl, "void", &i);
		i = TYPE_bit; BUNins(client->atomtbl, "bit", &i);
		i = TYPE_chr; BUNins(client->atomtbl, "chr", &i);
		i = TYPE_sht; BUNins(client->atomtbl, "sht", &i);
		i = TYPE_bat; BUNins(client->atomtbl, "bat", &i);
		      	BUNins(client->atomtbl, "BAT", &i);
		i = TYPE_int; BUNins(client->atomtbl, "int", &i);
		i = TYPE_oid; BUNins(client->atomtbl, "oid", &i);
		i = TYPE_ptr; BUNins(client->atomtbl, "ptr", &i);
		i = TYPE_flt; BUNins(client->atomtbl, "flt", &i);
		i = TYPE_dbl; BUNins(client->atomtbl, "dbl", &i);
		i = TYPE_lng; BUNins(client->atomtbl, "lng", &i);
		i = TYPE_str; BUNins(client->atomtbl, "str", &i);
	}

#ifdef MKMODS
	TEM_initclient(client);
#endif
}

@-
When a user disappears we should garbage collect the function and atom
tables. Likely they have not been migrated to disk, which makes this
operation cheap.
The space occupied by user defined functions should be reclaimed.
@c
void TBL_exitclient(Client client) {
	BAT	*b, *bn, *procs, *fcns;
	BUN 	p, q, r;
	int	xx, proc=TOK_PROC;

#ifdef MKMODS
	TEM_exitclient(client);
#endif
	TBL_M_lock(client);

	/* run the drop scripts. */
	bn = BATselect(TBL_mod_use, &client, &client);
	b = BATsort(bn); 
	b = BATrevert(procs=BATsetaccess(b, BAT_WRITE));
	BATloopFast(b, p, q, xx) { 
	    oid mid = *(oid*) BUNhloc(b,p); 
	    if (BUNlocate(TBL_mod_use, BUNhloc(b,p), &client)) {
	   	str module = BUNtailfnd(char,TBL_mod_nme,r,&mid);
	    	if (TBL_M_directloaded(client, mid, module))
		    TBL_drop(client, module, 1);
	    }
	}

	/* Check for procs in your fcn table.  */
	procs = BAT_select(TBL_fcn_tpe, &proc, &proc, FALSE);
	fcns = BATsemijoin(BATmirror(client->fcntbl), procs);

	BATloopFast(fcns, p, q, xx) {
		TBL_delproc(client, (str) BUNtvar(fcns, p), 
			*(oid*) BUNhloc(fcns, p), FALSE);
	}
	BBPreclaim(procs);
	BBPreclaim(fcns);

	/* Unload all loaded modules in reverse loading order. */
	BATloopFast(b, p, q, xx) { 
	    oid mid = *(oid*) BUNhloc(b,p); 
	    if (BUNlocate(TBL_mod_use, BUNhloc(b,p), &client)) {
	   	str module = BUNtailfnd(char,TBL_mod_nme,r,&mid);
	    	if (TBL_M_directloaded(client, mid, module))
		    TBL_unloadmod(client, module, 1);
	    }
	}
	BBPreclaim(b);
	BBPreclaim(bn);

	VARclearBAT(client->fcntbl);
	VARclearBAT(client->atomtbl);
	VARclearBAT(client->acctbl);
	client->fcntbl = client->atomtbl = client->acctbl = 0;
	TBL_M_unlock(NULL);
}

@- TBL_Install_Depend 
is called from the generated code in the routine <modulename>_Module_Install. 
It is called one time for each module that it is dependent on.
@c

void TBL_Install_Depend(TBLinstall *inst, oid mid, str user, str name) {
  if (!TBL_loadmod(inst->client, name, inst->level+1, inst->initstr)) {
   GDKwarning("TBL_Install_Depend: requires module %s, not loaded!\n", name);
  } else if (BUNlocate(TBL_mod_dep, &mid, name) == NULL) {
   BUNins(TBL_mod_dep, &mid, name);  
  }
}


@- TBL_Install_Atom
@c
void 
TBL_Install_Atom(
  oid mid,
  str name,
  int size,	/* 0 == not fixed size */
  int align)	/* 0 == not fixed size */
{
  str extended = GDKmalloc(strlen(name)+16);

  dlFPRINTF(GDKerr, "  TBL_Install_Atom(%s)\n", name);
  if ((size == 0) && (align == 0)) { /* fixed */
    sprintf(extended, "%s=*", name);
    BUNins(TBL_mod_atm, &mid, extended);
  } else {
    sprintf(extended, "%s=%d,%d", name, size, ABS(align));
    BUNins(TBL_mod_atm, &mid, extended);
  }
  GDKfree(extended);
}

@- TBL_Install_Accelerator
@c
void 
TBL_Install_Accelerator(oid mid, str name) {
  dlFPRINTF(GDKerr, "  TBL_Install_Accelerator(%s)\n", name);
  BUNins(TBL_mod_acc, &mid, name);
}

@- TBL_Install_Functions
@c
void TBL_Install_Functions( oid mid, TBLfcn *fcns, str user, str date ){
   	TBLfcn *cur = fcns;
   	while( cur->name ){
	   oid fid = TBL_Install_Function( mid, cur->name, cur->token,
	   	cur->fcn, cur->unpack, cur->check, cur->oldsig,
		cur->help, user, date);
	   str *arg = cur->args;
	   while( *arg ){
	      TBL_Install_Function_Arg( fid, *arg );
	      arg++;
	   }
	   if (cur->res)
	      TBL_Install_Function_Res( fid, cur->res );
	   cur++;
	}
}

@- TBL_Install_Function
@c
/* I think the types from parsing are only availiable as strings
   so we better input them as such */

/* An oid is generated */
oid 
TBL_Install_Function(
  oid mid,
  str name,
  int tpe, /* some sort of type? fcn_table[i].token */
  ptr orig, ptr pack_imp, ptr type_imp, /* functionpointers! */
  str signature,
  str help,
  str author,
  str date)
{
  int zero = 0;
  oid fid = TBL_oid++;

  dlFPRINTF(GDKerr, "  TBL_Install_Function(%d,%s) = %d\n", mid, name, fid);

  if (name[0] == 'b' && name[1] =='a' && name[2] == 't' && name[3] == 0) {
	name = "BAT"; /* sorry */ 
  }
  BUNins(TBL_fcn_nme, &fid, name); /* or &name */
  BUNins(TBL_fcn_fcn, &fid, &orig); /* correct??? */
  BUNins(TBL_fcn_tpe, &fid, &tpe);
  BUNins(TBL_fcn_mid, &fid, &mid);
  BUNins(TBL_fcn_dsc, &fid, help);
  BUNins(TBL_fcn_aut, &fid, author);
  BUNins(TBL_fcn_dat, &fid, date);
  BUNins(TBL_fcn_cnt, &fid, &zero);
@-
We want to save pointer to the real function
for example use in a different interpreter 
if (orig) BUNins(TBL_fcn_org, &fid, &orig); 
Its done in TBL_unpacked()
@c
  if (pack_imp) BUNins(TBL_fcn_imp, &fid, &pack_imp);
  if (signature) BUNins(TBL_fcn_sig, &fid, signature);
  TBL_fcn_pro_size++;

  return fid;
}

void TBL_Deinstall_Function(oid pid) {
  BUNdelHead(TBL_fcn_nme, &pid);
  BUNdelHead(TBL_fcn_fcn, &pid);
  BUNdelHead(TBL_fcn_mid, &pid);
  BUNdelHead(TBL_fcn_imp, &pid);
  BUNdelHead(TBL_fcn_tpe, &pid);
  BUNdelHead(TBL_fcn_sig, &pid);
  BUNdelHead(TBL_fcn_dsc, &pid);
  BUNdelHead(TBL_fcn_aut, &pid);
  BUNdelHead(TBL_fcn_dat, &pid);
  BUNdelHead(TBL_fcn_cnt, &pid);

  /* periodically clean up TBL_fcn_pro */
  if (BATcount(TBL_fcn_nme)+100 < TBL_fcn_pro_size) {
    BAT *b = BATrcopy(TBL_fcn_pro);
    BUN p, q, r;
    int xx;

    BATclear(TBL_fcn_pro);
    BATloopFast(b, p, q, xx) {
	oid pid = *(oid*) BUNhead(b,p);
	BUNfndOID(r, TBL_fcn_nme, &pid);
	if (r) BUNfastins(TBL_fcn_pro, &pid, BUNtvar(b,p));
    }
    TBL_fcn_pro->hsorted = TBL_fcn_pro->tsorted = 0; 
    BBPreclaim(b);
    TBL_fcn_pro_size = BATcount(TBL_fcn_nme);
  }
}

/* Called after _Function */
void TBL_Install_Function_Vararg(oid fid, str tpe) {
  dlFPRINTF(GDKerr, "    TBL_Install_Function_Vararg(%d,%s)\n", fid, tpe);
  BUNins(TBL_fcn_pro, &fid, tpe);
}


/* Called after _Function / _Vararg 
   This one would have to be called several times, once for each argument */
void TBL_Install_Function_Arg(oid fid, str tpe) {
  dlFPRINTF(GDKerr, "    TBL_Install_Function_Arg(%d,%s)\n", fid, tpe);
  BUNins(TBL_fcn_pro, &fid, tpe);
}

/* After _Arg */
void TBL_Install_Function_Res(oid fid, str tpe) {
  dlFPRINTF(GDKerr, "    TBL_Install_Function_Res(%d,%s)\n", fid, tpe);
  BUNins(TBL_fcn_pro, &fid, tpe);
}

@- TBL_Install_LoadMIL/DropMIL
Used for registering the MIL strings that are executed when a module
is loaded and dropped.
@c
void TBL_Install_LoadMIL(oid mid, str mil) {
  dlFPRINTF(GDKerr, "  TBL_Install_LoadMIL(%d,%s)\n", mid, mil);
  if (mil) BUNins(TBL_mod_load, &mid, mil);
}

void TBL_Install_DropMIL(oid mid, str mil) {
  dlFPRINTF(GDKerr, "  TBL_Install_DropMIL(%d,%s)\n", mid, mil);
  if (mil) BUNins(TBL_mod_drop, &mid, mil);
}
