@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f searchpath
@a Florian Waas
@v 1.0
@t Handling of Module Search Path

@h
#ifndef _searchpath_H
#define _searchpath_H

#include <gdk_storage.h>

#ifndef SO_EXT
#define SO_EXT ".so"
#endif

/* 
 * prototypes 
 *
 */

/* rewind list cursor and initialize the list if not done yet */
void MSP_rewind_module_list(void);

/* search for module and return the complete path */
char *MSP_locate_module(char *);
char *MSP_locate_script(char *);

/* return next module found in the list */
char *MSP_next_module(char *);

#endif
@c
#include "monet.h"
#include "searchpath.h"

#ifdef HAVE_SYS_PARAM_H
#include <sys/param.h>
#endif

static size_t SO_EXT_LEN = 0;	/* length of SO_EXT string, will be
				   filled in before use */

struct moddir {
    char *path;
    struct moddir *next;
};

static struct moddir *moddir_list=0;

#if 0				/* not used */
static void print_moddir_list(void) {
    struct moddir *entry=moddir_list;
    while(entry)
        {
            printf("list: %s\n",entry->path);
            entry=entry->next;
        }
}
#endif

static void
insert_moddir_entry(const char *name)
{
	struct moddir *last;
	struct moddir *newentry;

	if (!name || !*name)
		return;
	/* printf("inserted dir %s\n",name); */

	newentry = (struct moddir*) GDKmalloc(sizeof(struct moddir));
	newentry->next = 0;

	if ((last = moddir_list) != 0) {
		while (last->next)
			last = last->next;
		last->next = newentry;
	} else
		moddir_list = newentry;

	newentry->path = GDKstrdup(name);
}


static 
void insert_moddir_recursively(char *name) {
    DIR *dirp;
    struct dirent *dent=0;
    char fullname[MAXPATHLEN];

/*    printf("rec %s\n",name); */
    
    if (strlen(name)>2 && !strcmp(&name[strlen(name)-2],"//"))
        name[strlen(name)-2]='\0';
    
    dirp=opendir(name);
    if (!dirp) return;
    rewinddir(dirp);
    insert_moddir_entry(name);
    while((dent=readdir(dirp))!=0)
        {
            if (dent->d_name[0]=='.') continue;
            sprintf(fullname,"%s%c%s",name,DIR_SEP,dent->d_name);
            insert_moddir_recursively(fullname);
        }
    closedir(dirp);
}

static 
void parse_mod_path(void) {
    char *mod_path = GDKstrdup(GDKgetenv("monet_mod_path"));

    if (mod_path){
      size_t pos=0, len=strlen(mod_path);
      char *dirbegin=mod_path;
      do
        {
            while(mod_path[pos]!='\0' && mod_path[pos]!=PATH_SEP) pos++;
            mod_path[pos]='\0';

            if (strlen(dirbegin)>2 && !strcmp(&mod_path[pos-2],"//"))
                insert_moddir_recursively(dirbegin);
            else                    
                insert_moddir_entry(dirbegin);

            if (pos==len) break;
            dirbegin = mod_path + (++pos);
        }
      while(1);
    }
    GDKfree(mod_path);
}

static struct moddir *current_entry=0;
static DIR *dirp=0;

void MSP_rewind_module_list(void) {
    if (!moddir_list) parse_mod_path();
    current_entry=moddir_list;
    if(dirp) closedir(dirp);
    dirp=0;
}
    
#define LIBLEN	3
char *MSP_next_module(char *ext) {
    struct dirent *dent=0;
    char *next_module;

    while(current_entry)
        {
            if (!dirp)
                {
                    dirp=opendir(current_entry->path);
                    if (!dirp)
                        {
                            current_entry=current_entry->next;
                            continue;
                        }
                    rewinddir(dirp);
                }
            while((dent=readdir(dirp))!=0)
                {
                    char *suffix=0;
                    if ((suffix=strstr(dent->d_name,ext))==NULL) continue;
		    /*
		     * On some platforms (e.g., MacOS X/Mach-O/Darwin), 
		     * a library's version number (e.g., ".0"/".0.0.0")
		     * is not appended to the suffix, but rather placed
		     * between the library's name and suffix; however,
		     * we only want to match "lib<name><ext>", here,
		     * but not "lib<name><version><ext>":
		     */
		    if (((suffix-2)>=dent->d_name) &&
		        (suffix[-2]=='.')          &&
		       	(suffix[-1]>='0')&&(suffix[-1]<='9')) continue; 
                    suffix[0]='\0';
                    next_module=(char *)GDKmalloc(strlen(current_entry->path)+
                                               strlen(dent->d_name)+2);
                    sprintf(next_module,"%s%c%s", 
                            current_entry->path, DIR_SEP, dent->d_name);
                    return(next_module);
                }
            current_entry=current_entry->next;
            closedir(dirp);
            
            dirp=0;
        }
    return 0;
}

static char *MSP_libname( char *name ){
    char *libname = (char*)GDKmalloc( strlen(name) + LIBLEN + 1 );
    strcpy(libname, "lib");
    strcpy(libname+LIBLEN, name);
    return libname;
}

char *MSP_locate_module(char *mod_name) {
    char *name = MSP_libname( mod_name ); 
    size_t len = strlen(name);
    size_t fulllen = 0;
    char *next_module,*fullname;
    MSP_rewind_module_list();
    for (;;)
        {
            next_module=MSP_next_module(SO_EXT);
            if (!next_module) break;
	    fulllen = strlen(next_module);
            if ( fulllen > len &&
		 next_module[fulllen-len-1] == DIR_SEP &&
		 !strcmp(&next_module[fulllen-len],name))
                {
		    if (!SO_EXT_LEN)
			SO_EXT_LEN = strlen(SO_EXT);
#ifdef _AIX
                    fullname=(char *)GDKmalloc(fulllen+SO_EXT_LEN+1+len+7);
		    sprintf(fullname,"%s%s(%s.so.0)",next_module, SO_EXT, name);
#else
                    fullname=(char *)GDKmalloc(fulllen+SO_EXT_LEN+1);
                    sprintf(fullname,"%s%s",next_module, SO_EXT);
#endif
                    GDKfree(next_module);
                    GDKfree(name);
                    return fullname;
                }
	    GDKfree(next_module);
        }
    GDKfree(name);
    return 0;
}

#define MIL_EXT ".mil"

char *MSP_locate_script(char *mod_name) {
    int MIL_EXT_LEN = (int) strlen(MIL_EXT);
    char *name = GDKstrdup(mod_name); 
    size_t len = strlen(name);
    size_t fulllen = 0;
    char *next_module,*fullname;
    MSP_rewind_module_list();
    for (;;)
        {
            next_module=MSP_next_module(MIL_EXT);
            if (!next_module) break;
	    fulllen = strlen(next_module);
            if ( fulllen > len &&
		 next_module[fulllen-len-1] == DIR_SEP &&
		 !strcmp(&next_module[fulllen-len],name))
                {
                    fullname=(char *)GDKmalloc(fulllen+MIL_EXT_LEN+1);
                    sprintf(fullname,"%s%s",next_module, MIL_EXT);
                    GDKfree(next_module);
                    GDKfree(name);
                    return fullname;
                }
	    GDKfree(next_module);
        }
    GDKfree(name);
    return 0;
}
