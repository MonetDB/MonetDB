@ enum
@t Enumeration Datatypes
@a Peter Boncz
@v 1.0
@* Introduction

When large sets of data are stored and memory is short, one 
seeks for memory occupation optimizations.

One way to do this when the ordinality is low, is to substitute
the datatype to a smaller ordinal datatype. For instance, when 
less than 256 different string values occur in an attribute, one 
could store them as a byte. 

This remapping can be encapsulated nicely by introducing an 'enum'
atomic type, that appears to be the original type, but is in fact
stored as something smaller. Encode and decode commands, as well 
as 'tostr' and 'fromstr' ADT functions, can be generated beforehand
and use a mapping table to translate between the two representations. 

Further space optimizations into values smaller than a byte are
impossible in Monet, since all values need to have a unique memory address.

Though this may by a problem may waste memory, one should realize that 
main-memory databases suffer increasingly when the data representation gets 
more complex. This is obviously true for complex compression schemes, but 
even loading a single byte value is considerably slower on custom CPUs
than loading an entire 32-bit integer. On 64-bits architectures, this 
will even be the case for long 64-bit integers. 


This module implements encodings using 'chr' (1-byte encoding),
and 'sht' (2-byte encoding).

In order to use an enumerated type, it should first be introduced as
an ordinary type name, e.g. 'atom fruit:enum'. By default its underlying
type is then set to 'int'.
As soon as a bat of values is associated with the type, its
underlying type changes based on the storage space needed.

Furthermore, the enumerated types are considered ordinary BATs,
whose scope is limited unless they are explicitly made persistent.
Destroying an enumerated type removes its encoding bat and the
information from the GDK atom library, but does not affect the
MAL programs. This implies a runtime error as soon as you
try to encode/decode a value.
@* Module Definition 
@mal
atom enum:int;
module enum;

pattern create(e:any::2, src:bat[any,any::1]): bat[any::1,any::2]= ENUMcreate
comment "Associate a value domain with an enumerated type.";

pattern load(map:any::1):BAT[any,any::1] = ENUMload
comment "Load/activate a previously created enumeration type.";

pattern destroy(map:any):void = ENUMdestroy
comment "Destroy an enumeration type";

pattern encode(e:any::1,v:any::2):any::1 = ENUMencode
comment "Encode a value using a small map";

pattern encode(e:any::2,b:BAT[any::1,any]):BAT[any::1,any::2] = ENUMencode_multi
comment "Encode a BAT of tail values, into a new BAT of encoded values.
This action is actually a join operation.";

pattern lower(e:any::1, v:any::2):any::1 = ENUMlower
comment "Encode to the lowest value in the encoded domain that is 
	equal to or larger than v";

pattern upper(e:any::1, v:any::2):any::1 = ENUMupper
comment "Encode to the highest value in the encoded domain that is 
	equal to or less than v";

pattern decode(e:any):any = ENUMdecode
comment "Decode a value";

pattern decode(b:BAT[any::2,any::1]) : BAT[any::2,any] = ENUMdecode_multi
comment "Decode a BAT of tail values, into a new BAT of decoded values";

pattern getTable(e:any::1) : bat = ENUMtable
comment "Return the enumeration BAT of an enum type";

command isEnum(tpe:bat) : bit = isEnum
comment "Returns true iff the bat is used as an enumerated type";

command setHistogram(tpe:any::1, b:BAT[any,any]):void = ENUMsethisto
comment "registers the fact that ENUMtable(tpe) is a histogram on b's head column";

pattern isHistogram(tpe:any,b:BAT[any,any]) : bit = ENUMishisto
comment "returns whether ENUMtable(tpe) is a histogram on b's head column";

@- 
oldstuff

    proc ENUMtrick(bat[oid,any] b, BAT[any,int] map) : bat[oid,any] {
        var nme := sprintf("ENUM%d", abs(int(map)));
        map.rename(nme);
        var tpe := ENUMload(nme);
        ENUMsethisto(tpe, b.reverse);
        return [*nme](b);
    }
    ADDHELP("ENUMtrick", "boncz", "Dec  5 1998",
         "create a view on a BAT with a diffrent enum map.", "enum");

@{
@* Implementation
Part of the code is copied from the V 4.3 bat.mx file.
@= getBATdescriptor
        if( BBPcheck(*@2,"@4")==0) 
		return throwMessage("@4:cannot access bat @2 in bbp");
        @3= (BAT*) BBPgetdesc(*@2);
        if( @3 == NULL) { *@1 = 0; 
		return throwMessage("@4:cannot access descriptor @2");
        }
	if( *@2 <0) @3= BATmirror(@3);
@-
Note that we have to build the table with pre-instantiated
function references, because there is no easy way from the GDK layer
to access the enum administration.
@= enumCheck
     for(xx=0; xx<MAX_ENUM; xx++)\
	if (ENUMtpe[xx] == @1) break;\
     if ((xx>MAX_ENUM) || ((b=BATdescriptor(ENUMmap[xx])) == NULL)) {\
	return throwException("@2: illegal enum type.");\
     }
@c
#include "gdk.h"
#include "mal_client.h"
#include "io.h"
#include "mal.h"

typedef int (*fcn)();

#define MAX_ENUM 80

bat ENUMmap[MAX_ENUM] = { 0 };
oid ENUMhisto[MAX_ENUM] = { 0 };
int ENUMtpe[MAX_ENUM] = { -1 };

@:imp(0)@	@:imp(1)@	@:imp(2)@	@:imp(3)@ 	@:imp(4)@
@:imp(5)@	@:imp(6)@	@:imp(7)@	@:imp(8)@ 	@:imp(9)@
@:imp(10)@	@:imp(11)@	@:imp(12)@	@:imp(13)@ 	@:imp(14)@
@:imp(15)@	@:imp(16)@	@:imp(17)@	@:imp(18)@ 	@:imp(19)@
@:imp(20)@	@:imp(21)@	@:imp(22)@	@:imp(23)@ 	@:imp(24)@
@:imp(25)@	@:imp(26)@	@:imp(27)@	@:imp(28)@ 	@:imp(29)@
@:imp(30)@	@:imp(31)@	@:imp(32)@	@:imp(33)@ 	@:imp(34)@
@:imp(35)@	@:imp(36)@	@:imp(37)@	@:imp(38)@ 	@:imp(39)@
@:imp(40)@	@:imp(41)@	@:imp(42)@	@:imp(43)@ 	@:imp(44)@
@:imp(45)@	@:imp(46)@	@:imp(47)@	@:imp(48)@ 	@:imp(49)@
@:imp(50)@	@:imp(51)@	@:imp(52)@	@:imp(53)@ 	@:imp(54)@
@:imp(55)@	@:imp(56)@	@:imp(57)@	@:imp(58)@ 	@:imp(59)@
@:imp(60)@	@:imp(61)@	@:imp(62)@	@:imp(63)@ 	@:imp(64)@
@:imp(65)@	@:imp(66)@	@:imp(67)@	@:imp(68)@ 	@:imp(69)@
@:imp(70)@	@:imp(71)@	@:imp(72)@	@:imp(73)@ 	@:imp(74)@
@:imp(75)@	@:imp(76)@	@:imp(77)@	@:imp(78)@ 	@:imp(79)@

fcn ENUMconv[MAX_ENUM*4+1] = { 
@:def(0)@	@:def(1)@	@:def(2)@	@:def(3)@ 	@:def(4)@
@:def(5)@	@:def(6)@	@:def(7)@	@:def(8)@ 	@:def(9)@
@:def(10)@	@:def(11)@	@:def(12)@	@:def(13)@ 	@:def(14)@
@:def(15)@	@:def(16)@	@:def(17)@	@:def(18)@ 	@:def(19)@
@:def(20)@	@:def(21)@	@:def(22)@	@:def(23)@ 	@:def(24)@
@:def(25)@	@:def(26)@	@:def(27)@	@:def(28)@ 	@:def(29)@
@:def(30)@	@:def(31)@	@:def(32)@	@:def(33)@ 	@:def(34)@
@:def(35)@	@:def(36)@	@:def(37)@	@:def(38)@ 	@:def(39)@
@:def(40)@	@:def(41)@	@:def(42)@	@:def(43)@ 	@:def(44)@
@:def(45)@	@:def(46)@	@:def(47)@	@:def(48)@ 	@:def(49)@
@:def(50)@	@:def(51)@	@:def(52)@	@:def(53)@ 	@:def(54)@
@:def(55)@	@:def(56)@	@:def(57)@	@:def(58)@ 	@:def(59)@
@:def(60)@	@:def(61)@	@:def(62)@	@:def(63)@ 	@:def(64)@
@:def(65)@	@:def(66)@	@:def(67)@	@:def(68)@ 	@:def(69)@
@:def(70)@	@:def(71)@	@:def(72)@	@:def(73)@ 	@:def(74)@
@:def(75)@	@:def(76)@	@:def(77)@	@:def(78)@ 	@:def(79)@
0 };

@= def
	enum@1chrTostr, enum@1chrFromstr, enum@1shtTostr, enum@1shtFromstr,
@= block
int enum@1Tostr(int mapid, str* dst, int* len, @1* src){
	int l; ptr v; 
	BAT *b = BATdescriptor(ENUMmap[mapid]);

	if (*src == @1_nil) {
		v = ATOMnilptr(b->htype);
	} else {
		BUN p = BUNptr(b, 1 + *(unsigned @2*) src); 
		v = BUNhead(b,p);
	}
	if (b->htype != TYPE_str) {
		fcn tostr = BATatoms[b->htype].atomToStr;
		return (*tostr)(dst, len, v);
	}
	l = strLen(v);
	if (*len < l) {
		if (*dst) GDKfree(*dst);
		*dst = (char*) GDKmalloc(*len = l);
	}
	memcpy(*dst, v, l);
	return l; 
}
int enum@1Fromstr(int mapid, str src, int* len, @1** dst){
	int r, l = 0;
	BUN p; ptr v;
	BAT *b = BATdescriptor(ENUMmap[mapid]);

	if (b->htype != TYPE_str) {
		fcn fromstr = BATatoms[b->htype].atomFromStr;
 		v = (ptr) GDKmalloc(l=32);
		r = (*fromstr)(src, &l, &v);
	} else {
		r = strlen(src); 
		v = src;
	}
	if (*len < sizeof(@1)) {
		*dst = (@1*) GDKmalloc(*len = sizeof(@1));
	}
	if ((p = SORTfnd(b, v)) != NULL) {
		**(unsigned @2**) dst = BUNindex(b,p)-1;
	} else {
		**dst = @1_nil;
	}
	if (l) GDKfree(v);
	return r;
}
@-
@c
@:block(chr,char)@
@:block(sht,short)@
@= imp
	@:template(@1,chr,char)@ @:template(@1,sht,short)@
@= template
static int enum@1@2Tostr(char** dst, int* len, @2* src){
	return enum@2Tostr(@1,dst,len,src);
}
static int enum@1@2Fromstr(str src, int* len, @2** dst){
	return enum@2Fromstr(@1,dst,len,src);
}
@c
int ENUMatom(int i, BAT *h){
	str name= h->batId;
	if (BATcount(h) > 255) {
		ATOMproperty(name, "storage", (fcn) TYPE_sht); 
		ATOMproperty(name, "tostr", ENUMconv[i*4+2]);
		ATOMproperty(name, "fromstr", ENUMconv[i*4+3]);
	} else {
		ATOMproperty(name, "storage", (fcn) TYPE_chr); 
		ATOMproperty(name, "tostr", ENUMconv[i*4]);
		ATOMproperty(name, "fromstr", ENUMconv[i*4+1]);
	}
	ENUMtpe[i] = ATOMindex(name);
	ENUMmap[i] = h->batCacheid;
	BBPfix(h->batCacheid);
	return ENUMtpe[i];
}
str ENUMreload(int *retval, int bid) {
	int i;
	BAT *h;

	@:getBATdescriptor(retval,&bid,h,ENUMload)@
	MT_set_lock(mal_contextLock, "ENUMload");
	for(i=0; i<MAX_ENUM; i++) {
		if (ENUMmap[i] == 0) {
			char *name = h->batId;
			if (BATcount(h) > 255) {
				ATOMproperty(name, "storage", (fcn) TYPE_sht); 
				ATOMproperty(name, "tostr", ENUMconv[i*4+2]);
				ATOMproperty(name, "fromstr", ENUMconv[i*4+3]);
			} else {
				ATOMproperty(name, "storage", (fcn) TYPE_chr); 
				ATOMproperty(name, "tostr", ENUMconv[i*4]);
				ATOMproperty(name, "fromstr", ENUMconv[i*4+1]);
			}
			ENUMtpe[i] = ATOMindex(name);
			ENUMmap[i] = h->batCacheid;
			BBPfix(h->batCacheid);
			*retval = h->batCacheid;
			MT_unset_lock(mal_contextLock, "ENUMload");
			return MAL_SUCCEED;
		}
	}
	MT_unset_lock(mal_contextLock, "ENUMload");
	return throwMessage("ENUMload: too many active enum types.");
}

str ENUMcreate(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	BAT *h,*b;
	ptr nil;
	int *retval,hid,bid; str ret;
	int tpe,xx;
	str name;

	retval = (int*) getArgReference(stk,pci,0);
	tpe= getArgType(mb,pci,1);
	bid= *(int*) getArgReference(stk,pci,2);
	name= malTypeName(tpe);
	@:getBATdescriptor(retval,&bid,b,ENUMcreate)@
	h = BAThistogram(b);
	nil = ATOMnilptr(b->htype);
	BUNdelHead(h, nil);
	BATorder(h);
	BATrename(h, name);
/*
	BATmode(h, PERSISTENT);
	BBPsave(h);
*/
	hid= h->batCacheid;
	ret= ENUMreload(retval, hid);
	GDKfree(name);
	return ret;
}
str ENUMload(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	BAT *b;
	int xx;
	int tpe, *retval;
	str ret;
	str name;

	tpe= getArgType(mb,pci,1);
	name= malTypeName(tpe);
	retval= (int*) getArgReference(stk,pci,0);
	*retval= BBPindex(name);
	if( *retval ==0)
		return throwMessage("ENUMload: encoding BAT does not exist.");
	ret= ENUMreload(retval,*retval);
	GDKfree(name);
	return ret;
}

str ENUMdestroy(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	BAT *b;
	int xx;
	int tpe;

	tpe= getArgType(mb,pci,1);
	@:enumCheck(tpe, ENUMdestroy)@
	MT_set_lock(mal_contextLock, "ENUMdestroy");
	ATOMdelete(tpe);
	BBPunfix(ENUMmap[xx]);
	ENUMhisto[xx] = 0;
	ENUMmap[xx] = 0;
	ENUMtpe[xx] = 0;
	MT_unset_lock(mal_contextLock, "ENUMdestroy");
	return MAL_SUCCEED;
}
@-
The result of an encode/lower/upper step is stored in the 
receiving variable.
@= encoding
	if( ATOMstorage(tpe)== TYPE_chr){
		if (p == NULL) *(chr*) dst = chr_nil; 
		else *(unsigned char*) dst = BUNindex(b,p) - 1;
	} else {
		if (p == NULL) *(sht*) dst = sht_nil; 
		else *(unsigned short*) dst = BUNindex(b,p) - 1;
	}
@c
str ENUMencode(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	BAT *b;
	ptr p,src,dst;
	int xx;
	int tpe;

	tpe= getArgType(mb,pci,1);
	@:enumCheck(tpe,ENUMencode)@
	src= *(ptr*) getArgReference(stk,pci,2);
	dst= (ptr) getArgReference(stk,pci,0);
	p = BUNfnd(b, src);
	@:encoding@
	return MAL_SUCCEED;
}
str ENUMlower(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	int xx,tpe;
	BUN p,src,dst;
	BAT *b;
	
	tpe= getArgType(mb,pci,1);
	src= *(ptr*) getArgReference(stk,pci,2);
	dst= (ptr) getArgReference(stk,pci,0);
	@:enumCheck(tpe,ENUMlower)@
	if (!ATOMlinear(b->htype))
	 	return throwMessage("ENUMlower@1Map: incompatible source type.");
	if (BAThordered(b)&1) {
		p = SORTfndlast(BATmirror(b), src);
		if (p && p > BUNfirst(b))  p -= BUNsize(b);
		else p = NULL;
	} else {
		BATidx(b, NULL);
		p = (BUN) IDXfndlast(b, src);
		if (p && p > (BUN) b->hidx.first) p = ((BUN*) p)[-1];
		else p = NULL;
	}
	@:encoding@
	return MAL_SUCCEED;
} 

str ENUMupper(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	int xx,tpe;
	BUN p,src,dst;
	BAT *b;
	
	tpe= getArgType(mb,pci,1);
	src= *(ptr*) getArgReference(stk,pci,2);
	dst= (ptr) getArgReference(stk,pci,0);
	@:enumCheck(tpe,ENUMlower)@
	if (!ATOMlinear(b->htype))
	 	return throwException("ENUMupper@1Map: incompatible source type.");
	if (BAThordered(b)&1) {
		p = SORTfndfirst(BATmirror(b), src);
	} else {
		BATidx(b,NULL);
		p = (BUN) IDXfndfirst(b, src);
		if (p) p = *(BUN*) p;
	}
	@:encoding@
	return MAL_SUCCEED;
} 

str ENUMdecode(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	int xx,tpe;
	BUN p,src, *dst;
	BAT *b;
	
	tpe= getArgType(mb,pci,1);
	src= *(ptr*) getArgReference(stk,pci,1);
	dst= (ptr) getArgReference(stk,pci,0);
	@:enumCheck(tpe,ENUMlower)@

	if( b->htype != getArgType(mb,pci,0))
		return throwMessage("ENUMdecode:incompatible source type");
	if( ATOMstorage(tpe) == TYPE_chr){
		if (*(chr*) src == chr_nil) p = ATOMnilptr(b->htype);
		else p = BUNhead(b, BUNptr(b, 1 + *(unsigned char*)src));
	} else{
		if (*(sht*) src == sht_nil) p = ATOMnilptr(b->htype);
		else p = BUNhead(b, BUNptr(b, 1 + *(unsigned short*)src));
	}
	
	if (b->hvarsized) {
		int l = ATOMlen(b->htype, p); 
		* (ptr*)dst =  (ptr*) GDKmalloc(l);
		memcpy(*(ptr*)dst, p, l);
	} else {
		memcpy(dst, p, ATOMsize(b->htype));
	}
	return MAL_SUCCEED;
}


#define HASHfnd_loc(r,b,p) r = BUNfnd(b,p)
#define HASHfnd_var(r,b,p) r = BUNfnd(b,p)

@= encode
{ 	BAT *bn = BATnew(src->htype, tpe, BATcount(src)); 
	BUN p,q,r; int xx;
	unsigned @2 idx;
	
	if (BAThordered(b)&1) {
	    BATloopFast(src, p, q, xx) {
		BUN r = (BUN) SORTfnd@4(b, BUNt@3(src,p));
		if (r == NULL) {
			idx = @1_nil; 
		} else {
			idx = BUNindex(b,r) - 1;
		}
		BUNfastins(bn, BUNhead(src,p), &idx); 
	    } 
	} else {
	    BATloopFast(src, p, q, xx) {
		HASHfnd@4(r, b, BUNt@3(src,p));
		if (r == NULL) {
			idx = @1_nil; 
		} else {
			idx = BUNindex(b,r) - 1;
		}
		BUNfastins(bn, BUNhead(src,p), &idx); 
	    } 
	} 
	*retval = bn->batCacheid;
	bn->tsorted = 0;
	ALIGNsetH(bn, src);
} break;
@c
str ENUMencode_multi(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	BAT *b,*src;
	ptr p;
	int xx,bid,*retval;
	int tpe;

	tpe= getArgType(mb,pci,1);
	@:enumCheck(tpe,ENUMencode_multi)@
	bid= *(int*) getArgReference(stk,pci,2);
	retval= (int*) getArgReference(stk,pci,0);
	@:getBATdescriptor(retval,&bid,src,ENUMencode_multi)@

	if (src->ttype != b->htype) 
	 	return throwMessage("ENUMencode_multi: incompatible types");
	if (ATOMstorage(tpe) == TYPE_chr) { 
	    switch(ATOMstorage(src->ttype)) {
	    case TYPE_void: 
		return throwMessage("ENUMencode_multi: illegal tail type");
	    case TYPE_chr:	@:encode(chr,char,loc,_chr)@
	    case TYPE_sht:	@:encode(chr,char,loc,_sht)@
	    case TYPE_int:	@:encode(chr,char,loc,_int)@
	    case TYPE_flt:	@:encode(chr,char,loc,_flt)@
	    case TYPE_lng:	@:encode(chr,char,loc,_lng)@
	    case TYPE_dbl:	@:encode(chr,char,loc,_dbl)@
	    default:if(src->tvarsized) {
				@:encode(chr,char,var,_var)#
		    } else {
				@:encode(chr,char,loc,_loc)#
	    }	    }
	} else {
	    switch(ATOMstorage(src->ttype)) {
	    case TYPE_void: 
		return throwMessage("ENUMencode_multi: illegal tail type");
	    case TYPE_chr:	@:encode(sht,short,loc,_chr)@
	    case TYPE_sht:	@:encode(sht,short,loc,_sht)@
	    case TYPE_int:	@:encode(sht,short,loc,_int)@
	    case TYPE_flt:	@:encode(sht,short,loc,_flt)@
	    case TYPE_lng:	@:encode(sht,short,loc,_lng)@
	    case TYPE_dbl:	@:encode(sht,short,loc,_dbl)@
	    default:if(src->tvarsized) {
				@:encode(sht,short,var,_var)#
		    } else {
				@:encode(sht,short,loc,_loc)#
	    }	    }
	}
	return MAL_SUCCEED;
} 

@= decode
{	BAT *bn = BATnew(src->htype, b->htype, BATcount(src)); 
	BUN p,q; int xx;
	ptr w,nil = ATOMnilptr(b->htype);
	
	BATloopFast(src, p, q, xx) {
		unsigned @2 *idx = (unsigned @2*) BUNtloc(src,p);
		if (*(@1*) idx == chr_nil) {
			w = nil;
		} else {
			w = BUNhead(b, BUNptr(b, 1 + *idx));
		}
		BUNfastins(bn, BUNhead(src,p), w); 
		
	} 
	*retval = bn->batCacheid;
}
@c
str ENUMdecode_multi(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	BAT *b,*src;
	ptr p;
	int xx,*bid,*retval;
	int tpe;

	bid= (int*) getArgReference(stk,pci,1);
	retval= (int*) getArgReference(stk,pci,0);
	@:getBATdescriptor(retval,bid,src,ENUMencode_multi)@
	tpe= src->ttype;
	@:enumCheck(tpe,ENUMencode_multi)@
	if (ATOMstorage(tpe) == TYPE_chr) { 
	    @:decode(chr,char)@
	} else if (ATOMstorage(tpe) == TYPE_sht) { 
	    @:decode(sht,short)@
	} else
	    return throwMessage("ENUMdecode_multi: illegal tail type.");
	return MAL_SUCCEED;
}

int ENUMchktpe(int tpe) {
	int i;
	for(i=0; i<MAX_ENUM; i++)
		if (ENUMtpe[i] == tpe) return TRUE;
	return FALSE;
}

int ENUMisTable(BAT *b, int tpe){
	if( b->ttype== tpe)
		return ENUMchktpe(tpe);
	return FALSE;
}
str ENUMtable(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	BAT *b;
	int xx,*retval;
	int tpe;

	tpe= *(int*) getArgReference(stk,pci,1);
	retval= (int*) getArgReference(stk,pci,0);

	@:enumCheck(tpe, ENUMtable)@
	BBPfix(b->batCacheid);
	*retval = b->batCacheid;
	return MAL_SUCCEED;
}

str isEnum(bit *ret, int *bid){
	BAT *b;
	int i;
	@:getBATdescriptor(ret,bid,b,isEnum)@
	*ret= FALSE;
	for(i=0; i<MAX_ENUM; i++)
		if (ENUMmap[i] == b->batCacheid) { *ret= TRUE;break;}
	return MAL_SUCCEED;
}

str ENUMsethisto(int *retval, int* tpe, int *bid) {
	BAT *b,*column;
	int xx;
	@:enumCheck(*tpe, ENUMsethisto)@
	@:getBATdescriptor(retval,bid,column,ENUMsethisto)@
	if (column->halign == 0) {
		column->halign = OIDnew(1);
		column->batDirtydesc = TRUE;
	}
	ENUMhisto[xx] = column->halign;
	return MAL_SUCCEED;
}

str ENUMishisto(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	BAT *b,*column;
	int xx,*retval;
	int tpe,*bid;

	tpe= *(int*) getArgReference(stk,pci,1);
	bid= (int*) getArgReference(stk,pci,2);
	retval= (int*) getArgReference(stk,pci,0);
	@:enumCheck(tpe, ENUMishisto)@
	@:getBATdescriptor(retval,bid,column,ENUMishisto)@
	*retval = (ENUMhisto[xx] == column->halign);
	return MAL_SUCCEED;
}

str ENUMepilogue() {
	int xx;
	for(xx=0; xx<MAX_ENUM; xx++)  {
		if (ENUMmap[xx])  {
			BBPunfix(ENUMmap[xx]);
		}
	}
	return MAL_SUCCEED;
}
