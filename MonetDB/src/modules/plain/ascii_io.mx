@f ascii_io
@t The ascio io Module
@a Niels Nes
@d 12/01/2001
@m 
.module ascii_io;

.COMMAND ascii_io_debug( int debug ) = init_ascii_io; ""

.COMMAND load( BAT[void,str] names, BAT[void,str] seps, BAT[void,str] types, str datafile, int nr ) : BAT[str,bat] = ascii_io_load; ""
.COMMAND dump( BAT[void,str] names, BAT[void,str] seps, BAT[void,bat] bats, str datafile, int nr ) = ascii_io_dump; ""

.LOAD

proc load_format( str fmt ) : BAT[str,BAT] := {
	var names := new(void,str); names.seqbase(oid(0));
	var seps := new(void,str); seps.seqbase(oid(0));
	var types := new(void,str); types.seqbase(oid(0));
	names.insert(nil,"names");seps.insert(nil,",");types.insert(nil,"str");
	names.insert(nil,"seps");seps.insert(nil,",");types.insert(nil,"str");
	names.insert(nil,"types");seps.insert(nil,"\n");types.insert(nil,"str");
	return load(names, seps, types, fmt, 1000);
}

proc load_data( BAT[str,BAT] fmt, str data, int nr ) : BAT[str,BAT] := {
	var names := fmt.find("names");
	var seps := fmt.find("seps");
	var types := fmt.find("types");
	return load(names, seps, types, data, nr);
}

proc make_persistent( BAT[str,BAT] bats ) := {
	if (bats.exist("key")){
		var keybat := bats.find("key");
		bats := bats.diff(bats.reverse.select("key").reverse);
		bats@batloop(){
			var b := keybat.reverse().join($t);
			b.rename($h);
			b.persists(true);
		}
	} else {
		bats@batloop(){
			$t.rename($h);
			$t.persists(true);
		}
	}
}


proc dump_seps( BAT[void,BAT] bats ) : BAT[void,str] := {
	var seps := new(void,str); seps.seqbase(oid(0));
	var id := 0;
	var cnt := bats.count - 1;
	bats@batloop(){
		if (id != cnt) {
			seps.insert(nil,",");
		} else {
			seps.insert(nil,"\n");
		}
		id += 1;
	}
	return seps;
}

proc bat_ttype( bat b ) : str := {
	return monet_atomtbl.reverse.find(b.ttype);
}

proc dump_format( BAT[void,BAT] bats, str fmt ) : BAT[str,BAT] := {
	bats := [~bats].seqbase(oid(0));
	var names := [bbpname](bats);
	var seps  := dump_seps(bats);
	var types := [bat_ttype](bats);
	fmtbats:= new(void,bat); fmtbats.seqbase(oid(0));
	fmtbats.insert(nil,names);
	fmtbats.insert(nil,seps);
	fmtbats.insert(nil,types);

	names := new(void,str); names.seqbase(oid(0));
	seps := new(void,str); seps.seqbase(oid(0));
	names.insert(nil,"names");seps.insert(nil,",");
	names.insert(nil,"seps");seps.insert(nil,",");
	names.insert(nil,"types");seps.insert(nil,"\n");
	dump(names, seps, fmtbats, fmt, 1000);
	names.insert(nil,"bats"); 
	fmtbats.insert(nil,bats);
	return names.reverse.join(fmtbats);
}

proc dump_data( BAT[str,BAT] fmt, str data, int cnt) := {
	var names := fmt.find("names");
	var seps := fmt.find("seps");
	var bats;
	if (fmt.exist("bats")){
		bats := fmt.find("bats");
	} else {
		bats := [load](names);
	}
	dump( names, seps, bats, data, cnt );
}

# todo add function to create a key (oid sequence) colom
.END;

.END ascii_io;
@h
#ifndef _ASCII_IO2_H_
#define _ASCII_IO2_H_

#include <ascii_io.proto.h>

extern BAT *ASCIIload( BAT *names, BAT *seps, BAT *types, char *datafile, int nr );
extern void ASCIIdump( BAT *names, BAT *seps, BAT *bats, char *datafile, int nr );

#endif
@c

#include "ascii_io.h"
#include "config.h"
#include <gdk.h>
#include <stream.h>

#include <string.h>
#include <ctype.h>

typedef struct ascii_io_t {
	char *name;
	char *sep;
	int seplen;
	char *type;
	int  adt;
	BAT *c;
} ascii_io;

typedef struct ascii_load_t {
	int nr;
	int nr_attrs;
	ascii_io *format;
} ascii;

static int ascii_io_debug = 0;
  

ptr bun_tail(BAT *b, int nr){
	REGISTER int _i = BUNindex((b),BUNfirst((b)));
	return (ptr)BUNtail(b, BUNptr(b,_i+nr));
}


BAT *void_bat_create(int adt, int nr) {
	BAT *b = BATnew(TYPE_void,adt,nr);
	BATseqbase(b,0);
	return b;
}

ptr *ADT_fromStr( int type, char *s){
        int l = 0;
        ptr *res = NULL;
        if (type == TYPE_str)
                res = (ptr*)GDKstrdup(s);
        else
                BATatoms[type].atomFromStr(s, &l, (ptr)&res);
        return res;
}
char *ADT_toStr( int type, ptr a){
	int l = 0;
	char *res = NULL;
/*
        if (type == TYPE_str)
                res = GDKstrdup((char*)a);
        else
*/
                BATatoms[type].atomToStr( &res, &l, a);
	return res;
}

static char *sep_dup( char *sep ){
	int len = strlen(sep);
	char *res = GDKmalloc(len+1), *result = res;
	char *end = sep+len;

	while(sep < end){
		if (*sep == '\\'){
			++sep;
			switch(*sep++){
			case 'r': *res++ = '\r'; break;
			case 'n': *res++ = '\n'; break;
			case 't': *res++ = '\t'; break;
			}
		} else {
			*res++ = *sep++; 
		}
	}
	*res = '\0';
	return result;
}

static
int create_loadformat( ascii *as, BAT *names, BAT *seps, BAT *types ){
	int p;
	int nr_attrs = BATcount(names);
	ascii_io *fmt = as->format =  
		(ascii_io*)GDKmalloc(sizeof(ascii_io) * (nr_attrs + 1) );

	as->nr_attrs = nr_attrs;
	for (p=0; p<as->nr_attrs; p++){
		fmt[p].name = (char*)bun_tail(names, p);
		fmt[p].sep = sep_dup((char*)bun_tail(seps, p));
		fmt[p].seplen = strlen( fmt[p].sep );
		fmt[p].type = (char*)bun_tail(types, p);
		fmt[p].adt = ATOMindex( fmt[p].type );
	}
	return as->nr_attrs;
}

static
int create_dumpformat( ascii *as, BAT *names, BAT *seps, BAT *bats ){
	int p;
	int nr_attrs = BATcount(names);
	ascii_io *fmt = as->format =  
		(ascii_io*)GDKmalloc(sizeof(ascii_io) * (nr_attrs + 1) );

	as->nr_attrs = nr_attrs;
	for (p=0; p<as->nr_attrs; p++){
		BAT *b = (BAT*)BATdescriptor(*(bat*)bun_tail(bats, p));
		fmt[p].name = (char*)bun_tail(names, p);
		fmt[p].sep = sep_dup((char*)bun_tail(seps, p));
		fmt[p].seplen = strlen( fmt[p].sep );
		fmt[p].type = ATOMname(b->ttype);
		fmt[p].adt = (b)->ttype;
	}
	return as->nr_attrs;
}

static
void destroy_format( ascii *as ){
	int p;
	ascii_io *fmt = as->format;

	for (p=0; p<as->nr_attrs; p++){
		GDKfree( fmt[p].sep );
	}
	GDKfree(fmt);
}

static
int assign_BATs( ascii *as, BAT *bats ){
	ascii_io *fmt = as->format;
	int res = as->nr;
	int i;
	for (i=0; i<as->nr_attrs; i++){
		BAT *b = (BAT*)BATdescriptor(*(bat*)bun_tail(bats, i));
		fmt[i].c = (b);
		if (res == -1 || BATcount(fmt[i].c)<res)
			res = BATcount(fmt[i].c);
	}
	as->nr = res;
	return res;
}

static
int create_bats( ascii *as ){
	ascii_io *fmt = as->format;
	int i;

	for (i=0; i<as->nr_attrs; i++){
		fmt[i].c = void_bat_create(fmt[i].adt,as->nr);
	}
	return 0;
}

static
BAT *collect_bats( ascii *as ){
	BAT *bats = BATnew(TYPE_str,TYPE_bat,as->nr_attrs);
	ascii_io *fmt = as->format;
	int i;

	for (i=0; i<as->nr_attrs; i++){
		BUNins(bats,(ptr)fmt[i].name, (ptr)&fmt[i].c->batCacheid);
	}
	return bats;
}

static INLINE
int myisspace(int s ){
        if (s==(int)' ' || s==(int)'\t' || s==(int)'\n'){
                return 1;
        }
        return 0;
}

static INLINE
char *strip( char *s, char *e ){
        while(myisspace((int)*s)){
		s++;
	}
	e--;
        while(myisspace((int)*e)){
		e--;
	}
	e++;
	if (e && *e){
		*e = 0;
	}
	return s;
}

static INLINE
void insert_val( ascii_io *fmt, char *s, char *e ){
	ptr *adt;
	adt = ADT_fromStr( fmt->adt, strip(s,e) ); 
	BUNins(fmt->c,&int_nil,adt);
	GDKfree(adt);
}

static INLINE
int insert_line( ascii *as, char *line ){
	ascii_io *fmt = as->format;
        char *s,*e = 0;
	int i,quotes = 0;
	for( i = 0; i<as->nr_attrs-1; i++){
		s=line;
		while(*line){
			if (*line == *(fmt[i].sep) && 
			     strncmp( fmt[i].sep, line, fmt[i].seplen) == 0 ){
				e = line; /*strstr( line, fmt[i].sep ); */
				break;
		     	} else if(*line == '\"' && *(line-1) != '\\'){
				quotes = 1;
				line++;
				while( *line && *line!='\"') line++;
				if (*line) line++;
				else return -1;
			} else {
				line++;
			}
		}
		if (e){
			char *end = e;
			if (quotes){
				quotes = 0;
				s = strchr(s, '\"');
				if (!s) return -1;
				s++;
				e = strchr(s, '\"');
			}
			*e = 0;
			insert_val( &fmt[i], s, e );
			line = end + fmt[i].seplen;
		} else {
		        GDKerror("Error: missing sep %s line %d field %d\n", fmt->sep, BATcount(fmt->c), i);
			return -1;
		}
		e = 0;
	}
	s=line;
	while(*line){
		if (*line == *(fmt[as->nr_attrs-1].sep) && 
		     strncmp( fmt[as->nr_attrs-1].sep, line, 
			      fmt[as->nr_attrs-1].seplen) == 0 ){
			e = line; /*strstr( line, fmt[as->nr_attrs-1].sep ); */
			break;
		} else if(*line == '\"' && *(line-1) != '\\'){
			quotes = 1;
			line++;
			while( *line && *line!='\"') line++;
			if (*line) line++;
			else return -1;
		} else {
			line++;
		}
	}
	if (!e) e = line;
	if (e){
		char *end = e;
		if (quotes){
			quotes = 0;
			s = strchr(s, '\"');
			if (!s) return -1;
			s++;
			e = strchr(s, '\"');
		}
		*e = 0;
		insert_val( &fmt[as->nr_attrs-1], s, e );
		line = end + fmt[as->nr_attrs-1].seplen;
	}
	e = 0;
	return 0;
}

static INLINE
int dump_line( ascii_io *fmt, stream *fd, int nr_attrs, int id ){
	char *str;
	int i;
	for( i = 0; i<nr_attrs; i++){
		str = ADT_toStr(fmt[i].adt, (char*)bun_tail(fmt[i].c,id));
		(void)fd->write( fd, str, 1, strlen(str) );
		(void)fd->write( fd, fmt[i].sep, 1, fmt[i].seplen );
		GDKfree(str);
	}
	return 0;
}

#define SIZE 1*1024*1024
static
int load_file( ascii *as, stream *fd ){
	int eof = 0, p = 0;
	char *buf = GDKmalloc(SIZE+1);
	char *s = buf,*sep = as->format[as->nr_attrs-1].sep;
        int i = 0, seplen = as->format[as->nr_attrs-1].seplen;

	while(!eof && i < as->nr){
		int l, size = SIZE-p;
		char *end;
		if ((l=fd->read(fd, buf+p, 1, size )) < size )
			eof = 1;
		end = s + p + l;
		*end = '\0';
		p = l = 0;
		while( s < end ){
			char *e = strstr( s, sep );
			if (e){
				*e = '\0';
				insert_line(as, s );	
				s = e + seplen;
			} else if (eof && s + as->nr_attrs < end){
				insert_line(as, s );	
				s = end;
			} else {
				p = end - s;
				memcpy(buf, s, p );
				break;
			}
			i++;
			if (ascii_io_debug && (i%100000) == 0)
				fprintf(GDKerr, "inserted %d\n", i);
			if (i >= as->nr)
				break;
		}
		s = buf;
	}
	GDKfree(buf);
	as->nr = i;
	return 0;
}

static
int dump_file( ascii *as, stream *fd ){
        int i = 0;
	for( i=0; i<as->nr; i++ ){
		if (dump_line( as->format, fd, as->nr_attrs, i ) < 0)
			return -1;
		if (ascii_io_debug && (i%1000000) == 0)
			fprintf(GDKerr, "dumped %d lines\n", i);
        } 
	return 0;
}

BAT *ASCIIload( BAT *names, BAT *seps, BAT *types, 
		 char *datafile, int nr ){
	BAT *bats = NULL;
	ascii as;

	as.nr_attrs = 0;
	as.nr = nr;
	if (create_loadformat( &as, names, seps, types) >= 0 && 
	    create_bats( &as ) >= 0){
		stream *s = open_rastream( datafile );
		if (!s->errnr && load_file( &as, s )>=0)
			bats = collect_bats( &as );
		if (s->errnr){
		 	GDKerror("could not open file %s\n", datafile );
		} else {
			s->close(s);
		}
		s->destroy(s);
	}
	destroy_format( &as );
	return bats;
}

void ASCIIdump( BAT *names, BAT *seps, BAT *bats, 
	      char *datafile, int nr ){
	ascii as;

	as.nr_attrs = 0;
	as.nr = nr;
	if (create_dumpformat( &as, names, seps, bats) >= 0 && 
	    assign_BATs( &as, bats ) >=  0){
		stream *s = open_wastream( datafile );
		if (!s->errnr && dump_file( &as, s ) >= 0){
			fprintf(GDKerr, "saved in %s\n", datafile );
		}
		if (s->errnr){
		 	GDKerror("could not open file %s\n", datafile );
		} else {
			s->close(s);
		}
		s->destroy(s);
	}
	destroy_format( &as );
}

int init_ascii_io(int *debug){
	ascii_io_debug = *debug;
	return GDK_SUCCEED;
}
int ascii_io_load( BAT **bats, BAT *names, BAT* seps, BAT* types, str datafile, int *nr){
	*bats = ASCIIload( names, seps, types, datafile, *nr );
	if (*bats) {
		return GDK_SUCCEED;
	} else {
		return GDK_FAIL;
	}
}
int ascii_io_dump( BAT *names, BAT* seps, BAT* bats, str datafile, int *nr){
	ASCIIdump( names, seps, bats, datafile, *nr );
	return GDK_SUCCEED;
}

@mil
module(ascii_io,io);

#ascii_io_debug(1);

fp := fopen ( "format", "w+" );
fputs( "key,\",\",str\n", fp);
fputs( "a_io_test,\"\\n\",dbl\n", fp);
fclose( fp );

fp := fopen ( "data", "w+" );
fputs( "test, 0.12345\n", fp);
fputs( "second line, 9.0\n", fp);
fclose( fp );

bats := load("format","data",10);
bats := load_data(load_format(path+"/format"), path+"/test100k", 100000);
bats.print;
a := bats.find("key").reverse().join( bats.find("a_io_test") );
a.print;
dump_data(load_format("format"), "data", -1);

fp := fopen ( "data", "r" );
s := fgets( fp ); 
s.print();
fclose( fp );
quit;
