@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f bat
@v 1.0
@a Peter Boncz, M.L. Kersten
@* Binary Association Tables
@T
This module contains all commands that are of use when managing Binary
Association Tables (BATs). The relational operations you can execute
on BATs have the form of a @[<a href="../algebra/index.html">neat algebra</a>@.

But a database system needs more that just this algebra, since often it
is crucial to do table-updates (this would not be permitted in a strict
algebra).

All commands needed for BAT updates, property management, I/O, persistency, and storage options
can be found in this module.

@* Module Definition
@m
.MODULE bat;

@- BAT basics
@m
.COMMAND bat(int ht, int tt) : BAT[any,any] = CMDnew_default;
"Creates a new empty transient BAT, with head- and tail-types as indicated."

.COMMAND bat(int ht, int tt, int size) : BAT[any,any] = CMDnew;
"Creates a new empty BAT, directly allocating for 'size' elements."

.COMMAND bat(int ht, int tt, lng size) : BAT[any,any] = CMDnew_lng;
"Creates a new empty BAT, directly allocating for 'size' elements."

.COMMAND reverse(BAT[any::1,any::2]) : BAT[any::2,any::1] = CMDreverse;
"Returns the reverse view of a BAT (head is tail and tail is head).
 BEWARE:  no copying is involved; input and output refer to the same object!"

.COMMAND mirror(BAT[any::1,any]) : BAT[any::1,any::1] = CMDmirror;
"Returns the head-mirror image of a BAT (two head columns)."

.COMMAND convert(BAT[any::1,any::2] ) : BAT[any::1,any::2] = CMDconvert;
"Convert the contents of a BAT from little-endian to big-endian and vice versa.
 THIS COMMAND SHOULD NOT BE USED FROM MIL! DANGEROUS! DEBUGGING PUPOSES ONLY!"

.COMMAND order(BAT[any::1,any::2] b) : BAT[any::1,any::2] = CMDorder;
"Sorts the BAT itself, in place, on ascending head values. Returns b."

.COMMAND order_rev(BAT[any::1,any::2] b) : BAT[any::1,any::2] = CMDorder_rev;
"Sorts the BAT itself, in place, on descending head values. Returns b."

.COMMAND revert(BAT[any::1,any::2] b) : BAT[any::1,any::2] = CMDrevert;
"Puts all BUNs in a BAT in reverse order. Returns b."

@- BAT updates
@m
.COMMAND insert(BAT[any::1, any::2], any::1 h, any::2 t)
				: BAT[any::1,any::2] = CMDinsert_bun;
"Insert one BUN[h,t] in a BAT.
 Returns the modified BAT."

.COMMAND insert(BAT[any::1, any::2], BAT[any::1,any::2])
				: BAT[any::1,any::2] = CMDinsert_bat;
"Insert all BUNs of the second BAT into the first.
 Returns the modified BAT."

.COMMAND replace(BAT[any::1, any::2], any::1 h, any::2 t)
				: BAT[any::1,any::2] = CMDreplace_bun;
"Replace the tail value of one BUN that has some head value.
 Returns the modified BAT."

.COMMAND replace(BAT[any::1, any::2], BAT[any::1,any::2])
				: BAT[any::1,any::2] = CMDreplace_bat;
"Perform replace for all BUNs of the second BAT into the first.
 Returns the modified BAT."

.COMMAND delete(BAT[any::1, any::2], any::1 h, any::2 t)
				: BAT[any::1,any::2] = CMDdelete_bun;
"Delete one specific BUN.
 Returns the modified BAT."

.COMMAND delete(BAT[any::1, any::2], any::1 h)
				: BAT[any::1,any::2] = CMDdelete_head;
"Delete all BUNs with a certain head value.
 Returns the modified BAT."

.COMMAND delete(BAT[any::1, any::2])
				: BAT[any::1,any::2] = CMDdelete_all;
"Delete all BUNs in a BAT.
 Returns the modified BAT."

.COMMAND delete(BAT[any::1, any::2] b, BAT[any::1,any] bn)
				: BAT[any::1,any::2] = CMDdelete_bat_head;
"Delete from the first BAT all BUNs with a head value that is in the second.
 Returns the modified BAT."

.COMMAND deleteBuns(BAT[any::1, any::2], BAT[any::1,any::2])
				: BAT[any::1,any::2] = CMDdelete_bat_bun;
"Delete from the first BAT all BUNs with a corresponding BUN in the second.
 Returns the modified BAT."

@+ void bats
To prevent void bats to convert to oid bats we need overloaded insert and
replace commands. These operations should at a later stage be moved to the
kernel libraries, e.g. bat.mx
@m
	.COMMAND append( BAT[oid,any::1] i, any::1 u ) : BAT[oid,any::1] = oid_bat_append_val_wrap; "append the value u to i"

	.COMMAND append( BAT[oid,any::1] i, BAT[oid,any::1] u ) : BAT[oid,any::1] = oid_bat_append_oid_bat_wrap; "append the content of u to i (renumbers u-oids' to unique numbers)"

	.COMMAND append( BAT[void,any::1] i, any::1 u ) : BAT[void,any::1] = bat_append_val_wrap; "append the value u to i"

	.COMMAND append( BAT[void,any::1] i, BAT[void,any::1] u ) : BAT[void,any::1] = bat_append_void_bat_wrap; "append the content of u to i"

	.COMMAND append( BAT[void,any::1] i, BAT[oid,any::1] u ) : BAT[void,any::1] = bat_append_oid_bat_wrap; "append the content of u to i"

	.COMMAND append( BAT[oid,void] i, BAT[oid,void] u ) : BAT[oid,void] = bat_append_oidvoid_bat_wrap; "Special case append for empty bats, works around impossible void,void case"

	.COMMAND replace( BAT[void,any::1] o, BAT[oid,any::1] d ) : BAT[void,any::1] = bat_replace_oid_bat_wrap; "inplace replace values on the given locations"

@- BAT properties
@T
Monet maintains a number of {\em properties} on each BAT that is used to steer tactical
query optimization (i.e. choosing a good algorithms for a particular algebra command).

These properties can be inspected with the {\tt info(BAT[any,any]) : BAT[str,str] } command:
\begin{verbatim}
> var car_age := bat(void,int);
> car_age.info().print();
#---------------------------------#
# BAT:		     tmp_31	  #
# (str)		     (str)	  #
#---------------------------------#
[ "batId",	     "car_age"	  ] # logical bat name
[ "batCacheid",	     "26"	  ] # BBP index
[ "batParentid",     "0"	  ] # set if a BAT is a view
[ "head",	     "void"	  ] # physical head-type
[ "tail",	     "int"	  ] # physical tail-type
[ "batPersistence",  "persistent" ] # transient/session/persistent
[ "batRestricted",   "updatable"  ] # read-only/append-only/updatable
[ "batDirty",	     "clean"	  ] # clean/dirty
[ "batRefcnt",	     "1"	  ] # physical refcount
[ "batLRefcnt",	     "1"	  ] # logical refcount (total)
[ "batPlevel",	     "1"	  ] # logical refcount (persistent part)
[ "batSet",	     "0"	  ] # [head,tail] combinations are unique
[ "batCopiedtodisk", "1"	  ] # has been saved or not
\end{verbatim}

The above are global BAT properties. The properties {\tt batPersistence},
{\tt batRestricted} and {\tt batDirty} will be explained in the next section,
and the various reference counts in the section that follows it.

Per column, a number of properties are kept. We only show the head-properties; the tail properties
have the first character of their named replaced by 't' ({\tt sorted}, {\tt tdense}, etc.):

\begin{verbatim}
[ "hsorted",	     "1"	  ] # column is known to be sorted
[ "hdense",	     "1"	  ] # column is known to be densely ascended
[ "hseqbase",	     "0@0"	  ] # if densely ascending (i.e. 0@0, 1@0, @,0, ...): first value
\end{verbatim}

As described in the @[<a href="../../gdk/index.html#mod_1_3_0">GDK Technical Reference</a>@,
BATs store their data in one to five heaps, of which at least one called {\tt batBuns}
is present always. For each column type that is {\em variable-sized} - like {\tt str} - another
heap might be present ({\tt hheap} and {\tt theap}). 

\begin{verbatim}
[ "batBuns.free",    "400004"	  ] # occupied size in bytes
[ "batBuns.size",    "400012"	  ] # allocated size in bytes
[ "batBuns.maxsize", "400012"	  ] # reserver virtual memory in bytes
[ "batBuns.storage", "malloced"	  ] # malloced/mmap/priv
\end{verbatim}

Properties steer the algorithms that Monet uses to execute algebra command. For instance,
the {\tt find(BAT[any::1,any::2] b, any:;1) : any::2) that looks up a tail value by head,
uses binary search if and only if the head column is sorted (in other cases, hash-lookup
and scan are execution options).

Sometimes new (extension) code contains bugs in the property management, leaving false
properties on produced BATs. You can imagine that later on, this leads to additional
bugs, as e,g, the binary search algorithms will yield erroneous results on a non-sorted
sequence.

To make problem detection easier, the MIL interpreter contains property checking code,
that is set with via the  {\tt debugmask(int)} command:
\begin{description}
\item[2] {\tt debugmask(debugmask() and 2)} causes that all properties on
newly created BATs to be checked. You must realize that finding out that a column is sorted
({\tt hsorted/tsorted}) costs a full scan, and finding out that it contains unique values
({\tt hkeyed/tkeyed}) costs a full scan plus the creation of a full hash index.
\item[8] {\tt debugmask(debugmask() and 8)} causes that all properties on
{\bf all} BATs handled by the MIL interpreter to be checked. This will catch all property errors.
\end{description}

By default, both bits in the {\tt debugmask} are off, which gives fastest performance.
@m
.COMMAND count ( int bid ) : lng = CMDcount_bat;
"Returns the current size (in number of elements) of a BAT."

.COMMAND count ( BAT[void,void] b, lng cnt ) : lng = CMDsetcount_bat;
"Returns the current size (in number of elements) of a BAT."

.COMMAND capacity ( int bid ) : lng = CMDcapacity;
"Returns the current allocation size (in max number of elements) of a BAT."

.COMMAND info ( BAT[any,any] ) : BAT[str,str] = CMDinfo;
"Produce a BAT containing info about a BAT in \"attribute\",\"value\" format.
 It contains all properties of the BAT record. See the BAT documentation in
 GDK for more information."

.COMMAND head ( int bid ) : str = CMDhead;
"Returns the type of the head column of a BAT, as a string."

.COMMAND tail ( int bid ) : str = CMDtail;
"Returns the type of the tail column of a BAT, as a string."

.COMMAND key( BAT[any::1,any::2] b, bit mode)
				: BAT[any::1,any::2] = CMDsetkey;
"Sets the 'key' property of the head column to 'mode'. In 'key' mode,
 the kernel will silently block insertions that cause a duplicate entries
 in the head column.
 KNOWN BUG: when 'key' is set to TRUE, this function does not automatically
 eliminate duplicates. Use b := b.kunique;"

.COMMAND key( BAT[any::1,any::2] b) : bit = CMDgetkey;
"return whether the head column of a BAT is unique (key)."

.COMMAND set( BAT[any::1,any::2] b, bit mode)
				: BAT[any::1,any::2] = CMDsetset;
"Sets the 'set' property on this BAT to 'mode'. In 'set' mode, the kernel
 will silently block insertions that cause a duplicate BUN [head,tail] entries
 in the BAT.
 KNOWN BUG: when 'set' is set to TRUE, this function does not automatically
 eliminate duplicates. Use b := b.sunique;
 Returns the BAT itself."

.COMMAND access( BAT[any::1,any::2] b, int mode)
				: BAT[any::1,any::2] = CMDsetaccess;
"Try to change the update access priviliges to this BAT. Mode:
 BAT_READ   - allow only read access.
 BAT_APPEND - allow reads and insertions of new elements.
 BAT_WRITE  - allow reads, insertions, and updates.
 BATs are updateable by default. On making a BAT readonly, all
 subsequent updates fail with an error message.
 Returns the BAT itself."

.COMMAND access( BAT[any::1,any::2] b) : int = CMDgetaccess;
"Return the update access privilige of a BAT."

.COMMAND seqbase( BAT[oid,any::1] b ) : oid = CMDget_seqbase;
"Get the sequence base for the void vcolumn of a BAT."

.COMMAND seqbase( BAT[void,any::1] b ) : oid = CMDget_seqbase;
"Get the sequence base for the void vcolumn of a BAT."

.COMMAND seqbase( BAT[void,any::1] b, oid seqbase)
				: BAT[void,any::1] = CMDset_seqbase;
"Set the sequence base for the void vcolumn of a BAT.
 Returns the BAT itself."

.COMMAND ordered(BAT[any,any]) : bit = CMDordered;
"Returns whether a BAT is ordered on head or not."

.COMMAND ordered_rev(BAT[any,any]) : bit = CMDordered_rev;
"Returns whether a BAT is ordered on head or not."


.COMMAND batsize(str batname) : int = CMDbatsize_str;
"A version of BATsize that does not require loading the BAT."

.COMMAND batsize(BAT[any,any] b) : int = CMDbatsize;
"A version of BATsize that does not require loading the BAT."

@- BUN Access
@m
.ITERATOR  batloop(BAT[any,any], ptr handle) = CMDbatloop_std;
"Iterators are special MIL constructs:
  <bat-expression> @ <iterator>(<parameters>) <MIL-statement>
 'b@batloop()..' iterates over all BUNs [$h,$t] of BAT b."

.ITERATOR  batloop(BAT[any,any], ptr handle, int low, int high) = CMDbatloop;
"Iterators are special MIL constructs:
  <bat-expression> @ <iterator>(<parameters>) <MIL-statement>
 'b@batloop(low,high)..' iterates over all BUNs of b.slice(low,high)"

.ITERATOR  hashloop(BAT[any::1,any] b, ptr handle, any::1 val) = CMDhashloop;
"Iterators are special MIL constructs:
  <bat-expression> @ <iterator>(<parameters>) <MIL-statement>
 'b@hashloop(v)..' iterates over all BUNs [$h,$t] of BAT b where ($h = val)."

@- BAT I/O, Persistency
@T
The BAT Buffer Pool (BBP) manages all known BATs. It administers
their logical and physical names and a reference count. BATs can
be {\em persistent}, {\em transient} or {\em session}. The BBP also manages
swapping on a BAT level: a BAT is either loaded entirely or not.
MIL variables of type {\tt bat} can either be loaded or not. When
the Monet server is started, all BATs are swapped out. If an unloaded
bat-variable is used as an operand in a command, it is automatically
loaded.	 The BBP applies a simple but effective LRU based swapping
algorithm. BATs have a {\em heat}, which drops over time, and is
increased when a BAT is used by some command.  If the size of the
allocated arena gets to be large, BATs may be swapped out.
@m
.COMMAND bbpname ( BAT[any,any] , str s) : BIT = CMDrename;
"Give a logical name to a BAT. This can fail if a BAT with name 's' already
 exists. The command then returns FALSE, else TRUE."

.COMMAND bbpname ( BAT[any,any]) : STR = CMDname;
"Gives back the logical name of a BAT."

.COMMAND roles ( BAT[any::1,any::2] , str h, str t)
				: BAT[any::1,any::2] = CMDroles;
"Give a logical name to the columns of a BAT.
 Returns the BAT itself."

.COMMAND col_name ( BAT[any,any] , str s) : BAT[any,any] = CMDcol_name;
"Give a logical name to tail column of a BAT.
 Returns the BAT itself."

.COMMAND persists( BAT[any::1,any::2], bit mode) : BAT[any::1,any::2] = CMDpersists;
"Make the BAT persistent (mode = TRUE), transient (mode = FALSE).
 or session (mode = bit(nil)). Returns the BAT itself."

.COMMAND destroy(str nme ) : bit = CMDdestroy;
"Destroys the BAT."

.COMMAND save(str nme) : bit = CMDsave;
"Save a BAT to storage, if it was loaded and dirty. Returns whether IO was necessary.
 Please realize that calling this function violates the atomic repository commit protocol!!"

.COMMAND unload(str name) : bit = CMDunload;
"Swapout a BAT to disk. Transient BATs can also be swapped out.
 Returns whether the unload indeed happened. "

.COMMAND hot(str name) : void = CMDhot;
"Makes a BAT very hot for the BBP. The chance of being chosen for swapout is
 small, afterwards.  Returns the BAT itself."

.COMMAND cold(str nme) : void = CMDcold;
"Makes a BAT very cold for the BBP. The chance of being choses for swapout is
 big, afterwards.  Returns the BAT itself."

.COMMAND heat(str nme) : int = CMDheat;
"returns the current BBP heat (LRU stamp)"


@- Heap Specific Commands
@T
BATs are stored in memory in a number of Heap objects. A heap is nothing
more than a contiguous range of memory. Bats are saved to disk by just writing
away their image. This approach without pointer swizzling makes it possible
to either load an image into an alloced range of memory (STORE\_MEM), or
memory-map (STORE\_MMAP) an image into virtual memory.

The heap images of a BAT are stored in the {\tt $MONETHOME/dbfarm/$DB/bat/}
directory.  For each bat X, the following heaps are stored:
\begin{description}
\item[X.buns] an array with all the fixed-size parts of all BUNs.
\item[X.hheap] if the head column contains a variable sized atoms (e.g. str),
then the fixed-size part of a BUN contains an integer byte-offset into
the heap. String values themselves are stored in this the X.hheap.
\item[X.theap] similar to X.hheap, but for the tail column.
\item[X.hacc]. On each column, you might create {\em persistent hash accelerator
structure}. 
\end{description}

Each of these heaps can be {\bf compressed} using the Unix {\tt compress}
utility forming a X.ext.Z file. Monet will automatically decompress it
upon load. Compressed heaps cannot be memory mapped.

A final file present for each t in the BAT directory is:
\begin{description}
\item[X.desc] the BAT descriptor. Stores most of the properties of a BAT.
\end{description}
@
For more technical information on BATs, we refer to the
@[<a href="../../gdk/index.html">GDK</a>@
documentation.
@m
.COMMAND mmap(BAT[any::1,any::2], int buns_mode, int hheap_mode, int theap_mode) : BAT[any::1,any::2] = CMDmmap;
"For each individual heap, you can change the allocation mode to
 either STORE_MEM or STORE_MMAP. Passing an int(nil) means: no change.
 Changing a dirty STORE_MEM heap into STORE_MMAP, will cause a BAT save
 (this has to happen before the heap can be mapped into virtual memory).
 These modes are persistent. "

.COMMAND madvise(BAT[any::1,any::2], int buns_mode, int hheap_mode, int theap_mode) : BAT[any::1,any::2] = CMDmadvise;
"Modern Operating Systems allow users to influence the buffer management
 policy of virtual memory. This is a crucial feature for database systems,
 and eliminates the need to reimplement the OS in a database buffer manager.
 The supported flags are BUF_NORMAL (the normal adaptive kernel algorithm),
 BUF_RANDOM (no page prefetching), BUF_SEQUENTIAL (prefetch and swapout),
 BUF_WILLNEED (load everything with prefetch), BUF_DONTNEED (swapout).
 These buffer management modes are not persistent.
 Returns the BAT operated upon."

@- BAT Accelerators
@m
.COMMAND accbuild(BAT[any,any] b, str acctype) = CMDaccbuild;
"Build an accelerator on the head column of b. The builtin accelerator
 types index and hash will be created as transient accelerators. They
 will not be saved on disk. User-defined accelerators must always be
 persistent."

@- Synced BATs
The binary model of Monet has important advantages when working in
main-memory. Tables are thin and very efficiently processed. The binary
model gives rise, however, to a larger-than-normal number of join
and semijoin operations. Relations are split up in vertical parts that
are very much related to each other. Then, for instance, multiple
similar semijoins occur on different vertical parts. By equipping the
kernel with knowledge about the correspondence of these parts, we
can greatly limit the amount of work to be done.

When two BATs effectively contain the same sequence of head elements,
we call them 'synced'. This is implemented by storing a very large
OID for each column. An update to the column destroys this OID.
By comparing two OIDs the Monet kernel can very quickly decide that
two columns are exactly equal. All BAT algebra operations propagate
these 'sync' OIDs with their own propagation rules.
@m
.COMMAND synced (BAT[any,any] b1, BAT[any,any] b2) : bit = CMDsynced;
"Tests whether two BATs are synced or not. "

.END bat;

@- system bats
@mil
    CONST monet_fcn_aut := bat("monet_fcn_aut");
    CONST monet_fcn_cnt := bat("monet_fcn_cnt");
    CONST monet_fcn_dat := bat("monet_fcn_dat");
    CONST monet_fcn_dsc := bat("monet_fcn_dsc");
    CONST monet_fcn_fcn := bat("monet_fcn_fcn");
    CONST monet_fcn_imp := bat("monet_fcn_imp");
    CONST monet_fcn_mid := bat("monet_fcn_mid");
    CONST monet_fcn_nme := bat("monet_fcn_nme");
    CONST monet_fcn_pro := bat("monet_fcn_pro");
    CONST monet_fcn_sig := bat("monet_fcn_sig");
    CONST monet_fcn_tpe := bat("monet_fcn_tpe");
    CONST monet_mod_acc := bat("monet_mod_acc");
    CONST monet_mod_atm := bat("monet_mod_atm");
    CONST monet_mod_cnt := bat("monet_mod_cnt");
    CONST monet_mod_dep := bat("monet_mod_dep");
    CONST monet_mod_drop := bat("monet_mod_drop");
    CONST monet_mod_hdl := bat("monet_mod_hdl");
    CONST monet_mod_load := bat("monet_mod_load");
    CONST monet_mod_nme := bat("monet_mod_nme");
    CONST monet_mod_proc := bat("monet_mod_proc");
    CONST monet_mod_use := bat("monet_mod_use");
    CONST monet_mod_var := bat("monet_mod_var");

@- constants for mmap()
@mil
    CONST STORE_MEM   := 0;	# load into GDKmalloced memory
    CONST STORE_MMAP  := 1;	# mmap() into virtual memory
    CONST STORE_COMPR := 2;	# currently not implemented this way

    PROC mmap(bat[any::1,any::2] b, int memmode) : bat[any::1,any::2] {
	return mmap(b, memmode, memmode, memmode );
    }

    # overload madvise to pass the same memory mode for all heaps
    PROC madvise(bat[any::1,any::2] b, int memmode) : bat[any::1,any::2] {
	return madvise(b, memmode, memmode, memmode );
    }

@- constants for madvise()
@mil
    CONST BUF_NORMAL	:= 0;	# No further special treatment
    CONST BUF_RANDOM	:= 1;	# Expect random page references
    CONST BUF_SEQUENTIAL:= 2;	# Expect sequential page references
    CONST BUF_WILLNEED	:= 3;	# Will need these pages
    CONST BUF_DONTNEED	:= 4;	# Don't need these pages
@- constants for readonly()
@mil
    CONST BAT_READ   := 1;	# allow only read access.
    CONST BAT_APPEND := 2;	# allow reads and insertions of new elements.
    CONST BAT_WRITE  := 0;	# allow reads, insertions, and updates.

    PROC destroy(bat[any,any] b) : bit{
	return destroy(str(b));
	}

    PROC capacity(bat[any,any] b) : lng {
	return capacity(int(b));
	}

    PROC save(bat[any::1,any::2] b) : bat[any::1,any::2] {
	save(bbpname(b));
	return b;
    }

    PROC load(str batname) : bat[any,any] {
	return bat(batname);
    }

    PROC cold(bat[any::1,any::2] b) : void {
	cold(b.bbpname());
    }

    PROC hot(bat[any::1,any::2] b) : void {
	hot(b.bbpname());
    }

    PROC head(bat[any,any] b) : str {
	return head(int(b));
    }

    PROC tail(bat[any,any] b) : str  {
	return tail(int(b));
	}

    PROC ttype(any b) : int   {
	 return monet_atomtbl.find(b.tail());
    }
#    ADDHELP("ttype","boncz","Apr 07 2004","Get tail-type as an integer","bat");

    PROC htype(any b) : int   {
	 return monet_atomtbl.find(b.head());
    }
#    ADDHELP("htype","boncz","Apr 07 2004","Get head-type as an integer","bat");

    PROC new(int ht, int tt) : bat[any,any] {
	return bat(ht,tt);
    }

    PROC new(int ht, int tt, int cnt) : bat[any,any] {
	return bat(ht,tt,cnt);
    }

    PROC new(int ht, int tt, lng cnt) : bat[any,any] {
	return bat(ht,tt,cnt);
    }
@
@{
@{
@* Implementation Code

@= batconvert
	(BAT@2type(@1) == TYPE_bat)?(BUN)&((BAT*)@2)->batCacheid:(BUN)@2

@+ Information Functions

@h
#ifndef BAT_H
#define BAT_H

#include "gdk.h"
#include "monet.h"
#include "bat.proto.h"

bat_export size_t void_append_bat(BAT *b, BAT *u);
bat_export size_t void_insert_bat(BAT *b, BAT *u);
bat_export ssize_t void_replace_bat(BAT *b, BAT *u);
bat_export int void_inplace(BAT *b, oid id, ptr val);

#endif /*BAT_H */
@c
#include "bat.h"

int
CMDnew_lng(BAT **ret, int *ht, int *tt, lng *cap)
{
	if (*cap < 0)
		*cap = 0;
	*ret = BATnew(*ht, *tt, (size_t) * cap);
	if (*ret)
		(*ret)->batDirty |= 2;
	return (*ret) ? GDK_SUCCEED : GDK_FAIL;
}

int
CMDnew(BAT **ret, int *ht, int *tt, int *cap)
{
	if (*cap < 0)
		*cap = 0;
	*ret = BATnew(*ht, *tt, (size_t) * cap);
	if (*ret)
		(*ret)->batDirty |= 2;
	return (*ret) ? GDK_SUCCEED : GDK_FAIL;
}

int
CMDnew_default(BAT **ret, int *ht, int *tt)
{
	int default_size = 0;

	return CMDnew(ret, ht, tt, &default_size);
}

int
CMDreverse(BAT **ret, BAT *b)
{
	*ret = BATmirror(b);
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

int
CMDmirror(BAT **ret, BAT *b)
{
	BAT *v = *ret = VIEWcombine(b);

	if (b->batRestricted == BAT_WRITE) {
		*ret = BATrcopy(v);
		BBPreclaim(v);
	}
	return (*ret) ? GDK_SUCCEED : GDK_FAIL;
}

int
CMDconvert(BAT **ret, BAT *b)
{
	if (BATconvert(*ret = b, CONV_HTON) == NULL)
		BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

int
CMDrevert(BAT **ret, BAT *b)
{
	if (BATrevert(*ret = b) == NULL)
		return GDK_FAIL;
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

int
CMDorder(BAT **ret, BAT *b)
{
	if (BATorder(*ret = b) == NULL)
		return GDK_FAIL;
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

int
CMDorder_rev(BAT **ret, BAT *b)
{
	if (BATorder_rev(*ret = b) == NULL)
		return GDK_FAIL;
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

int
CMDinsert_bun(BAT **r, BAT *b, ptr h, ptr t)
{
	if (BUNins(*r = b, @:batconvert(b,h)@, @:batconvert(b,t)@) == NULL)
		return GDK_FAIL;
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

int
CMDinsert_bat(BAT **r, BAT *b, BAT *s)
{
	if (BATins(*r = b, s) == NULL)
		return GDK_FAIL;
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

int
CMDreplace_bun(BAT **r, BAT *b, ptr h, ptr t)
{
	if (BUNreplace(*r = b, @:batconvert(b,h)@, @:batconvert(b,t)@) == NULL)
		return GDK_FAIL;
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

int
CMDreplace_bat(BAT **r, BAT *b, BAT *s)
{
	if (BATreplace(*r = b, s) == NULL)
		return GDK_FAIL;
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

int
CMDdelete_bun(BAT **r, BAT *b, ptr h, ptr t)
{
	if (BUNdel(*r = b, h, t) == NULL)
		return GDK_FAIL;
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

int
CMDdelete_head(BAT **r, BAT *b, ptr h)
{
	if (BUNdelHead(*r = b, @:batconvert(b,h)@) == NULL)
		return GDK_FAIL;
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

int
CMDdelete_all(BAT **r, BAT *b)
{
	if (BATclear(*r = b) == NULL)
		return GDK_FAIL;
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

int
CMDdelete_bat_bun(BAT **r, BAT *b, BAT *s)
{
	if (BATdel(*r = b, s) == NULL)
		return GDK_FAIL;
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

int
CMDdelete_bat_head(BAT **r, BAT *b, BAT *s)
{
	if (BATdelHead(*r = b, s) == NULL)
		return GDK_FAIL;
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}


@-
The next collection of operators fill a hole in the Monet kernel libraries.
It provide handy operations on void-BATs. The sole reason not to move it to
the bat.mx module is that overall the kernel does not support bat[void,void]
@c
size_t
void_append_bat(BAT *b, BAT *u)
{
	size_t sz = BUNsize(u);
	size_t sbase = b->hseqbase + BATcount(b);

	BATseqbase(u, sbase);
	BATins(b, u);
	return sz;
}

size_t
void_insert_bat(BAT *b, BAT *u)
{
	size_t nr = 0;
	BUN r, s;
	oid nil = oid_nil;

	BATloop(u, r, s) {
		BUNins(b, (ptr) &nil, BUNtail(u, r));
		nr++;
	}
	return nr;
}

int
void_inplace(BAT *b, oid id, ptr val)
{
	int res = GDK_SUCCEED;
	BUN p = NULL;
	BUN oldInserted = b->batInserted;

	assert(b->htype == TYPE_void);
	assert(b->hseqbase != oid_nil);
	assert(BATcount(b) > (id -b->hseqbase));

	b->batInserted = NULL;
	BUNfndVOID(p, b, (ptr) &id);

	assert(p >= b->batInserted);	/* we don't want delete/ins */
	if (b->batRestricted)
		GDKerror("void_inplace: access denied\n");
	assert(!b->batRestricted);
	if (!BUNinplace(b, p, (ptr) &id, val))
		 res = GDK_FAIL;

	b->batInserted = oldInserted;
	return res;
}

ssize_t
void_replace_bat(BAT *b, BAT *u)
{
	size_t nr = 0;
	BUN r, s;

	BATloop(u, r, s) {
		oid updid = *(oid *) BUNhead(u, r);
		ptr val = BUNtail(u, r);

		if (void_inplace(b, updid, val) == GDK_FAIL)
			return -1;
		nr++;
	}
	return nr;
}

int
bat_append_void_bat_wrap(BAT **res, BAT *i, BAT *u)
{
	*res = i;
	void_append_bat(i, u);
	BBPfix(i->batCacheid);
	return GDK_SUCCEED;
}

int
bat_append_oid_bat_wrap(BAT **res, BAT *i, BAT *u)
{
	*res = i;
	void_insert_bat(i, u);
	BBPfix(i->batCacheid);
	return GDK_SUCCEED;
}

int
bat_append_oidvoid_bat_wrap(BAT **res, BAT *i, BAT *u)
{
	/*(void)u; fake usage to fool compilers in case assertions are disabled
	   assert (!BATcount(i));
	 */
	*res = i;
	void_insert_bat(i, u);
	BBPfix(i->batCacheid);
	return GDK_SUCCEED;
}

static oid
oid_max(BAT *i)
{
	oid o = 0;

	if (BATcount(i))
		o = *(oid *) BUNhead(i, BUNlast(i) - BUNsize(i));
	if (!BAThordered(i)) {
		BUN r, s;
		int d;

		BATloopFast(i, r, s, d) {
			oid v = *(oid *) BUNhead(i, r);

			if (v > o)
				o = v;
		}
	}
	return o;
}

int
oid_bat_append_oid_bat_wrap(BAT **res, BAT *i, BAT *u)
{
	BUN r, s;
	oid o;

	assert(i->htype == TYPE_oid && (BATcount(u) == 0 || u->htype == TYPE_oid || u->htype == TYPE_void));

	o = oid_max(i);
	o++;
	BATloop(u, r, s) {
		oid h = *(oid *) BUNhead(u, r) + o;

		BUNins(i, &h, BUNtail(u, r));
	}
	*res = i;
	BBPfix(i->batCacheid);
	return GDK_SUCCEED;
}

int
oid_bat_append_val_wrap(BAT **res, BAT *i, ptr t)
{
	oid o;

	assert(i->htype == TYPE_oid);
	o = oid_max(i);
	o++;
	*res = i;
	BUNins(i, (ptr) &o, @:batconvert(i,t)@
	    );
	BBPfix(i->batCacheid);
	return GDK_SUCCEED;
}


int
bat_append_val_wrap(BAT **res, BAT *i, ptr t)
{
	oid h = i->hseqbase + BATcount(i);

	*res = i;
	BUNins(i, (ptr) &h, @:batconvert(i,t)@
	    );
	BBPfix(i->batCacheid);
	return GDK_SUCCEED;
}

int
bat_replace_oid_bat_wrap(BAT **res, BAT *o, BAT *d)
{
	*res = o;
	if (void_replace_bat(o, d) < 0)
		return GDK_FAIL;
	BBPfix(o->batCacheid);
	return GDK_SUCCEED;
}


/* descriptors may be unloaded by BBPtrim, so secure them with a hotfix while in use */
static BAT *
lock_desc(bat bid)
{
	BBPfix(bid);
	return (BAT *) BBPgetdesc(bid);
}

static void
unlock_desc(bat bid)
{
	BBPunfix(bid);
}

int
CMDcount_bat(lng *res, int *bid)
{
	if (BBPcheck((bat) *bid, "CMDcount_bat")) {
		BAT *b = lock_desc((bat) *bid);

		if (b == NULL) {
			*res = lng_nil;
		} else if (BBP_cache((bat) *bid)) {
			*res = (lng) BATcount(b);
		} else {
			/* BAT not loaded */
			*res = (lng) ((b->batBuns->free - (b->batFirst - b->batBuns->base)) / BUNsize(b) );
		}
		unlock_desc(*bid);
	}
	return GDK_SUCCEED;
}

int
CMDsetcount_bat(lng *res, BAT *b, lng *c)
{
	BATsetcount(b,*c);
	/* also need to set the end of the heap (allthough not used) */
	b->batBuns->free += *c;
	*res = *c;
	return GDK_SUCCEED;
}

int
CMDcapacity(lng *res, int *bid)
{
	if (BBPcheck((bat) *bid, "CMDcapacity")) {
		BAT *b = lock_desc((bat) *bid);

		if (b == NULL) {
			*res = lng_nil;
		} else {
			*res = (lng) BATcapacity(b);
		}
		unlock_desc(*bid);
	}
	return GDK_SUCCEED;
}

int
CMDhead(str *res, int *bid)
{
	if (BBPcheck((bat) *bid, "CMDhead")) {
		str ret = str_nil;
		BAT *b = lock_desc((bat) *bid);

		if (b) {
			ret = *bid > 0 ? ATOMname(b->htype) : ATOMname(b->ttype);
		}
		*res = GDKstrdup(ret);
		unlock_desc(*bid);
	} else {
		*res = GDKstrdup(str_nil);
	}
	return GDK_SUCCEED;
}

int
CMDtail(str *res, int *bid)
{
	if (BBPcheck((bat) *bid, "CMDtail")) {
		str ret = str_nil;
		BAT *b = lock_desc((bat) *bid);

		if (b) {
			ret = *bid > 0 ? ATOMname(b->ttype) : ATOMname(b->htype);
		}
		*res = GDKstrdup(ret);
		unlock_desc(*bid);
	} else {
		*res = GDKstrdup(str_nil);
	}
	return GDK_SUCCEED;
}

int
CMDsetkey(BAT **result, BAT *input, bit *param)
{
	BATkey(*result = input, *param ? BOUND2BTRUE : FALSE);
	BBPfix(input->batCacheid);
	return GDK_SUCCEED;
}

int
CMDsetset(BAT **result, BAT *input, bit *param)
{
	BATset(*result = input, *param ? BOUND2BTRUE : FALSE);
	BBPfix(input->batCacheid);
	return GDK_SUCCEED;
}

int
CMDordered(bit *result, BAT *input)
{
	*result = BATordered(input) ? 1 : 0;
	return GDK_SUCCEED;
}

int
CMDordered_rev(bit *result, BAT *input)
{
	*result = BATordered_rev(input) ? 1 : 0;
	return GDK_SUCCEED;
}

int
CMDgetkey(bit *ret, BAT *b)
{
	/* we must take care of the special case of a nil column (TYPE_void,seqbase=nil)
	 * such nil columns never set hkey (and BUNins will never invalidate it if set) yet
	 * a nil column of a BAT with <= 1 entries does not contain doubles => return TRUE.
	 */
	if (BATcount(b) <= 1) {
		*ret = TRUE;
	} else {
		if (!b->hkey) {
			BATpropcheck(b, BATPROPS_ALL);
		}
		*ret = b->hkey ? TRUE : FALSE;
	}
	return GDK_SUCCEED;
}

int
CMDpersists(BAT **r, BAT *input, bit *param)
{
	BATmode(*r = input, (*param == TRUE) ? PERSISTENT : (*param == FALSE) ? TRANSIENT : SESSION);
	BBPfix(input->batCacheid);
	return GDK_SUCCEED;
}

int
CMDdestroy(bit *res, str input )
{
	int bid = BBPindex(input);

	*res = FALSE;
	if (bid) {
		BBPfix(bid);
		if (BBPindex(input) == bid) {
			BAT *b = (BAT*)BBPgetdesc(ABS(bid));

			BATmode(b, TRANSIENT);
			*res = TRUE;
		}
		BBPunfix(bid);
	}
	return GDK_SUCCEED;
}

int
CMDsetaccess(BAT **r, BAT *input, int *param)
{
	bat oldCacheid = input->batCacheid;

	*r = BATsetaccess(input, *param);
	if ((*r)->batCacheid == oldCacheid) {
		BBPfix(oldCacheid);
	}
	return GDK_SUCCEED;
}

int
CMDgetaccess(int *r, BAT *input)
{
	*r = BATgetaccess(input);
	return GDK_SUCCEED;
}

static char *
pre(str s1, str s2)
{
	static char buf[64];

	snprintf(buf, 64, "%s%s", s1, s2);
	return buf;
}
static char *
local_itoa(ssize_t i)
{
	static char buf[32];

	snprintf(buf, 32, SSZFMT, i);
	return buf;
}
static char *
local_utoa(size_t i)
{
	static char buf[32];

	snprintf(buf, 32, SZFMT, i);
	return buf;
}

#define COLLISION 6

void
HASHinfo(BAT *bn, Hash *h, str s)
{
	hash_t i;
	hash_t j;
	size_t cnt[COLLISION + 2];
	size_t largebuckets = 0;
	size_t largetot = 0;
	char buf[32];

	BUNins(bn, pre(s, "type"), ATOMname(h->type));
	BUNins(bn, pre(s, "mask"), local_utoa(h->mask));
	BUNins(bn, pre(s, "lim"), local_utoa(h->lim));

	for (i = 0; i <= COLLISION + 1; i++) {
		cnt[i] = 0;
	}
	for (i = 0; i <= h->mask; i++) {
		if (h->hash[i] == HASH_MAX) {
			cnt[0]++;
		} else if (h->hash[i] > h->lim) {
			GDKerror("HASHinfo: hash consistency problem %d\n", i);
		} else if ((j = HASHlist(h, h->hash[i])) <= COLLISION + 1) {
			cnt[j]++;
		} else {
			largebuckets++;
			largetot += j;
		}
	}

	for (i = 0; i <= COLLISION + 1; i++)
		if (cnt[i]) {
			BUNins(bn, pre(s, local_utoa(i)), local_utoa(cnt[i]));
		}
	snprintf(buf, 32, SZFMT " on " SZFMT, largetot, largebuckets);
	BUNins(bn, pre(s, "collision"), buf);
}

static void
infoHeap(BAT *bn, Heap *hp, str nme)
{
	char buf[1024], *p = buf;

	if (!hp)
		return;
	while (*nme)
		*p++ = *nme++;
	strcpy(p, "free");
	BUNins(bn, buf, local_utoa(hp->free));
	strcpy(p, "size");
	BUNins(bn, buf, local_utoa(hp->size));
	strcpy(p, "maxsize");
	BUNins(bn, buf, local_utoa(hp->maxsize));
	strcpy(p, "storage");
	BUNins(bn, buf, (hp->base == NULL) ? "absent" : (hp->storage == STORE_MMAP) ? (hp->filename ? "memory mapped" : "anonymous vm") : (hp->storage == STORE_PRIV) ? "private map" : "malloced");
	strcpy(p, "filename");
	BUNins(bn, buf, hp->filename ? hp->filename : "no file");
}

static char *
oidtostr(oid i)
{
	int len = 32;
	static char bf[32];
	char *p = bf;

	(void) OIDtoStr(&p, &len, &i);
	return bf;
}

int
CMDinfo(BAT **retval, BAT *b)
{
	BAT *bn;
	char mode[1024], *access;

	if (!(bn = BATnew(TYPE_str, TYPE_str, 128)))
		return GDK_FAIL;
	*retval = bn;

	if (b->batPersistence == PERSISTENT) {
		strcpy(mode, "persistent");
	} else if (b->batPersistence == SESSION) {
		strcpy(mode, "session");
	} else if (b->batPersistence == TRANSIENT) {
		strcpy(mode, "transient");
	} else {
		strcpy(mode, "unknown");
	}

	switch (b->batRestricted) {
	case BAT_READ:
		access = "read-only";
		break;
	case BAT_WRITE:
		access = "updatable";
		break;
	case BAT_APPEND:
		access = "append-only";
		break;
	default:
		access = "unknown";
	}

	BUNins(bn, "version", local_itoa(b->GDKversion));
	BUNins(bn, "batId", b->batId);
	BUNins(bn, "batCacheid", local_itoa(b->batCacheid));
	BUNins(bn, "batParentid", local_itoa(b->batParentid));
	BUNins(bn, "batSharecnt", local_itoa(b->batSharecnt));
	BUNins(bn, "head", ATOMname(b->htype));
	BUNins(bn, "tail", ATOMname(b->ttype));
	BUNins(bn, "batPersistence", mode);
	BUNins(bn, "batRestricted", access);
	BUNins(bn, "batRefcnt", local_itoa(BBP_refs(b->batCacheid)));
	BUNins(bn, "batLRefcnt", local_itoa(BBP_lrefs(b->batCacheid)));
	BUNins(bn, "batDirty", BATdirty(b) ? "dirty" : "clean");
	BUNins(bn, "batSet", local_itoa(b->batSet));
	BUNins(bn, "void_tid", local_itoa(b->void_tid));
	BUNins(bn, "void_cnt", local_itoa(b->void_cnt));

	BUNins(bn, "hsorted", local_itoa(BAThordered(b)));
	BUNins(bn, "hident", b->hident);
	BUNins(bn, "hdense", local_itoa(BAThdense(b)));
	BUNins(bn, "hseqbase", oidtostr(b->hseqbase));
	BUNins(bn, "hkey", local_itoa(b->hkey));
	BUNins(bn, "hloc", local_itoa(b->hloc));
	BUNins(bn, "hvarsized", local_itoa(b->hvarsized));
	BUNins(bn, "halign", local_utoa(b->halign));
	BUNins(bn, "hnosorted", local_utoa(b->H->nosorted));
	BUNins(bn, "hnosorted_rev", local_utoa(b->H->nosorted_rev));
	BUNins(bn, "hnodense", local_utoa(b->H->nodense));
	BUNins(bn, "hnokey[0]", local_utoa(b->H->nokey[0]));
	BUNins(bn, "hnokey[1]", local_utoa(b->H->nokey[1]));

	BUNins(bn, "tident", b->tident);
	BUNins(bn, "tdense", local_itoa(BATtdense(b)));
	BUNins(bn, "tseqbase", oidtostr(b->tseqbase));
	BUNins(bn, "tsorted", local_itoa(BATtordered(b)));
	BUNins(bn, "tkey", local_itoa(b->tkey));
	BUNins(bn, "tloc", local_itoa(b->tloc));
	BUNins(bn, "tvarsized", local_itoa(b->tvarsized));
	BUNins(bn, "talign", local_utoa(b->talign));
	BUNins(bn, "tnosorted", local_utoa(b->T->nosorted));
	BUNins(bn, "tnosorted_rev", local_utoa(b->T->nosorted_rev));
	BUNins(bn, "tnodense", local_utoa(b->T->nodense));
	BUNins(bn, "tnokey[0]", local_utoa(b->T->nokey[0]));
	BUNins(bn, "tnokey[1]", local_utoa(b->T->nokey[1]));

	BUNins(bn, "batInserted", local_utoa(BUNindex(b, b->batInserted)));
	BUNins(bn, "batDeleted", local_utoa(BUNindex(b, b->batDeleted)));
	BUNins(bn, "batFirst", local_utoa(BUNindex(b, b->batFirst)));
	BUNins(bn, "top", local_utoa(BUNindex(b, (BUN) ((char *) Bunbase(b) + b->batBuns->free))));
	BUNins(bn, "batStamp", local_itoa(b->batStamp));
	BUNins(bn, "lastUsed", local_itoa(BBP_lastused(b->batCacheid)));
	BUNins(bn, "curStamp", local_itoa(BBPcurstamp()));
	BUNins(bn, "batCopiedtodisk", local_itoa(b->batCopiedtodisk));
	BUNins(bn, "batDirtydesc", b->batDirtydesc ? "dirty" : "clean");

	BUNins(bn, "batDirtybuns", b->batDirtybuns ? "dirty" : "clean");
	infoHeap(bn, b->batBuns, "batBuns.");

	BUNins(bn, "hheapdirty", b->hheapdirty ? "dirty" : "clean");
	infoHeap(bn, b->hheap, "hheap.");

	BUNins(bn, "theapdirty", b->theapdirty ? "dirty" : "clean");
	infoHeap(bn, b->theap, "theap.");

	/* dump index information */
	if (b->hhash) {
		HASHinfo(bn, b->hhash, "hhash->");
	}
	if (b->thash) {
		HASHinfo(bn, b->thash, "thash->");
	}
	return GDK_SUCCEED;
}

#define ROUND_UP(x,y) ((y)*(((x)+(y)-1)/(y)))

int
CMDbatsize(int *tot, BAT *b)
{
	size_t blksize = MT_pagesize();
	size_t size = ROUND_UP(sizeof(BATstore), blksize);

	if (!VIEWparent(b)) {
		size_t cnt = BATcapacity(b);

		size += ROUND_UP(b->batBuns->size, blksize);
		if (b->hheap)
			size += ROUND_UP(b->hheap->size, blksize);
		if (b->theap)
			size += ROUND_UP(b->theap->size, blksize);
		if (b->hhash)
			size += ROUND_UP(sizeof(hash_t) * cnt, blksize);
		if (b->thash)
			size += ROUND_UP(sizeof(hash_t) * cnt, blksize);
	}
	*tot = size;
	return GDK_SUCCEED;
}

int
CMDbatsize_str(int *tot, str batname)
{
	bat bid = BBPindex(batname);
	BAT *b = bid ? (BAT *) BBPgetdesc(bid) : NULL;

	if (b == NULL) {
		GDKerror("CMDbatsize_str: %s no such bat.\n", batname);
		return GDK_FAIL;
	}
	return CMDbatsize(tot, b);
}

@+ Synced BATs
@c
int
CMDsynced(bit *ret, BAT *b1, BAT *b2)
{
	*ret = ALIGNsynced(b1, b2) ? 1 : 0;
	return GDK_SUCCEED;
}

@+ BBP Management, IO
@c
int
CMDroles(BAT **r, BAT *b, str hname, str tname)
{
	BATroles(*r = b, hname, tname);
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

int
CMDcol_name(BAT **r, BAT *b, str tname)
{
	BATcol_name(*r = b, tname);
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

int
CMDrename(bit *retval, BAT *b, str s)
{
	int ret;
	int c;
	char *t = s;

	for ( ; (c = *t) != 0; t++) {
		if (c != '_' && !GDKisalnum(c)) {
			GDKerror("CMDrename: identifier expected: %s\n", s);
			return GDK_FAIL;
		}
	}

 	ret = BATname(b, s);
	*retval = FALSE;
	if (ret == 1) {
		GDKerror("CMDrename: identifier expected: %s\n", s);
		return GDK_FAIL;
	} else if (ret == BBPRENAME_ILLEGAL) {
		GDKerror("CMDrename: illegal temporary name: '%s'\n", s);
		return GDK_FAIL;
	} else if (ret == BBPRENAME_LONG) {
		GDKerror("CMDrename: name too long: '%s'\n", s);
		return GDK_FAIL;
	} else if (ret != BBPRENAME_ALREADY) {
		*retval = TRUE;
	}
	return GDK_SUCCEED;
}

int
CMDname(str *retval, BAT *b)
{
	*retval = GDKstrdup(BBPname(b->batCacheid));
	return GDK_SUCCEED;
}

int
CMDunload(bit *res, str input)
{
	bat bid = ABS(BBPindex(input));

	*res = FALSE;
	if (bid > 0) {
		BAT *b;

		BBPfix(bid);
		b = BBP_cache(bid);
		if (b) {
			if (b->batPersistence == SESSION)
				BATmode(b, TRANSIENT);
			BBPcold(bid);	/* will trigger unload of also persistent bats */
		}
		*res = BBPunfix(bid) == 0;
	}
	return GDK_SUCCEED;
}

int
CMDhot(str input)
{
	BBPhot(BBPindex(input));
	return GDK_SUCCEED;
}

int
CMDcold(str input)
{
	BBPcold(BBPindex(input));
	return GDK_SUCCEED;
}

int
CMDheat(int *res, str input)
{
	int bid = BBPindex(input);

	if (bid) {
		*res = BBP_lastused(bid) & 0x7fffffff;
	}
	return GDK_SUCCEED;
}

int
CMDsave(bit *res, str input)
{
	bat bid = BBPindex(input);
	BAT *b;

	*res = FALSE;
	if (bid) {
		BBPfix(bid);
		b = BBP_cache(bid);
		if (b && BATdirty(b)) {
			if (BBPsave(b) == 0)
				*res = TRUE;
		}
		BBPunfix(bid);
	}
	return GDK_SUCCEED;
}


@= change_heap
{
	if (@2) {
		int mode = (@2)->storage;

		if (mode == STORE_MMAP && (@2)->filename == NULL)
			mode = STORE_MEM;
		if (*@1 == int_nil || *@1 == mode) {
			*@1 = -1;
		}
	}
}
@c
int
CMDmmap(BAT **r, BAT *b, int *bns, int *hhp, int *thp)
{
	@:change_heap(bns,b->batBuns)@
	@:change_heap(hhp,b->hheap)@
	@:change_heap(thp,b->theap)@
	if (BATmmap(*r = b, *bns, *hhp, *thp) == 0) {
		BBPfix(b->batCacheid);
		return GDK_SUCCEED;
	}
	return GDK_FAIL;
}

int
CMDmadvise(BAT **r, BAT *b, int *bns, int *hhp, int *thp)
{
	BBPfix(b->batCacheid);
	return BATmadvise(*r = b, (*bns == int_nil) ? -1 : *bns, (*hhp == int_nil) ? -1 : *hhp, (*thp == int_nil) ? -1 : *thp) ? GDK_FAIL : GDK_SUCCEED;
}

@+ Accelerator Control
@c
int
CMDaccbuild(BAT *b, str acc )
{
	if (strcmp(acc, "hash") == 0 && BAThash(b,0)) {
		return GDK_SUCCEED;
	}
	return GDK_FAIL;
}

@+ Iterators
@= hashiter
	if (b->tvarsized) {
		HASHloop@1(b, b->hhash, idx, v, p)
			if ((i = ITERATE(v, BUNtvar(b,p), h)) < 0)
				return i;
	} else {
		HASHloop@1(b, b->hhash, idx, v, p)
			if ((i = ITERATE(v, BUNtloc(b,p), h)) < 0)
				return i;
	}
	break;
@c
int
CMDhashloop(BAT *b, ptr *handle, ptr v)
{
	Iteration h = *(Iteration *) handle;
	char *p;
	hash_t idx;
	int i;

	if (BATprepareHash(b))
		return GDK_FAIL;

	switch (ATOMstorage(BAThtype(b))) {
	case TYPE_chr:
		@:hashiter(_chr)@
	case TYPE_sht:
		@:hashiter(_sht)@
	case TYPE_int:
	case TYPE_flt:
		@:hashiter(_int)@
	case TYPE_dbl:
	case TYPE_lng:
		@:hashiter(_lng)@
	default:
		if (b->hvarsized) {
			@:hashiter(var)@
		} else {
			@:hashiter(loc)@
		}
	}
	return GDK_SUCCEED;
}

@= batlooparg
	if (@1 > BATcount(b)) {
		GDKerror("CMDbatloop: @1 parameter out of range (%lu %lu).\n", @1, BATcount(b));
		return GDK_FAIL;
	}
	@2 = BUNptr(b, BUNindex(b, BUNfirst(b)) + @1);
@= batloopitr
	while (p <= q) {
		if ((i = ITERATE(BUNh@1(b,p), BUNt@2(b,p), h)) < 0)
			return i;
		p = (BUN) ((char *) p + s);
	}
@c
static int
doCMDbatloop(BAT *b, ptr *handle, size_t low, size_t high)
{
	Iteration h = *(Iteration *) handle;
	BUN p, q;
	int i, s = BUNsize(b);

	if (high < low)
		return GDK_SUCCEED;
	@:batlooparg(low,p)@
	@:batlooparg(high,q)@
	if (b->hvarsized) {
		if (b->tvarsized) {
			@:batloopitr(var,var)@
		} else {
			@:batloopitr(var,loc)@
		}
	} else {
		if (b->tvarsized) {
			@:batloopitr(loc,var)@
		} else {
			@:batloopitr(loc,loc)@
		}
	}
	return GDK_SUCCEED;
}

/* XXX should be size_t *low, size_t *high for 64 bit architecture */
int
CMDbatloop(BAT *b, ptr *handle, int *low, int *high)
{
	return doCMDbatloop(b, handle, (size_t) * low, (size_t) * high);
}

int
CMDbatloop_std(BAT *b, ptr *handle)
{
	size_t n = BATcount(b);

	if (n == 0)
		return GDK_SUCCEED;
	return doCMDbatloop(b, handle, (size_t) 0, n - 1);
}

int
CMDget_seqbase(oid *o, BAT *b)
{
	*o = b->hseqbase;
	return GDK_SUCCEED;
}

int
CMDset_seqbase(BAT **r, BAT *b, oid *o)
{
	BATseqbase(*r = b, *o);
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

@}
@}
