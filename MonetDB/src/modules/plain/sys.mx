@f sys
@t System Information BATs
@a M.L. Kersten
@v 1.0
@* Introduction
This document introduces a series of pseudo bats that provide access
to information stored within the Monet internal data structures.
In all cases, the pseudo BAT operation returns a transient BAT that
should be garbage collected after being used.

The main performance drain would be to use a pseudo BAT directly to
successively access it components. This can be avoided by first assigning
the pseudo BAT to a variable.

@- useful procedures

The commands here return BATs that can be easily reused in scripts. 
For @%interactive use@ there is a collection of 
@[<a href=#mod_2_1_0><bf>predefined procedures</bf></a>@
that you might well find very useful.

@* Module Definition 
@m
.MODULE sys;

@- Performance Stats
@m
.COMMAND view_gdk_cpu() : BAT[str,int] = view_gdk_cpu; 	
	"Global cpu usage info"
.COMMAND view_gdk_memory(): BAT[str,int] = view_gdk_mem; 
	"Global memory usage info"
.COMMAND view_gdk_io(): BAT[str,int] = view_gdk_io; 
	"Global IO activityinfo"
.COMMAND view_gdk_bbp(): BAT[str,int] = view_gdk_bbp; 
	"Global BBP usage info"

.COMMAND mem_printmap() : void = print_mem_map;
        "print a map of all memory that is in use"
.COMMAND mem_cursize() : lng = get_mem_cursize;
 	"the amount of physical swapspace in KB that is currently in use"
.COMMAND mem_maxsize() : lng = get_mem_maxsize;
 	"the maximum usable amount of physical swapspace in KB (target only)"
.COMMAND mem_maxsize(lng) : void = set_mem_maxsize;
 	"set the maximum usable amount of physical swapspace in KB"
.COMMAND vm_cursize() : lng = get_vm_cursize;
 	"the amount of logical VM space in KB that is currently in use"
.COMMAND vm_maxsize() : lng = get_vm_maxsize;
 	"the maximum usable amount of logical VM space in KB (target only)"
.COMMAND vm_maxsize(lng) : void = set_vm_maxsize;
 	"set the maximum usable amount of physical swapspace in KB"
.COMMAND mem_usage(lng minsize) : BAT[str,lng] = get_mem_usage;
	"get a split-up of how much memory blocks are in use."
.COMMAND vm_usage(lng minsize) : BAT[str,lng] = get_vm_usage;
	"get a split-up of how much virtual memory blocks are in use."

@- BAT Buffer Pool
@m
.COMMAND view_bbp_name(): BAT[int,str] = view_bbp_name; 
	"Pseudo bat to map a BAT id into its name"
.COMMAND view_bbp_refcnt(): BAT[int,int] = view_bbp_refcnt; 
	"Pseudo bat to map a BAT id into its reference count"
.COMMAND view_bbp_location(): BAT[int,str] = view_bbp_location; 
	"Pseudo bat to map a BAT id into its disk location"
.COMMAND view_bbp_heat(): BAT[int,int] = view_bbp_heat; 
	"Pseudo bat to map a BAT id into its name"
.COMMAND view_bbp_dirty(): BAT[int,str] = view_bbp_dirty; 
	"Pseudo bat to map a BAT id into its dirty/diffs/clean status"
.COMMAND view_bbp_status(): BAT[int,str] = view_bbp_status; 
	"Pseudo bat to map a BAT id into its disk/load status"
.COMMAND view_bbp_kind(): BAT[int,str] = view_bbp_kind; 
	"Pseudo bat to map a BAT id into its type"

.COMMAND check_bbp_size() : lng = check_bbp_size;
	"Walk the BBP directories, delete leftovers and return total size"

@- GDK status 
@m
.COMMAND view_gdk_env( ): BAT[str,str] = view_gdk_env; 
	"Pseudo bat to map thread to name"
.COMMAND view_gdk_thread( ): BAT[int,str] = view_gdk_thread; 
	"Pseudo bat to map thread to name"

@- Monet Client Data
@m
.COMMAND view_client_name( ): BAT[int,str] = view_client_name; 
	"Pseudo bat to map client identifier to its name"
.COMMAND view_client_login( ): BAT[int,str] = view_client_login; 
	"Pseudo bat to map client identifier to its login time"
.COMMAND view_client_tree( ): BAT[int,str] = view_client_tree; 
	"Pseudo bat to map client identifier to its current active tree"

@- Monet Variables
@m
.BUILTIN view_var_type() : BAT[int,str] = view_var_type; 
	"Pseudo bat to gain access to all visible variables"
.BUILTIN view_var_kind() : BAT[int,str] = view_var_kind; 
	"Pseudo bat to map variable name to frozen/liquid"
.BUILTIN view_var_constant() : BAT[int,str] = view_var_constant; 
	"Pseudo bat to map variable name to constant/changeable"
.BUILTIN view_var_value() : BAT[int,str] = view_var_value; 
	"Pseudo bat to map variable name to its value (as a string)."

@- Monet Modules
@m
.COMMAND view_modules() : BAT[int,str] = view_modules;
	"Pseudo bat with all currently available modules" 
.COMMAND module_name(str) : str = get_mod_name;
	"extract module name from module string" 
.COMMAND module_db(str) : str = get_mod_db;
	"extract database name from module string" 
.COMMAND format_fcn_sig(oid) : str = format_fcn_sig;
	"print a function signature"

@- Printing 
@m
.COMMAND print(ANY value) = CMDprint_val;
"Print a MIL value between square brackets."

.COMMAND print(BAT[ANY::1,ANY], ...BAT[ANY::1,ANY]...) = CMDprint_table;
 "BATs are printed with '#' for legend lines, and the BUNs on seperate
 lines between brackets, containing each to comma separated values
 (head and tail).
 If multiple BATs are passed for printing, print() performs an implicit
 natural join, producing a multiattribute table."

.COMMAND print(INT order, BAT[ANY::1,ANY], ...BAT[ANY::1,ANY]...)
                                                = CMDprint_otable;
 "The same as normal table print, but enforces to use the order of
  BAT number [1..argc] to do the printing."

.COMMAND table(BAT[any::1,any], ...BAT[any::1,any]...) = print_table_default;
	"Print an n-ary table. Like print(n-ary) but does not print oid column"

.COMMAND table(INT order, BAT[any::1,any], ...BAT[any::1,any]...) = print_table;
	"Print an n-ary table. Use the ordering of param [1..argc]"

.COMMAND printf(str format, ...) = print_format;
	"Print a formatted string on the standard client output." 

.COMMAND sprintf(str format, ...) : str = print_str;
	"Print a formatted string on the standard client output." 

@+ MIL Procedure definitions
@m
.LOAD

    PROC help_tpe(int tpe) : str := {
	IF (tpe = TOK_PROC) RETURN "PROC:      ";
	ELSE IF (tpe = TOK_OPERATOR) RETURN "OPERATOR:  ";
	ELSE IF (tpe = TOK_COMMAND) RETURN "COMMAND:   ";
	ELSE IF (tpe = TOK_BUILTIN) RETURN "BUILTIN:   ";
	ELSE IF (tpe = TOK_ITERATOR) RETURN "ITERATOR:  ";
	ELSE IF (tpe = TOK_OBJECT) RETURN "OBJECT:    ";
	RETURN "UNKNOWN:   ";
    }
 
    PROC help_sig(oid fid) : void := {
	printf("%s%s\n",
            help_tpe(monet_fcn_tpe.find(fid)), format_fcn_sig(fid));
	if (monet_fcn_mid.exist(fid)) {
	    printf("MODULE:    %s\n",
                monet_mod_nme.find(monet_fcn_mid.find(fid)));
        }
	if (and(monet_fcn_aut.exist(fid), monet_fcn_dat.exist(fid))) {
	    printf("COMPILED:  by %s on %s\n",
                monet_fcn_aut.find(fid), monet_fcn_dat.find(fid));
        }
	if (monet_fcn_dsc.exist(fid)) {
	    printf("%s\n", monet_fcn_dsc.find(fid));
        } else {
	    printf("no text available\n");
        }
    }
 
    PROC help; # forward decl
    PROC help(str fcn) : void := {
	IF (monet_fcntbl.exist(fcn)) monet_fcntbl@hashloop(fcn) {
	    help_sig($t); printf("\n");
	} ELSE {
	    printf("no help available\n");
	}
    }

    # self help 
    ADDHELP("help", "boncz", "Feb  6 1996",
         "provide help for a MIL construct.", "sys");

    PROC col_name(BAT[any::1,any::2] b, str name) : bat[any::1,any::2] := {
	b.bbpname(name);
	return b;
    }
    PROC rename(BAT[any::1,any::2] b, str name) : bat[any::1,any::2] := {
	if (not(b.bbpname(name))) ERROR("rename(%s,%s): operation failed", str(b), name);
	return b;
    }
    ADDHELP("rename", "boncz", "Feb  6 1996",
         "try to name a BAT and fail if it is not possible.", "sys");

    PROC modules() : void := {
	var b := view_modules.reverse.kunique.reverse;
	table(1,[module_name](b).reverse.sort.reverse.col_name("name"), 
		[module_db](b).col_name("database"));
	
    }
    ADDHELP("modules", "boncz", "Aug 14 1997",
	"list all installed modules, plus owner and db restrictions", "sys"); 
	
    PROC loaded() : void := table(1,monet_mod_nme.reverse.sort.reverse.col_name("module"), 
			     monet_mod_cnt.copy.col_name("usage_count"));
    ADDHELP("loaded", "boncz", "Feb  6 1996", 
	"list all loaded modules, and the number of active users.", "sys"); 

    PROC sigs(str modname) : void := {
	if (monet_mod_nme.reverse.exist(modname)) {
	    var o := monet_mod_nme.reverse.find(modname);
	    var b := [format_fcn_sig](monet_fcn_mid.uselect(o).reverse);
	    table(1,b.reverse.sort.reverse.col_name("signature"));
	} else if ([module_name](view_modules).reverse.exist(modname)) {
  	    ERROR("sigs: must load module first.\n");
	} else {
  	    ERROR("sigs: module does not exist.\n");
	}
    }
    ADDHELP("sigs", "boncz", "Aug  2 1996",  
	"Show all signatures of the functions in a module.", "sys");

    proc dir(bat[int,str] b) {
        var nme := view_bbp_name;
	var atm := adm_atomtbl.copy.access(BAT_WRITE).delete("BAT"); #doubly present
	
	table(1, b.reverse.sort.reverse.col_name("name"),
		[htype](b.join(nme.reverse)).outerjoin(atm.reverse).col_name("htype"),	
		[ttype](b.join(nme.reverse)).outerjoin(atm.reverse).col_name("ttype"),	
		[count](b.mirror).col_name("count"),	
		view_bbp_heat.col_name("heat"),
		view_bbp_dirty.col_name("dirty"),
		view_bbp_status.col_name("status"),
		view_bbp_kind.col_name("kind"), 
		view_bbp_refcnt.col_name("refcnt"));
    }

    PROC dir() : void := {
        var nme := view_bbp_name.copy.access(BAT_WRITE).col_name("name");
	var rev := [*](nme.reverse.select(int(nil),-1),-1).reverse;
	dir(nme.replace(rev));
    }
    PROC dir(str substr) : void := {
        var nme := view_bbp_name.like(substr).access(BAT_WRITE).col_name("name");
        var rev := [*](nme.reverse.select(int(nil),-1),-1).reverse;
        dir(nme.replace(rev));
    }
    ADDHELP("dir", "boncz", "Feb  6 1996", 
	"list all bats, including system bats. Optionally filter on name with a certain substring", "sys"); 

    proc dir_leaks() {
	var b0 := view_bbp_name.access(BAT_WRITE);
	b0.replace([*](b0.reverse.select(int(nil),-1),-1).reverse);
        var b1 := [[startsWith](b0,"tmp_")?b0:].access(BAT_WRITE);
        var b2 := like(view_var_value, "tmp_");
        var b3 := bat(int,str,b1.count);
        b1.delete(int(b0));
        b1@batloop() { 
            var pat := "tmp_" + $h;
            if (like(b2,pat).count = 0) b3.insert($h,$t);
        }
        dir(b3);
    }

    PROC ls() : void := {
	var nme := view_bbp_name;
	var prs := nme.semijoin(view_bbp_kind.select("pers"));
	var rev := [*](nme.reverse.select(int(nil),-1),-1).reverse;
	dir(prs.access(BAT_WRITE).col_name("name").replace(rev));
    }
    PROC ls(str substr) : void := {
        var nme := view_bbp_name.like(substr);
	var prs := nme.semijoin(view_bbp_kind.select("pers"));
	var rev := [*](nme.reverse.select(int(nil),-1),-1).reverse;
	dir(prs.access(BAT_WRITE).col_name("name").replace(rev));
    }
    ADDHELP("ls", "boncz", "Feb  6 1996", 
	"list all data bats. Optionally filter on name with a certain substring", "sys"); 

    PROC exit() : void := {
	quit;
    }
    ADDHELP("exit", "boncz", "Jan 9 1998", "quit for consultants", "sys"); 

    PROC procs() : void := {
	   var a := [format_fcn_sig](monet_fcntbl.reverse.
			semijoin(monet_fcn_tpe.select(TOK_PROC)).reverse);
	   table(1,a.reverse.sort.reverse.col_name("MIL Procedure"));
    }
    ADDHELP("procs", "boncz", "Feb  6 1996", "list all defined procs.", "sys"); 

    PROC clients() : void :=  { 
	var tree := view_client_tree.access(BAT_WRITE);
	tree.replace(clientid, "clients()");
	table(view_client_name,view_client_login,tree.col_name("mil"));
    } 
    ADDHELP("clients", "boncz", "Feb  6 1996", 
	"list all active clients by their number.", "sys"); 

    PROC vars() : void := 
	print(view_var_type, view_var_kind, view_var_constant, view_var_value);
    ADDHELP("vars", "boncz", "Feb  6 1996", 
        	"list all Monet variables and their values.", "sys"); 

    PROC threads() : void := print(view_gdk_thread); 
    ADDHELP("threads", "boncz", "Feb  6 1996", 
		"list all system threads and their function.", "sys"); 

    PROC env() : void := print(view_gdk_env);
    ADDHELP("env", "boncz", "Feb  6 1996", 
		"list the values of all environment variables", "sys"); 

    PROC environment() : bat[str,str] := return view_gdk_env;
    ADDHELP("environment", "boncz", "Mar 22 1998", "deprecated", "sys");

    PROC cpu() : bat[str,int] := RETURN view_gdk_cpu;
    ADDHELP("cpu", "boncz", "Mar 22 1998", "Global cpu usage info", "sys");

    PROC memory() : bat[str,int] := RETURN view_gdk_memory;
    ADDHELP("memory", "boncz", "Mar 22 1998", "Global memory usage info","sys");

    PROC io() : bat[str,int] := RETURN view_gdk_io;
    ADDHELP("io", "boncz", "Mar 22 1998", "Global IO activity info", "sys");

    PROC bbp() : bat[str,int] := RETURN view_gdk_bbp;
    ADDHELP("bbp", "boncz", "Mar 22 1998", "Global BBP usage info", "sys");

    PROC tail(bat[any,any] b) : int := 
         return adm_atomtbl.reverse.find(b.ttype);
    ADDHELP("tail","boncz","Mar 22 1998","Get tail-type as an int","sys");

    PROC head(bat[any,any] b) : int:= 
         return adm_atomtbl.reverse.find(b.htype);
    ADDHELP("head","boncz","Mar 22 1998","Get head-type as an int","sys");

    PROC readonly( BAT[any::1,any::2] b, int mode) : BAT[any::1,any::2]
        := return access(b,mode);
    ADDHELP("readonly", "boncz", "Aug  6 1998",
        "deprecated. Use 'b.access' instead.", "sys");
 
    PROC readonly( BAT[any::1,any::2] b) : int := {
        var s := b.info.find("batRestricted");
        if (s = "updatable") {
                return BAT_WRITE;
        } else if (s = "read-only") {
                return BAT_READ;
        } else if (s = "append-only") {
                return BAT_APPEND;
        } 
        ERROR("readonly: unknown mode.");
    }
    ADDHELP("readonly", "boncz", "Aug  6 1998",
        "deprecated. Use 'info.find(batRestricted)' instead.", "sys");

    PROC mem_usage() : BAT[str,lng] return mem_usage(lng(100000));
    PROC vm_usage() : BAT[str,lng] return vm_usage(lng(100000));
    PROC mem_usage(int minsize) : BAT[str,lng] return mem_usage(lng(minsize));
    PROC vm_usage(int minsize) : BAT[str,lng] return vm_usage(lng(minsize));

.END;
.END sys;

@{
@* Implementation Code
@h
#ifndef _SYS_H_
#define _SYS_H_

#include "sys.proto.h"

#endif
@c
#include <stdarg.h>
#include <time.h>
#include "gdk.h"
#include "gdk_bbp.h"
#include "monet.h"
#include "monet_context.h"
#include "monet_client.h"
#include "monet_parse.h"
#include "monet_deparse.h"
#include "monet_queue.h"

#ifdef HAVE_SYS_TIMES_H
# include <sys/times.h>
#endif
 
#define PARAM(x)        (argv+x)
#define RETVAL          (argv)

static char* local_itoa(int i){
        static char buf[32];
        sprintf(buf,"%d",i);
        return buf;
}

@+ BBP status
The BAT buffer pool datastructures describe the memory resident information
on the whereabouts of the BATs. The three predominant tables are made accessible
for inspection. 

The most interesting sysbat for end-users is the BID-> NAME mapping,
because it provides access to the system guaranteed persistent BAT identifier.
@= Pseudo
	if (BBPindex("view_@1_@2") <= 0)
        	BATname(b, "@2");
        BATroles(b,"@1","@2");
	BATmode(b,TRANSIENT);
	BATfakeCommit(b);
	*retval= b;
	
@c
int
view_bbp_name(
   BAT**        retval  /* put pointer to BAT[int,str] record here. */
){       
	BAT*    b;
        int     i;

        b= BATnew(TYPE_int,TYPE_str,BBPsize);
        if (b == 0) return GDK_FAIL;

	BBPlock("view_bbp_name");
        for(i=1; i < BBPsize; i++) if (i != b->batCacheid) {
        	if (BBP_logical(i)) { 
			BUNins(b, &i, BBP_logical(i));
        		if (BBP_logical(-i)) {
				int j = -i;
				BUNins(b, &j, BBP_logical(j));
			}
		}
	}
	BBPunlock("view_bbp_name");
	@:Pseudo(bbp,name)@
        return GDK_SUCCEED;
}

@-
The BAT status is redundantly stored in view_bat_info.
@c
int
view_bbp_location(
   BAT**        retval  /* put pointer to BAT[int,str] record here. */
){       
	BAT*    b;
        int     i;

        b= BATnew(TYPE_int,TYPE_str,BBPsize);
        if (b == 0) return GDK_FAIL;

	BBPlock("view_bbp_location");
        for(i=1; i < BBPsize; i++) if (i != b->batCacheid) {
        	if (BBP_logical(i))
                BUNins(b, &i, BBP_physical(i));
	}
	BBPunlock("view_bbp_location");
	@:Pseudo(bbp,location)@
        return GDK_SUCCEED;
}


#define monet_modulesilent (!(GDKdebug&16384))

int
view_bbp_heat(
   BAT**        retval  /* put pointer to BAT[int,int] record here. */
){       
	BAT*    b;
        int     i;

        b= BATnew(TYPE_int,TYPE_int,BBPsize);
        if (b == 0) return GDK_FAIL;

	BBPlock("view_bbp_heat");
        for(i=1; i < BBPsize; i++) if (i != b->batCacheid) {
            if (BBP_cache(i) && !monet_modulesilent) {
		int heat = BBPheat(i);
                BUNins(b, &i, &heat);
	    } else if (BBP_logical(i)) { 
		int zero = 0;
                BUNins(b, &i, &zero);
	    }
	}
	BBPunlock("view_bbp_heat");
	@:Pseudo(bbp,heat)@
        return GDK_SUCCEED;
}

@-
The BAT dirty status: dirty => (mem != disk); diffs = not-committed
@c
int
view_bbp_dirty(
   BAT**        retval  /* put pointer to BAT[int,str] record here. */
){       
	BAT*    b;
        int     i;

        b= BATnew(TYPE_int,TYPE_str,BBPsize);
        if (b == 0) return GDK_FAIL;

	BBPlock("view_bbp_dirty");
        for(i=1; i < BBPsize; i++) if (i != b->batCacheid) {
        if (BBP_logical(i)){
		BAT *bn = BBP_cache(i);
                BUNins(b, &i, bn?
				BATdirty(bn)?
					"dirty":
					DELTAdirty(bn)?
						"diffs":
						"clean":
				(BBP_status(i)&BBPSWAPPED)?
					"diffs": 
					"clean");
	}}
	BBPunlock("view_bbp_dirty");
	@:Pseudo(bbp,status)@
        return GDK_SUCCEED;
}

@-
The BAT status is redundantly stored in view_bat_info.
@c
int
view_bbp_status(
   BAT**        retval  /* put pointer to BAT[int,str] record here. */
){       
	BAT*    b;
        int     i;

        b= BATnew(TYPE_int,TYPE_str,BBPsize);
        if (b == 0) return GDK_FAIL;

	BBPlock("view_bbp_status");
        for(i=1; i < BBPsize; i++) if (i != b->batCacheid) {
        if (BBP_logical(i)){
		char *loc = BBP_cache(i)?"load":"disk";
                BUNins(b, &i,loc );
	}}
	BBPunlock("view_bbp_status");
	@:Pseudo(bbp,status)@
        return GDK_SUCCEED;
}

int
view_bbp_kind(
   BAT**        retval  /* put pointer to BAT[int,str] record here. */
){       
	BAT*    b;
        int     i;

        b= BATnew(TYPE_int,TYPE_str,BBPsize);
        if (b == 0) return GDK_FAIL;

	BBPlock("view_bbp_kind");
        for(i=1; i < BBPsize; i++) if (i != b->batCacheid) {
	if (BBP_logical(i)) {
	    char *mode = NULL;
	    if ((BBP_status(i)&BBPDELETED) || !(BBP_status(i)&BBPPERSISTENT)) {
		mode = "tran";
	    } else {
		mode = "pers";
	    }
	    if (mode) BUNins(b, &i, mode);
	}}
	BBPunlock("view_bbp_kind");
	@:Pseudo(bbp,kind)@
        return GDK_SUCCEED;
}

int
view_bbp_refcnt(
   BAT**        retval  /* put pointer to BAT[int,str] record here. */
){       
	BAT	 *b;
        int     i;

        b= BATnew(TYPE_int,TYPE_int,BBPsize);
        if (b == 0) return GDK_FAIL;

	BBPlock("view_bbp_refcnt");
        for(i=1; i < BBPsize; i++) if (i != b->batCacheid) {
	if (BBP_logical(i)) {
		int refs = BBP_refs(i);
		BUNins(b, &i, &refs);
	}}
	BBPunlock("view_bbp_refcnt");
	@:Pseudo(bbp,group)@
        return GDK_SUCCEED;
}

@+ GDK
The old-fashioned BATdump command is replaced by the sys.
@c
int
view_gdk_thread(
   BAT**        retval  /* put pointer to BAT[int,str] record here. */
){       
	BAT*    b;
        int     i;

        b= BATnew(TYPE_int,TYPE_str,THREADS);
        if (b == 0) return GDK_FAIL;

        for(i=0; i < THREADS; i++)
	if( GDKthreads[i].pid) {
                BUNins(b, &GDKthreads[i].tid, GDKthreads[i].name);
	}
	@:Pseudo(gdk,thread)@
        return GDK_SUCCEED;
}

int view_gdk_env(	
	BAT **retval
){
	BAT *b = *retval = BATnew(TYPE_str, TYPE_str, 12);
	char prefix[128];
	if (b == 0) return GDK_FAIL;
	if( GDKdbfarmStr[0])
		BUNins(b, "gdk_dbfarm", GDKdbfarmStr);
	if( GDKdbnameStr[0])
		BUNins(b, "gdk_dbname", GDKdbnameStr);
	if( GDKdistrStr[0])
		BUNins(b, "gdk_distr", GDKdistrStr);
	if( GDKmonetrcStr[0])
		BUNins(b, "gdk_monetrc", GDKmonetrcStr);
	BUNins(b, "gdk_dir", GDKdirStr);
        sprintf(prefix, "%dbit%s", sizeof(ptr)*8, monet_arch);
	BUNins(b, "gdk_arch", prefix); 
	BUNins(b, "gdk_version", monet_version);
	BUNins(b, "monet_cwd", monet_cwd);
	/* BUNins(b, "monet_general", monet_general);*/
	BUNins(b, "monet_pid", local_itoa(getpid()));
	BUNins(b, "monet_welcome", (monet_welcome?"yes":"no"));
	BUNins(b, "monet_deamon", (monet_deamon?"yes":"no"));
	BUNins(b, "monet_prompt", monet_prompt);
	@:Pseudo(gdk,env)@
	return GDK_SUCCEED;
}

int check_bbp_size(lng *ret) {
	*ret = BBPdiskscan(NULL);
	return GDK_SUCCEED;
}

@+ Monet sys variables
@c
int
view_client_name(
   BAT**        retval  /* put pointer to BAT[int,str] record here. */
){       
	BAT*    b;
        int     i;

        b= BATnew(TYPE_int,TYPE_str,MAXCLIENTS);
        if (b == 0) return GDK_FAIL;

        for(i=0; i < MAXCLIENTS; i++)
	if( monet_clients[i].user) {
                BUNins(b, &i, monet_clients[i].user);
	}

	@:Pseudo(client,name)@
        return GDK_SUCCEED;
}
int
view_client_login(
   BAT**        retval  /* put pointer to BAT[int,str] record here. */
){       
	BAT*    b;
        int     i;
	char 	s[26];

        b= BATnew(TYPE_int,TYPE_str,MAXCLIENTS);
        if (b == 0) return GDK_FAIL;

        for(i=0; i < MAXCLIENTS; i++)
	if( monet_clients[i].user) {
		time_t logintime=(time_t)monet_clients[i].login;

#ifdef CYGWIN32
		localtime(&logintime);
#else
		struct tm localt;
		localtime_r(&logintime,&localt);
#endif

#ifdef HAVE_CTIME_R3
		asctime_r(&localt,s,26);
#else
#ifdef HAVE_CTIME_R
		asctime_r(&localt,s);
#else
		strcpy(s, "no asctime in WIN32");
#endif
#endif
		s[24]=0;
                BUNins(b, &i, s);
	}

	@:Pseudo(client,login)@
        return GDK_SUCCEED;
}

int view_client_tree(BAT **retval){
	BAT *b = *retval = BATnew(TYPE_int, TYPE_str, 50); 
	char buf[4096]; 
	int i; 

        for (i = 0; i < MAXCLIENTS; i++) 
            if (monet_clients[i].mode != FINISHED) {
		Client c = monet_clients + i;
		buf[0] = 0; 
		lockparser(c);
		yydeparse(c, c->tree, buf, buf+80);
		unlockparser(c);
		BUNins(b, &i,buf);
	    }
	@:Pseudo(client,tree)@
	return GDK_SUCCEED;
}

@+ Variables
The variable information can be turned into a BAT for inspection as well.
@c
int
view_var_type(
   int          stk,    /* variable context number ("stack"). */
   YYSTREE      lt,     /* syntax tree of parsed MIL. */
   ValPtr        res     /* value record for result. */
){
        Client  c;
        Variable v;
	BAT *b, **retval=&b;

        CNTXTclient(stk, &c);

	b = BATnew(TYPE_str,TYPE_str,100);
	if( b== 0) return -1;

        while(TRUE) {
		for(v = monet_cntxt[stk].var; v != NULL; v= v->next) {
			BUNins(b, v->name, 
			BATatoms[v->binding.vtype].name );
                }
		if (stk < 0) break;
                stk = monet_cntxt[stk].outer;
        } 
	@:Pseudo(var,type)@
        res->vtype = TYPE_bat;
        res->val.bval = BBPcacheid(b);
	return 0;
}

int
view_var_kind(
   int          stk,    /* variable context number ("stack"). */
   YYSTREE      lt,     /* syntax tree of parsed MIL. */
   ValPtr        res     /* value record for result. */
){
        Client  c;
        Variable v;
	BAT *b, **retval=&b;

        CNTXTclient(stk, &c);

	b = BATnew(TYPE_str,TYPE_str,100);
	if( b== 0) return -1;

        while(TRUE) {
		for(v = monet_cntxt[stk].var; v != NULL; v= v->next) {
			BUNins(b, v->name,
			(v->frozen?"frozen":"liquid"));
                }
		if (stk < 0) break;
                stk = monet_cntxt[stk].outer;
        } 
	@:Pseudo(var,type_status)@
        res->vtype = TYPE_bat;
        res->val.bval = BBPcacheid(b);
	return 0;
}
int
view_var_constant(
   int          stk,    /* variable context number ("stack"). */
   YYSTREE      lt,     /* syntax tree of parsed MIL. */
   ValPtr        res     /* value record for result. */
){
        Client  c;
        Variable v;
	BAT *b, **retval=&b;

        CNTXTclient(stk, &c);

	b = BATnew(TYPE_str,TYPE_str,100);
	if( b== 0) return -1;

        while(TRUE) {
		for(v = monet_cntxt[stk].var; v != NULL; v= v->next) {
			BUNins(b, v->name,
			(v->constant?"constant":"changeable"));
                }
		if (stk < 0) break;
                stk = monet_cntxt[stk].outer;
        } 
	@:Pseudo(var,value_status)@
        res->vtype = TYPE_bat;
        res->val.bval = BBPcacheid(b);
	return 0;
}

int
view_var_value(
   int          stk,    /* variable context number ("stack"). */
   YYSTREE      lt,     /* syntax tree of parsed MIL. */
   ValPtr        res     /* value record for result. */
){
        Client  c;
        Variable v;
	BAT *b, **retval=&b;
	char *buf = NULL;
	int l = 0;

        CNTXTclient(stk, &c);

	b = BATnew(TYPE_str,TYPE_str,100);
	if( b== 0) return -1;

        while(TRUE) {
		for(v = monet_cntxt[stk].var; v != NULL; v= v->next) {
			int t = ATOMstorage(v->binding.vtype);
			ptr p = ATOMextern(t)?v->binding.val.pval:(ptr)&v->binding.val.ival;
                	if ((*BATatoms[v->binding.vtype].atomToStr)(&buf, &l, p)) {
				BUNins(b, v->name, buf);
			} else {
				BUNins(b, v->name, str_nil);
			}
		}
		if (stk < 0) break;
                stk = monet_cntxt[stk].outer;
        } 
	@:Pseudo(var,value_value)@
        res->vtype = TYPE_bat;
        res->val.bval = BBPcacheid(b);
	return 0;
}

@+ Modules
@c
static char any_str[] = "any";

int view_modules(BAT** res){
	*res = (BAT*) TBL_getdir();
	return GDK_SUCCEED;
}

int get_mod_name(str* res, str src){
	str entry = GDKstrdup(src);
	str s = strchr(entry, '-');
	if (s) *s = 0;	
	*res = entry;
	return GDK_SUCCEED;	
}

int get_mod_db(str *res, str src){
	str entry = GDKstrdup(src);
	str s = strchr(entry, '-');
	if (s == NULL) {
		s = any_str;
	}
	*res = GDKstrdup(s);
	GDKfree(entry);
	return GDK_SUCCEED;	
}


@- Performance
To obtain a good impression of the Monet performance we need timing information.
The most detailed information is best obtained with the system profiler.
 
However, the direct approach is to enable the user to read the timers maintained
internally. This is done with the CPU, IO, MEMORY, and BBP command which 
displays the elapsed time in seconds, user- and system-cpu time in milliseconds
since its last invocation and the amount of space in use.  The process 
identifier is used to differentiate among the possible processes.
 
Note that in multi threaded mode the routine prints the elapsed
time since the beginning of each process.
@{
@c
static int clk = 0;
static struct tms state;

int view_gdk_cpu(BAT **retval) {
	int     i;
	struct tms newst;
	BAT *b;
 
 
	*retval = b = BATnew(TYPE_str, TYPE_int, 32);
	if ( b == 0) return GDK_FAIL;
	if( clk == 0) {
		clk= time(0);
		times(&state);
	}
	times(&newst);
	/* store counters, ignore errors */
	i = time(0) - clk;
	b = BUNins(b, "elapsed", &i);
	i= newst.tms_utime *1000/HZ ;
	b = BUNins(b, "user", &i);
	i= (newst.tms_utime - state.tms_utime)*1000/HZ;
	b = BUNins(b, "elapuser", &i);
	i = newst.tms_stime *1000/HZ;
	b = BUNins(b, "system", &i);
	i = (newst.tms_stime - state.tms_stime)*1000/HZ;
	b = BUNins(b, "elapsystem", &i);

	state = newst; 
	@:Pseudo(gdk,cpu)@
	return GDK_SUCCEED;
}
@-
Same observations as to view_gdk_cpu()
@c
static void *memincr=NULL;
int view_gdk_mem(BAT **retval) {
	struct mallinfo m;
	BAT *b;
	int i;
	m = MT_mallinfo();
 
	*retval = b = BATnew(TYPE_str, TYPE_int, 32);
	if ( b == 0) return GDK_FAIL;

	/* store counters, ignore errors */
	if (memincr == NULL) {
		memincr = GDK_mem_start;
	}
	i= ((char*) sbrk(0) -  (char*) memincr);
 
	memincr = (char*) sbrk(0);
	b = BUNins(b, "memincr", &i);
	b = BUNins(b, "arena", &m.arena);
	b = BUNins(b, "ordblks", &m.ordblks);
	b = BUNins(b, "smblks", &m.smblks);
	b = BUNins(b, "hblkhd", &m.hblkhd);
	b = BUNins(b, "hblks", &m.hblks);
	b = BUNins(b, "usmblks", &m.usmblks);
	b = BUNins(b, "fsmblks", &m.fsmblks);
	b = BUNins(b, "uordblks", &m.uordblks);
	b = BUNins(b, "fordblks", &m.fordblks);
	@:Pseudo(gdk,mem)@
	return GDK_SUCCEED;
}

int get_mem_cursize(lng *num) {
	*num = GDKmem_cursize();
	return GDK_SUCCEED;
}
int get_mem_maxsize(lng *num) {
	*num = GDKmem_maxsize();
	return GDK_SUCCEED;
}
int set_mem_maxsize(lng *num) {
	GDK_mem_maxsize = *num;
	return GDK_SUCCEED;
}
int get_vm_cursize(lng *num) {
	*num = GDKvm_cursize();
	return GDK_SUCCEED;
}
int get_vm_maxsize(lng *num) {
	*num = GDKvm_maxsize();
	return GDK_SUCCEED;
}
int set_vm_maxsize(lng *num) {
	GDK_vm_maxsize = *num;
	return GDK_SUCCEED;
}

@= heap
sz = HEAP@1size(@2);
if (sz > *minsize) {
	sprintf(buf, "@3/%s", s); 
	BUNins(bn, buf, &sz);
} @3 += sz; tot += sz;
@c

int get_mem_usage(BAT **ret, lng *minsize) {
	lng buns=0, hhsh=0, thsh=0, hind=0, tind=0, head=0, tail=0, hacc=0, tacc=0, tot=0, n=0, sz;
	BAT *bn = BATnew(TYPE_str, TYPE_lng, 2*BBPsize);
	char buf[1024];
	int i;

	BBPlock("get_mem_usage");
	for(i=1; i <BBPsize; i++) { 
		BAT *b = BBP_cache(i);
		str s = BBP_logical(i);
		if (s == NULL) {
			continue;
		}
		sz = 0;
		if (BBP[i].cache)  sz += sizeof(BATstore);
		if (BBP[i].nme[0]) n += strLen(BBP[i].nme[0]);
		if (BBP[i].nme[1]) n += strLen(BBP[i].nme[1]);
		if (BBP[i].path) n += strLen(BBP[i].path);
		if (b) sz += sizeof(BAT); /* mirror */
			
		if (sz > *minsize) {
			sprintf(buf, "desc/%s", s); 
			BUNins(bn, buf, &sz);
		} tot += (lng) sz;

		if (b == NULL || VIEWparent(b)) {
			continue;
		}
		@:heap(mem,b->batBuns,buns)@
		@:heap(mem,b->hhash_heap,hhsh)@
		@:heap(mem,b->thash_heap,thsh)@
		@:heap(mem,b->hidx_heap,hind)@
		@:heap(mem,b->tidx_heap,tind)@
		@:heap(mem,&b->hheap,head)@
		@:heap(mem,&b->theap,tail)@
		@:heap(mem,&b->haccelerator,hacc)@
		@:heap(mem,&b->taccelerator,tacc)@
	} 
	/* totals per category */
	if (buns) BUNins(bn, "_tot/buns", &buns);
	if (head) BUNins(bn, "_tot/head", &head);
	if (tail) BUNins(bn, "_tot/tail", &tail);
	if (hhsh) BUNins(bn, "_tot/hhsh", &hhsh);
	if (thsh) BUNins(bn, "_tot/thsh", &thsh);
	if (hind) BUNins(bn, "_tot/hind", &hind);
	if (tind) BUNins(bn, "_tot/tind", &tind);
	if (hacc) BUNins(bn, "_tot/hacc", &hacc);
	if (tacc) BUNins(bn, "_tot/tacc", &tacc);

	/* special area 1: BBP rec */
	sz = BBPlimit*sizeof(BBPrec) + n;
	if (sz) BUNins(bn, "_tot/bbp", &sz);
	tot += sz;

	/* special area 2: monet context records */
	sz = monet_cntxtmax*sizeof(CntxtRec);
	if (sz) BUNins(bn, "_tot/mil", &sz);
	tot += sz;
	if (tot) BUNins(bn, "_tot/found", &tot);
	sz = GDKmem_heapsize();
	if (sz) BUNins(bn, "_tot/sbrk", &sz);
/*	compilation errors !
	if (GDK_mem_cursize) BUNins(bn, "_tot/valloc", &GDK_mem_cursize);

*/
	sz = GDKmem_heapinuse();
	if (sz) BUNins(bn, "_tot/malloc", &sz);
	sz = sz + GDK_mem_cursize - tot;
	if (sz) BUNins(bn, "_tot/malloc_unknown", &sz);
	sz = GDKmem_cursize();
	if (sz) BUNins(bn, "_tot/all", &sz);
	BBPunlock("get_mem_usage");

	*ret = bn;
	return GDK_SUCCEED;
}

int get_vm_usage(BAT **ret, lng *minsize) {
	lng buns=0, hhsh=0, thsh=0, hind=0, tind=0, head=0, tail=0, hacc=0, tacc=0, tot=0, sz;
	BAT *bn = BATnew(TYPE_str, TYPE_lng, 2*BBPsize);
	char buf[1024];
	int i;

	BBPlock("get_vm_usage");
	for(i=1; i <BBPsize; i++) {
		BAT *b = BBP_cache(i);
		str s = BBP_logical(i);
		if (s == NULL || b == NULL || VIEWparent(b)) {
			continue;
		}
		@:heap(vm,b->batBuns,buns)@
		@:heap(vm,b->hhash_heap,hhsh)@
		@:heap(vm,b->thash_heap,thsh)@
		@:heap(vm,b->hidx_heap,hind)@
		@:heap(vm,b->tidx_heap,tind)@
		@:heap(vm,&b->hheap,head)@
		@:heap(vm,&b->theap,tail)@
		@:heap(vm,&b->haccelerator,hacc)@
		@:heap(vm,&b->taccelerator,tacc)@
	} 
	/* totals per category */
	if (buns) BUNins(bn, "_tot/buns", &buns);
	if (head) BUNins(bn, "_tot/head", &head);
	if (tail) BUNins(bn, "_tot/tail", &tail);
	if (hhsh) BUNins(bn, "_tot/hhsh", &hhsh);
	if (thsh) BUNins(bn, "_tot/thsh", &thsh);
	if (hind) BUNins(bn, "_tot/hind", &hind);
	if (tind) BUNins(bn, "_tot/tind", &tind);
	if (hacc) BUNins(bn, "_tot/hacc", &hacc);
	if (tacc) BUNins(bn, "_tot/tacc", &tacc);

	/* special area 1: BBP rec */
	sz = BBPmaxsize*sizeof(BBPrec);
	if (sz) BUNins(bn, "_tot/bbp", &sz);
	tot += sz;

	/* special area 2: monet context records */
	sz = monet_cntxtlim*sizeof(CntxtRec);
	if (sz) BUNins(bn, "_tot/mil", &sz);
	tot += sz;
	if (tot) BUNins(bn, "_tot/found", &tot);

	/* look at sbkr() to determine how much we missed */
	sz = GDKvm_cursize();
	if (sz) BUNins(bn, "_tot/all", &sz);
	sz -= tot;
	tot = GDKvm_heapsize();
	if (sz) BUNins(bn, "_tot/sbrk", &tot);
	BBPunlock("get_vm_usage");

	*ret = bn;
	return GDK_SUCCEED;
}

@-
Additional information on the process utilization is given by
the io command. The following information is obtained.
 
@T
\begin{tabular}{| l| l|}\hline
maxrss     &the maximum resident set size utilized (in kilobytes).\\
minflt     &the number of page faults serviced without any I/O\\
	 &activity; here I/O activity is avoided by "reclaiming" a\\
 
	 &activity; here I/O activity is avoided by "reclaiming" a\\
	 &page frame from the list of pages awaiting reallocation.\\
majflt     &the number of page faults serviced that required I/O\\
	 &activity.\\
nswap      &the number of times a process was "swapped" out of main\\
	 &memory\\
inblock    &the number of times the file system had to perform input.\\
oublock    &the number of times the file system had to perform output.\\
nvcsw      &the number of times a context switch resulted due to a\\
	 &process voluntarily giving up the processor before its\\
	 &time slice was completed (usually to await availability of\\
	 &a resource).\\
nivcsw     &the number of times a context switch resulted due to a\\
	 &higher priority process becoming runnable or because the\\
	 &current process exceeded its time slice.\\
\end{tabular}
@
The resource statistics are collected in a BAT. It can then
be queried. A default listing is produced by the command @%usagecmd@.
(which should be moved to Monet)
 
The BAT grows. It should be compacted.
@c
#ifdef HAVE_SYS_RESOURCE_H
# include <sys/resource.h>
#endif
 
int view_gdk_io(BAT **retval) {
	struct rusage ru;
	int i;
	BAT *b;
 
	getrusage(RUSAGE_SELF, &ru);
	*retval = b = BATnew(TYPE_str, TYPE_int, 32);
	if (b == 0) return GDK_FAIL;
 
	/* store counters, ignore errors */
	i = ru.ru_maxrss; BUNins(b, "maxrss", &i); 
	i = ru.ru_minflt; BUNins(b, "minflt", &i);
	i = ru.ru_majflt; BUNins(b, "majflt", &i);
	i = ru.ru_nswap; BUNins(b, "nswap", &i);
	i = ru.ru_inblock; BUNins(b, "inblock", &i);
	i = ru.ru_oublock; BUNins(b, "oublock", &i);
	i = ru.ru_nvcsw; BUNins(b, "nvcsw", &i);
	i = ru.ru_nivcsw; BUNins(b, "ninvcsw", &i);

	@:Pseudo(gdk,io)@
	return GDK_SUCCEED;
}

int view_gdk_bbp(BAT **retval) {
	int 	pbat = 0;
	int	pdisk = 0;
	int	pheat = 0; 
	int	i,tmp=0,per=0; 
	BAT	*b;

	*retval = b = BATnew(TYPE_str, TYPE_int, 32);
	if (b == 0) return GDK_FAIL;

	for (i = 1; i < BBPsize; i++) {
		if (BBP_logical(i)) {
			pbat++; 
			if (BBP_cache(i)) {
				pheat += BBPheat(i); 
				if (BBP_cache(i)->batPersistence == PERSISTENT)
					per++;
				else tmp++;
			} else {
				pdisk++; 
			}
		}
	}
	b = BUNins(b, "bats", &pbat);
	b = BUNins(b, "tmpbats", &tmp);
	b = BUNins(b, "perbats", &per);
	b = BUNins(b, "ondisk", &pdisk);
	b = BUNins(b, "todisk", &BBPout);
	b = BUNins(b, "fromdisk", &BBPin);

	@:Pseudo(gdk,bbp)@
	return GDK_SUCCEED;
}

@+ Printing
@c
int CMDprint_val(ptr val, int tpe) {
        FILE *fp = GDKout;
        fputs("[ ", fp);
        ATOMprint(tpe, val, fp);
        fputs(" ]\n", fp);
        return GDK_SUCCEED;
}

int CMDprint_bats(int argc, BAT *argv[], int order) {
        FILE *fp = GDKout;
        BATmultiprintf(fp, argc+1, argv, TRUE, order);
        return GDK_SUCCEED;
}

int CMDprint_otable(int *order, ...) {
        BAT *b, *piv[MAXPARAMS];
        int nbats = 0;
        va_list ap;

        va_start(ap,order);
        while((b = va_arg(ap, BAT*)) != NULL) {
                piv[nbats++] = b;
        }
        return CMDprint_bats(nbats, piv, *order);
}

int CMDprint_table(BAT* b, ...) {
        BAT *piv[MAXPARAMS];
        int nbats = 0;
        va_list ap;

        va_start(ap,b);
        do {
                piv[nbats++] = b;
        } while((b = va_arg(ap, BAT*)) != NULL);
        return CMDprint_bats(nbats, piv, 0);
}

int print_format(str format, ...) {
	va_list ap;
	int ret; 
	str s; 

	va_start(ap,format);
	ret = monet_sprintf(&s, format, ap);
	va_end(ap);
	if (ret == GDK_FAIL) {
		return GDK_FAIL;
	}
	ret = fputs(s, GDKout);
	GDKfree(s);
 	if (ret < 0) {
		GDKsyserror("printf():");
		return GDK_FAIL;
	}
	return GDK_SUCCEED;
}

int print_str(str *s, str format, ...) {
	va_list ap;
	int ret; 

	va_start(ap,format);
	ret = monet_sprintf(s, format, ap);
	va_end(ap);
	return ret;
}


int print_table(int *order, ...) {
	BAT *piv[MAXPARAMS];
	int argc = 0;
	va_list ap;

        va_start (ap, order);
        do {
		piv[argc] = va_arg (ap,BAT*) ;
	} while(piv[argc++]);
        va_end (ap);
	BATmultiprintf(GDKout, argc, piv, FALSE, *order);
	return GDK_SUCCEED;
}

int print_table_default(BAT *b, ...) {
	BAT *piv[MAXPARAMS];
	int argc = 1;
	va_list ap;

	piv[0] = b;
        va_start (ap, b);
        do {
		piv[argc] = va_arg (ap,BAT*) ;
	} while(piv[argc++]);
        va_end (ap);
	BATmultiprintf(GDKout, argc, piv, FALSE, 0);
	return GDK_SUCCEED;
}

int format_fcn_sig(str *sig, oid *fid){
	if (TBL_formatsig(*sig = (str) GDKmalloc(256), *fid)) {
		return GDK_SUCCEED;
	}
	GDKfree(*sig);
	return GDK_FAIL;
}

int print_mem_map() {
        MT_alloc_print();
        return GDK_SUCCEED;
}
@
@}
