@f io
@t The io Module
@a N.J. Nes
@d 01/07/1996

@+ Introduction
@T
This module contains all the file access commands. The implementation
is very simple. All function call the stdio library function.

This module is seperated from the database kernel since some 
servers are not allowed to do file accesses.

{\tt fopen()} opens the file named by filename  and  associates  a
stream  with  it. {\tt fopen()}  returns  a  pointer to the FILE
structure associated with the stream. The resulting pointer is needed
by all other io function. So fopen should be called before any other 
function. 

The {\tt fclose()} command closes the associated stream. The FILE pointer 
given can not be used after calling this function. 

Pipes can be created with {\tt popen()}. This function returns the
identifier to a bidirectional pipe. You can then for instance {\tt fork()}
a new Monet session, passing this identifier.

Both sessions can then use the pipe to open a stream with {\tt fdpipe()}.
The one end should pass {\tt true} as the {\tt up} parameter, the other
{\tt down}. This function returns a stream, and can be used in combination
with any of the functions of this module.

The {\tt fflush()} command flushes the buffer of the associated stream.

{\tt feof()} returns non-zero when EOF has previously been
detected reading the named input stream, otherwise zero.

{\tt freopen()} substitutes the named file in place  of  the  open
stream. A flush is first attempted, and then the original
stream is closed, regardless of whether the open ultimately
succeeds. Failure to flush or close stream successfully is
ignored. It returns the new FILE pointer.

The {\tt fread()} and {\tt fwrite()} commands read/write a number of bytes 
to or from a associated stream. The read function returns a string 
containing the result. The write function returns the number of written bytes. 

The {\tt fseek()} function seeks an offset number of bytes form the start, the 
current position, or the end of the stream.
\footnote{See the mil script file for the correct constants.}
This function returns the number of bytes moved. 

The {\tt fprintf()} function print a variable number of 
arguments using the format string. They return the number of arguments 
printed. 

The {\tt fputs()} places a string on the given output stream. 
{\tt fgets()} reads a string until an end of line is found form the 
given input stream. 

Look at the related ANSI-C/POSIX manual pages to get the needed information.

@* Module Definition
@m
.MODULE io;
    .USE blob; # fread() and fwrite() need blobs

    .ATOM stream = ptr;
    .END;
    .ATOM bipipe = lng;
    .END;

    .COMMAND stdin() : stream = io_stdin; 
	"return the input stream to the database client"
    .COMMAND stderr() : stream = io_stderr;
	"return the error stream for the database console"
    .COMMAND stdout() : stream = io_stdout;
	"return the output stream for the database client"

    .COMMAND fopen ( str filename, str mode ) : stream = io_fopen; 
	"See: man fopen. Returns stream, or stream(nil) on failure."
    .COMMAND freopen ( str filename, str mode, stream ) : stream = io_freopen;
	"See: man freopen. Returns stream, or stream(nil) on failure."
    .COMMAND popen( ) : bipipe = io_popen;
	"Open a bidirectional pipe. See: man pipe" 
    .COMMAND fdpipe(bipipe, bit up, str mode) : stream = io_fdpipe;
        "Open a stream in one direction through a pipe." 
    .COMMAND ferror() : str = io_ferror;
   	"returns last error message. str(nil) if none. "

    .COMMAND fclose( stream ) = io_fclose; 
	"See: man fclose"
    .COMMAND fflush( stream ) = io_fflush; 
	"See: man fflush"
    .COMMAND feof( stream ) : bit = io_feof; 
	"See: man feof"

    .COMMAND fread( stream filep, int nbytes ) : blob = io_fread; 
	"See: man fread"
    .COMMAND fwrite( stream filep, str buf, int nbytes ) = io_fwrite_str;
	"See: man fwrite"
    .COMMAND fwrite( stream filep, blob buf, int nbytes ) = io_fwrite;
	"See: man fwrite"
    .COMMAND fseek( stream filep, int pos, int offset ) : int = io_fseek; 
	"See: man fseek"
    .COMMAND ftell( stream filep ) : int = io_ftell; 
	"See: man ftell"

    .COMMAND fprint( stream filep, ... ) = io_fprint; 
	"Print a (comma seperated) list of arguments"

    .COMMAND fprintf( stream filep, str format, ... ) = io_fprintf; 
	"See: man fprintf"

    .COMMAND fputs( str s, stream filep ) = io_fputs; 
	"See: man fputs"
    .COMMAND fgets( stream filep ): str = io_fgets; 
	"See: man fgets"

    .COMMAND fputc( int c, stream filep ) = io_fputc; 
	"See: man fputs"
    .COMMAND fgetc( stream filep ): chr = io_fgetc; 
	"See: man fgetc"

    .COMMAND ftable( stream filep, ...BAT[any::1,any]... ) = io_ftable_default; 
	"Print an n-ary table to a file."

    .COMMAND ftable( stream filep, int orderspec, ...BAT[any::1,any]... ) = io_ftable; 
	"Print an n-ary table to a file, using order of BAT [1..argc]."

@- MIL initializations 
The constants for the seek function.
@m
.LOAD
        const EOF      := -1;
        const SEEK_SET := 0;
        const SEEK_CUR := 1;
        const SEEK_END := 2;
.END;

.END io;

@* Example Script
@mil
setoid(oid(20000000));
module(io);

fp := fopen ( "test", "w+" );
fwrite( fp, "Dit is een test\n", 17 );
fp := freopen ( "test", "r+", fp );
fread( fp, 17 ).tostr.print;

fseek( fp, 0, 0);
fprintf( fp, "%s %d %c %d %f\n", "test", 10, 'c', 10, 7.0 );

s := "testing again and again\n";

fseek( fp, 0, 0);
fputs( s, fp );
fseek( fp, 0, 0);
s := fgets( fp );

fflush( fp );
fclose( fp );
printf( "%s %d %c %d %f\n", "test", 10, 'c', 10, 7.0 );
printf( "%s\n", s );

quit;
@{
@* Implementation Code
@h
#ifndef _IO_H_
#define _IO_H_

#include <stdio.h>
#include <stdarg.h>
#include <blob.h>

typedef struct {
	int up, down;
} bipipe;

typedef FILE* stream;

#define FILEP_CHECK(fp) \
	if (!fp){ \
		GDKerror( "Incorrect file pointer\n"); \
		return(GDK_FAIL); \
	}


#include "io.proto.h"

#endif /* _IO_H_ */

@c
#include "io.h"
#include "monet.h"

int io_stdin (stream *ret) { *ret = GDKin;  return GDK_SUCCEED; }
int io_stdout(stream *ret) { *ret = GDKout; return GDK_SUCCEED; }
int io_stderr(stream *ret) { *ret = stderr; return GDK_SUCCEED; }

int io_fclose( stream* filepp ){
   FILE *fp = *(FILE**) filepp; 
   FILEP_CHECK(fp);
   if (fclose(fp) < 0) {
	GDKsyserror("io_fclose:");
	return GDK_FAIL;
   }
   return(GDK_SUCCEED);
}

int io_fflush( stream *filepp ){
   FILE *fp = *(FILE**) filepp; 
   FILEP_CHECK(fp);
   (void)fflush(fp);
   return(GDK_SUCCEED);
}

int io_popen(bipipe *retval){
   if (pipe((int*) retval) < 0) {
	GDKsyserror("io_popen:");
	return GDK_FAIL;
   }
   return GDK_SUCCEED;
}
int io_fdpipe(stream *retval, bipipe* p, bit *up, str mode){
   *retval = (stream) fdopen(up?p->up:p->down, mode);
   if (*retval == 0) return GDK_SUCCEED;
   GDKsyserror("io_fdpipe:");
   return GDK_FAIL;
}

int io_feof( bit *res, stream *filepp ){
   FILE *fp = *(FILE**) filepp; 
   FILEP_CHECK(fp);
   *res = feof(fp)?TRUE:FALSE;
   return(GDK_SUCCEED);
}

int io_fopen( stream *res, str name, str mode ){
   *res = fopen(name,mode);
   if (!*res) *res = *(stream*) ATOMnilptr(TYPE_stream);
   return GDK_SUCCEED;
}

int io_freopen( stream *res, str name, str mode, stream *filepp ){
   FILE *fp = *(FILE**) filepp; 
   FILEP_CHECK(fp);
   *res = freopen(name,mode,fp);
   if (!*res) *res = *(stream*) ATOMnilptr(TYPE_stream);
   return GDK_SUCCEED;
}

int io_ferror( str *msg) {
   int r = MT_geterrno();
   if (r) {
    	*msg = GDKstrdup(strerror(r));
   } else { 
	*msg = str_nil;
   }
   return GDK_SUCCEED;
}

int io_fread( blob **res, stream *filepp, int *nbytes ){
   FILE *fp = *(FILE**) filepp; 
   int err = -1;
   str buf;
   FILEP_CHECK(fp);
   buf = (str) GDKmalloc( sizeof(int) + *nbytes );
   if ((*res = (blob*) buf) != NULL){
   	err = fread(buf+sizeof(int),1,*nbytes,fp);
   }
   if (err<0){
      GDKsyserror("io_fread:");
      if (*res) GDKfree(*res);
      return(GDK_FAIL);
   }
   *(int*) (*res) = err;
   return(GDK_SUCCEED);
}

int io_fwrite_str(stream *filepp, str buf, int *nbytes ){
   FILE *fp = *(FILE**) filepp; 
   int n = strlen(buf); 
   FILEP_CHECK(fp);
   if (*nbytes < n) n = *nbytes;
   if (fwrite(buf,1,n,fp) < (size_t) n) {
      GDKsyserror("io_fwrite_str:");
      return(GDK_FAIL);
   }
   return(GDK_SUCCEED);
}

int io_fwrite(stream *filepp, blob *b, int *nbytes ){
   FILE *fp = *(FILE**) filepp; 
   int n = *nbytes;
   str buf = (str) b;
   FILEP_CHECK(fp);
   if (n> *(int*) buf) {
	n = MAX(0,*(int*) buf);
	GDKerror("io_fwrite: blob contains only %d bytes.\n", *(int*) buf);
   }
   if (fwrite(buf+sizeof(int),1,n,fp) < (size_t) n) {
      GDKsyserror("io_fwrite:");
      return(GDK_FAIL);
   }
   return(GDK_SUCCEED);
}

int io_fseek(int *res, stream *filepp, int *pos, int *nbytes ){
   FILE *fp = *(FILE**) filepp; 
   FILEP_CHECK(fp);
   *res = fseek(fp, (long)*pos, *nbytes);
   if (*res < 0) {
      GDKsyserror("io_fseek:");
      return(GDK_FAIL);
   }
   return(GDK_SUCCEED);
}

int io_ftell(int *res, stream *filepp ){
   FILE *fp = *(FILE**) filepp; 
   FILEP_CHECK(fp);
   *res = ftell(fp);
   if (*res < 0) {
      GDKsyserror("io_ftell:");
      return(GDK_FAIL);
   }
   return(GDK_SUCCEED);
}

int io_fprintf(stream *filepp, str format,  ...){
        va_list ap;
        int ret;
        str s;
 
	FILEP_CHECK(*filepp);
        va_start(ap,format);
        ret = monet_sprintf(&s, format, ap);
        va_end(ap);
        if (ret == GDK_FAIL) {
                return GDK_FAIL;
        }
        if (fputs(s, *filepp) < 0) {
                GDKsyserror("io_fprintf():");
                GDKfree(s);
                return GDK_FAIL;
        }
	GDKfree(s);
        return GDK_SUCCEED;
}

int io_fprint(stream *filepp, ...){
        va_list ap;
        ptr val; 
	int type;
 
	FILEP_CHECK(*filepp);
        va_start(ap,filepp);

	val = va_arg (ap,ptr);
        if(val){
		type = va_arg(ap,int);
		if (ATOMstorage(type) != TYPE_str)
			fprintf( *filepp, "%s(\"", ATOMname(type) );
		ATOMprint(type, val, *filepp);
		if (ATOMstorage(type) != TYPE_str)
			fprintf( *filepp, "\")" );
		val = va_arg (ap,ptr);
        	while(val){
			type = va_arg(ap,int);
			if (ATOMstorage(type) != TYPE_str)
				fprintf( *filepp, ", %s(\"", ATOMname(type) );
			else
				fprintf( *filepp, ", ");
			ATOMprint(type, val, *filepp);
			if (ATOMstorage(type) != TYPE_str)
				fprintf( *filepp, "\")" );
			val = va_arg (ap,ptr);
		}
	}
        va_end(ap);
        return GDK_SUCCEED;
}



int io_fputs(str s, stream *filepp ){
   FILEP_CHECK(*filepp);
   if (fputs(s,*(FILE**)filepp) < 0) {
      GDKsyserror("io_fputs: ");
      return GDK_FAIL;
   }
   return(GDK_SUCCEED);
}

int io_fputc(int *c, stream *filepp ){
   FILE *fp = *(FILE**) filepp; 
   FILEP_CHECK(fp);
   if (fputc(*c, fp) < 0) {
      GDKsyserror("io_fputs: ");
      return GDK_FAIL;
   }
   return(GDK_SUCCEED);
}

int io_fgets( str *s, stream *filepp ){
   FILE *fp = *(FILE**) filepp; 
   FILEP_CHECK(fp);
   *s = GDKmalloc( BUFSIZ );
   **s = 0;
   if (fgets(*s, BUFSIZ, fp) <= (char *) 0) {
      if (feof(fp)){
        **s = 0;
      	return(GDK_SUCCEED);
      }
      GDKsyserror("io_fgets: ");
      return GDK_FAIL;
   }
   return(GDK_SUCCEED);
}

int io_fgetc( chr *c, stream *filepp ){
   FILE *fp = *(FILE**) filepp; 
   int ret;
   FILEP_CHECK(fp);
   ret = (int)fgetc(fp);
   if (ret <= 0) {
      GDKsyserror("io_fgetc: ");
      return GDK_FAIL;
   }
   *c = ret;
   return(GDK_SUCCEED);
}

typedef BAT* batptr;

int io_ftable( stream* filepp, int *orderspec, ...){
        BAT *piv[MAXPARAMS];
        int argc = 0;
        va_list ap;

   	FILEP_CHECK(*filepp);
        va_start (ap, orderspec);
        do {
                piv[argc] = va_arg (ap,BAT*) ;
        } while(piv[argc++]);
        va_end (ap);
        BATmultiprintf(*filepp, argc, piv, FALSE, *orderspec);
        return GDK_SUCCEED;
}

int io_ftable_default(stream *filepp, ...) {
        BAT *piv[MAXPARAMS];
        int argc = 0;
        va_list ap;

   	FILEP_CHECK(*filepp);
        va_start (ap,filepp);
        do {
                piv[argc] = va_arg (ap,BAT*) ;
        } while(piv[argc++]);
        va_end (ap);
        BATmultiprintf(*filepp, argc, piv, FALSE, 0);
        return GDK_SUCCEED;
}
@}
