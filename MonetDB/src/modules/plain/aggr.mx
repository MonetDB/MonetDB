@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f aggr
@a P. Boncz, S. Manegold
@t Aggregates Module
@v 1.0

This module contains some efficient aggregate functions that compute their
result in one scan, rather than in the iterative manner of the generic
MIL aggr_ implementations.

The implementation code was derived from the former tpcd module and some
test scripts were added.
@m
.MODULE aggr;

.COMMAND {sum_bte}(BAT[oid,bte] b, BAT[oid,any] e) : BAT[oid,bte] = CMDaggr_sum_bte_bte;
	"grouped tail sum"
.COMMAND {sum_sht}(BAT[oid,bte] b, BAT[oid,any] e) : BAT[oid,sht] = CMDaggr_sum_bte_sht;
	"grouped tail sum"
.COMMAND {sum_sht}(BAT[oid,sht] b, BAT[oid,any] e) : BAT[oid,sht] = CMDaggr_sum_sht_sht;
	"grouped tail sum"
.COMMAND {sum_int}(BAT[oid,bte] b, BAT[oid,any] e) : BAT[oid,int] = CMDaggr_sum_bte_int;
	"grouped tail sum"
.COMMAND {sum_int}(BAT[oid,sht] b, BAT[oid,any] e) : BAT[oid,int] = CMDaggr_sum_sht_int;
	"grouped tail sum"
.COMMAND {sum_int}(BAT[oid,int] b, BAT[oid,any] e) : BAT[oid,int] = CMDaggr_sum_int_int;
	"grouped tail sum"
.COMMAND {sum_wrd}(BAT[oid,bte] b, BAT[oid,any] e) : BAT[oid,wrd] = CMDaggr_sum_bte_wrd;
	"grouped tail sum"
.COMMAND {sum_wrd}(BAT[oid,sht] b, BAT[oid,any] e) : BAT[oid,wrd] = CMDaggr_sum_sht_wrd;
	"grouped tail sum"
.COMMAND {sum_wrd}(BAT[oid,int] b, BAT[oid,any] e) : BAT[oid,wrd] = CMDaggr_sum_int_wrd;
	"grouped tail sum"
.COMMAND {sum_wrd}(BAT[oid,wrd] b, BAT[oid,any] e) : BAT[oid,wrd] = CMDaggr_sum_wrd_wrd;
	"grouped tail sum"
.COMMAND {sum_lng}(BAT[oid,bte] b, BAT[oid,any] e) : BAT[oid,lng] = CMDaggr_sum_bte_lng;
	"grouped tail sum"
.COMMAND {sum_lng}(BAT[oid,sht] b, BAT[oid,any] e) : BAT[oid,lng] = CMDaggr_sum_sht_lng;
	"grouped tail sum"
.COMMAND {sum_lng}(BAT[oid,int] b, BAT[oid,any] e) : BAT[oid,lng] = CMDaggr_sum_int_lng;
	"grouped tail sum"
.COMMAND {sum_lng}(BAT[oid,wrd] b, BAT[oid,any] e) : BAT[oid,lng] = CMDaggr_sum_wrd_lng;
	"grouped tail sum"
.COMMAND {sum_lng}(BAT[oid,lng] b, BAT[oid,any] e) : BAT[oid,lng] = CMDaggr_sum_lng_lng;
	"grouped tail sum"
.COMMAND {sum_flt}(BAT[oid,flt] b, BAT[oid,any] e) : BAT[oid,flt] = CMDaggr_sum_flt_flt;
	"grouped tail sum"
.COMMAND {sum_dbl}(BAT[oid,flt] b, BAT[oid,any] e) : BAT[oid,dbl] = CMDaggr_sum_flt_dbl;
	"grouped tail sum"
.COMMAND {sum_dbl}(BAT[oid,dbl] b, BAT[oid,any] e) : BAT[oid,dbl] = CMDaggr_sum_dbl_dbl;
	"grouped tail sum"

.COMMAND {prod_bte}(BAT[oid,bte] b, BAT[oid,any] e) : BAT[oid,bte] = CMDaggr_prod_bte_bte;
	"grouped tail product"
.COMMAND {prod_sht}(BAT[oid,bte] b, BAT[oid,any] e) : BAT[oid,sht] = CMDaggr_prod_bte_sht;
	"grouped tail product"
.COMMAND {prod_sht}(BAT[oid,sht] b, BAT[oid,any] e) : BAT[oid,sht] = CMDaggr_prod_sht_sht;
	"grouped tail product"
.COMMAND {prod_int}(BAT[oid,bte] b, BAT[oid,any] e) : BAT[oid,int] = CMDaggr_prod_bte_int;
	"grouped tail product"
.COMMAND {prod_int}(BAT[oid,sht] b, BAT[oid,any] e) : BAT[oid,int] = CMDaggr_prod_sht_int;
	"grouped tail product"
.COMMAND {prod_int}(BAT[oid,int] b, BAT[oid,any] e) : BAT[oid,int] = CMDaggr_prod_int_int;
	"grouped tail product"
.COMMAND {prod_wrd}(BAT[oid,bte] b, BAT[oid,any] e) : BAT[oid,wrd] = CMDaggr_prod_bte_wrd;
	"grouped tail product"
.COMMAND {prod_wrd}(BAT[oid,sht] b, BAT[oid,any] e) : BAT[oid,wrd] = CMDaggr_prod_sht_wrd;
	"grouped tail product"
.COMMAND {prod_wrd}(BAT[oid,int] b, BAT[oid,any] e) : BAT[oid,wrd] = CMDaggr_prod_int_wrd;
	"grouped tail product"
.COMMAND {prod_wrd}(BAT[oid,wrd] b, BAT[oid,any] e) : BAT[oid,wrd] = CMDaggr_prod_wrd_wrd;
	"grouped tail product"
.COMMAND {prod_lng}(BAT[oid,bte] b, BAT[oid,any] e) : BAT[oid,lng] = CMDaggr_prod_bte_lng;
	"grouped tail product"
.COMMAND {prod_lng}(BAT[oid,sht] b, BAT[oid,any] e) : BAT[oid,lng] = CMDaggr_prod_sht_lng;
	"grouped tail product"
.COMMAND {prod_lng}(BAT[oid,int] b, BAT[oid,any] e) : BAT[oid,lng] = CMDaggr_prod_int_lng;
	"grouped tail product"
.COMMAND {prod_lng}(BAT[oid,wrd] b, BAT[oid,any] e) : BAT[oid,lng] = CMDaggr_prod_wrd_lng;
	"grouped tail product"
.COMMAND {prod_lng}(BAT[oid,lng] b, BAT[oid,any] e) : BAT[oid,lng] = CMDaggr_prod_lng_lng;
	"grouped tail product"
.COMMAND {prod_flt}(BAT[oid,flt] b, BAT[oid,any] e) : BAT[oid,flt] = CMDaggr_prod_flt_flt;
	"grouped tail product"
.COMMAND {prod_dbl}(BAT[oid,flt] b, BAT[oid,any] e) : BAT[oid,dbl] = CMDaggr_prod_flt_dbl;
	"grouped tail product"
.COMMAND {prod_dbl}(BAT[oid,dbl] b, BAT[oid,any] e) : BAT[oid,dbl] = CMDaggr_prod_dbl_dbl;
	"grouped tail product"

.COMMAND {avg}(BAT[oid,bte] b, BAT[oid,any] e) : BAT[oid,dbl] = CMDaggr_avg_bte;
	"grouped tail average"
.COMMAND {avg}(BAT[oid,sht] b, BAT[oid,any] e) : BAT[oid,dbl] = CMDaggr_avg_sht;
	"grouped tail average"
.COMMAND {avg}(BAT[oid,int] b, BAT[oid,any] e) : BAT[oid,dbl] = CMDaggr_avg_int;
	"grouped tail average"
.COMMAND {avg}(BAT[oid,wrd] b, BAT[oid,any] e) : BAT[oid,dbl] = CMDaggr_avg_wrd;
	"grouped tail average"
.COMMAND {avg}(BAT[oid,lng] b, BAT[oid,any] e) : BAT[oid,dbl] = CMDaggr_avg_lng;
	"grouped tail average"
.COMMAND {avg}(BAT[oid,flt] b, BAT[oid,any] e) : BAT[oid,dbl] = CMDaggr_avg_flt;
	"grouped tail average"
.COMMAND {avg}(BAT[oid,dbl] b, BAT[oid,any] e) : BAT[oid,dbl] = CMDaggr_avg_dbl;
	"grouped tail average"

.COMMAND {variance}(BAT[oid,bte] b, BAT[oid,any] e) : BAT[oid,bte] = CMDaggr_variance_bte;
        "grouped tail variance"
.COMMAND {variance}(BAT[oid,sht] b, BAT[oid,any] e) : BAT[oid,sht] = CMDaggr_variance_sht;
        "grouped tail variance"
.COMMAND {variance}(BAT[oid,int] b, BAT[oid,any] e) : BAT[oid,int] = CMDaggr_variance_int;
        "grouped tail variance"
.COMMAND {variance}(BAT[oid,wrd] b, BAT[oid,any] e) : BAT[oid,wrd] = CMDaggr_variance_wrd;
        "grouped tail variance"
.COMMAND {variance}(BAT[oid,lng] b, BAT[oid,any] e) : BAT[oid,lng] = CMDaggr_variance_lng;
        "grouped tail variance"
.COMMAND {variance}(BAT[oid,flt] b, BAT[oid,any] e) : BAT[oid,flt] = CMDaggr_variance_flt;
        "grouped tail variance"
.COMMAND {variance}(BAT[oid,dbl] b, BAT[oid,any] e) : BAT[oid,dbl] = CMDaggr_variance_dbl;
        "grouped tail variance"

.COMMAND {min}(BAT[oid,any::1] b, BAT[oid,any] e) : BAT[oid,any::1] = CMDaggr_min;
	"grouped tail minimum"
.COMMAND {max}(BAT[oid,any::1] b, BAT[oid,any] e) : BAT[oid,any::1] = CMDaggr_max;
	"grouped tail maximum"

.COMMAND {count}(BAT[oid,any] b, BAT[oid,any] e, bit ignore_nils) : BAT[oid,int] = CMDaggr_count;
	"grouped count; ignores nil values iff ignore_nils==TRUE"
.COMMAND {size}(BAT[oid,bit] b, BAT[oid,any] e) : BAT[oid,wrd] = CMDaggr_size;
	"grouped count of true values"

.COMMAND size(BAT[any,bit]) : wrd = CMDsize;
        "return the number of true values in a tail column"
.COMMAND hasNil(BAT[any,any]) : bit = CMDhasNil;
        "return if there is a nil value in the tail column"
.COMMAND card(BAT[any,any]) : wrd = CMDcard_unlimited;
        "return the number of different values in a tail column"
.COMMAND card(BAT[any,any], wrd maxelements) : wrd = CMDcard;
        "as card(b), but returns nil if card(b) > maxelements"

.END aggr;

@mil
    proc {count}(BAT[oid,any] b, BAT[oid,any] e) : BAT[oid,int] {
		return {count}(b,e,FALSE);
    }
    ADDHELP("{count}", "manegold", "Jun 03 2003",
    "short-cut for {count}(b,e,FALSE)", "aggr");

    proc {count_no_nil}(BAT[oid,any] b, BAT[oid,any] e) : BAT[oid,int] {
		return {count}(b,e,TRUE);
    }
    ADDHELP("{count_no_nil}", "manegold", "Jun 03 2003",
    "short-cut for {count}(b,e,TRUE)", "aggr");

    proc size(BAT[any,bit] b) : wrd {
	var h := b.histogram();
	if (h.exist(true))
	    return h.find(true).wrd(); # 64bit: when histogram() returns wrd, remove cast
	return wrd(0);
    }

    proc {sum}(BAT[oid, bte] b, bat[oid,any] e ) : BAT[oid,bte] {
		return	 {sum_bte}(b,e);
    }
    proc {sum}(BAT[oid, sht] b, bat[oid,any] e ) : BAT[oid,sht] {
		return	 {sum_sht}(b,e);
    }
    proc {sum}(BAT[oid, int] b, bat[oid,any] e ) : BAT[oid,int] {
		return	 {sum_int}(b,e);
    }
    proc {sum}(BAT[oid, wrd] b, bat[oid,any] e ) : BAT[oid,wrd] {
		return	 {sum_wrd}(b,e);
    }
    proc {sum}(BAT[oid, lng] b, bat[oid,any] e ) : BAT[oid,lng] {
		return	 {sum_lng}(b,e);
    }
    proc {sum}(BAT[oid, flt] b, bat[oid,any] e ) : BAT[oid,flt] {
		return	 {sum_flt}(b,e);
    }
    proc {sum}(BAT[oid, dbl] b, bat[oid,any] e ) : BAT[oid,dbl] {
		return	 {sum_dbl}(b,e);
    }

    proc {prod}(BAT[oid, bte] b, bat[oid,any] e ) : BAT[oid,bte] {
		return	 {prod_bte}(b,e);
    }
    proc {prod}(BAT[oid, sht] b, bat[oid,any] e ) : BAT[oid,sht] {
		return	 {prod_sht}(b,e);
    }
    proc {prod}(BAT[oid, int] b, bat[oid,any] e ) : BAT[oid,int] {
		return	 {prod_int}(b,e);
    }
    proc {prod}(BAT[oid, wrd] b, bat[oid,any] e ) : BAT[oid,wrd] {
		return	 {prod_wrd}(b,e);
    }
    proc {prod}(BAT[oid, lng] b, bat[oid,any] e ) : BAT[oid,lng] {
		return	 {prod_lng}(b,e);
    }
    proc {prod}(BAT[oid, flt] b, bat[oid,any] e ) : BAT[oid,flt] {
		return	 {prod_flt}(b,e);
    }
    proc {prod}(BAT[oid, dbl] b, bat[oid,any] e ) : BAT[oid,dbl] {
		return	 {prod_dbl}(b,e);
    }
    proc {card}(BAT[oid,any] b, BAT[oid,any] e) : BAT[oid,wrd] {
	return {count}(b.sunique(),e).[wrd](); # 64bit: when count() returns wrd, remove cast
    }

    proc variance(BAT[any,any::1] b) : any::1 {
	var c := dbl(b.count());
	if (c = 0.0LL) {
		return 0.cast(b.ttype());
	}
	var s := [*](b,b).sum();
	var a := b.avg();
	return ((s / c) - (a * a)).cast(b.ttype());
    }

@{
@{
@+ Implementation
These implementations need just one scan and a simple hash-maintained data
structure to compute a group of common aggregates.
@c
#include <gdk.h>
#include "aggr.proto.h"

/*
with group OIDs spanning a range of less SMALL_AGGR_MAX (the actual number
of groups might be even less, in case there are "holes" in the group OID
range), we use a simple array as temporary sum/cnt table on order to benefit
from positional lookups; with size of sum <= 8 bytes and size of cnt == 4
bytes, we stay below 16 KBytes, i.e., within (almost) any L1 cache
*/
#define SMALL_AGGR_MAX 1024

@= large_aggr_sum
	if (BATprepareHash(bn)) {
		BBPreclaim(bn);
		return GDK_FAIL;
	}
	BATloopFast(b, p, q, xx) {
		oid *h = (oid*) BUNhead(b,p);
		@1 *t = (@1*) BUN@2(b,p);

		BUNfndOID(r, bn, h);
		if (r) {
			@3 *dst = (@3*) BUN@2(bn, r);
			if (*dst != @3_nil) {
				if (*t == @1_nil) {
					*dst = @3_nil;
				} else {
					*dst += *t;
				}
			}
		}
	}
@c
@= small_aggr_sum
	sums = (@3*) GDKmalloc(range*sizeof(@3));
	for (i = 0; i < range; i++)
		sums[i] = zero;
	BATloopFast(b, p, q, xx) {
		oid h = (*(oid*) BUNhead(b,p)) - min;
		@1 *t = (@1*) BUN@2(b,p);

		if (h < range) {
			@3 *dst = sums + h;
			if (*dst != @3_nil) {
				if (*t == @1_nil) {
					*dst = @3_nil;
				} else {
					*dst += *t;
				}
			}
		}
	}
	BATloopFast(bn, p, q, xx) {
		oid h = (*(oid*) BUNhead(bn,p)) - min;
		*(@3*)BUN@2(bn, p) = sums[h];
	}
        GDKfree(sums);
@c
@= large_aggr_prod
	if (BATprepareHash(bn)) {
		BBPreclaim(bn);
		return GDK_FAIL;
	}
	BATloopFast(b, p, q, xx) {
		oid *h = (oid*) BUNhead(b,p);
		@1 *t = (@1*) BUN@2(b,p);

		BUNfndOID(r, bn, h);
		if (r) {
			@3 *dst = (@3*) BUN@2(bn, r);
			if (*dst != @3_nil) {
				if (*t == @1_nil) {
					*dst = @3_nil;
				} else {
					*dst *= *t;
				}
			}
		}
	}
@c
@= small_aggr_prod
	prods = (@3*) GDKmalloc(range*sizeof(@3));
	for (i = 0; i < range; i++)
		prods[i] = one;
	BATloopFast(b, p, q, xx) {
		oid h = (*(oid*) BUNhead(b,p)) - min;
		@1 *t = (@1*) BUN@2(b,p);

		if (h < range) {
			@3 *dst = prods + h;
			if (*dst != @3_nil) {
				if (*t == @1_nil) {
					*dst = @3_nil;
				} else {
					*dst *= *t;
				}
			}
		}
	}
	BATloopFast(bn, p, q, xx) {
		oid h = (*(oid*) BUNhead(bn,p)) - min;
		*(@3*)BUN@2(bn, p) = prods[h];
	}
        GDKfree(prods);
@c
@= large_aggr_avg
	cnt  = (size_t*) GDKmalloc(BATcount(e)*sizeof(size_t));
	memset(cnt, 0, BATcount(e)*sizeof(size_t));
	if (BATprepareHash(bn)) {
		GDKfree(cnt);
		BBPreclaim(bn);
		return GDK_FAIL;
	}
	BATloopFast(b, p, q, xx) {
		oid *h = (oid*) BUNhead(b,p);
		@1 *t = (@1*) BUN@2(b,p);

		BUNfndOID(r,bn,h);
		if (r) {
			dbl *dst = (dbl*) BUN@2(bn, r);
			if (*dst != dbl_nil) {
				if (*t == @1_nil) {
					*dst = dbl_nil;
				} else {
					*dst += *t;
				}
				cnt[BUNindex(bn,r)-off]++;
			}
		}
	}
	/* postprocess by dividing sums by counts */
	BATloopFast(bn, p, q, xx) {
		dbl *dst = (dbl*) BUN@2(bn, p);
		if (cnt[yy] == 0) {
			*dst = dbl_nil;
		} else if (*dst != dbl_nil) {
			*dst = (dbl) (*dst / cnt[yy]);
		} yy++;
	}
	GDKfree(cnt);
@c
@= small_aggr_avg
	sums = (dbl*) GDKmalloc(range*sizeof(dbl));
	cnt  = (size_t*) GDKmalloc(range*sizeof(size_t));
	for (i = 0; i < range; i++)
		sums[i] = zero;
	memset(cnt, 0, range*sizeof(size_t));
	BATloopFast(b, p, q, xx) {
		oid h = (*(oid*) BUNhead(b,p)) - min;
		@1 *t = (@1*) BUN@2(b,p);

		if (h < range) {
			dbl *dst = sums + h;
			if (*dst != dbl_nil) {
				if (*t == @1_nil) {
					*dst = dbl_nil;
				} else {
					*dst += *t;
				}
				cnt[h]++;
			}
		}
	}
	/* postprocess by dividing sums by counts */
	BATloopFast(bn, p, q, xx) {
		oid h = (*(oid*) BUNhead(bn,p)) - min;
		dbl *dst = (dbl*) BUN@2(bn, p);
		if (cnt[h] == 0 || sums[h] == dbl_nil) {
			*dst = dbl_nil;
		} else {
			*dst = (dbl) (sums[h]/cnt[h]);
		}
	}
        GDKfree(sums);
	GDKfree(cnt);
@c

@= arithsumprod
int
CMDaggr_sum_@1_@3(BAT **ret, BAT *b, BAT *e)
{
	BAT *bn = BATnew(e->htype, TYPE_@3, BATcount(e));
	@3 zero = (@3) 0, *sums;
	BUN p, q, r;
	int xx;
	oid i, range, min, max;

	if (bn == NULL)
		return GDK_FAIL;
	/* init: set all sums to zero */
	bn->tsorted = bn->hsorted = 0;
	ALIGNsetH(bn, e);
	if (BAThordered(e)&1) {
		min = *(oid*)BUNhead(e, BUNfirst(e));
		BATloopFast(e, p, q, xx) {
			if (BUNfastins(bn, BUNhead(e,p), &zero) == NULL) {
				BBPreclaim(bn);
				return GDK_FAIL;
			}
		}
		max = *(oid*)BUNhead(e, BUNlast(e)-BUNsize(e));
	} else {
		min = max = *(oid*)BUNhead(e, BUNfirst(e));
		BATloopFast(e, p, q, xx) {
			if (BUNfastins(bn, BUNhead(e,p), &zero) == NULL) {
				BBPreclaim(bn);
				return GDK_FAIL;
			}
			i = *(oid*)BUNhead(e, p);
			if (i < min)
				min = i;
			else if (i > max)
				max = i;
		}
	}
	range = max - min + 1;

	/* scan b, and add values to sums in-place */
	if (range > SMALL_AGGR_MAX) {
		ALGODEBUG THRprintf(GDKout, "#CMDaggr_sum_@1_@3: range(=" SZFMT ") > SMALL_AGGR_MAX(=%d)  => large_aggr_sum\n",(size_t) range,SMALL_AGGR_MAX);
		@:large_aggr_sum(@1,@2,@3)@
	} else {
		ALGODEBUG THRprintf(GDKout, "#CMDaggr_sum_@1_@3: range(=" SZFMT ") <= SMALL_AGGR_MAX(=%d)  => small_aggr_sum\n",(size_t) range,SMALL_AGGR_MAX);
		@:small_aggr_sum(@1,@2,@3)@
	}
	*ret = bn;
	return GDK_SUCCEED;
}

int
CMDaggr_prod_@1_@3(BAT **ret, BAT *b, BAT *e)
{
	BAT *bn = BATnew(e->htype, TYPE_@3, BATcount(e));
	@3 one = (@3) 1, *prods;
	BUN p, q, r;
	int xx;
	oid i, range, min, max;

	if (bn == NULL)
		return GDK_FAIL;
	/* init: set all prods to one */
	bn->tsorted = bn->hsorted = 0;
	ALIGNsetH(bn, e);
	if (BAThordered(e)&1) {
		min = *(oid*)BUNhead(e, BUNfirst(e));
		BATloopFast(e, p, q, xx) {
			if (BUNfastins(bn, BUNhead(e,p), &one) == NULL) {
				BBPreclaim(bn);
				return GDK_FAIL;
			}
		}
		max = *(oid*)BUNhead(e, BUNlast(e)-BUNsize(e));
	} else {
		min = max = *(oid*)BUNhead(e, BUNfirst(e));
		BATloopFast(e, p, q, xx) {
			if (BUNfastins(bn, BUNhead(e,p), &one) == NULL) {
				BBPreclaim(bn);
				return GDK_FAIL;
			}
			i = *(oid*)BUNhead(e, p);
			if (i < min)
				min = i;
			else if (i > max)
				max = i;
		}
	}
	range = max - min + 1;

	/* scan b, and mul values to prods in-place */
	if (range > SMALL_AGGR_MAX) {
		ALGODEBUG THRprintf(GDKout, "#CMDaggr_prod_@1_@3: range(=" SZFMT ") > SMALL_AGGR_MAX(=%d)  => large_aggr_prod\n",(size_t) range,SMALL_AGGR_MAX);
		@:large_aggr_prod(@1,@2,@3)@
	} else {
		ALGODEBUG THRprintf(GDKout, "#CMDaggr_prod_@1_@3: range(=" SZFMT ") <= SMALL_AGGR_MAX(=%d)  => small_aggr_prod\n",(size_t) range,SMALL_AGGR_MAX);
		@:small_aggr_prod(@1,@2,@3)@
	}
	*ret = bn;
	return GDK_SUCCEED;
}
@c
@:arithsumprod(bte,tloc,bte)@
@:arithsumprod(bte,tloc,sht)@
@:arithsumprod(bte,tloc,int)@
@:arithsumprod(bte,tloc,wrd)@
@:arithsumprod(bte,tloc,lng)@
@:arithsumprod(sht,tloc,sht)@
@:arithsumprod(sht,tloc,int)@
@:arithsumprod(sht,tloc,wrd)@
@:arithsumprod(sht,tloc,lng)@
@:arithsumprod(int,tloc,int)@
@:arithsumprod(int,tloc,wrd)@
@:arithsumprod(int,tloc,lng)@
@:arithsumprod(wrd,tloc,wrd)@
@:arithsumprod(wrd,tloc,lng)@
@:arithsumprod(lng,tloc,lng)@
@:arithsumprod(flt,tloc,flt)@
@:arithsumprod(flt,tloc,dbl)@
@:arithsumprod(dbl,tloc,dbl)@

@= arithavg
int
CMDaggr_avg_@1(BAT **ret, BAT *b, BAT *e)
{
	BAT *bn = BATnew(e->htype, TYPE_dbl, BATcount(e));
	int xx;
	size_t yy = 0, off ;
	size_t *cnt;
	oid i, range, min, max;
	dbl zero = (dbl) 0, *sums;
	BUN p, q, r;

	if (bn == NULL)
		return GDK_FAIL;
	off = BUNindex(bn,BUNfirst(bn));
	/* init sums and counts to zero */
	bn->tsorted = bn->hsorted = 0;
	ALIGNsetH(bn, e);
	if (BAThordered(e)&1) {
		min = *(oid*)BUNhead(e, BUNfirst(e));
		BATloopFast(e, p, q, xx) {
			if (BUNfastins(bn, BUNhead(e,p), &zero) == NULL) {
				BBPreclaim(bn);
				return GDK_FAIL;
			}
		}
		max = *(oid*)BUNhead(e, BUNlast(e)-BUNsize(e));
	} else {
		min = max = *(oid*)BUNhead(e, BUNfirst(e));
		BATloopFast(e, p, q, xx) {
			if (BUNfastins(bn, BUNhead(e,p), &zero) == NULL) {
				BBPreclaim(bn);
				return GDK_FAIL;
			}
			i = *(oid*)BUNhead(e, p);
			if (i < min)
				min = i;
			else if (i > max)
				max = i;
		}
	}
	range = max - min + 1;

	/* scan b, adding sums, and incrementing counts */
	if (range > SMALL_AGGR_MAX) {
		ALGODEBUG THRprintf(GDKout, "#CMDaggr_avg_@1: range(=" SZFMT ") > SMALL_AGGR_MAX(=%d)  =>  large_aggr_avg\n",(size_t) range,SMALL_AGGR_MAX);
		@:large_aggr_avg(@1,@2)@
	} else {
		ALGODEBUG THRprintf(GDKout, "#CMDaggr_avg_@1: range(=" SZFMT ") <= SMALL_AGGR_MAX(=%d)  =>  small_aggr_avg\n",(size_t) range,SMALL_AGGR_MAX);
		@:small_aggr_avg(@1,@2)@
	}
	*ret = bn;
	return GDK_SUCCEED;
}
@c
@:arithavg(bte,tloc)@
@:arithavg(sht,tloc)@
@:arithavg(int,tloc)@
@:arithavg(wrd,tloc)@
@:arithavg(lng,tloc)@
@:arithavg(flt,tloc)@
@:arithavg(dbl,tloc)@

@-
this was imported in the DD merge.
TODO: add ALGODEBUG and optimize further?

@= arithvar
int
CMDaggr_variance_@1(BAT **ret, BAT *b, BAT *e)
{
	size_t nElements = BATcount(e);
	BAT *bn = *ret = BATnew(e->htype, BATttype(b), nElements);
	int xx;
	size_t off, idx = 0;
	int *cnt ;
	dbl *sum ;
	dbl *sumsquares ;
	@1 zero = (@1) 0;
	BUN p, q, r;
	oid previousOid = oid_nil;

	if (bn == NULL)
		return GDK_FAIL;
	off = BUNindex(e,BUNfirst(e));
	cnt = (int*) GDKmalloc(nElements*sizeof(int));
	if (cnt == NULL) {
		BBPreclaim(bn);
		return GDK_FAIL;
	}
	sum = (dbl*) GDKmalloc(nElements*sizeof(dbl));
	if (sum == NULL) {
		BBPreclaim(bn);
		GDKfree(cnt);
		return GDK_FAIL;
	}
	sumsquares = (dbl*) GDKmalloc(nElements*sizeof(dbl));
	if (sumsquares == NULL) {
		BBPreclaim(bn);
		GDKfree(cnt);
		GDKfree(sum);
		return GDK_FAIL;
	}

	/* scan b, adding sums, and incrementing counts */
	if (BATprepareHash(bn)) {
		BBPreclaim(bn);
		GDKfree(cnt);
		GDKfree(sum);
		GDKfree(sumsquares);
		return GDK_FAIL;
	}

	/* init sums and counts to zero */
	memset(cnt, 0, nElements*sizeof(int));
	memset(sum, 0, nElements*sizeof(dbl));
	memset(sumsquares, 0, nElements*sizeof(dbl));

	BATloopFast(b, p, q, xx) {
		oid *h = (oid*) BUNhead(b,p);
		if (*h != previousOid) {
			previousOid = *h;
			BUNfndOID(r,e,h);
			if (!r)
				continue;
			idx = BUNindex(e,r)-off;
		}

		if (cnt[idx] != int_nil) {
			@1 v = *(@1*) BUNtloc(b,p);
			if (v == @1_nil) {
				cnt[idx] = int_nil;
			} else {
				cnt[idx]++;
				sum[idx] += v;
				sumsquares[idx] += (v * v);
			}
		}
	}

	/* postprocess by dividing sumsquares and sum by counts and
	   substracting square of the averages from the average sum of
	   squares */
	idx = 0;
	BATloopFast(e, p, q, xx) {
		if (cnt[idx] == int_nil) {
			@1 _nil = @1_nil;
			if (BUNfastins(bn, BUNhead(e,p), (ptr)&_nil) == NULL) {
				*ret = NULL;
				break;
			}
		} else if (cnt[idx] <= 1) {
			if (BUNfastins(bn, BUNhead(e,p), &zero) == NULL) {
				*ret = NULL;
				break;
			}
		} else {
			dbl avg = (sum[idx] / cnt[idx]);
			@1 variance = (@1) (sumsquares[idx] / cnt[idx] - (avg * avg));
			if (BUNfastins(bn, BUNhead(e,p), &variance) == NULL) {
				*ret = NULL;
				break;
			}
		}
		idx++;
	}
	GDKfree(cnt);
	GDKfree(sum);
	if (!*ret) {
		BBPreclaim(bn);
		return GDK_FAIL;
	}
	bn->hsorted = bn->tsorted = 0;
	ALIGNsetH(bn, e);
	return GDK_SUCCEED;
}
@c
@:arithvar(bte)@
@:arithvar(sht)@
@:arithvar(int)@
@:arithvar(wrd)@
@:arithvar(lng)@
@:arithvar(flt)@
@:arithvar(dbl)@


@= extreme
int
CMDaggr_@1_@3(BAT **ret, BAT *b, BAT *e)
{
	BAT *bn = *ret = BATnew(e->htype, BATttype(b), BATcount(e));
	int (*cmp)(ptr,ptr);
	ptr nil;
	int xx;
	size_t yy = 0, off;
	@3 *extremes;
	BUN p, q, r;

	if (bn == NULL)
		return GDK_FAIL;
	cmp= BATatoms[bn->ttype].atomCmp;
	nil = ATOMnilptr(bn->ttype);
	off = BUNindex(e,BUNfirst(e));
	extremes = (@3*) GDKmalloc(BATcount(e)*sizeof(@3));
	if (extremes == NULL) {
		BBPreclaim(bn);
		return GDK_FAIL;
	}

	/* init: set all extremes to the zero pointer */
	@:extreme_init_@3(@4)@

	/* scan b and replace totals by the extreme value (just pointers to vals in b) */
	if (BATprepareHash(e)) {
		BBPreclaim(bn);
		GDKfree(extremes);
		return GDK_FAIL;
	}
	BATloopFast(b, p, q, xx) {
		oid *h = (oid*) BUNhead(b,p);
		ptr t =  BUNtail(b,p);

		BUNfndOID(r,e,h);
		if (r) {
			@:extreme_body_@3(@2)@
		}
	}
	/* insert the extreme values into the result */
	yy = 0;
	BATloopFast(e, p, q, xx) {
		@3 val = extremes[yy++];
		if (BUNfastins(bn, BUNhead(e,p), @:extreme_tail_@3@) == NULL) {
			*ret = NULL;
			break;
		}
	}
	GDKfree(extremes);
	if (!*ret) {
		BBPreclaim(bn);
		return GDK_FAIL;
	}
	bn->tsorted = bn->hsorted = 0;
	ALIGNsetH(bn, e);
	return GDK_SUCCEED;
}
@= extreme_init_oid
	for (yy = 0 ; yy < BATcount(e) ; yy++) extremes[yy] = GDK_oid_@1;
@= extreme_init_ptr
	memset(extremes, 0, BATcount(e)*sizeof(ptr));
@= extreme_body_oid
			oid *val = extremes + (BUNindex(e,r) - off);
			if (*val != *(oid*)nil) {
				if ((*cmp)(t,nil) == 0) {
					*val = *(oid*)nil;
				} else if ((*cmp)(t,val) @1 0) {
					*val = *(oid*)t;
				}
			}
@= extreme_body_ptr
			ptr *val = extremes + (BUNindex(e,r) - off);
			if (*val != nil) {
				if ((*cmp)(t,nil) == 0) {
					*val = nil;
				} else if (*val == NULL || (*cmp)(t,*val) @1 0) {
					*val = t;
				}
			}
@= extreme_tail_oid
	&val
@= extreme_tail_ptr
	val?val:nil
@= extreme_
@:extreme(@1,@2,oid,@3)@
@:extreme(@1,@2,ptr,@3)@
int
CMDaggr_@1(BAT **ret, BAT *b, BAT *e)
{
	if (b->ttype == TYPE_void) {
		return CMDaggr_@1_oid(ret, b, e);
	} else {
		return CMDaggr_@1_ptr(ret, b, e);
	}
}
@c
@:extreme_(min,<,max)@
@:extreme_(max,>,min)@

@= large_aggr_count
	if (BATprepareHash(bn)) {
		BBPreclaim(bn);
		return GDK_FAIL;
	}
	BATloopFast(b, p, q, xx) {
		oid *h = (oid*) BUNhead(b,p);

		BUNfndOID(r, bn, h);
		if (r) {
			ptr t = BUNtail(b,p);
			(void) t; /* silence compiler about unused variable */
			@1 {
				int *dst = (int*) BUNtloc(bn, r);
				(*dst)++;
			}
		}
	}
@c
@= small_aggr_count
	cnt  = (int*) GDKmalloc(range*sizeof(int));
	memset(cnt, 0, range*sizeof(int));
	BATloopFast(b, p, q, xx) {
		oid h = (*(oid*) BUNhead(b,p)) - min;

		if (h < range) {
			ptr t = BUNtail(b,p);
			(void) t; /* silence compiler about unused variable */
			@1 {
				cnt[h]++;
			}
		}
	}
	BATloopFast(bn, p, q, xx) {
		oid h = (*(oid*) BUNhead(bn,p)) - min;
		*(int*)BUNtloc(bn, p) = cnt[h];
	}
        GDKfree(cnt);
@c

int
CMDaggr_count(BAT **ret, BAT *b, BAT *e, bit *ignore_nils)
{
/* XXX in a large BAT, it is conceivable that there are head elements
   that occur more often than fits in an "int", so the return BAT
   should really have a tail type of size_t.
 */
	BAT *bn = BATnew(e->htype, TYPE_int, BATcount(e));
	int zero = 0, *cnt;
	BUN p, q, r;
	int xx;
	oid i, range, min, max;
	int btt;
	ptr bt_nil;

	if (bn == NULL)
		return GDK_FAIL;
	btt = b->ttype;
	bt_nil = ATOMnilptr(b->ttype);

	/* init: set all sums to zero */
	bn->tsorted = bn->hsorted = 0;
	ALIGNsetH(bn, e);
	if (BAThordered(e) & 1) {
		min = *(oid *) BUNhead(e, BUNfirst(e));
		BATloopFast(e, p, q, xx) {
			if (BUNfastins(bn, BUNhead(e, p), &zero) == NULL) {
				BBPreclaim(bn);
				return GDK_FAIL;
			}
		}
		max = *(oid *) BUNhead(e, BUNlast(e) - BUNsize(e));
	} else {
		min = max = *(oid *) BUNhead(e, BUNfirst(e));
		BATloopFast(e, p, q, xx) {
			if (BUNfastins(bn, BUNhead(e, p), &zero) == NULL) {
				BBPreclaim(bn);
				return GDK_FAIL;
			}
			i = *(oid *) BUNhead(e, p);
			if (i < min)
				min = i;
			else if (i > max)
				max = i;
		}
	}
	range = max - min + 1;

	/* scan b, and add increment totals for true values */
	if (range > SMALL_AGGR_MAX) {
		if (*ignore_nils) {
			ALGODEBUG THRprintf(GDKout, "#CMDaggr_count: range(=" SZFMT ") > SMALL_AGGR_MAX(=%d)  =>  large_aggr_count(if (ATOMcmp(btt,t,bt_nil)))\n", (size_t) range, SMALL_AGGR_MAX);

			@:large_aggr_count(if(ATOMcmp(btt,t,bt_nil)))@
		} else {
			ALGODEBUG THRprintf(GDKout, "#CMDaggr_count: range(=" SZFMT ") > SMALL_AGGR_MAX(=%d)  =>  large_aggr_count()\n", (size_t) range, SMALL_AGGR_MAX);

			@:large_aggr_count()@
		}
	} else {
		if (*ignore_nils) {
			ALGODEBUG THRprintf(GDKout, "#CMDaggr_count: range(=" SZFMT ") <= SMALL_AGGR_MAX(=%d)  =>  small_aggr_count(if (ATOMcmp(btt,t,bt_nil)))\n", (size_t) range, SMALL_AGGR_MAX);

			@:small_aggr_count(if(ATOMcmp(btt,t,bt_nil)))@
		} else {
			ALGODEBUG THRprintf(GDKout, "#CMDaggr_count: range(=" SZFMT ") <= SMALL_AGGR_MAX(=%d)  =>  small_aggr_count()\n", (size_t) range, SMALL_AGGR_MAX);

			@:small_aggr_count()@
		}
	}
	*ret = bn;
	return GDK_SUCCEED;
}

int
CMDaggr_size(BAT **ret, BAT *b, BAT *e)
{
	BAT *bn = BATnew(e->htype, TYPE_wrd, BATcount(e));
	wrd zero = 0;
	BUN p, q, r;
	int xx;

	if (bn == NULL)
		return GDK_FAIL;
	/* init: set all sums to zero */
	bn->tsorted = bn->hsorted = 0;
	ALIGNsetH(bn, e);
	BATloopFast(e, p, q, xx) {
		if (BUNfastins(bn, BUNhead(e, p), &zero) == NULL) {
			BBPreclaim(bn);
			return GDK_FAIL;
		}
	}
	/* scan b, and add increment totals for true values */
	if (BATprepareHash(bn)) {
		BBPreclaim(bn);
		return GDK_FAIL;
	}
	BATloopFast(b, p, q, xx) {
		if (*(bit *) BUNtloc(b, p) == TRUE) {
			oid *h = (oid *) BUNhead(b, p);

			BUNfndOID(r, bn, h);
			if (r) {
				wrd *dst = (wrd *) BUNtloc(bn, r);

				(*dst)++;
			}
		}
	}
	*ret = bn;
	return GDK_SUCCEED;
}

int
CMDsize(wrd *ret, BAT *b)
{
	*ret = BATgetprop_wrd(b, GDK_AGGR_SIZE);
	if (*ret < 0) {
		bit *cur = (bit *) BUNtail(b, BUNfirst(b));
		bit *end = (bit *) BUNtail(b, BUNlast(b));
		wrd cnt;
		int xx = BUNsize(b);

		for (cnt = 0; cur < end; cur += xx)
			cnt += (*cur == TRUE);
		BATsetprop_wrd(b, GDK_AGGR_SIZE, *ret = cnt);
	}
	return GDK_SUCCEED;
}

#define CARD_INC_BOUNDED(x,y) if (++(x) > (y)) break
#define CARD_INC_UNBOUNDED(x,y) ++(x)

@= card_bound_tpe
	if (BATtordered(b)&1) {
		/* the sorted algorithm: scan */
		ptr prev =  (ptr) BUNt@2(b, BUNfirst(b));
		cursize = 1; /* start counting unique elements... (at one) */
		BATloopFast(b, p, q, xx) {
			ptr cur =  (ptr) BUNt@2(b, p);
			if (!@1_EQ(prev, cur, @3)) {
				CARD_INC_@4(cursize, maxsize);
				prev = cur;
			}
		}
	} else {
		/* default algorithm is hash based */
		size_t yy = BUNindex(b, BUNfirst(b));
		BAT *v = VIEWcreate(BATmirror(b));
		Heap *hp = (Heap*) GDKmalloc(sizeof(Heap));
		str nme = BBP_physical(v->batCacheid);
		hp->filename = (str) GDKmalloc(strlen(nme)+12);
		sprintf(hp->filename, "%s.%chash", nme, v->batCacheid>0?'h':'t');
		if ((v->hhash = HASHnew(hp, any, BATcapacity(b), HASHmask(BATcount(b)))) == NULL) {
			BBPreclaim(v);
			return GDK_FAIL;
		}
		BATmirror(v)->thash = v->hhash; 
		cursize = 0; /* start counting unique elements... (at zero) */
		BATloopFast(b, p, q, xx) {
			ptr cur =  (ptr) BUNt@2(b, p);
			HASHfnd_@3(r, v, cur);
			if (r == NULL) {
				CARD_INC_@4(cursize, maxsize);
				HASHins_@3(v->hhash, yy, cur);
			}
			yy++;
		}
		BBPreclaim(v); /* free view and hash table */
	}
	break;
@= card_bound
	{
		int any = tpe;	/* name chosen for convenience in atom macros */
		switch(ATOMstorage(any)) {
#ifndef NOEXPAND_CHR
		case TYPE_chr:
			@:card_bound_tpe(simple,loc,chr,@1)@
#endif
#ifndef NOEXPAND_BTE
		case TYPE_bte:
			@:card_bound_tpe(simple,loc,bte,@1)@
#endif
#ifndef NOEXPAND_SHT
		case TYPE_sht:
			@:card_bound_tpe(simple,loc,sht,@1)@
#endif
#if !defined(NOEXPAND_INT) || !defined(NOEXPAND_FLT)
		case TYPE_int:
		case TYPE_flt:
			@:card_bound_tpe(simple,loc,int,@1)@
#endif
#if !defined(NOEXPAND_LNG) || !defined(NOEXPAND_DBL)
		case TYPE_lng:
		case TYPE_dbl:
			@:card_bound_tpe(simple,loc,lng,@1)@
#endif
		default:
			if (b->tvarsized) {
				@:card_bound_tpe(atom,var,any,@1)@
			} else {
				@:card_bound_tpe(atom,loc,any,@1)@
			}
		}
	}
@c

int
CMDcard(wrd *result, BAT *b, wrd *maxelements)
{
	wrd maxsize = *maxelements, cursize = BATcount(b);

	if (b->ttype == TYPE_void && b->tseqbase == oid_nil) {
		cursize = 1;
	} else if (cursize > 1 && !b->tkey) {
		cursize = BATgetprop_wrd(b, GDK_AGGR_CARD);
		if ((b->ttype == TYPE_chr || b->ttype == TYPE_bte) && *maxelements > 256) {
			maxsize = 256;
		} else if (b->ttype == TYPE_sht && *maxelements > 65536) {
			maxsize = 65536;
		} else if (cursize == wrd_nil && BATcount(b) > 10000 && *maxelements > 1000 && !(BATtordered(b) & 1)) {
			/* the recursive quick-look optimization does not make sense for the sorted case */
			maxsize = *maxelements / 10;
			CMDcard(&cursize, b, &maxsize);	/* try your luck with a smaller limit... */
			maxsize = *maxelements;
		}
		if (cursize == wrd_nil) {
			BUN p, q, r;	/* if we could not figure out the cardinality by now, we must do real work.. :( */
			int xx, tpe = b->ttype;

			if (tpe == TYPE_str && strElimDoubles(b->theap)) {
				tpe = TYPE_var;	/* use offsets only in case of a double-eliminated string heap */
			}
#if 0
#endif
			if (maxsize <= (ssize_t) BATcount(b)) {
				@:card_bound(BOUNDED)@
			} else {
				maxsize = BATcount(b);	/* reducing maxsize limits memory consumption in hash table */
				@:card_bound(UNBOUNDED)@	/* UNBOUNDED = no overhead for checking maxsize */
			}
		}
	}
	if (cursize <= *maxelements) {
		BATsetprop_wrd(b, GDK_AGGR_CARD, *result = cursize);
	} else {
		*result = wrd_nil;
	}
	return GDK_SUCCEED;
}

int
CMDcard_unlimited(wrd *result, BAT *b)
{
	wrd limit = (wrd) BATcount(b);

	return CMDcard(result, b, &limit);
}

int
CMDhasNil(bit *ret, BAT *b)
{
	*ret = (BATcount(b) == 0) ? FALSE : BATtdense(b) ? (b->tseqbase == oid_nil) : BATgetprop_bit(BATmirror(b), GDK_AGGR_HASNIL);
	if (*ret == bit_nil) {
		*ret = BUNfnd(BATmirror(b), ATOMnilptr(b->ttype)) ? TRUE : FALSE;
		BATsetprop_bit(BATmirror(b), GDK_AGGR_HASNIL, *ret);
	}
	return GDK_SUCCEED;
}

@}
@}
