@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.
@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f blob
@v 1.0
@a Wilko Quak, Peter Boncz
@t The blob Type

@* Introduction
Monet support for blob. It is the generic form of a variable
sized extension atom. Easy to derive from. Its memory layout 
consists of first 4 bytes containing the bytes-size of the 
blob (excluding the integer), and then just binary data.

@* Module Definition
@m
.MODULE blob;

   .ATOM blob;
      .TOSTR   = blob_tostr;
      .FROMSTR = blob_fromstr;
      .NEQUAL  = blob_nequal;
      .HASH    = blob_hash;
      .NULL    = blob_null;
      .WRITE   = blob_write;
      .READ    = blob_read;
      .CONVERT = blob_convert;
      .PUT     = blob_put;
      .DEL     = blob_del;
      .LENGTH  = blob_length;
      .HEAP    = blob_heap;
   .END;

@+ string functions
Manipulation functions to extract strings from blobs and vice versa.
Not to be confused with blob parsing and printing.
@m
   .COMMAND tostr(blob) : str = fromblob; 
	"get the bytes from blob as a string, till the first 0 byte
         or the end of the blob"
   .COMMAND tostr(blob, int index) : str = fromblob_idx;
	"get the bytes from blob as a string, starting at byte 'index'
         till the first 0 byte or the end of the blob."
   .COMMAND toblob(str) : blob = toblob;
	"store a string as a blob."
   .COMMAND nitems(blob) : int = blob_nitems;
        "get the number of bytes stored in this blob."

.END blob;

@* Example Script
@mil
PROC test_blob() : void {
  setoid(oid(20000000));
  bl := blob("(5:11 FC E2 A0 0A)");
  bl.print;
  bl2 := toblob("Hello World");
  bl2.print;
  tostr(bl2).print;
}

@{
@* Implementation Code
@h
#ifndef __BLOB_H__
#define __BLOB_H__

typedef struct blob
{
   size_t nitems;
   /*unsigned*/ char data[1];
} blob;

#include "blob.proto.h"

blob_export size_t blobsize(size_t nitems);

#endif /* __BLOB_H__ */
@c
#include <gdk.h>

#include "blob.h"

size_t blobsize(size_t nitems)
{
   if (nitems == ~(size_t)0)
      nitems = 0;
   return (sizeof(size_t)+nitems);
}

var_t blob_put(Heap* h,var_t* bun,blob* val)
{
   char* base;

   *bun = HEAP_malloc(h,blobsize(val->nitems));
   base = h->base;
   if (*bun) memcpy(&base[*bun],(char *)val,blobsize(val->nitems));
   return *bun;
}

#if 0
int blob_get(Heap* h,int* bun,int* l,blob** val)
{
   blob* from = HEAP_index(h,*bun,blob);
   size_t size = blobsize(from->nitems);

   if (*val == NULL)
   {
      *val = (blob *)GDKmalloc(size);
      *l = size;
   }
   else if (*l < size)
   {
      GDKfree(*val);
      *val = (blob *)GDKmalloc(size);
      *l = size;
   }
   memcpy(*val,from,size);

   return (size);
}
#endif

int blob_nequal(blob* l,blob*  r)
{
   size_t len = l->nitems;

   if (len != r->nitems)
      return(1);

   if (len == ~(size_t)0)
      return(0);

   return memcmp(l->data, r->data, len) != 0;
}

void blob_del(Heap* h,var_t* index)
{
   HEAP_free(h, *index);
}

hash_t blob_hash(blob* b)
{
   return (hash_t) b->nitems;
}

blob* blob_null(void)
{
   static blob nullval;
   nullval.nitems = ~(size_t)0;
   return(&nullval);
}

blob *blob_read(blob *a, stream *s, size_t cnt) {
	int len;
	(void) cnt;
	assert(cnt==1);
	if (!stream_readInt(s, &len))
		return NULL;
	if ((a = GDKmalloc(len)) == NULL)
		return NULL;
	if (stream_read(s, (char*)a, len, 1) != 1) {
		GDKfree(a);
		return NULL;
	}
	return a;
} 

void blob_write(blob *a, stream *s, size_t cnt) {
	int len = blobsize(a->nitems);
	(void) cnt;
	assert(cnt==1);
	if (stream_writeInt(s, (int) len))
		stream_write(s, (char*)a, len, 1 );
}

void blob_convert( blob *b, int direction){
	(void) direction;
	b->nitems = normal_vart_SWAP(b->nitems);
}

int blob_length(blob* p)
{
   return(blobsize(p->nitems));
}


void blob_heap(Heap* heap, size_t capacity)
{
   HEAP_initialize(heap,capacity,0,(int)sizeof(var_t));
}

#ifndef OLDSTYLE
int blob_tostr(str* tostr,int* l,blob* p)
{
	char* s;
	size_t i;
	size_t expectedlen;

	if (p->nitems == ~(size_t)0)
		expectedlen = 4;
	else
		expectedlen = 24 + (p->nitems * 3);
	if (*l < 0 || (size_t) *l < expectedlen) {
		if (*tostr != NULL)
			GDKfree(*tostr);
		*tostr = (str)GDKmalloc(expectedlen);
		*l = (int) expectedlen;
	}
	if (p->nitems == ~(size_t)0) {
		strcpy(*tostr, "nil");
		return 3;
	}

	sprintf(*tostr,"(" SZFMT ":", p->nitems);
	s = *tostr + strlen(*tostr);

	for (i = 0; i < p->nitems; i++) {
		int val = (p->data[i]>>4)&15;
		*s++ = ' ';
		if (val >= 10){
			*s++ = 'A' + val - 10;
		} else {
			*s++ = '0' + val;
		}
		val = p->data[i]&15;
		if (val >= 10){
			*s++ = 'A' + val - 10;
		} else {
			*s++ = '0' + val;
		}
	}
	*s++ = ')';
	*s = '\0';
	return(s - *tostr);
}

int blob_fromstr(char* instr,int* l,blob** val)
{
   size_t i;
   size_t nitems;
   size_t nbytes;
   blob *result;
   char* s = instr;

   s = strchr(s,'(');
   if (s == NULL)
   {
      GDKwarning("Missing ( in blob\n");
      *val = (blob*)NULL;
      return(0);
   }
   nitems = (size_t) strtoul(s + 1, &s, 10);
   if (s == NULL)
   {
      GDKwarning("Missing nitems in blob\n");
      *val = (blob *)NULL;
      return(0);
   }
#if SIZEOF_SIZE_T > SIZEOF_INT
   if (nitems > 0x7fffffff) {
      GDKwarning("Blob too large\n");
      *val = (blob *)NULL;
      return(0);
   }
#endif
   nbytes = blobsize(nitems);
   s = strchr(s,':');
   if (s == NULL)
   {
      GDKwarning("Missing ':' in blob\n");
      *val = (blob *)NULL;
      return(0);
   }
   ++s;

   if (*val == (blob* )NULL)
   {
      *val = (blob *)GDKmalloc(nbytes);
      *l = nbytes;
   }
   else if (*l < 0 || (size_t) *l < nbytes)
   {
      GDKfree(*val);
      *val = (blob *)GDKmalloc(nbytes);
      *l = (int) nbytes;
   }
   result = *val;
   result->nitems = nitems;

   /*
   // Read the values of the blob.
   */
   for (i = 0; i < nitems; ++i)
   {
      char res = 0;
	
      if (*s == ' ') 
	s++; 

      if (*s >= '0' && *s <= '9') {
	res = *s - '0';
      } else if (*s >= 'A' && *s <= 'F') {
	res = 10 + *s - 'A';
      } else if (*s >= 'a' && *s <= 'f') {
	res = 10 + *s - 'a';
      } else {
	break;
      }
      s++;
      res <<= 4;
      if (*s >= '0' && *s <= '9') {
	res += *s - '0';
      } else if (*s >= 'A' && *s <= 'F') {
	res += 10 + *s - 'A';
      } else if (*s >= 'a' && *s <= 'f') {
	res += 10 + *s - 'a';
      } else {
	break;
      }
      s++; /* skip space */
      
      result->data[i] = res;
   }

   if (i < nitems)
   {
	 GDKerror("blob too short \n");
	 return -1;
   }

   s = strchr(s,')');
   if (s == 0)
   {
      GDKerror("Missing ')' in blob\n");
   }

   return s-instr;
}

#else

/* the code in this branch of the #if is not being maintained */

#define MAXCHAR 127
#define LINE.LEN 80
#define CODEDLN 61
#define NORM.LEN 45

char blob_chtbl[MAXCHAR] = { 
	 0, 0, 0, 0, 0, 0, 0, 0, 
	 0, 0, 0, 0, 0, 0, 0, 0, 
	 0, 0, 0, 0, 0, 0, 0, 0, 
	 0, 0, 0, 0, 0, 0, 0, 0, 
	32,33,34,35,36,37,38,39,
	40,41,42,43,44,45,46,47,
	48,49,50,51,52,53,54,55,
	56,57,58,59,60,61,62,63,
	64,65,66,67,68,69,70,71,
	72,73,74,75,76,77,78,79,
	80,81,82,83,84,85,86,87,
	88,89,90,91,92,93,94,95,
	32, 0, 0, 0, 0, 0, 0, 0, 
	 0, 0, 0, 0, 0, 0, 0, 0, 
	 0, 0, 0, 0, 0, 0, 0, 0, 
	 0, 0, 0, 0, 0, 0, 94 };

#define ENC(c) (((c) & 077) + ' ')

char *blob_outdec(char* p,char* dst)
{
        int c1, c2, c3, c4;
 
        c1 = *p >> 2;
        c2 = (*p << 4) & 060 | (p[1] >> 4) & 017;
        c3 = (p[1] << 2) & 074 | (p[2] >> 6) & 03;
        c4 = p[2] & 077;
	dst[0] = ENC(c1);
	dst[1] = ENC(c1);
	dst[2] = ENC(c1);
	dst[3] = ENC(c1);
	return dst+4;
}
 
int blob_tostr(str* dst,int* size,blob* src)
{
	int i, n, len = *(int*) src;
	int memsize = 4 + (len*4)/3;
	char *out, *end;

@-
correct memsize for first and last chars of each line
@c
	memsize += 1 + 2*(memsize / CODEDLN); 

	if (*dst == 0) {
		*dst = (char*) GDKmalloc(*size = memsize);
	} else if (*size < memsize) {
		GDKfree(*dst);
		*dst = (char*) GDKmalloc(*size = memsize);
	}
        if (len == -1) {
                strcpy(*dst, "nil");
                return 3;
        }
	src +=sizeof(int);
	end = ((char *)src) + len;

        for (out=*dst; ((char *)src)<end; src += n) {
		n = MIN(end,src+45)-src;
		*out++ = ENC(n);
                for (i = 0; i < n; i += 3)
                      out = blob_outdec(&((char*)src)[i], out);
		*out++ = '\n';
	}
	if (out > *dst) out--;
	*out = 0;
	return out - *dst;
}

str blob_eoln(char* src,char*  end)
{
	char *r=strchr(src,'\n');
	if (r) return r;
	return end;
}

int blob_fromstr(char* src,int* size,blob** dst)
{
	int l = strlen(src), memsize = sizeof(int) + 1 + (l*3)/4;
	char *ut, *r, *end = src+l;

        if (!*dst) {
              	*dst = (blob *) GDKmalloc(*size=memsize);
	} else if (*size < memsize) {
		GDKfree(*dst);
              	*dst = (blob *) GDKmalloc(*size=memsize);
	}
	ut = (char *)*dst + sizeof(int);

	for (r=blob_eoln(src,end); src<end; src=r, r=blob_eoln(src,end)) {
		unsigned int n, c, len = r-src;
		char buf[LINELEN], *bp;
@-
PETER: this code wanted to modify the source line. So we copy it.
@c
		memcpy(buf, src, len);
		buf[--len] = '\0';
@-
Get the binary line length.
@c
		n = blob_chtbl[*buf];
		if (n == NORMLEN) goto decod;
@-
Pad with blanks.
@c
decod:		for (bp = &buf[c = len]; c < CODEDLN; c++, bp++) 
			*bp = ' ';
@-
Output a group of 3 bytes (4 input characters).  The input chars are pointed 
to by p, they are to be output to file f.  n is used to tell us not to
output all of them at the end of the file.
@c
		bp = &buf[1];
		while (n > 0) {
			*(ut++) = blob_chtbl[*bp]<<2 | blob_chtbl[bp[1]]>>4;
			n--;
			if (n) {
			    *(ut++) = blob_chtbl[bp[1]]<<4 | blob_chtbl[bp[2]]>>2;
		  	    n--;
			}
			if (n) {
			    *(ut++) = blob_chtbl[bp[2]]<<6 | blob_chtbl[bp[3]];
			    n--;
			}
			bp += 4;
		}
	}
@-
PETER: set the blob size.
@c
	*(int*) *dst = ut- ((char *)*dst + sizeof(int));
        return l;
}
#endif /* OLDSTYLE */

int fromblob_idx(str *retval, blob *b, int *index){
	str s, p = b->data + *index; 
	str r, q = b->data + b->nitems;
	for(r=p; r<q; r++) {
		if (*r == 0) break; 
	}
	*retval = s = (str) GDKmalloc(1+r-p);
	for(; p<r; p++, s++) 
		*s = *p;  
	*s = 0;
	return GDK_SUCCEED;
}

int fromblob(str *retval, blob *b){
	int zero = 0;
	return fromblob_idx(retval, b , &zero);
}

int toblob(blob **retval, str s){
	int len = strLen(s);
	blob *b = (blob*) GDKmalloc(blobsize(len));
	b->nitems = len;
	memcpy(b->data, s, len);
	*retval = b;
	return GDK_SUCCEED;
}

int blob_nitems(int *ret,blob *b) {
    *ret = b->nitems;
    return GDK_SUCCEED;
}

@}
