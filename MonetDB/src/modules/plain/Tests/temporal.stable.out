stdout of test 'temporal` in directory 'modules/plain` itself:

#> Mtest:	other temporal
#> Mtest:	Mtimeout -timeout 420 ./temporal temporal
#> Mlog:	Mtimeout -timeout 210 Mserver -modulesilent -yaccsilent -d8 -db modules_plain temporal.mil
# Monet Database Server V4.1
# Copyright (c) 1993-1999, CWI & SION. All rights reserved.
# compiled for IRIX646.5/32bit on Fri Jan 14 01:04:33 MET 2000.
#script:temporal.mil

loaded;
#---------------------------------#
# module	| usage_count	  #
#---------------------------------#
[ "algebra",	  1		  ]
[ "arith",	  1		  ]
[ "bat",	  1		  ]
[ "kernel",	  1		  ]
[ "str",	  1		  ]
[ "sys",	  1		  ]
[ "trans",	  1		  ]

Try: modules;                - for other modules.
     ls;                     - for persistent bat listing.
     sigs("<module>")        - for available commands per module.
     help("<command>")       - for help one-liner for a command.

#You are system administrator (adm)!

#line 352 "temporal.mx"
module(temporal);

proc check_date(str d) : str {
  if(isnil(date(d)))
	ERROR("Not a date: %s",d);
  else if(isnil(date(str(date(d)))))
	ERROR("Not recastable to str: %s",d);
  return date(d);
}
check_date("721012").print;
[ 72oct12 ]
check_date("72-10-01").print;
[ 72oct01 ]
check_date("72/01/12").print;
[ 72jan12 ]
check_date("19721012").print;
[ 1972oct12 ]
check_date("1972-10-12").print;
[ 1972oct12 ]
check_date("1972-10-12").print;
[ 1972oct12 ]
check_date("72OCT12").print;
[ 72oct12 ]
check_date("1972OCT12").print;
[ 1972oct12 ]
check_date("72-oct-12").print;
[ 72oct12 ]
check_date("1972-oct-12").print;
[ 1972oct12 ]
check_date("1972-OCT-12").print;
[ 1972oct12 ]
check_date("1972-Oct-12").print;
[ 1972oct12 ]
check_date("1972/Oct/12").print;
[ 1972oct12 ]
check_date("1972.Oct.12").print;
[ 1972oct12 ]
check_date("1972 Oct 12").print;
[ 1972oct12 ]

var t1 := date("721012");
var t2 := date("1988 Nov 30");
var d := t2 - t1;
printf("%s: %d %d %d %d %d\n", str(d), d.year, d.month, d.day, d.hours, d.minutes);
1916y1m18d-0h:0m: 1916 1 18 0 0

in(date("1999/05/05"), new_interval(date("1999/02/02"), date("1999/06/06"))).print;
[ true ]
in(date("1998/05/05"), new_interval(date("1999/02/02"), date("1999/06/06"))).print;
[ false ]
in(date("1999/02/02"), new_interval(date("1999/02/02"), date("1999/06/06"))).print;
[ true ]
in(date("1999/06/06"), new_interval(date("1999/02/02"), date("1999/06/06"))).print;
[ false ]
in(date("1999/02/03"), new_interval(date("1999/02/02"), date("1999/06/06"))).print;
[ true ]
in(date("1999/06/05"), new_interval(date("1999/02/02"), date("1999/06/06"))).print;
[ true ]
in(date("1999/02/01"), new_interval(date("1999/02/02"), date("1999/06/06"))).print;
[ false ]
in(date("1999/06/07"), new_interval(date("1999/02/02"), date("1999/06/06"))).print;
[ false ]

# Compare equal intervals
=(new_interval(date("1999/02/02"), date("1999/06/06")), new_interval(date("1999/02/02"), date("1999/06/06"))).print;
[ true ]
<(new_interval(date("1999/02/02"), date("1999/06/06")), new_interval(date("1999/02/02"), date("1999/06/06"))).print;
[ false ]
>(new_interval(date("1999/02/02"), date("1999/06/06")), new_interval(date("1999/02/02"), date("1999/06/06"))).print;
[ false ]
<=(new_interval(date("1999/02/02"), date("1999/06/06")), new_interval(date("1999/02/02"), date("1999/06/06"))).print;
[ true ]
>=(new_interval(date("1999/02/02"), date("1999/06/06")), new_interval(date("1999/02/02"), date("1999/06/06"))).print;
[ true ]

# XXX: no definition of less than and equal than is available.  At least,
# the server should not crash.

# Compare interval 1 < interval 2
=(new_interval(date("1999/02/02"), date("1999/03/03")), new_interval(date("1999/03/04"), date("1999/06/06"))).print;
[ false ]
<(new_interval(date("1999/02/02"), date("1999/03/03")), new_interval(date("1999/03/04"), date("1999/06/06"))).print;
[ true ]
>(new_interval(date("1999/02/02"), date("1999/03/03")), new_interval(date("1999/03/04"), date("1999/06/06"))).print;
[ false ]
<=(new_interval(date("1999/02/02"), date("1999/03/03")), new_interval(date("1999/03/04"), date("1999/06/06"))).print;
[ true ]
>=(new_interval(date("1999/02/02"), date("1999/03/03")), new_interval(date("1999/03/04"), date("1999/06/06"))).print;
[ false ]

# Compare interval 1 <= interval 2 with exact boundary match
=(new_interval(date("1999/02/02"), date("1999/03/03")), new_interval(date("1999/03/03"), date("1999/06/06"))).print;
[ false ]
<(new_interval(date("1999/02/02"), date("1999/03/03")), new_interval(date("1999/03/03"), date("1999/06/06"))).print;
[ false ]
>(new_interval(date("1999/02/02"), date("1999/03/03")), new_interval(date("1999/03/03"), date("1999/06/06"))).print;
[ false ]
<=(new_interval(date("1999/02/02"), date("1999/03/03")), new_interval(date("1999/03/03"), date("1999/06/06"))).print;
[ true ]
>=(new_interval(date("1999/02/02"), date("1999/03/03")), new_interval(date("1999/03/03"), date("1999/06/06"))).print;
[ false ]
