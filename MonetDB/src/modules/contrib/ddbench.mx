@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@v 1.0
@f ddbench
@a Peter Boncz
@t DDbench Optimization Module
@* Introduction
@T
This module is intended to attack the times presented on the DD benchmark
by the infocharger product. 

@+ Enumeration Grouping/Counting
@T
It enables experimentation with various optimizations:
\begin{itemize}

\item creating a group BAT on a BAT with enumeration tail-column
      can be avoided using a view-implementation that returns the
      same BAT, but with a different enumeration lookup-table
      (that contains oids instead of the original type). This 
      adapted lookup table is produced by the {\small\tt enum\_view()} command.

      This totally eliminates the group computation costs of batch 0.

\item specific techniques to more efficiently perform the group(ct,b) 
      operations of batch 1, exploiting the fact that both ct and b are 
      enumeration types. More specifically: a hash table is not necessary, 
      and an enumerated column for the group oids can be constructed directly, 
      instead of in a second step. 

      This reduces the group computation cost of batch 1.

\item when computing a full histogram on an enumerated column, we
      can just return the lookup table without effort; it
      already is a histogram! 

      This totally eliminates the histogram creation cost of batches 0 and 1. 
\end{itemize}

The above are obvious improvements of which the only question is how much
exactly they will improve the computation time. These implementations
are incorporated using procs into the generic {\small\tt group()} commands.

@+ Selections and Intersecting them
@T
Our initial benchmark result was obtained by 
creating selection-BATs with {\small\tt uselect()} and intersecting those for AND 
predicates.
These selection BATs where piped into a {\small\tt CTsubgroup()}, which 
rematerialized a sub-CT on which consequently a histogram was computed.

First, focusing on the selection effort, a number of optimizations
may be identified:
\begin{description}
\item[bitmasks]  the select-phase may be optimized by using bitmasks instead
      ov (inverted) oid-lists.  As the selection percentages are high, 
      oid BATs used to express selections can be very large and may even be 
     larger than the data-BATs
(e.g. gender\_0 has BAT-width of 1 byte, so it takes 1MB, but the selection
      BAT of all males (50\%) has BAT-width 4 bytes, so takes 2MB).
In case where the selection percentage is over 12\%, we can better store the
selection as a bitmask, which is done by the {\small\tt val\_bitselect()} and
{\small\tt rng\_bitselect()} commands (for equi- and range-select respectively). 
The storage is again a BAT, that has the new {\small\tt bit32} type in its tail.
The {\small\tt \[and\]()} operator can simply be used for intersecting them.

\item[subselect] instead of the materialized AND strategy for further zooming 
into subgroups (i.e. {\small\tt kintersect()} for oid-BATs, and {\small\tt \[and\]()} for 
bitmasks) we can use the already existing selection to reduce the number
of comparisons in the scan for the second predicate (which are traded
off for lookup effort on the first selection). This strategy has both been
implemented for the oid- and bitmask cases by having {\small\tt val\_bitselect()} and
{\small\tt rng\_bitselect()} commands that receive an additional oid- or bitmask-BAT
parameter for the initial restriction.

\item[overwrite-anding] when doing an additional restriction, we sometimes 
knwo that the original restriction is not going to be used anymore. In such 
cases, we can {\bf overwrite} the original restriction with the result. As the
retstriction-BAT is hot anyway, this altogether saves all allocation
and memory-access cost to the result BAT, at very little extra expense.
This strategy has both been implemented for the oid- and bitmask cases in
the {\small\tt val\_bitrefine()} and {\small\tt rng\_bitrefine()} commands 
(bitmask selections), and {\small\tt val\_oidrefine()} and {\small\tt rng\_oidrefine()} 
commands (oid-BAT selections).

\item[single-scan/multipredicate-selects] in batch2, selections are requested for both gender 
(male,females), age (18-45,45-55,55-80), marital (single,married,divorced) and
zipcode(3000-4000,4000-7000). In such cases we can try to save scans on the 
data-attributes by computing e.g. both {\small\tt =male} and {\small\tt =female}  
in one scan. 
This strategy has both been implemented for the oid- and bitmask cases in
the {\small\tt vals\_bitselect()} and {\small\tt rngs\_bitselect()} commands 
(bitmask selections), and {\small\tt vals\_oidselect()} and {\small\tt rngs\_oidselect()} 
commands (oid-BAT selections).

The return value of these operations is a BAT of result BATs.

\item[result estimation] the oid-BAT computing selection primitives
     exploit the fact that the tail-column of the data BATs are enumeration
     types. The lookup table of such types contains a histogram, which is
     used for creating a good result size estimate. 
\end{description}

All the selection primitives exploit (even require) the fact that the 
head-columns of the data BATs are {\small\tt void} and that their tail-column is
an enumeration type.

@+ Sub-Histograms
@T
For the computation of the sub-histograms, the following
optimizations have been done:

\begin{itemize}
\item evading the materialization of a sub-CT by providing an aggregate 
construct with a filter. This generic construct is mimicked in case of the 
COUNT aggregate by the {\small\tt oid\_subhisto()} and {\small\tt bit\_subhisto()} implementations.

\item whereas the multiple select on one attribute tries to exploit
      the advantages of scanning an attribute only once; this same
      technique may be applied for computation of the sub-histograms.
      This is especially useful for the bitmask subhistograms, as 
      they scan ther bitmasks anyway. The {\small\tt bits\_subhisto()} implementations scans multiple bitmasks and creates multiple histogram results.
\end{itemize}

All the selection primitives exploit (even require) the fact that the 
head-columns of the data BATs are {\small\tt void} and that their tail-column is
an enumeration type. The limited cardinality of such types is exploited
by using a direct-indexed array instead of a hash-table to organize
the histogram counting buckets.

@+ Other Possible Optimizations
@T
We discuss possible avenues to further improve the performance of the DD benchmark. 

One such is idea is to further enhance the speed of the basic primitives on
intel processors by processing multiple byte-values in parallel using
the speical MMX instruction set. This approach necessarily involves
assembly programming.

Another approach is through query optimization where first on invests in computing 
more complex cubes, which are used in batches 2 and 3 to avoid going to the 
full data set altogether. 

Finally, a different representation of crosstables using bitmasks that are
interpreted using a tree-data structure is being investigated by Martin. It 
should find its way into this document (TODO).

@- MMX parallellism
@T
Extra speed may be gained by implementing in assembly directly. 
The incompatibilities suffered by this might be recompensated by
the opportunity to achieve implementation code that cannot possibly
generated with C, {\bf and} provides significant performance advantages.

Such opportunities are especially found in the implementations of the
bitmask-BAT commands on PC hardware.

\begin{description}
\item[MMX selections]
PC hardware provides 64-bit MMX registers on which 8 independent
byte-compares may be performed in one clock cycle. This technique will 
probably accelerate by a factor 4 all {\small\tt *\_bitselect()} commands.

\item[bitmask subselects] intel hardware has a special opcode
that in 1 clock-cycle tells you which is the first bit in an 
integer bitmask that is turned on. This might significantly (factor 2?)
speed up the {\small\tt bit\_subhisto()} implementation as it scans
over a bitmask to see which tuples are selected.
\end{description}

@- Query Optimization
@T
An additional way to speed up the DD benchmark is to use an intelligent
cube-caching system. The basic idea is to first invest in computing a 
complex cubes that are cached instead of out current binary \[X,reliable\]
cubes. In the batches 2,3,4 when subsets are requested, (parts of ) 
these can be immediately asked by the cached complex cubes without any scans.

To be more explicit, 
in the DD benchmark we have the following attributes

\begin{tabular}{l|c|c|l}
 & \multicolumn{3}{c}{\bf attributes of the DD benchmark}\\
\hline\\
reliable & bool  & 2    & \{ true, false \}\\
marital  & string& 4    & \{single,married,divorced,widow\}\\
town     & string& 15   & 15 Dutch city names\\
age      & int   & 80   & [18-98]\\
spendings& float & 100  & \ \\
zipcode  & int   & 7000 & 2000-9000\\
\end{tabular}

The {\small\tt reliable} attribute is called the {\em target attribute}, 
the others are the {\em query attributes} 
the benchmark consists of 4 batches, that are executed separately, one
after the other:
\begin{description}
\item[batch 0] for each attribute {\small\tt select COUNT(*) FROM attr GROUP BY attr} ( 6 results).
\item[batch 1] for each query attribute {\small\tt select COUNT(*) FROM attr,reliable GROUP by attr,reliable} (5 results). 
\item[batch 2] for 10 simple predicates {\small\tt PRED} on one query attribute, do for the 
other 5 query attributes a {\small\tt select COUNT(*) FROM attr,reliable WHERE PRED GROUP by attr,reliable} (50 results).
\item[batch 3] for 10 predicates {\small\tt (PRED1 and PRED2)} on two query attributes, do for 
the other 4 attributes a {\small\tt select COUNT(*) FROM attr,reliable WHERE PRED1 AND PRED2 GROUP by attr,reliable} (40 results).
\item[batch 4] for 10 predicates {\small\tt (PRED1 and PRED2 and PRED3)} on three query attributes, do for 
the other 3 attributes a {\small\tt select COUNT(*) FROM attr,reliable WHERE PRED1 AND PRED2 AND PRED3 GROUP by attr,reliable} (30 results).
\end{description}

These queries results can be viewed as 0, 1, 2, and 3-dimensional cubes.

In our initial experiments, we just cache the 1-dimensional cubes:

\begin{tabular}{r|r|r}
 & \multicolumn{2}{l}{\bf cached cubes: standard strategy}\\
\hline\\
cube1 & [ spendings, reliable ] &   200 values\\
cube2 &   [ zipcode, reliable ] & 14000 values\\
cube3 &       [ age, reliable ] &   160 values\\
cube4 &      [ town, reliable ] &    30 values\\
cube5 &    [ gender, reliable ] &     4 values\\
cube6 &   [ marital, reliable ] &     8 values\\
\end{tabular}

Now, we could use a simple strategy that simply adds attributes to each
cubes in ascending order of cardinality till the cube size reaches a certain 
treshold. The \[attr,reliable\] cubes of added attributes disappear.
If we take, for instance the treshold to be 1000, we get the
following cubes to cache:

\begin{tabular}{r|r|r}
 & \multicolumn{2}{l}{\bf cached cubes: {\em limit=1000}}\\
\hline\\
cube1 &    [ spendings, gender, reliable ] & 400 values\\
cube2 &   [ spendings, marital, reliable ] & 800 values\\
cube3 &              [ zipcode, reliable ] & 14000 values\\
cube4 &          [ age, gender, reliable ] & 320 values\\
cube5 &         [ age, marital, reliable ] & 640 values\\
cube6 & [town, marital, gender, reliable ] & 240 values\\
\end{tabular}

These should not be much more expensive to compute by choosing
a smart {\small\tt CTgroup()} sequence. First -- and independently -- compute
{\small\tt \[zipcode,reliable\]}.  Then do {\small\tt \[gender,reliable\]}
and use this to {\small\tt CTgroup()} the attributes {\small\tt age} and {\small\tt spendings}.
Then do {\small\tt \[marital,reliable\]}, and compute with this the extra
{\small\tt age} and {\small\tt spendings} cross-tables. Finally
do a {\small\tt CTgroup()} with {\small\tt town}.

The histograms of batch 1 will be more detailed, so a small postprocess
step that sums the cell values in one class is necessary: 
{\small\begin{verbatim}
SELECT sum(cnt) FROM cube1 GROUP BY spendings; 
\end{verbatim}}

In MIL, this becomes
{\small\begin{verbatim}
ct := cube1_spendings.CTgroup();
aggr := join(cube1_cnt.reverse, ct);
subhisto := {sum}(cube1_cnt, aggr);
print(cube1_spendings, subhisto); 
\end{verbatim}}

Due to the fact that cell cardinalities of the {\small\tt cube1\_X } BATs are 
in the hundreds, the cost this step is negligable. The benefits of this approach 
appear in batch 2 (and later), when we have selections on '{\small\tt gender=male}' 
and '{\small\tt gender=female}' with a GROUP BY on {\small\tt \[spendings,reliable\]}. 
As {\small\tt \[spendings,gender,reliable\]} are covered by {\small\tt cube1}
we can resolve them with the queries:

{\small\begin{verbatim}
SELECT cnt FROM cube1 WHERE gender='male' GROUP BY spendings; 
SELECT cnt FROM cube1 WHERE gender='female' GROUP BY spendings; 
\end{verbatim}}
In MIL, this becomes
{\small\begin{verbatim}
subhisto1 := semijoin(cube1_cnt, cube1_gender.uselect('male');
print(cube1_spendings,subhisto1);

subhisto2 := semijoin(cube1_cnt, cube1_gender.uselect('female');
print(cube2_spendings,subhisto2);
\end{verbatim}}

the below table shows which queries from batch 2 would be 'covered' by
the cached subcubes with {\em limit=1000}:

\begin{tabular}{l|l|l}
{\bf selections}  & \multicolumn{2}{l}{\bf group by}\\
\ 	    & {\bf\em covered}		     & {\bf\em not covered}\\
\hline\\
2* gender,  & 4:spendings,age,marital,town   & 1:zipcode\\
3* age,     & 3:gender,marital,town  	     & 2:spendings,zipcode\\
3* marital  & 4:gender,spendings,age,town    & 1:zipcode\\
2* zipcode  & \                              & 5:age,gender,town,marital,spendings\\
\end{tabular}

In total, (2*4 + 3*3 + 3*4) = 28 out of 50 queries of batch 1 are covered. 
As batch 1 accounts for half of the benchmark cost, the savings can be 
significant.

One should remark that the cubes of which {\small\tt zipcode} is part must
be computed in the 'old' way; e.g. using a subselection to query a 
cached binary CT (keeping those in memory as well just costs 5MB and is worth 
doing). This forces us to still do all the selects and subselects
(or intersects). So this part of the computation cost of batch 2 is
not attacked by this optimization; limiting its impact.

The next question that arises is whether batch 3 and 4 can also benifit
from the complex cube caching strategy. Short examination learns that
only one cube out of 40 is covered in batch 3 (cube6 covers selection on 
{\small\tt marital,gender}, group by {\small\tt town,reliable}) and none from
batch 4.

So we could consider using a larger limit, e.g. {\em limit=2000}:

\begin{tabular}{r|r|r}
 & \multicolumn{2}{l}{\bf cached cubes: {\em limit=2000}}\\
\hline\\
cube1 & [ spendings, gender, marital, reliable ] & 1600 values\\
cube2 &                    [ zipcode, reliable ] & 14000 values\\
cube3 &       [ age, gender, marital, reliable ] & 1280 values\\
cube4 &       [town, marital, gender, reliable ] & 240 values\\
\end{tabular}

or {\em limit=30000}:

\begin{tabular}{r|r|r}
 & \multicolumn{2}{l}{\bf cached cubes: {\em limit=30000}}\\
\hline\\
cube1 & [ spendings, town, gender, marital, reliable ] & 24000 values\\
cube2 &       [ age, town, gender, marital, reliable ] & 19200 values\\
cube3 &                  [ zipcode, gender, reliable ] & 28000 values\\
\end{tabular}

The below table summarizes the 'coverage' in batch 3 of all three caching strategies:

\begin{tabular}{l|l|l|l}
{\bf selections}     & \multicolumn{3}{l}{\bf group by}\\
\ 	             & {\bf\em limit=1000} & {\bf\em limit=2000} & {\bf\em limit=30000}\\
\hline\\
3* gender,age        & \          & 1:marital            & 2:town,marital\\ 
3* age,town          & \          & \                    & 2:gender,marital\\
2* marital,age       & \          & 1:gender             & 2:town,gender\\
1* marital,gender    & 1:town     & 3:spendings,age,town & 3:spendings,age,town\\
1* zipcode,town      & \          & \                    & \ \\
\hline
{\em total covered:} & 1          & 8                    & 19\\ 
\end{tabular}

So, with {\em limit=30000}, again about half of batch 3 can be covered.
Experiments should determine whether these extra savings are offset by the
increased computation  cost of the cubes and sub queries on them, caused
by the increased cube sizes (probably not; {\em limit=1000} performs best). 



@* Module Definition
@m
.MODULE ddbench;

.USE xtables;
.USE enum;

.ATOM bit32 = int;
.FROMSTR = bit32FromStr;
.TOSTR = bit32ToStr;
.END;

.COMMAND stats(BAT[void,bit32] sel) : BAT[str,lng] = bit32stats;
 "produce info on this bit-selection"

.COMMAND tobat(BAT[void,bit32] sel) : BAT[oid,void] = bit32tobat;
 "convert a bat[void,bit32] bitmap selection into a BAT of oids"

.COMMAND kintersect(BAT[oid,any::1] b, BAT[void,bit32] sel) : 
					BAT[oid,any::1] = bit32semijoin;
 "do b.semijoin(sel.tobat); b must be dense and sel must correspond to it.\n"

@- groupings optimized for enumeration types
@m
.COMMAND enum_view(BAT[void,any] b) : 	BAT[oid,int] = enum_view; 
 "produces a histogram that is an adaptation of the enum-lookup table
  of the tail of b. Its head column differs: it contains oids; namely 
  the first oid of 'b' where the original lookup head value occured
  in the tail of 'b'. In other words :-), this produces the lookup
  table needed to create an 'enumeration view' that represents CTgroup(b)."

.COMMAND enum_group(BAT[void,any] ct, BAT[void,any] b) : 
	 				BAT[void,any] = enum_group; 
 "optimized group: use a byte-array[card(ct)*card(b)] instead of a hash
	           table and directly create enumerated group oid-s" 

.COMMAND enum_semijoin(BAT[void,any::1] b1, BAT[any,any] b2) : 
	 				BAT[oid,any::1] = enum_semijoin; 
 "positional semijoin if the b2 head type is an enumerated oid"

.COMMAND enum_join(BAT[any::1,void] b1, BAT[any,any::2] b2) : 
	 				BAT[any::1,any::2] = enum_join; 
 "positional join if the b2 head type is an enumerated oid"

@- fast oid selections 
work only on void BATs with enum tails. treat the BATs as unary
arrays. Use the enumeration lookup table as a histogram to estimate
the selectivity.
@m
.COMMAND val_oidselect(BAT[oid,any::1] b, any::1 v) : 
				BAT[void,oid] = val_oidselect;
 "uselect, optimized for enumeration types"

.COMMAND rng_oidselect(BAT[oid,any::1] b, any::1 lo, any::1 hi) :
				BAT[void,oid] = rng_oidselect;
 "uselect, optimized for enumeration types"

.COMMAND vals_oidselect(BAT[oid,any::1] b, any::1 v, ...any::1...) : 
	 			BAT[int,BAT[oid,void]] = vals_oidselect;
 "uselect, optimized for enum types, on multiple equi-select predicates"

.COMMAND rngs_oidselect(BAT[oid,any::1] b, any::1 lo, any::1 hi, ...any::1..) : 
	 			BAT[int,BAT[oid,void]] = rngs_oidselect;
 "uselect, optimized for enum types, on multiple range-select predicates"

.COMMAND subselect(BAT[oid,void] sel, BAT[oid,any::1] b, any::1 v) : 
				BAT[oid,void] = val_oidsubsel;
 "uselect, on b.semijoin(sel), optimized for enum types"

.COMMAND subselect(BAT[oid,void] sel, BAT[oid,any::1] b, any::1 lo, 
		any::1 hi) :	BAT[oid,void] = rng_oidsubsel;
 "uselect, on b.semijoin(sel), optimized for enum types"

@- selections that produce bitmasks
work only on void BATs with enum tails. Coded out in 32-tuple batches
to process the bitmask per 32-bit integers.
@m
.COMMAND val_bitselect(BAT[oid,any::1] b, any::1 v) : 
	 				BAT[void,bit32] = val_bitselect;
 "do a range-scan equiselect, but output the result as a bitmask, partitioned
  in 32-bits integers. "

.COMMAND rng_bitselect(BAT[oid,any::1] b, any::1 lo, any::1 hi) : 
	 			BAT[void,bit32] = rng_bitselect;
 "do a range-scan rangeselect, but output the result as a bitmask, partitioned
  in 32-bits integers. "

.COMMAND vals_bitselect(BAT[oid,any::1] b, any::1 v, ...any::1...) : 
	 			BAT[int,BAT[void,bit32]] = vals_bitselect;
 "computes multiple bitmasks for each equi-select 'v' on 'sel'"

.COMMAND rngs_bitselect(BAT[oid,any::1] b, any::1 lo, any::1 hi, ...any::1...) :
	 			BAT[int,BAT[void,bit32]] = rngs_bitselect;
 "computes multiple bitmasks for each equi-select 'v' on 'sel'"

.COMMAND subselect(BAT[void,bit32] sel, BAT[oid,any::1] b, any::1 v) : 
				BAT[void,bit32] = val_bitsubsel;
 "do a bitselect on the subset indicated by the first BAT param"

.COMMAND subselect(BAT[void,bit32] sel, BAT[oid,any::1] b, any::1 lo, 
		any::1 hi) :	BAT[void,bit32] = rng_bitsubsel;
 "do a bitselect on the subset indicated by the first BAT param"

@- refinements
these are like the sub-selects, but overwrite the 'sel' parameter
with the result.
@m 
.COMMAND refine(BAT[oid,void] sel, BAT[oid,any::1] b, any::1 v) : 
				BAT[oid,void] = val_oidrefine;
 "like val_oidsubsel(sel,b,v), but *OVERWRITES* sel with result."

.COMMAND refine(BAT[oid,void] sel, BAT[oid,any::1] b, any::1 lo, 
		any::1 hi) :	BAT[oid,void] = rng_oidrefine;
 "like rng_oidsubsel(sel,b,lo,hi), but *OVERWRITES* sel with result."

.COMMAND refine(BAT[void,bit32] sel, BAT[oid,any::1] b, any::1 v) : 
				BAT[void,bit32] = val_bitrefine;
 "like val_bitsubsel(sel,b,v), but *OVERWRITES* sel with result."

.COMMAND refine(BAT[void,bit32] sel, BAT[oid,any::1] b, any::1 lo, 
		any::1 hi) :	BAT[void,bit32] = rng_bitrefine;
 "like rng_bitsubsel(sel,b,lo,hi), but *OVERWRITES* sel with result."

@- sub-histograms
work only on void BATs with enum tails.
@m
.COMMAND subhistos(BAT[oid,any::1] b, ...BAT[void,bit32]...) :
	 BAT[int,BAT[any,int]] = bits_subhisto;
 "computes multiple subset-histograms on b, receiving multiple bitmasks"

.COMMAND subhisto(BAT[oid,any::1] b, BAT[oid,any] sel) :
	 			BAT[any,int] = oid_subhisto;
 "computes a subset-histogram on b, receiving the subset as a selection BAT"

.COMMAND subhisto(BAT[oid,any::1] b, BAT[void,bit32] sel) :
	 BAT[any,int] = bit_subhisto;
 "computes a subset-histogram on b, receiving the subset as a bitmask"

.END ddbench;

@mil
    proc group(bat[oid,any] b) : bat[oid,oid] {
        return CTgroup(b);
    }

    proc group(bat[void,any] b) : bat[oid,oid] {
        if (isenum(b.ttype())) {
	    return enum_trick(b,enum_view(b));
        }
        return CTgroup(b);
    }

    proc group(bat[oid,any] ct, bat[oid,any] b) : bat[oid,any] {
        return CTgroup(ct,b);
    }

    proc group(bat[void,any] ct, bat[void,any] b) : bat[oid,any] {
        if (isenum(b.ttype()) and isenum(ct.ttype())) {
            # condition should be more generic: thin types
            var bn := enum_group(ct,b);
            monet_atomtbl.insert(str(b.ttype().enum_table()),b.ttype());
            return bn;
        }
        return CTgroup(ct,b);
    }
    
    proc {count}(bat[any::1,any] b) : bat[any::1,int] {
    	if (isenum(b.htype()))
	if (enum_ishisto(b.htype(),b)) {
    	    # always use histograms for enum creation!
    	    return enum_table(b.htype());
    	}
    	return histogram(b.reverse());
    }

    proc not(bat[void,bit32] b) : bat[void,bit32] {
        return [bit32]([not]([int](b)));
    }

    proc semijoin(bat[void,any::1] b1, bat[any,any] b2) : bat[oid,any::1] {
	if (isenum(b2.htype()))
	if (enum_table(b2.htype()).htype() = oid) {
		return enum_semijoin(b1,b2);
	}
	return kintersect(b1,b2);
    }

    proc semijoin(bat[void,bit32] b1, bat[void,bit32] b2) : bat[void,bit32] {
        return [bit32]([and]([int](b1),[int](b2)));
    }

    proc mjoin(bat[any::1,any::3] b1, bat[any::3,any::2] b2) : bat[any::1,any::2] {
	return join(b1,b2);
    }

    proc mjoin(bat[any::1,void] b1, bat[any,any::2] b2) : bat[any::1,any::2] {
	if (isenum(b2.htype()))
	if (enum_table(b2.htype()).htype() = oid) {
		return enum_join(b1,b2);
	}
	return join(b1,b2);
    }

    proc mjoin(bat[any::1,any] b1, bat[void,any::2] b2) : bat[any::1,any::2] {
	if (isenum(b1.ttype()))
	if (enum_table(b1.ttype()).htype() = oid) {
		return mirror(enum_join(mirror(b2),mirror(b1)));
	}
	return join(b1,b2);
    }

@* Test Script
@mil

PROC test_ddbench() : void {
    if (view_bbp_name.reverse().exist("tpe")) {
	tpe := tpe.destroy();
	commit;
    }

    a := new(oid,oid);
    a.insert(2@0,nil); a.insert(2@0,nil); a.insert(2@0,nil); a.insert(2@0,nil);
    a.insert(1@0,nil); a.insert(1@0,nil); a.insert(1@0,nil);
    a.insert(0@0,nil); a.insert(0@0,nil); a.insert(0@0,nil); a.insert(0@0,nil);
    a.insert(0@0,nil); a.insert(0@0,nil); a.insert(0@0,nil); a.insert(0@0,nil);
    a.insert(3@0,nil); a.insert(3@0,nil); a.insert(3@0,nil); a.insert(3@0,nil);
    a.insert(a.copy());
    aa := a.mark(0@0).reverse();
    tpe := enum_create("tpe", aa);
    aaa := tpe.[encode](aa);

    brsel := rng_bitselect(aaa, tpe.encode(1@0), tpe.encode(3@0));
    aa.semijoin(brsel.tobat()).print();
    aaa.bit_subhisto(brsel).print();
    
    bvsel := val_bitselect(aaa, tpe.encode(2@0));
    aa.semijoin(bvsel.tobat()).print();
    aaa.bit_subhisto(bvsel).print();
    
    bvvsel := val_bitselect(brsel, aaa, tpe.encode(3@0));
    aaa.bit_subhisto(bvvsel).print();
    
    brrsel := rng_bitselect(brsel, aaa, tpe.encode(1@0), tpe.encode(2@0));
    aaa.bit_subhisto(brrsel).print();

    brsel.access(BAT_WRITE);
    rng_bitrefine(brsel, aaa, tpe.encode(1@0), tpe.encode(2@0));
    aaa.bit_subhisto(brsel).print();

    val_bitrefine(brsel, aaa, tpe.encode(2@0));
    aaa.bit_subhisto(brsel).print();

    bvs := vals_bitselect(aaa, tpe.encode(1@0), tpe.encode(3@0)); 
    bvs@batloop() print($t);

    brs := rngs_bitselect(aaa, tpe.encode(1@0), tpe.encode(2@0), 
                           tpe.encode(2@0), tpe.encode(3@0)); 
    brs@batloop() print($t);

    bhs := bits_subhisto(aaa, bvvsel, brsel); 
    bhs@batloop() print($t);

    orsel := rng_oidselect(aaa, tpe.encode(1@0), tpe.encode(3@0));
    aaa.oid_subhisto(orsel).print();

    ovsel := val_oidselect(aaa, tpe.encode(2@0));
    aaa.oid_subhisto(ovsel).print();

    ovvsel := val_oidselect(orsel, aaa, tpe.encode(3@0));
    aaa.oid_subhisto(ovvsel).print();

    orrsel := rng_oidselect(orsel, aaa, tpe.encode(1@0), tpe.encode(2@0));
    aaa.oid_subhisto(orrsel).print();

    orsel.access(BAT_WRITE);
    rng_oidrefine(orsel, aaa, tpe.encode(1@0), tpe.encode(2@0));
    aaa.oid_subhisto(orsel).print();

    val_oidrefine(orsel, aaa, tpe.encode(2@0));
    aaa.oid_subhisto(orsel).print();

    ovs := vals_oidselect(aaa, tpe.encode(1@0), tpe.encode(3@0)); 
    ovs@batloop() print($t);

    ors := rngs_oidselect(aaa, tpe.encode(1@0), tpe.encode(2@0), 
                           tpe.encode(2@0), tpe.encode(3@0)); 
    ors@batloop() print($t);
}

@* Implementation 
@c
#include <monet.h>
#include <stdio.h>
#include <stdarg.h>
#include "streams.h"
#include "enum.proto.h"
#include "enum.h"

static size_t
estimate(BAT *b, size_t lo, size_t hi)
{
	BUN p = BUNptr(b, BUNindex(b, BUNfirst(b)) + lo);
	BUN q = BUNptr(b, BUNindex(b, BUNfirst(b)) + hi);
	int xx = BUNsize(b);
	size_t sum = 1;

	if (p < BUNfirst(b))
		p = BUNfirst(b);
	if (q >= BUNlast(b))
		q = BUNlast(b) - xx;

	while (p <= q) {
		sum += *(int *) BUNtloc(b, p);
		p += xx;
	}
	return (size_t) (sum * BATMARGIN);
}

@= rng_estimate
	estimate(map, (size_t) *(unsigned @1*) lo@2, (size_t) *(unsigned @1*) hi@2)
@= val_estimate
	estimate(map, (size_t) *(unsigned @1*) v@2, (size_t) *(unsigned @1*) v@2)
@= check_bitsel
	if (@2->htype != TYPE_void || @2->ttype != TYPE_bit32 || 
	    @2->hseqbase != (BAThdense(@3)?@3->hseqbase:@3->halign) ||
	    @2->halign != (@4+1) || BATcount(@2)-1 != ((@4-1)>>5))
	{
		GDKerror("@1: illegal bitvector\n");
		return GDK_FAIL;
	}
@= check_oidsel
	if (@2->htype != TYPE_oid) {
		GDKerror("@1: selection head must be oids.\n");
		return GDK_FAIL;
	}
	if (BUNsize(@2) != ATOMsize(@2->htype)) {
		GDKerror("@1: selection tail must be void.\n");
		return GDK_FAIL;
	}
@= check_enumbat
	if (!enum_chktpe(@2->ttype)) {
		GDKerror("@1: attribute tail column is not enum.\n");
		return GDK_FAIL;
	}
	if (BUNsize(@2) != ATOMsize(@2->ttype)) {
		GDKerror("@1: attribute head must be void.\n");
		return GDK_FAIL;
	}

@+ bit32 type 
@= atommem
        if (!*dst) {
                *dst = (@1 *) GDKmalloc(*len = @2);
        } else if (*len < (int) @2) {
                GDKfree(*dst);
                *dst = (@1 *) GDKmalloc(*len = @2);
        }
@c
extern int TYPE_bit32;

int
bit32ToStr(char **dst, int *len, int *src)
{
	int mask = 1;
	str p;

	@:atommem(char,33)@

	if (*src == int_nil) {
		strcpy(*dst, "nil");
		return 3;
	}
	p = *dst;
	do {
		*p++ = (*src & mask) ? '1' : '0';
	} while (mask <<= 1);
	*p = 0;
	return (int) strlen(*dst);
}

int
bit32FromStr(char *src, int *len, int **dst)
{
	str p = src;
	int res = 0, mask = 1;

	@:atommem(int,sizeof(int))@

	do {
		if (*p == '1') {
			res |= mask;
		} else if (*p != '0') {
			**dst = int_nil;
			return 0;
		}
	} while (mask <<= 1);
	**dst = res;
	return (int) (p - src);
}


int
bit32tobat(BAT **ret, BAT *sel)
{
	oid size = sel->halign - 1;
	oid o = sel->hseqbase, last = o + size;
	int *cur = (int *) BUNhloc(sel, BUNfirst(sel));
	BAT *bn;

	@:check_bitsel(bit32tobat,sel,sel,size)@

	*ret = bn = BATnew(TYPE_oid, TYPE_void, size);

	for (;;) {
		int mask = 1, val = *cur++;

		do {
			if (val & mask)
				BUNfastins(bn, &o, NULL);
			if (++o >= last) {
				BATkey(bn, TRUE);
				return GDK_SUCCEED;
			}
		} while (mask <<= 1);
	}
}


int
bit32semijoin(BAT **ret, BAT *b, BAT *sel)
{
	int *cur = (int *) BUNhloc(sel, BUNfirst(sel));
	BUN p = BUNfirst(b), q = BUNlast(b);
	int xx = BUNsize(b);
	BAT *bn;

	@:check_bitsel(bit32semijoin,sel,b,BATcount(b))@
	*ret = bn = BATnew(TYPE_oid, BATttype(b), sel->halign - 1);

	for (;;) {
		int mask = 1, val = *cur++;

		do {
			if (val & mask)
				BUNfastins(bn, BUNhead(b, p), BUNtail(b, p));
			if ((p += xx) >= q) {
				bn->hsorted = BAThordered(b);
				bn->tsorted = BATtordered(b);
				if (b->hkey)
					BATkey(bn, TRUE);
				if (b->tkey)
					BATkey(BATmirror(bn), TRUE);
				return GDK_SUCCEED;
			}
		} while (mask <<= 1);
	}
}


int
bit32stats(BAT **ret, BAT *sel)
{
	size_t hits = 0, size = sel->halign - 1, i = size;
	int *cur = (int *) BUNhloc(sel, BUNfirst(sel));

	@:check_bitsel(bit32stats,sel,sel,size)@

	for (;;) {
		int mask = 1, val = *cur++;

		do {
			if (val & mask)
				hits++;
			if (--i == 0) {
				lng v;

				*ret = BATnew(TYPE_str, TYPE_lng, 4);
				v = (lng) sel->hseqbase;
				BUNins(*ret, "seqbase", &v);
				v = (lng) size;
				BUNins(*ret, "size", &v);
				v = (lng) hits;
				BUNins(*ret, "yes", &v);
				size -= hits;
				v = (lng) size;
				BUNins(*ret, "no", &v);
				return GDK_SUCCEED;
			}
		} while (mask <<= 1);
	}
}


@+ enum_view
@c
/* COMMAND 
 * optimized group: create an enumerated oid column that is a view on b
 */
typedef struct {
	oid val;
	int cnt;
} histo_t;

int
enum_view(BAT **res, BAT *b)
{
	BAT *histo;
	int tpe = b->ttype;

	if (!enum_table(&histo, &tpe)) {
		return GDK_FAIL;
	}
	if (ATOMsize(b->ttype) == 1) {
		@:createview(char)@
	} else {
		@:createview(short)@
	}
	return GDK_SUCCEED;
}

@= createview
{	BUN p, q;
	size_t xx, cnt = BATcount(histo);
	oid curoid = b->hseqbase;
	BAT* map = BATnew(TYPE_oid, TYPE_int, cnt);
	histo_t *dst = (histo_t*) BUNfirst(map);
	size_t off = BUNindex(histo, BUNfirst(histo));

	map->batBuns->free += cnt * sizeof(histo_t);
	map->hsorted = map->tsorted = FALSE;
	for(xx=0; xx<cnt; xx++) dst[xx].cnt = 0;

	BATloopFast(b, p, q, xx) {
		unsigned @1 idx = *(unsigned @1*) BUNtloc(b,p);
		if (dst[idx].cnt == 0) {
			dst[idx].val = curoid;  
			dst[idx].cnt = 
				*(int*) BUNtloc(histo,BUNptr(histo, (off+idx)));
			if (--cnt == 0) break;
		} curoid++;
	} *res = map;
}

@+ enum_group
@c	
/* COMMAND 
 * optimized group: use a byte-array[card(ct)*card(b)] instead of a hash
 * table and directly create enumerated group oid-s
 */

int
enum_group(BAT **res, BAT *ct, BAT *b)
{
	size_t card_b, card_c, pow_c, pow_b;
	int log_c, log_b;
	BAT *histo_b, *histo_ct;
	int ctpe = ct->ttype, btpe = b->ttype;

	if (!ALIGNsynced(ct, b)) {
		GDKerror("enum_group: params must be aligned.\n");
		return GDK_FAIL;
	}
	if (BAThdense(ct) == 0 || BAThdense(b) == 0) {
		GDKerror("enum_group: params must be dense.\n");
		return GDK_FAIL;
	}
	@:check_enumbat(enum_group,ct)@
	@:check_enumbat(enum_group,b)@

	enum_table(&histo_ct, &ctpe);
	enum_table(&histo_b, &btpe);
	card_c = BATcount(histo_ct);
	card_b = BATcount(histo_b);
	for (log_c = 0, pow_c = 1; pow_c < card_c; pow_c <<= 1, log_c++)
		;
	for (log_b = 0, pow_b = 1; pow_b < card_b; pow_b <<= 1, log_b++)
		;

	/* we shift on the maptable that is closest to a power of 2 */
	if (pow_b * card_c < pow_c * card_b) {
		BAT *swap_bat = ct;
		size_t swap_card = card_c;

		ct = b;
		b = swap_bat;
		card_c = card_b;
		card_b = swap_card;
		pow_c = pow_b;
		log_c = log_b;
	}

	/* group, create histogram and result in enumtype */
	if (card_b * pow_c < 255) {
		if (ATOMsize(b->ttype) != 1 || ATOMsize(ct->ttype) != 1) {
			GDKerror("enum_group: nyi: unexpected types.\n");
			return GDK_FAIL;
		}
		@:enumgroup(char,char,char)@
	} else if (card_b * pow_c > 65535) {
		GDKerror("enum_group: overflow scenario nyi.\n");
		return GDK_FAIL;
	} else if (ATOMsize(b->ttype) == ATOMsize(ct->ttype)) {
		GDKerror("enum_group: nyi: unexpected types.\n");
		return GDK_FAIL;
	} else if (pow_c > 255) {
		@:enumgroup(short,char,short)@
	} else {
		@:enumgroup(char,short,short)@
	}
	ALIGNsetH(*res, ct);
	return GDK_SUCCEED;
}

@- optimized implementation
@T
The below grouping algorithm exploits a limited number of grouping
combinations by creating an 'map' of index numbers for each possible group
that is initialized on zero. The index to the map is computed for each
combination of group values (c,b) as c*CARD\_C + b. As an optimization,
we take POW\_C which is the smallest power of 2 $>=$ CARD\_C, so the 
multiplication can be implemented as a shift (LOG\_C to the right).

If the map entry is 0, this is a new group. Group members are collected in 
a histogram BAT $=>$ at the same moment we also collect the counts for
each group. This enables us to create the result directly as an
enumerated type. The histogram BAT serves as the lookup table for
this enumerated type.

nils are not handled properly $=>$ they are treated as normal values
(FUTURE: we might want to have group(nil,X) = group(Y,nil) = nil).

@= enumgroup
{	BAT *bn, *histo = BATnew(TYPE_oid, TYPE_int, pow_c*card_b);
	int new_enum_tpe, histo_entry = 0;
	oid baseoid = b->hseqbase, lastoid = baseoid + BATcount(b);
	char buf[128];

	unsigned @1 *cp = (unsigned @1*) BUNtloc(ct,BUNfirst(ct)); 
	unsigned @2 *bp = (unsigned @2*) BUNtloc(b,BUNfirst(b)); 
	unsigned @3 *map = (unsigned @3*) GDKmalloc(pow_c*card_b*sizeof(@3));
	unsigned @3 *rp;
	oid curoid;
	histo_t* base = (histo_t*) histo->batHole;

	/* preparation: create an histogram and use it as maptable of a new 
         * enumtype. Create 'bn' result BAT with  this tailtype and dense head.
         */	
	histo->batBuns->free += BUNsize(histo)*pow_c*card_b;
	sprintf(buf, "enum_%d", (int) histo->batCacheid);
	BBPrename(histo->batCacheid, buf);	
	enum_load(&new_enum_tpe, histo);
	*res = bn = BATnew(TYPE_void, new_enum_tpe, BATcount(b));
	BATseqbase(bn, baseoid);
	rp = (unsigned @3*) BUNfirst(bn);
	memset(map, 0, pow_c*card_b*sizeof(@3));

	/* the core of the algorithm */
	for(curoid=baseoid; curoid<lastoid; curoid++) {
		unsigned @3* map_ptr = map + ((*bp << log_c) | *cp);
		unsigned int grp_idx = *map_ptr; 

		if (grp_idx == 0) {
			*rp = histo_entry;
			*map_ptr = ++histo_entry; 
			base[histo_entry].val = curoid;
			base[histo_entry].cnt = 1;
		} else {
			base[grp_idx].cnt++; 
			*rp = grp_idx - 1;
		}
		cp ++; bp ++; rp++;
	}

	/* aftermath: free space and set correct boundaries on created BATs */ 
	GDKfree(map);
	histo->batBuns->free -= BUNsize(histo)*(pow_c*card_b - histo_entry);
	bn->batBuns->free += sizeof(@3)*BATcount(b);
	histo->tsorted = bn->tsorted = 0;
	enum_sethisto(&new_enum_tpe, BATmirror(bn));
}

@+ fetch-joins on enumerated oids.
@c
@:enum_fetch(enum_join,t)@
@:enum_fetch(enum_semijoin,h)@

@= enum_fetch
int @1( BAT** res, BAT* b1, BAT* b2){
	BAT *map, *bn = BATnew(TYPE_oid, b1->ttype, BATcount(b2));
	ssize_t off1;
	size_t off2;
	int xx = b2->htype;
	BUN p, q;

	if (!BAT@2dense(b1)) {
		GDKerror("@1: first param not BAT@2dense.\n");
		return GDK_FAIL;
	}	
	if ((!enum_table(&map, (int*) &xx)) || map->htype != TYPE_oid) {
		GDKerror("@1: head of second BAT should be enumerated oid.\n");
		return GDK_FAIL;
	}
	off1 = (ssize_t) (BUNindex(b1, BUNfirst(b1)) - b1->hseqbase);
	off2 = BUNindex(map, BUNfirst(map));
	if (ATOMsize(b2->htype) == 1) {
		@:@1(char)@
	} else if (ATOMsize(b2->htype) == 2) {
		@:@1(short)@
	}
	*res = bn;
	return GDK_SUCCEED;
}

@= enum_join
	BATloopFast(b2, p, q, xx) {
		unsigned @1 *cur = (unsigned @1*) BUNtloc(b2,p);
		oid *o = (oid*) BUNhloc(map, BUNptr(map, off2 + *cur));
		BUN r = BUNptr(b1, off1 + *o);
		BUNfastins(bn, BUNhead(b1,r), BUNtail(b2,p));
	}
	bn->hsorted = (BAThordered(b2)&BAThordered(map)&1)?BAThordered(b1):0;
	bn->tsorted = BATtordered(b2);
@= enum_semijoin
	BATloopFast(b2, p, q, xx) {
		unsigned @1 *cur = (unsigned @1*) BUNhloc(b2,p);
		oid *o = (oid*) BUNhloc(map, BUNptr(map, off2 + *cur));
		BUN r = BUNptr(b1, off1 + *o);
		BUNfastins(bn, o, BUNtail(b1,r));
	}
	bn->hsorted = BAThordered(map)?BAThordered(b2):0;
	bn->tsorted = (BAThordered(b2)&BAThordered(map)&1)?BATtordered(b1):0;

@+ Bitvector Equi-Select and Range-Select 
Here we use the fact that memory on modern hardware is fetched (at least)
by the 32-bits. So when selecting on 1-byte dense arrays, we can process
4 bytes at a time (2 for 2-byte arrays). Big endian hardware causes
some headaches here as the bytes appear out of order. The shift
direction is also inverse. All that is handled by the below macros:
@c
#ifndef WORDS_BIGENDIAN
#define SHIFT(x,b)	 x <<= b

#define CHR01 0x00000001
#define CHR02 0x00000002
#define CHR03 0x00000004
#define CHR04 0x00000008
#define CHR05 0x00000010
#define CHR06 0x00000020
#define CHR07 0x00000040
#define CHR08 0x00000080
#define CHR09 0x00000100
#define CHR10 0x00000200
#define CHR11 0x00000400
#define CHR12 0x00000800
#define CHR13 0x00001000
#define CHR14 0x00002000
#define CHR15 0x00004000
#define CHR16 0x00008000
#define CHR17 0x00010000
#define CHR18 0x00020000
#define CHR19 0x00040000
#define CHR20 0x00080000
#define CHR21 0x00100000
#define CHR22 0x00200000
#define CHR23 0x00400000
#define CHR24 0x00800000
#define CHR25 0x01000000
#define CHR26 0x02000000
#define CHR27 0x04000000
#define CHR28 0x08000000
#define CHR29 0x10000000
#define CHR30 0x20000000
#define CHR31 0x40000000
#define CHR32 0x80000000

#define SHT01 0x00000001
#define SHT02 0x00000002
#define SHT03 0x00000004
#define SHT04 0x00000008
#define SHT05 0x00000010
#define SHT06 0x00000020
#define SHT07 0x00000040
#define SHT08 0x00000080
#define SHT09 0x00000100
#define SHT10 0x00000200
#define SHT11 0x00000400
#define SHT12 0x00000800
#define SHT13 0x00001000
#define SHT14 0x00002000
#define SHT15 0x00004000
#define SHT16 0x00008000
#define SHT17 0x00010000
#define SHT18 0x00020000
#define SHT19 0x00040000
#define SHT20 0x00080000
#define SHT21 0x00100000
#define SHT22 0x00200000
#define SHT23 0x00400000
#define SHT24 0x00800000
#define SHT25 0x01000000
#define SHT26 0x02000000
#define SHT27 0x04000000
#define SHT28 0x08000000
#define SHT29 0x10000000
#define SHT30 0x20000000
#define SHT31 0x40000000
#define SHT32 0x80000000
#else
#define SHIFT(x,b)	 x >>= b

#define CHR01 0x00000008
#define CHR02 0x00000004
#define CHR03 0x00000002
#define CHR04 0x00000001
#define CHR05 0x00000080
#define CHR06 0x00000040
#define CHR07 0x00000020
#define CHR08 0x00000010
#define CHR09 0x00000800
#define CHR10 0x00000400
#define CHR11 0x00000200
#define CHR12 0x00000100
#define CHR13 0x00008000
#define CHR14 0x00004000
#define CHR15 0x00002000
#define CHR16 0x00001000
#define CHR17 0x00080000
#define CHR18 0x00040000
#define CHR19 0x00020000
#define CHR20 0x00010000
#define CHR21 0x00800000
#define CHR22 0x00400000
#define CHR23 0x00200000
#define CHR24 0x00100000
#define CHR25 0x08000000
#define CHR26 0x04000000
#define CHR27 0x02000000
#define CHR28 0x01000000
#define CHR29 0x80000000
#define CHR30 0x40000000
#define CHR31 0x20000000
#define CHR32 0x10000000

#define SHT01 0x00000002
#define SHT02 0x00000001
#define SHT03 0x00000008
#define SHT04 0x00000004
#define SHT05 0x00000020
#define SHT06 0x00000010
#define SHT07 0x00000080
#define SHT08 0x00000040
#define SHT09 0x00000200
#define SHT10 0x00000100
#define SHT11 0x00000800
#define SHT12 0x00000400
#define SHT13 0x00002000
#define SHT14 0x00001000
#define SHT15 0x00008000
#define SHT16 0x00004000
#define SHT17 0x00020000
#define SHT18 0x00010000
#define SHT19 0x00080000
#define SHT20 0x00040000
#define SHT21 0x00200000
#define SHT22 0x00100000
#define SHT23 0x00800000
#define SHT24 0x00400000
#define SHT25 0x02000000
#define SHT26 0x01000000
#define SHT27 0x08000000
#define SHT28 0x04000000
#define SHT29 0x20000000
#define SHT30 0x10000000
#define SHT31 0x80000000
#define SHT32 0x40000000
#endif

#define NEXTrefine	submask = *(sub++);
#define NEXTnormal

#define multiplex 	for(i=0;i<argc;i++)

/* COMMAND 
 * do a range-scan equiselect, but output the result as a bitmask, paritioned
 * in 32-bits integers. The head-oids are densly incremental from from 0@0
 */
int
val_bitselect(BAT **res, BAT *b, ptr v)
{
	int *dst, val;
	BAT *bn = BATnew(TYPE_void, TYPE_bit32, 1 + BATcount(b) / 32);
	int vector = 0;

	@:bitselect(normal,val)@

	*res = bn;
	return GDK_SUCCEED;
}

@c
/* COMMAND 
 * do a range-scan rangeselect, but output the result as a bitmask, paritioned
 * in 32-bits integers. The head-oids are densly incremental from from 0@0
 */
int
rng_bitselect(BAT **res, BAT *b, ptr lo, ptr hi)
{
	int *dst, low, high;
	BAT *bn = BATnew(TYPE_void, TYPE_bit32, 1 + BATcount(b) / 32);
	int vector = 0;

	@:bitselect(normal,rng)@

	*res = bn;
	return GDK_SUCCEED;
}


/* COMMAND 
 * do a bitselect on the subset indicated by the first BAT param
 */
int
val_bitsubsel(BAT **res, BAT *sel, BAT *b, ptr v)
{
	int *sub = (int *) BUNfirst(sel);
	int *dst, val, submask;
	BAT *bn = BATnew(TYPE_void, TYPE_bit32, 1 + BATcount(b) / 32);
	int vector = 0;

	@:check_bitsel(val_bitsubsel,sel,b,BATcount(b))@
	bn = BATnew(TYPE_void, TYPE_bit32, 1 + BATcount(b) / 32);
	@:bitselect(refine,val)@

	*res = bn;
	return GDK_SUCCEED;
}

/* COMMAND 
 * do a bitselect on the subset indicated by the first BAT param
 */
int
rng_bitsubsel(BAT **res, BAT *sel, BAT *b, ptr lo, ptr hi)
{
	int *sub = (int *) BUNfirst(sel);
	int *dst, low, high, submask;
	int vector = 0;
	BAT *bn;

	@:check_bitsel(rng_bitsubsel,sel,b,BATcount(b))@
	bn = BATnew(TYPE_void, TYPE_bit32, 1 + BATcount(b) / 32);
	@:bitselect(refine,rng)@

	*res = bn;
	return GDK_SUCCEED;
}

/* COMMAND 
 * do a bitselect on the subset indicated by the first BAT param
 */
int
val_bitrefine(BAT **res, BAT *sel, BAT *b, ptr v)
{
	int *sub = (int *) BUNfirst(sel);
	int *dst, val, submask;
	BAT *bn = sel;
	int vector = 0;

	ALIGNdel(sel, "val_oidrefine");
	@:check_bitsel(val_bitrefine,sel,b,BATcount(b))@
	@:bitselect(refine,val)@

	*res = bn;
	return GDK_SUCCEED;
}

/* COMMAND 
 * do a bitselect on the subset indicated by the first BAT param
 */
int
rng_bitrefine(BAT **res, BAT *sel, BAT *b, ptr lo, ptr hi)
{
	int *sub = (int *) BUNfirst(sel);
	int *dst, low, high, submask;
	BAT *bn = sel;
	int vector = 0;

	ALIGNdel(sel, "val_oidrefine");
	@:check_bitsel(rng_bitrefine,sel,b,BATcount(b))@
	@:bitselect(refine,rng)@

	*res = bn;
	return GDK_SUCCEED;
}

/* COMMAND 
 * do a range-scan equiselect, but output the result as a bitmask, 
 * partitioned  in 32-bits integers. 
 */
int
vals_bitselect(BAT **res, BAT *b, ...)
{
	int *v[MAXPARAMS], val[MAXPARAMS];
	int vector[MAXPARAMS], *dst[MAXPARAMS], i, argc;
	BAT *bn[MAXPARAMS];
	va_list ap;

	va_start(ap, b);
	for (argc = 0; TRUE; argc++) {
		v[argc] = va_arg(ap, int *);

		if (v[argc] == NULL)
			break;
		bn[argc] = BATnew(TYPE_void, TYPE_bit32, 1 + BATcount(b) / 32);
		vector[argc] = 0;
	}
	va_end(ap);

	@:bitselect(normal,val,multiplex,[i])@

	*res = BATnew(TYPE_int, TYPE_bat, argc);
	for (i = 0; i < argc; i++)
		BUNins(*res, &i, &bn[i]->batCacheid);
	return GDK_SUCCEED;
}

/* COMMAND 
 * do a range-scan rangeselect, but output the result as a bitmask, 
 * partitioned in 32-bits integers.
 */
int
rngs_bitselect(BAT **res, BAT *b, ...)
{
	int *lo[MAXPARAMS], *hi[MAXPARAMS], low[MAXPARAMS], high[MAXPARAMS];
	int *dst[MAXPARAMS], vector[MAXPARAMS], i, argc;
	BAT *bn[MAXPARAMS];
	va_list ap;

	va_start(ap, b);
	for (argc = 0; TRUE; argc++) {
		lo[argc] = va_arg(ap, int *);

		if (lo[argc] == NULL)
			break;
		hi[argc] = va_arg(ap, int *);

		bn[argc] = BATnew(TYPE_void, TYPE_bit32, 1 + BATcount(b) / 32);
		vector[argc] = 0;
	}
	va_end(ap);

	@:bitselect(normal,rng,multiplex,[i])@

	*res = BATnew(TYPE_int, TYPE_bat, argc);
	for (i = 0; i < argc; i++)
		BUNins(*res, &i, &bn[i]->batCacheid);
	return GDK_SUCCEED;
}


@- optimized bit32 select/refine implementations
@T
The creation of the destination submask, of which each integer
contains 32 answers (yes or no selected) is sped up by loop
unrolling these 32 tests. If the attribute type being
examined is chr, this converts 4 character memory reads
into 1 integer read plus 3 shifts and ANDs. It also avoids
shifting the test-mask and checking wheter its bit should cross
from left to right (bit 31 shifts into bit 0). Finally, it 
streamlines the result collection, which comes down to 1 integer 
memory write per 32 processed tuples.

The 32-tuple-at-a-time optimization is made only when the
head column is void and the attribute type is either a 1-byte 
or 2-byte intege. If not, a generic ADT-call interface is used.
This loop is also used to process remaining tuples that did not 
fit into a 32-at-a-time roundup.

This select may be done either on all tuples, or as a subselection 
on an already existing bitmask. This is controlled with the 
first parameter:
\begin{itemize}
\item sel: select on all values
\item sub: refine using the already existing mask 'sel'
\end{itemize}

The second parameter to the 'bitselect' macro is:
\begin{itemize}
\item val: equi-select on a single value 'v'
\item rng: range-select between 'lo' and 'hi'
\end{itemize}

The third and fourth parameters are optional. In the
standard cases they are empty. In the case in which multiple
results should be computed in one scan, the third parameter is 
the multiplier-statement {\small\tt for(i=0;i$<$argc;i++)} and 
the fourth param is the array-index operator({\small\tt \[i\]}).

@= bitselect
{	BUN p = BUNfirst(b), q = BUNlast(b);
	GDKfcn cmp = BATatoms[b->ttype].atomCmp;
	int mask = 1, xx = BUNsize(b);
	oid stamp;

	@3 {
		dst@4 = (int*) BUNfirst(bn@4);
		vector@4 = 0;
	}

	/* optimized versions are only tried if there is no head column to care
           about and the start of the values in the BAT is integer-aligned */
	if (BUNsize(b) == ATOMsize(b->ttype) && (((size_t) p)&3) == 0) {
		if (ATOMstorage(b->ttype) == TYPE_chr) {
			int *src = (int*) p;
			/* treat 32 tuples = 32 (=2^5) bytes per iteration */
			int *end = src + (((q-p) >> 5) << 3); 

			@3 @:INIT@2(unsigned char,@4)@

			while(src < end) {
				/* silly code spelled out to make SPARC feel good */
				int cur = src[0];
				NEXT@1
				@3 @:BIT@1(TST@2,cur&255,CHR01,@4)@ SHIFT(cur,8); 
				@3 @:BIT@1(TST@2,cur&255,CHR02,@4)@ SHIFT(cur,8); 
				@3 @:BIT@1(TST@2,cur&255,CHR03,@4)@ SHIFT(cur,8); 
				@3 @:BIT@1(TST@2,cur,    CHR04,@4)@ cur = src[1]; 
				@3 @:BIT@1(TST@2,cur&255,CHR05,@4)@ SHIFT(cur,8); 
				@3 @:BIT@1(TST@2,cur&255,CHR06,@4)@ SHIFT(cur,8); 
				@3 @:BIT@1(TST@2,cur&255,CHR07,@4)@ SHIFT(cur,8); 
				@3 @:BIT@1(TST@2,cur,    CHR08,@4)@ cur = src[2]; 
				@3 @:BIT@1(TST@2,cur&255,CHR09,@4)@ SHIFT(cur,8); 
				@3 @:BIT@1(TST@2,cur&255,CHR10,@4)@ SHIFT(cur,8); 
				@3 @:BIT@1(TST@2,cur&255,CHR11,@4)@ SHIFT(cur,8); 
				@3 @:BIT@1(TST@2,cur,    CHR12,@4)@ cur = src[3]; 
				@3 @:BIT@1(TST@2,cur&255,CHR13,@4)@ SHIFT(cur,8); 
				@3 @:BIT@1(TST@2,cur&255,CHR14,@4)@ SHIFT(cur,8); 
				@3 @:BIT@1(TST@2,cur&255,CHR15,@4)@ SHIFT(cur,8); 
				@3 @:BIT@1(TST@2,cur,    CHR16,@4)@ cur = src[4]; 
				@3 @:BIT@1(TST@2,cur&255,CHR17,@4)@ SHIFT(cur,8); 
				@3 @:BIT@1(TST@2,cur&255,CHR18,@4)@ SHIFT(cur,8); 
				@3 @:BIT@1(TST@2,cur&255,CHR19,@4)@ SHIFT(cur,8); 
				@3 @:BIT@1(TST@2,cur,    CHR20,@4)@ cur = src[5]; 
				@3 @:BIT@1(TST@2,cur&255,CHR21,@4)@ SHIFT(cur,8); 
				@3 @:BIT@1(TST@2,cur&255,CHR22,@4)@ SHIFT(cur,8); 
				@3 @:BIT@1(TST@2,cur&255,CHR23,@4)@ SHIFT(cur,8); 
				@3 @:BIT@1(TST@2,cur,    CHR24,@4)@ cur = src[6]; 
				@3 @:BIT@1(TST@2,cur&255,CHR25,@4)@ SHIFT(cur,8); 
				@3 @:BIT@1(TST@2,cur&255,CHR26,@4)@ SHIFT(cur,8); 
				@3 @:BIT@1(TST@2,cur&255,CHR27,@4)@ SHIFT(cur,8); 
				@3 @:BIT@1(TST@2,cur,    CHR28,@4)@ cur = src[7]; 
				@3 @:BIT@1(TST@2,cur&255,CHR29,@4)@ SHIFT(cur,8); 
				@3 @:BIT@1(TST@2,cur&255,CHR30,@4)@ SHIFT(cur,8); 
				@3 @:BIT@1(TST@2,cur&255,CHR31,@4)@ SHIFT(cur,8); 
				@3 @:BIT@1(TST@2,cur,    CHR32,@4)@ src += 8;
				@3 { *dst@4++ = vector@4; vector@4 = 0; } 
			}
			p = (BUN) end;
		} else if (ATOMstorage(b->ttype) == TYPE_sht) {
			int *src = (int*) p;
			/* treat 32 tuples = 32*2 = 64 (=2^6) bytes per iteration */
			int *end = src + (((q-p) >> 6) << 4);

			@3 @:INIT@2(unsigned short,@4)@

			while(src < end) {
				int cur = src[0];
				/* silly code spelled out to make SPARC feel good */
				NEXT@1
				@3 @:BIT@1(TST@2,cur&65535,SHT01,@4)@ SHIFT(cur,16); 
				@3 @:BIT@1(TST@2,cur,      SHT02,@4)@ cur = src[1];
				@3 @:BIT@1(TST@2,cur&65535,SHT03,@4)@ SHIFT(cur,16); 
				@3 @:BIT@1(TST@2,cur,      SHT04,@4)@ cur = src[2];
				@3 @:BIT@1(TST@2,cur&65535,SHT05,@4)@ SHIFT(cur,16); 
				@3 @:BIT@1(TST@2,cur,      SHT06,@4)@ cur = src[3];
				@3 @:BIT@1(TST@2,cur&65535,SHT07,@4)@ SHIFT(cur,16); 
				@3 @:BIT@1(TST@2,cur,      SHT08,@4)@ cur = src[4];
				@3 @:BIT@1(TST@2,cur&65535,SHT09,@4)@ SHIFT(cur,16); 
				@3 @:BIT@1(TST@2,cur,      SHT10,@4)@ cur = src[5];
				@3 @:BIT@1(TST@2,cur&65535,SHT11,@4)@ SHIFT(cur,16); 
				@3 @:BIT@1(TST@2,cur,      SHT12,@4)@ cur = src[6];
				@3 @:BIT@1(TST@2,cur&65535,SHT13,@4)@ SHIFT(cur,16); 
				@3 @:BIT@1(TST@2,cur,      SHT14,@4)@ cur = src[7];
				@3 @:BIT@1(TST@2,cur&65535,SHT15,@4)@ SHIFT(cur,16); 
				@3 @:BIT@1(TST@2,cur,      SHT16,@4)@ cur = src[8];
				@3 @:BIT@1(TST@2,cur&65535,SHT17,@4)@ SHIFT(cur,16); 
				@3 @:BIT@1(TST@2,cur,      SHT18,@4)@ cur = src[9];
				@3 @:BIT@1(TST@2,cur&65535,SHT19,@4)@ SHIFT(cur,16); 
				@3 @:BIT@1(TST@2,cur,      SHT20,@4)@ cur = src[10];
				@3 @:BIT@1(TST@2,cur&65535,SHT21,@4)@ SHIFT(cur,16); 
				@3 @:BIT@1(TST@2,cur,      SHT22,@4)@ cur = src[11];
				@3 @:BIT@1(TST@2,cur&65535,SHT23,@4)@ SHIFT(cur,16); 
				@3 @:BIT@1(TST@2,cur,      SHT24,@4)@ cur = src[12];
				@3 @:BIT@1(TST@2,cur&65535,SHT25,@4)@ SHIFT(cur,16); 
				@3 @:BIT@1(TST@2,cur,      SHT26,@4)@ cur = src[13];
				@3 @:BIT@1(TST@2,cur&65535,SHT27,@4)@ SHIFT(cur,16); 
				@3 @:BIT@1(TST@2,cur,      SHT28,@4)@ cur = src[14];
				@3 @:BIT@1(TST@2,cur&65535,SHT29,@4)@ SHIFT(cur,16); 
				@3 @:BIT@1(TST@2,cur,      SHT30,@4)@ cur = src[15];
				@3 @:BIT@1(TST@2,cur&65535,SHT31,@4)@ SHIFT(cur,16); 
				@3 @:BIT@1(TST@2,cur,      SHT32,@4)@ src += 16;
				@3 { *dst@4++ = vector@4; vector@4 = 0; } 
			}
			p = (BUN) end;
		}
	}

	/* process any tuples left with a slower (generic) implementation */
	@3 {
		bn@4->batBuns->free = ((char*) dst@4) - bn@4->batBuns->base; 
		bn@4->tsorted = 0;
		bn@4->batDirty = 1;
	}
	if (p < q) {
	    NEXT@1
	    while(p < q) {
		@3 @:BIT@1(CALL@2,BUNtail(b,p),mask,@4)@
		mask <<= 1; 
		if (mask == 0) {
			@3 {
				BUNfastins(bn@4, NULL, &vector@4);
				vector@4=0; 
				NEXT@1
			} mask = 1; 
		}
		p += xx;
  	    }
	}   
	if (mask != 1) {
		@3 BUNfastins(bn@4, NULL, &vector@4);
	}
	/* we put a stamp in the seqbase of the result. This stamp
         * relates the selection to the BAT from which it was derived. 
	 */
	if (BAThdense(b)) {
		stamp = b->hseqbase;
	} else {
		if (b->halign == 0) {
			b->halign = OIDnew(1);
			b->batDirtydesc = TRUE;
		}
		stamp = b->halign;
	}

        /* The size (in bits) of the bitvector is stored in the 
         * halign -- incremented with 1 to avoid the 0 value 
	 */
	@3 {
		bn@4->halign = 1 + BATcount(b);
		BATseqbase(bn@4, stamp);
	}
}
@= BITnormal
	if (@:@1(@2,@4)@) vector@4 |= @3;
@= BITrefine
	if (submask&@3 && @:@1(@2,@4)@) vector@4 |= @3;
@= INITval
	val@2 = *(@1*) (v@2);
@= INITrng
	{ low@2 = *(@1*) (lo@2); high@2 = *(@1*) (hi@2); }
@= TSTval
	(@1) == val@2
@= TSTrng
        (@1) >= low@2 && (@1) <= high@2
@= CALLval
	(*cmp)(@1, v@2) == 0
@= CALLrng
	(*cmp)(@1, lo@2) >= 0 && (*cmp)(@1,hi@2) <= 0

@+ OID (Sub)Selections
@c
/* COMMAND 
 * do a equi-select
 */
int
val_oidselect(BAT **res, BAT *b, ptr v)
{
	oid *dst, *last = 0;
	int val;
	BAT *bn;

	(void) last;
	@:oidselect(val)@

	*res = bn;
	return GDK_SUCCEED;
}

@c
/* COMMAND 
 * do a range-select
 */
int
rng_oidselect(BAT **res, BAT *b, ptr lo, ptr hi)
{
	oid *dst, *last = 0;
	int low, high;
	BAT *bn;

	(void) last;
	@:oidselect(rng)@

	*res = bn;
	return GDK_SUCCEED;
}


/* COMMAND 
 * do a equi-select on multiple values, yielding multiple BAT results.
 */
int
vals_oidselect(BAT **res, BAT *b, ...)
{
	int *v[MAXPARAMS], val[MAXPARAMS], i, argc;
	oid *dst[MAXPARAMS], *last[MAXPARAMS];
	BAT *bn[MAXPARAMS];
	va_list ap;

	va_start(ap, b);
	last[0] = 0;
	(void) last[0];
	for (argc = 0; TRUE; argc++) {
		v[argc] = va_arg(ap, int *);

		if (v[argc] == NULL)
			break;
	}
	va_end(ap);
	@:oidselect(val,multiplex,[i])@

	*res = BATnew(TYPE_int, TYPE_bat, argc);
	for (i = 0; i < argc; i++)
		BUNins(*res, &i, &bn[i]->batCacheid);
	return GDK_SUCCEED;
}

/* COMMAND 
 * do a range-select on multiple range predicates yielding multiple BAT results.
 */
int
rngs_oidselect(BAT **res, BAT *b, ...)
{
	int *lo[MAXPARAMS], *hi[MAXPARAMS], low[MAXPARAMS], high[MAXPARAMS];
	oid *dst[MAXPARAMS], *last[MAXPARAMS];
	BAT *bn[MAXPARAMS];
	int i, argc;
	va_list ap;

	va_start(ap, b);
	last[0] = 0;
	(void) last[0];
	for (argc = 0; TRUE; argc++) {
		lo[argc] = va_arg(ap, int *);

		if (lo[argc] == NULL)
			break;
		hi[argc] = va_arg(ap, int *);
	}
	va_end(ap);

	@:oidselect(rng,multiplex,[i])@

	*res = BATnew(TYPE_int, TYPE_bat, argc);
	for (i = 0; i < argc; i++)
		BUNins(*res, &i, &bn[i]->batCacheid);
	return GDK_SUCCEED;
}

@- optimized oid-select implementation

@= oidselect
{	int tpe=b->ttype;
	BAT *map;

	if (!enum_chktpe(b->ttype)) {
		GDKerror("oidselect: attribute tail column is not enum.\n");
		return GDK_FAIL;
	}
	enum_table(&map, &tpe);
	/* if (BUNsize(b) == ATOMsize(b->ttype)) { 
		if (ATOMstorage(b->ttype) == TYPE_chr) {
			@:oidsel(@1,@2,@3,char,1)@
		} else if (ATOMstorage(b->ttype) == TYPE_sht) {
			@:oidsel(@1,@2,@3,short,2)@
		}
	} else */ if (BAThdense(b) && ATOMstorage(b->ttype) == TYPE_chr) {
		int bs = BUNsize(b);
		@:oidsel(@1,@2,@3,char,bs)@
	} else if (BAThdense(b) && ATOMstorage(b->ttype) == TYPE_sht) {
		int bs = BUNsize(b);
		@:oidsel(@1,@2,@3,short,bs)@
	} else {
		GDKerror("oidselect: case nyi.\n");
		return GDK_FAIL;
	}
}

@= oidsel
	BUN cur = BUNtloc(b,BUNfirst(b));
	BUN end = BUNtloc(b,BUNlast(b));

	oid o = b->hseqbase;
	@2 {	
		size_t size_estimate = @:@1_estimate(@4,@3)@;
		bn@3 = BATnew(TYPE_oid,TYPE_void,size_estimate);
		dst@3 = (oid*) BUNfirst(bn@3);
		last@3 = (oid*) (bn@3->batBuns->base + bn@3->batBuns->size);
	}
	@2 @:INIT@1(unsigned @4,@3)@

#if (defined(IRIX) && SIZEOF_LONG==8 && !defined (__GNUC__))
	@:prefetch@2(@1,@4,@5)@
#endif
	while(cur < end) {
		@2 if (@:TST@1(*(unsigned @4*) cur,@3)@) {
			*(dst@3++) = o;
		} cur += @5; o++;
	}
	@2 {
		bn@3->batBuns->free = ((char*) dst@3) - bn@3->batBuns->base;
		bn@3->hkey = BATmirror(bn@3)->tkey = b->hkey;
		bn@3->hsorted = BAThordered(b) && ((GDKdebug&786432)==0);
		bn@3->batDirty = 1;
	}

@= prefetch_select
#pragma ivdep 
	while(cur < end) {
#pragma prefetch_ref=cur[@4],stride=@5,kind=rd,size=4
		if (@:TST@1(*(unsigned @2*) cur)@) {
			*(dst++) = o;
		} cur += @3; o++;
	}
@= prefetchmultiplex
@= prefetch
if (@3 < 128 && GDKdebug&1048576)
if ((GDKdebug&786432)==262144) {
	int d0 = @3*32;
	BUN endK = end - 2*d0;
	while(cur < endK) {
	    oid ol = o+32;
#pragma ivdep 
#pragma prefetch_ref=cur[128],stride=32,kind=rd,size=4
#pragma prefetch_ref=cur[d0+128],stride=32,kind=rd,size=4
	    while(o < ol) {
		int t0 = (@:TST@1(*(unsigned @2*)(cur+0))@);
		int t1 = (@:TST@1(*(unsigned @2*)(cur+d0))@);
		if (t0) *(dst++) = o;
		if (t1) *(dst++) = o+32;
		cur += @3; o++;
	    }
	    cur += d0; o += 32;
	}
} else if ((GDKdebug&786432)==524288) {
	int d0 = @3*32, d1=d0+d0, d2=d1+d0;
	BUN endK = end - 4*d0;
	while(cur < endK) {
	    oid ol = o+32;
#pragma ivdep 
#pragma prefetch_ref=cur[128],stride=32,kind=rd,size=4
#pragma prefetch_ref=cur[d0+128],stride=32,kind=rd,size=4
#pragma prefetch_ref=cur[d1+128],stride=32,kind=rd,size=4
#pragma prefetch_ref=cur[d2+128],stride=32,kind=rd,size=4
	    while(o < ol) {
		int t0 = (@:TST@1(*(unsigned @2*)(cur+0))@);
		int t1 = (@:TST@1(*(unsigned @2*)(cur+d0))@);
		int t2 = (@:TST@1(*(unsigned @2*)(cur+d1))@);
		int t3 = (@:TST@1(*(unsigned @2*)(cur+d2))@);
		if (t0) *(dst++) = o;
		if (t1) *(dst++) = o+32;
		if (t2) *(dst++) = o+64;
		if (t3) *(dst++) = o+96;
		cur += @3; o++;
	    }
	    cur += d2; o += 128;
	}
} else if ((GDKdebug&786432)==786432) {
	int d0 = @3*32, d1=d0+d0, d2=d1+d0, d3=d2+d0, d4=d3+d0;
	BUN endK = end - 6*d0;
	while(cur < endK) {
	    oid ol = o+32;
#pragma ivdep 
#pragma prefetch_ref=cur[128],stride=32,kind=rd,size=4
#pragma prefetch_ref=cur[d0+128],stride=32,kind=rd,size=4
#pragma prefetch_ref=cur[d1+128],stride=32,kind=rd,size=4
#pragma prefetch_ref=cur[d2+128],stride=32,kind=rd,size=4
#pragma prefetch_ref=cur[d3+128],stride=32,kind=rd,size=4
#pragma prefetch_ref=cur[d4+128],stride=32,kind=rd,size=4
	    while(o < ol) {
		int t0 = (@:TST@1(*(unsigned @2*)(cur+0))@);
		int t1 = (@:TST@1(*(unsigned @2*)(cur+d0))@);
		int t2 = (@:TST@1(*(unsigned @2*)(cur+d1))@);
		int t3 = (@:TST@1(*(unsigned @2*)(cur+d2))@);
		int t4 = (@:TST@1(*(unsigned @2*)(cur+d3))@);
		int t5 = (@:TST@1(*(unsigned @2*)(cur+d4))@);
		if (t0) *(dst++) = o;
		if (t1) *(dst++) = o+32;
		if (t2) *(dst++) = o+64;
		if (t3) *(dst++) = o+96;
		if (t4) *(dst++) = o+128;
		if (t5) *(dst++) = o+160;
		cur += @3; o++;
	    } 
	    cur += d4; o += 160;
	}
} else if (@3 >= 64) { 
	@:prefetch_select(@1,@2,@3,256,1)@
} else if (@3 >= 32) { 
	@:prefetch_select(@1,@2,@3,128,1)@
} else if (@3 >= 16) { 
	@:prefetch_select(@1,@2,@3,128,2)@
} else if (@3 >= 8) { 
	@:prefetch_select(@1,@2,@3,128,4)@
} else if (@3 >= 4) { 
	@:prefetch_select(@1,@2,@3,128,8)@
} else if (@3 >= 2) { 
	@:prefetch_select(@1,@2,@3,128,16)@
} else {  
	@:prefetch_select(@1,@2,@3,128,32)@
}

@= checkdstFALSE
@= checkdstTRUE
	if (dst@1 >= last@1) {
		ssize_t off = ((char*) dst@1) - BUNfirst(bn@1);
		bn@1->batBuns->free = bn@1->batBuns->size;
		if (BATextend(bn@1, BATgrows(bn@1)) == NULL) {
			BBPreclaim(bn);
			return GDK_FAIL; 
		}
		dst@1 = (oid*) (BUNfirst(bn@1) + off);
		last@1 = (oid*) (bn@1->batBuns->base + bn@1->batBuns->size);
	}

@c
/* COMMAND 
 * do a bitselect on the subset indicated by the first BAT param
 */
int
val_oidsubsel(BAT **res, BAT *sel, BAT *b, ptr v)
{
	oid *dst = NULL, *last;
	int val;
	BAT *bn = NULL;

	@:check_oidsel(val_oidrefine,sel)@
	@:oidrefine(val,TRUE)@

	*res = bn;
	return GDK_SUCCEED;
}

/* COMMAND 
 * do a bitselect on the subset indicated by the first BAT param
 */
int
rng_oidsubsel(BAT **res, BAT *sel, BAT *b, ptr lo, ptr hi)
{
	int low, high;
	oid *dst = NULL, *last;
	BAT *bn = NULL;

	@:check_oidsel(rng_oidrefine,sel)@
	@:oidrefine(rng,TRUE)@

	*res = bn;
	return GDK_SUCCEED;
}

/* COMMAND 
 * do a bitselect on the subset indicated by the first BAT param
 */
int
val_oidrefine(BAT **res, BAT *sel, BAT *b, ptr v)
{
	oid *dst = NULL, *last = 0;
	int val;
	BAT *bn = NULL;

	(void) last;
	ALIGNdel(sel, "val_oidrefine");
	@:check_oidsel(val_oidrefine,sel)@
	@:oidrefine(val,FALSE)@

	*res = bn;
	return GDK_SUCCEED;
}

/* COMMAND 
 * do a bitselect on the subset indicated by the first BAT param
 */
int
rng_oidrefine(BAT **res, BAT *sel, BAT *b, ptr lo, ptr hi)
{
	int low, high;
	oid *dst = NULL, *last = 0;
	BAT *bn = NULL;

	(void) last;
	ALIGNdel(sel, "val_oidrefine");
	@:check_oidsel(rng_oidrefine,sel)@
	@:oidrefine(rng,FALSE)@

	*res = bn;
	return GDK_SUCCEED;
}


@- optimized oid-refine implementation

@= oidrefine
{	oid *cur = (oid*) BUNfirst(sel);
	oid *end = (oid*) BUNlast(sel);
	oid base = b->hseqbase;
	int tpe=b->ttype;
	BAT *map;

	@:check_oidsel(subsel_oid,sel)@
	@:check_enumbat(subsel_oid,b)@
	enum_table(&map, &tpe);

	if (ATOMstorage(b->ttype) == TYPE_chr) {
		@:oidref(@1,@2,char)@
	} else if (ATOMstorage(b->ttype) == TYPE_sht) {
		@:oidref(@1,@2,short)@
	}
	bn->batBuns->free = ((char*) dst) - bn->batBuns->base;
	bn->hsorted = BAThordered(b) && BAThordered(sel);
	bn->hkey = BATmirror(bn)->tkey = b->hkey && sel->hkey;
	bn->batDirty = 1;
}
@= oidref
	unsigned @3 *src = (unsigned @3*) BUNfirst(b);
	size_t size_estimate = (size_t) (@:@1_estimate(@3)@ * ((float) BATcount(sel)/(float) BATcount(b)));
	if (@2) {
		bn = BATnew(TYPE_oid,TYPE_void,size_estimate);
	} else {
		bn = sel;
	}
	dst = (oid*) BUNfirst(bn);
	last = (oid*) (bn->batBuns->base + bn->batBuns->size);

	@:INIT@1(unsigned @3)@
	while(cur < end) {
		size_t idx = *cur - base;
		if (@:TST@1(src[idx])@) {
			@:checkdst@2@
			*(dst++) = *cur; 
		} cur ++;
	}

@+ Sub-Histogram Calculation
@c
/* COMMAND sel_histo
 * computes a subset-histogram on b, receiving the subset as a selection BAT
 */
int
oid_subhisto(BAT **res, BAT *b, BAT *sel)
{
	oid *cur = (oid *) BUNhloc(sel, BUNfirst(sel));
	int *cnt;
	BAT *bn = NULL;

	@:subhisto(oid)@

	*res = bn;
	return GDK_SUCCEED;
}


/* COMMAND 
 * computes a subset-histogram on b, receiving the subset as a bitmask
 */
int
bit_subhisto(BAT **res, BAT *b, BAT *sel)
{
	int *cur = (int *) BUNhloc(sel, BUNfirst(sel));
	int *cnt;
	BAT *bn = NULL;

	@:subhisto(bit)@

	*res = bn;
	return GDK_SUCCEED;
}

/* basically the same implementation, but now we produce multiple histograms 
   at the same time */
int
bits_subhisto(BAT **res, BAT *b, ...)
{
	int *cur[MAXPARAMS], *cnt[MAXPARAMS], i, argc;
	BAT *bn[MAXPARAMS], *sel[MAXPARAMS];
	va_list ap;

	va_start(ap, b);
	for (argc = 0; TRUE; argc++) {
		sel[argc] = va_arg(ap, BAT *);

		if (sel[argc] == NULL)
			break;
		cur[argc] = (int *) BUNfirst(sel[argc]);
	}
	va_end(ap);

	@:subhisto(bit,multiplex,[i])@

	*res = BATnew(TYPE_int, TYPE_bat, argc);
	for (i = 0; i < argc; i++)
		BUNins(*res, &i, &bn[i]->batCacheid);
	return GDK_SUCCEED;
}

@- optimized sub-histogram implementation

@= subhisto
{	int xx = b->ttype, *yy;
	BAT *map;
	BUN p,q;

	@2 @:check_@1sel(@1_subhisto,sel@3,b,BATcount(b))@
	@:check_enumbat(@1_subhisto,b)@

	/* initialization */
	enum_table(&map, &xx);
	@2 {
		size_t xx = BATcount(map);
		cnt@3 = (int*) GDKmalloc(xx<<2);
		for(yy=cnt@3; xx--; yy++) *yy = 0;
	}

	/* the algorithm */
	if (ATOMstorage(b->ttype) == TYPE_chr) {
		@:@1_subhisto(char,@2,@3)@
		@:end_subhisto(char,@2,@3)@
	} else if (ATOMstorage(b->ttype) == TYPE_sht) {
		@:@1_subhisto(short,@2,@3)@
		@:end_subhisto(short,@2,@3)@
	}
}
@= bit_subhisto
        size_t n = BATcount(b);
        unsigned @1 *src = (unsigned @1*) BUNfirst(b);
        unsigned @1 *end = src + ((n >> 5) << 5);
        size_t mask = 1;
 
        while(src < end) {
                while(mask) {
                        @2 if ((*cur@3)&mask) cnt@3[*src]++; /* ABR&ABW */
                        mask <<= 1; src++;
                }
                mask = 1; @2 cur@3++;
        }
        n = 1 << (n&31);
        while(mask != n) {
                @2 if ((*cur@3)&mask) cnt@3[*src]++;
                mask <<= 1; src++;
        }
@= oid_subhisto
        unsigned @1 *base = (unsigned @1*) BUNfirst(b);
        oid *end = (oid*) BUNlast(sel);
        oid off = b->hseqbase;
        while(cur < end) {
                unsigned @1 idx = base[*(cur++)-off]; 
                cnt[idx]++; 
        } 
@= end_subhisto
        @2 {
                bn@3 = BATnew(map->htype, TYPE_int, BATcount(map));
                yy = cnt@3;
                BATloopFast(map, p, q, xx) {
                        if (*yy) BUNfastins(bn@3, BUNhead(map,p), yy);
                        yy++;
                }
		bn@3->hsorted = BAThordered(map);
		bn@3->tsorted = FALSE;
		bn@3->hkey = BATmirror(bn@3)->tkey = TRUE;
                GDKfree(cnt@3);
        }

@* Benchmark Script
@T
DD Benchmark dynamic MIL script with detailed result
collection and XFIG summary sheet generation.
\begin{verbatim}
Enhanced and commented by M. Kersten Okt 1998
Generalized for multiple strategies by P. Boncz Nov 1998
\end{verbatim}
@sh
#!/bin/sh

ASCII=$1
TEMP=/tmp
RND=`echo echo '$$'|sh`
BENCH=ddbench$RND
PORT=`echo $RND | awk ' { print 5 ($1)%10000 } '`

###
### param check
### 

if [ -s $ASCII ]
then
  true
else
  echo ddbench: illegal ascii file $ASCII
  echo "usage: $0 ASCII"
  return 1
fi

MONETBAK=$MONETFARM
MONETFARM=$TEMP/$BENCH
export MONETFARM


###
### create tempdir and put general files there
### 

rm -r -f $TEMP/$BENCH 2>/dev/null
mkdir $TEMP/$BENCH
mkdir $TEMP/$BENCH/dbfarm
mkdir $TEMP/$BENCH/normal
mkdir $TEMP/$BENCH/wide
touch $TEMP/$BENCH/homes
fgrep -v "#line" scripts/run | egrep -v "^$" > $MONETFARM/run
fgrep -v "#line" scripts/summary | egrep -v "^$" > $MONETFARM/summary
fgrep -v "#line" scripts/config.pl | egrep -v "^$" > $MONETFARM/config.sed
fgrep -v "#line" scripts/template.pl | egrep -v "^$" > $MONETFARM/template.fig
fgrep -v "#line" scripts/all | egrep -v "^$" > $MONETFARM/all
cp scripts/print.mil $MONETFARM
cp scripts/noprint.mil $MONETFARM
chmod 755 $MONETFARM/run $MONETFARM/all $MONETFARM/summary


### 
### load the database from ASCII dump 
### 

fgrep "," scripts/mload.spec > $MONETFARM/mload.spec

echo "Mcreatedb -db bench1 -port $PORT"
Mcreatedb -db bench1 -port $PORT
echo "Mcreatedb -db bench10 -port $PORT"
Mcreatedb -db bench10 -port $PORT

echo "Mload $ASCII -db bench1 -oid 0 -s 1000000 -f $MONETFARM/mload.spec"
Mload $ASCII -db bench1 -oid 0 -s 1000000 -f $MONETFARM/mload.spec

echo "cp -r $MONETFARM/dbfarm/bench1/* $MONETFARM/dbfarm/bench10"
cp -r $MONETFARM/dbfarm/bench1/* $MONETFARM/dbfarm/bench10

echo "cat scripts/init_par.mil scripts/init_enum.mil scripts/init.mil | Mserver --dbname=bench1"
cat scripts/init_par.mil scripts/init_enum.mil scripts/init.mil | Mserver --dbname=bench1 

echo "cat scripts/init_par.mil scripts/init_scale.mil scripts/init.mil | Mserver --dbname=bench10 -mmap 100"
cat scripts/init_par.mil scripts/init_scale.mil scripts/init.mil | Mserver --dbname=bench10 -mmap 100 

### 
### generate the (scaled) query bodies
### 
for i in load batch0 batch1 select2 batch2 select3 batch3 select4 batch4
do
  cat scripts/$i.mil >> $MONETFARM/normal.mil

  echo "scaling up $i.mil"
  fgrep printf scripts/$i.mil | fgrep -v fprintf >> $MONETFARM/wide.mil
  fgrep ":= 0" scripts/$i.mil >> $MONETFARM/wide.mil
  for j in 0 1 2 3 4 5 6 7 8 9
  do
    fgrep "var" scripts/$i.mil | fgrep -v "{ var" | sed -e "s/_0/_$j/g">>$MONETFARM/wide.mil
  done
  fgrep "{|" scripts/$i.mil >> $MONETFARM/wide.mil
  for j in 0 1 2 3 4 5 6 7 8 9
  do
    fgrep ":= nil" scripts/$i.mil | sed -e "s/_0/_$j/g" >> $MONETFARM/wide.mil
    fgrep "_0" scripts/$i.mil | fgrep ":=" | sed -e "s/_0/_$j/g" >> $MONETFARM/wide.mil
  done
  fgrep "reliable" scripts/$i.mil | fgrep -v "_0" >> $MONETFARM/wide.mil
  fgrep "|}" scripts/$i.mil >> $MONETFARM/wide.mil
  for j in 0 1 2 3 4 5 6 7 8 9
  do
    fgrep ":+=" scripts/$i.mil|sed -e "s/_0/_$j/g">>$MONETFARM/wide.mil
  done
  fgrep "fpNice" scripts/$i.mil >> $MONETFARM/wide.mil
done


### 
### generate all relevant script combinations
### 

gen_script()
{
  nm=$1_$2_$3_$4
  dir=$MONETFARM/$5/$nm
  mkdir $dir
  if [ XX$5 = XXnormal ]
  then
    cat scripts/head.mil | sed -e "s/XX/1/" | sed -e "s/YY/$nm/" > $dir/tmp.mil
  else
    cat scripts/head.mil | sed -e "s/XX/10/" | sed -e "s/YY/$nm/" > $dir/tmp.mil
  fi
  if [ XX$4 = XXenum ]
  then
    cat scripts/enum.mil >> $dir/tmp.mil
  fi
  cat scripts/prelude.mil >> $dir/tmp.mil
  cat scripts/$1.mil >> $dir/tmp.mil
  cat scripts/$2.mil >> $dir/tmp.mil
  cat scripts/$3.mil >> $dir/tmp.mil
  cat $MONETFARM/$5.mil >> $dir/tmp.mil
  cat scripts/epilogue.mil >> $dir/tmp.mil
  sed "s/_Y/_$4/g" $dir/tmp.mil > $dir/query.mil
  rm $dir/tmp.mil
}

gen_scripts()
{
  gen_script $1 $2 $3 $4 normal
  gen_script $1 $2 $3 $4 wide
}

gen_scripts old and semijoin type 

for select_representation in old oid bit
do
  for select_combination in and sub
  do
    for group_strategy in semijoin subgroup subhisto 
    do
      gen_scripts $select_representation $select_combination $group_strategy enum 
    done
  done
done
rm -rf $MONETFARM/*/bit*subgroup* # impossible combination
rm $MONETFARM/normal.mil $MONETFARM/wide.mil  # cleanup


MONETFARM=$MONETBAK
export MONETFARM
echo "pushd $TEMP/$BENCH"

@+ Benchmark Initialization
@f scripts_mload
@s
,",",int
*age_tmp,",",int
*gender_tmp,",",chr
*marital_tmp,",",str
*town_tmp,",",str
*zipcode_tmp,",",int
*spendings_tmp,",",int
*reliable_tmp,",",str

@f scripts_init_par
@mil
module(str,enum,alarm); 

threadcnt(1);
sleep(1);

@f scripts_init_enum
@mil
# construct [void,enum] and [oid,tpe] from [void,tpe]
proc init(str nme) : void {
    printf("start %s_enum\n",nme);
    var tmp := bat(nme + "_tmp");
    var tpe := enum_create(nme, tmp);
    var res := tpe.[encode](tmp);
    tpe.enum_sethisto(res.reverse());
    res.rename(nme + "_enum").persists(true);
    printf("save %s_enum\n",nme);
    res.mmap(STORE_MMAP).unload();
    printf("start %s_type\n",nme);
    var old := [oid](tmp.reverse()).reverse();
    old.rename(nme + "_type").persists(true);
    printf("save %s_type\n",nme);
    old.mmap(STORE_MMAP).unload();
    tmp := tmp.destroy();
    printf("end %s\n",nme);
}

@f scripts_init_scale
@mil
# construct [void,enum] and [oid,tpe] from [void,tpe]
# while scaling 10 times with multiple inserts
proc init(str nme) : void {
    printf("start %s_type\n",nme);
    var tmp := bat(nme + "_tmp").seqbase(nil);
    var res := new(void, tmp.ttype(), 4*tmp.count());
    var i := 0;
    while((i :+= 1) <= 10) res.insert(tmp);
    res := [oid](res.seqbase(0@0).reverse()).reverse();
    res.rename(nme + "_type").persists(true);
    printf("save %s_type\n",nme);
    res.mmap(STORE_MMAP).unload();
    printf("start %s_enum\n",nme);
    var tpe := enum_create(nme, tmp);
    [*=](bat(nme).access(BAT_WRITE),10); # tricky!
    res := tpe.[encode](tmp);
    tmp.destroy(); tmp := res;
    res := new(void, tmp.ttype(), 4*tmp.count());
    while((i :+= 1) <= 21) res.insert(tmp);
    tpe.enum_sethisto(res.reverse());
    res.seqbase(0@0).rename(nme + "_enum").persists(true);
    printf("save %s_enum\n",nme);
    res.access(BAT_READ).mmap(STORE_MMAP).unload();
    printf("end %s\n",nme);
}

@f scripts_init
@mil
{|
    init("zipcode");
    init("spendings");
    init("age");
    init("town");
    init("marital");
    init("gender");
    init("reliable");
|}

commit;

@f scripts_run
@sh
#!/bin/sh
#
usage()
{
   echo "usage: $0 [print,noprint] PAR[x] VF[1,10] HF[normal,wide]/SCRIPT [MONETPARAMS]"  
}

if [ -f homes ]
then
   fgrep bench1 homes >/dev/null
   if [ $? = 1 ]
   then
     echo "$0: must execute in generated TMP/ddbench directory"
     usage; return 1
   fi
else 
   echo "$0: must execute in generated TMP/ddbench directory"
   usage; return 1
fi
 
MONETBAK=$MONETFARM
MONETFARM=`pwd`
PAR=$2
VF=$3
TMP=$MONETFARM/$4
export TMP VF PAR MONETFARM

cat $1.mil $TMP/query.mil > query.mil
echo "Mserver --dbname=bench$3 $5 $6 $7 $8 $9 < query.mil"
time Mserver --dbname=bench$3 $5 $6 $7 $8 $9 < query.mil

echo export MONETFARM=`pwd`
echo export PAR=$2
echo export TMP=$MONETFARM/$4

MONETFARM=$MONETBAK
export MONETFARM

@f scripts_all
@sh
#!/bin/sh
RESULTS=$HOME/results`echo echo '$$'|sh`
mkdir $RESULTS
 
ddbench()
{
for E in $2/*
do
  run $1 1 1 $E 
  run $1 1 1 $E 
  run $1 2 1 $E 
  run $1 1 10 $E -mmap 100
  run $1 2 10 $E -mmap 100
done
mkdir $RESULTS/$2
cp -r $2/* $RESULTS/$2
}
 
ddbench noprint normal
#ddbench noprint wide          

@f scripts_summary
@sh
#!/bin/sh

for i in $*
do
 for j in $i/*.sed
 do
  sed -f ../config.sed -f $j< ../template.fig | fig2dev -L ps -c -P -m 0.6>$j.ps
 done
done

@f scripts_head
@mil
module(unix,alarm,stream,str,xtables);

#output for the Xfig overview is dumped in a separate file
var DB := environment.find("dbname");
var PAR := int(getenv("PAR"));
var TMP := getenv("TMP");
var fpNice:= open_wstream(sprintf("%s/%s_par%d.sed", TMP, DB, PAR));
var fps := new(int,Stream);
var VF := int(getenv("VF"));
var HF := XX; # value gets substituted in during script generation
var SCR := "YY"; # value gets substituted in during script generation

threadcnt(PAR - 1);
sleep(1);

# normally, we cache the binary subcubes of batch 1
var cache_batch1 := true; 
var CT_reliable := nil;

@f scripts_print
@mil
module(stream,alarm);

proc revprint(stream fp, bat[any,any] b1, bat[any,any] b2) : void 
          fp.[fprintf]("%d\t%s\n", b2, [str](b1));
proc revprint(stream fp, bat[any,any] b1, bat[any,any] b2, bat[any,any] b3) : void 
          fp.[fprintf]("%d\t%s\t%s\n", b3, [str](b2), [str](b1));

proc print_table(str seq, str att1, bat[any,any] aggr) : int {
        var t0 := time;
        var b1 := varval(att1+"s");
        var fp := fps.find(threadid);
        var col1 := b1.semijoin(aggr);
        var t1 := time;
        fp.fprintf("     count   %s\n", att1);
        fp.fprintf("==========================\n");
        revprint(fp, col1, aggr);
        fp.fprintf("!!print %s: %d =semijoin %d =print\n", seq, t1-t0, time-t1);
        return time - t0;
}
 
proc print_table(str seq, str att1, str att2, bat[any,any] aggr) : int {
        var t0 := time;
        var b1 := varval(att1+"s");
        var b2 := varval(att2+"s");
        var fp := fps.find(threadid);
        var col1 := b1.semijoin(aggr);
        var col2 := b2.semijoin(aggr);
        var t1 := time;
        fp.fprintf("     count   %s %s\n", att2, att1);
        fp.fprintf("==================================\n");
        revprint(fp, col1, col2, aggr);
        fp.fprintf("!!print %s: %d =semijoin %d =print\n", seq, t1-t0, time-t1);
        return time - t0;
}

@f scripts_noprint.mil
@mil
proc print_table() : bit return true; 

@f scripts_enum
@mil
module(enum);

var zipcode, spendings, town, age, marital, gender, reliable;
{|
    zipcode := enum_load("zipcode");
    spendings := enum_load("spendings");
    town := enum_load("town");
    age := enum_load("age");
    marital := enum_load("marital");
    gender := enum_load("gender");
    reliable := enum_load("reliable");
|}

proc conv_str(bat[void,any] b) : bat[void,any]  {
	if (isenum(b.ttype())) {
	    var e := enum_table(b.ttype());
	    if (e.htype() != str) {
		var map := [str](e.reverse()).reverse();
		return enum_trick(b, map);
	}   }
	return b;
}

proc revprint(fp,b1,b2) : void  enum_print(fp,b2,b1);
proc revprint(fp,b1,b2,b3) : void enum_print(fp,b3,b2,b1);

@f scripts_prelude
@mil
proc semijoin(str seq, bat[any::1,any::2] b1, bat[any::1,any] b2) : 
							bat[any::1,any::2] 
{
        var t0 := time;
        var fp := fps.find(threadid);
	var bn := semijoin(b1,b2);
        fp.fprintf("!!semijoin %s: %d\n", seq, time-t0);
	return bn;
}

proc load(str seq, str varnme, str nme) : int{
        var t0 := time;
        var b := load(nme);
        assign(varnme, b);
        assign(varnme+"s", conv_str(b));
        return time-t0;
}
	
proc ucube(str seq, str attr) : int {
        var t0 := time;
        var b := varval(attr);
        var fp := fps.find(threadid);
        var ct := group(b);
        var t1 := time;
        var aggr := {count}(ct.reverse());
        fp.fprintf("!!ucube %s: %d =group %d =aggr %d =ngroups\n", seq, t1-t0, time-t1, aggr.count());
        seq.print_table(attr, aggr);
        assign("CT_" + attr, ct);
	return time-t0;
}

proc bicube(str seq, str att1, str att2) : int {
        var t0 := time;
        var b0 := varval("CT_" + att1);
        var b1 := varval(att1);
        var b2 := varval(att2);
        var fp := fps.find(threadid);
        var ct := group(b0,b2);
        var t1 := time;
        var aggr := {count}(ct.reverse());
	if (cache_batch1) {
		var tpe := b0.ttype();
		assign("CT_" + att1, ct);
		b0 := nil;
 		if (isenum(tpe)) enum_drop(tpe);
	}
        fp.fprintf("!!bicube %s: %d =group %d =aggr %d =ngroups\n", seq, t1, time-t1, aggr.count());
        seq.print_table(att1, att2, aggr);
	return time-t0;
}


#The output of the benchmark is organized by thread.
threads;
i := 0;
view_gdk_thread.reverse()@hashloop("Interpreter") {
   fps.insert($t, fopen(sprintf("%s/%s_par%d.out%d", TMP, DB, PAR, i), "w+"));
   i := i + 1;
}
fps.print();

var tot0 := 0, tot1 := 0, tot2 := 0, tot3 := 0, tot4 := 0;
var tot5 := 0, tot6 := 0, tot7 := 0, tot8 := 0; tot9 := 0;


@+ Option 1: Subgroup Method
@- CT-semijoin-histogram (semijoin.mil)
@f scripts_semijoin
@mil
proc group(bat[any,any] b) : bat[any,any] return CTgroup(b);
proc group(bat[any,any] a, bat[any,any] b) : bat[any,any] return CTgroup(a,b);

proc subcube(str seq, str att1, str att2, bat[any,any] sel) : int {
        var t0 := time;
        var b0 := varval("CT_" + att1);
        var b1 := varval(att1);
        var b2 := varval(att2);
        var fp := fps.find(threadid);
	var ct := semijoin(b0,sel);
        var t1 := time;
        var aggr := {count}(ct.reverse());
        fp.fprintf("!!subcube %s: %d =semijoin %d =aggr %d =ngroups\n", seq, t1-t0, time-t1, aggr.count());
        seq.print_table(att1, att2, aggr);
	return time - t0;
}

@- CTsubgroup-histogram (subgroup.mil)
@f scripts_subgroup
@mil
cache_batch1 := false; # we cache batch 0 here

proc group(bat[any,any] b) : bat[any,any] return CTgroup(b);
proc group(bat[any,any] a, bat[any,any] b) : bat[any,any] return CTgroup(a,b);

proc subcube(str seq, str att1, str att2, bat[any,any] sel) : int {
        var t0 := time;
        var b0 := varval("CT_" + att1);
        var b1 := varval(att1);
        var b2 := varval(att2);
        var fp := fps.find(threadid);
	var ct := CTsubgroup(b0,b1,sel);
        var t1 := time;
        var aggr := {count}(ct.reverse());
        fp.fprintf("!!subcube %s: %d =CTsubgroup %d =aggr %d =ngroups\n", seq, t1-t0, time-t1, aggr.count());
        seq.print_table(att1, att2, aggr);
	return time - t0;
}

@- Nonmaterialized sub-histogram (subhisto.mil)
@f scripts_subhisto
@mil
module(ddbench);

proc subcube(str seq, str att1, str att2, bat[any,any] sel) : int {
        var t0 := time;
        var b0 := varval("CT_" + att1);
        var b1 := varval(att1);
        var b2 := varval(att2);
        var fp := fps.find(threadid);
        var aggr := subhisto(b0,sel);
        fp.fprintf("!!subcube %s: %d =subhisto %d =ngroups\n", seq, time-t0, aggr.count());
        seq.print_table(att1, att2, aggr);
	return time - t0;
}

@+ Option 2: Select Method
@- old uselect (old.mil)
@f scripts_old
@mil
proc valselect(str seq, bat[any,any] b, any val) : bat[any,any] {
	var t0 := time;
        var fp := fps.find(threadid);
	var b1 := b.uselect(b.ttype().encode(val));
        fp.fprintf("!!select %s: %d =uselect_val %d =ntuples\n", seq, time-t0, b1.count());
        fp.fprintf("!!predicate: %s == %s\n", b1.str(), val.str());
	return b1;
}
proc rngselect(str seq, bat[any,any] b, any::1 lo, any::1 hi) : bat[any,any] {
	var t0 := time;
        var fp := fps.find(threadid);
	var b1 := b.uselect(b.ttype().upper(lo),b.ttype().lower(hi));
        fp.fprintf("!!select %s: %d =uselect_rng %d =ntuples\n", seq, time-t0, b1.count());
        fp.fprintf("!!predicate: %s in [%s,%s]\n", b1.str(), lo.str(), hi.str());
	return b1;
}

@- oid enum-select (oid.mil)
@f scripts_oid
@mil
module(ddbench);
proc valselect(str seq, bat[any,any] b, any val) : bat[any,any] {
	var t0 := time;
        var fp := fps.find(threadid);
	var b1 := b.val_oidselect(b.ttype().encode(val));
        fp.fprintf("!!select %s: %d =val_oidselect %d =ntuples\n", seq, time-t0, b1.count());
        fp.fprintf("!!predicate: %s == %s\n", b1.str(), val.str());
	return b1;
}
proc rngselect(str seq, bat[any,any] b, any::1 lo, any::1 hi) : bat[any,any] {
	var t0 := time;
        var fp := fps.find(threadid);
	var b1 := b.rng_oidselect(b.ttype().upper(lo),b.ttype().lower(hi));
        fp.fprintf("!!select %s: %d =rng_oidselect %d ntuples\n", seq, time-t0, b1.count());
        fp.fprintf("!!predicate: %s in [%s,%s]\n", b1.str(), lo.str(), hi.str());
	return b1;
}

@- bit enum-select (bit.mil)
@f scripts_bit
@mil
module(ddbench);
proc valselect(str seq, bat[any,any] b, any val) : bat[any,any] {
	var t0 := time;
        var fp := fps.find(threadid);
	var b1 := b.val_bitselect(b.ttype().encode(val));
        fp.fprintf("!!select %s: %d =val_bitselect %d =ntuples\n", seq, time-t0, b1.count());
        fp.fprintf("!!predicate: %s == %s\n", b1.str(), val.str());
	return b1;
}
proc rngselect(str seq, bat[any,any] b, any::1 lo, any::1 hi) : bat[any,any] {
	var t0 := time;
        var fp := fps.find(threadid);
	var b1 := b.rng_bitselect(b.ttype().upper(lo),b.ttype().lower(hi));
        fp.fprintf("!!select %s: %d =rng_bitselect %d =ntuples\n", seq, time-t0, b1.count());
        fp.fprintf("!!predicate: %s in [%s,%s]\n", b1.str(), lo.str(), hi.str());
	return b1;
}

@+ Option 2: Selection Combination Method
@- select-semijoin (and.mil)
@f scripts_and
@mil
proc valselect(str seq, bat[any,any] sel, bat[any,any] b, any val) : bat[any,any] {
	var b1 := seq.valselect(b, val);
	var t0 := time;
        var fp := fps.find(threadid);
	var b2 := semijoin(sel,b1);
        fp.fprintf("!!select %s: %d =semijoin %d =ntuples\n", seq, time-t0, b2.count());
        fp.fprintf("!!predicate: %s == %s\n", b1.str(), val.str());
	return b2;
}
proc rngselect(str seq, bat[any,any] sel, bat[any,any] b, any::1 lo, any::1 hi) : bat[any,any] {
	var b1 := seq.rngselect(b, lo, hi);
	var t0 := time;
        var fp := fps.find(threadid);
	var b2 := semijoin(sel,b1);
        fp.fprintf("!!select %s: %d =semijoin %d =ntuples\n", seq, time-t0, b2.count());
        fp.fprintf("!!predicate: %s in [%s,%s]\n", b1.str(), lo.str(), hi.str());
	return b2;
}

@- subselect (sub.mil)
@f scripts_sub
@mil
module(ddbench);
proc valselect(str seq, bat[any,any] sel, bat[any,any] b, any val) : bat[any,any] {
	var t0 := time;
        var fp := fps.find(threadid);
	var b1 := subselect(sel, b, b.ttype().encode(val));
        fp.fprintf("!!select %s: %d =subselect %d =ntuples\n", seq, time-t0, b1.count());
        fp.fprintf("!!predicate: %s == %s\n", b1.str(), val.str());
	return b1;
}
proc rngselect(str seq, bat[any,any] sel, bat[any,any] b, any::1 lo, any::1 hi) : bat[any,any] {
	var t0 := time;
        var fp := fps.find(threadid);
	var b1 := subselect(sel, b, b.ttype().upper(lo), b.ttype().lower(hi));
        fp.fprintf("!!select %s: %d =subselect %d =ntuples\n", seq, time-t0, b1.count());
        fp.fprintf("!!predicate: %s in [%s,%s]\n", b1.str(), lo.str(), hi.str());
	return b1;
}

@+ Main Benchmark Script
@- LOADING PHASE 
Loading phase is not officially part of the benchmark
The timing is of interest for future direct access
to another database
@f scripts_load
@mil
var res_0000, res_0001, res_0002, res_0003, res_0004, res_0005; 
var res_0100, res_0101, res_0102, res_0103, res_0104, res_0105;
var res_0200, res_0201, res_0202, res_0203, res_0204, res_0205;
var res_0300, res_0301, res_0302, res_0303, res_0304, res_0305;
var res_0400, res_0401, res_0402, res_0403, res_0404, res_0405;
var res_0500, res_0501, res_0502, res_0503, res_0504, res_0505;
var res_0600, res_0601, res_0602, res_0603, res_0604, res_0605;
var res_0700, res_0701, res_0702, res_0703, res_0704, res_0705;
var res_0800, res_0801, res_0802, res_0803, res_0804, res_0805;
var res_0900, res_0901, res_0902, res_0903, res_0904, res_0905;
var zipcode_0, spendings_0, gender_0, town_0, age_0, marital_0;
var zipcode_0s, spendings_0s, gender_0s, town_0s, age_0s, marital_0s;
var reliable_X, reliable_Xs, t, start := time;

{|
	tot0 := "seq_0000".load("zipcode_0", "zipcode_Y"); 
	tot1 := "seq_0000".load("spendings_0", "spendings_Y"); 
        tot2 := "seq_0001".load("gender_0", "gender_Y"); 
	tot3 := "seq_0001".load("town_0", "town_Y"); 
	tot4 := "seq_0002".load("age_0", "age_Y"); 
	tot5 := "seq_0002".load("marital_0", "marital_Y"); 
	tot6 := "seq_0002".load("reliable_X", "reliable_Y"); 
|}

fpNice.fprintf("s/LLL0/%dms/\n", tot0);
fpNice.fprintf("s/LLL1/%dms/\n", tot1);
fpNice.fprintf("s/LLL2/%dms/\n", tot2);
fpNice.fprintf("s/LLL3/%dms/\n", tot3);
fpNice.fprintf("s/LLL4/%dms/\n", tot4);
fpNice.fprintf("s/LLL5/%dms/\n", tot5);
fpNice.fprintf("s/LLL6/%dms/\n", tot6);
fpNice.fprintf("s/LLLL/%dms/\n", time-t);

@- BATCH 0
@f scripts_batch0
@mil
printf("# %d start of batch0.mil\n", (t := time)-start); 
tot0 := 0; tot1 := 0; tot2 := 0; tot3 := 0; tot4 := 0; tot5 := 0; 

var CT_age_0, CT_town_0, CT_gender_0, CT_zipcode_0, CT_marital_0, CT_spendings_0;

{| 
  res_0000 := "seq_0003".ucube("zipcode_0");
  res_0100 := "seq_0004".ucube("spendings_0");
  res_0200 := "seq_0005".ucube("age_0");
  res_0300 := "seq_0006".ucube("gender_0");
  res_0400 := "seq_0007".ucube("town_0");
  res_0500 := "seq_0008".ucube("marital_0");
      tot6 := "seq_0009".ucube("reliable_X");
|}

tot0 :+= res_0000; tot1 :+= res_0100; tot2 :+= res_0200;
tot3 :+= res_0300; tot4 :+= res_0400; tot5 :+= res_0500;

fpNice.fprintf("s/AAA0/%dms/\n", tot0);
fpNice.fprintf("s/AAA1/%dms/\n", tot1);
fpNice.fprintf("s/AAA2/%dms/\n", tot2);
fpNice.fprintf("s/AAA3/%dms/\n", tot3);
fpNice.fprintf("s/AAA4/%dms/\n", tot4);
fpNice.fprintf("s/AAA5/%dms/\n", tot5);
fpNice.fprintf("s/AAA6/%dms/\n", tot6);

fpNice.fprintf("s/AAAA/%dms/\n", time-t); 

@- BATCH 1
@f scripts_batch1
@mil
printf("# %d start of batch1.mil\n", (t := time)-start); 
tot0 := 0; tot1 := 0; tot2 := 0; tot3 := 0; tot4 := 0; tot5 := 0; 

{|
  res_0000 := "seq_0010".bicube("zipcode_0", "reliable_X");
  res_0100 := "seq_0011".bicube("spendings_0", "reliable_X");
  res_0200 := "seq_0012".bicube("age_0", "reliable_X");
  res_0300 := "seq_0013".bicube("gender_0", "reliable_X");
  res_0400 := "seq_0014".bicube("town_0", "reliable_X");
  res_0500 := "seq_0015".bicube("marital_0", "reliable_X");
|}

tot0 :+= res_0000; tot1 :+= res_0100; tot2 :+= res_0200;
tot3 :+= res_0300; tot4 :+= res_0400; tot5 :+= res_0500;

fpNice.fprintf("s/BBB0/%dms/\n", tot0);
fpNice.fprintf("s/BBB1/%dms/\n", tot1);
fpNice.fprintf("s/BBB2/%dms/\n", tot2);
fpNice.fprintf("s/BBB3/%dms/\n", tot3);
fpNice.fprintf("s/BBB4/%dms/\n", tot4);
fpNice.fprintf("s/BBB5/%dms/\n", tot5);

fpNice.fprintf("s/BBBB/%dms/\n", time-t); 

@- BATCH 2
@f scripts_select2
@mil
printf("# %d start of select2.mil\n", (t := time)-start); 
tot0 := 0; tot1 := 0; tot2 := 0; tot3 := 0; tot4 := 0; 
tot5 := 0; tot6 := 0; tot7 := 0; tot8 := 0; tot9 := 0;

var females_0, males_0, age_18to45_0, age_45to55_0, age_55to80_0;
var single_0, married_0, divorced_0, center_0, south_0; 

{|
  { var tt := time;    females_0 := "seq_0016".valselect(gender_0, 'f');         res_0000 := time - tt; }
  { var tt := time;      males_0 := "seq_0017".valselect(gender_0, 'm');         res_0100 := time - tt; }
  { var tt := time; age_18to45_0 := "seq_0018".rngselect(age_0, 18, 45);         res_0200 := time - tt; }
  { var tt := time; age_45to55_0 := "seq_0019".rngselect(age_0, 45, 55);         res_0300 := time - tt; }
  { var tt := time; age_55to80_0 := "seq_0020".rngselect(age_0, 55, 80);         res_0400 := time - tt; }
  { var tt := time;     single_0 := "seq_0021".valselect(marital_0, "single");   res_0500 := time - tt; }
  { var tt := time;    married_0 := "seq_0022".valselect(marital_0, "married");  res_0600 := time - tt; }
  { var tt := time;   divorced_0 := "seq_0023".valselect(marital_0, "divorced"); res_0700 := time - tt; }
  { var tt := time;     center_0 := "seq_0024".rngselect(zipcode_0, 1000, 3000); res_0800 := time - tt; }
  { var tt := time;      south_0 := "seq_0025".rngselect(zipcode_0, 4000, 7000); res_0900 := time - tt; }
|}

@f scripts_batch2
@mil
printf("# %d start of group batch2.mil\n", time-start); 

{|
  res_0003 := "seq_0026".subcube("zipcode_0","reliable_X",females_0);
  res_0103 := "seq_0027".subcube("zipcode_0","reliable_X",males_0);
  res_0203 := "seq_0028".subcube("zipcode_0","reliable_X",age_18to45_0);
  res_0303 := "seq_0029".subcube("zipcode_0","reliable_X",age_45to55_0);
  res_0403 := "seq_0030".subcube("zipcode_0","reliable_X",age_55to80_0);
  res_0504 := "seq_0031".subcube("zipcode_0","reliable_X",single_0);
  res_0604 := "seq_0032".subcube("zipcode_0","reliable_X",married_0);
  res_0704 := "seq_0033".subcube("zipcode_0","reliable_X",divorced_0);

  res_0005 := "seq_0034".subcube("spendings_0","reliable_X",females_0);
  res_0105 := "seq_0035".subcube("spendings_0","reliable_X",males_0);
  res_0205 := "seq_0036".subcube("spendings_0","reliable_X",age_18to45_0);
  res_0305 := "seq_0037".subcube("spendings_0","reliable_X",age_45to55_0);
  res_0405 := "seq_0038".subcube("spendings_0","reliable_X",age_55to80_0);
  res_0505 := "seq_0039".subcube("spendings_0","reliable_X",single_0);
  res_0605 := "seq_0040".subcube("spendings_0","reliable_X",married_0);
  res_0705 := "seq_0041".subcube("spendings_0","reliable_X",divorced_0);
  res_0805 := "seq_0042".subcube("spendings_0","reliable_X",center_0);
  res_0905 := "seq_0043".subcube("spendings_0","reliable_X",south_0);

  res_0001 := "seq_0044".subcube("age_0","reliable_X",females_0);
  res_0101 := "seq_0045".subcube("age_0","reliable_X",males_0);
  res_0502 := "seq_0046".subcube("age_0","reliable_X",single_0);
  res_0602 := "seq_0047".subcube("age_0","reliable_X",married_0);
  res_0702 := "seq_0048".subcube("age_0","reliable_X",divorced_0);
  res_0802 := "seq_0049".subcube("age_0","reliable_X",center_0);
  res_0902 := "seq_0050".subcube("age_0","reliable_X",south_0);

  res_0002 := "seq_0051".subcube("town_0","reliable_X",females_0);
  res_0102 := "seq_0052".subcube("town_0","reliable_X",males_0);
  res_0202 := "seq_0053".subcube("town_0","reliable_X",age_18to45_0);
  res_0302 := "seq_0054".subcube("town_0","reliable_X",age_45to55_0);
  res_0402 := "seq_0055".subcube("town_0","reliable_X",age_55to80_0);
  res_0503 := "seq_0056".subcube("town_0","reliable_X",single_0);
  res_0603 := "seq_0057".subcube("town_0","reliable_X",married_0);
  res_0703 := "seq_0058".subcube("town_0","reliable_X",divorced_0);
  res_0803 := "seq_0059".subcube("town_0","reliable_X",center_0);
  res_0903 := "seq_0060".subcube("town_0","reliable_X",south_0);

  res_0004 := "seq_0061".subcube("marital_0","reliable_X",females_0);
  res_0104 := "seq_0062".subcube("marital_0","reliable_X",males_0);
  res_0204 := "seq_0063".subcube("marital_0","reliable_X",age_18to45_0);
  res_0304 := "seq_0064".subcube("marital_0","reliable_X",age_45to55_0);
  res_0404 := "seq_0065".subcube("marital_0","reliable_X",age_55to80_0);
  res_0804 := "seq_0066".subcube("marital_0","reliable_X",center_0);
  res_0904 := "seq_0067".subcube("marital_0","reliable_X",south_0);

  res_0201 := "seq_0068".subcube("gender_0","reliable_X",age_18to45_0);
  res_0301 := "seq_0069".subcube("gender_0","reliable_X",age_45to55_0);
  res_0401 := "seq_0070".subcube("gender_0","reliable_X",age_55to80_0);
  res_0501 := "seq_0071".subcube("gender_0","reliable_X",single_0);
  res_0601 := "seq_0072".subcube("gender_0","reliable_X",married_0);
  res_0701 := "seq_0073".subcube("gender_0","reliable_X",divorced_0);
  res_0801 := "seq_0074".subcube("gender_0","reliable_X",center_0);
  res_0901 := "seq_0075".subcube("gender_0","reliable_X",south_0);
|}

tot0 :+= res_0000 + res_0001 + res_0002 + res_0003 + res_0004 + res_0005;
tot1 :+= res_0100 + res_0101 + res_0102 + res_0103 + res_0104 + res_0105;
tot2 :+= res_0200 + res_0201 + res_0202 + res_0203 + res_0204 + res_0205;
tot3 :+= res_0300 + res_0301 + res_0302 + res_0303 + res_0304 + res_0305;
tot4 :+= res_0400 + res_0401 + res_0402 + res_0403 + res_0404 + res_0405;
tot5 :+= res_0500 + res_0501 + res_0502 + res_0503 + res_0504 + res_0505;
tot6 :+= res_0600 + res_0601 + res_0602 + res_0603 + res_0604 + res_0605;
tot7 :+= res_0700 + res_0701 + res_0702 + res_0703 + res_0704 + res_0705;
tot8 :+= res_0800 + res_0801 + res_0802 + res_0803 + res_0804 + res_0805;
tot9 :+= res_0900 + res_0901 + res_0902 + res_0903 + res_0904 + res_0905;

fpNice.fprintf("s/CCC0/%dms/\n", tot0);
fpNice.fprintf("s/CCC1/%dms/\n", tot1); 
fpNice.fprintf("s/CCC2/%dms/\n", tot2); 
fpNice.fprintf("s/CCC3/%dms/\n", tot3);
fpNice.fprintf("s/CCC4/%dms/\n", tot4);
fpNice.fprintf("s/CCC5/%dms/\n", tot5);
fpNice.fprintf("s/CCC6/%dms/\n", tot6);
fpNice.fprintf("s/CCC7/%dms/\n", tot7);
fpNice.fprintf("s/CCC8/%dms/\n", tot8);
fpNice.fprintf("s/CCC9/%dms/\n", tot9);

fpNice.fprintf("s/CCCC/%dms/\n",time - t); 


@- BATCH 3
@f scripts_select3
@mil
printf("# %d start of select3.mil\n", (t := time)-start); 
tot0 := 0; tot1 := 0; tot2 := 0; tot3 := 0; tot4 := 0; 
tot5 := 0; tot6 := 0; tot7 := 0; tot8 := 0; tot9 := 0;

var females_age_30to45_0, females_age_45to55_0, males_age_55to80_0;
var mokum_age_18to45_0, rotstad_age_18to45_0, lichtstad_age_18to45_0;
var married_age_19to25_0, married_age_45to55_0, married_females_0, center_mokum_0;

{|
  south_0 := nil;
  single_0 := nil;
  divorced_0 := nil;

  { var tt := time;   females_age_45to55_0 := "seq_0076".semijoin(age_45to55_0, females_0);           res_0000 := time - tt; }
  { var tt := time;   married_age_45to55_0 := "seq_0077".semijoin(age_45to55_0, married_0);           res_0100 := time - tt; }
  { var tt := time;   females_age_30to45_0 := "seq_0078".rngselect(females_0,age_0,30,45);           res_0200 := time - tt; }
  { var tt := time;     males_age_55to80_0 := "seq_0079".semijoin(males_0,age_55to80_0);              res_0300 := time - tt; }
  { var tt := time;     mokum_age_18to45_0 := "seq_0080".valselect(age_18to45_0,town_0,"Amsterdam"); res_0400 := time - tt; }
  { var tt := time;   rotstad_age_18to45_0 := "seq_0081".valselect(age_18to45_0,town_0,"Rotterdam"); res_0500 := time - tt; }
  { var tt := time; lichtstad_age_18to45_0 := "seq_0082".valselect(age_18to45_0,town_0,"Eindhoven"); res_0600 := time - tt; }
  { var tt := time;   married_age_19to25_0 := "seq_0083".rngselect(married_0,age_0,19,25);           res_0700 := time - tt; }
  { var tt := time;      married_females_0 := "seq_0084".semijoin(married_0,females_0);               res_0800 := time - tt; }
  { var tt := time;         center_mokum_0 := "seq_0085".valselect(center_0,town_0,"Amsterdam");     res_0900 := time - tt; }
|}

@f scripts_batch3
@mil
printf("# %d start of group batch3.mil\n", time-start); 

{|
  females_0 := nil;
  males_0 := nil;
  age_18to45_0 := nil;
  age_45to55_0 := nil;
  age_55to80_0 := nil; 
  married_0 := nil;
  center_0 := nil;

  res_0001 := "seq_0086".subcube("zipcode_0", "reliable_X", females_age_45to55_0);
  res_0101 := "seq_0087".subcube("zipcode_0", "reliable_X", married_age_45to55_0);
  res_0201 := "seq_0088".subcube("zipcode_0", "reliable_X", females_age_30to45_0);
  res_0301 := "seq_0090".subcube("zipcode_0", "reliable_X", males_age_55to80_0);
  res_0401 := "seq_0091".subcube("zipcode_0", "reliable_X", mokum_age_18to45_0);
  res_0501 := "seq_0092".subcube("zipcode_0", "reliable_X", rotstad_age_18to45_0);
  res_0601 := "seq_0093".subcube("zipcode_0", "reliable_X", lichtstad_age_18to45_0);
  res_0701 := "seq_0094".subcube("zipcode_0", "reliable_X", married_age_19to25_0);
  res_0801 := "seq_0095".subcube("zipcode_0", "reliable_X", married_females_0);

  res_0002 := "seq_0096".subcube("spendings_0", "reliable_X", females_age_45to55_0);
  res_0102 := "seq_0097".subcube("spendings_0", "reliable_X", married_age_45to55_0);
  res_0202 := "seq_0098".subcube("spendings_0", "reliable_X", females_age_30to45_0);
  res_0302 := "seq_0099".subcube("spendings_0", "reliable_X", males_age_55to80_0);
  res_0402 := "seq_0100".subcube("spendings_0", "reliable_X", mokum_age_18to45_0);
  res_0502 := "seq_0101".subcube("spendings_0", "reliable_X", rotstad_age_18to45_0);
  res_0602 := "seq_0102".subcube("spendings_0", "reliable_X", lichtstad_age_18to45_0);
  res_0702 := "seq_0103".subcube("spendings_0", "reliable_X", married_age_19to25_0);
  res_0802 := "seq_0104".subcube("spendings_0", "reliable_X", married_females_0);
  res_0901 := "seq_0105".subcube("spendings_0", "reliable_X", center_mokum_0);

  res_0803 := "seq_0106".subcube("age_0", "reliable_X", married_females_0);
  res_0902 := "seq_0107".subcube("age_0", "reliable_X", center_mokum_0);

  res_0003 := "seq_0108".subcube("town_0", "reliable_X", females_age_45to55_0);
  res_0103 := "seq_0109".subcube("town_0", "reliable_X", married_age_45to55_0);
  res_0203 := "seq_0110".subcube("town_0", "reliable_X", females_age_30to45_0);
  res_0303 := "seq_0111".subcube("town_0", "reliable_X", males_age_55to80_0);
  res_0703 := "seq_0112".subcube("town_0", "reliable_X", married_age_19to25_0);
  res_0804 := "seq_0113".subcube("town_0", "reliable_X", married_females_0);

  res_0004 := "seq_0114".subcube("marital_0", "reliable_X", females_age_45to55_0);
  res_0204 := "seq_0115".subcube("marital_0", "reliable_X", females_age_30to45_0);
  res_0304 := "seq_0116".subcube("marital_0", "reliable_X", males_age_55to80_0);
  res_0403 := "seq_0117".subcube("marital_0", "reliable_X", mokum_age_18to45_0);
  res_0503 := "seq_0118".subcube("marital_0", "reliable_X", rotstad_age_18to45_0);
  res_0603 := "seq_0119".subcube("marital_0", "reliable_X", lichtstad_age_18to45_0);
  res_0903 := "seq_0120".subcube("marital_0", "reliable_X", center_mokum_0);

  res_0104 := "seq_0121".subcube("gender_0", "reliable_X", married_age_45to55_0);
  res_0404 := "seq_0122".subcube("gender_0", "reliable_X", mokum_age_18to45_0);
  res_0504 := "seq_0123".subcube("gender_0", "reliable_X", rotstad_age_18to45_0);
  res_0604 := "seq_0124".subcube("gender_0", "reliable_X", lichtstad_age_18to45_0);
  res_0704 := "seq_0125".subcube("gender_0", "reliable_X", married_age_19to25_0);
  res_0904 := "seq_0126".subcube("gender_0", "reliable_X", center_mokum_0);
|}

tot0 :+= res_0000 + res_0001 + res_0002 + res_0003 + res_0004;
tot1 :+= res_0100 + res_0101 + res_0102 + res_0103 + res_0104;
tot2 :+= res_0200 + res_0201 + res_0202 + res_0203 + res_0204;
tot3 :+= res_0300 + res_0301 + res_0302 + res_0303 + res_0304;
tot4 :+= res_0400 + res_0401 + res_0402 + res_0403 + res_0404;
tot5 :+= res_0500 + res_0501 + res_0502 + res_0503 + res_0504;
tot6 :+= res_0600 + res_0601 + res_0602 + res_0603 + res_0604;
tot7 :+= res_0700 + res_0701 + res_0702 + res_0703 + res_0704;
tot8 :+= res_0800 + res_0801 + res_0802 + res_0803 + res_0804;
tot9 :+= res_0900 + res_0901 + res_0902 + res_0903 + res_0904;

fpNice.fprintf("s/DDD0/%dms/\n", tot0);
fpNice.fprintf("s/DDD1/%dms/\n", tot1); 
fpNice.fprintf("s/DDD2/%dms/\n", tot2); 
fpNice.fprintf("s/DDD3/%dms/\n", tot3);
fpNice.fprintf("s/DDD4/%dms/\n", tot4);
fpNice.fprintf("s/DDD5/%dms/\n", tot5);
fpNice.fprintf("s/DDD6/%dms/\n", tot6);
fpNice.fprintf("s/DDD7/%dms/\n", tot7);
fpNice.fprintf("s/DDD8/%dms/\n", tot8);
fpNice.fprintf("s/DDD9/%dms/\n", tot9);

fpNice.fprintf("s/DDDD/%dms/\n",time - t); 

@- BATCH 4
@f scripts_select4
@mil
printf("# %d start of select4.mil\n", (t := time)-start); 
tot0 := 0; tot1 := 0; tot2 := 0; tot3 := 0; tot4 := 0; 
tot5 := 0; tot6 := 0; tot7 := 0; tot8 := 0; tot9 := 0;

var females_age_30to45_married_0, females_age_30to45_countryside_0, females_age_45to55_married_0;
var females_age_45to55_countryside_0, males_age_55to80_countryside_0;
var suburbia_age_18to45_mokum_0, suburbia_age_18to45_rotstad_0;
var married_females_countryside_0, center_age_60to100_mokum_0, center_age_45to55_mokum_0;

{|
  lichtstad_age_18to45_0 := nil;
  married_age_19to25_0 := nil;
  married_age_45to55_0 := nil;

  { var tt := time;     females_age_30to45_married_0 := "seq_0127".valselect(females_age_30to45_0,marital_0,"married"); res_0000 := time - tt; }
  { var tt := time; females_age_30to45_countryside_0 := "seq_0128".rngselect(females_age_30to45_0,zipcode_0,7000,9000); res_0100 := time - tt; }
  { var tt := time;     females_age_45to55_married_0 := "seq_0129".valselect(females_age_45to55_0,marital_0,"married"); res_0200 := time - tt; }
  { var tt := time; females_age_45to55_countryside_0 := "seq_0130".rngselect(females_age_45to55_0,zipcode_0,7000,9000); res_0300 := time - tt; }
  { var tt := time;   males_age_55to80_countryside_0 := "seq_0131".rngselect(males_age_55to80_0,zipcode_0,7000,9000);   res_0400 := time - tt; }
  { var tt := time;      suburbia_age_18to45_mokum_0 := "seq_0132".rngselect(mokum_age_18to45_0,zipcode_0,1000,3000);   res_0500 := time - tt; }
  { var tt := time;    suburbia_age_18to45_rotstad_0 := "seq_0133".rngselect(rotstad_age_18to45_0,zipcode_0,1000,3000); res_0600 := time - tt; }
  { var tt := time;    married_females_countryside_0 := "seq_0134".rngselect(married_females_0,zipcode_0,7000,9000);    res_0700 := time - tt; }
  { var tt := time;       center_age_60to100_mokum_0 := "seq_0135".rngselect(center_mokum_0,age_0,60,100);              res_0800 := time - tt; }
  { var tt := time;        center_age_45to55_mokum_0 := "seq_0136".rngselect(center_mokum_0,age_0,45,55);               res_0900 := time - tt; }
|}

@f scripts_batch4
@mil
printf("# %d start of group batch4.mil\n", time-start);

{|
  females_age_30to45_0 := nil;
  females_age_45to55_0 := nil;
  males_age_55to80_0 := nil;
  mokum_age_18to45_0 := nil;
  rotstad_age_18to45_0 := nil;
  married_females_0 := nil;
  center_mokum_0 := nil;

  res_0001 := "seq_0137".subcube("zipcode_0", "reliable_X", females_age_30to45_married_0);
  res_0201 := "seq_0138".subcube("zipcode_0", "reliable_X", females_age_45to55_married_0);

  res_0002 := "seq_0139".subcube("spendings_0", "reliable_X", females_age_30to45_married_0);
  res_0101 := "seq_0140".subcube("spendings_0", "reliable_X", females_age_30to45_countryside_0);
  res_0202 := "seq_0141".subcube("spendings_0", "reliable_X", females_age_45to55_married_0);
  res_0301 := "seq_0142".subcube("spendings_0", "reliable_X", females_age_45to55_countryside_0);
  res_0401 := "seq_0143".subcube("spendings_0", "reliable_X", males_age_55to80_countryside_0);
  res_0501 := "seq_0144".subcube("spendings_0", "reliable_X", suburbia_age_18to45_mokum_0);
  res_0601 := "seq_0145".subcube("spendings_0", "reliable_X", suburbia_age_18to45_rotstad_0);
  res_0701 := "seq_0146".subcube("spendings_0", "reliable_X", married_females_countryside_0);
  res_0801 := "seq_0147".subcube("spendings_0", "reliable_X", center_age_60to100_mokum_0);
  res_0901 := "seq_0148".subcube("spendings_0", "reliable_X", center_age_45to55_mokum_0);

  res_0702 := "seq_0149".subcube("age_0", "reliable_X", married_females_countryside_0);

  res_0003 := "seq_0150".subcube("town_0", "reliable_X", females_age_30to45_married_0);
  res_0102 := "seq_0151".subcube("town_0", "reliable_X", females_age_30to45_countryside_0);
  res_0203 := "seq_0152".subcube("town_0", "reliable_X", females_age_45to55_married_0);
  res_0302 := "seq_0153".subcube("town_0", "reliable_X", females_age_45to55_countryside_0);
  res_0402 := "seq_0154".subcube("town_0", "reliable_X", males_age_55to80_countryside_0);
  res_0703 := "seq_0155".subcube("town_0", "reliable_X", married_females_countryside_0);

  res_0103 := "seq_0156".subcube("marital_0", "reliable_X", females_age_30to45_countryside_0);
  res_0303 := "seq_0157".subcube("marital_0", "reliable_X", females_age_45to55_countryside_0);
  res_0403 := "seq_0158".subcube("marital_0", "reliable_X", males_age_55to80_countryside_0);
  res_0502 := "seq_0159".subcube("marital_0", "reliable_X", suburbia_age_18to45_mokum_0);
  res_0602 := "seq_0160".subcube("marital_0", "reliable_X", suburbia_age_18to45_rotstad_0);
  res_0802 := "seq_0161".subcube("marital_0", "reliable_X", center_age_60to100_mokum_0);
  res_0902 := "seq_0162".subcube("marital_0", "reliable_X", center_age_45to55_mokum_0);

  res_0503 := "seq_0163".subcube("gender_0", "reliable_X", suburbia_age_18to45_mokum_0);
  res_0603 := "seq_0164".subcube("gender_0", "reliable_X", suburbia_age_18to45_rotstad_0);
  res_0803 := "seq_0165".subcube("gender_0", "reliable_X", center_age_60to100_mokum_0);
  res_0903 := "seq_0166".subcube("gender_0", "reliable_X", center_age_45to55_mokum_0);
|}

tot0 :+= res_0000 + res_0001 + res_0002 + res_0003;
tot1 :+= res_0100 + res_0101 + res_0102 + res_0103;
tot2 :+= res_0200 + res_0201 + res_0202 + res_0203;
tot3 :+= res_0300 + res_0301 + res_0302 + res_0303;
tot4 :+= res_0400 + res_0401 + res_0402 + res_0403;
tot5 :+= res_0500 + res_0501 + res_0502 + res_0503;
tot6 :+= res_0600 + res_0601 + res_0602 + res_0603;
tot7 :+= res_0700 + res_0701 + res_0702 + res_0703;
tot8 :+= res_0800 + res_0801 + res_0802 + res_0803;
tot9 :+= res_0900 + res_0901 + res_0902 + res_0903;

fpNice.fprintf("s/EEE0/%dms/\n", tot0);
fpNice.fprintf("s/EEE1/%dms/\n", tot1); 
fpNice.fprintf("s/EEE2/%dms/\n", tot2); 
fpNice.fprintf("s/EEE3/%dms/\n", tot3);
fpNice.fprintf("s/EEE4/%dms/\n", tot4);
fpNice.fprintf("s/EEE5/%dms/\n", tot5);
fpNice.fprintf("s/EEE6/%dms/\n", tot6);
fpNice.fprintf("s/EEE7/%dms/\n", tot7);
fpNice.fprintf("s/EEE8/%dms/\n", tot8);
fpNice.fprintf("s/EEE9/%dms/\n", tot9);

@f scripts_epilogue
@mil
fpNice.fprintf("s/EEEE/%dms/\n",time - t); 
fpNice.fprintf("s/TOTALTIME/%dms/\n",time-start);
printf("# %d total time\n", time-start);
fps@batloop() fclose($t);

fpNice.fprintf("s/TITLE1/Monet/\n");
fpNice.fprintf("s/TITLE2/%s/\n", SCR);
fpNice.fprintf("s/CPUSUSED/%d/\n", PAR);
fpNice.fprintf("s/VERSCAL/%d/\n", VF);
fpNice.fprintf("s/HORSCAL/%d/\n", HF);
fpNice.fprintf("s/DBMSVERSION/Monet v%s/\n", environment.find("version"));
fpNice.fprintf("s/OSVERSION/%s/\n", environment.find("prefix"));
var tm := ctime;
fpNice.fprintf("s/REPORTDATE/%s/\n", tm.string(0, tm.length() - 1));
fpNice.fclose();

@f scripts_config
These are parameters in sed style that describe the machine configuration.
@p
# your company name
s/COMPANY/ACME Corp./

# basic machine parameters
s/CPUTYPE/unknown/
s/CPUSPERNODE/1/
s/SPECPERF/unknown/
s/MEMSIZE/unknown/
s/CACHESIZE/unknown/

# number of nodes connected by network (default: 1) 
s/PARNODES/1/
s/NETWORKBW/n.a./
s/NETWORKLAT/n.a./

# disk configuration
s/CTLTYPE/SCSI/
s/DISKTPE1/unknown/
s/DISKTPE2/ /
s/DISKTPE3/ /
s/DISKLAT1/X/
s/DISKLAT2/ms/
s/DISKLAT3/ /
s/DISKBW1/Y/
s/DISKBW2/MB\/s/
s/DISKBW3/ /
s/DISKUSAGE1/133*HF/
s/DISKUSAGE2/MB/
s/DISKUSAGE3/ /

# possible remark
s/EXTRA//
s/STARS//
s/NOTE//
#s/EXTRA/some remark/
#s/STARS/**/
#s/NOTE/footnote that appears at the bottom/

@f scripts_template
The DDBench results summary form in XFIG format. It contains capital
variable names that are filled in using a sed script. This sed script
is produced during the benchmark run; and is supplemented with some
machine-specific info that has to be filled in by hand (see above).
@p
#FIG 3.1
Portrait
Center
Inches
1200 2
6 12909 310 14019 1180
1 2 0 0 -1 7 4 0 20 0.0000000 1 0.000 13220 916 210 256 13012 662 13430 1172
1 2 0 0 -1 0 3 0 20 0.0000000 1 0.000 13216 931 180 220 13037 711 13396 1150
1 2 0 0 -1 0 10 0 20 0.0000000 1 0.000 13611 746 408 402 13204 343 14019 1147
2 4 0 0 -1 7 3 0 20 0.000 0 0 2 0 0 5
	 13431 990 13389 990 13389 367 13431 367 13431 990
2 2 0 0 -1 7 1 0 20 0.000 0 0 0 0 0 5
	 13386 931 13431 931 13431 1163 13386 1163 13386 931
2 2 0 0 -1 7 8 0 20 0.000 0 0 0 0 0 5
	 13510 310 12909 310 12909 1180 13510 1180 13510 310
2 2 0 0 -1 0 0 0 20 0.000 0 0 0 0 0 5
	 13389 911 13052 911 13052 1151 13389 1151 13389 911
2 2 0 0 -1 0 9 0 20 0.000 0 0 0 0 0 5
	 13612 343 13366 343 13366 1151 13612 1151 13612 343
2 2 0 0 -1 0 5 0 20 0.000 0 0 0 0 0 5
	 13053 342 13472 342 13472 1151 13053 1151 13053 342
2 2 0 0 -1 7 0 0 20 0.000 0 0 0 0 0 5
	 12998 318 13053 318 13053 1157 12998 1157 12998 318
2 3 0 0 -1 7 0 0 20 0.000 0 0 -1 0 0 9
	 13347 1152 13366 1128 13372 1115 13381 1092 13389 1071 13395 1053
	 13395 1157 13347 1157 13347 1152
2 4 0 0 -1 7 1 0 20 0.000 0 0 3 0 0 5
	 13426 419 13316 419 13316 366 13426 366 13426 419
-6
6 828 7654 4203 8629
2 4 0 1 -1 7 0 0 -1 0.000 0 0 11 0 0 5
	 4130 8557 4130 7657 831 7657 831 8557 4130 8557
2 4 0 1 -1 0 3 0 20 0.000 0 0 8 0 0 5
	 4130 7658 831 7658 831 7958 4130 7958 4130 7658
2 2 0 0 -1 0 1 0 20 0.000 0 0 0 0 0 5
	 4130 7805 830 7805 830 7996 4130 7996 4130 7805
-6
6 5329 11854 8704 12829
2 4 0 1 -1 7 0 0 -1 0.000 0 0 11 0 0 5
	 8631 12757 8631 11857 5332 11857 5332 12757 8631 12757
2 4 0 1 -1 0 3 0 20 0.000 0 0 8 0 0 5
	 8631 11858 5332 11858 5332 12158 8631 12158 8631 11858
2 2 0 0 -1 0 1 0 20 0.000 0 0 0 0 0 5
	 8631 12005 5331 12005 5331 12196 8631 12196 8631 12005
-6
6 5329 12904 8704 13879
2 4 0 1 -1 7 0 0 -1 0.000 0 0 11 0 0 5
	 8631 13807 8631 12907 5332 12907 5332 13807 8631 13807
2 4 0 1 -1 0 3 0 20 0.000 0 0 8 0 0 5
	 8631 12908 5332 12908 5332 13208 8631 13208 8631 12908
2 2 0 0 -1 0 1 0 20 0.000 0 0 0 0 0 5
	 8631 13055 5331 13055 5331 13246 8631 13246 8631 13055
-6
6 5329 13954 8704 14929
2 4 0 1 -1 7 0 0 -1 0.000 0 0 11 0 0 5
	 8631 14857 8631 13957 5332 13957 5332 14857 8631 14857
2 4 0 1 -1 0 3 0 20 0.000 0 0 8 0 0 5
	 8631 13958 5332 13958 5332 14258 8631 14258 8631 13958
2 2 0 0 -1 0 1 0 20 0.000 0 0 0 0 0 5
	 8631 14105 5331 14105 5331 14296 8631 14296 8631 14105
-6
6 5329 15004 8704 15979
2 4 0 1 -1 7 0 0 -1 0.000 0 0 11 0 0 5
	 8631 15907 8631 15007 5332 15007 5332 15907 8631 15907
2 4 0 1 -1 0 3 0 20 0.000 0 0 8 0 0 5
	 8631 15008 5332 15008 5332 15308 8631 15308 8631 15008
2 2 0 0 -1 0 1 0 20 0.000 0 0 0 0 0 5
	 8631 15155 5331 15155 5331 15346 8631 15346 8631 15155
-6
6 5329 16054 8704 17029
2 4 0 1 -1 7 0 0 -1 0.000 0 0 11 0 0 5
	 8631 16957 8631 16057 5332 16057 5332 16957 8631 16957
2 4 0 1 -1 0 3 0 20 0.000 0 0 8 0 0 5
	 8631 16058 5332 16058 5332 16358 8631 16358 8631 16058
2 2 0 0 -1 0 1 0 20 0.000 0 0 0 0 0 5
	 8631 16205 5331 16205 5331 16396 8631 16396 8631 16205
-6
6 5329 17104 8704 18079
2 4 0 1 -1 7 0 0 -1 0.000 0 0 11 0 0 5
	 8631 18007 8631 17107 5332 17107 5332 18007 8631 18007
2 4 0 1 -1 0 3 0 20 0.000 0 0 8 0 0 5
	 8631 17108 5332 17108 5332 17408 8631 17408 8631 17108
2 2 0 0 -1 0 1 0 20 0.000 0 0 0 0 0 5
	 8631 17255 5331 17255 5331 17446 8631 17446 8631 17255
-6
6 829 8704 4204 9679
2 4 0 1 -1 7 0 0 -1 0.000 0 0 11 0 0 5
	 4131 9607 4131 8707 832 8707 832 9607 4131 9607
2 4 0 1 -1 0 3 0 20 0.000 0 0 8 0 0 5
	 4131 8708 832 8708 832 9008 4131 9008 4131 8708
2 2 0 0 -1 0 1 0 20 0.000 0 0 0 0 0 5
	 4131 8855 831 8855 831 9046 4131 9046 4131 8855
-6
6 829 9754 4204 10729
2 4 0 1 -1 7 0 0 -1 0.000 0 0 11 0 0 5
	 4131 10657 4131 9757 832 9757 832 10657 4131 10657
2 4 0 1 -1 0 3 0 20 0.000 0 0 8 0 0 5
	 4131 9758 832 9758 832 10058 4131 10058 4131 9758
2 2 0 0 -1 0 1 0 20 0.000 0 0 0 0 0 5
	 4131 9905 831 9905 831 10096 4131 10096 4131 9905
-6
6 829 10804 4204 11779
2 4 0 1 -1 7 0 0 -1 0.000 0 0 11 0 0 5
	 4131 11707 4131 10807 832 10807 832 11707 4131 11707
2 4 0 1 -1 0 3 0 20 0.000 0 0 8 0 0 5
	 4131 10808 832 10808 832 11108 4131 11108 4131 10808
2 2 0 0 -1 0 1 0 20 0.000 0 0 0 0 0 5
	 4131 10955 831 10955 831 11146 4131 11146 4131 10955
-6
6 829 11854 4204 12829
2 4 0 1 -1 7 0 0 -1 0.000 0 0 11 0 0 5
	 4131 12757 4131 11857 832 11857 832 12757 4131 12757
2 4 0 1 -1 0 3 0 20 0.000 0 0 8 0 0 5
	 4131 11858 832 11858 832 12158 4131 12158 4131 11858
2 2 0 0 -1 0 1 0 20 0.000 0 0 0 0 0 5
	 4131 12005 831 12005 831 12196 4131 12196 4131 12005
-6
6 829 12904 4204 13879
2 4 0 1 -1 7 0 0 -1 0.000 0 0 11 0 0 5
	 4131 13807 4131 12907 832 12907 832 13807 4131 13807
2 4 0 1 -1 0 3 0 20 0.000 0 0 8 0 0 5
	 4131 12908 832 12908 832 13208 4131 13208 4131 12908
2 2 0 0 -1 0 1 0 20 0.000 0 0 0 0 0 5
	 4131 13055 831 13055 831 13246 4131 13246 4131 13055
-6
6 829 13954 4204 14929
2 4 0 1 -1 7 0 0 -1 0.000 0 0 11 0 0 5
	 4131 14857 4131 13957 832 13957 832 14857 4131 14857
2 4 0 1 -1 0 3 0 20 0.000 0 0 8 0 0 5
	 4131 13958 832 13958 832 14258 4131 14258 4131 13958
2 2 0 0 -1 0 1 0 20 0.000 0 0 0 0 0 5
	 4131 14105 831 14105 831 14296 4131 14296 4131 14105
-6
6 829 15004 4204 15979
2 4 0 1 -1 7 0 0 -1 0.000 0 0 11 0 0 5
	 4131 15907 4131 15007 832 15007 832 15907 4131 15907
2 4 0 1 -1 0 3 0 20 0.000 0 0 8 0 0 5
	 4131 15008 832 15008 832 15308 4131 15308 4131 15008
2 2 0 0 -1 0 1 0 20 0.000 0 0 0 0 0 5
	 4131 15155 831 15155 831 15346 4131 15346 4131 15155
-6
6 829 16054 4204 17029
2 4 0 1 -1 7 0 0 -1 0.000 0 0 11 0 0 5
	 4131 16957 4131 16057 832 16057 832 16957 4131 16957
2 4 0 1 -1 0 3 0 20 0.000 0 0 8 0 0 5
	 4131 16058 832 16058 832 16358 4131 16358 4131 16058
2 2 0 0 -1 0 1 0 20 0.000 0 0 0 0 0 5
	 4131 16205 831 16205 831 16396 4131 16396 4131 16205
-6
6 829 17104 4204 18079
2 4 0 1 -1 7 0 0 -1 0.000 0 0 11 0 0 5
	 4131 18007 4131 17107 832 17107 832 18007 4131 18007
2 4 0 1 -1 0 3 0 20 0.000 0 0 8 0 0 5
	 4131 17108 832 17108 832 17408 4131 17408 4131 17108
2 2 0 0 -1 0 1 0 20 0.000 0 0 0 0 0 5
	 4131 17255 831 17255 831 17446 4131 17446 4131 17255
-6
6 9829 7654 13204 8629
2 4 0 1 -1 7 0 0 -1 0.000 0 0 11 0 0 5
	 13131 8557 13131 7657 9832 7657 9832 8557 13131 8557
2 4 0 1 -1 0 3 0 20 0.000 0 0 8 0 0 5
	 13131 7658 9832 7658 9832 7958 13131 7958 13131 7658
2 2 0 0 -1 0 1 0 20 0.000 0 0 0 0 0 5
	 13131 7805 9831 7805 9831 7996 13131 7996 13131 7805
-6
6 9829 8704 13204 9679
2 4 0 1 -1 7 0 0 -1 0.000 0 0 11 0 0 5
	 13131 9607 13131 8707 9832 8707 9832 9607 13131 9607
2 4 0 1 -1 0 3 0 20 0.000 0 0 8 0 0 5
	 13131 8708 9832 8708 9832 9008 13131 9008 13131 8708
2 2 0 0 -1 0 1 0 20 0.000 0 0 0 0 0 5
	 13131 8855 9831 8855 9831 9046 13131 9046 13131 8855
-6
6 9829 9754 13204 10729
2 4 0 1 -1 7 0 0 -1 0.000 0 0 11 0 0 5
	 13131 10657 13131 9757 9832 9757 9832 10657 13131 10657
2 4 0 1 -1 0 3 0 20 0.000 0 0 8 0 0 5
	 13131 9758 9832 9758 9832 10058 13131 10058 13131 9758
2 2 0 0 -1 0 1 0 20 0.000 0 0 0 0 0 5
	 13131 9905 9831 9905 9831 10096 13131 10096 13131 9905
-6
6 9829 10804 13204 11779
2 4 0 1 -1 7 0 0 -1 0.000 0 0 11 0 0 5
	 13131 11707 13131 10807 9832 10807 9832 11707 13131 11707
2 4 0 1 -1 0 3 0 20 0.000 0 0 8 0 0 5
	 13131 10808 9832 10808 9832 11108 13131 11108 13131 10808
2 2 0 0 -1 0 1 0 20 0.000 0 0 0 0 0 5
	 13131 10955 9831 10955 9831 11146 13131 11146 13131 10955
-6
6 9829 11854 13204 12829
2 4 0 1 -1 7 0 0 -1 0.000 0 0 11 0 0 5
	 13131 12757 13131 11857 9832 11857 9832 12757 13131 12757
2 4 0 1 -1 0 3 0 20 0.000 0 0 8 0 0 5
	 13131 11858 9832 11858 9832 12158 13131 12158 13131 11858
2 2 0 0 -1 0 1 0 20 0.000 0 0 0 0 0 5
	 13131 12005 9831 12005 9831 12196 13131 12196 13131 12005
-6
6 9829 12904 13204 13879
2 4 0 1 -1 7 0 0 -1 0.000 0 0 11 0 0 5
	 13131 13807 13131 12907 9832 12907 9832 13807 13131 13807
2 4 0 1 -1 0 3 0 20 0.000 0 0 8 0 0 5
	 13131 12908 9832 12908 9832 13208 13131 13208 13131 12908
2 2 0 0 -1 0 1 0 20 0.000 0 0 0 0 0 5
	 13131 13055 9831 13055 9831 13246 13131 13246 13131 13055
-6
6 9829 13954 13204 14929
2 4 0 1 -1 7 0 0 -1 0.000 0 0 11 0 0 5
	 13131 14857 13131 13957 9832 13957 9832 14857 13131 14857
2 4 0 1 -1 0 3 0 20 0.000 0 0 8 0 0 5
	 13131 13958 9832 13958 9832 14258 13131 14258 13131 13958
2 2 0 0 -1 0 1 0 20 0.000 0 0 0 0 0 5
	 13131 14105 9831 14105 9831 14296 13131 14296 13131 14105
-6
6 9829 16054 13204 17029
2 4 0 1 -1 7 0 0 -1 0.000 0 0 11 0 0 5
	 13131 16957 13131 16057 9832 16057 9832 16957 13131 16957
2 4 0 1 -1 0 3 0 20 0.000 0 0 8 0 0 5
	 13131 16058 9832 16058 9832 16358 13131 16358 13131 16058
2 2 0 0 -1 0 1 0 20 0.000 0 0 0 0 0 5
	 13131 16205 9831 16205 9831 16396 13131 16396 13131 16205
-6
6 9829 15004 13204 15979
2 4 0 1 -1 7 0 0 -1 0.000 0 0 11 0 0 5
	 13131 15907 13131 15007 9832 15007 9832 15907 13131 15907
2 4 0 1 -1 0 3 0 20 0.000 0 0 8 0 0 5
	 13131 15008 9832 15008 9832 15308 13131 15308 13131 15008
2 2 0 0 -1 0 1 0 20 0.000 0 0 0 0 0 5
	 13131 15155 9831 15155 9831 15346 13131 15346 13131 15155
-6
6 9829 17104 13204 18079
2 4 0 1 -1 7 0 0 -1 0.000 0 0 11 0 0 5
	 13131 18007 13131 17107 9832 17107 9832 18007 13131 18007
2 4 0 1 -1 0 3 0 20 0.000 0 0 8 0 0 5
	 13131 17108 9832 17108 9832 17408 13131 17408 13131 17108
2 2 0 0 -1 0 1 0 20 0.000 0 0 0 0 0 5
	 13131 17255 9831 17255 9831 17446 13131 17446 13131 17255
-6
6 5324 10799 8774 11849
6 5329 10804 8704 11779
2 4 0 1 -1 7 0 0 -1 0.000 0 0 11 0 0 5
	 8631 11707 8631 10807 5332 10807 5332 11707 8631 11707
2 4 0 1 -1 0 3 0 20 0.000 0 0 8 0 0 5
	 8631 10808 5332 10808 5332 11108 8631 11108 8631 10808
2 2 0 0 -1 0 1 0 20 0.000 0 0 0 0 0 5
	 8631 10955 5331 10955 5331 11146 8631 11146 8631 10955
-6
4 0 7 0 0 22 12 0.0000000 4 180 2520 5404 11029 3.4 town=Amsterdam (.067)\001
-6
6 11069 6458 12719 7583
2 2 0 0 -1 7 0 0 1 0.000 0 0 0 0 0 5
	 11222 7140 11297 7140 11297 7290 11222 7290 11222 7140
2 2 0 0 -1 7 0 0 1 0.000 0 0 0 0 0 5
	 11447 7140 11522 7140 11522 7290 11447 7290 11447 7140
2 2 0 0 -1 7 0 0 1 0.000 0 0 0 0 0 5
	 11672 6690 11747 6690 11747 7290 11672 7290 11672 6690
2 2 0 0 -1 7 0 0 1 0.000 0 0 0 0 0 5
	 11897 6540 11897 6540 11897 7365 11897 7365 11897 6540
2 2 0 0 -1 7 0 0 1 0.000 0 0 0 0 0 5
	 11897 6540 11972 6540 11972 7290 11897 7290 11897 6540
2 2 0 0 -1 7 0 0 1 0.000 0 0 0 0 0 5
	 12122 6765 12197 6765 12197 7290 12122 7290 12122 6765
2 2 0 0 -1 7 0 0 1 0.000 0 0 0 0 0 5
	 12347 6915 12422 6915 12422 7290 12347 7290 12347 6915
2 2 0 0 -1 7 0 0 1 0.000 0 0 0 0 0 5
	 12572 6765 12647 6765 12647 7290 12572 7290 12572 6765
2 2 0 0 -1 7 0 0 8 0.000 0 0 0 0 0 5
	 11147 7290 11222 7290 11222 6690 11147 6690 11147 7290
2 2 0 0 -1 7 0 0 8 0.000 0 0 0 0 0 5
	 11372 7290 11447 7290 11447 6765 11372 6765 11372 7290
2 2 0 0 -1 7 0 0 8 0.000 0 0 0 0 0 5
	 11597 7290 11672 7290 11672 6540 11597 6540 11597 7290
2 2 0 0 -1 7 0 0 8 0.000 0 0 0 0 0 5
	 11822 6465 11897 6465 11897 7290 11822 7290 11822 6465
2 2 0 0 -1 7 0 0 8 0.000 0 0 0 0 0 5
	 12047 6840 12122 6840 12122 7290 12047 7290 12047 6840
2 2 0 0 -1 7 0 0 8 0.000 0 0 0 0 0 5
	 12272 7065 12347 7065 12347 7290 12272 7290 12272 7065
2 2 0 0 -1 7 0 0 8 0.000 0 0 0 0 0 5
	 12497 7140 12572 7140 12572 7290 12497 7290 12497 7140
4 0 -1 0 0 22 16 0.0000000 4 240 1710 11080 7480 ..against reliable\001
-6
2 1 0 3 -1 7 0 0 -1 0.000 0 0 -1 0 0 2
	 300 1200 14100 1200
2 1 0 3 -1 7 0 0 -1 0.000 0 0 -1 0 0 2
	 4200 300 4200 1200
2 1 0 3 -1 7 0 0 -1 0.000 0 0 -1 0 0 2
	 9000 300 9000 1200
2 1 0 3 -1 7 0 0 -1 0.000 0 0 -1 0 0 2
	 9000 3900 9000 4725
2 2 0 3 -1 7 0 0 -1 0.000 0 0 0 0 0 5
	 300 300 14100 300 14100 19875 300 19875 300 300
2 4 0 1 -1 7 0 0 -1 0.000 0 0 11 0 0 5
	 8632 10657 8632 9757 5333 9757 5333 10657 8632 10657
2 4 0 1 -1 0 3 0 20 0.000 0 0 8 0 0 5
	 8632 9758 5333 9758 5333 10058 8632 10058 8632 9758
2 4 0 1 -1 7 0 0 -1 0.000 0 0 11 0 0 5
	 8632 9607 8632 8707 5333 8707 5333 9607 8632 9607
2 4 0 1 -1 0 3 0 20 0.000 0 0 8 0 0 5
	 8632 8708 5333 8708 5333 9008 8632 9008 8632 8708
2 2 0 0 -1 0 1 0 20 0.000 0 0 0 0 0 5
	 8632 8855 5332 8855 5332 9046 8632 9046 8632 8855
2 4 0 1 -1 7 0 0 -1 0.000 0 0 11 0 0 5
	 8632 8557 8632 7657 5333 7657 5333 8557 8632 8557
2 4 0 1 -1 0 3 0 20 0.000 0 0 8 0 0 5
	 8632 7658 5333 7658 5333 7958 8632 7958 8632 7658
2 2 0 0 -1 0 1 0 20 0.000 0 0 0 0 0 5
	 8632 7805 5332 7805 5332 7996 8632 7996 8632 7805
2 2 0 0 -1 0 1 0 20 0.000 0 0 0 0 0 5
	 8632 9859 5332 9859 5332 10050 8632 10050 8632 9859
2 2 0 0 -1 7 1 0 16 0.000 0 0 0 0 0 5
	 904 18150 4054 18150 4054 18900 904 18900 904 18150
2 2 0 0 -1 7 1 0 16 0.000 0 0 0 0 0 5
	 5400 18150 8550 18150 8550 18900 5400 18900 5400 18150
2 2 0 0 -1 7 1 0 16 0.000 0 0 0 0 0 5
	 9975 18150 13125 18150 13125 18900 9975 18900 9975 18150
2 2 0 1 -1 7 1 0 16 0.000 0 0 0 0 0 5
	 300 19200 14100 19200 14100 19875 300 19875 300 19200
2 1 0 1 -1 7 0 0 -1 0.000 0 0 -1 0 0 2
	 9000 3675 14100 3675
2 1 0 1 -1 7 0 0 -1 0.000 0 0 -1 0 0 2
	 11325 3675 11325 4725
2 1 0 1 -1 7 0 0 -1 0.000 0 0 -1 0 0 2
	 4200 1800 9000 1800
2 1 0 1 -1 7 0 0 -1 0.000 0 0 -1 0 0 2
	 9000 1800 9000 1200
2 1 0 1 -1 7 0 0 -1 0.000 0 0 -1 0 0 4
	 4200 2550 9000 2550 9000 3000 14100 3000
2 1 0 1 -1 7 0 0 -1 0.000 0 0 -1 0 0 2
	 9000 3000 9000 3900
2 1 0 1 -1 7 0 0 1 0.000 0 0 -1 0 0 2
	 4800 7575 4800 19200
2 1 0 1 -1 7 0 0 1 0.000 0 0 -1 0 0 2
	 9300 7575 9300 19200
2 1 0 5 -1 7 0 0 -1 0.000 0 0 -1 0 0 2
	 4125 8100 5325 8100
2 1 0 5 -1 7 0 0 -1 0.000 0 0 -1 0 0 2
	 4125 8100 5325 9300
2 1 0 5 -1 7 0 0 -1 0.000 0 0 -1 0 0 2
	 4125 9150 5325 10200
2 1 0 5 -1 7 0 0 -1 0.000 0 0 -1 0 0 2
	 4125 10275 5325 11325
2 1 0 5 -1 7 0 0 -1 0.000 0 0 -1 0 0 2
	 4125 10275 5325 12375
2 1 0 5 -1 7 0 0 -1 0.000 0 0 -1 0 0 2
	 4125 10275 5325 13500
2 1 0 5 -1 7 0 0 -1 0.000 0 0 -1 0 0 2
	 4125 14475 5325 14475
2 1 0 5 -1 7 0 0 -1 0.000 0 0 -1 0 0 2
	 4125 14475 5325 15600
2 1 0 5 -1 7 0 0 -1 0.000 0 0 -1 0 0 2
	 4125 14475 5325 16650
2 1 0 5 -1 7 0 0 -1 0.000 0 0 -1 0 0 2
	 4125 16575 5325 17625
2 1 0 5 -1 7 0 0 -1 0.000 0 0 -1 0 0 2
	 8625 8100 9825 8100
2 1 0 5 -1 7 0 0 -1 0.000 0 0 -1 0 0 2
	 8625 8100 9825 9225
2 1 0 5 -1 7 0 0 -1 0.000 0 0 -1 0 0 2
	 8625 9150 9825 10275
2 1 0 5 -1 7 0 0 -1 0.000 0 0 -1 0 0 2
	 8625 9150 9825 11325
2 1 0 5 -1 7 0 0 -1 0.000 0 0 -1 0 0 2
	 8625 10200 9825 12375
2 1 0 5 -1 7 0 0 -1 0.000 0 0 -1 0 0 2
	 8625 11325 9825 13425
2 1 0 5 -1 7 0 0 -1 0.000 0 0 -1 0 0 2
	 8625 12450 9825 14550
2 1 0 5 -1 7 0 0 -1 0.000 0 0 -1 0 0 2
	 8602 16550 9802 15425
2 1 0 5 -1 7 0 0 -1 0.000 0 0 -1 0 0 2
	 8625 17625 9825 16500
2 1 0 5 -1 7 0 0 -1 0.000 0 0 -1 0 0 2
	 8625 17625 9825 17625
2 2 0 0 -1 7 1 0 16 0.000 0 0 0 0 0 5
	 381 5631 2626 5631 2626 6381 381 6381 381 5631
2 1 0 1 -1 7 0 0 1 0.000 0 0 -1 0 0 2
	 3976 5478 3976 7278
2 1 0 1 -1 7 0 0 1 0.000 0 0 -1 0 0 2
	 5401 5478 5401 7278
2 1 0 1 -1 7 0 0 1 0.000 0 0 -1 0 0 2
	 6826 5478 6826 7278
2 1 0 1 -1 7 0 0 1 0.000 0 0 -1 0 0 2
	 8251 5478 8251 7278
2 1 0 1 -1 7 0 0 1 0.000 0 0 -1 0 0 2
	 9676 5478 9676 7278
2 1 0 1 -1 7 0 0 1 0.000 0 0 -1 0 0 2
	 11101 5478 11101 7278
2 1 0 1 -1 7 0 0 -1 0.000 0 0 -1 0 0 3
	 2701 5477 2701 7277 11101 7277
2 2 0 0 -1 7 1 0 16 0.000 0 0 0 0 0 5
	 381 6531 2626 6531 2626 7281 381 7281 381 6531
2 1 0 3 -1 7 0 0 -1 0.000 0 0 -1 0 0 2
	 300 3675 9000 3675
2 1 0 3 -1 7 0 0 -1 0.000 0 0 -1 0 0 2
	 4200 825 4200 3675
2 4 0 0 -1 0 1 0 20 0.000 0 0 7 0 0 5
	 12600 5477 2543 5477 2543 5177 12600 5177 12600 5477
2 1 0 1 -1 7 0 0 -1 0.000 0 0 -1 0 0 2
	 2700 6375 6825 6375
2 1 0 1 -1 7 0 0 -1 0.000 0 0 -1 0 0 2
	 12542 6379 14042 6379
2 2 0 1 -1 7 0 0 0 0.000 0 0 0 0 0 5
	 12767 6379 12917 6379 12917 6079 12767 6079 12767 6379
2 2 0 1 -1 7 0 0 0 0.000 0 0 0 0 0 5
	 12992 6379 13142 6379 13142 5554 12992 5554 12992 6379
2 2 0 1 -1 7 0 0 0 0.000 0 0 0 0 0 5
	 13217 6379 13367 6379 13367 5404 13217 5404 13217 6379
2 2 0 1 -1 7 0 0 0 0.000 0 0 0 0 0 5
	 13442 6379 13592 6379 13592 5854 13442 5854 13442 6379
2 2 0 1 -1 7 0 0 0 0.000 0 0 0 0 0 5
	 13667 6379 13817 6379 13817 6079 13667 6079 13667 6379
2 2 0 1 -1 7 0 0 0 0.000 0 0 0 0 0 5
	 13892 6379 14042 6379 14042 6004 13892 6004 13892 6379
2 2 0 1 -1 7 0 0 0 0.000 0 0 0 0 0 5
	 12692 6379 12542 6379 12542 6004 12692 6004 12692 6379
2 1 0 1 -1 7 0 0 -1 0.000 0 0 -1 0 0 2
	 12450 6375 12450 5475
2 1 0 1 -1 7 0 0 -1 0.000 0 0 -1 0 0 2
	 6825 6375 11100 6375
2 1 0 1 -1 7 0 0 -1 0.000 0 0 -1 0 0 2
	 11101 6375 12451 6375
2 1 0 1 -1 7 0 0 1 0.000 0 0 -1 0 0 2
	 376 7576 14176 7576
2 1 0 3 -1 7 0 0 -1 0.000 0 0 -1 0 0 2
	 300 4725 14100 4725
2 1 0 1 -1 7 0 0 -1 0.000 0 0 -1 0 0 2
	 12150 3675 12150 4725
2 1 0 1 -1 7 0 0 -1 0.000 0 0 -1 0 0 2
	 12975 3675 12975 4725
2 2 0 0 -1 7 9 0 16 0.000 0 0 0 0 0 5
	 9000 1200 14100 1200 14100 2175 9000 2175 9000 1200
2 2 0 0 -1 7 9 0 16 0.000 0 0 0 0 0 5
	 300 3675 9000 3675 9000 4725 300 4725 300 3675
4 0 -1 0 0 2 24 0.0000000 4 330 3570 4800 1650 Hardware Description\001
4 0 -1 0 0 0 18 0.0000000 4 195 1830 9300 1050 REPORTDATE\001
4 0 -1 0 0 0 24 0.0000000 4 255 3030 9525 675 DD Benchmark v1.0\001
4 0 -1 0 0 2 24 0.0000000 4 330 3375 450 1650 Software Description\001
4 0 -1 0 0 2 18 0.0000000 4 195 1500 2478 18753 SUBTOTAL\001
4 0 -1 0 0 2 18 0.0000000 4 195 1500 6978 18753 SUBTOTAL\001
4 0 -1 0 0 2 18 0.0000000 4 195 1500 11478 18753 SUBTOTAL\001
4 0 -1 0 0 2 18 0.0000000 4 195 1110 2628 18453 BATCH2\001
4 0 -1 0 0 2 18 0.0000000 4 195 1110 7128 18453 BATCH3\001
4 0 -1 0 0 2 18 0.0000000 4 195 1110 11628 18453 BATCH4\001
4 0 7 0 0 22 12 0.0000000 4 180 2340 904 14179 2.7 marital=married (.500)\001
4 0 7 0 0 22 12 0.0000000 4 180 2175 904 13129 2.6 marital=single (.199)\001
4 0 7 0 0 22 12 0.0000000 4 180 2130 904 12079 2.5 age in [55,80] (.111)\001
4 0 7 0 0 22 12 0.0000000 4 180 2130 904 11029 2.4 age in [45,55] (.142)\001
4 0 7 0 0 22 12 0.0000000 4 180 2130 904 9979 2.3 age in [18,45] (.550)\001
4 0 7 0 0 22 12 0.0000000 4 180 2070 904 8929 2.2 gender=male (.500)\001
4 0 7 0 0 22 12 0.0000000 4 180 2250 906 7881 2.1 gender=female (.500)\001
4 0 7 0 0 22 12 0.0000000 4 180 2895 904 16279 2.9 zipcode in [3000,4000] (.285)\001
4 0 7 0 0 22 12 0.0000000 4 180 2430 904 15229 2.8 marital=divorced (.200)\001
4 0 7 0 0 22 12 0.0000000 4 180 2130 5406 7881 3.1 age in [30,45] (.155)\001
4 0 7 0 0 22 12 0.0000000 4 180 2130 5404 8929 3.2 age in [45,55] (.071)\001
4 0 7 0 0 22 12 0.0000000 4 180 2130 5404 9979 3.3 age in [55,80] (.056)\001
4 0 7 0 0 22 12 0.0000000 4 180 3000 904 17329 2.10 zipcode in [4000,7000] (.430)\001
4 0 7 0 0 14 12 0.0000000 4 165 2730 5404 17329 3.10 town=Amsterdam (.004)\001
4 0 7 0 0 22 12 0.0000000 4 180 2250 5404 16279 3.9 gender=female (.250)\001
4 0 7 0 0 22 12 0.0000000 4 180 2130 5404 15229 3.8 age in [45,55] (.071)\001
4 0 7 0 0 22 12 0.0000000 4 180 2130 5404 14179 3.7 age in [19,25] (.069)\001
4 0 7 0 0 22 12 0.0000000 4 180 2415 5404 13129 3.6 town=Eindhoven (.236)\001
4 0 7 0 0 22 12 0.0000000 4 180 2445 5404 12079 3.5 town=Rotterdam (.051)\001
4 0 7 0 0 22 12 0.0000000 4 180 2340 9907 7882 4.1 marital=married (.077)\001
4 0 7 0 0 22 12 0.0000000 4 180 2895 9904 8929 4.2 zipcode in [7000,7999] (.022)\001
4 0 7 0 0 22 12 0.0000000 4 180 2340 9904 9979 4.3 marital=married (.036)\001
4 0 7 0 0 22 12 0.0000000 4 180 2895 9904 11029 4.4 zipcode in [7000,7999] (.010)\001
4 0 7 0 0 22 12 0.0000000 4 180 2895 9904 13129 4.6 zipcode in [1000,3000] (.011)\001
4 0 7 0 0 22 12 0.0000000 4 180 2895 9904 12079 4.5 zipcode in [7000,7999] (.008)\001
4 0 7 0 0 22 12 0.0000000 4 180 2895 9904 14179 4.7 zipcode in [1000,3000] (.014)\001
4 0 7 0 0 22 12 0.0000000 4 180 2895 9904 15229 4.8 zipcode in [7000,7999] (.035)\001
4 0 7 0 0 14 12 0.0000000 4 180 2730 9904 16279 4.9 age in [60,100] (.003)\001
4 0 7 0 0 14 12 0.0000000 4 180 2835 9904 17329 4.10 age in [45,55] (0.005)\001
4 0 -1 0 0 2 36 0.0000000 4 360 7815 903 19728 OVERALL EXECUTION TIME: \001
4 0 -1 0 0 0 18 0.0000000 4 195 1275 9150 3600 Disk Drives\001
4 0 -1 0 0 0 18 0.0000000 4 195 1185 10800 3600 bandwidth\001
4 0 -1 0 0 0 18 0.0000000 4 255 810 12150 3600 latency\001
4 0 -1 0 0 0 18 0.0000000 4 195 600 13200 3600 usage\001
4 0 -1 0 0 2 18 0.0000000 4 255 2985 10050 3225 IO subsystem description\001
4 0 -1 0 0 2 18 0.0000000 4 195 2685 5175 3000 Network Architecture:\001
4 0 -1 0 0 2 18 0.0000000 4 255 2985 4425 2325 #Computing Nodes Used:\001
4 0 -1 0 0 2 36 0.0000000 4 225 270 8625 2475 *\001
4 0 -1 0 0 0 14 0.0000002 4 195 4500 5100 7500 (ordinalities  are indicated between square brackets)\001
4 0 -1 0 0 2 14 0.0000000 4 150 1170 450 6225 SUBTOTAL\001
4 0 -1 0 0 2 14 0.0000000 4 150 1170 450 7125 SUBTOTAL\001
4 0 -1 0 0 2 14 0.0000000 4 150 885 600 6825 BATCH1\001
4 0 -1 0 0 2 14 0.0000000 4 150 885 525 5925 BATCH0\001
4 0 -1 0 0 0 14 4.7123890 4 195 7380 13575 8175 (group sizes are indicated between parentheses (e.g. .42 means .42*1M*VF elements)\001
4 0 -1 0 0 0 18 0.0000000 4 195 1245 4500 3600 bandwidth:\001
4 0 -1 0 0 0 18 0.0000000 4 255 870 6975 3600 latency:\001
4 0 -1 0 0 2 24 0.0000000 4 255 2610 450 4050 Benchmark Size\001
4 0 -1 0 0 0 18 0.0000000 4 255 2055 450 3000 Operating System:\001
4 0 -1 0 0 0 18 0.0000000 4 195 825 525 2325 DBMS:\001
4 0 -1 0 0 2 18 0.0000000 4 255 2475 3375 3975 vertical scaling (VF):\001
4 0 -1 0 0 2 18 0.0000000 4 255 1380 7575 3975 * 1M tuples\001
4 0 -1 0 0 2 18 0.0000000 4 255 2835 3150 4350 horizontal scaling (HF):\001
4 0 -1 0 0 2 18 0.0000000 4 195 1830 7125 4350 * 100 attributes\001
4 0 -1 0 0 22 16 0.0000000 4 240 1815 12390 6602 simple histogram\001
4 0 7 0 0 22 14 0.0000000 4 210 1425 2691 5409 zipcode[7000]\001
4 0 7 0 0 22 14 0.0000000 4 210 1605 4046 5409 spendings[101]\001
4 0 7 0 0 22 14 0.0000000 4 210 885 5701 5401 age[100]\001
4 0 7 0 0 22 14 0.0000000 4 210 1005 7126 5401 gender[2]\001
4 0 7 0 0 22 14 0.0000000 4 210 885 8458 5410 town[15]\001
4 0 7 0 0 22 14 0.0000000 4 210 975 10015 5410 marital[3]\001
4 0 7 0 0 22 14 0.0000000 4 210 1035 11505 5410 reliable[2]\001
4 0 -1 0 0 2 36 0.0000000 4 360 2940 8100 2400 PARNODES\001
4 0 -1 0 0 2 18 0.0000000 4 195 1905 5925 3525 NETWORKBW\001
4 0 -1 0 0 2 18 0.0000000 4 195 2010 7950 3525 NETWORKLAT\001
4 0 -1 0 0 2 18 0.0000000 4 195 1680 1275 3375 OSVERSION\001
4 0 -1 0 0 2 18 0.0000000 4 195 1620 10950 2400 CACHESIZE\001
4 0 -1 0 0 2 18 0.0000000 4 195 1275 10950 2775 CTLTYPE\001
4 0 -1 0 0 2 18 0.0000000 4 195 1320 6300 3975 VERSCAL\001
4 0 -1 0 0 2 18 0.0000000 4 195 1380 6300 4350 HORSCAL\001
4 0 -1 0 0 2 18 0.0000000 4 195 1365 9075 3975 DISKTPE1\001
4 0 -1 0 0 2 18 0.0000000 4 195 1365 9075 4275 DISKTPE2\001
4 0 -1 0 0 2 18 0.0000000 4 195 1365 9075 4575 DISKTPE3\001
4 0 -1 0 0 2 18 0.0000000 4 195 825 5100 1050 TITLE2\001
4 0 -1 0 0 2 18 0.0000000 4 195 1290 11400 4275 DISKBW2\001
4 0 -1 0 0 2 18 0.0000000 4 195 1290 11400 4575 DISKBW3\001
4 0 -1 0 0 2 18 0.0000000 4 195 1290 11400 3975 DISKBW1\001
4 0 -1 0 0 2 18 0.0000000 4 195 1395 12300 4275 DISKLAT2\001
4 0 -1 0 0 2 18 0.0000000 4 195 1395 12300 4575 DISKLAT3\001
4 0 -1 0 0 2 18 0.0000000 4 195 1395 12300 3975 DISKLAT1\001
4 0 -1 0 0 2 18 0.0000000 4 195 1320 10650 1500 MEMSIZE\001
4 0 -1 0 0 0 18 0.0000000 4 195 765 9075 2025 #CPUs\001
4 0 -1 0 0 2 18 0.0000000 4 195 2085 9975 2025 CPUSPERNODE\001
4 0 -1 0 0 0 18 0.0000000 4 195 540 10275 2025 used:\001
4 0 -1 0 0 0 18 0.0000000 4 255 1530 9075 1500 Memory Size:\001
4 0 -1 0 0 0 18 0.0000000 4 255 1770 9150 2401 Cache Memory:\001
4 0 -1 0 0 0 18 0.0000000 4 195 1725 9225 2776 Disk controller:\001
4 0 -1 0 0 2 18 0.0000000 4 195 135 10950 2025 CPUSUSED\001
4 0 -1 0 0 2 18 0.0000000 4 195 2100 4425 675 DBMSVERSION\001
4 0 -1 0 0 2 18 0.0000000 4 195 960 1275 2625 TITLE1\001
4 0 -1 0 0 22 18 0.0000000 4 270 14130 375 5025 compute decision rules with beamsearch(width=10,depth=3) predicting 'reliable' using confidence intervals\001
4 0 -1 0 0 2 18 0.0000000 4 195 1800 13125 4575 DISKUSAGE3\001
4 0 -1 0 0 2 18 0.0000000 4 195 1800 13125 4275 DISKUSAGE2\001
4 0 -1 0 0 2 18 0.0000000 4 195 1800 13125 3975 DISKUSAGE1\001
4 0 -1 0 0 2 18 0.0000000 4 195 720 2850 6075 AAA0\001
4 0 -1 0 0 2 18 0.0000000 4 195 720 4200 6075 AAA1\001
4 0 -1 0 0 2 18 0.0000000 4 195 720 5625 6075 AAA2\001
4 0 -1 0 0 2 18 0.0000000 4 195 720 7125 6075 AAA3\001
4 0 -1 0 0 2 18 0.0000000 4 195 720 8475 6075 AAA4\001
4 0 -1 0 0 2 18 0.0000000 4 195 720 9900 6075 AAA5\001
4 0 -1 0 0 2 18 0.0000000 4 195 720 11325 6075 AAA6\001
4 0 -1 0 0 2 18 0.0000000 4 195 675 2925 6975 BBB0\001
4 0 -1 0 0 2 18 0.0000000 4 195 675 5700 6975 BBB2\001
4 0 -1 0 0 2 18 0.0000000 4 195 675 4200 6975 BBB1\001
4 0 -1 0 0 2 18 0.0000000 4 195 675 7125 6975 BBB3\001
4 0 -1 0 0 2 18 0.0000000 4 195 675 8475 6975 BBB4\001
4 0 -1 0 0 2 18 0.0000000 4 195 675 9975 6975 BBB5\001
4 0 -1 0 0 2 18 0.0000000 4 195 945 750 5475 EXTRA\001
4 0 -1 0 0 2 18 0.0000000 4 195 900 1875 5400 STARS\001
4 0 -1 0 0 2 18 0.0000000 4 195 720 1575 6975 BBBB\001
4 0 -1 0 0 2 18 0.0000000 4 195 780 1575 6150 AAAA\001
4 0 -1 0 0 2 18 0.0000000 4 195 720 1875 8400 CCC0\001
4 0 -1 0 0 2 18 0.0000000 4 195 720 1875 9375 CCC1\001
4 0 -1 0 0 2 18 0.0000000 4 195 720 1726 11475 CCC3\001
4 0 -1 0 0 2 18 0.0000000 4 195 720 1801 12600 CCC4\001
4 0 -1 0 0 2 18 0.0000000 4 195 720 1801 13575 CCC5\001
4 0 -1 0 0 2 18 0.0000000 4 195 720 1801 14625 CCC6\001
4 0 -1 0 0 2 18 0.0000000 4 195 720 1726 15675 CCC7\001
4 0 -1 0 0 2 18 0.0000000 4 195 720 1726 16725 CCC8\001
4 0 -1 0 0 2 18 0.0000000 4 195 720 1800 10500 CCC2\001
4 0 -1 0 0 2 18 0.0000000 4 195 720 1725 17775 CCC9\001
4 0 -1 0 0 2 18 0.0000000 4 195 765 6375 8400 DDD0\001
4 0 -1 0 0 2 18 0.0000000 4 195 765 6375 9450 DDD1\001
4 0 -1 0 0 2 18 0.0000000 4 195 765 6450 10425 DDD2\001
4 0 -1 0 0 2 18 0.0000000 4 195 765 6450 11550 DDD3\001
4 0 -1 0 0 2 18 0.0000000 4 195 765 6450 12600 DDD4\001
4 0 -1 0 0 2 18 0.0000000 4 195 765 6450 13575 DDD5\001
4 0 -1 0 0 2 18 0.0000000 4 195 765 6375 14700 DDD6\001
4 0 -1 0 0 2 18 0.0000000 4 195 765 6450 15750 DDD7\001
4 0 -1 0 0 2 18 0.0000000 4 195 765 6450 16725 DDD8\001
4 0 -1 0 0 2 18 0.0000000 4 195 765 6450 17775 DDD9\001
4 0 -1 0 0 2 18 0.0000000 4 195 675 10950 8325 EEE0\001
4 0 -1 0 0 2 18 0.0000000 4 195 675 10950 9450 EEE1\001
4 0 -1 0 0 2 18 0.0000000 4 195 675 10950 10500 EEE2\001
4 0 -1 0 0 2 18 0.0000000 4 195 675 10875 11550 EEE3\001
4 0 -1 0 0 2 18 0.0000000 4 195 675 10950 12600 EEE4\001
4 0 -1 0 0 2 18 0.0000000 4 195 675 10875 13650 EEE5\001
4 0 -1 0 0 2 18 0.0000000 4 195 675 10875 14700 EEE6\001
4 0 -1 0 0 2 18 0.0000000 4 195 675 10875 15675 EEE7\001
4 0 -1 0 0 2 18 0.0000000 4 195 675 10875 16725 EEE8\001
4 0 -1 0 0 2 18 0.0000000 4 195 675 10950 17850 EEE9\001
4 0 -1 0 0 2 18 0.0000000 4 195 795 1050 20175 NOTE\001
4 0 -1 0 0 2 18 0.0000000 4 195 780 1050 18600 CCCC\001
4 0 -1 0 0 2 18 0.0000000 4 195 840 5625 18600 DDDD\001
4 0 -1 0 0 2 18 0.0000000 4 195 720 10275 18600 EEEE\001
4 0 -1 0 0 2 36 0.0000000 4 360 2790 600 900 COMPANY\001
4 0 -1 0 0 0 18 0.0000000 4 270 3720 5250 4650 (1 target, 6*HF query attributes)\001
4 0 -1 0 0 0 18 0.0000000 4 195 1290 11700 2100 SPECint95:\001
4 0 -1 0 0 2 18 0.0000000 4 195 1410 13050 2100 SPECPERF\001
4 0 -1 0 0 0 18 0.0000000 4 225 525 11700 1725 type:\001
4 0 -1 0 0 2 18 0.0000000 4 195 1620 12450 1725 CPUTYPE\001
4 0 -1 0 0 2 36 0.0000000 4 360 3255 8775 19725 TOTALTIME\001
