@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.

@f cluster
@a Peter Boncz
@v 1.0
@t BAT Clustering

@* Introduction
When working in a main-memory situation, clustering of data on disk-pages
is not important. Whenever mmap()-ed data is used intensively from cold
tables, reducing the number of pagefaults becomes a hot issue.
@
The below functions rearrange data in Monet heaps (used for storing
BUNs var-sized atoms, or accelerators). Applying these clusterings will
allow that Monet's main-memory oriented algorithms work efficient  also
in such a disk-oriented context.

@* Module Definition
@m
.MODULE cluster;

@- multi-pass sorting
Sorting that makes use of double elimination, and using partitioning.
@m
.COMMAND order (bat[any::1,any::2] b, int partitions) 
				: bat[any::1,any::2] = CMDpart_order;
"Fast order() on BATs that exceed main-memory, using partitioning. Returns b."

@- arbitrary clusterings
@m
.COMMAND acccluster(BAT[any,any], int acctype) = CMDacccluster;
"Call the accelerator-specific cluster function to rearrange the
 cause less page faults."

.COMMAND heapclustercopy(BAT[any,any], BAT[any,any]) = CMDheapclustercopy;
"Rearrange the *tail* atoms -- that are supposed to of a variable sized
 typle like 'str' -- in the tail heap of the first BAT. They are put in
 order of appearance of the head elements of the second BAT. That is,
 for each head element from the second BAT we look up the appearance of
 this head element in the first BAT, and re-insert the corresponding tail
 element.
 WARNING: the second BAT *must* be a superset of the first, otherwise
 tuples will be lost!
 WARNING: you better work with head-unique BAts for this, otherwise
 the semantics are very vague.
 NOTE: the two BATs may be equal, in which case lookup is trivial."

.END cluster;
@{
@* Module Implementation
@= unary
int CMD@1(BAT **retval, BAT *b){
	return (*retval = @2(b))?GDK_SUCCEED:GDK_FAIL;
}
@= idxloop
IDXloop(b, p, q) {
        if (*p) BUNfastins(c, BUNh@1(b, (*p)), BUNt@2(b, (*p)));
}
@c
#include "cluster.proto.h"

BAT *BATsort_insert(BAT *c, BAT *b) {
        BUN     *p;
        BUN     *q;
        BATcheck(c, "BATsort: BAT c");
        BATcheck(b, "BATsort: BAT b");
        if (!BATidx(b, NULL)) {
                return NULL;
        }
        p = IDXfirst(b);
        q = IDXlast(b);
        if (b->hvarsized){
                if (b->tvarsized){
                        @:idxloop(var,var)@
                } else {
                        @:idxloop(var,loc)@
                }
        } else {
                if (b->tvarsized){
                        @:idxloop(loc,var)@
                } else {
                        @:idxloop(loc,loc)@
                }
        }
        return c;
}

@- Sorting with Partitioning
If the BAT to be sorted is >> larger than main-memory, it pays to
range-partition the relation first in chunks that fit the memory,
and then sort the chunks with the most efficient MM algorithm.
@
This sorting only changes the order of the tuples in the BUN heap.
Care is taken to leave the head and tail heaps intact.
@c
int CMDpart_order(
   BAT**	ret, /* will return b */
   BAT*         b,   /* pointer to BAT[any,any] record.*/
   int*		n
){
	BAT   *bn, *m = BATmirror(b);
	Heap  hph = b->hheap, hpt = b->theap;
	int   ht = BAThtype(b), htrick = ATOMvarsized(ht);
	int   tt = BATttype(b), ttrick = ATOMvarsized(tt);
	int   xx; 
	BUN   p, q;

	ALIGNchk(b, "CMDpart_order");
	if (!ATOMlinear(b->htype)) {
		GDKerror("CMDpart_order: %s cannot order a %s head\n",
				BBPname(b->batCacheid), ATOMname(b->htype));
	}
@-
fool the partition function into thinking there are no varsized atoms 
@c
	if (htrick) {
	    b->htype = m->ttype = TYPE_int;
	    b->hvarsized = m->tvarsized = 0;
	}
	if (ttrick) {
	    b->ttype = m->htype = TYPE_int;
	    b->tvarsized = m->hvarsized = 0;
	}
	b->hheap.base = b->theap.base = 0;

@- range split
@c
	bn = BATrangesplit(m, *n, FALSE);
@-
in-place conversion of void columns to oid 
@c
	if (b->ttype == TYPE_void) {
		b->ttype = m->htype = TYPE_oid;
        	m->hvarsized = b->tvarsized = 0;
		strcpy(b->tatom, "oid");
        	BATsetdims(b);
        	m->dims.tailloc = b->dims.headloc;
        	m->dims.headloc = b->dims.tailloc;
        	m->dims.bunshift = b->dims.bunshift;
        	m->dims.bunwidth = b->dims.bunwidth;
	}
@-
Now declare the BAT empty.
@c
	ACCremoveall(*ret=b);
	b->batBuns->free = BUNfirst(b) - b->batBuns->base; 
        b->batInserted = BUNlast(b);                              
	BATloopFast(bn, p, q, xx) {
	    bat *bp = (bat*) BUNtail(bn,p);
	    BAT *bm = BATdescriptor(*bp);
	    BAT *bf = BATmirror(bm);

	    if (BAThordered(bf)&1) {
		if (BATins(b, bf) == NULL) {
		    BBPreclaim(bn);
		    return GDK_FAIL;
		}
		continue;
	    }
@-
The partitions get sorted now. Restore the concealed head and tail
heaps, so the sort functions work correctly. They can just
use the hheap and theap of the 'b'.
@c
	    bf->htype = bm->ttype = ht;
	    bf->ttype = bm->htype = tt;
	    bf->hvarsized = bm->tvarsized = htrick;
	    bf->tvarsized = bm->hvarsized = ttrick;
	    bf->hheap = hph; bf->theap = hpt;
@-
Create a binary index.
@c
            if (BATidx(bf, 0) == NULL) {
		BBPreclaim(bn);
		return GDK_FAIL;
	    }
@-
We will now be inserting. We do not want to modify any head or
tail heaps, so we must conceal the fact that they exist.
@c
	    if (htrick) {
		bf->htype = bm->ttype = TYPE_int;
	    	bf->hvarsized = bm->tvarsized = 0;
	    }
	    if (ttrick) {
		bf->ttype = bm->htype = TYPE_int;
	    	bf->tvarsized = bm->hvarsized = 0;
	    }
	    bf->hheap.base = bf->theap.base = 0;
	    BATsort_insert(b, bf);
	    BBPunfix(bm->batCacheid);
	}
	BBPreclaim(bn); 
@-
Restore the type information of 'b'. Mark the head column sorted.
@c
	if (htrick) {
		b->htype = m->ttype = htrick;
		b->hvarsized = m->tvarsized = 1;
	}
	if (ttrick) {
		b->ttype = m->htype = ttrick;
		b->tvarsized = m->hvarsized = 1;
	}
	BBPfix(b->batCacheid);
	b->hheap = hph; b->theap = hpt;
	b->tsorted = 0; b->hsorted = GDK_SORTED;

	return GDK_SUCCEED;	
}

@+ Arbitrary Clusterings
@c
int CMDacccluster(BAT *b, int *acctype){
	int t = *acctype;
	void (*cluster)();

	BATcheck(b, "CLUSTERacc:"); 
	if (!((t==b->hacctype && b->haccelerator.base) &&
	      (cluster=BATaccelerators[t].accCluster))) 
	{
		return GDK_FAIL;
	}
	(*cluster)(&b->haccelerator,b);
	return GDK_SUCCEED;
}

int CMDheapclustercopy(BAT *b, BAT* order){
	int bunsize;
	BUN p,q,r;
	var_t (*fcn)();
	Heap hn;
 
	BATcheck(b, "CLUSTERcopyheap: BAT 1"); 
	BATcheck(order, "CLUSTERcopyheap: BAT 2");

	if (!(b && order && b->batBuns->base && b->theap.base &&
		order->batBuns->base && (fcn = BATatoms[b->ttype].atomPut) &&
		BATatoms[b->ttype].atomHeap && b->htype==order->htype)) 
	{
		return GDK_FAIL;
	}
 
	/* alloc && copy the old structures into scratch structures. */
	bunsize = BUNsize(b);
	hn.filename = NULL;
	if (ATOMheap(b->ttype, &hn, BATcount(b)+1) < 0) {
		return GDK_FAIL;
	}
 
	if (b == order) {
	     BATloopFast(b, p, q, bunsize) {
		(*fcn)(&hn, BUNtloc(b, p), BUNtvar(b, p));
	     }
	} else if (ATOMstorage(b->htype) == ATOMstorage(TYPE_oid)) {
	    BATloopFast(order, p, q, bunsize) {
		BUNfndOID(r, b, BUNhloc(order,p));
		if (r) (*fcn)(&hn, BUNtloc(b, r), BUNtvar(b, r));
	    }
	} else {
	    BATloopFast(order, p, q, bunsize) {
		r = BUNfnd(b, BUNhead(order,p));
		if (r) (*fcn)(&hn, BUNtloc(b, r), BUNtvar(b, r));
	    }
	}
 
	/* reassign */
	if (hn.storage == STORE_MMAP) {
		GDKunlink(NULL, b->theap.filename, "");
	}
	HEAPfree(&b->theap);
	b->theap = hn;
	b->batDirtybuns = b->batDirtydesc = b->theapdirty = TRUE;
	return GDK_SUCCEED;
}
@}
