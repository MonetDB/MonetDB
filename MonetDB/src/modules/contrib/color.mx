@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f color
@t The color module
@a Alex van Ballegooij
@v 1.0
@* Introduction
@T
The color atom is a simple 32bit (24bit+zeros) encoding of a standard RGB 
color encoding, consisting of the red component in bits 16-23, 
the green component in bits 8-15, and the blue component in bits 0-7.

The module contains a number of color conversion methods to construct
colors in various colorspaces and extract relevant color channels.

rgb = (byte,byte,byte) colorspace r,g,b=[0..255]
hsv = (flt,flt,flt) colorspace h=[0..360], s,v=[0..1]
ycc = (byte,byte,byte) colorspace y,c,c=[0..255]

@* Implementation

@+ MEL definition
@m
.MODULE color;
	.ATOM color = int;
		.FROMSTR = color_fromstr;
		.TOSTR   = color_tostr;
	.END;

	.COMMAND rgb(int r,int g,int b) : color = rgb;
		"Converts an RGB triplets to a color atom"
	.COMMAND red  (color c) : int = red;
		"Extracts red component from a color atom"
	.COMMAND green(color c) : int = green;
		"Extracts green component from a color atom"
	.COMMAND blue (color c) : int = blue;
		"Extracts blue component from a color atom"

	.COMMAND hsv(flt h,flt s,flt v) : color = hsv;
		"Converts an HSV triplets to a color atom"
	.COMMAND hue       (color c) : flt = hue;
		"Extracts hue component from a color atom"
	.COMMAND saturation(color c) : flt = saturation;
		"Extracts saturation component from a color atom"
	.COMMAND value     (color c) : flt = value;
		"Extracts value component from a color atom"

	.COMMAND ycc(int y,int cr,int cb) : color = ycc;
		"Converts an YCC triplets to a color atom"
	.COMMAND luminance (color c) : int = luminance;
		"Extracts Y(luminance) component from a color atom"
	.COMMAND cr        (color c) : int = cr;
		"Extracts Cr(red color) component from a color atom"
	.COMMAND cb        (color c) : int = cb;
		"Extracts Cb(blue color) component from a color atom"

.END color;

@+ C implementation
@c

/*
#define DEBUG 
*/

@h
#ifndef _COLOR_H
#define _COLOR_H
typedef unsigned int color;

#include "color.proto.h"
#define color_nil ((color)int_nil)
@-
Type-mappers for convenience
@= HT_bunfastins_typemap
#define @1@2_bunfastins_nocheck_noinc(b, p, h, t) @1@3_bunfastins_nocheck_noinc(b, p, h, t)
#define @1@2_bunfastins_nocheck(b, p, h, t, s)    @1@3_bunfastins_nocheck(b, p, h, t, s)
#define @1@2_bunfastins(b, h, t) @1@3_bunfastins_nocheck_noinc(b, h, t)
#define @2@1_bunfastins_nocheck_noinc(b, p, h, t) @3@1_bunfastins_nocheck_noinc(b, p, h, t)
#define @2@1_bunfastins_nocheck(b, p, h, t, s)    @3@1_bunfastins_nocheck(b, p, h, t, s)
#define @2@1_bunfastins(b, h, t) @3@1_bunfastins_nocheck_noinc(b, h, t)
@h
@:HT_bunfastins_typemap(void,color,int)@
@:HT_bunfastins_typemap(oid,color,int)@
@:HT_bunfastins_typemap(chr,color,int)@
@:HT_bunfastins_typemap(sht,color,int)@
@:HT_bunfastins_typemap(int,color,int)@
@:HT_bunfastins_typemap(lng,color,int)@
@:HT_bunfastins_typemap(any,color,int)@

#endif
@c
#include "monetdb_config.h"
#include <math.h>
#include "color.h"

@- Atom commands
@c

int
hextoint(chr h, chr l)
{
	int r = 0;

	if (h >= '0' && h <= '9')
		r = 16 * (int) (h - '0');
	if (h >= 'a' && h <= 'f')
		r = 16 * (int) (10 + h - 'a');
	if (h >= 'A' && h <= 'F')
		r = 16 * (int) (10 + h - 'A');
	if (l >= '0' && l <= '9')
		r += (int) (l - '0');
	if (l >= 'a' && l <= 'f')
		r += (int) (10 + l - 'a');
	if (l >= 'A' && l <= 'F')
		r += (int) (10 + l - 'A');
	return r;
}

int
color_fromstr(char *colorStr, int *len, color **c)
{
	char *p = colorStr;

#ifdef DEBUG
	printf("* color_fromstr:\n");
	printf("  - colorStr: %s\n", (colorStr != NULL ? colorStr : "null"));
	printf("  - *len: %d\n", *len);
#endif

	if (!*c) {
		*c = (color *) GDKmalloc(sizeof(color));
	} else if (*len < (int) sizeof(color)) {
		GDKfree(*c);
		*c = GDKmalloc(sizeof(color));
		*len = sizeof(color);
	}

	while (GDKisspace(*p))
		p++;
	if (p[0] == 'n' && p[1] == 'i' && p[2] == 'l') {
		color **sc = (color **) c;

		**sc = color_nil;
		p += 3;
	} else {
		if (p[0] == '0' && p[1] == 'x' && p[2] == '0' && p[3] == '0') {
			int r = hextoint(p[4], p[5]);
			int g = hextoint(p[6], p[7]);
			int b = hextoint(p[8], p[9]);

			**c = (color) (r << 16 | g << 8 | b);
		} else {
			GDKwarning("Invalid color string representation '%s'\n", p);
			**c = chr_nil;
		}
	}

#ifdef DEBUG
	printf("  = *c: 0x%08X\n", (int) **c);
	printf("  = *len: %d\n", *len);
#endif

	return p - colorStr;
}

int
color_tostr(char **colorStr, int *len, color *c)
{
	color sc = *c;

#ifdef DEBUG
	printf("* color_tostr:\n");
	printf("  - *len: %d\n", *len);
	printf("  - c: %s\n", (c != NULL ? c : "null"));
#endif

	/* allocate and fill a new string */

	if (*len < 11) {
		GDKfree(*colorStr);
		*colorStr = GDKmalloc(11);
		*len = 11;
	}

	if (sc == color_nil) {
		strcpy(*colorStr, "nil");
		return 3;
	}
	snprintf(*colorStr, *len, "0x%08X", (unsigned int) sc);

#ifdef DEBUG
	printf("  = buf: %s\n", buf);
	printf("  = *colorStr: %s\n", *colorStr);
	printf("  = *len: %d\n", *len);
#endif
	return strlen(*colorStr);
}


int
rgb(color *rgb, int *r, int *g, int *b)
{
	*rgb = (color) (((*r & 0xFF) << 16) | ((*g & 0xFF) << 8) | (*b & 0xFF));
	return (GDK_SUCCEED);
}

int
red(int *r, color *c)
{
	*r = (int) ((*c >> 16) & 0xFF);
	return (GDK_SUCCEED);
}

int
green(int *g, color *c)
{
	*g = (int) ((*c >> 8) & 0xFF);
	return (GDK_SUCCEED);
}

int
blue(int *b, color *c)
{
	*b = (int) (*c & 0xFF);
	return (GDK_SUCCEED);
}

#define max2(a,b) ((a)>(b)?(a):(b))
#define max3(a,b,c) max2(max2(a,b),(c))

#define min2(a,b) ((a)<(b)?(a):(b))
#define min3(a,b,c) min2(min2(a,b),(c))

#define EPS 0.001f

void
color_rgb2hsv(float *h, float *s, float *v, int R, int G, int B)
{
	register float H, S, V, max;
	register float Rtmp = ((float) (R)) / 255.0f;
	register float Gtmp = ((float) (G)) / 255.0f;
	register float Btmp = ((float) (B)) / 255.0f;

	max = max3(Rtmp, Gtmp, Btmp);
	V = max;
	if (fabs(max) <= EPS) {
		S = 0;
		H = 0;
	} else {
		register float min, delta;

		min = min3(Rtmp, Gtmp, Btmp);
		delta = max - min;
		S = delta / max;
		if (Rtmp == max)
			H = (Gtmp - Btmp) / delta;
		else if (Gtmp == max)
			H = 2 + (Btmp - Rtmp) / delta;
		else		/* Btmp == max */
			H = 4 + (Rtmp - Gtmp) / delta;
		H *= 60;
		if (H < 0)
			H += 360;
	}
	*h = H;
	*s = S;
	*v = V;
}

int
hsv(color *c, flt *h, flt *s, flt *v)
{
	int r, g, b;
	float Rtmp, Gtmp, Btmp;

	if (fabs(*s) <= EPS) {
		Rtmp = Gtmp = Btmp = (*v);
	} else {
		float Htmp = (*h) / 60;
		float f = Htmp - ((int) Htmp);
		float p = (*v) * (1 - (*s));
		float q = (*v) * (1 - (*s) * f);
		float t = (*v) * (1 - (*s) * (1 - f));

		switch ((int) floor(Htmp)) {
		case 0:
			Rtmp = *v;
			Gtmp = t;
			Btmp = p;
			break;
		case 1:
			Rtmp = q;
			Gtmp = *v;
			Btmp = p;
			break;
		case 2:
			Rtmp = p;
			Gtmp = *v;
			Btmp = t;
			break;
		case 3:
			Rtmp = p;
			Gtmp = q;
			Btmp = *v;
			break;
		case 4:
			Rtmp = t;
			Gtmp = p;
			Btmp = *v;
			break;
		default:	/* case 5: */
			Rtmp = *v;
			Gtmp = p;
			Btmp = q;
			break;
		}
	}
	r = (int) ((Rtmp * 255.0f) + 0.5f);
	g = (int) ((Gtmp * 255.0f) + 0.5f);
	b = (int) ((Btmp * 255.0f) + 0.5f);
	return rgb(c, &r, &g, &b);
}

int
hue(flt *f, color *c)
{
	float h, s, v;

	color_rgb2hsv(&h, &s, &v, (*c >> 16) & 0xFF, (*c >> 8) & 0xFF, (*c) & 0xFF);
	*f = h;
	return (GDK_SUCCEED);
}

int
saturation(flt *f, color *c)
{
	float h, s, v;

	color_rgb2hsv(&h, &s, &v, (*c >> 16) & 0xFF, (*c >> 8) & 0xFF, (*c) & 0xFF);
	*f = s;
	return (GDK_SUCCEED);
}

int
value(flt *f, color *c)
{
	float h, s, v;

	color_rgb2hsv(&h, &s, &v, (*c >> 16) & 0xFF, (*c >> 8) & 0xFF, (*c) & 0xFF);
	*f = v;
	return (GDK_SUCCEED);
}


#ifndef CLIP
#define CLIP(X)     ((unsigned char)(((X)&~0xFF)?(((X)<0x00)?0x00:0xFF):(X)))
#endif

int
ycc(color *c, int *y, int *cr, int *cb)
{
	int r, g, b;
	float Y = (float) *y;
	float CR = (float) (*cr - 128);
	float CB = (float) (*cb - 128);

	r = (int) (Y + CR * 1.4022f);
	r = CLIP(r);
	g = (int) (Y - CB * 0.3456f - CR * 0.7145f);
	g = CLIP(g);
	b = (int) (Y + CB * 1.7710f);
	b = CLIP(b);
	return rgb(c, &r, &g, &b);
}

int
luminance(int *y, color *c)
{
	int r = (int) ((*c >> 16) & 0xFF);
	int g = (int) ((*c >> 8) & 0xFF);
	int b = (int) (*c & 0xFF);

	*y = (int) (0.2989f * (float) (r) + 0.5866f * (float) (g) + 0.1145f * (float) (b));
	*y = CLIP(*y);
	return (GDK_SUCCEED);
}

int
cr(int *cr, color *c)
{
	int r = (int) ((*c >> 16) & 0xFF);
	int g = (int) ((*c >> 8) & 0xFF);
	int b = (int) (*c & 0xFF);

	*cr = (int) (0.5000f * (float) (r) - 0.4183f * (float) (g) - 0.0816f * (float) (b)) + 128;
	return (GDK_SUCCEED);
}

int
cb(int *cb, color *c)
{
	int r = (int) ((*c >> 16) & 0xFF);
	int g = (int) ((*c >> 8) & 0xFF);
	int b = (int) (*c & 0xFF);

	*cb = (int) (-0.1687f * (float) (r) - 0.3312f * (float) (g) + 0.5000f * (float) (b)) + 128;
	return (GDK_SUCCEED);
}
