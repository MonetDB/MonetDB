@f opengis
@A C.W. Quak
@m
.MODULE opengis;

   .USE gis;

   .ATOM Point[16,8];
      .TOSTR   = Point_tostr;
      .FROMSTR = Point_fromstr;
      .NEQUAL  = point_comp;
      .HASH    = point_hash;
      .NULL    = point_null;
      .CONVERT = point_convert;
   .END;

   .ATOM Line[32,8];
      .TOSTR   = Line_tostr;
      .FROMSTR = Line_fromstr;
      .NEQUAL  = segment_comp;
      .HASH    = segment_hash;
      .NULL    = segment_null;
      .CONVERT = segment_convert;
   .END;

   .ATOM LineString;
      .TOSTR   = LineString_tostr;
      .FROMSTR = LineString_fromstr;
      .NEQUAL  = polyline_comp;
      .DEL     = polyline_del;
      .HASH    = polyline_hash;
      .NULL    = polyline_null;
      .CONVERT = polyline_convert;
      .PUT     = polyline_put;
      .LENGTH  = polyline_length;
      .HEAP    = polyline_heap;
      .CHECK   = polyline_heapcheck;
   .END;

   .ATOM Polygon;
      .TOSTR   = Polygon_tostr;
      .FROMSTR = Polygon_fromstr;
      .NEQUAL  = cpolygon_comp;
      .DEL     = cpolygon_del;
      .HASH    = cpolygon_hash;
      .NULL    = cpolygon_null;
      .CONVERT = cpolygon_convert;
      .PUT     = cpolygon_put;
      .LENGTH  = cpolygon_length;
      .HEAP    = cpolygon_heap;
      .CHECK   = cpolygon_heapcheck;
   .END;

   .ATOM MultiPoint;
      .TOSTR   = MultiPoint_tostr;
      .FROMSTR = MultiPoint_fromstr;
      .NEQUAL  = multipoint_comp;
      .DEL     = multipoint_del;
      .HASH    = multipoint_hash;
      .NULL    = multipoint_null;
      .PUT     = multipoint_put;
      .LENGTH  = multipoint_length;
      .HEAP    = multipoint_heap;
      .CHECK   = multipoint_heapcheck;
   .END;

   .ATOM GeometryCollection;
      .TOSTR   = GeometryCollection_tostr;
      .FROMSTR = GeometryCollection_fromstr;
      .NEQUAL  = GeometryCollection_comp;
      .DEL     = GeometryCollection_del;
      .HASH    = GeometryCollection_hash;
      .NULL    = GeometryCollection_null;
      .PUT     = GeometryCollection_put;
      .LENGTH  = GeometryCollection_length;
      .HEAP    = GeometryCollection_heap;
      .CHECK   = GeometryCollection_heapcheck;
   .END;

   .ATOM MultiLineString;
      .TOSTR   = MultiLineString_tostr;
      .FROMSTR = MultiLineString_fromstr;
      .NEQUAL  = MultiLineString_comp;
      .DEL     = MultiLineString_del;
      .HASH    = MultiLineString_hash;
      .NULL    = MultiLineString_null;
      .PUT     = MultiLineString_put;
      .LENGTH  = MultiLineString_length;
      .HEAP    = MultiLineString_heap;
      .CHECK   = MultiLineString_heapcheck;
   .END;

   .ATOM MultiPolygon;
      .TOSTR   = MultiPolygon_tostr;
      .FROMSTR = MultiPolygon_fromstr;
      .NEQUAL  = MultiPolygon_comp;
      .DEL     = MultiPolygon_del;
      .HASH    = MultiPolygon_hash;
      .NULL    = MultiPolygon_null;
      .PUT     = MultiPolygon_put;
      .LENGTH  = MultiPolygon_length;
      .HEAP    = MultiPolygon_heap;
      .CHECK   = MultiPolygon_heapcheck;
   .END;

   .ATOM Geometry;
      .TOSTR   = Geometry_tostr;
      .FROMSTR = Geometry_fromstr;
      .NEQUAL  = Geometry_comp;
      .DEL     = Geometry_del;
      .HASH    = Geometry_hash;
      .NULL    = Geometry_null;
      .PUT     = Geometry_put;
      .LENGTH  = Geometry_length;
      .HEAP    = Geometry_heap;
      .CHECK   = Geometry_heapcheck;
   .END;

   .COMMAND Dimension(Point p) : int	= Point_Dimension; "The dimension of this object"
   .COMMAND Dimension(LineString p) : int	= LineString_Dimension; "The dimension of this object"
   .COMMAND Dimension(Polygon p) : int	= Polygon_Dimension; "The dimension of this object"
   .COMMAND Dimension(MultiPoint p) : int	= MultiPoint_Dimension; "The dimension of this object"
   .COMMAND Dimension(MultiLineString p) : int	= MultiLineString_Dimension; "The dimension of this object"
   .COMMAND Dimension(MultiPolygon p) : int	= MultiPolygon_Dimension; "The dimension of this object"

   .COMMAND Boundary(MultiPoint p): MultiPoint 	= MultiPoint_Boundary; "The closure of the combinatorial boundary of this Geometry"
   .COMMAND Boundary(Line l): MultiPoint 	= Line_Boundary; "The closure of the combinatorial boundary of this Geometry"
   .COMMAND Boundary(LineString l): MultiPoint 	= LineString_Boundary; "The closure of the combinatorial boundary of this Geometry"
   .COMMAND Boundary(Polygon p): MultiLineString = Polygon_Boundary; "The closure of the combinatorial boundary of this Geometry"

   .COMMAND Relate(Point p1,Point p2,str matrix) : bit 			= Relate_Point_Point; ""
   .COMMAND Relate(Point p1,MultiPoint p2,str matrix) : bit		= Relate_Point_MultiPoint; ""
   .COMMAND Relate(Point p,Line l,str matrix) : bit 			= Relate_Point_Line; ""
   .COMMAND Relate(Point p,LineString l,str matrix) : bit 		= Relate_Point_LineString; ""
   .COMMAND Relate(Point p,Polygon pol,str matrix) : bit 		= Relate_Point_Polygon; ""
   .COMMAND Relate(MultiPoint m1,MultiPoint m2,str matrix) : bit	= Relate_MultiPoint_MultiPoint; ""
   .COMMAND Relate(MultiPoint m1,Line o2,str matrix) : bit		= Relate_MultiPoint_Line; ""
   .COMMAND Relate(MultiPoint m1,LineString o2,str matrix) : bit	= Relate_MultiPoint_LineString; ""
   .COMMAND Relate(MultiPoint m1,Polygon o2,str matrix) : bit		= Relate_MultiPoint_Polygon; ""
   .COMMAND Relate(Line l1,Line l2,str matrix) : bit 			= Relate_Line_Line; ""
   .COMMAND Relate(Line l1,LineString l2,str matrix) : bit 		= Relate_Line_LineString; ""
   .COMMAND Relate(LineString l1,LineString l2,str matrix) : bit	= Relate_LineString_LineString; ""

   .COMMAND X(Point p) : dbl	= Point_X; "The x-coordinate value for this Point"
   .COMMAND Y(Point p) : dbl	= Point_Y; "The y-coordinate value for this Point"

   .COMMAND NumGeometries(MultiPoint m) : int = MultiPoint_NumGeometries; ""
   .COMMAND GeometryN(MultiPoint m,int n ) : Point = MultiPoint_GeometryN; ""

   .COMMAND StartPoint(Line l) : Point = Line_StartPoint; ""
   .COMMAND EndPoint(Line l) : Point = Line_EndPoint; ""

   .COMMAND StartPoint(LineString l) : Point = LineString_StartPoint; ""
   .COMMAND EndPoint(LineString l) : Point = LineString_EndPoint; ""
   .COMMAND IsClosed(LineString l) : int = LineString_IsClosed; ""
   .COMMAND IsRing(LineString l) : int = LineString_IsRing; ""

   .COMMAND Area(Polygon p) : dbl = Polygon_Area; ""
   .COMMAND Centroid(Polygon p) : Point = Polygon_Centroid; ""
   .COMMAND PointOnSurface(Polygon p) : Point = Polygon_PointOnSurface; ""
   .COMMAND ExteriorRing(Polygon p) : LineString = Polygon_ExteriorRing; ""
   .COMMAND NumInteriorRing(Polygon p) : int = Polygon_NumInteriorRing; ""
   .COMMAND InteriorRingN(Polygon p,int n) : LineString = Polygon_InteriorRingN; ""

   .COMMAND NumGeometries(GeometryCollection m) : int = GeometryCollection_NumGeometries; ""
   .COMMAND GeometryN(GeometryCollection m,int n ) : Geometry = GeometryCollection_GeometryN; ""

   .COMMAND NumGeometries(MultiLineString m) : int = MultiLineString_NumGeometries; ""
   .COMMAND GeometryN(MultiLineString m,int n ) : LineString = MultiLineString_GeometryN; ""

   .COMMAND NumGeometries(MultiPolygon m) : int = MultiPolygon_NumGeometries; ""
   .COMMAND GeometryN(MultiPolygon m,int n) : Polygon = MultiPolygon_GeometryN; ""

   #
   # Non opengis Methods.
   #
   .COMMAND nbytes(GeometryCollection p) : int	= GeometryCollection_nbytes; ""
   .COMMAND nbytes(Point p) : int		= Point_nbytes; ""
   .COMMAND nbytes(LineString p) : int		= LineString_nbytes; ""
   .COMMAND nbytes(Polygon p) : int		= Polygon_nbytes; ""
   .COMMAND nbytes(Geometry p) : int		= Geometry_nbytes; ""
   .COMMAND nbytes(MultiPoint p) : int		= MultiPoint_nbytes; ""
   .COMMAND nbytes(MultiLineString p) : int	= MultiLineString_nbytes; ""
   .COMMAND nbytes(MultiPolygon p) : int	= MultiPolygon_nbytes; ""

   .COMMAND RelateString(LineString l1,LineString l2) : str = RelateString_LineString_LineString; ""
   .COMMAND RelateString(Line l1,Line l2) : str = RelateString_Line_Line; ""
   .COMMAND RelateString(Point p1,Point p2) : str = RelateString_Point_Point; ""
   .COMMAND RelateString(Point p,LineString l) : str = RelateString_Point_LineString; ""

   .COMMAND RelateHistogram() : bat[str,int] = RelateHistogram; ""

   .COMMAND toLineString(polyline p) : LineString	= polyline_toLineString; ""
   .COMMAND topolyline(LineString p) : polyline		= LineString_topolyline; ""
   .COMMAND toLineString(Line l) : LineString 		= Line_toLineString; ""
   .COMMAND toLine(segment s) : Line			= segment_toLine; ""
   .COMMAND toPoint(point p) : Point			= point_toPoint; ""

   .COMMAND hasminitree(LineString l) : bit	= LineString_hasminitree; "Return whether this LineString contains minitree"

   .COMMAND make_geometry(point p) : Geometry		= Geometry_make_point; ""
   .COMMAND make_geometry(polyline p) : Geometry	= Geometry_make_polyline; ""
   .COMMAND make_geometry(cpolygon p) : Geometry	= Geometry_make_cpolygon; ""

   .COMMAND asPoint(Geometry g) : Point			= Geometry_as_Point; ""
   .COMMAND asLineString(Geometry g) : LineString	= Geometry_as_LineString; ""
   .COMMAND asPolygon(Geometry g) : Polygon		= Geometry_as_Polygon; ""

   .COMMAND create_collection(Geometry)	: GeometryCollection	= gcollection_create; ""
   .COMMAND append(GeometryCollection c,Geometry g): GeometryCollection = gcollection_append; ""
   .COMMAND nitems(GeometryCollection c): int 			= gcollection_nitems; ""
   .COMMAND item(GeometryCollection c,int i): Geometry 		= gcollection_item; ""

   .COMMAND split(segment p1,segment p2,oid i1,oid o2,bat[oid,oid],bat[oid,dbl],bat[oid,point]) = segment_split; ""

   .COMMAND relreverse(str) :str = rel_reverse; ""

   .COMMAND mrcompare(polyline p1,polyline p2) = mr_compare; ""
.END opengis;
@h
#ifndef __OPENGIS_H__
#define __OPENGIS_H__

#include "geometry.h"

typedef point Point;
typedef segment Line;
typedef cpolygon Polygon;
typedef polyline LineString;
typedef multipoint MultiPoint;

#include "Polygon.h"
#include "MultiLineString.h"
#include "MultiPolygon.h"
#include "Geometry.h"
#include "GeometryCollection.h"

#include "PointPoint.h"
#include "PointMultiPoint.h"
#include "PointLine.h"
#include "PointLineString.h"
#include "PointPolygon.h"
#include "PointMultiLineString.h"
#include "MultiPointMultiPoint.h"
#include "MultiPointLine.h"
#include "MultiPointLineString.h"
#include "MultiPointPolygon.h"
#include "LineLine.h"
#include "LineLineString.h"
#include "LineStringLineString.h"
#include "Reverse.h"

extern "C"
{
#include "gdk_heap.h"
#define HEAPindex(HEAP,INDEX,TYPE) ((TYPE *)(HEAP->base + INDEX))
}
#include "opengis.proto.h"

#endif /* __OPENGIS_H__ */
@C
#include "gis.h"
#include "opengis.h"


#include "triangulate.h"
#include "opengisreader.h"
#include "opengiswriter.h"
#include "writer.h"
#include <string.h>
#include <math.h>

#include "minirealm.h"

//
// Copy a varsized object from somewhere to a heap.
//

@:putop(GeometryCollection)@
@:putop(MultiLineString)@
@:putop(MultiPolygon)@

@= putop
void @1_put(Heap* h,int*  bun,@1* val)
{
   //
   // We only copy the part of the @1 that is
   // really used.
   //
   int nbytes = val->usedbytes();

   //
   // Allocate the memory in the heap.
   //
   *bun  = HEAP_malloc(h,nbytes);

   //
   //
   //
   @1* goalpos = (@1 *)(&((char *)(h->base))[*bun]);
   memcpy((char *)goalpos,(char *)val,nbytes);
   goalpos->nbytes_v = nbytes;
}
@
@C

void Geometry_put(Heap* h,int*  bun,Geometry* val)
{
   char* base;
   int nbytes = val->nbytes();

   *bun  = HEAP_malloc(h,nbytes);
   base = h->base;
   memcpy(&base[*bun],(char *)val,nbytes);
}
//========================================================================

@:heapop(Geometry)@
@:heapop(GeometryCollection)@
@:heapop(MultiLineString)@
@:heapop(MultiPolygon)@

@= heapop
int @1_heapcheck(
   Heap*        h,
   HeapRepair*  hr)

{
   return(HEAP_check(h,hr));
}

int heapstatus_@1(BAT *bat)
{
   HEAP_printstatus(&(bat->theap));
   return(GDK_SUCCEED);
}

int @1_heap(Heap* h,int capacity)
{
   HEAP_initialize(h,capacity,0,8);
   return(0);
}

void @1_del(Heap* h,int* index)
{
   HEAP_free(h,*index);
}

int @1_length(@1* obj)
{
   return(obj->nbytes());
}

@
//
//========================================================================
//
@- NULL Functions
@C
@:nullval(Geometry)@
@:nullval(GeometryCollection)@
@:nullval(MultiLineString)@
@:nullval(MultiPolygon)@

@= nullval
@1* @1_null()
{
   return(@1::null());
}
@
//
//========================================================================
//
@- String Functions
@C
@:tostrop(GeometryCollection)@
@:tostrop(MultiLineString)@
@:tostrop(MultiPoint)@
@:tostrop(MultiPolygon)@
@:tostrop(LineString)@
@:tostrop(Geometry)@
@:tostrop(Polygon)@
@:tostrop(Point)@
@:tostrop(Line)@

@= tostrop
int @1_tostr(char** s,int* l,@1* val)
{
   OpenGisWriter writer(*s,*l);

   writer.write(*val);

   *s = writer.start;
   *l = (int)writer.len;
   return(writer.pos);
}

@
@C

@:fromstrop(Geometry)@
@:fromstrop(GeometryCollection)@
@:fromstrop(MultiLineString)@
@:fromstrop(MultiPolygon)@
@:fromstrop(MultiPoint)@
@:fromstrop(Polygon)@
@:fromstrop(LineString)@

@= fromstrop
int @1_fromstr(str s,int* l,@1** val)
{
   if (*val != NULL)
      delete (void *)*val;

   OpenGisReader reader(s);
   *val = reader.readTagged@1();
   *l = (*val)->nbytes();
   return(reader.bytesread());
}

@
@C

int Line_fromstr(str s,int* l,Line** val)
{
   if (*val == NULL)
   {
      *val = segment::create();
      *l = sizeof(segment);
   }
   if (*l < (int)sizeof(segment))
   {
      delete (void *)*val;
      *val = segment::create();
      *l = sizeof(segment);
   }

   OpenGisReader reader(s);
   **val = reader.readTaggedLine();
   return(reader.bytesread());
}

int Point_fromstr(str s,int* l,Point** val)
{
   if (*val == NULL)
   {
      *val = point::create();
      *l = sizeof(point);
   }
   if (*l < (int)sizeof(point))
   {
      delete (void *)*val;
      *val = point::create();
      *l = sizeof(point);
   }

   OpenGisReader reader(s);
   **val = reader.readTaggedPoint();
   return(reader.bytesread());
}

//
//========================================================================
//
@- Compare Functions
@C
@:neqop(Geometry)@
@:neqop(GeometryCollection)@
@:neqop(MultiLineString)@
@:neqop(MultiPolygon)@


@= neqop
int @1_comp(@1* l,@1* r)
{
   return(!(*l == *r));
}
@
@C

//
//========================================================================
//
@- Hash Functions
@C
@:hashop(Geometry)@
@:hashop(GeometryCollection)@
@:hashop(MultiLineString)@
@:hashop(MultiPolygon)@

@= hashop
int @1_hash(@1* obj)
{
   return(obj->hash());
}
@
@C

//
//===========================
// Function concerning Points
//===========================
//
int Point_X (
   double* rval,
   Point* p)
{
   *rval = p->x;
   return(GDK_SUCCEED);
}

int Point_Y (
   double* rval,
   Point* p)
{
   *rval = p->y;
   return(GDK_SUCCEED);
}

//
//==========================
// Functions concerning Line
//==========================
//
int Line_StartPoint(
   Point* rval,
   Line *m)
{
   *rval = m->source;
   return(GDK_SUCCEED);
}

int Line_EndPoint(
   Point* rval,
   Line *m)
{
   *rval = m->dest;
   return(GDK_SUCCEED);
}

//
//================================
// Functions concerning LineString
//================================
//
int LineString_StartPoint(
   Point* rval,
   LineString *m)
{
   *rval = m->source();
   return(GDK_SUCCEED);
}

int LineString_EndPoint(
   Point* rval,
   LineString *m)
{
   *rval = m->dest();
   return(GDK_SUCCEED);
}

int LineString_IsClosed(
   int* rval,
   LineString *m)
{
   *rval = m->closed();
   return(GDK_SUCCEED);
}

int LineString_IsRing(
   int* rval,
   LineString *m)
{
   *rval = ((m->closed() && (!m->selfintersect())));
   return(GDK_SUCCEED);
}

//
//================================
// Function concerning MultiPoints
//================================
//
int MultiPoint_NumGeometries(
   int* rval,
   MultiPoint *m)
{
   *rval = m->npoints();
   return(GDK_SUCCEED);
}

int MultiPoint_GeometryN(
   Point* rval,
   MultiPoint *m,
   int* n)
{
   *rval = m->pnt(*n);
   return(GDK_SUCCEED);
}

//
//========================================
// Function concerning GeometryCollections
//========================================
//
int GeometryCollection_NumGeometries(
   int* rval,
   GeometryCollection *m)
{
   *rval = m->nitems();
   return(GDK_SUCCEED);
}

int GeometryCollection_GeometryN(
   Geometry** rval,
   GeometryCollection *m,
   int* n)
{
   *rval = m->geometry(*n).copy();
   return(GDK_SUCCEED);
}

//
//======================================
// Functions concerning MultiLineStrings
//======================================
//
int MultiLineString_NumGeometries(
   int* rval,
   MultiLineString *m)
{
   *rval = m->nitems();
   return(GDK_SUCCEED);
}

int MultiLineString_GeometryN(
   LineString** rval,
   MultiLineString *m,
   int* n)
{
   *rval = m->geometry(*n).copy();
   return(GDK_SUCCEED);
}

//
//===================================
// Functions concerning MultiPolygons
//===================================
//
int MultiPolygon_NumGeometries(
   int* rval,
   MultiPolygon *m)
{
   *rval = m->nitems();
   return(GDK_SUCCEED);
}

int MultiPolygon_GeometryN(
   Polygon** rval,
   MultiPolygon *m,
   int* n)
{
   *rval = m->geometry(*n).copy();
   return(GDK_SUCCEED);
}

//
//==============================
// Functions concerning Polygons
//==============================
//
int Polygon_Area(
   dbl* rval,
   Polygon* p)
{
   *rval = p->area();
   return(GDK_SUCCEED);
}

int Polygon_Centroid(
   Point* rval,
   Polygon* p)
{
   *rval = p->centroid();
   return(GDK_SUCCEED);
}

int Polygon_PointOnSurface(
   Point* rval,
   Polygon* p)
{
   *rval = p->internalpoint();
   return(GDK_SUCCEED);
}

int Polygon_ExteriorRing(
   LineString** rval,
   Polygon* p)
{
   *rval = (LineString *)p->boundary().copy();
   return(GDK_SUCCEED);
}

int Polygon_NumInteriorRing(
   int* rval,
   Polygon* p)
{
   *rval = p->nholes();
   return(GDK_SUCCEED);
}

int Polygon_InteriorRingN(
   LineString** rval,
   Polygon* p,
   int* n)
{
   *rval = (LineString *)p->hole(*n).copy();
   return(GDK_SUCCEED);
}

//
//========================================
// Function concerning GeometryCollections
//========================================
//
int gcollection_create(
   GeometryCollection** rval,
   Geometry* g)
{
   *rval = GeometryCollection::create(5,g->nbytes() * 3);
   (*rval)->additem(*g);
   return(GDK_SUCCEED);
}

int gcollection_append(
   GeometryCollection** retval,
   GeometryCollection* c,
   Geometry* g)
{
   GeometryCollection* rval = c->copy();
   rval = rval->additem(*g);
   *retval = rval;

   return(GDK_SUCCEED);
}

int gcollection_nitems(
   int* rval,
   GeometryCollection* g)
{
   *rval = g->nitems();
   return(GDK_SUCCEED);
}

int gcollection_item(
   Geometry** rval,
   GeometryCollection* g,
   int *item)
{
   *rval = g->geometry(*item).copy();
   return(GDK_SUCCEED);
}

//
//===============================
// Function concerning Geometries
//===============================
//
int Geometry_make_point(
   Geometry** rval,
   point* p)
{
   *rval = Geometry::create(*p);
   return(GDK_SUCCEED);
}

int Geometry_as_Point(
   Point* rval,
   Geometry* g)
{
   *rval = g->asPoint();
   return(GDK_SUCCEED);
}

int Geometry_make_polyline(
   Geometry** rval,
   polyline* p)
{
   *rval = Geometry::create(*p);
   return(GDK_SUCCEED);
}

int Geometry_as_LineString(
   LineString** rval,
   Geometry* g)
{
   *rval = g->asLineString().copy();
   return(GDK_SUCCEED);
}

int Geometry_make_cpolygon(
   Geometry** rval,
   cpolygon* p)
{
   *rval = Geometry::create(*p);
   return(GDK_SUCCEED);
}

int Geometry_as_Polygon(
   Polygon** rval,
   Geometry* g)
{
   *rval = g->asPolygon().copy();
   return(GDK_SUCCEED);
}


//
//====================
// The Relate function
//====================
//

//
// Y = Implemented
// W = Wrapper
// R = Reverse
//
//		| Point	| MultiP| Line  | LineS | Polygon
// ------------------------------------------------------
// Point	|   Y	|   W	|   Y	|   Y	|   W
// MultiPoint	|   -	|   Y	|   W	|   Y	|   Y
// Line		|   -	|   -	|   Y	|   W	|   -
// LineString	|   -	|   -	|   -	|   Y	|   -
// Polygon	|   -	|   -	|   -	|   -	|   -

@:relops(Point,Point)@
@:relops(Point,MultiPoint)@
@:relops(Point,Line)@
@:relops(Point,LineString)@
@:relops(Point,Polygon)@
@:relops(MultiPoint,MultiPoint)@
@:relops(MultiPoint,Line)@
@:relops(MultiPoint,LineString)@
@:relops(MultiPoint,Polygon)@
@:relops(Line,Line)@
@:relops(Line,LineString)@
@:relops(LineString,LineString)@

@= relops
int Relate_@1_@2(
   bit* rval,
   @1* o1,
   @2* o2,
   char* param)
{
   *rval = Relate(*o1,*o2,param);
   return(GDK_SUCCEED);
}
@
@C
//
//===============================
// Functions returning Boundaries
//===============================
//

@:bndops(Line)@
@:bndops(Point)@
@:bndops(LineString)@
@:bndops(MultiPoint)@

@= bndops
int @1_Boundary(
   MultiPoint** rval,
   @1* param)
{
   *rval = param->boundary();
   return(GDK_SUCCEED);
}
@
@C

int Polygon_Boundary(
   MultiLineString** rval,
   Polygon* param)
{
   *rval = Boundary(*param);
   return(GDK_SUCCEED);
}

//
//===============================
// Function concerning Geometries
//===============================
//

@:geomops(Point)@
@:geomops(LineString)@
@:geomops(Polygon)@
@:geomops(MultiPoint)@
@:geomops(MultiLineString)@
@:geomops(MultiPolygon)@

@= geomops
int @1_Dimension(
   int* rval,
   @1* param)
{
   *rval = param->dimension();
   return(GDK_SUCCEED);
}
@
@C
//
//==============================================================
// These functions return the number of bytes used by the object
//==============================================================
//

@:nbytesfunc(Point)@
@:nbytesfunc(LineString)@
@:nbytesfunc(Polygon)@
@:nbytesfunc(Geometry)@
@:nbytesfunc(MultiPoint)@
@:nbytesfunc(MultiLineString)@
@:nbytesfunc(MultiPolygon)@
@:nbytesfunc(GeometryCollection)@

@= nbytesfunc
int @1_nbytes(
   int* rval,
   @1* param)
{
   *rval = param->nbytes();
   return(GDK_SUCCEED);
}
@
@C


//
//=======================================================================
// These functions return a string representation of the topology matrix.
//=======================================================================
//

int RelateString_Point_Point(
   str* rval,
   Point* p1,
   Point* p2)
{
   relationship rel = Relate(*p1,*p2);
   *rval = rel.tostring();
   return(GDK_SUCCEED);
}

int RelateString_Point_LineString(
   str* rval,
   Point* p,
   LineString* l)
{
   relationship rel = Relate(*p,*l);
   *rval = rel.tostring();
   return(GDK_SUCCEED);
}

int RelateString_Line_Line(
   str* rval,
   Line* l1,
   Line* l2)
{
   relationship rel = Relate(*l1,*l2);
   *rval = rel.tostring();
   return(GDK_SUCCEED);
}

int RelateString_LineString_LineString(
   str* rval,
   LineString* l1,
   LineString* l2)
{
   relationship rel = Relate(*l1,*l2);
   *rval = rel.tostring();
   return(GDK_SUCCEED);
}

//
//=========================================================================
// These functions concern relationships of lines while keeping histograms.
//=========================================================================
//

int RelateHistogram(
   BAT** rval)
{
   *rval = relate_histogram();
   return(GDK_SUCCEED);
}


//
//=================================================================
// These functions convert spatial object from one type to another.
//=================================================================
//

int Line_toLineString(
   LineString** rval,
   Line* l)
{
   *rval = l->topolyline();
   return(GDK_SUCCEED);
}

int polyline_toLineString(
   LineString** rval,
   polyline* p)
{
   *rval = p->copy();
   return(GDK_SUCCEED);
}

int LineString_topolyline(
   polyline** rval,
   LineString* p)
{
   *rval = p->copy();
   return(GDK_SUCCEED);
}

int point_toPoint(
   Point* rval,
   point* p)
{
   *rval = *p;
   return(GDK_SUCCEED);
}

int segment_toLine(
   Line* rval,
   segment* s)
{
   *rval = *s;
   return(GDK_SUCCEED);
}

//
//=================================================================================
// This function splits two intersecting line segments into non intersecting parts.
//=================================================================================
//

int segment_split(
   segment* p1,
   segment* p2,
   oid* o1,
   oid* o2,
   BAT* oid_plnid,
   BAT* oid_segnumpos,
   BAT* oid_position)
{
   split(*p1,*p2,*o1,*o2,oid_plnid,oid_segnumpos,oid_position);
   return(GDK_SUCCEED);
}

//
//=================
// Temporary stuff.
//=================
//
int mr_compare(polyline* p1,polyline* p2)
{
   MultiPoint* p1b = p1->boundary();
   MultiPoint* p2b = p2->boundary();

   minirealm m(p1b,p2b);

   for(int i=0;i<p1->nsegments();++i)
   {
      m.add(p1->sgmt(i),true,false);
   }
   for(int j=0;j<p2->nsegments();++j)
   {
      m.add(p2->sgmt(j),false,true);
   }
   m.dump();

   return(GDK_SUCCEED);
}

int LineString_hasminitree(bit* rval,LineString* l)
{
   *rval = ((polyline* )l)->hasminitree();
   return(GDK_SUCCEED);
}


int rel_reverse(
   char** rval,
   char* param)
{
   char* ret = new char[9];

   ret[0] = param[0];
   ret[1] = param[3];
   ret[2] = param[6];
   ret[3] = param[1];
   ret[4] = param[4];
   ret[5] = param[7];
   ret[6] = param[2];
   ret[7] = param[5];
   ret[8] = param[8];
   ret[9] = param[9];

   *rval = ret;

   return(GDK_SUCCEED);
}

@mil
setoid(oid(20000000));
module(opengis);

l1 := Line("LINE (0 0,0 2)"); l1s := l1.toLineString;
l2 := Line("LINE (2 0,2 2)"); l2s := l2.toLineString;
l3 := Line("LINE (0 2,2 2)"); l3s := l3.toLineString;
l4 := Line("LINE (0 1,2 1)"); l4s := l4.toLineString;
l5 := Line("LINE (0 1,0 3)"); l5s := l5.toLineString;
l6 := Line("LINE (0 -1,0 3)"); l6s := l6.toLineString;
l7 := Line("LINE (-1 1,1 1)"); l7s := l7.toLineString;
l8 := Line("LINE (0 1,0 2)"); l8s := l8.toLineString;

# DISJOINT
RelateString(l1,l2).print;
RelateString(l1s,l2s).print;
# TOUCH
RelateString(l1,l3).print;
RelateString(l1s,l3s).print;
# REINL
RelateString(l1,l4).print;
RelateString(l1s,l4s).print;
# LEINR
RelateString(l4,l1).print;
RelateString(l4s,l1s).print;
# CROSS
RelateString(l1,l7).print;
RelateString(l1s,l7s).print;
# EQUALS
RelateString(l1,l1).print;
RelateString(l1s,l1s).print;
# LINR
RelateString(l1,l6).print;
RelateString(l1s,l6s).print;
# RINL
RelateString(l6,l1).print;
RelateString(l6s,l1s).print;
# LIN2R
RelateString(l8,l1).print;
RelateString(l8s,l1s).print;
# RIN2L
RelateString(l1,l8).print;
RelateString(l1s,l8s).print;
# OVERLAP
RelateString(l1,l5).print;
RelateString(l1s,l5s).print;

RelateHistogram.print;
