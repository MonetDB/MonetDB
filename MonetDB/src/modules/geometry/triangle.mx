@f triangle
@A C.W. Quak
@* The triangle class
@h
#ifndef __TRIANGLE_H__
#define __TRIANGLE_H__

//
// Object Definition.
//
class triangle
{
public:
   //
   // Data storage.
   //
   point p1;
   point p2;
   point p3;

   //
   // Constructors.
   //
   triangle(const point& p1,const point& p2,const point& p3);
   triangle();

   //
   // Operations needed by Monet.
   //
   bool OK() const;
   bool operator== (const triangle& p) const;
   bool operator!= (const triangle& p) const;
   int expectedstrlen() const;
   int tostr(char* s,int len) const;
   static triangle* null();
   static triangle* create();
   static triangle* fromstr(char *s,int* parselen,int *buflen,triangle* p);
   int hash() const;
   void convert_host_to_net();
   void convert_net_to_host();


   //
   // Const Operations.
   //
   point& pnt(int index);
   box bbox() const;
   int dimension() const;
   void plot() const;
   double area() const;
   bool clockwise() const;
   triangle* copy() const;
   bool inside(const point& p) const;
   point centroid() const;

   void translate(const point& p);
   void scale(const double factor);
   void rotate(const double angle);

   class polyline* topolyline() const;
   class polygon* topolygon() const;


   //
   // Non const operations.
   //
   void doreverse();
   void set(const point& p1,const point& p2,const point& p3);
};

//
// Inline Implementation
//
inline int triangle::dimension() const
{
   return(2);
}

inline triangle::triangle()
{
}

inline triangle* triangle::copy() const
{
   triangle* rval = new triangle(*this);
   return(rval);
}

inline triangle::triangle(const point& pnt1,const point& pnt2,const point& pnt3)
{
   p1 = pnt1;
   p2 = pnt2;
   p3 = pnt3;
}

#endif /* __TRIANGLE_H__ */
@C
@+ Implementation Code for triangle values.
@C
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#include "geometry.h"

void triangle::set(const point& pnt1,const point& pnt2,const point& pnt3)
{
   p1 = pnt1;
   p2 = pnt2;
   p3 = pnt3;
}

triangle* triangle::create()
{
   return new triangle;
}

void triangle::plot() const
{
   GDKwarning("triangle %f %f %f %f %f %f\n",
      p1.x,p1.y,p2.x,p2.y,p3.x,p3.y);
}

void triangle::doreverse()
{
   point tmp = p1;
   p1=p2;
   p2=tmp;
}

void triangle::translate(const point& p)
{
   p1.translate(p);
   p2.translate(p);
   p3.translate(p);
}

void triangle::scale(const double factor)
{
   p1.scale(factor);
   p2.scale(factor);
   p3.scale(factor);
}

void triangle::rotate(const double angle) 
{
   p1.rotate(angle);
   p2.rotate(angle);
   p3.rotate(angle);
}

bool triangle::operator==(const triangle& s) const
{
   return(
      ((p1 == s.p1) && (p2 == s.p2) && (p3 == s.p3)) ||
      ((p1 == s.p1) && (p2 == s.p3) && (p3 == s.p2)) ||
      ((p1 == s.p2) && (p2 == s.p1) && (p3 == s.p3)) ||
      ((p1 == s.p2) && (p2 == s.p3) && (p3 == s.p1)) ||
      ((p1 == s.p3) && (p2 == s.p1) && (p3 == s.p2)) ||
      ((p1 == s.p3) && (p2 == s.p2) && (p3 == s.p1))
   );
}

bool triangle::inside(const point& p) const
{
   bool CHit = false;

   if ((((p1.y <= p.y) && (p.y < p3.y)) ||
     ((p3.y <= p.y) && (p.y < p1.y))) &&
     (p.x < (p3.x - p1.x) * (p.y - p1.y) / (p3.y - p1.y) + p1.x))
     CHit = !CHit;
   if ((((p2.y <= p.y) && (p.y < p1.y)) ||
     ((p1.y <= p.y) && (p.y < p2.y))) &&
     (p.x < (p1.x - p2.x) * (p.y - p2.y) / (p1.y - p2.y) + p2.x))
     CHit = !CHit;
   if ((((p3.y <= p.y) && (p.y < p2.y)) ||
     ((p2.y <= p.y) && (p.y < p3.y))) &&
     (p.x < (p2.x - p3.x) * (p.y - p3.y) / (p2.y - p3.y) + p3.x))
     CHit = !CHit;

   return(CHit);
}

int triangle::hash() const
{
   return(bbox().hash());
}

bool triangle::OK() const
{
   if ((p1 == p2) || (p1 == p3) || (p2 == p3))
   {
      GDKerror("Triangle with duplicate point\n");
      return(false);
   }
   return(true);

}

box triangle::bbox() const
{
   box rval(p1);
   rval.bbox_include(p2);
   rval.bbox_include(p3);
   return(rval);
}

bool triangle::clockwise() const
{
   double       rval=0;

   rval += ( p1.x - p2.x) * ( p1.y + p2.y);
   rval += ( p2.x - p3.x) * ( p2.y + p3.y);
   rval += ( p3.x - p1.x) * ( p3.y + p1.y);

   if (rval == 0)
   {
      GDKwarning("Triangle ((%f,%f),(%f,%f),(%f,%f)) is neither clockwise nor counterclockwise\n",
         p1.x,p1.y,p2.x,p2.y,p3.x,p3.y);
   }

   return(rval < 0);
}

polyline* triangle::topolyline() const
{
   polyline* rval = polyline::create(4);

   rval->data(0) = p1;
   rval->data(1) = p2;
   rval->data(2) = p3;
   rval->data(3) = p1;

   return(rval);
}

polygon* triangle::topolygon() const
{
   polygon* rval = polygon::create(3);

   rval->data(0) = p1;
   rval->data(1) = p2;
   rval->data(2) = p3;

   return(rval);
}

double triangle::area() const
{
   double       rval=0;

   rval += ( p1.x - p2.x) * ( p1.y + p2.y);
   rval += ( p2.x - p3.x) * ( p2.y + p3.y);
   rval += ( p3.x - p1.x) * ( p3.y + p1.y);

   rval /= 2.0;
   if (rval < 0)
      rval = - rval;

   return(rval);
}

int triangle::tostr(char* s,int len) const
{
   int rval = 0;
   rval += sprintf(s + rval,"(");
   rval += p1.tostr(s + rval,len-rval);
   rval += sprintf(s + rval,",");
   rval += p2.tostr(s + rval,len-rval);
   rval += sprintf(s + rval,",");
   rval += p3.tostr(s + rval,len-rval);
   rval += sprintf(s + rval,")");

   if (rval > len)
      GDKwarning("Prepare for the worst\n");
   return(rval);
}

int triangle::expectedstrlen() const
{
   return(300);
}

triangle* triangle::fromstr(char *s,int* parselen,int *buflen,triangle* t)
{
   if (t == NULL)
   {
      t = triangle::create();
      *buflen = sizeof(triangle);
   }
   if (*buflen < (int)sizeof(triangle))
   {
      delete (void *)t;
      t = triangle::create();
      *buflen = sizeof(triangle);
   }

   char* snew = s;

   int pbuflen = sizeof(point);
   int pparselen;

   snew = strchr(snew,'(');
   ++snew;
   pparselen = *parselen - (s - snew);
   point::fromstr(snew,&pparselen,&pbuflen,&(t->p1));
   snew += pparselen;
   snew = strchr(snew,',');
   pparselen = *parselen - (s - snew);
   point::fromstr(snew,&pparselen,&pbuflen,&(t->p2));
   snew += pparselen;
   snew = strchr(snew,',');
   pparselen = *parselen - (s - snew);
   point::fromstr(snew,&pparselen,&pbuflen,&(t->p3));
   snew += pparselen;
   snew = strchr(snew,')');

   int bytesread = snew-s;
   if (bytesread > *parselen)
      GDKwarning("Problems\n");
   
   *parselen = bytesread;
   return(t);
}

triangle* triangle::null()
{
   triangle* rval = new triangle;
   rval->p1.x = COORD_MAX;
   rval->p1.y = COORD_MAX;
   rval->p2.x = COORD_MAX;
   rval->p2.y = COORD_MAX;
   rval->p3.x = COORD_MAX;
   rval->p3.y = COORD_MAX;
   return(rval);
}

void triangle::convert_host_to_net()
{
   p1.convert_host_to_net();
   p2.convert_host_to_net();
   p3.convert_host_to_net();
}

void triangle::convert_net_to_host()
{
   p1.convert_net_to_host();
   p2.convert_net_to_host();
   p3.convert_net_to_host();
}

point& triangle::pnt(int index)
{
   if (index == 1)
      return(p1);
   if (index == 2)
      return(p2);
   if (index == 3)
      return(p3);

   GDKwarning("Index %d out of bounds for triangle\n",index);
   return(p3);
}

point triangle::centroid() const
{
   return(point(
      (p1.x + p2.x + p3.x) / 3.0,
      (p1.y + p2.y + p3.y) / 3.0));
}
