@f interval_tree
@A C.W. Quak
@h
#ifndef __INTERVAL_TREE_H__
#define __INTERVAL_TREE_H__

//
// An interval tree is a tree inside a Monet heap structure.
// There are two types of nodes and leaves.
//

class interval_node
{
public:
   interval val;	// Bounding interval of all children.

   int left;		// Index of two children. If the child
   int right;		// is a leaf it is negative.
};

class interval_leaf
{
public:
   static const int maxkids;

   int nitems;		// number of used items.

   //
   // This should be the value of maxkids. But the
   // compiler does not like that.
   //
   int kids[100];	// array with indices.
};

int interval_tree_getrootindex(Heap* tree);
void interval_tree_setrootindex(Heap* tree,int idx);
int interval_tree_makenode(Heap* tree,int left,int right,const interval& range);
int interval_tree_makeleaf(Heap* tree);
interval_node* interval_tree_getnode(Heap* tree,int index);
interval_leaf* interval_tree_getleaf(Heap* tree,int index);

#endif /* __INTERVAL_TREE_H__ */
@C
#include "gis.h"
#include "gisbulk.proto.h"
#include "interval_tree.h"

const int interval_leaf::maxkids = 100;

//
//================================
// interval_tree helper functions.
//================================
//
void interval_tree_setrootindex(Heap* h,int idx)
{
   int rootptrindex = HEAP_private(h);
   *HEAPindex(h,rootptrindex,int) = idx;
}

int interval_tree_getrootindex(Heap* h)
{
   int rootptrindex = HEAP_private(h);
   return(*HEAPindex(h,rootptrindex,int));
}

int interval_tree_makenode(Heap* h,int left,int right,const interval& range)
{
   int newindex = HEAP_malloc(h,sizeof(interval_node));
   interval_node* n = interval_tree_getnode(h,newindex);
   n->left = left;
   n->right = right;
   n->val = range;
   return(newindex);
}

int interval_tree_makeleaf(Heap* h)
{
   int newindex = -HEAP_malloc(h,sizeof(interval_leaf));
   interval_leaf* n = interval_tree_getleaf(h,newindex);
   n->nitems = 0;
   return(newindex);
}

interval_node* interval_tree_getnode(Heap* h,int idx)
{
   return(HEAPindex(h,idx,interval_node));
}

interval_leaf* interval_tree_getleaf(Heap* h,int idx)
{
   return(HEAPindex(h,-idx,interval_leaf));
}

//
//================================
// Code for splitting a leaf node.
//================================
//

//
// Temporary struct needed for split.
//
class interval_index
{ 
public:
   interval i;
   int i_idx;
};


int interval_index_compare(const void* l,const void* r)
{
   interval_index* left = (interval_index *)l;
   interval_index* right = (interval_index *)r;

   if ((left->i.min == right->i.min) && (left->i.max == right->i.max))
   {
      return(0);
   }
   else if ((left->i.min < right->i.min) || 
      ((left->i.min == right->i.min) && (left->i.max < right->i.max)))
   {
      return(-1);
   }
   else
   {
      return(1);
   }
}

//
// Add an interval to a leaf that is full. The current
// leaf is split, its entries are spread over the two
// leaves and connected with a new node. The index of the
// node is returned.
//
static int interval_split_leaf(
   BAT* b,
   Heap* tree,
   int leaf_idx,	// Leaf to be split.
   int i_idx,		// Index of interval to be inserted.
   const interval& i)	// Interval to be inserted.
{
   interval_leaf* leaf = interval_tree_getleaf(tree,leaf_idx);

   //
   // Make an array of all old entries and the new one.
   //
   interval_index ii[interval_leaf::maxkids + 1];

   //
   // Calculate the range of the new node.
   //
   interval range = i;

   for(int x=0;x<interval_leaf::maxkids;++x)
   {
      ii[x].i = *((interval *)BUNhloc(b,BUNptr(b,leaf->kids[x])));
      ii[x].i_idx = leaf->kids[x];

      range.include(ii[x].i);
   }
   ii[interval_leaf::maxkids].i = i;
   ii[interval_leaf::maxkids].i_idx = i_idx;

   //
   // Sort the array on interval.min.
   //
   qsort(&ii[0],interval_leaf::maxkids + 1,sizeof(interval_index),interval_index_compare);

   //
   // Clear the old leaf
   // Create a new leaf
   // Generate a node with two leaves as children
   //
   leaf->nitems = 0;
   int right_idx = interval_tree_makeleaf(tree);
   interval_leaf* right = interval_tree_getleaf(tree,right_idx);
   int node_idx = interval_tree_makenode(tree,leaf_idx,right_idx,range);

   //
   // Put half of the list in the left leaf and the 
   // other half in the right.
   //
   int half = (interval_leaf::maxkids + 1)/2;

   for(int i1=0;i1<=half;++i1)
   {
      leaf->kids[leaf->nitems++] = ii[i1].i_idx;
   }
   for(int i2=half + 1;i2<=interval_leaf::maxkids;++i2)
   {
      right->kids[right->nitems++] = ii[i2].i_idx;
   }

   //
   // Return the index of the created node.
   //
   return(node_idx);
}

//
//=======================================================
// Code for inserting an interval into the interval tree.
//=======================================================
//

//
// Insert a new interval in the interval tree.
//
static int interval_tree_insert_rec(
   BAT* b,		// BAT on which index is created.
   Heap* tree,		// Heap in which tree resides.
   int self_idx,	// Index of the current node in the tree.
   int i_idx,		// Index of the inserted element in the bat.
   const interval& i)	// Value of inserted element.
{
   if (self_idx == 0)
   {
      //
      // create a new leaf.
      //
      return(interval_tree_insert_rec(b,tree,interval_tree_makeleaf(tree),i_idx,i));
   }
   else if (self_idx > 0)
   {
      //
      // this is a node.
      // 
      interval_node* self = interval_tree_getnode(tree,self_idx);

      if (self->val.min < i.min)
      {
         //
	 // Insert into left.
	 //
	 self->left = interval_tree_insert_rec(b,tree,self->left,i_idx,i);
	 self->val.include(i);
	 return(self_idx);
      }
      else
      {
         //
	 // Insert into right.
	 //
	 self->right = interval_tree_insert_rec(b,tree,self->right,i_idx,i);
	 self->val.include(i);
	 return(self_idx);
      }
   }
   else
   {
      //
      // this is a leaf.
      //
      interval_leaf* leaf = interval_tree_getleaf(tree,self_idx);

      if (++leaf->nitems <= interval_leaf::maxkids)
      {
         //
	 // There is room in the leaf.
	 //
	 leaf->kids[leaf->nitems - 1] = i_idx;
         return(self_idx);
      }
      else
      {
	 //
	 // We split the leaf.
	 //
         return(interval_split_leaf(b,tree,self_idx,i_idx,i));
      }
   }
}

void interval_tree_insert(
   Heap* tree,
   int index,
   BAT* b,
   interval* i)
{
   int rootindex = interval_tree_getrootindex(tree);

   interval_tree_setrootindex(tree,interval_tree_insert_rec(b,tree,rootindex,index,*i));
}

//
//=============================================
// Functions needed for interfacing with monet.
//=============================================
//
void interval_tree_save(Heap*,BAT*)
{
}

void interval_tree_destroy(Heap* h,BAT*)
{
   HEAP_destroy(h);
}

void interval_tree_build(
   Heap* tree,
   int*,
   BAT* b)
{
   if (BAThtype(b) != TYPE_interval)
   {
      GDKerror("Cannot build interval_tree because head not of type interval\n");
      return;
   }

   b->hacctype = ACC_interval_tree;
   HEAP_initialize(tree,100,sizeof(int),8);
   interval_tree_setrootindex(tree,0);

   //
   // Insert all buns into the heap.
   //
   BUN index,dummy; 
   BATloop(b,index,dummy)
   {
      interval_tree_insert(tree,BUNindex(b,index),b,(interval *)BUNhead(b, index));
   }
}

//
//======================================================
// Code for deleting an interval from the interval tree.
//======================================================
//
static bool interval_tree_delete_rec(
   Heap* h,
   int self_idx,
   int i_idx,
   const interval& i)
{
   if(self_idx == 0)
   {
      return(false);
   }
   else if (self_idx > 0)
   {
      //
      // This is a node.
      //
      interval_node* self = interval_tree_getnode(h,self_idx);

      if (!overlap(self->val,i))
         return(false);

      if(interval_tree_delete_rec(h,self->left,i_idx,i))
         return(true);
      return(interval_tree_delete_rec(h,self->left,i_idx,i));
   }
   else
   {
      //
      // This is a leaf.
      //
      interval_leaf* leaf = interval_tree_getleaf(h,self_idx);

      for(int x=0;x<leaf->nitems;++x)
      {
         if(leaf->kids[x] == i_idx)
	 {
	    leaf->kids[x] = leaf->kids[leaf->nitems--];
	    return(true);
	 }
      }
      return(false);
   }
}

void interval_tree_delete(
   Heap* h,	
   int index,   
   BAT*,	
   interval* i)
{
   if (!interval_tree_delete_rec(
      h,
      interval_tree_getrootindex(h),
      index,
      *i))
   {
      GDKerror("interval_tree structure corrupt\n");
   }
}

//
//========================================
// Code for selection on an interval_tree.
//========================================
//
static void interval_tree_select_rec(
   BAT* intervals,
   Heap* tree,
   int self_idx,
   const interval& i,
   BAT* result)
{
   if(self_idx > 0)
   {
      //
      // This is a node.
      //
      interval_node* self = interval_tree_getnode(tree,self_idx);

      if (overlap(self->val,i))
      {
         interval_tree_select_rec(intervals,tree,self->left,i,result);
         interval_tree_select_rec(intervals,tree,self->right,i,result);
      }
   }
   else
   {
      //
      // This is a leaf.
      //
      interval_leaf* leaf = interval_tree_getleaf(tree,self_idx);
      for(int x=0;x<leaf->nitems;++x)
      {
	 BUN bun = (BUN)BUNptr(intervals,(leaf->kids[x]));
         interval* cur = (interval *)BUNtail(intervals,bun);

	 if (overlap(*cur,i))
	 {
	    BUNins(result,BUNhead(intervals,bun),cur);
	 }
      }
   }
}

//
// Interface function to monet:
//    COMMAND iselect(bat[any,interval],dbl):bat[any,interval]
//
int interval_tree_select_double(
   BAT** rval,
   BAT* intervals,
   double* d)
{
   // Heap* tree = &intervals->taccelerator;
   interval i(*d,*d);

   BAT* result = BATnew(BAThtype(intervals),BATttype(intervals),BATcount(intervals)/10);

#ifdef XXXXX
   if (intervals->tacctype != ACC_interval_tree)
   {
      int dummy;
      interval_tree_build(&intervals->taccelerator,&dummy,BATmirror(intervals));
   }
   if (tree->base == NULL)
   {
      GDKerror("This BAT has no index");
      return(NULL);
   }
   interval_tree_select_rec(intervals,tree,interval_tree_getrootindex(tree),i,result);
#else
   BUN bun,tl;
   BATloop(intervals,bun,tl)
   {
      interval* cur = (interval *)BUNtail(intervals, bun);
      if ((overlap(*cur,i)) && (cur->max != i.max))
      {
	 BUNins(result,BUNhead(intervals,bun),cur);
      }
   }
#endif

   *rval = result;

   return(GDK_SUCCEED);
}

//
// Interface function to monet:
//    COMMAND iselect(bat[any,interval],interval):bat[any,interval]
//
int interval_tree_select_interval(
   BAT** rval,
   BAT* intervals,
   interval* i)
{
   Heap* tree = &intervals->taccelerator;

   if (intervals->tacctype != ACC_interval_tree)
   {
      int dummy;
      interval_tree_build(&intervals->taccelerator,&dummy,BATmirror(intervals));
   }
   if (tree->base == NULL)
   {
      GDKerror("This BAT has no index");
      return(NULL);
   }

   BAT* result = BATnew(BAThtype(intervals),BATttype(intervals),BATcount(intervals)/10);

   interval_tree_select_rec(intervals,tree,interval_tree_getrootindex(tree),*i,result);

   *rval = result;
   return(GDK_SUCCEED);

}

//
//======================================================
// Code for printing tree structure of an interval_tree.
//======================================================
//
static void interval_tree_print_rec(
   BAT* intervals,
   Heap* tree,
   int self_idx)
{
   if(self_idx > 0)
   {
      //
      // This is a node.
      //
      interval_node* self = interval_tree_getnode(tree,self_idx);

      GDKwarning("A node with index %d, interval [%f,%f] children %d %d\n",
	 self_idx,self->val.min,self->val.max,
         self->left,self->right);

      interval_tree_print_rec(intervals,tree,self->left);
      interval_tree_print_rec(intervals,tree,self->right);
   }
   else
   {
      //
      // This is a leaf.
      //
      interval_leaf* leaf = interval_tree_getleaf(tree,self_idx);

      GDKwarning("A leaf with index %d and %d children\n",self_idx,leaf->nitems);
   }
}

//
// Interface function to monet:
//    COMMAND print(bat[any,interval])
//
int interval_tree_print(BAT* intervals)
{
   Heap* tree = &intervals->taccelerator;

   if (intervals->tacctype != ACC_interval_tree)
   {
      GDKerror("There is no index on bat so I cannot print the tree structure\n");
      return(GDK_FAIL);
   }
   if (tree->base == NULL)
   {
      GDKerror("This BAT has no index");
      return(NULL);
   }

   interval_tree_print_rec(intervals,tree,interval_tree_getrootindex(tree));

   return(GDK_SUCCEED);

}
