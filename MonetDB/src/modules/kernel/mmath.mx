@f mmath
@a N.J. Nes, M. Kersten
@d 07/01/1996
@t The math module

@* Introduction
This module contains the math commands. The implementation is very simply,
the c math library functions are called. See for documentation the
ANSI-C/POSIX manuals of the equaly named functions.

NOTE: the operand itself is being modified, rather than that we produce
a new BAT. This to save the expensive copying.

@* Module Definition
@mal
module mmath;

command acos(x:dbl):dbl = MATHunary_ACOS
"The acos(x) function calculates the arc cosine of x,
that is the value whose cosine is x. The value is returned in radians
and is mathematically defined to be between 0 and PI (inclusive).";

command asin(x:dbl)  : dbl = MATHunary_ASIN
"The asin(x) function calculates the arc sine of x,
that is the value whose sine is x. The value is returned in radians
and is mathematically defined to be between -PI/20 and -PI/2 (inclusive).";

command atan(x:dbl)     : dbl = MATHunary_ATAN
"The atan(x) function calculates the arc tangent of x,
that is the value whose tangent is x. The value is returned in radians
and is mathematically defined to be between -PI/2 and PI/2 (inclusive).";

command atan2(x:dbl,y:dbl): dbl = MATHbinary_ATAN2
"The atan2(x,y) function calculates the arc tangent of the two
variables x and y. It is similar to calculating the arc
tangent of y / x, except that the signs of both arguments
are used to determine the quadrant of the result.
The value is returned in radians and is mathematically defined
to be between -PI/2 and PI/2 (inclusive).";


command cos(x:dbl)   	  : dbl = MATHunary_COS
comment "The cos(x) function returns the cosine of x,
where x is given in radians. The return value is between -1 and 1.";

command sin(x:dbl)   	  : dbl = MATHunary_SIN
comment "The sin(x) function returns the cosine of x,
where x is given in radians. The return value is between -1 and 1.";

command tan(x:dbl)   	  : dbl = MATHunary_TAN
comment "The tan(x) function returns the tangent of x,
where x is given in radians";


command cosh(x:dbl)     : dbl = MATHunary_COSH
comment "The cosh() function  returns the hyperbolic cosine of x,
which is defined mathematically as (exp(x) + exp(-x)) / 2.";

command sinh(x:dbl)     : dbl = MATHunary_SINH
comment "The sinh() function  returns  the  hyperbolic sine of x,
which is defined mathematically as (exp(x) - exp(-x)) / 2.";

command tanh(x:dbl)     : dbl = MATHunary_TANH
comment "The tanh() function returns the hyperbolic tangent of x,
which is defined mathematically as sinh(x) / cosh(x).";


command exp(x:dbl)   	  : dbl = MATHunary_EXP
comment "The exp(x) function returns the value of e
(the base of natural logarithms) raised to the power of x.";

command log(x:dbl)   	  : dbl = MATHunary_LOG
comment "The log(x) function returns the natural logarithm of x.";

command log10(x:dbl)    : dbl = MATHunary_LOG10
comment "The log10(x) function returns the base-10 logarithm of x.";


command pow(x:dbl,y:dbl)  : dbl = MATHbinary_POW
comment "The pow(x,y) function  returns the value of x raised to the power of y.";

command sqrt(y:dbl)  	  : dbl = MATHunary_SQRT
comment "The sqrt(x) function returns the non-negative square root of x.";


command ceil(y:dbl)     : dbl = MATHunary_CEIL
comment "The ceil(x) function rounds x upwards to the nearest integer.";

command fabs(y:dbl)     : dbl = MATHunary_FABS
comment "The fabs(x) function  returns  the  absolute value of the 
floating-point number x.";

command floor(y:dbl)    : dbl = MATHunary_FLOOR
comment "The floor(x) function rounds x downwards to the nearest integer.";

command fmod(y:dbl,x:dbl) : dbl = MATHbinary_FMOD
comment "The fmod(x,y) function computes the remainder of dividing x by y.
The return value is x - n * y, where n is the quotient of x / y,
rounded towards zero to an integer.";

command round(x:dbl,y:int)     : dbl = MATHbinary_ROUND
comment "The round(n, m) returns n rounded to m places to the right of the
decimal point; if m is omitted, to 0 places. m can be negative to
round off digits left of the decimal point. m must be an integer.";

@-
The constants defined in math.h are defined in const.mx
@* Example Script
@mil
module(mmath);
setoid(oid(20000000));
asin(sin(M_PI)).print;
acos(cos(M_PI)).print;
atan(tan(M_PI_2)).print;
atan(tan(M_PI_4)).print;
tan(atan2(dbl(0.1),dbl(1.0))).print;
sqrt(pow(dbl(2),dbl(2))).print;

exp(dbl(10)).print;
log(dbl(10)).print;
log10(dbl(10)).print;

ceil(dbl(1.2)).print;
fabs(dbl(1.2)).print;
floor(dbl(1.2)).print;
fmod(dbl(15.2),dbl(2.5)).print;

quit;
@{
@h
#ifndef __MMATH_H__
#define __MMATH_H__

#include <gdk.h>

#endif /* __MMATH_H__ */
@}

@{
@* Implementation Code
@c

#include "mmath.h"
#include <math.h>
#include "mal.h"

extern double sqrt(double x);
extern double cbrt(double x);
extern double sin(double x);
extern double cos(double x);
extern double fabs(double x);

#define acos_unary(x, z)      *z = acos(*x)
#define asin_unary(x, z)      *z = asin(*x)
#define atan_unary(x, z)      *z = atan(*x)
#define atan2_binary(x, y, z) *z = atan2(*x,*y)
#define cos_unary(x, z)       *z = cos(*x)
#define sin_unary(x, z)       *z = sin(*x)
#define tan_unary(x, z)       *z = tan(*x)

#define cosh_unary(x, z)       *z = cosh(*x)
#define sinh_unary(x, z)       *z = sinh(*x)
#define tanh_unary(x, z)       *z = tanh(*x)

#define exp_unary(x, z)       *z = exp(*x)
#define log_unary(x, z)       *z = log(*x)
#define log10_unary(x, z)     *z = log10(*x)

#define pow_binary(x, y, z)   *z = pow(*x,*y)
#define sqrt_unary(x, z)      *z = sqrt(*x)

#define ceil_unary(x, z)      *z = ceil(*x)
#define fabs_unary(x, z)      *z = fabs(*x)
#define floor_unary(x, z)     *z = floor(*x)
#define fmod_binary(x, y, z)  *z = fmod(*x,*y)

@:unop(_ACOS,acos)@
@:unop(_ASIN,asin)@
@:unop(_ATAN,atan)@
@:binop(_ATAN2,atan2)@
@:unop(_COS,cos)@
@:unop(_SIN,sin)@
@:unop(_TAN,tan)@

@:unop(_COSH,cosh)@
@:unop(_SINH,sinh)@
@:unop(_TANH,tanh)@

@:unop(_EXP,exp)@
@:unop(_LOG,log)@
@:unop(_LOG10,log10)@

@:binop(_POW,pow)@
@:unop(_SQRT,sqrt)@

@:unop(_CEIL,ceil)@
@:unop(_FABS,fabs)@
@:unop(_FLOOR,floor)@
@:binop(_FMOD,fmod)@

@= unop
str MATHunary@1(dbl *res , dbl *a ) {
#ifdef DEBUG
	printf( "MATHunary@1\n");
#endif
   if (*a == dbl_nil) {
	*res = dbl_nil;
   } else {
	@2_unary( a, res );
   }
   return MAL_SUCCEED;
}
@

@= binop
str MATHbinary@1(dbl *res, dbl *a, dbl *b ) {
#ifdef DEBUG
	printf( "MATHbinary@1\n");
#endif
   if (*a == dbl_nil || *b == dbl_nil) {
	*res = dbl_nil;
   } else {
	@2_binary( a, b, res);
   }
   return MAL_SUCCEED;
}
@

@c
str MATHbinary_ROUND(dbl *res, dbl *x, int *y) {
  if(*x == dbl_nil || *y == int_nil) {
    *res = dbl_nil;
  } else {
    double factor = pow(10,*y), integral;
    double tmp = *y>0?modf(*x,&integral):*x;

    tmp *= factor;
    if(tmp>=0)
      tmp = floor(tmp+0.5);
    else
      tmp = ceil(tmp-0.5);
    tmp /= factor;

    if(*y>0)
      tmp += integral;

    *res = tmp;
  }

  return MAL_SUCCEED;
}
@}
