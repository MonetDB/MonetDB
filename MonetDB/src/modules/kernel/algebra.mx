@f algebra
@a Peter Boncz, Martin Kersten, Niels Nes
@v 2.0
@t BAT Algebra

@* Introduction
This modules contains the most common algebraic BAT manipulation 
commands. We call them @#algebra@, because all operations take
values as parameters, and produce new result values, but  
@%do not modify their parameters@.
@
@* Module Definition 
Unlike the previous Monet versions, we reduce the number
of functions returning a BAT reference. This was previously needed
to simplify recursive bat-expression and manage reference counts.
In the current version we return only a BAT identifier when a new
bat is being created.
@-
All parameters to the modules are passed by reference.
In particular, this means that
string values are passed to the module layer as (str *)
and we have to de-reference them before entering the gdk library.
This calls for knowlegde on the underlying BAT typs`s
@= derefStr
        if( @1->@2type== TYPE_str) @3 = *(str *)@3;
@
We split between selections that return one value, and selections 
that return a BAT.
@+ Value Selections
[Somehow we need this next marker to force Mx to produce good output]
@-

@mal
module algebra;

command exist(b:bat[any::1,any], h:any::1) : bit = CMDexist
comment "Returns whether 'h' occurs as a head value in b.";

command exist(b:bat[any::1,any::2], h:any::1, t:any::2) : bit = CMDexistBUN
comment "Returns true when 'h,t' occurs as a bun in b.";

command find(b:bat[any::1,any::2], h:any::1): any::2 = CMDfind
comment "Returns the tail value 't' for which some [h,t] BUN exists in b.
 If no such BUN exists, an error occurs." ;

command position(b:bat[any::1,any], val:any::1) : int = CMDposition
comment "Returns the BAT position e [0.. b.count> of a 'val' in the 
head column of b.  It gives an error if 'val' does not occur in b. ";
 
command position(b:bat[any::1,any::2], val:any::1, tval:any::2) : int = CMDpositionBUN
comment "Returns the BAT position e [0.. b.count> of a 'val' in the 
head column of b.  It gives an error if 'val' does not occur in b. ";
 
command fetch(b:bat[any,any::1], x:oid) : any::1 = CMDfetchoid;
command fetch(b:bat[any,any::1], x:lng) : any::1 = CMDfetch;
command fetch(b:bat[any,any::1], x:int) : any::1 = CMDfetch
comment "Returns the tail value of the BUN at the x-th position with 0 <= x < b.count";

@+ BAT Selections
@- positional select
@mal
command fetch(b:bat[any::1,any::2], s:bat[int, any] ) : 
				bat[any::1,any::2] = CMDfetchbat
comment "Returns a positional selection of b by the integer head values of s";

command fetch(b:bat[any::1,any::2], s:bat[oid, any]) : 
				bat[any::1,any::2] = CMDfetchbat
comment "Returns a positional selection of b by the oid head values of s";
@- range select
@mal
command select (b:bat[any::1,any::2], low:any::2, high:any::2) : 
				bat[any::1, any::2] = CMDselect
comment "Select all BUNs of a BAT that have tail values: {v| low <= v <= high}.
NIL boundary values have a special meaning.
+ low  == nil means: no lower bound
+ high == nil means: no upper bound.

NOTE 1: you should cast the nil to the appropriate type, e.g. int(nil)
        in order to cirumvent type clashes.
NOTE 2: as the 'nil' element has no clear place in the ordered domain 
        of values, tuples with 'nil values are NEVER returned by the 
        range select.";
@- unary range select
@mal
command uselect (b:bat[any::1,any::2], low:any::2, high:any::2) : 
				bat[any::1, void] = CMDuselect
comment "Select on tail, returning only the head values. 
 SEE ALSO: select(bat,low,high).";
@- value select
@mal
command select ( b:bat[any::1,any::2], value:any::2) :
                                bat[any::1, any::2] = CMDselect1
comment "Select all BUNs of a BAT with a certain tail value. Selection
 on NIL is also possible (it should be properly casted, e.g.: int(nil)).";
@- unary value select
@mal
command uselect ( b:bat[any::1,any::2], value:any::2) : 
				bat[any::1, void] = CMDuselect1
comment "Value select, but returning only the head values.
 SEE ALSO: select(bat,val)";
@mal
command fragment ( b:bat[any::1,any::2], 
	hlow:any::1, hhigh:any::1,
	tlow:any::2, thigh:any::2 ) : 
				bat[any::1,any::2] = CMDfragment
comment "Select both on head and tail range.";
@- random selection 
@mal
command sample ( b:bat[any::1,any::2], num:int ) : 
				bat[any::1,any::2] = CMDsample
comment "Produce a random selection of size 'num' from the input BAT.";
@- substring select 
@mal
command like ( b:bat[any::1, str], substr:str) :  
				bat[any::1, str] = CMDlike
comment "Selects all elements from the input BAT that have 'substr'
as substring in the tail.";
command slice(b:bat[any::1,any::2], x:int, y:int) : 
				bat[any::1,any::2] =CMDslice
comment "Return the slice with the BUNs at position x till y.";
@+ BAT copying
@mal
command copy( b:bat[any::1,any::2]) : 
				bat[any::1, any::2] = CMDcopy
comment "Returns physical copy of a BAT.";
@- sorted copy
@mal
command sort( b:bat[any::1,any::2]) : 
				bat[any::1, any::2] = CMDsort
comment "Returns a copy of a BAT sorted on the head column.";

#command sort_ht( b:bat[any::1,any::2]) : bat[any::1, any::2] = CMDsort_ht
#comment "Returns a sorted copy of a BAT.";
@- vertical projection
@mal
# moved to mal.mx
#pattern project( b:bat[any::1,any], val:any::2) : 
				#bat[any::1, any::2] = CMDproject
#comment "Fill the tail column with a constant value.";
@+ Sets
@T
Sets in Monet can be viewed in two ways:
\begin{itemize} 
\item by looking at both colums of a BAT together (Set-, or s-operators).
\item by looking at the head column only (Key- or k-operators).
\end{itemize} 
For this reason, all standard set operations come in two flavors:
\begin{itemize}
\item k-{\tt operand}, which look only at the head column.
\item s-{\tt operand} series, that look at the whole BUN.
\end{itemize}
@

@T
Operands provided are:
\begin{itemize}
\item {\tt [s,k]unique} (bat[any::1,any::2]) : bat[any::1,any::2]\\
produces a copy of the bat, with double elimination
\item {\tt [s,k]union}(bat[any::1,any::2],bat[any::1,any::2]) : bat[any::1,any::
2]\\
bat union.
\item {\tt [s,k]diff}(bat[any::1,any::2],bat[any::1,any::2]) : bat[any::1,any:
:2]\\
bat difference.
\item {\tt [s,k]intersection}(bat[any::1,any::2],bat[any::1,any::2]) : bat[any:
:1,any::2]\\
bat intersection.
\end{itemize}
Implementations typically take two forms: if the input relation(s) is/are
ordered, a merge-algorithm is used. Otherwise, hash-indices are produced
on demand for the hash-based algorithms.
\\
The {\tt [k,s]intersect(l,r)} operations result in all BUNs of {\tt l} that 
are also in {\tt r}. They do not do double-elimination over the {\tt l} BUNs.
\\
The {\tt [k,s]diff(l,r)} operations result in all BUNs of {\tt l} that are
not in {\tt r}. They do not do double-elimination over the {\tt l} BUNs.
\\
The {\tt [k,s]union(l,r)} operations result in all BUNs of l that are  
not in {\tt r}, plus all BUNs of {\tt r}. They do not do double-elimination 
over the {\tt l} nor {\tt r} BUNs.
\\
Operations with double-elimination can be formed by performing 
{\tt [k,s]unique(l)} on their operands.
\\
The {\tt kintersect(l,r)} is used also as implementation for the 
{\tt semijoin()}.

@- bun-unique elements
@mal
command unique (b:bat[any::1,any::2] ) : bat[any::1,any::2] = CMDsunique; 
command sunique (b:bat[any::1,any::2] ) : bat[any::1,any::2] = CMDsunique
comment "Select unique tuples from the input BAT. Double elimination is 
 done over BUNs as a whole (head and tail). 
 Result is a BAT with real set() semantics.";
@- head-unique elements
@mal
command kunique ( b:bat[any::1,any::2] ) : bat[any::1,any::2] = CMDkunique
comment "Select unique tuples from the input BAT. Double elimination is done
 only looking at the head column. Result is a BAT with hkeyed() == true.";

command tunique ( b:bat[any::1,any::2] ) : bat[any::1,any::2] = CMDtunique
comment "Select unique tail tuples from the input BAT. equivalent to
	revers().kunique() ";

@- bun-intersecting elements
@mal
command intersect ( left:bat[any::1,any::2], right:bat[any::1,any::2]) : 
				bat[any::1,any::2] = CMDsintersect; 
command sintersect ( left:bat[any::1,any::2], right:bat[any::1,any::2]) : 
				bat[any::1,any::2] = CMDsintersect
comment "Returns the intersection taken over *both* columns of two BATs.
 Results in all BUNs of 'left' that are also in 'right'. Does *not* do 
 double-elimination over the 'left' BUNs, If you want this, use:
 'sintersect(left.sunique,right.sunique)' or: 'sintersect(left,right).sunique'.";

@- head-intersecting elements (a.k.a. semijoin)
@mal
command semijoin( left:bat[any::1,any::2], right:bat[any::1,any] ) :
				bat[any::1,any::2] = CMDsemijoin
comment "Returns the intersection taken over only the *head* columns of 
two BATs. Results in all BUNs of 'left' that are also in 'right'. Does *not* do 
 double-elimination over the 'left' BUNs, If you want this, use:
 'kintersect(left.kunique,right.kunique)' or: 'kintersect(left,right).kunique'.";
command kintersect ( left:bat[any::1,any::2], right:bat[any::1,any] ) :
				bat[any::1,any::2] = CMDsemijoin
comment "Returns the intersection taken over only the *head* columns of 
two BATs. Results in all BUNs of 'left' that are also in 'right'. Does *not* do 
 double-elimination over the 'left' BUNs, If you want this, use:
 'kintersect(left.kunique,right.kunique)' or: 'kintersect(left,right).kunique'.";
@- bun-differing elements
@mal
command diff ( left:bat[any::1,any::2], right:bat[any::1,any::2] ) : 
				bat[any::1,any::2] = CMDsdiff; 
command sdiff ( left:bat[any::1,any::2], right:bat[any::1,any::2] ) : 
				bat[any::1,any::2] = CMDsdiff
comment "Returns the difference taken over *both* columns of two BATs.  
 Results in all BUNs of 'left' that are *not* in 'right'. Does *not* do
 double-elimination over the 'left' BUNs, If you want this, use:
 'sdiff(left.sunique,right.sunique)' or: 'sdiff(left,right).sunique'.";
@- head-differing elements
@mal
command kdiff ( left:bat[any::1,any::2], right:bat[any::1,any] ) :
				bat[any::1,any::2] = CMDkdiff
comment "Returns the difference taken over only the *head* columns of two BATs. 
 Results in all BUNs of 'left' that are *not* in 'right'. Does *not* do
 double-elimination over the 'left' BUNs, If you want this, use:
 'kdiff(left.kunique,right.kunique)' or: 'kdiff(left,right).kunique'.";
@- union on bun
@mal
command union ( left:bat[any::1,any::2], right:bat[any::1,any::2]) : 
				bat[any::1,any::2] = CMDsunion; 
command sunion ( left:bat[any::1,any::2], right:bat[any::1,any::2]) : 
				bat[any::1,any::2] = CMDsunion
comment "Returns the union of two BATs; looking at both columns of both BATs. 
 Results in all BUNs of 'left' that are  not in 'right', plus all BUNs 
 of 'right'. *no* double-elimination is done. If you want this, do: 
 'sunion(left.sunique,right.sunique)' or: 'sunion(left,right).sunique'.";
@- union on head
@mal
command kunion ( left:bat[any::1,any::2], right:bat[any::1,any::2]):bat[any::1,any::2] = CMDkunion
comment "Returns the union of two BATs; looking at head-columns only. 
 Results in all BUNs of 'left' that are  not in 'right', plus all BUNs 
 of 'right'. *no* double-elimination is done. If you want this, do: 
 'kunion(left.kunique,right.kunique)' or: 'sunion(left,right).kunique'.";
@+ Joins
The core of every relational engine.
Signature Changed: Output tail type incorrect because of soid to coid switch. 

@- join(projected out join columns)
The join collection provided by the GDK kernel.

@mal
command join( left:bat[any::1,any::2], right:bat[any::2,any::3]) :
                               bat[any::1,any::3] = CMDjoin
comment "Returns all BUNs, consisting of a head-value from 'left' and
a tail-value from 'right' for which there are BUNs in 'left'
and 'right' with equal tail- resp. head-value (i.e. the join
columns are projected out).";

command fetchjoin ( left:BAT[any::1,any::2],right:BAT[any::2,any::3] ) :
                    BAT[any::1,any::3] = CMDfetchjoin
comment "Hook directly into the fetch implementation of the join.";

command mergejoin (left:BAT[any::1,any::2], right:BAT[any::2,any::3]) :
                    BAT[any::1,any::3] = CMDmergejoin
comment "Hook directly into the merge implementation of the join.";

command hashjoin ( left:BAT[any::1,any::2], right:BAT[any::2,any::3]) :
                    BAT[any::1,any::3] = CMDhashjoin
comment "Hook directly into the hash implementation of the join.";

command indexjoin ( left:BAT[any::1,any::2], right:BAT[any::2,any::3]) :
                    BAT[any::1,any::3] = CMDindexjoin
comment "Hook directly into the index implementation of the join.";

@- Outer Join
@mal
command outerjoin( outer:bat[any::1,any::2], inner:bat[any::2,any::3]) :
                                bat[any::1,any::3] = CMDouterjoin
comment "Returns all the result of a join, plus the BUNS formed NIL in
the tail and the head-values of 'outer' whose tail-value does
not match an head-value in 'inner'.";

@- { <,<=,=,>=,> } Join
@mal
command thetajoin( left:bat[any::1,any::2], right:bat[any::2,any::3], 
		mode:int) : bat[any::1,any::3] = CMDthetajoin
comment "Theta join on for 'mode' in { LE, LT, EQ, GT, GE }.
JOIN_EQ is just the same as join(). All other options do merge
algorithms; either using the fact that they are ordered()
already (left on tail, right on head), or by using/creating
binary search trees on the join columns. ";
@- Theta Join with inner columns
@mal
command theta ( inner_result:bat[any::2,any::2], 
		outer_result:bat[any::1,any::3],
		left:bat[any::1,any::2], 
		right:bat[any::2,any::3], mode:int ) 
				= CMDtheta
comment "Theta join, just as simple thetajoin(l,r); the difference
is that it returns two values, which are added to the first params
'inner_result' and 'outer_result'; 'inner_result' gets all matching
inner tuples, 'outer_result' the other two (what would have the
result of thetajoin(l,r)).";
@- Band Join (approximate match)
@mal
command bandjoin( outer:bat[any::1,any::2], 
		   inner:bat[any::2,any::3],
		   minus:any::2 , plus:any::2 ) : 
				bat[any::1,any::3] = CMDbandjoin
comment "This is a join() for which the predicate is that two BUNs match if
the left-tail value is within the range [right-head - minus,
right-head + plus]
Works only for the builtin numerical types, and their derivates.";
@+ OID Introducing Commands
For relational processing, some operators are necessary to produce newly 
initiated OID columns, for representing n-ary (intermediary) relations. 

@- OID head column
@mal
command mark( b:bat[any::1,any] ) : bat[any::1,oid] = CMDmark_default
comment "Produces a new BAT with fresh unique OIDs in the tail.";

command mark( b:bat[any::1,any],base:void ): bat[any::1,oid] = CMDmark_default
comment "Produces a new BAT with fresh unique OIDs in the tail.";

command mark( b:bat[any::1,any], base:oid ) : bat[any::1,oid] = CMDmark
comment "Produces a new BAT with fresh unique dense sequense of OIDs in the tail
 that starts at base (i.e. [base,base+1,..base+b.count()-1] ).";
@- number tail column
@mal
command number( b:bat[any::1,any] ) : bat[any::1,int]  = CMDnumber
comment "Produces a new BAT with identical head column, and consecutively
increasing integers (starting with 0) in the tail column.";

@+ BAT fragmentation commands
Various operations for splitting BATs into useful fragments.

@- Hash Split
The commands below is temporarilly postponed
command hashsplit ( b:bat[any::1,any::2] , buckects:int ) :
			 	bat[int,bat[any::1,any::2]] = CMDhashsplit
comment "Split a BAT on tail column according (hash-value MOD buckets).
Returns a recursive BAT, containing the fragments in the tail,
their bucket number in the head.";

command uhashsplit ( b:bat[any::1,any::2], buckets:int ) :
			 	bat[int,bat[any::1,any::2]] = CMDuhashsplit
comment "Same as hashsplit, but only collect the head values in the fragments";
@- Range Split
command rangesplit ( b:bat[any::1,any::2], ranges:int ) : 
				bat[any::2,bat[any::1,any::2]] = CMDrangesplit
comment "Split a BAT on tail column in 'ranges' equally sized
consecutive ranges. Returns a recursive BAT, containing the
fragments in the tail, the higher-bound of the range in the head.
The higher bound of the last range is 'nil'.";

command urangesplit ( b:bat[any::1,any::2], ranges:int ) : 
				bat[any::2,bat[any::1,void]] = CMDurangesplit
comment "Same as rangesplit, but only collect the head values in the fragments" ;

@+ Common BAT Aggregates
These operations examine a BAT, and compute some simple aggregate result 
over it.
@- BAT size
@mal
command count ( b:bat[any,any] ) : lng = CMDcount
comment "Return the number of elements currently in a BAT.";
@- Histogram on Tail 
@mal
command histogram ( b:bat[any,any::2]) : bat[any::2,int] = CMDhistogram
comment "Produce a BAT containing the histogram of the tail values.
 bat.histogram() ::= {count}(bat.reverse)";

@-
command out of order right now. Should become an optimization pattern
group.count -> histogram(bat.reverse)
command {count} ( b:bat[any::2,any]) : 
				bat[any::2,int] = CMDhistogram_rev
comment "Count the number of groups.
 It has fast implementation: histogram(bat.reverse)";

@- Default Min and Max
@T
Implementations a generic Min and Max routines get declared first. The 
{\tt min()} and {\tt max()} routines below catch any tail-type. 
The type-specific routines defined later are faster, and will 
override these any implementations.
@- minimum tail value
@mal
command min ( b:bat[any::1,any::2] ): any::2 = CMDBATminimum
comment "Give the lowest tail value. Error on empty BATs.";

@- maximum tail value
@mal
command max ( b:bat[any::1,any::2] ) : any::2 = CMDBATmaximum
comment "Give the highest tail value. Error on empty BATs.";

command size ( b:bat[any,any] ) : int = CMDBATsize
comment "Returns the current size (in number of elements) of a BAT.";

@+ Type-Specific Sum, Max and Min
@T
For X $\in$ \{ sht,int,flt,dbl,lng \},  we define (using the {\em aggregate}
macro):
\begin{itemize}
\item command sum(bat[any,X] : X, 
\item command max(bat[any,X] : X, and 
\item command min(bat[any,X] : X. 
\end{itemize}
@mal
@:aggregate(sum,"Gives the sum of all tail values.")@
@:aggregate(max,"Give the highest tail value. Error on empty BATs.")@
@:aggregate(min,"Give the lowest tail value. Error on empty BATs.")@

@= aggregate_definition
command @1 ( b:bat[any,@2] ) : @2 = CMD@1_@2 comment @3;
@= aggregate
@:aggregate_definition(@1,sht,@2)@
@:aggregate_definition(@1,int,@2)@
@:aggregate_definition(@1,flt,@2)@
@:aggregate_definition(@1,dbl,@2)@
@:aggregate_definition(@1,lng,@2)@

@+ Modeling With Properties
@T
The Monet kernel performs {\em run-time optimizations}. To choose between
alternaticve algorithms in a sensible way, it maintains knowledge about 
each BAT, sometimes as a {\em BAT property}, sometimes as two
{\em column properties} for each column (head and tail)
of a BAT. An example of the former is {\em size(bat) : int}
(which gives the number of BUNs in a BAT), an example
of the latter is {\tt ordered(column) : bit}, indicating 
whether the column contains its valued stored in ascending order.
The convention is to use a BAT as operand also for the column
properties; which then is supposed to be valid for the head
column ({\tt ordered(BAT)}). Tail columns can be described by 
using the mirror BAT with the minus operator ({\tt ordered(-BAT)}).

@- Column Properties
@T
\begin{description}
\item[{\tt ordered(BAT) : bit}] 
	TRUE if the head column is stored in ascending order, else FALSE.
\item[{\tt keyed(BAT) : bit}] 
	TRUE if no duplicates are present in the head column, else FALSE.
\item[{\tt idx(BAT) : bit}] 
	TRUE if a binary index tree search accelerator is present on 
	the head column of the BAT, else FALSE.
\item[{\tt hashtab(BAT) : bit}] presence of hash table on the head column of 
	a BAT. TRUE if a bucket-chained hash table search accelerator is 
	present on the head column of the BAT, else FALSE.
\item[{\tt subcol(BAT, BAT) : bit}] 
	TRUE if the bag of all values in the head column of the left BAT is
	a bag-subset of the bag of all values in the head column of the 
	right BAT, else FALSE. 
\item[{\tt sync(BAT) : oid}] 
	Sync-OID on the head column of a BAT. A sync-OID denotes some unique
	sequence of values. If two columns have the same sync-OID, then they
	are guaranteed to contain the same values, in the same sequence.
\end{description}

@- BAT properties
@T
\begin{description}
\item[{\tt size(BAT) : int}] 
	The (estimated) length of a column.
\item[{\tt unique(BAT) : int}] 
	The (estimated) number of distinct values in one column.
\item[{\tt subset(BAT, BAT) : bit}] 
	TRUE if the left BAT is a subset of the BUNs of the right BAT, 
	else FALSE.
\item[{\tt setunique(BAT) : bit}] 
	TRUE if the BAT contains no duplicate BUNs, else FALSE.
\end{description}

@- Property Propagation Rules
@T
At database creation time, the properties of the BATs in the database
can be derived directly from the database schema.

When queries are executed, they will produce {\em intermediate results},
which in terms are operands for further execution. Hence it is necessary
to {\em propagate properties} from the operands of an algebraic operator,
to its result. 

This process can be captured by having a series of {\em propagation rules} 
for each algebraic operand. Since each algebraic operands may apply
different strategies, according to different status in its operand properties, 
each algebraic operator may have different propagation rules with these 
different situations as conditions.

@* Command Implementations in C
This module contains just a wrapper implementations; since all described 
operations are part of the GDK kernel.

@-
The BAT identifiers passed through this module may indicate
that the 'reverse' view applies. This should be taken into
account while resolving them.
@= getBATdescriptor
        if( BBPcheck(*@2,"@4")==0) 
                return throwMessage("@4:cannot access bat @2 in bbp");
        @3= (BAT*) BBPgetdesc(*@2);
        if( @3 == NULL) { *@1 = 0; 
                return throwMessage("@4:cannot access descriptor @2");
	}
	if( *@2 <0){ /* BAT reverse */ @3 = BATmirror(@3); }

@= aggregate_implementation
str CMDsum_@1(@1* result, int *bid) {
	BAT *b;
	@:getBATdescriptor(result,bid,b,CMDsum)@
	if( BATsum(b, result)) return MAL_SUCCEED;
	return throwMessage("CMDsum_@1:GDKerror");
}
str CMDmin_@1(@1* result, int *bid) {
	BAT *b;
	@:getBATdescriptor(result,bid,b,CMDmin)@
	if( BATmin(b, result)) return MAL_SUCCEED;
	return throwMessage("CMDmin_@1:GDKerror");
}
str CMDmax_@1(@1* result, int *bid) {
	BAT *b;
	@:getBATdescriptor(result,bid,b,CMDmax)@
	if( BATmax(b, result)) return  MAL_SUCCEED;
	return throwMessage("CMDmax_@1:GDKerror");
}
@c
#include "monet.h"
/*
 * The contents of this file are subject to the Monet Public
 * License Version 1.1 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy of
 * the License at 
 * http://www.monetsolutions.com/Download/Licensing/MonetPL-1.1.html
 * 
 * Software distributed under the License is distributed on an "AS
 * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 * 
 * The Original Code is the Monet Database System.
 * 
 * The Initial Developer of the Original Code is CWI.
 * Portions created by CWI are Copyright (C) 1997-2001 CWI.  
 * All Rights Reserved.
 * 
 * Contributor(s): Martin Kersten <Martin.Kersten@cwi.nl>
 *		   Peter Boncz <Peter.Boncz@cwi.nl>
 *		   Niels Nes <Niels.Nes@cwi.nl>
 */

str CMDBATsize(int *res, int *bid) {
        if (BBPcheck(*bid, "CMDBATsize")) {
                BAT *b = (BAT*) BBPgetdesc(*bid);
                if (b == NULL) {
                        *res = int_nil;
                } else if (BBP_cache(*bid)) {
                        *res = BATcount(b);
                } else {
                        /* BAT not loaded */
                        *res = (b->batBuns->free - 
			(b->batHole - b->batBuns->base))/BUNsize(b) - 1;
                }
        }
        return MAL_SUCCEED;
}



@:aggregate_implementation(sht)@
@:aggregate_implementation(int)@
@:aggregate_implementation(flt)@
@:aggregate_implementation(dbl)@
@:aggregate_implementation(lng)@

str CMDBATminimum(ptr *result, int *bid) {
	BAT *b;

	@:getBATdescriptor(result,bid,b,CMDBATminimum)@
	if (!ATOMlinear(b->ttype)) 
		return throwException("CMDminANY:'%s' lacks linear order",
					ATOMname(b->ttype));
	if (ATOMvarsized(b->ttype)) {
		*(ptr*) result = BATmin(b, NULL);
		if( *(ptr*) result ) return MAL_SUCCEED; 
		return throwMessage("CMDBATminimum:GDKerror");
	}
	if (BATmin(b, result)) {
		if (b->ttype == TYPE_bat) 
			*(int*) result = BATdescriptor(*(int*) result)->batCacheid;
		return MAL_SUCCEED;
	}
	return throwMessage("CMDBATminimum:GDKerror");
}
str CMDBATmaximum(ptr *result, int *bid) {
	BAT *b;

	@:getBATdescriptor(result,bid,b,CMDBATmaximum)@
	if (!ATOMlinear(b->ttype)) 
		return throwException("CMDmaxANY:'%s' lacks linear order",
				ATOMname(b->ttype));
	if (ATOMvarsized(b->ttype)) {
		*(ptr*) result = BATmax(b, NULL);
		if( *(ptr*) result ) return MAL_SUCCEED; 
		return throwMessage("CMDBATmaximum:GDKerror");
	}
	if (BATmax(b, result)) {
		if (b->ttype == TYPE_bat) 
			*(int*) result = BATdescriptor(*(int*) result)->batCacheid;
		return MAL_SUCCEED;
	}
	return throwMessage("CMDBATmaximum:GDKerror");
}
str CMDselect1(int *result, int *bid, ptr value) {
	BAT *b, *bn;
	@:getBATdescriptor(result,bid,b,CMDselect1)@
	@:derefStr(b,h,value);@
	bn = (BAT*) BATselect(b, value, 0);
	if( bn ) {
		*result = bn->batCacheid;
		return MAL_SUCCEED;
	}
	return throwMessage("CMDselect1:GDKerror");
}

str CMDuselect1(int *result, int *bid, ptr value) {
	BAT *b, *bn;
	@:getBATdescriptor(result,bid,b,CMDuselect1)@
	@:derefStr(b,h,value);@
	bn = (BAT*) BATuselect(b, value, 0);
	if( bn ) {
		*result = bn->batCacheid;
		return MAL_SUCCEED;
	}
	return throwMessage("CMDuselect1:GDKerror");
}

str CMDselect(int *result, int *bid, ptr low, ptr high) {
	BAT *b, *bn;
	@:getBATdescriptor(result,bid,b,CMDselect)@
	@:derefStr(b,t,low);@
	@:derefStr(b,t,high);@
	bn = (BAT*) BATselect(b, low, high);
	if( bn ) {
		*result = bn->batCacheid;
		return MAL_SUCCEED;
	}
	return throwMessage("CMDselect:GDKerror");
}
str CMDuselect(int *result, int *bid, ptr low, ptr high) {
	BAT *b, *bn;
	@:getBATdescriptor(result,bid,b,CMDuselect)@
	@:derefStr(b,t,low);@
	@:derefStr(b,t,high);@
	bn = (BAT*) BATuselect(b, low, high);
	if( bn ) {
		*result = bn->batCacheid;
		return MAL_SUCCEED;
	}
	return throwMessage("CMDuselect:GDKerror");
}
str CMDfragment(int *result, int *bid, 
		ptr hlow, ptr hhigh, ptr tlow, ptr thigh) 
{
	BAT *b, *bn;
	@:getBATdescriptor(result,bid,b,CMDfragment)@
	@:derefStr(b,h,hlow);@
	@:derefStr(b,h,hhigh);@
	@:derefStr(b,t,tlow);@
	@:derefStr(b,t,thigh);@
	bn = (BAT*) BATrestrict(b, hlow, hhigh, tlow, thigh);
	if( bn ) {
		*result = bn->batCacheid;
		return MAL_SUCCEED;
	}
	return throwMessage("CMDfragment:GDKerror");
}
str CMDthetajoin(int *result, int *lid, int *rid, int *mode) {
	BAT *left, *right, *bn;
	@:getBATdescriptor(result,lid,left,CMDthetajoin)@
	@:getBATdescriptor(result,rid,right,CMDthetajoin)@
	bn = (BAT*) BATthetajoin(left, right, *mode);
	if( bn ) {
		*result = bn->batCacheid;
		return MAL_SUCCEED;
	}
	return throwMessage("CMDthetajoin:GDKerror");
}
str CMDtheta(int *iid, int *oi, int *lid, int *rid, int *mode) {
	BAT *inner,*outer, *left, *right;
	int result;
	@:getBATdescriptor(&result,iid,inner,CMDtheta)@
	@:getBATdescriptor(&result,oi,outer,CMDtheta)@
	@:getBATdescriptor(&result,lid,left,CMDtheta)@
	@:getBATdescriptor(&result,rid,right,CMDtheta)@
	BATtheta(inner, outer, left, right, *mode);
	return MAL_SUCCEED;
}
str CMDbandjoin(int *result, int *lid, int *rid, ptr *minus, ptr *plus) {
	BAT *left, *right, *bn;
	@:getBATdescriptor(result,lid,left,CMDbandjoin)@
	@:getBATdescriptor(result,rid,right,CMDbandjoin)@
	bn = (BAT*) BATbandjoin(left, right, minus, plus);
	if( bn ) {
		*result = bn->batCacheid;
		return MAL_SUCCEED;
	}
	return throwMessage("CMDbandjoin:GDKerror");
}

@-
Let cut this text down with some Mx macro's
@= unary
str CMD@1(int *result, int *bid) {
	BAT *b,*bn;
	@:getBATdescriptor(result,bid,b,CMD@1)@
	*result = 0;
	bn = (BAT*) @2(b);
	if( bn ) {
		*result = bn->batCacheid;
		return MAL_SUCCEED;
	}
	return throwMessage("CMD@1:GDKerror");
}
@= unaryint
str CMD@1(int *result, int *bid) {
	BAT *b;
	*result = 0;
	@:getBATdescriptor(result,bid,b,CMD@1)@
	*result = (int) @2(b);
	return MAL_SUCCEED;
}
@= binary
str CMD@1(int *result, int *lid, int *rid) {
	BAT *left, *right,*bn;
	*result = 0;
	@:getBATdescriptor(result,lid,left,CMD@1)@
	@:getBATdescriptor(result,rid,right,CMD@1)@
	bn = (BAT*) @2(left, right);
	if( bn ) {
		*result = bn->batCacheid;
		return MAL_SUCCEED;
	}
	return throwMessage("CMD@1:GDKerror");
}
@= binaryint
str CMD@1(int *result, int* bid, int *param) {
	BAT *b, *bn;
	*result = 0;
	@:getBATdescriptor(result,bid,b,CMD@1)@
	bn = @2(b, *param);
	if( bn ) {
		*result = bn->batCacheid;
		return MAL_SUCCEED;
	}
	return throwMessage("CMD@1:GDKerror");
}
@c
@:unaryint(count, BATcount)@
@:unary(histogram, BAThistogram)@
@:unary(sort, BATsort)@
@:unary(number, BATnumber)@
@:unary(copy, BATcopy)@
@:unary(kunique, BATkunique)@
@:unary(sunique, BATsunique)@
@:binary(join, BATjoin)@
@:binary(semijoin, BATsemijoin)@
@:binary(outerjoin, BATouterjoin)@
@:binary(sunion, BATsunion)@
@:binary(kunion, BATkunion)@
@:binary(sintersect, BATsintersect)@
@:binary(kintersect, BATkintersect)@
@:binary(sdiff, BATsdiff)@
@:binary(kdiff, BATkdiff)@
@:binaryint(sample, BATsample)@

str CMDfetchjoin(int *result, int *lid, int *rid) {
	BAT *left, *right,*bn;
	int rfetch,lfetch;

	@:getBATdescriptor(result,lid,left,CMDfetchjoin)@
	@:getBATdescriptor(result,rid,right,CMDfetchjoin)@

	rfetch = (BAThdense(right) && ATOMstorage(left->ttype) <= TYPE_int);
	lfetch = (BATtdense(left) && ATOMstorage(right->htype) <= TYPE_int);
	if (lfetch && !(rfetch && BATcount(left) < BATcount(right))) {
		bn= BATfetchjoin(left, right);
	} else if (rfetch) 
		bn= BATmirror(BATfetchjoin(BATmirror(right), BATmirror(left)));

	if( bn ) {
		*result = bn->batCacheid;
		return MAL_SUCCEED;
	}
	return throwMessage("CMDfetchjoin:can not perform a fetchjoin");
}
str CMDhashjoin(int *result, int *lid, int *rid) {
	BAT *left, *right,*bn;
	int lsize,rsize;

	@:getBATdescriptor(result,lid,left,CMDhashjoin)@
	@:getBATdescriptor(result,rid,right,CMDhashjoin)@

	lsize = left->batBuns->size + (left->hheap.base?left->hheap.size:0) +
                                 (left->theap.base?left->theap.size:0);
	rsize = right->batBuns->size + (right->hheap.base?right->hheap.size:0) +
                                 (right->theap.base?right->theap.size:0);

	if (rsize < lsize) 
		bn= BATmirror(BAThashjoin(BATmirror(right), BATmirror(left)));
	else	bn= BAThashjoin(left, right);

	if( bn ) {
		*result = bn->batCacheid;
		return MAL_SUCCEED;
	}
	return throwMessage("CMDhashjoin:can not perform a hashjoin");
}

str CMDmergejoin(int *result, int *lid, int *rid) {
	BAT *left, *right,*bn;
	int lsize,rsize;

	@:getBATdescriptor(result,lid,left,CMDmergejoin)@
	@:getBATdescriptor(result,rid,right,CMDmergejoin)@
	if ( !((BATtordered(left)&1)||(BAThordered(right)&1)) ) 
		return throwMessage( 
		"CMDmergejoin:neither left nor right bat is ordered.\n" );

	if ( (left->ttype==TYPE_void) || (right->htype==TYPE_void) ) 
		return throwMessage( 
		"CMDmergejoin:Cannot perform mergejoin on void fields.\n" );
	bn= BATmergejoin(left,right);
	if( bn ) {
		*result = bn->batCacheid;
		return MAL_SUCCEED;
	}
	return throwMessage("CMDmergejoin:can not perform a mergejoin");
}

str CMDindexjoin(int *result, int *lid, int *rid) {
	BAT *left, *right,*bn;
	int lsize,rsize;

	@:getBATdescriptor(result,lid,left,CMDindexjoin)@
	@:getBATdescriptor(result,rid,right,CMDindexjoin)@

	bn= BATthetajoin(left,right, JOIN_EQ);
	if( bn ) {
		*result = bn->batCacheid;
		return MAL_SUCCEED;
	}
	return throwMessage("CMDindexjoin:can not perform a indexjoin");
}
str CMDtunique(int *result, int *bid) {
	BAT *b,*bn;
	@:getBATdescriptor(result,bid,b,CMDtunique)@
	*result = 0;
	bn = (BAT*) BATkunique(BATreverse(b));
	if( bn ) {
		*result = bn->batCacheid;
		return MAL_SUCCEED;
	}
	return throwMessage("CMDtunique:GDKerror");
}

str CMDmark(int *result, int *bid, oid *base){
	BAT *b, *bn;
	@:getBATdescriptor(result,bid,b,CMDmark)@
	bn= BATmark(b, *base);
	if( bn ) {
		*result = bn->batCacheid;
		return MAL_SUCCEED;
	}
	return throwMessage("CMDmark:GDKerror");
}
str CMDmark_default(int *result, int *bid){
	oid base;
	BAT *b;
	@:getBATdescriptor(result,bid,b,CMDmark_default)@
	base = OIDnew(BATcount(b));
	return CMDmark(result, bid, &base);
}
str CMDhashsplit(int *result, int *bid, int *nfrag){
	BAT *b, *bn;
	@:getBATdescriptor(result,bid,b,CMDhashsplit)@
	bn= BAThashsplit(b, *nfrag, FALSE);
	if( bn ) {
		*result = bn->batCacheid;
		return MAL_SUCCEED;
	}
	return throwMessage("CMDhashsplit:GDKerror");
}
str CMDuhashsplit(int *result, int *bid, int *nfrag){
	BAT *b, *bn;
	@:getBATdescriptor(result,bid,b,CMDuhashsplit)@
	bn= BAThashsplit(b, *nfrag, TRUE);
	if( bn ) {
		*result = bn->batCacheid;
		return MAL_SUCCEED;
	}
	return throwMessage("CMDuhashsplit:GDKerror");
}
str CMDrangesplit(int *result, int *bid, int *nfrag){
	BAT *b, *bn;
	@:getBATdescriptor(result,bid,b,CMDrangesplit)@
	bn= BATrangesplit(b, *nfrag, FALSE);
	if( bn ) {
		*result = bn->batCacheid;
		return MAL_SUCCEED;
	}
	return throwMessage("CMDrangesplit:GDKerror");
}
str CMDurangesplit(int *result, int *bid, int *nfrag){
	BAT *b, *bn;
	@:getBATdescriptor(result,bid,b,CMDurangesplit)@
	bn= BATrangesplit(b, *nfrag, TRUE);
	if( bn ) {
		*result = bn->batCacheid;
		return MAL_SUCCEED;
	}
	return throwMessage("CMDurangesplit:GDKerror");
}

str CMDhistogram_rev(int *result, int *bid) {
	BAT *b, *bn;
	@:getBATdescriptor(result,bid,b,CMDhistogram_rev)@
	bn =BAThistogram(BATmirror(b));
	if( bn ) {
		*result = bn->batCacheid;
		return MAL_SUCCEED;
	}
	return throwMessage("CMDhistogram:GDKerror");
} 


@- Substring Select
The string pattern matching routine has been added. It should be
dynamically linked.
A simple string matcher is included. It should be refined later on
@c
INLINE int like(x, y, ylen)
str x, y;
int ylen;
{
        char *r;
        if (*x == (char )NULL) {
                return 0;
        }
        for (r = x+strlen(x)-ylen; x <= r; x++) {
                int ok = 1;
                char *s = x;
                char *q;
                for (q = y; *q; q++, s++)
                    if (*q != tolower(*s)) {
                        ok = 0; break;
                    }
                if (ok){
			return 1;
		}
        }
        return 0;
}

str CMDlike(int *ret, int *bid, str *k) {
	BAT *c, *b, *bn;
	str	t,s;
	BUN	u, v;
	int 	xx, yy=0;
	@:getBATdescriptor(ret,bid,b,CMDlike)@
        c = BATnew(BAThtype(b), TYPE_str, BATcount(b)/10);
	t = GDKstrdup(*k);

	for(s=t; *s; s++,yy++)
		*s = tolower(*s);
	
	if (b->hvarsized) {
	    BATloopFast(b, u, v, xx) 
		if (like(BUNtvar(b, u), t, yy)) 
		    BUNfastins(c, BUNhvar(b, u), BUNtvar(b, u));
	} else {
	    BATloopFast(b, u, v, xx) 
		if (like(BUNtvar(b, u), t, yy)) 
		    BUNfastins(c, BUNhloc(b, u), BUNtvar(b, u));
	}
	c->hsorted = BAThordered(b);
	c->tsorted = BATtordered(b);
	GDKfree(t);
	*ret = c->batCacheid;
	return MAL_SUCCEED;
}

@- BAT slice
@c
str CMDslice(int *ret, bat *bid, int *start, int *end){
	BAT *b, *br;
	@:getBATdescriptor(ret,bid,b,CMDslice)@
	br = BATslice(b, start, end);
	if( br != NULL){
		*ret= br->batCacheid;
		return MAL_SUCCEED;
	}
	*ret =0;
	return throwMessage("CMDslice:GDKerror");
}

@- BUN Get/Fetch
@c
str CMDposition(int *retval, int *bid, ptr val){
	BAT *b;
	ptr p,v;

	@:getBATdescriptor(retval,bid,b,CMDposition)@
	@:derefStr(b,h,val)@
	v = BUNfnd(b, val);
        if (v == 0) 
                return throwMessage("CMDposition: item not found");
        *retval = BUNindex(b, v)- BUNindex(b, BUNfirst(b));
        return MAL_SUCCEED;
}
str CMDpositionBUN(int *retval, int *bid, ptr val, ptr tval){
	BAT *b;
	ptr v;

	@:getBATdescriptor(retval,bid,b,CMDpositionBUN)@
	@:derefStr(b,h,val)@
	@:derefStr(b,t,tval)@
	v = BUNlocate(b, val, tval);
        if (v == 0) 
                return throwMessage("CMDposition: item not found");
        *retval = BUNindex(b, v)- BUNindex(b, BUNfirst(b));
        return MAL_SUCCEED;
}

str CMDfetchbat(int * ret, int *bid, int *sid){
	BAT *b, *s, *bn;
	@:getBATdescriptor(ret,bid,b,CMDfetchbat)@
	@:getBATdescriptor(ret,sid,s,CMDfetchbat)@

	bn= BATfetch(b, s);
	if( bn ) {
		*ret = bn->batCacheid;
		return MAL_SUCCEED;
	}
	return throwMessage("CMDfetchbat:GDKerror");
}

@-
Factor out some common code.

@= putTail
	if (b->theap.base) {
	    ptr _src = b->theap.base + *(int*) BUNtloc(b,@1);
	    int _len = ATOMlen(b->ttype, _src);
	    ptr _dst = GDKmalloc(_len);
	    memcpy(_dst, _src, _len);
	    *(ptr*) ret = _dst;
	} else {
	    int _s = ATOMsize(ATOMtype(b->ttype));
	    if (ATOMvarsized(b->ttype)) {
		memcpy(*(ptr*) ret=GDKmalloc(_s), BUNtloc(b, @1), _s);
	    } else if (b->ttype == TYPE_bat) {
		bat bid = *(int*) BUNtloc(b, @1);
		*(BAT**) ret = BATdescriptor(bid);
		BBPfix(bid);
	    } else if (_s == 4) {
		*(int*) ret = *(int*) BUNtail(b, @1);
	    } else if (_s == 1) {
		*(chr*) ret = *(chr*) BUNtail(b, @1);
	    } else if (_s == 2) {
		*(sht*) ret = *(sht*) BUNtail(b, @1);
	    } else if (_s == 8) {
		*(lng*) ret = *(lng*) BUNtail(b, @1);
	    } else {
		memcpy(ret, BUNtloc(b, @1), _s);
	    }
	}
@c
str CMDfetch(ptr ret, int *bid, int *pos){
	int i = *pos;
	BAT *b;
	int result;

	@:getBATdescriptor(&result,bid,b,CMDfetch);
        if ((i < 0) || (i >= BATcount(b)))
                return throwMessage("CMDfetch: idx out of range");
        i += BUNindex(b, BUNfirst(b));
	@:putTail(BUNptr(b,i))@
        return MAL_SUCCEED;
}

str CMDfetchoid(ptr *ret, int *bid, oid *pos){
	BAT *b;
	int newpos;
	int result;

	@:getBATdescriptor(&result,bid,b,CMDfetchoid);
	newpos = (int) (*pos - b->hseqbase);
	if (b->hseqbase == oid_nil) 
                return throwMessage("CMDfetchoid: void lookup on uninitialized column.");
	return CMDfetch(*ret, bid, &newpos);
}

str CMDexist(bit *ret, int *bid, ptr val){ 
	BAT *b;
	BUN q;
	int result;

	@:getBATdescriptor(&result,bid,b,CMDexist);
	@:derefStr(b,h,val)@
	q = BUNfnd(b, val);
	*ret = q?1:0;
        return MAL_SUCCEED;
}
str CMDexistBUN(bit *ret, int *bid, ptr val, ptr tval){ 
	BAT *b;
	BUN q;
	int result;

	@:getBATdescriptor(&result,bid,b,CMDexistBUN);
	@:derefStr(b,h,val)@
	@:derefStr(b,t,tval)@
	q = BUNlocate(b, val, tval);
	*ret = q?1:0;
        return MAL_SUCCEED;
}

str CMDfind(ptr ret, int *bid, ptr val){ 
	BAT *b;
	ptr p;
	BUN q;
	int result;

	@:getBATdescriptor(&result,bid,b,CMDfind);
	@:derefStr(b,h,val)@
	q = BUNfnd(b, val);
	if (q == NULL)
		return throwException("CMDfind: value not found.");
	@:putTail(q)@
        return MAL_SUCCEED;
}
