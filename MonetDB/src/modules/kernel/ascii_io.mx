@f ascii_io
@t The ascio io Module
@a Niels Nes
@d 12/01/2001
@+
What is the purpose of this module...?
@mal
module ascii_io;

command ascii_io_debug( int debug ) = init_ascii_io 
comment "Ascii_io debug control";

command load( names:BAT[void,str], seps:BAT[void,str], types:BAT[void,str],
	datafile:str, nr:int ) : BAT[str,bat] = ascii_io_load
comment "Load a bat using specific format.";

command dump(names:BAT[void,str], seps:BAT[void,str], bats:BAT[void,bat],
	datafile:str, nr:int) = ascii_io_dump 
comment "Dump the bat in ascii format";

command output(order:BAT[any,any], seps:BAT[void,str], bats:BAT[void,bat],
	s:stream) = ascii_io_output 
comment "Send the bat to an output stream.";
@-
The remainder should be compiled into a mal procedure to be loaded
from the shared includes.
@mil
proc load_format( str fmt ) : BAT[str,BAT] := {
	var names := new(void,str); names.seqbase(oid(0));
	var seps := new(void,str); seps.seqbase(oid(0));
	var types := new(void,str); types.seqbase(oid(0));
	names.insert(nil,"names");seps.insert(nil,",");types.insert(nil,"str");
	names.insert(nil,"seps");seps.insert(nil,",");types.insert(nil,"str");
	names.insert(nil,"types");seps.insert(nil,"\n");types.insert(nil,"str");
	return load(names, seps, types, fmt, 1000);
}

proc load_data( BAT[str,BAT] fmt, str data, int nr ) : BAT[str,BAT] := {
	var names := fmt.find("names");
	var seps := fmt.find("seps");
	var types := fmt.find("types");
	return load(names, seps, types, data, nr);
}

proc make_persistent( BAT[str,BAT] bats ) := {
	if (bats.exist("key")){
		var keybat := bats.find("key");
		var nbats := bats.diff(bats.reverse.select("key").reverse);
		nbats@batloop(){
			var b := keybat.reverse().join($t);
			b.rename($h);
			b.persists(true);
		}
	} else {
		bats@batloop(){
			$t.rename($h);
			$t.persists(true);
		}
	}
}

proc merge_data( BAT[str,BAT] bats ) := {
	if (bats.exist("key")){
		var keybat := bats.find("key");
		var nbats := bats.diff(bats.reverse.select("key").reverse);
		nbats@batloop(){
			var b := keybat.reverse().join($t);
			var o := bat($h);
			o.insert(b);
		}
	} else {
		bats@batloop(){
			var o := bat($h);
			o.insert($t);
		}
	}
}

proc dump_seps( BAT[void,BAT] bats ) : BAT[void,str] := {
	var seps := new(void,str); seps.seqbase(oid(0));
	var id := 0;
	var cnt := bats.count - 1;
	bats@batloop(){
		if (id != cnt) {
			seps.insert(nil,",");
		} else {
			seps.insert(nil,"\n");
		}
		id += 1;
	}
	return seps;
}

proc bat_ttype( bat b ) : str := {
	return monet_atomtbl.reverse.find(b.ttype);
}

proc dump_format( BAT[void,BAT] bats, str fmt ) : BAT[str,BAT] := {
	bats := [~bats].seqbase(oid(0));
	var names := [bbpname](bats);
	var seps  := dump_seps(bats);
	var types := [bat_ttype](bats);
	var fmtbats:= new(void,bat); fmtbats.seqbase(oid(0));
	fmtbats.insert(nil,names);
	fmtbats.insert(nil,seps);
	fmtbats.insert(nil,types);

	names := new(void,str); names.seqbase(oid(0));
	seps := new(void,str); seps.seqbase(oid(0));
	names.insert(nil,"names");seps.insert(nil,",");
	names.insert(nil,"seps");seps.insert(nil,",");
	names.insert(nil,"types");seps.insert(nil,"\n");
	dump(names, seps, fmtbats, fmt, 1000);
	names.insert(nil,"bats"); 
	fmtbats.insert(nil,bats);
	return names.reverse.join(fmtbats);
}

proc dump_data( BAT[str,BAT] fmt, str data, int cnt) := {
	var names := fmt.find("names");
	var seps := fmt.find("seps");
	var bats;
	if (fmt.exist("bats")){
		bats := fmt.find("bats");
	} else {
		bats := [load](names);
	}
	dump( names, seps, bats, data, cnt );
}

# todo add function to create a key (oid sequence) colom
@h
/*
 * The contents of this file are subject to the Monet Public
 * License Version 1.1 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy of
 * the License at 
 * http://www.monetsolutions.com/Download/Licensing/MonetPL-1.1.html
 * 
 * Software distributed under the License is distributed on an "AS
 * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 * 
 * The Original Code is the Monet Database System.
 * 
 * The Initial Developer of the Original Code is CWI.
 * Portions created by CWI are Copyright (C) 1997-2002 CWI.  
 * All Rights Reserved.
 * 
 * Contributor(s): Martin Kersten <Martin.Kersten@cwi.nl>
 *		   Peter Boncz <Peter.Boncz@cwi.nl>
 *		   Niels Nes <Niels.Nes@cwi.nl>
 *		   Stefan Manegold  <Stefan.Manegold@cwi.nl>
 */

#ifndef _ASCII_IO2_H_
#define _ASCII_IO2_H_

#include <streams.h>
#include <ascii_io.proto.h>

extern BAT *ASCIIload( BAT *names, BAT *seps, BAT *types, char *datafile, int nr );
extern void ASCIIdump( BAT *names, BAT *seps, BAT *bats, char *datafile, int nr );

#endif
@c

#include <gdk.h>
#include "ascii_io.h"

#include <string.h>
#include <ctype.h>

typedef struct ascii_io_t {
	char* name;
	char* sep;
	int   seplen;
	char* type;
	int   adt;
	BAT*  c;
	BUN   p;
} ascii_io;

typedef struct ascii_load_t {
	int nr;
	int nr_attrs;
	ascii_io *format;
} ascii;

static int ascii_io_debug = 0;

ptr bun_tail(BAT *b, int nr){
	REGISTER int _i = BUNindex((b),BUNfirst((b)));
	return (ptr)BUNtail(b, BUNptr(b,_i+nr));
}


BAT *void_bat_create(int adt, int nr) {
	BAT *b = BATnew(TYPE_void,adt,nr);
	BATseqbase(b,0);
	return b;
}

static
ptr *ADT_fromStr( int type, char *s){
        int l = 0;
        ptr *res = NULL;
        if (type == TYPE_str)
                res = (ptr*)GDKstrdup(s);
        else
                BATatoms[type].atomFromStr(s, &l, (ptr)&res);
        return res;
}

static
int ADT_toStr( char **buf, int *len, int type, ptr a){
        return (int)BATatoms[type].atomToStr( buf, len, a);
}

static char *sep_dup( char *sep ){
	int len = strlen(sep);
	char *res = GDKmalloc(len+1), *result = res;
	char *end = sep+len;

	while(sep < end){
		if (*sep == '\\'){
			++sep;
			switch(*sep++){
			case 'r': *res++ = '\r'; break;
			case 'n': *res++ = '\n'; break;
			case 't': *res++ = '\t'; break;
			}
		} else {
			*res++ = *sep++; 
		}
	}
	*res = '\0';
	return result;
}

static
int create_loadformat( ascii *as, BAT *names, BAT *seps, BAT *types ){
	int p;
	int nr_attrs = BATcount(names);
	ascii_io *fmt = as->format =  
		(ascii_io*)GDKmalloc(sizeof(ascii_io) * (nr_attrs + 1) );

	as->nr_attrs = nr_attrs;
	for (p=0; p<as->nr_attrs; p++){
		fmt[p].name = (char*)bun_tail(names, p);
		fmt[p].sep = sep_dup((char*)bun_tail(seps, p));
		fmt[p].seplen = strlen( fmt[p].sep );
		fmt[p].type = (char*)bun_tail(types, p);
		fmt[p].adt = ATOMindex( fmt[p].type );
		if (ascii_io_debug)
			printf("%s\n", fmt[p].name );
	}
	return as->nr_attrs;
}

static
int create_dumpformat( ascii *as, BAT *names, BAT *seps, BAT *bats ){
	int p;
	int nr_attrs = BATcount(bats);
	ascii_io *fmt = as->format =  
		(ascii_io*)GDKmalloc(sizeof(ascii_io) * (nr_attrs + 1) );

	as->nr_attrs = nr_attrs;
	for (p=0; p<as->nr_attrs; p++){
		BAT *b = (BAT*)BATdescriptor(*(bat*)bun_tail(bats, p));
		fmt[p].name = NULL;
		if (names)
			fmt[p].name = (char*)bun_tail(names, p);
		fmt[p].sep = sep_dup((char*)bun_tail(seps, p));
		fmt[p].seplen = strlen( fmt[p].sep );
		fmt[p].type = ATOMname(b->ttype);
		fmt[p].adt = (b)->ttype;
	}
	return as->nr_attrs;
}

static
void destroy_format( ascii *as ){
	int p;
	ascii_io *fmt = as->format;

	for (p=0; p<as->nr_attrs; p++){
		GDKfree( fmt[p].sep );
	}
	GDKfree(fmt);
}

static
int assign_BATs( ascii *as, BAT *bats ){
	ascii_io *fmt = as->format;
	int res = as->nr;
	int i;
	for (i=0; i<as->nr_attrs; i++){
		BAT *b = (BAT*)BATdescriptor(*(bat*)bun_tail(bats, i));
		fmt[i].c = (b);
		if (res == -1 || BATcount(fmt[i].c)<res)
			res = BATcount(fmt[i].c);
	}
	as->nr = res;
	return res;
}

static
int check_BATs( ascii *as ){
	ascii_io *fmt = as->format;
	int i;
	int cnt = BATcount(fmt[0].c);
	oid base = fmt[0].c->hseqbase;

	if (!BAThdense(fmt[0].c)) return -1;

	for (i=0; i<as->nr_attrs; i++){
		BAT *b = fmt[i].c;
		if (BATcount(fmt[i].c) != cnt ||
		    fmt[i].c->hseqbase != base)
			return -1;

		fmt[i].p = (ptr)BUNfirst(fmt[i].c);
	}
	return base;
}

static
int create_bats( ascii *as ){
	ascii_io *fmt = as->format;
	int i;

	for (i=0; i<as->nr_attrs; i++){
		fmt[i].c = void_bat_create(fmt[i].adt,as->nr);
	}
	return 0;
}

static
BAT *collect_bats( ascii *as ){
	BAT *bats = BATnew(TYPE_str,TYPE_bat,as->nr_attrs);
	ascii_io *fmt = as->format;
	int i;

	for (i=0; i<as->nr_attrs; i++){
		BUNins(bats,(ptr)fmt[i].name, (ptr)&fmt[i].c->batCacheid);
		BBPunfix( fmt[i].c->batCacheid );
	}
	return bats;
}

static INLINE
int myisspace(int s ){
        if (s==(int)' ' || s==(int)'\t' || s==(int)'\n'){
                return 1;
        }
        return 0;
}

static INLINE
char *strip( char *s, char *e ){
        while(myisspace((int)*s)){
		s++;
	}
	e--;
        while(myisspace((int)*e)){
		e--;
	}
	e++;
	if (e && *e){
		*e = 0;
	}
	return s;
}

static INLINE
void insert_val( ascii_io *fmt, char *s, char *e ){
	ptr *adt;
	adt = ADT_fromStr( fmt->adt, strip(s,e) ); 
	BUNins(fmt->c,&int_nil,adt);
	GDKfree(adt);
}

static INLINE
int insert_line( ascii *as, char *line ){
	ascii_io *fmt = as->format;
        char *s,*e = 0;
	int i,quotes = 0;
	for( i = 0; i<as->nr_attrs-1; i++){
		s=line;
		while(*line){
			if (*line == *(fmt[i].sep) && 
			     strncmp( fmt[i].sep, line, fmt[i].seplen) == 0 ){
				e = line; /*strstr( line, fmt[i].sep ); */
				break;
		     	} else if(*line == '\"' && *(line-1) != '\\'){
				quotes = 1;
				line++;
				while( *line && *line!='\"') line++;
				if (*line) line++;
				else return -1;
			} else {
				line++;
			}
		}
		if (e){
			char *end = e;
			if (quotes){
				quotes = 0;
				s = strchr(s, '\"');
				if (!s) return -1;
				s++;
				e = strchr(s, '\"');
			}
			*e = 0;
			insert_val( &fmt[i], s, e );
			line = end + fmt[i].seplen;
		} else {
		        GDKerror("Error: missing sep %s line %d field %d\n", fmt->sep, BATcount(fmt->c), i);
			return -1;
		}
		e = 0;
	}
	s=line;
	while(*line){
		if (*line == *(fmt[as->nr_attrs-1].sep) && 
		     strncmp( fmt[as->nr_attrs-1].sep, line, 
			      fmt[as->nr_attrs-1].seplen) == 0 ){
			e = line; /*strstr( line, fmt[as->nr_attrs-1].sep ); */
			break;
		} else if(*line == '\"' && *(line-1) != '\\'){
			quotes = 1;
			line++;
			while( *line && *line!='\"') line++;
			if (*line) line++;
			else return -1;
		} else {
			line++;
		}
	}
	if (!e) e = line;
	if (e){
		char *end = e;
		if (quotes){
			quotes = 0;
			s = strchr(s, '\"');
			if (!s) return -1;
			s++;
			e = strchr(s, '\"');
		}
		*e = 0;
		insert_val( &fmt[as->nr_attrs-1], s, e );
		line = end + fmt[as->nr_attrs-1].seplen;
	}
	e = 0;
	return 0;
}

static INLINE
int dump_line( char **buf, int *len, ascii_io *fmt, stream *fd, int nr_attrs, int id ){
	int i;
	for( i = 0; i<nr_attrs; i++){
		int l =
		 ADT_toStr(buf, len, fmt[i].adt, (char*)bun_tail(fmt[i].c,id));
		(void)fd->write( fd, *buf, 1, l );
		(void)fd->write( fd, fmt[i].sep, 1, fmt[i].seplen );
	}
	return 0;
}

static INLINE
int output_line( char **buf, int *len, ascii_io *fmt, stream *fd, int nr_attrs, ptr id ){
	int i;
	for( i = 0; i<nr_attrs; i++){
		fmt[i].p = BUNfnd( fmt[i].c, id );
		if (fmt[i].p == 0)
			break;
	}
	if ( i == nr_attrs ){
	    for( i = 0; i<nr_attrs; i++){
		if (fmt[i].adt == TYPE_str){
			char *s = (char*)BUNtail(fmt[i].c, fmt[i].p);
			int l = strlen(s);
			(void)fd->write( fd, "\"", 1, 1 );
			(void)fd->write( fd, s, 1, l );
			(void)fd->write( fd, "\"", 1, 1 );
		} else {
			int l = ADT_toStr(buf, len, fmt[i].adt, 
			(char*)BUNtail(fmt[i].c,fmt[i].p));
			(void)fd->write( fd, *buf, 1, l );
		}
		(void)fd->write( fd, fmt[i].sep, 1, fmt[i].seplen );
	    }
	}
	return 0;
}

static INLINE
int output_line_dense( char **buf, int *len, ascii_io *fmt, stream *fd, int nr_attrs ){
	int i;
	for( i = 0; i<nr_attrs; i++){
		char *p = BUNtail(fmt[i].c, fmt[i].p);
		if (fmt[i].adt == TYPE_str){
			int l = strlen(p);
			(void)fd->write( fd, "\"", 1, 1 );
			(void)fd->write( fd, p, 1, l );
			(void)fd->write( fd, "\"", 1, 1 );
		} else {
			int l = ADT_toStr(buf, len, fmt[i].adt, p);
			(void)fd->write( fd, *buf, 1, l );
		}
		(void)fd->write( fd, fmt[i].sep, 1, fmt[i].seplen );
		fmt[i].p = BUNnext( fmt[i].c, fmt[i].p );
	}
	return 0;
}

static INLINE
int output_line_lookup( char **buf, int *len, ascii_io *fmt, stream *fd, int nr_attrs, int id ){
	int i;
	for( i = 0; i<nr_attrs; i++){
		char *p = BUNtail(fmt[i].c, BUNptr(fmt[i].c,id+BUNindex(fmt[i].c,BUNfirst(fmt[i].c))));
		if (fmt[i].adt == TYPE_str){
			char *s = (char*)p;
			int l = strlen(s);
			(void)fd->write( fd, "\"", 1, 1 );
			(void)fd->write( fd, s, 1, l );
			(void)fd->write( fd, "\"", 1, 1 );
		} else {
			int l = ADT_toStr(buf, len, fmt[i].adt, p);
			(void)fd->write( fd, *buf, 1, l );
		}
		(void)fd->write( fd, fmt[i].sep, 1, fmt[i].seplen );
	}
	return 0;
}


#define SIZE 1*1024*1024
static
int load_file( ascii *as, stream *fd ){
	int eof = 0, p = 0, done = 0, bufsz = SIZE;
	char *buf = GDKmalloc(bufsz+1);
	char *s = buf,*sep = as->format[as->nr_attrs-1].sep;
        int i = 0, seplen = as->format[as->nr_attrs-1].seplen;

	if (ascii_io_debug)
		fprintf( GDKerr, "load_file\n");

	while(!eof && (as->nr < 0|| i < as->nr)){
		int l, size = bufsz-p;
		char *end;
		if ((l=fd->read(fd, buf+p, 1, size )) < size )
			eof = 1;
		end = s + p + l;
		*end = '\0';
		p = l = 0;
		done = 0;
		while( s < end ){
			char *e = strstr( s, sep );
			if (e){
				*e = '\0';
				insert_line(as, s );	
				s = e + seplen;
				done = 1;
			} else if (eof && s + as->nr_attrs < end){
				insert_line(as, s );	
				s = end;
			} else {
				if (!done){ /* nothing found in current buf
					     * ie. need to enlarge 
					     */
					buf = GDKrealloc(buf, (bufsz*=16) +1);
				}
				p = end - s;
				memcpy(buf, s, p );
				break;
			}
			i++;
			if (ascii_io_debug && (i%100000) == 0)
				fprintf(GDKerr, "inserted %d\n", i);
			if (as->nr > 0 && i >= as->nr)
				break;
		}
		s = buf;
	}
	GDKfree(buf);
	as->nr = i;
	return 0;
}

static
int dump_file( ascii *as, stream *fd ){
        int i = 0;
	int len = BUFSIZ;
	char *buf = GDKmalloc(len);
	for( i=0; i<as->nr; i++ ){
		if (dump_line( &buf, &len, as->format, fd, as->nr_attrs, i )<0){
			GDKfree(buf);
			return -1;
		}
		if (ascii_io_debug && (i%1000000) == 0)
			fprintf(GDKerr, "dumped %d lines\n", i);
        } 
	GDKfree(buf);
	return 0;
}

static
int output_file( ascii *as, BAT *order, stream *fd ){
	int len = BUFSIZ; 
	char *buf = GDKmalloc(len);
	BUN p,q;
        int i = 0;
	as->nr = BATcount(order);
	
	BATloop( order, p, q){
		ptr h = BUNhead(order, p);
		if(output_line( &buf, &len,as->format, fd, as->nr_attrs, h )<0){
			GDKfree(buf);
			return -1;
		}
		i++;
		if (ascii_io_debug && (i%1000000) == 0)
			fprintf(stderr, "dumped %d lines\n", i);
        } 
	GDKfree(buf);
	return i;
}

static
int output_file_dense( ascii *as, stream *fd ){
	int len = BUFSIZ; 
	char *buf = GDKmalloc(len);
	BUN p,q;
        int i = 0;
	
	for(i=0; i<as->nr; i++){
		if(output_line_dense( &buf, &len, as->format, fd, as->nr_attrs )<0){
			GDKfree(buf);
			return -1;
		}
		if (ascii_io_debug && (i%1000000) == 0)
			fprintf(stderr, "dumped %d lines\n", i);
        } 
	GDKfree(buf);
	return i;
}

static
int output_file_ordered( ascii *as, BAT *order, stream *fd, int base ){
	int len = BUFSIZ; 
	char *buf = GDKmalloc(len);
	BUN p,q;
        int i = 0;
	
	BATloop( order, p, q){
		oid h = *(oid*)BUNhead(order, p) - base;
		if(output_line_lookup( &buf, &len, as->format, fd, as->nr_attrs, h )<0){
			GDKfree(buf);
			return -1;
		}
		if (ascii_io_debug && (i%1000000) == 0)
			fprintf(stderr, "dumped %d lines\n", i);
        } 
	GDKfree(buf);
	return i;
}


BAT *ASCIIload( BAT *names, BAT *seps, BAT *types, 
		 char *datafile, int nr ){
	BAT *bats = NULL;
	ascii as;

	as.nr_attrs = 0;
	as.nr = nr;
	if (create_loadformat( &as, names, seps, types) >= 0 && 
	    create_bats( &as ) >= 0){
		stream *s = open_rastream( datafile );
		if (!s->errnr && load_file( &as, s )>=0)
			bats = collect_bats( &as );
		if (s->errnr){
		 	GDKerror("could not open file %s\n", datafile );
		} else {
			s->close(s);
		}
		s->destroy(s);
	}
	destroy_format( &as );
	return bats;
}

void ASCIIdump( BAT *names, BAT *seps, BAT *bats, 
	      char *datafile, int nr ){
	ascii as;

	as.nr_attrs = 0;
	as.nr = nr;
	if (create_dumpformat( &as, names, seps, bats) >= 0 && 
	    assign_BATs( &as, bats ) >=  0){
		stream *s = open_wastream( datafile );
		if (!s->errnr && dump_file( &as, s ) >= 0){
			fprintf(GDKerr, "saved in %s\n", datafile );
		}
		if (s->errnr){
		 	GDKerror("could not open file %s\n", datafile );
		} else {
			s->close(s);
		}
		s->destroy(s);
	}
	destroy_format( &as );
}
int ASCIIoutput( BAT *order, BAT *seps, BAT *bats, stream *s ){
	ascii as;
	int base = -1;

	as.nr_attrs = 0;
	as.nr = -1;
	if (create_dumpformat( &as, NULL, seps, bats) >= 0 && 
	    assign_BATs( &as, bats ) >=  0){
		if ((base = check_BATs( &as )) >= 0 ){
			if (BAThdense(order) && 
 			    order->hseqbase == base && BATcount(order) == as.nr)
				output_file_dense( &as, s );
			else
				output_file_ordered( &as, order, s, base );
		} else {
			output_file( &as, order, s ); 
		}
	}
	destroy_format( &as );
	return as.nr;
}

int init_ascii_io(int *debug){
	ascii_io_debug = *debug;
	return GDK_SUCCEED;
}
int ascii_io_load( BAT **bats, BAT *names, BAT* seps, BAT* types, str datafile, int *nr){
	*bats = ASCIIload( names, seps, types, datafile, *nr );
	if (*bats) {
		return GDK_SUCCEED;
	} else {
		return GDK_FAIL;
	}
}
int ascii_io_dump( BAT *names, BAT* seps, BAT* bats, str datafile, int *nr){
	ASCIIdump( names, seps, bats, datafile, *nr );
	return GDK_SUCCEED;
}
int ascii_io_output( BAT *order, BAT* seps, BAT* bats, stream *s ){
	ASCIIoutput( order, seps, bats, *(stream**)s );
	return GDK_SUCCEED;
}

@mil
module(ascii_io,io);

#ascii_io_debug(1);

fp := fopen ( "format", "w+" );
fputs( "key,\",\",str\n", fp);
fputs( "a_io_test,\"\\n\",dbl\n", fp);
fclose( fp );

fp := fopen ( "data", "w+" );
fputs( "test, 0.12345\n", fp);
fputs( "second line, 9.0\n", fp);
fclose( fp );

bats := load("format","data",10);
bats := load_data(load_format(path+"/format"), path+"/test100k", 100000);
bats.print;
a := bats.find("key").reverse().join( bats.find("a_io_test") );
a.print;
dump_data(load_format("format"), "data", -1);

fp := fopen ( "data", "r" );
s := fgets( fp ); 
s.print();
fclose( fp );
quit;
