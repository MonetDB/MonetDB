@f calib
@t Calibrator for Monet
@a mzu
@v 0.1
@* Calibrator for Monet
Calibrator as a Monet module

@m
.MODULE calib;

@- Section
@m
.COMMAND calib_info() : BAT[str,dbl] = CMDcalib_info;
  "Gives results of calibrator tests as BAT. 
  First row 'ready' indicates if the tests have been performed "
.COMMAND calib_init(lng MHz, lng maxrange) : void = CMDcalib_init;
  "Runs calibrator tests with given CPU clock frequency and max memory range"
.COMMAND calib_free() : void = CMDcalib_free;
  "Frees calibrator allocated resources"
.END calib;

@c
#include "monet.h"
#include <gdk.h>
#include    <stdlib.h>
#include	<stdio.h>
#include	<math.h>
#include	<string.h>
#include	<stdarg.h>


#define NUMLOADS 100000
#define REDUCE	 10
#define	NUMTRIES 3
#define	MINRANGE 1024
#define MAXLEVELS 9
#define LENPLATEAU 3

	#define EPSILON1 0.1	
/*	#define EPSILON3 2.0	*/

/*	#define EPSILON2 0.04	*/
	#define EPSILON4 1.0	


/* #define CALIBRATOR_CREATE_PLOTS */
#undef CALIBRATOR_CREATE_PLOTS
/* #define CALIBRATOR_PRINT_OUTPUT */
#undef CALIBRATOR_PRINT_OUTPUT

#include "calib_common.c"
caliblng MINTIME = 10000;
#include "calib_run.c"
#include "calib_analyse.c"
/* #include "calib_plot.c" */
/* #include "calib_print.c" */
#include "calib_main.c"

struct fullInfo *calibInfo=0;
caliblng MHz,maxrange;

int CMDcalib_init(lng *setMHz, lng *setmaxrange)
{
	MHz=*setMHz;
	maxrange=*setmaxrange;
	if (calibInfo)
		freeFullInfo(calibInfo);
	calibInfo = mainRun(MHz, maxrange*1.25, "nofile");
	return GDK_SUCCEED;
}

int CMDcalib_info(BAT **retval)
{
	BAT *b;
	char fld[100];
	double val;
	int l;
	cacheInfo *cache;
	AssoInfo *Asso;
	TLBinfo *TLB;
	
	*retval = b = BATnew(TYPE_str, TYPE_dbl, 32);
	if (!b) return GDK_FAIL;
	val=(calibInfo!=0);
	b=BUNins(b, "ready", &val);

	if(!calibInfo)
		return GDK_SUCCEED;
	cache=calibInfo->cache;
	Asso=calibInfo->Asso;
	TLB=calibInfo->TLB;
	
	val=MHz;
	b=BUNins(b, "MHz", &val);
	val=maxrange;
	b=BUNins(b, "maxrange", &val);
/* cpu info */
	val=NSperIt(calibInfo->cache->latency1[0]);
	b=BUNins(b, "cpuloop ns", &val);
	val=round(CYperIt(calibInfo->cache->latency1[0]));
	b=BUNins(b, "cpuloop cc", &val);
	val=NSperIt(calibInfo->delayC);
	b=BUNins(b, "cpu delay ns", &val);
	val=round(CYperIt(calibInfo->delayC));
	b=BUNins(b, "cpu delay cc", &val);
/* cache info */
	val=cache->levels;
	b=BUNins(b, "cache levels", &val);
	for(l=0;l<cache->levels;l++)
	{
		sprintf(fld, "cache %d size", l+1);
		val=cache->size[l];
		b=BUNins(b, fld, &val);
		sprintf(fld, "cache %d linesize", l+1);
		val=cache->linesize[l+1];
		b=BUNins(b, fld, &val);
		sprintf(fld, "cache %d associativity", l+1);
		val=Asso->entries[l];
		b=BUNins(b, fld, &val);
		sprintf(fld, "cache %d miss-latency ns", l+1);
		val=NSperIt(cache->latency2[l+1] - cache->latency2[l]);
		b=BUNins(b, fld, &val);
		sprintf(fld, "cache %d miss-latency cc", l+1);
		val=round(CYperIt(cache->latency2[l+1] - cache->latency2[l]));
		b=BUNins(b, fld, &val);
		sprintf(fld, "cache %d replace-time ns", l+1);
		val=NSperIt(cache->latency1[l+1] - cache->latency1[l]);
		b=BUNins(b, fld, &val);
		sprintf(fld, "cache %d replace-time cc", l+1);
		val=round(CYperIt(cache->latency1[l+1] - cache->latency1[l]));
		b=BUNins(b, fld, &val);
	}
/* TLB info */
	val=TLB->levels;
	b=BUNins(b, "TLB levels", &val);
	for(l=0;l<TLB->levels;l++)
	{
		sprintf(fld, "TLB %d entries", l+1);
		val=TLB->entries[l];
		b=BUNins(b, fld, &val);
		sprintf(fld, "TLB %d pagesize", l+1);
		val=TLB->pagesize[l+1];
		b=BUNins(b, fld, &val);
		sprintf(fld, "TLB %d miss-latency ns");
		val=NSperIt(TLB->latency2[l+1] - TLB->latency2[l]);
		b=BUNins(b, fld, &val);
		sprintf(fld, "TLB %d miss-latency cc");
		val=round(CYperIt(TLB->latency2[l+1] - TLB->latency2[l]));
		b=BUNins(b, fld, &val);
	}
	return GDK_SUCCEED;
}


int CMDcalib_free()
{
	if (!calibInfo) 
		return GDK_FAIL;
	freeFullInfo(calibInfo);
	calibInfo=0;
	return GDK_SUCCEED;
}
