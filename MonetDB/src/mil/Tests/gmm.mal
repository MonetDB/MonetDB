# Mil compiler Version 1.0)
# Copyright (c) 1993-2001, CWI. All rights reserved.

# Predefined code segment
##CHANGES TO ORIGINAL:
## seqbase -> setSequenceBase	(**)
## persists(FALSE) -> setTransient
## persists(TRUE) -> setPersistent
## (**) the return value is not necessarily a BAT id anymore.
##line 23 "../../../src/gmm/gmm.mx"
use "kernel/io";
use "kernel/alarm";
use "kernel/lock";
use "kernel/mmath";
use "kernel/xtables";
#  module(io,alarm,lock,mmath,xtables);
	Nthreads := 4;
#  CONST Nthreads  := 4;
	aa_a := newoid();
	ba_a := int(aa_a);
	sessionId := +("S",ba_a);
#  CONST sessionId := "S" + int(newoid());
#  VAR   randomseed;
	randomseed := 40;
#randomseed := 40;
	ca_a := mem_maxsize(1000000000LL);
#mem_maxsize(1000000000LL);
	da_a := vm_maxsize(2000000000LL);
#vm_maxsize( 2000000000LL);
function init_modgmm():void;
#  PROC init_modgmm():void := { 
	curthreads:= threadcnt(0);
#    VAR curthreads := threadcnt(0);
	ea_a := +(Nthreads,1);
barrier	fa_a:= <(curthreads,ea_a);
#    IF (curthreads < (Nthreads + 1)) 
	ga_a := -(Nthreads,curthreads);
	ha_a := +(ga_a,1);
	ia_a := threadcnt(ha_a);
#	threadcnt( (Nthreads - curthreads) + 1 );
end	fa_a;
barrier	ja_a:= isnil(randomseed);
	randomseed := time();
#    IF (isnil(randomseed)) randomseed := time();
end	ja_a;
	ka_a := srand(randomseed);
#    srand(randomseed);
end function;
#  }
	la_a := init_modgmm();
#  init_modgmm();
#
	GMMdebuglog:= fopen("/ufs/arjen/tmp/GMM.log","a");
#  VAR GMMdebuglog := fopen("/ufs/arjen/tmp/GMM.log", "a");
function debug(msg:str,msg:any[]):void;
#  PROC debug( str msg, ..any.. ):void := {
	ma_a := +(msg," @ %s\n");
	na_a := +("GMM: ",ma_a);
	oa_a := mil.getVarTempRange(2);
	pa_a := ctime();
	qa_a := trim(pa_a);
	ra_a := fprintf(GMMdebuglog,na_a,oa_a,qa_a);
#    fprintf( GMMdebuglog, "GMM: " + msg + " @ %s\n", $(2..), trim( ctime() ) );
	sa_a := fflush(GMMdebuglog);
#    fflush( GMMdebuglog );
end function;
#  }
	sessionId:= take("sessionId");
	ta_a := debug("Starting gmm.mil session %s",sessionId);
#  debug("Starting gmm.mil session %s", sessionId);
#
function _x(x:bat[any,any::1]):bat[void,any::1];
	ua_a := reverse(x);
	va_a := mark(ua_a,nil);
	wa_a := reverse(va_a);
	return wa_a;
end function;
#  PROC _x(BAT[any,any::1] x):BAT[void,any::1] := {RETURN x.reverse.mark(nil).reverse;}
function nx(x:bat[any,any::1]):bat[void,any::1];
	xa_a := oid(0);
	ya_a := reverse(x);
	ab_a := mark(ya_a,xa_a);
	bb_a := reverse(ab_a);
	return bb_a;
end function;
#  PROC nx(BAT[any,any::1] x):BAT[void,any::1] := {RETURN x.reverse.mark(oid(0)).reverse;}
function x_(x:bat[any::1,any]):bat[any::1,void];
	cb_a := mark(x,nil);
	return cb_a;
end function;
#  PROC x_(BAT[any::1,any] x):BAT[any::1,void] := {RETURN x.mark(nil);}
function xn(x:bat[any::1,any]):bat[any::1,void];
	db_a := oid(0);
	eb_a := mark(x,db_a);
	return eb_a;
end function;
#  PROC xn(BAT[any::1,any] x):BAT[any::1,void] := {RETURN x.mark(oid(0));}
function Nseq(N:int):bat[void,int];
#  PROC Nseq(int N):BAT[void,int] := {
	i:= 0;
	seq:= new(void,int);
#    VAR i := 0; VAR seq := new(void,int);
	fb_a := oid(0);
	gb_a := setSequenceBase(seq,fb_a);
#    seq.setSequenceBase(oid(0));
barrier	hb_a:= true;
	jb_a := <(i,N);
barrier	ib_a:= jb_a;
	kb_a := insert(seq,nil,i);
	lb_a := :+=(i,1);
redo	hb_a;
end	ib_a;
end	hb_a;
#    WHILE (i<N) { seq.insert(nil,i); i:+=1; }
	return seq;
#    RETURN seq;
end function;
#  }
function randseq(N:int):bat[void,int];
#  PROC randseq(int N):BAT[void,int] := {
	i:= 0;
	seq:= new(void,int);
#    VAR i := 0; VAR seq := new(void,int);
	mb_a := oid(0);
	nb_a := setSequenceBase(seq,mb_a);
#    seq.setSequenceBase(oid(0));
barrier	ob_a:= true;
	qb_a := <(i,N);
barrier	pb_a:= qb_a;
	rb_a := rand();
	sb_a := insert(seq,nil,rb_a);
	tb_a := :+=(i,1);
redo	ob_a;
end	pb_a;
end	ob_a;
#    WHILE (i<N) { seq.insert(nil,rand()); i:+=1; }
	return seq;
#    RETURN seq;
end function;
#  }
#
#  # casting bats of bats should have worked with [dbl] but doesn't -- BUG!
function conv2sht(b:bat[any::1,any]):bat[any::1,sht];
	ub_a := multiplex.sht(b);
	return ub_a;
end function;
#  PROC conv2sht(BAT[any::1,any] b):BAT[any::1,sht] := {RETURN [sht](b);}
function conv2flt(b:bat[any::1,any]):bat[any::1,flt];
	vb_a := multiplex.flt(b);
	return vb_a;
end function;
#  PROC conv2flt(BAT[any::1,any] b):BAT[any::1,flt] := {RETURN [flt](b);}
function conv2dbl(b:bat[any::1,any]):bat[any::1,dbl];
	wb_a := multiplex.dbl(b);
	return wb_a;
end function;
#  PROC conv2dbl(BAT[any::1,any] b):BAT[any::1,dbl] := {RETURN [dbl](b);}
#
function sqrt(x:flt):dbl;
	xb_a := dbl(x);
	yb_a := sqrt(xb_a);
	return yb_a;
end function;
#  PROC sqrt(flt x):dbl := {RETURN sqrt(dbl(x));}
function sqrt_multiplex(x:bat[any::1,flt]):bat[any::1,dbl];
	ac_a := multiplex.dbl(x);
	bc_a := multiplex.sqrt(ac_a);
	return bc_a;
end function;
#  PROC [sqrt](BAT[any::1,flt] x):BAT[any::1,dbl] := {RETURN [sqrt]([dbl](x));}
function log(x:flt):dbl;
	cc_a := dbl(x);
	dc_a := log(cc_a);
	return dc_a;
end function;
#  PROC log(flt x):dbl := {RETURN log(dbl(x));}
function log_multiplex(x:bat[any::1,flt]):bat[any::1,dbl];
	ec_a := multiplex.dbl(x);
	fc_a := multiplex.log(ec_a);
	return fc_a;
end function;
#  PROC [log](BAT[any::1,flt] x):BAT[any::1,dbl] := {RETURN [log]([dbl](x));}
#
#
##line 77 "../../../src/gmm/gmm.mx"
#  # circumvent parsing problems with [[op]](bat[bat],bat[bat])
function nestedop(op:str, x:bat[any::1,any], y:bat[any::1,any]):bat[any::1,any];
#  PROC nestedop(str op, bat[any::1,any] x, bat[any::1,any] y):BAT[any::1,any] := {
	gc_a := mil.multiplex_deref(op,x,y);
	return gc_a;
#    RETURN [* op](x, y); 
end function;
#  }
function nestedop(op:str, x:bat[any::1,any], y:bat[any::1,any], z:any):bat[any::1,any];
#  PROC nestedop(str op, bat[any::1,any] x, bat[any::1,any] y, any z):BAT[any::1,any] := 
#  {
	hc_a := mil.multiplex_deref(op,x,y,z);
	return hc_a;
#    RETURN [* op](x, y, z); 
end function;
#  }
function nestedop(op:str, x:bat[any::1,any::2]):bat[any::1,any::2];
#  PROC nestedop(str op, bat[any::1,any::2] x):BAT[any::1,any::2] := {
	ic_a := mil.multiplex_deref(op,x);
	return ic_a;
#    RETURN [* op](x); 
end function;
#  }
#
function square(x:bat[any::1,any::2]):bat[any::1,any::2];
	jc_a := multiplex.*(x,x);
	return jc_a;
end function;
#  PROC square(bat[any::1,any::2] x):BAT[any::1,any::2] := {RETURN [*](x, x );}
#
#  #  post@batloop{
#  #    VAR p := $t;
#  #    p.access(BAT_WRITE);
#  #    [:/=](p, s);
#  #    p.access(BAT_READ);
#  #  }
#
#
#
##line 392 "../../../src/gmm/gmm.mx"
	N := 8;
#  CONST N := 8;
	C := 8;
#  CONST C := 8;
#
	cseq:= Nseq(C);
#  VAR cseq := Nseq( C );
	nseq:= Nseq(N);
#  VAR nseq := Nseq( N );
#
#
##line 455 "../../../src/gmm/gmm.mx"
##VAR dict := new( str, str );
##dict.rename(sessionId + "dict");
#
#
##line 466 "../../../src/gmm/gmm.mx"
use "kernel/enum";
#  module(enum);
function init_clustertype():int;
#  PROC init_clustertype(): int := {
#    VAR tc;
	kc_a := view_bbp_name();
	lc_a := reverse(kc_a);
barrier	mc_a:= exist(lc_a,"TCluster");
#    IF( view_bbp_name().reverse.exist("TCluster" ) ) {
	tc := enum_load("TCluster");
#      tc := enum_load( "TCluster" );
end	mc_a;
barrier	nc_a:= not(mc_a);
#    } ELSE {
	tc := enum_create("TCluster",cseq);
#      tc := enum_create( "TCluster", cseq );
end	nc_a;
#    }
	return tc;
#    RETURN tc;
end function;
#  }
function destroy_clustertype():void;
#  PROC destroy_clustertype():void := {
	TCluster:= take("TCluster");
	oc_a := enum_drop(TCluster);
#    enum_drop( TCluster );
	pc_a := bat("TCluster");
	qc_a := setTransient(pc_a,);
#    bat("TCluster").setTransient();
end function;
#  }
	TCluster:= init_clustertype();
#  VAR TCluster := init_clustertype();
	cseq:= take("cseq");
	cseq := multiplex.encode(TCluster,cseq);
#  cseq := [encode](TCluster,cseq);
#
#
##line 499 "../../../src/gmm/gmm.mx"
function coeffName(i:int):str;
	rc_a := str(i);
	sc_a := +("Icoeff_",rc_a);
	return sc_a;
end function;
#  PROC coeffName(int i): str := { RETURN "Icoeff_" + str(i); }
function newCollection(cname:str, Nimg:int):bat[str,bat];
#  PROC newCollection( str cname, int Nimg ): BAT[str,bat] := {
	tc_a := new(str,bat);
	res:= rename(tc_a,cname);
#    VAR res := new(str,bat).rename(cname);
	I:= new(void,str,Nimg);
#    VAR I := new( void, str, Nimg );
	uc_a := oid(0);
	vc_a := +(cname,"_I");
	wc_a := setSequenceBase(I,uc_a);
	xc_a := rename(wc_a,vc_a);
#    I.setSequenceBase(oid(0)).rename( cname + "_I" );
	Ib:= new(oid,void,Nimg);
#    VAR Ib := new( oid, void, Nimg );
	Ibr:= reverse(Ib);
#    VAR Ibr:= Ib.reverse;
	yc_a := oid(0);
	ad_a := setSequenceBase(Ibr,yc_a);
#    Ibr.setSequenceBase(oid(0));
	bd_a := +(cname,"_Ib");
	cd_a := rename(Ib,bd_a);
#    Ib.rename( cname + "_Ib" );
	Ix:= new(void,int,Nimg);
#    VAR Ix := new( void, int, Nimg );
	dd_a := oid(0);
	ed_a := setSequenceBase(Ix,dd_a);
#    Ix.setSequenceBase(oid(0));
	fd_a := +(cname,"_Ix");
	gd_a := rename(Ix,fd_a);
#    Ix.rename( cname + "_Ix" );
	Iy:= new(void,int,Nimg);
#    VAR Iy := new( void, int, Nimg );
	hd_a := oid(0);
	id_a := setSequenceBase(Iy,hd_a);
#    Iy.setSequenceBase(oid(0));
	jd_a := +(cname,"_Iy");
	kd_a := rename(Iy,jd_a);
#    Iy.rename( cname + "_Iy" );
	ld_a := insert(res,"I",I);
#    res.insert( "I", I );
	md_a := insert(res,"Ib",Ib);
#    res.insert( "Ib", Ib );
	nd_a := insert(res,"Ix",Ix);
#    res.insert( "Ix", Ix );
	od_a := insert(res,"Iy",Iy);
#    res.insert( "Iy", Iy );
	N:= take("N");
	pd_a := +(cname,"_Icoeffs");
	qd_a := new(int,bat,N);
	coeffs:= rename(qd_a,pd_a);
#    VAR coeffs := new(int,bat,N).rename(cname + "_Icoeffs" );
	i:= 0;
#    VAR i := 0;
barrier	rd_a:= true;
	td_a := <(i,N);
barrier	sd_a:= td_a;
#    WHILE (i < N) {
	x_i:= new(void,sht,Nimg);
#      VAR x_i := new(void,sht,Nimg);
	ud_a := oid(0);
	vd_a := setSequenceBase(x_i,ud_a);
#      x_i.setSequenceBase(oid(0));
	wd_a := coeffName(i);
	xd_a := +("_",wd_a);
	yd_a := +(cname,xd_a);
	ae_a := rename(x_i,yd_a);
#      x_i.rename( cname + "_" + coeffName(i) );
	be_a := insert(coeffs,i,x_i);
#      coeffs.insert( i, x_i );
	x_i := nil;
#      x_i := nil;
	ce_a := :+=(i,1);
#      i :+= 1;
redo	rd_a;
end	sd_a;
end	rd_a;
#    }
	de_a := insert(res,"Coeffs",coeffs);
#    res.insert( "Coeffs", coeffs );
	BAT_READ:= take("BAT_READ");
	ee_a := access(res,BAT_READ);
#    res.access( BAT_READ );
	return res;
#    RETURN res;
end function;
#  }
function newCollection(cname:str):bat[str,bat];
#  PROC newCollection( str cname ): BAT[str,bat] :=
#  {
	fe_a := newCollection(cname,1);
	return fe_a;
#    RETURN newCollection(cname, 1);
end function;
#  }
#
#
##line 546 "../../../src/gmm/gmm.mx"
function paramName(p:str, i:int):str;
#PROC paramName(str p,int i): str := { 
	ge_a := str(i);
	he_a := +("_",ge_a);
	ie_a := +(p,he_a);
	return ie_a;
#  RETURN p + "_" + str(i); 
end function;
#}
function renameGMM(model:bat[str,bat], mname:str):void;
#PROC renameGMM( bat[str,bat] model, str mname ):void := {
	je_a := rename(model,mname);
#  model.rename(mname);
barrier	ke_a:= bunStream(model,ke_aH,ke_aT);
#  model@batloop(){
	le_a := +("_",ke_aH);
	me_a := +(mname,le_a);
	ne_a := rename(ke_aT,me_a);
#    $t.rename(mname + "_" + $h);
redo	ke_a;
end	ke_a;
#  }
	oe_a := find(model,"Mean");
barrier	pe_a:= bunStream(oe_a,pe_aH,pe_aT);
#  model.find("Mean")@batloop(){
	qe_a := str(pe_aH);
	re_a := +("_Mean_",qe_a);
	se_a := +(mname,re_a);
	te_a := rename(pe_aT,se_a);
#    $t.rename(mname + "_Mean_" + str($h));
redo	pe_a;
end	pe_a;
#  }
	ue_a := find(model,"Covar");
barrier	ve_a:= bunStream(ue_a,ve_aH,ve_aT);
#  model.find("Covar")@batloop(){
	we_a := str(ve_aH);
	xe_a := +("_Covar_",we_a);
	ye_a := +(mname,xe_a);
	af_a := rename(ve_aT,ye_a);
#    $t.rename(mname + "_Covar_" + str($h));
redo	ve_a;
end	ve_a;
#  }
end function;
#}
function newGMM(Nimg:int):bat[str,bat];
#PROC newGMM( int Nimg ): BAT[str,bat] := {
	model:= new(str,bat);
#  VAR model := new(str,bat);
	C:= take("C");
	bf_a := *(Nimg,C);
	mImgIdx:= new(oid,void,bf_a);
#  VAR mImgIdx := new(oid,void,Nimg * C);
	cf_a := oid(0);
	df_a := reverse(mImgIdx);
	ef_a := setSequenceBase(df_a,cf_a);
#  mImgIdx.reverse.setSequenceBase(oid(0));
	BAT_APPEND:= take("BAT_APPEND");
	ff_a := access(mImgIdx,BAT_APPEND);
#  mImgIdx.access( BAT_APPEND );
	gf_a := insert(model,"mImgIdx",mImgIdx);
#  model.insert("mImgIdx", mImgIdx);
	TCluster:= take("TCluster");
	hf_a := *(Nimg,C);
	mCIdx:= new(TCluster,void,hf_a);
#  VAR mCIdx := new(TCluster,void,Nimg * C);
	if_a := oid(0);
	jf_a := reverse(mCIdx);
	kf_a := setSequenceBase(jf_a,if_a);
#  mCIdx.reverse.setSequenceBase(oid(0));
	lf_a := access(mCIdx,BAT_APPEND);
#  mCIdx.access( BAT_APPEND );
	mf_a := insert(model,"mCIdx",mCIdx);
#  model.insert("mCIdx", mCIdx);
	nf_a := *(Nimg,C);
	prior:= new(void,flt,nf_a);
#  VAR prior := new(void,flt,Nimg * C);
	of_a := oid(0);
	pf_a := setSequenceBase(prior,of_a);
#  prior.setSequenceBase(oid(0));
	qf_a := access(prior,BAT_APPEND);
#  prior.access( BAT_APPEND );
	rf_a := insert(model,"Prior",prior);
#  model.insert("Prior", prior);
	N:= take("N");
	mean:= new(int,bat,N);
#  VAR mean := new(int,bat,N);
	covar:= new(int,bat,N);
#  VAR covar := new(int,bat,N);
	i:= 0;
#  VAR i := 0;
barrier	sf_a:= true;
	uf_a := <(i,N);
barrier	tf_a:= uf_a;
#  WHILE (i < N) {
	vf_a := *(Nimg,C);
	mean_i:= new(void,flt,vf_a);
#    VAR mean_i := new(void,flt,Nimg*C);
	wf_a := oid(0);
	xf_a := setSequenceBase(mean_i,wf_a);
#    mean_i.setSequenceBase(oid(0));
	yf_a := *(Nimg,C);
	variance_i:= new(void,flt,yf_a);
#    VAR variance_i := new(void,flt,Nimg*C);
	ag_a := oid(0);
	bg_a := setSequenceBase(variance_i,ag_a);
#    variance_i.setSequenceBase(oid(0));
	cg_a := access(mean_i,BAT_APPEND);
#    mean_i.access( BAT_APPEND );
	dg_a := access(variance_i,BAT_APPEND);
#    variance_i.access( BAT_APPEND );
	eg_a := insert(mean,i,mean_i);
#    mean.insert( i, mean_i );
	fg_a := insert(covar,i,variance_i);
#    covar.insert( i, variance_i );
	mean_i := nil;
#    mean_i := nil;
	variance_i := nil;
#    variance_i := nil;
	gg_a := :+=(i,1);
#    i :+= 1;
redo	sf_a;
end	tf_a;
end	sf_a;
#  }
	BAT_READ:= take("BAT_READ");
	hg_a := access(mean,BAT_READ);
#  mean.access( BAT_READ );
	ig_a := access(covar,BAT_READ);
#  covar.access( BAT_READ );
	jg_a := insert(model,"Mean",mean);
#  model.insert( "Mean", mean );
	kg_a := insert(model,"Covar",covar);
#  model.insert( "Covar", covar );
	lg_a := *(Nimg,C);
	init_variances:= new(void,flt,lg_a);
#  VAR init_variances := new(void,flt,Nimg * C);
	mg_a := oid(0);
	ng_a := setSequenceBase(init_variances,mg_a);
#  init_variances.setSequenceBase(oid(0));
	og_a := access(init_variances,BAT_APPEND);
#  init_variances.access( BAT_APPEND );
	pg_a := insert(model,"init_variances",init_variances);
#  model.insert("init_variances", init_variances);
	qg_a := access(model,BAT_READ);
#  model.access( BAT_READ );
	return model;
#  RETURN model;
end function;
#}
function newGMM(mname:str, Nimg:int):bat[str,bat];
#PROC newGMM( str mname, int Nimg ): BAT[str,bat] := {
	gmm:= newGMM(Nimg);
#  VAR gmm := newGMM(Nimg);
	rg_a := renameGMM(gmm,mname);
#  renameGMM(gmm, mname);
	return gmm;
#  RETURN gmm;
end function;
#}
function newGMM(mname:str):bat[str,bat];
#PROC newGMM( str mname ): BAT[str,bat] := {
	sg_a := newGMM(mname,1);
	return sg_a;
#  RETURN newGMM( mname, 1 );
end function;
#}
#
#
##line 669 "../../../src/gmm/gmm.mx"
function newImage(dict:bat[str,str], theUrl:str):oid;
#  PROC newImage( BAT[str,str] dict, str theUrl ): oid := {
#    VAR theImgId;
	tg_a := find(dict,"I");
	ug_a := bat(tg_a);
	vg_a := insert(ug_a,nil,theUrl);
#    bat(dict.find("I")).insert( nil, theUrl );
	I:= take("I");
	wg_a := max(I);
	xg_a := reverse(I);
	theImgId := fetch(xg_a,wg_a);
#    theImgId := I.reverse.fetch( I.max );
	return theImgId;
#    RETURN theImgId;
end function;
#  }
#
#
#
##line 1264 "../../../src/gmm/gmm.mx"
	Niter := 100;
#  CONST Niter     := 100;
	MIN_COVAR := 0.005;
#  CONST MIN_COVAR := 0.005;           # 0.005LL;
	MIN_S := 1.0e-10;
#  CONST MIN_S     := 1.0e-10;	#1.0E-300LL;
	COVAR_INIT_FRACTION := 0.1;
#  CONST COVAR_INIT_FRACTION := 0.1;   # 1.0LL/10;
#
#  VAR olde;
#  VAR loglikelihood;
#  VAR EM_model;
#  VAR EM_coll;
#
#
#
##line 1330 "../../../src/gmm/gmm.mx"
#
#
##line 1431 "../../../src/gmm/gmm.mx"
#
#
##line 1494 "../../../src/gmm/gmm.mx"
#    # PROC EM(int Niter, bat[str,bat] EM_coll, bat[str,bat] EM_model):bat[str,bat]
function EM_globalmodel(Niter:int):bat[str,bat];
#  PROC EM_globalmodel(int Niter): bat[str,bat] := {
#    
##line 1279 "../../../src/gmm/gmm.mx"
	gmm:= EM_model;
#  VAR gmm      := EM_model;
#
	yg_a := find(EM_coll,"I");
	NImg:= count(yg_a);
#  VAR NImg     := EM_coll.find("I").count;
	Ib:= find(EM_coll,"Ib");
#  VAR Ib       := EM_coll.find("Ib");
	coeffs:= find(EM_coll,"Coeffs");
#  VAR coeffs   := EM_coll.find("Coeffs");
#
	sessionId:= take("sessionId");
	ah_a := +(sessionId,"_final");
	bh_a := +("gmm",ah_a);
	gmmfinal:= newGMM(bh_a,NImg);
#  VAR gmmfinal := newGMM("gmm" + sessionId + "_final", NImg);
#  
##line 655 "../../../src/gmm/gmm.mx"
	ch_a := find(gmmfinal,"init_variances");
	BAT_APPEND:= take("BAT_APPEND");
	dh_a := access(ch_a,BAT_APPEND);
#  access( gmmfinal.find("init_variances"), BAT_APPEND );
	eh_a := find(gmmfinal,"Prior");
	fh_a := access(eh_a,BAT_APPEND);
#  access( gmmfinal.find("Prior"), BAT_APPEND );
	gh_a := find(gmmfinal,"mImgIdx");
	hh_a := access(gh_a,BAT_APPEND);
#  access( gmmfinal.find("mImgIdx"), BAT_APPEND );
	ih_a := find(gmmfinal,"mCIdx");
	jh_a := access(ih_a,BAT_APPEND);
#  access( gmmfinal.find("mCIdx"), BAT_APPEND );
	kh_a := find(gmmfinal,"Mean");
barrier	lh_a:= bunStream(kh_a,lh_aH,lh_aT);
	mh_a := access(lh_aT,BAT_APPEND);
redo	lh_a;
end	lh_a;
#  gmmfinal.find("Mean")@batloop{  access($t, BAT_APPEND); }
	nh_a := find(gmmfinal,"Covar");
barrier	oh_a:= bunStream(nh_a,oh_aH,oh_aT);
	ph_a := access(oh_aT,BAT_APPEND);
redo	oh_a;
end	oh_a;
#  gmmfinal.find("Covar")@batloop{ access($t, BAT_APPEND); }
#
#
##line 1286 "../../../src/gmm/gmm.mx"
#
#      # @@modelop(gmmfinal,persists,true)@
#  
##line 655 "../../../src/gmm/gmm.mx"
	qh_a := find(gmmfinal,"init_variances");
	STORE_MEM:= take("STORE_MEM");
	rh_a := mmap(qh_a,STORE_MEM);
#  mmap( gmmfinal.find("init_variances"), STORE_MEM );
	sh_a := find(gmmfinal,"Prior");
	th_a := mmap(sh_a,STORE_MEM);
#  mmap( gmmfinal.find("Prior"), STORE_MEM );
	uh_a := find(gmmfinal,"mImgIdx");
	vh_a := mmap(uh_a,STORE_MEM);
#  mmap( gmmfinal.find("mImgIdx"), STORE_MEM );
	wh_a := find(gmmfinal,"mCIdx");
	xh_a := mmap(wh_a,STORE_MEM);
#  mmap( gmmfinal.find("mCIdx"), STORE_MEM );
	yh_a := find(gmmfinal,"Mean");
barrier	ai_a:= bunStream(yh_a,ai_aH,ai_aT);
	bi_a := mmap(ai_aT,STORE_MEM);
redo	ai_a;
end	ai_a;
#  gmmfinal.find("Mean")@batloop{  mmap($t, STORE_MEM); }
	ci_a := find(gmmfinal,"Covar");
barrier	di_a:= bunStream(ci_a,di_aH,di_aT);
	ei_a := mmap(di_aT,STORE_MEM);
redo	di_a;
end	di_a;
#  gmmfinal.find("Covar")@batloop{ mmap($t, STORE_MEM); }
#
#
##line 1288 "../../../src/gmm/gmm.mx"
#
#
	mImgIdx:= find(gmm,"mImgIdx");
#  VAR mImgIdx  := gmm.find("mImgIdx");
	mCIdx:= find(gmm,"mCIdx");
#  VAR mCIdx    := gmm.find("mCIdx");
	fi_a := reverse(Ib);
	xcIdx:= join(fi_a,mImgIdx);
#  VAR xcIdx    := join(Ib.reverse, mImgIdx);
	gi_a := xn(xcIdx);
	xIdx:= reverse(gi_a);
#  VAR xIdx     := xn(xcIdx).reverse;
	cIdx:= nx(xcIdx);
#  VAR cIdx     := nx(xcIdx);
#
#
##line 1496 "../../../src/gmm/gmm.mx"
#
	iter:= 1;
#    VAR iter := 1;
barrier	hi_a:= true;
	ji_a := <(iter,Niter);
barrier	ii_a:= ji_a;
#    WHILE (iter < Niter) {
#      
##line 1349 "../../../src/gmm/gmm.mx"
#  
##line 1331 "../../../src/gmm/gmm.mx"
#  
##line 1305 "../../../src/gmm/gmm.mx"
	covar:= find(gmm,"Covar");
#  VAR covar    := gmm.find("Covar");
	covar := multiplex.nestedop("dbl",covar);
#                  covar := [nestedop]( "dbl", covar);
#  
##line 107 "../../../src/gmm/gmm.mx"
	ki_a := htype(covar);
	li_a := count(covar);
	ivariances:= new(ki_a,bat,li_a);
#  VAR ivariances := new(covar.htype,bat,covar.count);
#  {
	ivariances_lock:= lock_create();
#    VAR ivariances_lock := lock_create();
	Nthreads:= take("Nthreads");
barrier	mi_a:= bunStream(Nthreads,mi_aH,mi_aT);
#    covar@ [Nthreads]batloop(){
#      VAR _ivariances_result := [inv]($t
	_ivariances_result:= multiplex.inv(mi_aT);
#	   );
	ni_a := lock_set(ivariances_lock);
#      lock_set(ivariances_lock);
	oi_a := insert(ivariances,mi_aH,_ivariances_result);
#      ivariances.insert($h,_ivariances_result);
	pi_a := lock_unset(ivariances_lock);
#      lock_unset(ivariances_lock);
redo	mi_a;
end	mi_a;
#    }
	qi_a := lock_destroy(ivariances_lock);
#    lock_destroy(ivariances_lock);
#  }
#
#
##line 1307 "../../../src/gmm/gmm.mx"
#
	covar := nil;
#                  covar  := nil;
#  
##line 130 "../../../src/gmm/gmm.mx"
#VAR isqrtdet;
#
##line 127 "../../../src/gmm/gmm.mx"
#
##line 167 "../../../src/gmm/gmm.mx"
#  {
	isqrtdet_a:= fetch(ivariances,0);
	isqrtdet_e:= fetch(ivariances,4);
#    VAR isqrtdet_a := ivariances.fetch(0);    VAR isqrtdet_e := ivariances.fetch(4);
	isqrtdet_b:= fetch(ivariances,1);
	isqrtdet_f:= fetch(ivariances,5);
#    VAR isqrtdet_b := ivariances.fetch(1);    VAR isqrtdet_f := ivariances.fetch(5);
	isqrtdet_c:= fetch(ivariances,2);
	isqrtdet_g:= fetch(ivariances,6);
#    VAR isqrtdet_c := ivariances.fetch(2);    VAR isqrtdet_g := ivariances.fetch(6);
	isqrtdet_d:= fetch(ivariances,3);
	isqrtdet_h:= fetch(ivariances,7);
#    VAR isqrtdet_d := ivariances.fetch(3);    VAR isqrtdet_h := ivariances.fetch(7);
#    
##line 157 "../../../src/gmm/gmm.mx"
#    # perform four operations isqrtdet_a in parallel
#    {
#      {|
barrier	ri_a:= true;
#	
##line 147 "../../../src/gmm/gmm.mx"
#      # perform two operations isqrtdet_a in parallel
#      {
#	{|
barrier	si_a:= true;
	BAT_WRITE:= take("BAT_WRITE");
	ti_a := multiplex.*(isqrtdet_a,isqrtdet_b);
	isqrtdet_a := access(ti_a,BAT_WRITE);
#	   isqrtdet_a := [*](isqrtdet_a,isqrtdet_b).access(BAT_WRITE);
	isqrtdet_c := multiplex.*(isqrtdet_c,isqrtdet_d);
#	   isqrtdet_c := [*](isqrtdet_c,isqrtdet_d);
end	si_a;
#	 |}
	ui_a := multiplex.:*=(isqrtdet_a,isqrtdet_c);
#	 [:*=](isqrtdet_a,isqrtdet_c);
#      }
#
#
##line 160 "../../../src/gmm/gmm.mx"
#
#	
##line 147 "../../../src/gmm/gmm.mx"
#      # perform two operations isqrtdet_e in parallel
#      {
#	{|
barrier	vi_a:= true;
	wi_a := multiplex.*(isqrtdet_e,isqrtdet_f);
	isqrtdet_e := access(wi_a,BAT_WRITE);
#	   isqrtdet_e := [*](isqrtdet_e,isqrtdet_f).access(BAT_WRITE);
	isqrtdet_g := multiplex.*(isqrtdet_g,isqrtdet_h);
#	   isqrtdet_g := [*](isqrtdet_g,isqrtdet_h);
end	vi_a;
#	 |}
	xi_a := multiplex.:*=(isqrtdet_e,isqrtdet_g);
#	 [:*=](isqrtdet_e,isqrtdet_g);
#      }
#
#
##line 161 "../../../src/gmm/gmm.mx"
#
end	ri_a;
#       |}
	yi_a := multiplex.:*=(isqrtdet_a,isqrtdet_e);
#       [:*=](isqrtdet_a,isqrtdet_e);      
#    }
#
#
##line 172 "../../../src/gmm/gmm.mx"
#
	isqrtdet := isqrtdet_a;
#    isqrtdet := isqrtdet_a;
#  }
#
#
##line 127 "../../../src/gmm/gmm.mx"
#
#
#
##line 131 "../../../src/gmm/gmm.mx"
#
#
#
##line 1309 "../../../src/gmm/gmm.mx"
#
	isqrtdet := multiplex.sqrt(isqrtdet);
#  isqrtdet     := [sqrt](isqrtdet);
#  
##line 1227 "../../../src/gmm/gmm.mx"
#VAR xs;
#
##line 1224 "../../../src/gmm/gmm.mx"
#
##line 1240 "../../../src/gmm/gmm.mx"
	aj_a := htype(coeffs);
	bj_a := count(coeffs);
	xs := new(aj_a,bat,bj_a);
#  xs := new(coeffs.htype,bat,coeffs.count);
	xs_lock:= lock_create();
#  VAR xs_lock := lock_create();
barrier	cj_a:= bunStream(Nthreads,cj_aH,cj_aT);
#  coeffs@ [Nthreads]batloop(){
	_xs_result:= join(xIdx,cj_aT);
#    VAR _xs_result := join( xIdx, $t );
	dj_a := lock_set(xs_lock);
#    lock_set(xs_lock);
	ej_a := insert(xs,cj_aH,_xs_result);
#    xs.insert( $h, _xs_result );
	fj_a := lock_unset(xs_lock);
#    lock_unset(xs_lock);
redo	cj_a;
end	cj_a;
#  }
	gj_a := lock_destroy(xs_lock);
#  lock_destroy(xs_lock);
#
#
##line 1224 "../../../src/gmm/gmm.mx"
#
#
#
##line 1228 "../../../src/gmm/gmm.mx"
#
#
#
##line 1311 "../../../src/gmm/gmm.mx"
#
	hj_a := find(gmm,"Mean");
	means:= multiplex.join(cIdx,hj_a);
#  VAR means    := [join]( const cIdx, gmm.find("Mean") );
	ivars:= multiplex.join(cIdx,ivariances);
#  VAR ivars    := [join]( const cIdx, ivariances );
	diffs:= multiplex.nestedop("dmahalanobis_i_diagcov",xs,means,ivars);
#  VAR diffs    := [nestedop]("dmahalanobis_i_diagcov",xs,means,ivars);
#  
##line 130 "../../../src/gmm/gmm.mx"
#VAR dists;
#
##line 127 "../../../src/gmm/gmm.mx"
#
##line 167 "../../../src/gmm/gmm.mx"
#  {
	dists_a:= fetch(diffs,0);
	dists_e:= fetch(diffs,4);
#    VAR dists_a := diffs.fetch(0);    VAR dists_e := diffs.fetch(4);
	dists_b:= fetch(diffs,1);
	dists_f:= fetch(diffs,5);
#    VAR dists_b := diffs.fetch(1);    VAR dists_f := diffs.fetch(5);
	dists_c:= fetch(diffs,2);
	dists_g:= fetch(diffs,6);
#    VAR dists_c := diffs.fetch(2);    VAR dists_g := diffs.fetch(6);
	dists_d:= fetch(diffs,3);
	dists_h:= fetch(diffs,7);
#    VAR dists_d := diffs.fetch(3);    VAR dists_h := diffs.fetch(7);
#    
##line 157 "../../../src/gmm/gmm.mx"
#    # perform four operations dists_a in parallel
#    {
#      {|
barrier	ij_a:= true;
#	
##line 147 "../../../src/gmm/gmm.mx"
#      # perform two operations dists_a in parallel
#      {
#	{|
barrier	jj_a:= true;
	kj_a := multiplex.+(dists_a,dists_b);
	dists_a := access(kj_a,BAT_WRITE);
#	   dists_a := [+](dists_a,dists_b).access(BAT_WRITE);
	dists_c := multiplex.+(dists_c,dists_d);
#	   dists_c := [+](dists_c,dists_d);
end	jj_a;
#	 |}
	lj_a := multiplex.:+=(dists_a,dists_c);
#	 [:+=](dists_a,dists_c);
#      }
#
#
##line 160 "../../../src/gmm/gmm.mx"
#
#	
##line 147 "../../../src/gmm/gmm.mx"
#      # perform two operations dists_e in parallel
#      {
#	{|
barrier	mj_a:= true;
	nj_a := multiplex.+(dists_e,dists_f);
	dists_e := access(nj_a,BAT_WRITE);
#	   dists_e := [+](dists_e,dists_f).access(BAT_WRITE);
	dists_g := multiplex.+(dists_g,dists_h);
#	   dists_g := [+](dists_g,dists_h);
end	mj_a;
#	 |}
	oj_a := multiplex.:+=(dists_e,dists_g);
#	 [:+=](dists_e,dists_g);
#      }
#
#
##line 161 "../../../src/gmm/gmm.mx"
#
end	ij_a;
#       |}
	pj_a := multiplex.:+=(dists_a,dists_e);
#       [:+=](dists_a,dists_e);      
#    }
#
#
##line 172 "../../../src/gmm/gmm.mx"
#
	dists := dists_a;
#    dists := dists_a;
#  }
#
#
##line 127 "../../../src/gmm/gmm.mx"
#
#
#
##line 131 "../../../src/gmm/gmm.mx"
#
#
#
##line 1315 "../../../src/gmm/gmm.mx"
#
	xs := nil;
#                  xs     := nil;
	diffs := nil;
#                  diffs  := nil;
	means := nil;
#		  means  := nil;
	ivars := nil;
#		  ivars  := nil;
	ivariances := nil;
#		  ivariances := nil;
	isdet:= join(cIdx,isqrtdet);
#  VAR isdet    := join( cIdx, isqrtdet );
	N:= take("N");
	act:= multiplex.multivariate_gaussian_pdf_diagcov(dists,isdet,N);
#  VAR act      := [multivariate_gaussian_pdf_diagcov]( dists, isdet, N );
	dists := nil;
#                  dists  := nil;
	isdet := nil;
#                  isdet  := nil;
#
#
##line 1331 "../../../src/gmm/gmm.mx"
#
	qj_a := find(gmm,"Prior");
	rj_a := multiplex.dbl(qj_a);
	priors:= join(cIdx,rj_a);
#  VAR priors   := join( cIdx, [dbl](gmm.find("Prior")) );
	act := multiplex.*(act,priors);
#  act          := [*]( act, priors );
	sj_a := reverse(xIdx);
	tj_a := join(sj_a,act);
	s:= pump.sum(tj_a);
#  VAR s        := {sum}( xIdx.reverse.join(act) );
##  s            := [ [>](s,const MIN_S)? s : const MIN_S ];
##  s            := [ [!=](s,const dbl(0))? s : const 1.0LL ];
	uj_a := multiplex.>(s,MIN_S);
	vj_a := M2m.ifthen(uj_a,s,1.0LL);
	wj_a:= M2m.batconstruct1(vj_a);
	s := wj_a;
#  s            := [ [>](s,const MIN_S)? s : const 1.0LL ];
	xj_a := join(xIdx,s);
	post:= multiplex./(act,xj_a);
#  VAR post     := [/](act,xIdx.join(s));
	priors := nil;
#                  priors := nil;
	act := nil;
#                  act    := nil;
#
#
##line 1349 "../../../src/gmm/gmm.mx"
#
#  
##line 1353 "../../../src/gmm/gmm.mx"
	yj_a := multiplex.log(s);
	loglikelihood := multiplex.*(yj_a,-1);
#  loglikelihood := [*]([log](s), const -1);
	ak_a := join(Ib,loglikelihood);
	loglikelihood := pump.sum(ak_a);
#  loglikelihood := {sum}(join(Ib,loglikelihood));
	s := nil;
#                  s      := nil;
	bk_a := max(loglikelihood);
	ck_a := isnil(bk_a);
barrier	dk_a:= not(ck_a);
#  IF (not(isnil(loglikelihood.max)))
	ek_a := max(loglikelihood);
	fk_a := debug("Iter %d, maxLL %lf",iter,ek_a);
#    debug("Iter %d, maxLL %lf", iter, loglikelihood.max);
#  ELSE
end	dk_a;
barrier	gk_a:= not(dk_a);
	hk_a := debug("Iter %d",iter);
end	gk_a;
#    debug("Iter %d", iter);    
barrier	ik_a:= >(iter,1);
#  IF (iter>1) {
	jk_a := multiplex.-(loglikelihood,olde);
	deltall:= multiplex.abs(jk_a);
#    VAR deltall := [abs]([-](loglikelihood, olde));
##print( loglikelihood, olde, deltall );
	kk_a := multiplex.<(deltall,1.0LL);
	converged:= uselect(kk_a,1);
#    VAR converged := [<](deltall, const 1.0LL).uselect(true);
barrier	lk_a:= bunStream(converged,lk_aH,lk_aT);
#    converged@batloop(){
	mk_a := "Image %3d converged to (local?) maximum of likelihood";
	nk_a := debug(mk_a,lk_aH);
#      debug("Image %3d converged to (local?) maximum of likelihood", $h);
redo	lk_a;
end	lk_a;
#    }
	ok_a := count(converged);
barrier	pk_a:= >(ok_a,0);
#    IF (converged.count > 0) {
	loglikelihood := kdiff(loglikelihood,converged);
#      loglikelihood := kdiff( loglikelihood, converged );
#      
##line 1386 "../../../src/gmm/gmm.mx"
	restgmm:= new(str,bat);
#  VAR restgmm := new(str,bat);
#
#  VAR fff;
#  {
	qk_a := find(gmmfinal,"mImgIdx");
	rk_a := count(qk_a);
	convNewId:= oid(rk_a);
#    VAR convNewId := oid(gmmfinal.find("mImgIdx").count);
	sk_a := mirror(converged);
	convIdx:= join(sk_a,mImgIdx);
#    VAR convIdx   := join(converged.mirror, mImgIdx);
#    
##line 611 "../../../src/gmm/gmm.mx"
#{
	tk_a := reverse(convIdx);
	uk_a := mark(tk_a,convNewId);
	fIdx:= reverse(uk_a);
#  VAR fIdx := convIdx.reverse.mark(convNewId).reverse;
#
	vk_a := find(gmm,"mImgIdx");
	wk_a := reverse(vk_a);
	convImgIdx:= join(fIdx,wk_a);
#  VAR convImgIdx     := join( fIdx, gmm.find("mImgIdx").reverse );
	xk_a := find(gmm,"mCIdx");
	yk_a := reverse(xk_a);
	convCIdx:= join(fIdx,yk_a);
#  VAR convCIdx       := join( fIdx, gmm.find("mCIdx").reverse );
#        # implementation of batinsert into empty voidbats causes trouble...
#        debug("<PROPCHECK1 hkey=%s />",     
	al_a := find(gmmfinal,"mImgIdx");
	bl_a := info(al_a);
	cl_a := find(bl_a,"hkey");
	dl_a := debug("<PROPCHECK1 hkey=%s />",cl_a);
#          gmmfinal.find("mImgIdx").info.find("hkey"));
	el_a := reverse(convImgIdx);
	fl_a := find(gmmfinal,"mImgIdx");
	gl_a := insert(fl_a,el_a);
#  gmmfinal.find("mImgIdx").insert( convImgIdx.reverse );
#        debug("<PROPCHECK2 hkey=%s />",    
	hl_a := find(gmmfinal,"mImgIdx");
	il_a := info(hl_a);
	jl_a := find(il_a,"hkey");
	kl_a := debug("<PROPCHECK2 hkey=%s />",jl_a);
#          gmmfinal.find("mImgIdx").info.find("hkey"));
	ll_a := reverse(convCIdx);
	ml_a := find(gmmfinal,"mCIdx");
	nl_a := insert(ml_a,ll_a);
#  gmmfinal.find("mCIdx").insert( convCIdx.reverse );
#
	ol_a := find(gmm,"Prior");
	pl_a := join(fIdx,ol_a);
	ql_a := find(gmmfinal,"Prior");
	rl_a := insert(ql_a,pl_a);
#  gmmfinal.find("Prior").insert( join(fIdx, gmm.find("Prior")) );
	sl_a := find(gmmfinal,"Mean");
#  [insert]( gmmfinal.find("Mean"),
	tl_a := find(gmm,"Mean");
	ul_a := multiplex.join(fIdx,tl_a);
	vl_a := multiplex.insert(sl_a,ul_a);
#            [join](const fIdx, gmm.find("Mean")) );
	wl_a := find(gmmfinal,"Covar");
#  [insert]( gmmfinal.find("Covar"),
	xl_a := find(gmm,"Covar");
	yl_a := multiplex.join(fIdx,xl_a);
	am_a := multiplex.insert(wl_a,yl_a);
#            [join](const fIdx, gmm.find("Covar")) );
#
	bm_a := find(gmm,"init_variances");
	cm_a := join(fIdx,bm_a);
	dm_a := find(gmmfinal,"init_variances");
	em_a := insert(dm_a,cm_a);
#  gmmfinal.find("init_variances").insert( join(fIdx, gmm.find("init_variances")) );
#}
#
#
##line 1392 "../../../src/gmm/gmm.mx"
#
#    
##line 1376 "../../../src/gmm/gmm.mx"
	fm_a := find(gmmfinal,"mImgIdx");
	gm_a := kunique(fm_a);
	hm_a := count(gm_a);
barrier	im_a:= =(hm_a,NImg);
#    IF ( gmmfinal.find("mImgIdx").kunique.count = NImg ) {
	jm_a := debug("All images converged; break...");
#      debug("All images converged; break...");
leave	im_a;
#      BREAK;
#    }
#
#
##line 1393 "../../../src/gmm/gmm.mx"
#
#
end	im_a;
	nconvIdx:= diff(mImgIdx,convIdx);
#    VAR nconvIdx  := diff(mImgIdx,convIdx);
#    
##line 634 "../../../src/gmm/gmm.mx"
	km_a := oid(0);
	lm_a := reverse(nconvIdx);
	mm_a := mark(lm_a,km_a);
	fIdx:= reverse(mm_a);
#VAR fIdx           := nconvIdx.reverse.mark(oid(0)).reverse;
#{
	nm_a := find(gmm,"mImgIdx");
	om_a := reverse(nm_a);
	convImgIdx:= join(fIdx,om_a);
#  VAR convImgIdx     := join( fIdx, gmm.find("mImgIdx").reverse );
	pm_a := find(gmm,"mCIdx");
	qm_a := reverse(pm_a);
	convCIdx:= join(fIdx,qm_a);
#  VAR convCIdx       := join( fIdx, gmm.find("mCIdx").reverse );
	rm_a := reverse(convImgIdx);
	sm_a := insert(restgmm,"mImgIdx",rm_a);
#  restgmm.insert( "mImgIdx", convImgIdx.reverse );
	tm_a := reverse(convCIdx);
	um_a := insert(restgmm,"mCIdx",tm_a);
#  restgmm.insert( "mCIdx",   convCIdx.reverse );
#
	vm_a := find(gmm,"Prior");
	wm_a := join(fIdx,vm_a);
	xm_a := insert(restgmm,"Prior",wm_a);
#  restgmm.insert( "Prior", join(fIdx, gmm.find("Prior")) );
	ym_a := find(gmm,"Mean");
	an_a := multiplex.join(fIdx,ym_a);
	bn_a := insert(restgmm,"Mean",an_a);
#  restgmm.insert( "Mean",  [join](const fIdx, gmm.find("Mean")) );
	cn_a := find(gmm,"Covar");
	dn_a := multiplex.join(fIdx,cn_a);
	en_a := insert(restgmm,"Covar",dn_a);
#  restgmm.insert( "Covar", [join](const fIdx, gmm.find("Covar")) );
#
	fn_a := find(gmm,"init_variances");
	gn_a := join(fIdx,fn_a);
	hn_a := insert(restgmm,"init_variances",gn_a);
#  restgmm.insert( "init_variances", join(fIdx, gmm.find("init_variances")) );
#}
#
#
##line 1396 "../../../src/gmm/gmm.mx"
#
#
	fff := fIdx;
#    fff := fIdx;
#  }
	in_a := str(iter);
	jn_a := +(in_a,"_rest");
	kn_a := +("_",jn_a);
	ln_a := +(sessionId,kn_a);
	mn_a := +("gmm",ln_a);
	nn_a := renameGMM(restgmm,mn_a);
#  renameGMM(restgmm,"gmm" + sessionId + "_" + str(iter) + "_rest");
#  
##line 655 "../../../src/gmm/gmm.mx"
	on_a := find(restgmm,"init_variances");
	BAT_READ:= take("BAT_READ");
	pn_a := access(on_a,BAT_READ);
#  access( restgmm.find("init_variances"), BAT_READ );
	qn_a := find(restgmm,"Prior");
	rn_a := access(qn_a,BAT_READ);
#  access( restgmm.find("Prior"), BAT_READ );
	sn_a := find(restgmm,"mImgIdx");
	tn_a := access(sn_a,BAT_READ);
#  access( restgmm.find("mImgIdx"), BAT_READ );
	un_a := find(restgmm,"mCIdx");
	vn_a := access(un_a,BAT_READ);
#  access( restgmm.find("mCIdx"), BAT_READ );
	wn_a := find(restgmm,"Mean");
barrier	xn_a:= bunStream(wn_a,xn_aH,xn_aT);
	yn_a := access(xn_aT,BAT_READ);
redo	xn_a;
end	xn_a;
#  restgmm.find("Mean")@batloop{  access($t, BAT_READ); }
	ao_a := find(restgmm,"Covar");
barrier	bo_a:= bunStream(ao_a,bo_aH,bo_aT);
	co_a := access(bo_aT,BAT_READ);
redo	bo_a;
end	bo_a;
#  restgmm.find("Covar")@batloop{ access($t, BAT_READ); }
#
#
##line 1401 "../../../src/gmm/gmm.mx"
#
	gmm := restgmm;
#  gmm         := restgmm;
	restgmm := nil;
#  restgmm     := nil;
#
	Ib := kdiff(Ib,converged);
#  Ib          := kdiff(Ib, converged);
	iIdx:= nx(Ib);
#  VAR iIdx    := nx(Ib); # <new oid, old oid>
	Ib := xn(Ib);
#  Ib          := xn(Ib);
#
	oldc:= coeffs;
#  VAR oldc    := coeffs; # UGLY: nestedjoin macro makes new variable
#  
##line 1224 "../../../src/gmm/gmm.mx"
#
##line 1240 "../../../src/gmm/gmm.mx"
	do_a := htype(oldc);
	eo_a := count(oldc);
	coeffs := new(do_a,bat,eo_a);
#  coeffs := new(oldc.htype,bat,oldc.count);
	coeffs_lock:= lock_create();
#  VAR coeffs_lock := lock_create();
barrier	fo_a:= bunStream(Nthreads,fo_aH,fo_aT);
#  oldc@ [Nthreads]batloop(){
	_coeffs_result:= join(iIdx,fo_aT);
#    VAR _coeffs_result := join( iIdx, $t );
	go_a := lock_set(coeffs_lock);
#    lock_set(coeffs_lock);
	ho_a := insert(coeffs,fo_aH,_coeffs_result);
#    coeffs.insert( $h, _coeffs_result );
	io_a := lock_unset(coeffs_lock);
#    lock_unset(coeffs_lock);
redo	fo_a;
end	fo_a;
#  }
	jo_a := lock_destroy(coeffs_lock);
#  lock_destroy(coeffs_lock);
#
#
##line 1224 "../../../src/gmm/gmm.mx"
#
#
#
##line 1410 "../../../src/gmm/gmm.mx"
#
	oldc := nil;
#                  oldc    := nil;
#
	ko_a := reverse(iIdx);
	xIdx := join(xIdx,ko_a);
#  xIdx        := join(xIdx, iIdx.reverse);
	lo_a := xn(xIdx);
	newxIdx:= reverse(lo_a);
#  VAR newxIdx := xn(xIdx).reverse;
	xIdx := nx(xIdx);
#  xIdx        := nx(xIdx);
	post := join(newxIdx,post);
#  post        := join(newxIdx, post);
	cIdx := join(newxIdx,cIdx);
#  cIdx        := join(newxIdx, cIdx);
	mo_a := reverse(fff);
	cIdx := join(cIdx,mo_a);
#  cIdx        := join( cIdx, fff.reverse ); # renumber for mCIdx/mImgIdx
	newxIdx := nil;
#                  newxIdx := nil;             
	fff := nil;
#                  fff     := nil;             
#
	mImgIdx := find(gmm,"mImgIdx");
#  mImgIdx     := gmm.find("mImgIdx");
	mCIdx := find(gmm,"mCIdx");
#  mCIdx       := gmm.find("mCIdx");
#
#
##line 1369 "../../../src/gmm/gmm.mx"
#
#    }
#    
##line 1376 "../../../src/gmm/gmm.mx"
end	pk_a;
	no_a := find(gmmfinal,"mImgIdx");
	oo_a := kunique(no_a);
	po_a := count(oo_a);
barrier	qo_a:= =(po_a,NImg);
#    IF ( gmmfinal.find("mImgIdx").kunique.count = NImg ) {
	ro_a := debug("All images converged; break...");
#      debug("All images converged; break...");
leave	qo_a;
#      BREAK;
#    }
#
#
##line 1371 "../../../src/gmm/gmm.mx"
#
end	qo_a;
#  }
end	ik_a;
	olde := loglikelihood;
#  olde := loglikelihood;
#
#
##line 1350 "../../../src/gmm/gmm.mx"
#
#
#
##line 1499 "../../../src/gmm/gmm.mx"
#
#      
##line 1432 "../../../src/gmm/gmm.mx"
	so_a := reverse(cIdx);
	to_a := join(so_a,post);
	newpr:= pump.sum(to_a);
#   VAR newpr     := {sum}( cIdx.reverse.join(post) );
	newpr := multiplex.flt(newpr);
#                  newpr := [flt]( newpr );
#   VAR newpriors := [/]( newpr,
	uo_a := reverse(Ib);
	vo_a := histogram(uo_a);
	wo_a := reverse(mImgIdx);
	xo_a := join(wo_a,vo_a);
	newpriors:= multiplex./(newpr,xo_a);
#                         mImgIdx.reverse.join( Ib.reverse.histogram ) );
#debug("NP: #post %d, #newpr %d, #newpriors %d, #Ndata %d",
	yo_a := reverse(cIdx);
	ap_a := join(yo_a,post);
	bp_a := count(ap_a);
#  cIdx.reverse.join(post).count,
	cp_a := count(newpr);
#  newpr.count,
	dp_a := count(newpriors);
#  newpriors.count,
	ep_a := reverse(Ib);
#  Ib.reverse.histogram.count
	fp_a := histogram(ep_a);
	gp_a := count(fp_a);
	hp_a := debug("NP: #post %d, #newpr %d, #newpriors %d, #Ndata %d",bp_a,cp_a,dp_a,gp_a);
#);
#
#   
##line 1224 "../../../src/gmm/gmm.mx"
#
##line 1240 "../../../src/gmm/gmm.mx"
	ip_a := htype(coeffs);
	jp_a := count(coeffs);
	xs := new(ip_a,bat,jp_a);
#  xs := new(coeffs.htype,bat,coeffs.count);
	xs_lock:= lock_create();
#  VAR xs_lock := lock_create();
barrier	kp_a:= bunStream(Nthreads,kp_aH,kp_aT);
#  coeffs@ [Nthreads]batloop(){
	_xs_result:= join(xIdx,kp_aT);
#    VAR _xs_result := join( xIdx, $t );
	lp_a := lock_set(xs_lock);
#    lock_set(xs_lock);
	mp_a := insert(xs,kp_aH,_xs_result);
#    xs.insert( $h, _xs_result );
	np_a := lock_unset(xs_lock);
#    lock_unset(xs_lock);
redo	kp_a;
end	kp_a;
#  }
	op_a := lock_destroy(xs_lock);
#  lock_destroy(xs_lock);
#
#
##line 1224 "../../../src/gmm/gmm.mx"
#
#
#
##line 1443 "../../../src/gmm/gmm.mx"
#
	xhc:= multiplex.nestedop("*",xs,post);
#   VAR xhc       := [nestedop]( "*", xs, const post );
	xhc := multiplex.nestedop("flt",xhc);
#                  xhc := [nestedop]("flt", xhc);
#   
##line 1227 "../../../src/gmm/gmm.mx"
#VAR gxhc;
#
##line 1224 "../../../src/gmm/gmm.mx"
#
##line 1240 "../../../src/gmm/gmm.mx"
	pp_a := htype(xhc);
	qp_a := count(xhc);
	gxhc := new(pp_a,bat,qp_a);
#  gxhc := new(xhc.htype,bat,xhc.count);
	gxhc_lock:= lock_create();
#  VAR gxhc_lock := lock_create();
barrier	rp_a:= bunStream(Nthreads,rp_aH,rp_aT);
#  xhc@ [Nthreads]batloop(){
	sp_a := reverse(cIdx);
	_gxhc_result:= join(sp_a,rp_aT);
#    VAR _gxhc_result := join( cIdx.reverse, $t );
	tp_a := lock_set(gxhc_lock);
#    lock_set(gxhc_lock);
	up_a := insert(gxhc,rp_aH,_gxhc_result);
#    gxhc.insert( $h, _gxhc_result );
	vp_a := lock_unset(gxhc_lock);
#    lock_unset(gxhc_lock);
redo	rp_a;
end	rp_a;
#  }
	wp_a := lock_destroy(gxhc_lock);
#  lock_destroy(gxhc_lock);
#
#
##line 1224 "../../../src/gmm/gmm.mx"
#
#
#
##line 1228 "../../../src/gmm/gmm.mx"
#
#
#
##line 1446 "../../../src/gmm/gmm.mx"
#
#   
##line 107 "../../../src/gmm/gmm.mx"
	xp_a := htype(gxhc);
	yp_a := count(gxhc);
	newc:= new(xp_a,bat,yp_a);
#  VAR newc := new(gxhc.htype,bat,gxhc.count);
#  {
	newc_lock:= lock_create();
#    VAR newc_lock := lock_create();
barrier	aq_a:= bunStream(Nthreads,aq_aH,aq_aT);
#    gxhc@ [Nthreads]batloop(){
#      VAR _newc_result := {sum}($t
	_newc_result:= pump.sum(aq_aT);
#	   );
	bq_a := lock_set(newc_lock);
#      lock_set(newc_lock);
	cq_a := insert(newc,aq_aH,_newc_result);
#      newc.insert($h,_newc_result);
	dq_a := lock_unset(newc_lock);
#      lock_unset(newc_lock);
redo	aq_a;
end	aq_a;
#    }
	eq_a := lock_destroy(newc_lock);
#    lock_destroy(newc_lock);
#  }
#
#
##line 1447 "../../../src/gmm/gmm.mx"
#
	gxhc := nil;
#                  gxhc    := nil;
	xhc := nil;
#                  xhc     := nil;
	newmeans:= multiplex.nestedop("/",newc,newpr);
#   VAR newmeans  := [nestedop]("/", newc, const newpr);
	newc := nil;
#                  newc    := nil;
#
#   
##line 1224 "../../../src/gmm/gmm.mx"
#
##line 1240 "../../../src/gmm/gmm.mx"
	fq_a := htype(newmeans);
	gq_a := count(newmeans);
	means := new(fq_a,bat,gq_a);
#  means := new(newmeans.htype,bat,newmeans.count);
	means_lock:= lock_create();
#  VAR means_lock := lock_create();
barrier	hq_a:= bunStream(Nthreads,hq_aH,hq_aT);
#  newmeans@ [Nthreads]batloop(){
	_means_result:= join(cIdx,hq_aT);
#    VAR _means_result := join( cIdx, $t );
	iq_a := lock_set(means_lock);
#    lock_set(means_lock);
	jq_a := insert(means,hq_aH,_means_result);
#    means.insert( $h, _means_result );
	kq_a := lock_unset(means_lock);
#    lock_unset(means_lock);
redo	hq_a;
end	hq_a;
#  }
	lq_a := lock_destroy(means_lock);
#  lock_destroy(means_lock);
#
#
##line 1224 "../../../src/gmm/gmm.mx"
#
#
#
##line 1453 "../../../src/gmm/gmm.mx"
#
	hdiffs:= multiplex.nestedop("-",xs,means);
#   VAR hdiffs    := [nestedop]("-",xs,means);
	xs := nil;
#                  xs      := nil;
	means := nil;
#                  means   := nil;
	hdiffs := multiplex.square(hdiffs);
#   hdiffs        := [square](hdiffs);
	hdiffs := multiplex.nestedop("*",hdiffs,post);
#   hdiffs	 := [nestedop]("*",hdiffs,const post);
	hdiffs := multiplex.nestedop("flt",hdiffs);
#                  hdiffs := [nestedop]("flt", hdiffs);
#   
##line 1227 "../../../src/gmm/gmm.mx"
#VAR ghdiffs;
#
##line 1224 "../../../src/gmm/gmm.mx"
#
##line 1240 "../../../src/gmm/gmm.mx"
	mq_a := htype(hdiffs);
	nq_a := count(hdiffs);
	ghdiffs := new(mq_a,bat,nq_a);
#  ghdiffs := new(hdiffs.htype,bat,hdiffs.count);
	ghdiffs_lock:= lock_create();
#  VAR ghdiffs_lock := lock_create();
barrier	oq_a:= bunStream(Nthreads,oq_aH,oq_aT);
#  hdiffs@ [Nthreads]batloop(){
	pq_a := reverse(cIdx);
	_ghdiffs_result:= join(pq_a,oq_aT);
#    VAR _ghdiffs_result := join( cIdx.reverse, $t );
	qq_a := lock_set(ghdiffs_lock);
#    lock_set(ghdiffs_lock);
	rq_a := insert(ghdiffs,oq_aH,_ghdiffs_result);
#    ghdiffs.insert( $h, _ghdiffs_result );
	sq_a := lock_unset(ghdiffs_lock);
#    lock_unset(ghdiffs_lock);
redo	oq_a;
end	oq_a;
#  }
	tq_a := lock_destroy(ghdiffs_lock);
#  lock_destroy(ghdiffs_lock);
#
#
##line 1224 "../../../src/gmm/gmm.mx"
#
#
#
##line 1228 "../../../src/gmm/gmm.mx"
#
#
#
##line 1460 "../../../src/gmm/gmm.mx"
#
#   
##line 107 "../../../src/gmm/gmm.mx"
	uq_a := htype(ghdiffs);
	vq_a := count(ghdiffs);
	diffs:= new(uq_a,bat,vq_a);
#  VAR diffs := new(ghdiffs.htype,bat,ghdiffs.count);
#  {
	diffs_lock:= lock_create();
#    VAR diffs_lock := lock_create();
barrier	wq_a:= bunStream(Nthreads,wq_aH,wq_aT);
#    ghdiffs@ [Nthreads]batloop(){
#      VAR _diffs_result := {sum}($t
	_diffs_result:= pump.sum(wq_aT);
#	   );
	xq_a := lock_set(diffs_lock);
#      lock_set(diffs_lock);
	yq_a := insert(diffs,wq_aH,_diffs_result);
#      diffs.insert($h,_diffs_result);
	ar_a := lock_unset(diffs_lock);
#      lock_unset(diffs_lock);
redo	wq_a;
end	wq_a;
#    }
	br_a := lock_destroy(diffs_lock);
#    lock_destroy(diffs_lock);
#  }
#
#
##line 1461 "../../../src/gmm/gmm.mx"
#
	ghdiffs := nil;
#                  ghdiffs := nil;
	hdiffs := nil;
#                  hdiffs  := nil;
	newvars:= multiplex.nestedop("/",diffs,newpr);
#   VAR newvars   := [nestedop]("/",diffs,const newpr);
	diffs := nil;
#                  diffs   := nil;
#
#
##line 1500 "../../../src/gmm/gmm.mx"
#
#      
##line 1471 "../../../src/gmm/gmm.mx"
#   
##line 130 "../../../src/gmm/gmm.mx"
#VAR minvars;
#
##line 127 "../../../src/gmm/gmm.mx"
#
##line 167 "../../../src/gmm/gmm.mx"
#  {
	minvars_a:= fetch(newvars,0);
	minvars_e:= fetch(newvars,4);
#    VAR minvars_a := newvars.fetch(0);    VAR minvars_e := newvars.fetch(4);
	minvars_b:= fetch(newvars,1);
	minvars_f:= fetch(newvars,5);
#    VAR minvars_b := newvars.fetch(1);    VAR minvars_f := newvars.fetch(5);
	minvars_c:= fetch(newvars,2);
	minvars_g:= fetch(newvars,6);
#    VAR minvars_c := newvars.fetch(2);    VAR minvars_g := newvars.fetch(6);
	minvars_d:= fetch(newvars,3);
	minvars_h:= fetch(newvars,7);
#    VAR minvars_d := newvars.fetch(3);    VAR minvars_h := newvars.fetch(7);
#    
##line 157 "../../../src/gmm/gmm.mx"
#    # perform four operations minvars_a in parallel
#    {
#      {|
barrier	cr_a:= true;
#	
##line 147 "../../../src/gmm/gmm.mx"
#      # perform two operations minvars_a in parallel
#      {
#	{|
barrier	dr_a:= true;
	er_a := multiplex.min(minvars_a,minvars_b);
	minvars_a := access(er_a,BAT_WRITE);
#	   minvars_a := [min](minvars_a,minvars_b).access(BAT_WRITE);
	minvars_c := multiplex.min(minvars_c,minvars_d);
#	   minvars_c := [min](minvars_c,minvars_d);
end	dr_a;
#	 |}
	fr_a := multiplex.:min=(minvars_a,minvars_c);
#	 [:min=](minvars_a,minvars_c);
#      }
#
#
##line 160 "../../../src/gmm/gmm.mx"
#
#	
##line 147 "../../../src/gmm/gmm.mx"
#      # perform two operations minvars_e in parallel
#      {
#	{|
barrier	gr_a:= true;
	hr_a := multiplex.min(minvars_e,minvars_f);
	minvars_e := access(hr_a,BAT_WRITE);
#	   minvars_e := [min](minvars_e,minvars_f).access(BAT_WRITE);
	minvars_g := multiplex.min(minvars_g,minvars_h);
#	   minvars_g := [min](minvars_g,minvars_h);
end	gr_a;
#	 |}
	ir_a := multiplex.:min=(minvars_e,minvars_g);
#	 [:min=](minvars_e,minvars_g);
#      }
#
#
##line 161 "../../../src/gmm/gmm.mx"
#
end	cr_a;
#       |}
	jr_a := multiplex.:min=(minvars_a,minvars_e);
#       [:min=](minvars_a,minvars_e);      
#    }
#
#
##line 172 "../../../src/gmm/gmm.mx"
#
	minvars := minvars_a;
#    minvars := minvars_a;
#  }
#
#
##line 127 "../../../src/gmm/gmm.mx"
#
#
#
##line 131 "../../../src/gmm/gmm.mx"
#
#
#
##line 1471 "../../../src/gmm/gmm.mx"
#
	covarsmall:= multiplex.<(minvars,MIN_COVAR);
#   VAR covarsmall    := [<](minvars,const MIN_COVAR);
	covarnil:= multiplex.isnil(minvars);
#   VAR covarnil      := [isnil](minvars);
	kr_a := multiplex.or(covarsmall,covarnil);
	covarnotsmall:= multiplex.not(kr_a);
#   VAR covarnotsmall := [not]([or](covarsmall,covarnil));
	covarsmall := nil;
#                  covarsmall := nil;
	covarnil := nil;
#                  covarnil   := nil;
	lr_a := select(covarnotsmall,0);
	Ntoosmall:= count(lr_a);
#   VAR Ntoosmall     := select(covarnotsmall,false).count;
barrier	mr_a:= >(Ntoosmall,0);
#   IF ( Ntoosmall > 0 ) {
	nr_a := "Covariance too small in %d model(s)";
	or_a := debug(nr_a,Ntoosmall);
#     debug("Covariance too small in %d model(s)", Ntoosmall);
	init_variances:= find(gmm,"init_variances");
#     VAR init_variances := gmm.find("init_variances");
	pr_a := htype(newvars);
	qr_a := count(newvars);
	ccovars:= new(pr_a,bat,qr_a);
#     VAR ccovars   := new( newvars.htype, bat, newvars.count );
barrier	rr_a:= bunStream(newvars,rr_aH,rr_aT);
#     newvars@batloop(){
	sr_a := M2m.ifthen(covarnotsmall,rr_aT,init_variances);
	tr_a:= M2m.batconstruct1(sr_a);
	cv:= tr_a;
#       VAR cv := [ covarnotsmall ? $t : init_variances ];
	ur_a := insert(ccovars,rr_aH,cv);
#       ccovars.insert($h, cv);
redo	rr_a;
end	rr_a;
#     }
	newvars := ccovars;
#     newvars := ccovars;
#   }
#
#
##line 1501 "../../../src/gmm/gmm.mx"
#
end	mr_a;
	vr_a := :+=(iter,1);
#      iter :+= 1;
#
	gmmnew:= new(str,bat);
#      VAR gmmnew := new(str,bat);
	wr_a := insert(gmmnew,"Prior",newpriors);
#      gmmnew.insert( "Prior",  newpriors );
	xr_a := insert(gmmnew,"Mean",newmeans);
#      gmmnew.insert( "Mean",   newmeans );
	yr_a := insert(gmmnew,"Covar",newvars);
#      gmmnew.insert( "Covar",  newvars );
#
	as_a := insert(gmmnew,"mImgIdx",mImgIdx);
#      gmmnew.insert("mImgIdx", mImgIdx );
	bs_a := insert(gmmnew,"mCIdx",mCIdx);
#      gmmnew.insert("mCIdx",   mCIdx );
	cs_a := find(gmm,"init_variances");
	ds_a := insert(gmmnew,"init_variances",cs_a);
#      gmmnew.insert("init_variances", gmm.find("init_variances") );
#      
##line 655 "../../../src/gmm/gmm.mx"
	es_a := find(gmmnew,"init_variances");
	fs_a := access(es_a,BAT_READ);
#  access( gmmnew.find("init_variances"), BAT_READ );
	gs_a := find(gmmnew,"Prior");
	hs_a := access(gs_a,BAT_READ);
#  access( gmmnew.find("Prior"), BAT_READ );
	is_a := find(gmmnew,"mImgIdx");
	js_a := access(is_a,BAT_READ);
#  access( gmmnew.find("mImgIdx"), BAT_READ );
	ks_a := find(gmmnew,"mCIdx");
	ls_a := access(ks_a,BAT_READ);
#  access( gmmnew.find("mCIdx"), BAT_READ );
	ms_a := find(gmmnew,"Mean");
barrier	ns_a:= bunStream(ms_a,ns_aH,ns_aT);
	os_a := access(ns_aT,BAT_READ);
redo	ns_a;
end	ns_a;
#  gmmnew.find("Mean")@batloop{  access($t, BAT_READ); }
	ps_a := find(gmmnew,"Covar");
barrier	qs_a:= bunStream(ps_a,qs_aH,qs_aT);
	rs_a := access(qs_aT,BAT_READ);
redo	qs_a;
end	qs_a;
#  gmmnew.find("Covar")@batloop{ access($t, BAT_READ); }
#
#
##line 1512 "../../../src/gmm/gmm.mx"
#
	ss_a := str(iter);
	ts_a := +("_",ss_a);
	us_a := +(sessionId,ts_a);
	vs_a := +("gmm",us_a);
	ws_a := renameGMM(gmmnew,vs_a);
#      gmmnew.renameGMM("gmm" + sessionId + "_" + str(iter));
#
	gmm := gmmnew;
#      gmm := gmmnew;
#
barrier	xs_a:= =(iter,2);
#      IF (iter = 2) {
#        # free memory for globals
	EM_coll := nil;
#        EM_coll  := nil;
	EM_model := nil;
#        EM_model := nil;
#      }
end	xs_a;
redo	hi_a;
end	ii_a;
end	hi_a;
#    }
barrier	ys_a:= =(iter,Niter);
#    IF (iter = Niter) {
	at_a := debug("Not all images have converged");
#      debug("Not all images have converged");
	bt_a := find(gmmfinal,"mImgIdx");
	ct_a := count(bt_a);
	lastId:= oid(ct_a);
#      VAR lastId       := oid(gmmfinal.find("mImgIdx").count);
	remainingIdx:= find(gmm,"mImgIdx");
#      VAR remainingIdx := gmm.find("mImgIdx");
#      
##line 611 "../../../src/gmm/gmm.mx"
#{
	dt_a := reverse(remainingIdx);
	et_a := mark(dt_a,lastId);
	fIdx:= reverse(et_a);
#  VAR fIdx := remainingIdx.reverse.mark(lastId).reverse;
#
	ft_a := find(gmm,"mImgIdx");
	gt_a := reverse(ft_a);
	convImgIdx:= join(fIdx,gt_a);
#  VAR convImgIdx     := join( fIdx, gmm.find("mImgIdx").reverse );
	ht_a := find(gmm,"mCIdx");
	it_a := reverse(ht_a);
	convCIdx:= join(fIdx,it_a);
#  VAR convCIdx       := join( fIdx, gmm.find("mCIdx").reverse );
#        # implementation of batinsert into empty voidbats causes trouble...
#        debug("<PROPCHECK1 hkey=%s />",     
	jt_a := find(gmmfinal,"mImgIdx");
	kt_a := info(jt_a);
	lt_a := find(kt_a,"hkey");
	mt_a := debug("<PROPCHECK1 hkey=%s />",lt_a);
#          gmmfinal.find("mImgIdx").info.find("hkey"));
	nt_a := reverse(convImgIdx);
	ot_a := find(gmmfinal,"mImgIdx");
	pt_a := insert(ot_a,nt_a);
#  gmmfinal.find("mImgIdx").insert( convImgIdx.reverse );
#        debug("<PROPCHECK2 hkey=%s />",    
	qt_a := find(gmmfinal,"mImgIdx");
	rt_a := info(qt_a);
	st_a := find(rt_a,"hkey");
	tt_a := debug("<PROPCHECK2 hkey=%s />",st_a);
#          gmmfinal.find("mImgIdx").info.find("hkey"));
	ut_a := reverse(convCIdx);
	vt_a := find(gmmfinal,"mCIdx");
	wt_a := insert(vt_a,ut_a);
#  gmmfinal.find("mCIdx").insert( convCIdx.reverse );
#
	xt_a := find(gmm,"Prior");
	yt_a := join(fIdx,xt_a);
	au_a := find(gmmfinal,"Prior");
	bu_a := insert(au_a,yt_a);
#  gmmfinal.find("Prior").insert( join(fIdx, gmm.find("Prior")) );
	cu_a := find(gmmfinal,"Mean");
#  [insert]( gmmfinal.find("Mean"),
	du_a := find(gmm,"Mean");
	eu_a := multiplex.join(fIdx,du_a);
	fu_a := multiplex.insert(cu_a,eu_a);
#            [join](const fIdx, gmm.find("Mean")) );
	gu_a := find(gmmfinal,"Covar");
#  [insert]( gmmfinal.find("Covar"),
	hu_a := find(gmm,"Covar");
	iu_a := multiplex.join(fIdx,hu_a);
	ju_a := multiplex.insert(gu_a,iu_a);
#            [join](const fIdx, gmm.find("Covar")) );
#
	ku_a := find(gmm,"init_variances");
	lu_a := join(fIdx,ku_a);
	mu_a := find(gmmfinal,"init_variances");
	nu_a := insert(mu_a,lu_a);
#  gmmfinal.find("init_variances").insert( join(fIdx, gmm.find("init_variances")) );
#}
#
#
##line 1527 "../../../src/gmm/gmm.mx"
#
#    }
#      # @@modelop(gmmfinal,persists,false)@
end	ys_a;
	return gmmfinal;
#    RETURN gmmfinal;
end function;
#  }
#
#    # PROC EM(bat[str,bat] EM_coll, bat[str,bat] EM_model):bat[str,bat]
function EM_globalmodel():bat[str,bat];
#  PROC EM_globalmodel():bat[str,bat] := {
	Niter:= take("Niter");
	ou_a := EM_globalmodel(Niter);
	return ou_a;
#    RETURN EM_globalmodel(Niter);
end function;
#  }
#
#
#
##line 1557 "../../../src/gmm/gmm.mx"
	Nsamples := 100;
#  CONST Nsamples := 100;
	mu_1 := 5.0LL;
	sigma_1 := 2.0LL;
#  CONST mu_1 := 5.0LL; CONST sigma_1 := 2.0LL;
	mu_2 := 7.0LL;
	sigma_2 := 3.0LL;
#  CONST mu_2 := 7.0LL; CONST sigma_2 := 3.0LL;
#
function mix2g():dbl;
#  PROC mix2g(): dbl := {
	rand:= take("rand");
	pu_a := and(rand,15);
barrier	qu_a:= >(pu_a,10);
#    IF ( (rand and 15) > 10 ) 
	ru_a := ran_gaussian(mu_1,sigma_1);
	return ru_a;
#      RETURN ran_gaussian(mu_1,sigma_1);
end	qu_a;
barrier	su_a:= not(qu_a);
	tu_a := ran_gaussian(mu_2,sigma_2);
	return tu_a;
end	su_a;
#    ELSE RETURN ran_gaussian(mu_2,sigma_2);
end function;
#  }
#
function gen2mix(Nel:int):bat[void,dbl];
#  PROC gen2mix(int Nel):BAT[void,dbl] := {
	res:= new(void,dbl);
#    VAR res := new(void,dbl);
	uu_a := oid(0);
	vu_a := setSequenceBase(res,uu_a);
#    res.setSequenceBase(oid(0));
	i:= 0;
#    VAR i := 0;
barrier	wu_a:= true;
	yu_a := <(i,Nel);
barrier	xu_a:= yu_a;
#    WHILE (i < Nel) {
	av_a := mix2g();
	bv_a := insert(res,nil,av_a);
#      res.insert(nil, mix2g());
	cv_a := :+=(i,1);
#      i :+=1; 
redo	wu_a;
end	xu_a;
end	wu_a;
#    }
	return res;
#    RETURN res;
end function;
#  }
#
#
##line 1591 "../../../src/gmm/gmm.mx"
function cumsum_multiplex(xs:bat[any::1,any]):bat[any::1,lng];
#  PROC [cumsum](BAT[any::1,any] xs): BAT[any::1,lng] := {
	dv_a := htype(xs);
	ev_a := count(xs);
	res:= new(dv_a,lng,ev_a);
#    VAR res := new(xs.htype,lng,xs.count);
	s:= lng(0);
#    VAR s := lng(0);
barrier	fv_a:= bunStream(xs,fv_aH,fv_aT);
#    xs@batloop(){
	gv_a := :+=(s,fv_aT);
#      s :+= $t;
	hv_a := insert(res,fv_aH,s);
#      res.insert( $h, s );
redo	fv_a;
end	fv_a;
#    }
	return res;
#    RETURN res;
end function;
#  }
#
#  
##line 1605 "../../../src/gmm/gmm.mx"
function randseq(Nsamples:int, prior:bat[int,flt]):bat[void,any::1];
#  PROC randseq(int Nsamples, bat[int,flt] prior): bat[void,any::1] := {
	iv_a := htype(prior);
	res:= new(oid,iv_a,Nsamples);
#    VAR res := new(oid, prior.htype,Nsamples);
	jv_a := randseq(Nsamples);
	samp:= multiplex.lng(jv_a);
#    VAR samp := [lng](randseq(Nsamples));
	kv_a := multiplex.*(prior,RAND_MAX);
	lv_a := multiplex.int(kv_a);
	mv_a := multiplex.cumsum(lv_a);
	cint:= reverse(mv_a);
#    VAR cint := [cumsum]( [int]([*](prior, const RAND_MAX)) ).reverse;
	ib:= lng(0);
#    VAR ib := lng(0);
barrier	nv_a:= bunStream(cint,nv_aH,nv_aT);
#    cint@batloop(){
	ie:= nv_aH;
#      VAR ie := $h;
#      # a poor man's interval-join
#      res.insert(
	ov_a := multiplex.>(samp,ib);
	pv_a := multiplex.<=(samp,ie);
	qv_a := multiplex.and(ov_a,pv_a);
	rv_a := uselect(qv_a,1);
#	[and]( [>](samp,ib), [<=](samp,ie) ).uselect(true).project($t) 
	sv_a := project(rv_a,nv_aT);
	tv_a := insert(res,sv_a);
#      );
	ib := ie;
#      ib := ie;
redo	nv_a;
end	nv_a;
#    }
	uv_a := order(res);
#    res.order;
	BAT_READ:= take("BAT_READ");
	vv_a := nx(res);
	wv_a := access(vv_a,BAT_READ);
	return wv_a;
#    RETURN nx(res).access(BAT_READ);
end function;
#  }
#
#
##line 1601 "../../../src/gmm/gmm.mx"
#
#  
##line 1605 "../../../src/gmm/gmm.mx"
function randseq(Nsamples:int, prior:bat[TCluster,flt]):bat[void,any::1];
#  PROC randseq(int Nsamples, bat[TCluster,flt] prior): bat[void,any::1] := {
	xv_a := htype(prior);
	res:= new(oid,xv_a,Nsamples);
#    VAR res := new(oid, prior.htype,Nsamples);
	yv_a := randseq(Nsamples);
	samp:= multiplex.lng(yv_a);
#    VAR samp := [lng](randseq(Nsamples));
	aw_a := multiplex.*(prior,RAND_MAX);
	bw_a := multiplex.int(aw_a);
	cw_a := multiplex.cumsum(bw_a);
	cint:= reverse(cw_a);
#    VAR cint := [cumsum]( [int]([*](prior, const RAND_MAX)) ).reverse;
	ib:= lng(0);
#    VAR ib := lng(0);
barrier	dw_a:= bunStream(cint,dw_aH,dw_aT);
#    cint@batloop(){
	ie:= dw_aH;
#      VAR ie := $h;
#      # a poor man's interval-join
#      res.insert(
	ew_a := multiplex.>(samp,ib);
	fw_a := multiplex.<=(samp,ie);
	gw_a := multiplex.and(ew_a,fw_a);
	hw_a := uselect(gw_a,1);
#	[and]( [>](samp,ib), [<=](samp,ie) ).uselect(true).project($t) 
	iw_a := project(hw_a,dw_aT);
	jw_a := insert(res,iw_a);
#      );
	ib := ie;
#      ib := ie;
redo	dw_a;
end	dw_a;
#    }
	kw_a := order(res);
#    res.order;
	BAT_READ:= take("BAT_READ");
	lw_a := nx(res);
	mw_a := access(lw_a,BAT_READ);
	return mw_a;
#    RETURN nx(res).access(BAT_READ);
end function;
#  }
#
#
##line 1602 "../../../src/gmm/gmm.mx"
#
#  
##line 1605 "../../../src/gmm/gmm.mx"
function randseq(Nsamples:int, prior:bat[void,flt]):bat[void,any::1];
#  PROC randseq(int Nsamples, bat[void,flt] prior): bat[void,any::1] := {
	nw_a := htype(prior);
	res:= new(oid,nw_a,Nsamples);
#    VAR res := new(oid, prior.htype,Nsamples);
	ow_a := randseq(Nsamples);
	samp:= multiplex.lng(ow_a);
#    VAR samp := [lng](randseq(Nsamples));
	pw_a := multiplex.*(prior,RAND_MAX);
	qw_a := multiplex.int(pw_a);
	rw_a := multiplex.cumsum(qw_a);
	cint:= reverse(rw_a);
#    VAR cint := [cumsum]( [int]([*](prior, const RAND_MAX)) ).reverse;
	ib:= lng(0);
#    VAR ib := lng(0);
barrier	sw_a:= bunStream(cint,sw_aH,sw_aT);
#    cint@batloop(){
	ie:= sw_aH;
#      VAR ie := $h;
#      # a poor man's interval-join
#      res.insert(
	tw_a := multiplex.>(samp,ib);
	uw_a := multiplex.<=(samp,ie);
	vw_a := multiplex.and(tw_a,uw_a);
	ww_a := uselect(vw_a,1);
#	[and]( [>](samp,ib), [<=](samp,ie) ).uselect(true).project($t) 
	xw_a := project(ww_a,sw_aT);
	yw_a := insert(res,xw_a);
#      );
	ib := ie;
#      ib := ie;
redo	sw_a;
end	sw_a;
#    }
	ax_a := order(res);
#    res.order;
	BAT_READ:= take("BAT_READ");
	bx_a := nx(res);
	cx_a := access(bx_a,BAT_READ);
	return cx_a;
#    RETURN nx(res).access(BAT_READ);
end function;
#  }
#
#
##line 1603 "../../../src/gmm/gmm.mx"
#
#
#
##line 1623 "../../../src/gmm/gmm.mx"
function gmmsamp_diag(Nsamples:int, gmm:bat[str,bat]):bat[str,bat];
#  PROC gmmsamp_diag( int Nsamples, bat[str,bat] gmm ): bat[str,bat] := {
	res:= new(str,bat,2);
#    VAR res := new(str,bat,2);
	N:= take("N");
	samples:= new(int,bat,N);
#    VAR samples := new(int,bat,N);
#    VAR XX;
	nseq:= take("nseq");
barrier	dx_a:= bunStream(nseq,dx_aH,dx_aT);
#    nseq@batloop{ 
	XX := new(void,dbl,Nsamples);
#	XX:= new(void,dbl,Nsamples);
	ex_a := oid(0);
	fx_a := setSequenceBase(XX,ex_a);
#	XX.setSequenceBase(oid(0)); 
	gx_a := insert(samples,dx_aT,XX);
#	samples.insert($t,XX);
redo	dx_a;
end	dx_a;
#    }
	BAT_READ:= take("BAT_READ");
	hx_a := access(samples,BAT_READ);
#    samples.access(BAT_READ);
#    # do it...
	mean:= find(gmm,"Mean");
#    VAR mean := gmm.find("Mean");
	covar:= find(gmm,"Covar");
#    VAR covar := gmm.find("Covar");
#    
##line 107 "../../../src/gmm/gmm.mx"
	ix_a := htype(covar);
	jx_a := count(covar);
	sigma:= new(ix_a,bat,jx_a);
#  VAR sigma := new(covar.htype,bat,covar.count);
#  {
	sigma_lock:= lock_create();
#    VAR sigma_lock := lock_create();
	Nthreads:= take("Nthreads");
barrier	kx_a:= bunStream(Nthreads,kx_aH,kx_aT);
#    covar@ [Nthreads]batloop(){
#      VAR _sigma_result := [sqrt]($t
	_sigma_result:= multiplex.sqrt(kx_aT);
#	   );
	lx_a := lock_set(sigma_lock);
#      lock_set(sigma_lock);
	mx_a := insert(sigma,kx_aH,_sigma_result);
#      sigma.insert($h,_sigma_result);
	nx_a := lock_unset(sigma_lock);
#      lock_unset(sigma_lock);
redo	kx_a;
end	kx_a;
#    }
	ox_a := lock_destroy(sigma_lock);
#    lock_destroy(sigma_lock);
#  }
#
#
##line 1631 "../../../src/gmm/gmm.mx"
#
#
	cseq:= take("cseq");
	px_a := find(gmm,"Prior");
	qx_a := reverse(cseq);
	rx_a := join(qx_a,px_a);
	clusters:= randseq(Nsamples,rx_a);
#    VAR clusters := randseq(Nsamples, cseq.reverse.join(gmm.find("Prior")));
barrier	sx_a:= bunStream(clusters,sx_aH,sx_aT);
#    clusters@batloop(){
	tx_a := reverse(cseq);
	c:= find(tx_a,sx_aT);
#      VAR c := cseq.reverse.find($t);
#      [insert]( samples, const $h,
	ux_a := multiplex.find(mean,c);
	vx_a := multiplex.find(sigma,c);
	wx_a := multiplex.ran_gaussian(ux_a,vx_a);
	xx_a := multiplex.insert(samples,sx_aH,wx_a);
#	[ran_gaussian]( [find](mean,c), [find](sigma,c) ) );
redo	sx_a;
end	sx_a;
#    }
	yx_a := multiplex.access(samples,BAT_READ);
#    [access](samples,BAT_READ);
#    # return structure
	ay_a := insert(res,"Samples",samples);
#    res.insert( "Samples", samples );
	by_a := insert(res,"Clusters",clusters);
#    res.insert( "Clusters", clusters );
	return res;
#    RETURN res;
end function;
#  }
function gmmsamp_diag(Nsamples:int, theImg:oid, gmm:bat[str,bat]):bat[str,bat];
#  PROC gmmsamp_diag( int Nsamples, oid theImg, bat[str,bat] gmm ): bat[str,bat] := {
	cy_a := find(gmm,"mImgIdx");
	dy_a := reverse(cy_a);
	ey_a := uselect(dy_a,theImg);
	selIdx:= mirror(ey_a);
#    VAR selIdx := gmm.find("mImgIdx").reverse.uselect(theImg).mirror;
	subgmm:= new(str,bat);
#    VAR subgmm := new(str,bat);
#    
##line 634 "../../../src/gmm/gmm.mx"
	fy_a := oid(0);
	gy_a := reverse(selIdx);
	hy_a := mark(gy_a,fy_a);
	fIdx:= reverse(hy_a);
#VAR fIdx           := selIdx.reverse.mark(oid(0)).reverse;
#{
	iy_a := find(gmm,"mImgIdx");
	jy_a := reverse(iy_a);
	convImgIdx:= join(fIdx,jy_a);
#  VAR convImgIdx     := join( fIdx, gmm.find("mImgIdx").reverse );
	ky_a := find(gmm,"mCIdx");
	ly_a := reverse(ky_a);
	convCIdx:= join(fIdx,ly_a);
#  VAR convCIdx       := join( fIdx, gmm.find("mCIdx").reverse );
	my_a := reverse(convImgIdx);
	ny_a := insert(subgmm,"mImgIdx",my_a);
#  subgmm.insert( "mImgIdx", convImgIdx.reverse );
	oy_a := reverse(convCIdx);
	py_a := insert(subgmm,"mCIdx",oy_a);
#  subgmm.insert( "mCIdx",   convCIdx.reverse );
#
	qy_a := find(gmm,"Prior");
	ry_a := join(fIdx,qy_a);
	sy_a := insert(subgmm,"Prior",ry_a);
#  subgmm.insert( "Prior", join(fIdx, gmm.find("Prior")) );
	ty_a := find(gmm,"Mean");
	uy_a := multiplex.join(fIdx,ty_a);
	vy_a := insert(subgmm,"Mean",uy_a);
#  subgmm.insert( "Mean",  [join](const fIdx, gmm.find("Mean")) );
	wy_a := find(gmm,"Covar");
	xy_a := multiplex.join(fIdx,wy_a);
	yy_a := insert(subgmm,"Covar",xy_a);
#  subgmm.insert( "Covar", [join](const fIdx, gmm.find("Covar")) );
#
	aa_b := find(gmm,"init_variances");
	ba_b := join(fIdx,aa_b);
	ca_b := insert(subgmm,"init_variances",ba_b);
#  subgmm.insert( "init_variances", join(fIdx, gmm.find("init_variances")) );
#}
#
#
##line 1648 "../../../src/gmm/gmm.mx"
#
	da_b := gmmsamp_diag(Nsamples,subgmm);
	return da_b;
#    RETURN gmmsamp_diag( Nsamples, subgmm );
end function;
#  }
#
function randprob(N:int):bat[void,dbl];
#  PROC randprob(int N):bat[void,dbl] := {
	t:= randseq(N);
#    VAR t := randseq(N);
	ea_b := multiplex.lng(t);
	fa_b := sum(ea_b);
	ga_b := dbl(fa_b);
	t := multiplex./(t,ga_b);
#    t := [/]( t, const dbl([lng](t).sum) );
	return t;
#    RETURN t;
end function;
#  }
#
#
##line 1705 "../../../src/gmm/gmm.mx"
function initGMM(coll:bat[str,bat]):bat[str,bat];
#PROC initGMM( bat[str,bat] coll ):bat[str,bat] := {
	ha_b := debug("Estimating initial model");
#  debug("Estimating initial model");
	gmm:= new(str,bat);
#  VAR gmm := new(str,bat);
#
	I:= find(coll,"I");
#  VAR I       := coll.find("I");
	Ib:= find(coll,"Ib");
#  VAR Ib      := coll.find("Ib");
	coeffs:= find(coll,"Coeffs");
#  VAR coeffs  := coll.find("Coeffs");
#
	cseq:= take("cseq");
	ia_b := reverse(cseq);
	ja_b := project(ia_b,1);
	ka_b := reverse(ja_b);
	la_b := project(I,1);
	icIdx:= join(la_b,ka_b);
#  VAR icIdx   := I.project(1).join(cseq.reverse.project(1).reverse);
	mImgIdx:= xn(icIdx);
#  VAR mImgIdx := xn(icIdx);
	ma_b := nx(icIdx);
	mCIdx:= reverse(ma_b);
#  VAR mCIdx   := nx(icIdx).reverse;
#
	na_b := insert(gmm,"mImgIdx",mImgIdx);
#  gmm.insert( "mImgIdx", mImgIdx );
	oa_b := insert(gmm,"mCIdx",mCIdx);
#  gmm.insert( "mCIdx",   mCIdx );
#
#
##line 1722 "../../../src/gmm/gmm.mx"
	C:= take("C");
	pa_b := /(1.0,C);
	qa_b := reverse(mImgIdx);
	ra_b := project(qa_b,pa_b);
	sa_b := insert(gmm,"Prior",ra_b);
#  gmm.insert( "Prior", mImgIdx.reverse.project(1.0 / C ) );
#
#
##line 1727 "../../../src/gmm/gmm.mx"
	ta_b := count(I);
	ua_b := *(ta_b,C);
	va_b := new(oid,void,ua_b);
	aSample:= reverse(va_b);
#  VAR aSample := new(oid,void,I.count * C).reverse;
	aSampleR:= revers(aSample);
#   VAR aSampleR:= aSample.revers;
	wa_b := oid(0);
	xa_b := setSequenceBase(aSampleR,wa_b);
#  aSampleR.setSequenceBase(oid(0));
	ya_b := oid(0);
	ab_b := mark(I,ya_b);
barrier	bb_b:= bunStream(ab_b,bb_bH,bb_bT);
#  I.mark(oid(0))@batloop(){
	cb_b := reverse(Ib);
	db_b := select(cb_b,bb_bH);
	eb_b := int(bb_bT);
	fb_b := *(C,eb_b);
	gb_b := oid(fb_b);
	hb_b := sample(db_b,C);
	ib_b := mark(hb_b,gb_b);
	jb_b := insert(aSample,ib_b);
#    aSample.insert( Ib.reverse.select($h).sample(C).mark(oid(C * int($t))) );
redo	bb_b;
end	bb_b;
#  }
#  gmm.insert( "Mean",
#      [reverse]( 
#	[join](
	kb_b := multiplex.reverse(coeffs);
#	  [reverse](coeffs), 
	lb_b := multiplex.join(kb_b,aSample);
#	  const aSample ))
	mb_b := multiplex.reverse(lb_b);
	nb_b := insert(gmm,"Mean",mb_b);
#  );
#
#
##line 1741 "../../../src/gmm/gmm.mx"
#  
##line 1227 "../../../src/gmm/gmm.mx"
#VAR imgcoeffs;
#
##line 1224 "../../../src/gmm/gmm.mx"
#
##line 1240 "../../../src/gmm/gmm.mx"
	ob_b := htype(coeffs);
	pb_b := count(coeffs);
	imgcoeffs := new(ob_b,bat,pb_b);
#  imgcoeffs := new(coeffs.htype,bat,coeffs.count);
	imgcoeffs_lock:= lock_create();
#  VAR imgcoeffs_lock := lock_create();
	Nthreads:= take("Nthreads");
barrier	qb_b:= bunStream(Nthreads,qb_bH,qb_bT);
#  coeffs@ [Nthreads]batloop(){
	_imgcoeffs_result:= join(Ib,qb_bT);
#    VAR _imgcoeffs_result := join( Ib, $t );
	rb_b := lock_set(imgcoeffs_lock);
#    lock_set(imgcoeffs_lock);
	sb_b := insert(imgcoeffs,qb_bH,_imgcoeffs_result);
#    imgcoeffs.insert( $h, _imgcoeffs_result );
	tb_b := lock_unset(imgcoeffs_lock);
#    lock_unset(imgcoeffs_lock);
redo	qb_b;
end	qb_b;
#  }
	ub_b := lock_destroy(imgcoeffs_lock);
#  lock_destroy(imgcoeffs_lock);
#
#
##line 1224 "../../../src/gmm/gmm.mx"
#
#
#
##line 1228 "../../../src/gmm/gmm.mx"
#
#
#
##line 1741 "../../../src/gmm/gmm.mx"
#
#  
##line 107 "../../../src/gmm/gmm.mx"
	vb_b := htype(imgcoeffs);
	wb_b := count(imgcoeffs);
	Area:= new(vb_b,bat,wb_b);
#  VAR Area := new(imgcoeffs.htype,bat,imgcoeffs.count);
#  {
	Area_lock:= lock_create();
#    VAR Area_lock := lock_create();
barrier	xb_b:= bunStream(Nthreads,xb_bH,xb_bT);
#    imgcoeffs@ [Nthreads]batloop(){
#      VAR _Area_result := {sum}($t
	_Area_result:= pump.sum(xb_bT);
#	   );
	yb_b := lock_set(Area_lock);
#      lock_set(Area_lock);
	ac_b := insert(Area,xb_bH,_Area_result);
#      Area.insert($h,_Area_result);
	bc_b := lock_unset(Area_lock);
#      lock_unset(Area_lock);
redo	xb_b;
end	xb_b;
#    }
	cc_b := lock_destroy(Area_lock);
#    lock_destroy(Area_lock);
#  }
#
#
##line 1742 "../../../src/gmm/gmm.mx"
#
	imgcoeffs := nil;
#            imgcoeffs := nil;
	dc_b := reverse(Ib);
	Ndata:= histogram(dc_b);
#  VAR Ndata := Ib.reverse.histogram;
#  
##line 107 "../../../src/gmm/gmm.mx"
	ec_b := htype(Area);
	fc_b := count(Area);
	means:= new(ec_b,bat,fc_b);
#  VAR means := new(Area.htype,bat,Area.count);
#  {
	means_lock:= lock_create();
#    VAR means_lock := lock_create();
barrier	gc_b:= bunStream(Nthreads,gc_bH,gc_bT);
#    Area@ [Nthreads]batloop(){
#      VAR _means_result := [/]($t
#	
##line 104 "../../../src/gmm/gmm.mx"
#,Ndata
#
#
##line 112 "../../../src/gmm/gmm.mx"
	_means_result:= multiplex./(gc_bT,Ndata);
#   );
	hc_b := lock_set(means_lock);
#      lock_set(means_lock);
	ic_b := insert(means,gc_bH,_means_result);
#      means.insert($h,_means_result);
	jc_b := lock_unset(means_lock);
#      lock_unset(means_lock);
redo	gc_b;
end	gc_b;
#    }
	kc_b := lock_destroy(means_lock);
#    lock_destroy(means_lock);
#  }
#
#
##line 1745 "../../../src/gmm/gmm.mx"
#
#  
##line 1227 "../../../src/gmm/gmm.mx"
#VAR alignedmeans;
#
##line 1224 "../../../src/gmm/gmm.mx"
#
##line 1240 "../../../src/gmm/gmm.mx"
	lc_b := htype(means);
	mc_b := count(means);
	alignedmeans := new(lc_b,bat,mc_b);
#  alignedmeans := new(means.htype,bat,means.count);
	alignedmeans_lock:= lock_create();
#  VAR alignedmeans_lock := lock_create();
barrier	nc_b:= bunStream(Nthreads,nc_bH,nc_bT);
#  means@ [Nthreads]batloop(){
	oc_b := reverse(Ib);
	_alignedmeans_result:= join(oc_b,nc_bT);
#    VAR _alignedmeans_result := join( Ib.reverse, $t );
	pc_b := lock_set(alignedmeans_lock);
#    lock_set(alignedmeans_lock);
	qc_b := insert(alignedmeans,nc_bH,_alignedmeans_result);
#    alignedmeans.insert( $h, _alignedmeans_result );
	rc_b := lock_unset(alignedmeans_lock);
#    lock_unset(alignedmeans_lock);
redo	nc_b;
end	nc_b;
#  }
	sc_b := lock_destroy(alignedmeans_lock);
#  lock_destroy(alignedmeans_lock);
#
#
##line 1224 "../../../src/gmm/gmm.mx"
#
#
#
##line 1228 "../../../src/gmm/gmm.mx"
#
#
#
##line 1746 "../../../src/gmm/gmm.mx"
#
	means := nil;
#            means := nil;
#
	diffs:= multiplex.nestedop("-",coeffs,alignedmeans);
#  VAR diffs := [nestedop]("-",coeffs,alignedmeans);
	alignedmeans := nil;
#            alignedmeans := nil;
	coeffs := nil;
#	    coeffs := nil;
	diffs := multiplex.square(diffs);
#  diffs := [square](diffs);       # deepop?
#  
##line 1227 "../../../src/gmm/gmm.mx"
#VAR imgdiffs;
#
##line 1224 "../../../src/gmm/gmm.mx"
#
##line 1240 "../../../src/gmm/gmm.mx"
	tc_b := htype(diffs);
	uc_b := count(diffs);
	imgdiffs := new(tc_b,bat,uc_b);
#  imgdiffs := new(diffs.htype,bat,diffs.count);
	imgdiffs_lock:= lock_create();
#  VAR imgdiffs_lock := lock_create();
barrier	vc_b:= bunStream(Nthreads,vc_bH,vc_bT);
#  diffs@ [Nthreads]batloop(){
	_imgdiffs_result:= join(Ib,vc_bT);
#    VAR _imgdiffs_result := join( Ib, $t );
	wc_b := lock_set(imgdiffs_lock);
#    lock_set(imgdiffs_lock);
	xc_b := insert(imgdiffs,vc_bH,_imgdiffs_result);
#    imgdiffs.insert( $h, _imgdiffs_result );
	yc_b := lock_unset(imgdiffs_lock);
#    lock_unset(imgdiffs_lock);
redo	vc_b;
end	vc_b;
#  }
	ad_b := lock_destroy(imgdiffs_lock);
#  lock_destroy(imgdiffs_lock);
#
#
##line 1224 "../../../src/gmm/gmm.mx"
#
#
#
##line 1228 "../../../src/gmm/gmm.mx"
#
#
#
##line 1753 "../../../src/gmm/gmm.mx"
#
#  
##line 107 "../../../src/gmm/gmm.mx"
	bd_b := htype(imgdiffs);
	cd_b := count(imgdiffs);
	tmp:= new(bd_b,bat,cd_b);
#  VAR tmp := new(imgdiffs.htype,bat,imgdiffs.count);
#  {
	tmp_lock:= lock_create();
#    VAR tmp_lock := lock_create();
barrier	dd_b:= bunStream(Nthreads,dd_bH,dd_bT);
#    imgdiffs@ [Nthreads]batloop(){
#      VAR _tmp_result := {sum}($t
	_tmp_result:= pump.sum(dd_bT);
#	   );
	ed_b := lock_set(tmp_lock);
#      lock_set(tmp_lock);
	fd_b := insert(tmp,dd_bH,_tmp_result);
#      tmp.insert($h,_tmp_result);
	gd_b := lock_unset(tmp_lock);
#      lock_unset(tmp_lock);
redo	dd_b;
end	dd_b;
#    }
	hd_b := lock_destroy(tmp_lock);
#    lock_destroy(tmp_lock);
#  }
#
#
##line 1754 "../../../src/gmm/gmm.mx"
#
#  
##line 107 "../../../src/gmm/gmm.mx"
	id_b := htype(tmp);
	jd_b := count(tmp);
	variances:= new(id_b,bat,jd_b);
#  VAR variances := new(tmp.htype,bat,tmp.count);
#  {
	variances_lock:= lock_create();
#    VAR variances_lock := lock_create();
barrier	kd_b:= bunStream(Nthreads,kd_bH,kd_bT);
#    tmp@ [Nthreads]batloop(){
#      VAR _variances_result := [/]($t
#	
##line 104 "../../../src/gmm/gmm.mx"
#,Ndata
#
#
##line 112 "../../../src/gmm/gmm.mx"
	_variances_result:= multiplex./(kd_bT,Ndata);
#   );
	ld_b := lock_set(variances_lock);
#      lock_set(variances_lock);
	md_b := insert(variances,kd_bH,_variances_result);
#      variances.insert($h,_variances_result);
	nd_b := lock_unset(variances_lock);
#      lock_unset(variances_lock);
redo	kd_b;
end	kd_b;
#    }
	od_b := lock_destroy(variances_lock);
#    lock_destroy(variances_lock);
#  }
#
#
##line 1755 "../../../src/gmm/gmm.mx"
#
	tmp := nil;
#            tmp := nil;
	imgdiffs := nil;
#	    imgdiffs := nil;
	Ndata := nil;
#	    Ndata := nil;
#  
##line 130 "../../../src/gmm/gmm.mx"
#VAR init_variances;
#
##line 127 "../../../src/gmm/gmm.mx"
#
##line 167 "../../../src/gmm/gmm.mx"
#  {
	init_variances_a:= fetch(variances,0);
	init_variances_e:= fetch(variances,4);
#    VAR init_variances_a := variances.fetch(0);    VAR init_variances_e := variances.fetch(4);
	init_variances_b:= fetch(variances,1);
	init_variances_f:= fetch(variances,5);
#    VAR init_variances_b := variances.fetch(1);    VAR init_variances_f := variances.fetch(5);
	init_variances_c:= fetch(variances,2);
	init_variances_g:= fetch(variances,6);
#    VAR init_variances_c := variances.fetch(2);    VAR init_variances_g := variances.fetch(6);
	init_variances_d:= fetch(variances,3);
	init_variances_h:= fetch(variances,7);
#    VAR init_variances_d := variances.fetch(3);    VAR init_variances_h := variances.fetch(7);
#    
##line 157 "../../../src/gmm/gmm.mx"
#    # perform four operations init_variances_a in parallel
#    {
#      {|
barrier	pd_b:= true;
#	
##line 147 "../../../src/gmm/gmm.mx"
#      # perform two operations init_variances_a in parallel
#      {
#	{|
barrier	qd_b:= true;
	BAT_WRITE:= take("BAT_WRITE");
	rd_b := multiplex.+(init_variances_a,init_variances_b);
	init_variances_a := access(rd_b,BAT_WRITE);
#	   init_variances_a := [+](init_variances_a,init_variances_b).access(BAT_WRITE);
	init_variances_c := multiplex.+(init_variances_c,init_variances_d);
#	   init_variances_c := [+](init_variances_c,init_variances_d);
end	qd_b;
#	 |}
	sd_b := multiplex.:+=(init_variances_a,init_variances_c);
#	 [:+=](init_variances_a,init_variances_c);
#      }
#
#
##line 160 "../../../src/gmm/gmm.mx"
#
#	
##line 147 "../../../src/gmm/gmm.mx"
#      # perform two operations init_variances_e in parallel
#      {
#	{|
barrier	td_b:= true;
	ud_b := multiplex.+(init_variances_e,init_variances_f);
	init_variances_e := access(ud_b,BAT_WRITE);
#	   init_variances_e := [+](init_variances_e,init_variances_f).access(BAT_WRITE);
	init_variances_g := multiplex.+(init_variances_g,init_variances_h);
#	   init_variances_g := [+](init_variances_g,init_variances_h);
end	td_b;
#	 |}
	vd_b := multiplex.:+=(init_variances_e,init_variances_g);
#	 [:+=](init_variances_e,init_variances_g);
#      }
#
#
##line 161 "../../../src/gmm/gmm.mx"
#
end	pd_b;
#       |}
	wd_b := multiplex.:+=(init_variances_a,init_variances_e);
#       [:+=](init_variances_a,init_variances_e);      
#    }
#
#
##line 172 "../../../src/gmm/gmm.mx"
#
	init_variances := init_variances_a;
#    init_variances := init_variances_a;
#  }
#
#
##line 127 "../../../src/gmm/gmm.mx"
#
#
#
##line 131 "../../../src/gmm/gmm.mx"
#
#
#
##line 1759 "../../../src/gmm/gmm.mx"
#
	xd_b := multiplex./(init_variances,N);
#  init_variances := [*]( [/]( init_variances, const N ), 
	init_variances := multiplex.*(xd_b,COVAR_INIT_FRACTION);
#    const COVAR_INIT_FRACTION );
#    # Q: blow up this one here or in the loop???
	yd_b := reverse(mImgIdx);
	init_variances := join(yd_b,init_variances);
#  init_variances := join(mImgIdx.reverse, init_variances);
	ae_b := insert(gmm,"init_variances",init_variances);
#  gmm.insert( "init_variances", init_variances );
#
	covar:= new(int,bat,N);
#  VAR covar := new(int,bat,N);
	i:= 0;
#  VAR i := 0;
barrier	be_b:= true;
	de_b := <(i,N);
barrier	ce_b:= de_b;
#  WHILE (i < N) {
	ee_b := insert(covar,i,init_variances);
#    covar.insert( i, init_variances );
	fe_b := :+=(i,1);
#    i :+= 1;
redo	be_b;
end	ce_b;
end	be_b;
#  }
	ge_b := insert(gmm,"Covar",covar);
#  gmm.insert( "Covar", covar );
#
	sessionId:= take("sessionId");
	he_b := +(sessionId,"_init");
	ie_b := +("gmm",he_b);
	je_b := renameGMM(gmm,ie_b);
#  gmm.renameGMM("gmm" + sessionId + "_init");
	return gmm;
#  RETURN gmm;
end function;
#}
#
#
#
##line 1781 "../../../src/gmm/gmm.mx"
function test_EM(Nimg:int, M:int):bat[str,bat];
#PROC test_EM(int Nimg, int M): bat[str,bat] := {
	testmodels:= new(str,bat);
#  VAR testmodels := new(str,bat);
#
	ke_b := debug("Creating collection with M=%d",M);
#  debug("Creating collection with M=%d",M);
	sessionId:= take("sessionId");
	le_b := +("imgs",sessionId);
	imgs:= newCollection(le_b,Nimg);
#  VAR imgs := newCollection("imgs" + sessionId, Nimg);
#  
##line 663 "../../../src/gmm/gmm.mx"
	me_b := find(imgs,"Coeffs");
barrier	ne_b:= bunStream(me_b,ne_bH,ne_bT);
	oe_b := setPersistent(ne_bT);
redo	ne_b;
end	ne_b;
#  imgs.find("Coeffs")@batloop{ setPersistent($t); }
barrier	pe_b:= bunStream(imgs,pe_bH,pe_bT);
	qe_b := setPersistent(pe_bT);
redo	pe_b;
end	pe_b;
#  imgs@batloop(){ setPersistent($t); }
#
#
##line 1786 "../../../src/gmm/gmm.mx"
#
#  
##line 663 "../../../src/gmm/gmm.mx"
	re_b := find(imgs,"Coeffs");
barrier	se_b:= bunStream(re_b,se_bH,se_bT);
	STORE_MMAP:= take("STORE_MMAP");
	te_b := mmap(se_bT,STORE_MMAP);
redo	se_b;
end	se_b;
#  imgs.find("Coeffs")@batloop{ mmap($t, STORE_MMAP); }
barrier	ue_b:= bunStream(imgs,ue_bH,ue_bT);
	ve_b := mmap(ue_bT,STORE_MMAP);
redo	ue_b;
end	ue_b;
#  imgs@batloop(){ mmap($t, STORE_MMAP); }
#
#
##line 1787 "../../../src/gmm/gmm.mx"
#
#
#
##line 1793 "../../../src/gmm/gmm.mx"
	we_b := find(imgs,"Coeffs");
	xe_b := setTransient(we_b,);
#           imgs.find("Coeffs").setTransient();
	ye_b := +("src",sessionId);
	src_gmm:= newGMM(ye_b);
#  VAR src_gmm := newGMM("src" + sessionId);
#  
##line 655 "../../../src/gmm/gmm.mx"
	af_b := find(src_gmm,"init_variances");
	bf_b := setPersistent(af_b);
#  setPersistent( src_gmm.find("init_variances") );
	cf_b := find(src_gmm,"Prior");
	df_b := setPersistent(cf_b);
#  setPersistent( src_gmm.find("Prior") );
	ef_b := find(src_gmm,"mImgIdx");
	ff_b := setPersistent(ef_b);
#  setPersistent( src_gmm.find("mImgIdx") );
	gf_b := find(src_gmm,"mCIdx");
	hf_b := setPersistent(gf_b);
#  setPersistent( src_gmm.find("mCIdx") );
	if_b := find(src_gmm,"Mean");
barrier	jf_b:= bunStream(if_b,jf_bH,jf_bT);
	kf_b := setPersistent(jf_bT);
redo	jf_b;
end	jf_b;
#  src_gmm.find("Mean")@batloop{  setPersistent($t); }
	lf_b := find(src_gmm,"Covar");
barrier	mf_b:= bunStream(lf_b,mf_bH,mf_bT);
	nf_b := setPersistent(mf_bT);
redo	mf_b;
end	mf_b;
#  src_gmm.find("Covar")@batloop{ setPersistent($t); }
#
#
##line 1795 "../../../src/gmm/gmm.mx"
#
#  
##line 655 "../../../src/gmm/gmm.mx"
	of_b := find(src_gmm,"init_variances");
	pf_b := mmap(of_b,STORE_MMAP);
#  mmap( src_gmm.find("init_variances"), STORE_MMAP );
	qf_b := find(src_gmm,"Prior");
	rf_b := mmap(qf_b,STORE_MMAP);
#  mmap( src_gmm.find("Prior"), STORE_MMAP );
	sf_b := find(src_gmm,"mImgIdx");
	tf_b := mmap(sf_b,STORE_MMAP);
#  mmap( src_gmm.find("mImgIdx"), STORE_MMAP );
	uf_b := find(src_gmm,"mCIdx");
	vf_b := mmap(uf_b,STORE_MMAP);
#  mmap( src_gmm.find("mCIdx"), STORE_MMAP );
	wf_b := find(src_gmm,"Mean");
barrier	xf_b:= bunStream(wf_b,xf_bH,xf_bT);
	yf_b := mmap(xf_bT,STORE_MMAP);
redo	xf_b;
end	xf_b;
#  src_gmm.find("Mean")@batloop{  mmap($t, STORE_MMAP); }
	ag_b := find(src_gmm,"Covar");
barrier	bg_b:= bunStream(ag_b,bg_bH,bg_bT);
	cg_b := mmap(bg_bT,STORE_MMAP);
redo	bg_b;
end	bg_b;
#  src_gmm.find("Covar")@batloop{ mmap($t, STORE_MMAP); }
#
#
##line 1796 "../../../src/gmm/gmm.mx"
#
#
#  
##line 1663 "../../../src/gmm/gmm.mx"
#  
##line 663 "../../../src/gmm/gmm.mx"
	dg_b := find(imgs,"Coeffs");
barrier	eg_b:= bunStream(dg_b,eg_bH,eg_bT);
	BAT_APPEND:= take("BAT_APPEND");
	fg_b := access(eg_bT,BAT_APPEND);
redo	eg_b;
end	eg_b;
#  imgs.find("Coeffs")@batloop{ access($t, BAT_APPEND); }
barrier	gg_b:= bunStream(imgs,gg_bH,gg_bT);
	hg_b := access(gg_bT,BAT_APPEND);
redo	gg_b;
end	gg_b;
#  imgs@batloop(){ access($t, BAT_APPEND); }
#
#
##line 1663 "../../../src/gmm/gmm.mx"
#
#  
##line 655 "../../../src/gmm/gmm.mx"
	ig_b := find(src_gmm,"init_variances");
	jg_b := access(ig_b,BAT_APPEND);
#  access( src_gmm.find("init_variances"), BAT_APPEND );
	kg_b := find(src_gmm,"Prior");
	lg_b := access(kg_b,BAT_APPEND);
#  access( src_gmm.find("Prior"), BAT_APPEND );
	mg_b := find(src_gmm,"mImgIdx");
	ng_b := access(mg_b,BAT_APPEND);
#  access( src_gmm.find("mImgIdx"), BAT_APPEND );
	og_b := find(src_gmm,"mCIdx");
	pg_b := access(og_b,BAT_APPEND);
#  access( src_gmm.find("mCIdx"), BAT_APPEND );
	qg_b := find(src_gmm,"Mean");
barrier	rg_b:= bunStream(qg_b,rg_bH,rg_bT);
	sg_b := access(rg_bT,BAT_APPEND);
redo	rg_b;
end	rg_b;
#  src_gmm.find("Mean")@batloop{  access($t, BAT_APPEND); }
	tg_b := find(src_gmm,"Covar");
barrier	ug_b:= bunStream(tg_b,ug_bH,ug_bT);
	vg_b := access(ug_bT,BAT_APPEND);
redo	ug_b;
end	ug_b;
#  src_gmm.find("Covar")@batloop{ access($t, BAT_APPEND); }
#
#
##line 1664 "../../../src/gmm/gmm.mx"
#
#  # some random metadata for now
	wg_b := str(0);
	xg_b := +(wg_b,".jpg");
	yg_b := +("http://nowhere.org/noimg_",xg_b);
	ah_b := find(imgs,"I");
	bh_b := insert(ah_b,nil,yg_b);
#  imgs.find("I").insert(nil,"http://nowhere.org/noimg_" + str(0) + ".jpg");
	ch_b := Nseq(M);
barrier	dh_b:= bunStream(ch_b,dh_bH,dh_bT);
#  Nseq(M)@batloop(){
	eh_b := oid(0);
	fh_b := find(imgs,"Ib");
	gh_b := insert(fh_b,eh_b,nil);
#    imgs.find("Ib").insert(oid(0),nil);
	hh_b := %(dh_bT,44);
	ih_b := find(imgs,"Ix");
	jh_b := insert(ih_b,nil,hh_b);
#    imgs.find("Ix").insert(nil, ($t % 44));
	kh_b := /(dh_bT,44);
	lh_b := find(imgs,"Iy");
	mh_b := insert(lh_b,nil,kh_b);
#    imgs.find("Iy").insert(nil, ($t / 44));
redo	dh_b;
end	dh_b;
#  }
	C:= take("C");
	nh_b := randprob(C);
	oh_b := multiplex.flt(nh_b);
	ph_b := find(src_gmm,"Prior");
	qh_b := insert(ph_b,oh_b);
#  src_gmm.find("Prior").insert( [flt](randprob(C)) );
	cseq:= take("cseq");
barrier	rh_b:= bunStream(cseq,rh_bH,rh_bT);
#  cseq@batloop(){
#    # NOTE: was RAND_MAX + 1.0LL
	sh_b := find(src_gmm,"Mean");
#    [insert]( src_gmm.find("Mean"), const nil,
	th_b := randseq(N);
	uh_b := +(RAND_MAX,1.0);
	vh_b := /(uh_b,255);
	wh_b := multiplex./(th_b,vh_b);
	xh_b := reverse(wh_b);
	yh_b := number(xh_b);
	ai_b := reverse(yh_b);
	bi_b := multiplex.insert(sh_b,nil,ai_b);
#      [/]( randseq(N), const (RAND_MAX + 1.0) / 255).reverse.number.reverse );
	ci_b := find(src_gmm,"Covar");
#    [insert]( src_gmm.find("Covar"), const nil,
	di_b := randseq(N);
	ei_b := +(RAND_MAX,1.0);
	fi_b := /(ei_b,128);
	gi_b := multiplex./(di_b,fi_b);
	hi_b := reverse(gi_b);
	ii_b := number(hi_b);
	ji_b := reverse(ii_b);
	ki_b := multiplex.insert(ci_b,nil,ji_b);
#      [/]( randseq(N), const (RAND_MAX + 1.0) / 128).reverse.number.reverse );
redo	rh_b;
end	rh_b;
#  }
	li_b := oid(0);
	mi_b := _x(cseq);
	ni_b := project(mi_b,li_b);
	oi_b := reverse(ni_b);
	pi_b := find(src_gmm,"mImgIdx");
	qi_b := insert(pi_b,oi_b);
#  src_gmm.find("mImgIdx").insert(_x(cseq).project(const oid(0)).reverse);
	ri_b := _x(cseq);
	si_b := reverse(ri_b);
	ti_b := find(src_gmm,"mCIdx");
	ui_b := insert(ti_b,si_b);
#  src_gmm.find("mCIdx").insert(_x(cseq).reverse);
#    # bug with first insert in table
	vi_b := find(src_gmm,"mImgIdx");
	wi_b := oid(0);
	xi_b := reverse(vi_b);
	yi_b := setSequenceBase(xi_b,wi_b);
	aj_b := reverse(yi_b);
#  src_gmm.find("mImgIdx").reverse.setSequenceBase(oid(0)).reverse;
	bj_b := find(src_gmm,"mCIdx");
	cj_b := oid(0);
	dj_b := reverse(bj_b);
	ej_b := setSequenceBase(dj_b,cj_b);
	fj_b := reverse(ej_b);
#  src_gmm.find("mCIdx").reverse.setSequenceBase(oid(0)).reverse;
#  
##line 655 "../../../src/gmm/gmm.mx"
	gj_b := find(src_gmm,"init_variances");
	BAT_READ:= take("BAT_READ");
	hj_b := access(gj_b,BAT_READ);
#  access( src_gmm.find("init_variances"), BAT_READ );
	ij_b := find(src_gmm,"Prior");
	jj_b := access(ij_b,BAT_READ);
#  access( src_gmm.find("Prior"), BAT_READ );
	kj_b := find(src_gmm,"mImgIdx");
	lj_b := access(kj_b,BAT_READ);
#  access( src_gmm.find("mImgIdx"), BAT_READ );
	mj_b := find(src_gmm,"mCIdx");
	nj_b := access(mj_b,BAT_READ);
#  access( src_gmm.find("mCIdx"), BAT_READ );
	oj_b := find(src_gmm,"Mean");
barrier	pj_b:= bunStream(oj_b,pj_bH,pj_bT);
	qj_b := access(pj_bT,BAT_READ);
redo	pj_b;
end	pj_b;
#  src_gmm.find("Mean")@batloop{  access($t, BAT_READ); }
	rj_b := find(src_gmm,"Covar");
barrier	sj_b:= bunStream(rj_b,sj_bH,sj_bT);
	tj_b := access(sj_bT,BAT_READ);
redo	sj_b;
end	sj_b;
#  src_gmm.find("Covar")@batloop{ access($t, BAT_READ); }
#
#
##line 1685 "../../../src/gmm/gmm.mx"
#
	uj_b := oid(0);
	aSampleImg:= gmmsamp_diag(M,uj_b,src_gmm);
#  VAR aSampleImg := gmmsamp_diag(M, oid(0), src_gmm);
#  {
	vj_b := find(aSampleImg,"Samples");
	imgSamples:= multiplex.nestedop("sht",vj_b);
#    VAR imgSamples := [nestedop]( "sht", aSampleImg.find("Samples") );
#    [insert](
	wj_b := find(imgs,"Coeffs");
#      imgs.find("Coeffs"),
#      imgSamples
	xj_b := multiplex.insert(wj_b,imgSamples);
#    );
	commit:= take("commit");
#    commit;
#  }
#  
##line 663 "../../../src/gmm/gmm.mx"
	yj_b := find(imgs,"Coeffs");
barrier	ak_b:= bunStream(yj_b,ak_bH,ak_bT);
	bk_b := access(ak_bT,BAT_READ);
redo	ak_b;
end	ak_b;
#  imgs.find("Coeffs")@batloop{ access($t, BAT_READ); }
barrier	ck_b:= bunStream(imgs,ck_bH,ck_bT);
	dk_b := access(ck_bT,BAT_READ);
redo	ck_b;
end	ck_b;
#  imgs@batloop(){ access($t, BAT_READ); }
#
#
##line 1695 "../../../src/gmm/gmm.mx"
#
#
#
##line 1798 "../../../src/gmm/gmm.mx"
#
	ek_b := find(src_gmm,"mImgIdx");
	fk_b := oid(0);
	gk_b := reverse(ek_b);
	hk_b := setSequenceBase(gk_b,fk_b);
#  src_gmm.find("mImgIdx").reverse.setSequenceBase(oid(0)); # bug??
	ik_b := find(src_gmm,"mCIdx");
	jk_b := oid(0);
	kk_b := reverse(ik_b);
	lk_b := setSequenceBase(kk_b,jk_b);
#  src_gmm.find("mCIdx").reverse.setSequenceBase(oid(0));
#
#  # Insert additional images
	imgNr:= 1;
#  VAR imgNr := 1;
barrier	mk_b:= true;
	ok_b := <(imgNr,Nimg);
barrier	nk_b:= ok_b;
#  WHILE ( imgNr < Nimg ) {
#    
##line 1663 "../../../src/gmm/gmm.mx"
#  
##line 663 "../../../src/gmm/gmm.mx"
	pk_b := find(imgs,"Coeffs");
barrier	qk_b:= bunStream(pk_b,qk_bH,qk_bT);
	rk_b := access(qk_bT,BAT_APPEND);
redo	qk_b;
end	qk_b;
#  imgs.find("Coeffs")@batloop{ access($t, BAT_APPEND); }
barrier	sk_b:= bunStream(imgs,sk_bH,sk_bT);
	tk_b := access(sk_bT,BAT_APPEND);
redo	sk_b;
end	sk_b;
#  imgs@batloop(){ access($t, BAT_APPEND); }
#
#
##line 1663 "../../../src/gmm/gmm.mx"
#
#  
##line 655 "../../../src/gmm/gmm.mx"
	uk_b := find(src_gmm,"init_variances");
	vk_b := access(uk_b,BAT_APPEND);
#  access( src_gmm.find("init_variances"), BAT_APPEND );
	wk_b := find(src_gmm,"Prior");
	xk_b := access(wk_b,BAT_APPEND);
#  access( src_gmm.find("Prior"), BAT_APPEND );
	yk_b := find(src_gmm,"mImgIdx");
	al_b := access(yk_b,BAT_APPEND);
#  access( src_gmm.find("mImgIdx"), BAT_APPEND );
	bl_b := find(src_gmm,"mCIdx");
	cl_b := access(bl_b,BAT_APPEND);
#  access( src_gmm.find("mCIdx"), BAT_APPEND );
	dl_b := find(src_gmm,"Mean");
barrier	el_b:= bunStream(dl_b,el_bH,el_bT);
	fl_b := access(el_bT,BAT_APPEND);
redo	el_b;
end	el_b;
#  src_gmm.find("Mean")@batloop{  access($t, BAT_APPEND); }
	gl_b := find(src_gmm,"Covar");
barrier	hl_b:= bunStream(gl_b,hl_bH,hl_bT);
	il_b := access(hl_bT,BAT_APPEND);
redo	hl_b;
end	hl_b;
#  src_gmm.find("Covar")@batloop{ access($t, BAT_APPEND); }
#
#
##line 1664 "../../../src/gmm/gmm.mx"
#
#  # some random metadata for now
	jl_b := str(imgNr);
	kl_b := +(jl_b,".jpg");
	ll_b := +("http://nowhere.org/noimg_",kl_b);
	ml_b := find(imgs,"I");
	nl_b := insert(ml_b,nil,ll_b);
#  imgs.find("I").insert(nil,"http://nowhere.org/noimg_" + str(imgNr) + ".jpg");
	ol_b := Nseq(M);
barrier	pl_b:= bunStream(ol_b,pl_bH,pl_bT);
#  Nseq(M)@batloop(){
	ql_b := oid(imgNr);
	rl_b := find(imgs,"Ib");
	sl_b := insert(rl_b,ql_b,nil);
#    imgs.find("Ib").insert(oid(imgNr),nil);
	tl_b := %(pl_bT,44);
	ul_b := find(imgs,"Ix");
	vl_b := insert(ul_b,nil,tl_b);
#    imgs.find("Ix").insert(nil, ($t % 44));
	wl_b := /(pl_bT,44);
	xl_b := find(imgs,"Iy");
	yl_b := insert(xl_b,nil,wl_b);
#    imgs.find("Iy").insert(nil, ($t / 44));
redo	pl_b;
end	pl_b;
#  }
	am_b := randprob(C);
	bm_b := multiplex.flt(am_b);
	cm_b := find(src_gmm,"Prior");
	dm_b := insert(cm_b,bm_b);
#  src_gmm.find("Prior").insert( [flt](randprob(C)) );
barrier	em_b:= bunStream(cseq,em_bH,em_bT);
#  cseq@batloop(){
#    # NOTE: was RAND_MAX + 1.0LL
	fm_b := find(src_gmm,"Mean");
#    [insert]( src_gmm.find("Mean"), const nil,
	gm_b := randseq(N);
	hm_b := +(RAND_MAX,1.0);
	im_b := /(hm_b,255);
	jm_b := multiplex./(gm_b,im_b);
	km_b := reverse(jm_b);
	lm_b := number(km_b);
	mm_b := reverse(lm_b);
	nm_b := multiplex.insert(fm_b,nil,mm_b);
#      [/]( randseq(N), const (RAND_MAX + 1.0) / 255).reverse.number.reverse );
	om_b := find(src_gmm,"Covar");
#    [insert]( src_gmm.find("Covar"), const nil,
	pm_b := randseq(N);
	qm_b := +(RAND_MAX,1.0);
	rm_b := /(qm_b,128);
	sm_b := multiplex./(pm_b,rm_b);
	tm_b := reverse(sm_b);
	um_b := number(tm_b);
	vm_b := reverse(um_b);
	wm_b := multiplex.insert(om_b,nil,vm_b);
#      [/]( randseq(N), const (RAND_MAX + 1.0) / 128).reverse.number.reverse );
redo	em_b;
end	em_b;
#  }
	xm_b := oid(imgNr);
	ym_b := _x(cseq);
	an_b := project(ym_b,xm_b);
	bn_b := reverse(an_b);
	cn_b := find(src_gmm,"mImgIdx");
	dn_b := insert(cn_b,bn_b);
#  src_gmm.find("mImgIdx").insert(_x(cseq).project(const oid(imgNr)).reverse);
	en_b := _x(cseq);
	fn_b := reverse(en_b);
	gn_b := find(src_gmm,"mCIdx");
	hn_b := insert(gn_b,fn_b);
#  src_gmm.find("mCIdx").insert(_x(cseq).reverse);
#    # bug with first insert in table
	in_b := find(src_gmm,"mImgIdx");
	jn_b := oid(0);
	kn_b := reverse(in_b);
	ln_b := setSequenceBase(kn_b,jn_b);
	mn_b := reverse(ln_b);
#  src_gmm.find("mImgIdx").reverse.setSequenceBase(oid(0)).reverse;
	nn_b := find(src_gmm,"mCIdx");
	on_b := oid(0);
	pn_b := reverse(nn_b);
	qn_b := setSequenceBase(pn_b,on_b);
	rn_b := reverse(qn_b);
#  src_gmm.find("mCIdx").reverse.setSequenceBase(oid(0)).reverse;
#  
##line 655 "../../../src/gmm/gmm.mx"
	sn_b := find(src_gmm,"init_variances");
	tn_b := access(sn_b,BAT_READ);
#  access( src_gmm.find("init_variances"), BAT_READ );
	un_b := find(src_gmm,"Prior");
	vn_b := access(un_b,BAT_READ);
#  access( src_gmm.find("Prior"), BAT_READ );
	wn_b := find(src_gmm,"mImgIdx");
	xn_b := access(wn_b,BAT_READ);
#  access( src_gmm.find("mImgIdx"), BAT_READ );
	yn_b := find(src_gmm,"mCIdx");
	ao_b := access(yn_b,BAT_READ);
#  access( src_gmm.find("mCIdx"), BAT_READ );
	bo_b := find(src_gmm,"Mean");
barrier	co_b:= bunStream(bo_b,co_bH,co_bT);
	do_b := access(co_bT,BAT_READ);
redo	co_b;
end	co_b;
#  src_gmm.find("Mean")@batloop{  access($t, BAT_READ); }
	eo_b := find(src_gmm,"Covar");
barrier	fo_b:= bunStream(eo_b,fo_bH,fo_bT);
	go_b := access(fo_bT,BAT_READ);
redo	fo_b;
end	fo_b;
#  src_gmm.find("Covar")@batloop{ access($t, BAT_READ); }
#
#
##line 1685 "../../../src/gmm/gmm.mx"
#
	ho_b := oid(imgNr);
	aSampleImg:= gmmsamp_diag(M,ho_b,src_gmm);
#  VAR aSampleImg := gmmsamp_diag(M, oid(imgNr), src_gmm);
#  {
	io_b := find(aSampleImg,"Samples");
	imgSamples:= multiplex.nestedop("sht",io_b);
#    VAR imgSamples := [nestedop]( "sht", aSampleImg.find("Samples") );
#    [insert](
	jo_b := find(imgs,"Coeffs");
#      imgs.find("Coeffs"),
#      imgSamples
	ko_b := multiplex.insert(jo_b,imgSamples);
#    );
#    commit;
#  }
#  
##line 663 "../../../src/gmm/gmm.mx"
	lo_b := find(imgs,"Coeffs");
barrier	mo_b:= bunStream(lo_b,mo_bH,mo_bT);
	no_b := access(mo_bT,BAT_READ);
redo	mo_b;
end	mo_b;
#  imgs.find("Coeffs")@batloop{ access($t, BAT_READ); }
barrier	oo_b:= bunStream(imgs,oo_bH,oo_bT);
	po_b := access(oo_bT,BAT_READ);
redo	oo_b;
end	oo_b;
#  imgs@batloop(){ access($t, BAT_READ); }
#
#
##line 1695 "../../../src/gmm/gmm.mx"
#
#
#
##line 1805 "../../../src/gmm/gmm.mx"
#
	qo_b := :+=(imgNr,1);
#    imgNr :+= 1;
redo	mk_b;
end	nk_b;
end	mk_b;
#  }
##  testmodels.insert( "coll",  imgs );
##  testmodels.insert( "src",   src_gmm );
#
	gmm:= initGMM(imgs);
#  VAR gmm := initGMM( imgs );
##  testmodels.insert( "init",  gmm );
#
#
##line 1816 "../../../src/gmm/gmm.mx"
	ro_b := debug("EM model training");
#  debug("EM model training");
	EM_coll:= take("EM_coll");
	EM_coll := imgs;
#  EM_coll  := imgs;
	EM_model:= take("EM_model");
	EM_model := gmm;
#  EM_model := gmm;
	src_gmm := nil;
#    src_gmm := nil;
	imgs := nil;
#    imgs := nil;
	gmm := nil;
#    gmm  := nil;
#    #VAR gmmnew := EM(imgs, gmm);
	gmmnew:= EM_globalmodel();
#  VAR gmmnew := EM_globalmodel();
	so_b := insert(testmodels,"final",gmmnew);
#  testmodels.insert( "final", gmmnew );
#
#  # @@imgop(imgs,persists,false)@
#  # @@modelop(src_gmm,persists,false)@
#
	return testmodels;
#  RETURN testmodels;
end function;
#}
##VAR testmodels := test_EM(128,1320);
##VAR testmodels := test_EM(10,100);
#
#
#
##line 1838 "../../../src/gmm/gmm.mx"
function classify(coeffs:bat[int,bat], gmm:bat[str,bat]):bat[void,TCluster];
#  PROC classify( bat[int,bat] coeffs, bat[str,bat] gmm ): bat[void,TCluster] := {
#    
##line 1331 "../../../src/gmm/gmm.mx"
#  
##line 1305 "../../../src/gmm/gmm.mx"
	covar:= find(gmm,"Covar");
#  VAR covar    := gmm.find("Covar");
	covar := multiplex.nestedop("dbl",covar);
#                  covar := [nestedop]( "dbl", covar);
#  
##line 107 "../../../src/gmm/gmm.mx"
	to_b := htype(covar);
	uo_b := count(covar);
	ivariances:= new(to_b,bat,uo_b);
#  VAR ivariances := new(covar.htype,bat,covar.count);
#  {
	ivariances_lock:= lock_create();
#    VAR ivariances_lock := lock_create();
	Nthreads:= take("Nthreads");
barrier	vo_b:= bunStream(Nthreads,vo_bH,vo_bT);
#    covar@ [Nthreads]batloop(){
#      VAR _ivariances_result := [inv]($t
	_ivariances_result:= multiplex.inv(vo_bT);
#	   );
	wo_b := lock_set(ivariances_lock);
#      lock_set(ivariances_lock);
	xo_b := insert(ivariances,vo_bH,_ivariances_result);
#      ivariances.insert($h,_ivariances_result);
	yo_b := lock_unset(ivariances_lock);
#      lock_unset(ivariances_lock);
redo	vo_b;
end	vo_b;
#    }
	ap_b := lock_destroy(ivariances_lock);
#    lock_destroy(ivariances_lock);
#  }
#
#
##line 1307 "../../../src/gmm/gmm.mx"
#
	covar := nil;
#                  covar  := nil;
#  
##line 130 "../../../src/gmm/gmm.mx"
#VAR isqrtdet;
#
##line 127 "../../../src/gmm/gmm.mx"
#
##line 167 "../../../src/gmm/gmm.mx"
#  {
	isqrtdet_a:= fetch(ivariances,0);
	isqrtdet_e:= fetch(ivariances,4);
#    VAR isqrtdet_a := ivariances.fetch(0);    VAR isqrtdet_e := ivariances.fetch(4);
	isqrtdet_b:= fetch(ivariances,1);
	isqrtdet_f:= fetch(ivariances,5);
#    VAR isqrtdet_b := ivariances.fetch(1);    VAR isqrtdet_f := ivariances.fetch(5);
	isqrtdet_c:= fetch(ivariances,2);
	isqrtdet_g:= fetch(ivariances,6);
#    VAR isqrtdet_c := ivariances.fetch(2);    VAR isqrtdet_g := ivariances.fetch(6);
	isqrtdet_d:= fetch(ivariances,3);
	isqrtdet_h:= fetch(ivariances,7);
#    VAR isqrtdet_d := ivariances.fetch(3);    VAR isqrtdet_h := ivariances.fetch(7);
#    
##line 157 "../../../src/gmm/gmm.mx"
#    # perform four operations isqrtdet_a in parallel
#    {
#      {|
barrier	bp_b:= true;
#	
##line 147 "../../../src/gmm/gmm.mx"
#      # perform two operations isqrtdet_a in parallel
#      {
#	{|
barrier	cp_b:= true;
	BAT_WRITE:= take("BAT_WRITE");
	dp_b := multiplex.*(isqrtdet_a,isqrtdet_b);
	isqrtdet_a := access(dp_b,BAT_WRITE);
#	   isqrtdet_a := [*](isqrtdet_a,isqrtdet_b).access(BAT_WRITE);
	isqrtdet_c := multiplex.*(isqrtdet_c,isqrtdet_d);
#	   isqrtdet_c := [*](isqrtdet_c,isqrtdet_d);
end	cp_b;
#	 |}
	ep_b := multiplex.:*=(isqrtdet_a,isqrtdet_c);
#	 [:*=](isqrtdet_a,isqrtdet_c);
#      }
#
#
##line 160 "../../../src/gmm/gmm.mx"
#
#	
##line 147 "../../../src/gmm/gmm.mx"
#      # perform two operations isqrtdet_e in parallel
#      {
#	{|
barrier	fp_b:= true;
	gp_b := multiplex.*(isqrtdet_e,isqrtdet_f);
	isqrtdet_e := access(gp_b,BAT_WRITE);
#	   isqrtdet_e := [*](isqrtdet_e,isqrtdet_f).access(BAT_WRITE);
	isqrtdet_g := multiplex.*(isqrtdet_g,isqrtdet_h);
#	   isqrtdet_g := [*](isqrtdet_g,isqrtdet_h);
end	fp_b;
#	 |}
	hp_b := multiplex.:*=(isqrtdet_e,isqrtdet_g);
#	 [:*=](isqrtdet_e,isqrtdet_g);
#      }
#
#
##line 161 "../../../src/gmm/gmm.mx"
#
end	bp_b;
#       |}
	ip_b := multiplex.:*=(isqrtdet_a,isqrtdet_e);
#       [:*=](isqrtdet_a,isqrtdet_e);      
#    }
#
#
##line 172 "../../../src/gmm/gmm.mx"
#
	isqrtdet := isqrtdet_a;
#    isqrtdet := isqrtdet_a;
#  }
#
#
##line 127 "../../../src/gmm/gmm.mx"
#
#
#
##line 131 "../../../src/gmm/gmm.mx"
#
#
#
##line 1309 "../../../src/gmm/gmm.mx"
#
	isqrtdet := multiplex.sqrt(isqrtdet);
#  isqrtdet     := [sqrt](isqrtdet);
#  
##line 1227 "../../../src/gmm/gmm.mx"
#VAR xs;
#
##line 1224 "../../../src/gmm/gmm.mx"
#
##line 1240 "../../../src/gmm/gmm.mx"
	jp_b := htype(coeffs);
	kp_b := count(coeffs);
	xs := new(jp_b,bat,kp_b);
#  xs := new(coeffs.htype,bat,coeffs.count);
	xs_lock:= lock_create();
#  VAR xs_lock := lock_create();
barrier	lp_b:= bunStream(Nthreads,lp_bH,lp_bT);
#  coeffs@ [Nthreads]batloop(){
	xIdx:= take("xIdx");
	_xs_result:= join(xIdx,lp_bT);
#    VAR _xs_result := join( xIdx, $t );
	mp_b := lock_set(xs_lock);
#    lock_set(xs_lock);
	np_b := insert(xs,lp_bH,_xs_result);
#    xs.insert( $h, _xs_result );
	op_b := lock_unset(xs_lock);
#    lock_unset(xs_lock);
redo	lp_b;
end	lp_b;
#  }
	pp_b := lock_destroy(xs_lock);
#  lock_destroy(xs_lock);
#
#
##line 1224 "../../../src/gmm/gmm.mx"
#
#
#
##line 1228 "../../../src/gmm/gmm.mx"
#
#
#
##line 1311 "../../../src/gmm/gmm.mx"
#
	qp_b := find(gmm,"Mean");
	means:= multiplex.join(cIdx,qp_b);
#  VAR means    := [join]( const cIdx, gmm.find("Mean") );
	ivars:= multiplex.join(cIdx,ivariances);
#  VAR ivars    := [join]( const cIdx, ivariances );
	diffs:= multiplex.nestedop("dmahalanobis_i_diagcov",xs,means,ivars);
#  VAR diffs    := [nestedop]("dmahalanobis_i_diagcov",xs,means,ivars);
#  
##line 130 "../../../src/gmm/gmm.mx"
#VAR dists;
#
##line 127 "../../../src/gmm/gmm.mx"
#
##line 167 "../../../src/gmm/gmm.mx"
#  {
	dists_a:= fetch(diffs,0);
	dists_e:= fetch(diffs,4);
#    VAR dists_a := diffs.fetch(0);    VAR dists_e := diffs.fetch(4);
	dists_b:= fetch(diffs,1);
	dists_f:= fetch(diffs,5);
#    VAR dists_b := diffs.fetch(1);    VAR dists_f := diffs.fetch(5);
	dists_c:= fetch(diffs,2);
	dists_g:= fetch(diffs,6);
#    VAR dists_c := diffs.fetch(2);    VAR dists_g := diffs.fetch(6);
	dists_d:= fetch(diffs,3);
	dists_h:= fetch(diffs,7);
#    VAR dists_d := diffs.fetch(3);    VAR dists_h := diffs.fetch(7);
#    
##line 157 "../../../src/gmm/gmm.mx"
#    # perform four operations dists_a in parallel
#    {
#      {|
barrier	rp_b:= true;
#	
##line 147 "../../../src/gmm/gmm.mx"
#      # perform two operations dists_a in parallel
#      {
#	{|
barrier	sp_b:= true;
	tp_b := multiplex.+(dists_a,dists_b);
	dists_a := access(tp_b,BAT_WRITE);
#	   dists_a := [+](dists_a,dists_b).access(BAT_WRITE);
	dists_c := multiplex.+(dists_c,dists_d);
#	   dists_c := [+](dists_c,dists_d);
end	sp_b;
#	 |}
	up_b := multiplex.:+=(dists_a,dists_c);
#	 [:+=](dists_a,dists_c);
#      }
#
#
##line 160 "../../../src/gmm/gmm.mx"
#
#	
##line 147 "../../../src/gmm/gmm.mx"
#      # perform two operations dists_e in parallel
#      {
#	{|
barrier	vp_b:= true;
	wp_b := multiplex.+(dists_e,dists_f);
	dists_e := access(wp_b,BAT_WRITE);
#	   dists_e := [+](dists_e,dists_f).access(BAT_WRITE);
	dists_g := multiplex.+(dists_g,dists_h);
#	   dists_g := [+](dists_g,dists_h);
end	vp_b;
#	 |}
	xp_b := multiplex.:+=(dists_e,dists_g);
#	 [:+=](dists_e,dists_g);
#      }
#
#
##line 161 "../../../src/gmm/gmm.mx"
#
end	rp_b;
#       |}
	yp_b := multiplex.:+=(dists_a,dists_e);
#       [:+=](dists_a,dists_e);      
#    }
#
#
##line 172 "../../../src/gmm/gmm.mx"
#
	dists := dists_a;
#    dists := dists_a;
#  }
#
#
##line 127 "../../../src/gmm/gmm.mx"
#
#
#
##line 131 "../../../src/gmm/gmm.mx"
#
#
#
##line 1315 "../../../src/gmm/gmm.mx"
#
	xs := nil;
#                  xs     := nil;
	diffs := nil;
#                  diffs  := nil;
	means := nil;
#		  means  := nil;
	ivars := nil;
#		  ivars  := nil;
	ivariances := nil;
#		  ivariances := nil;
	isdet:= join(cIdx,isqrtdet);
#  VAR isdet    := join( cIdx, isqrtdet );
	N:= take("N");
	act:= multiplex.multivariate_gaussian_pdf_diagcov(dists,isdet,N);
#  VAR act      := [multivariate_gaussian_pdf_diagcov]( dists, isdet, N );
	dists := nil;
#                  dists  := nil;
	isdet := nil;
#                  isdet  := nil;
#
#
##line 1331 "../../../src/gmm/gmm.mx"
#
	aq_b := find(gmm,"Prior");
	bq_b := multiplex.dbl(aq_b);
	priors:= join(cIdx,bq_b);
#  VAR priors   := join( cIdx, [dbl](gmm.find("Prior")) );
	act := multiplex.*(act,priors);
#  act          := [*]( act, priors );
	cq_b := reverse(xIdx);
	dq_b := join(cq_b,act);
	s:= pump.sum(dq_b);
#  VAR s        := {sum}( xIdx.reverse.join(act) );
##  s            := [ [>](s,const MIN_S)? s : const MIN_S ];
##  s            := [ [!=](s,const dbl(0))? s : const 1.0LL ];
	eq_b := multiplex.>(s,MIN_S);
	fq_b := M2m.ifthen(eq_b,s,1.0LL);
	gq_b:= M2m.batconstruct1(fq_b);
	s := gq_b;
#  s            := [ [>](s,const MIN_S)? s : const 1.0LL ];
	hq_b := join(xIdx,s);
	post:= multiplex./(act,hq_b);
#  VAR post     := [/](act,xIdx.join(s));
	priors := nil;
#                  priors := nil;
	act := nil;
#                  act    := nil;
#
#
##line 1839 "../../../src/gmm/gmm.mx"
#
	pmax:= fetch(post,0);
#    VAR pmax := post.fetch(0);
	iq_b := mirror(post);
	jq_b := fetch(iq_b,0);
	kq_b := encode(TCluster,jq_b);
	res:= project(pmax,kq_b);
#    VAR res  := pmax.project(const encode(TCluster, post.mirror.fetch(0)));
barrier	lq_b:= bunStream(post,lq_bH,lq_bT);
#    post@batloop(){
	pcomp:= multiplex.<=(lq_bT,pmax);
#      VAR pcomp := [<=]($t,pmax);
	mq_b := encode(TCluster,lq_bH);
	nq_b := M2m.ifthen(pcomp,res,mq_b);
	oq_b:= M2m.batconstruct1(nq_b);
	res := oq_b;
#      res :=  [ pcomp ?  res : const encode(TCluster, $h) ];
	pq_b := M2m.ifthen(pcomp,pmax,lq_bT);
	qq_b:= M2m.batconstruct1(pq_b);
	pmax := qq_b;
#      pmax := [ pcomp ? pmax : $t ];
redo	lq_b;
end	lq_b;
#    }
	return res;
#    RETURN res;
end function;
#  }
#
#
##line 1853 "../../../src/gmm/gmm.mx"
function vectostr(x:bat[any,dbl]):str;
#  PROC vectostr( BAT[any,dbl] x ): str := {
	s:= "< ";
#    VAR s := "< ";
	rq_b := fetch(x,0);
	sq_b := sprintf("%4.0lf",rq_b);
	tq_b := :+=(s,sq_b);
#    s :+= sprintf( "%4.0lf", x.fetch(0) );
	uq_b := count(x);
	vq_b := -(uq_b,1);
	wq_b := slice(x,1,vq_b);
barrier	xq_b:= bunStream(wq_b,xq_bH,xq_bT);
#    x.slice(1, x.count - 1)@batloop(){
	yq_b := sprintf(", %4.0lf",xq_bT);
	ar_b := :+=(s,yq_b);
#      s :+= sprintf( ", %4.0lf", $t );
redo	xq_b;
end	xq_b;
#    }
	br_b := :+=(s," >");
#    s :+= " >";
	return s;
#    RETURN s;
end function;
#  }
function vectostr(x:bat[any,flt]):str;
#  PROC vectostr( BAT[any,flt] x ): str := {
	s:= "< ";
#    VAR s := "< ";
	cr_b := fetch(x,0);
	dr_b := sprintf("%4.0f",cr_b);
	er_b := :+=(s,dr_b);
#    s :+= sprintf( "%4.0f", x.fetch(0) );
	fr_b := count(x);
	gr_b := -(fr_b,1);
	hr_b := slice(x,1,gr_b);
barrier	ir_b:= bunStream(hr_b,ir_bH,ir_bT);
#    x.slice(1, x.count - 1)@batloop(){
	jr_b := sprintf(", %4.0f",ir_bT);
	kr_b := :+=(s,jr_b);
#      s :+= sprintf( ", %4.0f", $t );
redo	ir_b;
end	ir_b;
#    }
	lr_b := :+=(s," >");
#    s :+= " >";
	return s;
#    RETURN s;
end function;
#  }
#
#  CONST infosep :=
	infosep := "------------------------------------------------------------";
#    "------------------------------------------------------------";
function gmminfo(gmm:bat[str,bat]):bat[void,str];
#  PROC gmminfo( BAT[str,bat] gmm ): BAT[void,str] := {
	mr_b := oid(0);
	nr_b := new(void,str);
	s:= setSequenceBase(nr_b,mr_b);
#    VAR s := new(void,str).setSequenceBase(oid(0));
	or_b := find(gmm,"mImgIdx");
	imgidx:= reverse(or_b);
#    VAR imgidx := gmm.find("mImgIdx").reverse;
	oldimgid:= fetch(imgidx,0);
#    VAR oldimgid := imgidx.fetch(0);
	imgid:= oldimgid;
#    VAR imgid := oldimgid;
	pr_b := find(gmm,"mImgIdx");
	qr_b := kunique(pr_b);
	rr_b := sort(qr_b);
barrier	sr_b:= bunStream(rr_b,sr_bH,sr_bT);
#    gmm.find("mImgIdx").kunique.sort@batloop(){
	imgid:= sr_bH;
#      VAR imgid := $h;
	tr_b := sprintf("-- Img %3d --",imgid);
	ur_b := +(tr_b,infosep);
	vr_b := insert(s,nil,ur_b);
#      s.insert( nil, sprintf("-- Img %3d --", imgid) + infosep );
#
	wr_b := select(imgidx,sr_bH);
	xr_b := find(gmm,"mCIdx");
	yr_b := reverse(xr_b);
	as_b := mirror(wr_b);
	bs_b := join(as_b,yr_b);
	cs_b := reverse(bs_b);
	ds_b := sort(cs_b);
barrier	es_b:= bunStream(ds_b,es_bH,es_bT);
#      imgidx.select($h).mirror.join(gmm.find("mCIdx").reverse).reverse.sort@batloop(){
	fs_b := find(gmm,"Prior");
	gs_b := find(fs_b,es_bT);
	hs_b := dbl(gs_b);
#	s.insert( nil, sprintf( "prior[%d]: %.3lf\t", $h, dbl(find(gmm.find("Prior"), $t)) ) +
	is_b := find(gmm,"Mean");
	js_b := multiplex.find(is_b,es_bT);
	ks_b := vectostr(js_b);
	ls_b := sprintf("prior[%d]: %.3lf\t",es_bH,hs_b);
	ms_b := +("mean:  ",ks_b);
	ns_b := +(ls_b,ms_b);
	os_b := insert(s,nil,ns_b);
#		       "mean:  " + vectostr([find](gmm.find("Mean" ),$t)) );
	ps_b := find(gmm,"Covar");
	qs_b := multiplex.find(ps_b,es_bT);
	rs_b := vectostr(qs_b);
	ss_b := +("            \tcovar: ",rs_b);
	ts_b := insert(s,nil,ss_b);
#	s.insert( nil, "            \tcovar: " +vectostr([find](gmm.find("Covar"),$t)) );
redo	es_b;
end	es_b;
#      }
redo	sr_b;
end	sr_b;
#    }
	us_b := +("-------------",infosep);
	vs_b := insert(s,nil,us_b);
#    s.insert( nil, "-------------" + infosep );
	return s;
#    RETURN s;
end function;
#  }
#
function printmodel(gmm:bat[str,bat]):void;
#  PROC printmodel( BAT[str,bat] gmm ): void := {
	g:= gmminfo(gmm);
#    VAR g := gmminfo(gmm);
	ws_b := project(g,"%s\n");
	xs_b := multiplex.printf(ws_b,g);
#    [printf]( g.project("%s\n"), g );
end function;
#  }
function printmodels(gmma:bat[str,bat], gmmb:bat[str,bat]):void;
#  PROC printmodels( BAT[str,bat] gmma, BAT[str,bat] gmmb ): void := {
	ga:= gmminfo(gmma);
#    VAR ga := gmminfo(gmma);
	gb:= gmminfo(gmmb);
#    VAR gb := gmminfo(gmmb);
	ys_b := multiplex.printf("%s\t|\t%s\n",ga,gb);
#    [printf]( const "%s\t|\t%s\n", ga, gb );
end function;
#  }
#
##  printmodels( testmodels.find("src"), 
##               testmodels.find("final") );
#
#
##line 1909 "../../../src/gmm/gmm.mx"
function sampleQueries(Nqimg:int, testmodels:bat[str,bat]):bat[str,bat];
#  PROC sampleQueries(int Nqimg, BAT[str,bat] testmodels):bat[str,bat] := {
	qgmm:= new(str,bat);
#    VAR qgmm := new(str,bat);
#    {
	gmm:= find(testmodels,"src");
#      VAR gmm   := testmodels.find("src");
	at_b := find(testmodels,"coll");
	bt_b := find(at_b,"I");
	qimgs:= sample(bt_b,Nqimg);
#      VAR qimgs := testmodels.find("coll").find("I").sample(Nqimg);
	ct_b := mirror(qimgs);
	dt_b := find(gmm,"mImgIdx");
	qimgidx:= join(ct_b,dt_b);
#      VAR qimgidx := join(qimgs.mirror, gmm.find("mImgIdx"));
#      
##line 634 "../../../src/gmm/gmm.mx"
	et_b := oid(0);
	ft_b := reverse(qimgidx);
	gt_b := mark(ft_b,et_b);
	fIdx:= reverse(gt_b);
#VAR fIdx           := qimgidx.reverse.mark(oid(0)).reverse;
#{
	ht_b := find(gmm,"mImgIdx");
	it_b := reverse(ht_b);
	convImgIdx:= join(fIdx,it_b);
#  VAR convImgIdx     := join( fIdx, gmm.find("mImgIdx").reverse );
	jt_b := find(gmm,"mCIdx");
	kt_b := reverse(jt_b);
	convCIdx:= join(fIdx,kt_b);
#  VAR convCIdx       := join( fIdx, gmm.find("mCIdx").reverse );
	lt_b := reverse(convImgIdx);
	mt_b := insert(qgmm,"mImgIdx",lt_b);
#  qgmm.insert( "mImgIdx", convImgIdx.reverse );
	nt_b := reverse(convCIdx);
	ot_b := insert(qgmm,"mCIdx",nt_b);
#  qgmm.insert( "mCIdx",   convCIdx.reverse );
#
	pt_b := find(gmm,"Prior");
	qt_b := join(fIdx,pt_b);
	rt_b := insert(qgmm,"Prior",qt_b);
#  qgmm.insert( "Prior", join(fIdx, gmm.find("Prior")) );
	st_b := find(gmm,"Mean");
	tt_b := multiplex.join(fIdx,st_b);
	ut_b := insert(qgmm,"Mean",tt_b);
#  qgmm.insert( "Mean",  [join](const fIdx, gmm.find("Mean")) );
	vt_b := find(gmm,"Covar");
	wt_b := multiplex.join(fIdx,vt_b);
	xt_b := insert(qgmm,"Covar",wt_b);
#  qgmm.insert( "Covar", [join](const fIdx, gmm.find("Covar")) );
#
	yt_b := find(gmm,"init_variances");
	au_b := join(fIdx,yt_b);
	bu_b := insert(qgmm,"init_variances",au_b);
#  qgmm.insert( "init_variances", join(fIdx, gmm.find("init_variances")) );
#}
#
#
##line 1915 "../../../src/gmm/gmm.mx"
#
	sessionId:= take("sessionId");
	cu_b := +(sessionId,"_query");
	du_b := +("gmm",cu_b);
	eu_b := renameGMM(qgmm,du_b);
#      renameGMM(qgmm,"gmm" + sessionId + "_query");
#      
##line 655 "../../../src/gmm/gmm.mx"
	fu_b := find(qgmm,"init_variances");
	BAT_READ:= take("BAT_READ");
	gu_b := access(fu_b,BAT_READ);
#  access( qgmm.find("init_variances"), BAT_READ );
	hu_b := find(qgmm,"Prior");
	iu_b := access(hu_b,BAT_READ);
#  access( qgmm.find("Prior"), BAT_READ );
	ju_b := find(qgmm,"mImgIdx");
	ku_b := access(ju_b,BAT_READ);
#  access( qgmm.find("mImgIdx"), BAT_READ );
	lu_b := find(qgmm,"mCIdx");
	mu_b := access(lu_b,BAT_READ);
#  access( qgmm.find("mCIdx"), BAT_READ );
	nu_b := find(qgmm,"Mean");
barrier	ou_b:= bunStream(nu_b,ou_bH,ou_bT);
	pu_b := access(ou_bT,BAT_READ);
redo	ou_b;
end	ou_b;
#  qgmm.find("Mean")@batloop{  access($t, BAT_READ); }
	qu_b := find(qgmm,"Covar");
barrier	ru_b:= bunStream(qu_b,ru_bH,ru_bT);
	su_b := access(ru_bT,BAT_READ);
redo	ru_b;
end	ru_b;
#  qgmm.find("Covar")@batloop{ access($t, BAT_READ); }
#
#
##line 1917 "../../../src/gmm/gmm.mx"
#
#    }
	return qgmm;
#    RETURN qgmm;
end function;
#  }
#
#
##line 1926 "../../../src/gmm/gmm.mx"
#  # VAR gmm_q := sampleQueries(4,testmodels);
#  # VAR gmm_i := testmodels.find("final");
#
function RSL(gmm_q:bat[str,bat], gmm_i:bat[str,bat]):void;
#  PROC RSL( bat[str,bat] gmm_q, bat[str,bat] gmm_i ):void := {
	tu_b := find(gmm_q,"mCIdx");
	uu_b := reverse(tu_b);
	vu_b := find(gmm_i,"mCIdx");
	cqciIdx:= join(uu_b,vu_b);
#    VAR cqciIdx     := join(gmm_q.find("mCIdx").reverse, gmm_i.find("mCIdx"));
	ciIdx:= nx(cqciIdx);
#    VAR ciIdx	    := nx(cqciIdx);
	wu_b := xn(cqciIdx);
	cqIdx:= reverse(wu_b);
#    VAR cqIdx	    := xn(cqciIdx).reverse;
#
	xu_b := find(gmm_q,"mImgIdx");
	yu_b := reverse(xu_b);
#    VAR gqiIdx      := join(gmm_q.find("mImgIdx").reverse, 
	av_b := find(gmm_q,"mImgIdx");
	bv_b := reverse(cqIdx);
	cv_b := join(av_b,bv_b);
	gqiIdx:= join(yu_b,cv_b);
#			 join(gmm_q.find("mImgIdx"), cqIdx.reverse));
	giIdx:= nx(gqiIdx);
#    VAR giIdx       := nx(gqiIdx);
#
	qiIdx:= join(gqiIdx,ciIdx);
#    VAR qiIdx       := join(gqiIdx, ciIdx);
	dv_b := xn(qiIdx);
	qIdx:= reverse(dv_b);
#    VAR qIdx        := xn(qiIdx).reverse;
	iIdx:= nx(qiIdx);
#    VAR iIdx        := nx(qiIdx);
#
#
##line 1944 "../../../src/gmm/gmm.mx"
	ev_b := find(gmm_i,"Prior");
	logpriors_i:= multiplex.log(ev_b);
#    VAR logpriors_i := [log](gmm_i.find("Prior"));
	covar_i:= find(gmm_i,"Covar");
#    VAR covar_i     := gmm_i.find("Covar");
#    
##line 130 "../../../src/gmm/gmm.mx"
#VAR det_i;
#
##line 127 "../../../src/gmm/gmm.mx"
#
##line 167 "../../../src/gmm/gmm.mx"
#  {
	det_i_a:= fetch(covar_i,0);
	det_i_e:= fetch(covar_i,4);
#    VAR det_i_a := covar_i.fetch(0);    VAR det_i_e := covar_i.fetch(4);
	det_i_b:= fetch(covar_i,1);
	det_i_f:= fetch(covar_i,5);
#    VAR det_i_b := covar_i.fetch(1);    VAR det_i_f := covar_i.fetch(5);
	det_i_c:= fetch(covar_i,2);
	det_i_g:= fetch(covar_i,6);
#    VAR det_i_c := covar_i.fetch(2);    VAR det_i_g := covar_i.fetch(6);
	det_i_d:= fetch(covar_i,3);
	det_i_h:= fetch(covar_i,7);
#    VAR det_i_d := covar_i.fetch(3);    VAR det_i_h := covar_i.fetch(7);
#    
##line 157 "../../../src/gmm/gmm.mx"
#    # perform four operations det_i_a in parallel
#    {
#      {|
barrier	fv_b:= true;
#	
##line 147 "../../../src/gmm/gmm.mx"
#      # perform two operations det_i_a in parallel
#      {
#	{|
barrier	gv_b:= true;
	BAT_WRITE:= take("BAT_WRITE");
	hv_b := multiplex.*(det_i_a,det_i_b);
	det_i_a := access(hv_b,BAT_WRITE);
#	   det_i_a := [*](det_i_a,det_i_b).access(BAT_WRITE);
	det_i_c := multiplex.*(det_i_c,det_i_d);
#	   det_i_c := [*](det_i_c,det_i_d);
end	gv_b;
#	 |}
	iv_b := multiplex.:*=(det_i_a,det_i_c);
#	 [:*=](det_i_a,det_i_c);
#      }
#
#
##line 160 "../../../src/gmm/gmm.mx"
#
#	
##line 147 "../../../src/gmm/gmm.mx"
#      # perform two operations det_i_e in parallel
#      {
#	{|
barrier	jv_b:= true;
	kv_b := multiplex.*(det_i_e,det_i_f);
	det_i_e := access(kv_b,BAT_WRITE);
#	   det_i_e := [*](det_i_e,det_i_f).access(BAT_WRITE);
	det_i_g := multiplex.*(det_i_g,det_i_h);
#	   det_i_g := [*](det_i_g,det_i_h);
end	jv_b;
#	 |}
	lv_b := multiplex.:*=(det_i_e,det_i_g);
#	 [:*=](det_i_e,det_i_g);
#      }
#
#
##line 161 "../../../src/gmm/gmm.mx"
#
end	fv_b;
#       |}
	mv_b := multiplex.:*=(det_i_a,det_i_e);
#       [:*=](det_i_a,det_i_e);      
#    }
#
#
##line 172 "../../../src/gmm/gmm.mx"
#
	det_i := det_i_a;
#    det_i := det_i_a;
#  }
#
#
##line 127 "../../../src/gmm/gmm.mx"
#
#
#
##line 131 "../../../src/gmm/gmm.mx"
#
#
#
##line 1946 "../../../src/gmm/gmm.mx"
#
	logdet_i:= multiplex.log(det_i);
#    VAR logdet_i    := [log](det_i);
	ivars_i:= multiplex.nestedop("inv",covar_i);
#    VAR ivars_i     := [nestedop]("inv",covar_i);
#
#
##line 1955 "../../../src/gmm/gmm.mx"
	qivars_i:= multiplex.join(iIdx,ivars_i);
#    VAR qivars_i    := [join](const iIdx, ivars_i);
	covar_q:= find(gmm_q,"Covar");
#    VAR covar_q     := gmm_q.find("Covar");
	qvars_q:= multiplex.join(qIdx,covar_q);
#    VAR qvars_q     := [join](const qIdx, covar_q);
	tmp:= multiplex.nestedop("*",qvars_q,qivars_i);
#    VAR tmp         := [nestedop]("*", qvars_q, qivars_i);
#    
##line 130 "../../../src/gmm/gmm.mx"
#VAR traces;
#
##line 127 "../../../src/gmm/gmm.mx"
#
##line 167 "../../../src/gmm/gmm.mx"
#  {
	traces_a:= fetch(tmp,0);
	traces_e:= fetch(tmp,4);
#    VAR traces_a := tmp.fetch(0);    VAR traces_e := tmp.fetch(4);
	traces_b:= fetch(tmp,1);
	traces_f:= fetch(tmp,5);
#    VAR traces_b := tmp.fetch(1);    VAR traces_f := tmp.fetch(5);
	traces_c:= fetch(tmp,2);
	traces_g:= fetch(tmp,6);
#    VAR traces_c := tmp.fetch(2);    VAR traces_g := tmp.fetch(6);
	traces_d:= fetch(tmp,3);
	traces_h:= fetch(tmp,7);
#    VAR traces_d := tmp.fetch(3);    VAR traces_h := tmp.fetch(7);
#    
##line 157 "../../../src/gmm/gmm.mx"
#    # perform four operations traces_a in parallel
#    {
#      {|
barrier	nv_b:= true;
#	
##line 147 "../../../src/gmm/gmm.mx"
#      # perform two operations traces_a in parallel
#      {
#	{|
barrier	ov_b:= true;
	pv_b := multiplex.+(traces_a,traces_b);
	traces_a := access(pv_b,BAT_WRITE);
#	   traces_a := [+](traces_a,traces_b).access(BAT_WRITE);
	traces_c := multiplex.+(traces_c,traces_d);
#	   traces_c := [+](traces_c,traces_d);
end	ov_b;
#	 |}
	qv_b := multiplex.:+=(traces_a,traces_c);
#	 [:+=](traces_a,traces_c);
#      }
#
#
##line 160 "../../../src/gmm/gmm.mx"
#
#	
##line 147 "../../../src/gmm/gmm.mx"
#      # perform two operations traces_e in parallel
#      {
#	{|
barrier	rv_b:= true;
	sv_b := multiplex.+(traces_e,traces_f);
	traces_e := access(sv_b,BAT_WRITE);
#	   traces_e := [+](traces_e,traces_f).access(BAT_WRITE);
	traces_g := multiplex.+(traces_g,traces_h);
#	   traces_g := [+](traces_g,traces_h);
end	rv_b;
#	 |}
	tv_b := multiplex.:+=(traces_e,traces_g);
#	 [:+=](traces_e,traces_g);
#      }
#
#
##line 161 "../../../src/gmm/gmm.mx"
#
end	nv_b;
#       |}
	uv_b := multiplex.:+=(traces_a,traces_e);
#       [:+=](traces_a,traces_e);      
#    }
#
#
##line 172 "../../../src/gmm/gmm.mx"
#
	traces := traces_a;
#    traces := traces_a;
#  }
#
#
##line 127 "../../../src/gmm/gmm.mx"
#
#
#
##line 131 "../../../src/gmm/gmm.mx"
#
#
#
##line 1959 "../../../src/gmm/gmm.mx"
#
#
#
##line 1966 "../../../src/gmm/gmm.mx"
	vv_b := find(gmm_q,"Mean");
	qmeanq:= multiplex.join(qIdx,vv_b);
#    VAR qmeanq      := [join](const qIdx, gmm_q.find("Mean"));
	wv_b := find(gmm_i,"Mean");
	qmeani:= multiplex.join(iIdx,wv_b);
#    VAR qmeani	    := [join](const iIdx, gmm_i.find("Mean"));
	diffs:= multiplex.nestedop("-",qmeanq,qmeani);
#    VAR diffs       := [nestedop]("-", qmeanq, qmeani);
	diffs := multiplex.square(diffs);
#    diffs           := [square]( diffs );
	diffs := multiplex.nestedop("*",diffs,qivars_i);
#    diffs	    := [nestedop]("*", diffs, qivars_i);
#    
##line 130 "../../../src/gmm/gmm.mx"
#VAR Dmaha;
#
##line 127 "../../../src/gmm/gmm.mx"
#
##line 167 "../../../src/gmm/gmm.mx"
#  {
	Dmaha_a:= fetch(diffs,0);
	Dmaha_e:= fetch(diffs,4);
#    VAR Dmaha_a := diffs.fetch(0);    VAR Dmaha_e := diffs.fetch(4);
	Dmaha_b:= fetch(diffs,1);
	Dmaha_f:= fetch(diffs,5);
#    VAR Dmaha_b := diffs.fetch(1);    VAR Dmaha_f := diffs.fetch(5);
	Dmaha_c:= fetch(diffs,2);
	Dmaha_g:= fetch(diffs,6);
#    VAR Dmaha_c := diffs.fetch(2);    VAR Dmaha_g := diffs.fetch(6);
	Dmaha_d:= fetch(diffs,3);
	Dmaha_h:= fetch(diffs,7);
#    VAR Dmaha_d := diffs.fetch(3);    VAR Dmaha_h := diffs.fetch(7);
#    
##line 157 "../../../src/gmm/gmm.mx"
#    # perform four operations Dmaha_a in parallel
#    {
#      {|
barrier	xv_b:= true;
#	
##line 147 "../../../src/gmm/gmm.mx"
#      # perform two operations Dmaha_a in parallel
#      {
#	{|
barrier	yv_b:= true;
	aw_b := multiplex.+(Dmaha_a,Dmaha_b);
	Dmaha_a := access(aw_b,BAT_WRITE);
#	   Dmaha_a := [+](Dmaha_a,Dmaha_b).access(BAT_WRITE);
	Dmaha_c := multiplex.+(Dmaha_c,Dmaha_d);
#	   Dmaha_c := [+](Dmaha_c,Dmaha_d);
end	yv_b;
#	 |}
	bw_b := multiplex.:+=(Dmaha_a,Dmaha_c);
#	 [:+=](Dmaha_a,Dmaha_c);
#      }
#
#
##line 160 "../../../src/gmm/gmm.mx"
#
#	
##line 147 "../../../src/gmm/gmm.mx"
#      # perform two operations Dmaha_e in parallel
#      {
#	{|
barrier	cw_b:= true;
	dw_b := multiplex.+(Dmaha_e,Dmaha_f);
	Dmaha_e := access(dw_b,BAT_WRITE);
#	   Dmaha_e := [+](Dmaha_e,Dmaha_f).access(BAT_WRITE);
	Dmaha_g := multiplex.+(Dmaha_g,Dmaha_h);
#	   Dmaha_g := [+](Dmaha_g,Dmaha_h);
end	cw_b;
#	 |}
	ew_b := multiplex.:+=(Dmaha_e,Dmaha_g);
#	 [:+=](Dmaha_e,Dmaha_g);
#      }
#
#
##line 161 "../../../src/gmm/gmm.mx"
#
end	xv_b;
#       |}
	fw_b := multiplex.:+=(Dmaha_a,Dmaha_e);
#       [:+=](Dmaha_a,Dmaha_e);      
#    }
#
#
##line 172 "../../../src/gmm/gmm.mx"
#
	Dmaha := Dmaha_a;
#    Dmaha := Dmaha_a;
#  }
#
#
##line 127 "../../../src/gmm/gmm.mx"
#
#
#
##line 131 "../../../src/gmm/gmm.mx"
#
#
#
##line 1971 "../../../src/gmm/gmm.mx"
#
#
	tmp:= multiplex.+(Dmaha,traces);
#    VAR tmp         := [+](Dmaha,traces);
	gw_b := join(iIdx,logdet_i);
	tmp := multiplex.+(gw_b,tmp);
#    tmp             := [+](iIdx.join(logdet_i), tmp);
	hw_b := join(iIdx,logpriors_i);
	compiL:= multiplex.-(hw_b,tmp);
#    VAR compiL	    := [-](iIdx.join(logpriors_i), tmp);
	iw_b := reverse(giIdx);
	jw_b := join(iw_b,compiL);
	maxcompiL:= pump.max(jw_b);
#    VAR maxcompiL   := {max}(giIdx.reverse.join(compiL));
#
	kw_b := find(gmm_q,"Prior");
	lw_b := join(cqIdx,kw_b);
	compqL:= multiplex.*(lw_b,maxcompiL);
#    VAR compqL	    := [*](join(cqIdx,gmm_q.find("Prior")), maxcompiL);
#
#
##line 1983 "../../../src/gmm/gmm.mx"
	mw_b := find(gmm_q,"mImgIdx");
	nw_b := reverse(mw_b);
	imgidx_q:= join(cqIdx,nw_b);
#    VAR imgidx_q    := join( cqIdx, gmm_q.find("mImgIdx").reverse);
	ow_b := find(gmm_i,"mImgIdx");
	pw_b := reverse(ow_b);
	imgidx_i:= join(ciIdx,pw_b);
#    VAR imgidx_i    := join( ciIdx, gmm_i.find("mImgIdx").reverse);
	gimgidx_q:= CTgroup(imgidx_q);
#    VAR gimgidx_q   := CTgroup(imgidx_q);
	gimgidx_i:= CTgroup(gimgidx_q,imgidx_i);
#    VAR gimgidx_i   := CTgroup(gimgidx_q, imgidx_i);
#   
	qw_b := reverse(gimgidx_i);
	rw_b := join(qw_b,compqL);
	RSL:= pump.sum(rw_b);
#    VAR RSL         := {sum}(join( gimgidx_i.reverse, compqL));
#
	sw_b := debug("Results ranked");
#debug("Results ranked");
##      VAR printres  := new(void,str);
##      printres.insert(nil, sprintf( "%3s %3s  %8s\n", "Q", "I", "RSL(Q,I)" ));
##      printres.insert(nil, sprintf( "================\n" ));
##      printres.insert([sprintf]( const "%3d,%3d,%8.lf\n", imgidx_q,imgidx_i, RSL));
##      printres@batloop(){printf("%s",$t);}
#
##    VAR minRSL      := {min}(join(gimgidx_q.reverse, RSL));
end function;
#}
#
#
#
##line 2009 "../../../src/gmm/gmm.mx"
function L2dist(x:bat[any::1,dbl], y:bat[any::1,dbl]):dbl;
#  PROC L2dist( BAT[any::1,dbl] x, BAT[any::1,dbl] y ): dbl := {
	dist:= multiplex.-(x,y);
#    VAR dist := [-](x, y);
	dist := multiplex.*(dist,dist);
#    dist := [*](dist, dist);
	tw_b := sum(dist);
	uw_b := count(dist);
	dist := /(tw_b,uw_b);
#    dist := dist.sum / dist.count;
	return dist;
#    RETURN dist;
end function;
#  }
#
#  # this is really a fitness-join
function mapnearest(ma:bat[int,bat], mb:bat[int,bat]):bat[int,int];
#  PROC mapnearest( BAT[int,bat] ma, BAT[int,bat] mb ): BAT[int,int] := {
	TCluster:= take("TCluster");
	C:= take("C");
	cdist:= new(TCluster,bat,C);
#    VAR cdist := new(TCluster,bat,C);
	cseq:= take("cseq");
barrier	vw_b:= bunStream(cseq,vw_bH,vw_bT);
#    cseq@batloop(){
	csrcoid:= vw_bH;
#      VAR csrcoid := $h;
	csrc:= vw_bT;
#      VAR csrc := $t;
	cdist_c:= new(TCluster,dbl);
#      VAR cdist_c := new(TCluster,dbl);
barrier	ww_b:= bunStream(cseq,ww_bH,ww_bT);
#      cseq@batloop(){
	cnewoid:= ww_bH;
#        VAR cnewoid := $h;
	cnew:= ww_bT;
#	VAR cnew := $t;
#	cdist_c.insert( cnew, 
	xw_b := multiplex.find(ma,csrcoid);
#	  L2dist( [find](ma,csrcoid), 
	yw_b := multiplex.find(mb,cnewoid);
	ax_b := L2dist(xw_b,yw_b);
	bx_b := insert(cdist_c,cnew,ax_b);
#		[find](mb,cnewoid) ) ); 
redo	ww_b;
end	ww_b;
#      }
	cx_b := reverse(cdist_c);
	dx_b := order(cx_b);
	ex_b := insert(cdist,csrc,dx_b);
#      cdist.insert( csrc, cdist_c.reverse.order );
redo	vw_b;
end	vw_b;
#    }
	fx_b := multiplex.fetch(cdist,0);
	return fx_b;
#    RETURN [fetch](cdist, const 0);
end function;
#  }
#
function testclassify(src_gmm:bat[str,bat], gmmnew:bat[str,bat]):void;
#  PROC testclassify( BAT[str,bat] src_gmm, BAT[str,bat] gmmnew ): void := {
	sampleImg:= take("sampleImg");
	gx_b := find(sampleImg,"Samples");
	c:= classify(gx_b,gmmnew);
#    VAR c := classify( sampleImg.find("Samples"), gmmnew );
	hx_b := find(sampleImg,"Clusters");
	ix_b := diff(c,hx_b);
	Nerr:= count(ix_b);
#    VAR Nerr := diff(c, sampleImg.find("Clusters")).count;
#
	Nerrmap:= Nerr;
#    VAR Nerrmap := Nerr;
#      # don't know setoriented solution yet
#      #  VAR cmap := mapnearest( src_gmm.find("Mean"), gmmnew.find("Mean") );
#      #  VAR Nerrmap := diff(c.join(cmap.reverse),sampleImg.find("Clusters")).count;
	jx_b := "Estimated # misclassified blocks: %4d (raw: %4d)\n";
	kx_b := printf(jx_b,Nerrmap,Nerr);
#    printf("Estimated # misclassified blocks: %4d (raw: %4d)\n", Nerrmap, Nerr);
end function;
#  }
#
#  # testclassify(src_gmm, gmmnew);
#
#
##line 2052 "../../../src/gmm/gmm.mx"
function dmahalanobis(x:bat[void,dbl], mu:dbl, variance:dbl):bat[void,dbl];
#  PROC dmahalanobis( BAT[void,dbl] x, dbl mu, dbl variance ): BAT[void,dbl] := {
	dist:= multiplex.-(x,mu);
#    VAR dist := [-](x, const mu);
	dist := multiplex.*(dist,dist);
#    dist := [*](dist, dist);
	dist := multiplex./(dist,variance);
#    dist := [/]( dist, const variance );
	return dist;
#    RETURN dist;
end function;
#  }
#
function mvgpdf(d:bat[void,dbl], det:dbl, Ndim:int):bat[void,dbl];
#  PROC mvgpdf( BAT[void,dbl] d, dbl det, int Ndim ): BAT[void,dbl] := {
	M_PI:= take("M_PI");
	lx_b := *(2,M_PI);
	mx_b := dbl(Ndim);
	nx_b := /(mx_b,2);
	ox_b := pow(lx_b,nx_b);
	px_b := sqrt(det);
	qx_b := *(ox_b,px_b);
	norm:= /(1,qx_b);
#    VAR norm := 1/(pow((2*M_PI), dbl(Ndim)/2) * sqrt(det) );
	rx_b := multiplex.*(d,-0.5LL);
	p:= multiplex.exp(rx_b);
#    VAR p := [exp]( [*]( d, -0.5LL ) );
	sx_b := multiplex.*(p,norm);
	return sx_b;
#    RETURN [*]( p, const norm );
end function;
#  }
#
function test():void;
#  PROC test():void := {
	tx_b := debug("Testing...");
#    debug( "Testing..." );
#
#
##line 2070 "../../../src/gmm/gmm.mx"
	mu:= new(int,dbl);
#    VAR mu := new( int, dbl );
	mu_1:= take("mu_1");
	ux_b := insert(mu,1,mu_1);
#    mu.insert( 1, mu_1 );
	mu_2:= take("mu_2");
	vx_b := insert(mu,2,mu_2);
#    mu.insert( 2, mu_2 );
#    # ...
	sigma:= new(int,dbl);
#    VAR sigma := new( int, dbl );
	sigma_1:= take("sigma_1");
	wx_b := insert(sigma,1,sigma_1);
#    sigma.insert( 1, sigma_1 );
	sigma_2:= take("sigma_2");
	xx_b := insert(sigma,2,sigma_2);
#    sigma.insert( 2, sigma_2 );
#    # ...
#
#
##line 2081 "../../../src/gmm/gmm.mx"
	covar:= multiplex.*(sigma,sigma);
#    VAR covar := [*]( sigma, sigma );
	det:= prod(covar);
#    VAR det := prod( covar );
	yx_b := "Determinant: %lf (%lf)\n";
	ay_b := *(sigma_2,sigma_2);
	by_b := *(sigma_1,ay_b);
	cy_b := *(sigma_1,by_b);
	dy_b := printf(yx_b,det,cy_b);
#    printf( "Determinant: %lf (%lf)\n", det, sigma_1 * sigma_1 * sigma_2 * sigma_2 );
#
#
##line 2087 "../../../src/gmm/gmm.mx"
	ey_b := oid(0);
	fy_b := new(void,dbl);
	x_1:= setSequenceBase(fy_b,ey_b);
#    VAR x_1 := new( void, dbl ).setSequenceBase(oid(0));
	gy_b := oid(0);
	hy_b := new(void,dbl);
	x_2:= setSequenceBase(hy_b,gy_b);
#    VAR x_2 := new( void, dbl ).setSequenceBase(oid(0));
#    # ...
	i:= 0;
#    VAR i := 0;
barrier	iy_b:= true;
	Nsamples:= take("Nsamples");
	ky_b := <(i,Nsamples);
barrier	jy_b:= ky_b;
#    WHILE (i < Nsamples) {
	ly_b := ran_gaussian(mu_1,sigma_1);
	my_b := insert(x_1,nil,ly_b);
#      x_1.insert( nil, ran_gaussian(mu_1,sigma_1) );
	ny_b := ran_gaussian(mu_2,sigma_2);
	oy_b := insert(x_2,nil,ny_b);
#      x_2.insert( nil, ran_gaussian(mu_2,sigma_2) );
#      # ...
	py_b := :+=(i,1);
#      i :+= 1;
redo	iy_b;
end	jy_b;
end	iy_b;
#    }
#
#
##line 2100 "../../../src/gmm/gmm.mx"
	qy_b := find(mu,1);
	ry_b := find(covar,1);
	dist_1:= multiplex.dmahalanobis_i_diagcov(x_1,qy_b,ry_b);
#    VAR dist_1 := [dmahalanobis_i_diagcov]( x_1, mu.find(1), covar.find(1) );
	sy_b := find(mu,2);
	ty_b := find(covar,2);
	dist_2:= multiplex.dmahalanobis_i_diagcov(x_2,sy_b,ty_b);
#    VAR dist_2 := [dmahalanobis_i_diagcov]( x_2, mu.find(2), covar.find(2) );
#    # ...
	dist:= multiplex.+(dist_1,dist_2);
#    VAR dist := [+]( dist_1, dist_2 ); # ...
#
#
##line 2108 "../../../src/gmm/gmm.mx"
	p:= multiplex.multivariate_gaussian_pdf_diagcov(dist,det,2);
#    VAR p := [multivariate_gaussian_pdf_diagcov]( dist, det, 2 );
#    # print( x_1, x_2, p );
#
#
#
##line 2114 "../../../src/gmm/gmm.mx"
	uy_b := find(mu,1);
	vy_b := find(covar,1);
	wy_b := dmahalanobis(x_1,uy_b,vy_b);
	thediff:= multiplex.-(wy_b,dist_1);
#    VAR thediff := [-]( dmahalanobis(x_1, mu.find(1), covar.find(1) ), dist_1 );
	xy_b := find(mu,2);
	yy_b := find(covar,2);
	aa_c := dmahalanobis(x_2,xy_b,yy_b);
	ba_c := multiplex.-(aa_c,dist_2);
	thediff := multiplex.+(thediff,ba_c);
#    thediff := [+]( thediff, [-]( dmahalanobis(x_2, mu.find(2), covar.find(2) ), dist_2 ) );
	ca_c := sum(thediff);
barrier	da_c:= >(ca_c,1e-10LL);
#    IF ( thediff.sum > 1e-10LL ) {
	ea_c := "!ERROR: difference in Mahalanobis distances (%lf)!\n";
	fa_c := sum(thediff);
	ga_c := printf(ea_c,fa_c);
#      printf( "!ERROR: difference in Mahalanobis distances (%lf)!\n", thediff.sum );
end	da_c;
barrier	ha_c:= not(da_c);
	ia_c := printf("Mahalanobis distances ok.\n");
end	ha_c;
#    } ELSE printf( "Mahalanobis distances ok.\n" );
	ja_c := mvgpdf(dist,det,2);
	thediff := multiplex.-(ja_c,p);
#    thediff := [-]( mvgpdf( dist, det, 2 ), p );
	ka_c := sum(thediff);
barrier	la_c:= >(ka_c,1e-10LL);
#    IF ( thediff.sum > 1e-10LL ) {
	ma_c := "!ERROR: difference in probabilities (%lf)!\n";
	na_c := sum(thediff);
	oa_c := printf(ma_c,na_c);
#      printf( "!ERROR: difference in probabilities (%lf)!\n", thediff.sum );
end	la_c;
barrier	pa_c:= not(la_c);
	qa_c := printf("Probabilities ok.\n");
end	pa_c;
#    } ELSE printf( "Probabilities ok.\n" );
end function;
#  }
#
#
#
##line 2127 "../../../src/gmm/gmm.mx"
	coeffs:= take("coeffs");
	coeffs := nil;
#  coeffs := nil;
	mImgIdx:= take("mImgIdx");
	mImgIdx := nil;
#  mImgIdx := nil;
	mCIdx:= take("mCIdx");
	mCIdx := nil;
#  mCIdx := nil;
#
##  gmm := nil;
##  gmmnew := nil;
#
	commit:= take("commit");
#  commit;
#
#
#
##line 2140 "../../../src/gmm/gmm.mx"
#
	fragsize := 64;
#  CONST fragsize := 64;
	imgFrameNr:= take("imgFrameNr");
	Nimg:= count(imgFrameNr);
#  VAR Nimg := imgFrameNr.count;
	s_tdict:= take("s_tdict");
	collidx:= reverse(s_tdict);
#  VAR collidx := s_tdict.reverse;
#
#  
##line 2224 "../../../src/gmm/gmm.mx"
#  VAR tmBatIds, tmBatIds_Mean, tmBatIds_Covar;
#
#
##line 2145 "../../../src/gmm/gmm.mx"
#
	view_bbp_name:= take("view_bbp_name");
	ra_c := multiplex.startsWith(view_bbp_name,"gmm_trained");
	sa_c := uselect(ra_c,1);
	ta_c := count(sa_c);
barrier	ua_c:= >(ta_c,0);
#  IF ([startsWith](view_bbp_name,"gmm_trained").uselect(true).count > 0) {
#    
##line 2229 "../../../src/gmm/gmm.mx"
#  
##line 2219 "../../../src/gmm/gmm.mx"
	tmBatIds := new(str,str);
#  tmBatIds       := new(str,str);
	tmBatIds_Mean := new(int,str);
#  tmBatIds_Mean  := new(int,str);
	tmBatIds_Covar := new(int,str);
#  tmBatIds_Covar := new(int,str);
#
#
##line 2229 "../../../src/gmm/gmm.mx"
#
	va_c := +("gmm_trained","_Prior");
	wa_c := reverse(view_bbp_name);
barrier	xa_c:= exist(wa_c,va_c);
	ya_c := +("gmm_trained","_Prior");
	ab_c := insert(tmBatIds,"Prior",ya_c);
#  IF (view_bbp_name.reverse.exist("gmm_trained"+"_Prior"))   tmBatIds.insert("Prior",   "gmm_trained"+"_Prior");
end	xa_c;
	bb_c := +("gmm_trained","_mCIdx");
	cb_c := reverse(view_bbp_name);
barrier	db_c:= exist(cb_c,bb_c);
	eb_c := +("gmm_trained","_mCIdx");
	fb_c := insert(tmBatIds,"mCIdx",eb_c);
#  IF (view_bbp_name.reverse.exist("gmm_trained"+"_mCIdx"))   tmBatIds.insert("mCIdx",   "gmm_trained"+"_mCIdx");
end	db_c;
	gb_c := +("gmm_trained","_mImgIdx");
	hb_c := reverse(view_bbp_name);
barrier	ib_c:= exist(hb_c,gb_c);
	jb_c := +("gmm_trained","_mImgIdx");
	kb_c := insert(tmBatIds,"mImgIdx",jb_c);
#  IF (view_bbp_name.reverse.exist("gmm_trained"+"_mImgIdx")) tmBatIds.insert("mImgIdx", "gmm_trained"+"_mImgIdx");
end	ib_c;
	lb_c := +("gmm_trained","_init_variances");
	mb_c := reverse(view_bbp_name);
barrier	nb_c:= exist(mb_c,lb_c);
#  IF (view_bbp_name.reverse.exist("gmm_trained"+"_init_variances")) 
	ob_c := +("gmm_trained","_init_variances");
	pb_c := insert(tmBatIds,"init_variances",ob_c);
#    tmBatIds.insert("init_variances", "gmm_trained"+"_init_variances");
end	nb_c;
	nseq:= take("nseq");
barrier	qb_c:= bunStream(nseq,qb_cH,qb_cT);
#  nseq@batloop(){
	rb_c := str(qb_cT);
	sb_c := +("_Mean_",rb_c);
	tb_c := +("gmm_trained",sb_c);
	ub_c := reverse(view_bbp_name);
barrier	vb_c:= exist(ub_c,tb_c);
#    IF (view_bbp_name.reverse.exist("gmm_trained" + "_Mean_"  + str($t)))
	vb_cT:= take("vb_cT");
	wb_c := str(vb_cT);
	xb_c := +("_Mean_",wb_c);
	yb_c := +("gmm_trained",xb_c);
	ac_c := insert(tmBatIds_Mean,vb_cT,yb_c);
#      tmBatIds_Mean.insert( $t, "gmm_trained" + "_Mean_"  + str($t));
end	vb_c;
	bc_c := str(qb_cT);
	cc_c := +("_Covar_",bc_c);
	dc_c := +("gmm_trained",cc_c);
	ec_c := reverse(view_bbp_name);
barrier	fc_c:= exist(ec_c,dc_c);
#    IF (view_bbp_name.reverse.exist("gmm_trained" + "_Covar_" + str($t)))
	fc_cT:= take("fc_cT");
	gc_c := str(fc_cT);
	hc_c := +("_Covar_",gc_c);
	ic_c := +("gmm_trained",hc_c);
	jc_c := insert(tmBatIds_Covar,fc_cT,ic_c);
#      tmBatIds_Covar.insert($t, "gmm_trained" + "_Covar_" + str($t));
end	fc_c;
redo	qb_c;
end	qb_c;
#  }
#
#
##line 2147 "../../../src/gmm/gmm.mx"
#
end	ua_c;
barrier	kc_c:= not(ua_c);
#  } ELSE {
	trainedmodels:= newGMM("gmm_trained",Nimg);
#    VAR trainedmodels := newGMM("gmm_trained", Nimg);
#    
##line 655 "../../../src/gmm/gmm.mx"
	lc_c := find(trainedmodels,"init_variances");
	BAT_APPEND:= take("BAT_APPEND");
	mc_c := access(lc_c,BAT_APPEND);
#  access( trainedmodels.find("init_variances"), BAT_APPEND );
	nc_c := find(trainedmodels,"Prior");
	oc_c := access(nc_c,BAT_APPEND);
#  access( trainedmodels.find("Prior"), BAT_APPEND );
	pc_c := find(trainedmodels,"mImgIdx");
	qc_c := access(pc_c,BAT_APPEND);
#  access( trainedmodels.find("mImgIdx"), BAT_APPEND );
	rc_c := find(trainedmodels,"mCIdx");
	sc_c := access(rc_c,BAT_APPEND);
#  access( trainedmodels.find("mCIdx"), BAT_APPEND );
	tc_c := find(trainedmodels,"Mean");
barrier	uc_c:= bunStream(tc_c,uc_cH,uc_cT);
	vc_c := access(uc_cT,BAT_APPEND);
redo	uc_c;
end	uc_c;
#  trainedmodels.find("Mean")@batloop{  access($t, BAT_APPEND); }
	wc_c := find(trainedmodels,"Covar");
barrier	xc_c:= bunStream(wc_c,xc_cH,xc_cT);
	yc_c := access(xc_cT,BAT_APPEND);
redo	xc_c;
end	xc_c;
#  trainedmodels.find("Covar")@batloop{ access($t, BAT_APPEND); }
#
#
##line 2150 "../../../src/gmm/gmm.mx"
#
#    
##line 655 "../../../src/gmm/gmm.mx"
	ad_c := find(trainedmodels,"init_variances");
	bd_c := setPersistent(ad_c);
#  setPersistent( trainedmodels.find("init_variances") );
	cd_c := find(trainedmodels,"Prior");
	dd_c := setPersistent(cd_c);
#  setPersistent( trainedmodels.find("Prior") );
	ed_c := find(trainedmodels,"mImgIdx");
	fd_c := setPersistent(ed_c);
#  setPersistent( trainedmodels.find("mImgIdx") );
	gd_c := find(trainedmodels,"mCIdx");
	hd_c := setPersistent(gd_c);
#  setPersistent( trainedmodels.find("mCIdx") );
	id_c := find(trainedmodels,"Mean");
barrier	jd_c:= bunStream(id_c,jd_cH,jd_cT);
	kd_c := setPersistent(jd_cT);
redo	jd_c;
end	jd_c;
#  trainedmodels.find("Mean")@batloop{  setPersistent($t); }
	ld_c := find(trainedmodels,"Covar");
barrier	md_c:= bunStream(ld_c,md_cH,md_cT);
	nd_c := setPersistent(md_cT);
redo	md_c;
end	md_c;
#  trainedmodels.find("Covar")@batloop{ setPersistent($t); }
#
#
##line 2151 "../../../src/gmm/gmm.mx"
#
#    
##line 655 "../../../src/gmm/gmm.mx"
	od_c := find(trainedmodels,"init_variances");
	STORE_MMAP:= take("STORE_MMAP");
	pd_c := mmap(od_c,STORE_MMAP);
#  mmap( trainedmodels.find("init_variances"), STORE_MMAP );
	qd_c := find(trainedmodels,"Prior");
	rd_c := mmap(qd_c,STORE_MMAP);
#  mmap( trainedmodels.find("Prior"), STORE_MMAP );
	sd_c := find(trainedmodels,"mImgIdx");
	td_c := mmap(sd_c,STORE_MMAP);
#  mmap( trainedmodels.find("mImgIdx"), STORE_MMAP );
	ud_c := find(trainedmodels,"mCIdx");
	vd_c := mmap(ud_c,STORE_MMAP);
#  mmap( trainedmodels.find("mCIdx"), STORE_MMAP );
	wd_c := find(trainedmodels,"Mean");
barrier	xd_c:= bunStream(wd_c,xd_cH,xd_cT);
	yd_c := mmap(xd_cT,STORE_MMAP);
redo	xd_c;
end	xd_c;
#  trainedmodels.find("Mean")@batloop{  mmap($t, STORE_MMAP); }
	ae_c := find(trainedmodels,"Covar");
barrier	be_c:= bunStream(ae_c,be_cH,be_cT);
	ce_c := mmap(be_cT,STORE_MMAP);
redo	be_c;
end	be_c;
#  trainedmodels.find("Covar")@batloop{ mmap($t, STORE_MMAP); }
#
#
##line 2152 "../../../src/gmm/gmm.mx"
#
#    
##line 2194 "../../../src/gmm/gmm.mx"
#  # Can be paired with modelfromBatIds(X,tmBatIds)
#  
##line 2219 "../../../src/gmm/gmm.mx"
	tmBatIds := new(str,str);
#  tmBatIds       := new(str,str);
	tmBatIds_Mean := new(int,str);
#  tmBatIds_Mean  := new(int,str);
	tmBatIds_Covar := new(int,str);
#  tmBatIds_Covar := new(int,str);
#
#
##line 2195 "../../../src/gmm/gmm.mx"
#
	de_c := find(trainedmodels,"mCIdx");
	ee_c := info(de_c);
	fe_c := find(ee_c,"batId");
	ge_c := insert(tmBatIds,"mCIdx",fe_c);
#  tmBatIds.insert( "mCIdx",   trainedmodels.find("mCIdx").info.find("batId") );
	he_c := find(trainedmodels,"mImgIdx");
	ie_c := info(he_c);
	je_c := find(ie_c,"batId");
	ke_c := insert(tmBatIds,"mImgIdx",je_c);
#  tmBatIds.insert( "mImgIdx", trainedmodels.find("mImgIdx").info.find("batId") );
	le_c := find(trainedmodels,"Prior");
	me_c := info(le_c);
	ne_c := find(me_c,"batId");
	oe_c := insert(tmBatIds,"Prior",ne_c);
#  tmBatIds.insert( "Prior",   trainedmodels.find("Prior").info.find("batId") );
	pe_c := find(trainedmodels,"init_variances");
	qe_c := info(pe_c);
	re_c := find(qe_c,"batId");
	se_c := insert(tmBatIds,"init_variances",re_c);
#  tmBatIds.insert( "init_variances", trainedmodels.find("init_variances").info.find("batId") );
	te_c := find(trainedmodels,"Mean");
	ue_c := multiplex.info(te_c);
	ve_c := multiplex.find(ue_c,"batId");
	we_c := insert(tmBatIds_Mean,ve_c);
#  tmBatIds_Mean.insert(  [find]([info](trainedmodels.find("Mean")), const "batId") );
	xe_c := find(trainedmodels,"Covar");
	ye_c := multiplex.info(xe_c);
	af_c := multiplex.find(ye_c,"batId");
	bf_c := insert(tmBatIds_Covar,af_c);
#  tmBatIds_Covar.insert( [find]([info](trainedmodels.find("Covar")), const "batId") );
#
#
##line 2153 "../../../src/gmm/gmm.mx"
#
end	kc_c;
#  }
	ii:= 55;
#  VAR ii    := 55; # 0;
barrier	cf_c:= true;
	ef_c := *(ii,fragsize);
	ff_c := <(ef_c,Nimg);
barrier	df_c:= ff_c;
#  WHILE ( (ii*fragsize) < Nimg ) {
	gf_c := find(collidx,"keyframes_file");
	hf_c := *(ii,fragsize);
	if_c := +(ii,1);
	jf_c := *(if_c,fragsize);
	kf_c := -(jf_c,1);
	lf_c := bat(gf_c);
	frag_i:= slice(lf_c,hf_c,kf_c);
#    VAR frag_i := bat(collidx.find("keyframes_file")).slice(ii*fragsize,((ii+1)*fragsize) - 1);
	mf_c := oid(0);
	nf_c := mark(frag_i,mf_c);
	of_c := find(collidx,"imgBlock");
	pf_c := bat(of_c);
	qf_c := reverse(nf_c);
	rf_c := join(qf_c,pf_c);
	sf_c := oid(0);
	tf_c := reverse(rf_c);
	uf_c := mark(tf_c,sf_c);
	frag_iIdx:= reverse(uf_c);
#    VAR frag_iIdx := frag_i.mark(oid(0)).reverse.join(bat(collidx.find("imgBlock"))).reverse.mark(oid(0)).reverse;
#
	EM_coll:= take("EM_coll");
	EM_coll := new(str,bat);
#    EM_coll := new(str,bat);
	vf_c := insert(EM_coll,"I",frag_i);
#    EM_coll.insert("I",  frag_i);
	imgBlock:= take("imgBlock");
	wf_c := reverse(imgBlock);
	xf_c := join(frag_iIdx,wf_c);
	yf_c := reverse(xf_c);
	ag_c := insert(EM_coll,"Ib",yf_c);
#    EM_coll.insert("Ib", frag_iIdx.join(imgBlock.reverse).reverse);
#
	coeffs:= new(int,bat);
#    VAR coeffs := new(int,bat);
barrier	bg_c:= bunStream(nseq,bg_cH,bg_cT);
#    nseq@batloop(){
	cg_c := str(bg_cT);
	dg_c := +("imgBlockCoeff_",cg_c);
	eg_c := find(collidx,dg_c);
	fg_c := bat(eg_c);
	gg_c := join(frag_iIdx,fg_c);
	hg_c := insert(coeffs,bg_cT,gg_c);
#      coeffs.insert( $t, frag_iIdx.join(bat(collidx.find("imgBlockCoeff_" + str($t)))) );
redo	bg_c;
end	bg_c;
#    }
	ig_c := insert(EM_coll,"Coeffs",coeffs);
#    EM_coll.insert("Coeffs", coeffs);
	coeffs := nil;
#    		coeffs := nil;
	EM_model:= take("EM_model");
	EM_model := initGMM(EM_coll);
#    EM_model := initGMM( EM_coll );
#
	gmm:= EM_globalmodel(30);
#    VAR gmm := EM_globalmodel(30); # 30 iterations for starters
#
#    
##line 2208 "../../../src/gmm/gmm.mx"
#  # Must be paired with a modelBatIds(tmBatIds,X) in the same context
	trainedmodels := new(str,bat);
#  trainedmodels := new(str, bat);
	jg_c := multiplex.bat(tmBatIds);
	kg_c := insert(trainedmodels,jg_c);
#  trainedmodels.insert( [bat](tmBatIds) );
	lg_c := multiplex.bat(tmBatIds_Mean);
	mg_c := insert(trainedmodels,"Mean",lg_c);
#  trainedmodels.insert( "Mean", [bat](tmBatIds_Mean) );
	ng_c := multiplex.bat(tmBatIds_Covar);
	og_c := insert(trainedmodels,"Covar",ng_c);
#  trainedmodels.insert( "Covar", [bat](tmBatIds_Covar) );
#
#
##line 2173 "../../../src/gmm/gmm.mx"
#
	pg_c := find(trainedmodels,"mImgIdx");
	qg_c := count(pg_c);
	lastId:= oid(qg_c);
#    VAR lastId := oid(trainedmodels.find("mImgIdx").count);
	midx:= find(gmm,"mImgIdx");
#    VAR midx := gmm.find("mImgIdx");
#    
##line 611 "../../../src/gmm/gmm.mx"
#{
	rg_c := reverse(midx);
	sg_c := mark(rg_c,lastId);
	fIdx:= reverse(sg_c);
#  VAR fIdx := midx.reverse.mark(lastId).reverse;
#
	tg_c := find(gmm,"mImgIdx");
	ug_c := reverse(tg_c);
	convImgIdx:= join(fIdx,ug_c);
#  VAR convImgIdx     := join( fIdx, gmm.find("mImgIdx").reverse );
	vg_c := find(gmm,"mCIdx");
	wg_c := reverse(vg_c);
	convCIdx:= join(fIdx,wg_c);
#  VAR convCIdx       := join( fIdx, gmm.find("mCIdx").reverse );
#        # implementation of batinsert into empty voidbats causes trouble...
#        debug("<PROPCHECK1 hkey=%s />",     
	xg_c := find(trainedmodels,"mImgIdx");
	yg_c := info(xg_c);
	ah_c := find(yg_c,"hkey");
	bh_c := debug("<PROPCHECK1 hkey=%s />",ah_c);
#          trainedmodels.find("mImgIdx").info.find("hkey"));
	ch_c := reverse(convImgIdx);
	dh_c := find(trainedmodels,"mImgIdx");
	eh_c := insert(dh_c,ch_c);
#  trainedmodels.find("mImgIdx").insert( convImgIdx.reverse );
#        debug("<PROPCHECK2 hkey=%s />",    
	fh_c := find(trainedmodels,"mImgIdx");
	gh_c := info(fh_c);
	hh_c := find(gh_c,"hkey");
	ih_c := debug("<PROPCHECK2 hkey=%s />",hh_c);
#          trainedmodels.find("mImgIdx").info.find("hkey"));
	jh_c := reverse(convCIdx);
	kh_c := find(trainedmodels,"mCIdx");
	lh_c := insert(kh_c,jh_c);
#  trainedmodels.find("mCIdx").insert( convCIdx.reverse );
#
	mh_c := find(gmm,"Prior");
	nh_c := join(fIdx,mh_c);
	oh_c := find(trainedmodels,"Prior");
	ph_c := insert(oh_c,nh_c);
#  trainedmodels.find("Prior").insert( join(fIdx, gmm.find("Prior")) );
	qh_c := find(trainedmodels,"Mean");
#  [insert]( trainedmodels.find("Mean"),
	rh_c := find(gmm,"Mean");
	sh_c := multiplex.join(fIdx,rh_c);
	th_c := multiplex.insert(qh_c,sh_c);
#            [join](const fIdx, gmm.find("Mean")) );
	uh_c := find(trainedmodels,"Covar");
#  [insert]( trainedmodels.find("Covar"),
	vh_c := find(gmm,"Covar");
	wh_c := multiplex.join(fIdx,vh_c);
	xh_c := multiplex.insert(uh_c,wh_c);
#            [join](const fIdx, gmm.find("Covar")) );
#
	yh_c := find(gmm,"init_variances");
	ai_c := join(fIdx,yh_c);
	bi_c := find(trainedmodels,"init_variances");
	ci_c := insert(bi_c,ai_c);
#  trainedmodels.find("init_variances").insert( join(fIdx, gmm.find("init_variances")) );
#}
#
#
##line 2176 "../../../src/gmm/gmm.mx"
#
#    
##line 2194 "../../../src/gmm/gmm.mx"
#  # Can be paired with modelfromBatIds(X,tmBatIds)
#  
##line 2219 "../../../src/gmm/gmm.mx"
	tmBatIds := new(str,str);
#  tmBatIds       := new(str,str);
	tmBatIds_Mean := new(int,str);
#  tmBatIds_Mean  := new(int,str);
	tmBatIds_Covar := new(int,str);
#  tmBatIds_Covar := new(int,str);
#
#
##line 2195 "../../../src/gmm/gmm.mx"
#
	di_c := find(trainedmodels,"mCIdx");
	ei_c := info(di_c);
	fi_c := find(ei_c,"batId");
	gi_c := insert(tmBatIds,"mCIdx",fi_c);
#  tmBatIds.insert( "mCIdx",   trainedmodels.find("mCIdx").info.find("batId") );
	hi_c := find(trainedmodels,"mImgIdx");
	ii_c := info(hi_c);
	ji_c := find(ii_c,"batId");
	ki_c := insert(tmBatIds,"mImgIdx",ji_c);
#  tmBatIds.insert( "mImgIdx", trainedmodels.find("mImgIdx").info.find("batId") );
	li_c := find(trainedmodels,"Prior");
	mi_c := info(li_c);
	ni_c := find(mi_c,"batId");
	oi_c := insert(tmBatIds,"Prior",ni_c);
#  tmBatIds.insert( "Prior",   trainedmodels.find("Prior").info.find("batId") );
	pi_c := find(trainedmodels,"init_variances");
	qi_c := info(pi_c);
	ri_c := find(qi_c,"batId");
	si_c := insert(tmBatIds,"init_variances",ri_c);
#  tmBatIds.insert( "init_variances", trainedmodels.find("init_variances").info.find("batId") );
	ti_c := find(trainedmodels,"Mean");
	ui_c := multiplex.info(ti_c);
	vi_c := multiplex.find(ui_c,"batId");
	wi_c := insert(tmBatIds_Mean,vi_c);
#  tmBatIds_Mean.insert(  [find]([info](trainedmodels.find("Mean")), const "batId") );
	xi_c := find(trainedmodels,"Covar");
	yi_c := multiplex.info(xi_c);
	aj_c := multiplex.find(yi_c,"batId");
	bj_c := insert(tmBatIds_Covar,aj_c);
#  tmBatIds_Covar.insert( [find]([info](trainedmodels.find("Covar")), const "batId") );
#
#
##line 2177 "../../../src/gmm/gmm.mx"
#
#    commit;
#
	trainedmodels := nil;
#    trainedmodels := nil;
	EM_model := nil;
#    EM_model := nil;
	EM_coll := nil;
#    EM_coll  := nil;
#
	gmm := nil;
#    gmm := nil;
	midx := nil;
#    midx := nil;
#
	cj_c := :+=(ii,1);
#    ii :+= 1;
redo	cf_c;
end	df_c;
end	cf_c;
#  }
#
#
##line 2338 "../../../src/gmm/gmm.mx"
	GMMdebuglog:= take("GMMdebuglog");
	dj_c := fflush(GMMdebuglog);
#  fflush( GMMdebuglog );
#  # enum_drop( TCluster );
#  # fclose( GMMdebuglog );
#  # quit;
#
#
##line 2346 "../../../src/gmm/gmm.mx"
function modelIdx(N:int):bat[str,void];
#PROC modelIdx(int N): BAT[str,void] := {
	ej_c := new(str,void);
	fj_c := oid(0);
	gj_c := reverse(ej_c);
	hj_c := setSequenceBase(gj_c,fj_c);
	modelidx:= reverse(hj_c);
#  VAR modelidx := new(str,void).reverse.setSequenceBase(oid(0)).reverse;
	ij_c := Nseq(N);
	seq:= reverse(ij_c);
#  VAR seq := Nseq(N).reverse;
	jj_c := insert(modelidx,"Prior",nil);
#  modelidx.insert( "Prior", nil );
	kj_c := project(seq,"Mu_");
	lj_c := mirror(seq);
	mj_c := multiplex.+(kj_c,lj_c);
	mu:= _x(mj_c);
#  VAR mu := _x([+](seq.project("Mu_"), seq.mirror));
	nj_c := project(seq,"Sigma_");
	oj_c := mirror(seq);
	pj_c := multiplex.+(nj_c,oj_c);
	covar:= _x(pj_c);
#  VAR covar := _x([+](seq.project("Sigma_"), seq.mirror));
	qj_c := reverse(mu);
	rj_c := insert(modelidx,qj_c);
#  modelidx.insert( mu.reverse );
	sj_c := reverse(covar);
	tj_c := insert(modelidx,sj_c);
#  modelidx.insert( covar.reverse );
	uj_c := reverse(mu);
	vj_c := number(uj_c);
	wj_c := reverse(vj_c);
	mu := join(wj_c,modelidx);
#  mu := mu.reverse.number.reverse.join(modelidx);
	xj_c := reverse(covar);
	yj_c := number(xj_c);
	ak_c := reverse(yj_c);
	covar := join(ak_c,modelidx);
#  covar := covar.reverse.number.reverse.join(modelidx);
	return modelidx;
#  RETURN modelidx;
end function;
#}
#
#
