stdout of test '01_Modules_static` in directory 'tests/Availability` itself:


# 15:30:03 >  
# 15:30:03 >  Mtimeout -timeout 60 Mserver "--config=/ufs/boncz/MonetDB/linux/etc/monet.conf" --debug=10 --set "monet_mod_path=/ufs/boncz/MonetDB/linux/lib/MonetDB" --set "gdk_dbfarm=/ufs/boncz/MonetDB/linux/var/MonetDB/dbfarm" --set "sql_logdir=/ufs/boncz/MonetDB/linux/var/MonetDB/log" --set mapi_port=55437 --set sql_port=50559 --set monet_prompt= --trace --dbname=mTests_tests_Availability  < 01_Modules_static.milS
# 15:30:03 >  

# Monet Database Server V4.3.13
# Copyright (c) 1993-2004, CWI. All rights reserved.
# compiled for i686-pc-linux-gnu/32bit; dynamically linked.
setoid(oid(20000000));

var Fname:=new(oid,str);	Fname.col_name("function");
var FnameS:=new(oid,str);	FnameS.col_name("function");
var Ftype:=new(oid,str);	Ftype.col_name("type");
var Fmod:=new(oid,str);		Fmod.col_name("module");
var Fsig:=new(oid,str);		Fsig.col_name("signature");
var Fhelp:=new(oid,str);	Fhelp.col_name("help");
var Fnts:=new(oid,str);

monet_fcntbl.sort()@batloop() {
	var Tname:=$h;
	var Ttype:=help_tpe(monet_fcn_tpe.find($t));
	var Tmod:="";
	if (monet_fcn_mid.exist($t)) {
		Tmod:=monet_mod_nme.find(monet_fcn_mid.find($t));
		if (Tmod.startsWith("_")) {
			Tmod := string(Tmod,1);
		}
	} else {
		Tmod:="";
	}
	var Tsig:=format_fcn_sig($t);
	var Thelp:="";
	if (monet_fcn_dsc.exist($t)) {
		Thelp:=monet_fcn_dsc.find($t);
	} else {
		Thelp:="not available";
	}
	Fname.insert($t,Tname);
	Ftype.insert($t,Ttype);
	Fmod.insert($t,Tmod);
	Fsig.insert($t,Tsig);
	Fhelp.insert($t,Thelp);
	Fnts.insert($t,sprintf("%s %s %s",Tname,Ttype,Tsig));
}

Fnts.count().print();
[ 679 ]
Fnts.reverse().sort().reverse()@batloop() {
	FnameS.insert($h,Fname.find($h));
}
FnameS.count().print();
[ 679 ]

var All:=0;

var Static_mods:=Fmod.reverse().kunique().sort().copy();
table(Static_mods.reverse().col_name(sprintf("%i modules",Static_mods.count())));
#-----------------#
# 8 modules	  #
#-----------------#
[ ""		  ]
[ "algebra"	  ]
[ "arith"	  ]
[ "bat"		  ]
[ "builtin"	  ]
[ "str"		  ]
[ "sys"		  ]
[ "trans"	  ]
Static_mods@batloop() {
	printf("\nModule: \"%s\"\n\n",$h);
	var FnameM:=kintersect(FnameS,Fmod.select($h));FnameM.col_name("function");
	FnameM.count().print(); table(1,FnameM,Ftype,Fsig,Fhelp);
	All:=All+FnameM.count();
}

Module: ""

[ 56 ]
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
# function		type		signature										help																																																																												  # name
# str			str		str													str																																																															  # type
#-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
[ "ascii",		  "PROC:      ",  "ascii(str) : int",											  "not available"																																																													  ]
[ "atoms",	  "PROC:      ",  "atoms() : void",									  "not available"																																																																										  ]
[ "capacity",	  "PROC:      ",  "capacity(BAT[any,any]) : lng",						  "not available"																																																													  ]
[ "cold",	  "PROC:      ",  "cold(BAT[any::1,any::2]) : void",						  "not available"																																																													  ]
[ "destroy",	  "PROC:      ",  "destroy(BAT[any,any]) : bit",						  "not available"																																																													  ]
[ "dir",	  "PROC:      ",  "dir() : void",								  "not available"																																																													  ]
[ "dir",	  "PROC:      ",  "dir(str) : void",								  "not available"																																																													  ]
[ "dir_leaks",		  "PROC:      ",  "dir_leaks() : void",											  "not available"																																																													  ]
[ "head",	  "PROC:      ",  "head(BAT[any,any]) : str",									  "not available"																																																													  ]
[ "help",	  "PROC:      ",  "help(str) : void",								  "not available"																																																													  ]
[ "help_sig",	  "PROC:      ",  "help_sig(oid) : void",							  "not available"																																																													  ]
[ "help_tpe",	  "PROC:      ",  "help_tpe(int) : str",							  "not available"																																																													  ]
[ "hot",	  "PROC:      ",  "hot(BAT[any::1,any::2]) : void",						  "not available"																																																													  ]
[ "htype",	  "PROC:      ",  "htype(any) : int",										  "not available"																																																													  ]
[ "join",	  "PROC:      ",  "join(BAT[any::1,any::2], BAT[any::2,any::3], lng, str, ..any..) : BAT[any::1,any::3]", "not available"																																																													  ]
[ "join",	  "PROC:      ",  "join(BAT[any::1,any::2], BAT[any::2,any::3], str, ..any..) : BAT[any::1,any::3]", "not available"																																																													  ]
[ "load",	  "PROC:      ",  "load(str) : BAT[any,any]",							  "not available"																																																													  ]
[ "locate",		  "PROC:      ",  "locate(str, str) : int",										  "not available"																																																													  ]
[ "locate",		  "PROC:      ",  "locate(str, str, int) : int",									  "not available"																																																													  ]
[ "madvise",	  "PROC:      ",  "madvise(BAT[any::1,any::2], int) : BAT[any::1,any::2]",			  "not available"																																																													  ]
[ "mem_usage",	  "PROC:      ",  "mem_usage() : BAT[str,lng]",							  "not available"																																																													  ]
[ "mem_usage",	  "PROC:      ",  "mem_usage(int) : BAT[str,lng]",						  "not available"																																																													  ]
[ "mil_select",	  "PROC:      ",  "mil_select(BAT[any::1,any::2], str, any::2, any::2) : BAT[any::1,any::2]",	  "not available"																																																													  ]
[ "mmap",	  "PROC:      ",  "mmap(BAT[any::1,any::2], int) : BAT[any::1,any::2]",				  "not available"																																																													  ]
[ "new",	  "PROC:      ",  "new(BAT[any,any], BAT[any,any], int) : BAT[any,any]",				  "not available"																																																													  ]
[ "new",	  "PROC:      ",  "new(int, int) : BAT[any,any]",						  "not available"																																																													  ]
[ "new",	  "PROC:      ",  "new(int, int, int) : BAT[any,any]",						  "not available"																																																													  ]
[ "new",	  "PROC:      ",  "new(int, int, lng) : BAT[any,any]",						  "not available"																																																													  ]
[ "outerjoin",	  "PROC:      ",  "outerjoin(BAT[any::1,any::2], BAT[any::2,any::3]) : BAT[any::1,any::3]",	  "not available"																																																													  ]
[ "prod",	  "PROC:      ",  "prod(BAT[any,dbl]) : dbl",							  "not available"																																																													  ]
[ "prod",	  "PROC:      ",  "prod(BAT[any,flt]) : flt",							  "not available"																																																													  ]
[ "prod",	  "PROC:      ",  "prod(BAT[any,int]) : int",							  "not available"																																																													  ]
[ "prod",	  "PROC:      ",  "prod(BAT[any,lng]) : lng",							  "not available"																																																													  ]
[ "prod",	  "PROC:      ",  "prod(BAT[any,sht]) : sht",							  "not available"																																																													  ]
[ "project",	  "PROC:      ",  "project(BAT[any::1,any]) : BAT[any::1,void]",				  "not available"																																																													  ]
[ "repeat",		  "PROC:      ",  "repeat(str, int) : str",										  "not available"																																																													  ]
[ "save",	  "PROC:      ",  "save(BAT[any::1,any::2]) : BAT[any::1,any::2]",				  "not available"																																																													  ]
[ "space",		  "PROC:      ",  "space(int) : str",											  "not available"																																																													  ]
[ "stringinsert",	  "PROC:      ",  "stringinsert(str, int, int, str) : str",								  "not available"																																																													  ]
[ "stringleft",		  "PROC:      ",  "stringleft(str, int) : str",										  "not available"																																																													  ]
[ "stringlength",	  "PROC:      ",  "stringlength(str) : int",										  "not available"																																																													  ]
[ "stringreplace",	  "PROC:      ",  "stringreplace(str, str, str) : str",									  "not available"																																																													  ]
[ "stringright",	  "PROC:      ",  "stringright(str, int) : str",									  "not available"																																																													  ]
[ "substring",		  "PROC:      ",  "substring(str, int) : str",										  "not available"																																																													  ]
[ "substring",		  "PROC:      ",  "substring(str, int, int) : str",									  "not available"																																																													  ]
[ "sum",	  "PROC:      ",  "sum(BAT[any,dbl]) : dbl",							  "not available"																																																													  ]
[ "sum",	  "PROC:      ",  "sum(BAT[any,flt]) : flt",							  "not available"																																																													  ]
[ "sum",	  "PROC:      ",  "sum(BAT[any,int]) : int",							  "not available"																																																													  ]
[ "sum",	  "PROC:      ",  "sum(BAT[any,lng]) : lng",							  "not available"																																																													  ]
[ "sum",	  "PROC:      ",  "sum(BAT[any,sht]) : sht",							  "not available"																																																													  ]
[ "tail",	  "PROC:      ",  "tail(BAT[any,any]) : str",									  "not available"																																																													  ]
[ "ttype",	  "PROC:      ",  "ttype(any) : int",										  "not available"																																																													  ]
[ "tunique",	  "PROC:      ",  "tunique(BAT[any,any::1]) : BAT[any::1,void]",				  "not available"																																																													  ]
[ "vars",		  "PROC:      ",  "vars(str) : void",									  "not available"																																			  ]
[ "vm_usage",	  "PROC:      ",  "vm_usage() : BAT[str,lng]",							  "not available"																																																													  ]
[ "vm_usage",	  "PROC:      ",  "vm_usage(int) : BAT[str,lng]",						  "not available"																																																													  ]

Module: "algebra"

[ 112 ]
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
# function		type		signature										help																																													  # name
# str		str		str											str																																													  # type
#-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
[ "ADDHELP",	  "PROC:      ",  "ADDHELP(str, str, str, str, str) : void",						  "provide helpful info on a command (author, date, help-text)."																													  ]
[ "antijoin",			  "COMMAND:   ",  "antijoin(BAT[any::1,any::2], BAT[any::2,any::4]) : BAT[any::1,any::4]",			  "Returns head-value from 'left' and tail-value from 'right'\nfor all BUNs in the cross product of 'left' and 'right' that\ndo not satisfy the equality on remaining columns."																																																							  ]
[ "avg",	  "PROC:      ",  "avg(BAT[any,dbl]) : dbl",								  "Gives the average of all tail values."																																  ]
[ "avg",	  "PROC:      ",  "avg(BAT[any,flt]) : dbl",								  "Gives the average of all tail values."																																  ]
[ "avg",	  "PROC:      ",  "avg(BAT[any,int]) : dbl",								  "Gives the average of all tail values."																																  ]
[ "avg",	  "PROC:      ",  "avg(BAT[any,lng]) : dbl",								  "Gives the average of all tail values."																																  ]
[ "avg",	  "PROC:      ",  "avg(BAT[any,sht]) : dbl",								  "Gives the average of all tail values."																																  ]
[ "bandjoin",	  "COMMAND:   ",  "bandjoin(BAT[any::1,any::2], BAT[any::2,any::3], any::2, any::2) : BAT[any::1,any::3]", "This is a join() for which the predicate is that two BUNs match if\nthe left-tail value is within the range [right-head - minus,\nright-head + plus]\n\nWorks only for the builtin numerical types, and their derivates."										  ]
[ "clear",	  "PROC:      ",  "clear(BAT[any::1,any::2]) : BAT[any::1,any::2]",					  "Backward compatibility. Does a b.delete()"																																  ]
[ "copy",	  "COMMAND:   ",  "copy(BAT[any::1,any::2]) : BAT[any::1,any::2]",					  "Returns physical copy of a BAT."																																	  ]
[ "count",	  "COMMAND:   ",  "count(BAT[any,any]) : int",								  "Returns the number of elements currently in a BAT."																															  ]
[ "count",	  "COMMAND:   ",  "count(BAT[any,any], bit) : int",							  "Returns the number of elements currently in a BAT;\n ignores BUNs with nil-tail iff ignore_nils==TRUE."																								  ]
[ "count_no_nil", "PROC:      ",  "count_no_nil(BAT[any,any]) : int",							  "short-cut for count(b,TRUE)"																																		  ]
[ "cross",	  "COMMAND:   ",  "cross(BAT[any::1,any::2], BAT[any::3,any::4]) : BAT[any::1,any::4]",					  "Returns head-value from 'left' and tail-value from 'right'\nfor all BUNs in the cross product of 'left' and 'right'."														  ]
[ "diff",	  "PROC:      ",  "diff(BAT[any::1,any::2], BAT[any::1,any::2]) : BAT[any::1,any::2]",			  "backward compatibility: use sdiff() explicitly."																															  ]
[ "exist",	  "COMMAND:   ",  "exist(BAT[any::1,any::2], any::1, any::2) : bit",					  "Returns true when 'h,t' occurs as a bun in b."																															  ]
[ "exist",	  "COMMAND:   ",  "exist(BAT[any::1,any], any::1) : bit",						  "Returns whether 'h' occurs as a head value in b."																															  ]
[ "fetch",	  "COMMAND:   ",  "fetch(BAT[any,any::1], int) : any::1",						  "Returns the tail value of the BUN at the x-th position with 0 <= x < b.count"																											  ]
[ "fetch",	  "COMMAND:   ",  "fetch(BAT[any,any::1], oid) : any::1",						  "Returns the tail value of the BUN at the x-th position with 0 <= x < b.count"																											  ]
[ "fetch",	  "COMMAND:   ",  "fetch(BAT[any::1,any::2], BAT[int,any]) : BAT[any::1,any::2]",			  "Returns a positional selection of b by the integer head values of s"																													  ]
[ "fetch",	  "COMMAND:   ",  "fetch(BAT[any::1,any::2], BAT[oid,any]) : BAT[any::1,any::2]",			  "Returns a positional selection of b by the oid head values of s"																													  ]
[ "find",	  "COMMAND:   ",  "find(BAT[any::1,any::2], any::1) : any::2",						  "Returns the tail value 't' for which some [h,t] BUN exists in b.\n If no such BUN exists, an error occurs."																								  ]
[ "find_higher",  "COMMAND:   ",  "find_higher(BAT[any::1,void], any::1) : oid",					  "find the value equal to or (of not exists) greater than the searched value"																																																																			  ]
[ "find_lower",	  "COMMAND:   ",  "find_lower(BAT[any::1,void], any::1) : oid",						  "find the value equal to or (of not exists) smaller than the searched value"																																																																			  ]
[ "find_unescaped_occurrence",	  "PROC:      ",  "find_unescaped_occurrence(str, str, str) : int",							  "finds the first occurrence of c that is not escaped by esc"																																																													  ]
[ "fragment",	  "COMMAND:   ",  "fragment(BAT[any::1,any::2], any::1, any::1, any::2, any::2) : BAT[any::1,any::2]",	  "Select both on head and tail range."																																	  ]
[ "group",			  "COMMAND:   ",  "group(BAT[any::1,any], int, int, int) : BAT[any::1,int]",						  "Produces a new BAT with identical head column, and in the tail column groups of equally valued\nintegers within each group. Parameters: a start group value, group number increment, group size."																																												  ]
[ "group",			  "COMMAND:   ",  "group(BAT[any::1,int]) : BAT[any::1,void]",						  "Produces a new BAT with groups identified by the head column. The result contains tail times the head value, ie the tail contains the result group sizes."																																																									  ]
[ "hashsplit",	  "COMMAND:   ",  "hashsplit(BAT[any::1,any::2], int) : BAT[int,BAT]",					  "Split a BAT on tail column according (hash-value MOD buckets).\nReturns a recursive BAT, containing the fragments in the tail,\ntheir bucket number in the head."																	  ]
[ "histogram",	  "COMMAND:   ",  "histogram(BAT[any,any::2]) : BAT[any::2,int]",					  "Produce a BAT containing the histogram of the tail values.\n bat.histogram() ::= {count}(bat.reverse)"																								  ]
[ "intersect",	  "PROC:      ",  "intersect(BAT[any::1,any::2], BAT[any::1,any::2]) : BAT[any::1,any::2]",		  "backward compatibility: use sintersect() explicitly."																														  ]
[ "join",	  "COMMAND:   ",  "join(BAT[any::1,any::2], BAT[any::2,any::3], lng) : BAT[any::1,any::3]",		  "Returns all BUNs, consisting of a head-value from 'left' and\na tail-value from 'right' for which there are BUNs in 'left'\nand 'right' with equal tail- resp. head-value (i.e. the join\ncolumns are projected out)."										  ]
[ "join",	  "PROC:      ",  "join(BAT[any::1,any::2], BAT[any::2,any::3]) : BAT[any::1,any::3]",			  "Returns [left.head,right.tail] where (*fcn)(left.tail,right.head,..params..)"																											  ]
[ "kdiff",			  "COMMAND:   ",  "kdiff(BAT[any::1,any::2], BAT[any::1,any]) : BAT[any::1,any::2]",					  "Returns the difference taken over only the *head* columns of two BATs.\n Results in all BUNs of 'left' that are *not* in 'right'. Does *not* do\n double-elimination over the 'left' BUNs, If you want this, use:\n 'kdiff(left.kunique,right.kunique)' or: 'kdiff(left,right).kunique'."																																	  ]
[ "kintersect",			  "COMMAND:   ",  "kintersect(BAT[any::1,any::2], BAT[any::1,any]) : BAT[any::1,any::2]",				  "Returns the intersection taken over only the *head* columns of two BATs.\n Results in all BUNs of 'left' that are also in 'right'. Does *not* do\n double-elimination over the 'left' BUNs, If you want this, use:\n 'kintersect(left.kunique,right.kunique)' or: 'kintersect(left,right).kunique'."																																  ]
[ "kunion",			  "COMMAND:   ",  "kunion(BAT[any::1,any::2], BAT[any::1,any::2]) : BAT[any::1,any::2]",	  "Returns the union of two BATs; looking at head-columns only.\n Results in all BUNs of 'left', plus all BUNs of 'right' that are not in \n'left'. *no* double-elimination is done. If you want this, do:\n 'kunion(left.kunique,right.kunique)' or: 'sunion(left,right).kunique'."																																		  ]
[ "kunique",	  "COMMAND:   ",  "kunique(BAT[any::1,any::2]) : BAT[any::1,any::2]",					  "Select unique tuples from the input BAT. Double elimination is done\n only looking at the head column. Result is a BAT with hkeyed() == true."																			  ]
[ "like",	  "COMMAND:   ",  "like(BAT[any::1,str], str) : BAT[any::1,str]",					  "Selects all elements from the input BAT that have 'substr'\nas substring in the tail."																										  ]
[ "like",			  "PROC:      ",  "like(str, str) : bit",										  "does SQL LIKE expression with use of PCRE"																																																															  ]
[ "like",			  "PROC:      ",  "like(str, str, str) : bit",										  "does SQL LIKE expression with use of PCRE"																																																															  ]
[ "like_uselect",		  "PROC:      ",  "like_uselect(BAT[any::1,str], str, str) : BAT[any::1,void]",						  "does SQL LIKE select which supports % and _ (also understands escapes)"																																																											  ]
[ "like_uselect_pcre",		  "PROC:      ",  "like_uselect_pcre(BAT[any::1,str], str, str) : BAT[any::1,void]",					  "does SQL LIKE select with use of PCRE"																																																															  ]
[ "mark",	  "COMMAND:   ",  "mark(BAT[any::1,any]) : BAT[any::1,oid]",						  "Produces a new BAT with fresh unique OIDs in the tail."																														  ]
[ "mark",	  "COMMAND:   ",  "mark(BAT[any::1,any], oid) : BAT[any::1,oid]",					  "Produces a new BAT with fresh unique dense sequense of OIDs in the tail\n that starts at base (i.e. [base,base+1,..base+b.count()-1] )."																				  ]
[ "max",	  "COMMAND:   ",  "max(BAT[any,dbl]) : dbl",								  "Give the highest tail value. Error on empty BATs."																															  ]
[ "max",	  "COMMAND:   ",  "max(BAT[any,flt]) : flt",								  "Give the highest tail value. Error on empty BATs."																															  ]
[ "max",	  "COMMAND:   ",  "max(BAT[any,int]) : int",								  "Give the highest tail value. Error on empty BATs."																															  ]
[ "max",	  "COMMAND:   ",  "max(BAT[any,lng]) : lng",								  "Give the highest tail value. Error on empty BATs."																															  ]
[ "max",	  "COMMAND:   ",  "max(BAT[any,sht]) : sht",								  "Give the highest tail value. Error on empty BATs."																															  ]
[ "max",	  "COMMAND:   ",  "max(BAT[any::1,any::2]) : any::2",							  "\nGive the highest tail value. Error on empty BATs."																															  ]
[ "merge",	  "COMMAND:   ",  "merge(BAT[oid,oid]) : BAT[lng,void]",						  "Merge head and tail into a single value"																																																																							  ]
[ "mil_select",	  "PROC:      ",  "mil_select(BAT[any::1,any::2], str, ..any..) : BAT[any::1,any::2]",			  "Returns all BUNs where (*fcn)(tail,,..params..)."																															  ]
[ "min",	  "COMMAND:   ",  "min(BAT[any,dbl]) : dbl",								  "Give the lowest tail value. Error on empty BATs."																															  ]
[ "min",	  "COMMAND:   ",  "min(BAT[any,flt]) : flt",								  "Give the lowest tail value. Error on empty BATs."																															  ]
[ "min",	  "COMMAND:   ",  "min(BAT[any,int]) : int",								  "Give the lowest tail value. Error on empty BATs."																															  ]
[ "min",	  "COMMAND:   ",  "min(BAT[any,lng]) : lng",								  "Give the lowest tail value. Error on empty BATs."																															  ]
[ "min",	  "COMMAND:   ",  "min(BAT[any,sht]) : sht",								  "Give the lowest tail value. Error on empty BATs."																															  ]
[ "min",	  "COMMAND:   ",  "min(BAT[any::1,any::2]) : any::2",							  "\nGive the lowest tail value. Error on empty BATs."																															  ]
[ "neg_select",	  "PROC:      ",  "neg_select(BAT[any::1,any::2], str, ..any..) : BAT[any::1,any::2]",			  "Returns all BUNs where not (*fcn)(tail,,..params..)"																															  ]
[ "number",	  "COMMAND:   ",  "number(BAT[any::1,any]) : BAT[any::1,int]",						  "Produces a new BAT with identical head column, and consecutively\nincreasing integers (starting with 0) in the tail column."																						  ]
[ "outerjoin",	  "COMMAND:   ",  "outerjoin(BAT[any::1,any::2], BAT[any::2,any::3], lng) : BAT[any::1,any::3]",	  "Returns all the result of a join, plus the BUNS formed NIL in\nthe tail and the head-values of 'outer' whose tail-value does\nnot match an head-value in 'inner'."																	  ]
[ "position",	  "COMMAND:   ",  "position(BAT[any::1,any::2], any::1, any::2) : int",					  "Returns the BAT position e [0.. b.count> of a 'val' in the head column of b.\n It gives an error if 'val' does not occur in b. "																					  ]
[ "position",	  "COMMAND:   ",  "position(BAT[any::1,any], any::1) : int",						  "Returns the BAT position e [0.. b.count> of a 'val' in the head column of b.\n It gives an error if 'val' does not occur in b. "																					  ]
[ "prod_dbl",	  "COMMAND:   ",  "prod_dbl(BAT[any,dbl]) : dbl",							  "Gives the product of all tail values."																																  ]
[ "prod_dbl",	  "COMMAND:   ",  "prod_dbl(BAT[any,flt]) : dbl",							  "Gives the product of all tail values."																																  ]
[ "prod_flt",	  "COMMAND:   ",  "prod_flt(BAT[any,flt]) : flt",							  "Gives the product of all tail values."																																  ]
[ "prod_int",	  "COMMAND:   ",  "prod_int(BAT[any,int]) : int",							  "Gives the product of all tail values."																																  ]
[ "prod_int",	  "COMMAND:   ",  "prod_int(BAT[any,sht]) : int",							  "Gives the product of all tail values."																																  ]
[ "prod_lng",	  "COMMAND:   ",  "prod_lng(BAT[any,int]) : lng",							  "Gives the product of all tail values."																																  ]
[ "prod_lng",	  "COMMAND:   ",  "prod_lng(BAT[any,lng]) : lng",							  "Gives the product of all tail values."																																  ]
[ "prod_lng",	  "COMMAND:   ",  "prod_lng(BAT[any,sht]) : lng",							  "Gives the product of all tail values."																																  ]
[ "prod_sht",	  "COMMAND:   ",  "prod_sht(BAT[any,sht]) : sht",							  "Gives the product of all tail values."																																  ]
[ "project",	  "COMMAND:   ",  "project(BAT[any::1,any], any::2) : BAT[any::1,any::2]",				  "Fill the tail column with a constant value."																																  ]
[ "rangesplit",	  "COMMAND:   ",  "rangesplit(BAT[any::1,any::2], int) : BAT[any::2,BAT]",				  "Split a BAT on tail column in 'ranges' equally sized\nconsecutive ranges. Returns a recursive BAT, containing the\nfragments in the tail, the higher-bound of the range in the head.\nThe higher bound of the last range is 'nil'."									  ]
[ "rev_select",	  "PROC:      ",  "rev_select(BAT[any::1,any::2], str, any::2) : BAT[any::1,any::2]",			  "(value OP column) select rather than (column OP value)"																														  ]
[ "rmax_lower",	  "COMMAND:   ",  "rmax_lower(BAT[any::1,oid], any::1) : oid",						  "find the highest oid that may contain <= the passed value in an rmin() summary."																																																																		  ]
[ "rmax_summary", "COMMAND:   ",  "rmax_summary(BAT[void,any::1], int) : BAT[any::1,oid]",				  "provide a running-maximum summary of a specified size on the tail. It will be sorted on value and oid."																																																															  ]
[ "rmin_higher",  "COMMAND:   ",  "rmin_higher(BAT[any::1,oid], any::1) : oid",						  "find the lowest oid that may contain >= the passed value, in an rmax() summary."																																																																		  ]
[ "rmin_summary", "COMMAND:   ",  "rmin_summary(BAT[void,any::1], int) : BAT[any::1,oid]",				  "provide a running-minimum summary of a specified size on the tail. It will be sorted on value (reversely on oid)."																																																														  ]
[ "sample",	  "COMMAND:   ",  "sample(BAT[any::1,any::2], int) : BAT[any::1,any::2]",				  "Produce a random selection of size 'num' from the input BAT."																													  ]
[ "sdiff",			  "COMMAND:   ",  "sdiff(BAT[any::1,any::2], BAT[any::1,any::2]) : BAT[any::1,any::2]",					  "Returns the difference taken over *both* columns of two BATs.\n Results in all BUNs of 'left' that are *not* in 'right'. Does *not* do\n double-elimination over the 'left' BUNs, If you want this, use:\n 'sdiff(left.sunique,right.sunique)' or: 'sdiff(left,right).sunique'."																																		  ]
[ "select",	  "COMMAND:   ",  "select(BAT[any::1,any::2], any::2) : BAT[any::1,any::2]",				  "Select all BUNs of a BAT with a certain tail value. Selection\n on NIL is also possible (it should be properly casted, e.g.: int(nil))."																				  ]
[ "select",			  "COMMAND:   ",  "select(BAT[any::1,any::2], any::2, any::2) : BAT[any::1,any::2]",					  "Select all BUNs of a BAT that have tail values: {v| low <= v <= high}.\n\nNIL boundary values have a special meaning.\n+ low  == nil means: no lower bound\n+ high == nil means: no upper bound.\n\nNOTE 1: you should cast the nil to the appropriate type, e.g. int(nil)\n        in order to circumvent type clashes.\nNOTE 2: as the 'nil' element has no clear place in the ordered domain\n        of values, tuples with 'nil values are NEVER returned by the\n        range select."								  ]
[ "select",			  "COMMAND:   ",  "select(BAT[any::1,any::2], any::2, any::2, bit, bit) : BAT[any::1,any::2]",				  "Select all BUNs of a BAT that have tail values: {v| low <[=] v <[=] high}.\nEither boundary value is included ('<=') if the respective bit (l_in / h_in)\nis TRUE, and excluded ('<') otherwise.\n\nNIL boundary values have a special meaning.\n+ low  == nil means: no lower bound\n+ high == nil means: no upper bound.\n\nNOTE 1: you should cast the nil to the appropriate type, e.g. int(nil)\n        in order to cirumvent type clashes.\nNOTE 2: as the 'nil' element has no clear place in the ordered domain\n        of values, tuples with 'nil values are NEVER returned by the\n        range select."  ]
[ "semijoin",	  "PROC:      ",  "semijoin(BAT[any::1,any::2], BAT[any::1,any]) : BAT[any::1,any::2]",			  "semijoin is a synonym of kintersect."																																  ]
[ "sintersect",			  "COMMAND:   ",  "sintersect(BAT[any::1,any::2], BAT[any::1,any::2]) : BAT[any::1,any::2]",				  "Returns the intersection taken over *both* columns of two BATs.\n Results in all BUNs of 'left' that are also in 'right'. Does *not* do\n double-elimination over the 'left' BUNs, If you want this, use:\n 'sintersect(left.sunique,right.sunique)' or: 'sintersect(left,right).sunique'."																																	  ]
[ "slice",	  "COMMAND:   ",  "slice(BAT[any::1,any::2], int, int) : BAT[any::1,any::2]",				  "Return the slice with the BUNs at position x till y."																														  ]
[ "sort",	  "COMMAND:   ",  "sort(BAT[any::1,any::2]) : BAT[any::1,any::2]",							  "Returns copy of a BAT with the BUNs sorted on ascending head values."																				  ]
[ "sort_ht",			  "PROC:      ",  "sort_ht(BAT[any::1,any::2]) : BAT[any::1,any::2]",							  "sorts a BAT according to its head (primary) and tail values (secondary).(straight forward hack, not tuned for performance at all, just used for testing.)"																																																	  ]
[ "sort_rev",	  "COMMAND:   ",  "sort_rev(BAT[any::1,any::2]) : BAT[any::1,any::2]",							  "Returns copy of a BAT with the BUNs sorted on descending head values."																				  ]
[ "split",	  "COMMAND:   ",  "split(BAT[lng,void]) : BAT[oid,oid]",						  "Split head into two values"																																																																									  ]
[ "sql2pcre",			  "PROC:      ",  "sql2pcre(str, str) : str",							  "converts SQL LIKE to PCRE pattern"																																																																  ]
[ "sum_dbl",	  "COMMAND:   ",  "sum_dbl(BAT[any,dbl]) : dbl",							  "Gives the sum of all tail values."																																	  ]
[ "sum_dbl",	  "COMMAND:   ",  "sum_dbl(BAT[any,flt]) : dbl",							  "Gives the sum of all tail values."																																	  ]
[ "sum_flt",	  "COMMAND:   ",  "sum_flt(BAT[any,flt]) : flt",							  "Gives the sum of all tail values."																																	  ]
[ "sum_int",	  "COMMAND:   ",  "sum_int(BAT[any,int]) : int",							  "Gives the sum of all tail values."																																	  ]
[ "sum_int",	  "COMMAND:   ",  "sum_int(BAT[any,sht]) : int",							  "Gives the sum of all tail values."																																	  ]
[ "sum_lng",	  "COMMAND:   ",  "sum_lng(BAT[any,int]) : lng",							  "Gives the sum of all tail values."																																	  ]
[ "sum_lng",	  "COMMAND:   ",  "sum_lng(BAT[any,lng]) : lng",							  "Gives the sum of all tail values."																																	  ]
[ "sum_lng",	  "COMMAND:   ",  "sum_lng(BAT[any,sht]) : lng",							  "Gives the sum of all tail values."																																	  ]
[ "sum_sht",	  "COMMAND:   ",  "sum_sht(BAT[any,sht]) : sht",							  "Gives the sum of all tail values."																																	  ]
[ "sunion",			  "COMMAND:   ",  "sunion(BAT[any::1,any::2], BAT[any::1,any::2]) : BAT[any::1,any::2]",				  "Returns the union of two BATs; looking at both columns of both BATs.\n Results in all BUNs of 'left' that are not in 'right', plus all BUNs\n of 'right'. *no* double-elimination is done. If you want this, do:\n 'sunion(left.sunique,right.sunique)' or: 'sunion(left,right).sunique'."																																	  ]
[ "sunique",			  "COMMAND:   ",  "sunique(BAT[any::1,any::2]) : BAT[any::1,any::2]",							  "Select unique tuples from the input BAT. Double elimination is done over\n BUNs as a whole (head and tail). Result is a BAT with real set() semantics."																																																	  ]
[ "thetajoin",	  "COMMAND:   ",  "thetajoin(BAT[any::1,any::2], BAT[any::2,any::3], int, lng) : BAT[any::1,any::3]",	  "Theta join on for 'mode' in { LE, LT, EQ, GT, GE }.\n\nJOIN_EQ is just the same as join(). All other options do merge\nalgorithms; either using the fact that they are ordered()\nalready (left on tail, right on head), or by using/creating\nbinary search trees on the join columns. "		  ]
[ "uhashsplit",	  "COMMAND:   ",  "uhashsplit(BAT[any::1,any::2], int) : BAT[int,BAT]",					  "Same as hashsplit, but only collect the head values in the fragments"																												  ]
[ "union",	  "PROC:      ",  "union(BAT[any::1,any::2], BAT[any::1,any::2]) : BAT[any::1,any::2]",			  "backward compatibility: use sunion() explicitly."																															  ]
[ "unique",	  "PROC:      ",  "unique(BAT[any::1,any::2]) : BAT[any::1,any::2]",					  "backward compatibility: use sunique() explicitly."																															  ]
[ "urangesplit",  "COMMAND:   ",  "urangesplit(BAT[any::1,any::2], int) : BAT[any::2,BAT]",				  "Same as rangesplit, but only collect the head values in the fragments"																												  ]
[ "uselect",	  "COMMAND:   ",  "uselect(BAT[any::1,any::2], any::2) : BAT[any::1,void]",				  "Value select, but returning only the head values.\n SEE ALSO: select(bat,val)"																											  ]
[ "uselect",			  "COMMAND:   ",  "uselect(BAT[any::1,any::2], any::2, any::2) : BAT[any::1,void]",					  "Select on tail, returning only the head values.\n SEE ALSO: select(bat,low,high)."																																																										  ]
[ "uselect",			  "COMMAND:   ",  "uselect(BAT[any::1,any::2], any::2, any::2, bit, bit) : BAT[any::1,void]",				  "Select on tail, returning only the head values.\n SEE ALSO: select(bat,low,high,l_in,h_in)."																																																									  ]
[ "{count}",	  "COMMAND:   ",  "{count}(BAT[any::2,any]) : BAT[any::2,int]",						  "has fast implementation: histogram(bat.reverse)"																															  ]

Module: "arith"

[ 301 ]
#-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
# function		type		signature												help																																																																												  # name
#-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
[ "!=",		  "OPERATOR:  ",  "!=(any::1, any::1) : bit",								  "left unequal to right?"																																		  ]
[ "!=",		  "OPERATOR:  ",  "!=(bit, bit) : bit",									  "left unequal to right?"																																		  ]
[ "!=",		  "OPERATOR:  ",  "!=(chr, chr) : bit",									  "left unequal to right?"																																		  ]
[ "!=",		  "OPERATOR:  ",  "!=(dbl, dbl) : bit",									  "left unequal to right?"																																		  ]
[ "!=",		  "OPERATOR:  ",  "!=(flt, flt) : bit",									  "left unequal to right?"																																		  ]
[ "!=",		  "OPERATOR:  ",  "!=(int, int) : bit",									  "left unequal to right?"																																		  ]
[ "!=",		  "OPERATOR:  ",  "!=(lng, lng) : bit",									  "left unequal to right?"																																		  ]
[ "!=",		  "OPERATOR:  ",  "!=(oid, oid) : bit",									  "left unequal to right?"																																		  ]
[ "!=",		  "OPERATOR:  ",  "!=(sht, sht) : bit",									  "left unequal to right?"																																		  ]
[ "!=",		  "OPERATOR:  ",  "!=(str, str) : bit",									  "left unequal to right?"																																		  ]
[ "%",		  "OPERATOR:  ",  "%(chr, int) : int",									  "modulo"																																				  ]
[ "%",		  "OPERATOR:  ",  "%(int, chr) : chr",									  "modulo"																																				  ]
[ "%",		  "OPERATOR:  ",  "%(int, int) : int",									  "modulo"																																				  ]
[ "%",		  "OPERATOR:  ",  "%(int, sht) : sht",									  "modulo"																																				  ]
[ "%",		  "OPERATOR:  ",  "%(lng, int) : int",									  "modulo"																																				  ]
[ "%",		  "OPERATOR:  ",  "%(lng, lng) : lng",											  "modulo"																																																																											  ]
[ "%",		  "OPERATOR:  ",  "%(sht, int) : int",									  "modulo"																																				  ]
[ "%",		  "OPERATOR:  ",  "%(sht, sht) : sht",											  "modulo"																																																																											  ]
[ "*",		  "OPERATOR:  ",  "*(chr, chr) : chr",									  "multiplication"																																			  ]
[ "*",		  "OPERATOR:  ",  "*(chr, dbl) : dbl",									  "multiplication"																																			  ]
[ "*",		  "OPERATOR:  ",  "*(chr, flt) : flt",									  "multiplication"																																			  ]
[ "*",		  "OPERATOR:  ",  "*(chr, int) : int",									  "multiplication"																																			  ]
[ "*",		  "OPERATOR:  ",  "*(chr, lng) : lng",									  "multiplication"																																			  ]
[ "*",		  "OPERATOR:  ",  "*(chr, sht) : sht",									  "multiplication"																																			  ]
[ "*",		  "OPERATOR:  ",  "*(dbl, chr) : dbl",									  "multiplication"																																			  ]
[ "*",		  "OPERATOR:  ",  "*(dbl, dbl) : dbl",									  "multiplication"																																			  ]
[ "*",		  "OPERATOR:  ",  "*(dbl, flt) : dbl",									  "multiplication"																																			  ]
[ "*",		  "OPERATOR:  ",  "*(dbl, int) : dbl",									  "multiplication"																																			  ]
[ "*",		  "OPERATOR:  ",  "*(dbl, lng) : dbl",									  "multiplication"																																			  ]
[ "*",		  "OPERATOR:  ",  "*(dbl, sht) : dbl",									  "multiplication"																																			  ]
[ "*",		  "OPERATOR:  ",  "*(flt, chr) : flt",									  "multiplication"																																			  ]
[ "*",		  "OPERATOR:  ",  "*(flt, dbl) : dbl",									  "multiplication"																																			  ]
[ "*",		  "OPERATOR:  ",  "*(flt, flt) : flt",									  "multiplication"																																			  ]
[ "*",		  "OPERATOR:  ",  "*(flt, int) : flt",									  "multiplication"																																			  ]
[ "*",		  "OPERATOR:  ",  "*(flt, lng) : flt",									  "multiplication"																																			  ]
[ "*",		  "OPERATOR:  ",  "*(flt, sht) : flt",									  "multiplication"																																			  ]
[ "*",		  "OPERATOR:  ",  "*(int, chr) : int",									  "multiplication"																																			  ]
[ "*",		  "OPERATOR:  ",  "*(int, dbl) : dbl",									  "multiplication"																																			  ]
[ "*",		  "OPERATOR:  ",  "*(int, flt) : flt",									  "multiplication"																																			  ]
[ "*",		  "OPERATOR:  ",  "*(int, int) : int",									  "multiplication"																																			  ]
[ "*",		  "OPERATOR:  ",  "*(int, lng) : lng",									  "multiplication"																																			  ]
[ "*",		  "OPERATOR:  ",  "*(int, sht) : int",									  "multiplication"																																			  ]
[ "*",		  "OPERATOR:  ",  "*(lng, chr) : lng",									  "multiplication"																																			  ]
[ "*",		  "OPERATOR:  ",  "*(lng, dbl) : dbl",									  "multiplication"																																			  ]
[ "*",		  "OPERATOR:  ",  "*(lng, flt) : dbl",									  "multiplication"																																			  ]
[ "*",		  "OPERATOR:  ",  "*(lng, int) : lng",									  "multiplication"																																			  ]
[ "*",		  "OPERATOR:  ",  "*(lng, lng) : lng",									  "multiplication"																																			  ]
[ "*",		  "OPERATOR:  ",  "*(lng, sht) : lng",									  "multiplication"																																			  ]
[ "*",		  "OPERATOR:  ",  "*(sht, chr) : sht",									  "multiplication"																																			  ]
[ "*",		  "OPERATOR:  ",  "*(sht, dbl) : dbl",									  "multiplication"																																			  ]
[ "*",		  "OPERATOR:  ",  "*(sht, flt) : flt",									  "multiplication"																																			  ]
[ "*",		  "OPERATOR:  ",  "*(sht, int) : int",									  "multiplication"																																			  ]
[ "*",		  "OPERATOR:  ",  "*(sht, lng) : lng",									  "multiplication"																																			  ]
[ "*",		  "OPERATOR:  ",  "*(sht, sht) : sht",									  "multiplication"																																			  ]
[ "+",		  "OPERATOR:  ",  "+(chr, chr) : chr",									  "addition"																																				  ]
[ "+",		  "OPERATOR:  ",  "+(chr, dbl) : dbl",									  "addition"																																				  ]
[ "+",		  "OPERATOR:  ",  "+(chr, flt) : flt",									  "addition"																																				  ]
[ "+",		  "OPERATOR:  ",  "+(chr, int) : int",									  "addition"																																				  ]
[ "+",		  "OPERATOR:  ",  "+(chr, lng) : lng",									  "addition"																																				  ]
[ "+",		  "OPERATOR:  ",  "+(chr, sht) : sht",									  "addition"																																				  ]
[ "+",		  "OPERATOR:  ",  "+(dbl, chr) : dbl",									  "addition"																																				  ]
[ "+",		  "OPERATOR:  ",  "+(dbl, dbl) : dbl",									  "addition"																																				  ]
[ "+",		  "OPERATOR:  ",  "+(dbl, flt) : dbl",									  "addition"																																				  ]
[ "+",		  "OPERATOR:  ",  "+(dbl, int) : dbl",									  "addition"																																				  ]
[ "+",		  "OPERATOR:  ",  "+(dbl, lng) : dbl",									  "addition"																																				  ]
[ "+",		  "OPERATOR:  ",  "+(dbl, sht) : dbl",									  "addition"																																				  ]
[ "+",		  "OPERATOR:  ",  "+(flt, chr) : flt",									  "addition"																																				  ]
[ "+",		  "OPERATOR:  ",  "+(flt, dbl) : dbl",									  "addition"																																				  ]
[ "+",		  "OPERATOR:  ",  "+(flt, flt) : flt",									  "addition"																																				  ]
[ "+",		  "OPERATOR:  ",  "+(flt, int) : flt",									  "addition"																																				  ]
[ "+",		  "OPERATOR:  ",  "+(flt, lng) : flt",									  "addition"																																				  ]
[ "+",		  "OPERATOR:  ",  "+(flt, sht) : flt",									  "addition"																																				  ]
[ "+",		  "OPERATOR:  ",  "+(int, chr) : int",									  "addition"																																				  ]
[ "+",		  "OPERATOR:  ",  "+(int, dbl) : dbl",									  "addition"																																				  ]
[ "+",		  "OPERATOR:  ",  "+(int, flt) : flt",									  "addition"																																				  ]
[ "+",		  "OPERATOR:  ",  "+(int, int) : int",									  "addition"																																				  ]
[ "+",		  "OPERATOR:  ",  "+(int, lng) : lng",									  "addition"																																				  ]
[ "+",		  "OPERATOR:  ",  "+(int, sht) : int",									  "addition"																																				  ]
[ "+",		  "OPERATOR:  ",  "+(lng, chr) : lng",									  "addition"																																				  ]
[ "+",		  "OPERATOR:  ",  "+(lng, dbl) : dbl",									  "addition"																																				  ]
[ "+",		  "OPERATOR:  ",  "+(lng, flt) : dbl",									  "addition"																																				  ]
[ "+",		  "OPERATOR:  ",  "+(lng, int) : lng",									  "addition"																																				  ]
[ "+",		  "OPERATOR:  ",  "+(lng, lng) : lng",									  "addition"																																				  ]
[ "+",		  "OPERATOR:  ",  "+(lng, sht) : lng",									  "addition"																																				  ]
[ "+",		  "OPERATOR:  ",  "+(sht, chr) : sht",									  "addition"																																				  ]
[ "+",		  "OPERATOR:  ",  "+(sht, dbl) : dbl",									  "addition"																																				  ]
[ "+",		  "OPERATOR:  ",  "+(sht, flt) : flt",									  "addition"																																				  ]
[ "+",		  "OPERATOR:  ",  "+(sht, int) : int",									  "addition"																																				  ]
[ "+",		  "OPERATOR:  ",  "+(sht, lng) : lng",									  "addition"																																				  ]
[ "+",		  "OPERATOR:  ",  "+(sht, sht) : sht",									  "addition"																																				  ]
[ "-",		  "OPERATOR:  ",  "-(chr) : chr",									  "negative value"																																			  ]
[ "-",		  "OPERATOR:  ",  "-(chr, chr) : chr",									  "substraction"																																			  ]
[ "-",		  "OPERATOR:  ",  "-(chr, dbl) : dbl",									  "substraction"																																			  ]
[ "-",		  "OPERATOR:  ",  "-(chr, flt) : flt",									  "substraction"																																			  ]
[ "-",		  "OPERATOR:  ",  "-(chr, int) : int",									  "substraction"																																			  ]
[ "-",		  "OPERATOR:  ",  "-(chr, lng) : lng",									  "substraction"																																			  ]
[ "-",		  "OPERATOR:  ",  "-(chr, sht) : sht",									  "substraction"																																			  ]
[ "-",		  "OPERATOR:  ",  "-(dbl) : dbl",									  "negative value"																																			  ]
[ "-",		  "OPERATOR:  ",  "-(dbl, chr) : dbl",									  "substraction"																																			  ]
[ "-",		  "OPERATOR:  ",  "-(dbl, dbl) : dbl",									  "substraction"																																			  ]
[ "-",		  "OPERATOR:  ",  "-(dbl, flt) : dbl",									  "substraction"																																			  ]
[ "-",		  "OPERATOR:  ",  "-(dbl, int) : dbl",									  "substraction"																																			  ]
[ "-",		  "OPERATOR:  ",  "-(dbl, lng) : dbl",									  "substraction"																																			  ]
[ "-",		  "OPERATOR:  ",  "-(dbl, sht) : dbl",									  "substraction"																																			  ]
[ "-",		  "OPERATOR:  ",  "-(flt) : flt",									  "negative value"																																			  ]
[ "-",		  "OPERATOR:  ",  "-(flt, chr) : flt",									  "substraction"																																			  ]
[ "-",		  "OPERATOR:  ",  "-(flt, dbl) : dbl",									  "substraction"																																			  ]
[ "-",		  "OPERATOR:  ",  "-(flt, flt) : flt",									  "substraction"																																			  ]
[ "-",		  "OPERATOR:  ",  "-(flt, int) : flt",									  "substraction"																																			  ]
[ "-",		  "OPERATOR:  ",  "-(flt, lng) : flt",									  "substraction"																																			  ]
[ "-",		  "OPERATOR:  ",  "-(flt, sht) : flt",									  "substraction"																																			  ]
[ "-",		  "OPERATOR:  ",  "-(int) : int",									  "negative value"																																			  ]
[ "-",		  "OPERATOR:  ",  "-(int, chr) : int",									  "substraction"																																			  ]
[ "-",		  "OPERATOR:  ",  "-(int, dbl) : dbl",									  "substraction"																																			  ]
[ "-",		  "OPERATOR:  ",  "-(int, flt) : flt",									  "substraction"																																			  ]
[ "-",		  "OPERATOR:  ",  "-(int, int) : int",									  "substraction"																																			  ]
[ "-",		  "OPERATOR:  ",  "-(int, lng) : lng",									  "substraction"																																			  ]
[ "-",		  "OPERATOR:  ",  "-(int, sht) : int",									  "substraction"																																			  ]
[ "-",		  "OPERATOR:  ",  "-(lng) : lng",									  "negative value"																																			  ]
[ "-",		  "OPERATOR:  ",  "-(lng, chr) : lng",									  "substraction"																																			  ]
[ "-",		  "OPERATOR:  ",  "-(lng, dbl) : dbl",									  "substraction"																																			  ]
[ "-",		  "OPERATOR:  ",  "-(lng, flt) : dbl",									  "substraction"																																			  ]
[ "-",		  "OPERATOR:  ",  "-(lng, int) : lng",									  "substraction"																																			  ]
[ "-",		  "OPERATOR:  ",  "-(lng, lng) : lng",									  "substraction"																																			  ]
[ "-",		  "OPERATOR:  ",  "-(lng, sht) : lng",									  "substraction"																																			  ]
[ "-",		  "OPERATOR:  ",  "-(sht) : sht",									  "negative value"																																			  ]
[ "-",		  "OPERATOR:  ",  "-(sht, chr) : sht",									  "substraction"																																			  ]
[ "-",		  "OPERATOR:  ",  "-(sht, dbl) : dbl",									  "substraction"																																			  ]
[ "-",		  "OPERATOR:  ",  "-(sht, flt) : flt",									  "substraction"																																			  ]
[ "-",		  "OPERATOR:  ",  "-(sht, int) : int",									  "substraction"																																			  ]
[ "-",		  "OPERATOR:  ",  "-(sht, lng) : lng",									  "substraction"																																			  ]
[ "-",		  "OPERATOR:  ",  "-(sht, sht) : sht",									  "substraction"																																			  ]
[ "/",		  "OPERATOR:  ",  "/(chr, chr) : chr",									  "division"																																				  ]
[ "/",		  "OPERATOR:  ",  "/(chr, dbl) : dbl",									  "division"																																				  ]
[ "/",		  "OPERATOR:  ",  "/(chr, flt) : flt",									  "division"																																				  ]
[ "/",		  "OPERATOR:  ",  "/(chr, int) : int",									  "division"																																				  ]
[ "/",		  "OPERATOR:  ",  "/(chr, lng) : lng",									  "division"																																				  ]
[ "/",		  "OPERATOR:  ",  "/(chr, sht) : sht",									  "division"																																				  ]
[ "/",		  "OPERATOR:  ",  "/(dbl, chr) : dbl",									  "division"																																				  ]
[ "/",		  "OPERATOR:  ",  "/(dbl, dbl) : dbl",									  "division"																																				  ]
[ "/",		  "OPERATOR:  ",  "/(dbl, flt) : dbl",									  "division"																																				  ]
[ "/",		  "OPERATOR:  ",  "/(dbl, int) : dbl",									  "division"																																				  ]
[ "/",		  "OPERATOR:  ",  "/(dbl, lng) : dbl",									  "division"																																				  ]
[ "/",		  "OPERATOR:  ",  "/(dbl, sht) : dbl",									  "division"																																				  ]
[ "/",		  "OPERATOR:  ",  "/(flt, chr) : flt",									  "division"																																				  ]
[ "/",		  "OPERATOR:  ",  "/(flt, dbl) : dbl",									  "division"																																				  ]
[ "/",		  "OPERATOR:  ",  "/(flt, flt) : flt",									  "division"																																				  ]
[ "/",		  "OPERATOR:  ",  "/(flt, int) : flt",									  "division"																																				  ]
[ "/",		  "OPERATOR:  ",  "/(flt, lng) : flt",									  "division"																																				  ]
[ "/",		  "OPERATOR:  ",  "/(flt, sht) : flt",									  "division"																																				  ]
[ "/",		  "OPERATOR:  ",  "/(int, chr) : int",									  "division"																																				  ]
[ "/",		  "OPERATOR:  ",  "/(int, dbl) : dbl",									  "division"																																				  ]
[ "/",		  "OPERATOR:  ",  "/(int, flt) : flt",									  "division"																																				  ]
[ "/",		  "OPERATOR:  ",  "/(int, int) : int",									  "division"																																				  ]
[ "/",		  "OPERATOR:  ",  "/(int, lng) : lng",									  "division"																																				  ]
[ "/",		  "OPERATOR:  ",  "/(int, sht) : int",									  "division"																																				  ]
[ "/",		  "OPERATOR:  ",  "/(lng, chr) : lng",									  "division"																																				  ]
[ "/",		  "OPERATOR:  ",  "/(lng, dbl) : dbl",									  "division"																																				  ]
[ "/",		  "OPERATOR:  ",  "/(lng, flt) : dbl",									  "division"																																				  ]
[ "/",		  "OPERATOR:  ",  "/(lng, int) : lng",									  "division"																																				  ]
[ "/",		  "OPERATOR:  ",  "/(lng, lng) : lng",									  "division"																																				  ]
[ "/",		  "OPERATOR:  ",  "/(lng, sht) : lng",									  "division"																																				  ]
[ "/",		  "OPERATOR:  ",  "/(sht, chr) : sht",									  "division"																																				  ]
[ "/",		  "OPERATOR:  ",  "/(sht, dbl) : dbl",									  "division"																																				  ]
[ "/",		  "OPERATOR:  ",  "/(sht, flt) : flt",									  "division"																																				  ]
[ "/",		  "OPERATOR:  ",  "/(sht, int) : int",									  "division"																																				  ]
[ "/",		  "OPERATOR:  ",  "/(sht, lng) : lng",									  "division"																																				  ]
[ "/",		  "OPERATOR:  ",  "/(sht, sht) : sht",									  "division"																																				  ]
[ "<",		  "OPERATOR:  ",  "<(any::1, any::1) : bit",								  "left smaller than right?"																																		  ]
[ "<",		  "OPERATOR:  ",  "<(chr, chr) : bit",									  "left smaller than right?"																																		  ]
[ "<",		  "OPERATOR:  ",  "<(dbl, dbl) : bit",									  "left smaller than right?"																																		  ]
[ "<",		  "OPERATOR:  ",  "<(flt, flt) : bit",									  "left smaller than right?"																																		  ]
[ "<",		  "OPERATOR:  ",  "<(int, int) : bit",									  "left smaller than right?"																																		  ]
[ "<",		  "OPERATOR:  ",  "<(lng, lng) : bit",									  "left smaller than right?"																																		  ]
[ "<",		  "OPERATOR:  ",  "<(oid, oid) : bit",									  "left smaller than right?"																																		  ]
[ "<",		  "OPERATOR:  ",  "<(sht, sht) : bit",									  "left smaller than right?"																																		  ]
[ "<",		  "OPERATOR:  ",  "<(str, str) : bit",									  "left smaller than right?"																																		  ]
[ "<<",		  "OPERATOR:  ",  "<<(chr, int) : chr",									  "shift left"																																				  ]
[ "<<",		  "OPERATOR:  ",  "<<(int, int) : int",									  "shift left"																																				  ]
[ "<<",		  "OPERATOR:  ",  "<<(lng, int) : lng",									  "shift left"																																				  ]
[ "<<",		  "OPERATOR:  ",  "<<(sht, int) : sht",									  "shift left"																																				  ]
[ "<=",		  "OPERATOR:  ",  "<=(any::1, any::1) : bit",								  "left smaller than right or equal?"																																	  ]
[ "<=",		  "OPERATOR:  ",  "<=(chr, chr) : bit",									  "left smaller than right or equal?"																																	  ]
[ "<=",		  "OPERATOR:  ",  "<=(dbl, dbl) : bit",									  "left smaller than right or equal?"																																	  ]
[ "<=",		  "OPERATOR:  ",  "<=(flt, flt) : bit",									  "left smaller than right or equal?"																																	  ]
[ "<=",		  "OPERATOR:  ",  "<=(int, int) : bit",									  "left smaller than right or equal?"																																	  ]
[ "<=",		  "OPERATOR:  ",  "<=(lng, lng) : bit",									  "left smaller than right or equal?"																																	  ]
[ "<=",		  "OPERATOR:  ",  "<=(oid, oid) : bit",									  "left smaller than right or equal?"																																	  ]
[ "<=",		  "OPERATOR:  ",  "<=(sht, sht) : bit",									  "left smaller than right or equal?"																																	  ]
[ "<=",		  "OPERATOR:  ",  "<=(str, str) : bit",									  "left smaller than right or equal?"																																	  ]
[ "=",		  "OPERATOR:  ",  "=(any::1, any::1) : bit",								  "left equal to right?"																																		  ]
[ "=",		  "OPERATOR:  ",  "=(bit, bit) : bit",									  "left equal to right?"																																		  ]
[ "=",		  "OPERATOR:  ",  "=(chr, chr) : bit",									  "left equal to right?"																																		  ]
[ "=",		  "OPERATOR:  ",  "=(dbl, dbl) : bit",									  "left equal to right?"																																		  ]
[ "=",		  "OPERATOR:  ",  "=(flt, flt) : bit",									  "left equal to right?"																																		  ]
[ "=",		  "OPERATOR:  ",  "=(int, int) : bit",									  "left equal to right?"																																		  ]
[ "=",		  "OPERATOR:  ",  "=(lng, lng) : bit",									  "left equal to right?"																																		  ]
[ "=",		  "OPERATOR:  ",  "=(oid, oid) : bit",									  "left equal to right?"																																		  ]
[ "=",		  "OPERATOR:  ",  "=(sht, sht) : bit",									  "left equal to right?"																																		  ]
[ "=",		  "OPERATOR:  ",  "=(str, str) : bit",									  "left equal to right?"																																		  ]
[ ">",		  "OPERATOR:  ",  ">(any::1, any::1) : bit",								  "left greater than right?"																																		  ]
[ ">",		  "OPERATOR:  ",  ">(chr, chr) : bit",									  "left greater than right?"																																		  ]
[ ">",		  "OPERATOR:  ",  ">(dbl, dbl) : bit",									  "left greater than right?"																																		  ]
[ ">",		  "OPERATOR:  ",  ">(flt, flt) : bit",									  "left greater than right?"																																		  ]
[ ">",		  "OPERATOR:  ",  ">(int, int) : bit",									  "left greater than right?"																																		  ]
[ ">",		  "OPERATOR:  ",  ">(lng, lng) : bit",									  "left greater than right?"																																		  ]
[ ">",		  "OPERATOR:  ",  ">(oid, oid) : bit",									  "left greater than right?"																																		  ]
[ ">",		  "OPERATOR:  ",  ">(sht, sht) : bit",									  "left greater than right?"																																		  ]
[ ">",		  "OPERATOR:  ",  ">(str, str) : bit",									  "left greater than right?"																																		  ]
[ ">=",		  "OPERATOR:  ",  ">=(any::1, any::1) : bit",								  "left greater than right or equal?)"																																	  ]
[ ">=",		  "OPERATOR:  ",  ">=(chr, chr) : bit",									  "left greater than right or equal?)"																																	  ]
[ ">=",		  "OPERATOR:  ",  ">=(dbl, dbl) : bit",									  "left greater than right or equal?)"																																	  ]
[ ">=",		  "OPERATOR:  ",  ">=(flt, flt) : bit",									  "left greater than right or equal?)"																																	  ]
[ ">=",		  "OPERATOR:  ",  ">=(int, int) : bit",									  "left greater than right or equal?)"																																	  ]
[ ">=",		  "OPERATOR:  ",  ">=(lng, lng) : bit",									  "left greater than right or equal?)"																																	  ]
[ ">=",		  "OPERATOR:  ",  ">=(oid, oid) : bit",									  "left greater than right or equal?)"																																	  ]
[ ">=",		  "OPERATOR:  ",  ">=(sht, sht) : bit",									  "left greater than right or equal?)"																																	  ]
[ ">=",		  "OPERATOR:  ",  ">=(str, str) : bit",									  "left greater than right or equal?)"																																	  ]
[ ">>",		  "OPERATOR:  ",  ">>(chr, int) : chr",									  "shift right"																																				  ]
[ ">>",		  "OPERATOR:  ",  ">>(int, int) : int",									  "shift right"																																				  ]
[ ">>",		  "OPERATOR:  ",  ">>(lng, int) : lng",									  "shift right"																																				  ]
[ ">>",		  "OPERATOR:  ",  ">>(sht, int) : sht",									  "shift right"																																				  ]
[ "abs",	  "COMMAND:   ",  "abs(chr) : chr",									  "absolute value"																																			  ]
[ "abs",	  "COMMAND:   ",  "abs(dbl) : dbl",									  "absolute value"																																			  ]
[ "abs",	  "COMMAND:   ",  "abs(flt) : flt",									  "absolute value"																																			  ]
[ "abs",	  "COMMAND:   ",  "abs(int) : int",									  "absolute value"																																			  ]
[ "abs",	  "COMMAND:   ",  "abs(lng) : lng",									  "absolute value"																																			  ]
[ "abs",	  "COMMAND:   ",  "abs(sht) : sht",									  "absolute value"																																			  ]
[ "and",	  "OPERATOR:  ",  "and(bit, bit) : bit",								  "boolean and"																																				  ]
[ "and",	  "OPERATOR:  ",  "and(chr, chr) : chr",								  "bitwise and"																																				  ]
[ "and",	  "OPERATOR:  ",  "and(int, int) : int",								  "bitwise and"																																				  ]
[ "and",	  "OPERATOR:  ",  "and(lng, lng) : lng",								  "bitwise and"																																				  ]
[ "and",	  "OPERATOR:  ",  "and(sht, sht) : sht",								  "bitwise and"																																				  ]
[ "between",	  "COMMAND:   ",  "between(any::1, any::1, any::1) : bit",						  "checks (low <= val <= high)"																																		  ]
[ "between",	  "COMMAND:   ",  "between(chr, chr, chr) : bit",							  "checks (low <= val <= high)"																																		  ]
[ "between",	  "COMMAND:   ",  "between(dbl, dbl, dbl) : bit",							  "checks (low <= val <= high)"																																		  ]
[ "between",	  "COMMAND:   ",  "between(flt, flt, flt) : bit",							  "checks (low <= val <= high)"																																		  ]
[ "between",	  "COMMAND:   ",  "between(int, int, int) : bit",							  "checks (low <= val <= high)"																																		  ]
[ "between",	  "COMMAND:   ",  "between(lng, lng, lng) : bit",							  "checks (low <= val <= high)"																																		  ]
[ "between",	  "COMMAND:   ",  "between(oid, oid, oid) : bit",							  "checks (low <= val <= high)"																																		  ]
[ "between",	  "COMMAND:   ",  "between(sht, sht, sht) : bit",							  "checks (low <= val <= high)"																																		  ]
[ "between",	  "COMMAND:   ",  "between(str, str, str) : bit",							  "checks (low <= val <= high)"																																		  ]
[ "dbl2lng",	  "COMMAND:   ",  "dbl2lng(dbl) : lng",									  "keep binary representation (!DS2.2)"																																	  ]
[ "flt2int",	  "COMMAND:   ",  "flt2int(flt) : int",									  "keep binary representation (!DS2.2)"																																	  ]
[ "getCHR_MAX",	  "COMMAND:   ",  "getCHR_MAX() : chr",									  "Get maximum value of ordered type chr"																																  ]
[ "getCHR_MIN",	  "COMMAND:   ",  "getCHR_MIN() : chr",									  "Get minimum value of ordered type chr"																																  ]
[ "getINT_MAX",	  "COMMAND:   ",  "getINT_MAX() : int",									  "Get maximum value of ordered type int"																																  ]
[ "getINT_MIN",	  "COMMAND:   ",  "getINT_MIN() : int",									  "Get minimum value of ordered type int"																																  ]
[ "getLNG_MAX",	  "COMMAND:   ",  "getLNG_MAX() : lng",									  "Get maximum value of ordered type lng"																																  ]
[ "getLNG_MIN",	  "COMMAND:   ",  "getLNG_MIN() : lng",									  "Get minimum value of ordered type lng"																																  ]
[ "getRAND_MAX",  "COMMAND:   ",  "getRAND_MAX() : int",								  "Maximum value returned by rand()"																																	  ]
[ "getSHT_MAX",	  "COMMAND:   ",  "getSHT_MAX() : sht",									  "Get maximum value of ordered type sht"																																  ]
[ "getSHT_MIN",	  "COMMAND:   ",  "getSHT_MIN() : sht",									  "Get minimum value of ordered type sht"																																  ]
[ "ifthenelse",	  "COMMAND:   ",  "ifthenelse(bit, any::1, any::1) : any::1",						  "boolean switch: returns b?t:f (returns error on isnil(b)"																														  ]
[ "int2flt",	  "COMMAND:   ",  "int2flt(int) : flt",									  "keep binary representation (!DS2.2)"																																	  ]
[ "inv",	  "COMMAND:   ",  "inv(dbl) : dbl",									  "inverse value (1/x)"																																			  ]
[ "inv",	  "COMMAND:   ",  "inv(flt) : flt",									  "inverse value (1/x)"																																			  ]
[ "isnil",	  "COMMAND:   ",  "isnil(any) : bit",									  "is a value nil?"																																			  ]
[ "isnil",	  "COMMAND:   ",  "isnil(bit) : bit",									  "is a value nil?"																																			  ]
[ "isnil",	  "COMMAND:   ",  "isnil(chr) : bit",									  "is a value nil?"																																			  ]
[ "isnil",	  "COMMAND:   ",  "isnil(dbl) : bit",									  "is a value nil?"																																			  ]
[ "isnil",	  "COMMAND:   ",  "isnil(flt) : bit",									  "is a value nil?"																																			  ]
[ "isnil",	  "COMMAND:   ",  "isnil(int) : bit",									  "is a value nil?"																																			  ]
[ "isnil",	  "COMMAND:   ",  "isnil(lng) : bit",									  "is a value nil?"																																			  ]
[ "isnil",	  "COMMAND:   ",  "isnil(oid) : bit",									  "is a value nil?"																																			  ]
[ "isnil",	  "COMMAND:   ",  "isnil(sht) : bit",									  "is a value nil?"																																			  ]
[ "isnil",	  "COMMAND:   ",  "isnil(str) : bit",									  "is a value nil?"																																			  ]
[ "lng2dbl",	  "COMMAND:   ",  "lng2dbl(lng) : dbl",									  "keep binary representation (!DS2.2)"																																	  ]
[ "max",	  "COMMAND:   ",  "max(any::1, any::1) : any::1",							  "maximum of two values"																																		  ]
[ "max",	  "COMMAND:   ",  "max(chr, chr) : chr",								  "maximum of two values"																																		  ]
[ "max",	  "COMMAND:   ",  "max(dbl, dbl) : dbl",								  "maximum of two values"																																		  ]
[ "max",	  "COMMAND:   ",  "max(flt, flt) : flt",								  "maximum of two values"																																		  ]
[ "max",	  "COMMAND:   ",  "max(int, int) : int",								  "maximum of two values"																																		  ]
[ "max",	  "COMMAND:   ",  "max(lng, lng) : lng",								  "maximum of two values"																																		  ]
[ "max",	  "COMMAND:   ",  "max(oid, oid) : oid",								  "maximum of two values"																																		  ]
[ "max",	  "COMMAND:   ",  "max(sht, sht) : sht",								  "maximum of two values"																																		  ]
[ "min",	  "COMMAND:   ",  "min(any::1, any::1) : any::1",							  "minimum of two values"																																		  ]
[ "min",	  "COMMAND:   ",  "min(chr, chr) : chr",								  "minimum of two values"																																		  ]
[ "min",	  "COMMAND:   ",  "min(dbl, dbl) : dbl",								  "minimum of two values"																																		  ]
[ "min",	  "COMMAND:   ",  "min(flt, flt) : flt",								  "minimum of two values"																																		  ]
[ "min",	  "COMMAND:   ",  "min(int, int) : int",								  "minimum of two values"																																		  ]
[ "min",	  "COMMAND:   ",  "min(lng, lng) : lng",								  "minimum of two values"																																		  ]
[ "min",	  "COMMAND:   ",  "min(oid, oid) : oid",								  "minimum of two values"																																		  ]
[ "min",	  "COMMAND:   ",  "min(sht, sht) : sht",								  "minimum of two values"																																		  ]
[ "not",	  "OPERATOR:  ",  "not(bit) : bit",									  "boolean negation"																																			  ]
[ "not",	  "OPERATOR:  ",  "not(chr) : chr",									  "bitwise negation"																																			  ]
[ "not",	  "OPERATOR:  ",  "not(int) : int",									  "bitwise negation"																																			  ]
[ "not",	  "OPERATOR:  ",  "not(lng) : lng",									  "bitwise negation"																																			  ]
[ "not",	  "OPERATOR:  ",  "not(sht) : sht",									  "bitwise negation"																																			  ]
[ "or",		  "OPERATOR:  ",  "or(bit, bit) : bit",									  "boolean or"																																				  ]
[ "or",		  "OPERATOR:  ",  "or(chr, chr) : chr",									  "bitwise or"																																				  ]
[ "or",		  "OPERATOR:  ",  "or(int, int) : int",									  "bitwise or"																																				  ]
[ "or",		  "OPERATOR:  ",  "or(lng, lng) : lng",									  "bitwise or"																																				  ]
[ "or",		  "OPERATOR:  ",  "or(sht, sht) : sht",									  "bitwise or"																																				  ]
[ "rand",	  "COMMAND:   ",  "rand() : int",									  "return a random number"																																		  ]
[ "srand",	  "COMMAND:   ",  "srand(int) : void",									  "initialize the rand() function with a seed"																																  ]
[ "xor",	  "OPERATOR:  ",  "xor(bit, bit) : bit",								  "boolean xor"																																				  ]
[ "xor",	  "OPERATOR:  ",  "xor(chr, chr) : chr",								  "bitwise xor"																																				  ]
[ "xor",	  "OPERATOR:  ",  "xor(int, int) : int",								  "bitwise xor"																																				  ]
[ "xor",	  "OPERATOR:  ",  "xor(lng, lng) : lng",								  "bitwise xor"																																				  ]
[ "xor",	  "OPERATOR:  ",  "xor(sht, sht) : sht",								  "bitwise xor"																																				  ]

Module: "bat"

[ 62 ]
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
# function		type		signature										help																																																																																					  # name
# str		str		str													str																																					  # type
#-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
[ "BAT",	  "COMMAND:   ",  "BAT(int, int) : BAT[any,any]",							  "Creates a new empty transient BAT, with head- and tail-types as indicated."																																																				  ]
[ "BAT",	  "COMMAND:   ",  "BAT(int, int, int) : BAT[any,any]",							  "Creates a new empty BAT, directly allocating for 'size' elements."																																																					  ]
[ "BAT",	  "COMMAND:   ",  "BAT(int, int, lng) : BAT[any,any]",							  "Creates a new empty BAT, directly allocating for 'size' elements."																																																					  ]
[ "accbuild",	  "COMMAND:   ",  "accbuild(BAT[any,any], str) : void",									  "Build an accelerator on the head column of b. The builtin accelerator\n types index and hash will be created as transient accelerators. They\n will not be saved on disk. User-defined accelerators must always be\n persistent."									  ]
[ "access",	  "COMMAND:   ",  "access(BAT[any::1,any::2]) : int",							  "Return the update access privilige of a BAT."																																																							  ]
[ "access",	  "COMMAND:   ",  "access(BAT[any::1,any::2], int) : BAT[any::1,any::2]",					  "Try to change the update access priviliges to this BAT. Mode:\n BAT_READ   - allow only read access.\n BAT_APPEND - allow reads and insertions of new elements.\n BAT_WRITE  - allow reads, insertions, and updates.\n BATs are updateable by default. On making a BAT readonly, all\n subsequent updates fail with an error message.\n Returns the BAT itself."  ]
[ "append",	  "COMMAND:   ",  "append(BAT[oid,any::1], BAT[oid,any::1]) : BAT[oid,any::1]",						  "append the content of u to i (renumbers u-oids' to unique numbers)"																													  ]
[ "append",	  "COMMAND:   ",  "append(BAT[oid,any::1], any::1) : BAT[oid,any::1]",							  "append the value u to i"																																		  ]
[ "append",	  "COMMAND:   ",  "append(BAT[oid,void], BAT[oid,void]) : BAT[oid,void]",						  "Special case append for empty bats, works around impossible void,void case"																												  ]
[ "append",	  "COMMAND:   ",  "append(BAT[void,any::1], BAT[oid,any::1]) : BAT[void,any::1]",					  "append the content of u to i"																																	  ]
[ "append",	  "COMMAND:   ",  "append(BAT[void,any::1], BAT[void,any::1]) : BAT[void,any::1]",					  "append the content of u to i"																																	  ]
[ "append",	  "COMMAND:   ",  "append(BAT[void,any::1], any::1) : BAT[void,any::1]",						  "append the value u to i"																																		  ]
[ "batloop",	  "ITERATOR:  ",  "batloop(BAT[any,any], ptr) : void",							  "Iterators are special MIL constructs:\n  <bat-expression> @ <iterator>(<parameters>) <MIL-statement>\n 'b@batloop()..' iterates over all BUNs [$h,$t] of BAT b."																																									  ]
[ "batloop",	  "ITERATOR:  ",  "batloop(BAT[any,any], ptr, int, int) : void",					  "Iterators are special MIL constructs:\n  <bat-expression> @ <iterator>(<parameters>) <MIL-statement>\n 'b@batloop(low,high)..' iterates over all BUNs of b.slice(low,high)"																																								  ]
[ "batsize",	  "COMMAND:   ",  "batsize(BAT[any,any]) : lng",							  "A version of BATsize that does not require loading the BAT."																																	  ]
[ "batsize",	  "COMMAND:   ",  "batsize(str) : lng",									  "A version of BATsize that does not require loading the BAT."																																	  ]
[ "bbpname",	  "COMMAND:   ",  "bbpname(BAT[any,any]) : str",							  "Gives back the logical name of a BAT."																																																								  ]
[ "bbpname",	  "COMMAND:   ",  "bbpname(BAT[any,any], str) : bit",							  "Give a logical name to a BAT. This can fail if a BAT with name 's' already\n exists. The command then returns FALSE, else TRUE."																																													  ]
[ "capacity",	  "COMMAND:   ",  "capacity(int) : lng",								  "Returns the current allocation size (in max number of elements) of a BAT."																																																				  ]
[ "col_name",	  "COMMAND:   ",  "col_name(BAT[any,any], str) : BAT[any,any]",							  "Give a logical name to tail column of a BAT.\n Returns the BAT itself."																												  ]
[ "cold",	  "COMMAND:   ",  "cold(str) : void",									  "Makes a BAT very cold for the BBP. The chance of being choses for swapout is\n big, afterwards."																												  ]
[ "convert",	  "COMMAND:   ",  "convert(BAT[any::1,any::2]) : BAT[any::1,any::2]",					  "Convert the contents of a BAT from little-endian to big-endian and vice versa.\n THIS COMMAND SHOULD NOT BE USED FROM MIL! DANGEROUS! DEBUGGING PURPOSES ONLY!"																																									  ]
[ "count",	  "COMMAND:   ",  "count(BAT[void,void], lng) : lng",							  "Sets the size (in number of elements) of a BAT."																																		  ]
[ "count",	  "COMMAND:   ",  "count(int) : lng",									  "Returns the current size (in number of elements) of a BAT."																																																						  ]
[ "delete",	  "COMMAND:   ",  "delete(BAT[any::1,any::2]) : BAT[any::1,any::2]",						  "Delete all BUNs in a BAT.\n Returns the modified BAT."																														  ]
[ "delete",	  "COMMAND:   ",  "delete(BAT[any::1,any::2], BAT[any::1,any]) : BAT[any::1,any::2]",			  "Delete from the first BAT all BUNs with a head value that is in the second.\n Returns the modified BAT."																																																  ]
[ "delete",	  "COMMAND:   ",  "delete(BAT[any::1,any::2], any::1) : BAT[any::1,any::2]",					  "Delete all BUNs with a certain head value.\n Returns the modified BAT."																												  ]
[ "delete",	  "COMMAND:   ",  "delete(BAT[any::1,any::2], any::1, any::2) : BAT[any::1,any::2]",				  "Delete one specific BUN.\n Returns the modified BAT."																														  ]
[ "deleteBuns",	  "COMMAND:   ",  "deleteBuns(BAT[any::1,any::2], BAT[any::1,any::2]) : BAT[any::1,any::2]",		  "Delete from the first BAT all BUNs with a corresponding BUN in the second.\n Returns the modified BAT."																																																  ]
[ "destroy",	  "COMMAND:   ",  "destroy(str) : bit",									  "Destroys the BAT."																																											  ]
[ "hashloop",	  "ITERATOR:  ",  "hashloop(BAT[any::1,any], ptr, any::1) : void",					  "Iterators are special MIL constructs:\n  <bat-expression> @ <iterator>(<parameters>) <MIL-statement>\n 'b@hashloop(v)..' iterates over all BUNs [$h,$t] of BAT b where ($h = val)."																																							  ]
[ "head",	  "COMMAND:   ",  "head(int) : str",											  "Returns the type of the head column of a BAT, as a string."																														  ]
[ "heat",	  "COMMAND:   ",  "heat(str) : int",									  "returns the current BBP heat (LRU stamp)"																																																								  ]
[ "hot",	  "COMMAND:   ",  "hot(str) : void",									  "Makes a BAT very hot for the BBP. The chance of being chosen for swapout is\n small, afterwards."																												  ]
[ "info",	  "COMMAND:   ",  "info(BAT[any,any]) : BAT[str,str]",							  "Produce a BAT containing info about a BAT in \"attribute\",\"value\" format.\n It contains all properties of the BAT record. See the BAT documentation in\n GDK for more information."																																						  ]
[ "inplace",	  "COMMAND:   ",  "inplace(BAT[void,any::1], BAT[oid,any::1]) : BAT[void,any::1]",			  "inplace replace values on the given locations"																																																						  ]
[ "inplace",	  "COMMAND:   ",  "inplace(BAT[void,any::1], oid, any::1) : BAT[void,any::1]",				  "inplace replace values on the given locations"																																																																															  ]
[ "insert",	  "COMMAND:   ",  "insert(BAT[any::1,any::2], BAT[any::1,any::2]) : BAT[any::1,any::2]",			  "Insert all BUNs of the second BAT into the first.\n Returns the modified BAT."																											  ]
[ "insert",	  "COMMAND:   ",  "insert(BAT[any::1,any::2], any::1, any::2) : BAT[any::1,any::2]",				  "Insert one BUN[h,t] in a BAT.\n Returns the modified BAT."																														  ]
[ "key",	  "COMMAND:   ",  "key(BAT[any::1,any::2]) : bit",							  "return whether the head column of a BAT is unique (key)."																																																						  ]
[ "key",	  "COMMAND:   ",  "key(BAT[any::1,any::2], bit) : BAT[any::1,any::2]",						  "Sets the 'key' property of the head column to 'mode'. In 'key' mode,\n the kernel will silently block insertions that cause a duplicate entries\n in the head column.\n KNOWN BUG: when 'key' is set to TRUE, this function does not automatically\n eliminate duplicates. Use b := b.kunique;"	  ]
[ "madvise",	  "COMMAND:   ",  "madvise(BAT[any::1,any::2], int, int, int) : BAT[any::1,any::2]",			  "Modern Operating Systems allow users to influence the buffer management\n policy of virtual memory. This is a crucial feature for database systems,\n and eliminates the need to reimplement the OS in a database buffer manager.\n The supported flags are BUF_NORMAL (the normal adaptive kernel algorithm),\n BUF_RANDOM (no page prefetching), BUF_SEQUENTIAL (prefetch and swapout),\n BUF_WILLNEED (load everything with prefetch), BUF_DONTNEED (swapout).\n These buffer management modes are not persistent.\n Returns the BAT operated upon."	  ]
[ "mirror",	  "COMMAND:   ",  "mirror(BAT[any::1,any]) : BAT[any::1,any::1]",					  "Returns the head-mirror image of a BAT (two head columns)."																																																						  ]
[ "mmap",	  "COMMAND:   ",  "mmap(BAT[any::1,any::2], int, int, int) : BAT[any::1,any::2]",			  "For each individual heap, you can change the allocation mode to\n either STORE_MEM or STORE_MMAP. Passing an int(nil) means: no change.\n Changing a dirty STORE_MEM heap into STORE_MMAP, will cause a BAT save\n (this has to happen before the heap can be mapped into virtual memory).\n These modes are persistent. "																													  ]
[ "order",	  "COMMAND:   ",  "order(BAT[any::1,any::2]) : BAT[any::1,any::2]",					  "Sorts the BAT itself, in place, on ascending head values. Returns b."																																																				  ]
[ "order_rev",	  "COMMAND:   ",  "order_rev(BAT[any::1,any::2]) : BAT[any::1,any::2]",					  "Sorts the BAT itself, in place, on descending head values. Returns b."																																																				  ]
[ "ordered",	  "COMMAND:   ",  "ordered(BAT[any,any]) : bit",							  "Returns whether a BAT is ordered on head or not."																																																							  ]
[ "ordered_rev",  "COMMAND:   ",  "ordered_rev(BAT[any,any]) : bit",							  "Returns whether a BAT is ordered on head or not."																																																							  ]
[ "persists",	  "COMMAND:   ",  "persists(BAT[any::1,any::2], bit) : BAT[any::1,any::2]",				  "Make the BAT persistent (mode = TRUE), transient (mode = FALSE).\n or session (mode = bit(nil)). Returns the BAT itself."																																														  ]
[ "replace",	  "COMMAND:   ",  "replace(BAT[any::1,any::2], BAT[any::1,any::2]) : BAT[any::1,any::2]",		  "Perform replace for all BUNs of the second BAT into the first.\n Returns the modified BAT."																																																		  ]
[ "replace",	  "COMMAND:   ",  "replace(BAT[any::1,any::2], any::1, any::2) : BAT[any::1,any::2]",				  "Replace the tail value of one BUN that has some head value.\n Returns the modified BAT."																										  ]
[ "reverse",	  "COMMAND:   ",  "reverse(BAT[any::1,any::2]) : BAT[any::2,any::1]",					  "Returns the reverse view of a BAT (head is tail and tail is head).\n BEWARE:  no copying is involved; input and output refer to the same object!"																																											  ]
[ "revert",	  "COMMAND:   ",  "revert(BAT[any::1,any::2]) : BAT[any::1,any::2]",					  "Puts all BUNs in a BAT in reverse order. Returns b."																																																							  ]
[ "roles",	  "COMMAND:   ",  "roles(BAT[any::1,any::2], str, str) : BAT[any::1,any::2]",				  "Give a logical name to the columns of a BAT.\n Returns the BAT itself."																																																				  ]
[ "save",	  "COMMAND:   ",  "save(str) : bit",									  "Save a BAT to storage, if it was loaded and dirty. Returns whether IO was necessary.\n Please realize that calling this function violates the atomic repository commit protocol!!"																																							  ]
[ "seqbase",	  "COMMAND:   ",  "seqbase(BAT[oid,any::1]) : oid",							  "Get the sequence base for the void vcolumn of a BAT."																																																						  ]
[ "seqbase",	  "COMMAND:   ",  "seqbase(BAT[void,any::1]) : oid",							  "Get the sequence base for the void vcolumn of a BAT."																																																						  ]
[ "seqbase",	  "COMMAND:   ",  "seqbase(BAT[void,any::1], oid) : BAT[void,any::1]",					  "Set the sequence base for the void vcolumn of a BAT.\n Returns the BAT itself."																																																			  ]
[ "set",	  "COMMAND:   ",  "set(BAT[any::1,any::2], bit) : BAT[any::1,any::2]",						  "Sets the 'set' property on this BAT to 'mode'. In 'set' mode, the kernel\n will silently block insertions that cause a duplicate BUN [head,tail] entries\n in the BAT.\n KNOWN BUG: when 'set' is set to TRUE, this function does not automatically\n eliminate duplicates. Use b := b.sunique;\n Returns the BAT itself."  ]
[ "synced",	  "COMMAND:   ",  "synced(BAT[any,any], BAT[any,any]) : bit",						  "Tests whether two BATs are synced or not. "																																																								  ]
[ "tail",	  "COMMAND:   ",  "tail(int) : str",											  "Returns the type of the tail column of a BAT, as a string."																														  ]
[ "unload",	  "COMMAND:   ",  "unload(str) : bit",									  "Swapout a BAT to disk. Transient BATs can also be swapped out.\n Returns whether the unload indeed happened. "																																															  ]

Module: "builtin"

[ 42 ]
#-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
# function		type		signature												help																																																																												  # name
#-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
[ "CATCH",	  "BUILTIN:   ",  "CATCH(STATEMENT) : str ",									  "Turns on buffering of error messages while executing STATEMENT.\n Error messages that occur during this execution are returned as a string.\n If no error occurrs, catch returns str(nil)."																	  ]
[ "ERROR",	  "BUILTIN:   ",  "ERROR(str format, ...any...) ",								  "Produce an error message, much like in C-printf() format.\n This raises an error, meaning that MIL statement execution will terminate."																							  ]
[ "RAISE",	  "BUILTIN:   ",  "RAISE(str err) ",										  "Raise the errors that were captured by the catch statement."																																	  ]
[ "[cast]",	  "BUILTIN:   ",  "[cast] (bat[any::1,any] v, int type_specifier) : bat[any::1,any] ",				  "Cast values explicitly, using an integer-expression as type specifier."																															  ]
[ "assign",	  "BUILTIN:   ",  "assign(VARNAME, EXPRESSION) ",								  "assign (introduce) a variable by string name."																																		  ]
[ "call",	  "BUILTIN:   ",  "call(str function, bat[str,str] b) : any ",							  "Evaluate a function with a variable number of parameters that come from\n a bat. Each bun in the bat is one parameter (in ordrder). The head contains\n the integer type number, and the tail a string representation. Each parameter\n value is obtained by doing a cast from string to that type."				  ]
[ "cast",	  "BUILTIN:   ",  "cast(any v, int type_specifier) : any ",							  "Cast values explicitly, using an integer-expression as type specifier."																															  ]
[ "clientid",	  "BUILTIN:   ",  "clientid() : int ",										  "Returns your integer session id. On the Mserver console, this returns 0."																															  ]
[ "constant",	  "BUILTIN:   ",  "constant(IDENT varname, ..IDENT... ) ",							  "Fix both type and value of a number of MIL variables."																																	  ]
[ "debugmask",	  "BUILTIN:   ",  "debugmask(MASK) : int  ",									  "Return the debug mask. If a MASK is passed, set it to that value."																																  ]
[ "drop",	  "BUILTIN:   ",  "drop(str modname, ...str...) ",							  "Unloads Monet extension modules (previously loaded with MODULE())\n You can only unload modules installed by yourself.\n\n In command-line mode, you can save typing the \" (though this often\n will collide with a MIL keyword)."																																																  ]
[ "eval",	  "BUILTIN:   ",  "eval(str format) : any ",									  "Evaluates a MIL-script, given as a string."																																			  ]
[ "fork",	  "BUILTIN:   ",  "fork(STATEMENT) : int ",								  "Open a new client session to execute this request.\n FUTURE: forks on remote Mservers.\n Returns new client id."																																																														  ]
[ "freeze",	  "BUILTIN:   ",  "freeze(IDENT varname, ..IDENT...) ",								  "Fix the type of a number of MIL variables; their values can still change."																															  ]
[ "kill",	  "BUILTIN:   ",  "kill(int clientid) ",									  "Kills a client session. Killing the console (clientid = 0) is a system\n shutdown.\n WARNING: if BAT-modifying operations are killed, we do not\n garuantee *anything*!!"																			  ]
[ "mod",	  "BUILTIN:   ",  "mod() : str ",										  "During module loading a module stack is kept. This function returns the top module"																														  ]
[ "module",	  "BUILTIN:   ",  "module(str modname, ...str...) ",							  "Loads Monet extension modules (previously installed with Minstall)\n into a running Mserver.\n After this, you will be able to use new Atoms (e.g. polygon), Search\n Accelerators (e.g. R-tree), Commands (e.g. spatjoin(A,B)), and Iterators\n (e.g. B.nearloop(rect) {}).\n You can either load modules installed by yourself or by the system\n administrator (adm)\n\n In command-line mode, you can save typing the \" (providing the\n resulting identifier does not collide with another MIL keyword)."														  ]
[ "module_pop",	  "BUILTIN:   ",  "module_pop() ",										  "During module loading a variable module is set to the current module name. At the end of a module load the enclosing module is popped from a stack"																						  ]
[ "module_push",  "BUILTIN:   ",  "module_push(str modname) ",									  "During module loading a variable module is set to the current module name. The previous module is pushed onto a stack"																									  ]
[ "multitable",	  "COMMAND:   ",  "multitable(BAT[any,BAT]) : void",									  "Print an n-ary table contained within a BAT of BATs"																																																																						  ]
[ "newoid",	  "BUILTIN:   ",  "newoid(int range) : oid ",									  "Reserves a range of consecutive unique OIDs; returns the lowest in range."																															  ]
[ "print",	  "COMMAND:   ",  "print(BAT[any::1,any], ..BAT[any::1,any]..) : void",						  "BATs are printed with '#' for legend lines, and the BUNs on seperate\n lines between brackets, containing each to comma separated values\n (head and tail).\n If multiple BATs are passed for printing, print() performs an implicit\n natural join, producing a multiattribute table."					  ]
[ "print",	  "COMMAND:   ",  "print(any) : void",										  "Print a MIL value between square brackets."																																			  ]
[ "print",	  "COMMAND:   ",  "print(int, BAT[any::1,any], ..BAT[any::1,any]..) : void",					  "The same as normal table print, but enforces to use the order of\n  BAT number [1..argc] to do the printing."																										  ]
[ "printf",	  "COMMAND:   ",  "printf(str, ..any..) : void",								  "Print a formatted string on the standard client output."																																	  ]
[ "prompt",	  "BUILTIN:   ",  "prompt(str prompt) ",									  "Change the MIL client prompt string."																																			  ]
[ "qstat",	  "BUILTIN:   ",  "qstat() ",											  "Print the MIL-queue statistics."																																				  ]
[ "qtrace",	  "BUILTIN:   ",  "qtrace(INT jobnumber) ",									  "Set the MIL-queue performance tracer."																																			  ]
[ "queue",	  "BUILTIN:   ",  "queue() ",											  "Print the Monet Interpreter job queue."																																			  ]
[ "quit",	  "BUILTIN:   ",  "quit() or CTRL-D ",										  "Terminates a session. Terminating the console\n (Mserver) still makes the system wait for all active clients to finish,\n before causing a database shutdown."																				  ]
[ "runon",	  "BUILTIN:   ",  "runon(STATEMENT, int threadno) ",							  "A statement can be designated to a particular thread\n using the runon command."																																																																		  ]
[ "setoid",	  "BUILTIN:   ",  "setoid(oid base) : oid ",									  "Sets the oid range of consecutive unique OIDs; returns the lowest in range."																															  ]
[ "source",	  "BUILTIN:   ",  "source(str mil_file) : any ",								  "Read and evaluate a MIL-script from a file. Relative paths start from\n the database directory"																												  ]
[ "sprintf",	  "COMMAND:   ",  "sprintf(str, ..any..) : str",								  "Print a formatted string on the standard client output."																																	  ]
[ "table",	  "COMMAND:   ",  "table(BAT[any::1,any], ..BAT[any::1,any]..) : void",						  "Print an n-ary table. Like print(n-ary) but does not print oid column"																															  ]
[ "table",	  "COMMAND:   ",  "table(int, BAT[any::1,any], ..BAT[any::1,any]..) : void",					  "Print an n-ary table. Use the ordering of param [1..argc]"																																	  ]
[ "threadcnt",	  "BUILTIN:   ",  "threadcnt(int inc) : int ",									  "Increases or decreases the number of active interpreter threads.\n returns the number of active threads."																											  ]
[ "threadid",	  "BUILTIN:   ",  "threadid() : int ",										  "Returns your the id of the thread running your MIL interpreter."																																  ]
[ "type",	  "BUILTIN:   ",  "type(any v) : int ",										  "Return the type of a value (expression). Returns an type number.\n TIP: use the monet_atomtbl BAT to translate type numbers to strings."																							  ]
[ "varname",	  "BUILTIN:   ",  "varname(VARIABLE) : str ",									  "(invoked on a simple variable): returns the variable name."																																	  ]
[ "varval",	  "BUILTIN:   ",  "varval(str) : any ",										  "(invoked on a simple variable): returns the variable name."																																	  ]
[ "whack",	  "BUILTIN:   ",  "whack(int i) : int ",										  "Cut the reference from a BAT in the BBPcache; return its BUN heap pointer."																															  ]

Module: "str"

[ 25 ]
#-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
# function		type		signature									help																																					  # name
#-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
[ "+",		  "OPERATOR:  ",  "+(str, any) : str",											  "Concatenate two strings."																																																																									  ]
[ "chrAt",	  "COMMAND:   ",  "chrAt(str, int) : chr",										  "String array lookup operation. DEPRECATED: non-ASCII characters become nil, use: string(str,pos,1)"																																																																  ]
[ "codeset",	  "COMMAND:   ",  "codeset() : str",											  "Return the locale's codeset"																																																																									  ]
[ "endsWith",	  "COMMAND:   ",  "endsWith(str, str) : bit",										  "Suffix check."																																																																										  ]
[ "iconv",	  "COMMAND:   ",  "iconv(str, str, str) : str",										  "String codeset conversion"																																																																									  ]
[ "length",	  "COMMAND:   ",  "length(str) : int",											  "Return the length of a string in characters."																																																																						  ]
[ "ltrim",	  "COMMAND:   ",  "ltrim(str) : str",											  "Strip whitespaces from start of a string."																																																																							  ]
[ "nbytes",	  "COMMAND:   ",  "nbytes(str) : int",											  "Return the length of a string in bytes."																																																																							  ]
[ "r_search",	  "COMMAND:   ",  "r_search(str, chr) : int",										  "Reverse search for a character. Returns position, -1 if not found. DEPRECATED: does not work for non-ASCII characters, use: r_search(str,str)"																																																										  ]
[ "r_search",	  "COMMAND:   ",  "r_search(str, str) : int",										  "Reverse search for a substring. Returns position, -1 if not found."																																																																				  ]
[ "rtrim",	  "COMMAND:   ",  "rtrim(str) : str",											  "Strip whitespaces from end of a string."																																																																							  ]
[ "search",	  "COMMAND:   ",  "search(str, chr) : int",										  "Search for a character. Returns position, -1 if not found. DEPRECATED: does not work for non-ASCII characters, use: search(str,str)"																																																												  ]
[ "search",	  "COMMAND:   ",  "search(str, str) : int",										  "Search for a substring. Returns position, -1 if not found."																																																																					  ]
[ "split",	  "COMMAND:   ",  "split(str) : BAT[void,chr]",							  "Split the string s into separate chrs"																																																																							  ]
[ "split",	  "COMMAND:   ",  "split(str, str) : BAT[void,str]",								  "Split the string s based on the seperator sep\nnote: the separator may not be an empty string."																																																								  ]
[ "startsWith",	  "COMMAND:   ",  "startsWith(str, str) : bit",										  "Prefix check."																																																																										  ]
[ "string",	  "COMMAND:   ",  "string(str, int) : str",										  "Return the tail s[offset..n] of a string s[0..n]."																																																																						  ]
[ "string",	  "COMMAND:   ",  "string(str, int, int) : str",									  "Return substring s[offset..offset+count] of a string s[0..n]"																																																																				  ]
[ "substitute",	  "COMMAND:   ",  "substitute(str, str, str, bit) : str",							  "Substitute first occurrence of substring 'src' by 'dst'.\nIff repeated = true this is repeated while 'src' can be found in the result string.\nIn order to prevent recursion and result strings of unlimited size, repeating\nis only done iff src is not a substring of dst."																										  ]
[ "toLower",	  "COMMAND:   ",  "toLower(str) : str",											  "Convert a string to lower case."																																																																								  ]
[ "toUpper",	  "COMMAND:   ",  "toUpper(str) : str",											  "Convert a string to upper case."																																																																								  ]
[ "translate",	  "COMMAND:   ",  "translate(str, str, str) : str",								  "Return the value of src modified so that every character in the value of\nsrc that occurs at some position N in the value of mapstr has been replaced\nby the character that occurs at position N in the value of transtr.\nEvery character in the value of src that does not appear in the value of\nmapstr is unchanged.\nEvery character in the value of src that appears at some position M in the\nvalue of mapstr, where the value of transtr is less than M characters in\nlength, is omitted from the returned value.\nIf any of the inputs is nil, the result is nil.\nNote that all three strings are UTF-8 encoded and that the function works\nat the Unicode level, not the byte level."  ]
[ "trim",	  "COMMAND:   ",  "trim(str) : str",											  "Strip whitespaces around a string."																																																																								  ]
[ "unicode",	  "COMMAND:   ",  "unicode(int) : str",											  "convert a unicode to a one-character string. (!DS2.2)"																																																																					  ]
[ "unicodeAt",	  "COMMAND:   ",  "unicodeAt(str, int) : int",										  "get a unicode character (as an int) from a string position. (!DS2.2)"																																																																			  ]

Module: "sys"

[ 71 ]
#-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
# function			type		signature											help																																																																												  # name
#-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
[ "bbp",		  "PROC:      ",  "bbp() : BAT[str,int]",								  "Global BBP usage info"																																																												  ]
[ "check_bbp_size",	  "COMMAND:   ",  "check_bbp_size() : lng",								  "Walk the BBP directories, delete leftovers and return total size"																																																							  ]
[ "clients",		  "PROC:      ",  "clients() : void",									  "list all active clients by their number."																																																										  ]
[ "cpu",		  "PROC:      ",  "cpu() : BAT[str,int]",								  "Global cpu usage info"																																																												  ]
[ "dir",		  "PROC:      ",  "dir(BAT[int,str]) : void",						  "list all bats, including system bats. Optionally filter on name with a certain substring"																																																				  ]
[ "env",		  "PROC:      ",  "env() : void",									  "list the values of all environment variables"																																																									  ]
[ "environment",	  "PROC:      ",  "environment() : BAT[str,str]",							  "deprecated"																																																														  ]
[ "exit",		  "PROC:      ",  "exit() : void",									  "quit for consultants"																																																												  ]
[ "format_fcn_sig",	  "COMMAND:   ",  "format_fcn_sig(oid) : str",								  "print a function signature"																																																												  ]
[ "help",		  "PROC:      ",  "help() : void",									  "provide help for a MIL construct."																																																											  ]
[ "io",			  "PROC:      ",  "io() : BAT[str,int]",								  "Global IO activity info"																																																												  ]
[ "loaded",		  "PROC:      ",  "loaded() : void",									  "list all loaded modules, and the number of active users."																																																								  ]
[ "ls",			  "PROC:      ",  "ls() : void",									  "list all data bats. Optionally filter on name with a certain substring"																																																						  ]
[ "ls",			  "PROC:      ",  "ls(str) : void",									  "list all data bats filtered on name with some substring"																																																								  ]
[ "mem_bigsize",	  "COMMAND:   ",  "mem_bigsize() : lng",									  "returns threshold after which memory allocations come from anonymous VM"																																																																			  ]
[ "mem_bigsize",	  "COMMAND:   ",  "mem_bigsize(lng) : void",									  "sets threshold after which memory allocations come from anonymous VM"																																																																			  ]
[ "mem_colormap",	  "COMMAND:   ",  "mem_colormap() : void",									  "print a color map of all memory that is in use"																																																																						  ]
[ "mem_cursize",	  "COMMAND:   ",  "mem_cursize() : lng",								  "the amount of physical swapspace in KB that is currently in use"																																																							  ]
[ "mem_maxsize",	  "COMMAND:   ",  "mem_maxsize() : lng",								  "the maximum usable amount of physical swapspace in KB (target only)"																																																							  ]
[ "mem_maxsize",	  "COMMAND:   ",  "mem_maxsize(lng) : void",								  "set the maximum usable amount of physical swapspace in KB"																																																								  ]
[ "mem_printmap",	  "COMMAND:   ",  "mem_printmap() : void",								  "print a map of all memory that is in use"																																																										  ]
[ "mem_usage",		  "COMMAND:   ",  "mem_usage(lng) : BAT[str,lng]",							  "get a split-up of how much memory blocks are in use."																																																								  ]
[ "memory",		  "PROC:      ",  "memory() : BAT[str,int]",								  "Global memory usage info"																																																												  ]
[ "module_db",		  "COMMAND:   ",  "module_db(str) : str",								  "extract database name from module string"																																																										  ]
[ "module_name",	  "COMMAND:   ",  "module_name(str) : str",								  "extract module name from module string"																																																										  ]
[ "modules",		  "PROC:      ",  "modules() : void",									  "list all installed modules, plus owner and db restrictions"																																																								  ]
[ "procs",		  "PROC:      ",  "procs() : void",									  "list all defined procs."																																																												  ]
[ "readonly",		  "PROC:      ",  "readonly(BAT[any::1,any::2]) : int",							  "deprecated. Use 'info.find(batRestricted)' instead."																																																									  ]
[ "readonly",		  "PROC:      ",  "readonly(BAT[any::1,any::2], int) : BAT[any::1,any::2]",				  "deprecated. Use 'b.access' instead."																																																											  ]
[ "rename",		  "PROC:      ",  "rename(BAT[any::1,any::2], str) : BAT[any::1,any::2]",				  "try to name a BAT and fail if it is not possible."																																																									  ]
[ "sigs",		  "PROC:      ",  "sigs(str) : void",									  "Show all signatures of the functions in a module."																																																									  ]
[ "threads",		  "PROC:      ",  "threads() : void",									  "list all system threads and their function."																																																										  ]
[ "vars",		  "PROC:      ",  "vars() : void",										  "list all Monet variables and their values. Optionally filter on name with a certain substring"																																																																  ]
[ "view_atom_align",	  "COMMAND:   ",  "view_atom_align() : BAT[int,int]",						  "Global type table alignment property"																																																										  ]
[ "view_atom_name",	  "COMMAND:   ",  "view_atom_name() : BAT[int,str]",						  "Global type table names"																																																												  ]
[ "view_atom_size",	  "COMMAND:   ",  "view_atom_size() : BAT[int,int]",						  "Global type table sizement property"																																																											  ]
[ "view_bbp_count",	  "COMMAND:   ",  "view_bbp_count() : BAT[int,lng]",							  "Pseudo bat to map a BAT id into its count"																																																																							  ]
[ "view_bbp_dirty",	  "COMMAND:   ",  "view_bbp_dirty() : BAT[int,str]",							  "Pseudo bat to map a BAT id into its dirty/diffs/clean status"																																																							  ]
[ "view_bbp_heat",	  "COMMAND:   ",  "view_bbp_heat() : BAT[int,int]",							  "Pseudo bat to map a BAT id into its name"																																																										  ]
[ "view_bbp_htype",	  "COMMAND:   ",  "view_bbp_htype() : BAT[int,str]",							  "Pseudo bat to map a BAT id into its head type"																																																																						  ]
[ "view_bbp_kind",	  "COMMAND:   ",  "view_bbp_kind() : BAT[int,str]",							  "Pseudo bat to map a BAT id into its type"																																																										  ]
[ "view_bbp_location",	  "COMMAND:   ",  "view_bbp_location() : BAT[int,str]",							  "Pseudo bat to map a BAT id into its disk location"																																																									  ]
[ "view_bbp_lrefcnt",	  "COMMAND:   ",  "view_bbp_lrefcnt() : BAT[int,int]",							  "Pseudo bat to map a BAT id into its logical reference count"																																																								  ]
[ "view_bbp_name",	  "COMMAND:   ",  "view_bbp_name() : BAT[int,str]",							  "Pseudo bat to map a BAT id into its name"																																																										  ]
[ "view_bbp_refcnt",	  "COMMAND:   ",  "view_bbp_refcnt() : BAT[int,int]",							  "Pseudo bat to map a BAT id into its reference count"																																																									  ]
[ "view_bbp_status",	  "COMMAND:   ",  "view_bbp_status() : BAT[int,str]",							  "Pseudo bat to map a BAT id into its disk/load status"																																																								  ]
[ "view_bbp_ttype",	  "COMMAND:   ",  "view_bbp_ttype() : BAT[int,str]",							  "Pseudo bat to map a BAT id into its tail type"																																																																						  ]
[ "view_client_login",	  "COMMAND:   ",  "view_client_login() : BAT[int,str]",							  "Pseudo bat to map client identifier to its login time"																																																								  ]
[ "view_client_name",	  "COMMAND:   ",  "view_client_name() : BAT[int,str]",							  "Pseudo bat to map client identifier to its name"																																																									  ]
[ "view_client_tree",	  "COMMAND:   ",  "view_client_tree() : BAT[int,str]",							  "Pseudo bat to map client identifier to its current active tree"																																																							  ]
[ "view_gdk_bbp",	  "COMMAND:   ",  "view_gdk_bbp() : BAT[str,int]",							  "Global BBP usage info"																																																												  ]
[ "view_gdk_cpu",	  "COMMAND:   ",  "view_gdk_cpu() : BAT[str,int]",							  "Global cpu usage info"																																																												  ]
[ "view_gdk_env",	  "COMMAND:   ",  "view_gdk_env() : BAT[str,str]",							  "List the values of all environment variables"																																																									  ]
[ "view_gdk_io",	  "COMMAND:   ",  "view_gdk_io() : BAT[str,int]",							  "Global IO activityinfo"																																																												  ]
[ "view_gdk_mem_histo",	  "COMMAND:   ",  "view_gdk_mem_histo() : BAT[lng,lng]",						  "Global memory histogram"																																																												  ]
[ "view_gdk_memory",	  "COMMAND:   ",  "view_gdk_memory() : BAT[str,int]",							  "Global memory usage info"																																																												  ]
[ "view_gdk_thread",	  "COMMAND:   ",  "view_gdk_thread() : BAT[int,str]",							  "Pseudo bat to map thread to name"																																																											  ]
[ "view_gdk_vm_histo",	  "COMMAND:   ",  "view_gdk_vm_histo() : BAT[lng,lng]",							  "Global virtual memory histogram"																																																											  ]
[ "view_modules",	  "COMMAND:   ",  "view_modules() : BAT[int,str]",							  "Pseudo bat with all currently available modules"																																																									  ]
[ "view_var_constant",	  "BUILTIN:   ",  "view_var_constant() : BAT[int,str] ",						  "Pseudo bat to map variable id to constant/changeable"																																																								  ]
[ "view_var_kind",	  "BUILTIN:   ",  "view_var_kind() : BAT[int,str] ",							  "Pseudo bat to map variable id to frozen/liquid"																																																									  ]
[ "view_var_name",	  "BUILTIN:   ",  "view_var_name() : BAT[int,str] ",							  "Pseudo bat to map variable id to its name."																																																										  ]
[ "view_var_type",	  "BUILTIN:   ",  "view_var_type() : BAT[int,str] ",							  "Pseudo bat to map variable id to its type (as a string)."																																																								  ]
[ "view_var_value",	  "BUILTIN:   ",  "view_var_value() : BAT[int,str] ",							  "Pseudo bat to map variable id to its value (as a string)."																																																								  ]
[ "vm_cursize",		  "COMMAND:   ",  "vm_cursize() : lng",									  "the amount of logical VM space in KB that is currently in use"																																																							  ]
[ "vm_maxsize",		  "COMMAND:   ",  "vm_maxsize() : lng",									  "the maximum usable amount of logical VM space in KB (target only)"																																																							  ]
[ "vm_maxsize",		  "COMMAND:   ",  "vm_maxsize(lng) : void",								  "set the maximum usable amount of physical swapspace in KB"																																																								  ]
[ "vm_minsize",		  "COMMAND:   ",  "vm_minsize() : lng",										  "Get the threshold. Block larger then this threshold will be mmapped."																																																																			  ]
[ "vm_minsize",		  "COMMAND:   ",  "vm_minsize(lng) : void",									  "Set the threshold. Block larger then this threshold will be mmapped."																																																																			  ]
[ "vm_trim",		  "COMMAND:   ",  "vm_trim(lng) : void",								  "flush memory maps"																																			  ]
[ "vm_usage",		  "COMMAND:   ",  "vm_usage(lng) : BAT[str,lng]",							  "get a split-up of how much virtual memory blocks are in use."																																																							  ]

Module: "trans"

[ 10 ]
#-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
# tmp_43		tmp_35		tmp_37											tmp_40																																																															  # name
# str		str		str											str																																																															  # type
#-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
[ "abort",	  "COMMAND:   ",  "abort() : bit",									  "brings all BATs back to state at last global commit"																																																									  ]
[ "abort",	  "COMMAND:   ",  "abort(BAT[any,any], ..BAT[any,any]..) : void",					  "undo the delta changes in a BAT."																																																											  ]
[ "alpha",	  "COMMAND:   ",  "alpha(BAT[any::1,any::2]) : BAT[any::1,any::2]",					  "give list of insertions since the previous state."																																																									  ]
[ "clean",	  "COMMAND:   ",  "clean(BAT[any,any], ..BAT[any,any]..) : void",					  "flush the delta status of a BAT.\n         (DANGER: it is marked clean, so these changes will not be committed to disk)."																																																  ]
[ "commit",	  "COMMAND:   ",  "commit() : bit",									  "global commit on all persistent BATs (to disk)"																																																									  ]
[ "commit",	  "COMMAND:   ",  "commit(BAT[any,any], ..BAT[any,any]..) : void",					  "flush the delta status of a BAT (it is *not* written to disk)."																																																							  ]
[ "delta",	  "COMMAND:   ",  "delta(BAT[any::1,any::2]) : BAT[any::1,any::2]",					  "give list of deletions since the previous state."																																																									  ]
[ "prev",	  "COMMAND:   ",  "prev(BAT[any::1,any::2]) : BAT[any::1,any::2]",					  "the previous state of this BAT"																																																											  ]
[ "subcommit",	  "COMMAND:   ",  "subcommit(BAT[any,BAT]) : bit",							  "commit only a set of BATs, passed in the tail of the bat-of-bats parameter.\n  These BATs should not need any rollback; either these should be new\n  persistent BATs that were not present in the last commit, or no-longer\n  persistent BATs that can be destroyed. Thus subcommit mostly serves to add\n  or remove persistent tables from a database (quickly)."																		  ]
[ "sync",	  "COMMAND:   ",  "sync() : bit",									  "save all persistent BATs"																																																												  ]

All.print();
[ 679 ]

quit();

# 15:30:04 >  
# 15:30:04 >  Done.
# 15:30:04 >  

