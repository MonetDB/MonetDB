stdout of test '02_Modules_plain` in directory 'tests/Availability` itself:


# 18:28:10 >  
# 18:28:10 >  Mtimeout -timeout 60 Mserver "--config=/var/tmp/_4.3.13-FixedPetersDDsync_PREFIX_MONET_GNU_32_d_--enable-warning_/etc/monet.conf" --debug=10 --set "monet_mod_path=/var/tmp/_4.3.13-FixedPetersDDsync_PREFIX_MONET_GNU_32_d_--enable-warning_/lib/MonetDB" --set "gdk_dbfarm=/var/tmp/_4.3.13-FixedPetersDDsync_PREFIX_MONET_GNU_32_d_--enable-warning_/var/MonetDB/dbfarm" --set "sql_logdir=/var/tmp/_4.3.13-FixedPetersDDsync_PREFIX_MONET_GNU_32_d_--enable-warning_/var/MonetDB/log" --set mapi_port=53708 --set sql_port=52024 --set monet_prompt= --trace --dbname=mTests_tests_Availability  < 02_Modules_plain.milS
# 18:28:10 >  

# Monet Database Server V4.5.0
# Copyright (c) 1993-2004, CWI. All rights reserved.
# Compiled for i686-pc-win32/32bit; dynamically linked.
# Visit http://monetdb.cwi.nl/ for further information.
setoid(oid(20000000));

var MODULES:=bat("MODULES");

var Static_fcn:=monet_fcntbl.reverse().copy();

var Fname:=new(oid,str);	Fname.col_name("function");
var FnameS:=new(oid,str);	FnameS.col_name("function");
var Ftype:=new(oid,str);	Ftype.col_name("type");
var Fsig:=new(oid,str);		Fsig.col_name("signature");
var Fhelp:=new(oid,str);	Fhelp.col_name("help");
var Fnts:=new(oid,str);

var Plain_mods:=MODULES.select("plain").sort().copy();
table(Plain_mods.reverse().col_name(sprintf("%i modules",Plain_mods.count())));
#-----------------#
# 24 modules	  # name
# str		  # type
#-----------------#
[ "aggr"	  ]
[ "aggrX3"	  ]
[ "alarm"	  ]
[ "ascii_io"	  ]
[ "bat_arith"	  ]
[ "blob"	  ]
[ "counters"	  ]
[ "decimal"	  ]
[ "enum"	  ]
[ "lock"	  ]
[ "logger"	  ]
[ "mapi"	  ]
[ "mkey"	  ]
[ "mmath"	  ]
[ "monettime"	  ]
[ "pcl"		  ]
[ "pcre"	  ]
[ "pqueue"	  ]
[ "profiler"	  ]
[ "radix"	  ]
[ "salgebra"	  ]
[ "stats"	  ]
[ "streams"	  ]
[ "tcpip"	  ]
[ "unix"	  ]
[ "upgrade"	  ]
[ "url"		  ]
[ "xtables"	  ]
Plain_mods@batloop() {
	var The_mod:=$h;
	printf("\nModule: \"%s\"\n\n",The_mod);
	module($h);

	var Mod_fcn:=sdiff(monet_fcntbl.reverse(),Static_fcn).reverse();
	Mod_fcn.sort()@batloop() {
	    var addThis:=false;
	    if (not(monet_fcn_mid.exist($t))) {
		addThis:=true;
	    } else {
		var m:=monet_mod_nme.find(monet_fcn_mid.find($t));
		if (m.startsWith("_")) {
		    m:=string(m,1);
		}
		if (m = The_mod) {
		    addThis:=true;
		}
	    }
	    if (addThis) {
		var Tname:=$h;
		var Ttype:=help_tpe(monet_fcn_tpe.find($t));
		var Tsig:=format_fcn_sig($t);
		var Thelp:="";
		if (monet_fcn_dsc.exist($t)) {
			Thelp:=monet_fcn_dsc.find($t);
		} else {
			Thelp:="not available";
		}
		Fname.insert($t,Tname);
		Ftype.insert($t,Ttype);
		Fsig.insert($t,Tsig);
		Fhelp.insert($t,Thelp);
		Fnts.insert($t,sprintf("%s %s %s",Tname,Ttype,Tsig));
	    }
	}

	drop($h);
	Static_fcn:=sunion(Static_fcn,monet_fcntbl.reverse());

	Fnts.count().print();
	Fnts.reverse().sort().reverse()@batloop() {
		FnameS.insert($h,Fname.find($h));
	}
	FnameS.count().print(); table(1,FnameS,Ftype,Fsig,Fhelp);

	Fname.delete();
	FnameS.delete();
	Ftype.delete();
	Fsig.delete();
	Fhelp.delete();
	Fnts.delete();
}

Module: "aggr"

[ 49 ]
[ 49 ]
#-------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
# function			type		signature							help								  # name
# str			str		str								str								  # type
#-------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
[ "card",		  "COMMAND:   ",  "card(BAT[any,any]) : int",					  "return the number of different values in a tail column"	  ]
[ "card",		  "COMMAND:   ",  "card(BAT[any,any], int) : int",				  "as card(b), but returns nil if card(b) > maxelements"	  ]
[ "hasNil",		  "COMMAND:   ",  "hasNil(BAT[any,any]) : bit",					  "return if there is a nil value in the tail column"		  ]
[ "size",		  "COMMAND:   ",  "size(BAT[any,bit]) : int",					  "return the number of true values in a tail column"		  ]
[ "size",		  "PROC:      ",  "size(BAT[any,bit]) : int",					  "not available"						  ]
[ "variance",		  "PROC:      ",  "variance(BAT[any,any::1]) : any::1",				  "not available"						  ]
[ "{avg}",		  "COMMAND:   ",  "{avg}(BAT[oid,dbl], BAT[oid,any]) : BAT[oid,dbl]",		  "grouped tail average"					  ]
[ "{avg}",		  "COMMAND:   ",  "{avg}(BAT[oid,flt], BAT[oid,any]) : BAT[oid,dbl]",		  "grouped tail average"					  ]
[ "{avg}",		  "COMMAND:   ",  "{avg}(BAT[oid,int], BAT[oid,any]) : BAT[oid,dbl]",		  "grouped tail average"					  ]
[ "{avg}",		  "COMMAND:   ",  "{avg}(BAT[oid,lng], BAT[oid,any]) : BAT[oid,dbl]",		  "grouped tail average"					  ]
[ "{avg}",		  "COMMAND:   ",  "{avg}(BAT[oid,sht], BAT[oid,any]) : BAT[oid,dbl]",		  "grouped tail average"					  ]
[ "{card}",		  "PROC:      ",  "{card}(BAT[oid,any], BAT[oid,any]) : BAT[oid,int]",		  "not available"						  ]
[ "{count_no_nil}",	  "PROC:      ",  "{count_no_nil}(BAT[oid,any], BAT[oid,any]) : BAT[oid,int]",	  "short-cut for {count}(b,e,TRUE)"				  ]
[ "{count}",		  "COMMAND:   ",  "{count}(BAT[oid,any], BAT[oid,any], bit) : BAT[oid,int]",	  "grouped count; ignores nil values iff ignore_nils==TRUE"	  ]
[ "{count}",		  "PROC:      ",  "{count}(BAT[oid,any], BAT[oid,any]) : BAT[oid,int]",		  "short-cut for {count}(b,e,FALSE)"				  ]
[ "{max}",		  "COMMAND:   ",  "{max}(BAT[oid,any::1], BAT[oid,any]) : BAT[oid,any::1]",	  "grouped tail maximum"					  ]
[ "{min}",		  "COMMAND:   ",  "{min}(BAT[oid,any::1], BAT[oid,any]) : BAT[oid,any::1]",	  "grouped tail minimum"					  ]
[ "{prod_dbl}",		  "COMMAND:   ",  "{prod_dbl}(BAT[oid,dbl], BAT[oid,any]) : BAT[oid,dbl]",	  "grouped tail product"					  ]
[ "{prod_dbl}",		  "COMMAND:   ",  "{prod_dbl}(BAT[oid,flt], BAT[oid,any]) : BAT[oid,dbl]",	  "grouped tail product"					  ]
[ "{prod_flt}",		  "COMMAND:   ",  "{prod_flt}(BAT[oid,flt], BAT[oid,any]) : BAT[oid,flt]",	  "grouped tail product"					  ]
[ "{prod_int}",		  "COMMAND:   ",  "{prod_int}(BAT[oid,int], BAT[oid,any]) : BAT[oid,int]",	  "grouped tail product"					  ]
[ "{prod_int}",		  "COMMAND:   ",  "{prod_int}(BAT[oid,sht], BAT[oid,any]) : BAT[oid,int]",	  "grouped tail product"					  ]
[ "{prod_lng}",		  "COMMAND:   ",  "{prod_lng}(BAT[oid,int], BAT[oid,any]) : BAT[oid,lng]",	  "grouped tail product"					  ]
[ "{prod_lng}",		  "COMMAND:   ",  "{prod_lng}(BAT[oid,lng], BAT[oid,any]) : BAT[oid,lng]",	  "grouped tail product"					  ]
[ "{prod_sht}",		  "COMMAND:   ",  "{prod_sht}(BAT[oid,sht], BAT[oid,any]) : BAT[oid,sht]",	  "grouped tail product"					  ]
[ "{prod}",		  "PROC:      ",  "{prod}(BAT[oid,dbl], BAT[oid,any]) : BAT[oid,dbl]",		  "not available"						  ]
[ "{prod}",		  "PROC:      ",  "{prod}(BAT[oid,flt], BAT[oid,any]) : BAT[oid,flt]",		  "not available"						  ]
[ "{prod}",		  "PROC:      ",  "{prod}(BAT[oid,int], BAT[oid,any]) : BAT[oid,int]",		  "not available"						  ]
[ "{prod}",		  "PROC:      ",  "{prod}(BAT[oid,lng], BAT[oid,any]) : BAT[oid,lng]",		  "not available"						  ]
[ "{prod}",		  "PROC:      ",  "{prod}(BAT[oid,sht], BAT[oid,any]) : BAT[oid,sht]",		  "not available"						  ]
[ "{size}",		  "COMMAND:   ",  "{size}(BAT[oid,bit], BAT[oid,any]) : BAT[oid,int]",		  "grouped count of true values"				  ]
[ "{sum_dbl}",		  "COMMAND:   ",  "{sum_dbl}(BAT[oid,dbl], BAT[oid,any]) : BAT[oid,dbl]",	  "grouped tail sum"						  ]
[ "{sum_dbl}",		  "COMMAND:   ",  "{sum_dbl}(BAT[oid,flt], BAT[oid,any]) : BAT[oid,dbl]",	  "grouped tail sum"						  ]
[ "{sum_flt}",		  "COMMAND:   ",  "{sum_flt}(BAT[oid,flt], BAT[oid,any]) : BAT[oid,flt]",	  "grouped tail sum"						  ]
[ "{sum_int}",		  "COMMAND:   ",  "{sum_int}(BAT[oid,int], BAT[oid,any]) : BAT[oid,int]",	  "grouped tail sum"						  ]
[ "{sum_int}",		  "COMMAND:   ",  "{sum_int}(BAT[oid,sht], BAT[oid,any]) : BAT[oid,int]",	  "grouped tail sum"						  ]
[ "{sum_lng}",		  "COMMAND:   ",  "{sum_lng}(BAT[oid,int], BAT[oid,any]) : BAT[oid,lng]",	  "grouped tail sum"						  ]
[ "{sum_lng}",		  "COMMAND:   ",  "{sum_lng}(BAT[oid,lng], BAT[oid,any]) : BAT[oid,lng]",	  "grouped tail sum"						  ]
[ "{sum_sht}",		  "COMMAND:   ",  "{sum_sht}(BAT[oid,sht], BAT[oid,any]) : BAT[oid,sht]",	  "grouped tail sum"						  ]
[ "{sum}",		  "PROC:      ",  "{sum}(BAT[oid,dbl], BAT[oid,any]) : BAT[oid,dbl]",		  "not available"						  ]
[ "{sum}",		  "PROC:      ",  "{sum}(BAT[oid,flt], BAT[oid,any]) : BAT[oid,flt]",		  "not available"						  ]
[ "{sum}",		  "PROC:      ",  "{sum}(BAT[oid,int], BAT[oid,any]) : BAT[oid,int]",		  "not available"						  ]
[ "{sum}",		  "PROC:      ",  "{sum}(BAT[oid,lng], BAT[oid,any]) : BAT[oid,lng]",		  "not available"						  ]
[ "{sum}",		  "PROC:      ",  "{sum}(BAT[oid,sht], BAT[oid,any]) : BAT[oid,sht]",		  "not available"						  ]
[ "{variance}",		  "COMMAND:   ",  "{variance}(BAT[oid,dbl], BAT[oid,any]) : BAT[oid,dbl]",	  "grouped tail variance"					  ]
[ "{variance}",		  "COMMAND:   ",  "{variance}(BAT[oid,flt], BAT[oid,any]) : BAT[oid,flt]",	  "grouped tail variance"					  ]
[ "{variance}",		  "COMMAND:   ",  "{variance}(BAT[oid,int], BAT[oid,any]) : BAT[oid,int]",	  "grouped tail variance"					  ]
[ "{variance}",		  "COMMAND:   ",  "{variance}(BAT[oid,lng], BAT[oid,any]) : BAT[oid,lng]",	  "grouped tail variance"					  ]
[ "{variance}",		  "COMMAND:   ",  "{variance}(BAT[oid,sht], BAT[oid,any]) : BAT[oid,sht]",	  "grouped tail variance"					  ]

Module: "aggrX3"

[ 81 ]
[ 81 ]
#-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
# function			type		signature									help								  # name
# str			str		str										str								  # type
#-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
[ "card",		  "PROC:      ",  "card(BAT[any,any]) : int",							  "not available"						  ]
[ "size",		  "PROC:      ",  "size(BAT[any,bit]) : int",							  "not available"						  ]
[ "{avg}",		  "COMMAND:   ",  "{avg}(BAT[oid,dbl], BAT[oid,any]) : BAT[oid,dbl]",				  "grouped tail average on dbl"					  ]
[ "{avg}",		  "COMMAND:   ",  "{avg}(BAT[oid,dbl], BAT[oid,oid], BAT[oid,any]) : BAT[oid,dbl]",		  "grouped tail average on dbl"					  ]
[ "{avg}",		  "COMMAND:   ",  "{avg}(BAT[oid,flt], BAT[oid,any]) : BAT[oid,dbl]",				  "grouped tail average on flt"					  ]
[ "{avg}",		  "COMMAND:   ",  "{avg}(BAT[oid,flt], BAT[oid,oid], BAT[oid,any]) : BAT[oid,dbl]",		  "grouped tail average on flt"					  ]
[ "{avg}",		  "COMMAND:   ",  "{avg}(BAT[oid,int], BAT[oid,any]) : BAT[oid,dbl]",				  "grouped tail average on int"					  ]
[ "{avg}",		  "COMMAND:   ",  "{avg}(BAT[oid,int], BAT[oid,oid], BAT[oid,any]) : BAT[oid,dbl]",		  "grouped tail average on int"					  ]
[ "{avg}",		  "COMMAND:   ",  "{avg}(BAT[oid,lng], BAT[oid,any]) : BAT[oid,dbl]",				  "grouped tail average on lng"					  ]
[ "{avg}",		  "COMMAND:   ",  "{avg}(BAT[oid,lng], BAT[oid,oid], BAT[oid,any]) : BAT[oid,dbl]",		  "grouped tail average on lng"					  ]
[ "{avg}",		  "COMMAND:   ",  "{avg}(BAT[oid,sht], BAT[oid,any]) : BAT[oid,dbl]",				  "grouped tail average on sht"					  ]
[ "{avg}",		  "COMMAND:   ",  "{avg}(BAT[oid,sht], BAT[oid,oid], BAT[oid,any]) : BAT[oid,dbl]",		  "grouped tail average on sht"					  ]
[ "{card}",		  "PROC:      ",  "{card}(BAT[oid,any], BAT[oid,any]) : BAT[oid,int]",				  "not available"						  ]
[ "{card}",		  "PROC:      ",  "{card}(BAT[oid,any], BAT[oid,oid], BAT[oid,any]) : BAT[oid,int]",		  "not available"						  ]
[ "{count_no_nil}",	  "PROC:      ",  "{count_no_nil}(BAT[oid,any], BAT[oid,any]) : BAT[oid,int]",			  "short-cut for {count}(b,e,TRUE)"				  ]
[ "{count_no_nil}",	  "PROC:      ",  "{count_no_nil}(BAT[oid,any], BAT[oid,oid], BAT[oid,any]) : BAT[oid,int]",	  "short-cut for {count}(b,g,e,TRUE)"				  ]
[ "{count}",		  "COMMAND:   ",  "{count}(BAT[oid,any], BAT[oid,any], bit) : BAT[oid,int]",			  "grouped count; ignores nil values iff ignore_nils==TRUE"	  ]
[ "{count}",		  "COMMAND:   ",  "{count}(BAT[oid,any], BAT[oid,oid], BAT[oid,any], bit) : BAT[oid,int]",	  "grouped count; ignores nil values iff ignore_nils==TRUE"	  ]
[ "{count}",		  "PROC:      ",  "{count}(BAT[oid,any], BAT[oid,any]) : BAT[oid,int]",				  "short-cut for {count}(b,e,FALSE)"				  ]
[ "{count}",		  "PROC:      ",  "{count}(BAT[oid,any], BAT[oid,oid], BAT[oid,any]) : BAT[oid,int]",		  "short-cut for {count}(b,g,e,FALSE)"				  ]
[ "{max}",		  "COMMAND:   ",  "{max}(BAT[oid,any::1], BAT[oid,any]) : BAT[oid,any::1]",			  "grouped tail maximum"					  ]
[ "{max}",		  "COMMAND:   ",  "{max}(BAT[oid,any::1], BAT[oid,oid], BAT[oid,any]) : BAT[oid,any::1]",	  "grouped tail maximum"					  ]
[ "{min}",		  "COMMAND:   ",  "{min}(BAT[oid,any::1], BAT[oid,any]) : BAT[oid,any::1]",			  "grouped tail minimum"					  ]
[ "{min}",		  "COMMAND:   ",  "{min}(BAT[oid,any::1], BAT[oid,oid], BAT[oid,any]) : BAT[oid,any::1]",	  "grouped tail minimum"					  ]
[ "{prod_dbl}",		  "COMMAND:   ",  "{prod_dbl}(BAT[oid,dbl], BAT[oid,any]) : BAT[oid,dbl]",			  "grouped tail prod on dbl"					  ]
[ "{prod_dbl}",		  "COMMAND:   ",  "{prod_dbl}(BAT[oid,dbl], BAT[oid,oid], BAT[oid,any]) : BAT[oid,dbl]",	  "grouped tail prod on dbl"					  ]
[ "{prod_dbl}",		  "COMMAND:   ",  "{prod_dbl}(BAT[oid,flt], BAT[oid,any]) : BAT[oid,dbl]",			  "grouped tail prod on flt"					  ]
[ "{prod_dbl}",		  "COMMAND:   ",  "{prod_dbl}(BAT[oid,flt], BAT[oid,oid], BAT[oid,any]) : BAT[oid,dbl]",	  "grouped tail prod on flt"					  ]
[ "{prod_flt}",		  "COMMAND:   ",  "{prod_flt}(BAT[oid,flt], BAT[oid,any]) : BAT[oid,flt]",			  "grouped tail prod on flt"					  ]
[ "{prod_flt}",		  "COMMAND:   ",  "{prod_flt}(BAT[oid,flt], BAT[oid,oid], BAT[oid,any]) : BAT[oid,flt]",	  "grouped tail prod on flt"					  ]
[ "{prod_int}",		  "COMMAND:   ",  "{prod_int}(BAT[oid,int], BAT[oid,any]) : BAT[oid,int]",			  "grouped tail prod on int"					  ]
[ "{prod_int}",		  "COMMAND:   ",  "{prod_int}(BAT[oid,int], BAT[oid,oid], BAT[oid,any]) : BAT[oid,int]",	  "grouped tail prod on int"					  ]
[ "{prod_int}",		  "COMMAND:   ",  "{prod_int}(BAT[oid,sht], BAT[oid,any]) : BAT[oid,int]",			  "grouped tail prod on sht"					  ]
[ "{prod_int}",		  "COMMAND:   ",  "{prod_int}(BAT[oid,sht], BAT[oid,oid], BAT[oid,any]) : BAT[oid,int]",	  "grouped tail prod on sht"					  ]
[ "{prod_lng}",		  "COMMAND:   ",  "{prod_lng}(BAT[oid,int], BAT[oid,any]) : BAT[oid,lng]",			  "grouped tail prod on int"					  ]
[ "{prod_lng}",		  "COMMAND:   ",  "{prod_lng}(BAT[oid,int], BAT[oid,oid], BAT[oid,any]) : BAT[oid,lng]",	  "grouped tail prod on int"					  ]
[ "{prod_lng}",		  "COMMAND:   ",  "{prod_lng}(BAT[oid,lng], BAT[oid,any]) : BAT[oid,lng]",			  "grouped tail prod on lng"					  ]
[ "{prod_lng}",		  "COMMAND:   ",  "{prod_lng}(BAT[oid,lng], BAT[oid,oid], BAT[oid,any]) : BAT[oid,lng]",	  "grouped tail prod on lng"					  ]
[ "{prod_lng}",		  "COMMAND:   ",  "{prod_lng}(BAT[oid,sht], BAT[oid,any]) : BAT[oid,lng]",			  "grouped tail prod on sht"					  ]
[ "{prod_lng}",		  "COMMAND:   ",  "{prod_lng}(BAT[oid,sht], BAT[oid,oid], BAT[oid,any]) : BAT[oid,lng]",	  "grouped tail prod on sht"					  ]
[ "{prod_sht}",		  "COMMAND:   ",  "{prod_sht}(BAT[oid,sht], BAT[oid,any]) : BAT[oid,sht]",			  "grouped tail prod on sht"					  ]
[ "{prod_sht}",		  "COMMAND:   ",  "{prod_sht}(BAT[oid,sht], BAT[oid,oid], BAT[oid,any]) : BAT[oid,sht]",	  "grouped tail prod on sht"					  ]
[ "{prod}",		  "PROC:      ",  "{prod}(BAT[oid,dbl], BAT[oid,any]) : BAT[oid,dbl]",				  "not available"						  ]
[ "{prod}",		  "PROC:      ",  "{prod}(BAT[oid,dbl], BAT[oid,oid], BAT[oid,any]) : BAT[oid,dbl]",		  "not available"						  ]
[ "{prod}",		  "PROC:      ",  "{prod}(BAT[oid,flt], BAT[oid,any]) : BAT[oid,flt]",				  "not available"						  ]
[ "{prod}",		  "PROC:      ",  "{prod}(BAT[oid,flt], BAT[oid,oid], BAT[oid,any]) : BAT[oid,flt]",		  "not available"						  ]
[ "{prod}",		  "PROC:      ",  "{prod}(BAT[oid,int], BAT[oid,any]) : BAT[oid,int]",				  "not available"						  ]
[ "{prod}",		  "PROC:      ",  "{prod}(BAT[oid,int], BAT[oid,oid], BAT[oid,any]) : BAT[oid,int]",		  "not available"						  ]
[ "{prod}",		  "PROC:      ",  "{prod}(BAT[oid,lng], BAT[oid,any]) : BAT[oid,lng]",				  "not available"						  ]
[ "{prod}",		  "PROC:      ",  "{prod}(BAT[oid,lng], BAT[oid,oid], BAT[oid,any]) : BAT[oid,lng]",		  "not available"						  ]
[ "{prod}",		  "PROC:      ",  "{prod}(BAT[oid,sht], BAT[oid,any]) : BAT[oid,sht]",				  "not available"						  ]
[ "{prod}",		  "PROC:      ",  "{prod}(BAT[oid,sht], BAT[oid,oid], BAT[oid,any]) : BAT[oid,sht]",		  "not available"						  ]
[ "{size}",		  "COMMAND:   ",  "{size}(BAT[oid,bit], BAT[oid,any]) : BAT[oid,int]",				  "grouped count of true values"				  ]
[ "{sum_dbl}",		  "COMMAND:   ",  "{sum_dbl}(BAT[oid,dbl], BAT[oid,any]) : BAT[oid,dbl]",			  "grouped tail sum on dbl"					  ]
[ "{sum_dbl}",		  "COMMAND:   ",  "{sum_dbl}(BAT[oid,dbl], BAT[oid,oid], BAT[oid,any]) : BAT[oid,dbl]",		  "grouped tail sum on dbl"					  ]
[ "{sum_dbl}",		  "COMMAND:   ",  "{sum_dbl}(BAT[oid,flt], BAT[oid,any]) : BAT[oid,dbl]",			  "grouped tail sum on flt"					  ]
[ "{sum_dbl}",		  "COMMAND:   ",  "{sum_dbl}(BAT[oid,flt], BAT[oid,oid], BAT[oid,any]) : BAT[oid,dbl]",		  "grouped tail sum on flt"					  ]
[ "{sum_flt}",		  "COMMAND:   ",  "{sum_flt}(BAT[oid,flt], BAT[oid,any]) : BAT[oid,flt]",			  "grouped tail sum on flt"					  ]
[ "{sum_flt}",		  "COMMAND:   ",  "{sum_flt}(BAT[oid,flt], BAT[oid,oid], BAT[oid,any]) : BAT[oid,flt]",		  "grouped tail sum on flt"					  ]
[ "{sum_int}",		  "COMMAND:   ",  "{sum_int}(BAT[oid,int], BAT[oid,any]) : BAT[oid,int]",			  "grouped tail sum on int"					  ]
[ "{sum_int}",		  "COMMAND:   ",  "{sum_int}(BAT[oid,int], BAT[oid,oid], BAT[oid,any]) : BAT[oid,int]",		  "grouped tail sum on int"					  ]
[ "{sum_int}",		  "COMMAND:   ",  "{sum_int}(BAT[oid,sht], BAT[oid,any]) : BAT[oid,int]",			  "grouped tail sum on sht"					  ]
[ "{sum_int}",		  "COMMAND:   ",  "{sum_int}(BAT[oid,sht], BAT[oid,oid], BAT[oid,any]) : BAT[oid,int]",		  "grouped tail sum on sht"					  ]
[ "{sum_lng}",		  "COMMAND:   ",  "{sum_lng}(BAT[oid,int], BAT[oid,any]) : BAT[oid,lng]",			  "grouped tail sum on int"					  ]
[ "{sum_lng}",		  "COMMAND:   ",  "{sum_lng}(BAT[oid,int], BAT[oid,oid], BAT[oid,any]) : BAT[oid,lng]",		  "grouped tail sum on int"					  ]
[ "{sum_lng}",		  "COMMAND:   ",  "{sum_lng}(BAT[oid,lng], BAT[oid,any]) : BAT[oid,lng]",			  "grouped tail sum on lng"					  ]
[ "{sum_lng}",		  "COMMAND:   ",  "{sum_lng}(BAT[oid,lng], BAT[oid,oid], BAT[oid,any]) : BAT[oid,lng]",		  "grouped tail sum on lng"					  ]
[ "{sum_lng}",		  "COMMAND:   ",  "{sum_lng}(BAT[oid,sht], BAT[oid,any]) : BAT[oid,lng]",			  "grouped tail sum on sht"					  ]
[ "{sum_lng}",		  "COMMAND:   ",  "{sum_lng}(BAT[oid,sht], BAT[oid,oid], BAT[oid,any]) : BAT[oid,lng]",		  "grouped tail sum on sht"					  ]
[ "{sum_sht}",		  "COMMAND:   ",  "{sum_sht}(BAT[oid,sht], BAT[oid,any]) : BAT[oid,sht]",			  "grouped tail sum on sht"					  ]
[ "{sum_sht}",		  "COMMAND:   ",  "{sum_sht}(BAT[oid,sht], BAT[oid,oid], BAT[oid,any]) : BAT[oid,sht]",		  "grouped tail sum on sht"					  ]
[ "{sum}",		  "PROC:      ",  "{sum}(BAT[oid,dbl], BAT[oid,any]) : BAT[oid,dbl]",				  "not available"						  ]
[ "{sum}",		  "PROC:      ",  "{sum}(BAT[oid,dbl], BAT[oid,oid], BAT[oid,any]) : BAT[oid,dbl]",		  "not available"						  ]
[ "{sum}",		  "PROC:      ",  "{sum}(BAT[oid,flt], BAT[oid,any]) : BAT[oid,flt]",				  "not available"						  ]
[ "{sum}",		  "PROC:      ",  "{sum}(BAT[oid,flt], BAT[oid,oid], BAT[oid,any]) : BAT[oid,flt]",		  "not available"						  ]
[ "{sum}",		  "PROC:      ",  "{sum}(BAT[oid,int], BAT[oid,any]) : BAT[oid,int]",				  "not available"						  ]
[ "{sum}",		  "PROC:      ",  "{sum}(BAT[oid,int], BAT[oid,oid], BAT[oid,any]) : BAT[oid,int]",		  "not available"						  ]
[ "{sum}",		  "PROC:      ",  "{sum}(BAT[oid,lng], BAT[oid,any]) : BAT[oid,lng]",				  "not available"						  ]
[ "{sum}",		  "PROC:      ",  "{sum}(BAT[oid,lng], BAT[oid,oid], BAT[oid,any]) : BAT[oid,lng]",		  "not available"						  ]
[ "{sum}",		  "PROC:      ",  "{sum}(BAT[oid,sht], BAT[oid,any]) : BAT[oid,sht]",				  "not available"						  ]
[ "{sum}",		  "PROC:      ",  "{sum}(BAT[oid,sht], BAT[oid,oid], BAT[oid,any]) : BAT[oid,sht]",		  "not available"						  ]

Module: "alarm"

[ 7 ]
[ 7 ]
#---------------------------------------------------------------------------------------------------------#
# function		type		signature			help					  # name
# str		str		str				str					  # type
#---------------------------------------------------------------------------------------------------------#
[ "alarm",	  "COMMAND:   ",  "alarm(int, str) : void",	  "execute action in X secs"		  ]
[ "ctime",	  "COMMAND:   ",  "ctime() : str",		  "current time as a string"		  ]
[ "epoch",	  "COMMAND:   ",  "epoch() : int",		  "current time as unix epoch"		  ]
[ "sleep",	  "COMMAND:   ",  "sleep(int) : void",		  "sleep X secs"			  ]
[ "time",	  "COMMAND:   ",  "time() : int",		  "time in milliseconds"		  ]
[ "timers",	  "COMMAND:   ",  "timers() : BAT[str,str]",	  "give a list of all active timers"	  ]
[ "usec",	  "COMMAND:   ",  "usec() : lng",		  "time in microseconds"		  ]

Module: "ascii_io"

[ 20 ]
[ 20 ]
#---------------------------------------------------------------------------------------------------------------------------------------------------------#
# function			type		signature										help			  # name
# str			str		str											str			  # type
#---------------------------------------------------------------------------------------------------------------------------------------------------------#
[ "ascii_io_debug",	  "COMMAND:   ",  "ascii_io_debug(int) : void",								  ""			  ]
[ "bat_ttype",		  "PROC:      ",  "bat_ttype(BAT[any,any]) : str",							  "not available"	  ]
[ "dump",		  "COMMAND:   ",  "dump(BAT[void,str], BAT[void,str], BAT[void,BAT], str, int) : void",			  ""			  ]
[ "dump_data",		  "PROC:      ",  "dump_data(BAT[str,BAT], BAT[str,BAT], str, int) : void",				  "not available"	  ]
[ "dump_data",		  "PROC:      ",  "dump_data(BAT[str,BAT], str, int) : void",						  "not available"	  ]
[ "dump_format",	  "PROC:      ",  "dump_format(BAT[void,BAT], str) : BAT[str,BAT]",					  "not available"	  ]
[ "dump_seps",		  "PROC:      ",  "dump_seps(BAT[void,BAT]) : BAT[void,str]",						  "not available"	  ]
[ "export",		  "PROC:      ",  "export(BAT[any,any], str) : void",							  "not available"	  ]
[ "fclose",		  "PROC:      ",  "fclose(Stream) : void",								  "not available"	  ]
[ "fflush",		  "PROC:      ",  "fflush(Stream) : void",								  "not available"	  ]
[ "fopen",		  "PROC:      ",  "fopen(str, str) : Stream",								  "not available"	  ]
[ "fputs",		  "PROC:      ",  "fputs(str, Stream) : void",								  "not available"	  ]
[ "import",		  "PROC:      ",  "import(BAT[any,any], str) : BAT[any,any]",						  "not available"	  ]
[ "input",		  "COMMAND:   ",  "input(BAT[void,str], BAT[void,str], BAT[void,str], Stream, int) : BAT[str,BAT]",	  ""			  ]
[ "load",		  "COMMAND:   ",  "load(BAT[void,str], BAT[void,str], BAT[void,str], str, int) : BAT[str,BAT]",		  ""			  ]
[ "load_data",		  "PROC:      ",  "load_data(BAT[str,BAT], str, int) : BAT[str,BAT]",					  "Load data given Mload-style format; limit to nr elements (all if -1)"  ]
[ "load_format",	  "PROC:      ",  "load_format(str) : BAT[str,BAT]",							  "Load Mload-style format file fmt"					  ]
[ "make_persistent",	  "PROC:      ",  "make_persistent(BAT[str,BAT]) : void",						  "Make loaded bats persistent."					  ]
[ "merge_data",		  "PROC:      ",  "merge_data(BAT[str,BAT]) : void",							  "Merge loaded bats with existing ones."				  ]
[ "output",		  "COMMAND:   ",  "output(BAT[any,any], BAT[void,str], BAT[void,BAT], Stream) : void",			  ""			  ]

Module: "bat_arith"

[ 138 ]
[ 138 ]
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
# function		type		signature						help														  # name
# str		str		str							str														  # type
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
[ "[%]",	  "OPERATOR:  ",  "[%](BAT[void,int], BAT[void,int]) : BAT[void,int]",	  "optimized multiplexed mod ('%') on head-aligned [void,int] BATs"						  ]
[ "[%]",	  "OPERATOR:  ",  "[%](BAT[void,int], int) : BAT[void,int]",		  "optimized multiplexed right-scalar mod ('%') on [void,int] BAT"						  ]
[ "[%]",	  "OPERATOR:  ",  "[%](BAT[void,lng], BAT[void,lng]) : BAT[void,lng]",	  "optimized multiplexed mod ('%') on head-aligned [void,lng] BATs"						  ]
[ "[%]",	  "OPERATOR:  ",  "[%](BAT[void,lng], lng) : BAT[void,lng]",		  "optimized multiplexed right-scalar mod ('%') on [void,lng] BAT"						  ]
[ "[%]",	  "OPERATOR:  ",  "[%](BAT[void,sht], BAT[void,sht]) : BAT[void,sht]",	  "optimized multiplexed mod ('%') on head-aligned [void,sht] BATs"						  ]
[ "[%]",	  "OPERATOR:  ",  "[%](BAT[void,sht], sht) : BAT[void,sht]",		  "optimized multiplexed right-scalar mod ('%') on [void,sht] BAT"						  ]
[ "[%]",	  "OPERATOR:  ",  "[%](int, BAT[void,int]) : BAT[void,int]",		  "optimized multiplexed left-scalar mod ('%') on [void,int] BAT"						  ]
[ "[%]",	  "OPERATOR:  ",  "[%](lng, BAT[void,lng]) : BAT[void,lng]",		  "optimized multiplexed left-scalar mod ('%') on [void,lng] BAT"						  ]
[ "[%]",	  "OPERATOR:  ",  "[%](sht, BAT[void,sht]) : BAT[void,sht]",		  "optimized multiplexed left-scalar mod ('%') on [void,sht] BAT"						  ]
[ "[*]",	  "OPERATOR:  ",  "[*](BAT[void,dbl], BAT[void,dbl]) : BAT[void,dbl]",	  "optimized multiplexed mul ('*') on head-aligned [void,dbl] BATs"						  ]
[ "[*]",	  "OPERATOR:  ",  "[*](BAT[void,dbl], dbl) : BAT[void,dbl]",		  "optimized multiplexed right-scalar mul ('*') on [void,dbl] BAT"						  ]
[ "[*]",	  "OPERATOR:  ",  "[*](BAT[void,flt], BAT[void,flt]) : BAT[void,flt]",	  "optimized multiplexed mul ('*') on head-aligned [void,flt] BATs"						  ]
[ "[*]",	  "OPERATOR:  ",  "[*](BAT[void,flt], flt) : BAT[void,flt]",		  "optimized multiplexed right-scalar mul ('*') on [void,flt] BAT"						  ]
[ "[*]",	  "OPERATOR:  ",  "[*](BAT[void,int], BAT[void,int]) : BAT[void,int]",	  "optimized multiplexed mul ('*') on head-aligned [void,int] BATs"						  ]
[ "[*]",	  "OPERATOR:  ",  "[*](BAT[void,int], int) : BAT[void,int]",		  "optimized multiplexed right-scalar mul ('*') on [void,int] BAT"						  ]
[ "[*]",	  "OPERATOR:  ",  "[*](BAT[void,lng], BAT[void,lng]) : BAT[void,lng]",	  "optimized multiplexed mul ('*') on head-aligned [void,lng] BATs"						  ]
[ "[*]",	  "OPERATOR:  ",  "[*](BAT[void,lng], lng) : BAT[void,lng]",		  "optimized multiplexed right-scalar mul ('*') on [void,lng] BAT"						  ]
[ "[*]",	  "OPERATOR:  ",  "[*](BAT[void,sht], BAT[void,sht]) : BAT[void,sht]",	  "optimized multiplexed mul ('*') on head-aligned [void,sht] BATs"						  ]
[ "[*]",	  "OPERATOR:  ",  "[*](BAT[void,sht], sht) : BAT[void,sht]",		  "optimized multiplexed right-scalar mul ('*') on [void,sht] BAT"						  ]
[ "[*]",	  "OPERATOR:  ",  "[*](dbl, BAT[void,dbl]) : BAT[void,dbl]",		  "optimized multiplexed left-scalar mul ('*') on [void,dbl] BAT"						  ]
[ "[*]",	  "OPERATOR:  ",  "[*](flt, BAT[void,flt]) : BAT[void,flt]",		  "optimized multiplexed left-scalar mul ('*') on [void,flt] BAT"						  ]
[ "[*]",	  "OPERATOR:  ",  "[*](int, BAT[void,int]) : BAT[void,int]",		  "optimized multiplexed left-scalar mul ('*') on [void,int] BAT"						  ]
[ "[*]",	  "OPERATOR:  ",  "[*](lng, BAT[void,lng]) : BAT[void,lng]",		  "optimized multiplexed left-scalar mul ('*') on [void,lng] BAT"						  ]
[ "[*]",	  "OPERATOR:  ",  "[*](sht, BAT[void,sht]) : BAT[void,sht]",		  "optimized multiplexed left-scalar mul ('*') on [void,sht] BAT"						  ]
[ "[+]",	  "OPERATOR:  ",  "[+](BAT[void,dbl], BAT[void,dbl]) : BAT[void,dbl]",	  "optimized multiplexed add ('+') on head-aligned [void,dbl] BATs"						  ]
[ "[+]",	  "OPERATOR:  ",  "[+](BAT[void,dbl], dbl) : BAT[void,dbl]",		  "optimized multiplexed right-scalar add ('+') on [void,dbl] BAT"						  ]
[ "[+]",	  "OPERATOR:  ",  "[+](BAT[void,flt], BAT[void,flt]) : BAT[void,flt]",	  "optimized multiplexed add ('+') on head-aligned [void,flt] BATs"						  ]
[ "[+]",	  "OPERATOR:  ",  "[+](BAT[void,flt], flt) : BAT[void,flt]",		  "optimized multiplexed right-scalar add ('+') on [void,flt] BAT"						  ]
[ "[+]",	  "OPERATOR:  ",  "[+](BAT[void,int], BAT[void,int]) : BAT[void,int]",	  "optimized multiplexed add ('+') on head-aligned [void,int] BATs"						  ]
[ "[+]",	  "OPERATOR:  ",  "[+](BAT[void,int], int) : BAT[void,int]",		  "optimized multiplexed right-scalar add ('+') on [void,int] BAT"						  ]
[ "[+]",	  "OPERATOR:  ",  "[+](BAT[void,lng], BAT[void,lng]) : BAT[void,lng]",	  "optimized multiplexed add ('+') on head-aligned [void,lng] BATs"						  ]
[ "[+]",	  "OPERATOR:  ",  "[+](BAT[void,lng], lng) : BAT[void,lng]",		  "optimized multiplexed right-scalar add ('+') on [void,lng] BAT"						  ]
[ "[+]",	  "OPERATOR:  ",  "[+](BAT[void,sht], BAT[void,sht]) : BAT[void,sht]",	  "optimized multiplexed add ('+') on head-aligned [void,sht] BATs"						  ]
[ "[+]",	  "OPERATOR:  ",  "[+](BAT[void,sht], sht) : BAT[void,sht]",		  "optimized multiplexed right-scalar add ('+') on [void,sht] BAT"						  ]
[ "[+]",	  "OPERATOR:  ",  "[+](dbl, BAT[void,dbl]) : BAT[void,dbl]",		  "optimized multiplexed left-scalar add ('+') on [void,dbl] BAT"						  ]
[ "[+]",	  "OPERATOR:  ",  "[+](flt, BAT[void,flt]) : BAT[void,flt]",		  "optimized multiplexed left-scalar add ('+') on [void,flt] BAT"						  ]
[ "[+]",	  "OPERATOR:  ",  "[+](int, BAT[void,int]) : BAT[void,int]",		  "optimized multiplexed left-scalar add ('+') on [void,int] BAT"						  ]
[ "[+]",	  "OPERATOR:  ",  "[+](lng, BAT[void,lng]) : BAT[void,lng]",		  "optimized multiplexed left-scalar add ('+') on [void,lng] BAT"						  ]
[ "[+]",	  "OPERATOR:  ",  "[+](sht, BAT[void,sht]) : BAT[void,sht]",		  "optimized multiplexed left-scalar add ('+') on [void,sht] BAT"						  ]
[ "[-]",	  "OPERATOR:  ",  "[-](BAT[void,dbl], BAT[void,dbl]) : BAT[void,dbl]",	  "optimized multiplexed sub ('-') on head-aligned [void,dbl] BATs"						  ]
[ "[-]",	  "OPERATOR:  ",  "[-](BAT[void,dbl], dbl) : BAT[void,dbl]",		  "optimized multiplexed right-scalar sub ('-') on [void,dbl] BAT"						  ]
[ "[-]",	  "OPERATOR:  ",  "[-](BAT[void,flt], BAT[void,flt]) : BAT[void,flt]",	  "optimized multiplexed sub ('-') on head-aligned [void,flt] BATs"						  ]
[ "[-]",	  "OPERATOR:  ",  "[-](BAT[void,flt], flt) : BAT[void,flt]",		  "optimized multiplexed right-scalar sub ('-') on [void,flt] BAT"						  ]
[ "[-]",	  "OPERATOR:  ",  "[-](BAT[void,int], BAT[void,int]) : BAT[void,int]",	  "optimized multiplexed sub ('-') on head-aligned [void,int] BATs"						  ]
[ "[-]",	  "OPERATOR:  ",  "[-](BAT[void,int], int) : BAT[void,int]",		  "optimized multiplexed right-scalar sub ('-') on [void,int] BAT"						  ]
[ "[-]",	  "OPERATOR:  ",  "[-](BAT[void,lng], BAT[void,lng]) : BAT[void,lng]",	  "optimized multiplexed sub ('-') on head-aligned [void,lng] BATs"						  ]
[ "[-]",	  "OPERATOR:  ",  "[-](BAT[void,lng], lng) : BAT[void,lng]",		  "optimized multiplexed right-scalar sub ('-') on [void,lng] BAT"						  ]
[ "[-]",	  "OPERATOR:  ",  "[-](BAT[void,sht], BAT[void,sht]) : BAT[void,sht]",	  "optimized multiplexed sub ('-') on head-aligned [void,sht] BATs"						  ]
[ "[-]",	  "OPERATOR:  ",  "[-](BAT[void,sht], sht) : BAT[void,sht]",		  "optimized multiplexed right-scalar sub ('-') on [void,sht] BAT"						  ]
[ "[-]",	  "OPERATOR:  ",  "[-](dbl, BAT[void,dbl]) : BAT[void,dbl]",		  "optimized multiplexed left-scalar sub ('-') on [void,dbl] BAT"						  ]
[ "[-]",	  "OPERATOR:  ",  "[-](flt, BAT[void,flt]) : BAT[void,flt]",		  "optimized multiplexed left-scalar sub ('-') on [void,flt] BAT"						  ]
[ "[-]",	  "OPERATOR:  ",  "[-](int, BAT[void,int]) : BAT[void,int]",		  "optimized multiplexed left-scalar sub ('-') on [void,int] BAT"						  ]
[ "[-]",	  "OPERATOR:  ",  "[-](lng, BAT[void,lng]) : BAT[void,lng]",		  "optimized multiplexed left-scalar sub ('-') on [void,lng] BAT"						  ]
[ "[-]",	  "OPERATOR:  ",  "[-](sht, BAT[void,sht]) : BAT[void,sht]",		  "optimized multiplexed left-scalar sub ('-') on [void,sht] BAT"						  ]
[ "[/]",	  "OPERATOR:  ",  "[/](BAT[void,dbl], BAT[void,dbl]) : BAT[void,dbl]",	  "optimized multiplexed div ('/') on head-aligned [void,dbl] BATs"						  ]
[ "[/]",	  "OPERATOR:  ",  "[/](BAT[void,dbl], dbl) : BAT[void,dbl]",		  "optimized multiplexed right-scalar div ('/') on [void,dbl] BAT"						  ]
[ "[/]",	  "OPERATOR:  ",  "[/](BAT[void,flt], BAT[void,flt]) : BAT[void,flt]",	  "optimized multiplexed div ('/') on head-aligned [void,flt] BATs"						  ]
[ "[/]",	  "OPERATOR:  ",  "[/](BAT[void,flt], flt) : BAT[void,flt]",		  "optimized multiplexed right-scalar div ('/') on [void,flt] BAT"						  ]
[ "[/]",	  "OPERATOR:  ",  "[/](BAT[void,int], BAT[void,int]) : BAT[void,int]",	  "optimized multiplexed div ('/') on head-aligned [void,int] BATs"						  ]
[ "[/]",	  "OPERATOR:  ",  "[/](BAT[void,int], int) : BAT[void,int]",		  "optimized multiplexed right-scalar div ('/') on [void,int] BAT"						  ]
[ "[/]",	  "OPERATOR:  ",  "[/](BAT[void,lng], BAT[void,lng]) : BAT[void,lng]",	  "optimized multiplexed div ('/') on head-aligned [void,lng] BATs"						  ]
[ "[/]",	  "OPERATOR:  ",  "[/](BAT[void,lng], lng) : BAT[void,lng]",		  "optimized multiplexed right-scalar div ('/') on [void,lng] BAT"						  ]
[ "[/]",	  "OPERATOR:  ",  "[/](BAT[void,sht], BAT[void,sht]) : BAT[void,sht]",	  "optimized multiplexed div ('/') on head-aligned [void,sht] BATs"						  ]
[ "[/]",	  "OPERATOR:  ",  "[/](BAT[void,sht], sht) : BAT[void,sht]",		  "optimized multiplexed right-scalar div ('/') on [void,sht] BAT"						  ]
[ "[/]",	  "OPERATOR:  ",  "[/](dbl, BAT[void,dbl]) : BAT[void,dbl]",		  "optimized multiplexed left-scalar div ('/') on [void,dbl] BAT"						  ]
[ "[/]",	  "OPERATOR:  ",  "[/](flt, BAT[void,flt]) : BAT[void,flt]",		  "optimized multiplexed left-scalar div ('/') on [void,flt] BAT"						  ]
[ "[/]",	  "OPERATOR:  ",  "[/](int, BAT[void,int]) : BAT[void,int]",		  "optimized multiplexed left-scalar div ('/') on [void,int] BAT"						  ]
[ "[/]",	  "OPERATOR:  ",  "[/](lng, BAT[void,lng]) : BAT[void,lng]",		  "optimized multiplexed left-scalar div ('/') on [void,lng] BAT"						  ]
[ "[/]",	  "OPERATOR:  ",  "[/](sht, BAT[void,sht]) : BAT[void,sht]",		  "optimized multiplexed left-scalar div ('/') on [void,sht] BAT"						  ]
[ "[:%=]",	  "OPERATOR:  ",  "[:%=](BAT[void,int], BAT[void,int]) : BAT[void,int]",  "optimized multiplexed in-place mod (':%=') on head-aligned [void,int] BATs (overwrites first operand)"	  ]
[ "[:%=]",	  "OPERATOR:  ",  "[:%=](BAT[void,int], int) : BAT[void,int]",		  "optimized multiplexed right-scalar in-place mod (':%=') on [void,int] BAT (overwrites first operand)"	  ]
[ "[:%=]",	  "OPERATOR:  ",  "[:%=](BAT[void,lng], BAT[void,lng]) : BAT[void,lng]",  "optimized multiplexed in-place mod (':%=') on head-aligned [void,lng] BATs (overwrites first operand)"	  ]
[ "[:%=]",	  "OPERATOR:  ",  "[:%=](BAT[void,lng], lng) : BAT[void,lng]",		  "optimized multiplexed right-scalar in-place mod (':%=') on [void,lng] BAT (overwrites first operand)"	  ]
[ "[:%=]",	  "OPERATOR:  ",  "[:%=](BAT[void,sht], BAT[void,sht]) : BAT[void,sht]",  "optimized multiplexed in-place mod (':%=') on head-aligned [void,sht] BATs (overwrites first operand)"	  ]
[ "[:%=]",	  "OPERATOR:  ",  "[:%=](BAT[void,sht], sht) : BAT[void,sht]",		  "optimized multiplexed right-scalar in-place mod (':%=') on [void,sht] BAT (overwrites first operand)"	  ]
[ "[:%=]",	  "OPERATOR:  ",  "[:%=](int, BAT[void,int]) : BAT[void,int]",		  "optimized multiplexed left-scalar in-place mod (':%=') on [void,int] BAT (overwrites second operand)"	  ]
[ "[:%=]",	  "OPERATOR:  ",  "[:%=](lng, BAT[void,lng]) : BAT[void,lng]",		  "optimized multiplexed left-scalar in-place mod (':%=') on [void,lng] BAT (overwrites second operand)"	  ]
[ "[:%=]",	  "OPERATOR:  ",  "[:%=](sht, BAT[void,sht]) : BAT[void,sht]",		  "optimized multiplexed left-scalar in-place mod (':%=') on [void,sht] BAT (overwrites second operand)"	  ]
[ "[:*=]",	  "OPERATOR:  ",  "[:*=](BAT[void,dbl], BAT[void,dbl]) : BAT[void,dbl]",  "optimized multiplexed in-place mul (':*=') on head-aligned [void,dbl] BATs (overwrites first operand)"	  ]
[ "[:*=]",	  "OPERATOR:  ",  "[:*=](BAT[void,dbl], dbl) : BAT[void,dbl]",		  "optimized multiplexed right-scalar in-place mul (':*=') on [void,dbl] BAT (overwrites first operand)"	  ]
[ "[:*=]",	  "OPERATOR:  ",  "[:*=](BAT[void,flt], BAT[void,flt]) : BAT[void,flt]",  "optimized multiplexed in-place mul (':*=') on head-aligned [void,flt] BATs (overwrites first operand)"	  ]
[ "[:*=]",	  "OPERATOR:  ",  "[:*=](BAT[void,flt], flt) : BAT[void,flt]",		  "optimized multiplexed right-scalar in-place mul (':*=') on [void,flt] BAT (overwrites first operand)"	  ]
[ "[:*=]",	  "OPERATOR:  ",  "[:*=](BAT[void,int], BAT[void,int]) : BAT[void,int]",  "optimized multiplexed in-place mul (':*=') on head-aligned [void,int] BATs (overwrites first operand)"	  ]
[ "[:*=]",	  "OPERATOR:  ",  "[:*=](BAT[void,int], int) : BAT[void,int]",		  "optimized multiplexed right-scalar in-place mul (':*=') on [void,int] BAT (overwrites first operand)"	  ]
[ "[:*=]",	  "OPERATOR:  ",  "[:*=](BAT[void,lng], BAT[void,lng]) : BAT[void,lng]",  "optimized multiplexed in-place mul (':*=') on head-aligned [void,lng] BATs (overwrites first operand)"	  ]
[ "[:*=]",	  "OPERATOR:  ",  "[:*=](BAT[void,lng], lng) : BAT[void,lng]",		  "optimized multiplexed right-scalar in-place mul (':*=') on [void,lng] BAT (overwrites first operand)"	  ]
[ "[:*=]",	  "OPERATOR:  ",  "[:*=](BAT[void,sht], BAT[void,sht]) : BAT[void,sht]",  "optimized multiplexed in-place mul (':*=') on head-aligned [void,sht] BATs (overwrites first operand)"	  ]
[ "[:*=]",	  "OPERATOR:  ",  "[:*=](BAT[void,sht], sht) : BAT[void,sht]",		  "optimized multiplexed right-scalar in-place mul (':*=') on [void,sht] BAT (overwrites first operand)"	  ]
[ "[:*=]",	  "OPERATOR:  ",  "[:*=](dbl, BAT[void,dbl]) : BAT[void,dbl]",		  "optimized multiplexed left-scalar in-place mul (':*=') on [void,dbl] BAT (overwrites second operand)"	  ]
[ "[:*=]",	  "OPERATOR:  ",  "[:*=](flt, BAT[void,flt]) : BAT[void,flt]",		  "optimized multiplexed left-scalar in-place mul (':*=') on [void,flt] BAT (overwrites second operand)"	  ]
[ "[:*=]",	  "OPERATOR:  ",  "[:*=](int, BAT[void,int]) : BAT[void,int]",		  "optimized multiplexed left-scalar in-place mul (':*=') on [void,int] BAT (overwrites second operand)"	  ]
[ "[:*=]",	  "OPERATOR:  ",  "[:*=](lng, BAT[void,lng]) : BAT[void,lng]",		  "optimized multiplexed left-scalar in-place mul (':*=') on [void,lng] BAT (overwrites second operand)"	  ]
[ "[:*=]",	  "OPERATOR:  ",  "[:*=](sht, BAT[void,sht]) : BAT[void,sht]",		  "optimized multiplexed left-scalar in-place mul (':*=') on [void,sht] BAT (overwrites second operand)"	  ]
[ "[:+=]",	  "OPERATOR:  ",  "[:+=](BAT[void,dbl], BAT[void,dbl]) : BAT[void,dbl]",  "optimized multiplexed in-place add (':+=') on head-aligned [void,dbl] BATs (overwrites first operand)"	  ]
[ "[:+=]",	  "OPERATOR:  ",  "[:+=](BAT[void,dbl], dbl) : BAT[void,dbl]",		  "optimized multiplexed right-scalar in-place add (':+=') on [void,dbl] BAT (overwrites first operand)"	  ]
[ "[:+=]",	  "OPERATOR:  ",  "[:+=](BAT[void,flt], BAT[void,flt]) : BAT[void,flt]",  "optimized multiplexed in-place add (':+=') on head-aligned [void,flt] BATs (overwrites first operand)"	  ]
[ "[:+=]",	  "OPERATOR:  ",  "[:+=](BAT[void,flt], flt) : BAT[void,flt]",		  "optimized multiplexed right-scalar in-place add (':+=') on [void,flt] BAT (overwrites first operand)"	  ]
[ "[:+=]",	  "OPERATOR:  ",  "[:+=](BAT[void,int], BAT[void,int]) : BAT[void,int]",  "optimized multiplexed in-place add (':+=') on head-aligned [void,int] BATs (overwrites first operand)"	  ]
[ "[:+=]",	  "OPERATOR:  ",  "[:+=](BAT[void,int], int) : BAT[void,int]",		  "optimized multiplexed right-scalar in-place add (':+=') on [void,int] BAT (overwrites first operand)"	  ]
[ "[:+=]",	  "OPERATOR:  ",  "[:+=](BAT[void,lng], BAT[void,lng]) : BAT[void,lng]",  "optimized multiplexed in-place add (':+=') on head-aligned [void,lng] BATs (overwrites first operand)"	  ]
[ "[:+=]",	  "OPERATOR:  ",  "[:+=](BAT[void,lng], lng) : BAT[void,lng]",		  "optimized multiplexed right-scalar in-place add (':+=') on [void,lng] BAT (overwrites first operand)"	  ]
[ "[:+=]",	  "OPERATOR:  ",  "[:+=](BAT[void,sht], BAT[void,sht]) : BAT[void,sht]",  "optimized multiplexed in-place add (':+=') on head-aligned [void,sht] BATs (overwrites first operand)"	  ]
[ "[:+=]",	  "OPERATOR:  ",  "[:+=](BAT[void,sht], sht) : BAT[void,sht]",		  "optimized multiplexed right-scalar in-place add (':+=') on [void,sht] BAT (overwrites first operand)"	  ]
[ "[:+=]",	  "OPERATOR:  ",  "[:+=](dbl, BAT[void,dbl]) : BAT[void,dbl]",		  "optimized multiplexed left-scalar in-place add (':+=') on [void,dbl] BAT (overwrites second operand)"	  ]
[ "[:+=]",	  "OPERATOR:  ",  "[:+=](flt, BAT[void,flt]) : BAT[void,flt]",		  "optimized multiplexed left-scalar in-place add (':+=') on [void,flt] BAT (overwrites second operand)"	  ]
[ "[:+=]",	  "OPERATOR:  ",  "[:+=](int, BAT[void,int]) : BAT[void,int]",		  "optimized multiplexed left-scalar in-place add (':+=') on [void,int] BAT (overwrites second operand)"	  ]
[ "[:+=]",	  "OPERATOR:  ",  "[:+=](lng, BAT[void,lng]) : BAT[void,lng]",		  "optimized multiplexed left-scalar in-place add (':+=') on [void,lng] BAT (overwrites second operand)"	  ]
[ "[:+=]",	  "OPERATOR:  ",  "[:+=](sht, BAT[void,sht]) : BAT[void,sht]",		  "optimized multiplexed left-scalar in-place add (':+=') on [void,sht] BAT (overwrites second operand)"	  ]
[ "[:-=]",	  "OPERATOR:  ",  "[:-=](BAT[void,dbl], BAT[void,dbl]) : BAT[void,dbl]",  "optimized multiplexed in-place sub (':-=') on head-aligned [void,dbl] BATs (overwrites first operand)"	  ]
[ "[:-=]",	  "OPERATOR:  ",  "[:-=](BAT[void,dbl], dbl) : BAT[void,dbl]",		  "optimized multiplexed right-scalar in-place sub (':-=') on [void,dbl] BAT (overwrites first operand)"	  ]
[ "[:-=]",	  "OPERATOR:  ",  "[:-=](BAT[void,flt], BAT[void,flt]) : BAT[void,flt]",  "optimized multiplexed in-place sub (':-=') on head-aligned [void,flt] BATs (overwrites first operand)"	  ]
[ "[:-=]",	  "OPERATOR:  ",  "[:-=](BAT[void,flt], flt) : BAT[void,flt]",		  "optimized multiplexed right-scalar in-place sub (':-=') on [void,flt] BAT (overwrites first operand)"	  ]
[ "[:-=]",	  "OPERATOR:  ",  "[:-=](BAT[void,int], BAT[void,int]) : BAT[void,int]",  "optimized multiplexed in-place sub (':-=') on head-aligned [void,int] BATs (overwrites first operand)"	  ]
[ "[:-=]",	  "OPERATOR:  ",  "[:-=](BAT[void,int], int) : BAT[void,int]",		  "optimized multiplexed right-scalar in-place sub (':-=') on [void,int] BAT (overwrites first operand)"	  ]
[ "[:-=]",	  "OPERATOR:  ",  "[:-=](BAT[void,lng], BAT[void,lng]) : BAT[void,lng]",  "optimized multiplexed in-place sub (':-=') on head-aligned [void,lng] BATs (overwrites first operand)"	  ]
[ "[:-=]",	  "OPERATOR:  ",  "[:-=](BAT[void,lng], lng) : BAT[void,lng]",		  "optimized multiplexed right-scalar in-place sub (':-=') on [void,lng] BAT (overwrites first operand)"	  ]
[ "[:-=]",	  "OPERATOR:  ",  "[:-=](BAT[void,sht], BAT[void,sht]) : BAT[void,sht]",  "optimized multiplexed in-place sub (':-=') on head-aligned [void,sht] BATs (overwrites first operand)"	  ]
[ "[:-=]",	  "OPERATOR:  ",  "[:-=](BAT[void,sht], sht) : BAT[void,sht]",		  "optimized multiplexed right-scalar in-place sub (':-=') on [void,sht] BAT (overwrites first operand)"	  ]
[ "[:-=]",	  "OPERATOR:  ",  "[:-=](dbl, BAT[void,dbl]) : BAT[void,dbl]",		  "optimized multiplexed left-scalar in-place sub (':-=') on [void,dbl] BAT (overwrites second operand)"	  ]
[ "[:-=]",	  "OPERATOR:  ",  "[:-=](flt, BAT[void,flt]) : BAT[void,flt]",		  "optimized multiplexed left-scalar in-place sub (':-=') on [void,flt] BAT (overwrites second operand)"	  ]
[ "[:-=]",	  "OPERATOR:  ",  "[:-=](int, BAT[void,int]) : BAT[void,int]",		  "optimized multiplexed left-scalar in-place sub (':-=') on [void,int] BAT (overwrites second operand)"	  ]
[ "[:-=]",	  "OPERATOR:  ",  "[:-=](lng, BAT[void,lng]) : BAT[void,lng]",		  "optimized multiplexed left-scalar in-place sub (':-=') on [void,lng] BAT (overwrites second operand)"	  ]
[ "[:-=]",	  "OPERATOR:  ",  "[:-=](sht, BAT[void,sht]) : BAT[void,sht]",		  "optimized multiplexed left-scalar in-place sub (':-=') on [void,sht] BAT (overwrites second operand)"	  ]
[ "[:/=]",	  "OPERATOR:  ",  "[:/=](BAT[void,dbl], BAT[void,dbl]) : BAT[void,dbl]",  "optimized multiplexed in-place div (':/=') on head-aligned [void,dbl] BATs (overwrites first operand)"	  ]
[ "[:/=]",	  "OPERATOR:  ",  "[:/=](BAT[void,dbl], dbl) : BAT[void,dbl]",		  "optimized multiplexed right-scalar in-place div (':/=') on [void,dbl] BAT (overwrites first operand)"	  ]
[ "[:/=]",	  "OPERATOR:  ",  "[:/=](BAT[void,flt], BAT[void,flt]) : BAT[void,flt]",  "optimized multiplexed in-place div (':/=') on head-aligned [void,flt] BATs (overwrites first operand)"	  ]
[ "[:/=]",	  "OPERATOR:  ",  "[:/=](BAT[void,flt], flt) : BAT[void,flt]",		  "optimized multiplexed right-scalar in-place div (':/=') on [void,flt] BAT (overwrites first operand)"	  ]
[ "[:/=]",	  "OPERATOR:  ",  "[:/=](BAT[void,int], BAT[void,int]) : BAT[void,int]",  "optimized multiplexed in-place div (':/=') on head-aligned [void,int] BATs (overwrites first operand)"	  ]
[ "[:/=]",	  "OPERATOR:  ",  "[:/=](BAT[void,int], int) : BAT[void,int]",		  "optimized multiplexed right-scalar in-place div (':/=') on [void,int] BAT (overwrites first operand)"	  ]
[ "[:/=]",	  "OPERATOR:  ",  "[:/=](BAT[void,lng], BAT[void,lng]) : BAT[void,lng]",  "optimized multiplexed in-place div (':/=') on head-aligned [void,lng] BATs (overwrites first operand)"	  ]
[ "[:/=]",	  "OPERATOR:  ",  "[:/=](BAT[void,lng], lng) : BAT[void,lng]",		  "optimized multiplexed right-scalar in-place div (':/=') on [void,lng] BAT (overwrites first operand)"	  ]
[ "[:/=]",	  "OPERATOR:  ",  "[:/=](BAT[void,sht], BAT[void,sht]) : BAT[void,sht]",  "optimized multiplexed in-place div (':/=') on head-aligned [void,sht] BATs (overwrites first operand)"	  ]
[ "[:/=]",	  "OPERATOR:  ",  "[:/=](BAT[void,sht], sht) : BAT[void,sht]",		  "optimized multiplexed right-scalar in-place div (':/=') on [void,sht] BAT (overwrites first operand)"	  ]
[ "[:/=]",	  "OPERATOR:  ",  "[:/=](dbl, BAT[void,dbl]) : BAT[void,dbl]",		  "optimized multiplexed left-scalar in-place div (':/=') on [void,dbl] BAT (overwrites second operand)"	  ]
[ "[:/=]",	  "OPERATOR:  ",  "[:/=](flt, BAT[void,flt]) : BAT[void,flt]",		  "optimized multiplexed left-scalar in-place div (':/=') on [void,flt] BAT (overwrites second operand)"	  ]
[ "[:/=]",	  "OPERATOR:  ",  "[:/=](int, BAT[void,int]) : BAT[void,int]",		  "optimized multiplexed left-scalar in-place div (':/=') on [void,int] BAT (overwrites second operand)"	  ]
[ "[:/=]",	  "OPERATOR:  ",  "[:/=](lng, BAT[void,lng]) : BAT[void,lng]",		  "optimized multiplexed left-scalar in-place div (':/=') on [void,lng] BAT (overwrites second operand)"	  ]
[ "[:/=]",	  "OPERATOR:  ",  "[:/=](sht, BAT[void,sht]) : BAT[void,sht]",		  "optimized multiplexed left-scalar in-place div (':/=') on [void,sht] BAT (overwrites second operand)"	  ]

Module: "blob"

[ 4 ]
[ 4 ]
#-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
# function		type		signature			help																  # name
# str		str		str				str																  # type
#-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
[ "nitems",	  "COMMAND:   ",  "nitems(blob) : int",		  "get the number of bytes stored in this blob."										  ]
[ "toblob",	  "COMMAND:   ",  "toblob(str) : blob",		  "store a string as a blob."													  ]
[ "tostr",	  "COMMAND:   ",  "tostr(blob) : str",		  "get the bytes from blob as a string, till the first 0 byte\n         or the end of the blob"					  ]
[ "tostr",	  "COMMAND:   ",  "tostr(blob, int) : str",	  "get the bytes from blob as a string, starting at byte 'index'\n         till the first 0 byte or the end of the blob."	  ]

Module: "counters"

[ 14 ]
[ 14 ]
#-------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
# function			type		signature				help											  # name
# str			str		str					str											  # type
#-------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
[ "counter2bat",	  "COMMAND:   ",  "counter2bat(counter) : BAT[str,lng]",  "store the retrieved results in a BAT"						  ]
[ "counter2str",	  "PROC:      ",  "counter2str(counter) : str",		  "cast counter to string."								  ]
[ "event_name",		  "PROC:      ",  "event_name(int) : str",		  "return the (native) name of an event given by number"				  ]
[ "event_number",	  "PROC:      ",  "event_number(int) : int",		  "return the number of an event given by name"						  ]
[ "event_number",	  "PROC:      ",  "event_number(str) : int",		  "not available"									  ]
[ "init_counters",	  "COMMAND:   ",  "init_counters() : void",		  "initialize counters module\n  (to be used on initial load, only)"			  ]
[ "profile",		  "PROC:      ",  "profile(str, str, str) : counter",	  "Count events event0 & event1 while executing cmd; return the results as counter."	  ]
[ "show_native_events",	  "COMMAND:   ",  "show_native_events() : BAT[int,str]",  "all available events"								  ]
[ "show_unified_events",  "COMMAND:   ",  "show_unified_events() : BAT[int,str]", "all unified event names"								  ]
[ "start_count",	  "COMMAND:   ",  "start_count(int, int) : counter",	  "start counters for two events specified by number"					  ]
[ "start_count",	  "PROC:      ",  "start_count(int, str) : counter",	  "start counters for two events, first specified by number, second specified by name"	  ]
[ "start_count",	  "PROC:      ",  "start_count(str, int) : counter",	  "start counters for two events, first specified by name, second specified by number"	  ]
[ "start_count",	  "PROC:      ",  "start_count(str, str) : counter",	  "start counters for two events specified by name"					  ]
[ "stop_count",		  "COMMAND:   ",  "stop_count(counter) : counter",	  "stop the counting and retrieve the results"						  ]

Module: "decimal"

[ 36 ]
[ 36 ]
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
# function			type		signature								help																																																																																									  # name
# str			str		str									str																																																																																									  # type
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
[ "!=",			  "OPERATOR:  ",  "!=(decimal, decimal) : bit",						  "decimal non-equality test (!DS2.2)"																																																																																					  ]
[ "*",			  "OPERATOR:  ",  "*(decimal, decimal) : decimal",					  "Returns a decimal whose value is exactly (val1 * val2)."																																																																																		  ]
[ "+",			  "OPERATOR:  ",  "+(decimal, decimal) : decimal",					  "Returns a decimal whose value is extactly (val1 + val2)."																																																																																		  ]
[ "-",			  "OPERATOR:  ",  "-(decimal) : decimal",						  "Returns a decimal whose value is -1 * value, with equal scale and precision as 'value'."																																																																														  ]
[ "-",			  "OPERATOR:  ",  "-(decimal, decimal) : decimal",					  "Returns a decimal whose value is exactly (val1 - val2)."																																																																																		  ]
[ "/",			  "OPERATOR:  ",  "/(decimal, decimal) : decimal",					  "Returns a decimal whose value is val1 DIV val2, (scale=0) like in C integer division.\n      This operator can implement MOD as MOD(x,y) = x - y*DIV(d,y).\n      Use the tertiary divide(num,div,prec) command for dividing with arbitrary precision.\n      Division by zero returns decimal(nil)."																																																				  ]
[ "<",			  "OPERATOR:  ",  "<(decimal, decimal) : bit",						  "decimal smaller-than test (!DS2.2)"																																																																																					  ]
[ "<=",			  "OPERATOR:  ",  "<=(decimal, decimal) : bit",						  "decimal smaller-or-equal test (!DS2.2)"																																																																																				  ]
[ "=",			  "OPERATOR:  ",  "=(decimal, decimal) : bit",						  "decimal equality test (!DS2.2)"																																																																																					  ]
[ ">",			  "OPERATOR:  ",  ">(decimal, decimal) : bit",						  "decimal greater-than test (!DS2.2)"																																																																																					  ]
[ ">=",			  "OPERATOR:  ",  ">=(decimal, decimal) : bit",						  "decimal greater-or-equal test (!DS2.2)"																																																																																				  ]
[ "[/]",		  "PROC:      ",  "[/](BAT[any::1,decimal], decimal) : BAT[any::1,decimal]",		  "not available"																																																																																							  ]
[ "[divide]",		  "PROC:      ",  "[divide](BAT[any::1,decimal], decimal, int) : BAT[any::1,decimal]",	  "not available"																																																																																							  ]
[ "abs",		  "COMMAND:   ",  "abs(decimal) : decimal",						  "Returns a decimal whose value is the absolute value of this number."																																																																																	  ]
[ "addscale",		  "COMMAND:   ",  "addscale(decimal, int) : decimal",					  "Return a  decimal with the same number as value, but with scale = value.scale + delta.\n      This can be seen as shifting the dot in the floating-point value of the decimal\n      to the left (delta < 0) or right (delta > 0) (!DS2.2)."																																																												  ]
[ "bulkdivide",		  "COMMAND:   ",  "bulkdivide(BAT[any::1,decimal], decimal) : BAT[any::1,decimal]",	  "(!DS2.2)"																																																																																								  ]
[ "bulkdivide",		  "COMMAND:   ",  "bulkdivide(BAT[any::1,decimal], decimal, int) : BAT[any::1,decimal]",  "(!DS2.2)"																																																																																								  ]
[ "dbl",		  "COMMAND:   ",  "dbl(decimal) : dbl",							  "Return the value of a decimal as a double (return dbl(nil) on overflow)."																																																																																  ]
[ "decimal",		  "COMMAND:   ",  "decimal(dbl) : decimal",						  "Create a decimal from a double value."																																																																																				  ]
[ "decimal",		  "COMMAND:   ",  "decimal(flt) : decimal",						  "Create a decimal from a float value."																																																																																				  ]
[ "decimal",		  "COMMAND:   ",  "decimal(int) : decimal",						  "Translates an integer into a decimal."																																																																																				  ]
[ "decimal",		  "COMMAND:   ",  "decimal(lng) : decimal",						  "Translates a long into a decimal."																																																																																					  ]
[ "decimal_minrepeat",	  "COMMAND:   ",  "decimal_minrepeat(int) : void",					  "set number of repeating characters after which to condense decimals (!DS2.2)."																																																																															  ]
[ "divide",		  "COMMAND:   ",  "divide(decimal, decimal, int) : decimal",				  "Returns a decimal whose value is (val1 / val2), truncated to a specified precision.\n      Division by zero returns decimal(nil)."																																																																									  ]
[ "flt",		  "COMMAND:   ",  "flt(decimal) : flt",							  "Return the value of a decimal as a float (return flt(nil) on overflow)."																																																																																  ]
[ "getprecision",	  "COMMAND:   ",  "getprecision(decimal) : int",					  "Returns the precision of this number (!DS2.2)."																																																																																			  ]
[ "getscale",		  "COMMAND:   ",  "getscale(decimal) : int",						  "Returns the scale of this number (!DS2.2)"																																																																																				  ]
[ "int",		  "COMMAND:   ",  "int(decimal) : int",							  "Return the truncated value of a decimal as an integer (return int(nil) on overflow)."																																																																														  ]
[ "isnil",		  "COMMAND:   ",  "isnil(decimal) : bit",						  "decimal nil test (!DS2.2)"																																																																																						  ]
[ "istenfold",		  "COMMAND:   ",  "istenfold(decimal) : bit",						  "returns whether decimal is an exact multiple of 10 (!DS2.2)."																																																																																	  ]
[ "lng",		  "COMMAND:   ",  "lng(decimal) : lng",							  "Return the truncated value of a decimal as a long (return lng(nil) on overflow)."																																																																															  ]
[ "pow",		  "COMMAND:   ",  "pow(decimal, int) : decimal",					  "Raises a decimal to the power of some integer.\n      The precision of the result is the precision of the decimal (!DS2.2)."																																																																										  ]
[ "pow",		  "COMMAND:   ",  "pow(decimal, int, int) : decimal",					  "Raises a decimal to the power of some integer.\n      The precision argument determines the maximum precision of the result (!DS2.2)."																																																																								  ]
[ "setprecision",	  "COMMAND:   ",  "setprecision(decimal, int) : decimal",				  "Return the same number but with a different precision; i.e. truncated or zero-padded (!DS2.2)."																																																																													  ]
[ "setscale",		  "COMMAND:   ",  "setscale(decimal, int) : decimal",					  "Normalize the number of a decimal by setting the scale to a fixed value.\n      This is compensated by making the number shorter (by truncation) or by enlarging\n      it with trailing zeros (!DS2.2)."																																																																  ]
[ "str",		  "COMMAND:   ",  "str(decimal, str) : str",						  "Formats a decimal in a fixed-width string (truncated, if necessary).\n      format = [ '+' ] ( N1 | ( N1 '.' N2 ) | ( '.' N2 ) ) [ 'E' N3 ]\n       with: Nx = a number of the form [0-9]+ (possibly starting with 0)\n      where: N1 = is the number of digits before the decimal point (default = 0)\n             N2 = is the number of digits after the decimal point (default = 1)\n             N3 = the number of digits to use for the scale (default = 2)\n      A zero will be printed with only one zero digit (left space-padded), unless N1 has a\n      leading zero, in which case a zero-padded number of width N1 is produced.\n      If the plus at start is specified, positive numbers start with a plus. "	  ]

Module: "enum"

[ 23 ]
[ 23 ]
#-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
# function			type		signature								help										  # name
# str			str		str									str										  # type
#-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
[ "[decode]",		  "COMMAND:   ",  "[decode](int, BAT[any::1,any]) : BAT[any::1,any]",			  "decode a BAT of tail values, into a new BAT of decoded values"		  ]
[ "[encode]",		  "COMMAND:   ",  "[encode](int, BAT[any::1,any]) : BAT[any::1,any]",			  "encode a BAT of tail values, into a new BAT of encoded values"		  ]
[ "decode",		  "COMMAND:   ",  "decode(int, any) : any",						  "decode a value"								  ]
[ "encode",		  "COMMAND:   ",  "encode(int, any) : any",						  "encode a value"								  ]
[ "enum_create",	  "PROC:      ",  "enum_create(str, BAT[any,any]) : int",				  "create a new enumeration type."						  ]
[ "enum_destroy",	  "COMMAND:   ",  "enum_destroy(int) : void",						  "destroy an enumeration type"							  ]
[ "enum_drop",		  "PROC:      ",  "enum_drop(int) : void",						  "deactivate an enumeration type."						  ]
[ "enum_ishisto",	  "COMMAND:   ",  "enum_ishisto(int, BAT[any,any]) : bit",				  "returns whether enum_table(tpe) is a histogram on b's head column"		  ]
[ "enum_load",		  "COMMAND:   ",  "enum_load(BAT[any,int]) : int",					  "load/activate a previously created enumeration type."			  ]
[ "enum_load",		  "PROC:      ",  "enum_load(str) : void",						  "activate an enumeration type from a histogram bat."				  ]
[ "enum_new",		  "COMMAND:   ",  "enum_new(str, BAT[any,any]) : int",					  "create a new enumeration type."						  ]
[ "enum_print",		  "COMMAND:   ",  "enum_print(Stream, BAT[any,int], BAT[any,any]) : void",		  "quick file print of 2 synced bats, an int and enumerated string tail"	  ]
[ "enum_print",		  "COMMAND:   ",  "enum_print(Stream, BAT[any,int], BAT[any,any], BAT[any,any]) : void",  "quick file print of 3 synced bats, and int tail and two enumerated strings"	  ]
[ "enum_sethisto",	  "COMMAND:   ",  "enum_sethisto(int, BAT[any,any]) : void",				  "registers the fact that enum_table(tpe) is a histogram on b's head column"	  ]
[ "enum_table",		  "COMMAND:   ",  "enum_table(int) : BAT[any,any]",					  "return the enumeration BAT of an enum type"					  ]
[ "enum_trick",		  "PROC:      ",  "enum_trick(BAT[oid,any], BAT[any,int]) : BAT[oid,any]",		  "create a view on a BAT with a diffrent enum map."				  ]
[ "fclose",		  "PROC:      ",  "fclose(Stream) : void",						  "not available"								  ]
[ "fflush",		  "PROC:      ",  "fflush(Stream) : void",						  "not available"								  ]
[ "fopen",		  "PROC:      ",  "fopen(str, str) : Stream",						  "not available"								  ]
[ "fputs",		  "PROC:      ",  "fputs(str, Stream) : void",						  "not available"								  ]
[ "isenum",		  "COMMAND:   ",  "isenum(int) : bit",							  "returns true iff tpe is an enumerated type"					  ]
[ "lower",		  "COMMAND:   ",  "lower(int, any) : any",						  "encode to the lowest value in the encoded domain that is larger than v"	  ]
[ "upper",		  "COMMAND:   ",  "upper(int, any) : any",						  "encode to the hightes value in the encoded domain that is smaller than v"	  ]

Module: "lock"

[ 9 ]
[ 9 ]
#-----------------------------------------------------------------------------------------------------------------------------------------#
# function		type		signature			help									  # name
# str		str		str				str									  # type
#-----------------------------------------------------------------------------------------------------------------------------------------#
[ "lock_create",  "COMMAND:   ",  "lock_create() : lock",	  "create an unset lock"						  ]
[ "lock_destroy", "COMMAND:   ",  "lock_destroy(lock) : void",	  "destroy a lock"							  ]
[ "lock_set",	  "COMMAND:   ",  "lock_set(lock) : void",	  "try to set a lock; if set, block till it is freed"			  ]
[ "lock_try",	  "COMMAND:   ",  "lock_try(lock) : int",	  "try a lock, if free set it and return 0, if not return EBUSY"	  ]
[ "lock_unset",	  "COMMAND:   ",  "lock_unset(lock) : void",	  "unset a lock"							  ]
[ "sema_create",  "COMMAND:   ",  "sema_create(int) : sema",	  "create an unset sema, with an initial value"				  ]
[ "sema_destroy", "COMMAND:   ",  "sema_destroy(sema) : void",	  "destroy a sema"							  ]
[ "sema_down",	  "COMMAND:   ",  "sema_down(sema) : void",	  "decrease the semaphpore if >0; else block"				  ]
[ "sema_up",	  "COMMAND:   ",  "sema_up(sema) : void",	  "increase the semaphore"						  ]

Module: "logger"

[ 6 ]
[ 6 ]
#-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
# function			type		signature							help													  # name
# str			str		str								str													  # type
#-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
[ "log_delta",		  "COMMAND:   ",  "log_delta(BAT[void,any::1], BAT[oid,any::1], oid) : bit",	  "log the delta in the WAL (return success)"								  ]
[ "log_insert",		  "COMMAND:   ",  "log_insert(BAT[void,any::1], oid) : bit",			  "log the inserts in the WAL (return success)"								  ]
[ "log_trans_end",	  "COMMAND:   ",  "log_trans_end(oid) : bit",					  "write transaction end in the WAL (return success)"							  ]
[ "log_trans_start",	  "COMMAND:   ",  "log_trans_start(bit) : oid",					  "Log a start of a transaction, return new transaction id"						  ]
[ "logger_start",	  "COMMAND:   ",  "logger_start(str, str) : bit",				  "Start logging; if first start, check if recovery is needed. if already logging, close the old file."	  ]
[ "logger_start",	  "PROC:      ",  "logger_start() : void",					  "not available"											  ]

Module: "mapi"

[ 31 ]
[ 31 ]
#-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
# function			type		signature									help																																								  # name
# str			str		str										str																																								  # type
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
[ "fclose",		  "PROC:      ",  "fclose(Stream) : void",							  "not available"																																						  ]
[ "fflush",		  "PROC:      ",  "fflush(Stream) : void",							  "not available"																																						  ]
[ "fopen",		  "PROC:      ",  "fopen(str, str) : Stream",							  "not available"																																						  ]
[ "fputs",		  "PROC:      ",  "fputs(str, Stream) : void",							  "not available"																																						  ]
[ "get_mapi_port",	  "PROC:      ",  "get_mapi_port() : int",							  "not available"																																						  ]
[ "listen",		  "PROC:      ",  "listen() : void",								  "Start the Mapi listener on 50000."																																				  ]
[ "listen",		  "PROC:      ",  "listen(bit) : void",								  "Start the Mapi listener on 50000.\n If <open> is true, accept connections from everywhere, otherwise only from localhost."																														  ]
[ "listen",		  "PROC:      ",  "listen(int) : void",								  "Start the Mapi listener on <port>."																																				  ]
[ "listen",		  "PROC:      ",  "listen(int, bit) : void",							  "Start the Mapi listener on <port>.\n If <open> is true, accept connections from everywhere, otherwise only from localhost."																														  ]
[ "listen",		  "PROC:      ",  "listen(int, int) : void",							  "Start the Mapi listener on <port> for <maxusers>."																																		  ]
[ "listen",		  "PROC:      ",  "listen(int, int, bit) : void",						  "Start the Mapi listener on <port> for <maxusers>.\n If <open> is true, accept connections from everywhere, otherwise only from localhost."																												  ]
[ "listen",		  "PROC:      ",  "listen(int, int, str) : void",						  "Start the Mapi listener on <port> for <maxusers>.\nFor a new client connection MIL procedure <cmd>(int sock) is called.\nIf no <cmd> is specified a new client thread is forked."																		  ]
[ "listen",		  "PROC:      ",  "listen(int, int, str, bit) : void",						  "Start the Mapi listener on <port> for <maxusers>.\nFor a new client connection MIL procedure <cmd>(int sock) is called.\nIf no <cmd> is specified a new client thread is forked.\n If <open> is true, accept connections from everywhere, otherwise only from localhost.\n If <open> is true, accept connections from everywhere, otherwise only from localhost."	  ]
[ "listen",		  "PROC:      ",  "listen(int, str) : void",							  "Start the Mapi listener on <port>.\nFor a new client connection MIL procedure <cmd>(int sock) is called."																											  ]
[ "listen",		  "PROC:      ",  "listen(int, str, bit) : void",						  "Start the Mapi listener on <port>.\nFor a new client connection MIL procedure <cmd>(int sock) is called.\n If <open> is true, accept connections from everywhere, otherwise only from localhost."																					  ]
[ "listen",		  "PROC:      ",  "listen(int, str, int, str) : void",						  "Start the Mapi listener on <port> and/or <sockfile> for <maxusers>.\nFor a new client connection MIL procedure <cmd>(int sock) is called.\nIf no <cmd> is specified a new client thread is forked."																  ]
[ "listen",		  "PROC:      ",  "listen(int, str, int, str, bit) : void",					  "Start the Mapi listener on <port> and/or <sockfile> for <maxusers>.\nFor a new client connection MIL procedure <cmd>(int sock) is called.\nIf no <cmd> is specified a new client thread is forked.\n If <open> is true, accept connections from everywhere, otherwise only from localhost."										  ]
[ "listen",		  "PROC:      ",  "listen(str) : void",								  "Start the Mapi listener on 50000.\nFor a new client connection MIL procedure <cmd>(int sock) is called."																											  ]
[ "listen",		  "PROC:      ",  "listen(str, bit) : void",							  "Start the Mapi listener on 50000.\nFor a new client connection MIL procedure <cmd>(int sock) is called.\n If <open> is true, accept connections from everywhere, otherwise only from localhost."																					  ]
[ "mapi_listen",	  "PROC:      ",  "mapi_listen(int, int, str) : void",						  "Start the Mapi listener on <port> for <maxusers>.\n For a new client connection MIL procedure <cmd>(Stream s_in, Stream s_out) is called.\nIf no <cmd> is specified a new client thread is forked."																  ]
[ "mapi_listen",	  "PROC:      ",  "mapi_listen(int, int, str, bit) : void",					  "Start the Mapi listener on <port> for <maxusers>.\n For a new client connection MIL procedure <cmd>(Stream s_in, Stream s_out) is called.\nIf no <cmd> is specified a new client thread is forked.\n If <open> is true, accept connections from everywhere, otherwise only from localhost."										  ]
[ "mapi_listen2",	  "BUILTIN:   ",  "mapi_listen2(int port, str sockfile, int maxusers, str cmd, bit open) ",	  "Start the Mapi listener on <port> and/or <sockfile> for <maxusers>.\n For a new client connection MIL procedure <cmd>(Stream s_in, Stream s_out) is called.\nIf no <cmd> is specified a new client thread is forked.\n <sockfile> is the name of a Unix socket.\n If <open> is true, accept connections from everywhere, otherwise only from localhost."		  ]
[ "mapi_listen_ssl",	  "BUILTIN:   ",  "mapi_listen_ssl(int port, int maxusers, str keyfile, str certfile, str cmd) ", "Start the Mapi listener on <port> for <maxusers> using SSL.\n<keyfile> and <certfile> give the path names for files with the server key and certificates in PEM format.\nFor a new client connection MIL procedure <cmd>(Stream s_in, Stream s_out) is called.\nIf no <cmd> is specified a new client thread is forked."	  ]
[ "mapi_server",	  "PROC:      ",  "mapi_server(int, int) : void",						  "not available"																																						  ]
[ "mapi_start",		  "PROC:      ",  "mapi_start() : void",							  "not available"																																						  ]
[ "mapi_start",		  "PROC:      ",  "mapi_start(bit) : void",							  "not available"																																											  ]
[ "mapi_stream_read",	  "PROC:      ",  "mapi_stream_read(Stream) : str",						  "Read a string from <S> until a '1' character."																																		  ]
[ "milclient",		  "BUILTIN:   ",  "milclient(stream in, stream out) : void ",					  "mapi-client"																																												  ]
[ "stream_line",	  "PROC:      ",  "stream_line(Stream) : str",							  "Read a string from <S> until a newline."																																			  ]
[ "stream_strip",	  "PROC:      ",  "stream_strip(Stream, str) : str",						  "Read a string from <S> until the <stop> word.\nThe <stop> word is stripped from the result string."																												  ]
[ "stream_until",	  "COMMAND:   ",  "stream_until(Stream, str) : str",						  "read a string from <S> until the <stop> word"																																		  ]

Module: "mkey"

[ 18 ]
[ 18 ]
#-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
# function			type		signature										help													  # name
# str			str		str											str													  # type
#-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
[ "[:rotate_xor_hash=]",  "PROC:      ",  "[:rotate_xor_hash=](BAT[any::1,int], int, BAT[any::1,any]) : BAT[any::1,int]",	  "not available"											  ]
[ "bulk_rotate_xor_hash", "COMMAND:   ",  "bulk_rotate_xor_hash(BAT[oid,int], int, BAT[oid,any]) : BAT[oid,int]",		  "pre:  h and b should be synced on head\n         post: [:xor=]([:rotate=](h, nbits), [hash](b))"	  ]
[ "ds_eq",		  "PROC:      ",  "ds_eq(BAT[void,oid], BAT[any,any], BAT[void,oid], BAT[any,any]) : BAT[void,bit]",	  "not available"											  ]
[ "ds_hash",		  "PROC:      ",  "ds_hash(BAT[BAT,any]) : BAT[oid,int]",						  "not available"											  ]
[ "ds_link",		  "PROC:      ",  "ds_link(BAT[BAT,BAT]) : BAT[oid,oid]",						  "not available"											  ]
[ "ds_link",		  "PROC:      ",  "ds_link(BAT[oid,any::1], BAT[oid,any::1], ..BAT[oid,any]..) : BAT[oid,oid]",		  "not available"											  ]
[ "ds_sort",		  "PROC:      ",  "ds_sort(BAT[any::1,any::2], bit) : BAT[any::1,any::2]",				  "not available"											  ]
[ "hash",		  "COMMAND:   ",  "hash(any) : int",									  "compute a hash int number from any value"								  ]
[ "hash",		  "COMMAND:   ",  "hash(bit) : int",									  ""													  ]
[ "hash",		  "COMMAND:   ",  "hash(chr) : int",									  ""													  ]
[ "hash",		  "COMMAND:   ",  "hash(dbl) : int",									  ""													  ]
[ "hash",		  "COMMAND:   ",  "hash(flt) : int",									  ""													  ]
[ "hash",		  "COMMAND:   ",  "hash(int) : int",									  ""													  ]
[ "hash",		  "COMMAND:   ",  "hash(lng) : int",									  ""													  ]
[ "hash",		  "COMMAND:   ",  "hash(sht) : int",									  ""													  ]
[ "hash",		  "COMMAND:   ",  "hash(str) : int",									  ""													  ]
[ "rotate",		  "COMMAND:   ",  "rotate(int, int) : int",								  "left-rotate an int by nbits"										  ]
[ "rotate_xor_hash",	  "PROC:      ",  "rotate_xor_hash(int, int, any) : int",						  "not available"											  ]

Module: "mmath"

[ 38 ]
[ 38 ]
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
# function			type		signature			help																																											  # name
# str			str		str				str																																											  # type
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
[ "acos",		  "COMMAND:   ",  "acos(dbl) : dbl",		  "The acos(x) function calculates the arc cosine of x;\nthat is the value whose cosine is x. The value is returned in radians\nand is mathematically defined to be between 0 and PI (inclusive)."																			  ]
[ "acos",		  "PROC:      ",  "acos(flt) : flt",		  "not available"																																									  ]
[ "asin",		  "COMMAND:   ",  "asin(dbl) : dbl",		  "The asin(x) function calculates the arc sine of x;\nthat is the value whose sine is x. The value is returned in radians\nand is mathematically defined to be between -PI/20 and -PI/2 (inclusive)."																			  ]
[ "asin",		  "PROC:      ",  "asin(flt) : flt",		  "not available"																																									  ]
[ "atan",		  "COMMAND:   ",  "atan(dbl) : dbl",		  "The atan(x) function calculates the arc tangent of x;\nthat is the value whose tangent is x. The value is returned in radians\nand is mathematically defined to be between -PI/2 and PI/2 (inclusive)."																		  ]
[ "atan",		  "PROC:      ",  "atan(flt) : flt",		  "not available"																																									  ]
[ "atan2",		  "COMMAND:   ",  "atan2(dbl, dbl) : dbl",	  "The atan2(x,y) function calculates the arc tangent of the two\nvariables x and y. It is similar to calculating the arc\ntangent of y / x, except that the signs of both arguments\nare used to determine the quadrant of the result.\nThe value is returned in radians and is mathematically defined\nto be between -PI/2 and PI/2 (inclusive)."	  ]
[ "ceil",		  "COMMAND:   ",  "ceil(dbl) : dbl",		  "The ceil(x) function rounds x upwards to the nearest integer."																																			  ]
[ "ceil",		  "PROC:      ",  "ceil(flt) : flt",		  "not available"																																									  ]
[ "cos",		  "COMMAND:   ",  "cos(dbl) : dbl",		  "The cos(x) function returns the cosine of x,\nwhere x is given in radians. The return value is between -1 and 1."																													  ]
[ "cos",		  "PROC:      ",  "cos(flt) : flt",		  "not available"																																									  ]
[ "cosh",		  "COMMAND:   ",  "cosh(dbl) : dbl",		  "The cosh() function  returns the hyperbolic cosine of x,\nwhich is defined mathematically as (exp(x) + exp(-x)) / 2."																												  ]
[ "cosh",		  "PROC:      ",  "cosh(flt) : flt",		  "not available"																																									  ]
[ "exp",		  "COMMAND:   ",  "exp(dbl) : dbl",		  "The exp(x) function returns the value of e\n(the base of natural logarithms) raised to the power of x."																														  ]
[ "exp",		  "PROC:      ",  "exp(flt) : flt",		  "not available"																																									  ]
[ "fabs",		  "COMMAND:   ",  "fabs(dbl) : dbl",		  "The fabs(x) function returns the absolute value of the\nfloating-point number x."																																  ]
[ "finite",		  "COMMAND:   ",  "finite(dbl) : bit",		  "The finite(x) function returns true if x is neither infinite nor a 'not-a-number' (NaN) value, and false otherwise."																													  ]
[ "floor",		  "COMMAND:   ",  "floor(dbl) : dbl",		  "The floor(x) function rounds x downwards to the nearest integer."																																			  ]
[ "floor",		  "PROC:      ",  "floor(flt) : flt",		  "not available"																																									  ]
[ "fmod",		  "COMMAND:   ",  "fmod(dbl, dbl) : dbl",	  "The fmod(x,y) function computes the remainder of dividing x by y.\nThe return value is x - n * y, where n is the quotient of x / y,\nrounded towards zero to an integer."																						  ]
[ "isinf",		  "COMMAND:   ",  "isinf(dbl) : int",		  "The isinf(x) function returns -1 if x represents negative infinity, 1 if x represents positive infinity, and 0 otherwise."																												  ]
[ "isnan",		  "COMMAND:   ",  "isnan(dbl) : bit",		  "The isnan(x) function returns true if x is 'not-a-number' (NaN), and false otherwise."																																  ]
[ "log",		  "COMMAND:   ",  "log(dbl) : dbl",		  "The log(x) function returns the natural logarithm of x."																																				  ]
[ "log",		  "PROC:      ",  "log(flt) : flt",		  "not available"																																									  ]
[ "log10",		  "COMMAND:   ",  "log10(dbl) : dbl",		  "The log10(x) function returns the base-10 logarithm of x."																																				  ]
[ "log10",		  "PROC:      ",  "log10(flt) : flt",		  "not available"																																									  ]
[ "pow",		  "COMMAND:   ",  "pow(dbl, dbl) : dbl",	  "The pow(x,y) function  returns the value of x raised to the power of y."																																		  ]
[ "round",		  "COMMAND:   ",  "round(dbl, int) : dbl",	  "The round(n, m) returns n rounded to m places to the right of the\ndecimal point; if m is omitted, to 0 places. m can be negative to\nround off digits left of the decimal point. m must be an integer."																		  ]
[ "sin",		  "COMMAND:   ",  "sin(dbl) : dbl",		  "The sin(x) function returns the cosine of x,\nwhere x is given in radians. The return value is between -1 and 1."																													  ]
[ "sin",		  "PROC:      ",  "sin(flt) : flt",		  "not available"																																									  ]
[ "sinh",		  "COMMAND:   ",  "sinh(dbl) : dbl",		  "The sinh() function  returns  the  hyperbolic sine of x,\nwhich is defined mathematically as (exp(x) - exp(-x)) / 2."																												  ]
[ "sinh",		  "PROC:      ",  "sinh(flt) : flt",		  "not available"																																									  ]
[ "sqrt",		  "COMMAND:   ",  "sqrt(dbl) : dbl",		  "The sqrt(x) function returns the non-negative square root of x."																																			  ]
[ "sqrt",		  "PROC:      ",  "sqrt(flt) : flt",		  "not available"																																									  ]
[ "tan",		  "COMMAND:   ",  "tan(dbl) : dbl",		  "The tan(x) function returns the tangent of x,\nwhere x is given in radians"																																		  ]
[ "tan",		  "PROC:      ",  "tan(flt) : flt",		  "not available"																																									  ]
[ "tanh",		  "COMMAND:   ",  "tanh(dbl) : dbl",		  "The tanh() function returns the hyperbolic tangent of x,\nwhich is defined mathematically as sinh(x) / cosh(x)."																													  ]
[ "tanh",		  "PROC:      ",  "tanh(flt) : flt",		  "not available"																																									  ]

Module: "monettime"

[ 116 ]
[ 116 ]
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
# function				type		signature														help													  # name
# str				str		str															str													  # type
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
[ "!=",				  "OPERATOR:  ",  "!=(date, date) : bit",												  "date non-equality test (!DS2.2)"									  ]
[ "!=",				  "OPERATOR:  ",  "!=(daytime, daytime) : bit",												  "daytime non-equality test (!DS2.2)"									  ]
[ "!=",				  "OPERATOR:  ",  "!=(timestamp, timestamp) : bit",											  "timestamp non-equality test (!DS2.2)"								  ]
[ "<",				  "OPERATOR:  ",  "<(date, date) : bit",												  "date smaller-than test (!DS2.2)"									  ]
[ "<",				  "OPERATOR:  ",  "<(daytime, daytime) : bit",												  "daytime smaller-than test (!DS2.2)"									  ]
[ "<",				  "OPERATOR:  ",  "<(timestamp, timestamp) : bit",											  "timestamp smaller-than test (!DS2.2)"								  ]
[ "<=",				  "OPERATOR:  ",  "<=(date, date) : bit",												  "date smaller-or-equal test (!DS2.2)"									  ]
[ "<=",				  "OPERATOR:  ",  "<=(daytime, daytime) : bit",												  "daytime smaller-or-equal test (!DS2.2)"								  ]
[ "<=",				  "OPERATOR:  ",  "<=(timestamp, timestamp) : bit",											  "timestamp smaller-or-equal test (!DS2.2)"								  ]
[ "=",				  "OPERATOR:  ",  "=(date, date) : bit",												  "date equality test (!DS2.2)"										  ]
[ "=",				  "OPERATOR:  ",  "=(daytime, daytime) : bit",												  "daytime equality test (!DS2.2)"									  ]
[ "=",				  "OPERATOR:  ",  "=(timestamp, timestamp) : bit",											  "timestamp equality test (!DS2.2)"									  ]
[ ">",				  "OPERATOR:  ",  ">(date, date) : bit",												  "date greater-than test (!DS2.2)"									  ]
[ ">",				  "OPERATOR:  ",  ">(daytime, daytime) : bit",												  "daytime greater-than test (!DS2.2)"									  ]
[ ">",				  "OPERATOR:  ",  ">(timestamp, timestamp) : bit",											  "timestamp greater-than test (!DS2.2)"								  ]
[ ">=",				  "OPERATOR:  ",  ">=(date, date) : bit",												  "date greater-or-equal test (!DS2.2)"									  ]
[ ">=",				  "OPERATOR:  ",  ">=(daytime, daytime) : bit",												  "daytime greater-or-equal test (!DS2.2)"								  ]
[ ">=",				  "OPERATOR:  ",  ">=(timestamp, timestamp) : bit",											  "timestamp greater-or-equal test (!DS2.2)"								  ]
[ "TIMEZONE",			  "PROC:      ",  "TIMEZONE(str) : tzone",												  "not available"											  ]
[ "[date]",			  "PROC:      ",  "[date](BAT[any::1,timestamp]) : BAT[any::1,date]",									  "not available"											  ]
[ "[daytime]",			  "PROC:      ",  "[daytime](BAT[any::1,int]) : BAT[any::1,daytime]",									  "not available"											  ]
[ "[daytime]",			  "PROC:      ",  "[daytime](BAT[any::1,int], BAT[any::1,int]) : BAT[any::1,daytime]",							  "not available"											  ]
[ "[daytime]",			  "PROC:      ",  "[daytime](BAT[any::1,int], BAT[any::1,int], BAT[any::1,int]) : BAT[any::1,daytime]",					  "not available"											  ]
[ "[daytime]",			  "PROC:      ",  "[daytime](BAT[any::1,timestamp]) : BAT[any::1,daytime]",								  "not available"											  ]
[ "[epoch]",			  "PROC:      ",  "[epoch](BAT[any::1,timestamp]) : BAT[any::1,int]",									  "not available"											  ]
[ "[rule]",			  "PROC:      ",  "[rule](BAT[any::1,int], BAT[any::1,int], BAT[any::1,int], BAT[any::1,int], BAT[any::1,int]) : BAT[any::1,rule]",	  "not available"											  ]
[ "[rule]",			  "PROC:      ",  "[rule](BAT[any::1,int], BAT[any::1,str], BAT[any::1,int], BAT[any::1,int]) : BAT[any::1,rule]",			  "not available"											  ]
[ "[rule]",			  "PROC:      ",  "[rule](BAT[any::1,int], BAT[any::1,str], BAT[any::1,int], BAT[any::1,int], BAT[any::1,int]) : BAT[any::1,rule]",	  "not available"											  ]
[ "[timestamp]",		  "PROC:      ",  "[timestamp](BAT[any::1,date], BAT[any::1,daytime]) : BAT[any::1,timestamp]",						  "not available"											  ]
[ "[timestamp]",		  "PROC:      ",  "[timestamp](BAT[any::1,int]) : BAT[any::1,timestamp]",								  "not available"											  ]
[ "add",			  "COMMAND:   ",  "add(daytime, lng) : daytime",											  "returns the daytime that comes 'msecs' (possibly negative) after 'value'."				  ]
[ "add",			  "COMMAND:   ",  "add(timestamp, lng) : timestamp",											  "returns the timestamp that comes 'msecs' (possibly negative) after 'value' (!DS2.2)."		  ]
[ "adddays",			  "COMMAND:   ",  "adddays(date, int) : date",												  "returns the date after a number of days (possibly negative)."					  ]
[ "addmonths",			  "COMMAND:   ",  "addmonths(date, int) : date",											  "returns the date after a number of months (possibly negative)."					  ]
[ "addmonths",			  "PROC:      ",  "addmonths(timestamp, int) : timestamp",										  "not available"											  ]
[ "addyears",			  "COMMAND:   ",  "addyears(date, int) : date",												  "returns the date after a number of years (possibly negative)."					  ]
[ "compute",			  "COMMAND:   ",  "compute(rule, int) : date",												  "compute the date from a rule in a certain year (!DS2.2)."						  ]
[ "current_date",		  "PROC:      ",  "current_date() : date",												  "not available"											  ]
[ "current_time",		  "PROC:      ",  "current_time() : daytime",												  "not available"											  ]
[ "current_timestamp",		  "PROC:      ",  "current_timestamp() : timestamp",											  "not available"											  ]
[ "date",			  "COMMAND:   ",  "date(int, int, int) : date",												  "creates a date from (year,month,day) parameters."							  ]
[ "date",			  "COMMAND:   ",  "date(timestamp) : date",												  "extracts date from timestamp (in the local timezone)."						  ]
[ "date",			  "COMMAND:   ",  "date(timestamp, tzone) : date",											  "extracts date from timestamp in a certain tzone (!DS2.2)."						  ]
[ "date_add_sec_interval",	  "COMMAND:   ",  "date_add_sec_interval(date, int) : date",										  "add  seconds interval"										  ]
[ "date_add_sec_interval",	  "PROC:      ",  "date_add_sec_interval(date, lng) : date",										  "not available"											  ]
[ "date_sub_month_interval",	  "COMMAND:   ",  "date_sub_month_interval(date, int) : date",										  "subtract months interval"										  ]
[ "date_sub_sec_interval",	  "COMMAND:   ",  "date_sub_sec_interval(date, int) : date",										  "subtract seconds interval"										  ]
[ "date_sub_sec_interval",	  "PROC:      ",  "date_sub_sec_interval(date, lng) : date",										  "not available"											  ]
[ "day",			  "COMMAND:   ",  "day(date) : int",													  "extracts day from date (value between 1 and 31)"							  ]
[ "day",			  "COMMAND:   ",  "day(rule) : int",													  "extract day from rule (!DS2.2)."									  ]
[ "day",			  "PROC:      ",  "day(lng) : int",													  "not available"											  ]
[ "day",			  "PROC:      ",  "day(timestamp) : int",												  "not available"											  ]
[ "dayname",			  "COMMAND:   ",  "dayname(int) : str",													  "Returns day name from a number between [1-7], str(nil) otherwise (!DS2.2)."				  ]
[ "daynum",			  "COMMAND:   ",  "daynum(str) : int",													  "Returns number of day [1-7] from a string; or nil if does not match any (!DS2.2)."			  ]
[ "dayofweek",			  "COMMAND:   ",  "dayofweek(date) : int",												  "Returns the current day of the week where 1=sunday, .., 7=saturday"					  ]
[ "dayofyear",			  "COMMAND:   ",  "dayofyear(date) : int",												  "Returns N where d is the Nth day of the year (january 1 returns 1)"					  ]
[ "daytime",			  "COMMAND:   ",  "daytime(int, int, int, int) : daytime",										  "creates a time from (hours,minutes,seconds,milliseconds) parameters."				  ]
[ "daytime",			  "COMMAND:   ",  "daytime(timestamp) : daytime",											  "extracts daytime from timestamp (in the local timezone)."						  ]
[ "daytime",			  "COMMAND:   ",  "daytime(timestamp, tzone) : daytime",										  "extracts daytime from timestamp in a certain tzone (!DS2.2)."					  ]
[ "daytime",			  "PROC:      ",  "daytime(int) : daytime",												  "not available"											  ]
[ "daytime",			  "PROC:      ",  "daytime(int, int) : daytime",											  "not available"											  ]
[ "daytime",			  "PROC:      ",  "daytime(int, int, int) : daytime",											  "not available"											  ]
[ "diff",			  "COMMAND:   ",  "diff(date, date) : int",												  "returns the number of days between 'val1' and 'val2'."						  ]
[ "diff",			  "COMMAND:   ",  "diff(timestamp, timestamp) : lng",											  "returns the number of milliseconds between 'val1' and 'val2' (!DS2.2)."				  ]
[ "dst",			  "COMMAND:   ",  "dst(timestamp, tzone) : bit",											  "return whether DST holds in the tzone at a certain point of time (!DS2.2)."				  ]
[ "end_dst",			  "COMMAND:   ",  "end_dst(tzone) : rule",												  "extract rule that determines end of DST from tzone (!DS2.2)."					  ]
[ "epoch",			  "PROC:      ",  "epoch(timestamp) : int",												  "not available"											  ]
[ "hours",			  "COMMAND:   ",  "hours(daytime) : int",												  "extracts hour from daytime (value between 0 and 23)"							  ]
[ "hours",			  "PROC:      ",  "hours(lng) : int",													  "not available"											  ]
[ "hours",			  "PROC:      ",  "hours(timestamp) : int",												  "not available"											  ]
[ "isnil",			  "COMMAND:   ",  "isnil(date) : bit",													  "date nil test (!DS2.2)"										  ]
[ "isnil",			  "COMMAND:   ",  "isnil(daytime) : bit",												  "daytime nil test (!DS2.2)"										  ]
[ "isnil",			  "COMMAND:   ",  "isnil(timestamp) : bit",												  "timestamp nil test (!DS2.2)"										  ]
[ "local_timezone",		  "PROC:      ",  "local_timezone() : lng",												  "not available"											  ]
[ "milliseconds",		  "COMMAND:   ",  "milliseconds(daytime) : int",											  "extracts milliseconds from daytime (value between 0 and 999)"					  ]
[ "milliseconds",		  "PROC:      ",  "milliseconds(timestamp) : int",											  "not available"											  ]
[ "minutes",			  "COMMAND:   ",  "minutes(daytime) : int",												  "extracts minutes from daytime (value between 0 and 59)"						  ]
[ "minutes",			  "COMMAND:   ",  "minutes(rule) : int",												  "extract minutes from rule (!DS2.2)."									  ]
[ "minutes",			  "COMMAND:   ",  "minutes(tzone) : int",												  "extract number of minutes that tzone is offset wrt GMT (!DS2.2)."					  ]
[ "minutes",			  "PROC:      ",  "minutes(lng) : int",													  "not available"											  ]
[ "minutes",			  "PROC:      ",  "minutes(timestamp) : int",												  "not available"											  ]
[ "monettime_synonyms",		  "COMMAND:   ",  "monettime_synonyms(bit) : void",											  "Allow synonyms for the parse format of date/timestamp in addition ot their print format (!DS2.2)."	  ]
[ "month",			  "COMMAND:   ",  "month(date) : int",													  "extracts month from date (value between 1 and 12)"							  ]
[ "month",			  "COMMAND:   ",  "month(rule) : int",													  "extract month from rule (!DS2.2)."									  ]
[ "month",			  "PROC:      ",  "month(int) : int",													  "not available"											  ]
[ "month",			  "PROC:      ",  "month(timestamp) : int",												  "not available"											  ]
[ "monthname",			  "COMMAND:   ",  "monthname(int) : str",												  "Returns month name from a number between [1-12], str(nil) otherwise (!DS2.2)."			  ]
[ "monthnum",			  "COMMAND:   ",  "monthnum(str) : int",												  "Returns month number [1-12] from a string; or nil if does not match any (!DS2.2)."			  ]
[ "msecs",			  "PROC:      ",  "msecs(int, int, int, int, int) : lng",										  "not available"											  ]
[ "olddate",			  "COMMAND:   ",  "olddate(str) : date",												  "create a date from the old instant format."								  ]
[ "oldduration",		  "COMMAND:   ",  "oldduration(str) : int",												  "parse the old duration format and return an (estimated) number of days."				  ]
[ "rule",			  "COMMAND:   ",  "rule(int, int, int, int) : rule",											  "create a DST start/end date rule. (!DS2.2)"								  ]
[ "rule",			  "PROC:      ",  "rule(int, int, int, int, int) : rule",										  "not available"											  ]
[ "rule",			  "PROC:      ",  "rule(int, str, int, int) : rule",											  "not available"											  ]
[ "rule",			  "PROC:      ",  "rule(int, str, int, int, int) : rule",										  "not available"											  ]
[ "seconds",			  "COMMAND:   ",  "seconds(daytime) : int",												  "extracts seconds from daytime (value between 0 and 59)"						  ]
[ "seconds",			  "PROC:      ",  "seconds(lng) : int",													  "not available"											  ]
[ "seconds",			  "PROC:      ",  "seconds(timestamp) : int",												  "not available"											  ]
[ "start_dst",			  "COMMAND:   ",  "start_dst(tzone) : rule",												  "extract rule that determines start of DST from tzone (!DS2.2)."					  ]
[ "time_add_sec_interval",	  "PROC:      ",  "time_add_sec_interval(daytime, lng) : daytime",									  "not available"											  ]
[ "time_sub_sec_interval",	  "PROC:      ",  "time_sub_sec_interval(daytime, lng) : daytime",									  "not available"											  ]
[ "timestamp",			  "COMMAND:   ",  "timestamp(date, daytime) : timestamp",										  "creates a timestamp from (date,daytime) parameters (in the local timezone)."				  ]
[ "timestamp",			  "COMMAND:   ",  "timestamp(date, daytime, tzone) : timestamp",									  "creates a timestamp from (date,daytime,tzone) parameters (!DS2.2)."					  ]
[ "timestamp",			  "PROC:      ",  "timestamp(int) : timestamp",												  "not available"											  ]
[ "timestamp_add_sec_interval",	  "PROC:      ",  "timestamp_add_sec_interval(timestamp, lng) : timestamp",								  "not available"											  ]
[ "timestamp_sub_month_interval", "PROC:      ",  "timestamp_sub_month_interval(timestamp, int) : timestamp",								  "not available"											  ]
[ "timestamp_sub_sec_interval",	  "PROC:      ",  "timestamp_sub_sec_interval(timestamp, lng) : timestamp",								  "not available"											  ]
[ "tzone",			  "COMMAND:   ",  "tzone(int) : tzone",													  "create a tzone as a simple hour difference from GMT. (!DS2.2)"					  ]
[ "tzone",			  "COMMAND:   ",  "tzone(int, rule, rule) : tzone",											  "create a tzone as an hour difference from GMT and a DST. (!DS2.2)"					  ]
[ "tzone_local",		  "COMMAND:   ",  "tzone_local() : tzone",												  "get the local tzone; which is used for printing timestamps (!DS2.2)"					  ]
[ "tzone_local",		  "COMMAND:   ",  "tzone_local(tzone) : void",												  "set the local tzone; which is used for printing timestamps (!DS2.2)"					  ]
[ "weekday",			  "COMMAND:   ",  "weekday(rule) : int",												  "extract weekday from rule (!DS2.2)."									  ]
[ "weekofyear",			  "COMMAND:   ",  "weekofyear(date) : int",												  "Returns the week number in the year."								  ]
[ "year",			  "COMMAND:   ",  "year(date) : int",													  "extracts year from date (nonzero value between -5867411 and +5867411)."				  ]
[ "year",			  "PROC:      ",  "year(int) : int",													  "not available"											  ]
[ "year",			  "PROC:      ",  "year(timestamp) : int",												  "not available"											  ]

Module: "pcl"

[ 8 ]
[ 8 ]
#---------------------------------------------------------------------------------------------------------------------------------------------------------#
# function			type		signature					help								  # name
# str			str		str						str								  # type
#---------------------------------------------------------------------------------------------------------------------------------------------------------#
[ "pcl_eventname",	  "COMMAND:   ",  "pcl_eventname(int) : str",			  "return name of given event number"				  ]
[ "pcl_info",		  "COMMAND:   ",  "pcl_info() : BAT[str,str]",			  "get information about the processor in use"			  ]
[ "pcl_query",		  "COMMAND:   ",  "pcl_query(BAT[int,any], int) : BAT[int,int]",  "query for existing events"					  ]
[ "pcl_start",		  "COMMAND:   ",  "pcl_start(BAT[int,any], int) : void",	  "start counting the given events"				  ]
[ "pcl_start_rates",	  "COMMAND:   ",  "pcl_start_rates(BAT[int,any], int) : void",	  "start counting the events needed for the given rates"	  ]
[ "pcl_stop",		  "COMMAND:   ",  "pcl_stop(BAT[int,any]) : BAT[int,lng]",	  "stop counting and return the counts for the given events."	  ]
[ "pcl_stop_rates",	  "COMMAND:   ",  "pcl_stop_rates(BAT[int,any]) : BAT[int,dbl]",  "stop event counters and return the requested rates."		  ]
[ "pcl_try",		  "COMMAND:   ",  "pcl_try(BAT[int,any], int) : bit",		  "try wheter the events could be started together on this CPU"	  ]

Module: "pcre"

[ 6 ]
[ 6 ]
#-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
# function		type		signature							help								  # name
# str		str		str								str								  # type
#-----------------------------------------------------------------------------------------------------------------------------------------------------------------#
[ "pcre_compile", "COMMAND:   ",  "pcre_compile(str) : pcre",					  "compile a pattern"						  ]
[ "pcre_match",	  "COMMAND:   ",  "pcre_match(pcre, str) : bit",				  "match a pattern"						  ]
[ "pcre_replace", "COMMAND:   ",  "pcre_replace(BAT[any::1,str], str, str, str) : BAT[any::1,str]",	  "Replace _all_ matches of \"pattern\" in every string contained in\\n   \"origin_strs\" with \"replacement\".\n\\n   If no matches found in a string, the string is copied to the returned BAT."																																																																				  ]
[ "pcre_replace", "COMMAND:   ",  "pcre_replace(str, str, str, str) : str",				  "Replace _all_ matches of \"pattern\" in \"origin_str\" with\\n\t\"replacement\".\n\\n    Parameter \"flags\" accept these flags: 'i', 'm', 's', and 'x'.\n\\n\t'e': if present, an empty string is considered to be a valid match\n\\n\t'i': if present, the match operates in case-insensitive mode. Otherwise, in\\n\t     case-sensitive mode.\n\\n    'm': if present, the match operates in multi-line mode.\n\\n\t's': if present, the match operates in \"dot-all\"\n\tThe specifications of the flags can be found in \"man pcreapi\"\n\\n\tThe flag letters may be repeated.\n\\n\tNo other letters than 'e', 'i', 'm', 's' and 'x' are allowed in \"flags\".\n\\n\tReturns the replaced string, or if no matches found, the original string."	  ]
[ "pcre_select",  "COMMAND:   ",  "pcre_select(str, BAT[any::1,str]) : BAT[any::1,str]",	  "Select tuples based on the pattern"				  ]
[ "pcre_uselect", "COMMAND:   ",  "pcre_uselect(str, BAT[any::1,str]) : BAT[any::1,void]",	  "Select tuples based on the pattern, only returning the head"	  ]

Module: "pqueue"

[ 95 ]
[ 95 ]
#-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
# tmp_35				tmp_36		tmp_37							tmp_40											  # name
# str				str		str							str											  # type
#-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
[ "pqueue_dequeue_max",		  "COMMAND:   ",  "pqueue_dequeue_max(BAT[oid,any]) : void",		  "Removes top element of the max-pqueue and updates it"				  ]
[ "pqueue_dequeue_max",		  "COMMAND:   ",  "pqueue_dequeue_max(BAT[oid,chr]) : void",		  "Removes top element of the max-pqueue and updates it"				  ]
[ "pqueue_dequeue_max",		  "COMMAND:   ",  "pqueue_dequeue_max(BAT[oid,dbl]) : void",		  "Removes top element of the max-pqueue and updates it"				  ]
[ "pqueue_dequeue_max",		  "COMMAND:   ",  "pqueue_dequeue_max(BAT[oid,flt]) : void",		  "Removes top element of the max-pqueue and updates it"				  ]
[ "pqueue_dequeue_max",		  "COMMAND:   ",  "pqueue_dequeue_max(BAT[oid,int]) : void",		  "Removes top element of the max-pqueue and updates it"				  ]
[ "pqueue_dequeue_max",		  "COMMAND:   ",  "pqueue_dequeue_max(BAT[oid,lng]) : void",		  "Removes top element of the max-pqueue and updates it"				  ]
[ "pqueue_dequeue_max",		  "COMMAND:   ",  "pqueue_dequeue_max(BAT[oid,oid]) : void",		  "Removes top element of the max-pqueue and updates it"				  ]
[ "pqueue_dequeue_max",		  "COMMAND:   ",  "pqueue_dequeue_max(BAT[oid,ptr]) : void",		  "Removes top element of the max-pqueue and updates it"				  ]
[ "pqueue_dequeue_max",		  "COMMAND:   ",  "pqueue_dequeue_max(BAT[oid,sht]) : void",		  "Removes top element of the max-pqueue and updates it"				  ]
[ "pqueue_dequeue_min",		  "COMMAND:   ",  "pqueue_dequeue_min(BAT[oid,any]) : void",		  "Removes top element of the min-pqueue and updates it"				  ]
[ "pqueue_dequeue_min",		  "COMMAND:   ",  "pqueue_dequeue_min(BAT[oid,chr]) : void",		  "Removes top element of the min-pqueue and updates it"				  ]
[ "pqueue_dequeue_min",		  "COMMAND:   ",  "pqueue_dequeue_min(BAT[oid,dbl]) : void",		  "Removes top element of the min-pqueue and updates it"				  ]
[ "pqueue_dequeue_min",		  "COMMAND:   ",  "pqueue_dequeue_min(BAT[oid,flt]) : void",		  "Removes top element of the min-pqueue and updates it"				  ]
[ "pqueue_dequeue_min",		  "COMMAND:   ",  "pqueue_dequeue_min(BAT[oid,int]) : void",		  "Removes top element of the min-pqueue and updates it"				  ]
[ "pqueue_dequeue_min",		  "COMMAND:   ",  "pqueue_dequeue_min(BAT[oid,lng]) : void",		  "Removes top element of the min-pqueue and updates it"				  ]
[ "pqueue_dequeue_min",		  "COMMAND:   ",  "pqueue_dequeue_min(BAT[oid,oid]) : void",		  "Removes top element of the min-pqueue and updates it"				  ]
[ "pqueue_dequeue_min",		  "COMMAND:   ",  "pqueue_dequeue_min(BAT[oid,ptr]) : void",		  "Removes top element of the min-pqueue and updates it"				  ]
[ "pqueue_dequeue_min",		  "COMMAND:   ",  "pqueue_dequeue_min(BAT[oid,sht]) : void",		  "Removes top element of the min-pqueue and updates it"				  ]
[ "pqueue_enqueue_max",		  "COMMAND:   ",  "pqueue_enqueue_max(BAT[oid,any], oid, any) : void",	  "Inserts element (oid,any) in the max-pqueue"						  ]
[ "pqueue_enqueue_max",		  "COMMAND:   ",  "pqueue_enqueue_max(BAT[oid,chr], oid, chr) : void",	  "Inserts element (oid,chr) in the max-pqueue"						  ]
[ "pqueue_enqueue_max",		  "COMMAND:   ",  "pqueue_enqueue_max(BAT[oid,dbl], oid, dbl) : void",	  "Inserts element (oid,dbl) in the max-pqueue"						  ]
[ "pqueue_enqueue_max",		  "COMMAND:   ",  "pqueue_enqueue_max(BAT[oid,flt], oid, flt) : void",	  "Inserts element (oid,flt) in the max-pqueue"						  ]
[ "pqueue_enqueue_max",		  "COMMAND:   ",  "pqueue_enqueue_max(BAT[oid,int], oid, int) : void",	  "Inserts element (oid,int) in the max-pqueue"						  ]
[ "pqueue_enqueue_max",		  "COMMAND:   ",  "pqueue_enqueue_max(BAT[oid,lng], oid, lng) : void",	  "Inserts element (oid,lng) in the max-pqueue"						  ]
[ "pqueue_enqueue_max",		  "COMMAND:   ",  "pqueue_enqueue_max(BAT[oid,oid], oid, oid) : void",	  "Inserts element (oid,oid) in the max-pqueue"						  ]
[ "pqueue_enqueue_max",		  "COMMAND:   ",  "pqueue_enqueue_max(BAT[oid,ptr], oid, ptr) : void",	  "Inserts element (oid,ptr) in the max-pqueue"						  ]
[ "pqueue_enqueue_max",		  "COMMAND:   ",  "pqueue_enqueue_max(BAT[oid,sht], oid, sht) : void",	  "Inserts element (oid,sht) in the max-pqueue"						  ]
[ "pqueue_enqueue_min",		  "COMMAND:   ",  "pqueue_enqueue_min(BAT[oid,any], oid, any) : void",	  "Inserts element (oid,any) in the min-pqueue"						  ]
[ "pqueue_enqueue_min",		  "COMMAND:   ",  "pqueue_enqueue_min(BAT[oid,chr], oid, chr) : void",	  "Inserts element (oid,chr) in the min-pqueue"						  ]
[ "pqueue_enqueue_min",		  "COMMAND:   ",  "pqueue_enqueue_min(BAT[oid,dbl], oid, dbl) : void",	  "Inserts element (oid,dbl) in the min-pqueue"						  ]
[ "pqueue_enqueue_min",		  "COMMAND:   ",  "pqueue_enqueue_min(BAT[oid,flt], oid, flt) : void",	  "Inserts element (oid,flt) in the min-pqueue"						  ]
[ "pqueue_enqueue_min",		  "COMMAND:   ",  "pqueue_enqueue_min(BAT[oid,int], oid, int) : void",	  "Inserts element (oid,int) in the min-pqueue"						  ]
[ "pqueue_enqueue_min",		  "COMMAND:   ",  "pqueue_enqueue_min(BAT[oid,lng], oid, lng) : void",	  "Inserts element (oid,lng) in the min-pqueue"						  ]
[ "pqueue_enqueue_min",		  "COMMAND:   ",  "pqueue_enqueue_min(BAT[oid,oid], oid, oid) : void",	  "Inserts element (oid,oid) in the min-pqueue"						  ]
[ "pqueue_enqueue_min",		  "COMMAND:   ",  "pqueue_enqueue_min(BAT[oid,ptr], oid, ptr) : void",	  "Inserts element (oid,ptr) in the min-pqueue"						  ]
[ "pqueue_enqueue_min",		  "COMMAND:   ",  "pqueue_enqueue_min(BAT[oid,sht], oid, sht) : void",	  "Inserts element (oid,sht) in the min-pqueue"						  ]
[ "pqueue_init",		  "COMMAND:   ",  "pqueue_init(BAT[void,any::1], int) : BAT[oid,any::1]", "Creates an initially empty pqueue of bat a's tailtype with maximum size maxsize"	  ]
[ "pqueue_peek",		  "PROC:      ",  "pqueue_peek(BAT[oid,any]) : any",			  "not available"									  ]
[ "pqueue_topn",		  "PROC:      ",  "pqueue_topn(BAT[oid,any], int, int) : BAT[oid,any]",	  "not available"									  ]
[ "pqueue_topn_max",		  "COMMAND:   ",  "pqueue_topn_max(BAT[oid,any], int) : BAT[oid,any]",	  "Return the topn elements of the bat t using a max-pqueue"				  ]
[ "pqueue_topn_max",		  "COMMAND:   ",  "pqueue_topn_max(BAT[oid,chr], int) : BAT[oid,chr]",	  "Return the topn elements of the bat t using a max-pqueue"				  ]
[ "pqueue_topn_max",		  "COMMAND:   ",  "pqueue_topn_max(BAT[oid,dbl], int) : BAT[oid,dbl]",	  "Return the topn elements of the bat t using a max-pqueue"				  ]
[ "pqueue_topn_max",		  "COMMAND:   ",  "pqueue_topn_max(BAT[oid,flt], int) : BAT[oid,flt]",	  "Return the topn elements of the bat t using a max-pqueue"				  ]
[ "pqueue_topn_max",		  "COMMAND:   ",  "pqueue_topn_max(BAT[oid,int], int) : BAT[oid,int]",	  "Return the topn elements of the bat t using a max-pqueue"				  ]
[ "pqueue_topn_max",		  "COMMAND:   ",  "pqueue_topn_max(BAT[oid,lng], int) : BAT[oid,lng]",	  "Return the topn elements of the bat t using a max-pqueue"				  ]
[ "pqueue_topn_max",		  "COMMAND:   ",  "pqueue_topn_max(BAT[oid,oid], int) : BAT[oid,oid]",	  "Return the topn elements of the bat t using a max-pqueue"				  ]
[ "pqueue_topn_max",		  "COMMAND:   ",  "pqueue_topn_max(BAT[oid,ptr], int) : BAT[oid,ptr]",	  "Return the topn elements of the bat t using a max-pqueue"				  ]
[ "pqueue_topn_max",		  "COMMAND:   ",  "pqueue_topn_max(BAT[oid,sht], int) : BAT[oid,sht]",	  "Return the topn elements of the bat t using a max-pqueue"				  ]
[ "pqueue_topn_max",		  "COMMAND:   ",  "pqueue_topn_max(BAT[void,any], int) : BAT[oid,any]",	  "Return the topn elements of the bat t using a max-pqueue"				  ]
[ "pqueue_topn_max",		  "COMMAND:   ",  "pqueue_topn_max(BAT[void,chr], int) : BAT[oid,chr]",	  "Return the topn elements of the bat t using a max-pqueue"				  ]
[ "pqueue_topn_max",		  "COMMAND:   ",  "pqueue_topn_max(BAT[void,dbl], int) : BAT[oid,dbl]",	  "Return the topn elements of the bat t using a max-pqueue"				  ]
[ "pqueue_topn_max",		  "COMMAND:   ",  "pqueue_topn_max(BAT[void,flt], int) : BAT[oid,flt]",	  "Return the topn elements of the bat t using a max-pqueue"				  ]
[ "pqueue_topn_max",		  "COMMAND:   ",  "pqueue_topn_max(BAT[void,int], int) : BAT[oid,int]",	  "Return the topn elements of the bat t using a max-pqueue"				  ]
[ "pqueue_topn_max",		  "COMMAND:   ",  "pqueue_topn_max(BAT[void,lng], int) : BAT[oid,lng]",	  "Return the topn elements of the bat t using a max-pqueue"				  ]
[ "pqueue_topn_max",		  "COMMAND:   ",  "pqueue_topn_max(BAT[void,oid], int) : BAT[oid,oid]",	  "Return the topn elements of the bat t using a max-pqueue"				  ]
[ "pqueue_topn_max",		  "COMMAND:   ",  "pqueue_topn_max(BAT[void,ptr], int) : BAT[oid,ptr]",	  "Return the topn elements of the bat t using a max-pqueue"				  ]
[ "pqueue_topn_max",		  "COMMAND:   ",  "pqueue_topn_max(BAT[void,sht], int) : BAT[oid,sht]",	  "Return the topn elements of the bat t using a max-pqueue"				  ]
[ "pqueue_topn_min",		  "COMMAND:   ",  "pqueue_topn_min(BAT[oid,any], int) : BAT[oid,any]",	  "Return the topn elements of the bat t using a min-pqueue"				  ]
[ "pqueue_topn_min",		  "COMMAND:   ",  "pqueue_topn_min(BAT[oid,chr], int) : BAT[oid,chr]",	  "Return the topn elements of the bat t using a min-pqueue"				  ]
[ "pqueue_topn_min",		  "COMMAND:   ",  "pqueue_topn_min(BAT[oid,dbl], int) : BAT[oid,dbl]",	  "Return the topn elements of the bat t using a min-pqueue"				  ]
[ "pqueue_topn_min",		  "COMMAND:   ",  "pqueue_topn_min(BAT[oid,flt], int) : BAT[oid,flt]",	  "Return the topn elements of the bat t using a min-pqueue"				  ]
[ "pqueue_topn_min",		  "COMMAND:   ",  "pqueue_topn_min(BAT[oid,int], int) : BAT[oid,int]",	  "Return the topn elements of the bat t using a min-pqueue"				  ]
[ "pqueue_topn_min",		  "COMMAND:   ",  "pqueue_topn_min(BAT[oid,lng], int) : BAT[oid,lng]",	  "Return the topn elements of the bat t using a min-pqueue"				  ]
[ "pqueue_topn_min",		  "COMMAND:   ",  "pqueue_topn_min(BAT[oid,oid], int) : BAT[oid,oid]",	  "Return the topn elements of the bat t using a min-pqueue"				  ]
[ "pqueue_topn_min",		  "COMMAND:   ",  "pqueue_topn_min(BAT[oid,ptr], int) : BAT[oid,ptr]",	  "Return the topn elements of the bat t using a min-pqueue"				  ]
[ "pqueue_topn_min",		  "COMMAND:   ",  "pqueue_topn_min(BAT[oid,sht], int) : BAT[oid,sht]",	  "Return the topn elements of the bat t using a min-pqueue"				  ]
[ "pqueue_topn_min",		  "COMMAND:   ",  "pqueue_topn_min(BAT[void,any], int) : BAT[oid,any]",	  "Return the topn elements of the bat t using a min-pqueue"				  ]
[ "pqueue_topn_min",		  "COMMAND:   ",  "pqueue_topn_min(BAT[void,chr], int) : BAT[oid,chr]",	  "Return the topn elements of the bat t using a min-pqueue"				  ]
[ "pqueue_topn_min",		  "COMMAND:   ",  "pqueue_topn_min(BAT[void,dbl], int) : BAT[oid,dbl]",	  "Return the topn elements of the bat t using a min-pqueue"				  ]
[ "pqueue_topn_min",		  "COMMAND:   ",  "pqueue_topn_min(BAT[void,flt], int) : BAT[oid,flt]",	  "Return the topn elements of the bat t using a min-pqueue"				  ]
[ "pqueue_topn_min",		  "COMMAND:   ",  "pqueue_topn_min(BAT[void,int], int) : BAT[oid,int]",	  "Return the topn elements of the bat t using a min-pqueue"				  ]
[ "pqueue_topn_min",		  "COMMAND:   ",  "pqueue_topn_min(BAT[void,lng], int) : BAT[oid,lng]",	  "Return the topn elements of the bat t using a min-pqueue"				  ]
[ "pqueue_topn_min",		  "COMMAND:   ",  "pqueue_topn_min(BAT[void,oid], int) : BAT[oid,oid]",	  "Return the topn elements of the bat t using a min-pqueue"				  ]
[ "pqueue_topn_min",		  "COMMAND:   ",  "pqueue_topn_min(BAT[void,ptr], int) : BAT[oid,ptr]",	  "Return the topn elements of the bat t using a min-pqueue"				  ]
[ "pqueue_topn_min",		  "COMMAND:   ",  "pqueue_topn_min(BAT[void,sht], int) : BAT[oid,sht]",	  "Return the topn elements of the bat t using a min-pqueue"				  ]
[ "pqueue_topreplace_max",	  "COMMAND:   ",  "pqueue_topreplace_max(BAT[oid,any], oid, any) : void", "Replaces top element with input and updates max-pqueue"				  ]
[ "pqueue_topreplace_max",	  "COMMAND:   ",  "pqueue_topreplace_max(BAT[oid,chr], oid, chr) : void", "Replaces top element with input and updates max-pqueue"				  ]
[ "pqueue_topreplace_max",	  "COMMAND:   ",  "pqueue_topreplace_max(BAT[oid,dbl], oid, dbl) : void", "Replaces top element with input and updates max-pqueue"				  ]
[ "pqueue_topreplace_max",	  "COMMAND:   ",  "pqueue_topreplace_max(BAT[oid,flt], oid, flt) : void", "Replaces top element with input and updates max-pqueue"				  ]
[ "pqueue_topreplace_max",	  "COMMAND:   ",  "pqueue_topreplace_max(BAT[oid,int], oid, int) : void", "Replaces top element with input and updates max-pqueue"				  ]
[ "pqueue_topreplace_max",	  "COMMAND:   ",  "pqueue_topreplace_max(BAT[oid,lng], oid, lng) : void", "Replaces top element with input and updates max-pqueue"				  ]
[ "pqueue_topreplace_max",	  "COMMAND:   ",  "pqueue_topreplace_max(BAT[oid,oid], oid, oid) : void", "Replaces top element with input and updates max-pqueue"				  ]
[ "pqueue_topreplace_max",	  "COMMAND:   ",  "pqueue_topreplace_max(BAT[oid,ptr], oid, ptr) : void", "Replaces top element with input and updates max-pqueue"				  ]
[ "pqueue_topreplace_max",	  "COMMAND:   ",  "pqueue_topreplace_max(BAT[oid,sht], oid, sht) : void", "Replaces top element with input and updates max-pqueue"				  ]
[ "pqueue_topreplace_min",	  "COMMAND:   ",  "pqueue_topreplace_min(BAT[oid,any], oid, any) : void", "Replaces top element with input and updates min-pqueue"				  ]
[ "pqueue_topreplace_min",	  "COMMAND:   ",  "pqueue_topreplace_min(BAT[oid,chr], oid, chr) : void", "Replaces top element with input and updates min-pqueue"				  ]
[ "pqueue_topreplace_min",	  "COMMAND:   ",  "pqueue_topreplace_min(BAT[oid,dbl], oid, dbl) : void", "Replaces top element with input and updates min-pqueue"				  ]
[ "pqueue_topreplace_min",	  "COMMAND:   ",  "pqueue_topreplace_min(BAT[oid,flt], oid, flt) : void", "Replaces top element with input and updates min-pqueue"				  ]
[ "pqueue_topreplace_min",	  "COMMAND:   ",  "pqueue_topreplace_min(BAT[oid,int], oid, int) : void", "Replaces top element with input and updates min-pqueue"				  ]
[ "pqueue_topreplace_min",	  "COMMAND:   ",  "pqueue_topreplace_min(BAT[oid,lng], oid, lng) : void", "Replaces top element with input and updates min-pqueue"				  ]
[ "pqueue_topreplace_min",	  "COMMAND:   ",  "pqueue_topreplace_min(BAT[oid,oid], oid, oid) : void", "Replaces top element with input and updates min-pqueue"				  ]
[ "pqueue_topreplace_min",	  "COMMAND:   ",  "pqueue_topreplace_min(BAT[oid,ptr], oid, ptr) : void", "Replaces top element with input and updates min-pqueue"				  ]
[ "pqueue_topreplace_min",	  "COMMAND:   ",  "pqueue_topreplace_min(BAT[oid,sht], oid, sht) : void", "Replaces top element with input and updates min-pqueue"				  ]
[ "test_pqueue",		  "PROC:      ",  "test_pqueue() : void",				  "not available"									  ]
[ "test_pqueue_str",		  "PROC:      ",  "test_pqueue_str() : void",				  "not available"									  ]

Module: "profiler"

[ 13 ]
[ 13 ]
#---------------------------------------------------------------------------------------------------------------------------------------------------------#
# function			type		signature				help									  # name
# str			str		str					str									  # type
#---------------------------------------------------------------------------------------------------------------------------------------------------------#
[ "fclose",		  "PROC:      ",  "fclose(Stream) : void",		  "not available"							  ]
[ "fflush",		  "PROC:      ",  "fflush(Stream) : void",		  "not available"							  ]
[ "fopen",		  "PROC:      ",  "fopen(str, str) : Stream",		  "not available"							  ]
[ "fputs",		  "PROC:      ",  "fputs(str, Stream) : void",		  "not available"							  ]
[ "getProfilerCount",	  "COMMAND:   ",  "getProfilerCount() : BAT[str,int]",	  "Get a copy of the profiler count summary table"			  ]
[ "getProfilerTicks",	  "COMMAND:   ",  "getProfilerTicks() : BAT[str,lng]",	  "Get a copy of the profiler ticks summary table"			  ]
[ "profile",		  "PROC:      ",  "profile() : int",			  "not available"							  ]
[ "resetProfiler",	  "COMMAND:   ",  "resetProfiler() : void",		  "Set all counters to zero again"					  ]
[ "setFilter",		  "COMMAND:   ",  "setFilter(str, str) : int",		  "Set the profile filter strings"					  ]
[ "startProfiler",	  "COMMAND:   ",  "startProfiler() : void",		  "Collect command and proc counts"					  ]
[ "startProfiler",	  "COMMAND:   ",  "startProfiler(Stream) : int",	  "Start the event profiling stream; output is sent to Stream output"	  ]
[ "startProfiler",	  "COMMAND:   ",  "startProfiler(str) : int",		  "Start the event profiling stream; output is sent to fname"		  ]
[ "stopProfiler",	  "COMMAND:   ",  "stopProfiler() : int",		  "Stop the event profiling stream"					  ]

Module: "radix"

[ 142 ]
[ 142 ]
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
# function			type		signature													help																																																																																																									  # name
# str			str		str														str																																																																																																									  # type
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
[ "CACHE_LINES",	  "PROC:      ",  "CACHE_LINES() : int",											  "not available"																																																																																																							  ]
[ "[IntX]",		  "COMMAND:   ",  "[IntX](BAT[any::1,integer128]) : BAT[any::1,Int128]",							  "convert an integer128 to Int128"																																																																																																					  ]
[ "[IntX]",		  "COMMAND:   ",  "[IntX](BAT[any::1,integer16]) : BAT[any::1,Int16]",								  "convert an integer16 to Int16"																																																																																																					  ]
[ "[IntX]",		  "COMMAND:   ",  "[IntX](BAT[any::1,integer1]) : BAT[any::1,Int1]",								  "convert an integer1 to Int1"																																																																																																						  ]
[ "[IntX]",		  "COMMAND:   ",  "[IntX](BAT[any::1,integer256]) : BAT[any::1,Int256]",							  "convert an integer256 to Int256"																																																																																																					  ]
[ "[IntX]",		  "COMMAND:   ",  "[IntX](BAT[any::1,integer2]) : BAT[any::1,Int2]",								  "convert an integer2 to Int2"																																																																																																						  ]
[ "[IntX]",		  "COMMAND:   ",  "[IntX](BAT[any::1,integer32]) : BAT[any::1,Int32]",								  "convert an integer32 to Int32"																																																																																																					  ]
[ "[IntX]",		  "COMMAND:   ",  "[IntX](BAT[any::1,integer4]) : BAT[any::1,Int4]",								  "convert an integer4 to Int4"																																																																																																						  ]
[ "[IntX]",		  "COMMAND:   ",  "[IntX](BAT[any::1,integer64]) : BAT[any::1,Int64]",								  "convert an integer64 to Int64"																																																																																																					  ]
[ "[IntX]",		  "COMMAND:   ",  "[IntX](BAT[any::1,integer8]) : BAT[any::1,Int8]",								  "convert an integer8 to Int8"																																																																																																						  ]
[ "[integer]",		  "COMMAND:   ",  "[integer](BAT[any::1,int], int) : BAT[any::1,any]",								  "create a view that makes tail column appear as an integerX column for some width=X"																																																																																															  ]
[ "[integer]",		  "COMMAND:   ",  "[integer](BAT[any::1,integer128], int) : BAT[any::1,any]",							  "create a view that makes tail column appear as an integerX column for some width=X"																																																																																															  ]
[ "[integer]",		  "COMMAND:   ",  "[integer](BAT[any::1,integer16], int) : BAT[any::1,any]",							  "create a view that makes tail column appear as an integerX column for some width=X"																																																																																															  ]
[ "[integer]",		  "COMMAND:   ",  "[integer](BAT[any::1,integer1], int) : BAT[any::1,any]",							  "create a view that makes tail column appear as an integerX column for some width=X"																																																																																															  ]
[ "[integer]",		  "COMMAND:   ",  "[integer](BAT[any::1,integer256], int) : BAT[any::1,any]",							  "create a view that makes tail column appear as an integerX column for some width=X"																																																																																															  ]
[ "[integer]",		  "COMMAND:   ",  "[integer](BAT[any::1,integer2], int) : BAT[any::1,any]",							  "create a view that makes tail column appear as an integerX column for some width=X"																																																																																															  ]
[ "[integer]",		  "COMMAND:   ",  "[integer](BAT[any::1,integer32], int) : BAT[any::1,any]",							  "create a view that makes tail column appear as an integerX column for some width=X"																																																																																															  ]
[ "[integer]",		  "COMMAND:   ",  "[integer](BAT[any::1,integer4], int) : BAT[any::1,any]",							  "create a view that makes tail column appear as an integerX column for some width=X"																																																																																															  ]
[ "[integer]",		  "COMMAND:   ",  "[integer](BAT[any::1,integer64], int) : BAT[any::1,any]",							  "create a view that makes tail column appear as an integerX column for some width=X"																																																																																															  ]
[ "[integer]",		  "COMMAND:   ",  "[integer](BAT[any::1,integer8], int) : BAT[any::1,any]",							  "create a view that makes tail column appear as an integerX column for some width=X"																																																																																															  ]
[ "[integer]",		  "PROC:      ",  "[integer](BAT[any::1,int]) : BAT[any::1,integer1]",								  "not available"																																																																																																							  ]
[ "[pax]",		  "COMMAND:   ",  "[pax](BAT[any::1,integer128]) : BAT[any::1,pax128]",								  "convert an integer128 to pax128"																																																																																																					  ]
[ "[pax]",		  "COMMAND:   ",  "[pax](BAT[any::1,integer16]) : BAT[any::1,pax16]",								  "convert an integer16 to pax16"																																																																																																					  ]
[ "[pax]",		  "COMMAND:   ",  "[pax](BAT[any::1,integer1]) : BAT[any::1,pax1]",								  "convert an integer1 to pax1"																																																																																																						  ]
[ "[pax]",		  "COMMAND:   ",  "[pax](BAT[any::1,integer256]) : BAT[any::1,pax256]",								  "convert an integer256 to pax256"																																																																																																					  ]
[ "[pax]",		  "COMMAND:   ",  "[pax](BAT[any::1,integer2]) : BAT[any::1,pax2]",								  "convert an integer2 to pax2"																																																																																																						  ]
[ "[pax]",		  "COMMAND:   ",  "[pax](BAT[any::1,integer32]) : BAT[any::1,pax32]",								  "convert an integer32 to pax32"																																																																																																					  ]
[ "[pax]",		  "COMMAND:   ",  "[pax](BAT[any::1,integer4]) : BAT[any::1,pax4]",								  "convert an integer4 to pax4"																																																																																																						  ]
[ "[pax]",		  "COMMAND:   ",  "[pax](BAT[any::1,integer64]) : BAT[any::1,pax64]",								  "convert an integer64 to pax64"																																																																																																					  ]
[ "[pax]",		  "COMMAND:   ",  "[pax](BAT[any::1,integer8]) : BAT[any::1,pax8]",								  "convert an integer8 to pax8"																																																																																																						  ]
[ "cache_join",		  "PROC:      ",  "cache_join(BAT[void,oid], BAT[void,any::1]) : BAT[void,any::1]",						  "not available"																																																																																																							  ]
[ "jivejoin0",		  "COMMAND:   ",  "jivejoin0(BAT[oid,oid], BAT[void,any::1], BAT[int,int], int, int) : BAT[void,any::1]",			  "positional join with built-in NSM projection, and implicit 1-pass perfect knowledge radix-cluster on output according to proj head"																																																																																									  ]
[ "jivejoin1",		  "COMMAND:   ",  "jivejoin1(BAT[void,oid], BAT[oid,oid], BAT[void,any::1], BAT[int,int], int, int) : BAT[void,any::1]",	  "positional join with built-in NSM projection, and implicit 1-pass perfect knowledge radix-cluster on output according to proj head"																																																																																									  ]
[ "jivejoin1",		  "COMMAND:   ",  "jivejoin1(BAT[void,oid], BAT[oid,oid], BAT[void,integer128], BAT[int,int], int, int) : BAT[void,Int128]",	  "positional join with built-in NSM projection, and implicit 1-pass perfect knowledge radix-cluster on output according to proj head"																																																																																									  ]
[ "jivejoin1",		  "COMMAND:   ",  "jivejoin1(BAT[void,oid], BAT[oid,oid], BAT[void,integer16], BAT[int,int], int, int) : BAT[void,Int16]",	  "positional join with built-in NSM projection, and implicit 1-pass perfect knowledge radix-cluster on output according to proj head"																																																																																									  ]
[ "jivejoin1",		  "COMMAND:   ",  "jivejoin1(BAT[void,oid], BAT[oid,oid], BAT[void,integer1], BAT[int,int], int, int) : BAT[void,Int1]",	  "positional join with built-in NSM projection, and implicit 1-pass perfect knowledge radix-cluster on output according to proj head"																																																																																									  ]
[ "jivejoin1",		  "COMMAND:   ",  "jivejoin1(BAT[void,oid], BAT[oid,oid], BAT[void,integer256], BAT[int,int], int, int) : BAT[void,Int256]",	  "positional join with built-in NSM projection, and implicit 1-pass perfect knowledge radix-cluster on output according to proj head"																																																																																									  ]
[ "jivejoin1",		  "COMMAND:   ",  "jivejoin1(BAT[void,oid], BAT[oid,oid], BAT[void,integer2], BAT[int,int], int, int) : BAT[void,Int2]",	  "positional join with built-in NSM projection, and implicit 1-pass perfect knowledge radix-cluster on output according to proj head"																																																																																									  ]
[ "jivejoin1",		  "COMMAND:   ",  "jivejoin1(BAT[void,oid], BAT[oid,oid], BAT[void,integer32], BAT[int,int], int, int) : BAT[void,Int32]",	  "positional join with built-in NSM projection, and implicit 1-pass perfect knowledge radix-cluster on output according to proj head"																																																																																									  ]
[ "jivejoin1",		  "COMMAND:   ",  "jivejoin1(BAT[void,oid], BAT[oid,oid], BAT[void,integer4], BAT[int,int], int, int) : BAT[void,Int4]",	  "positional join with built-in NSM projection, and implicit 1-pass perfect knowledge radix-cluster on output according to proj head"																																																																																									  ]
[ "jivejoin1",		  "COMMAND:   ",  "jivejoin1(BAT[void,oid], BAT[oid,oid], BAT[void,integer64], BAT[int,int], int, int) : BAT[void,Int64]",	  "positional join with built-in NSM projection, and implicit 1-pass perfect knowledge radix-cluster on output according to proj head"																																																																																									  ]
[ "jivejoin1",		  "COMMAND:   ",  "jivejoin1(BAT[void,oid], BAT[oid,oid], BAT[void,integer8], BAT[int,int], int, int) : BAT[void,Int8]",	  "positional join with built-in NSM projection, and implicit 1-pass perfect knowledge radix-cluster on output according to proj head"																																																																																									  ]
[ "jivejoin1",		  "COMMAND:   ",  "jivejoin1(BAT[void,oid], BAT[oid,oid], BAT[void,pax128], BAT[int,int], int, int) : BAT[void,Int128]",	  "positional join with built-in NSM projection, and implicit 1-pass perfect knowledge radix-cluster on output according to proj head"																																																																																									  ]
[ "jivejoin1",		  "COMMAND:   ",  "jivejoin1(BAT[void,oid], BAT[oid,oid], BAT[void,pax16], BAT[int,int], int, int) : BAT[void,Int16]",		  "positional join with built-in NSM projection, and implicit 1-pass perfect knowledge radix-cluster on output according to proj head"																																																																																									  ]
[ "jivejoin1",		  "COMMAND:   ",  "jivejoin1(BAT[void,oid], BAT[oid,oid], BAT[void,pax1], BAT[int,int], int, int) : BAT[void,Int1]",		  "positional join with built-in NSM projection, and implicit 1-pass perfect knowledge radix-cluster on output according to proj head"																																																																																									  ]
[ "jivejoin1",		  "COMMAND:   ",  "jivejoin1(BAT[void,oid], BAT[oid,oid], BAT[void,pax256], BAT[int,int], int, int) : BAT[void,Int256]",	  "positional join with built-in NSM projection, and implicit 1-pass perfect knowledge radix-cluster on output according to proj head"																																																																																									  ]
[ "jivejoin1",		  "COMMAND:   ",  "jivejoin1(BAT[void,oid], BAT[oid,oid], BAT[void,pax2], BAT[int,int], int, int) : BAT[void,Int2]",		  "positional join with built-in NSM projection, and implicit 1-pass perfect knowledge radix-cluster on output according to proj head"																																																																																									  ]
[ "jivejoin1",		  "COMMAND:   ",  "jivejoin1(BAT[void,oid], BAT[oid,oid], BAT[void,pax32], BAT[int,int], int, int) : BAT[void,Int32]",		  "positional join with built-in NSM projection, and implicit 1-pass perfect knowledge radix-cluster on output according to proj head"																																																																																									  ]
[ "jivejoin1",		  "COMMAND:   ",  "jivejoin1(BAT[void,oid], BAT[oid,oid], BAT[void,pax4], BAT[int,int], int, int) : BAT[void,Int4]",		  "positional join with built-in NSM projection, and implicit 1-pass perfect knowledge radix-cluster on output according to proj head"																																																																																									  ]
[ "jivejoin1",		  "COMMAND:   ",  "jivejoin1(BAT[void,oid], BAT[oid,oid], BAT[void,pax64], BAT[int,int], int, int) : BAT[void,Int64]",		  "positional join with built-in NSM projection, and implicit 1-pass perfect knowledge radix-cluster on output according to proj head"																																																																																									  ]
[ "jivejoin1",		  "COMMAND:   ",  "jivejoin1(BAT[void,oid], BAT[oid,oid], BAT[void,pax8], BAT[int,int], int, int) : BAT[void,Int8]",		  "positional join with built-in NSM projection, and implicit 1-pass perfect knowledge radix-cluster on output according to proj head"																																																																																									  ]
[ "jivejoin2",		  "COMMAND:   ",  "jivejoin2(BAT[oid,oid], BAT[void,any::1]) : BAT[void,any::1]",						  "positional join that creates a void head by inserting the join result positionally"																																																																																															  ]
[ "jivejoin2",		  "COMMAND:   ",  "jivejoin2(BAT[oid,oid], BAT[void,integer128]) : BAT[void,Int128]",						  "positional join that creates a void head by inserting the join result positionally"																																																																																															  ]
[ "jivejoin2",		  "COMMAND:   ",  "jivejoin2(BAT[oid,oid], BAT[void,integer16]) : BAT[void,Int16]",						  "positional join that creates a void head by inserting the join result positionally"																																																																																															  ]
[ "jivejoin2",		  "COMMAND:   ",  "jivejoin2(BAT[oid,oid], BAT[void,integer1]) : BAT[void,Int1]",						  "positional join that creates a void head by inserting the join result positionally"																																																																																															  ]
[ "jivejoin2",		  "COMMAND:   ",  "jivejoin2(BAT[oid,oid], BAT[void,integer256]) : BAT[void,Int256]",						  "positional join that creates a void head by inserting the join result positionally"																																																																																															  ]
[ "jivejoin2",		  "COMMAND:   ",  "jivejoin2(BAT[oid,oid], BAT[void,integer2]) : BAT[void,Int2]",						  "positional join that creates a void head by inserting the join result positionally"																																																																																															  ]
[ "jivejoin2",		  "COMMAND:   ",  "jivejoin2(BAT[oid,oid], BAT[void,integer32]) : BAT[void,Int32]",						  "positional join that creates a void head by inserting the join result positionally"																																																																																															  ]
[ "jivejoin2",		  "COMMAND:   ",  "jivejoin2(BAT[oid,oid], BAT[void,integer4]) : BAT[void,Int4]",						  "positional join that creates a void head by inserting the join result positionally"																																																																																															  ]
[ "jivejoin2",		  "COMMAND:   ",  "jivejoin2(BAT[oid,oid], BAT[void,integer64]) : BAT[void,Int64]",						  "positional join that creates a void head by inserting the join result positionally"																																																																																															  ]
[ "jivejoin2",		  "COMMAND:   ",  "jivejoin2(BAT[oid,oid], BAT[void,integer8]) : BAT[void,Int8]",						  "positional join that creates a void head by inserting the join result positionally"																																																																																															  ]
[ "jivejoin2",		  "COMMAND:   ",  "jivejoin2(BAT[oid,oid], BAT[void,pax128]) : BAT[void,Int128]",						  "positional join that creates a void head by inserting the join result positionally"																																																																																															  ]
[ "jivejoin2",		  "COMMAND:   ",  "jivejoin2(BAT[oid,oid], BAT[void,pax16]) : BAT[void,Int16]",							  "positional join that creates a void head by inserting the join result positionally"																																																																																															  ]
[ "jivejoin2",		  "COMMAND:   ",  "jivejoin2(BAT[oid,oid], BAT[void,pax1]) : BAT[void,Int1]",							  "positional join that creates a void head by inserting the join result positionally"																																																																																															  ]
[ "jivejoin2",		  "COMMAND:   ",  "jivejoin2(BAT[oid,oid], BAT[void,pax256]) : BAT[void,Int256]",						  "positional join that creates a void head by inserting the join result positionally"																																																																																															  ]
[ "jivejoin2",		  "COMMAND:   ",  "jivejoin2(BAT[oid,oid], BAT[void,pax2]) : BAT[void,Int2]",							  "positional join that creates a void head by inserting the join result positionally"																																																																																															  ]
[ "jivejoin2",		  "COMMAND:   ",  "jivejoin2(BAT[oid,oid], BAT[void,pax32]) : BAT[void,Int32]",							  "positional join that creates a void head by inserting the join result positionally"																																																																																															  ]
[ "jivejoin2",		  "COMMAND:   ",  "jivejoin2(BAT[oid,oid], BAT[void,pax4]) : BAT[void,Int4]",							  "positional join that creates a void head by inserting the join result positionally"																																																																																															  ]
[ "jivejoin2",		  "COMMAND:   ",  "jivejoin2(BAT[oid,oid], BAT[void,pax64]) : BAT[void,Int64]",							  "positional join that creates a void head by inserting the join result positionally"																																																																																															  ]
[ "jivejoin2",		  "COMMAND:   ",  "jivejoin2(BAT[oid,oid], BAT[void,pax8]) : BAT[void,Int8]",							  "positional join that creates a void head by inserting the join result positionally"																																																																																															  ]
[ "log2",		  "PROC:      ",  "log2(int) : int",												  "not available"																																																																																																							  ]
[ "normal",		  "COMMAND:   ",  "normal(oid, int, int, int, int) : BAT[oid,int]",								  "create a random bat of certain size, head values unique, tail values\n from a normal distribution between [0..domain].\n default values: base = 0@0, mean = size/2, stddev = size/10, domain=size."																																																																																	  ]
[ "normal",		  "PROC:      ",  "normal(int) : BAT[oid,int]",											  "not available"																																																																																																							  ]
[ "normal",		  "PROC:      ",  "normal(int, int) : BAT[oid,int]",										  "not available"																																																																																																							  ]
[ "normal",		  "PROC:      ",  "normal(int, int, int) : BAT[oid,int]",									  "not available"																																																																																																							  ]
[ "normal",		  "PROC:      ",  "normal(int, int, int, int) : BAT[oid,int]",									  "not available"																																																																																																							  ]
[ "normal",		  "PROC:      ",  "normal(oid, int, int) : BAT[oid,int]",									  "not available"																																																																																																							  ]
[ "normal",		  "PROC:      ",  "normal(oid, int, int, int) : BAT[oid,int]",									  "not available"																																																																																																							  ]
[ "pax_blocksize",	  "COMMAND:   ",  "pax_blocksize(int) : int",											  "get/set the pax blocksize"																																																																																																						  ]
[ "pax_blocksize",	  "PROC:      ",  "pax_blocksize() : int",											  "not available"																																																																																																							  ]
[ "phash_join",		  "COMMAND:   ",  "phash_join(BAT[any::1,any::2], BAT[any::2,any::3], int, int, bit) : BAT[any,any]",				  "partitioned hash-join on radix clustered inputs"																																																																																																			  ]
[ "phash_join",		  "PROC:      ",  "phash_join(BAT[any::1,any::2], BAT[any::2,any::3]) : BAT[any::1,any::3]",					  "not available"																																																																																																							  ]
[ "phash_join_new",	  "PROC:      ",  "phash_join_new(BAT[any::1,any::2], BAT[any::2,any::3], int) : BAT[any::1,any::3]",				  "not available"																																																																																																							  ]
[ "phash_join_new",	  "PROC:      ",  "phash_join_new(BAT[any::1,any::2], BAT[any::2,any::3], int, int, bit) : BAT[any::1,any::3]",			  "not available"																																																																																																							  ]
[ "posjoin",		  "COMMAND:   ",  "posjoin(BAT[void,oid], BAT[void,any::1], int, int, int) : BAT[void,any::1]",					  "perform a positional join that exploits radix-clusteredness for prefetching"																																																																																																  ]
[ "posjoin",		  "COMMAND:   ",  "posjoin(BAT[void,oid], BAT[void,integer128]) : BAT[void,Int128]",						  "positional join with built-in NSM projection"																																																																																																			  ]
[ "posjoin",		  "COMMAND:   ",  "posjoin(BAT[void,oid], BAT[void,integer16]) : BAT[void,Int16]",						  "positional join with built-in NSM projection"																																																																																																			  ]
[ "posjoin",		  "COMMAND:   ",  "posjoin(BAT[void,oid], BAT[void,integer1]) : BAT[void,Int1]",						  "positional join with built-in NSM projection"																																																																																																			  ]
[ "posjoin",		  "COMMAND:   ",  "posjoin(BAT[void,oid], BAT[void,integer256]) : BAT[void,Int256]",						  "positional join with built-in NSM projection"																																																																																																			  ]
[ "posjoin",		  "COMMAND:   ",  "posjoin(BAT[void,oid], BAT[void,integer2]) : BAT[void,Int2]",						  "positional join with built-in NSM projection"																																																																																																			  ]
[ "posjoin",		  "COMMAND:   ",  "posjoin(BAT[void,oid], BAT[void,integer32]) : BAT[void,Int32]",						  "positional join with built-in NSM projection"																																																																																																			  ]
[ "posjoin",		  "COMMAND:   ",  "posjoin(BAT[void,oid], BAT[void,integer4]) : BAT[void,Int4]",						  "positional join with built-in NSM projection"																																																																																																			  ]
[ "posjoin",		  "COMMAND:   ",  "posjoin(BAT[void,oid], BAT[void,integer64]) : BAT[void,Int64]",						  "positional join with built-in NSM projection"																																																																																																			  ]
[ "posjoin",		  "COMMAND:   ",  "posjoin(BAT[void,oid], BAT[void,integer8]) : BAT[void,Int8]",						  "positional join with built-in NSM projection"																																																																																																			  ]
[ "posjoin",		  "COMMAND:   ",  "posjoin(BAT[void,oid], BAT[void,pax128]) : BAT[void,Int128]",						  "positional join with built-in PAX projection"																																																																																																			  ]
[ "posjoin",		  "COMMAND:   ",  "posjoin(BAT[void,oid], BAT[void,pax16]) : BAT[void,Int16]",							  "positional join with built-in PAX projection"																																																																																																			  ]
[ "posjoin",		  "COMMAND:   ",  "posjoin(BAT[void,oid], BAT[void,pax1]) : BAT[void,Int1]",							  "positional join with built-in PAX projection"																																																																																																			  ]
[ "posjoin",		  "COMMAND:   ",  "posjoin(BAT[void,oid], BAT[void,pax256]) : BAT[void,Int256]",						  "positional join with built-in PAX projection"																																																																																																			  ]
[ "posjoin",		  "COMMAND:   ",  "posjoin(BAT[void,oid], BAT[void,pax2]) : BAT[void,Int2]",							  "positional join with built-in PAX projection"																																																																																																			  ]
[ "posjoin",		  "COMMAND:   ",  "posjoin(BAT[void,oid], BAT[void,pax32]) : BAT[void,Int32]",							  "positional join with built-in PAX projection"																																																																																																			  ]
[ "posjoin",		  "COMMAND:   ",  "posjoin(BAT[void,oid], BAT[void,pax4]) : BAT[void,Int4]",							  "positional join with built-in PAX projection"																																																																																																			  ]
[ "posjoin",		  "COMMAND:   ",  "posjoin(BAT[void,oid], BAT[void,pax64]) : BAT[void,Int64]",							  "positional join with built-in PAX projection"																																																																																																			  ]
[ "posjoin",		  "COMMAND:   ",  "posjoin(BAT[void,oid], BAT[void,pax8]) : BAT[void,Int8]",							  "positional join with built-in PAX projection"																																																																																																			  ]
[ "posjoin",		  "PROC:      ",  "posjoin(BAT[void,oid], BAT[void,any::1], int) : BAT[void,any::1]",						  "not available"																																																																																																							  ]
[ "posjoin",		  "PROC:      ",  "posjoin(BAT[void,oid], BAT[void,any::1], int, int) : BAT[void,any::1]",					  "not available"																																																																																																							  ]
[ "radix_bits",		  "COMMAND:   ",  "radix_bits(BAT[any,any]) : int",										  "return the number of bits on which the head column is radix clustered."																																																																																																  ]
[ "radix_cluster",	  "COMMAND:   ",  "radix_cluster(BAT[any::1,any::2], str, flt, int, ..int..) : BAT[any::1,any::2]",				  "do N radix-cluster steps creating (radix1 * radix2 * ... * radixN) clusters. First pass uses\n the last radix parameter, and so on backwards. Partial radix cluster (i.e. skipping lower\n significant bits) can be indicated by passing a negative number of bits as first parameter.\n\n If you pass an appendable, empty, limits bat, a radix_count2 result with the resulting cluster\n boundaries is returned in it. Note that you pass a batname of b, as returned by b.bbpname().\n\n If you pass a non-empty limits bat, it is used for resuming the clustering. The operation\n assumes that all significant highermost bits are already clustered, and limits contains\n the cluster sizes.\n\n If you pass a non-empty but writable limits bat, it will be used as above for resume,\n and will also be overwritten with the new cluster boundaries"	  ]
[ "radix_cluster",	  "COMMAND:   ",  "radix_cluster(BAT[integer1,any::2], str, flt, int, ..int..) : BAT[Int1,any::2]",				  ""																																																																																																									  ]
[ "radix_cluster",	  "COMMAND:   ",  "radix_cluster(BAT[integer128,any::2], str, flt, int, ..int..) : BAT[Int128,any::2]",				  ""																																																																																																									  ]
[ "radix_cluster",	  "COMMAND:   ",  "radix_cluster(BAT[integer16,any::2], str, flt, int, ..int..) : BAT[Int16,any::2]",				  ""																																																																																																									  ]
[ "radix_cluster",	  "COMMAND:   ",  "radix_cluster(BAT[integer2,any::2], str, flt, int, ..int..) : BAT[Int2,any::2]",				  ""																																																																																																									  ]
[ "radix_cluster",	  "COMMAND:   ",  "radix_cluster(BAT[integer256,any::2], str, flt, int, ..int..) : BAT[Int256,any::2]",				  ""																																																																																																									  ]
[ "radix_cluster",	  "COMMAND:   ",  "radix_cluster(BAT[integer32,any::2], str, flt, int, ..int..) : BAT[Int32,any::2]",				  ""																																																																																																									  ]
[ "radix_cluster",	  "COMMAND:   ",  "radix_cluster(BAT[integer4,any::2], str, flt, int, ..int..) : BAT[Int4,any::2]",				  ""																																																																																																									  ]
[ "radix_cluster",	  "COMMAND:   ",  "radix_cluster(BAT[integer64,any::2], str, flt, int, ..int..) : BAT[Int64,any::2]",				  ""																																																																																																									  ]
[ "radix_cluster",	  "COMMAND:   ",  "radix_cluster(BAT[integer8,any::2], str, flt, int, ..int..) : BAT[Int8,any::2]",				  ""																																																																																																									  ]
[ "radix_cluster",	  "COMMAND:   ",  "radix_cluster(BAT[pax1,any::2], str, flt, int, ..int..) : BAT[Int1,any::2]",					  ""																																																																																																									  ]
[ "radix_cluster",	  "COMMAND:   ",  "radix_cluster(BAT[pax128,any::2], str, flt, int, ..int..) : BAT[Int128,any::2]",				  ""																																																																																																									  ]
[ "radix_cluster",	  "COMMAND:   ",  "radix_cluster(BAT[pax16,any::2], str, flt, int, ..int..) : BAT[Int16,any::2]",				  ""																																																																																																									  ]
[ "radix_cluster",	  "COMMAND:   ",  "radix_cluster(BAT[pax2,any::2], str, flt, int, ..int..) : BAT[Int2,any::2]",					  ""																																																																																																									  ]
[ "radix_cluster",	  "COMMAND:   ",  "radix_cluster(BAT[pax256,any::2], str, flt, int, ..int..) : BAT[Int256,any::2]",				  ""																																																																																																									  ]
[ "radix_cluster",	  "COMMAND:   ",  "radix_cluster(BAT[pax32,any::2], str, flt, int, ..int..) : BAT[Int32,any::2]",				  ""																																																																																																									  ]
[ "radix_cluster",	  "COMMAND:   ",  "radix_cluster(BAT[pax4,any::2], str, flt, int, ..int..) : BAT[Int4,any::2]",					  ""																																																																																																									  ]
[ "radix_cluster",	  "COMMAND:   ",  "radix_cluster(BAT[pax64,any::2], str, flt, int, ..int..) : BAT[Int64,any::2]",				  ""																																																																																																									  ]
[ "radix_cluster",	  "COMMAND:   ",  "radix_cluster(BAT[pax8,any::2], str, flt, int, ..int..) : BAT[Int8,any::2]",					  ""																																																																																																									  ]
[ "radix_cluster",	  "PROC:      ",  "radix_cluster(BAT[any::1,any::2], flt, int, ..int..) : BAT[any::1,any::2]",					  "not available"																																																																																																							  ]
[ "radix_cluster",	  "PROC:      ",  "radix_cluster(BAT[any::1,any::2], int, ..int..) : BAT[any::1,any::2]",					  "not available"																																																																																																							  ]
[ "radix_cluster",	  "PROC:      ",  "radix_cluster(BAT[any::1,any::2], str, int, ..int..) : BAT[any::1,any::2]",					  "not available"																																																																																																							  ]
[ "radix_cluster2",	  "PROC:      ",  "radix_cluster2(BAT[void,oid], int, int, int) : BAT[oid,oid]",						  "not available"																																																																																																							  ]
[ "radix_count",	  "COMMAND:   ",  "radix_count(BAT[oid,oid], int, int) : BAT[int,int]",								  "return a histogram [radix-pattern,bucket-size] for the tail values of some BAT b.\n the first int holds the number of radix bits, the second how many lower bits to ignore.\n notice that the bat b maybe partially radix-clustered (or not at all). the radix_count\n command just detects consecutive chunks where (1) the tail values have the same specified\n radix-bits and (2) the head values are ascending"																																																							  ]
[ "radix_count2",	  "COMMAND:   ",  "radix_count2(BAT[any,oid], int, int) : BAT[int,int]",							  "generates a bat with in head the dense ascending sequence 0..((1 << radix) - 1), and in tail\nthe count of all tail value in b with these radix bits, ignoring the lowmost ones passed in shift"																																																																																	  ]
[ "radix_decluster",	  "COMMAND:   ",  "radix_decluster(BAT[oid,any::1], BAT[int,int], int) : BAT[void,any::1]",					  "merge a (partially) radix-clustered dense collection of oids back to their original void\n position.  second bat *must* be result of b.radix_count(x,y). Third parameter is a multiplier\n that tells how many times the number of chunks the matching-window-size should be."																																																																							  ]
[ "radix_decluster",	  "PROC:      ",  "radix_decluster(BAT[oid,any::1], BAT[int,int]) : BAT[void,any::1]",						  "not available"																																																																																																							  ]
[ "radix_decluster2",	  "COMMAND:   ",  "radix_decluster2(BAT[any::2,oid], BAT[any::2,any::1], BAT[int,int], int) : BAT[void,any::1]",		  ""																																																																																																									  ]
[ "radix_decluster3",	  "COMMAND:   ",  "radix_decluster3(BAT[any::2,oid], BAT[any::2,any::1], BAT[int,int], int) : BAT[void,any::1]",		  ""																																																																																																									  ]
[ "radix_decluster4",	  "COMMAND:   ",  "radix_decluster4(BAT[any::2,oid], BAT[any::2,any::1], BAT[int,int], int) : BAT[void,any::1]",		  ""																																																																																																									  ]
[ "radix_join",		  "COMMAND:   ",  "radix_join(BAT[any::1,any::2], BAT[any::2,any::3], int, int) : BAT[any,any]",				  "nested-loop join on radix clustered inputs"																																																																																																				  ]
[ "radix_join",		  "PROC:      ",  "radix_join(BAT[any::1,any::2], BAT[any::2,any::3]) : BAT[any::1,any::3]",					  "not available"																																																																																																							  ]
[ "radix_join",		  "PROC:      ",  "radix_join(BAT[any::1,any::2], BAT[any::2,any::3], int) : BAT[any::1,any::3]",				  "not available"																																																																																																							  ]
[ "uniform",		  "COMMAND:   ",  "uniform(oid, int, int) : BAT[oid,int]",									  "create a random bat of certain size, head values unique, tail values\n perfect uniform from a certain domain (domain>size => unique tails)."																																																																																								  ]
[ "uniform",		  "PROC:      ",  "uniform(int) : BAT[oid,int]",										  "not available"																																																																																																							  ]
[ "uniform",		  "PROC:      ",  "uniform(int, int) : BAT[oid,int]",										  "not available"																																																																																																							  ]

Module: "salgebra"

[ 11 ]
[ 11 ]
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
# function			type		signature							help									  # name
# str			str		str								str									  # type
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
[ "CHbat",		  "COMMAND:   ",  "CHbat(clusterhash) : BAT[void,any]",				  "Provides access to the original bat."				  ]
[ "CHdir",		  "PROC:      ",  "CHdir() : void",						  "List the clusterhash dictionary."					  ]
[ "clusterhash",	  "COMMAND:   ",  "clusterhash(BAT[any,any]) : clusterhash",			  "Build a new or get a previously built clusterhash for the input bat."  ]
[ "destroy",		  "COMMAND:   ",  "destroy(str) : void",					  "Destroy the clusterhash with name chname (if possible)."		  ]
[ "info",		  "COMMAND:   ",  "info(clusterhash) : BAT[str,str]",				  "Return some info about the chash."					  ]
[ "rename",		  "COMMAND:   ",  "rename(clusterhash, str) : void",				  "Try to name ch; fail upon error."					  ]
[ "select",		  "PROC:      ",  "select(clusterhash, any::1) : BAT[oid,any::1]",		  "Select using a clusterhash uselect plus a cast."			  ]
[ "test_salgebra",	  "PROC:      ",  "test_salgebra() : void",					  "not available"							  ]
[ "ujoin",		  "COMMAND:   ",  "ujoin(clusterhash, BAT[any,any]) : BAT[oid,void]",		  "Return join(ch, b).mark(nil) with propagated clustering."		  ]
[ "uselect",		  "COMMAND:   ",  "uselect(clusterhash, any) : BAT[oid,void]",			  "Return select(ch, v).mark(nil) with propagated clustering."		  ]
[ "usortedjoin",	  "COMMAND:   ",  "usortedjoin(clusterhash, BAT[any,any]) : BAT[oid,void]",	  "Return join(ch, b).mark(nil).sort with propagated clustering."	  ]

Module: "stats"

[ 5 ]
[ 5 ]
#-------------------------------------------------------------------------------------------------------------------------------------------------#
# function				type		signature						help					  # name
# str				str		str							str					  # type
#-------------------------------------------------------------------------------------------------------------------------------------------------#
[ "[stats_add]",		  "COMMAND:   ",  "[stats_add](ptr, lng) : void",			  "Add a value to a statistics object."	  ]
[ "[stats_del]",		  "COMMAND:   ",  "[stats_del](ptr) : void",				  "Delete a statistics object."		  ]
[ "[stats_histogram_new]",	  "COMMAND:   ",  "[stats_histogram_new](str, int, int, lng) : ptr",	  "Construct a new statistics object."	  ]
[ "[stats_new]",		  "COMMAND:   ",  "[stats_new](str) : ptr",				  "Construct a new statistics object."	  ]
[ "[stats_report]",		  "COMMAND:   ",  "[stats_report](ptr, str) : void",			  "Generate results."			  ]

Module: "streams"

[ 35 ]
[ 35 ]
#-------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
# function			type		signature						help									  # name
# str			str		str							str									  # type
#-------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
[ "block_stream",	  "COMMAND:   ",  "block_stream(Stream) : Stream",			  "open a block based stream"						  ]
[ "bstream_create",	  "COMMAND:   ",  "bstream_create(Stream, int) : Bstream",		  "create a buffered stream"						  ]
[ "bstream_destroy",	  "COMMAND:   ",  "bstream_destroy(Bstream) : void",			  "destroy bstream"							  ]
[ "bstream_read",	  "COMMAND:   ",  "bstream_read(Bstream, int) : int",			  "read atleast size bytes into the buffer of s"			  ]
[ "fclose",		  "PROC:      ",  "fclose(Stream) : void",				  "not available"							  ]
[ "fflush",		  "PROC:      ",  "fflush(Stream) : void",				  "not available"							  ]
[ "fgetc",		  "COMMAND:   ",  "fgetc(Stream) : int",				  "See: man fgetc"							  ]
[ "fgets",		  "COMMAND:   ",  "fgets(Stream) : str",				  "See: man fgets"							  ]
[ "fopen",		  "PROC:      ",  "fopen(str, str) : Stream",				  "not available"							  ]
[ "fprintf",		  "COMMAND:   ",  "fprintf(Stream, str, ..any..) : void",		  "See: man fprintf"							  ]
[ "fputs",		  "PROC:      ",  "fputs(str, Stream) : void",				  "not available"							  ]
[ "ftable",		  "COMMAND:   ",  "ftable(Stream, ..BAT[any::1,any]..) : void",		  "Print an n-ary table to a file."					  ]
[ "ftable",		  "COMMAND:   ",  "ftable(Stream, int, ..BAT[any::1,any]..) : void",	  "Print an n-ary table to a file, using order of BAT [1..argc]."	  ]
[ "fwrite",		  "COMMAND:   ",  "fwrite(Stream, str, int) : void",			  "See: man fwrite"							  ]
[ "open_rastream",	  "COMMAND:   ",  "open_rastream(str) : Stream",			  "open ascii file stream for reading"					  ]
[ "open_rstream",	  "COMMAND:   ",  "open_rstream(str) : Stream",				  "open a file stream for reading"					  ]
[ "open_wastream",	  "COMMAND:   ",  "open_wastream(str) : Stream",			  "open ascii file stream for writing"					  ]
[ "open_wstream",	  "COMMAND:   ",  "open_wstream(str) : Stream",				  "open a file stream for writing"					  ]
[ "socket_rastream",	  "COMMAND:   ",  "socket_rastream(int, str) : Stream",			  "open ascii socket stream for reading"				  ]
[ "socket_rstream",	  "COMMAND:   ",  "socket_rstream(int, str) : Stream",			  "open a socket stream for reading"					  ]
[ "socket_wastream",	  "COMMAND:   ",  "socket_wastream(int, str) : Stream",			  "open ascii socket stream for writing"				  ]
[ "socket_wstream",	  "COMMAND:   ",  "socket_wstream(int, str) : Stream",			  "open a socket stream for writing"					  ]
[ "stderr",		  "COMMAND:   ",  "stderr() : Stream",					  "return the error stream for the database console"			  ]
[ "stdin",		  "COMMAND:   ",  "stdin() : Stream",					  "return the input stream to the database client"			  ]
[ "stdout",		  "COMMAND:   ",  "stdout() : Stream",					  "return the output stream for the database client"			  ]
[ "stream_close",	  "COMMAND:   ",  "stream_close(Stream) : void",			  "close and destroy the stream s"					  ]
[ "stream_flush",	  "COMMAND:   ",  "stream_flush(Stream) : void",			  "flush the stream"							  ]
[ "stream_read",	  "COMMAND:   ",  "stream_read(Stream) : str",				  "read data from the stream"						  ]
[ "stream_readInt",	  "COMMAND:   ",  "stream_readInt(Stream) : int",			  "read an integer from the stream"					  ]
[ "stream_readLng",	  "COMMAND:   ",  "stream_readLng(Stream) : lng",			  "read a long integer from the stream"					  ]
[ "stream_rstream",	  "COMMAND:   ",  "stream_rstream(Stream) : Stream",			  "convert an ascii stream to binary"					  ]
[ "stream_write",	  "COMMAND:   ",  "stream_write(Stream, str) : void",			  "write data on the stream"						  ]
[ "stream_writeInt",	  "COMMAND:   ",  "stream_writeInt(Stream, int) : void",		  "write an integer on the stream"					  ]
[ "stream_writeLng",	  "COMMAND:   ",  "stream_writeLng(Stream, lng) : void",		  "write a long integer on the stream"					  ]
[ "stream_wstream",	  "COMMAND:   ",  "stream_wstream(Stream) : Stream",			  "convert an ascii stream to binary"					  ]

Module: "tcpip"

!WARNING: TCPepilogue: terminate 0 listeners
[ 21 ]
[ 21 ]
#-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
# function		type		signature				help																							  # name
# str		str		str					str																							  # type
#-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
[ "TCPIP_listen", "COMMAND:   ",  "TCPIP_listen() : void",		  "start a TCP/IP server with the default port number."																	  ]
[ "TCPIP_listen", "COMMAND:   ",  "TCPIP_listen(int) : void",		  "start a TCP/IP server"																				  ]
[ "arpc",	  "PROC:      ",  "arpc(..any..) : any",		  "not available"																					  ]
[ "cache",	  "COMMAND:   ",  "cache() : BAT[str,str]",		  "a copy of the list of BATs cached via the network"																	  ]
[ "close",	  "COMMAND:   ",  "close() : void",			  "close all connections"																				  ]
[ "close",	  "COMMAND:   ",  "close(int) : void",			  "close a connection to another TCP/IP server."																	  ]
[ "conns",	  "COMMAND:   ",  "conns() : BAT[int,str]",		  "a BAT with all current connections."																			  ]
[ "export",	  "COMMAND:   ",  "export(int, BAT[any,any]) : void",	  "export a value for transport on a named local TCP/IP server."															  ]
[ "export",	  "COMMAND:   ",  "export(int, any, str) : void",	  "export a value for transport on a named local TCP/IP server."															  ]
[ "flush",	  "COMMAND:   ",  "flush() : void",			  "Empty the TCP/IP cache, and delete all items in it."																	  ]
[ "import",	  "COMMAND:   ",  "import(str) : any",			  "import a value from a TCP/IP server, removing it from the cache."															  ]
[ "import",	  "COMMAND:   ",  "import(str, bit) : any",		  "import a value from a TCP/IP server, possibly removing it from the cache."														  ]
[ "listen",	  "COMMAND:   ",  "listen() : void",			  "start a TCP/IP server with the default port number."																	  ]
[ "listen",	  "COMMAND:   ",  "listen(int) : void",			  "start a TCP/IP server"																				  ]
[ "mil",	  "COMMAND:   ",  "mil(int, str) : void",		  "remote MIL string evaluation. String can be just any legal mil script\n (multiple statements allowed). Does NOT return a result value."						  ]
[ "mil",	  "COMMAND:   ",  "mil(int, str, ..any..) : void",	  "remote MIL evaluation with parameter transport, similary to rpc.\n Does NOT return a result value."											  ]
[ "open",	  "COMMAND:   ",  "open(str) : int",			  "open a connection to another TCP/IP server."																		  ]
[ "rpc",	  "COMMAND:   ",  "rpc(int, str, ..any..) : any",	  "remote MIL evaluation. Each argument that is represented by a %a is\n inserted with succeeding values from the parameter list of the rpc call.\n Returns the remote return value."	  ]
[ "terminate",	  "COMMAND:   ",  "terminate() : void",			  "stop a TCP/IP server"																				  ]
[ "terminate",	  "COMMAND:   ",  "terminate(int) : void",		  "stop a TCP/IP server"																				  ]
[ "waits",	  "COMMAND:   ",  "waits() : BAT[int,int]",		  "a BAT with all current waiting threads."																		  ]

Module: "unix"

[ 2 ]
[ 2 ]
#---------------------------------------------------------------------------------------------------------#
# function		type		signature			help					  # name
# str		str		str				str					  # type
#---------------------------------------------------------------------------------------------------------#
[ "getenv",	  "COMMAND:   ",  "getenv(str) : str",		  "Get the environment variable string."  ]
[ "setenv",	  "COMMAND:   ",  "setenv(str, str) : bit",	  "Set the environment variable string."  ]

Module: "upgrade"

[ 1 ]
[ 1 ]
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
# tmp_35		tmp_36		tmp_37			tmp_40															  # name
# str		str		str			str															  # type
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
[ "convert",	  "COMMAND:   ",  "convert(str) : void",  "convert the bats in the given bat directory (ie please supply the full directory, for example $dbfarm/dbname/bat)"	  ]

Module: "url"

[ 18 ]
[ 18 ]
#---------------------------------------------------------------------------------------------------------------------------------#
# function		type		signature				help							  # name
# str		str		str					str							  # type
#---------------------------------------------------------------------------------------------------------------------------------#
[ "getAnchor",	  "COMMAND:   ",  "getAnchor(url) : str",		  "Extract the anchor (reference) from the URL"		  ]
[ "getBasename",  "COMMAND:   ",  "getBasename(url) : str",		  "Extract the base file name of the URL"		  ]
[ "getContent",	  "COMMAND:   ",  "getContent(url) : str",		  "Get the URL resource in a local file"		  ]
[ "getContext",	  "COMMAND:   ",  "getContext(url) : str",		  "Get the path context of a URL "			  ]
[ "getDirectory", "COMMAND:   ",  "getDirectory(url) : BAT[int,str]",	  "Extract the directory names from the URL"		  ]
[ "getDomain",	  "COMMAND:   ",  "getDomain(url) : str",		  "Extract the Internet domain from the URL"		  ]
[ "getExtension", "COMMAND:   ",  "getExtension(url) : str",		  "Extract the file extension of the URL"		  ]
[ "getFile",	  "COMMAND:   ",  "getFile(url) : str",			  "Extract the last file name of the URL"		  ]
[ "getHost",	  "COMMAND:   ",  "getHost(url) : str",			  "Extract the server identity from the URL"		  ]
[ "getPort",	  "COMMAND:   ",  "getPort(url) : str",			  "Extract the port id from the URL"			  ]
[ "getProtocol",  "COMMAND:   ",  "getProtocol(url) : str",		  "Extract the protocol from the URL"			  ]
[ "getQuery",	  "COMMAND:   ",  "getQuery(url) : str",		  "Extract the query string from the URL"		  ]
[ "getQueryArg",  "COMMAND:   ",  "getQueryArg(url) : BAT[str,str]",	  "Extract the argument mappings from the URL"		  ]
[ "getRobotURL",  "COMMAND:   ",  "getRobotURL(url) : str",		  "Extract the location of the robot control file"	  ]
[ "getUser",	  "COMMAND:   ",  "getUser(url) : str",			  "Extract the user identity from the URL"		  ]
[ "isaURL",	  "COMMAND:   ",  "isaURL(url) : bit",			  "Check conformity of the URL syntax"			  ]
[ "newurl",	  "COMMAND:   ",  "newurl(str, str, int, str) : url",	  "Construct a URL from protocol, host,port,and file"	  ]
[ "newurl",	  "COMMAND:   ",  "newurl(str, str, str) : url",	  "Construct a URL from protocol, host,and file"	  ]

Module: "xtables"

[ 22 ]
[ 22 ]
#-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
# function			type		signature									help																																						  # name
# str			str		str										str																																						  # type
#-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
[ "CTderive",		  "COMMAND:   ",  "CTderive(BAT[oid,any], BAT[oid,any]) : grp",					  "Cross tabulation group extension step.\nReturned head values are identical as in 'ct'. Tail values are from\nthe same domain and indicate further refinement of the groups in 'ct',\ntaking into account also the tail-values in 'attr'."						  ]
[ "CTextend",		  "COMMAND:   ",  "CTextend(grp) : BAT[oid,any]",						  "Return the group extend."																																  ]
[ "CTgroup",		  "COMMAND:   ",  "CTgroup(BAT[oid,any]) : grp",						  "Cross tabulation group initialization.\nReturned head values are identical as in 'attr'. Tail values are from\nthe same domain and indicate unique groups in 'attr' tail column."													  ]
[ "CTgroup",		  "COMMAND:   ",  "CTgroup(BAT[oid,any], BAT[oid,any]) : grp",					  "binary grouping; a synonym for CTderive(ct,attr)"																													  ]
[ "CThistogram",	  "COMMAND:   ",  "CThistogram(grp) : BAT[any,int]",						  "Return the groups histogram."																															  ]
[ "CThistosum",		  "COMMAND:   ",  "CThistosum(BAT[oid,oid], BAT[oid,int]) : BAT[oid,int]",			  "Produce sum over old histogram table"																																	  ]
[ "CTmap",		  "COMMAND:   ",  "CTmap(grp) : BAT[oid,oid]",							  "Return the group map."																																  ]
[ "CTorderby",		  "PROC:      ",  "CTorderby(BAT[oid,any], BAT[oid,any]) : BAT[oid,oid]",			  "not available"																																				  ]
[ "CTorderby_rev",	  "PROC:      ",  "CTorderby_rev(BAT[oid,any], BAT[oid,any]) : BAT[oid,oid]",			  "not available"																																				  ]
[ "CTrefine",		  "COMMAND:   ",  "CTrefine(BAT[oid,any], BAT[oid,any]) : BAT[oid,oid]",			  "refine the ordering of a tail-ordered BAT by sub-ordering on the\nvalues of a second bat 'a' (where the heads of a and b match 1-1).\nThe effect of this is similar to (hash-based) CTderive, with the\ndistinction that the group ids respect the ordering of the group values."	  ]
[ "CTrefine_rev",	  "COMMAND:   ",  "CTrefine_rev(BAT[oid,any], BAT[oid,any]) : BAT[oid,oid]",			  "reverse sorting version of CTrefine"																																		  ]
[ "CTsubgroup",		  "PROC:      ",  "CTsubgroup(BAT[oid,oid], BAT[oid,any], BAT[oid,any]) : BAT[oid,oid]",	  "not available"																																				  ]
[ "CTsubhisto",		  "COMMAND:   ",  "CTsubhisto(BAT[void,bit], BAT[void,oid], BAT[oid,any]) : BAT[oid,int]",	  "optimized sub-histogram for synced grp[void,oid] and sel[void,bit]\nbats on a previously known domain "																								  ]
[ "_CTgroup",		  "COMMAND:   ",  "_CTgroup(BAT[oid,any], int, int) : grp",					  "Cross tabulation group initialization like CTgroup, but with user\nprovided #bits in hashmask and #distinct values in range."																			  ]
[ "extend",		  "PROC:      ",  "extend(grp) : BAT[any,int]",							  "not available"																																	  ]
[ "histogram",		  "PROC:      ",  "histogram(grp) : BAT[any,int]",						  "not available"																																	  ]
[ "map",		  "PROC:      ",  "map(grp) : BAT[oid,oid]",							  "not available"																																	  ]
[ "orderby_table",	  "PROC:      ",  "orderby_table(str, str, ..BAT[any::1,any]..) : void",			  "not available"																																				  ]
[ "print",		  "PROC:      ",  "print(str, BAT[any::1,any], ..BAT[any::1,any]..) : void",			  "not available"																																				  ]
[ "table",		  "PROC:      ",  "table(str, BAT[any::1,any], ..BAT[any::1,any]..) : void",			  "not available"																																				  ]
[ "{count}",		  "PROC:      ",  "{count}(BAT[oid,bit], BAT[oid,oid], BAT[oid,int]) : BAT[oid,int]",		  "not available"																																				  ]
[ "{count}",		  "PROC:      ",  "{count}(BAT[void,bit], BAT[void,oid], BAT[oid,int]) : BAT[oid,int]",		  "not available"																																				  ]

quit();

# 18:28:13 >  
# 18:28:13 >  Done.
# 18:28:13 >  

