@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2007 CWI.
@' All Rights Reserved.

@t An overview of the Monet Database System
@v version 4.3 
@a Peter Boncz, Martin Kersten, Niels Nes, Stefan Manegold
@d 1/10/2002
@* Introduction
@T
This document is an introduction to get you up and running with @[<a href="http://monetdb.cwi.nl">MonetDB</a>@, 
a novel database system under development since 1993 by the 
@[<a href="http://db.cwi.nl/projecten/thema.php4?themanr=5">CWI database research group</a>@.\\ 

Before reading this, download MonetDB from
@[<a href="http://sourceforge.net/projects/monetdb/">SourceForge</a>@
and compile it, following the instructions in the file HowToStart
(Unix/Linux and MacOS X) or HowToStart-win32.txt (Windows). \\

After reading this document,
the next step to take is to study the @[<a href="../mil/index.html"><acronym title="MonetDB Interpreter Language">MIL</acronym> Reference Manual</a>@.

@+ Background
@T
MonetDB builds on previous experiments in database architecture, which go 
back to the early eighties, when the {\bf Troll} database kernel was developed at the Vrije Universiteit,
Amsterdam by M.L. Kersten, and subsequently commercially distributed.  Troll was a typical first-generation 
relational algebra engine, with an emphasis on algorithms, a simple textual algebraic interface, and 
limited optimizer functionality. \\

A second architecture was developed between 1985 and 1992 
as a co-production between the database research group of CWI and the University of Twente
in the context of the @[<a href="http://wwwhome.cs.utwente.nl/~annita/prisma.html">PRISMA</a>@ project. 
In this project, the consequences of a highly parallel platform (100 cpus) and a 
large main-memory (in the GBs) on the architecture of an SQL-compliant database engine were researched.  A complete 
functional system was delivered in the early 1990s and subsequently abandoned, primarily due to 
the limitations imposed upon the portability of the system by its proprietary implementation 
language POOL and the refocusing of Philips Research on the core business of Philips.

@- MonetDB
@T
The MonetDB project started out as a serious attempt to build a complete database kernel that fully exploits the 
power of modern hardware on heavy analysis ("query-intensive") applications.
An initial version of MonetDB, called Monet, was designed and implemented by Kersten and gradually taken over by Boncz as 
part of his Ph.D. research track. Over its eight years of development many other people have contributed to 
its development as implementors of missing functionality or application developers.  \\

The MonetDB system is used as a data management engine by CWI data mining spin-off 
@[<a href="http://www.datadistilleries.com">Data Distilleries B.V.</a>@,  
and as such continues to be deployed at the marketing departments of (mostly) 
large financial institutions (like @[<a href="http://www.abnamro.com">ABN Amro</a>@,
@[<a href="http://www.postbank.nl">ING Postbank</a>@, @[<a href="http://www.aegon.nl">Aegon</a>@,
@[<a href="http://www.vodafone.nl">Vodafone</a>@, @[<a href="http://www.centerparcs.nl">Center Parcs</a>@,
@[<a href="http://www.ohra.nl">OHRA</a>@, @[<a href="http://www.imponline.com">IMP</a>@). 
Its deployment in commercial environments has greatly improved the stability of the MonetDB code, 
but also meant that in the first years its distribution was restricted. \\

After the restrictions on its distribution were lifted, the MonetDB source was transferred to 
@[<a href="http://sourceforge.net/projects/monetdb/">SourceForge</a>@, where it is now available for all 
and managed by a small core team of developers at the @[<a href="http://monetdb.cwi.nl/">CWI</a>@. Quality 
control of the source is performed at CWI where a nightly build and testing environment tests the main code 
branches on a farm of different hardware/OS/compiler combinations.

@- Technical Highlights
@T
As for its technical novelty, MonetDB uses full {\bf vertical fragmentation}
in order to better accommodate {\bf query-intensive access patterns}, both in terms of {\bf I/O optimization}
and for improving the access to the {\bf CPU caches}.  \\

MonetDB also uses a column-wise query-processing algebra that has zero degrees of freedom, which makes it
possible to use a generic but {\bf pre-compiled query engine}, as opposed to the interpretative
techniques used in other DBMSs.  Compile-time fixed query processing primitives are crucial for modern CPUs
like the Pentium 4, which need highly predictable code in order to avoid branch mispredictions,
as well as an ever present pool of independent instructions (in order to fill its parallel units
and obtain a good Instructions-Per-Cycle ratio). Note that compile-time here means {\em DBMS build time},
and not {\em query-compilation-time}, which is a run-time activity. \\

Another MonetDB design goal was extensibility: by constructing MonetDB as a {\bf back-end}, on top of
which multiple {\bf front-end} systems can work and interact with the storage/query
on a lower level than, say, SQL, allows re-use of the same system in multiple application domains, also
one of MonetDB's design goals.  \\

MonetDB has been applied successfully to
@[<a href="http://www.cwi.nl/htbin/ins1/publications?request=abstract&key=BoWiKe:ICDE:98"><acronym title="On-Line Analytical Processing">OLAP</acronym></a>@,
@[<a href="http://www.cwi.nl/htbin/ins1/publications?request=abstract&key=BoRuKw:VLDB:98">data mining</a>@,
@[<a href="http://www.cwi.nl/htbin/ins1/publications?request=abstract&key=BoQuKe:EDBT:96"><acronym title="Geographic Information System">GIS</acronym></a>@,
@[<a href="http://www.cwi.nl/htbin/ins1/publications/?request=abstract&key=VrMaNeKe:SIGMOD:02">k-NN search</a>@,
@[<a href="http://www.cwi.nl/htbin/ins1/publications?request=abstract&key=ScKeWi:ICDE:01"><acronym title="eXtensible Markup Language">XML</acronym></a>@-,
@[<a href="http://www.cwi.nl/htbin/ins1/publications?request=abstract&key=NeKe:BNCOD:98">image</a>@- and
@[<a href="http://citeseer.nj.nec.com/501825.html">video</a>@-databases.\\

\begin{center}
{\epsfxsize=0.55\textwidth
\epsffile{monet.feps}
\label{fig1}{\em Front-end/Back-end Architecture}}\\
@-
@T
A full reference of the MonetDB system covering motivation, basic principles, and detailed technical architecture 
can be found in the @[<a href="http://www.cwi.nl/htbin/ins1/publications?request=abstract&key=Bo:DISS:02">Ph.D thesis</a>@
of Boncz.
@-
@T
The remainder of this document provides a synopsis of the discriminative
features of MonetDB,  installation information, and a short tutorial to get
a flavor of using it.

@* MonetDB Features 
@T
MonetDB is database engine geared at high performance on systems with (complex) queries that have
to analyze large amounts of data (i.e. @[<acronym title="On-Line Analytical Processing">OLAP</acronym>@, {\bf not} @[<acronym title="On-Line Transaction Processing">OLTP</acronym>@). The features in which it most
differs from other DBMSs are summarized below:

\begin{itemize} 
\item {\em Independence of SQL:} \\

MonetDB has a front-end/back-end design
allowing the storage of more than just relational tables (such as object-oriented
or native @[<acronym title="eXtensible Markup Language">XML</acronym>@ data), and allowing the use of querying paradigms other than just SQL
(such as OQL and XQuery). 

In this architecture, MonetDB is the {\bf back-end}, which is accessed by multiple 
{\bf front-ends} such as an SQL front end, an @[<acronym title="eXtensible Markup Language">XML</acronym>@ front end or even a Data 
Mining tool).  The intermediate language with which these components talk to each 
other is called the @[<a href="../mil/index.html">MonetDB Interpreter Language</a>@ (MIL).

Currently, there are two front-ends freely available: the @[<a
href="http://monetdb.cwi.nl/SQL/index.html">SQL front end</a>@ and the @[<a
href="http://monetdb.cwi.nl/XQuery/index.html">XQuery front end</a>@. For the @[<acronym title="Object Database
Management Group">ODMG</acronym>@  front-end, there are no release plans, as it is owned by  @[<a
href="http://www.datadistilleries.com">Data Distilleries</a>@.
\\

\item {\em Binary Relational Data Storage:}\\

The MonetDB database system is the first kernel relying fully on binary (i.e. 2-column) relational 
tables, called Binary Association Tables (BATs), as the prime storage scheme for relational and object-oriented data models. The most common case
of using these binary tables is to put database values in the right column and system
generated object-identifiers (OIDs) in the left. MonetDB adds special support for densely
ascending OIDs (e.g. 0,1,2,..) in the form of virtual-OIDs (VOIDs), so at the physical level
MonetDB's binary tables are almost always unary tables, implemented as arrays, such that 
lookup-by-OID is as simple/cheap as indexing an array.

The first benefit of the forced decomposition of data structures in binary tables is that
the resulting physical vertical fragmentation is beneficial for the I/O and CPU cache
access cost for queries that scan through large volumes of data, but do not look at all
columns (at the same time). In other words, vertical fragmentation avoids touching
data that you do not want to see anyway, which translates into a more optimal use of
both I/O-memory and memory-cache bandwidths. The second advantage of the binary storage
model is that it allows for column-wise query processing, whose benefits are explained below.
\\

\item {\em BAT Algebra: the RISC approach to Query Languages}\\

The main component of MonetDB's query language, called MIL (MonetDB Interpreter Language),
is a BAT algebra. The BAT algebra processes queries column-at-a-time where each operator typically has
a simple built-in semantic and is not steered by any complex parameters (such as
expressions).  As each such individual operator typically processes 1 or 2 columns, its
only degree of freedom are the column types, which is handled in MonetDB by pre-compiling
a separate implementation for each type-combination. Thus, at database compile-time,
operators have full knowledge of their data processing task, thus giving current
compiler technology a chance to generate object code that is efficient on modern 
hardware (i.e. by avoiding the many hard-to-predict branches caused by interpretative 
code and type-checking, and producing inner-loops of algorithms that easily provide enough
independent instructions to keep the parallel CPU resources busy and reach a high instruction-per-cycle ratio).

Summarizing, by reducing the complexity of its query algebra to the minimum, MonetDB 
allows for a much more efficient implementation. This is similar to the @[<acronym title="Reduced Instruction Set Computer">RISC</acronym>@-@[<acronym title="Complex Instruction Set Computer">RISC</acronym>@ 
argument in CPU architecture.
\\

\item {\em Cache-Conscious Algorithms}\\

While most hardware components have experienced exponential growth in power over the years 
(a.k.a. Moore's law), I/O and, especially, memory latency have been lagging, creating an 
exponentially growing {\em memory bottleneck}. This means that, in order to achieve efficiency,
database query processing algorithms must have either sequential access (in which
case current machines provide high-bandwidth access to DRAM using hardware prefetching)
or, if the access pattern is random, then the total volume of cache-lines touched must be 
significantly smaller than the cache size. Depending on the architecture, the most 
performance-significant cache is either L1 or L2, and, even in the latter cache, this
yields a randomly accessible memory of at most some megabytes. This is a much smaller 
size than a "common" DBMS aims for (as these typically only address the I/O bottleneck).  
A second difference with I/O caching is that the CPU-cache is not fully associative and 
cannot be programmed, as cache-replacement happens automatically in hardware with (typically)
an @[<acronym title="Least Recently Used">LRU</acronym>@ algorithm.

In the @[<a href="../Modules/radix/index.html">radix</a>@ module, you will find the basic radix-cluster and 
radix-decluster operations for generic cache-conscious query processing in MonetDB. Also packaged
with MonetDB is a @[<a href="../Modules/calib/index.html">calibrator module</a>@ that automatically extracts all
relevant hardware characteristics, making cache-conscious query processing
work on any platform and configuration. 
\\

\item {\em Main-Memory Orientation:}\\

Given the sizable memories available in current computer platforms, the focus on gaining performance 
in a database setting is shifting to in-memory processing. As discussed above, hardware changes  
are making memory access a major battleground for query optimization, justifying MonetDB's focus
on the issue. Notice that a focus on main-memory does not mean that MonetDB
requires all your data to fit into RAM. MonetDB stores all persistent data on disk and only loads
the data that is needed into memory. Due to the column-wise query processing, only a few columns 
of all tables need to be in memory at any given time. Also, by memory-mapping files into virtual
memory, the amount of open data can easily exceed the amount of RAM. It depends on your access
pattern whether you will be able to avoid excessive I/O swapping. Notice that once your algorithms
are optimized to work well in the L2 cache as discussed above, they will certainly run well in
virtual memory, as random access should be localized to a small region, and all other access is 
sequential.

MonetDB can be compiled both on 32-bit and 64-bit systems. The former systems impose a limit on 
all open data of 2GB or 3GB. In 64-bit systems there is no restriction, though the size of each
individual column is currently limited to 2GB. In a future version of MonetDB, this restriction will 
be lifted.
\\

\item {\em Cooperative Transaction Management:}\\

Transaction processing is not buried deeply inside the kernel code where all users of the database 
have to pay the performance price. Instead, MonetDB assumes a cooperative environment, where the 
compilers/interpreters produce calls to the basic transaction management primitives
provided by @[<acronym title="MonetDB Interpreter Language">MIL</acronym>@. As such, we have the situation that @[<acronym title="MonetDB Interpreter Language">MIL</acronym>@ does not guarantee @[<acronym title="Atomicity, Consistency, Isolation, and Durability">ACID</acronym>@
properties, but it provides the basic building blocks to do so.

The advantage of this design is that query-intensive applications, like data mining and @[<acronym title="On-Line Analytical Processing">OLAP</acronym>@,
that do not do updates, or only periodic bulk updates, can improve their performance considerably. 
Furthermore, the disentanglement of transaction processing and query execution simplifies the code
and makes it possible to use different transaction managers in different situations.

In the case of the SQL front-end, we use a transaction manager based on write-ahead-logging (WAL)
in conjunction with virtual memory support, that minimizes resource overhead using copy-on-write
sharing of relation images.
\\

\item {\em Portability, Extensibility, and Documentation:}\\

MonetDB is a multi-threaded 32/64 bits executable that builds on the POSIX standard (among others, pthreads).
A minimal compatibility layer was added to allow it to work on native Windows compilers (though
building on Cygwin is also possible). A 64-bit version on Windows (Itanium) is under development. 
Most of the code is ANSI C, though some modules are still C++. 

The code is configured with the standard GNU tools (autoconf, automake, configure) such that
in principle building on any Posix platform should be as simple as {\tt ./bootstrap; ./configure; make all install}. 
As Microsoft Windows lacks configure, the MonetDB distribution comes with a pre-built Windows
{\tt monetdb\_config.h}, so that making becomes {\tt cd NT; make; make -f Makefile.msc all install}. 
More details and requirements are explained in the file @[<a href="../Installation/MonetDB/Unix/index.html">HowToStart</a>@ (for Unix and MacOS X users)
and @[<a href="../Installation/MonetDB/Windows/index.html">HowToStart-Win32.txt</a>@ (for Windows users).
Both files are located in the root of the source distribution.

MonetDB is an open database system that can be extended with new {\bf types} (e.g. point,polygons)
new {\bf operators} (e.g. spatial join) and new {\bf search accelerators} (e.g. R-trees)
bundled in {\bf modules}.  An extension module consists of a @[<a href="../mel/index.html">MEL</a>@ 
(MonetDB Extension Language) specification and a C or C++ implementation, provided by the programmer.
The @[<a href="../mel/mel-tool/index.html">mel</a>@ tool generates code for registering the new @[<acronym title="MonetDB Interpreter Language">MIL</acronym>@ atoms, accelerators 
and operators in the database plus some glue code.  The make system is designed to do all necessary 
work automatically for you, provided you write your extension module in the 
@[<a href="http://www.cwi.nl/htbin/ins1/publications?request=pdf&key=KeScBeBo:UNPUBLISHED:96">Mx</a>@
format and put it in the right directory (e.g. {\tt src/modules/contrib/}).

The MonetDB code is written using the {\tt @[<a href="http://www.cwi.nl/htbin/ins1/publications?request=pdf&key=KeScBeBo:UNPUBLISHED:96">Mx</a>@}
utility, which follows Knuth's suggestion for literate programming. Mx supports integration of source code and documentation
in a simple textual style, and document extraction in various formats (TeX/html) at 
configurable levels of detail (the "hide levels"). It also provides powerful
macro-expansion facilities, which are heavily used to encode query processing algorithms 
regardless of data type, thus providing a more flexible and powerful form of C++-templates in C.
\\

\item {\em Supported APIs:}\\

The @[<a href="../Modules/mapi/index.html">MonetDB-API</a>@ is the generic textual API for database
applications that use @[<acronym title="MonetDB Interpreter Language">MIL</acronym>@ to access MonetDB directly. It consists of a basic @[<a href="../APIs/Mapi/C/index.html">C-library</a>@ that can 
be linked with C/C++ programs and comes with wrappers for use in Java, Python, Perl, PHP and 
Haskell programs.

It should be noted that there is an alternative MonetDB API in the form of the 
@[<a href="../Modules/tcpip/index.html">tcpip</a>@ module that implement a protocol that allows 
transporting binary images of BATs to clients. This module is also a basic building
block for applications that use a shared-nothing architecture where multiple
MonetDB servers work together on different machines.

Finally, the SQL front-end also comes with an @[<acronym title="Open Database Connectivity">ODBC</acronym>@ driver implementation. The SQL supported
by the front-end is a (strong) subset of the SQL-2 standard. The @[<acronym title="Open Database Connectivity">ODBC</acronym>@ interface complies with 
ODBC3.0 and is available both on Unix and Windows.
\end{itemize}

@* Using MonetDB 

As stated before, we assume here you have successfully built and installed MonetDB according
to the documentation in the file @[<a href="../Installation/MonetDB/Unix/index.html">HowToStart</a>@ resp. 
@[<a href="../Installation/MonetDB/Windows/index.html">HowToStart-Win32.txt</a>@.

@+ System Utilities
@T
The MonetDB system consists of the following utilities:
\begin{description}
\item[@[<a href="../Tools/Mserver/index.html">Mserver</a>@]
	to start a MonetDB server instance.
\item[@[<a href="../Tools/MapiClient/index.html">MapiClient</a>@]
	to establish a client-session with command-line history.
\item[@[<a href="../mel/mel-tool/index.html">mel</a>@]
	to parse MonetDB extension module specifications and generate wrapper and header code.
@'\item[@[<a href="">sql</a>@]
@'	to compile SQL programs into @[<acronym title="MonetDB Interpreter Language">MIL</acronym>@.
\end{description}

@- Environment Variables
@T
There are no MonetDB-specific environment variables (any more).  The variables you want to 
set only have to do with being able to conveniently start the MonetDB server.\\

After a successful {\tt make install}, the  MonetDB binaries are located in the {\tt bin/} 
subdirectory of your installation directory. Unless you are system administrator
and installed in the (default) {\tt /usr/local}, you may find it
convenient to add this {\tt bin/} directory to your {\tt PATH} 
environment variable.\\

If you compiled with dynamic libraries (which is default - but static compilation 
is also possible), the MonetDB server, @[<a href="../Tools/Mserver/index.html">Mserver</a>@, depends on a number 
of {\small .so} libraries that need to be found. Therefore, you might need to add
the {\tt lib(64)/} directory to your {\tt LD\_LIBRARY\_PATH}.\\

However, in (the most common) case you compiled MonetDB yourself, you actually do not 
have to set the library path, as during compilation the prefixed path is compiled
into the executables as the first place to check for libraries.\\ 

Notice that some systems would need other environment variables than {\tt LD\_LIBRARY\_PATH}:
\begin{itemize}
\item Windows requires you to put the location of the {\tt .dll} (not {\tt .so}) 
libraries in the {\tt PATH}.
\item AIX uses {\tt LIBPATH} instead of {\tt LD\_LIBRARY\_PATH}
\item the 64-bit environment on IRIX uses {\tt LD\_LIBRARYN64\_PATH}.
\end{itemize}

@+ MonetDB.conf
@T
MonetDB is configured by a configuration file named {\tt MonetDB.conf}, whose location FILEPATH
can be specified explicitly on the command line with {\tt -c FILEPATH} or {\tt -$$-config FILEPATH},
or via the environment variable \$MONETDB\_CONFIG.
If this is not done explicitly, MonetDB looks for a {\tt MonetDB.conf} in the standard system configuration
directory, i.e., {\tt \<prefix\>/etc/MonetDB.conf}.\\

If you are new to using MonetDB, you may start with the {\tt \<prefix\>/etc/MonetDB.conf} that
is generated by the {\tt make}, and already contains your compilation
and installation paths. In case you need/want to change the default settings,
copy it to some place in your home directory, edit it there, and use the {\tt -c}/{\tt -$$-config}
option of Mserver to use your personalized copy of {\tt MonetDB.conf} instead of the default one.\\

In the following, we discuss the file format of {\tt MonetDB.conf} in detail.

@- Server Settings
@T
The below displays the most important settings for the MonetDB server (@[<a href="../Tools/Mserver/index.html">Mserver</a>@). \\ 

Notice that all settings in the configuration file can be overridden on the command-line
of @[<a href="../Tools/Mserver/index.html">Mserver</a>@ with the option {\tt -s option=value} or {\tt -$$-set option=value}.
\begin{verbatim}
prefix=/usr/local
exec_prefix=${prefix}
gdk_dbfarm=${prefix}/var/dbfarm	# origin of the database store
gdk_dbname=demo			# default database to open
gdk_mmap=33554432		# memory chunks of size >= 32M will be mmaped
gdk_debug=0			# debug
monet_prompt=>			# prompt 
monet_welcome=yes		# Version and copyright information
monet_mod_path=${exec_prefix}/lib(64)/MonetDB:${exec_prefix}/lib(64)/MonetDB/lib
monet_deamon=no			# if yes, there is no interactive server console
\end{verbatim}

Most commonly, you would set {\tt prefix} to your installation directory,
and {\tt gdk\_dbname} to your most commonly used database instance. This will 
basically enable you to start @[<a href="../Tools/Mserver/index.html">Mserver</a>@ without any command-line parameters.\\

If {\tt prefix} is set correctly, you will, in general, not need to adapt 
{\tt exec\_prefix} and {\tt monet\_mod\_path} (where MonetDB looks for {\tt lib(64)/}
directories with extension modules) anymore.\\

The {\tt gdk\_dbfarm} variable holds the directory in which one or more database
instances can have their data. That is, each database is a subdirectory of the
dbfarm. The name of the database is the name of the subdirectory. Creating
and removing a database is as simple as creating/removing a directory in the
file system, with any utility you like. The {\tt -$$-dbfarm PATH} option of @[<a href="../Tools/Mserver/index.html">Mserver</a>@,
which expects an {\bf absolute} path {\tt PATH}, overrides the 
{\tt gdk\_dbfarm} option from the configuration file. \\

One limitation of this setup is that it currently is not possible to use disk space
on multiple physical disks in one MonetDB database. The only workarounds to do this is
to either use RAID (be it hardware or software) to unite multiple disks into
one file system, or to use a file system that explicitly allows multiple physical disks
(like the AIX file system).\\ 

The {\tt gdk\_debug} and {\tt gdk\_mmap} options are for expert users only.
Setting the former gives extensive trace output during @[<acronym title="MonetDB Interpreter Language">MIL</acronym>@ execution, whereas the latter
controls where bulk memory is allocated from (malloc or virtual memory).\\

Finally, if you do not access @[<a href="../Tools/Mserver/index.html">Mserver</a>@ interactively or only via the
@[<a href="../Tools/MapiClient/index.html">MapiClient</a>@, you might want to start @[<a href="../Tools/Mserver/index.html">Mserver</a>@ as a background daemon,
which means that it will not start a @[<acronym title="MonetDB Interpreter Language">MIL</acronym>@ interpreter thread that reads
from {\tt stdin} and outputs to {\tt stdout} and {\tt stderr}.

@- MapiClient Settings
@T
\begin{verbatim}
host=localhost			# the host the server runs on
mapi_port=50000			# default port to address a Mserver
mapi_noheaders=no		# show all the mil output
mapi_debug=0			# The mapi debug level		
\end{verbatim}

The MapiClient tool allows you (and multiple concurrent clients) to 
access an Mserver with @[<acronym title="MonetDB Interpreter Language">MIL</acronym>@, as opposed to the default interpreter that 
Mserver starts on {\tt stdin}/{\tt stdout}/{\tt stderr}. 
MapiClient is slightly more
comfortable to work with, as it provides command-line editing and history.\\

Notice that you can only use MapiClient to connect to an 
Mserver if the server
has loaded the @[<a href="../Modules/mapi/index.html">mapi</a>@ module and issued a {\tt listen()} command. An example
of how this works will be given below in the interactive @[<acronym title="MonetDB Interpreter Language">MIL</acronym>@ session.\\

Suffice it to say now that MapiClient needs to know the machine name and 
TCP port where an Mserver is listening. These options can be given to
MapiClient with the {\tt -h HOSTNAME} / {\tt -$$-host HOSTNAME} and 
{\tt -p PORTNO} / {\tt -$$-port PORTNO} command line options. Default values
can be put in your MonetDB configuration file, such that you will
be able to start MapiClient without command-line parameters.

@- SQL Front End Settings
@T
\begin{verbatim}
sql_debug=0			#default debug setting for the SQL frontend
\end{verbatim}
It is urgently needed to document everything that has to do with the SQL frontend.

@- XQuery Front End Settings
@T
\begin{verbatim}

#output mode "dm" = pretty printed,
#            "xml" = enforce XML with enclosing <XQueryResult> tags
xquery_output=dm

#limit the document cache on disk to 100MB
xquery_cacheMB=100
\end{verbatim}

@+ Usage Scenario 
@T
In this scenario, we use the 'gold' example of data mining/@[<acronym title="On-Line Analytical Processing">OLAP</acronym>@ access to a car
insurance database which you can find in the {\tt scripts/gold/} subdirectory of 
the MonetDB distribution.  Please consult the README file there for all the details.\\

Go to the top-level source directory and do the following (where \$PREFIX is the 
directory where you successfully performed a {\tt make install}).

\begin{verbatim}
$ cd scripts/gold
$ mkdir -p $PREFIX/var/dbfarm/gold
$ export TSTTRGDIR=`pwd`
$ Mserver --dbname=gold < load.mil
$ Mserver --dbname=gold < init.mil
\end{verbatim}

The {\tt load.mil} and {\tt init.mil} are @[<acronym title="MonetDB Interpreter Language">MIL</acronym>@ scripts that create database tables and fill
them, using the @[<a href="../Modules/ascii_io/index.html">bulk loader</a>@.\\

We then start a MonetDB server on the newly created 'gold' database:

\begin{verbatim}
$ Mserver --dbname gold  
# Monet Database Server V4.4.0
# Copyright (c) 1993-2007, CWI. All rights reserved.
# Compiled for i686-redhat-linux-gnu/32bit; dynamically linked.
# Visit http://monetdb.cwi.nl/ for further information.
MonetDB>
\end{verbatim}

MonetDB answers with a prompt, waiting for @[<acronym title="MonetDB Interpreter Language">MIL</acronym>@ commands.\\

We now load the modules {\tt @[<a href="../Modules/mapi/index.html">mapi</a>@} (client @[<acronym title="MonetDB Interpreter Language">MIL</acronym>@ access) and {\tt @[<a href="../Modules/xtables/index.html">xtables</a>@}
(for cross-tabulation):

\begin{verbatim}
MonetDB>module(xtables);
MonetDB>module(mapi); 
MonetDB>mil_start();
\end{verbatim}

The {\tt @[<a href="../Modules/mapi/index.html">mil_start()</a>@} mil proc from the {\tt @[<a href="../Modules/mapi/index.html">mapi</a>@} module registers the mil frontend. The server is now ready to accept clients using the mil language.

We now open a new window and start the @[<a href="../Tools/MapiClient/index.html">MapiClient</a>@, telling it to connect
to the same port number we passed to {\tt @[<a href="../Modules/mapi/index.html">listen()</a>@} on the local machine. This
will establish a @[<acronym title="MonetDB Interpreter Language">MIL</acronym>@ session with the MonetDB server, so we get a prompt:

@[<a name="ls"></a>@;
\begin{verbatim}
$ MapiClient --host localhost --port 50000
# Monet Database Server V4.4.0
# Copyright (c) 1993-2007, CWI. All rights reserved.
# Compiled for i686-redhat-linux-gnu/32bit; dynamically linked.
# Visit http://monetdb.cwi.nl/ for further information.
mil>ls();
#---------------------------------------------------------------------------------------------------------#
# name          htype   ttype   count   heat    dirty           status  kind   refcnt   lrefcnt           # name
# str           str     str     lng     int     str             str     str    int      int               # type
#---------------------------------------------------------------------------------------------------------#
[ "car_age",      "void", "int",  100000, 0,      "clean",        "disk", "pers", 0,      1               ]
[ "car_carprice", "void", "int",  100000, 0,      "clean",        "disk", "pers", 0,      1               ]
[ "car_category", "void", "str",  100000, 0,      "clean",        "disk", "pers", 0,      1               ]
[ "car_class",    "void", "str",  100000, 0,      "clean",        "disk", "pers", 0,      1               ]
[ "car_gender",   "void", "chr",  100000, 0,      "clean",        "disk", "pers", 0,      1               ]
[ "car_neg",      "void", "str",  50000,  0,      "clean",        "disk", "pers", 0,      1               ]
[ "car_pos",      "void", "str",  50000,  0,      "clean",        "disk", "pers", 0,      1               ]
[ "car_town",     "void", "str",  100000, 0,      "clean",        "disk", "pers", 0,      1               ]
mil>
\end{verbatim}
A common command is {\tt @[<a href="../Modules/sys/index.html#mod_2_1_0">ls()</a>@} which lists all persistent BATs. You can pass a 
string parameter that restricts the list to BATs whose names start with that string (so, {\tt ls("car");} would
have given the same result in the example of the car insurance example database). 
There is also a similar command {\tt  @[<a href="../Modules/sys/index.html#mod_2_1_0">dir()</a>@} which lists {\em all} BATs instead 
of only the persistent ones.\\ 

The {\tt ls();} showed that the car insurance table consists of 7 attributes ({\tt age}, {\tt carprice}, {\tt category},
{\tt class}, {\tt gender}, and {\tt town}) that have been vertically fragmented in 7 persistent ({\tt "pers"}) BATs of 
type {\tt BAT[oid,any]}, which all have 100,000 elements, are clean (have not been updated), and none of which 
are loaded into memory. Additionally, there are sub-bats {\tt car_pos} and {\tt car_neg} that hold materialized results
of selections on the {\tt car_class} BAT for those customers that have resp. have not caused accidents, which is a 50-50 split
in this case.

Now for some querying:
\begin{verbatim}
mil>bat("car_town").histogram().print();
#-------------------------#
# h             tmp_46    # name
# str           int       # type
#-------------------------#
[ "atlanta",      9946    ]
[ "boston",       9965    ]
[ "dallas",       10071   ]
[ "detroit",      9943    ]
[ "houston",      9951    ]
[ "los angeles",  9962    ]
[ "miami",        10010   ]
[ "new york",     9990    ]
[ "san diego",    10098   ]
[ "washington",   10064   ]
mil>help("histogram");
COMMAND:   histogram(BAT[oid,any::1]) : BAT[any::1,int]
MODULE:    xtables
COMPILED:  by adm on Tue Sep 28 13:49:07 2004
compute a histogram on the tail. Optimized for retrieving the
         already present histogram on a cross-table computed by CTgroup.
 
COMMAND:   histogram(BAT[any,any::2]) : BAT[any::2,int]
MODULE:    algebra
COMPILED:  by adm on Tue Sep 28 13:49:07 2004
Produce a BAT containing the histogram of the tail values.
 bat.histogram() ::= {count}(bat.reverse)
 
mil>
\end{verbatim}
The above shows a histogram on the town where the car owners live, together with  the on-line
help on the histogram command. 

A more difficult query would ask for the counts of all car owners in Boston grouped by class
and category (in SQL: {\tt select count(*) from car where town = 'boston' group by class, category}):

\begin{verbatim}
mil>print(bat("car_class"),bat("car_category"),bat("car_town").uselect("boston").mirror().join(bat("car_class")).CTgroup(bat("car_category")).map().reverse().{count}());
#---------------------------------------------------------#
# h             car_class       car_category    tmp_57    # name
# void          str             str             int       # type
#---------------------------------------------------------#
[ 5@0,            "damage",       "nolease",      3875    ]
[ 67@0,           "damage",       "lease",        1114    ]
[ 50003@0,        "no damage",    "lease",        995     ]
[ 50025@0,        "no damage",    "nolease",      3981    ]
mil>
\end{verbatim}

In order to understand what this does, you are advised to read the 
@[<a href="../mil/index.html"><acronym title="MonetDB Interpreter Language">MIL</acronym> Reference Manual</a>@ first, and to study
the following help texts:

\begin{verbatim}
mil>sigs("xtables");
#---------------------------------------------------------------------------------#
# signature  # name
# str  # type
#---------------------------------------------------------------------------------#
[ ...  ]
[ "CTgroup(BAT[oid,any], BAT[oid,any]) : grp"  ]
[ ...  ]
mil>
mil>help("CTgroup");
COMMAND:   CTgroup(BAT[oid,any], BAT[oid,any]) : grp
MODULE:    xtables
COMPILED:  by adm on Fri Jun 16 08:24:38 2006
binary grouping; a synonym for CTderive(ct,attr)

...
 
mil>help("mirror");
COMMAND:   mirror(BAT[any::1,any]) : BAT[any::1,any::1]
MODULE:    bat
COMPILED:  by adm on Tue Sep 28 13:49:08 2004
Returns the head-mirror image of a BAT (two head columns).
 
mil>help("uselect");
COMMAND:   uselect(BAT[any::1,any::2], any::2) : BAT[any::1,void]
MODULE:    algebra
COMPILED:  by adm on Tue Sep 28 13:49:07 2004
Value select, but returning only the head values.
 SEE ALSO: select(bat,val)
 
...
 
mil>help("join");
...
 
PROC:      join(BAT[any::1,any::2], BAT[any::2,any::3]) : BAT[any::1,any::3]
MODULE:    algebra
COMPILED:  by boncz on Aug  6 1998
Returns [left.head,right.tail] where (*fcn)(left.tail,right.head,..params..)
 
COMMAND:   join(BAT[any::1,any::2], BAT[any::2,any::3], lng) : BAT[any::1,any::3]
MODULE:    algebra
COMPILED:  by adm on Tue Sep 28 13:49:07 2004
Returns all BUNs, consisting of a head-value from 'left' and
a tail-value from 'right' for which there are BUNs in 'left'
and 'right' with equal tail- resp. head-value (i.e. the join
columns are projected out).
 
mil>
\end{verbatim}

Finally, the MapiClient and Mserver sessions are closed, the former with $\backslash$q, the latter with a {\tt  @[<a href="../Modules/builtin/index.html#mod_2_3_1">quit</a>@}:

\begin{verbatim}
mil>\q
\end{verbatim}

\begin{verbatim}
MonetDB>quit();
\end{verbatim}

This concludes our quick tour of MonetDB.

@* Memory Management in MonetDB 
@T
This section documents some of the memory tuning options in the @[<a href="../Tools/Mserver/index.html">Mserver</a>@. It is intended for 
experienced MonetDB users who have studied and worked with @[<a href="../mil/index.html"><acronym title="MonetDB Interpreter Language">MIL</acronym></a>.

@+ The BAT Buffer Pool (BBP)
@T
The BBP is the pool of BATs in existence in a MonetDB database. The BAT buffer pool may keep a BAT cached in memory 
or cold on disk. BATs are in one of three modes: 
\begin{description}
\item[{\tt persistent}] may be cached in RAM but always resides on disk permanently.
\item[{\tt transient}] may be cached in RAM or reside on disk until the end of the @[<a href="../Tools/Mserver/index.html">Mserver</a>@ session. However,
as soon as the BAT ceases to have any references pointing to it, it is freed from RAM and removed from disk.
\item[{\tt session}] like a transient BAT. However, if a session BAT does not have any references, it may be kept
cached in RAM until the end of the @[<a href="../Tools/Mserver/index.html">Mserver</a>@ session if there is room in the BBP cache. The BBP uses 
an @[<acronym title="Least Recently Used">LRU</acronym>@ algorithm to unload/destroy BATs when space is needed.
\end{description}
The BAT mode is set with the {\tt @[<a href="../Modules/bat/index.html#mod_2_0_5">persists</a>@} command. Session-BATs can 
be released from the cache with {\tt @[<a href="../Modules/bat/index.html#mod_2_0_5">release(BAT):lng</a>@} which returns an 
identifier that can later be used to speculatively try to retrieve it again with the
{\tt @[<a href="../Modules/bat/index.html#mod_2_0_5">resurrect(lng):BAT</a>@} command.

The {\tt @[<a target="_self" href="#ls">ls()</a>@} and {\tt @[<a target="_self" href="#ls">dir()</a>@} 
commands list two kinds of reference counts for each BAT:

\begin{description}
\item[{\tt refcnt}] 
these are in-memory reference counts. If a @[<acronym title="MonetDB Interpreter Language">MIL</acronym>@ algebra command is executing,
it manipulates the BAT as an in-memory data structure. Swapping out these BATs must be prevented 
by the BBP while the command is running. Therefore, before entering such an algebra command,
the @[<acronym title="MonetDB Interpreter Language">MIL</acronym>@ interpreter increases the reference counts of its BAT parameters, and after leaving it reduces them.

\item[{\tt lrefcnt}] 
logical reference counts may be either @[<acronym title="MonetDB Interpreter Language">MIL</acronym>@ variables with a BAT value, or nested BATs (BATs of BATs that contain values).
A logical reference will not prevent a BAT from being unloaded (removed from the cache), but will prevent it from being destroyed (removed from disk).
Making a BAT persistent, will increment its lrefcnt by one (and making it transient decreases it by one).
\end{description}

The BBP @[<acronym title="Least Recently Used">LRU</acronym>@ policy is steerable by applications using the {\tt @[<a href="../Modules/bat/index.html#mod_2_0_5">hot(BAT)</a>@} and
{\tt @[<a href="../Modules/bat/index.html#mod_2_0_5">cold(BAT)</a>@} commands that decreases resp. increases the likelihood that
a BAT is unloaded when MonetDB is in need of resources.

@+ Memory Limitations
@T
Modern OSs all implement virtual memory, which means that there is more system memory available than the 
RAM alone: the extra space is provided by a {\em swap-file}. 

Virtual memory space can be used by programs, 
either using some malloc library (for small blocks), or using a direct virtual memory interface for 
coarse-grained access. On Windows, the latter is provided by the {\tt VirtualAlloc()} family of calls (short: valloc),
while on Posix this is done by memory mapping of the special file {\tt /dev/zero}. An advantage that this
valloc has over malloc is that it is possible to claim in advance large virtual memory
spaces without committing the memory yet (i.e. without consuming RAM+swap-file). As such, it allows
to allocate growing contiguous ranges of memory without the risk that an in-place reallocation fails (until the 
reserved limit is reached).

Additionally, modern OSs implement {\em memory-mapped} files. A memory mapping adds a file to the virtual memory,
without necessarily consuming RAM or swap-file space, as it uses the file itself to swap to.\\

On a 32-bit OS, the total amount of addressable memory is between 2 and 4GB. Modern 64-bit OSs implement
a 48-bit virtual memory which has a maximum address space of 240TB. As such, in 2002 it is easy to
construct a system that is limited by the 32-bit address barrier (as you can easily exceed 4GB by buying
some RAM+swap-file), whereas a 64-bit OS is limited only by its physical resources (RAM+swap-file).\\

Summarizing, there are three kinds of memory, that all consume virtual memory address space, but:
\begin{description}
\item[{\tt malloc}]
consumes space in RAM+swap-file;
\item[{\tt valloc}]
consumes space in RAM+swap-file, and allows reservation of not-yet-committed contiguous ranges;
\item[{\tt mmap}]
does not consume RAM+swap-file. A variant of this are {\em privately mapped} files, which are modifiable and only
consume RAM+swap-file space for those pages that have been modified (i.e. it guarantees that the underlying
file is left intact by any modifications).
\end{description}

By default BAT heaps are allocated 
from RAM+swap-file. Whether the space is taken from malloced memory or from valloc is determined
by comparing the heap-size to the {\tt gdk_mmap} threshold in the MonetDB configuration file.  

BATs are allocated from memory mapped memory only if that has been requested explicitly with the 
{\tt @[<a href="../Modules/bat/index.html#mod_2_0_6">mmap()</a>@} command. For each of the possibly five heaps,
a {\tt STORE\_MEM} or {\tt STORE\_MMAP} can be specified. Whether MonetDB uses normal memory
mapped files or {\em privately} mapped files depends on the {\tt @[<a href="../Modules/bat/index.html#mod_2_0_3">access()</a>@}
mode of the BAT (only {\tt BAT\_WRITE} leads to privately mapped files).\\

@+ Memory Tuning
@T
In MonetDB, which materializes all BATs, it is possible that MIL commands fail due to lack of memory:
\begin{verbatim}
# fails on any 32-bit system (or a 64-bit system with available RAM+swap-file less than 4GB)
var b1 := bat(void,chr,2000000000); 
var b2 := bat(void,chr,2000000000); 
\end{verbatim}

Confronted with such a problem, however, one should first determine the cause of the lack of memory. 
On well-equipped 32-bit systems, the problem tends to be the 2-4GB address space limit, whereas any 
lack of memory on a 64-bit system is due to lack of resources. \\

Most memory resource problems in MonetDB are easily avoidable by minimizing your open BAT
references (as discussed above) and making your access patterns cache friendly (see the 
@[<a href="../Modules/radix/index.html">radix module</a>@. Additionally, you are able to tune the 
buffer management policy of MonetDB to the capabilities of your hardware platform
as described in the following.\\

MonetDB provides two tuning thresholds that steer the behavior of the BBP @[<acronym title="Least Recently Used">LRU</acronym>@ algorithm:
\begin{description}
\item[mem] the physical resource limit.  The maximum is set with the
{\tt @[<a href="../Modules/sys/index.html#mod_2_0_1">mem_maxsize(lng)</a>@} command, where the default
is 80 percent of the RAM+swap-file size of the system. The current usage of physical resources
can be retrieved with {\tt @[<a href="../Modules/sys/index.html#mod_2_0_1">mem_cursize():lng</a>@}.
\item[vm] the virtual memory address space consumption limit.  The maximum is set with the
{\tt @[<a href="../Modules/sys/index.html#mod_2_0_1">vm_maxsize(lng)</a>@} command, where the default
is 80 percent of the RAM+swap-file size of the system. The current usage of virtual address
space can be retrieved with {\tt @[<a href="../Modules/sys/index.html#mod_2_0_1">vm_cursize():lng</a>@}.
\end{description}

A particular problem that can occur on 32-bit systems is when it seems that the virtual address
space is not yet exhausted, but an allocation of some large block fails anyway.  This tends 
to be caused by {\em virtual address space fragmentation} and can be monitored with
{\tt @[<a href="../Modules/sys/index.html#mod_2_0_1">mem_printmap():lng</a>@}. Other commands of interest
are {\tt @[<a href="../Modules/sys/index.html#mod_2_0_1">mem_usage(lng minsize) : BAT[str,lng]</a>@} 
and {\tt @[<a href="../Modules/sys/index.html#mod_2_0_1">vm_usage(lng minsize) : BAT[str,lng]</a>@} 
that give detailed overviews of where the various kinds of memory are being used.

Debug-mask 4 causes regular printing of memory resource consumption. It can either be set
from the {\tt @[<a href="../../../../monet-compiled/etc/MonetDB.conf">MonetDB.conf</a>@} file, the
@[<a href="../Tools/Mserver/index.html">Mserver</a>@ command line, or by executing
the @[<a href="../Modules/builtin/index.html#mod_2_4_2">debugmask()</a>@ operator. 

@* Copyright Notice
@T
{\small\begin{verbatim}
/*
 * The contents of this file are subject to the MonetDB Public License
 * Version 1.1 (the "License"); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 * http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
 *
 * Software distributed under the License is distributed on an "AS IS"
 * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
 * License for the specific language governing rights and limitations
 * under the License.
 *
 * The Original Code is the MonetDB Database System.
 *
 * The Initial Developer of the Original Code is CWI.
 * Portions created by CWI are Copyright (C) 1997-2007 CWI.
 * All Rights Reserved.
 */

\end{verbatim}}
