@section The MonetDB JDBC Driver
The most obvious way to connect to a data source using the Java
programming language is by making use of the in Java defined JDBC
framework.

MonetDB has a native Java JDBC driver type 4 which allows use of the
MonetDB database in a Java alike way.

It is quite difficult to have a fully complete JDBC implementation.
Also this driver isn't complete in that sense.  However, it is believed
that the most prominent parts of the JDBC interface are implemented, and
in such a way that they adhere to the specifications.  If you make
extensive use of JDBC semantics and rely on many of its features, please
read the release notes which are to be found in the @code{src/jdbc}
directory of the sql CVS tree.

This document will give a short description how to use the MonetDB JDBC
driver in Java applications.  A familiarity with the Java JDBC API is
required to fully understand this document.  Please note that you can
find the complete JDBC API on Sun's web site @code{http://java.sun.com/}.

@subsection Requirements
In order to use the MonetDB JDBC driver in Java applications you need
(of course) a running MonetDB instance with the SQL module loaded.\\
The SQL module is a separate module in the CVS tree, and should be
installed separately, since it is not included in the main MonetDB
module.

You should be able to issue the following command on the MonetDB prompt
without errors:
@ifset M4manual
@example
@code{module(sql\_server);}
@code{sql\_server\_start();}
@end example
@end ifset

@ifclear M4manual
@example
@code{include sql;}
@end example
@end ifclear

@subsection Getting the driver Jar
If you (compiled and) installed MonetDB and the SQL module the regular
way, you can find a two jar-archives in the directory
@code{share/MonetDB/lib} called @code{monetdb-X.Y-jdbc.jar} and
@code{jdbcclient-X.Y.jar} in the installation root (chosen during the
configure process).  For regular applications that only need the JDBC
driver, the first jar-file is sufficient.  When the JdbcClient utility
is required, the second is required.  Applications that require the JDBC
driver will, however, work with both jar-files.  The @code{X} and
@code{Y} in the names represent the major and minor version numbers of
the JDBC driver.\\
@emph{Note:} there may also exists a file named @code{mapi.jar} in
the mentioned directory, this jar does NOT contain the JDBC driver.

@subsection Compiling the driver (using ant, optional)
The directory @code{src/jdbc} of the sql CVS tree contains all the
files to build the driver using Apache's Ant tool.  Simply issuing the
command @code{ant} should be sufficient to build the driver
jar-archive in the subdirectory @code{jars}. See the ant web site for
more documentation on the ant build-tool.
@code{http://ant.apache.org/}  The Java sources require at least a
Java 2 platform 1.4 compatible compiler.

@subsection Testing the driver using the JdbcClient utility
Before you start developing your programs which use the MonetDB JDBC
driver it is generally a good idea to check if the driver actually works
in your environment.\\
Follow the steps below to assure your setup is complete:
@enumerate
@item start MonetDB
@item load the SQL module
@item run the JdbcClient utility using @code{java -jar
@{path/to/jdbcclient-X.Y.jar@} -umonetdb} (with
 password monetdb)
@end enumerate
The last step should give you something like this:

@verbatim
% java -jar jars/jdbcclient-1.2.jar -umonetdb
password:

Welcome to the MonetDB interactive JDBC terminal!
Database: MonetDB 4.99.19
Driver: MonetDB Native Driver 1.2 (Blunt+ 20060102)
Type \q to quit, \h for a list of available commands
auto commit mode: on
monetdb-> 
@end verbatim

@subsection Using the driver in your Java programs
In order to use the MonetDB JDBC driver, the jar-archive has to be in
the Java classpath.  Make sure this is actually the case.

Loading the driver in your Java program requires two lines of code:
@verbatim
// make sure the ClassLoader has the MonetDB JDBC driver loaded
Class.forName("nl.cwi.monetdb.jdbc.MonetDriver");
// request a Connection to a MonetDB server running on 'localhost'
Connection con = DriverManager.getConnection("jdbc:monetdb://localhost/database", "monetdb", "monetdb");
@end verbatim
The first line makes sure the Java ClassLoader has initialised (and
loaded) the Driver class of the MonetDB JDBC package, so it is
registered with the DriverManager.  The second line requests a Connection
object from the DriverManager which is suitable for MonetDB.

The string passed to the @code{"getConnection()"}method is defined as
@code{"jdbc:monetdb://<host>[:<port>]/<database>"} where elements between
@code{"<"} and @code{">"} are required and elements between @code{"["} and
@code{"]"} are optional.  Note that even though the database can be
specified, it usually is not supported by the database.  A warning is
issued each time that this value is being ignored.

@subsection A sample Java program
@verbatim
import java.sql.*;

/**
 * This example assumes there exist tables a and b filled with some data.
 * On these tables some queries are executed and the JDBC driver is tested
 * on it's accuracy and robustness against 'users'.
 *
 * @author Fabian Groffen
 */
public class MJDBCTest {
        public static void main(String[] args) throws Exception {
                // make sure the driver is loaded
                Class.forName("nl.cwi.monetdb.jdbc.MonetDriver");
                Connection con = DriverManager.getConnection("jdbc:monetdb://localhost/database", "monetdb", "monetdb");
                Statement st = con.createStatement();
                ResultSet rs;

                rs = st.executeQuery("SELECT a.var1, COUNT(b.id) as total FROM a, b WHERE a.var1 = b.id AND a.var1 = 'andb' GROUP BY a.var1 ORDER BY a.var1, total;");
                // get meta data and print columns with their type
                ResultSetMetaData md = rs.getMetaData();
                for (int i = 1; i <= md.getColumnCount(); i++) {
                        System.out.print(md.getColumnName(i) + ":" +
                                md.getColumnTypeName(i) + "\t");
                }
                System.out.println("");
                // print the data: only the first 5 rows, while there probably are
                // a lot more. This shouldn't cause any problems afterwards since the
                // result should get properly discarded on the next query
                for (int i = 0; rs.next() && i < 5; i++) {
                        for (int j = 1; j <= md.getColumnCount(); j++) {
                                System.out.print(rs.getString(j) + "\t");
                        }
                        System.out.println("");
                }

                // tell the driver to only return 5 rows, it can optimize on this
                // value, and will not fetch any more than 5 rows.
                st.setMaxRows(5);
                // we ask the database for 22 rows, while we set the JDBC driver to
                // 5 rows, this shouldn't be a problem at all...
                rs = st.executeQuery("select * from a limit 22");
                // read till the driver says there are no rows left
                for (int i = 0; rs.next(); i++) {
                        System.out.print("[" + rs.getString("var1") + "]");
                        System.out.print("[" + rs.getString("var2") + "]");
                        System.out.print("[" + rs.getInt("var3") + "]");
                        System.out.println("[" + rs.getString("var4") + "]");
                }

                // this close is not needed, should be done by next execute(Query) call
                // however if there can be some time between this point and the next
                // execute call, it is from a resource perspective better to close it.
                //rs.close();

                // unset the row limit; 0 means as much as the database sends us
                st.setMaxRows(0);
                // we only ask 10 rows
                rs = st.executeQuery("select * from b limit 10;");
                // and simply print them
                while (rs.next()) {
                        System.out.print(rs.getInt("rowid") + ", ");
                        System.out.print(rs.getString("id") + ", ");
                        System.out.print(rs.getInt("var1") + ", ");
                        System.out.print(rs.getInt("var2") + ", ");
                        System.out.print(rs.getString("var3") + ", ");
                        System.out.println(rs.getString("var4"));
                }

                // this close is not needed, as the Statement will close the last
                // ResultSet around when it's closed
                // again, if that can take some time, it's nicer to close immediately
                // the reason why these closes are commented out here, is to test if
                // the driver really cleans up it's mess like it should
                //rs.close();

                // perform a ResultSet-less query (with no trailing ; since that should
                // be possible as well and is JDBC standard)
                // Note that this method should return the number of updated rows. This
                // method however always returns -1, since Monet currently doesn't
                // support returning the affected rows.
                st.executeUpdate("delete from a where var1 = 'zzzz'");

                // closing the connection should take care of closing all generated
                // statements from it...
                // don't forget to do it yourself if the connection is reused or much
                // longer alive, since the Statement object contains a lot of things
                // you probably want to reclaim if you don't need them anymore.
                //st.close();
                con.close();
        }
}
@end verbatim

