@chapter Embedded MonetDB
The Embedded MonetDB version is optimized for running on small board computers
as a database back-end for a single client.
It is of particular interest if you need database functionality within
a limited application setting, e.g a self-contained database distributed
as part of the application.
Within this context, much of the code to facilitate and protect
concurrent use of the kernel can be disabled. For example,
the communication overhead of client-server TCP-IP interaction is removed.
Moreover, locking of critical resources in the kernel is not needed anymore,
which results in significant performance improvements.

The approach taken is to wrap a server such that the interaction
between client code and server can still follow the Mapi protocol.
It leads to a C-program with calls to the Mapi library routines,
which provides some protection against havoq behaviour.
From a programming view, it differs from a client-server application in
the startup and (implicit) termination.

You normally only have to change the call @code{mapi_connect()} into
@code{embedded_sql()} (or @code{embedded_mal()}). It requires an
optional argument list to refine the environment variables used by the server.
In combination with the header file @code{embeddedclient.h}
it provides the basis to compile and link the program.

@c The primary host language is C. Embedded versions for other languages are under development.

The behavior of an embedded SQL program can be simulated with
a server started as follows:
@example
mserver5 --set embedded=yes --dbinit="include sql;" &
@end example

As a result, the server starts in 'daemon' mode,
loads the SQL support library, and waits for a connection.
Only one connection is permitted.

@menu
* A Simple Example::
* Configuration Parameters::
* Embedded MonetDB Limitations::
@end menu

@node A Simple Example, Configuration Parameters, Embedded MonetDB, Embedded MonetDB
@subsection Mbedded Example
A minimalistic embedded application is shown below. It creates
a temporary table in the database, fills it, and retrieves the
records for some statistics gathering.

The key operation is @code{embedded_sql()} which takes an optional
environment argument list. Upon success of this call, there
will be a separate server thread running in the same user space to handle
the database requests. A short-circuit interaction is established
between the application and the kernel using in memory buffers.

The body of the program consists of the Mapi calls you have
already seen (@pxref{The Mapi Library}). It terminates with a call
to @code{mapi_disconnect()} which lets the MonetDB thread
gracefully die.

The tight coupling of application and kernel code also carries some
dangers.
Many of the MonetDB data structures can be directly accessed,
or calls to the kernel routines are possible.
It is highly advised to stick to the Mapi interaction protocol.
It gives a little more protection against malicious behavior
or unintended side-effects.

@example
@verbatim
#include <embeddedclient.h>

#define die(dbh,hdl) (hdl?mapi_explain_result(hdl,stderr):      \
              dbh?mapi_explain(dbh,stderr):         \
                  fprintf(stderr,"command failed\n"),   \
              exit(-1))

#define close_handle(X,Y) if (mapi_close_handle(X) != MOK) die(X, Y);

int
main()
{
    Mapi dbh;
    MapiHdl hdl = NULL;
    int i;

    dbh= embedded_sql(NULL,0);
    if (dbh == NULL || mapi_error(dbh))
        die(dbh, hdl);

    /* switch off autocommit */
    if (mapi_setAutocommit(dbh, 0) != MOK || mapi_error(dbh))
        die(dbh,NULL);

    if ((hdl = mapi_query(dbh, "create table emp"
				" (name varchar(20),age int)")) == NULL || mapi_error(dbh))
        die(dbh, hdl);
    close_handle(dbh,hdl);

    for(i=0; i< 1000; i++) {
        char query[100];
        snprintf(query, 100, "insert into emp values('user%d', %d)", i, i % 82);
        if ((hdl = mapi_query(dbh, query)) == NULL || mapi_error(dbh))
            die(dbh, hdl);
        close_handle(dbh,hdl);
    }

    if ((hdl = mapi_query(dbh, "select * from emp")) == NULL || mapi_error(dbh))
        die(dbh, hdl);

    i=0;
    while (mapi_fetch_row(hdl))  {
        char *age = mapi_fetch_field(hdl, 1);
        i= i+ atoi(age);
    }
    if (mapi_error(dbh))
        die(dbh, hdl);
    close_handle(dbh,hdl);
    printf("The footprint is %d Mb \n",i);

    mapi_disconnect(dbh);
    return 0;
}
@end verbatim
@end example

The embedded MonetDB engine is available as the
library @code{libembedded_sql.a} (and @code{libembedded_mal.a})
to be linked with a C-program.
Provided the programming environment have been initialized properly, it
suffices to prepare the embedded application using
@example
gcc myprog.c -o myprog `monetdb5-config --cflags --libs`
@end example

You might also write a Makefile to build the program as follows.[todo]
@example
@verbatim
CC= gcc
INCLUDE=`monetdb5-config --cflags`
LIBS=`monetdb5-config --libs`
myprog: myprog.o
	${CC} myprog.o -o myprog ${LIBS}
myprog.o : myprog.c
	${CC} -c ${INCLUDE} myprog.c

clean: myprog.o
	rm -f myprog myprog.o
@end verbatim
@end example

@node Configuration Parameters , Embedded MonetDB Limitations, A Simple Example , Embedded MonetDB
The configuration parameters for the server are read from its default
location in the file system. In an embedded setting this location may
not be accessible.
It requires calls to @code{embedded_option()} before you asks for the
instantiation of the server code itself.
The code snippet below illustrate how our example
is given hardwired knowledge on the desired settings:
@example
@verbatim
main(){
...
	Mbedded_option("dbfarm",".");
	Mbedded_option("dbname","demo");
	Mbedded_option("user","guest");
	Mbedded_option("password","anonymous");
...
	Mbedded_sql(NULL,0);
@end verbatim
@end example
For an overview of the system configuration parameters see XYZ.

@node Embedded MonetDB Limitations , MonetDB Assembler Language, Configuration Parameters, Embedded MonetDB
@subsection Limitations for Embedded MonetDB

In embedded applications the memory footprint is a factor of concern.
The raw footprint as delivered by the Unix @code{size} command is often used.
It is, however, also easily misleading, because the footprint
depends on both the code segments and buffered database partitions in use.
Therefore it makes sense to experiment with a minimal, but functionally
complete application to decide if the resources limitations are obeyed.

The minimal static footprint of MonetDB is about 16 Mb (+ ca 4Mb for SQL).
After module loading the space quickly grows to about 60Mb.
@emph{This footprint should be reduced.}

A better frame of reference for embedded applications is our sample
program, which is a simple, yet complete embedded application inspired by an
MP3 player. The table below illustrates some basic properties
on different embedded SQL platforms.

@multitable @columnfractions 0.2 0.2 0.2 0.2 0.2
@item
@tab Mbedded
@tab SQLite
@tab MySQL
@tab PostgreSQL
@item Prepare time
@item Max memory
@item CPU time
@end multitable
The @code{Prepare time} denotes the compilation and link time on
a state-of-the-art PC.

The embedded application world calls for many, highly specialized
enhancements. It is often well worth the effort to carve out the
functionality needed from the MonetDB software packages. The easiest
solution to limit the functionality and reduce resource consumption
is to reduce the modules loaded. This requires patches to the
startup scripts.

The benefit of an embedded database application also comes with limitations.
The one and foremost limitation of embedded MonetDB is that the first
application accessing the database effectively locks out any other concurrent
use.
Even in those situations where concurrent applications merely read the database,
or create privately held tables.

