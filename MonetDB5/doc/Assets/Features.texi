@node Features and Limitations, When to consider MonetDB, About this manual, TOC
@section Features and Limitations

In this section we give a short overview of the key features of MonetDB.
Its evolution in the area of data-mining and data-warehousing makes
it an ideal choice for high volume, complex query dominant applications.
In this light, MonetDB may be less adequate for secure OLTP settings.

It is important to recognize that MonetDB is primarily aimed at
experienced system programmers and administrators. End-users are
advised to use any of the open-source graphical SQL workbenches to
interact with the system. [see section x]

@menu
* When to consider MonetDB::
* When not to consider MonetDB::
@end menu
@node When to consider MonetDB, When not to consider MonetDB, Features and Limitations, TOC
@subsubsection When to consider MonetDB ?
@strong{A high-performance database management system.}
MonetDB is an easily accessible open-source DBMS for SQL-/XQuery-based
applications and database research projects. 
Its origin goes back over a decade, when we decided that the database hotset
- the part used by the applications - can be largely held in main-memory
or where a few columns of a broad relational table are sufficient to
handle a request.
Exploit cache-conscious algorithms proved pivotal for these design decisions.
@c is the above the meant?

@strong{A multi-model system.}
MonetDB supports multiple query language front-ends. Aside from
its proprietary language, called MonetDB Assembler Language (MAL),
it supports ANSI SQL-99 and W3C XQuery. Their underlying logical
data model and computational scheme differs widely. The system is designed
to provide a common ground for both and is prepared to support
languages based on yet another data model or processing paradigm.

@strong{A binary-relation database kernel.}
MonetDB is built on the canonical representation of database
containers, namely binary relations.
The datastructures are geared towards efficient representation of these
binary relations when they mimic a n-ary relational scheme.

This led to an architecture where the traditional page-pool is
replaced by a much larger granularity, called the BATs. They are
sizeable entities -up to hundreds of megabytes- swapped into
memory upon need.
The benefit of this approach has been shown in numerous papers
in scientific literature.

@strong{A broad spectrum database system.}
MonetDB is continuously developed to support a broad application
field. Although originally developed for Analytical CRM products,
it is now being used at the low-end scale as an embedded
relational kernel and projects are underway to tackle the huge
database problems encountered in science, e.g. astronomy.

@strong{An extendable database system.}
MonetDB has been strongly influenced by the scientific
experiments to understand the interplay between algorithms
and hardware features. It has turned MonetDB into a highly extensible
database system for software experts. It proofs valuable in
those cases where an application specific and critical
component makes all the difference between slow and fast
implementation.

@strong{An opensource software system.}
MonetDB has been developed over many years of research at 
@url{http://monetdb.cwi.nl,CWI}, whose charter ensures that results 
are easily accessible to others.
Be it through publication in the scientific domain or publication of the
software components involved.
Subscribing to the MonetDB users mailing list gives a glimpse of the
@c 'catch a glimpse' is the saying
audience and helps to justify the on-and-off office hours put into
its development and maintenance.

@node When not to consider MonetDB, The History of MonetDB, When to consider MonetDB, TOC
@subsection When not to consider MonetDB ?
There are several areas where MonetDB has not yet built a reputation.
They are the prime candidates for experimentation, but also areas
where application construction may become risky. More mature products
may then provide a short-term solution, while MonetDB programmers team
works on filling the functional gaps.
The following areas should be considered with care:

@strong{Persistent object caches.}
The tendency to develop applications in Java and C/C++ based on
a persistent object model, is a no-go area for MonetDB. Much like the
other database engines, the overhead involved in individual
record access does not do justice to the data structures and
algorithms in the kernel. They are chosen to optimize bulk
processing, which always comes at a price for individual object access.

Nevertheless, MonetDB has been used from its early days in a commercial
application, where the programmers took
care in maintaining the Java object-cache. It is a route with great
benefits, but also one where sufficient manpower should be
devoted to perform a good job.

@strong{High-performance financial OLTP.}
MonetDB was orginally not designed for highly concurrent transaction workloads.
For one reason it was decided to factor out the ACID techniques
and make them explicit in the query plans generated by the front-end compilers.
The SQL implementation provides full transaction control and recovery, but
only at a coarse level of granularity.

Given the abundance of main memory nowadays and the slack CPU cycles
to process database requests, it may be profitable to consider serial
execution of OLTP transactions. 

@strong{Security.}
MonetDB has not been designed with a strong focus on
security. The major precautions have been taken, but are incomplete
when access to the hosting machine is granted or when direct access
is granted to the MonetDB programming language features.
@c which language??
The system should preferably be deployed in a sand-boxed environment
where remote access is encapsulated in a dedicated application framework.

@strong{Scaleing over multiple machines.}
MonetDB does not provide a centralized controlled, distributed database
infrastructure. Instead, we move towards an architecture where
multiple autonomous MonetDB instances are joining together to process
a large and distributed workload.

In the multimedia applications we have exploited the inherent
data parallelism to speedup processing and reduce the synchronization cost.
The underlying platforms were 16-32 Linux-based cluster computers with
@c 16-32??
sizeable main memories.

