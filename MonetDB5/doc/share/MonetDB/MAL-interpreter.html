<html lang="en">
<head>
<title>MAL interpreter - Untitled</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Untitled">
<meta name="generator" content="makeinfo 4.8">
<link title="Top" rel="start" href="index.html#Top">
<link rel="prev" href="MAL-Modules.html#MAL-Modules" title="MAL Modules">
<link rel="next" href="Optimizer-landscape.html#Optimizer-landscape" title="Optimizer landscape">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This file documents the MonetDB Version 5.0 Reference Manual

Last updated: June 5, 2006

     Copyright (C) 2000-2006 CWI

     Permission is granted to make and distribute verbatim
     copies of this manual provided the copyright notice and
     this permission notice are preserved on all copies.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
body { 
    margin: 0px;
    padding: 0px;
}
a,a:visited {
	color: #336633;
}
a:hover {
	color: #003300;
}

p,body {
    font-family: Verdana, Arial, Helvetica, sans-serif;
    text-align: justify;
    font-size: 10pt;
}

h1 {
    font-family: Verdana, Arial, Helvetica, sans-serif;
    font-size: 14pt;
    font-style: bold;
	text-align: left;
}

td,th {
    font-family: Verdana, Arial, Helvetica, sans-serif;
    font-size: 10pt;
}

div.banner {
	padding: 5px 0px 0px 5px; 
}

div.banner img {
	border: 0px;
	text-decoration: none;
}

div.topmenu {
	margin-top: -20px;
	margin-left: 166px;
	padding: 8px 5px 5px 5px;
	font-size: 8pt;
	background-color: #A9CC99;
}

div.topmenu-bottom {
	margin-top: -4px;
	margin-left: 166px;
	padding: 2px 5px;
	background-color: #BCD2ED; 
}

div.topmenu a {
	padding: 4px 5px 1px 5px;
	text-decoration: none; 
}

div.topmenu a:focus {
	background-color: #6699CC; 
}

div.topmenu a:hover {
	background-color: #5662A0; 
}

/*
span.current {
}
*/

div.topmenu span.current a {
	color: #000000;
	background-color: #BCD2ED; 
}

/* this should be inherited IMHO, but it doesn't so we just redefine it */
div.topmenu span.current a:hover {
	color: #336633;
	background-color: #BCD2ED; 
}

/*
span.submenu {
}
*/

div.topmenu span.submenu a {
	background-color: #CBEEBB;
}

/* this should be inherited IMHO, but it doesn't so we just redefine it */
div.topmenu span.submenu a:hover {
	background-color: #9FB0DB; 
}

div.topmenu span.button {
	margin: 0px 0px 0px 10px;
}

div.topmenu span.button a {
	padding: 5px 6px 1px 6px;
	color: #333333;
	background-color: #FFAC37;
}

div.topmenu span.button a:hover {
	color: #FFFFFF;
}

div.content {
	padding: 5px;
	margin-left: 166px;
	margin-right: 12%;
}

div.header {
	padding: 5px;
	margin-left: 166px;
	margin-right: 12%;
}


div.sidebar-a {
	float: left;
	width: 156px;
	padding: 5px;
	font-size: 8pt;
}

div.sidebar-b { 
	float: right;
	width: 146px;
	margin: 0px 0px 0px 5px;
	padding: 5px;
	font-size: 8pt;
}

div.footer-a {
	float: left;
	width: 156px;
	margin: 5px 0px 0px 0px;
	padding: 5px;
	font-size: 7pt;
	background-color: #CBEEBB;
}

div.footer-a a {
	margin: 5px;
	text-decoration: none; 
}

div.footer-b {
	margin: 5px 0px 0px 0px;
	padding: 5px;
	background-color: #A9CC99;
	font-size: 7pt;
}

div.footer-b a {
	margin: 5px;
	padding: 2px 3px;
	text-decoration: none; 
}
div.footer-b a:focus {
	background-color: #6699CC; 
}
div.footer-b a:hover {
	color: #FFFFFF;
	background-color: #5662A0; 
}
div.footer-b img {
	border: 0px;
	vertical-align: bottom;
	text-decoration: none; 
}

div.news {
	border: 1px solid #666699;
	background-color: #E7E7E7; 
	margin: 3px 0px;
	padding: 5px 5px 5px 5px;
}

div.news li {
	list-style: square;
}

div.submenu-b {
	border: 1px solid #666699;
	background-color: #CBEEBB;
	margin: 3px 0px;
	padding: 5px 5px 5px 5px;
}

div.submenu-b a {
	text-decoration: none; 
	display: block;
	padding: 1px 2px;
	color: #000000;
	background-color: #A9CC99;
}

div.submenu-b a:hover {
	background-color: #BCD2ED; 
}

div.submenu-b ul {
	padding: 1px 0px 1px 0px;
	margin: 0px;
}

div.submenu-b li {
	list-style: none;
	padding: 1px 0px 0px 6px;
}

div.submenu {
	border: 1px solid #666699;
	background-color: #9FB0DB; 
	margin: 3px 0px;
	padding: 5px 5px 5px 5px;
}

div.submenu a {
	text-decoration: none; 
	display: block;
	padding: 1px 2px;
	_width: 100%;
}

div.submenu ul {
	padding: 1px 0px 1px 0px;
	margin: 0px;
}

div.submenu li {
	list-style: none;
	padding: 1px 0px 0px 6px;
}

div.submenu span.submenu a {
	color: #000000;
	background-color: #BCD2ED; 
}

/* this should be inherited IMHO, but it doesn't so we just redefine it */
div.submenu span.submenu a:hover {
	background-color: #A9CC99;
}

div.submenu span.current a {
	background-color: #CBEEBB;
}

/* this should be inherited IMHO, but it doesn't so we just redefine it */
div.submenu span.current a:hover {
	background-color: #CBEEBB;
}

pre.code {
	border: 1px solid Black;
	padding: 4px;
	font-family: monospace;
}
.authors {
	font-size: smaller;
	font-style: italic;
}
--></style>
</head>
<body>
<div class="node">
<p>
<a name="MAL-interpreter"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="Optimizer-landscape.html#Optimizer-landscape">Optimizer landscape</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="MAL-Modules.html#MAL-Modules">MAL Modules</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="index.html#Top">Top</a>
<hr>
</div>

<h2 class="chapter">11 The MAL Interpreter</h2>

<p>The MAL interpreter always works in the context of a single user session,
which provides for storage access to global variables and modules.

   <p>Runtime storage for variables are allocated on the stack of the
interpreter thread. The physical stack is often limited in size,
which calls for safeguarding their value and garbage collection before returning. 
A malicious procedure or implementation will lead to memory leakage.

   <p>A system command (linked C-routine) may be interested in extending the
stack. This is precluded, because it could interfere with the recursive
calling sequence of procedures. To accommodate the (rare) case, the routine
should issue an exception to be handled by the interpreter before retrying. 
All other errors are turned into an exception, followed by continuing
at the exception handling block of the MAL procedure.

<h3 class="section">11.1 MAL API</h3>

<p>The linkage between MAL interpreter and compiled C-routines
is kept as simple as possible. 
Basically we distinguish four kinds of calling conventions:
CMDcall, FCNcall, THRDcall, and  PATcall. 
The FCNcall indicates calling a MAL procedure, which leads
to a recursive call to the interpreter.

   <p>CMDcall initiates calling a linked function, passing pointers
to the parameters and result variable, i.e.  f(ptr a0,..., ptr aN)
The function returns a MAL-SUCCEED upon success and a pointer
to an exception string upon failure. 
Failure leads to raise-ing an exception in the interpreter loop,
by either looking up the relevant exception message in the module
administration or construction of a standard string. 
Upon successfull return, we update the ValRecord with length indications.

   <p>The PATcall initiates a call which contains the MAL context. 
i.e. f(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
The blk provides access to the code definitions. It is primarilly
used by routines intended to manipulate the code base itself, such
as the optimizers. The Mal stack frame pointer provides access
to the values maintained. The arguments passed are offsets
into the stack frame rather than pointers to the actual value.

   <p>BAT parameters require some care. Ideally, a BAT should not be kept
around long. This would mean that each time we access a BAT it has to be
pinned in memory and upon leaving the function, it is unpinned. 
This degrades performance significantly. 
After the parameters are fixed, we can safely free the destination
variable and re-initialize it to nil;

<h3 class="section">11.2 Exception handling</h3>

<p>Calling a built-in or user-defined routine may lead to an error, a
cached status message to be dealt with in MAL, or as an error status in Mapi.

   <p>Exceptions raised within a linked-in function requires some care. 
First, the called procedure does not know anything about the MAL
interpreter context. Thus, we need to return all relevant information
upon leaving the linked library routine.

   <p>Second, exceptional cases can be handled deeply in the recursion, where they
may also be handled, i.e. by issueing an GDKerror message. The upper layers
merely receive a negative integer value to indicate occurrence of an
error somewhere in the calling sequence. 
We have to also look into GDKerrbuf to see if there was
an error raised deeply inside the system.

   <p>The policy is to require all C-functions to return a string-pointer. 
Upon successfull call, this string function is NULL. Otherwise it contains an
encoding of the exceptional state encountered. This message
starts with the exception identifer, followed by contextual details.

<h3 class="section">11.3 BAT reference counting</h3>

<p>A key issue is to deal with temporary BATs in an efficient way. 
References to bats in the buffer pool may cause dangling references
at the language level. This appears as soons as your share
a reference and delete the BAT from one angle. If not carefull, the
dangling pointer may subsequently be associated with another BAT

   <p>Dangling references can be dealt with in several ways. 
First, we could increase the reference count each time a BAT
becomes shared and rely on the garbage collector to properly
decrement the count before abanding a execution frame. 
Second, we could try to avoid dangling pointers by permitting
just one reference per BAT. This doesn't work, because we may
keep BAT-views around, which depend on the existence of the
underlying BAT.

<h3 class="section">11.4 Garbage collection</h3>

<p>Garbage collection is relatively straightforward, because most values are
retained on the stackframe of an interpreter call. However, two storage
types and possibly user-defined type garbage collector definitions
require attention. [TAKE CARE OF fixable atoms !!]

   <p>All string values are private to the VALrecord, which means they
have to be freed explicitly before a MAL function returns. 
The first step is to always safe the destination variable
before a function call is made.
<pre class="example"></pre>
   <p>All operations are responsible to properly set the
reference count of the BATs being produced or destroyed. 
The exception are the target BAT variables. Their
reference is saved until the operation is finished. 
They the reference can be reduced (due to overwrite
of the target variable) or retained(the operation failed).

   <p>Actually, the libraries should not leave the
physical reference count being set. This is only
allowed during a GDK operation. All references
should be logical.

<h3 class="section">11.5 Performance section</h3>

<p>The interpreter has a built-in performance monitor hook, which is
activated using the compile option MALprofiler. Activation can lead to
a significant performance degradation, because for all traced functions
we have to keep track of essential system counter information.

<h3 class="section">11.6 Bootstrap and module load</h3>

<p>The server is bootstrapped by processing a MAL script with
module definitions. For each module encountered, the object library
lib_&lt;modulename&gt;.so is searched for in <small class="dots">...</small>/lib/MonetDB. 
The corresponding signature are defined
in <small class="dots">...</small>/lib/&lt;modulename&gt;.mal.

   <p>The default bootstrap script is called <small class="dots">...</small>/lib/MonetDB/mal_init.mal
and it is designated in the configuration file as the mal_init property. 
The rationale for this set-up is that database administrators can
extend/overload the bootstrap procedure without affecting the distributed
software package. 
It merely requires a different direction for the mal_init property.

   <p>The scheme also isolates the functionality embedded in modules from
inadvertise use on non-compliant databases. 
[access control issue, how to limit what a user can do on a database?]

   <p>Unlike previous versions of MonetDB, modules can not be unloaded. 
Dynamic libraries are always global and, therefore, it
is best to load them as part of the server initialization phase.

   <p>The MAL program should be compiled with -rdynamic and -ldl. 
This enables loading the routines and finding out the address
of a particular routine

<pre class="example"></pre>
   <p>The mapping from MAL module.function() identifier to an address is
resolved in the function getAddress. Since all modules libraries are loaded
completely with GLOBAL visibility, it suffices to provide the internal function
name. 
In case an attempt to link to an address fails,
a final attempt is made to locate the *.o file in
the current directory.

<pre class="example"></pre>
   <h3 class="section">11.7 Module loading</h3>

<p>The default location to search for the module is in monet_mod_path
unless an absolute path is given.

   <p>Loading further relies on the Linux policy to search for the module
location in the following order: 1) the colon-separated list of
directories in the user's LD_LIBRARY, 2) the libraries specified
in /etc/ld.so.cache, and 3) /usr/lib followed by /lib
If the module contains a routine _init, then that code is executed
before the loader returns. Likewise the routine _fini is called just
before the module is unloaded.

   <p>A module loading conflict emerges if a function is redefined. 
A duplicate load is simply ignored by keeping track of modules
already loaded.
<pre class="example"></pre>
   <p>To speedup restart and to simplify debugging, the Monet server can
be statically linked with some (or all) of the modules. 
A complicating factor is then to avoid users to initiate another load
of the module file, because it would lead to a dlopen error.

   <p>The partial way out of this dilema is to administer somewhere
the statically bound modules, or to enforce that each module
comes with a known routine for which we can search. 
In the current version we use the former approach.
<pre class="example"></pre>
   <h3 class="section">11.8 MAL runtime stack</h3>

<p>The runtime context of a MAL procedure is allocated on the runtime stack
of the corresponding interpreter. 
Access to the elements in the stack are through index offsets,
determined during MAL procedure parsing. 
This method has been proven highy efficient compared to using
individual GDKmalloci calls.

   <p>Unlike Monet Version 4, the scope administration for MAL procedures is
decoupled from their actual runtime behavior. This means we are
more relaxed on space allocation, because the size is determined
by the number of MAL procedure definitions instead of the runtime
calling behavior. (See mal_interpreter for details on value stack
management)

   <p>The variable names and types are kept in the stack to ease debugging. 
The underlying string value need not be garbage collected.

   <p>The interpreter should be protected against physical stack overflow. 
The solution chosen is to maintain an incremental depth size. 
Once it exceeds a threshold, we call upon the kernel to
ensure we are still within safe bounds.
<pre class="example"></pre>
   </body></html>

