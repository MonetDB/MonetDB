<?xml version="1.0"?>
<!DOCTYPE texinfo PUBLIC "-//GNU//DTD TexinfoML V4.8//EN" "http://www.gnu.org/software/texinfo/dtd/4.8/texinfo.dtd">
<texinfo xml:lang="en">
  <setfilename>MonetDB.xml</setfilename>
<!-- %**end of header -->
<!-- environment -->
  <setvalue name="VERSION">5.0</setvalue>
  <setvalue name="UPDATED">April 27, 2006</setvalue>
  <para>This file documents the MonetDB Version 5.0 Reference Manual</para>
  <para>Last updated: April 27, 2006</para>
  <para>Copyright (C) 2000-2006 CWI</para>
  <para>Permission is granted to make and distribute verbatim      copies of this manual provided the copyright notice and      this permission notice are preserved on all copies.</para>
  <titlepage>
    <booktitle>MonetDB Reference Manual</booktitle>
    <booksubtitle>Version 5.0</booksubtitle>
    <author>&lt;emph>The MonetDB Development Team&lt;/emph></author>
<!-- the following start the copy right page -->
    <para>This file documents the MonetDB Version 5.0 Reference Manual</para>
    <para>Last updated: April 27, 2006</para>
    <para>Copyright (C) 2000-2006 CWI</para>
    <para>Permission is granted to make and distribute verbatim      copies of this manual provided the copyright notice and      this permission notice are preserved on all copies.</para>
  </titlepage>
  <node>
    <nodename>Top</nodename>
    <nodenext>General Introduction</nodenext>
    <nodeup>(Dir)</nodeup>
    <unnumbered>
      <title>MonetDB Reference Manual</title>
      <para>This file documents the MonetDB Version 5.0 Reference Manual</para>
      <para>Last updated: April 27, 2006</para>
     
      <para>Copyright (C) 2000-2006 CWI</para>
     
      <para>Permission is granted to make and distribute verbatim      copies of this manual provided the copyright notice and      this permission notice are preserved on all copies.</para>
      <menu>
        <menuentry>
          <menunode>General Introduction</menunode>
          <menutitle>General Introduction</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Intended audience</menunode>
          <menutitle>Intended audience</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Features and Limitations</menunode>
          <menutitle>Features and Limitations</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Download and Installation</menunode>
          <menutitle>Download and Installation</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>MonetDB Overview</menunode>
          <menutitle>MonetDB Overview </menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Development Roadmap</menunode>
          <menutitle>Development Roadmap</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>SQL</menunode>
          <menutitle>SQL </menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>XQuery</menunode>
          <menutitle>XQuery </menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>User Interfaces</menunode>
          <menutitle>User Interfaces</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Programming Interfaces</menunode>
          <menutitle>Programming Interfaces</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Embedded MonetDB</menunode>
          <menutitle>Embedded MonetDB</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>MonetDB Assembler Language</menunode>
          <menutitle>MonetDB Assembler Language</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>MAL Modules</menunode>
          <menutitle>MAL Modules</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>MAL interpreter</menunode>
          <menutitle>MAL interpreter</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Optimizer landscape</menunode>
          <menutitle>Optimizer landscape</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Optimizer toolkit</menunode>
          <menutitle>Optimizer toolkit</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Program Debugging</menunode>
          <menutitle>Program Debugging</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Execution Profiling</menunode>
          <menutitle>Execution Profiling</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>MonetDB Extension Modules</menunode>
          <menutitle>MonetDB Extension Modules </menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>MonetDB BAT Kernel</menunode>
          <menutitle>MonetDB BAT Kernel </menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Advanced Topics</menunode>
          <menutitle>Advanced Topics</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Appendices</menunode>
          <menutitle>Appendices</menutitle>
          <menucomment></menucomment>
        </menuentry>
      </menu>
    </unnumbered>
  </node>
  <node>
    <nodename>General Introduction</nodename>
    <nodenext>Intended audience</nodenext>
    <nodeprev>Top</nodeprev>
    <nodeup>Top</nodeup>
    <chapter>
      <title>General Introduction</title>
      <para>The MonetDB reference manual serves as the primary entry point to locate information on its functionality, system architecture, services, and best practices on using its components.</para>
      <para>The manual is focussed on the features available in Version 5. Users of previous versions may benefit from the sections on e.g. SQL and the inner core of the system, because these components are shared with Version 4.</para>
      <para>The manual is produced from a Texinfo framework file, which collects and organizes bits-and-pieces of information scattered around the many source components comprising the MonetDB software family. The Texinfo file is turned into a HTML browse-able version using <emph>makeinfo</emph> program. It can also be used to produce a Postscript version using <emph>tex2dvi</emph> followed by <emph>dvips</emph>. The PDF version can be produced from the Postscript using <emph>ps2pdf</emph>. Alternative formats, e.g. XML and DocBook format, can be readily obtained from the Texinfo file.</para>
      <para>The copyright(2006) on the MonetDB software, documentation, and logo is owned by CWI. Other trademarks and copyrights referred to in this manual are the property of their respective owners.</para>
      <para><emph>Disclaimer</emph> The reference manual is still under development, much like the underlying source code base. This may lead to incomplete and inconsistencies descriptions, for which we apologize in advance. You can help improving the manual using the mailing list included in the website.</para>
      <menu>
        <menuentry>
          <menunode>Intended audience</menunode>
          <menutitle>Intended audience</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Get Going</menunode>
          <menutitle>Get Going</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Features and Limitations</menunode>
          <menutitle>Features and Limitations</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>The History of MonetDB</menunode>
          <menutitle>The History of MonetDB</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Manual Generation</menunode>
          <menutitle>Manual Generation</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Software Versions</menunode>
          <menutitle>Software Versions</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Conventions and Notation</menunode>
          <menutitle>Conventions and Notation</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Additional Resources</menunode>
          <menutitle>Additional Resources</menutitle>
          <menucomment></menucomment>
        </menuentry>
      </menu>
    </chapter>
  </node>
  <node>
    <nodename>Intended audience</nodename>
    <nodenext>Get Going</nodenext>
    <nodeprev>General Introduction</nodeprev>
    <nodeup>Top</nodeup>
    <section>
      <title>Intended Audience</title>
      <para>The MonetDB reference manual is aimed at application developers and researchers with an intermediate level exposure to database technology, its embedding in host environments, such as C, Perl, Python, PHP, or middleware solutions based on JDBC and ODBC.</para>
      <para>The route towards becoming a database application expert is long and tedious. It requires building experiences from small toy examples towards large business critical application. The MonetDB reference manual is not designed for this purpose, but in combination with the abundance of tutorial articles on SQL-based systems, it should be possible to quickly create your first working MonetDB/SQL application.</para>
      <para>The bulk of the MonetDB reference manual deals with the techniques deployed in the back-end for the expert user and researcher. Judicious use of the programming interfaces and database kernel modules for domain specific tasks lead to high-performance solutions. The grand challenge for the MonetDB development team is to assemble a sufficient and orthogonal set of partial solutions to accomodate a wide variety of front-ends.</para>
      <para>Feedback on the current set is highly appreciated, especially before you embark on a complex programming project. If the envisioned functionality is generally applicable it makes sense to contribute it to the community. Share your comments, thoughts, and comments through the <uref><urefurl>mailto:monetdb-users@lists.sourceforge.net</urefurl><urefdesc>MonetDB mailing list</urefdesc></uref> held at SourceForge.</para>
    </section>
  </node>
  <node>
    <nodename>Get Going</nodename>
    <nodenext>Features and Limitations</nodenext>
    <nodeprev>Intended audience</nodeprev>
    <nodeup>General Introduction</nodeup>
    <section>
      <title>How to Read This Manual</title>
      <para>The reference manual covers a lot of ground, which at first reading may be slightly confusing. The material is presented in a top-down fashion. Starting at installing the system components, SQL and the application interface layer, it discusses the MAL software stack at length. Forward references are included frequently to point into the right direction for additional information.</para>
      <para>First time users of MonetDB should read <xref><xrefnodename>Download and Installation</xrefnodename></xref> and <xref><xrefnodename>SQL</xrefnodename></xref>. It prepares the ground to develop applications. Advanced topics for application builders are covered in <xref><xrefnodename>User Interfaces</xrefnodename></xref>.</para>
      <para>The query language <xref><xrefnodename>XQuery</xrefnodename></xref> is intended for users living at the edge of technology. It provides a functional complete implementation of the XQuery and Xupdate standard. Unfortunately, XQuery compiler is currently only available for MonetDB Version 4.</para>
      <para>If you are interested in technical details of the MonetDB system, you should start reading <xref><xrefnodename>MonetDB Overview</xrefnodename></xref>. Two reading  tracks are possible. The <xref><xrefnodename>MonetDB Assembler Language</xrefnodename></xref> and subsequent sections describe the abstract machine and MAL optimizers to improve execution speed. It is relevant for a better understanding of the query processing behavior and provides an entry point to built new languages on top of the database kernel. The tutorial on SQL to MAL compilation provides a basis for developing your own language front-end.</para>
      <para>The second track, The Inner Core describes the datastructures and operations exploited in the abstract machine layer. This part is essential for developers to aid in bug fixing and to extend the kernel with new functionality. Its information covers also the ground for MonetDB Version 4. For most readers, however, it can be skipped without causing problems to develop efficient applications.</para>
    </section>
  </node>
  <node>
    <nodename>Features and Limitations</nodename>
    <nodenext>When to consider MonetDB</nodenext>
    <nodeprev>Get Going</nodeprev>
    <nodeup>Top</nodeup>
    <section>
      <title>Features and Limitations</title>
      <para>In this section we give a short overview of the key features to (not) consider the MonetDB product family. In a nutshell, its origin in the area of data-mining and data-warehousing makes it an ideal choice for high volume, complex query dominant applications. MonetDB was not designed for high-volume secure OLTP settings initially.</para>
      <para>It is important to recognize that the MonetDB language interfaces are primarily aimed at experienced system programmers and administrators. End-users are advised to use any of the open-source graphical SQL workbenches to interact with the system. (Sec <xref><xrefnodename>User Interfaces</xrefnodename></xref>)</para>
      <menu>
        <menuentry>
          <menunode>When to consider MonetDB</menunode>
          <menutitle>When to consider MonetDB</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>When not to consider MonetDB</menunode>
          <menutitle>When not to consider MonetDB</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>What are the MonetDB key features</menunode>
          <menutitle>What are the MonetDB key features</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Size limitations for MonetDB</menunode>
          <menutitle>Size limitations for MonetDB</menutitle>
          <menucomment></menucomment>
        </menuentry>
      </menu>
    </section>
  </node>
  <node>
    <nodename>When to consider MonetDB</nodename>
    <nodenext>When not to consider MonetDB</nodenext>
    <nodeprev>Features and Limitations</nodeprev>
    <nodeup>Features and Limitations</nodeup>
    <subsection>
      <title>When to consider MonetDB ?</title>
      <para><strong>A high-performance database management system.</strong> MonetDB is an easy accessible open-source DBMS for SQL-[XQuery-]based applications and database research projects. Its origin goes back over a decade, when we decided that the database hotset - the part used by the applications - can be largely held in main-memory or where a few columns of a broad relational table are sufficient to handle a request. Further exploitation of cache-conscious algorithms proved the validity of these design decisions.</para>
      <para><strong>A multi-model system.</strong> MonetDB supports multiple query language front-ends. Aside from its proprietary language, called the MonetDB Assembler Language (MAL), it supports ANSI SQL-99 and W3C XQuery. Their underlying logical data model and computational scheme differs widely. The system is designed to provide a common ground for both languages and it is prepared to support languages based on yet another data model or processing paradigm.</para>
      <para><strong>A binary-relation database kernel.</strong> MonetDB is built on the canonical representation of database containers, namely binary relations. The datastructures are geared towards efficient representation when they mimic a n-ary relational scheme.</para>
      <para>This led to an architecture where the traditional page-pool is replaced by one with a much larger granularity, called Binary Association Tables (BATs). They are sizeable entities -up to hundreds of megabytes- swapped into memory upon need. The benefit of this approach has been shown in numerous papers in the scientific literature.</para>
      <para><strong>A broad spectrum database system.</strong> MonetDB is continuously developed to support a broad application field. Although originally developed for Analytical CRM products, it is now being used at the low-end scale as an embedded relational kernel and projects are underway to tackle the huge database problems encountered in science, e.g. astronomy.</para>
      <para><strong>An extendable database system.</strong> MonetDB has been strongly influenced by the scientific experiments to understand the interplay between algorithms and hardware features. It has turned MonetDB into an extensible database system for software experts. It proofs valuable in those cases where an application specific and critical component makes all the difference between slow and fast implementation.</para>
      <para><strong>An opensource software system.</strong> MonetDB has been developed over many years of research at <uref><urefurl>http://monetdb.cwi.nl/</urefurl><urefdesc>CWI</urefdesc></uref>, whose charter ensures that results are easily accessible to others. Be it through publication in the scientific domain or publication of the software components involved. The MonetDB users mailing list is the access point to a larger audience for advice. A subscription to the mailing list helps the developer team to justify the on-and-off office hours put into MonetDB's development and maintenance.</para>
    </subsection>
  </node>
  <node>
    <nodename>When not to consider MonetDB</nodename>
    <nodenext>What are the MonetDB key features</nodenext>
    <nodeprev>When to consider MonetDB</nodeprev>
    <nodeup>Features and Limitations</nodeup>
    <subsection>
      <title>When not to consider MonetDB ?</title>
      <para>There are several areas where MonetDB has not yet built a reputation. They are the prime candidates for experimentation, but also areas where application construction may become risky. More mature products may then provide a short-term solution, while MonetDB programmers team works on filling the functional gaps. The following areas should be considered with care:</para>
      <para><strong>Persistent object caches.</strong> The tendency to develop applications in Java and C/C++ based on a persistent object model, is a no-go area for MonetDB. Much like the other database engines, the overhead involved in individual record access does not do justice to the data structures and algorithms in the kernel. They are chosen to optimize bulk processing, which always comes at a price for individual object access.</para>
      <para>Nevertheless, MonetDB has been used from its early days in a commercial application, where the programmers took care in maintaining the Java object-cache. It is a route with great benefits, but also one where sufficient manpower should be devoted to perform a good job.</para>
      <para><strong>High-performance financial OLTP.</strong> MonetDB was originally not designed for highly concurrent transaction workloads. For one reason it was decided to factor out the ACID techniques and make them explicit in the query plans generated by the front-end compilers. Given the abundance of main memory nowadays and the slack CPU cycles to process database requests, it may be profitable to consider serial execution of OLTP transactions.</para>
      <para>The SQL implementation provides full transaction control and recovery.</para>
      <para><strong>Security.</strong> MonetDB has not been designed with a strong focus on security. The major precautions have been taken, but are incomplete when access to the hosting machine is granted or when direct access is granted to the Monet Assembler Language features. The system is preferably deployed in a sand-boxed environment where remote access is encapsulated in a dedicated application framework.</para>
      <para><strong>Scaling over multiple machines.</strong> MonetDB does not provide a centralized controlled, distributed database infrastructure yet. Instead, we move towards an architecture where multiple autonomous MonetDB instances are joining together to process a large and distributed workload.</para>
      <para>In the multimedia applications we have exploited successfully the inherent data parallelism to speedup processing and reduce the synchronization cost. The underlying platforms were Linux-based cluster computers with sizeable main memories.</para>
    </subsection>
  </node>
  <node>
    <nodename>What are the MonetDB key features</nodename>
    <nodenext>Size limitations for MonetDB</nodenext>
    <nodeprev>When not to consider MonetDB</nodeprev>
    <nodeup>Features and Limitations</nodeup>
    <subsection>
      <title>What are the MonetDB key features</title>
      <para>The list below provides a glimpse on the technical characteristics and features of the MonetDB software packages. For the SQL front-end:</para>
      <itemize>
        <itemfunction><bullet/></itemfunction>
        <item>
          <para>It is based on the SQL'99 standard core.</para>
        </item>
        <item>
          <para>It supports nested queries.</para>
        </item>
        <item>
          <para>It supports views.</para>
        </item>
        <item>
          <para>It supports sequence types from the SQL'03 standard.</para>
        </item>
      </itemize>                                          
      <para>For the XQuery front-end:</para>
      <itemize>
        <itemfunction><bullet/></itemfunction>
        <item>
          <para>The W3C XQuery standard is fully implemented.</para>
        </item>
        <item>
          <para>The XUpdate draft standard is being implemented.</para>
        </item>
      </itemize>
      <para>The software characteristics for the MonetDB packages are:</para>
      <itemize>
        <itemfunction><bullet/></itemfunction>
        <item>
          <para>The kernel source code is written in ANSI-C and POSIX compliant.</para>
        </item>
        <item>
          <para>The application interface libraries source code complies with in the latest language versions.</para>
        </item>
        <item>
          <para>The source code is written in a literate programming style, to stimulate proximity of code and its documentation.</para>
        </item>
        <item>
          <para>The source code is compiled and tests on many platforms with different compiler options to ensure portability.</para>
        </item>
        <item>
          <para>The source code is based on the GNU toolkit, e.g. Automake, Autoconf, and Libtool for portability.</para>
        </item>
        <item>
          <para>The source code is heavily tested on a daily basis, and scrutinized using the <uref><urefurl>"http://www.valgrind.org"</urefurl><urefdesc>Valgrind</urefdesc></uref> toolkit.</para>
        </item>
      </itemize>
      <para>The heart is the MonetDB server, which comes with the following innovative features.</para>
      <itemize>
        <itemfunction><bullet/></itemfunction>
        <item>
          <para>A fully decomposed storage scheme using memory mapped files.</para>
        </item>
        <item>
          <para>It supports scalable databases, 32- and 64-bit platforms.</para>
        </item>
        <item>
          <para>Connectivity is provided through TCP/IP sockets on many platforms.</para>
        </item>
        <item>
          <para>Index selection, creation, and maintenance is automatic.</para>
        </item>
        <item>
          <para>The relational operators materialize their results and are self-optimizing.</para>
        </item>
        <item>
          <para>The operations are cache- and memory-aware with supreme performance.</para>
        </item>
        <item>
          <para>The database backend is multi-threaded and guards a single physical database instance.</para>
        </item>
      </itemize>
    </subsection>
  </node>
  <node>
    <nodename>Size limitations for MonetDB</nodename>
    <nodenext>The History of MonetDB</nodenext>
    <nodeprev>What are the MonetDB key features</nodeprev>
    <nodeup>Features and Limitations</nodeup>
    <subsection>
      <title>Size limitations for MonetDB</title>
      <para>The maximal database size supported by MonetBD depends on the underlying processing platform, i.e. a 32- or 64-bit processor, and storage device, i.e. the file system and disk raids.</para>
<!-- table spaces -->
      <para>The number of columns per tables is practically unlimited. Unlike traditional database systems, the storage space limitation depend on the maximal size for an individual column. Each column is mapped to a file, whose limit is dictated by the operating system and hardware platform.</para>
<!-- concurrency -->
      <para>The number of concurrent user threads is a configuration parameter.</para>
<!-- platform -->
    </subsection>
  </node>
  <node>
    <nodename>The History of MonetDB</nodename>
    <nodenext>Manual Generation</nodenext>
    <nodeprev>Size limitations for MonetDB</nodeprev>
    <nodeup>General Introduction</nodeup>
    <section>
      <title>A Brief History of MonetDB</title>
      <para><strong>The Dark Ages [1979-2002]</strong> The development of the MonetDB software family goes back as far as the early eighties when the first relational kernel, called Troll, was delivered to a larger audience. It was spread over ca 1000 sites world-wide and became part of a software case-tool until the beginning of the nineties. 
<!-- not very comprehensive (what? until the beginning of the 90s?) -->None of the code of this system has survived, but several ideas and experiences on how to obtain a fast kernel by simplification and explicit materialization found their origin during this period.</para>
      <para>The second part of the eighties was spent on building the first distributed main-memory database system in the context of the 
<!-- main-memory vs. main memory ?? should do a grep on both -->
<!-- throughout the documentation and make the spelling consistent -->national project PRISMA. A fully functional system of 100 processors and a wealthy 1GB of main memory showed the road to develop database technology from a different perspective. A more detailed account on the experiences can be found in REF.</para>
      <para><strong>The Early Days [1993-1995]</strong> Immediately after the PRISMA project was termed dead, the basis for a new database kernel based on Binary Association Tables (BATs) was laid out. The original target was to aim for better support of scientific databases with their then archaic file structures.</para>
      <para><strong>The Data Distilleries Era [1996-2003]</strong> The datamining projects running as of 1993 called for better database support. It culminated in the spin-off Data Distilleries, which based their analytical customer relationship suite on the power provided by the early MonetDB implementations. In the years following, many technical innovations were paired with strong industrial maturing of the software base.</para>
      <para><strong>The Open-Source Challenge [2003-2006]</strong> Moving MonetDB Version 4 into the open-source field required a large number of extensions to the code base. It became utmost important to support a mature implementation of the SQL99 standard, and the bulk of application programming interfaces (PHP,JDBC,Perl,ODBC). The culprit of this activity was the first official release in 2004 and the release of the XQuery front-end in 2005.</para>
      <para><strong>The Road Ahead [2006-</strong> This manual marks the alpha-release of MonetDB Version 5, the result of a multi-year activity to clean up the software stack and to better support for simple database requests. (See <xref><xrefnodename>Backward Compatibility</xrefnodename></xref>)</para>
      <para><strong>The future: X100, Armada</strong> New versions in the MonetDB software family are under development. Extensions and renovation of the kernel are tackled in the X100 project, which provides high-volume access to columns stored in compressed form. Its volcano-style interpreter aims to provide performance in I/O-dominant and streaming settings using vectorized processing and Just-In-Time (de)compression.</para>
      <para>The scene of distributed database is (again) addressed in the Armada project, but not using the traditional centralized administration focus. Instead the Armada project seeks the frontiers of autonomous database systems, which still provide a coherent functional view to its users. In its approach it challenges many dogmas in distributed database technology, such as the perspective on global consistency, the role of the client in managing the distributed world, and the way resources are spread.</para>
      <para>The MonetDB software framework provides a rich setting to pursue these allees of database research. We hope that many may benefit from our investments, both research and business wise.</para>
    </section>
  </node>
  <node>
    <nodename>Manual Generation</nodename>
    <nodenext>Conventions and Notation</nodenext>
    <nodeprev>The History of MonetDB</nodeprev>
    <nodeup>General Introduction</nodeup>
    <section>
      <title>Manual Generation</title>
      <para>The MonetDB code base is large collection of files, scattered over the system modules. Each source file is written in a literal programming style, which physically binds documentation with the relevant code sections. The utility program Mx processes the files marked *.mx to extract the code sections for system compilation or to prepare for a pretty printed listing.</para>
      <para>The reference manual is based on <emph>Texinfo</emph> formatted documentation to simplify generation for different rendering platforms. The components for the reference manual are extracted by</para>
      <example xml:space="preserve">Mx -i -B -H1 &lt;filename&gt;.mx</example>
      <para>which generates the file &lt;filename&gt;.bdy.texi. These pieces are collected and glued together in a manual framework, running <emph>makeinfo</emph> to produce the desired output format. The <emph>Texinfo</emph> information is currently limited to the documentation, it could also be extended to also process the code.</para>
      <para>A printable version of an *.mx file can be produced using the commands:</para>
      <example xml:space="preserve">Mx  &lt;filename&gt;.mx
pdflatex &lt;filename&gt;.tex</example>
      <para>The result, however, still includes the unexpanded tex info macros.</para>
    </section>
  </node>
  <node>
    <nodename>Conventions and Notation</nodename>
    <nodenext>Additional Resources</nodenext>
    <nodeprev>Manual Generation</nodeprev>
    <nodeup>General Introduction</nodeup>
    <section>
      <title>Conventions and Notation</title>
      <para>The  typographical conventions used in this manual are straightforward. <code>Monospaced</code> text is used to designate names in the code base and examples. <emph>Italics</emph> is used in explanations to indicate where a user supplied value should be substituted.</para>
      <para>Snippets of code are illustrated in verbatim font. The interaction with textual client interfaces uses the default prompt-setting of the underlying operating system.</para>
      <para>Keywords in the MonetDB interface languages are key sensitive; SQL keywords are not case sensitive. No distinction is made in this manual.</para>
    </section>
  </node>
  <node>
    <nodename>Additional Resources</nodename>
    <nodenext>Download and Installation</nodenext>
    <nodeprev>Conventions and Notation</nodeprev>
    <nodeup>General Introduction</nodeup>
    <section>
      <title>Additional Resources</title>
      <para>Although this reference manual aims to be complete for developing applications with MonetDB, it also depends on additional resources for a full understanding.</para>
      <para>This reference manual relies on external documentation for the basics of its query languages SQL, XQuery, its application interfaces, PHP, Perl, Pyhton, and its middleware support, JDBC and ODBC. Examples are used to illustrate their behaviour in the context of MonetDB only. The resource locations identified below may at times proof valuable.</para>
      <multitable>
        <columnfraction>9</columnfraction>
        <columnfraction>27</columnfraction>
        <tbody>
          <row>
            <entry>Perl DBI</entry>
            <entry><uref><urefurl>http://www.perl.org/</urefurl><urefdesc>http://www.perl.org/</urefdesc></uref></entry>
          </row>
          <row>
            <entry>PHP5</entry>
            <entry><uref><urefurl>http://www.php.net/</urefurl><urefdesc>http://www.php.net/</urefdesc></uref></entry>
          </row>
          <row>
            <entry>Python</entry>
            <entry><uref><urefurl>http://www.python.org/</urefurl><urefdesc>http://www.python.org/</urefdesc></uref></entry>
          </row>
          <row>
            <entry>XQuery</entry>
            <entry><uref><urefurl>http://wwww.w3c.org/TR/xquery/</urefurl><urefdesc>http://wwww.w3c.org/TR/xquery/</urefdesc></uref></entry>
          </row>
        </tbody>
      </multitable>
      <para>The primary source for additional information is the MonetDB website, <uref><urefurl>http://monetdb.cwi.nl/</urefurl><urefdesc>http://monetdb.cwi.nl/</urefdesc></uref>, and the code base itself.  Information on the background of its architecture can be found in the library of scientific publications.</para>
    </section>
  </node>
  <node>
    <nodename>Download and Installation</nodename>
    <nodenext>Software Versions</nodenext>
    <nodeprev>Additional Resources</nodeprev>
    <nodeup>Top</nodeup>
    <section>
      <title>Downloads and Installation</title>
      <para>Using MonetDB for experimentation and application development requires installation of the back-end server, a front-end compiler for SQL or XQuery, the APIs, and a (graphical) user interface. These components are packaged conveniently for several platforms in the <uref><urefurl>http://sourceforge.net/project/showfiles.php?group_id=56967</urefurl><urefdesc>download</urefdesc></uref> section at SourceForge.</para>
      <para>Most people prefer a standard distribution, `officially' declared as stable. Stable means that special care has been taken to assure that errors reported during the nightly builds have been solved on the platforms of interest. Major bug fixes are also applied to the latest stable version, while functional enhancements are kept for the next release or the daily builds.</para>
      <para>If you encounter errors during the installation, please have a look at the <uref><urefurl>http://monetdb.cwi.nl/GetGoing/Trouble/FAQ/index.html</urefurl><urefdesc>FAQ</urefdesc></uref> and <uref><urefurl>mailto:monetdb-users@lists.sourceforge.net</urefurl><urefdesc>MonetDB mailing list</urefdesc></uref> for common errors and some advice on how to proceed.</para>
      <menu>
        <menuentry>
          <menunode>Software Versions</menunode>
          <menutitle>Software Versions </menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Standard Distribution</menunode>
          <menutitle>Standard Distribution</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Source Distribution</menunode>
          <menutitle>Source Distribution</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Start and Stop the Server</menunode>
          <menutitle>Start and Stop the Server</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Database Configuration</menunode>
          <menutitle>Database Configuration </menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Checkpoint and Recovery</menunode>
          <menutitle>Checkpoint and Recovery </menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Database Dumps</menunode>
          <menutitle>Database Dumps </menutitle>
          <menucomment></menucomment>
        </menuentry>
      </menu>
    </section>
  </node>
  <node>
    <nodename>Software Versions</nodename>
    <nodenext>Standard Distribution</nodenext>
    <nodeprev>Download and Installation</nodeprev>
    <nodeup>General Introduction</nodeup>
    <subsection>
      <title>Software Versions</title>
      <para>The MonetDB product family consists of several related packages. At the time of writing Version 4.10 is distributed through <uref><urefurl>http://sourceforge.net/projects/monetdb</urefurl><urefdesc>SourceForge</urefdesc></uref>. It comes with the SQL version 2.10 and PathFinder 0.10 front-ends packages.</para>
      <para>This manual, however, is written in the context of preparing the launch of MonetDB Version 5. It works with the SQL version 2.10, but there is currently no XQuery front-end available.</para>
<!-- software portability issues -->
      <para>From its inception, the MonetDB software has been designed to meet the highest level of standards regarding software portability. The interface to the operating system is based on the POSIX standard. The default C-compilation options are strict, considering all compiler warnings as fatal. String and memory manipulation are all guarded against overflows. This with multi-year deployment in a commercial setting makes the code base robust.</para>
<!-- what are the platforms supported -->
      <para>Thanks to the GNU tools <code>autoconf</code>  and <code>automake</code> tools, the MonetDB software runs on a wide variety of hardware/software platforms. A summary of those operating systems and the compiler toolkits is shown below.</para>
      <multitable>
        <columnfraction>25</columnfraction>
        <columnfraction>10</columnfraction>
        <columnfraction>70</columnfraction>
        <thead>
          <row>
            <entry>Operating System</entry>
            <entry>Word size</entry>
            <entry>Compilers</entry>
          </row>
        </thead>
        <tbody>
          <row>
            <entry>Microsoft</entry>
            <entry>32 bits</entry>
            <entry>XP, Server 2003</entry>
          </row>
          <row>
            <entry>Cygwin (Windows)</entry>
            <entry>32 bits</entry>
            <entry>GNU</entry>
          </row>
          <row>
            <entry>Gentoo (Linux 2.6.14)</entry>
            <entry>32 bits</entry>
            <entry>GNU</entry>
          </row>
          <row>
            <entry>Fedora Core  4</entry>
            <entry>64 bits</entry>
            <entry>GNU, Intel</entry>
          </row>
          <row>
            <entry>Fedora Core 3</entry>
            <entry>64 bits</entry>
            <entry>GNU, Intel</entry>
          </row>
          <row>
            <entry>RedHat EL WS</entry>
            <entry>64 bits</entry>
            <entry>GNU, Intel</entry>
          </row>
          <row>
            <entry>Debian 3.0</entry>
            <entry>64 bits</entry>
            <entry>GNU, PGI</entry>
          </row>
          <row>
            <entry>Suse 9.3</entry>
            <entry>64 bits</entry>
            <entry>GNU, Intel</entry>
          </row>
          <row>
            <entry>MacOS X 10.4 (Darwin 8.2.0)</entry>
            <entry>32 bits</entry>
            <entry>GNU</entry>
          </row>
          <row>
            <entry>AIX 5.1</entry>
            <entry>32 bits</entry>
            <entry>GNU, IBM</entry>
          </row>
          <row>
            <entry>IRIX 64 6.5</entry>
            <entry>32,64 bits</entry>
            <entry>GNU, SGI</entry>
          </row>
          <row>
            <entry>Solaris 8 (SunOS 5.8)</entry>
            <entry>32,64 bits</entry>
            <entry>GNU, Sun</entry>
          </row>
          <row>
            <entry>OpenZaurus</entry>
            <entry>32 bits</entry>
            <entry>GNU (cross)</entry>
          </row>
          <row>
            <entry>Gumstix</entry>
            <entry>32 bits</entry>
            <entry>GNU (cross)</entry>
          </row>
          <row>
            <entry>LinkStation</entry>
            <entry>32 bits</entry>
            <entry>GNU (cross)</entry>
          </row>
        </tbody>
      </multitable>
      <para>The MonetDB development team uses many of these platforms to perform automated nightly regression testing. For more details see pxref(The Test Web).</para>
    </subsection>
  </node>
  <node>
    <nodename>Standard Distribution</nodename>
    <nodenext>Source Distribution</nodenext>
    <nodeprev>Software Versions</nodeprev>
    <nodeup>Download and Installation</nodeup>
    <subsection>
      <title>Standard Distribution</title>
      <para>The standard distribution is meant for users primarilly interesting in building SQL or XQuery applications. They should obtain the pre-packaged binary distribution from the <uref><urefurl>http://sourceforge.net/project/showfiles.php?group_id=56967</urefurl><urefdesc>download</urefdesc></uref> section at SourceForge. The system can be installed in a private directory for experimentation or in the Linux/Windows compliant default folder location.</para>
      <para>The choice between Version 4.9 and 5.0 should be planned carefully. Both engines provide the same SQL functionality, but differ greatly under the hood. Version 4.9 is based on the MIL scripting language, which is known to be slow, and provides limited support for query optimization and program development (e.g. a debugger). The MIL language becomes depreciated as soon as the XQuery compiler has been ported. Contrary, Version 5.0 provides an assembler like scripting language, geared at supporting front-end apllication code generation. It is not a language for programmers to write their applications on a daily basis. This simplicity greatly enhances the parsing and interpretation performance. Especially, small SQL queries run more than twice as fast. For more details see <xref><xrefnodename>Design considerations</xrefnodename></xref></para>
      <para>The MonetDB code base evolves quickly with daily builds available for users preferring living at the edge. Application developers, however, may tune into the <uref><urefurl>mailto:monetdb-users@lists.sourceforge.net</urefurl><urefdesc>MonetDB mailing list</urefdesc></uref> to be warned when a major release has become available, or when detected errors require a patch.</para>
      <para>Before you embark upon application development, take the quick tour from the tutorial section. It illustrates a small, but concrete application scenario geared at querying a historical database with trading trips of the world-famous East-Indian Trading Corp (1602-1795).</para>
    </subsection>
  </node>
  <node>
    <nodename>Source Distribution</nodename>
    <nodenext>Linux Installation</nodenext>
    <nodeprev>Standard Distribution</nodeprev>
    <nodeup>Download and Installation</nodeup>
    <subsection>
      <title>Source Distribution</title>
      <para>The source distribution is needed if you intend to inspect or extend the code base. The source distribution comes with the complete test-bench to assure that changes do not affect (in as far as they get tested) its stability. A single stable release is maintained for external users while we concurrently work on the next release. Older versions are not actively maintained by the development team.</para>
      <para>Set up of a fully functional system requires downloading a MonetDB server package and either/both the SQL and XQuery packages. The steps to be taken are described for installing the server only, because installing the other packages largely follow the same steps. The deviances are explained at the end of this section.</para>
      <para>The development version can be obtained from the CVS repository at SourceForge. You have to login to the CVS server first:</para>
      <verbatim xml:space="preserve"><![CDATA[
cvs -d:pserver:anonymous@cvs.sourceforge.net:/cvsroot/monetdb login
]]></verbatim>
      <para>Just type RETURN when asked for the password. Then get the MonetDB and SQL module sources by using the command:</para>
      <verbatim xml:space="preserve"><![CDATA[
cvs -d:pserver:anonymous@cvs.sourceforge.net:/cvsroot/monetdb co buildtools MonetDB5 sql
]]></verbatim>
      <para>This will create the directories buildtools, MonetDB5 and sql in your current working directory, which hold the sources for all three project packages. See the readme file to install the buildtools. MonetDB developers should use <code>ext</code> instead of <code>pserver</code>, e.g.</para>
      <verbatim xml:space="preserve"><![CDATA[
cvs -d :ext:<username>@cvs.sf.net:/cvsroot/monetdb checkout MonetDB5 sql
]]></verbatim>
      <para>Also see <uref><urefurl>http://sourceforge.net/cvs/?group_id=56967</urefurl><urefdesc>SourceForge documentation</urefdesc></uref> for more information on using cvs.</para>
      <menu>
        <menuentry>
          <menunode>Linux Installation</menunode>
          <menutitle>Linux Installation </menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Windows Installation</menunode>
          <menutitle>Windows Installation </menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Gentoo Installation</menunode>
          <menutitle>Gentoo Installation </menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Daily Builds</menunode>
          <menutitle>Daily Builds </menutitle>
          <menucomment></menucomment>
        </menuentry>
      </menu>
    </subsection>
  </node>
  <node>
    <nodename>Linux Installation</nodename>
    <nodenext>Windows Installation</nodenext>
    <nodeprev>Source Distribution</nodeprev>
    <nodeup>Source Distribution</nodeup>
    <subsection>
      <title>Linux Installation</title>
      <para>This section helps you to install the MonetDB source and compile it on a Unix platform (e.g., Linux, MacOS X/Darwin, or CYGWIN).</para>

      <subsubsection>
        <title>Prerequisites</title>
        <itemize>
          <itemfunction><bullet/></itemfunction>
          <item>
            <para><emph>CVS</emph> You only need this if you are building from CVS. If you start with the source distribution from SourceForge you don't need CVS. For instructions, see <uref><urefurl>http://sourceforge.net/docman/?group_id=1</urefurl><urefdesc>docman</urefdesc></uref> and look under the heading CVS Instructions.</para>
          </item>
          <item>
            <para><emph>Python</emph> MonetDB uses Python (version 2.0.0 or better) during configuration of the software. See <uref><urefurl>http://www.python.org/</urefurl><urefdesc>python.org</urefdesc></uref> for more information.</para>
          </item>
          <item>
            <para><emph>autoconf/automake/libtool</emph> MonetDB uses GNU <uref><urefurl>http://www.gnu.org/software/autoconf/</urefurl><urefdesc>autoconf</urefdesc></uref> (&gt;= 2.53), <uref><urefurl>http://www.gnu.org/software/automake/</urefurl><urefdesc>automake</urefdesc></uref> (&gt;= 1.5), and <uref><urefurl>http://www.gnu.org/software/libtool/</urefurl><urefdesc>libtool</urefdesc></uref> (&gt;= 1.4) during configuration of the software. Libtool is also used during the build.</para>
          </item>
          <item>
            <para><emph>standard software development tools</emph> To compile MonetDB, you also need to have a the following standard software development tools installed and ready for use on you system:</para>
            <itemize>
              <itemfunction><bullet/></itemfunction>
              <item>
                <para>a C/C++ compiler (e.g., GNU's gcc/g++)&lt;/li&gt;</para>
              </item>
              <item>
                <para>a lexical analyzer generator (e.g., "lex" or "flex")&lt;/li&gt;</para>
              </item>
              <item>
                <para>a parser generator (e.g., "yacc" or "bison")&lt;/li&gt;</para>
              </item>
              <item>
                <para>GNU make ("gmake") (native make's on, e.g., IRIX and Solaris usually don't work).</para>
              </item>
            </itemize>     
          </item>
          <item>
            <para>Mx, mel, and autogen These tools are only needed if you are building from CVS. If you start with the source distribution from SourceForge you don't need this.</para>
          </item>
          <item>
            <para><emph>disk space</emph> After downloading, MonetDB takes up about 40 MB of disk space; compilation adds another 70 MB.  Testing takes about 45 MB, and the installation about 20 MB (not including any databases).</para>
          </item>
        </itemize>
      </subsubsection>

      <subsubsection>
        <title>Bootstrap, Configure and Make</title>
        <para>Before executing the following steps, make sure that your shell-environment (especially variables like "PATH" and "LD_LIBRARY_PATH") is setup, thus that the tools listed above can be found. 
<!-- ("Bash"-users are welcome to simply "source conf/conf.bash". -->
<!-- This sets the proper environment and even provides aliases -->
<!-- "configure_MonetDB" &amp; "Mtest_MonetDB" for convenience. -->
<!-- See conf/conf.bash itself for more details.) --> In the top-level directory of MonetDB type the command:</para>
        <example xml:space="preserve">./bootstrap</example>
        <para>Then in any directory (preferably a *new empty* directory and *not* in the MonetDB top-level directory) give the command</para>
        <example xml:space="preserve">&lt;path-to&gt;/configure [&lt;options&gt;]</example>
        <para>where <code>&lt;path-to&gt;</code> is replaced with the (absolute or relative) path to the MonetDB top-level directory. The directory where you execute configure is the place where all intermediate source and object files are generated during compilation via "make".</para>
        <para>By default, MonetDB is eventually (i.e., during "make install"; see below) installed to /usr/local/.  To choose another target directory, you need to call</para>
        <example xml:space="preserve">.../configure --prefix=&lt;prefixdir&gt; [&lt;options&gt;]</example>
        <para>A sample of other useful configure options is:</para>
        <example xml:space="preserve">--enable-debug 		 enable full debugging default=off
--enable-optimize 		 enable extra optimization default=off
--enable-warning 		 enable extended compiler warnings default=off
--enable-profile 		 enable profiling default=off
--enable-instrument 	 enable instrument default=off
--with-gcc=[compiler] 	 which C compiler to use
                          ("yes" = gcc/g++,
                           "no"  = system-specific C/C++ compiler,
                           &amp;lt;other-compiler-name&amp;gt;)
--with-gxx=[compiler] 	 which C++ compiler to use
--with-bits=[#bits] 	 specify number of bits (32 or 64)</example>
        <para>Use the <code>--help</code> option of configure to find out more about configure options.</para>
        <para>In the same directory (where you called configure) give the command</para>
        <example xml:space="preserve">make</example>
        <para>to compile the source code.</para>
        <para>On a lightly loaded, 1.4 GHz Athlon Linux system, configure takes about 30 seconds, and make about 5 to 10 minutes, depending on the optimization level chosen during configure.</para>
      </subsubsection>

      <subsubsection>
        <title>Testing the Build</title>
        <para>If make went successfully, you can try</para>
        <example xml:space="preserve">make check</example>
        <para>This will do a lot of tests, some are unfortunately still expected to fail, but most should go successfully.  At the end of the output there is a reference to an HTML file which is created by the test process and shows the test results.</para>
        <para>Testing takes about 46 MB of disk space in the build directory. Running the tests takes about 13 minutes on the previously mentioned system.</para>
      </subsubsection>

      <subsubsection>
        <title>Installing</title>
        <para>Give the command</para>
        <example xml:space="preserve">make install</example>
        <para>By default (if no <ndash/>prefix option was given to configure above), this will install in /usr/local/.  Make sure you have appropriate privileges.</para>
      </subsubsection>

      <subsubsection>
        <title>Testing the Installation</title>
        <para>Make sure that /usr/local/bin (respectively &lt;prefixdir&gt;/bin, where &lt;prefixdir&gt; is the directory you specified with <code>--prefix</code> when calling configure) is in your PATH.</para>
        <para>In the MonetDB top-level directory issue the command</para>
        <example xml:space="preserve">Mtest.py -r</example>
        <para>This should produce much the same output as make check above, but uses the installed version of MonetDB.</para>
        <para>You need write permissions on part of the installation directory for this command: it will create subdirectories <code>var/MonetDB5/dbfarm</code> and Tests.</para>
      </subsubsection>

      <subsubsection>
        <title>Documentation</title>
        <para>The documentation recides in <code>share/MonetDB5/</code>. It consists of the pdf files of the current document and its web pages. The most recent version is best access from the <uref><urefurl>http://monetdb.cwi.nl</urefurl><urefdesc>MonetDB home page</urefdesc></uref>.</para>
      </subsubsection>

      <subsubsection>
        <title>Troubleshooting</title>
        <para>Bootstrap fails if any of the requisite programs can not be found or is an incompatible version. Bootstrap adds files to the source directory, so it must have write permissions.</para>
        <para>During bootstrap, warnings like</para>
        <example xml:space="preserve">	Remember to add `AC_PROG_LIBTOOL' to `configure.in'.
	You should add the contents of `/usr/share/aclocal/libtool.m4' to `aclocal.m4'.
	configure.in:37: warning: do not use m4_patsubst: use patsubst or m4_bpatsubst
	configure.in:104: warning: AC_PROG_LEX invoked multiple times
	configure.in:334: warning: do not use m4_regexp: use regexp or m4_bregexp
	automake/aclocal 1.6.3 is older than 1.7.
	Patching aclocal.m4 for Intel compiler on Linux (icc/ecc).
	patching file aclocal.m4
	Hunk #1 FAILED at 2542.
	1 out of 1 hunk FAILED -- saving rejects to file aclocal.m4.rej
	patching file aclocal.m4
	Hunk #1 FAILED at 1184.
	Hunk #2 FAILED at 2444.
	Hunk #3 FAILED at 2464.
	3 out of 3 hunks FAILED -- saving rejects to file aclocal.m4.rej&lt;/pre&gt;
might occur.</example>
        <para>For some technical reasons, it's hard to completely avoid them. However, it is usually save to ignore them and simply proceed with the usual compilation procedure. Only in case the subsequent configure or make do fail, these warning might have to be take more serious; in any case, you should include the e bootstrap output in whenever you report (see below) compilation problems.</para>
        <para>Configure will fail if certain essential programs can't be found or certain essential tasks (such as compiling a C program) can't be executed.  The problem will usually be clear from the error message.</para>
        <para>E.g., if configure cannot find package XYZ, it is either not installed on your machine, or it is not installed in places that configure usually searches (i.e., <code>/usr</code>, <code>/usr/local</code>). In the first case, you need to install package XYZ before you can configure, make, and install MonetDB.  In the latter case, you need to tell configure via "<ndash/>with-XYZ=&lt;DIR&gt;" where to find packages XYZ on your machine. configure then looks for the respective header files in <code>&lt;DIR&gt;/include</code>, and for the respective libraries in <code>&lt;DIR&gt;/lib</code>.</para>
        <para>Bugs and other problems with compiling or running MonetDB should be reported using the respective bug-tracking system at <uref><urefurl>https://sourceforge.net/tracker/?group_id=56967&amp;atid=482468</urefurl><urefdesc>SourceForge</urefdesc></uref> (preferred) or emailed to <uref><urefurl>mailto:monet@cwi.nl</urefurl><urefdesc>monet@cwi.nl</urefdesc></uref>.</para>
      </subsubsection>
    </subsection>
  </node>
  <node>
    <nodename>Windows Installation</nodename>
    <nodenext>Gentoo Installation</nodenext>
    <nodeprev>Linux Installation</nodeprev>
    <nodeup>Source Distribution</nodeup>
    <subsection>
      <title>Windows Installation</title>
      <para>This section helps you to install MonetDB on a native Windows system (NT, 2000, XP).</para>

      <subsubsection>
        <title>Prerequisites</title>
        <itemize>
          <itemfunction><bullet/></itemfunction>
          <item>
            <para><emph>CVS</emph> 	You need to have a working CVS.  Several solutions are 	available. We use internally 	<uref><urefurl>http://www.wincvs.org/</urefurl><urefdesc>WinCVS</urefdesc></uref> and CVS under 	<uref><urefurl>http://www.cygwin.com/</urefurl><urefdesc>Cygwin</urefdesc></uref>. 	For general information about the SourceForge repository, see 	<uref><urefurl>http://sourceforge.net/docman/?group_id=1</urefurl><urefdesc>docman</urefdesc></uref> 	and look under the heading CVS Instructions.  Pointers to CVS 	implementations for Windows can be found at e.g.: 	<uref><urefurl>http://www.cvshome.org/cyclic/cvs/windows.html</urefurl><urefdesc>http://www.cvshome.org/cyclic/cvs/windows.html</urefdesc></uref> 	<uref><urefurl>http://www.wincvs.org/</urefurl><urefdesc>http://www.wincvs.org/</urefdesc></uref> 	<uref><urefurl>http://www.componentsoftware.com/products/CVS/</urefurl><urefdesc>http://www.componentsoftware.com/products/CVS/</urefdesc></uref></para>
          </item>
          <item>
            <para><emph>Python</emph> 	MonetDB uses Python (version 2.0.0 or better) during 	configuration of the software.  See 	<uref><urefurl>http://www.python.org/</urefurl><urefdesc>python.org</urefdesc></uref> for more information.</para>
          </item>
          <item>
            <para><emph>Pthreads</emph> <uref><urefurl>ftp://sources.redhat.com/pub/pthreads-win32/</urefurl><urefdesc>Pthreads for Win32</urefdesc></uref>     should be installed to C:\Pthreads, otherwise you need     to patch the "PTHREAD = C:\Pthreads" line in "NT\rules.msc"     according to your setup. Newer versions of Pthreads seem to     have the "include" &amp;amp; "lib" directory not in C:\Pthreads, but in     C:\Pthreads\prebuilt. In that case, you either have to move the     "include" &amp; "lib" directory from C:\Pthreads\prebuilt to     C:\Pthreads, or set "PTHREAD = C:\Pthreads\prebuilt" in     "NT\rules.msc".</para>
          </item>
          <item>
            <para><emph>UnxUtils</emph> <uref><urefurl>http://UnxUtils.sourceforge.net/</urefurl><urefdesc>UnxUtils for Win32</urefdesc></uref>     must be installed in the root directory ("\", i.e.,     without the default "\UnxUtils\" prefix) of the drive where you     want to compile MonetDB.     The same drive is required, as the UnxUtils do not know about     drive letters, and hence absolute paths start with "\" (i.e.,     without a leading "C:", "D:", ...).  The default "\UnxUtils\"     prefix has to be omitted, as otherwise the UnxUtils' "bison"     does not find its own "bison.simple" file, which it expects to     be in "/usr/share/bison/bison.simple"     (aka. "\usr\share\bison\bison.simple").     Next to some tools used by Mtest.py for testing MonetDB (see     below), UnxUtils provide the lexical analyzer generator "flex"     and the parser generator "bison", which are required to compile     MonetDB.     Note: You have to install the UnxUtils using the original     <uref><urefurl>http://UnxUtils.sourceforge.net/UnxUtils.zip</urefurl><urefdesc>.zip file</urefdesc></uref>.     With the third-party executable     <uref><urefurl>http://www.braindonors.net/products/unxutils.asp</urefurl><urefdesc>installer</urefdesc></uref>,     choosing another than the default installation directory doesn't seem to     work...</para>
          </item>
          <item>
            <para><emph>Microsoft Visual C++</emph>     You need Microsoft Visual C++ 5 or higher.     Notice that if you do not own Microsoft Visual C++, you can     still compile on Windows using the Cygnus Posix-emulation     environment <uref><urefurl>http://www.cygwin.com</urefurl><urefdesc>CYGWIN</urefdesc></uref>     In that case, you should follow the standard instructions in the file     'HowToStart'. Alternatively, it might be possible to use the     free <uref><urefurl>http://www.mingw.org/index.shtml</urefurl><urefdesc>WIN32-GNU compilers</urefdesc></uref>     as a drop-in replacement for the Microsoft tools, but we have not     tried this yet.</para>
          </item>
          <item>
            <para><emph>disk space</emph> 	After downloading, MonetDB takes up about 40 MB of disk space; 	compilation adds another 70 MB.  Testing takes about 45 MB, and 	the installation about 20 MB (not including any databases).</para>
          </item>
        </itemize>
      </subsubsection>

      <subsubsection>
        <title>Compiling</title>
        <para>Open a Windows command shell or a UnxUtils shell and go to the top-level directory of MonetDB. Make sure that the proper environment for MSVC++ is set, otherwise call the corresponding BAT file. (see C:\Program Files\Microsoft Visual Studio\VC98\Bin\VCVARS32.BAT). Make sure that Python, C:\Pthreads\lib (or wherever you installed Pthreads), and \usr\local\wbin are in the PATH of your command shell. When all prerequisites have been satisfied, you type</para>
        <example xml:space="preserve">cd NT
nmake</example>
        <para>to compile the source code. If nmake went successfully, you can try</para>
        <example xml:space="preserve">nmake check</example>
        <para>This will do a lot of tests, some are unfortunately still expected to fail, but most should go successfully.  At the end of the output there is a reference to an HTML file which is created by the test process and shows the test results.  An explanation of the test results can be found in XXX<ndash/>to be filled in. Testing takes about 46 MB of disk space in the build directory.</para>
      </subsubsection>

      <subsubsection>
        <title>Testing the Installation</title>
        <para>Make sure that &lt;sourcedir&gt;\NT\bin, &lt;sourcedir&gt;\NT\lib, and &lt;sourcedir&gt;\NT\lib\MonetDB are in your PATH. In the MonetDB top-level directory issue the command</para>
        <example xml:space="preserve">Mtest.py -r</example>
        <para>(Make sure Mtest.py can be found, it should be in the bin directory that was filled by the nmake install command.)</para>
        <para>This should produce much the same output as nmake check above, but uses the installed version of MonetDB.</para>
      </subsubsection>

      <subsubsection>
        <title>Documentation</title>
        <para>The documentation starts in &lt;sourcedir&gt;\NT\doc\MonetDB.html</para>
        <para>NOTE: the current 'nmake install' does not yet generate this documentation to do this manually, execute *after* successful 'make install'.  In the top-level directory of the MonetDB build tree, call</para>
        <example xml:space="preserve">nmake html</example>
      </subsubsection>
    </subsection>
  </node>
  <node>
    <nodename>Gentoo Installation</nodename>
    <nodenext>Daily Builds</nodenext>
    <nodeprev>Windows Installation</nodeprev>
    <nodeup>Source Distribution</nodeup>
    <subsection>
      <title>Gentoo Installation</title>
      <para>This section helps you to install the MonetDB source using Gentoo on all platforms, MacOs in particular. [To be documented by Fabian]</para>
    </subsection>
  </node>
  <node>
    <nodename>Daily Builds</nodename>
    <nodenext>Start and Stop the Server</nodenext>
    <nodeprev>Gentoo Installation</nodeprev>
    <nodeup>Source Distribution</nodeup>
    <subsection>
      <title>Daily Builds</title>
      <para>Next to functionality and performance, stability and portability are first class goals of the MonetDB project. Pursuing these goals requires to constantly monitor stability and portability of the evolving MonetDB code base. For this purpose, we developed a test environment that automatically compiles and tests MonetDB (and its most prominent add-on packages) every night on a variety of system configurations.</para>
      <para>Software patches and functional enhancements are checked into the repositories on a daily basis. A limited set of distribution packages is prepared to disseminate the latest to developers and application programmers as quickly as possible. Such builds may, however, contain bugs or sometimes even break old functionality, mostly due to incompatibility of compiler code.</para>
      <para>The <uref><urefurl>http://monetdb.cwi.nl/Development/TestWeb/index.html</urefurl><urefdesc>TestWeb</urefdesc></uref> provides access to the test web-site that summarizes the results of the Automated Testing activities on various <uref><urefurl>http://monetdb.cwi.nl/Development/TestWeb/Platforms/index.html</urefurl><urefdesc>platforms</urefdesc></uref>. It is a good starting point before picking up a daily build version.</para>
      <para>Two versions of MonetDB are tested daily on all available platforms:</para>
      <itemize>
        <itemfunction><bullet/></itemfunction>
        <item>
          <para>the <emph>cutting edge</emph> development version ("Current"), i.e. the head of the main CVS branch; and</para>
        </item>
        <item>
          <para>the latest release version ("Stable"), i.e. the head of the most recent release branch.</para>
        </item>
      </itemize>
      <para>The test reports consist of three overview pages ("cross-check-lists") revealing the results of</para>
      <enumerate first="1">
        <item>
          <para>all compilation steps (bootstrap, configure, make, make install),</para>
        </item>
        <item>
          <para>testing via "make check" (using debugmask 10, i.e., exhaustive monitoring and correction of physical BAT properties is enabled in the server), and</para>
        </item>
        <item>
          <para>testing via "Mtest.py -d0 -r" (using debugmask 0, i.e., all debugging is switched off in the server).</para>
        </item>
      </enumerate>
      <subsubsection>
        <title>Stability</title>
        <para>With a (code-wise) complex system like MonetDB, modifying the source code <mdash/> be it for fixing bugs or for adding new features <mdash/> always bears the risk of breaking or at least altering some existing functionality. To facilitate the task of detecting such changes, small test scripts together with their respective correct/expected ("stable") output are collected within the CVS repository of MonetDB. Given the complexity of MonetDB, there is no way to do anything close to "exhaustive" testing, hence, the idea is to continuously extend the test collection. E.g., each developer should add some tests as soon as she/he adds new functionality. Likewise, a test script should be added for each bug report to monitor whether/when the bug is fixed, and to prevent (or at least detect) future occurrences of the same bug. The collection consists for hundreds of test scripts.</para>
        <para>To run all the tests and compare their current output to their stable output, a tool called Mtest is included in the MonetDB code base. Mtest recursively walks through the source tree, runs tests, and checks for difference between the stable and the current output. As a result, Mtest creates a web interface that allows convenient access to the differences encountered during testing. Each developer is supposed to run "Mtest" (respectively "make check") on his/her favorite development platform and check the results before checking in her/his changes. During the automatic daily tests, "make check" and "Mtest" are run on all testing platforms and the TestWeb is generated to provide convenient access to the results.</para>
      </subsubsection>

      <subsubsection>
        <title>Portability</title>
        <para>Though Fedora Linux on AMD Athlon PC's is our main development platform at CWI, we do not limit our attention to this single platform. Supporting a broad range of hardware and software platform is an important concern.</para>
        <para>Using standard configuration tools like automake, autoconf, and libtool, we have the same code base compiling not only on various flavors of Unix (e.g., Linux, Cygwin, AIX, IRIX, Solaris, MacOS X) but also on native Windows. Furthermore, the very code base compiles with a wide spectrum of (C-) compilers, ranging from GNU's gcc over several native Unix compilers (IBM, SGI, Sun, Intel, Portland Group) to Microsoft's Visual Studio and Visual Studio .NET on Windows.</para>
        <para>On the hardware side, we have MonetDB running on "almost anything" from a Intel StrongARM-based Linux PDA with 64 MB of flash memory to an SGI Origin2000 with 32 MIPS R12k CPU's and a total of 64 GB of (shared) main memory.</para>
      </subsubsection>
    </subsection>
  </node>
  <node>
    <nodename>Start and Stop the Server</nodename>
    <nodenext>Database Configuration</nodenext>
    <nodeprev>Daily Builds</nodeprev>
    <nodeup>Download and Installation</nodeup>
    <section>
      <title>Start and Stop the Server</title>
      <para>Starting and stopping the server under Windows doesn't need an extensive description. Just locate the server in the program list and start it. After the server has been started, you can activate a textual client interface. Close the window of the server and/or client and it ceases to exist.</para>
      <para>Once downloaded and installed MonetDB on your Linux system, it is adviceable to check its functionality with the following actions:</para>
      <example xml:space="preserve">&gt; monetdb --help</example>
      <para>The <code>monetdb</code> script is a wrapper around the MonetDB server program <code>mserver5</code> and its protection program <code>mguardian</code>. The call triggers <code>mserver5 --help</code> and responds with something like:</para>
      <verbatim xml:space="preserve"><![CDATA[
Usage: monetdb [command] [options] [script]
Primary command:
    --status        Show the server status [default]
    --start         Server(s) is (are) started
    --stop          Server(s) is (are) stopped
    --databases     Show the known databases
    --checkpoint    Create the checkpoint for a database
    --recover       Restore a database to an earlier date
    --log           Show the server management log

Secondary options:
    --dbname=<database_name>
    --dbfarm=<directory>
    --dbinit=<stmt>           Server prepare statement
    --config=<config_file>    Configuration file
    --debug=<number>          Trace server actions[0]
    --daemon=yes|no           Run in background [no]
    --set <option>=<value>    Set environment value
    --ascii                   Use ascii dump for the database [default=no]
    --help                    This list of options
]]></verbatim>
      <para>An error messages typically indicate a wrongly configured $PATH variable, making the <code>monetdb</code> program invisible to your shell. Retrace your installation steps.</para>
      <para>An access mode violation indicates that either the directory path to the location of the MonetDB data store does not exists, or the user has lack of file system permissions to create new directories/files in the location specified.</para>
      <para>To start a server for a database simpy type</para>
      <example xml:space="preserve">&gt; monetdb --start --dbname=voc
Do you want to create database 'voc' ? [yes/no]yes
Database xyz initialized
Starting database server 'voc'... ok</example>
      <para>The question is asked only the first time you attempt to access the <code>voc</code> database.</para>
      <para>It responds with a message that this action was successful, or an error message explains the problems encountered. The server is run as a daemon process and you need a MonetDB client program to connect to it. More details on the server configuration parameters are given in <xref><xrefnodename>Architecture overview</xrefnodename></xref>.</para>
      <para>At any time you can inspect the status of the (running) servers using the default command option <code>--status</code>.</para>
      <example xml:space="preserve">&gt;monetdb --status
DBNAME  SERVER  GUARD   DELAY   STARTED
voc     21488   21502   12      Sun Dec 18 09:05:36 2005</example>
      <para>It tells you when the server was started, the identity of the process looking after it, and the delay between successive checks. A server can be put to sleep using the command <code>monetdb --stop --dbname=&lt;name&gt;</code>. Ommission of a database name stops all running servers. The actions of monetdb are logged for post analysis, which can be inspected with <code>monetdb --log</code></para>
    </section>
  </node>
  <node>
    <nodename>Database Configuration</nodename>
    <nodenext>Checkpoint and Recovery</nodenext>
    <nodeprev>Start and Stop the Server</nodeprev>
    <nodeup>Download and Installation</nodeup>
    <subsection>
      <title>Database Configuration</title>
      <para>The database environment is collected in a configuration file, which is used by server-side applications, such as <code>mserver5</code> and <code>mguardian</code>. A default version is installed in the database store upon its creation using the command <code>monetdb</code>. Below we illustrate its most important components.</para>
      <itemize>
        <itemfunction><bullet/></itemfunction>
        <item>
          <para>prefix=/ufs/myhome/monet5/Linux</para>
        </item>
        <item>
          <para>exec_prefix=${prefix}</para>
        </item>
        <item>
          <para>dbfarm=${prefix}/var/MonetDB5/dbfarm</para>
        </item>
        <item>
          <para>monet_mod_path=${exec_prefix}/lib/MonetDB5</para>
        </item>
        <item>
          <para>checkpoint_dir=${prefix}/var/MonetDB5/chkpnt</para>
        </item>
        <item>
          <para>dbname=demo</para>
        </item>
        <item>
          <para>version=5.0</para>
        </item>
        <item>
          <para>welcome=yes</para>
        </item>
        <item>
          <para>embedded=no</para>
        </item>
        <item>
          <para>gdk_debug=0	# to control level of debugging</para>
        </item>
      </itemize>
      <para>The header consist of system wide information. The <code>prefix</code> and <code>exec_prefix</code> describe the location where MonetDB has been installed. <code>monet_mod_path</code> tells where to find the libraries. These arguments are critical for a proper working server.</para>
      <para>The remainder consists of arguments used by functional modules, or related tools. Consult the documentation before changing them.</para>
      <itemize>
        <itemfunction><bullet/></itemfunction>
        <item>
          <para>delay=120</para>
        </item>
        <item>
          <para>mal_init=${prefix}/lib/MonetDB5/mal_init.mal</para>
        </item>
        <item>
          <para>mal_listing = 7</para>
        </item>
        <item>
          <para>sql_debug=0</para>
        </item>
        <item>
          <para>sql_logdir=${prefix}/var/MonetDB5/dblogs</para>
        </item>
        <item>
          <para>pf_httpd_port=8080</para>
        </item>
        <item>
          <para>xquery_output=dm</para>
        </item>
        <item>
          <para>xquery_cacheMB=100</para>
        </item>
      </itemize>
    </subsection>
  </node>
  <node>
    <nodename>Checkpoint and Recovery</nodename>
    <nodenext>Database Dumps</nodenext>
    <nodeprev>Database Configuration</nodeprev>
    <nodeup>Download and Installation</nodeup>
    <subsection>
      <title>Checkpoint and Recovery</title>
      <para>Safeguarding the content of your database requires carefully planned steps. The easiest way is to shutdown the server first. Then the database directory holding the database can be compressed and stored away. You may want to create a tarball with compressed files and name them clearly for later recall.</para>
      <para>The checkpoint is not complete without the corresponding log files produced by SQL. They are stored by default in a mirror directory of <code>dbfarm</code>, called <code>dblogs</code>. They too should be picked up and safeguarded for future use.</para>
      <para>The checkpoint and recover operations are packaged as shell scripts, which are wrapped by the <code>monetdb</code> script. Taking a checkpoint and its recovery is as simple as:</para>
      <example xml:space="preserve">shell&gt;monetdb --checkpoint --dbname=demo
Checkpoint store .../var/MonetDB5/chkpnt
Preparing checkpoint file 'demo/2006-01-02-223704'
Preparing checkpoint log file 'demo/2006-01-02-223704-logs'

shell&gt;monetdb --recover --dbname=demo
Checkpoint tags defined for 'demo'
2006-01-02-224335
2006-01-02-224233
...
Specify the checkpoint tag for 'demo' ? 2006-01-02-224335
Move existing database out of the way 'demo2006-01-02-224416'
Move existing database logs out of the way 'demo2006-01-02-224416'
Restore from store .../var/MonetDB5/chkpnt
Reload checkpoint file 'demo/2006-01-02-224335'
Reload checkpoint log file 'demo/2006-01-02-224335-logs'
Database recovery finished</example>
      <para>Before the checkpoint operation starts the database server is brought down and restarted afterwards. The checkpoint files are stored away in a path available in the database configuration file.</para>
    </subsection>
  </node>
  <node>
    <nodename>Database Dumps</nodename>
    <nodenext>MonetDB Overview</nodenext>
    <nodeprev>Checkpoint and Recovery</nodeprev>
    <nodeup>Download and Installation</nodeup>
    <subsection>
      <title>Database Dumps</title>
      <para>An alternative scheme to safeguard and transport a SQL database is to produce an <code>ascii</code>-based database dump. This option is standard available for the <code>mclient</code> and <code>mjClient</code>. However, be prepared that not all SQL schema features may be retained in the process. It also takes much more time to produce the dump file.</para>
      <para>Consider you have already installed the SQL tutorial database <code>VOC</code> and wish to transport it to another machine. The following steps are required after you have started the database server.</para>
      <example xml:space="preserve">shell&gt; mclient -lsql --dump &gt;/tmp/voc.sql</example>
      <para>You can inspect the file <code>/tmp/voc.sql</code> to confirm that indeed a compact database dump is available. Move this file over to the new machine. The <code>monetdb</code> script can be used to create the database and start the server. Once done, it suffices to feed the dump file to a MonetDB client program to populate the database.</para>
      <example xml:space="preserve">shell&gt; monetdb --start --dbname=voc
Do you want to create database 'voc' ? [yes/no]yes
Database voc initialized
!WARNING: GDKlockHome: ignoring empty or invalid .gdk_lock.
!WARNING: BBPdir: initializing BBP.
# Monet Database Server V4.99.19
# Copyright (c) 1993-2006, CWI. All rights reserved.
# Compiled for x86_64-redhat-linux-gnu/64bit with 32bit OIDs; dynamically linked.
# config:/ufs/mk/monet5/Linux/var/MonetDB5/dbfarm/voc/.monetdb.conf
# dbfarm:/ufs/mk/monet5/Linux/var/MonetDB5/dbfarm
# dbname:voc
# Visit http://monetdb.cwi.nl/ for further information.
#include sql; mapi.listen();
shell&gt; mclient -lsql /tmp/voc.sql</example>
      <para>The dump facility is also avaible as an option to the <code>monetdb</code> script. It tags the dump and stores it away in the checkpoint directory.</para>
    </subsection>
  </node>
  <node>
    <nodename>MonetDB Overview</nodename>
    <nodenext>Design considerations</nodenext>
    <nodeprev>Database Dumps</nodeprev>
    <nodeup>Top</nodeup>
    <chapter>
      <title>Introduction to MonetDB Version 5</title>
      <para>The MonetDB product family consists of a large number of components developed within our group over the last decade. Some components have already been shipped to happy customers, some are still in the making, and others have found a resting place in the attic.</para>
      <para>The MonetDB architecture is designed to accommodate a wide-spectrum of standardized query language front-ends (SQL, XQuery), a variety of query transformation schemes, and different execution platforms (interpreted materialized or pipelined, dynamic compilation).</para>
      <para>MonetDB Version 5 is a major release of our software infrastructure. The most notable differences are its greatly improved software stack and a new interface language, which turns the database server back-end into an abstract database machine with its associated assembler language (MAL). It supports backward compatibility of interfaces, tools, and source sharing where feasible within the limited scope of resources available.</para>
      <para>In the remainder of this section we shortly introduce the MonetDB Version 5 design considerations and a quick overview of the its architecture.</para>
      <menu>
        <menuentry>
          <menunode>Design considerations</menunode>
          <menutitle>Design considerations</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Architecture overview</menunode>
          <menutitle>Architecture overview</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>MAL synopsis</menunode>
          <menutitle>MAL synopsis</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>MAL execution</menunode>
          <menutitle>MAL execution</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Backward Compatibility</menunode>
          <menutitle>Backward Compatibility</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Session Scenarios</menunode>
          <menutitle>Session Scenarios</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Scenario management</menunode>
          <menutitle>Scenario management</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Client administration</menunode>
          <menutitle>Client administration </menutitle>
          <menucomment></menucomment>
        </menuentry>
      </menu>
    </chapter>
  </node>
  <node>
    <nodename>Design considerations</nodename>
    <nodenext>Architecture overview</nodenext>
    <nodeprev>MonetDB Overview</nodeprev>
    <nodeup>MonetDB Overview</nodeup>
    <section>
      <title>Design considerations</title>
      <para>Redesign of the MonetDB software stack was driven by the need to reduce the effort to extend the system into novel directions and to reduce the Total Execution Cost (TEC). The TEC is what an end-user or application program will notice. The TEC is composed on several cost factors:</para>
      <itemize>
        <itemfunction><bullet/></itemfunction>
        <item>
          <para>A) API message handling</para>
        </item>
        <item>
          <para>P) Parsing and semantic analysis</para>
        </item>
        <item>
          <para>O) Optimization and plan generation</para>
        </item>
        <item>
          <para>D) Data access to the persistent store</para>
        </item>
        <item>
          <para>E) Execution of the query terms</para>
        </item>
        <item>
          <para>R) Result delivery to the application</para>
        </item>
      </itemize>
      <para>Choosing an architecture for processing database operations pre-supposes an intuition on where and how the cost will be distributed. In an OLTP setting you expect most of the cost to be in (P,O), while in OLAP it will be (D,E,R). In a distributed setting the components (O,D,E) are dominant. Web-applications would focus on (A,E,R).</para>
      <para>Such a simple characterization ignores the wide-spread differences that can be experienced at each level. To illustrate, in D) and R) it makes a big difference whether the data is already in the cache or still on disk. With E) it makes a big difference whether you are comparing two integers, evaluation of a mathematical function, e.g. Gaussian, or a regular expression evaluation on a string. As a result, intense optimization in one area may become completely invisible due to being overshadowed by other cost factors.</para>
      <para>The Version 5 infrastructure is designed to ease addressing each of these cost factors in a well-defined way, while retaining the flexibility to combine the components needed for a particular situation. This results in an architecture to assemble the components for a particular application domain and hardware platform.</para>
      <para>The primary interface to the database kernel is still based on the exchange of text in the form of queries and simply formatted results. This interface is designed for ease of interpretation, versatility and flexible to accommodate system debugging and application tool development. Although a textual interface potentially leads to a performance degradation, our experience with earlier system versions showed that the overhead can be kept within acceptable bounds. Moreover, a textual interface reduces the programming effort otherwise needed to develop test and application programs.</para>
    </section>
  </node>
  <node>
    <nodename>Architecture overview</nodename>
    <nodenext>MAL synopsis</nodenext>
    <nodeprev>Design considerations</nodeprev>
    <nodeup>MonetDB Overview</nodeup>
    <section>
      <title>Architecture overview</title>
      <para>The architecture is built around three independent components: the MonetDB server, the MonetDB guardian, and the client application. The MonetDB server is the heart of the system, it manages a single physical database on one machine for all (concurrent) applications. The guardian program works along side a single server, keeping an eye on its behavior. If the server accidently crashes, it is this program that will attempt an automatic restart. Server and guardian are managed with the <code>monetdb</code> script, introduced in <xref><xrefnodename>Start and Stop the Server</xrefnodename></xref>.</para>
      <para>The top layer consists of applications written in your favorite language. They provide both specific functionality for a particular product, e.g. Proximity, and generic functionality, e.g. the Aquabrowser. The applications communicate with the server using a de-facto standard interface packaged as a library e.g. JDBC, ODBC, Perl, PHP, etc..</para>
      <para>The prime query language processors available in the MonetDB family are SQL and XQuery. The former supports the core functionality of SQL:1999 and extends into SQL:2003. The latter is based on the W3C standard and includes the XUpdate functionality. The query language processors each manage their own private catalog structure. Software bridges, e.g. import/export routines, are used to share data between language paradigms.</para>
      <para>For each a language specific, strategic optimizer is included. It uses knowledge on the language semantics and general heuristics, such as pushing down selections through joins, to derive better programs.</para>
    </section>
  </node>
  <node>
    <nodename>MAL synopsis</nodename>
    <nodenext>MAL execution</nodenext>
    <nodeprev>Architecture overview</nodeprev>
    <nodeup>MonetDB Overview</nodeup>
    <section>
      <title>MonetDB Assembler Language (MAL)</title>
      <para>The target language for the query compilers is an assembler-like language, called the MonetDB Assembler Language (MAL). It is a simplified subset of the Monet Interface Language introduced previously. The language provides a direct the textual interface to the server back-end, i.e. MAL is a language available to applications as well.</para>
      <para>Its design is geared to provide a controlled setting for the query processors. They can produce algebraic representations of query plans, which by the MAL optimizers are turned into physical execution plans. In this process an execution paradigm is chosen to best fit the engines available and application needs.</para>
      <para>The <emph>box</emph> container model for MAL objects is a balance between hardwired decisions based on the typing scheme and hooks to implement those as user-defined extensions. For example, objects can be assembled in <emph> box</emph>es, which come with a simple management protocol. Their implementation can be geared towards any management style required, e.g. delivery of read-only objects for query processing, transparency to external resources through wrappers, and high-volume transaction support.</para>
      <para>Much in the spirit of Version 4 MAL can be readily extended with user defined types and service modules. Furthermore, the language design is meant to support the full breath of computational paradigms deployed in a database setting. In particular, it should provide a clean infrastructure to implement triggers and stream-based database applications. Its design and implementation takes the functionality a significant step further. To name a few:</para>
      <itemize>
        <itemfunction><bullet/></itemfunction>
        <item>
          <para>All instructions are strongly typed before being executed.</para>
        </item>
        <item>
          <para>Polymorphic functions are supported. They act as templates that produce strongly typed instantiations when needed.</para>
        </item>
        <item>
          <para>Function style expressions where each assignment instruction can receive multiple target results; it forms a point in the dataflow graph.</para>
        </item>
        <item>
          <para>Co-routines (Factories) support building streaming applications.</para>
        </item>
        <item>
          <para>Properties are associated with the program code for ease of optimization and scheduling.</para>
        </item>
      </itemize>
      <example xml:space="preserve"></example>
    </section>
  </node>
  <node>
    <nodename>MAL execution</nodename>
    <nodenext>Session Scenarios</nodenext>
    <nodeprev>MAL synopsis</nodeprev>
    <nodeup>MonetDB Overview</nodeup>
    <subsection>
      <title>MonetDB bootstrap</title>
      <para>Startup of the MonetDB server leads to loading the system kernel libraries as defined in a bootstrap script <code>mal_init.mx</code>. Its default location is decribed in the MonetDB configuration file. Failure to find the startup-file terminates the session. The global symbol table is initialized with function signatures, and the pre-compiled commands and pattern code blocks are loaded. The libraries may be dynamically loaded by default. Expect tens of modules and hundreds of operations to become readily available.</para>
      <para>Modules once loaded can not be dropped without restarting the server. The rational behind this design decision is that a dynamic load/drop feature is often hardly used and severely complicates the code base. In particular, upon each access to the global symbol table we have to be prepaired that concurrent threads my be actively changing its structure. Especially, dropping modules may cause sever problems by not being able to detect all references kept around. This danger required all accesses to global information to be packaged in a critical section, which is known to be a severe performance hindrence.</para>
      <example xml:space="preserve"></example>
    </subsection>
  </node>
  <node>
    <nodename>Session Scenarios</nodename>
    <nodenext>Scenario management</nodenext>
    <nodeprev>MAL execution</nodeprev>
    <nodeup>MonetDB Overview</nodeup>
    <section>
      <title>Session Scenarios</title>
      <para>In MonetDB multiple languages, optimizers, and execution engines can be combined at run time to satisfy a wide user-community. Such an assemblage of components is called a <emph>scenario</emph> and consists of a <emph>reader</emph>, <emph>parser</emph>, <emph>optimizer</emph>, <emph>tactic scheduler</emph> and <emph>engine</emph>. These hooks allow for both linked-in and external components.</para>
      <para>The languages supported are SQL, XQuery, and the Monet Assembler Language (MAL). The default scenario handles MAL instructions, which is used to illustrate the behavior of the scenario steps.</para>
      <para>The MAL reader component handles interaction with a front-end to obtain a string for subsequent compilation and execution. The reader uses the common stream package to read data in large chunks, if possible. In interactive mode the lines are processed one at a time.</para>
      <para>The MAL parser component turns the string into an internal representation of the MAL program. During this phase semantic checks are performed, such that we end up with a type correct program.</para>
      <para>The code block is subsequently sent to an MAL optimizer. In the default case the program is left untouched. For other languages, the optimizer deploys language specific code transformations, e.g. foreign-key optimizations in joins and volume reduction over intermediates. All optimization information is statically derived from the code blocks and possible catalogues maintained for the query language at hand. Optimizers leave advice and their findings in properties in the symbol table, see <xref><xrefnodename>Property management</xrefnodename></xref>.</para>
      <para>Once the program has thus been refined, the MAL scheduler prepares for execution using tactical optimizations. For example, it may parallelize the code, generate an ad-hoc user-defined function, or prepare for efficient replication management. In the default case, the program is handed over to the MAL interpreter without any further modification.</para>
      <para>The final stage is to choose an execution paradigm, i.e. interpretative (default), compilation of an ad-hoc user defined function, dataflow driven interpretation, or vectorized pipe-line execution by a dedicated engine.</para>
      <para>A failure encountered in any of the steps terminates the scenario cycle. It returns to the user for a new command.</para>
    </section>
  </node>
  <node>
    <nodename>Scenario management</nodename>
    <nodenext>Client administration</nodenext>
    <nodeprev>Session Scenarios</nodeprev>
    <nodeup>MonetDB Overview</nodeup>
    <subsection>
      <title>Scenario management</title>
      <para>Scenarios are captured in modules; they can be dynamically loaded and remain active until the system is brought to a halt. The first time a scenario is used, the system looks for a scenario initialization routine <code>XYZinitSystem()</code> and executes it. It is typically used to prepare the server for language specific interactions. Thereafter its components are set to those required by the scenario (e.g. "SQL") and the client initialization takes place.</para>
      <para>When the last user interested in a particular scenario leaves the scene, we activate its finalization routine calling <code>XYZexitSystem()</code>. It typically perform cleanup, backup and monitoring functions.</para>
      <para>A scenario is interpreted in a strictly linear fashion, i.e. performing a symbolic optimization after a parallelization is not permitted. The routines associated with each state in the scenario may patch the code so as to assure that subsequent execution can use a different scenario, e.g. to handle dynamic code fragments.</para>
      <para>The state of execution is maintained in the scenario record for each individual client. Sharing this information between clients should be dealt with in the implementation of the scenario managers. Upon need, the client can postpone a session scenario by pushing a new one(language, optimize, tactic, processor). Propagation of the state information is encapsulated a scenario2scenario() call. Not all transformations may be legal.</para>
      <example xml:space="preserve"></example>
      <para>The building blocks of scenarios are routines obeying a strict name signature. They require exclusive access to the client record. Any specific information should be accessible from there, e.g. access to a scenario specific state descriptor. The client scenario initialization and finalization brackets are  <code>XYZinitClient()</code> and <code>XYZexitClient()</code>.</para>
      <para>The <code>XYZparser(Client c)</code> contains the parser for language XYZ and should fill the mal program block associated with the client record. The latter may have been initialized with variables. Each language parser may require a catalog with information on the translation of language specific datastructures into their BAT equivalent.</para>
      <para>The <code>XYZoptimizer(Client c)</code> contains language specific optimizations using the MAL intermediate code as a starting point.</para>
      <para>The <code>XYZtactics(Client c)</code> synchronizes the program execution with the state of the machine, e.g. claiming resources, the history of the client or alignment of the request with concurrent actions (e.g. transaction coordination).</para>
      <para>The <code>XYZengine(Client c)</code> contains the applicable back-end engine. The default is the MAL interpreter, which provides good balance between speed and ability to analysis its behavior.</para>
      <menu>
        <menuentry>
          <menunode>Scenario management</menunode>
          <menutitle>Scenario management</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Client administration</menunode>
          <menutitle>Client administration</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Session Scenarios</menunode>
          <menutitle>Session Scenarios</menutitle>
          <menucomment></menucomment>
        </menuentry>
      </menu>
    </subsection>
  </node>
  <node>
    <nodename>Client administration</nodename>
    <nodenext>Development Roadmap</nodenext>
    <nodeprev>Scenario management</nodeprev>
    <nodeup>MonetDB Overview</nodeup>
    <section>
      <title>MonetDB Client Interface</title>
      <para>Clients gain access to the Monet server through a internet connection or through its server console. Access through the internet requires a client program at the source, which addresses the default port of a running server.</para>
      <para>At the server side, each client is represented by a session record with the current status, such as name, file descriptors, namespace, and local stack. Each client session has a dedicated thread of control, which limits the number of concurrent users to the thread management facilities of the underlying operating system. A large client base should be supported using a single server-side client thread, geared at providing a particular service.</para>
      <para>The number of clients permitted concurrent access is a compile time option. The console is the first and is always present. It reads from standard input and writes to standard output.</para>
      <para>Client records are linked into a hierarchy, where the top record denotes the context of the Monet administrator. The next layer is formed by a database administrator and the third layer contains user sessions. This hierachy is used to share and constrain resources, such as global variables or references to catalogue information. During parallel execution additional layers may be constructed. [This feature needs more implementation support]</para>
      <para>Client sessions remain in existence until the corresponding communication channels break or its retention timer expires The administrator and owner of a sesssion can manipulate the timeout with a system call.</para>
      <para>Keeping track of instructions executed is a valueable tool for script processing and debugging. Its default value is defined in the MonetDB configuration file. It can be changed at runtime for individual clients using the operation <code>clients.listing</code>(<emph>mask</emph>). A listing bit controls the level of detail to be generated during program execution tracing. The lowest level (1) simply dumps the input, (2) also demonstrates the MAL internal structur (4) adds the hidden type information</para>
      <para>The MAL debugger uses the client record to keep track of any pervasive debugger command. For detailed information on the debugger features see <xref><xrefnodename>Program Debugging</xrefnodename></xref>.</para>
    </section>
  </node>
  <node>
    <nodename>Development Roadmap</nodename>
    <nodenext>SQL Roadmap</nodenext>
    <nodeprev>Client administration</nodeprev>
    <nodeup>Top</nodeup>
    <section>
      <title>Development Roadmap</title>
      <para>In this section we summarize the MonetDB development roadmap as foreseen early 2006. The information is organized around the major system components. A precise timeline can not be given. It depends too much on the available resources and urgency (= pressure) by our research needs and clients.</para>
      <menu>
        <menuentry>
          <menunode>SQL Roadmap</menunode>
          <menutitle>SQL Roadmap </menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>XQuery Roadmap</menunode>
          <menutitle>XQuery Roadmap </menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Embedded Server Roadmap</menunode>
          <menutitle>Embedded Server Roadmap </menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Server Roadmap</menunode>
          <menutitle>Server Roadmap </menutitle>
          <menucomment></menucomment>
        </menuentry>
      </menu>
    </section>
  </node>
  <node>
    <nodename>SQL Roadmap</nodename>
    <nodenext>XQuery Roadmap</nodenext>
    <nodeprev>Development Roadmap</nodeprev>
    <nodeup>Development Roadmap</nodeup>
    <subsection>
      <title>SQL Roadmap</title>
      <para>The long term objective for the SQL front-end is to provide all features available in SQL:2003. The priority for individual features is determined in an ad hoq way. The SQL features scheduled for implementation and those that won;t be supported in the foreseeable future are shown below.</para>
      <para>Our current assessment of the features planned for upcoming releases, in order of priority, are:</para>
      <itemize>
        <itemfunction><bullet/></itemfunction>
        <item>
          <para><emph>Full text retrieval </emph> A full text retrieval support function consists of a special constructed index over text appearing in multiple columns of a relational table. This index is built using well-known Information Retrieval techniques, such as stemming, keyword recognition, and stop-word reduction. Several IR projects are underway, which enhance MonetDB with IR capabilities, e.g. see <uref><urefurl>spiegle</urefurl><urefdesc>spiegle</urefdesc></uref>.</para>
        </item>
        <item>
          <para><emph>Stored SQL procedures</emph> Stored procedures are a powerful scheme to offload operational abstractions to the server. The MonetDB server comes with its own programming language MAL to encode critical functions. Linking with the SQL compiler is readily available, leaving a MonetDB specific implementation of stored SQL procedures less important.</para>
        </item>
        <item>
          <para><emph>Support for multi-media objects</emph></para>
        </item>
        <item>
          <para><emph>General column and table constraint enforcement</emph></para>
        </item>
        <item>
          <para><emph>Internationalization of the character sets</emph></para>
        </item>
        <item>
          <para><emph>Full outer-join queries</emph></para>
        </item>
        <item>
          <para><emph>Triggers</emph></para>
        </item>
      </itemize>
      <para>The database backend architecture prohibits easy implementation of several SQL-99 features. Those on the list below are not expected to be supported.</para>
      <itemize>
        <itemfunction><bullet/></itemfunction>
        <item>
          <para>Cursor based processing, because the execution engine is not based on the iterator model deployed in other engines. A simulation of the cursor based scheme would be utterly expensive from a performance point of view.</para>
        </item>
        <item>
          <para>Multi-level transaction isolation levels. Coarse grain isolation is provided using table level locks.</para>
        </item>
      </itemize>
    </subsection>
  </node>
  <node>
    <nodename>XQuery Roadmap</nodename>
    <nodenext>Embedded Server Roadmap</nodenext>
    <nodeprev>SQL Roadmap</nodeprev>
    <nodeup>Development Roadmap</nodeup>
    <subsection>
      <title>XQuery Roadmap</title>
      <para>The XQuery compiler is currently only available on MonetDB Version 4. It is based on the <uref><urefurl>pathfinder.org</urefurl><urefdesc>Pathfinder</urefdesc></uref> compiler project.</para>
      <para>A novel compiler based on a XQuery algebra is under development. We expect that an alpha release for MonetDB Version 5 becomes available in the fall of 2006.</para>
    </subsection>
  </node>
  <node>
    <nodename>Embedded Server Roadmap</nodename>
    <nodenext>Server Roadmap</nodenext>
    <nodeprev>XQuery Roadmap</nodeprev>
    <nodeup>Development Roadmap</nodeup>
    <subsection>
      <title>Embedded MonetDB Roadmap</title>
      <para>The embedded MonetDB software family provides support for both SQL and Xquery (Version 4 only). The software has been tuned to run on small scall hardware platforms.</para>
      <para>A broader deployment of the embedded technology requires both extensions in the distributed MonetDB versions and its replication services. Continual attention is given to the memory footprint and cpu/io resource consumptions on embedded devices.</para>
      <para>A separate project, called the Datacell, is underway and geared at providing a streaming environment for embedded applications. The supportive modules are scheduled for release in 2006.</para>
    </subsection>
  </node>
  <node>
    <nodename>Server Roadmap</nodename>
    <nodenext>Backward Compatibility</nodenext>
    <nodeprev>Embedded Server Roadmap</nodeprev>
    <nodeup>Development Roadmap</nodeup>
    <subsection>
      <title>Server Roadmap</title>
      <para>The MonetDB server code base is continously being improved. Major areas under developement are:</para>
      <itemize>
        <itemfunction><bullet/></itemfunction>
        <item>
          <para><emph>Replication Service</emph> A single-write multiple-read distributed replication service is prepared for release mid 2006.  It will provide both the concept of merge tables and selective replication of tuples to different servers.</para>
        </item>
        <item>
          <para><emph>GIS support</emph> Support for geographical application is underway. It consists of a concise library for managing geometric types.</para>
        </item>
      </itemize>
    </subsection>
  </node>
  <node>
    <nodename>Backward Compatibility</nodename>
    <nodenext>SQL</nodenext>
    <nodeprev>Server Roadmap</nodeprev>
    <nodeup>MonetDB Overview</nodeup>
    <section>
      <title>Backward compatibility</title>
      <para>The MonetDB software runs back to the early nineties and users have based their business critical applications on the platform since the mid-nineties. This long history creates a challenge in a research laboratory setting to find an evoluationary software developement track. Fortunately, the core development team is still at CWI and is dedicated to maintain the software base. Ofcourse, within the confines of limited resources available and in balance with the primary research activities.</para>
      <para>The development of Version 5 was driven by the following compatibility requirements:</para>
      <itemize>
        <itemfunction><bullet/></itemfunction>
        <item>
          <para>The programming interface technology (ODBC, JDBC, Mapi) are all retained to reduce impact on external applications.</para>
        </item>
        <item>
          <para>SQL and XQuery should compile directly on both old and new versions.</para>
        </item>
        <item>
          <para>The MIL language is depreciated, but MIL programs can mostly be converted to the MAL language.<footnote><para> Only those features are compiled that do not require runtime knowledge on the typing structure.</para></footnote></para>
        </item>
        <item>
          <para>The kernel library GDK remains the primary execution engine, but it should also facilitate emerging alternatives.</para>
        </item>
        <item>
          <para>The key extension modules to the GDK kernel are mostly carried over without change.</para>
        </item>
        <item>
          <para>Auxiliary search paths are not supported, due to lack of interest in Version 4 user community and alternatives based on the BAT algebra.</para>
        </item>
      </itemize>
    </section>
  </node>
  <node>
    <nodename>SQL</nodename>
    <nodenext>Getting Started with SQL</nodenext>
    <nodeprev>Backward Compatibility</nodeprev>
    <nodeup>Top</nodeup>
    <chapter>
      <title>SQL</title>
      <para>The de facto language for database applications is SQL.  It evolved through several phases of standardization to the version currently known as SQL-2003. The SQL standard provides an ideal language framework, in terms of standardization committee viewpoints.  It is, however, hardly met by any of the existing (commercial) implementations. This is largely due to legacy of old software and backward compatibility requirements from their client base.  See for instance <uref><urefurl>http://www.dbazine.com/gulutzan3.shtml</urefurl><urefdesc>this</urefdesc></uref> on-line article on SQL standards.</para>
      <para>The MonetDB database system was originally developed as a database back-end kernel with its own, low-level algebraic interface and scripting language. The development of a SQL front end has been purposely postponed to the point where the kernel code base was sufficiently mature and field tested in large, mission critical applications in the financial sector.</para>
      <para>In 2002 the first version of the SQL front end emerged. This late development made it possible to immediately start from the SQL'99 definition. As soon as the SQL'03 specifications became available, its content was taken as the primary frame of reference. The SQL development strategy is driven by immediate needs of the user base, such that less-frequently used features end up low on the development stack.</para>
      <para>The purpose of this chapter is to give a quick introduction on the SQL front end, its limitations, and the way to use it.  Throughout this document proficiency in elementary use of SQL is assumed. If you are new to this world then pick up any of the introduction books and study it carefully. The SQL Implementation front-end is based on the SQL-99 standard, which is covered in many text books e.g. <emph>J. Melton and A.R. Simon</emph>, SQL:1999 Understanding Relational Language Components, ISBN 1558604561.</para>
      <para>The architecture is based on a separate compiler module, which translates SQL statements into MAL. In this process common optimization heuristics, specific to relational algebra are performed. There are bindings for SQL with JDBC, ODBC, PHP and C, (see <xref><xrefnodename>User Interfaces</xrefnodename></xref>) to integrate seamlessly in existing developments environments. Client utilities like <xref><xrefnodename>Aqua Data Studio</xrefnodename></xref>, <xref><xrefnodename>DbVisualizer</xrefnodename></xref> and <xref><xrefnodename>iSQL-Viewer</xrefnodename></xref> work flawlessly with the MonetDB SQL implementation and make your experience with even better!</para>
      <para>The remainder of this chapter provides a short tutorial to get going with MonetDB/SQL. A synopsis of the language features provides a quick intro on the scope of the current implementation and the short list for functional enhancements planned. The programming support sections illustrate some of the advanced features to analyse and your SQL code.</para>
      <menu>
        <menuentry>
          <menunode>Getting Started with SQL</menunode>
          <menutitle>Getting Started with SQL</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>The VOC Tutorial</menunode>
          <menutitle>The VOC Tutorial</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>SQL Language</menunode>
          <menutitle>SQL Language </menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>MonetDB/SQL Features</menunode>
          <menutitle>MonetDB/SQL Features</menutitle>
          <menucomment></menucomment>
        </menuentry>
      </menu>
    </chapter>
  </node>
  <node>
    <nodename>Getting Started with SQL</nodename>
    <nodenext>The VOC Tutorial</nodenext>
    <nodeprev>SQL</nodeprev>
    <nodeup>SQL</nodeup>
    <section>
      <title>Getting Started with MonetDB/SQL</title>
      <para>Working with SQL requires installation of the MonetDB server and SQL compiler module.  It can be downloaded from the <uref><urefurl>http://sourceforge.net/project/showfiles.php?group_id=56967</urefurl><urefdesc>download</urefdesc></uref> section at SourceForge. It is already included in the Windows installers.</para>
      <para>The first step is to start the database backend following the steps in <xref><xrefnodename>Start and Stop the Server</xrefnodename></xref> or illustrated below. Once it runs, you can choose between a textual interface or one of the graphical user interfaces (See <xref><xrefnodename>User Interfaces</xrefnodename></xref>). The easiest to start with is a textual SQL client. Under Windows, this client is already configured to directly contact the running server. For Linux users we illustrate the actions taken behind the scene.</para>
      <para>The first action on Linux is to start the database server as described in <xref><xrefnodename>Start and Stop the Server</xrefnodename></xref>.</para>
      <example xml:space="preserve">shell&gt; monetdb --start --dbname=voc
Starting database server 'voc'... ok
shell&gt;</example>
      <para>Failures to start the server are reported in the database log, which you can view using the commands</para>
      <example xml:space="preserve">monetdb --log
monetdb --log --dbname=voc</example>
      <para>The next step is to connect to the server with a textual client. Two such clients are included in the distribution: <code>mclient</code> and <code>mjclient</code>.</para>
      <para>The former is the native, C-implementation of the MonetDB client interface. It is a no-frills and fast interface geared at developers. The <code>mjclient</code> is a Java implementation and it uses a standardized database interaction protocol. If you are familiar with JDBC-based applications, or intend to build those, this interface may be your prime choice. The <code>mjclient</code> utility is illustrated:</para>
      <example xml:space="preserve">shell&gt; mjclient --database=voc --user=monetdb
password: *******
Welcome to the MonetDB interactive JDBC terminal!
Database: MonetDB 4.99.19
Driver: MonetDB Native Driver 1.3 (Spur_pre1 20060112)
Type \q to quit, \h for a list of available commands
auto commit mode: on
monetdb-&gt;</example>
      <para>The default password for the user <emph>monetdb</emph> is <emph>monetdb</emph>. The location of the jar file is taken from the MonetDB installation directory.  <code>mjclient</code> reads settings from the <code>~/.monetdb</code> file (in property=value format) for ease of use.</para>
      <para>The world of SQL is now available to the user:</para>
      <example xml:space="preserve">monetdb-&gt; SELECT 'Hello SQL, here I come' AS "message";
+------------------------+
| message                |
+========================+
| Hello SQL, here I come |
+------------------------+
1 row
monetdb-&gt;</example>
      <para>The alternative interface is <code>mclient</code> with its Spartan rendering scheme:</para>
      <example xml:space="preserve">shell&gt; mclient -lsql
sql&gt;SELECT 'Hello SQL, here I come' AS "message";
#  # table_name
# message # name
# char # type
# 22 # length
[ "Hello SQL, here I come"      ]
sql&gt;</example>
      <para>In a clean setup, either client program should run without problems. If you haven't managed to contact the database server either way, backtrack your steps. Is the server running? (use <code>monetdb --status</code>) More arguments may be needed if the server lives on a different machine or the client does not have access to the MonetDB configuration file to access the defaults. See <xref><xrefnodename>Mapi Client</xrefnodename></xref> or <xref><xrefnodename>Jdbc Client</xrefnodename></xref> for details.</para>
    </section>
  </node>
  <node>
    <nodename>The VOC Tutorial</nodename>
    <nodenext>SQL Language</nodenext>
    <nodeprev>Getting Started with SQL</nodeprev>
    <nodeup>SQL</nodeup>
    <section>
      <title>The VOC tutorial</title>
      <para>Exploring the wealth of functionality offered by MonetDB is best started using a toy database.  An example of such database is the VOC data set that provides a peephole view into the administrative system of a multi-national company, the <emph>Vereenigde geoctrooieerde Oostindische Compagnie</emph> (VOC for short - The (Dutch) East Indian Company).</para>
      <para>The VOC was granted a monopoly on the trade in the East Indies on March 20, 1602 by the representatives of the provinces of the Dutch republic. Attached to this monopoly was the duty to fight the enemies of the Republic and prevent other European nations to enter the East India trade. During its history of over 200 years, the VOC became the largest company of its kind, trading spices like nutmeg, cloves, cinnamon, pepper, and other consumer products like tea, silk and Chinese porcelain. Her factories or trade centers were world famous: Desjima in Japan, Mokha in Yemen, Surat in Persia and of course Batavia, the Company's headquarters on Java.</para>
      <para>The history of the VOC is an active area of research and a focal point for multi-country heritage projects, e.g. <uref><urefurl>http://www.tanap.net/content/voc/organization/organization_intro.htm</urefurl><urefdesc>TANAP</urefdesc></uref>, which includes a short historic overview of the VOC written by world expert on the topic F. Gaastra. The archives of the VOC are spread around the world, but a large contingent still resides in the <uref><urefurl>http://www.nationaalarchief.nl/</urefurl><urefdesc>National Archive&lt;</urefdesc></uref>, The Hague. The archives comprise over 25 million historical records. Much of which has not (yet) been digitized.</para>
      <para>The MonetDB/SQL tutorial is based on the material published in the book J.R. Bruijn, F.S. Gaastra and I. Schaar, <emph>Dutch-Asiatic Shipping in the 17th and 18th Centuries</emph>, which gives an account of the trips made to the East and ships returned safely (or wrecked on the way).  A total of 8000 records are provided.  They include information about ship name and type, captain, the arrival/departure of harbors along the route, personnel accounts, and anecdotal information.</para>

      <subsection>
        <title>Acquiring and loading the VOC data set</title>
        <para>The VOC data set can be downloaded from <uref><urefurl>http://monetdb.cwi.nl/Assets/VOC/voc_dump.sql.gz</urefurl><urefdesc>the MonetDB Assets site</urefdesc></uref> as a gzipped file with SQL statements. After the zipfile has been extracted, the file should be loaded into MonetDB via either the Java based <xref><xrefnodename>Jdbc Client</xrefnodename></xref> utility, or the <xref><xrefnodename>Mapi Client</xrefnodename></xref> C-program. Alternatively, the URL to the VOC data file can be supplied to the <code>mjclient</code> utility, which then directly reads from the URL.</para>
        <para>Before you load the VOC data set, it is advised to first add a different user with its own schema to the MonetDB database. We illustrate this process using the textual SQL client. Make sure the MonetDB server has been started, then start the SQL client. Under Linux you will see something like this:</para>
        <example xml:space="preserve">shell&gt; mjclient -uvoc
password: ***
Welcome to the MonetDB interactive JDBC terminal!
Database: MonetDB 4.99.19
Driver: MonetDB Native Driver 1.3 (Spur_pre1 20060112)
Type \q to quit, \h for a list of available commands
auto commit mode: on
voc&gt; CREATE USER "voc" WITH PASSWORD 'voc' NAME 'VOC Explorer' SCHEMA "sys";
Operation successful
voc&gt; CREATE SCHEMA "voc" AUTHORIZATION "voc";
Operation successful
voc&gt; ALTER USER "voc" SET SCHEMA "voc";
voc&gt;\q</example>
        <para>In the remainder of the tutorial you can no log onto the server as user <code>voc</code>.</para>
        <para>The tutorial database can be initialized using either <code>mjclient</code> and <code>mclient</code> as follows, provided the sql-dump file has already been downloaded:</para>
        <example xml:space="preserve">shell&gt; mjclient -uvoc -f voc_dump.sql -Xbatching
password: ***</example>
        <para>Or using a remotely living dump.</para>
        <example xml:space="preserve">shell&gt; mjclient -uvoc -f http://monetdb.cwi.nl/Assets/VOC/voc_dump.sql.gz -Xbatching
password:***
shell&gt;mclient -lsql -uvoc &lt;voc_dump.sql</example>
        <para>The argument <code>Xbatching</code> instructs the JDBC client to batch instructions before shipping them to the server. Loading the database takes a few seconds on a state-of-the-art machine.</para>
      </subsection>

      <subsection>
        <title>Exploring the VOC data set</title>
        <para>The <code>mjclient</code> contains a <emph>describe</emph> operator, denoted by <code>\d</code> to inspect the definition of the database schema and its tables. This functionality is not available in <code>MapiClient</code>.</para>
        <example xml:space="preserve">voc-&gt; \d
TABLE   sys.craftsmen
TABLE   sys.impotenten
TABLE   sys.invoices
TABLE   sys.passengers
TABLE   sys.seafarers
TABLE   sys.soldiers
TABLE   sys.total
TABLE   sys.voyages</example>
        <para>The set consists of 8 tables, which are all bound to each other using FOREIGN KEY relationships. The voyages table is considered to be the main table, which all others reference to. Every table, except invoices has a PRIMARY KEY defined over the columns number and number_sup. Since the invoices table holds zero or more invoices per voyage (identified by number, number_sub) a PRIMARY KEY constraint is not possible. Details of the tables are readily available.</para>
        <example xml:space="preserve">voc-&gt; \d sys.soldiers
CREATE TABLE "sys"."soldiers" (
        "number"               int      NOT NULL,
        "number_sup"           char(1)  NOT NULL,
        "trip"                 int ,
        "trip_sup"             char(1),
        "onboard_at_departure" int ,
        "death_at_cape"        int ,
        "left_at_cape"         int ,
        "onboard_at_cape"      int ,
        "death_during_voyage"  int ,
        "onboard_at_arrival"   int ,
        CONSTRAINT "soldiers_number_number_sup_pkey" PRIMARY KEY ("number", "number_sup"),
        CONSTRAINT "soldiers_number_number_sup_fkey" FOREIGN KEY ("number", "number_sup") REFERENCES "sys"."voyages" ("number", "number_sup")
);
voc-&gt;</example>
        <para>The tables craftsmen, importenten, passengers, seafarers, and soldiers all share the same columns. We can define a VIEW that combines them all into one big table, to make them easier to access.</para>
        <example xml:space="preserve">voc-&gt; CREATE VIEW onboard_people AS
voc=&gt; SELECT * FROM (
voc=(    SELECT 'craftsmen' AS type, craftsmen.* FROM craftsmen
voc=(    UNION ALL
voc=(    SELECT 'impotenten' AS type, impotenten.* FROM impotenten
voc=(    UNION ALL
voc=(    SELECT 'passengers' AS type, passengers.* FROM passengers
voc=(    UNION ALL
voc=(    SELECT 'seafarers' AS type, seafarers.* FROM seafarers
voc=(    UNION ALL
voc=(    SELECT 'soldiers' AS type, soldiers.* FROM soldiers
voc=(    UNION ALL
voc=(    SELECT 'total' AS type, total.* FROM total
voc=( ) AS onboard_people_table;
Operation successful</example>
        <para>The new view will show up and we can just use it as a normal table, to for instance calculate the number of records for each group of people:</para>
        <example xml:space="preserve">voc-&gt; SELECT type, COUNT(*) AS total FROM onboard_people GROUP BY type ORDER BY type;
+------------+-------+
| type       | total |
+============+=======+
| craftsmen  |  2349 |
| impotenten |   938 |
| passengers |  2813 |
| seafarers  |  4468 |
| soldiers   |  4177 |
| total      |  2454 |
+------------+-------+
6 rows

voc-&gt; select count(*) from impotenten;
+--------------+
| count_number |
+==============+
|          938 |
+--------------+
1 row</example>
        <para>It is possible to play with the set in many ways, to find out several things that took place during the voyages of the ships, or the money that was earned. A few examples are shown below.</para>
        <example xml:space="preserve">voc-&gt; SELECT COUNT(*) FROM voyages WHERE particulars LIKE '%_recked%';
+--------------+
| count_number |
+==============+
|          354 |
+--------------+
1 row

voc-&gt; SELECT chamber, CAST(AVG(invoice) AS integer) AS average
voc=&gt; FROM invoices
voc=&gt; WHERE invoice IS NOT NULL
voc=&gt; GROUP BY chamber
voc=&gt; ORDER BY average DESC;
+---------+----------+
| chamber | average  |
+=========+==========+
| A       |  282996 |
| Z       |  259300 |
| H       |  150182 |
| R       |  149628 |
| D       |  149522 |
| E       |  149518 |
| &lt;NULL&gt;  |   83309 |
+---------+----------+
7 rows

voc-&gt; CREATE VIEW extended_onboard AS SELECT number, number_sup, trip, trip_sup, onboard_at_departure, death_at_cape, left_at_cape, onboard_at_cape, death_during_voyage, onboard_at_arrival, death_during_voyage - left_at_cape AS death_at_arrival FROM onboard_people;
Operation successful</example>
      </subsection>

      <subsection>
        <title>Historical background</title>
        <para>Please take the time to experiment with the VOC data. For your convenience, we give here a short histororical background and interpretation of what to find in this database. The introduction given below is an OCR version from the book: J.R. Bruijn, F.S. Gaastra and I. Schaar, Dutch-Asiatic Shipping in the 17th and 18th Centuries</para>
        <para>This book presents tables which give a virtually complete survey of the direct shipping between the Netherlands and Asia between 1595-1795. This period contains, first, the voyages of the so-called Voorcompagnieand, hence, those for and under control of the Vereenigde Oostindische Compagnie (VOC). The survey ends in 1795. That year saw an end of the regular sailings of the VOC between the Netherlands and Asia, since, following the Batavian revolution in January, the Netherlands became involved in war with England. The last outward voyage left on 26 December 1794. After news of the changed situation in the Netherlands was received in Asia, the last homeward voyage took place in the spring of 1795. The VOC itself was disbanded in 1798.</para>
        <para>In total 66 voyages of the voorcompagnieare listed, one more than the traditionally accepted number. The reconnaissance ship, POSTILJON, from the fleet of Mahu and De Cordes, that was collected en route is given its own number (0022). Since the attempt of the Australische Compagnie to circumvent the monopoly of the VOC can be considered as a continuation of the voorcompagniethe voyage of Schouten and Le Maire is also listed (0196-0197). For the rest, exclusively the outward and homeward voyages of the VOC are mentioned in the tables. Of those there were in total 4722 outward and 3359 homeward. The administration of the company was strictly followed, so that, for example, the voyage of Hudson in 1609 (0133) is listed, but not that of Roggeveen in 1721-1722. Voyages of East Indiamen that were driven off course, and arrived for instance in Surinam, or those which went no further than the Cape are mentioned, as opposed to those of warships of the five Admiralties which, from 1783, were sent to Asia to protect the fleets and possessions of the VOC.</para>
        <para>The sources of the journeys consist primarily of the archives of the VOC in the Algemeen Rijksarchief in The Hague. They are, on the one hand, the so-called 'Uitloopboeken' and ship registers, and, on the other, the 'Overgekomen Brieven en Papieren' (OBP's). The latter contain the regular reports on the arrival and departure of ships in Batavia and other Asiatic harbors. In addition, the 'Overgekomen Brieven van de Kaap de Goede Hoop' and some other, more dispersed sources must be mentioned. The data on the voyages of the voorcompagniederive above all from ources published by the Linschoten Vereeniging.</para>
        <para>In volume I, the principal sources are described extensively and the origin of the information on each voyage is given. In addition, that volume contains an introduction on the organization of the VOC's shipping, which also includes an analysis and summary of the data presented in the tables. Various other supplementary information, such as the value of the export from the Netherlands, only available by year, is also published there. The tables follow closely the material presented in the major sources ('Uitloopboeken' en OBP's). Since these sources are not uniform over a period of almost two centuries, the level of completeness of the information given for each voyage also varies.</para>
        <para><emph>Homeward voyage</emph> During the compilation of the tables it became necessary in a few cases to add an A to some numbers. This occurred 5 times, in the following places: 5022, 5980, 5987, 6246 and 6649. Similarly in three cases a number had to be left open. The following numbers have not been used: 4605, 5027 and 8215. The voyage number is followed by a figure which shows whether the ship is making its first, second or subsequent voyage. The outward and homeward voyages are counted separately. The first voyage from the Netherlands and the subsequent homeward voyages are both shown by a `1'. Occasionally a ship was built or acquired in Asia. The first outward voyage of such a ship is considered as its second voyage.</para>
        <para><emph>Ship's name</emph> A uniform spelling has been chosen for the numerous variants given in the sources. In alphabetical ordering and in the index, the most relevant word was chosen. Thus the WAPEN VAN, HOORN (0243) is given under HOORN, the HOF NIET ALTIJD ZOMER (2380) under ZOMER and the VROUWE REBECCA JACOBA (3668) under REBECCA. It should be noted that especially in the seventeenth century ships' names were frequently provided with additions which were not used in a consistent fashion. The AMSTERDAM (0431) was sometimes called NIEUWAMSTERDAM, the WITTE OLIFANT (0533), the OLIFANT. The most frequent name is given in the tables. In the eighteenth century, especially, ships' names were frequently changed, or they used each other's names. This is always mentioned under the heading Particulars and in the index.</para>
        <para><emph>Master's name</emph> Similarly, a uniform spelling has been chosen for the name of the master, generally schipper, but in the eighteenth century also a kapitein or kapiteinluitenant. The index is arranged by surname or patronymic.</para>
        <para><emph>Tonnage</emph> The volume of the ships is given in metric tons. The sources give the figures in lasten (1 last = 2 tons). After 1636, however, information in lasten is no longer of any value, as, for fiscal reasons, the VOC's figures were kept artificially low. From then on the volume has been calculated on the basis of the measurements of the ships, according to a simple formula (volume in lasten = length x breadth x depth in Amsterdam feet, divided by 200; 1 ft. = 28,3 cm). The results of this calculation have been doubled and are given in the tables. This method and the problems regarding the assessment of the ships' volume is described in Volume I. In a number of cases where inconsistent information was found, both calculations are given, thus e.g. 600/850.</para>
        <para><emph>Type of ship</emph> Occasionally, in those cases where this is mentioned in the sources, the type of the ship is given in the same column as the tonnage. In general, the most frequent type of ship, the retourschip (East Indiaman) is not mentioned in the sources. Therefore, where the type of ship is not mentioned, it may often be assumed that an East Indiaman is meant. The various other types - hoeker, kat, pinas, jacht, fluit, paketboot - are given in Dutch.</para>
        <para><emph>Built</emph> The year given in this column refers to the year in which the ship was built. If the ship was hired or bought by the VOC, then this is mentioned in the column, together with the year in which the transaction occurred.</para>
        <para><emph>Yard</emph> The place is given where the ship was built. The chambers of the VOC had their own yard. 'A' refers to Amsterdam, 'Z' to Zeeland, 'D' to Delft, 'R' to Rotterdam, 'H' to Hoorn, and 'E' to Enkhuizen. When a ship was hired or bought by the VOC, the letter indicates the chamber that was responsible for the transaction. The ships of the voorcompagniedid not belong to a chamber. In these cases, A' indicates that a ship was built at an Amsterdam yard. The chambers also had no part in the buying or building of ships by the Hoge Regering in Batavia. In these cases the place of building or purchase in Asia is given.</para>
        <para><emph>Chamber</emph> With the outward voyages, this column gives the chamber which equipped the ship; with the homeward, the chamber to which the ship was addressed. There is no entry in this column for ships organized by the voorcompagnie</para>
        <para><emph>Departure</emph></para>
        <para>Under this heading is given the date and place of departure from Europe, Asia or the Cape of Good Hope. A date like 03-02-1645 refers to 3 February 1645. Where sailings from the Republic are concerned, the date given refers to the departure from the roads. Amsterdam, Hoorn and Enkhuizen ships generally left from Texel roads, Zeeland ships from the Wielingen or the roads of Rammekens, and Rotterdam and Delft ships from Goeree. Sometimes, ships were forced by storms or damage to return to the roads for a time or they sought shelter in one of the estuaries on the coast of Holland or Zeeland. Where possible, this is mentioned under the heading Particulars. In general the first date of departure is given in the tables, but in some cases, a later date has been chosen, in deference to the sources.</para>
        <para>As for leaving Batavia, departure from the roads of the town was decisive, and not, as is frequently described in the Company papers, the reaching of the `open sea' after passing the Sunda Strait. Where departures from other Asian ports are concerned in general only the Company establishment from which the ship sailed is given. Thus Ceylon is mentioned in the columns, but it can be assumed that most ships left from the Bay of Galle, at the southern point of the island. China is given for ships which left from Canton, and the date refers to departure from the roads at Whampoa. Bengal is given for ships which left from the anchorage in the Ganges close to the VOC-establishment at Hughly.</para>
        <para><emph>Call at Cape</emph> The data in this column give the arrival at (above) and the departure (below) from the Cape of Good Hope. In general no distinction is made between Table Bay and False Bay. Mention is made, when given in the sources, of ships which put in to the more northerly Saldanha and St. Helena Bays. When a ship sailed past the Cape, this is denoted by `no call'. When it is not known whether the ship stopped at the Cape at all - especially frequent before the foundation of the refreshment station there in 1652 - the column is left blank.</para>
        <para><emph>Arrival</emph> The third column contains the date and place of arrival in Asia, Europe or, when that was the destination of the journey, at the Cape of Good Hope. The place of arrival is given in the same manner as that of departure, though, in addition to the estuaries mentioned above, ships sometimes arrived in the Netherlands via the Vlie or at Delfzijl. The place of arrival in Asia refers to the establishment reached, unless the sources specify the actual port.</para>
        <para><emph>On board</emph> It is possible to differentiate the number of those on board into various categories. For the outward journey, these are seafarers, soldiers, craftsmen, and passengers. The craftsmen are those who were employed to perform some particular service in Asia, and are thus not part of the crew as such. 'Passengers' is in fact a residual category, including high officials of the Company, including ministers of religion with their wives and servants, but also slaves and stowaways. Whenever such a differentiation is not possible, which is especially the case in the early years, a figure for the total is given. Italics are used for this, or when the figures refer to more than one category. Only those categories are mentioned which were on board. Therefore, when one category is mentioned, this implies that the others were not represented on board.</para>
        <para>The sources for the return voyages are of a different kind and normally far less complete. They are totally absent for the journey between the Cape and the Netherlands. However, another category must be mentioned, namely the impotenten, who for various reasons were released from active service for the VOC and sent back to Europe. With regard to many voyages the sources only give the number of passengers and impotenten, and not the number of sailors and soldiers. Obviously, the absence of figures under these headings does not imply that there were none on board.</para>
        <para>Information on the outward voyages is divided into six columns:</para>
        <enumerate first="1">
          <item>
            <para>onboard_at_departure The number on board at departure</para>
          </item>
          <item>
            <para>death_at_cape The number dying between the Netherlands and the Cape. Frequently this figure refers to all the categories together, even when the other information is available per category. In such cases this figure is printed in italics.</para>
          </item>
          <item>
            <para>left_at_cape The number who leave the ship at the Cape.</para>
          </item>
          <item>
            <para>onboard_at_cape The number who come on board at the Cape.</para>
          </item>
          <item>
            <para>death_during_voyage The number dying on the whole voyage. Subtraction of III from V gives the number dying between the Cape and Asia.</para>
          </item>
          <item>
            <para>onboard_at_arrival The number on board on arrival in Asia.</para>
          </item>
        </enumerate>
        <para>Three columns are given for the homeward voyages:</para>
        <enumerate first="1">
          <item>
            <para>onboard_at_departure The number on board at departure</para>
          </item>
          <item>
            <para>death_at_cape The number dying en route to the Cape</para>
          </item>
          <item>
            <para>left_at_cape The number who went from board at the Cape</para>
          </item>
        </enumerate>
        <para>The figures in the various columns are taken from different sources which are not always consistent with each other. Therefore the figures on changes in the number of those on board during the voyages do not always tally with those on the size of the crew at departure and arrival.</para>
        <para><emph>Invoice value</emph> For the return voyages, the total value of the ship's cargo, according to the invoice made up in Batavia or some other establishment, is given, as is the chamber for which the cargo was destined. Generally, this was for the chamber under whose jurisdiction the ship sailed, but occasionally a proportion of the cargo was for one or more of the other chambers.</para>
        <para><emph>Particulars</emph> Under the last heading details deriving from the basic sources are given. They are generally incidental and as such not to be placed in one of the preceding columns. Because the sources are not the same across the whole period, and at times less complete, the extent and sort of material under this heading could not be consistent.</para>
        <para>In so far as it is available, information deals with the ports of call on the journey, with the details of changes in the composition of the crew and with the eventual fate of the ship. For the return voyage, the name of the fleet-commander is generally given, and, after his name, the number of the ship he was on. Finally, where necessary, differences in data between various sources are indicated. Occasionally, particulars from a published source are added.</para>
        <para><emph>Corresponding number</emph> This number, placed at the far right of the tables, denotes the next homeward voyage of the ship in volume II (naturally absent when the ship remains in Asia), or, in volume III, for homeward voyages, the number of the ship's previous outward voyage. In those cases where the ship was acquired in Asia, no corresponding number is given for the first homeward voyage from Asia.</para>
        <para>Due to the long duration of the preparation of these two volumes there are some inconsistencies in the text of the particulars and in the use of language.</para>
      </subsection>
    </section>
  </node>
  <node>
    <nodename>SQL Language</nodename>
    <nodenext>SQL Preface</nodenext>
    <nodeprev>The VOC Tutorial</nodeprev>
    <nodeup>SQL</nodeup>
    <section>
      <title>SQL Language</title>
      <para>The MonetDB/SQL language follows the SQL-2003 specification. This section introduces the language components supported in the current and upcoming releases.</para>
      <menu>
        <menuentry>
          <menunode>SQL Preface</menunode>
          <menutitle>SQL Preface</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>SQL Data Definition</menunode>
          <menutitle>SQL Data Definition </menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>SQL Data Types</menunode>
          <menutitle>SQL Data Types</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>SQL Data Manipulation</menunode>
          <menutitle>SQL Data Manipulation </menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>SQL Schema Definition</menunode>
          <menutitle>SQL Schema Definition</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>SQL Users</menunode>
          <menutitle>SQL Users</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>SQL Transactions</menunode>
          <menutitle>SQL Transactions</menutitle>
          <menucomment></menucomment>
        </menuentry>
      </menu>
    </section>
  </node>
  <node>
    <nodename>SQL Preface</nodename>
    <nodenext>SQL Data Definition</nodenext>
    <nodeprev>SQL Language</nodeprev>
    <nodeup>SQL Language</nodeup>
    <subsection>
      <title>SQL Preface</title>
      <para>We use the following notation to explain the supported variation SQL. The SQL syntax is summarized in extended BNF. Alternative constructs are seperated by | and grouped by parenthesis. Optional parts are marked with square brackets. A repetition is marked with either '+' or '*' to indicate at least once and many times, respectively. Lexical tokens are illustrated in capitals.</para>
      <para>Sometimes MonetDB/SQL supports extra syntax this is identified by a '+' before the clause. Unfortunately, we do not support the full SQL 2003 jet and this is specified by a '-' before the clause. If next to the '-' a '&lt;' and version number are given the feature is supported in the older releases.</para>
      <para>Currently we have partial support for SQL-2003. Features are added when (enough) users express their interest in these.</para>
      <itemize>
        <itemfunction><bullet/></itemfunction>
        <item>
          <para>Cursors, because the underlying engine is not based on record iterators.</para>
        </item>
        <item>
          <para>Triggers They will be supported in a future release.</para>
        </item>
        <item>
          <para>Asserts They will be supported in a future release.</para>
        </item>
        <item>
          <para>Domains</para>
        </item>
        <item>
          <para>Collate</para>
        </item>
        <item>
          <para>Character sets</para>
        </item>
        <item>
          <para>SQL User Defined Types</para>
        </item>
      </itemize>
    </subsection>
  </node>
  <node>
    <nodename>SQL Data Definition</nodename>
    <nodenext>SQL Data Types</nodenext>
    <nodeprev>SQL Preface</nodeprev>
    <nodeup>SQL Language</nodeup>
    <subsection>
      <title>SQL Data Definition</title>
      <subsubsection>
        <title>Create TABLE</title>
        <para>The parser currently supports the full &lt;table scope&gt; specifier, but the implementation is limited to LOCAL TEMPORARY tables (ie the tables are only visable in the clients session) and on COMMIT we 'DROP' these temporaries.</para>
        <verbatim xml:space="preserve"><![CDATA[
The CREATE table statement follows the 2003 syntax, ie 

	CREATE [ <table scope> ] TABLE 
		<table name> 
		<table contents source>
		[ ON COMMIT <table commit action> ROWS ]
		+[ ON COMMIT DROP ]

	<table scope> ::= <global or local> TEMPORARY

	<global or local> ::= GLOBAL | LOCAL

	<table commit action> ::= PRESERVE | DELETE

<table contents source> ::=
		<table element list>
	-|	OF <path-resolved user-defined type name> [ <subtable clause> ] [ <table element list> ]
	-<3.0|	<as subquery clause>

<table element list> ::= ( <table element> [ { , <table element> }... ] )

<table element> ::=
		<column definition>
	|	<table constraint definition>
	|	<like clause>
	-|	<self-referencing column specification>
	|	<column options>

-<self-referencing column specification> ::= REF IS <self-referencing column name> <reference generation>

-<reference generation> ::= SYSTEM GENERATED | USER GENERATED | DERIVED

-<self-referencing column name> ::= <column name>

<column options> ::= <column name> WITH OPTIONS <column option list>

<column option list> ::= [ -<scope clause> ] [ <default clause> ] [ <column constraint definition>... ]

-<subtable clause> ::= UNDER <supertable clause>

-<supertable clause> ::= <supertable name>

-<supertable name> ::= <table name>
]]></verbatim>
      </subsubsection>

      <subsubsection>
        <title>create table like</title>
        <para>It is posible to create a table which looks like an existing table. This can be done using the create table like statement. Currently there is no support for additional options. A work around is to use the alter statement to change options.</para>
        <verbatim xml:space="preserve"><![CDATA[
<like clause> ::= LIKE <table name> [ <like options> ]

-<like options> ::= <identity option> | <column default option>

-<identity option> ::= INCLUDING IDENTITY | EXCLUDING IDENTITY

-<column default option> ::= INCLUDING DEFAULTS | EXCLUDING DEFAULTS
]]></verbatim>
      </subsubsection>

      <subsubsection>
        <title>create table AS subquery</title>
        <para>As of version 3.0 support is added for table construction based on subqueries.</para>
        <verbatim xml:space="preserve"><![CDATA[
-<3.0	<as subquery clause> ::= [ ( <column name list> ) ] AS <subquery> <with or without data>

-<3.0	<with or without data> ::= WITH NO DATA | WITH DATA
]]></verbatim>
      </subsubsection>

      <subsubsection>
        <title>columns</title>
        <verbatim xml:space="preserve"><![CDATA[
<column definition> ::=
                <column name> [ <data type> | -<domain name> ] [ -<reference scope check> ]
                [ <default clause> | <identity column specification> | -<generation clause> ]
                [ <column constraint definition>... ] [ -<collate clause> ]
]]></verbatim>
      </subsubsection>

      <subsubsection>
        <title>Identity column</title>
        <para>SQL 2003 added identity columns, which are columns for which the values are coming from a sequenc generator. Besides the SQL 2003 syntax also the syntax from mysql (auto_increment) and postgress (serial data type) are supported.</para>
        <verbatim xml:space="preserve"><![CDATA[
<identity column specification> ::=
                GENERATED { ALWAYS | BY DEFAULT } AS IDENTITY
                [ ( <common sequence generator options> ) ]
	+| 	auto_increment

-<generation clause> ::= <generation rule> AS <generation expression>

-<generation rule> ::= GENERATED ALWAYS

-<generation expression> ::= ( <value expression> )
]]></verbatim>
      </subsubsection>

      <subsubsection>
        <title>Default values</title>
<!-- p -->
<!-- Specify the default for a column, domain, or attribute. -->
<!-- /p -->
<!-- as domain/attribute are currently not support default values are only -->
<!-- important for columns -->
        <para>To make insert statements easier a default value can associated with each column. Besides literal values, temporal and sequence functions can be used as default value. Value of these functions at insert time will be used. 
<!-- todo explain that our DEFAULT is more powerfull (like postgress), ie -->
<!-- support any function not just temporal and sequence related --></para>
        <verbatim xml:space="preserve"><![CDATA[
<default clause> ::= DEFAULT <default option>

<default option> ::=
                <literal>
        |       <datetime value function>
        |       USER
        |       CURRENT_USER
        |       CURRENT_ROLE
        |       SESSION_USER
        |       NULL
	+|	NEXT VALUE FOR <sequence name>
]]></verbatim>
        <para>For example an auto increment column can be created using the following column specification: 	col_name integer default NEXT VALUE FOR sequence_name</para>
      </subsubsection>

      <subsubsection>
        <title>Column and Table Constraints</title>
        <para>Column and Table constraints are supported. Besides the simple NOT NULL check also UNIQUE, PRIMARY and FOREIGN keys are supported. The limitation stems from the missing triggers, ie we currently check constraints directly on insert, update and delete. The NULL matching on foreign keys is limited to the SIMPLE MATCH type (NULL values statisfy the constraint). The FULL and PARTIAL MATCH types are not supported. The referential action is currently limited to RESTRICT, ie an update fails if a other columns have references to it.</para>
        <verbatim xml:space="preserve"><![CDATA[
<column constraint definition> ::= [ <constraint name definition> ] <column constraint> [ <constraint characteristics> ]

<column constraint> ::=
                NOT NULL
        |       <unique specification>
        |       <references specification>
        -|       <check constraint definition>

@c  we need to update to the new 2003 syntax soon...

<reference scope check> ::= REFERENCES ARE [ NOT ] CHECKED [ ON DELETE <reference scope check action> ]

<reference scope check action> ::= <referential action>

--h3 11.6 <table constraint definition> (p543)
--/h3

--p 
Specify an integrity constraint.
--/p

<table constraint definition> ::= [ <constraint name definition> ] <table constraint> [ <constraint characteristics> ]

<table constraint> ::=
		<unique constraint definition>
	|	<referential constraint definition>
	|	<check constraint definition>


<unique constraint definition> ::=
		<unique specification> ( <unique column list> )
	-|	UNIQUE ( VALUE )

<unique specification> ::= UNIQUE | PRIMARY KEY

<unique column list> ::= <column name list>

--h3 11.8 <referential constraint definition> (p547)
--/h3

--p 
Specify a referential constraint.
--/p

<referential constraint definition> ::= FOREIGN KEY ( <referencing columns> ) <references specification>

<references specification> ::= REFERENCES <referenced table and columns> [ MATCH <match type> ] [ <referential triggered action> ]

<match type> ::= FULL | PARTIAL | SIMPLE

<referencing columns> ::= <reference column list>

<referenced table and columns> ::= <table name> [ ( <reference column list> ) ]

<reference column list> ::= <column name list>

<referential triggered action> ::= <update rule> [ <delete rule> ] | <delete rule> [ <update rule> ]

<update rule> ::= ON UPDATE <referential action>

<delete rule> ::= ON DELETE <referential action>

<referential action> ::= CASCADE | SET NULL | SET DEFAULT | RESTRICT | NO ACTION

<check constraint definition> ::= CHECK ( <search condition> )

@subsubsection ALTER TABLE

<alter table statement> ::= ALTER TABLE <table name> <alter table action>

<alter table action> ::=
		<add column definition>
	|	<alter column definition>
	|	<drop column definition>
	|	<add table constraint definition>
	|	<drop table constraint definition>

@subsubsection ADD column

<add column definition> ::= ADD [ COLUMN ] <column definition>

@subsubsection ALTER column

<alter column definition> ::= ALTER [ COLUMN ] <column name> <alter column action>
<alter column action> ::=
		<set column default clause>
	|	<drop column default clause>
	|	<add column scope clause>
	|	<drop column scope clause>
	|	<alter identity column specification>

<set column default clause> ::= SET <default clause>
<drop column default clause> ::= DROP DEFAULT
-<add column scope clause> ::= ADD <scope clause>
-<drop column scope clause> ::= DROP SCOPE <drop behavior>

<alter identity column specification> ::= <alter identity column option>...

<alter identity column option> ::=
		<alter sequence generator restart option>
	|	SET <basic sequence generator option>

<drop column definition> ::= DROP [ COLUMN ] <column name> <drop behavior>

@subsubsection ADD constraint
<add table constraint definition> ::= ADD <table constraint definition>
<drop table constraint definition> ::= DROP CONSTRAINT <constraint name> <drop behavior>

@subsubsection DROP table
<drop table statement> ::= DROP TABLE <table name> <drop behavior>


]]></verbatim>
      </subsubsection>

      <subsubsection>
        <title>CREATE VIEW</title>
        <para>Regular view specifications are supported. However, recursive views and referenceable views are not supported. Next to this 2003 feature we support creating a view on top of a set of bats. In this case the query expression is replaced by the keyword BATS, and the bats are found based on the view specification. As this feature requires indepth knowledge of the system it is only open to the ADMIN_ROLE.</para>
        <verbatim xml:space="preserve"><![CDATA[
<view definition> ::=
                CREATE -[ RECURSIVE ] VIEW <table name> <view specification> AS <view query expression>
                [ WITH -[ <levels clause> ] CHECK OPTION ]

<view query expression> ::=
	<query expression>
 +|	BATS

<view specification> ::= <regular view specification> | <referenceable view specification>

<regular view specification> ::= [ ( <view column list> ) ]

-<referenceable view specification> ::= OF <path-resolved user-defined type name> [ <subview clause> ] [ <view element list> ]

-<subview clause> ::= UNDER <table name>

<view element list> ::= ( <view element> [ { , <view element> }... ] )

<view element> ::= <self-referencing column specification> | <view column option>

<view column option> ::= <column name> WITH OPTIONS -<scope clause>

<levels clause> ::= CASCADED | LOCAL

<view column list> ::= <column name list>

]]></verbatim>
      </subsubsection>
    </subsection>
  </node>
  <node>
    <nodename>SQL Data Types</nodename>
    <nodenext>SQL Data Manipulation</nodenext>
    <nodeprev>SQL Data Definition</nodeprev>
    <nodeup>SQL Language</nodeup>
    <subsection>
      <title>SQL Data Types</title>
      <para>MonetDB/SQL supports the following list of types.</para>
      <multitable>
        <columnfraction>39</columnfraction>
        <columnfraction>45</columnfraction>
<!-- @item SQLSTATE ?			@tab -->
        <tbody>
          <row>
            <entry>CHAR[ACTER] (L)</entry>
            <entry>character string with length L</entry>
          </row>
          <row>
            <entry>VARCHAR (L) | CHARACTER VARYING (L)</entry>
            <entry>string with atmost length L</entry>
          </row>
          <row>
            <entry>CLOB | CHARACTER LARGE OBJECT</entry>
          </row>
          <row>
            <entry>BLOB | BINARY LARGE OBJECT</entry>
          </row>
          <row>
            <entry>DECIMAL(P,S) | NUMERIC(P,S)</entry>
          </row>
          <row>
            <entry>SMALLINT</entry>
            <entry>16 bit integer</entry>
          </row>
          <row>
            <entry>INT</entry>
            <entry>32 bit integer</entry>
          </row>
          <row>
            <entry>BIGINT</entry>
            <entry>64 bit integer</entry>
          </row>
          <row>
            <entry>serial</entry>
            <entry>special 64 bit integer (sequence generator)</entry>
          </row>
          <row>
            <entry>REAL</entry>
            <entry>32 bit floating point</entry>
          </row>
          <row>
            <entry>DOUBLE [PRECISION]</entry>
            <entry>64 bit floating point</entry>
          </row>
          <row>
            <entry>BOO[LEAN]</entry>
          </row>
          <row>
            <entry>DATE</entry>
          </row>
          <row>
            <entry>TIME(T)</entry>
          </row>
          <row>
            <entry>TIMESTAMP(T)</entry>
          </row>
          <row>
            <entry>INTERVAL(Q) 
<!-- @item user-defined type -->
<!-- @item REF				@tab char, with length N -->
<!-- @item ROW -->
<!-- @item ARRAY -->
<!-- @item MULTISET --></entry>
          </row>
        </tbody>
      </multitable>
    </subsection>
  </node>
  <node>
    <nodename>SQL Data Manipulation</nodename>
    <nodenext>SQL Schema Definition</nodenext>
    <nodeprev>SQL Data Types</nodeprev>
    <nodeup>SQL Language</nodeup>
    <subsection>
      <title>SQL Data Manipulation</title>
    </subsection>
  </node>
  <node>
    <nodename>SQL Schema Definition</nodename>
    <nodenext>SQL Users</nodenext>
    <nodeprev>SQL Data Manipulation</nodeprev>
    <nodeup>SQL Language</nodeup>
    <subsection>
      <title>SQL Schema Definition</title>
    </subsection>
  </node>
  <node>
    <nodename>SQL Users</nodename>
    <nodenext>SQL Transactions</nodenext>
    <nodeprev>SQL Schema Definition</nodeprev>
    <nodeup>SQL Language</nodeup>
    <subsection>
      <title>SQL Users</title>
    </subsection>
  </node>
  <node>
    <nodename>SQL Transactions</nodename>
    <nodenext>MonetDB/SQL Features</nodenext>
    <nodeprev>SQL Users</nodeprev>
    <nodeup>SQL Language</nodeup>
    <subsection>
      <title>SQL Transactions</title>
    </subsection>
  </node>
  <node>
    <nodename>MonetDB/SQL Features</nodename>
    <nodenext>Feature List</nodenext>
    <nodeprev>SQL Transactions</nodeprev>
    <nodeup>SQL</nodeup>
    <section>
      <title>MonetDB/SQL Features</title>
      <para>The SQL Implementation implementation is based on the SQL-99 standard. It is built incrementally over time to cope with the effort required to realize all features. Priority is given to those features relevant to our research and upon request from our valued partners.</para>
      <para>The plethora of SQL implementations also show that the standard alone is hardly sufficient. All database systems have extended or twisted the language definition to satisfy the needs of their customer, to support legacy, and to better tap into the functionality offered by their kernel implementations. MonetDB/SQL is bound to follow this path too. The kernel imposes limitations on the features that can and cannot be realized. The are summarized in <xref><xrefnodename>Development Roadmap</xrefnodename></xref>.</para>
      <para>In the context of programming support, we provide a few primitives to simplify debugging of SQL programs. They are described separately. The list below provides a synopsis of the SQL features supported in the released version.</para>
      <menu>
        <menuentry>
          <menunode>Feature List</menunode>
          <menutitle>Feature List</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>SET Statement</menunode>
          <menutitle>SET Statement</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>EXPLAIN Statement</menunode>
          <menutitle>EXPLAIN Statement</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>DEBUG Statement</menunode>
          <menutitle>DEBUG Statement</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Optimizer Control</menunode>
          <menutitle>Optimizer Control</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Overlaying the BAT storage</menunode>
          <menutitle>Overlaying the BAT storage</menutitle>
          <menucomment></menucomment>
        </menuentry>
      </menu>
    </section>
  </node>
  <node>
    <nodename>Feature List</nodename>
    <nodenext>SET Statement</nodenext>
    <nodeprev>MonetDB/SQL Features</nodeprev>
    <nodeup>MonetDB/SQL Features</nodeup>
    <subsection>
      <title>SQL-99 Feature list</title>
      <para>In this section we give an itemized list of the SQL-99 features supported in the current release.</para>
      <itemize>
        <itemfunction><bullet/></itemfunction>
        <item>
          <para>Primary and foreign key integrity enforcement.</para>
        </item>
        <item>
          <para>Subqueries are fully supported.</para>
        </item>
        <item>
          <para>Table expression <code>union</code> and <code>intersection</code>.</para>
        </item>
        <item>
          <para>Table views for query processing only.</para>
        </item>
        <item>
          <para>Binding SQL functions with to externally supplied routines.</para>
        </item>
        <item>
          <para>Auto-increment keys (SQL 2003).</para>
        </item>
      </itemize>
    </subsection>
  </node>
  <node>
    <nodename>SET Statement</nodename>
    <nodenext>EXPLAIN Statement</nodenext>
    <nodeprev>Feature List</nodeprev>
    <nodeup>MonetDB/SQL Features</nodeup>
    <subsection>
      <title>SET Statement</title>
      <para>MonetDB/SQL comes with a limited variable scheme. Globel, session based variables can be introduced using the construct:</para>
      <example xml:space="preserve">SET &lt;variable&gt;=&lt;string&gt;
SET &lt;variable&gt;=&lt;boolean&gt;
SET &lt;variable&gt;=&lt;int&gt;</example>
      <para>Their type is inherited from the literal value supplied. The SQL engine comes with a limited set of environment variables to control its behavior.</para>
      <itemize>
        <itemfunction><bullet/></itemfunction>
        <item>
          <para>The <code>debug</code> variable takes an integer and sets the server global debug flag. (See MonetDB documentation) It also activates the debugger when the query is being executed.</para>
        </item>
        <item>
          <para>The <code>explain</code> variable currently takes the values 'plan' or 'performance'. The 'plan' qualifier produces a relational table with the plan derived for execution using the applicable back end and optimizer schemes. The 'performance' qualifier produces a performance trace of the SQL queries for post analysis. It is available in the system table called <code>history</code>. Omission of either qualifier merely results in a straight execution of the query.</para>
        </item>
        <item>
          <para>The <code>auto_commit</code> variable takes a boolean and controls automatic commit after a successful SQL execution, or conversely an automatic rollback.</para>
        </item>
        <item>
          <para>The <code>reply_size</code> limits the number of tuples sent to the front end. [It is unclear how the remainder can be obtained within the SQL language framework. The reply_size should be replaced by the <code>limit</code> language construct]</para>
        </item>
        <item>
          <para>The <code>history</code> variable is a boolean flag which leads to capturing execution information of any SQL query in a table for post-analysis.</para>
        </item>
      </itemize>
      <para>By default all remaining variables are stored as strings and any type analysis is up to the user. The can be freely used by the SQL programmer for inclusion in his queries. [TODO, a little more flexibilty would mean a lot]</para>
      <para>The variables and their type definition are assembled in a system table called 'sessions'. Its default content is shown below:</para>
      <example xml:space="preserve">&gt;select * from sessions;
#---------------------------------------------------------------------#
# t                     t                   t               t         # name
# str                   str                 str             int       # type
#---------------------------------------------------------------------#
[ "debug",                "0",                "int",          0       ]
[ "reply_size",           "-1",               "int",          0       ]
[ "explain",              "",                 "varchar",      0       ]
[ "auto_commit",          "false",            "boolean",      0       ]
[ "current_schema",       "sys",              "varchar",      1       ]
[ "current_user",         "monetdb",          "varchar",      1       ]
[ "current_role",         "monetdb",          "varchar",      0       ]
[ "current_timezone",     "0",                "sec_interval", 0       ]
[ "optimizer",            "yes",              "varchar",      0       ]</example>
    </subsection>
  </node>
  <node>
    <nodename>EXPLAIN Statement</nodename>
    <nodenext>DEBUG Statement</nodenext>
    <nodeprev>SET Statement</nodeprev>
    <nodeup>MonetDB/SQL Features</nodeup>
    <subsection>
      <title>EXPLAIN Statement</title>
      <para>The intermediate code produced by the SQL Implementation compiler can be made visible using the <code>explain</code> statement modifier. It gives a detailed description of the actions taken to produce the answer. The example below illustrates what you can expect when a simple query is pre-pended by the <code>explain</code> modifier. Although the details of this program are better understood when you have read the Chapter on MAL <xref><xrefnodename>MonetDB Assembler Language</xrefnodename></xref> the global structure is easy to explain.</para>
      <verbatim xml:space="preserve"><![CDATA[
>select count(*) from tables;
[ 27 ]
>explain select count(*) from tables;
#factory sql_cache.s1_0():bit;
#    _2:bat[:void,:int]  := sql.bind("sys","ptables","id",0);
#    _8:bat[:void,:int]  := sql.bind("sys","ptables","id",1);
#    _11 := bat.setWriteMode(_8);
#    _15:bat[:oid,:int]  := sql.bind("sys","ptables","id",3);
#    _18 := bat.setWriteMode(_15);
#    _24:bat[:void,:oid]  := sql.bind_dbat("sys","ptables",0);
#    _39:bat[:void,:int]  := sql.bind("sys","ttables","id",0);
#    _45:bat[:void,:oid]  := sql.bind_dbat("sys","ttables",0);
#barrier _90 := true;
#    _13 := algebra.kunion(_2,_11);
#    _20 := algebra.kdifference(_13,_18);
#    _22 := algebra.kunion(_20,_18);
#    _26 := bat.reverse(_24);
#    _28 := algebra.kdifference(_22,_26);
#    _33 := algebra.markT(_28,0@0);
#    _35 := bat.reverse(_33);
#    _37 := algebra.join(_35,_22);
#    _47 := bat.reverse(_45);
#    _49 := algebra.kdifference(_39,_47);
#    _53 := algebra.markT(_49,0@0);
#    _55 := bat.reverse(_53);
#    _57 := algebra.join(_55,_39);
#    _59 := bat.setWriteMode(_37);
#    bat.append(_59,_57);
#    _65 := algebra.markT(_59,0@0);
#    _67 := bat.reverse(_65);
#    _69 := algebra.join(_67,_59);
#    _74 := algebra.markT(_69,0@0);
#    _76 := bat.reverse(_74);
#    _78 := algebra.join(_76,_69);
#    _80 := aggr.count(_78);
#    sql.exportValue(1,"sys.tables","count_id","int",32,0,6,_80);
#    yield _90;
#    redo _90;
#exit _90;
#end s1_0;
]]></verbatim>
      <para>The SQL compiler keeps a limited cache of queries. Each query is looked up in this cache based on an expression pattern match where the constants may take on different values. If it doesn;t exist, the query is converted into a <emph>factory</emph> code block and stored in the module <code>sqlcache</code>. It consists of a prelude section, which locates the tables of interest in the SQL catalogs. The block between <code>barrier</code> and <code>yield</code> is the actual code executed upon each call of this function. It is a large collection of relational algebra operators, whose execution semantics depend on the actual MAL engine. The <code>factory</code> ensures that only this part is called when the query is executed repetitively.</para>
      <para>The call to the cached function is included in the function <code>main</code>, which is the only piece of code produced if the query is used more than once. The query cache disappears when the server is brought to a halt.</para>
      <para>When/how is the cache cleared? Can you list elements in the cache directly, e.g <code>explain;</code> or <code>explain sqlcache</code> or <code>explain sqlcache.sql0;</code></para>
    </subsection>
  </node>
  <node>
    <nodename>DEBUG Statement</nodename>
    <nodenext>Optimizer Control</nodenext>
    <nodeprev>EXPLAIN Statement</nodeprev>
    <nodeup>MonetDB/SQL Features</nodeup>
    <subsection>
      <title>DEBUG Statement</title>
      <para>The SQL statements are translated into MAL programs, which are optimized and stored away in an <code>sql_cache</code> module. The generated code can be debugged with the MAL debugger. It provides a simple mechanism to trace the execution, hunting for possible errors and detect performance bottlenecks (<xref><xrefnodename>Runtime Inspection</xrefnodename></xref>).</para>
      <para>The example below, illustrates how you can easily obtain a quick overview of the cost components of the query using the debugger timer flag and <code>continuation</code> command for the debugger.</para>
      <para>[ERROR: the 'start transaction' is needed now]</para>
      <verbatim xml:space="preserve"><![CDATA[
>start transaction;
&4 f
>debug select count(*) from tables;
#mdb #    mdb.start();
mdb>next
#mdb #    sql_cache.s0_0();
mdb>timer
mdb>continue
#    13 usec#    _2:bat[:void,:int]  := sql.bind(_3="sys", _4="ptables", _5="id", _6=0)
#     2 usec#    _8:bat[:void,:int]  := sql.bind(_3="sys", _4="ptables", _5="id", _9=1)
#     3 usec#    _11 := bat.setWriteMode(_8=<tmp_515>)
#     2 usec#    _15:bat[:oid,:int]  := sql.bind(_3="sys", _4="ptables", _5="id", _16=3)
#     1 usec#    _18 := bat.setWriteMode(_15=<tmp_516>)
#     2 usec#    _24:bat[:void,:oid]  := sql.bind_dbat(_3="sys", _4="ptables", _6=0)
#     4 usec#    _39:bat[:void,:int]  := sql.bind(_40="sys", _41="ttables", _42="id", _43=0)
#     1 usec#    _45:bat[:void,:oid]  := sql.bind_dbat(_40="sys", _41="ttables", _43=0)
#    17 usec#    _13 := algebra.kunion(_2=<tmp_26>, _11=<tmp_515>)
#     7 usec#    _20 := algebra.kdifference(_13=<tmp_1372>, _18=<tmp_516>)
#     3 usec#    _22 := algebra.kunion(_20=<tmp_1374>, _18=<tmp_516>)
#     1 usec#    _26 := bat.reverse(_24=<tmp_514>)
#     3 usec#    _28 := algebra.kdifference(_22=<tmp_1375>, _26=<~tmp_514>)
#     4 usec#    _33 := algebra.markT(_28=<tmp_1376>, _31=0@0)
#     0 usec#    _35 := bat.reverse(_33=<tmp_1377>)
#    22 usec#    _37 := algebra.join(_35=<~tmp_1377>, _22=<tmp_1375>)
#     1 usec#    _47 := bat.reverse(_45=<tmp_731>)
#     4 usec#    _49 := algebra.kdifference(_39=<tmp_732>, _47=<~tmp_731>)
#     2 usec#    _53 := algebra.markT(_49=<tmp_1400>, _31=0@0)
#     0 usec#    _55 := bat.reverse(_53=<tmp_1402>)
#     4 usec#    _57 := algebra.join(_55=<~tmp_1402>, _39=<tmp_732>)
#    12 usec#    _59 := bat.setWriteMode(_37=<tmp_1401>)
#     2 usec#    bat.append(_59=<tmp_1401>, _57=<tmp_1403>)
#     8 usec#    _65 := algebra.markT(_59=<tmp_1401>, _31=0@0)
#     0 usec#    _67 := bat.reverse(_65=<tmp_1405>)
#     9 usec#    _69 := algebra.join(_67=<~tmp_1405>, _59=<tmp_1401>)
#     2 usec#    _74 := algebra.markT(_69=<tmp_1406>, _72=0@0)
#     1 usec#    _76 := bat.reverse(_74=<tmp_1404>)
#     7 usec#    _78 := algebra.join(_76=<~tmp_1404>, _69=<tmp_1406>)
#     1 usec#    _80 := aggr.count(_78=<tmp_1410>)
&1 0 1 1 1
# sys.tables # table_name
# count_id # name
# int # type
# 2 # length
[ 27    ]
#    20 usec#    sql.exportValue(_83=1, _84="sys.tables", _85="count_id", _86="int", _87=32, _88=0, _89=6, _80=27)
#     2 usec#    sql_cache.s3_0()
>
]]></verbatim>
    </subsection>
  </node>
  <node>
    <nodename>Optimizer Control</nodename>
    <nodenext>Overlaying the BAT storage</nodenext>
    <nodeprev>DEBUG Statement</nodeprev>
    <nodeup>MonetDB/SQL Features</nodeup>
    <section>
      <title>Optimizer Control</title>
      <para>The code produced by MonetDB/SQL is massaged by several code optimizers to arrive at the best possible plan for evaluation. However, for development purposes and the rare case that more control is needed, the SQL session variable <code>optimizer</code> can be set to a MAL instruction list to identify the optimizer steps needed. [todo]</para>
      <example xml:space="preserve">&gt;select optimizer;
#--------------------#
# t                  # name
# str                # type
#--------------------#
[ "optimizer.sql();" ]
&gt;set optimizer="optimizer.factorize();";
&gt;explain select 1;</example>
      <para>The final result the optimizer steps become visible using the <code>explain</code> statement modifier. Alternatively, the optimizer script line may include a call to <code>optimizer.showPlan();</code>.</para>
    </section>
  </node>
  <node>
    <nodename>Overlaying the BAT storage</nodename>
    <nodenext>XQuery</nodenext>
    <nodeprev>Optimizer Control</nodeprev>
    <nodeup>MonetDB/SQL Features</nodeup>
    <section>
      <title>Overlaying the BAT storage</title>
      <para>The SQL implementation exploits many facilities of the underlying MonetDB kernel. Most notably, its efficient column-wise storage scheme with associated algebraic primitives. However, this kernel can also be programmed directly using the MonetDB Assembler Language (MAL), which provides a much richer set of operators then strictly necessary for a correct implementation and execution of SQL</para>
      <para>Although the BATs used for SQL storage can be manipulated directly at the MAL layer, it is strongly discouraged. For, SQL uses a rather complex administration to realise transaction safety. Working at the MAL layer directly could easily compromise the integrity of the system as a whole.</para>
      <para>However, there are cases where access to a collection of BATs from the SQL environment can be handy. For example, to inspect some of the system tables maintained in the kernel. This functionality is realised using an variation of the <code>view statement</code>. It is best illustrated with a short example.</para>
      <para>First, create in MonetDB the BATs of interest. Only void-BATs are allowed and the user should guarantee that they are aligned.</para>
      <example xml:space="preserve">a:=bat.new(:void,:int);
b:=bat.new(:void,:str);
bat.setSequenceBase(a,0@0);
bat.setSequenceBase(b,0@0);
bat.setPersistent(a);
bat.setPersistent(b);
bat.setName(a,"age");
bat.setName(b,"name");</example>
      <para>These BATs can be filled with attribute values, but make sure that all BATs are given an equal number of tuples. To conclude, commit the database to disk, whereafter the BATs become available to SQL, once you restart Mserver/SQL.</para>
      <example xml:space="preserve">bat.append(a, 32);
bat.append(b, "John");
bat.append(a, 31);
bat.append(b, "Mary");
transaction.commit(a,b);</example>
      <para>The BATs are made visible for read-only access using the a column specification. As it normally expects identifiers, we have to use double quotes instead.</para>
      <example xml:space="preserve">CREATE VIEW friends ("age","name") AS BATS;</example>
      <para>At this point the content of the BATs can be queried using ordinary SQL queries. Updates are prohibited.</para>
    </section>
  </node>
  <node>
    <nodename>XQuery</nodename>
    <nodenext>User Interfaces</nodenext>
    <nodeprev>Overlaying the BAT storage</nodeprev>
    <nodeup>Top</nodeup>
    <chapter>
      <title>XQuery</title>
      <para>Give a 3 page introduction on how to use XQuery</para>
    </chapter>
  </node>
  <node>
    <nodename>User Interfaces</nodename>
    <nodenext>Mapi Client</nodenext>
    <nodeprev>XQuery</nodeprev>
    <nodeup>Top</nodeup>
    <chapter>
      <title>User Interfaces</title>
      <menu>
        <menuentry>
          <menunode>Mapi Client</menunode>
          <menutitle>Mapi Client</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Jdbc Client</menunode>
          <menutitle>Jdbc Client</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Data Management Tools</menunode>
          <menutitle>Data Management Tools</menutitle>
          <menucomment></menucomment>
        </menuentry>
      </menu>
    </chapter>
  </node>
  <node>
    <nodename>Mapi Client</nodename>
    <nodenext>Jdbc Client</nodenext>
    <nodeprev>User Interfaces</nodeprev>
    <nodeup>User Interfaces</nodeup>
    <section>
      <title>Mapi Client Calling Arguments</title>
      <para>The <code>mclient</code> program provides a textual interface to a MonetDB server. On a Linux platform it provides readline functionality, which greatly improves user interaction. A history can be maintained to ease interaction over multiple sessions.</para>
      <para>A <code>mclient</code> requires minimally a language and host or port argument. The default setting is geared at establing a guest connection to a SQL database at a default server running on the localhost.</para>
      <para>A blocked mode interaction permits assemblage of multiple instructions in a buffer before it is shipped to the server for execution.</para>
      <para>The timer switch reports on the round-about time for queries sent to the server. It provides a first impression on the execution cost.</para>
      <example xml:space="preserve">mclient [ options ]</example>
      <para>Options are:</para>
      <verbatim xml:space="preserve"><![CDATA[
 -b t/f      | --blocked=true/false /* blocked mode */
 -D          | --dump           /* dump sql database */
 -e          | --error          /* exit on error */
 -H          | --history        /* load/save cmdline history (default off) */
 -h hostname | --host=hostname  /* host to connect to */
 -i          | --interactive    /* read stdin after command line args */
 -l language | --language=lang  /* {mal,sql,mil,xquery} */
 -P passwd   | --passwd=passwd  /* password */
 -p portnr   | --port=portnr    /* port to connect to */
 -q          | --quiet          /* don't print welcome message [default=on]*/
 -s stmt     | --statement=stmt /* run single statement */
 -T          | --time           /* time commands */
 -t          | --trace          /* trace Monet interaction */
 -u user     | --user=user      /* user id [default=monetdb] */
 -?          | --help           /* show this usage message */
]]></verbatim>
    </section>
  </node>
  <node>
    <nodename>Jdbc Client</nodename>
    <nodenext>Data Management Tools</nodenext>
    <nodeprev>Mapi Client</nodeprev>
    <nodeup>User Interfaces</nodeup>
    <section>
      <title>Jdbc Client Calling Arguments</title>
      <para>The textual client using the JDBC protocol comes with several options to fine-tune the interaction with the database server. A synopsis of the calling arguments is given below</para>
      <example xml:space="preserve">mjclient [-h host[:port]] [-p port] \
		[-f file] [-u user] [-l language] [-b [database]] \
		[-d [table]] [-e] [-X&lt;opt&gt;]</example>
      <para>but also using long option equivalents <ndash/>host <ndash/>port <ndash/>file <ndash/>user <ndash/>language <ndash/>dump <ndash/>echo <ndash/>database are allowed. Arguments may be written directly after the option like -p45123.</para>
      <para>If no host and port are given, localhost and 45123 (=sql_port default) are assumed.  An <code>.monetdb</code> file may exist in the user's home directory.  This file can contain preferences to use each time mjclient is started.  Options given on the command line override the preferences file.  The <code>.monetdb</code> file syntax is &lt;option&gt;=&lt;value&gt; where option is one of the options host, port, file, mode debug, or password.  Note that the last one is perilous and therefore not available as command line option. If no input file is given using the -f flag, an interactive session is started on the terminal.</para>
      <para>OPTIONS</para>
      <table>
        <tableitem>
          <tableterm><code>-h --host</code></tableterm>
          <item>
            <para>The hostname of the host that runs the MonetDB database.  A port number can be supplied by use of a colon, i.e. -h somehost:12345.</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm><code>-p --port</code></tableterm>
          <item>
            <para>The port number to connect to.</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm><code>-f --file</code></tableterm>
          <item>
            <para>A file name to use either for reading or writing.  The file will be used for writing when dump mode is used (-d <ndash/>dump). In read mode, the file can also be an URL pointing to a plain text file that is optionally gzip compressed.</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm><code>-u --user</code></tableterm>
          <item>
            <para>The username to use when connecting to the database.</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm><code>-l --language</code></tableterm>
          <item>
            <para>Use the given language, for example 'xquery'.</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm><code>-d --dump</code></tableterm>
          <item>
            <para>Dumps the given table(s), or the complete database if none given.</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm><code>--help</code></tableterm>
          <item>
            <para>This screen.</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm><code>-e --echo</code></tableterm>
          <item>
            <para>Also outputs the contents of the input file, if any.</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm><code>-b --database</code></tableterm>
          <item>
            <para>Try to connect to the given database (only makes sense if connecting to a DatabasePool or equivalent process).</para>
          </item>
        </tableitem>
      </table>
      <para>EXTRA OPTIONS</para>
      <table>
        <tableitem>
          <tableterm><code>-Xdebug</code></tableterm>
          <item>
            <para>Writes a transmission log to disk for debugging purposes.  If a file name is given, it is used, otherwise a file called monet&lt;timestamp&gt;.log is created.  A given file will never be overwritten; instead a unique variation of the file is used.</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm><code>-Xblksize</code></tableterm>
          <item>
            <para>Specifies the blocksize when using block mode, given in bytes.</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm><code>-Xoutput</code></tableterm>
          <item>
            <para>The output mode when dumping.  Default is sql, xml may be used for an experimental XML output.</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm><code>-Xbatching</code></tableterm>
          <item>
            <para>Indicates that a batch should be used instead of direct communication with the server for each statement.  If a number is given, it is used as batch size.  I.e. 8000 would execute the contents on the batch after each 8000 read rows.  Batching can greatly speedup the process of restoring a database dump.</para>
          </item>
        </tableitem>
      </table>
    </section>

    <section>
      <title>Console and Mapi Client</title>
      <subsection>
        <title>Online Help</title>
        <para>Online help on the modules and functions can be obtained using manual commands and the readline key-binding '&lt;TAB&gt;&lt;TAB&gt;'. The argument is a (partial) operator call, which is looked up in the symbol table. If the pattern includes a '(' it also displays the signature for each match. The <code>address</code> and <code>address</code> attributes are also shown if the call contains the closing bracket ')'.</para>
        <example xml:space="preserve">&gt;manual.completion("bat.is");
bat.isSynced
bat.isCached
bat.isPersistent
bat.isTransient
bat.isSortedReverse
bat.isSorted
bat.isaSet
bat.isaKey
&gt;manual.help("bat.isSorted(");
command bat.isSorted(b:bat[:any_1,:any_2]):bit
&gt;manual.help("bat.isSorted()");
command bat.isSorted(b:bat[:any_1,:any_2]):bit address BKCisSorted;
Returns whether a BAT is ordered on head or not.
&gt;manual.search("isSorted()");
command bat.isSortedReverse(b:bat[:any_1,:any_2]):bit address BKCisSortedReverse;
Returns whether a BAT is ordered on head or not.
command bat.isSorted(b:bat[:any_1,:any_2]):bit address BKCisSorted;
Returns whether a BAT is ordered on head or not.</example>
        <para>Keyword based lookup is supported by the operation <code>manual.search</code>; Additional routines are available in the <code>inspect</code> module to built reflexive code.</para>
        <para>The module and function names can be replaced by the wildcard character '*'. General regulat pattern matching is not supported.</para>
        <example xml:space="preserve">&gt; *.print(&lt;TAB&gt;&lt;TAB&gt;
command color.print(c:color):void
pattern array.print(a:bat[:any_1,:any_2],b:bat[:any_1,:int]...):void
pattern io.print(b1:bat[:any_1,:any]...):int
pattern io.print(order:int,b:bat[:any_1,:any],b2:bat[:any_1,:any]...):int
pattern io.print(val:any_1):int
pattern io.print(val:any_1,lst:any...):int
pattern io.print(val:bat[:any_1,:any_2]):int</example>
        <example xml:space="preserve"></example>
      </subsection>
    </section>
  </node>
  <node>
    <nodename>Data Management Tools</nodename>
    <nodenext>Aqua Data Studio</nodenext>
    <nodeprev>Jdbc Client</nodeprev>
    <nodeup>User Interfaces</nodeup>
    <section>
      <title>Data Management Tools</title>
      <para>There are many user-friendly tools to interact with a SQL database server. Although some tools are targetted to a single backend server, the systems described below have been successfully linked with MonetDB/SQL. For all systems considered, make sure you have Mserver installed on your system and that you can access the server using the ref(JDBC client).</para>
      <menu>
        <menuentry>
          <menunode>Aqua Data Studio</menunode>
          <menutitle>Aqua Data Studio</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>DbVisualizer</menunode>
          <menutitle>DbVisualizer</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>iSQL-Viewer</menunode>
          <menutitle>iSQL-Viewer</menutitle>
          <menucomment></menucomment>
        </menuentry>
      </menu>
    </section>
  </node>
  <node>
    <nodename>Aqua Data Studio</nodename>
    <nodenext>DbVisualizer</nodenext>
    <nodeprev>Data Management Tools</nodeprev>
    <nodeup>Data Management Tools</nodeup>
    <subsection>
      <title>Aqua Data Studio</title>
      <para>Aqua Data Studio is a graphical user interface to interact with MonetDB/SQL. It is available on Windows, Linux, and MacOS platforms from  the <uref><urefurl>http://www.aquafold.com</urefurl><urefdesc>distribution</urefdesc></uref> site. Download the Version 4.5  executable and install the software.</para>
      <para>The first step to make Aqua Data Studio aware of MonetDB is to register the database server . Go to the <code>Server-&gt;Register Server</code> panel and select the Generic- JDBC RDBMS theme. It requires the following additional field settings: </para>
      <multitable>
        <columnfraction>15</columnfraction>
        <columnfraction>80</columnfraction>
        <tbody>
          <row>
            <entry>Name:</entry>
            <entry>MonetDB SQL</entry>
          </row>
          <row>
            <entry>Type:</entry>
            <entry><emph> Whatever you want</emph></entry>
          </row>
          <row>
            <entry>Login Name:</entry>
            <entry>monetdb</entry>
          </row>
          <row>
            <entry>Password:</entry>
            <entry>monetdb</entry>
          </row>
          <row>
            <entry>URL</entry>
            <entry>jdbc:monetdb://localhost/database</entry>
          </row>
          <row>
            <entry>Driver:</entry>
            <entry>nl.cwi.monetdb.jdbc.MonetDriver</entry>
          </row>
          <row>
            <entry>Driver Location:</entry>
            <entry>C:\Program Files\CWI\MonetDB\share\MonetDB\lib\monetdb-1.3-jdbc.jar</entry>
          </row>
        </tbody>
      </multitable>
      <para>The location of the JDBC driver under Linux and OSX is by default /usr/share/MonetDB/lib/monetdb-1.3-jdbc.jar.</para>
      <para>Once the settings has been completed, start the MonetDB server and try to connect. If necessary extend the heap size of your java engine, e.g. use -Xmx1024M .</para>
      <para>Consult your system administrator if other MonetDB user creditials and locality settings are required.</para>
    </subsection>
  </node>
  <node>
    <nodename>DbVisualizer</nodename>
    <nodenext>iSQL-Viewer</nodenext>
    <nodeprev>Aqua Data Studio</nodeprev>
    <nodeup>Data Management Tools</nodeup>
    <subsection>
      <title>DbVisualizer</title>
      <para>DbVisualizer is a platform independent tool aimed to simplify database development and management for database administrators and developers. It's a very cool tool (can even draw dependency graphs based on the schema and foreign keys.</para>
      <para>Free, personal use versions are available from their <uref><urefurl>http://www.minq.se/</urefurl><urefdesc>website</urefdesc></uref>. Download and install the software. The following scheme works for version 4.3.6 and version 5.0.</para>
      <para>After starting DbVisualizer for the first time, it will load its default welcome screen. Before doing anything, open the Driver Manager, using the menu Tools-&gt;Driver Manager... In the Driver Manager add a new Driver using Driver-&gt;Create Driver... Type the name of the driver in the Name field, e.g. MonetDB. Type the URL format for the driver: jdbc:monetdb://hostname/database In the Driver File Paths box, follow the directions to load a JAR file that contains the JDBC driver.  Use the MonetDB JDBC driver that came with your distribution, typically installed in ${prefix }/share/MonetDB/lib/monetdb-X.Y-jdbc.jar.</para>
      <para>After adding, the window should list the driver class nl.cwi.monetdb.jdbc.MonetDriver and automatically fills it in in the Driver Class field.  Close the Driver Manager window. Back in the main window, in the Getting Started box, click the Tools-&gt;Connection Wizard link. A connection Wizard will pop up, and you will think you are working on a Microsoft Powered computer, no matter which operating system you use. Type the name for the database, e.g. MonetDB and click "Next". Select the just added monetdb Database Driver from the drop down list and again press "Next". Go grab a cup of coffee, when you found out the Wizard not only looks like a Microsoft Product(tm), but also acts like one.  Try to hide your frustration and cancel the Wizard and continue the manual way.</para>
      <para>From the menu select Database-&gt;Create Database Connection.  A popup dialog will try to persue you to use the wizard.  You know better so, click "No". Fill in the name for the connection in the Alias field, e.g. MonetDB. Select the monetdb driver from the list. Copy the default URL by clicking on the "URL Format: ..." text field and change it to reflect the right hostname (usually localhost will do). Fill in the default userid and password (monetdb). Press the "Connect" button.  It will report the database being used and the JDBC driver in use.  In the left pane the monetdb database now becomes available from browsing.</para>
      <para>Explore the application and have fun!</para>
      <para>A caveat of the free-version system is its performance on SQL scripts. They are sent as a single string to the server for execution. This is not the most optimal situation for MonetDB. Running a batch script is better started from the MonetDB SQL client.</para>
    </subsection>
  </node>
  <node>
    <nodename>iSQL-Viewer</nodename>
    <nodenext>Programming Interfaces</nodenext>
    <nodeprev>DbVisualizer</nodeprev>
    <nodeup>Data Management Tools</nodeup>
    <subsection>
      <title>iSQL-Viewer</title>
      <para>Another open-source graphical user interface is the <uref><urefurl>http://isql.sourceforge.net/</urefurl><urefdesc>iSQL-Viewer</urefdesc></uref>. It runs on any Java-enabled platform.</para>
      <para>Once installed and started you have the option define a service (or let the system find one itself). [Ignore the autodetect of services option]</para>
      <para>The Tools-&gt;Service Manager choice brings up a form to provide the detail for the MonetDB connections. Click the third button in toolbar and select 'Local Service' to define a service Immediately select the tab named 'Resource' and add the location of the MonetDB JDBC driver, installed by default in C:\Program Files\MonetDB\share\MonetDB\lib\MonetDB_JDBC.jar. under Windows and and in /usr/share/MonetDB/lib/MonetDB_JDBC.jar under Linux and OSX</para>
      <para>Go back to tab 'General' and enter the following items: </para>
      <multitable>
        <columnfraction>15</columnfraction>
        <columnfraction>80</columnfraction>
        <tbody>
          <row>
            <entry>Connection Name</entry>
            <entry>MonetDB SQL</entry>
          </row>
          <row>
            <entry>JDBC Driver</entry>
            <entry>nl.cwi.monetdb.jdbc.MonetDriver</entry>
          </row>
          <row>
            <entry>JDBC URL</entry>
            <entry>jdbc:monetdb://localhost/database</entry>
          </row>
          <row>
            <entry>User name</entry>
            <entry>monetdb</entry>
          </row>
          <row>
            <entry>Password</entry>
            <entry>monetdb</entry>
          </row>
        </tbody>
      </multitable>
      <para>Warning, disable the authentication prompt if you can not edit the user and password fields.</para>
      <para>In the <code>Tools&gt;Service Manager&gt;Resource</code> panel enter the location of the MonetDB JDBC driver <code>C:\Program Files\MonetDB\share\MonetDB\lib\MonetDB_JDBC.jar</code>.</para>
      <para>Documentation and tutorial on iSQL-Viewer are available on their <uref><urefurl>http://isqlviewer.com</urefurl><urefdesc>website</urefdesc></uref>.</para>
    </subsection>
  </node>
  <node>
    <nodename>Programming Interfaces</nodename>
    <nodenext>The Mapi Library</nodenext>
    <nodeprev>iSQL-Viewer</nodeprev>
    <nodeup>Top</nodeup>
    <section>
      <title>Application Programming Interfaces</title>
      <para>MonetDB comes with a complete set of programming libraries. Their basis is the Mapi library, which describes the protocol understood by the server. The Perl,PHP, and Python library are mostly wrappers around the Mapi routines.</para>
      <para>The programming interface is based on a client-server architecture, where the client program connects to a server using a TCP-IP connection to exchange commands and receives ansers. The underlying protocol uses plain UTF-8 data for ease of use and debugging. This leads to publically visible information exchange over a network, which may be undesirable. Therefore, a private and secure channel can be set up with the Secure Socket Layer functionality being offered.</para>
      <para>A more tightly connection between application logic and database server is described in <xref><xrefnodename>Embedded MonetDB</xrefnodename></xref>.</para>
      <menu>
        <menuentry>
          <menunode>The Mapi Library</menunode>
          <menutitle>The Mapi Library </menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>The Perl Library</menunode>
          <menutitle>The Perl Library</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>The PHP Library</menunode>
          <menutitle>The PHP Library</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>The Python Library</menunode>
          <menutitle>The Python Library</menutitle>
          <menucomment></menucomment>
        </menuentry>
      </menu>
    </section>
  </node>
  <node>
    <nodename>The Mapi Library</nodename>
    <nodenext>Sample Application</nodenext>
    <nodeprev>Programming Interfaces</nodeprev>
    <nodeup>Programming Interfaces</nodeup>
    <chapter>
      <title>The MonetDB Programming Interface</title>
      <para>The easiest way to extend the functionality of MonetDB is to construct an independent application, which communicates with a running server using a database driver with a simple API and a textual protocol.  The effectiveness of such an approach has been demonstrated by the wide use of database API implementations, such as Perl DBI, PHP, ODBC,...</para>
      <menu>
        <menuentry>
          <menunode>Sample Application</menunode>
          <menutitle>Sample Application</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Caveats</menunode>
          <menutitle>Caveats</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Compilation</menunode>
          <menutitle>Compilation</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Command Summary</menunode>
          <menutitle>Command Summary</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Library Synopsis</menunode>
          <menutitle>Library Synopsis</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Mapi Function Reference</menunode>
          <menutitle>Mapi Function Reference</menutitle>
          <menucomment></menucomment>
        </menuentry>
      </menu>
    </chapter>
  </node>
  <node>
    <nodename>Sample Application</nodename>
    <nodenext>Caveats</nodenext>
    <nodeprev>The Mapi Library</nodeprev>
    <nodeup>The Mapi Library</nodeup>
    <section>
      <title>Sample MAPI Application</title>
      <para>The database driver implementation given in this document focuses on developing applications in C/C++. The command collection has been chosen to align with common practice, i.e. queries follow a prepare, execute, and fetch_row paradigm. The output is considered a regular table. An example of a mini application below illustrates the main operations.</para>
      <example xml:space="preserve"><verbatim xml:space="preserve"><![CDATA[
#include <Mapi.h>
#include <stdio.h>

#define die(dbh,hdl) (hdl?mapi_explain_query(hdl,stderr):		\
                          dbh?mapi_explain(dbh,stderr):			\
                              fprintf(stderr,"command failed\n"),	\
                      exit(-1))

int main(int argc, char **argv)
{
    Mapi dbh;
    MapiHdl hdl = NULL;

    dbh = mapi_connect("localhost", 50000, "monetdb", "monetdb", "sql");
    if (mapi_error(dbh))
        die(dbh, hdl);

    if ((hdl = mapi_query(dbh, "create table emp(name varchar(20), age int)")) == NULL
        || mapi_error(dbh) != MOK)
        die(dbh, hdl);
    if (mapi_close_handle(hdl) != MOK)
        die(dbh, hdl);
    if ((hdl = mapi_query(dbh, "insert into emp values('John', 23)")) == NULL
        || mapi_error(dbh) != MOK)
        die(dbh, hdl);
    mapi_close_handle(hdl);
    if (mapi_error(dbh) != MOK)
        die(dbh, hdl);
    if ((hdl = mapi_query(dbh, "insert into emp values('Mary', 22)")) == NULL
        || mapi_error(dbh) != MOK)
        die(dbh, hdl);
    mapi_close_handle(hdl);
    if (mapi_error(dbh) != MOK)
        die(dbh, hdl);
    if ((hdl = mapi_query(dbh, "select * from emp")) == NULL
        || mapi_error(dbh) != MOK)
        die(dbh, hdl);

    while (mapi_fetch_row(hdl)) {
        char *nme = mapi_fetch_field(hdl, 0);
        char *age = mapi_fetch_field(hdl, 1);
        printf("%s is %s\n", nme, age);
    }
    if (mapi_error(dbh) != MOK)
        die(dbh, hdl);
    mapi_close_handle(hdl);
    if (mapi_error(dbh) != MOK)
        die(dbh, hdl);
    mapi_disconnect(dbh);

    return 0;
}
]]></verbatim></example>
      <para>The <code>mapi_connect()</code> operation establishes a communication channel with a running server on the local machine. The user name is "monetdb" with password "monetdb". The query language interface is either "sql", "mil" or "xquery".  Future versions are expected to recognize also "ram" and "mal".</para>
      <para>Errors on the interaction can be captured using <code>mapi_error()</code>, possibly followed by a request to dump a short error message explanation on a standard file location. It has been abstracted away in a macro.</para>
      <para>Provided we can establish a connection, the interaction proceeds as in many similar application development packages. Queries are shipped for execution using <code>mapi_query()</code> and an answer table can be consumed one row at a time. In many cases these functions suffice.</para>
      <para>The Mapi interface provides caching of rows at the client side. <code>mapi_query()</code> will load tuples into the cache, after which they can be read repeatedly using <code>mapi_fetch_row()</code> or directly accessed (<code>mapi_seek_row()</code>). This facility is particularly handy when small, but stable query results are repeatedly used in the client program.</para>
      <para>To ease communication between application code and the cache entries, the user can bind the C-variables both for input and output to the query parameters, and output columns, respectively.  The query parameters are indicated by '?' and may appear anywhere in the query template.</para>
    </section>
  </node>
  <node>
    <nodename>Caveats</nodename>
    <nodenext>Compilation</nodenext>
    <nodeprev>Sample Application</nodeprev>
    <nodeup>The Mapi Library</nodeup>
    <section>
      <title>Caveats</title>
      <para>The Mapi library expects complete lines from the server as answers to query actions. Incomplete lines leads to Mapi waiting forever on the server. Thus formatted printing is discouraged in favor of tabular printing as offered by the <code>table.print()</code> commands.</para>
    </section>
  </node>
  <node>
    <nodename>Compilation</nodename>
    <nodenext>Command Summary</nodenext>
    <nodeprev>Caveats</nodeprev>
    <nodeup>The Mapi Library</nodeup>
    <section>
      <title>Compilation</title>
      <para>The Mapi application uses include files found in the MonetDB distribution directory or at a central location on your machine. Assuming the location of the distribution is marked in the environment variable $MONETDB_PREFIX, the following actions are needed to get a working program.</para>
      <example xml:space="preserve"><verbatim xml:space="preserve"><![CDATA[
cc sample.c -I$MONETDB_PREFIX \
        -I$MONETDB_PREFIX/include/common \
        -I$MONETDB_PREFIX/include/mapi  \
        -L$MONETDB_PREFIX/lib \
        -lMapi -lutils -lstream \
        -Wl,--rpath -Wl,$MONETDB_PREFIX/lib/MonetDB:$MONETDB_PREFIX/lib \
        -o sample
]]></verbatim></example>
    </section>
  </node>
  <node>
    <nodename>Command Summary</nodename>
    <nodenext>Library Synopsis</nodenext>
    <nodeprev>Compilation</nodeprev>
    <nodeup>The Mapi Library</nodeup>
    <section>
      <title>Command Summary</title>
      <para>The quick reference guide to the Mapi library is given below.  More details on their constraints and defaults are given in the next section.</para>
      <multitable>
        <columnfraction>25</columnfraction>
        <columnfraction>75</columnfraction>
        <tbody>
          <row>
            <entry>mapi_bind()</entry>
            <entry>Bind string C-variable to a field</entry>
          </row>
          <row>
            <entry>mapi_bind_numeric()</entry>
            <entry>Bind numeric C-variable to field</entry>
          </row>
          <row>
            <entry>mapi_bind_var()</entry>
            <entry>Bind typed C-variable to a field</entry>
          </row>
          <row>
            <entry>mapi_cache_freeup()</entry>
            <entry>Forcefully shuffle fraction for cache refreshment</entry>
          </row>
          <row>
            <entry>mapi_cache_limit()</entry>
            <entry>Set the tuple cache limit</entry>
          </row>
          <row>
            <entry>mapi_cache_shuffle()</entry>
            <entry>Set shuffle fraction for cache refreshment</entry>
          </row>
          <row>
            <entry>mapi_clear_bindings()</entry>
            <entry>Clear all field bindings</entry>
          </row>
          <row>
            <entry>mapi_clear_params()</entry>
            <entry>Clear all parameter bindings</entry>
          </row>
          <row>
            <entry>mapi_close_handle()</entry>
            <entry>Close query handle and free resources</entry>
          </row>
          <row>
            <entry>mapi_connect()</entry>
            <entry>Connect to a Mserver</entry>
          </row>
          <row>
            <entry>mapi_connect_ssl()</entry>
            <entry>Connect to a Mserver using Secure Socket Layer (SSL)</entry>
          </row>
          <row>
            <entry>mapi_destroy()</entry>
            <entry>Free handle resources</entry>
          </row>
          <row>
            <entry>mapi_disconnect()</entry>
            <entry>Disconnect from server</entry>
          </row>
          <row>
            <entry>mapi_error()</entry>
            <entry>Test for error occurrence</entry>
          </row>
          <row>
            <entry>mapi_execute()</entry>
            <entry>Execute a query</entry>
          </row>
          <row>
            <entry>mapi_execute_array()</entry>
            <entry>Execute a query using string arguments</entry>
          </row>
          <row>
            <entry>mapi_explain()</entry>
            <entry>Display error message and context on stream</entry>
          </row>
          <row>
            <entry>mapi_explain_query()</entry>
            <entry>Display error message and context on stream</entry>
          </row>
          <row>
            <entry>mapi_fetch_all_rows()</entry>
            <entry>Fetch all answers from server into cache</entry>
          </row>
          <row>
            <entry>mapi_fetch_field()</entry>
            <entry>Fetch a field from the current row</entry>
          </row>
          <row>
            <entry>mapi_fetch_field_array()</entry>
            <entry>Fetch all fields from the current row</entry>
          </row>
          <row>
            <entry>mapi_fetch_line()</entry>
            <entry>Retrieve the next line</entry>
          </row>
          <row>
            <entry>mapi_fetch_reset()</entry>
            <entry>Set the cache reader to the beginning</entry>
          </row>
          <row>
            <entry>mapi_fetch_row()</entry>
            <entry>Fetch row of values</entry>
          </row>
          <row>
            <entry>mapi_finish()</entry>
            <entry>Terminate the current query</entry>
          </row>
          <row>
            <entry>mapi_get_dbname()</entry>
            <entry>Database being served</entry>
          </row>
          <row>
            <entry>mapi_get_field_count()</entry>
            <entry>Number of fields in current row</entry>
          </row>
          <row>
            <entry>mapi_get_host()</entry>
            <entry>Host name of server</entry>
          </row>
          <row>
            <entry>mapi_get_language()</entry>
            <entry>Query language name</entry>
          </row>
          <row>
            <entry>mapi_get_mapi_version()</entry>
            <entry>Mapi version name</entry>
          </row>
          <row>
            <entry>mapi_get_monet_versionId()</entry>
            <entry>MonetDB version identifier</entry>
          </row>
          <row>
            <entry>mapi_get_monet_version()</entry>
            <entry>MonetDB version name</entry>
          </row>
          <row>
            <entry>mapi_get_motd()</entry>
            <entry>Get server welcome message</entry>
          </row>
          <row>
            <entry>mapi_get_row_count()</entry>
            <entry>Number of rows in cache or -1</entry>
          </row>
          <row>
            <entry>mapi_get_trace()</entry>
            <entry>Get trace flag</entry>
          </row>
          <row>
            <entry>mapi_get_user()</entry>
            <entry>Current user name</entry>
          </row>
          <row>
            <entry>mapi_next_result()</entry>
            <entry>Go to next result set</entry>
          </row>
          <row>
            <entry>mapi_ping()</entry>
            <entry>Test server for accessibility</entry>
          </row>
          <row>
            <entry>mapi_prepare()</entry>
            <entry>Prepare a query for execution</entry>
          </row>
          <row>
            <entry>mapi_prepare_array()</entry>
            <entry>Prepare a query for execution using arguments</entry>
          </row>
          <row>
            <entry>mapi_query()</entry>
            <entry>Send a query for execution</entry>
          </row>
          <row>
            <entry>mapi_query_array()</entry>
            <entry>Send a query for execution with arguments</entry>
          </row>
          <row>
            <entry>mapi_query_handle()</entry>
            <entry>Send a query for execution</entry>
          </row>
          <row>
            <entry>mapi_quick_query_array()</entry>
            <entry>Send a query for execution with arguments</entry>
          </row>
          <row>
            <entry>mapi_quick_query()</entry>
            <entry>Send a query for execution</entry>
          </row>
          <row>
            <entry>mapi_quick_response()</entry>
            <entry>Quick pass response to stream</entry>
          </row>
          <row>
            <entry>mapi_quote()</entry>
            <entry>Escape characters</entry>
          </row>
          <row>
            <entry>mapi_reconnect()</entry>
            <entry>Reconnect with a clean session context</entry>
          </row>
          <row>
            <entry>mapi_rows_affected()</entry>
            <entry>Obtain number of rows changed</entry>
          </row>
          <row>
            <entry>mapi_seek_row()</entry>
            <entry>Move row reader to specific location in cache</entry>
          </row>
          <row>
            <entry>mapi_setAutocommit()</entry>
            <entry>Set auto-commit flag</entry>
          </row>
          <row>
            <entry>mapi_stream_query()</entry>
            <entry>Send query and prepare for reading tuple stream</entry>
          </row>
          <row>
            <entry>mapi_table()</entry>
            <entry>Get current table name</entry>
          </row>
          <row>
            <entry>mapi_timeout()</entry>
            <entry>Set timeout for long-running queries[TODO]</entry>
          </row>
          <row>
            <entry>mapi_trace()</entry>
            <entry>Set trace flag</entry>
          </row>
          <row>
            <entry>mapi_trace_log()</entry>
            <entry>Keep log of interaction</entry>
          </row>
          <row>
            <entry>mapi_virtual_result()</entry>
            <entry>Submit a virtual result set</entry>
          </row>
          <row>
            <entry>mapi_unquote()</entry>
            <entry>remove escaped characters</entry>
          </row>
        </tbody>
      </multitable>
    </section>
  </node>
  <node>
    <nodename>Library Synopsis</nodename>
    <nodenext>Mapi Function Reference</nodenext>
    <nodeprev>Command Summary</nodeprev>
    <nodeup>The Mapi Library</nodeup>
    <section>
      <title>Mapi Library</title>
      <para>The routines to build a MonetDB application are grouped in the library MonetDB Programming Interface, or shorthand Mapi.</para>
      <para>The protocol information is stored in a Mapi interface descriptor (mid).  This descriptor can be used to ship queries, which return a MapiHdl to represent the query answer.  The application can set up several channels with the same or a different Mserver. It is the programmer's responsibility not to mix the descriptors in retrieving the results.</para>
      <para>The application may be multi-threaded as long as the user respects the individual connections represented by the database handlers.</para>
      <para>The interface assumes a cautious user, who understands and has experience with the query or programming language model. It should also be clear that references returned by the API point directly into the administrative structures of Mapi.  This means that they are valid only for a short period, mostly between successive <code>mapi_fetch_row()</code> commands. It also means that it the values are to retained, they have to be copied.  A defensive programming style is advised.</para>
      <para>Upon an error, the routines <code>mapi_explain()</code> and <code>mapi_explain_query()</code> give information about the context of the failed call, including the expression shipped and any response received.  The side-effect is clearing the error status.</para>

      <subsection>
        <title>Error Message</title>
        <para>Almost every call can fail since the connection with the database server can fail at any time.  Functions that return a handle (either <code>Mapi</code> or <code>MapiHdl</code>) may return NULL on failure, or they may return the handle with the error flag set.  If the function returns a non-NULL handle, always check for errors with mapi_error.</para>
        <para>Functions that return MapiMsg indicate success and failure with the following codes.</para>
        <multitable>
          <columnfraction>15</columnfraction>
          <columnfraction>70</columnfraction>
          <tbody>
            <row>
              <entry>MOK</entry>
              <entry>No error</entry>
            </row>
            <row>
              <entry>MERROR</entry>
              <entry>Mapi internal error.</entry>
            </row>
            <row>
              <entry>MTIMEOUT</entry>
              <entry>Error communicating with the server.</entry>
            </row>
          </tbody>
        </multitable>
        <para>When these functions return MERROR or MTIMEOUT, an explanation of the error can be had by calling one of the functions <code>mapi_error_str()</code>, <code>mapi_explain()</code>, or <code>mapi_explain_query()</code>.</para>
        <para>To check for error messages from the server, call <code>mapi_result_error()</code>. This function returns NULL if there was no error, or the error message if there was.  A user-friendly message can be printed using <code>map_explain_result()</code>.  Typical usage is:</para>
        <verbatim xml:space="preserve"><![CDATA[
do {
    if ((error = mapi_result_error(hdl)) != NULL)
        mapi_explain_result(hdl, stderr);
    while ((line = mapi_fetch_line(hdl)) != NULL)
        /* use output */;
} while (mapi_next_result(hdl) == 1);
]]></verbatim>
      </subsection>
    </section>
  </node>
  <node>
    <nodename>Mapi Function Reference</nodename>
    <nodenext>The Perl Library</nodenext>
    <nodeprev>Library Synopsis</nodeprev>
    <nodeup>The Mapi Library</nodeup>
    <section>
      <title>Mapi Function Reference</title>
      <subsection>
        <title>Connecting and Disconnecting</title>
        <itemize>
          <itemfunction><bullet/></itemfunction>
          <item>
            <para>Mapi mapi_connect(const char *host, int port, const char *username, const char *password, const char *lang)</para>
            <para>Setup a connection with a Mserver at a <emph>host</emph>:<emph>port</emph> and login with <emph>username</emph> and <emph>password</emph>. If host == NULL, the local host is accessed.  If host starts with a '/' and the system supports it, host is actually the name of a UNIX domain socket, and port is ignored. If port == 0, a default port is used.  If username == NULL, the username of the owner of the client application containing the Mapi code is used.  If password == NULL, the password is omitted.  The preferred query language is any of {sql,mil,mal,xquery }.  On success, the function returns a pointer to a structure with administration about the connection.</para>
          </item>
          <item>
            <para>Mapi mapi_connect_ssl(const char *host, int port, const char *username, const char *password, const char *lang)</para>
            <para>Setup a connection with a Mserver at a <emph>host</emph>:<emph>port</emph> and login with <emph>username</emph> and <emph>password</emph>. The connection is made using the Secure Socket Layer (SSL) and hence all data transfers to and from the server are encrypted. The parameters are the same as in <code>mapi_connect()</code>.</para>
          </item>
          <item>
            <para>MapiMsg mapi_disconnect(Mapi mid)</para>
            <para>Terminate the session described by <emph>mid</emph>.  The only possible uses of the handle after this call is <emph>mapi_destroy()</emph> and <code>mapi_reconnect()</code>. Other uses lead to failure.</para>
          </item>
          <item>
            <para>MapiMsg mapi_destroy(Mapi mid)</para>
            <para>Terminate the session described by <emph> mid</emph> if not already done so, and free all resources. The handle cannot be used anymore.</para>
          </item>
          <item>
            <para>MapiMsg mapi_reconnect(Mapi mid)</para>
            <para>Close the current channel (if still open) and re-establish a fresh connection. This will remove all global session variables.</para>
          </item>
          <item>
            <para>MapiMsg mapi_ping(Mapi mid)</para>
            <para>Test availability of the server. Returns zero upon success.</para>
          </item>
        </itemize>
      </subsection>

      <subsection>
        <title>Sending Queries</title>
        <itemize>
          <itemfunction><bullet/></itemfunction>
          <item>
            <para>MapiHdl mapi_query(Mapi mid, const char *Command)</para>
            <para>Send the Command to the database server represented by mid.  This function returns a query handle with which the results of the query can be retrieved.  The handle should be closed with <code>mapi_close_handle()</code>.  The command response is buffered for consumption, c.f. mapi\_fetch\_row().</para>
          </item>
          <item>
            <para>MapiMsg mapi_query_handle(MapiHdl hdl, const char *Command)</para>
            <para>Send the Command to the database server represented by hdl, reusing the handle from a previous query.  If Command is zero it takes the last query string kept around.  The command response is buffered for consumption, e.g. <code>mapi_fetch_row()</code>.</para>
          </item>
          <item>
            <para>MapiHdl mapi_query_array(Mapi mid, const char *Command, char **argv)</para>
            <para>Send the Command to the database server replacing the placeholders (?) by the string arguments presented.</para>
          </item>
          <item>
            <para>MapiHdl mapi_quick_query(Mapi mid, const char *Command, FILE *fd)</para>
            <para>Similar to <code>mapi_query()</code>, except that the response of the server is copied immediately to the file indicated.</para>
          </item>
          <item>
            <para>MapiHdl mapi_quick_query_array(Mapi mid, const char *Command, char **argv, FILE *fd)</para>
            <para>Similar to <code>mapi_query_array()</code>, except that the response of the server is not analyzed, but shipped immediately to the file indicated.</para>
          </item>
          <item>
            <para>MapiHdl mapi_stream_query(Mapi mid, const char *Command, int windowsize)</para>
            <para>Send the request for processing and fetch a limited number of tuples (determined by the window size) to assess any erroneous situation. Thereafter, prepare for continual reading of tuples from the stream, until an error occurs. Each time a tuple arrives, the cache is shifted one.</para>
          </item>
          <item>
            <para>MapiHdl mapi_prepare(Mapi mid, const char *Command)</para>
            <para>Move the query to a newly allocated query handle (which is returned). Possibly interact with the back-end to prepare the query for execution.</para>
          </item>
          <item>
            <para>MapiMsg mapi_execute(MapiHdl hdl)</para>
            <para>Ship a previously prepared command to the backend for execution. A single answer is pre-fetched to detect any runtime error. MOK is returned upon success.</para>
          </item>
          <item>
            <para>MapiMsg mapi_execute_array(MapiHdl hdl, char **argv)</para>
            <para>Similar to mapi\_execute but replacing the placeholders for the string values provided.</para>
          </item>
          <item>
            <para>MapiMsg mapi_finish(MapiHdl hdl)</para>
            <para>Terminate a query.  This routine is used in the rare cases that consumption of the tuple stream produced should be prematurely terminated. It is automatically called when a new query using the same query handle is shipped to the database and when the query handle is closed with <code>mapi_close_handle()</code>.</para>
          </item>
          <item>
            <para>MapiMsg mapi_virtual_result(MapiHdl hdl, int columns, const char **columnnames, const char **columntypes, const int *columnlengths, int tuplecount, const char ***tuples)</para>
            <para>Submit a table of results to the library that can then subsequently be accessed as if it came from the server. columns is the number of columns of the result set and must be greater than zero. columnnames is a list of pointers to strings giving the names of the individual columns.  Each pointer may be NULL and columnnames may be NULL if there are no names. tuplecount is the length (number of rows) of the result set.  If tuplecount is less than zero, the number of rows is determined by a NULL pointer in the list of tuples pointers. tuples is a list of pointers to row values.  Each row value is a list of pointers to strings giving the individual results.  If one of these pointers is NULL it indicates a NULL/nil value.</para>
          </item>
        </itemize>
      </subsection>

      <subsection>
        <title>Getting Results</title>
        <itemize>
          <itemfunction><bullet/></itemfunction>
          <item>
            <para>int mapi_get_field_count(Mapi mid)</para>
            <para>Return the number of fields in the current row.</para>
          </item>
          <item>
            <para>int mapi_get_row_count(Mapi mid)</para>
            <para>If possible, return the number of rows in the last select call.  A -1 is returned if this information is not available.</para>
          </item>
          <item>
            <para>int mapi_rows_affected(MapiHdl hdl)</para>
            <para>Return the number of rows affected by a database update command such as SQL's INSERT/DELETE/UPDATE statements.</para>
          </item>
          <item>
            <para>int mapi_fetch_row(MapiHdl hdl)</para>
            <para>Retrieve a row from the server.  The text retrieved is kept around in a buffer linked with the query handle from which selective fields can be extracted.  It returns the number of fields recognized.  A zero is returned upon encountering end of sequence or error. This can be analyzed in using <code>mapi_error()</code>.</para>
          </item>
          <item>
            <para>int mapi_fetch_all_rows(MapiHdl hdl)</para>
            <para>All rows are cached at the client side first. Subsequent calls to <code>mapi_fetch_row()</code> will take the row from the cache. The number or rows cached is returned.</para>
          </item>
          <item>
            <para>int mapi_quick_response(MapiHdl hdl, FILE *fd)</para>
            <para>Read the answer to a query and pass the results verbatim to a stream. The result is not analyzed or cached.</para>
          </item>
          <item>
            <para>MapiMsg mapi_seek_row(MapiHdl hdl, int rownr, int whence)</para>
            <para>Reset the row pointer to the requested row number.  If whence is <code>MAPI_SEEK_SET</code> (0), rownr is the absolute row number (0 being the first row); if whence is <code>MAPI_SEEK_CUR</code> (1), rownr is relative to the current row; if whence is MAPI\_SEEK\_END (2), rownr is relative to the last row.</para>
          </item>
          <item>
            <para>MapiMsg mapi_fetch_reset(MapiHdl hdl)</para>
            <para>Reset the row pointer to the first line in the cache.  This need not be a tuple.  This is mostly used in combination with fetching all tuples at once.</para>
          </item>
          <item>
            <para>char **mapi_fetch_field_array(MapiHdl hdl)</para>
            <para>Return an array of string pointers to the individual fields.  A zero is returned upon encountering end of sequence or error. This can be analyzed in using mapi\_error().</para>
          </item>
          <item>
            <para>char *mapi_fetch_field(MapiHdl hdl, int fnr)</para>
            <para>Return a pointer a C-string representation of the value returned.  A zero is returned upon encountering an error or when the database value is NULL; this can be analyzed in using mapi\_error().</para>
          </item>
          <item>
            <para>MapiMsg mapi_next_result(MapiHdl hdl)</para>
            <para>Go to the next result set, discarding the rest of the output of the current result set.</para>
          </item>
        </itemize>
      </subsection>

      <subsection>
        <title>Errors</title>
        <itemize>
          <itemfunction><bullet/></itemfunction>
          <item>
            <para>MapiMsg mapi_error(Mapi mid)</para>
            <para>Return the last error code or 0 if there is no error.</para>
          </item>
          <item>
            <para>char *mapi_error_str(Mapi mid)</para>
            <para>Return a pointer to the last error message.</para>
          </item>
          <item>
            <para>char *mapi_result_error(MapiHdl hdl)</para>
            <para>Return a pointer to the last error message from the server.</para>
          </item>
          <item>
            <para>MapiMsg mapi_explain(Mapi mid, FILE *fd)</para>
            <para>Write the error message obtained from Mserver to a file.</para>
          </item>
          <item>
            <para>MapiMsg mapi_explain_query(MapiHdl hdl, FILE *fd)</para>
            <para>Write the error message obtained from Mserver to a file.</para>
          </item>
          <item>
            <para>MapiMsg mapi_explain_result(MapiHdl hdl, FILE *fd)</para>
            <para>Write the error message obtained from Mserver to a file.</para>
          </item>
        </itemize>
      </subsection>

      <subsection>
        <title>Parameters</title>
        <itemize>
          <itemfunction><bullet/></itemfunction>
          <item>
            <para>MapiMsg mapi_bind(MapiHdl hdl, int fldnr, char **val)</para>
            <para>Bind a string variable with a field in the return table.  Upon a successful subsequent <code>mapi_fetch_row()</code> the indicated field is stored in the space pointed to by val.  Returns an error if the field identified does not exist.</para>
          </item>
          <item>
            <para>MapiMsg mapi_bind_var(MapiHdl hdl, int fldnr, int type, void *val)</para>
            <para>Bind a variable to a field in the return table.  Upon a successful subsequent <code>mapi_fetch_row()</code>, the indicated field is converted to the given type and stored in the space pointed to by val.  The types recognized are { <code>MAPI_TINY, MAPI_UTINY, MAPI_SHORT, MAPI_USHORT, MAPI_INT, MAPI_UINT, MAPI_LONG, MAPI_ULONG, MAPI_LONGLONG, MAPI_ULONGLONG, MAPI_CHAR, MAPI_VARCHAR, MAPI_FLOAT, MAPI_DOUBLE, MAPI_DATE, MAPI_TIME, MAPI_DATETIME</code> }.  The binding operations should be performed after the mapi_execute command.  Subsequently all rows being fetched also involve delivery of the field values in the C-variables using proper conversion. For variable length strings a pointer is set into the cache.</para>
          </item>
          <item>
            <para>MapiMsg mapi_bind_numeric(MapiHdl hdl, int fldnr, int scale, int precision, void *val)</para>
            <para>Bind to a numeric variable, internally represented by MAPI_INT Describe the location of a numeric parameter in a query template.</para>
          </item>
          <item>
            <para>MapiMsg mapi_clear_bindings(MapiHdl hdl)</para>
            <para>Clear all field bindings.</para>
          </item>
          <item>
            <para>MapiMsg mapi_param(MapiHdl hdl, int fldnr, char **val)</para>
            <para>Bind a string variable with the n-th placeholder in the query template.  No conversion takes place.</para>
          </item>
          <item>
            <para>MapiMsg mapi_param_type(MapiHdl hdl, int fldnr, int ctype, int sqltype, void *val)</para>
            <para>Bind a variable whose type is described by ctype to a parameter whose type is described by sqltype.</para>
          </item>
          <item>
            <para>MapiMsg mapi_param_numeric(MapiHdl hdl, int fldnr, int scale, int precision, void *val)</para>
            <para>Bind to a numeric variable, internally represented by MAPI_INT.</para>
          </item>
          <item>
            <para>MapiMsg mapi_param_string(MapiHdl hdl, int fldnr, int sqltype, char *val, int *sizeptr)</para>
            <para>Bind a string variable, internally represented by MAPI_VARCHAR, to a parameter.  The sizeptr parameter points to the length of the string pointed to by val.  If sizeptr == NULL or *sizeptr == -1, the string is NULL-terminated.</para>
          </item>
          <item>
            <para>MapiMsg mapi_clear_params(MapiHdl hdl)</para>
            <para>Clear all parameter bindings.</para>
          </item>
        </itemize>
      </subsection>

      <subsection>
        <title>Miscellaneous</title>
        <itemize>
          <itemfunction><bullet/></itemfunction>
          <item>
            <para>MapiMsg mapi_setAutocommit(Mapi mid, int autocommit)</para>
            <para>Set the autocommit flag (default is on).  This only has an effect when the language is SQL.  In that case, the server commits after each statement sent to the server.</para>
          </item>
          <item>
            <para>MapiMsg mapi_cache_limit(Mapi mid, int maxrows)</para>
            <para>A limited number of tuples are pre-fetched after each <code>execute()</code>.  If maxrows is negative, all rows will be fetched before the application is permitted to continue. Once the cache is filled, a number of tuples are shuffled to make room for new ones, but taking into account non-read elements.  Filling the cache quicker than reading leads to an error.</para>
          </item>
          <item>
            <para>MapiMsg mapi_cache_shuffle(MapiHdl hdl, int percentage)</para>
            <para>Make room in the cache by shuffling percentage tuples out of the cache.  It is sometimes handy to do so, for example, when your application is stream-based and you process each tuple as it arrives and still need a limited look-back.  This percentage can be set between 0 to 100.  Making shuffle= 100% (default) leads to paging behavior, while shuffle==1 leads to a sliding window over a tuple stream with 1% refreshing.</para>
          </item>
          <item>
            <para>MapiMsg mapi_cache_freeup(MapiHdl hdl, int percentage)</para>
            <para>Forcefully shuffle the cache making room for new rows.  It ignores the read counter, so rows may be lost.</para>
          </item>
          <item>
            <para>char * mapi_quote(const char *str, int size)</para>
            <para>Escape special characters such as \n, \t in str with backslashes.  The returned value is a newly allocated string which should be freed by the caller.</para>
          </item>
          <item>
            <para>char * mapi_unquote(const char *name)</para>
            <para>The reverse action of <code>mapi_quote()</code>, turning the database representation into a C-representation. The storage space is dynamically created and should be freed after use.</para>
          </item>
          <item>
            <para>MapiMsg  mapi_trace(Mapi mid, int flag)</para>
            <para>Set the trace flag to monitor interaction with the server.</para>
          </item>
          <item>
            <para>int mapi_get_trace(Mapi mid)</para>
            <para>Return the current value of the trace flag.</para>
          </item>
          <item>
            <para>MapiMsg  mapi_trace_log(Mapi mid, const char *fname)</para>
            <para>Log the interaction between the client and server for offline inspection. Beware that the log file overwrites any previous log. It is not intended for recovery.</para>
          </item>
        </itemize>
        <para>The remaining operations are wrappers around the data structures maintained. Note that column properties are derived from the table output returned from the server.</para>
        <itemize>
          <itemfunction><bullet/></itemfunction>
          <item>
            <para>char *mapi_get_name(MapiHdl hdl, int fnr)</para>
          </item>
          <item>
            <para>char *mapi_get_type(MapiHdl hdl, int fnr)</para>
          </item>
          <item>
            <para>char *mapi_get_table(MapiHdl hdl, int fnr)</para>
          </item>
          <item>
            <para>int mapi_get_len(Mapi mid, int fnr)</para>
          </item>
          <item>
            <para>char *mapi_get_dbname(Mapi mid)</para>
          </item>
          <item>
            <para>char *mapi_get_host(Mapi mid)</para>
          </item>
          <item>
            <para>char *mapi_get_user(Mapi mid)</para>
          </item>
          <item>
            <para>char *mapi_get_lang(Mapi mid)</para>
          </item>
          <item>
            <para>char *mapi_get_version(Mapi mid)</para>
          </item>
          <item>
            <para>int mapi_get_versionId(Mapi mid)</para>
          </item>
          <item>
            <para>char *mapi_get_motd(Mapi mid)</para>
          </item>
          <item>
            <para>char **mapi_tables(Mapi mid)</para>
            <para>Return a list of accessible database tables.</para>
          </item>
          <item>
            <para>char **mapi_fields(Mapi mid)</para>
            <para>Return a list of accessible tables fields. This can also be obtained by inspecting the field descriptor returned by <code>mapi_fetch_field()</code>.</para>
          </item>
        </itemize>
        <example xml:space="preserve"></example>
      </subsection>
    </section>
  </node>
  <node>
    <nodename>The Perl Library</nodename>
    <nodenext>The PHP Library</nodenext>
    <nodeprev>Mapi Function Reference</nodeprev>
    <nodeup>Programming Interfaces</nodeup>
  </node>
  <node>
    <nodename>The PHP Library</nodename>
    <nodenext>The Python Library</nodenext>
    <nodeprev>The Perl Library</nodeprev>
    <nodeup>Programming Interfaces</nodeup>
  </node>
  <node>
    <nodename>The Python Library</nodename>
    <nodenext>Embedded MonetDB</nodenext>
    <nodeprev>The PHP Library</nodeprev>
    <nodeup>Programming Interfaces</nodeup>
  </node>
  <node>
    <nodename>Embedded MonetDB</nodename>
    <nodenext>A Simple Example</nodenext>
    <nodeprev>The Python Library</nodeprev>
    <nodeup>Top</nodeup>
    <section>
      <title>Embedded MonetDB</title>
      <para>The Embedded MonetDB version is optimized for running on small board computers as a database back-end for a single client. It is of particular interest if you need database functionality within a limited application setting, e.g a self-contained database distributed as part of the application. Within this context, much of the code to facilitate and protect concurrent use of the kernel can be disabled. For example, the communication overhead of client-server TCP-IP interaction is removed. Moreover, locking of critical resources in the kernel is not needed anymore, which results in significant performance improvements.</para>
      <para>The approach taken is to wrap a server such that the interaction between client code and server can still follow the Mapi protocol. It leads to a C-program with calls to the Mapi library routines, which provides some protection against havoq behaviour. From a programming view, it differs from a client-server application in the startup and (implicit) termination.</para>
      <para>You normally only have to change the call <code>mapi_connect()</code> into <code>embedded_sql()</code> (or <code>embedded_mal()</code>). It requires an optional argument list to refine the environment variables used by the server. In combination with the header file <code>embeddedclient.h</code> it provides the basis to compile and link the program.</para>
<!-- The primary host language is C. Embedded versions for other languages are under development. -->
      <para>The behavior of an embedded SQL program can be simulated with a server started as follows:</para>
      <example xml:space="preserve">mserver5 --set embedded=yes --dbinit="include sql;" &amp;</example>
      <para>As a result, the server starts in 'daemon' mode, loads the SQL support library, and waits for a connection. Only one connection is permitted.</para>
      <menu>
        <menuentry>
          <menunode>A Simple Example</menunode>
          <menutitle>A Simple Example</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Configuration Parameters</menunode>
          <menutitle>Configuration Parameters</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Embedded MonetDB Limitations</menunode>
          <menutitle>Embedded MonetDB Limitations</menutitle>
          <menucomment></menucomment>
        </menuentry>
      </menu>
    </section>
  </node>
  <node>
    <nodename>A Simple Example</nodename>
    <nodenext>Configuration Parameters</nodenext>
    <nodeprev>Embedded MonetDB</nodeprev>
    <nodeup>Embedded MonetDB</nodeup>
    <subsection>
      <title>Mbedded Example</title>
      <para>A minimalistic embedded application is shown below. It creates a temporary table in the database, fills it, and retrieves the records for some statistics gathering.</para>
      <para>The key operation is <code>embedded_sql()</code> which takes an optional environment argument list. Upon success of this call, there will be a separate server thread running in the same user space to handle the database requests. A short-circuit interaction is established between the application and the kernel using in memory buffers.</para>
      <para>The body of the program consists of the Mapi calls you have already seen (see <xref><xrefnodename>The Mapi Library</xrefnodename></xref>). It terminates with a call to <code>mapi_disconnect()</code> which lets the MonetDB thread gracefully die.</para>
      <para>The tight coupling of application and kernel code also carries some dangers. Many of the MonetDB data structures can be directly accessed, or calls to the kernel routines are possible. It is highly advised to stick to the Mapi interaction protocol. It gives a little more protection against malicious behavior or unintended side-effects.</para>
      <example xml:space="preserve"><verbatim xml:space="preserve"><![CDATA[
#include <embeddedclient.h>

#define die(dbh,hdl) (hdl?mapi_explain_result(hdl,stderr):      \
              dbh?mapi_explain(dbh,stderr):         \
                  fprintf(stderr,"command failed\n"),   \
              exit(-1))

#define close_handle(X,Y) if (mapi_close_handle(X) != MOK) die(X, Y);

int
main()
{
    Mapi dbh;
    MapiHdl hdl = NULL;
    int i;

    dbh= embedded_sql(NULL,0);
    if (dbh == NULL || mapi_error(dbh))
        die(dbh, hdl);

    /* switch off autocommit */
    if (mapi_setAutocommit(dbh, 0) != MOK || mapi_error(dbh))
        die(dbh,NULL);

    if ((hdl = mapi_query(dbh, "create table emp"
				" (name varchar(20),age int)")) == NULL || mapi_error(dbh))
        die(dbh, hdl);
    close_handle(dbh,hdl);

    for(i=0; i< 1000; i++) {
        char query[100];
        snprintf(query, 100, "insert into emp values('user%d', %d)", i, i % 82);
        if ((hdl = mapi_query(dbh, query)) == NULL || mapi_error(dbh))
            die(dbh, hdl);
        close_handle(dbh,hdl);
    }

    if ((hdl = mapi_query(dbh, "select * from emp")) == NULL || mapi_error(dbh))
        die(dbh, hdl);

    i=0;
    while (mapi_fetch_row(hdl))  {
        char *age = mapi_fetch_field(hdl, 1);
        i= i+ atoi(age);
    }
    if (mapi_error(dbh))
        die(dbh, hdl);
    close_handle(dbh,hdl);
    printf("The footprint is %d Mb \n",i);

    mapi_disconnect(dbh);
    return 0;
}
]]></verbatim></example>
      <para>The embedded MonetDB engine is available as the library <code>libembedded_sql.a</code> (and <code>libembedded_mal.a</code>) to be linked with a C-program. Provided the programming environment have been initialized properly, it suffices to prepare the embedded application using</para>
      <example xml:space="preserve">gcc myprog.c -o myprog `monetdb5-config --cflags --libs`</example>
      <para>You might also write a Makefile to build the program as follows.[todo]</para>
      <example xml:space="preserve"><verbatim xml:space="preserve"><![CDATA[
CC= gcc
INCLUDE=`monetdb5-config --cflags`
LIBS=`monetdb5-config --libs`
myprog: myprog.o
	${CC} myprog.o -o myprog ${LIBS}
myprog.o : myprog.c
	${CC} -c ${INCLUDE} myprog.c

clean: myprog.o
	rm -f myprog myprog.o
]]></verbatim></example>
    </subsection>
  </node>
  <node>
    <nodename>Configuration Parameters</nodename>
    <nodenext>Embedded MonetDB Limitations</nodenext>
    <nodeprev>A Simple Example</nodeprev>
    <nodeup>Embedded MonetDB</nodeup>
    <para>The configuration parameters for the server are read from its default location in the file system. In an embedded setting this location may not be accessible. It requires calls to <code>embedded_option()</code> before you asks for the instantiation of the server code itself. The code snippet below illustrate how our example is given hardwired knowledge on the desired settings:</para>
    <example xml:space="preserve"><verbatim xml:space="preserve"><![CDATA[
main(){
...
	Mbedded_option("dbfarm",".");
	Mbedded_option("dbname","demo");
	Mbedded_option("user","guest");
	Mbedded_option("password","anonymous");
...
	Mbedded_sql(NULL,0);
]]></verbatim></example>
    <para>For an overview of the system configuration parameters see XYZ.</para>
  </node>
  <node>
    <nodename>Embedded MonetDB Limitations</nodename>
    <nodenext>MonetDB Assembler Language</nodenext>
    <nodeprev>Configuration Parameters</nodeprev>
    <nodeup>Embedded MonetDB</nodeup>
    <subsection>
      <title>Limitations for Embedded MonetDB</title>
      <para>In embedded applications the memory footprint is a factor of concern. The raw footprint as delivered by the Unix <code>size</code> command is often used. It is, however, also easily misleading, because the footprint depends on both the code segments and buffered database partitions in use. Therefore it makes sense to experiment with a minimal, but functionally complete application to decide if the resources limitations are obeyed.</para>
      <para>The minimal static footprint of MonetDB is about 16 Mb (+ ca 4Mb for SQL). After module loading the space quickly grows to about 60Mb. <emph>This footprint should be reduced.</emph></para>
      <para>A better frame of reference for embedded applications is our sample program, which is a simple, yet complete embedded application inspired by an MP3 player. The table below illustrates some basic properties on different embedded SQL platforms.</para>
      <multitable>
        <columnfraction>20</columnfraction>
        <columnfraction>20</columnfraction>
        <columnfraction>20</columnfraction>
        <columnfraction>20</columnfraction>
        <columnfraction>20</columnfraction>
        <tbody>
          <row>
            <entry></entry>
            <entry>Mbedded</entry>
            <entry>SQLite</entry>
            <entry>MySQL</entry>
            <entry>PostgreSQL</entry>
          </row>
          <row>
            <entry>Prepare time</entry>
          </row>
          <row>
            <entry>Max memory</entry>
          </row>
          <row>
            <entry>CPU time</entry>
          </row>
        </tbody>
      </multitable>
      <para>The <code>Prepare time</code> denotes the compilation and link time on a state-of-the-art PC.</para>
      <para>The embedded application world calls for many, highly specialized enhancements. It is often well worth the effort to carve out the functionality needed from the MonetDB software packages. The easiest solution to limit the functionality and reduce resource consumption is to reduce the modules loaded. This requires patches to the startup scripts.</para>
      <para>The benefit of an embedded database application also comes with limitations. The one and foremost limitation of embedded MonetDB is that the first application accessing the database effectively locks out any other concurrent use. Even in those situations where concurrent applications merely read the database, or create privately held tables.</para>
    </subsection>
  </node>
  <node>
    <nodename>MonetDB Assembler Language</nodename>
    <nodenext>MAL instructions</nodenext>
    <nodeprev>Embedded MonetDB Limitations</nodeprev>
    <nodeup>Top</nodeup>
    <chapter>
      <title>Monetdb Assembler Language</title>
      <para>The primary textual interface to the Monetdb kernel is a simple, assembler-like language, called MAL. The language reflects the virtual machine architecture around the kernel libraries and has been designed for speed of parsing, ease of analysis, and ease of target compilation by query compilers. The language is not meant as a primary programming language, or scripting language. Such use is even discouraged.</para>
      <para>Furthermore, a MAL program is considered a specification of intended computation and data flow behavior. It should be understood that its actual evaluation depends on the execution paradigm chosen in the scenario. The program blocks can both be interpreted as ordered sequences of assembler instructions, or as a representation of a data-flow graph that should be resolved in a dataflow driven manner. The language syntax uses a functional style definition of actions and mark those that affect the flow explicitly. Flow of control keywords identify a point to chance the interpretation and denote a synchronization point.</para>
      <para>MAL is the target language for query compilers, such as the SQL and XQuery front-ends. Even simple SQL queries generate a long sequence of MAL instructions. They represent both the administrative actions to ensure binding and transaction control, the flow dependencies to produce the query result, and the steps needed to prepare the result set for delivery to the front-end.</para>
      <para>Only when the algebraic structure is too limited (e.g. updates), or the database back-end lacks feasible builtin bulk operators, one has to rely on more detailed flow of control primitives. But even in that case, the basic blocks to be processed by a MAL back-end are considered large, e.g. tens of simple bulk assignment instructions.</para>
      <para>The remainder of this chapter provide a concise overview of the language features and illustrative examples.</para>
      <menu>
        <menuentry>
          <menunode>MAL instructions</menunode>
          <menutitle>MAL instructions</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Flow of control</menunode>
          <menutitle>Flow of control</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Function definitions</menunode>
          <menutitle>Function definitions</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Factory definitions</menunode>
          <menutitle>Factory definitions</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Type resolution</menunode>
          <menutitle>Type resolution</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Atomary types</menunode>
          <menutitle>Atomary types</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Boxed variables</menunode>
          <menutitle>Boxed variables</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Property management</menunode>
          <menutitle>Property management</menutitle>
          <menucomment></menucomment>
        </menuentry>
      </menu>
    </chapter>
  </node>
  <node>
    <nodename>MAL instructions</nodename>
    <nodenext>Flow of control</nodenext>
    <nodeprev>MonetDB Assembler Language</nodeprev>
    <nodeup>MonetDB Assembler Language</nodeup>
    <section>
      <title>MAL instructions</title>
      <para>MAL instructions have purposely a simple format. Each instruction denotes a data-flow statement. It is syntactically represented by an assignment, where an expression (function call) delivers results to multiple target variables. The assignment patterns recognized are illustrated below.</para>
      <example xml:space="preserve">(t1,..,t32) := module.fcn(a1,..,a32);
t1 := module.fcn(a1,..,a32);
t1 := v1 operator v2;
t1 := constant;
(t1,..,tn) := (a1,..,an);</example>
      <para>Variables are implicitly defined upon first use and take on a type through a type classifier or inherit it from the context in which they are used, see <xref><xrefnodename>Type resolution</xrefnodename></xref>. Operators are grouped into user defined modules <xref><xrefnodename>MAL Modules</xrefnodename></xref>. Binary arithmetic operations are merely provided as a short-hand, e.g. the expression <code>t:=2+2</code> is converted directly into <code>t:= calc.+(2,2)</code>.</para>
      <para>Target variables are optional. The compiler introduces temporary variables to hold the result of the expression upon need. They act as data sinks in the flow graph.</para>
      <para>For parsing simplicity, each instruction fits on a single line. Comments start with a sharp '#' and continues to the end of the line. They are retained in the internal code representation to ease debugging of compiler generated MAL programs.</para>
      <para>The data structure to represent a MAL block is kept simple. It carries a sequence of MAL statements and a symbol table. The MAL instruction is a code byte string overlaid with the instruction pattern, which contains references into the symbol tables and administrative data for the interpreter.</para>
      <para>This method leads to a large allocated block, which can be easily freed, and pattern makes it possible to accommodate a variable argument list. Variable- and statement- block together describe the static part of a MAL procedure. It carries carry enough information to produce a listing and to aid symbolic debugging.</para>
    </section>
  </node>
  <node>
    <nodename>Flow of control</nodename>
    <nodenext>Function definitions</nodenext>
    <nodeprev>MAL instructions</nodeprev>
    <nodeup>MonetDB Assembler Language</nodeup>
    <section>
      <title>Flow of control</title>
      <para>The flow of control within a MAL program block can be changed by tagging an assignment with either <code>return</code>, <code>yield</code>, <code>barrier</code>, <code>catch</code>, <code>leave</code>, <code>redo</code>, or <code>exit</code>.</para>
      <para>The flow modifiers <code>return</code> and <code>yield</code> mark the end of a call and return one or more results to the calling environment. The <code>return</code> and <code>yield</code> are followed by a target list or an assignment, which is executed first.</para>
      <para>The <code>barrier</code> (<code>catch</code>) and <code>exit</code> pair mark a guarded statement block. They may be nested to form a proper hierarchy identified by their target variables.</para>
      <para>The <code>leave</code> and <code>redo</code> are conditional flow modifiers. Their first target variable is also denoted as the control variable. It is used after  the assignment statement has been evaluated to decide on the flow-of-control action to be taken. Built-in controls exists for booleans and numeric values. The barrier block is opened when the control variable holds true, when its numeric value &gt;= 0, or when it is a non-empty string. The <code>nil</code> value blocks entry in all cases.</para>
      <para>Once inside the barrier you have an option to prematurely <code>leave</code> it at the exit statement or to <code>redo</code> interpretation just after the corresponding barrier statement. Much like 'break' and 'continue' statements in the programming language C. The action is taken when the condition is met.</para>
      <para>The <code>exit</code> marks the exit for a block. Its optional assignment can be used to re-initialize the barrier control variables or wrap-up any related administration.</para>
      <para>A control block is recognized by its target variable set, which implies that nesting on the same target set is prohibited.</para>
      <para>The barrier blocks can be properly nested to form a hierarchy of basic blocks. The control flow within and between blocks is simple enough to deal with during an optimizer stage. The <code>redo</code> and <code>leave</code> statements mark the partial end of a block. Statements within these blocks can be re-arranged according to the data-flow dependencies. The order of partial blocks can not be changed that easily. It depends on the mutual exclusion of the data flows within each partial block.</para>
      <para>Common guarded blocks in imperative languages are the for-loop and if-then-else constructs. They can be simulated as follows.</para>
      <para>Consider the statement <code>for(i=1;i&lt;10;i++) print(i)</code>. The (optimized) MAL block to implement this becomes:</para>
      <example xml:space="preserve">     i:= 1;
barrier B:= i&lt;10;
     print(i);
     i:= i+1;
redo B:= i&lt;10;
exit B;</example>
      <para>Translation of the statement <code>if(i&lt;1) print("ok"); else print("wrong");</code> becomes:</para>
      <example xml:space="preserve">    i:=1;
barrier ifpart:= i&lt;1;
    print("ok");
exit ifpart;
barrier elsepart:= i&gt;=1;
    print("wrong");
exit elsepart;</example>
      <para>Note that both guarded blocks can be interchanged without affecting the outcome. Moreover, neither block would have been entered if the variable happens to be assigned <code>nil</code>.</para>
      <para>The primitives are sufficient to model a wide variety of iterators, whose pattern look like:</para>
      <example xml:space="preserve">barrier i:= newIterator(T);
    elm:= getElement(T,i);
    ...
    leave i:= noMoreElements(T);
    ...
    redo i:= hasMoreElements(T);
exit i:= exitIterator(T);</example>
      <para>The semantics obeyed by the iterator implementations is as follows. The redo expression updates the target variable <emph> i</emph> and control proceeds at the first statement after the barrier when the barrier is opened by <emph> i</emph>. If the barrier could not be re-opened, execution proceeds with the first statement after the redo. Likewise, the leave control statement skips to the exit when the control variable <emph> i</emph> shows a closed barrier block. Otherwise, it continues with the next instruction. Note, in both failed cases the control variable is possibly changed.</para>
      <para>A recurring situation is to iterate over the elements in a BAT. This is supported by an iterator implementation in the bbp module as follows:</para>
      <example xml:space="preserve">barrier (idx,hd,tl):= newIterator(B);
    ...
    redo (idx,hd,tl):= hasMoreElements(B);
exit i;</example>
      <para>Where idx is an integer to denote the row in the BAT, hd and tl denote values of the current element. This scheme is more efficient</para>
      <example xml:space="preserve"></example>
    </section>
  </node>
  <node>
    <nodename>Function definitions</nodename>
    <nodenext>Polymorphic Functions</nodenext>
    <nodeprev>Flow of control</nodeprev>
    <nodeup>MonetDB Assembler Language</nodeup>
    <section>
      <title>MAL functions</title>
      <para>MAL comes with a standard functional abstraction scheme. MAL functions are represented by MAL instruction lists, enclosed by a <code>function</code> and <code>end</code> statement. The <code>function</code> designates its signature, i.e. it lists the arguments and their types. The <code>end</code> statement marks the end of this sequence. Its argument is the function name.</para>
      <para>An illustrative example is:</para>
      <example xml:space="preserve">function helloWorld(msg:str):str;
    io.print(msg);
    return msg;
end hellowWorld;</example>
      <para>The functional abstraction scheme comes with several variations: commands, patterns, and factories. They are discussed shortly.</para>
      <menu>
        <menuentry>
          <menunode>Polymorphic Functions</menunode>
          <menutitle>Polymorphic Functions </menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Commands and Patterns</menunode>
          <menutitle>Commands and Patterns</menutitle>
          <menucomment></menucomment>
        </menuentry>
      </menu>
      <example xml:space="preserve"></example>
    </section>
  </node>
  <node>
    <nodename>Polymorphic Functions</nodename>
    <nodenext>Commands and Patterns</nodenext>
    <nodeprev>Function definitions</nodeprev>
    <nodeup>Function definitions</nodeup>
    <subsection>
      <title>Polymorphic Functions</title>
      <para>MAL supports polymorphic functions using type variables. The type variable is denoted by <code>any</code> and an optional index. Each time a polymorphic  MAL function is called, the symbol table is first inspected for the matching strongly typed version.  If non exists, a copy of the polymorphic routine is generated, whereafter the type variables are replaced with their concrete types. The function body is immediately type checked and, if no errors occured, added to the symbol table.</para>
      <para>The generic type variable <code>any</code> designates an unknown type, which may be filled at type resolution time. Unlike indexed polymorphic type arguments, <code>any</code> type arguments match possibly with different concrete types.</para>
      <para>An example of a parameterised function is shown below:</para>
      <example xml:space="preserve">function helloWorld(msg:any_1):any_1;
	io.print(msg);
return msg;</example>
      <para>The type variables ensure that the return type equals the argument type. Type variables can be used at any place where a type name is permitted. Beware that polymorphic type variables are propagated throughout the function body. This may invalidate type resolutions taken <xref><xrefnodename>Type resolution</xrefnodename></xref>.</para>
      <para>This version of <code>helloWorld</code> can also be used for other arguments types, i.e. <code>bit,sht,lng,flt,dbl,...</code>. For example, calling <code>helloWorld(3.14:flt)</code> echoes a float value.</para>
    </subsection>
  </node>
  <node>
    <nodename>Commands and Patterns</nodename>
    <nodenext>Factory definitions</nodenext>
    <nodeprev>Polymorphic Functions</nodeprev>
    <nodeup>Function definitions</nodeup>
    <subsection>
      <title>Commands and patterns</title>
      <para>The MAL function body can also be implemented with a C-function. They are introduced to the MAL type checker by providing their signature and an <code>address</code> qualifier for linkage.</para>
      <para>We distinguish both <code>command</code> and <code>pattern</code> C-function blocks. They differ in the information accessible at run time. The <code>command</code> variant calls the underlying C-function, passing pointers to the arguments on the MAL runtime stack. The <code>pattern</code> command is passed pointers to the MAL definition block, the runtime stack, and the instruction itself. It can be used to analyse the types of the arguments directly.</para>
      <para>For example, the definitions below link the kernel routine <code>BKCinsert_bun</code> with the function <code>bat.insert()</code>. It does not fully specify the result type. The <code>io.print()</code> pattern applies to any BAT argument list, provided they match on the head column type.</para>
      <example xml:space="preserve">command bat.insert(b:bat[:any_1,:any_2], ht:any_1, tt:any_2) :bat[:any_1,:any_2]
address BKCinsert_bun;

pattern io.print(b1:bat[:any_1,:any]...):int
address IOtable;</example>
      <example xml:space="preserve"></example>
    </subsection>

    <subsection>
      <title>Lifespan analysis</title>
      <para>Optimizers may be interested in the characteristic of the barrier blocks for making a decision. The variables have a lifespan in the code blocks, denoted by properties beginLifespan,endLifespan. The beginLifespan denotes the intruction where it receives its first value, the endLifespan the last instruction in which it was used as operand or target.</para>
      <para>If, however, the last use lies within a BARRIER block, we can not be sure about its end of life status, because a block redo may implictly revive it. For these situations we associate the endLifespan with the block exit.</para>
      <para>In many cases, we have to determine if the lifespan interferes with a optimization decision being prepared. The lifespan is calculated once at the beginning of the optimizer sequence. It should either be maintained to reflect the most accurate situation while optimizing the code base. In particular it means that any move/remove/addition of an instruction calls for either a recalculation or delta propagation. Unclear what will be the best strategy. For the time being we just recalc.</para>
      <example xml:space="preserve"></example>
    </subsection>
  </node>
  <node>
    <nodename>Factory definitions</nodename>
    <nodenext>Type resolution</nodenext>
    <nodeprev>Commands and Patterns</nodeprev>
    <nodeup>MonetDB Assembler Language</nodeup>
    <section>
      <title>Factories</title>
      <para>A convenient programming construct is the co-routine, which is specified as an ordinary function, but maintains its own state between calls, and permits re-entry other than by the first statement.</para>
      <para>The random generator example is used to illustrate its definition and use.</para>
      <example xml:space="preserve">factory random(seed:int,limit:int):int;
    rnd:=seed;
    lim:= limit;
barrier lim;
    leave lim:= lim-1;
    rnd:= rnd*125;
    yield rnd:= rnd % 32676;
    redo lim;
exit lim;
end random;</example>
      <para>The first time this factory is called, a factory plant is created in the local system to handle the requests. The plant carries the stack frame and synchronizes access.</para>
      <para>In this case it initializes the generator. The random number is generated and <code>yield</code>  as a result of the call. The factory process is then put to sleep. The second call received by the factory wakes it up at the point where it went to sleep. In this case it will find a <code>redo</code> statement and produces the next random number. Note that also in this case a seed and limit value are expected, but they are ignored in the body. This factory can be called upon to generate at most 'limit' random numbers using the 'seed' to initialize the generator. Thereafter it is being removed, i.e. reset to the original state.</para>
      <para>A cooperative group of factories can be readily constructed. For example, assume we would like the random factories to respond to both <code>random(seed,limit)</code> and <code>random()</code>. This can be defined as follows:</para>
      <example xml:space="preserve">factory random(seed:int,limit:int):int;
    rnd:=seed;
    lim:= limit;
barrier lim;
    LEAVE lim:= lim-1;
    rnd:= rnd*125;
    YIELD rnd:= rnd % 32676;
    REDO lim;
exit lim;
end random;

factory random():int;
barrier forever:=true;
    yield random(0,0);
    redo forever;
exit forever;
end random;</example>
      <subsection>
        <title>Client support</title>
        <para>For simple cases, e.g. implementation of a random function, it suffices to ensure that the state is secured between calls. But, in a database context there are multiple clients active. This means we have to be more precise on the relationship between a co-routine and the client for which it works.</para>
        <para>The co-routine concept researched in Monet 5 is the notion of a 'factory', which consists of 'factory plants' at possibly different locations and with different policies to handle client requests. Factory management is limited to its owner, which is derived from the module in which it is placed. By default Admin is the owner of all modules.</para>
        <para>The factory produces elements for multiple clients. Sharing the factory state or even remote processing is up to the factory owner. They are set through properties for the factory plant.</para>
        <para>The default policy is to instantiate one shared plant for each factory. If necessary, the factory can keep track of a client list to differentiate the states. A possible implementation would be:</para>
        <example xml:space="preserve">factory random(seed:int,clientid:int):int;
    clt:= bat.new(:int,:int);
    bat.insert(clt,clientid,seed);
barrier always:=true;
    rnd:= algebra.find(clt,clientid);
catch   rnd; #failed to find client
    insert(clt,clientid,seed);
    rnd:= algebra.find(clt,clientid);
exit    rnd;
    rnd:= rnd * 125;
    rnd:= rnd % 32676;
    algebra.replace(clt,clientid,rnd);
    yield rnd;
    redo always;
exit always;
end random;</example>
        <para>The operators to built client aware factories are, <code>factory.getCaller()</code>, which returns a client index, <code>factory.getModule()</code> and <code>factory.getFunction()</code>, which returns the identity of scope enclosed.</para>
        <para>To illustrate, the client specific random generator can be shielded using the factory:</para>
        <example xml:space="preserve">factory random(seed:int):int;
barrier always:=true;
    clientid:= factory.getCaller();
    yield user.random(seed, clientid);
    redo always;
exit always;
end random;</example>
      </subsection>

      <subsection>
        <title>Complex factory examples</title>
        <para>One interesting use of the factory scheme is to model a volcano-style query processor. Each node in the query tree is an iterator that calls upon the operands to produce a chunk, which are combined into a new  chunk for concumption of the parent. The prototypical join(R,S) query illustrates it. The plan does not test for all boundary conditions, it merely implements a nested loop. The end of a sequence is identified by a NIL chunk.</para>
        <example xml:space="preserve">factory query();
    Left:= sql.bind("relationA");
    Right:= sql.bind("relationB");
    rc:= sql.joinStep(Left,Right);
barrier rc!= nil;
    io.print(rc);
    rc:= sql.joinStep(Left,Right);
    redo rc!= nil;
exit rc;
end query;

#nested loop join
factory sql.joinStep(Left:bat[:any,:any],Right:bat[:any,:any]):bat[:any,:any];
    lc:= chopper.chunkStep(Left);
barrier outer:= lc != nil;
    rc:= chopper.chunkStep(Right);
    barrier inner:= rc != nil;
        chunk:= algebra.join(lc,rc);
        yield chunk;
        rc:= chopper.chunkStep(Right);
        redo inner:= rc != nil;
    exit inner;
    lc:= chopper.chunkStep(Left);
    redo outer:= lc != nil;
exit outer;
    # we have seen everything
    return nil;
end joinStep;

#factory for left branch
factory chunkStepL(L:bat[:any,:any]):bat[:any,:any];
    i:= 0;
    j:= 20;
    cnt:= algebra.count(L);
barrier outer:= j&lt;cnt;
    chunk:= algebra.slice(L,i,j);
    i:= j;
    j:= i+ 20;
    yield chunk;
    redo loop:= j&lt;cnt;
exit outer;
    # send last portion
    chunk:= algebra.slice(L,i,cnt);
    yielD chunk;
    return nil;
end chunkStep;

#factory for right leg
factory chunkStepR(L:bat[:any,:any]):bat[:any,:any];</example>
        <para>So far we haven;t re-used the pattern that both legs are identical. This could be modeled by a generic chunk factory. Choosing a new factory for each query steps reduces the administrative overhead.</para>
        <para>The Factory concept is still rather experimental and many questions should be considered, e.g. What is the lifetime of a factory? Does it persists after all clients has disappeared? What additional control do you need? Can you throw an exception to a Factory?</para>
        <example xml:space="preserve"></example>
      </subsection>
    </section>
  </node>
  <node>
    <nodename>Type resolution</nodename>
    <nodenext>Atomary types</nodenext>
    <nodeprev>Factory definitions</nodeprev>
    <nodeup>MonetDB Assembler Language</nodeup>
    <chapter>
      <title>MAL Type Resolution</title>
      <para>Given the interpretative nature of many of the MAL instructions, when and where type resolution takes place is a critical design issue. Performing it too late, i.e. at each instruction call, leads to performance problems if we derive the same information over and over again. However, many built-in operators have polymorphic typed signatures, so we cannot escape it altogether.</para>
      <para>Consider the small illustrative MAL program:</para>
      <example xml:space="preserve">function sample(nme:str, val:any_1):bit;
   c := 2 * 3;
   b := bbp.bind(nme);  #find a BAT
   h := algebra.select(b,val,val);
   t := aggr.count(h);
   x := io.print(t);
   y := io.print(val);
end sample;</example>
      <para>The function definition is polymorphic typed on the 2nd argument, it becomes a concrete type upon invocation. The system could attempt a type check, but quickly runs into assumptions that generally do not hold. The first assignment can be type checked during parsing and a symbolic optimizer could even evaluate the expression once. Looking up a BAT in the buffer pool leads to an element <code>:bat[<emph>ht,tt</emph>]</code> where <emph>ht</emph> and <emph>tt</emph> are runtime dependent types, which means that the selection operation can not be type-checked immediately. It is an example of an embedded polypmorphic statement, which requires intervention of the user/optimizer to make the type explicit before the type resolver becomes active. The operation <code>count</code> can be checked, if it is given a BAT argument. This assumes that we can infer that 'h' is indeed a BAT, which requires assurance that <code>algebra.select</code> produces one. However, there are no rules to avoid addition of new operators, or to differentiate among different implementations based on the argument types. Since <code>print(t)</code> contains an undetermined typed argument we should postpone typechecking as well. The last print statement can be checked upon function invocation.</para>
      <para>Life becomes really complex if the body contains a loop with variable types. For then we also have to keep track of the original state of the function. Or alternatively, type checking should consider the runtime stack rather than the function definition itself.</para>
      <para>These examples give little room to achieve our prime objective, i.e. a fast and early type resolution scheme. Any non-polymorphic function can be type checked and marked type-safe upon completion. Type checking polymorphic functions are post-poned until a concrete type instance is known. It leads to a clone, which can be type checked and is entered into the symbol table.</para>
    </chapter>
  </node>
  <node>
    <nodename>Atomary types</nodename>
    <nodenext>Boxed variables</nodenext>
    <nodeprev>Type resolution</nodeprev>
    <nodeup>MonetDB Assembler Language</nodeup>
    <section>
      <title>Atomary types</title>
      <para>MonetDB supports an extensible type system to accomodate a wide spectrum of database kernels and application needs. The type administration keeps track of their properties and provides access to the underlying implementations.</para>
      <para>MAL recognizes the definition of a new atom type by replacing the <code>module</code> keyword with <code>atom</code>. Atoms definitions require special care, because their definition and properties should be communicated with the GDK kernel library. The commands defined in an <code>atom </code> block are screened as of interest to the gdk_atom library.</para>
      <para>MonetDB comes with the hardwired types <code>bit,chr,sht,int,lng,oid,flt, dbl,str</code> and <code>bat</code>, the representation of a bat identifier. The kernel code has been optimized to deal with these types efficiently, i.e. without unnecessary function call overheads.</para>
      <para>A small collection of user-defined <code>atom</code> types is shipped with the sysem. They implement types considered essential for end-user applications, such as <code>color, date, time, blob</code>, and <code>url</code>. They are implemented using the type extension mechanism described below. As such, they provide examples for future extensions. A concrete example is the 'blob' datatype in the MonetDB atom module library(see ../modules/atoms/blob.mx)</para>

      <subsection>
        <title>Defining your own types</title>
        <para>For the courageous at heart, you may enter the difficult world of extending the kernel library. The easiest way is to derive the atom modules from one shipped in the source distributie. More involved atomary types require a study of the documentation associated with the atom structures (gdk_atoms), because you have to develop a handful routines complying with the signatures required in the GDK library. They are registered upon loading the <code>atom</code> module.</para>
        <example xml:space="preserve"></example>
      </subsection>
    </section>
  </node>
  <node>
    <nodename>Boxed variables</nodename>
    <nodenext>Property management</nodenext>
    <nodeprev>Atomary types</nodeprev>
    <nodeup>MonetDB Assembler Language</nodeup>
    <chapter>
      <title>Boxed variables</title>
      <para>Clients sessions often come with a global scope of variable settings. Access to these global variables should be easy, but they should also provide protection against concurrent update when the client wishes to perform parallel processing. Likewise, databases, query languages, etc. may define constants and variables accessible, e.g. relational schemas, to a selected user group.</para>
      <para>The approach taken is to rely on persistent object spaces as pioniered in Lynda and -later- JavaSpaces. They are called boxes in MonetDB and act as managed containers for persistent variables.</para>
      <para>Before a client program  can interact with a box, it should open it, passing qualifying authorization information and parameters to instruct the box-manager of the intended use. A built-in box is implicitly opened when you request for its service.</para>
      <para>At the end of a session, the box should be closed. Some box-managers may implement a lease-scheme to automatically close interaction with a client when the lease runs out. Likewise, the box can be notified when the last reference to a leased object ceases to exist.</para>
      <para>A box can be extended with a new object using the function deposit(name) with name a local variable. The default implementation silently accepts any new definition of the box. If the variable was known already in the box, its value is overwritten.</para>
      <para>A local copy of an object can be obtained using the pattern 'take(name,[param])', where name denotes the variable of interest. The type of the receiving variable should match the one known for the object. Whether an actual copy is produced or a reference to a shared object is returned is defined by the box manager.</para>
      <para>The object is given back to the box manager calling 'release(name)'. It may update the content of the repository accordingly, release locks, and move the value to persistent store. Whatever the semantics of the box requires. [The default implementation is a no-op]</para>
      <para>Finally, the object manager can be requested to 'discard(name)' a variable completely.  The default implementation is to reclaim the space in the box.</para>
      <para>Concurrency control, replication services, as well as access to remote stores may be delegated to a box manager. Depending on the intended semantics, the box manager may keep track of the clients holding links to this members, provide a traditional 2-phase locking scheme, optimistic control, or check-out/check-in scheme. In all cases, these management issues are transparant to the main thread (=client) of control, which operates on a temporary snapshot. For the time being we realize the managers as critical code sections, i.e. one client is permitted access to the box space at a time.</para>
      <para>Example: consider the client function:</para>
      <example xml:space="preserve">function myfcn():void;
	b:bat[:oid,:int] := bbp.take("mytable");
	c:bat[:int,:str] := sql.take("person","age");
	d:= intersect(b,c);
	io.print(d);
	u:str:= client.take(user);
	io.print(u);
	client.release(user);
end function;</example>
      <para>The function binds to a copy from the local persistent BAT space, much like bat-names are resolved in earlier versions. The second statement uses an implementation of take that searches a variable of interest using two string properties. It illustrates that a box manager is free to extend/overload the predefined scheme, which is geared towards storing MAL variables.</para>
      <para>The result bat 'c' is temporary and disappears upon garbage collection. The variable 'u' is looked up as the string object user.</para>
      <para>Note that BATs b and c need be released at some point. In general this point in time does not coincide with a computational boundary like a function return. During a session, several bats may be taken out of the box, being processed, and only at the end of a session being released. In this example, it means that the reference to b and c is lost at the end of the function (due to garbarge collection) and that subsequent use requires another take() call. The box manager bbp is notified of the implicit release and can take garbage collection actions.</para>
      <para>The box may be inspected at several times during a scenario run. The first time is when the MAL program is type-checked for the box operations. Typechecking a take() function is tricky. If the argument is a string literal, the box can be queried directly for the objects' type. If found, its type is matched against the lhs variable. This strategy fails in the situation when at runtime the object is subsequently replaced by another typed-instance in the box. We assume this not to happen and the exceptions it raises a valuable advice to reconsider the programming style.</para>
      <para>The type indicator for the destination variable should be provided to proceed with proper type checking. It can resolve overloaded function selection.</para>
      <para>Inspection of the Box can be encoded using an iterator at the MAL layer and relying on the functionality of the box. However, to improve introspection, we assume that all box implementations provide a few rudimentary functions, called objects(arglist) and dir(arglist). The function objects() produces a BAT with the object names, possibly limited to those identified by the arglist.</para>

      <section>
        <title>Future</title>
        <para>The world of boxes has not been explored deeply yet. It is envisioned that it could play a role to import/export different objects, e.g. introduce xml.take() which converts an XML document to a BAT, jpeg.take() similer for an image.</para>
        <para>Nesting boxes (like Russian dolls) is possible. It provides a simple containment scheme between boxes, but in general will interfere with the semantics of each box.</para>
        <para>Each box has [should] have an access control list, which names the users having permission to read/write its content. The first one to create the box becomes the owner. He may grant/revoke access to the box to users on a selective basis.</para>

        <subsection>
          <title>Session box</title>
          <para>Aside from box associated with the modules, a session box is created dynamically on behalf of each client. Such boxes are considered private and require access by the user name (and password). At the end of a session they are closed, which means that they are saved in persistent store until the next session starts. For example:</para>
          <example xml:space="preserve">function m():void;
	box.open("client_name");
	box.deposit("client_name","pi",3.417:flt);
	f:flt := box.take("client_name","pi");
	io.print(t);
	box.close("client_name");
end function;</example>
          <para>In the namespace it is placed subordinate to any space introduced by the system administrator. It will contain global client data, e.g. user, language, database, port, and any other session parameter. The boxes are all collected in the context of the database directory, i.e. the directory &lt;dbfarm&gt;/box</para>
        </subsection>

        <subsection>
          <title>Garbage collection</title>
          <para>The key objects managed by MonetDB are the persistent BATs, which call for an efficient scheme to make them accessible for manipulation in the MAL procedures taking into account a possibly hostile parallel access.</para>
          <para>Most kernel routines produce BATs as a result, which will be referenced from the runtime stack. They should be garbage collected as soon as deemed possible to free-up space. By default, temporary results are garbage collected before returning from a MAL function.</para>
        </subsection>

        <subsection>
          <title>Polymorphic globals</title>
          <para>The top level interaction keeps a 'box' with global variables, i.e. each MAL statement is interpreted in an already initialized stack frame. This causes the following problems: 1) how to get rid of global variables and 2) how to deal with variables that can take 'any' type. It is illustrated as follows:</para>
          <example xml:space="preserve">f:= mil.take("GT");
io.print(f);</example>
          <para>When executed in the context of a function, the answer will be simple [ 1 ]. The variable type need not be defined, because the print operation can handle any type using the concrete type associated with f on the stack.</para>
          <para>However, when executed interactively, statement by statement, the answer printed will be [ 0 ]. The reason is that both statements are converted into a function and executed independently. Between function calls the variables are reset, i.e. temporary variables are removed and others are re-initialized. [check]</para>
          <example xml:space="preserve"></example>
        </subsection>
      </section>
    </chapter>
  </node>
  <node>
    <nodename>Property management</nodename>
    <nodenext>MAL Modules</nodenext>
    <nodeprev>Boxed variables</nodeprev>
    <nodeup>MonetDB Assembler Language</nodeup>
    <chapter>
      <title>Property Management</title>
      <para>Properties come in several classes, those linked with the symbol table and those linked with the runtime environment. The former are determined once upon parsing or catalogue lookup. The runtime properties have two major subclasses, i.e. reflective and prescriptive. The reflective properties merely provide a fast cache to information aggregated from the target. Prescriptive properties communicate desirable states, leaving it to other system components to reach this state at the cheapest cost possible. This multifacetted world makes it difficult to come up with a concise model for dealing with properties. The approach taken here is an experimental step into this direction.</para>
      <para>This <code>mal_properties</code> module provides a generic scheme to administer property sets and a concise API to manage them. Its design is geared towards support of MAL optimizers, which typically make multiple passes over a program to derive an alternative, better version. Such code-transformations are aided by keeping track of derived information, e.g. the expected size of a temporary result or the alignment property between BATs.</para>
      <para>Properties capture part of the state of the system in the form of an simple term expression <code>(name, operator, constant)</code>. The property model assumes a namespace built around Identifiers. The operator satisfy the syntax rules for MAL operators. Conditional operators are quite common, e.g. the triple (count, &lt;, 1000) can be used to denote a small table.</para>

      <section>
        <title>Property Associations</title>
        <para>The property bearing objects in the MAL setting are variables (symbol table entries) and MAL function blocks. The direct relationship between instructions and a target variable, make it possible to keep the instruction properties in the corresponding target variable.</para>
        <para><emph>Variables properties.</emph> The variables can be extended at any time with a property set. Properties have a scope identical to the scope of the corresponding variable. Ommision of the operator and value turns it into a boolean valued property, whose default value is <code>true</code>.</para>
        <verbatim xml:space="preserve"><![CDATA[
	b{count=1000,sorted}:= mymodule.action("table");
	name{aligngroup=312} := bbp.take("person_name");
	age{aligngroup=312} := bbp.take("person_age");
]]></verbatim>
        <para>The example illustrates a mechanism to maintain alignment information. Such a property is helpful for optimizers to pick an efficient algorithm.</para>
        <para><emph>MAL function signatures.</emph> A function signature contains a description of the objects it is willing to accept and an indication of the expected result. The arguments can be tagged with properties that 'should be obeyed, or implied' by the actual arguments. It extends the typing scheme used during compilation/optimization. Likewise, the return values can be tagged with properties that 'at least' exist upon function return.</para>
        <verbatim xml:space="preserve"><![CDATA[
    function test(b:bat[:void,:int]{count<1000}):bat[:void,:int]{sorted}
       #code block
    end test
]]></verbatim>
        <para>These properties are informative to optimizers. They can be enforced at runtime using the operation <code>optimizer.enforceRules()</code> which injects calls into the program to check them. An assertion error is raised if the property does not hold. The code snippet</para>
        <verbatim xml:space="preserve"><![CDATA[
	z:= user.test(b);
]]></verbatim>
        <para>is translated into the following code block;</para>
        <verbatim xml:space="preserve"><![CDATA[
	mal.assert(b,"count","<",1000);
	z:= user.test(b);
	mal.assert(z,"sorted");
]]></verbatim>
        <para><emph>MAL instructions.</emph> Properties associated with an instruction are aimed at the a tactical optimizer and execution engine. It says something about the context in which the instruction should take place, e.g. a timeout property.</para>
        <para>The second layer involves tagging structures known to front-ends, such as SQL and XML. Given that they produce a MAL block, setting properties becomes an explicit action. This can be handled as a first step in the optimization phase, which 'executes' all property setting actions first. However, 'preferred' properties may have to be dealt with later. For example, an operation should produce a sorted BAT. This calls for a runtime test and possible coercion. Alternatively, the desired property leads to a different selection of an operator implementation.</para>
        <para><emph>How to propagate properties?</emph> Property inspection and manipulation is strongly linked with the operators of interest. Optimizers continuously inspect and update the properties, while kernel operators should not be bothered with their existence.</para>
        <example xml:space="preserve"></example>
      </section>
    </chapter>
  </node>
  <node>
    <nodename>MAL Modules</nodename>
    <nodenext>MAL interpreter</nodenext>
    <nodeprev>Property management</nodeprev>
    <nodeup>Top</nodeup>
    <section>
      <title>Module import</title>
      <para>The import statement simple switches the parser to a new input file, which takes precedence. The context for which the file should be interpreted is determined by the module name supplied. Typically this involves a module, whose definitions are stored at a known location.</para>
      <example xml:space="preserve"></example>
    </section>
  </node>
  <node>
    <nodename>MAL interpreter</nodename>
    <nodenext>Optimizer landscape</nodenext>
    <nodeprev>MAL Modules</nodeprev>
    <nodeup>Top</nodeup>
    <chapter>
      <title>The MAL Interpreter</title>
      <para>The MAL interpreter always works in the context of a single user session, which provides for storage access to global variables and modules.</para>
      <para>Runtime storage for variables are allocated on the stack of the interpreter thread. The physical stack is often limited in size, which calls for safeguarding their value and garbage collection before returning. A malicious procedure or implementation will lead to memory leakage.</para>
      <para>A system command (linked C-routine) may be interested in extending the stack. This is precluded, because it could interfere with the recursive calling sequence of procedures. To accommodate the (rare) case, the routine should issue an exception to be handled by the interpreter before retrying. All other errors are turned into an exception, followed by continuing at the exception handling block of the MAL procedure.</para>

      <section>
        <title>MAL API</title>
        <para>The linkage between MAL interpreter and compiled C-routines is kept as simple as possible. Basically we distinguish four kinds of calling conventions: CMDcall, FCNcall, THRDcall, and  PATcall. The FCNcall indicates calling a MAL procedure, which leads to a recursive call to the interpreter.</para>
        <para>CMDcall initiates calling a linked function, passing pointers to the parameters and result variable, i.e.  f(ptr a0,..., ptr aN) The function returns a MAL-SUCCEED upon success and a pointer to an exception string upon failure. Failure leads to raise-ing an exception in the interpreter loop, by either looking up the relevant exception message in the module administration or construction of a standard string. Upon successfull return, we update the ValRecord with length indications.</para>
        <para>The PATcall initiates a call which contains the MAL context. i.e. f(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci) The blk provides access to the code definitions. It is primarilly used by routines intended to manipulate the code base itself, such as the optimizers. The Mal stack frame pointer provides access to the values maintained. The arguments passed are offsets into the stack frame rather than pointers to the actual value.</para>
        <para>BAT parameters require some care. Ideally, a BAT should not be kept around long. This would mean that each time we access a BAT it has to be pinned in memory and upon leaving the function, it is unpinned. This degrades performance significantly. After the parameters are fixed, we can safely free the destination variable and re-initialize it to nil;</para>
      </section>

      <section>
        <title>Exception handling</title>
        <para>Calling a built-in or user-defined routine may lead to an error, a cached status message to be dealt with in MAL, or as an error status in Mapi.</para>
        <para>Exceptions raised within a linked-in function requires some care. First, the called procedure does not know anything about the MAL interpreter context. Thus, we need to return all relevant information upon leaving the linked library routine.</para>
        <para>Second, exceptional cases can be handled deeply in the recursion, where they may also be handled, i.e. by issueing an GDKerror message. The upper layers merely receive a negative integer value to indicate occurrence of an error somewhere in the calling sequence. We have to also look into GDKerrbuf to see if there was an error raised deeply inside the system.</para>
        <para>The policy is to require all C-functions to return a string-pointer. Upon successfull call, this string function is NULL. Otherwise it contains an encoding of the exceptional state encountered. This message starts with the exception identifer, followed by contextual details.</para>
      </section>

      <section>
        <title>BAT reference counting</title>
        <para>A key issue is to deal with temporary BATs in an efficient way. References to bats in the buffer pool may cause dangling references at the language level. This appears as soons as your share a reference and delete the BAT from one angle. If not carefull, the dangling pointer may subsequently be associated with another BAT</para>
        <para>Dangling references can be dealt with in several ways. First, we could increase the reference count each time a BAT becomes shared and rely on the garbage collector to properly decrement the count before abanding a execution frame. Second, we could try to avoid dangling pointers by permitting just one reference per BAT. This doesn't work, because we may keep BAT-views around, which depend on the existence of the underlying BAT.</para>
      </section>

      <section>
        <title>Garbage collection</title>
        <para>Garbage collection is relatively straightforward, because most values are retained on the stackframe of an interpreter call. However, two storage types and possibly user-defined type garbage collector definitions require attention. [TAKE CARE OF fixable atoms !!]</para>
        <para>All string values are private to the VALrecord, which means they have to be freed explicitly before a MAL function returns. The first step is to always safe the destination variable before a function call is made.</para>
        <example xml:space="preserve"></example>
        <para>All operations are responsible to properly set the reference count of the BATs being produced or destroyed. The exception are the target BAT variables. Their reference is saved until the operation is finished. They the reference can be reduced (due to overwrite of the target variable) or retained(the operation failed).</para>
        <para>Actually, the libraries should not leave the physical reference count being set. This is only allowed during a GDK operation. All references should be logical.</para>
      </section>

      <section>
        <title>Performance section</title>
        <para>The interpreter has a built-in performance monitor hook, which is activated using the compile option MALprofiler. Activation can lead to a significant performance degradation, because for all traced functions we have to keep track of essential system counter information.</para>
      </section>

      <section>
        <title>Bootstrap and module load</title>
        <para>The server is bootstrapped by processing a MAL script with module definitions. For each module encountered, the object library lib_&lt;modulename&gt;.so is searched for in <dots/>/lib/MonetDB. The corresponding signature are defined in <dots/>/lib/&lt;modulename&gt;.mal.</para>
        <para>The default bootstrap script is called <dots/>/lib/MonetDB/mal_init.mal and it is designated in the configuration file as the mal_init property. The rationale for this set-up is that database administrators can extend/overload the bootstrap procedure without affecting the distributed software package. It merely requires a different direction for the mal_init property.</para>
        <para>The scheme also isolates the functionality embedded in modules from inadvertise use on non-compliant databases. [access control issue, how to limit what a user can do on a database?]</para>
        <para>Unlike previous versions of MonetDB, modules can not be unloaded. Dynamic libraries are always global and, therefore, it is best to load them as part of the server initialization phase.</para>
        <para>The MAL program should be compiled with -rdynamic and -ldl. This enables loading the routines and finding out the address of a particular routine</para>
        <example xml:space="preserve"></example>
        <para>The mapping from MAL module.function() identifier to an address is resolved in the function getAddress. Since all modules libraries are loaded completely with GLOBAL visibility, it suffices to provide the internal function name. In case an attempt to link to an address fails, a final attempt is made to locate the *.o file in the current directory.</para>
        <example xml:space="preserve"></example>
      </section>

      <section>
        <title>Module loading</title>
        <para>The default location to search for the module is in monet_mod_path unless an absolute path is given.</para>
        <para>Loading further relies on the Linux policy to search for the module location in the following order: 1) the colon-separated list of directories in the user's LD_LIBRARY, 2) the libraries specified in /etc/ld.so.cache, and 3) /usr/lib followed by /lib If the module contains a routine _init, then that code is executed before the loader returns. Likewise the routine _fini is called just before the module is unloaded.</para>
        <para>A module loading conflict emerges if a function is redefined. A duplicate load is simply ignored by keeping track of modules already loaded.</para>
        <example xml:space="preserve"></example>
        <para>To speedup restart and to simplify debugging, the Monet server can be statically linked with some (or all) of the modules. A complicating factor is then to avoid users to initiate another load of the module file, because it would lead to a dlopen error.</para>
        <para>The partial way out of this dilema is to administer somewhere the statically bound modules, or to enforce that each module comes with a known routine for which we can search. In the current version we use the former approach.</para>
        <example xml:space="preserve"></example>
      </section>

      <section>
        <title>MAL runtime stack</title>
        <para>The runtime context of a MAL procedure is allocated on the runtime stack of the corresponding interpreter. Access to the elements in the stack are through index offsets, determined during MAL procedure parsing. This method has been proven highy efficient compared to using individual GDKmalloci calls.</para>
        <para>Unlike Monet Version 4, the scope administration for MAL procedures is decoupled from their actual runtime behavior. This means we are more relaxed on space allocation, because the size is determined by the number of MAL procedure definitions instead of the runtime calling behavior. (See mal_interpreter for details on value stack management)</para>
        <para>The variable names and types are kept in the stack to ease debugging. The underlying string value need not be garbage collected.</para>
        <para>The interpreter should be protected against physical stack overflow. The solution chosen is to maintain an incremental depth size. Once it exceeds a threshold, we call upon the kernel to ensure we are still within safe bounds.</para>
        <example xml:space="preserve"></example>
      </section>
    </chapter>
  </node>
  <node>
    <nodename>Optimizer landscape</nodename>
    <nodenext>Optimizers</nodenext>
    <nodeprev>MAL interpreter</nodeprev>
    <nodeup>Top</nodeup>
    <chapter>
      <title>The Optimizer Landscape</title>
      <para>One of the prime reasons to design the MAL intermediate language is to have a high-level description for database queries, which is easy to generate by a front-end compiler and easy to decode, optimize and interpret.</para>
      <para>An optimizer needs several mechanisms to be effective. It should be able to perform a symbolic evaluation of a code fragment and collect the result in properties for further decision making. The prototypical case is where an optimizer estimates the result size of a selection.</para>
      <para>Another major issue is to be able to generate and explore a space of alternative evaluation plans. This exploration may take place up front, but can also be ran at runtime for query fragments.</para>
      <menu>
        <menuentry>
          <menunode>Optimizers</menunode>
          <menutitle>Optimizers</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Optimizer toolkit</menunode>
          <menutitle>Optimizer toolkit</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Optimizer Dependencies</menunode>
          <menutitle>Optimizer Dependencies</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Optimizer Building Blocks</menunode>
          <menutitle>Optimizer Building Blocks</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Query Optimizer Framework</menunode>
          <menutitle>Query Optimizer Framework</menutitle>
          <menucomment></menucomment>
        </menuentry>
      </menu>
    </chapter>
  </node>
  <node>
    <nodename>Optimizers</nodename>
    <nodenext>Optimizer Dependencies</nodenext>
    <nodeprev>Optimizer landscape</nodeprev>
    <nodeup>Optimizer landscape</nodeup>
    <section>
      <title>Optimizers</title>
      <para>A query optimizer is often a large and complex piece of code, which enumerates alternative evaluation plans from which 'the best' plan is selected for evaluation. Limited progress has been made sofar to decompose the optimizer into (orthogonal) components, because it is a common believe in research that a holistic view on the problem is a prerequisite to find the best plan. Conversely, commercial optimizers use a cost-model driven approach, which explores part of the space using a limited (up to 300) rewriting rules.</para>
      <para>Our hypothesis is that query optimization should be realized with a collection of query optimizer transformers (QOT), each dedicated to a specific task. Furthermore, they are assembled in scenarios to support specific application domains or achieve a desired behavior. Such scenarios are selected on a session basis, a query basis, or dynamically at runtime; they are part of the query plan.</para>
      <para>The query transformer list below is under consideration for development. For each we consider its goal, approach, and expected impact. Moreover, the minimal prerequisites identify the essential optimizers that should have done their work already. For example, it doesn;t make sense to perform a static evaluation unless you have already propagated the constants using Alias Removal.</para>
      <para><emph>Scalar expressions (SXoptimizer)</emph> Goal: to remove scalar expressions which need be evaluated once during the query lifetime. Rationale: static expressions appear when variables used denote literal constants (e.g. 1+1), when catalog information can be merged with the plan (e.g. max(B.salary)), when session variables are used which are initialized once (e.g. user()). Early evaluation aids subsequent optimization. Approach: inspect all instructions to locate static expressions. Whether they should be removed depends on the expected re-use, which in most cases call for an explicit request upon query registration to do so. The result of a static evaluation provides a ground for AR. Impact: relevant for stored queries (MAL functions) Prereq: AR, CX</para>
      <para><emph>Relational Expression Optimizer (RXoptimizer)</emph> Goal: to evaluate a relational plan using properties of BATs, such as being empty or forming an aligned group. These optimizations assume that the code generator can detect properties while compiling e.g. an SQL query. Impact: high Prereq:</para>
      <para><emph>Alias Removal (ARoptimizer)</emph> Goal: to reduce the number of  variables referenceing the same value, thereby reducing the analysis complexity. Rationale: query transformations often result in replacing the right-hand side expression with a result variable. This pollutes the code block with simple assignments e.g. V:=T. Within the descendant flow the occurrence of V could be replaced by T, provided V is never assigned a new value. Approach: literal constants within a MAL block are already recognized and replaced by a single variable. Impact: medium</para>
      <para><emph>Common Expression Optimizer (CXoptimizer)</emph> Goal: to reduce the amount of work by avoiding calculation of the same operation twice. Rationale: to simplify code generation for front-ends, they do not have to remember the subexpressions already evaluated. It is much easier to detect at the MAL level. Approach: simply walk through the instruction sequence and locate identical patterns.  (Enhance is with semantic equivalent instructions) Impact: High Prereq: AR</para>
      <para><emph>Access Mode Optimizer (AMoptimizer)</emph> Goal: the default access mode for BATs is readonly. When updates are needed, it is switched to WriteMode, which needs to be done only once. Approach: remove duplicate calls Impact: low</para>
      <para><emph>Dead Code Removal (DCoptimizer)</emph> Goal: to remove all instructions whose result is not used Rationale: due to sloppy coding or alternative execution paths dead code may appear. Als XML Pathfinder is expected to produce a large number of simple assignments. Approach: Every instruction should produce a value used somewhere else. Impact: low</para>
      <para><emph>Heuristic Rule Rewrites (HRoptimizer)</emph> Goal: to reduce the volume as quick as possible. Rationale: most queries are focussed on a small part of the database. To avoid carrying too many intermediates, the selection should be performed as early as possible in the process. This assumes that selectivity factors are known upfront, which in turn depends on histogram of the value distribution. Approach: locate selections and push them back/forth through the flow graph. Impact: high</para>
      <para><emph>Join Path Optimizer (JPoptimizer)</emph> Goal: to reduce the volume produced by a join sequence Rationale: join paths are potentially expensive operations. Ideally the join path is evaluated starting at the smallest component, so as to reduce the size of the intermediate results. Approach: to successfully reduce the volume we need to estimate their processing cost. This calls for statistics over the value distribution, in particular, correlation histograms. If statistics are not available upfront, we have to restore to an incremental algorithm, which decides on the steps using the size of the relations. Impact: high</para>
      <para><emph>Operator Sort (OSoptimizer)</emph> Goal: to sort the dataflow graph in such a way as to reduce the cost, or to assure locality of access for operands. Rationale: A simple optimizer is to order the instructions for execution by permutation of the query components Approach: Impact:</para>
      <para><emph>Singleton Set (SSoptimizer)</emph> Goal: to replace sets that are known to produce precisely one tuple. Rationale: Singleton sets can be represented by value pairs in the MAL program, which reduces to a scalar expression. Approach: Identify a set variable for replacement. Impact:</para>
      <para><emph>Result Cacher (RCoptimizer)</emph> Goal: to reduce the processing cost by keeping track of expensive to compute intermediate results Rationale: Approach: result caching becomes active after an instruction has been evaluated. The result can be cached as long as its underlying operands remain unchanged. Result caching can be made transparent to the user, but affects the other QOTs Impact: high</para>
      <para><emph>Vector Execution (VEoptimizer)</emph> Goal: to rewrite a query to use a cache-optimal vector implementation Rationale: processing in the cache is by far the best you can get. However, the operands may far exceed the cache size and should be broken into pieces followed by a staged execution of the fragments involved. Approach: replace the query plan with fragment streamers Impact:</para>
      <para><emph>Staged Execution (SEoptimizer)</emph> Goal: to split a query plan into a number of steps, such that the first response set is delivered as quickly as possible. The remainder is only produced upon request. Rationale: interactive queries call for quick response and an indication of the processing time involved to run it too completion. Approach: staged execution can be realized using a fragmentation scheme over the database, e.g. each table is replaced by a union of fragments. This fragmentation could be determined upfront by the user or is derived from the query and database statistics. impact: high</para>
      <para><emph>Code Parallizer (CPoptimizer)</emph> Goal: to exploit parallel IO and cpu processing in both SMP and MPP settings. Rationale: throwing more resources to solve a complex query helps, provided it is easy to determine that parallel processing recovers the administrative overhead Approach: every flow path segment can be handled by an independent process thread. Impact: high</para>
      <para><emph>Query Evaluation Maps (QEMoptimizer)</emph> Goal: to avoid touching any tuple that is not relevant for answering a query. Rationale: the majority of work in solving a query is to disgard tuples of no interest and to find correlated tuples through join conditions. Ideally, the database learns these properties over time and re-organizes (or builts a map) to replace disgarding by map lookup. Approach: piggyback selection and joins as database fragmentation instructions Impact: high</para>
      <para><emph>MAL Compiler (MCcompiler) (tactics)</emph> Goal: to avoid interpretation of functional expressions Rationale: interpretation of arithmetic expressions with an interpreter is always expensive. Replacing a complex arithmetic expressin with a simple dynamically compiled C-functions often pays off. Especially for cached (MAL) queries Approach: Impact: high</para>
      <para><emph>Dynamic Query Scheduler (DQscheduler) (tactics)</emph> Goal: to organize the work in a way so as to optimize resource usage Rationale: straight interpretation of a query plan may not lead to the best use of the underlying resources. For example, the content of the runtime cache may provide an opportunity to safe time by accessing a cached source Approach: query scheduling is the last step before a relation algebra interpreter takes over control. The scheduling step involves a re-ordering of the instructions within the boundaries imposed by the flow graph. impact: medium</para>
      <para><emph>Aggregate Groups (AGoptimizer)</emph> Goal: to reduce the cost of computing aggregate expressions over times Rationale: many of our applications call for calculation of aggregates over dynamically defined groupings. They call for lengtly scans and it pays to piggyback all aggregate calculates, leaving their result in the cache for later consumption (eg the optimizers) Approach: Impact: High</para>
      <para><emph>Data Cube optimizer (DCoptimizer)</emph> Goal: to recognize data cube operations Rationale: Approach: Impact:</para>
      <para><emph>Demand Driven Interpreter (DDoptimizer) (tactics)</emph> Goal: to use the best interpreter and libraries geared at the task at hand Rationale: Interpretation of a query plan can be based on different computational models. A demand driven interpretation starts at the intended output and 'walks' backward through the flow graph to collect the pieces, possibly in a pipelined fashion. (Vulcano model) Approach: merely calls for a different implementation of the core operators Impact: high</para>
      <para><emph>Iterator Strength Reduction (SRoptimizer)</emph> Goal: to reduce the cost of iterator execution by moving instructions out of the loop. Rationale: although iteration at the MAL level should be avoided due to the inherent low performance compared to built-in operators, it is not forbidden. In that case we should confine the iterator block to the minimal work needed. Approach: inspect the flowgraph for each iterator and move instructions around. Impact: low</para>
      <para><emph>Accumulator Evaliations (AEoptimizer)</emph> Goal: to replace operators with cheaper ones. Rationale: based on the actual state of the computation and the richness of the supporting libraries there may exists alternative routes to solve a query. Approach: Operator rewriting depends on properties. No general technique. The first implementation looks at calculator expressions such as they appear frequently in the RAM compiler. Impact: high Prerequisite: should be called after CXoptimizer to avoid clashes.</para>
      <para><emph>Code Inliner (CIoptimizer)</emph> Goal: to reduce the calling depth of the interpreter and to obtain a better starting point for code squeezing Rationale: substitution of code blocks (or macro expansion) leads to longer linear code sequences. This provides opportunities for squeezing. Moreover, at runtime building and managing a stackframe is rather expensive. This should be avoided for functions called repeatedly. Approach: called explicity to inline a module (or symbol) Impact: medium</para>
      <para><emph>Code Outliner (COoptimizer)</emph> Goal: to reduce the program size by replacing a group with a single instruction Rationale: inverse macro expansion leads to shorter linear code sequences. This provides opportunities for less interpreter overhead, and to optimize complex, but repetative instruction sequences with a single hardwired call Approach: called explicitly to outline a module (or symbol) Impact: medium</para>
      <para><emph>Garbage Collector (GCoptimizer)</emph> Goal: to release resources as quickly as possible Rationale: BATs referenced from a MAL program keep resources locked. Approach: In cooperation with a resource scheduler we should identify those that can be released quickly. It requires a forced gargabe collection call at the end of the BAT's lifespan. Impact: large</para>
      <para><emph>Foreign Key replacements (FKoptimizer)</emph> Goal: to improve multi-attribute joins over foreign key constraints Rationale: the code produced by the SQL frontend involves foreign key constraints, which provides many opportunities for speedy code. Impact: large</para>
    </section>
  </node>
  <node>
    <nodename>Optimizer Dependencies</nodename>
    <nodenext>Optimizer Building Blocks</nodenext>
    <nodeprev>Optimizers</nodeprev>
    <nodeup>Optimizer landscape</nodeup>
    <section>
      <title>Optimizer Dependencies</title>
      <para>The optimizers are highly targeted to a particular problem. Aside from the resources available to invest in plan optimization, optimizers are partly dependent and may interfere.</para>
      <para>To aid selection of the components of interest, we have grouped them in a preferred order of deployment.</para>
      <multitable>
        <columnfraction>12</columnfraction>
        <columnfraction>80</columnfraction>
        <tbody>
          <row>
            <entry>Group A:</entry>
            <entry>Code Inliner (CIoptimizer)</entry>
          </row>
          <row>
            <entry></entry>
            <entry>Static expression evaluator. (SXoptimizer)</entry>
          </row>
          <row>
            <entry></entry>
            <entry>Relational Expression Evaluator. (RXoptimizer)</entry>
          </row>
          <row>
            <entry></entry>
            <entry>Strength Reduction (SRoptimizer)</entry>
          </row>
          <row>
            <entry>Group B:</entry>
            <entry>Common Expression Optimizer (CXoptimizer)</entry>
          </row>
          <row>
            <entry></entry>
            <entry>Query Evaluation Maps (QMoptimizer)</entry>
          </row>
          <row>
            <entry>Group C:</entry>
            <entry>Join Path Optimizer (JPoptimizer)</entry>
          </row>
          <row>
            <entry></entry>
            <entry>Operator Cost Reduction (OCoptimizer)</entry>
          </row>
          <row>
            <entry></entry>
            <entry>Operator Sort (OSoptimizer)</entry>
          </row>
          <row>
            <entry></entry>
            <entry>Foreign Key handling (FKoptimizer)</entry>
          </row>
          <row>
            <entry></entry>
            <entry>Aggregate Groups (AGoptimizer)</entry>
          </row>
          <row>
            <entry></entry>
            <entry>Data Cube optimizer (DCoptimizer)</entry>
          </row>
          <row>
            <entry></entry>
            <entry>Heuristic Rule Rewrite (HRoptimizer)</entry>
          </row>
          <row>
            <entry>group D:</entry>
            <entry>Code Parallizer (CPoptimizer)</entry>
          </row>
          <row>
            <entry></entry>
            <entry>Accumulator Evaliations (AEoptimizer)</entry>
          </row>
          <row>
            <entry></entry>
            <entry>Result Cacher (RCoptimizer)</entry>
          </row>
          <row>
            <entry></entry>
            <entry>Replication Manager (RManager)</entry>
          </row>
          <row>
            <entry>group E:</entry>
            <entry>MAL Compiler (MCcompiler)</entry>
          </row>
          <row>
            <entry></entry>
            <entry>Dynamic Query Scheduler (DQscheduler)</entry>
          </row>
          <row>
            <entry></entry>
            <entry>Vector Execution (VEoptimizer)</entry>
          </row>
          <row>
            <entry></entry>
            <entry>Staged Execution (SEoptimizer)</entry>
          </row>
          <row>
            <entry>group F:</entry>
            <entry>Alias Removal (ARoptimizer)</entry>
          </row>
          <row>
            <entry></entry>
            <entry>Access Mode Optimizer (AMoptimizer)</entry>
          </row>
          <row>
            <entry></entry>
            <entry>Dead Code Removal (DCoptimizer)</entry>
          </row>
          <row>
            <entry></entry>
            <entry>Garbage Collector (GCoptimizer)</entry>
          </row>
        </tbody>
      </multitable>
      <para>Alias removal can be applied after each other optimization step.</para>
    </section>
  </node>
  <node>
    <nodename>Optimizer Building Blocks</nodename>
    <nodenext>Query Optimizer Framework</nodenext>
    <nodeprev>Optimizer Dependencies</nodeprev>
    <nodeup>Optimizer landscape</nodeup>
    <section>
      <title>Optimizer building blocks</title>
      <para>Some instructions are independent of the execution context. In particular, expressions over side-effect free functions with constant parameters could be evaluated before the program block is considered further.</para>
      <para>A major task for an optimizer is to select instruction (sequences) which can and should be replaced with cheaper ones. The cost model underlying this decision depends on the processing stage and the overall objective. For example, based on a symbolic analysis their may exist better implementations within the interpreter to perform the job (e.g. hashjoin vs mergejoin). Alternative, expensive intermediates may be cached for later use.</para>
      <para>Plan enumeration is often implemented as a Memo structure, which designates alternative sub-plans based on a cost metric. Perhaps we can combine these memo structures into a large table for all possible combinations encountered for a user.</para>
      <para>The MAL language does not imply a specific optimizer to be used. Its programs are merely a sequence of specifications, which is interpreted by an engine specific to a given task. Activation of the engine is controlled by a scenario, which currently includes two hooks for optimization; a strategic optimizer and a tactical optimizer. Both engines take a MAL program and produce a (new/modified) MAL program for execution by the lower layers.</para>
      <para>MAL programs end-up in the symbol table linked to a user session. An optimizer has the freedom to change the code, provided it is known that the plan derived is invariant to changes in the environment. All others lead to alternative plans, which should be collected as a trail of MAL program blocks. These trails can be inspected for a posteriori analysis, at least in terms of some statistics on the properties of the MAL program structures automatically. Alternatively, the trail may be pruned and re-optimized when appropriate from changes in the environment.</para>
      <para>Breaking up the optimizer into different components and grouping them together in arbitrary sequences calls for careful programming.</para>
      <para>The rule applied for all optimizers is to not-return before checking the state of the MAL program, and to assure the dataflow and variable scopes are properly set. It costs some performance, but the difficulties that arise from optimizer interference are very hard to debug. One of the easiest pitfalls is to derive an optimized version of a MAL function while it is already referenced by or when polymorphic typechecking is required afterwards. For example,</para>
      <example xml:space="preserve"></example>
    </section>
  </node>
  <node>
    <nodename>Query Optimizer Framework</nodename>
    <nodenext>Optimizer toolkit</nodenext>
    <nodeprev>Optimizer Building Blocks</nodeprev>
    <nodeup>Optimizer landscape</nodeup>
    <section>
      <title>Optimizer framework</title>
      <para>The large number of query transformers calls for a flexible scheme for the deploy them. The approach taken is to make all optimizers visible at the language level as a MAL pattern. Then (semantic) optimizer merely inspects a MAL block for their occurrences and activitates it.</para>
      <para>Furthermore, the default optimizer scheme can be associated with a client record. The strategic optimizer merely prepends each query with this scheme before it searches/activates the optimizer routines.</para>
      <para>The optimizer routines have access to the client context, the MAL block, and the program counter where optimizer call was found. Each query transformer should remove itself from the MAL block;</para>
      <para>The optimizer terminates when no optimizer transformer call remains. [Some of the optimizers above should be moved to the tactic level]</para>
      <para>Note, all optimizer instructions are executed only once. This means that the instruction can be removed from further consideration. However, in the case that a designated function is selected for optimization (e.g. CXoptimizer(user,qry)) the pc is assumed 0. The first instruction always denotes the signature and can not be removed.</para>
      <para>To safeguard against incomplete optimizer implementations it is advisable to perform an optimizerCheck at the end. It takes as arguments the number of optimizer actions taken and the total cpu time spent. The body performs a full flow and type check and re-initializes the lifespan administration. In debugging mode also a copy of the new block is retained for inspection.</para>
      <example xml:space="preserve"></example>
      <para>For each function it should be relatively easy to determine its safety property. This calls for accessing the function MAL block and to inspect the arguments of the signature.</para>
      <example xml:space="preserve"></example>
      <para>Any instruction may block identification of a common subexpression. It suffices to stumble upon an unsafe function whose parameter lists has a non-empty intersection with the targeted instruction. To illustrate, consider the sequence</para>
      <example xml:space="preserve">L1 := f(A,B,C);
...
G1 := g(D,E,F);
...
l2:= f(A,B,C);
...
L2:= h()</example>
      <para>The instruction G1:=g(D,E,F) is blocking if G1 is an alias for {A,B,C}. Alternatively, function g() may be unsafe and {D,E,F} has a non-empty intersection with {A,B,C}. An alias can only be used later on for readonly (and not be used for a function with sideeffects)</para>
      <example xml:space="preserve"></example>
      <subsection>
        <title>Flow analysis</title>
        <para>In many optimization rules, the data flow dependency between statements is of crucial importance. The MAL language encodes a multi-source, multi-sink dataflow network. Optimizers typically extract part of the workflow and use the language properties to enumerate semantic equivalent solutions, which under a given cost model turns out to result in better performance.</para>
        <para>The flow graph plays a crucial role in many optimization steps. It is unclear as yet what primitives and what storage structure is most adequate. For the time being we introduce the operations needed and evaluate them directly against the program</para>
        <para>The routine flowStep(pca,pcb) checks whether the output of instruction pca flows directly into pcb, without its parameters being changed inbetween. This calls for checking assignments as well as operators that use any of the targets of pca, but which also change them (e.g. insert/delete bat) TODO, now more restrictive then needed.</para>
        <example xml:space="preserve"></example>
        <para>For each variable we should determine its scope of stability. End-points in the flow graph are illustrative as dead-code, that do not produce persistent data. It can be removed when you know there are no side-effect.</para>
        <para>Side-effect free evaluation is a property that should be known upfront. For the time being, we assume it for all operations known to the system. The property `unsafe` is reserved to identify cases where this does not hold. Typically, a bun-insert operation is unsafe, as it changes one of the parameters.</para>
        <example xml:space="preserve"></example>
      </subsection>

      <subsection>
        <title>Basic Algebraic Blocks</title>
        <para>Many code snippets produced by e.g. the SQL compiler is just a linear representation of an algebra tree/graph. Its detection makes a number of optimization decisions more easy, because the operations are known to be side-effect free within the tree/graph. This can be used to re-order the plan without concern on impact of the outcome. It suffice to respect the flow graph. [unclear as what we need]</para>
      </subsection>
    </section>
  </node>
  <node>
    <nodename>Optimizer toolkit</nodename>
    <nodenext>Alias Removal</nodenext>
    <nodeprev>Query Optimizer Framework</nodeprev>
    <nodeup>Optimizer landscape</nodeup>
    <chapter>
      <title>The Optimizer Toolkit</title>
      <para>In this section we introduce the collection of MAL optimizers included in the code base. The tool kit is incrementally built, triggered by experimentation and curiousity. Several optimizers require further development to cope with the many features making up the MonetDB system. Such limitations on the implementation are indicated where appropriate.</para>
      <menu>
        <menuentry>
          <menunode>Alias Removal</menunode>
          <menutitle>Alias Removal</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Dead Code Removal</menunode>
          <menutitle>Dead Code Removal</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Accumulator Evaluations</menunode>
          <menutitle>Accumulator Evaluations</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Heuristic Rewrite Rules</menunode>
          <menutitle>Heuristic Rewrite Rules</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Common Sub-Expression Removal</menunode>
          <menutitle>Common Sub-Expression Removal</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Empty Set Reduction</menunode>
          <menutitle>Empty Set Reduction</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Singleton Set Replacement</menunode>
          <menutitle>Singleton Set Replacement</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Peephole Optimization</menunode>
          <menutitle>Peephole Optimization</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Multiplex Compiler</menunode>
          <menutitle>Multiplex Compiler</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Garbage Collector</menunode>
          <menutitle>Garbage Collector</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Code Factorization</menunode>
          <menutitle>Code Factorization</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Multi-Association Tables</menunode>
          <menutitle>Multi-Association Tables </menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Partitioned Databases</menunode>
          <menutitle>Partitioned Databases</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Strength Reduction</menunode>
          <menutitle>Strength Reduction</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Costmodels</menunode>
          <menutitle>Costmodels</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Variable Stack Reduction</menunode>
          <menutitle>Variable Stack Reduction</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Query Execution Plans</menunode>
          <menutitle>Query Execution Plans</menutitle>
          <menucomment></menucomment>
        </menuentry>
      </menu>
    </chapter>
  </node>
  <node>
    <nodename>Alias Removal</nodename>
    <nodenext>Dead Code Removal</nodenext>
    <nodeprev>Optimizer toolkit</nodeprev>
    <nodeup>Optimizer toolkit</nodeup>
    <section>
      <title>Alias Removal</title>
      <para>The routine <code>optimizer.aliasRemoval()</code> walks through the program looking for simple assignment statements, e.g. V:=W. It replaces all subsequent occurrences of V by W, provided V is assigned a value once and W does not change in the remainder of the code. Special care should be taken for iterator blocks as illustrated in the case below:</para>
      <verbatim xml:space="preserve"><![CDATA[
	i:=0;
	b:= "done";
barrier go:= true;
	c:=i+1;
	d:="step";
	v:=d;
	io.print(v);
	i:=c;
redo go:= i<2;
exit go;
	io.print(b);
	optimizer.aliasRemoval();
]]></verbatim>
      <para>The constant strings are propagated to the <code>print()</code> routine, while the initial assigment <code>i:=0</code> should be retained. The code block becomes:</para>
      <verbatim xml:space="preserve"><![CDATA[
	i:=0;
barrier go:= true;
	c:=i+1;
	io.print("step");
	i:=c;
redo go:= i<2;
exit go;
	io.print("done");
]]></verbatim>
      <example xml:space="preserve"></example>
    </section>
  </node>
  <node>
    <nodename>Dead Code Removal</nodename>
    <nodenext>Accumulator Evaluations</nodenext>
    <nodeprev>Alias Removal</nodeprev>
    <nodeup>Optimizer toolkit</nodeup>
    <section>
      <title>Dead Code Removal</title>
      <para>Dead code fragments are recognized by assignments to variables whose value is not consumed any more. It can be detected  by marking all variables used as arguments as being relevant. In parallel, we built a list of instructions that should appear in the final result. The new code block is than built in one scan, discarding the superflous instructions.</para>
      <para>Instructions that produce side effects to the environment, e.g. printing and BAT updates, should be taken into account. Such (possibly recursive) functions should be marked with a property (<code>unsafe</code>) For now we recognize a few important ones Likewise instructions marked as control flow instructions should be retained.</para>
      <para>An illustrative example is the following MAL snippet:</para>
      <verbatim xml:space="preserve"><![CDATA[
	V7 := bat.new(:void,:int);
	V10 := bat.new(:int,:void);
	V16 := algebra.markH(V7);
	V17 := algebra.join(V16,V7);
	V19 := bat.new(:void,:int);
	V22 := bat.new(:void,:int);
	V23 := algebra.join(V16,V22);
	io.print("done");
	optimizer.deadCodeRemoval();
]]></verbatim>
      <para>The dead code removal trims this program to the following short block:</para>
      <verbatim xml:space="preserve"><![CDATA[
	io.print("done");
]]></verbatim>
      <example xml:space="preserve"></example>
    </section>
  </node>
  <node>
    <nodename>Accumulator Evaluations</nodename>
    <nodenext>Heuristic Rewrite Rules</nodenext>
    <nodeprev>Dead Code Removal</nodeprev>
    <nodeup>Optimizer toolkit</nodeup>
    <section>
      <title>Accumulator Evaluations</title>
      <para>Bulk arithmetic calculations are pretty expensive, because new <code>BAT</code>s are created for each expression. This memory hunger can be reduced by detecting opportunities for accummulator processing, i.e. where a (temporary) variable is overwritten. For example, consider the program snippet</para>
      <example xml:space="preserve">	t3:= batcalc.*(64,t2);
	t4:= batcalc,+(t1,t3);
	optimizer.expressionAccumulation();</example>
      <para>If variable t2 is not used any further and retains its type throughout the program block, we can re-use its storage space and propagate its alias through the remainder of the code.</para>
      <example xml:space="preserve">	batcalc.*(t2,64,t2);
	t4:= batcalc.+(t2,t1,t2);</example>
      <para>The implementation is straight forward. It only deals with the arithmetic operations available in <code>batcalc</code> right now. This set will be gradually be extended. The key decision is to determine whether we may overwrite any of the arguments. We assume this is permissible if the argument was produced by an operator from the <code>algebra, algebra2, group, aggrX3</code> modules.</para>
      <example xml:space="preserve"></example>
    </section>
  </node>
  <node>
    <nodename>Heuristic Rewrite Rules</nodename>
    <nodenext>Common Sub-Expression Removal</nodenext>
    <nodeprev>Accumulator Evaluations</nodeprev>
    <nodeup>Optimizer toolkit</nodeup>
    <section>
      <title>Heuristic rewrites rules</title>
      <para>One of the oldest optimizer tricks in relational query processing is to apply heuristic rules to reduce the processing cost. For example, a selection predicate is pushed through another operator to reduce the number of tuples to consider. Heuristic rewrites are relatively easy to apply in a context where the expression is still close to a relational algebra tree. Therefore, many of the standard rewrite rules are already applied by the SQL front-end as part of its strategic optimization decisions.</para>
      <para>Finding rewrite opportunities within a linear MAL program may be more difficult. For, the pattern should respect the flow of control that may already be introduced. The last resort for the optimizer builder is to write a C-function to look for a pattern of interest and transform it. The code base contains an example how to built such user specific optimizer routines. It translates the pattern:</para>
      <example xml:space="preserve">y:= reverse(R);
z:= select(y,l,h);</example>
      <para>into the statement:</para>
      <example xml:space="preserve">z:= selectHead(x,R,l,h)</example>
      <example xml:space="preserve"></example>
      <example xml:space="preserve"></example>
    </section>
  </node>
  <node>
    <nodename>Common Sub-Expression Removal</nodename>
    <nodenext>Empty Set Reduction</nodenext>
    <nodeprev>Heuristic Rewrite Rules</nodeprev>
    <nodeup>Optimizer toolkit</nodeup>
    <section>
      <title>Common Subexpression Elimination</title>
      <para>Common subexpression elimination merely involves a single scan through the program block to detect re-curring statements. The key problem to be addressed is to make sure that the parameters involved in the repeatative instruction are invariant.</para>
      <para>The analysis of <code>optimizer.commonExpressionRemoval()</code> is rather crude. All functions with possible side-effects on their arguments should have been marked as 'unsafe'. Their use within a MAL block breaks the dataflow graph for all objects involved (BATs, everything kept in boxes).</para>
      <para>The common subexpression optimizer locates backwards the identical instructions. It stops as soon as it has found an identical one. Before we can replace the expression with the variable(s) of the previous one, we should assure that we haven;t passed a safety barrier.</para>
      <verbatim xml:space="preserve"><![CDATA[
    b:= bat.new(:int,:int);
    c:= bat.new(:int,:int);
    d:= algebra.select(b,0,100);
    e:= algebra.select(b,0,100);
    k1:= 24;
    k2:= 27;
    l:= k1+k2;
    l2:= k1+k2;
    l3:= l2+k1;
    optimizer.commonExpressionRemoval();
]]></verbatim>
      <para>is translated into the code block where the first two instructions are not common, because they have side effects.</para>
      <verbatim xml:space="preserve"><![CDATA[
    b := bat.new(:int,:int);
    c := bat.new(:int,:int);
    d := algebra.select(b,0,100);
    e := d;
    k1 := 24;
    k2 := 27;
    l := calc.+(k1,k2);
    l3 := calc.+(l,k1);
]]></verbatim>
      <para>The current implementation is rather expensive nested-loop algorithm, which does not perform well for large MAL blocks. Furthermore, after each hit we apply alias removal. This potentially generates more common expressions. The search can be improved significantly when a dataflow graph is maintained for all variables. For, equality of instruction implies that all variables have been used before in a similar context.</para>
      <example xml:space="preserve"></example>
    </section>
  </node>
  <node>
    <nodename>Empty Set Reduction</nodename>
    <nodenext>Singleton Set Replacement</nodenext>
    <nodeprev>Common Sub-Expression Removal</nodeprev>
    <nodeup>Optimizer toolkit</nodeup>
    <section>
      <title>Emptyset Reduction</title>
      <para>One of the key decisions during MAL optimization is to estimate the size of the BATs produced and consumed. Two cases are of interest for symbolic processing. Namely when a BAT is known to contain no tuples and those that have precisely one element. Such information may come from application domain knowledge or as a side effect from symbolic evaluation. It is associated with the program under inspection as properties.</para>
      <para>The empty set property is used by the reduction algorithm presented here. Any empty set is propagated through the program to arrive at a smaller and therefore faster evaluation.</para>
      <para>For example, consider the following MAL test</para>
      <example xml:space="preserve"><verbatim xml:space="preserve"><![CDATA[
    V1 := bat.new(:void,:int);
    V7 := bat.new(:void,:int);
    V10{empty} := bat.new(:int,:void);
    V11 := bat.reverse(V10);
    V12 := algebra.kdifference(V7,V11);
    V16 := algebra.markH(V12);
    V17 := algebra.join(V16,V7);
    bat.append(V1,V17);
	optimizer.emptySet();
]]></verbatim></example>
      <para>Calling the optimizer optimize.emptySet("user","test") replaces this program by the following code snippet.</para>
      <example xml:space="preserve">     V1 := bat.new(:void,:int);
     V7 := bat.new(:void,:int);
     V16 := algebra.markH(V7);
     V17 := algebra.join(V16,V7);
     bat.append(V1,V17);</example>
      <para>During empty set propagation, new candidates may appear. For example, taking the intersection with an empty set creates a target variable that is empty too. It becomes an immediate target for optimization. The current implementation is conservative. A limited set of instructions is considered. Any addition to the MonetDB instruction set would call for assessment on their effect.</para>
      <example xml:space="preserve"></example>
    </section>
  </node>
  <node>
    <nodename>Singleton Set Replacement</nodename>
    <nodenext>Peephole Optimization</nodenext>
    <nodeprev>Empty Set Reduction</nodeprev>
    <nodeup>Optimizer toolkit</nodeup>
    <section>
      <title>Singleton Set Reduction</title>
      <para>Application semantics and precise cost analysis may identify the result of an operation to produce a BAT with a single element. Such variables can be tagged with the property <code>singleton</code>, whereafter the operation <code>optimizer.singleton()</code> derives an MAL program using a symbolic evaluation as far as possible.</para>
      <para>During its evaluation, more singleton sets can be created, leading to a ripple effect through the code. A non-optimizable instruction leads to a construction of a new table with the single instance.</para>
	
      <verbatim xml:space="preserve"><![CDATA[
	b:= bat.new(:int,:int);
	bat.insert(b,1,2);
	c{singleton}:= algebra.select(b,0,4);
	d:= algebra.markH(c);
	io.print(d);
	optimizer.singleton();
]]></verbatim>
      <para>is translated by into the code block</para>
      <verbatim xml:space="preserve"><![CDATA[
	b := bat.new(:int,:int);
	bat.insert(b,1,2);
	c{singleton} := algebra.select(b,0,4);
	($15,$16):= bat.unpack(c{singleton});
	d := bat.pack(nil,$16);
	io.print(d);
]]></verbatim>
    </section>
  </node>
  <node>
    <nodename>Peephole Optimization</nodename>
    <nodenext>Multiplex Compiler</nodenext>
    <nodeprev>Singleton Set Replacement</nodeprev>
    <nodeup>Optimizer toolkit</nodeup>
    <section>
      <title>Peephole optimization</title>
      <para>Recursive descend query compilers easily miss opportunities for better code generation, because limited context is retained or lookahead available. The peephole optimizer is built around such recurring patterns and compensates for the compilers 'mistakes'. The collection of peephole patterns should grow over time and front-end specific variations are foreseen.</para>
      <example xml:space="preserve"></example>
      <para>The SQL frontend heavily relies on a pivot table, which is a generated oid sequence. Unfortunately, this is not seen and the pattern '$i := calc.oid(0@0); $j:= algebra.markT($k,$i);' occurs often. This can be replaced with '$j:= algebra.markT($k)';</para>
      <para>Another example of a 2-way instruction sequence produced is then '$j:= algebra.markT($k); $l:= bat.reverse($j);', which can be replaced by '$l:= algebra.markH($k);'.</para>
      <para>The reverse-reverse operation also falls into this category. Reversal pairs may result from the processing scheme of a front-end compiler or from a side-effect from other optimization steps. Such reversal pairs should be removed as quickly as possible, so as to reduce the complexity of finding alternative optimization opportunities. As in all cases we should ensure that the intermediates dropped are not used for other purposes as well.</para>
      <verbatim xml:space="preserve"><![CDATA[
	r:bat[:int,:int]:= bat.new(:int,:int);
	o:= calc.oid(0@0);
	z:= algebra.markT(r,o);
	rr:= bat.reverse(z);
	s := bat.reverse(r);
	t := bat.reverse(s);
	io.print(t);
	optimizer.peephole();
]]></verbatim>
      <para>which is translated by the peephole optimizer into:</para>
      <verbatim xml:space="preserve"><![CDATA[
	r:bat[:int,:int] := bat.new(:int,:int);
	rr := algebra.markH(r);
	io.print(r);
]]></verbatim>
      <example xml:space="preserve"></example>
    </section>
  </node>
  <node>
    <nodename>Multiplex Compiler</nodename>
    <nodenext>Garbage Collector</nodenext>
    <nodeprev>Peephole Optimization</nodeprev>
    <nodeup>Optimizer toolkit</nodeup>
    <section>
      <title>Multiplex Compilation</title>
      <para>The MonetDB operator multiplex concept has been pivotal to easily apply any scalar function to elements in a containers. Any operator <code>cmd</code> came with its multiplex variant [<code>cmd</code>]. Given the signature <code>cmd(T1,..,Tn) : Tr</code>, it could be applied also as <code>[CMD](bat[:any_1,:T1],...,bat[any_1,Tn]) :bat[any_1,Tr]</code>.</para>
      <para>The semantics of the multiplex is to perform the natural join on all bat-valued parameters, and to execute the CMD for each combination of matching tuples. All results are collected in a result BAT. All but one argument may be replaced by a scalar value.</para>
      <para>The generic solution to the multiplex operators is to translate them to a MAL loop. A snippet of its behaviour:</para>
      <verbatim xml:space="preserve"><![CDATA[
    b:= bat.new(:int,:int);
    bat.insert(b,1,1);
    c:bat[:int,:int]:= optimizer.multiplex("calc.+",b,1);
]]></verbatim>
      <para>The current implementation requires the target type to be mentioned explicitly. The result of the optimizer is:</para>
      <verbatim xml:space="preserve"><![CDATA[
    b := bat.new(:int,:int);
    bat.insert(b,1,1);
    _8 := bat.new(:int,:int);
barrier (_11,_12,_13):= chopper.newIterator(b);
    _15 := calc.+(_13,1);
    bat.insert(_8,_12,_15);
catch MALexception;
exit MALexception;
    redo (_11,_12,_13):= chopper.hasMoreElements(b);
exit (_11,_12,_13);
    c := _8;
]]></verbatim>
      <para>[WARNING] the semantics does not align precisely with M4. For, in search for efficient operators we assume aligned BATs and the script version does not deal with duplicates in the head of the bats. [/WARNING]</para>
      <example xml:space="preserve"></example>
    </section>
  </node>
  <node>
    <nodename>Garbage Collector</nodename>
    <nodenext>Code Factorization</nodenext>
    <nodeprev>Multiplex Compiler</nodeprev>
    <nodeup>Optimizer toolkit</nodeup>
    <section>
      <title>Garbage Collection</title>
      <para>Garbage collection of temporary variables, such as strings and BATs, takes place upon returning from a function call. Especially for BATs this may keep sizable resources locked longer than strictly necessary. Although the programmer can influence their lifespan by assignment of the <code>nil</code>, thereby triggering the garbage collector, it is more appropriate to rely on an optimizer to inject these statements. For, it keeps the program smaller and a better target for code-optimizations.</para>
      <para>The operation <code>optimizer.garbageCollector()</code> removes all BATs that are at their end of life to make room for new ones. It is typically called as one of the last optimizer steps. A snippet of a the effect of the garbage collector:</para>
      <verbatim xml:space="preserve"><![CDATA[
    t1 := bat.new(:void,:int);
    t2 := array.grid(132000,8,1,0);
    t3 := array.grid(1,100,10560,0);
    t4 := array.grid(1,100,10560,0,8);
    t5 := batcalc.+(t2,t4);
    t6 := batcalc.oid(t5);
    t7 := algebra.join(t6,t1);
    optimizer.setGarbageCollector();
]]></verbatim>
      <para>is translated into the following code block:</para>
      <verbatim xml:space="preserve"><![CDATA[
    t1 := bat.new(:void,:int);
    t2 := array.grid(132000,8,1,0);
    t3 := array.grid(1,100,10560,0);
    t4 := array.grid(1,100,10560,0,8);
    t5 := batcalc.+(t2,t4);
    bat.setGarbage(t2);
    bat.setGarbage(t4);
    t6 := batcalc.oid(t5);
    bat.setGarbage(t5);
    t7 := algebra.join(t6,t1);
    bat.setGarbage(t6);
    bat.setGarbage(t1);
]]></verbatim>
      <para>The current algorithm is straight forward. After each instruction we check whether its BAT arguments are needed in the future. If not, we inject a garbage collection statement to release them, provided there are no other reasons to retain it. This should be done carefully, because the instruction may be part of a loop. If the variable is defined inside the loop, we can safely remove it.</para>
      <example xml:space="preserve"></example>
    </section>
  </node>
  <node>
    <nodename>Code Factorization</nodename>
    <nodenext>Multi-Association Tables</nodenext>
    <nodeprev>Garbage Collector</nodeprev>
    <nodeup>Optimizer toolkit</nodeup>
    <section>
      <title>Code Factorization</title>
      <para>In most real-life situations queries are repeatedly called with only slight changes in their parameters. This situation can be captured by the query compilers by keeping a cache of recent query plans. In MonetDB context such queries are represented as parameterized MAL programs.</para>
      <para>To further optimize the cached functions it might help to split the query plan into two sections. One section with those actions that do not depend on the arguments given and another section that contains the heart of the query using all information. Such a program can be represented by a MAL factory, which is a re-entrend query plan.</para>
      <para>An example of how factorize changes the code is shown below:</para>
      <verbatim xml:space="preserve"><![CDATA[
function test(s:str):lng;
    b:= bat.new(:int,:str);
    bat.insert(b,1,"hello");
    z:= algebra.select(b,s,s);
    i:= aggr.count(z);
    return i;
end test;
optimizer.factorize("user","test");
]]></verbatim>
      <para>which translates into the following block:</para>
      <verbatim xml:space="preserve"><![CDATA[
factory user.test(s:str):lng;
    b := bat.new(:int,:str);
    bat.insert(b,1,"hello");
barrier always := true;
    z := algebra.select(b,s,s);
    i := aggr.count(z);
    yield i;
    redo always;
exit always;
end test;
]]></verbatim>
      <para>The factorizer included is a prototype implementation of MAL factorization. The approach taken is to split the program into two pieces and wrap it as a MAL factory. The optimization assumes that the database is not changed on tables accessed only once during the factory lifetime. Such changes should be detected from the outside and followed by re-starting the factory.</para>
      <para>A refined scheme where the user can identify the 'frozen' parameters is left for the future. As the mapping of a query to any of the possible available factories to deal with the request. For the time being we simple reorganize the plan for all parameters</para>
      <para>Caveats. The factorize operation interferes with <code>optimizer.expressionAccumulation()</code> because that may overwrite the arguments. For the time being this is captured in a local routine.</para>
      <example xml:space="preserve"></example>
    </section>
  </node>
  <node>
    <nodename>Multi-Association Tables</nodename>
    <nodenext>Partitioned Databases</nodenext>
    <nodeprev>Code Factorization</nodeprev>
    <nodeup>Optimizer toolkit</nodeup>
    <section>
      <title>Multiple Association Tables</title>
      <para>A Multi Association Table descriptor (MAT) defines an ordered collection of type compatible BATs, whose union represents a single (virtual) BAT. The MAT may relate to a partitioned BAT, but could also be an arbitrary collection of temporary BATs within a program fragment.</para>
      <para>The MAT definition lives within the scope of a single block. The MAT optimizer simply expands the plan to deal with its components on an individual basis. Only when a blocking or aggregate operator is encounted, the underlying BAT is materialized.</para>
      <para>The MAT object can not be passed as an argument to any function without first being materialized. Simply because the MAT is not known by the type system and none of the lower level operations is currently aware of their existence.</para>
      <para>In the first approach of the MAT optimizer we assume that the last BAT in the MAT sequence is used as an accumulator. Furthermore, no semantic knowledge is used to reduce the possible superflous (semi)joins. Instead, we limit expansion to a single argument. The last one in the argument list. This is changed at a later stage when a cost-based evaluation be decide differently.</para>
      <para>To illustrate, consider</para>
      <example xml:space="preserve">    m0:= bat.new(:void,:int);
	m1:= bat.new(:void,:int);
	m2:= bat.new(:void,:int);
	b := mat.new(m0,m1,m2);
	s := algebra.select(b,1,3);
	i := algebra.count(s);
	io.print(s);
	io.print(i);
	c0 := bat.new(:int,:int);
	c1 := bat.new(:int,:int);
	c := mat.new(c0,c1);
	j := algebra.join(b,s);
	io.print(j);</example>
      <para>The selection and aggregate operations can simply be rewritten into a MAT.</para>
      <example xml:space="preserve">	_33 := algebra.select(m0,1,3);
	_34 := algebra.select(m1,1,3);
	_35 := algebra.select(m2,1,3);
    s := mat.new(_33,_34,_35);
    i := 0;
    _36 := aggr.count(_33);
    i := calc.+(i,_36);
    _37 := aggr.count(_34);
    i := calc.+(i,_37);
    _38 := aggr.count(_35);
    i := calc.+(i,_38);
    io.print(i);</example>
      <para>The print operation does not have MAT semantics yet, which calls for collection of the MAT components in a single BAT first.</para>
      <example xml:space="preserve">    s := mat.pack(_33,_34,_35);
    io.print(s);</example>
      <para>For the join we have to generate all possible combinations, not knowing anything about the properties of the components. The current heuristic is to limit expansion to a single argument. This leads to</para>
      <example xml:space="preserve">    b := mat.pack(m0,m1,m2);
    _39 := algebra.join(b,c0);
    _40 := algebra.join(b,c1);
    j := mat.new(_39,_40);</example>
      <para>The drawback of this scheme is the explosion in MAL statements. It is choosen as a basis for experimentation. In a fullblown system we would also use iterators to avoid it.</para>
      <example xml:space="preserve"></example>
    </section>
  </node>
  <node>
    <nodename>Partitioned Databases</nodename>
    <nodenext>Strength Reduction</nodenext>
    <nodeprev>Multi-Association Tables</nodeprev>
    <nodeup>Optimizer toolkit</nodeup>
    <section>
      <title>Incremental query processing</title>
      <para>Limitations on the addressing space in older PCs and the need for distributed storage makes that BATs ideally should be looked upon as a union of smaller BATs which are processed within the (memory) resource limitations given.</para>
      <para>In the previous section, we already introduced the concept of a MAT, as the named union of a number of BATs to form a single virtual BAT. It can be used as a basis for incremental processing as well. For this to work, we assume that the MAT components each satisfy the (memory) resource contraints.</para>
      <para>The operation <code>optimizer.partitionedQuery</code> takes these definitions and encapsulate them in iterator blocks, thereby minimizing the MAL program footprint.</para>
      <para>The optimizer is designed incrementally. The focus is on supporting the SQL front-end. In particularly, the operators considered is a limited subset of MAL. Occurrence of an operator outside this set terminates the optimizer activities.</para>
      <para>The general strategy is to select a portion of the workflow related to a MAT variable and encapsulate it with an iterator over the BAT partitions. In doing so, we replace operators with their incremental counter part, alike the MAT optimizer.</para>
      <para>A snippet of the partitioning optimizer is shown below. It assumes that the MAT <code>a0</code> consists of the components <code>a1,a2,a3</code>. A subsequent call of the partition optimizer will replace the print command with an iterator.</para>
      <verbatim xml:space="preserve"><![CDATA[

function qry(a:bat[:void,:any_1]{mat});
	io.print(b);
end qry;
optimizer.partitionedQuery("user","qry");
]]></verbatim>
      <para>The query is transformed into the following version.</para>
      <verbatim xml:space="preserve"><![CDATA[
function user.qry(a:bat[:void,:any_1]{mat}):void;
barrier (_5,_6):= mat.newIterator(a);
	io.print(_6);
	redo (_5,_6):= mat.hasMoreElements(a);
exit (_5,_6);
end qry;
]]></verbatim>
      <example xml:space="preserve"></example>
      <para>The translation of a MAL block into a multi-iterator only works if the network flow is simple, i.e there exists a 'single' sink, or all the information is compressed into variables that are passed back to the caller as a single value, or is sent non-interupted to the output channels. The bottom-line is to avoid expansion. An assignment to the target is not allowed [to be checked separately]</para>
      <example xml:space="preserve"></example>
      <para>The first implementation takes a query block and replaces the first bat variable with its partitioned equivalent. The external references should be adjusted to permit working your way through the complete graph incrementally. They denote an inclusive range. A copy of the program block is made by default. This could be optimized away later.</para>
      <example xml:space="preserve"></example>
    </section>
  </node>
  <node>
    <nodename>Strength Reduction</nodename>
    <nodenext>Costmodels</nodenext>
    <nodeprev>Partitioned Databases</nodeprev>
    <nodeup>Optimizer toolkit</nodeup>
    <section>
      <title>Strength Reduction</title>
      <para>An effective optimization technique in compiler construction is to move invariant statements out of the loops. The equivalent strategy can be applied to the guarded blocks in MAL programs. Any variable introduced in a block and assigned a value using a side-effect free operation is a candidate to be moved. Furthermore, it may not be used outside the block and the expression may not depend on variables assigned a value within the same block.</para>
      <verbatim xml:space="preserve"><![CDATA[
	j:= "hello world";
barrier go:=true;
	i:= 23;
	j:= "not moved";
	k:= j; 
	io.print(i);
	redo go:= false;
exit go;
	z:= j;
optimizer.strengthReduction();
]]></verbatim>
      <para>which is translated into the following code:</para>
      <verbatim xml:space="preserve"><![CDATA[
	j := "hello world";
	i := 23;
barrier go := true;
	j := "not moved";
	k := j;
	io.print(i);
	redo go:= false;
exit go;
	z:= j;
]]></verbatim>
      <para>Application is only applicable to loops and not to guarded blocks in general, because execution of a statement outside the guarded block consumes processing resources which may have been prohibited by the block condition.</para>
      <para>For example, it doesn't make sense to move creation of objects outside the barrier.</para>
      <example xml:space="preserve"></example>
    </section>
  </node>
  <node>
    <nodename>Costmodels</nodename>
    <nodenext>Variable Stack Reduction</nodenext>
    <nodeprev>Strength Reduction</nodeprev>
    <nodeup>Optimizer toolkit</nodeup>
    <section>
      <title>The MAL costmodel</title>
      <para>Cost models form the basis for many optimization decisions. The cost parameters are typically the size of the (intermediate) results and response time. Alternatively, they are running aggregates, e.g. max memory and total execution time, obtained from a simulated run. The current implementation contains a framework and example for building your own cost-based optimized.</para>
      <para>The <code>optimizer.costEstimation()</code> works its way through a MAL program in search for relational operators and estimates their result size. The operations taken into account are The estimated size is left behind as property <code>RMcost</code>, to avoid overwriting information produced by the front-end compiler.</para>
      <verbatim xml:space="preserve"><![CDATA[
    r{count=100} := bat.new(:void,:int);
    s{count=1000}:= bat.new(:void,:int);
    rs:= algebra.select(s,1,1);
    rr:= bat.reverse(r);
    j:= algebra.join(rs,rr);
    optimizer.costEstimation();
]]></verbatim>
      <para>changes the properties of the instructions as follows:</para>
      <verbatim xml:space="preserve"><![CDATA[
    r{RMcost=100,count=100} := bat.new(:void,:int);
    s{RMcost=1000,count=1000} := bat.new(:void,:int);
    rs{RMcost=500} := algebra.select(s{RMcost=1000,count=1000},1,1);
    rr{RMcost=100} := bat.reverse(r{RMcost=100,count=100});
    j{RMcost=100} := algebra.join(rs{RMcost=500},rr{RMcost=100});
]]></verbatim>
      <para>The cost estimation does not use any statistics on the actual data distribution yet. It just applies a few heuristic cost estimators.</para>
      <example xml:space="preserve"></example>
    </section>
  </node>
  <node>
    <nodename>Variable Stack Reduction</nodename>
    <nodenext>Query Execution Plans</nodenext>
    <nodeprev>Costmodels</nodeprev>
    <nodeup>Optimizer toolkit</nodeup>
    <section>
      <title>Variable Stack Reduction</title>
      <para>The compilers producing MAL may generate an abundance of temporary variables to hold the result of expressions. This leads to a polution of the runtime stack space, because space should be allocated and garbage collection tests should be performed.</para>
      <para>The routine <code>optimizer.reduce()</code> reduces the number of scratch variables to a minimum. All scratch variables of the same underlying type share the storage space. The result of this optimizer can be seen using the MonetDB debugger, which marks unused variables explicitly. Experience with the SQL front-end shows, that this optimization step easily reduces the stack consumption by over 20\%.</para>
      <para>This optimizer needs further testing. Furthermore, the other optimizers should be careful in setting the isused property, or this property can again be easily derived.</para>
      <example xml:space="preserve"></example>
    </section>
  </node>
  <node>
    <nodename>Query Execution Plans</nodename>
    <nodenext>Program Debugging</nodenext>
    <nodeprev>Variable Stack Reduction</nodeprev>
    <nodeup>Optimizer toolkit</nodeup>
    <section>
      <title>Query Execution Plans</title>
      <para>A commonly used data structure to represent and manipulate a query is a tree (or graph). Its nodes represent the operators and the leaves the operands. Such a view comes in handy when you have to re-organize whole sections of code or to built-up an optimized plan bottom up, e.g. using a memo structure.</para>
      <para>The MAL optimizer toolkit provides functions to overlay the body of any MAL block with a tree (graph) structure and to linearize them back into a MAL block. The linearization order is determined by a recursive descend tree walk from the anchor points in the source program.</para>
      <para>To illustrate, consider the code block:</para>
      <example xml:space="preserve">#T1:= bat.new(:int,:int);
#T2:= bat.new(:int,:int);
#T3:= bat.new(:int,:int);
#T4:= bat.new(:int,:int);
a:= algebra.select(T1,1,3);
b:= algebra.select(T2,1,3);
c:= algebra.select(T3,0,5);
d:= algebra.select(T4,0,5);
e:= algebra.join(a,c);
f:= algebra.join(b,d);
h:= algebra.join(e,f);
optimizer.dumpQEP();</example>
      <para>which produces an indented structure of the query plan.</para>
      <example xml:space="preserve">h := algebra.join(e,f);
    e := algebra.join(a,c);
        a := algebra.select(T1,1,3);
            T1 := bat.new(:int,:int);
        c := algebra.select(T3,0,5);
            T3 := bat.new(:int,:int);
    f := algebra.join(b,d);
        b := algebra.select(T2,1,3);
            T2 := bat.new(:int,:int);
        d := algebra.select(T4,0,5);
            T4 := bat.new(:int,:int);</example>
      <para>Any valid MAL routine can be overlayed with a tree (graph) view based on the flow dependencies, but not all MAL programs can be derived from a simple tree. For example, the code snippet above when interpreted as a linear sequence can not be represented unless the execution order itself becomes an operator node itself.</para>
      <para>However, since we haven't added or changed the original MAL program, the routine <code>qep.propagate</code> produces the orginial program, where the linear order has priority. If, however, we had entered new instructions into the tree, they would have been placed in close proximity of the other tree nodes.</para>
      <para>Special care is given to the flow-of-control blocks, because to produce a query plan section that can not easily be moved around. [give dot examples]</para>
      <example xml:space="preserve"></example>
    </section>
  </node>
  <node>
    <nodename>Program Debugging</nodename>
    <nodenext>The MAL Debugger</nodenext>
    <nodeprev>Query Execution Plans</nodeprev>
    <nodeup>Top</nodeup>
    <chapter>
      <title>Program Debugging</title>
      <para>In practice it is hard to write a correct MAL program the first time around. Instead, it is more often constructed by trial-and-error. As long as there are syntax and semantic errors the MAL compiler provides a sufficient handle to proceed. Once it passes the compiler we have to resort to a debugger to assess its behavior.</para>
      <menu>
        <menuentry>
          <menunode>The MAL Debugger</menunode>
          <menutitle>The MAL Debugger</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Handling Breakpoints</menunode>
          <menutitle>Handling Breakpoints</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Runtime Inspection</menunode>
          <menutitle>Runtime Inspection</menutitle>
          <menucomment></menucomment>
        </menuentry>
      </menu>
    </chapter>
  </node>
  <node>
    <nodename>The MAL Debugger</nodename>
    <nodenext>Handling Breakpoints</nodenext>
    <nodeprev>Program Debugging</nodeprev>
    <nodeup>Program Debugging</nodeup>
    <section>
      <title>The MAL debugger</title>
      <para>To ease debugging and performance monitoring, the MAL interpreter comes with a gdb-like debugger. An illustrative session elicits the functionality offered.</para>
      <example xml:space="preserve">&gt;function test(i:int):str;
&gt;	io.print(i);
&gt;	i:= i*2;
&gt;	b:= bbp.new(:int,:int);
&gt;	bat.insert(b,1,i);
&gt;	io.print(b);
&gt;	return test:= "ok";
&gt;end test;
&gt;user.test(1);
[ 1 ]
#-----------------#
# h     t         # name
# int   int       # type
#-----------------#
[ 1,      2       ]</example>
      <para>The debugger can be entered at any time using the call mdb.start(). An overview of the available commands is readily available.</para>
      <example xml:space="preserve">&gt;mdb.start();
#mdb !end main;
mdb&gt;help
next       -- Advance to next statement
continue   -- Continue program being debugged
break      -- set breakpoint on current instruction
break &lt;var&gt;    -- break on assignment to &lt;var&gt;
delete &lt;var&gt;   -- remove break point &lt;var&gt;
step       -- advance to next MAL instruction
module     -- display the module signatures
finish     -- finish current call
exit       -- terminate current call
quit       -- turn off debugging
list &lt;fcn&gt; -- list current program block
List &lt;fcn&gt; -- list with type information
var  &lt;fcn&gt;  -- print symbol table for module
optimizer &lt;idx&gt;  -- display program after optimizer step
print &lt;var&gt;    -- display value of a variable
print &lt;var&gt; &lt;cnt&gt;[&lt;first&gt;] -- display BAT chunk
info &lt;var&gt;     -- display bat variable properties
run        -- restart current procedure
where      -- print stack trace
down       -- go down the stack
up         -- go up the stack
timer      -- produce micro-second response time
io         -- produce page activity trace
help       -- this message
mdb&gt;</example>
      <para>We walk our way through a debugging session, highlighting the effects of the debugger commands. The call to mdb.start() has been encapsulated in a complete MAL function, as shown by issuing the list command. A more detailed listing shows the binding to the C-routine and the result of type resolution.</para>
      <example xml:space="preserve">&gt;mdb.start();
#end main;
mdb&gt;l
function user.main():int;
	mdb.start();
end main;
mdb&gt;L
function user.main():int;       # 0  (main:int)
	mdb.start();        # 1 MDBstart (_1:void)
end main;       # 2</example>
      <para>The user module is the default place for function defined at the console. The modules loaded can be shown typeing the command 'modules' or 'module'(or 'm'  for short). The former merely enumerates the module names, the latter also shows the names of the function in each. The function signatures become visible using the module and optionally the function name.</para>
      <example xml:space="preserve">mdb&gt;m alarm
#command alarm.alarm(secs:int,action:str):void address ALARMsetalarm;
#command alarm.ctime():str address ALARMctime;
#command alarm.epilogue():void address ALARMepilogue;
#command alarm.epoch():int address ALARMepoch;
#command alarm.prelude():void address ALARMprelude;
#command alarm.sleep(secs:int):void address ALARMsleep;
#command alarm.time():int address ALARMtime;
#command alarm.timers():bat[:str,:str] address ALARMtimers;
#command alarm.usec():lng address ALARMusec;
mdb&gt;m alarm.sleep
#command alarm.sleep(secs:int):void address ALARMsleep;
mdb&gt;</example>
      <para>The debugger mode is left with a &lt;return&gt;. Any subsequent MAL instruction re-activates the debugger to await for commands. The default operation is to step through the execution using the 'next' ('n') or 'step' ('s) commands, as shown below.</para>
      <example xml:space="preserve">&gt;user.test(1);
#    user.test(1);
mdb&gt;n
#    io.print(i);
mdb&gt;
[ 1 ]
#    i := calc.*(i,2);
mdb&gt;
#    b := bbp.new(:int,:int);
mdb&gt;</example>
      <para>The last instruction show is ready to be executed, which means the calculation has already been finished. The value assigned to a variable can be shown using a print statement, which contains the location of the variable on the stack frame, its name, its value and type. The complete stack frame becomes visible with 'values' ('v') command:</para>
      <example xml:space="preserve">#    bat.insert(b,1,i);
mdb&gt;
#    io.print(b);
mdb&gt;v
#Stack for 'test' size=32 top=11
#[0] test        = nil:str
#[1] i   = 4:int
#[2] _2  = 0:int   unused
#[3] _3  = 2:int  constant
#[4] b   = &lt;tmp_1226&gt;:bat[:int,:int]   count=1 lrefs=1 refs=0
#[5] _5  = 0:int   type variable
#[6] _6  = nil:bat[:int,:int]   unused
#[7] _7  = 1:int  constant
#[8] _8  = 0:int   unused
#[9] _9  = "ok":str  constant</example>
      <para>The variables marked 'unused' have been introduced as temporary variables, but which are not referenced in the remainder of the program. It also illustrates basic BAT properties, a complete description of which can be obtained using the 'info' ('i') command. A sample of the BAT content can be printed passing tuple indices, e.g. 'print b 10 10' prints the second batch of ten tuples.</para>
    </section>
  </node>
  <node>
    <nodename>Handling Breakpoints</nodename>
    <nodenext>Runtime Inspection</nodenext>
    <nodeprev>The MAL Debugger</nodeprev>
    <nodeup>Program Debugging</nodeup>
    <section>
      <title>Handling Breakpoints</title>
      <para>A powerful mechanism for debugging a program is to set breakpoints during the debugging session. The breakpoints are designated by a target variable name, a [module.]operator name, or a MAL line number (#&lt;number&gt;). As soon as the variable recieves a new value  or the operation is called the debugger is activated.</para>
      <para>The snippet below illustrates the reaction to set a break point on assignment to variable 'i'.</para>
      <example xml:space="preserve">&gt;mdb.start();
#end main;
mdb&gt;
&gt;user.test(1);
#    user.test(1);
mdb&gt;break i
breakpoint on 'i' not set
mdb&gt;n
#    io.print(i);
mdb&gt;break i
mdb&gt;c
[ 1 ]
#    i := calc.*(i,2);
mdb&gt;</example>
      <para>The breakpoints remain in effect over multiple function calls. They can be removed with the <code>delete</code> statement. A list of all remaining breakpoints is obtained with <code>breakpoints</code>.</para>
      <para>The interpreter can be instructed to call the debugger as soon as an exception is raised. Simply add the instruction <code>mdb.setCatch(true)</code>.</para>
    </section>
  </node>
  <node>
    <nodename>Runtime Inspection</nodename>
    <nodenext>Execution Profiling</nodenext>
    <nodeprev>Handling Breakpoints</nodeprev>
    <nodeup>Program Debugging</nodeup>
    <section>
      <title>Runtime Inspection and Reflection</title>
      <para>Part of the debugger functionality can also be used directly with MAL instructions. The execution trace of a snippet of code can be visualized encapsulation with <code>mdb.setTrace(true)</code> and <code>mdb.setTrace(false)</code>. Likewise, the performance can be monitored with the command <code>mdb.setTimer(on/off)</code>. Using a boolean argument makes it easy to control the (performance) trace at run time. The following snippet shows the effect of patching the test case.</para>
      <example xml:space="preserve">&gt;function test(i:int):str;
&gt;	mdb.setTrace(true);
&gt;	io.print(i);
&gt;	i:= i*2;
&gt;	b:= bbp.new(:int,:int);
&gt;	bat.insert(b,1,i);
&gt;	io.print(b);
&gt;	mdb.setTrace(false);
&gt;	return test:= "ok";
&gt;end test;
&gt;user.test(1);
#    mdb.setTrace(_3=true)
[ 1 ]
#    io.print(i=1)
#    i := calc.*(i=2, _5=2)
#    b := bbp.new(_7=0, _8=0)
#    bat.insert(b=&lt;tmp_1226&gt;, _10=1, i=2)
#-----------------#
# h     t         # name
# int   int       # type
#-----------------#
[ 1,      2       ]
#    io.print(b=&lt;tmp_1226&gt;)
#   261 usec!    user.test(_2=1)
&gt;</example>
      <para>The command setTimer() produces timing statistics in micro-seconds. Aside from the time spent in each statement separately, it accumulate the timeing for the complete call. The time spent on preparing the trace information is excluded from the time reported. For more detailed timing information the Linux tool <emph>valgrind</emph> may be of help.</para>
      <example xml:space="preserve">&gt;function test(i:int):str;
&gt;	mdb.setTimer(true);
&gt;	io.print(i);
&gt;	i:= i*2;
&gt;	b:= bbp.new(:int,:int);
&gt;	bat.insert(b,1,i);
&gt;	io.print(b);
&gt;	mdb.setTimer(false);
&gt;	return test:= "ok";
&gt;end test;
&gt;user.test(1);
#     6 usec#    mdb.setTimer(_3=true)
[ 1 ]
#    43 usec#    io.print(i=1)
#     5 usec#    i := calc.*(i=2, _5=2)
#    24 usec#    b := bbp.new(_7=0, _8=0)
#    10 usec#    bat.insert(b=&lt;tmp_1226&gt;, _10=1, i=2)
#-----------------#
# h     t         # name
# int   int       # type
#-----------------#
[ 1,      2       ]
#   172 usec#    io.print(b=&lt;tmp_1226&gt;)
#   261 usec#    user.test(_2=1)</example>
      <para>It is also possible to activate the debugger from within a program using <code>mdb.start()</code>. It remains in this mode until you either issue a quit command, or the command mdb.stop() instruction is encountered. The debugger is only activated when the user can direct its execution from the client interface. Otherwise, there is no proper input channel and the debugger will run in trace mode.</para>
      <para>The program listing functionality of the debugger is also captured in the MAL debugger module. The current code block can be listed using <code>mdb.list()</code> and <code>mdb.List()</code>. An arbitrary code block can be shown with  <code>mdb.list</code>(<emph>module</emph>,<emph>function</emph>) and <code>mdb.List</code>(<emph>module</emph>,<emph>function</emph>). A BAT representation of the current function is return by <code>mdb.getDefinition()</code><eosperiod/></para>
      <para>The symbol table and stack content, if available, can be shown with the operations <code>mdb.var()</code> and <code>mdb.list</code>(<emph>module</emph>,<emph>function</emph>) Access to the stack frames may be helpful in the context of exception handling. The operation <code>mdb.getStackDepth()</code> gives the depth and individual elements can be accessed as BATs using <code>mdb.getStackFrame(<emph>n</emph>)</code>. The top stack frame is accessed using <code>mdb.getStackFrame()</code>.</para>
    </section>
  </node>
  <node>
    <nodename>Execution Profiling</nodename>
    <nodenext>Event Filtering</nodenext>
    <nodeprev>Runtime Inspection</nodeprev>
    <nodeup>Top</nodeup>
    <chapter>
      <title>Execution Profiling</title>
      <para>A key issue in the road towards a high performance implementation is to understand where resources are being spent. This information can be obtained using different tools and at different levels of abstraction. A coarse grain insight for a particular application can be obtained using injection of the necessary performance capturing statements in the instruction sequence. Fine-grain, platform specific information can be obtained using existing profilers, like valgrind (http://www.valgrind.org), or hardware performance counters.</para>
      <para>The MAL profiler collects detailed performance information, such as cpu, memory and statement information. It is optionally extended with IO activity, which is needed for coarse grain profiling only.</para>
      <para>The execution profiler is supported by hooks in the MAL interpreter. The default strategy is to ship an event record immediately over a stream to a separate performance monitor, formatted as a tuple. An alternative strategy is preparation for off-line performance analysis. For this case the event record is turned into a XML structure and sent over the stream (most likely linked with a file) Reflective performance analysis is supported by an event cache, emptied explicitly upon need.</para>
      <menu>
        <menuentry>
          <menunode>Event Filtering</menunode>
          <menutitle>Event Filtering </menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Event Caching</menunode>
          <menutitle>Event Caching</menutitle>
          <menucomment></menucomment>
        </menuentry>
      </menu>
    </chapter>
  </node>
  <node>
    <nodename>Event Filtering</nodename>
    <nodenext>Event Caching</nodenext>
    <nodeprev>Execution Profiling</nodeprev>
    <nodeup>Execution Profiling</nodeup>
    <section>
      <title>Event Filtering</title>
      <para>The profiler supports selective retrieval of such information by tagging the instructions of interest. This means that a profiler call has a global effect, all concurrent users are affected by the performance overhead. Therefore, it is of primary interest to single user sessions.</para>
      <para>The example below illustrates how the different performance counter groups are activated, instructions are filtered for tracking, and where the profile information is retained for a posteriori analysis. The tuple format is chosen.</para>
      <example xml:space="preserve">profiler.activate("time");
profiler.activate("ticks");
#profiler.activate("cpu");
#profiler.activate("memory");
#profiler.activate("io");
#profiler.activate("pc");
#profiler.activate("event");
profiler.activate("statement");
profiler.setFilter("*","insert");
profiler.setFilter("*","print");

profiler.openStream("/tmp/MonetDBevents");
profiler.start();
b:= bbp.new(:int,:int);
bat.insert(b,1,15);
bat.insert(b,2,4);
bat.insert(b,3,9);
io.print(b);
profiler.stop();
profiler.closeStream();</example>
      <para>The information on CPU, IO, memory use, program counter and the event identifier are not retained. Furthermore, we are interested in all functions name <code>insert</code> and <code>print</code>. A wildcard can be used to signify any name, e.g. no constraints are put on the module in which the operations are defined.</para>
      <para>Execution of the sample leads to the creation of a file with the following content. The ticks are measured in micro-seconds.</para>
      <verbatim xml:space="preserve"><![CDATA[
# time, ticks,  stmt,   # name
[ "15:17:56",   12,      "_27 := bat.insert(<tmp_15>,1,15);",    ]
[ "15:17:56",   2,       "_30 := bat.insert(<tmp_15>,2,4);",     ]
[ "15:17:56",   2,       "_33 := bat.insert(<tmp_15>,3,9);",     ]
[ "15:17:56",   245,     "_36 := io.print(<tmp_15>);",   ]
]]></verbatim>
      <para>The XML-formatted output is produced by encapsulation of a code block with the pair <code>profiler.setOfflineProfiling()</code>. The default is tuple format, which can be requested explicitly using <code>profiler.setOnlineProfiling()</code>.</para>
    </section>
  </node>
  <node>
    <nodename>Event Caching</nodename>
    <nodenext>MonetDB Extension Modules</nodenext>
    <nodeprev>Event Filtering</nodeprev>
    <nodeup>Execution Profiling</nodeup>
    <section>
      <title>Event Caching</title>
      <para>Aside from shipping events to a separate process, the profiler can keep the events in a local <code>BAT</code> group, triggered with the command <code>profiler.setCachedProfiling()</code>. Ofcourse, every measurement scheme does not come for free and may even obscure performance measurements obtained throug e.g. valgrind. The separate event caches can be accessed using the operator <code>profiler.getTrace</code>(<emph>name</emph>). The current implementation only supports access to <code>time</code>,<code>ticks</code>,<code>pc</code>,<code>statement</code>. The event cache can be cleared with <code>profiler.clearTrace()</code>.</para>
      <para>Consider the following MAL program snippet:</para>
      <example xml:space="preserve">profiler.setAll();
profiler.setCachedProfiling();
profiler.startTrace();
b:= bbp.new(:int,:int);
bat.insert(b,1,15);
io.print(b);
profiler.stopTrace();
s:= profiler.getTrace("statement");
t:= profiler.getTrace("ticks");
io.print(s,t);</example>
      <para>The result of the program execution becomes:</para>
      <verbatim xml:space="preserve"><![CDATA[
#-----------------#
# h     t         # name
# int   int       # type
#-----------------#
[ 1,      15      ]
#---------------------------------------------------------#
# h     t                                       t         # name
# int   str                                     int       # type
#---------------------------------------------------------#
[ 1,      "b := bbp.new(0,0);",                   51      ]
[ 2,      "$6 := bat.insert(<tmp_22>,1,15);",     16      ]
[ 3,      "$9 := io.print(<tmp_22>);",            189     ]
]]></verbatim>
      <example xml:space="preserve"></example>
    </section>
  </node>
  <node>
    <nodename>MonetDB Extension Modules</nodename>
    <nodenext>MonetDB BAT Kernel</nodenext>
    <nodeprev>Event Caching</nodeprev>
    <nodeup>Top</nodeup>
  </node>
  <node>
    <nodename>MonetDB BAT Kernel</nodename>
    <nodenext>Advanced Topics</nodenext>
    <nodeprev>MonetDB Extension Modules</nodeprev>
    <nodeup>Top</nodeup>
  </node>
  <node>
    <nodename>Advanced Topics</nodename>
    <nodenext>Appendices</nodenext>
    <nodeprev>MonetDB BAT Kernel</nodeprev>
    <nodeup>Top</nodeup>
    <para>Some additional stuff</para>
  </node>
  <node>
    <nodename>Appendices</nodename>
    <nodenext>SQL 1999 Features</nodenext>
    <nodeprev>Advanced Topics</nodeprev>
    <nodeup>Top</nodeup>
    <menu>
      <menuentry>
        <menunode>SQL 1999 Features</menunode>
        <menutitle>SQL 1999 Features</menutitle>
        <menucomment></menucomment>
      </menuentry>
      <menuentry>
        <menunode>MAL Syntax</menunode>
        <menutitle>MAL Syntax </menutitle>
        <menucomment></menucomment>
      </menuentry>
      <menuentry>
        <menunode>Conversion of MIL Programs</menunode>
        <menutitle>Conversion of MIL Programs</menutitle>
        <menucomment></menucomment>
      </menuentry>
      <menuentry>
        <menunode>MAL Instruction Overview</menunode>
        <menutitle>MAL Instruction Overview</menutitle>
        <menucomment></menucomment>
      </menuentry>
      <menuentry>
        <menunode>MAL Instruction Help</menunode>
        <menutitle>MAL Instruction Help</menutitle>
        <menucomment></menucomment>
      </menuentry>
    </menu>
  </node>
  <node>
    <nodename>SQL 1999 Features</nodename>
    <nodenext>MAL Syntax</nodenext>
    <nodeprev>Appendices</nodeprev>
    <nodeup>Appendices</nodeup>
    <appendix>
      <title>SQL 1999 Features</title>
      <para>The table below illustrates the features supported (S) and not supported (N) in the MonetDB/SQL distribution. Beware, some of the features are technically impossible to support without major code changes or excessive performance consequences.</para>
      <multitable>
        <columnfraction>15</columnfraction>
        <columnfraction>70</columnfraction>
        <columnfraction>15</columnfraction>
        <tbody>
          <row>
            <entry>Feature ID</entry>
            <entry>Feature name</entry>
            <entry>S/N</entry>
          </row>
          <row>
            <entry>B011-B017</entry>
            <entry>Embedded Language support. Core SQL:1999 says that at least one of Embedded Ada, Embedded C, Embedded Cobol, Embedded Fortran, Embedded MUMPS, Embedded Pascal or Embedded PL/I 1 should be supported.</entry>
            <entry>N</entry>
          </row>
          <row>
            <entry>E011</entry>
            <entry>Numeric data types (FULL support)</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>E011-01</entry>
            <entry>INTEGER and SMELLIEST data types (including all spellings)</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>E011-02</entry>
            <entry>REAL, DOUBLE PRECISON, and FLOAT data types</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>E011-03</entry>
            <entry>DECIMAL and NUMERIC data types</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>E011-04</entry>
            <entry>Arithmetic operators</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>E011-05</entry>
            <entry>Numeric comparison</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>E011-06</entry>
            <entry>Implicit casting among the numeric data types</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>E021</entry>
            <entry>Character data types</entry>
            <entry>S(PARTIAL support)</entry>
          </row>
          <row>
            <entry>E021-01</entry>
            <entry>CHARACTER data type (including all its spellings)</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>E021-02</entry>
            <entry>CHARACTER VARYING data type (including all its spellings)</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>E021-03</entry>
            <entry>Character literals</entry>
          </row>
          <row>
            <entry>E021-04</entry>
            <entry>CHARACTER_LENGTH function</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>E021-05</entry>
            <entry>OCTET_LENGTH function</entry>
            <entry>N (TODO!!!)</entry>
          </row>
          <row>
            <entry>E021-06</entry>
            <entry>SUBSTRING function</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>E021-07</entry>
            <entry>Character concatenation</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>E021-08</entry>
            <entry>UPPER and LOWER functions</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>E021-09</entry>
            <entry>TRIM function</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>E021-10</entry>
            <entry>Implicit casting among the character data types</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>E021-11</entry>
            <entry>POSITION function</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>E021-12</entry>
            <entry>Character comparison</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>E031</entry>
            <entry>Identifiers (FULL support)</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>E031-01</entry>
            <entry>Delimited identifiers</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>E031-02</entry>
            <entry>Lower case identifiers</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>E031-03</entry>
            <entry>Trailing underscore</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>E051</entry>
            <entry>Basic query specification (FULL support)</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>E051-01</entry>
            <entry>SELECT DISTINCT</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>E051-02</entry>
            <entry>GROUP BY clause</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>E051-04</entry>
            <entry>GROUP BY can contain columns not in select-list</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>E051-05</entry>
            <entry>Select list items can be renamed</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>E051-06</entry>
            <entry>HAVING clause</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>E051-07</entry>
            <entry>Qualified * in select list</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>E051-08</entry>
            <entry>Correlation names in the FROM clause</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>E051-09</entry>
            <entry>Rename columns in the FROM clause</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>E061</entry>
            <entry>Basic predicates and search conditions (FULL support)</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>E061-01</entry>
            <entry>Comparison predicate</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>E061-02</entry>
            <entry>BETWEEN predicate</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>E061-03</entry>
            <entry>IN predicate with list of values</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>E061-04</entry>
            <entry>LIKE predicate</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>E061-05</entry>
            <entry>LIKE predicate: ESCAPE clause</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>E061-06</entry>
            <entry>NULL predicate</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>E061-07</entry>
            <entry>Quantified comparison predicate</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>E061-08</entry>
            <entry>EXISTS predicate</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>E061-09</entry>
            <entry>Subqueries in comparison predicate</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>E061-11</entry>
            <entry>Subqueries in IN predicate</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>E061-12</entry>
            <entry>Subqueries in quantified comparison predicate</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>E061-13</entry>
            <entry>Correlated subqueries</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>E061-14</entry>
            <entry>Search condition</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>E071</entry>
            <entry>Basic query expressions</entry>
            <entry>S (FULL support)</entry>
          </row>
          <row>
            <entry>E071-01</entry>
            <entry>UNION DISTINCT table operator</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>E071-02</entry>
            <entry>UNION ALL table operator</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>E071-03</entry>
            <entry>EXCEPT DISTINCT table operator</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>E071-05</entry>
            <entry>Columns combined via table operators need not have exactly the same data type</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>E071-06</entry>
            <entry>Table operators in subqueries</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>E081</entry>
            <entry>Basic Privileges</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>E081-01</entry>
            <entry>SELECT privilege at the table level</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>E081-02</entry>
            <entry>DELETE privilege</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>E081-03</entry>
            <entry>INSERT privilege at the table level</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>E081-04</entry>
            <entry>UPDATE privilege at the table level</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>E081-05</entry>
            <entry>UPDATE privilege at the column level</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>E081-06</entry>
            <entry>REFERENCES privilege at the table level</entry>
            <entry>N (not checked? needs work)</entry>
          </row>
          <row>
            <entry>E081-07</entry>
            <entry>REFERENCES privilege at the column level</entry>
            <entry>N (not checked? needs work)</entry>
          </row>
          <row>
            <entry>E081-08</entry>
            <entry>WITH GRANT OPTION</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>E081-09</entry>
            <entry>USAGE privilege</entry>
            <entry>N</entry>
          </row>
          <row>
            <entry>E081-10</entry>
            <entry>EXECUTE privilege</entry>
            <entry>N (Not checked)</entry>
          </row>
          <row>
            <entry>E091</entry>
            <entry>Set functions (FULL support)</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>E091-01</entry>
            <entry>AVG</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>E091-02</entry>
            <entry>COUNT</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>E091-03</entry>
            <entry>MAX</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>E091-04</entry>
            <entry>MIN</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>E091-05</entry>
            <entry>SUM</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>E091-06</entry>
            <entry>ALL quantifier</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>E091-07</entry>
            <entry>DISTINCT quantifier</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>E101</entry>
            <entry>Basic data manipulation (FULL support)</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>E101-01</entry>
            <entry>INSERT statement</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>E101-03</entry>
            <entry>Searched UPDATE statement</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>E101-04</entry>
            <entry>Searched DELETE statement</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>E111</entry>
            <entry>Single row SELECT statement</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>E121</entry>
            <entry>Basic cursor support</entry>
            <entry>N (Cursors are not supported, no change in ..)</entry>
          </row>
          <row>
            <entry>E121-01</entry>
            <entry>DECLARE CURSOR</entry>
            <entry></entry>
          </row>
          <row>
            <entry>E121-02</entry>
            <entry>ORDER BY columns need not be in select list</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>E121-03</entry>
            <entry>Value expressions in ORDER BY clause</entry>
            <entry>N (should be checked)</entry>
          </row>
          <row>
            <entry>E121-04</entry>
            <entry>OPEN statement</entry>
            <entry>N</entry>
          </row>
          <row>
            <entry>E121-06</entry>
            <entry>Positioned UPDATE statement</entry>
            <entry>N</entry>
          </row>
          <row>
            <entry>E121-07</entry>
            <entry>Positioned DELETE statement</entry>
            <entry>N</entry>
          </row>
          <row>
            <entry>E121-08</entry>
            <entry>CLOSE statement</entry>
            <entry>N</entry>
          </row>
          <row>
            <entry>E121-10</entry>
            <entry>FETCH statement: implicit NEXT</entry>
            <entry>N</entry>
          </row>
          <row>
            <entry>E121-17</entry>
            <entry>WITH HOLD cursors</entry>
            <entry>N</entry>
          </row>
          <row>
            <entry>E131</entry>
            <entry>Null value support (nulls in lieu of values)</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>E141</entry>
            <entry>Basic integrity constraints</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>E141-01</entry>
            <entry>NOT NULL constraints</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>E141-02</entry>
            <entry>UNIQUE constraints of NOT NULL columns</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>E141-03</entry>
            <entry>PRIMARY KEY constraints</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>E141-04</entry>
            <entry>Basic FOREIGN KEY constraint with the NO ACTION default</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>E141-06</entry>
            <entry>CHECK constraints</entry>
            <entry>N</entry>
          </row>
          <row>
            <entry>E141-07</entry>
            <entry>Column defaults</entry>
            <entry>N</entry>
          </row>
          <row>
            <entry>E141-08</entry>
            <entry>NOT NULL inferred on PRIMARY KEY</entry>
            <entry>N</entry>
          </row>
          <row>
            <entry>E141-10</entry>
            <entry>Names in a foreign key can be specified in any order (columns should be in the proper order)</entry>
            <entry>N</entry>
          </row>
          <row>
            <entry>E151</entry>
            <entry>Transaction support</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>E151-01</entry>
            <entry>COMMIT statement</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>E151-02</entry>
            <entry>ROLLBACK statement</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>E152</entry>
            <entry>Basic SET TRANSACTION statement</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>E152-01</entry>
            <entry>SET TRANSACTION statement: ISOLATION LEVEL SERIALIZABLE clause</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>E152-02</entry>
            <entry>SET TRANSACTION statement: READ ONLY and READ WRITE clauses</entry>
            <entry>N</entry>
          </row>
          <row>
            <entry>E153</entry>
            <entry>Updatable queries with subqueries</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>E161</entry>
            <entry>SQL comments using leading double minus</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>E171</entry>
            <entry>SQLSTATE support</entry>
            <entry>N</entry>
          </row>
          <row>
            <entry>F021</entry>
            <entry>Basic information schema</entry>
            <entry>N</entry>
          </row>
          <row>
            <entry>F021-01</entry>
            <entry>COLUMNS view</entry>
            <entry></entry>
          </row>
          <row>
            <entry>F021-02</entry>
            <entry>TABLES view</entry>
          </row>
          <row>
            <entry>F021-03</entry>
            <entry>VIEWS view</entry>
          </row>
          <row>
            <entry>F021-04</entry>
            <entry>TABLE_CONSTRAINTS view</entry>
          </row>
          <row>
            <entry>F021-05</entry>
            <entry>REFERENTIAL_CONSTRAINTS view</entry>
          </row>
          <row>
            <entry>F021-06</entry>
            <entry>CHECK_CONSTRAINTS view</entry>
          </row>
          <row>
            <entry>F031</entry>
            <entry>Basic schema manipulation</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>F031-01</entry>
            <entry>CREATE TABLE statement to create persistent base tables</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>F031-02</entry>
            <entry>CREATE VIEW statement</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>F031-03</entry>
            <entry>GRANT statement</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>F031-04</entry>
            <entry>ALTER TABLE statement: ADD COLUMN clause</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>F031-13</entry>
            <entry>DROP TABLE statement: RESTRICT clause</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>F031-16</entry>
            <entry>DROP VIEW statement: RESTRICT clause</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>F031-19</entry>
            <entry>REVOKE statement: RESTRICT clause</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>F041</entry>
            <entry>Basic joined table</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>F041-01</entry>
            <entry>Inner join (but not necessarily the INNER keyword)</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>F041-02</entry>
            <entry>INNER keyword</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>F041-03</entry>
            <entry>LEFT OUTER JOIN</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>F041-04</entry>
            <entry>RIGHT OUTER JOIN</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>F041-05</entry>
            <entry>Outer joins can be nested</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>F041-07</entry>
            <entry>The inner table in a left or right outer join can also be used in an inner join</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>F041-08</entry>
            <entry>All comparison operators are supported (rather than just =)</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>F051</entry>
            <entry>Basic date and time</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>F051-01</entry>
            <entry>DATE data type (including DATE literal)</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>F051-02</entry>
            <entry>TIME data type (including TIME literal) with fractional seconds precision of 0</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>F051-03</entry>
            <entry>TIMESTAMP data type (including TIMESTAMP literal) with fractional seconds precision of 0 and 6</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>F051-04</entry>
            <entry>Comparison predicate on DATE, TIME, and TIMESTAMP data types</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>F051-05</entry>
            <entry>Explicit CAST between datetime types and character types</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>F051-06</entry>
            <entry>CURRENT_DATE</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>F051-07</entry>
            <entry>LOCALTIME</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>F051-08</entry>
            <entry>LOCALTIMESTAMP</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>F081</entry>
            <entry>UNION and EXCEPT in views</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>F131</entry>
            <entry>Grouped operations</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>F131-01</entry>
            <entry>WHERE, GROUP BY, and HAVING clauses supported in queries with grouped views</entry>
            <entry>S (could use a test!)</entry>
          </row>
          <row>
            <entry>F131-02</entry>
            <entry>Multiple tables supported in queries with grouped views</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>F131-03</entry>
            <entry>Set functions supported in queries with grouped views</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>F131-04</entry>
            <entry>Subqueries with GROUP BY and HAVING clauses and grouped views</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>F131-05</entry>
            <entry>Single row SELECT with GROUP BY and HAVING clauses and grouped views</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>F181</entry>
            <entry>Multiple module support</entry>
            <entry>N (limited support)</entry>
          </row>
          <row>
            <entry>F201</entry>
            <entry>CAST function</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>F221</entry>
            <entry>Explicit defaults</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>F261</entry>
            <entry>CASE expression</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>F261-01</entry>
            <entry>Simple CASE</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>F261-02</entry>
            <entry>Searched CASE</entry>
            <entry>N</entry>
          </row>
          <row>
            <entry>F261_03</entry>
            <entry>NULLIF</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>F261-04</entry>
            <entry>COALESCE</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>F311</entry>
            <entry>Schema definition statement</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>F311-01</entry>
            <entry>CREATE SCHEMA</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>F311-02</entry>
            <entry>CREATE TABLE for persistent base tables</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>F311-03</entry>
            <entry>CREATE VIEW</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>F311-04</entry>
            <entry>CREATE VIEW: WITH CHECK OPTION</entry>
            <entry>N</entry>
          </row>
          <row>
            <entry>F311-05</entry>
            <entry>GRANT statement</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>F471</entry>
            <entry>Scalar subquery values</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>F481</entry>
            <entry>Expanded NULL predicate</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>F501</entry>
            <entry>Features and conformance views</entry>
            <entry>N</entry>
          </row>
          <row>
            <entry>F501-01</entry>
            <entry>SQL_FEATURES view</entry>
            <entry></entry>
          </row>
          <row>
            <entry>F501-02</entry>
            <entry>SQL_SIZING view</entry>
          </row>
          <row>
            <entry>F501-03</entry>
            <entry>SQL_LANGUAGES view</entry>
          </row>
          <row>
            <entry>F812</entry>
            <entry>Basic flagging</entry>
            <entry>N</entry>
          </row>
          <row>
            <entry>S011</entry>
            <entry>Distinct data types</entry>
            <entry>S</entry>
          </row>
          <row>
            <entry>S011-01</entry>
            <entry>USER_DEFINED_TYPES view</entry>
            <entry>N</entry>
          </row>
          <row>
            <entry>T321</entry>
            <entry>Basic SQL-invoked routines</entry>
            <entry>N</entry>
          </row>
          <row>
            <entry>T321-01</entry>
            <entry>User-defined functions with no overloading</entry>
            <entry>N</entry>
          </row>
          <row>
            <entry>T321-02</entry>
            <entry>User-defined stored procedures with no overloading</entry>
            <entry>N</entry>
          </row>
          <row>
            <entry>T321-03</entry>
            <entry>Function invocation</entry>
            <entry>N</entry>
          </row>
          <row>
            <entry>T321-04</entry>
            <entry>CALL statement</entry>
            <entry>N</entry>
          </row>
          <row>
            <entry>T321-05</entry>
            <entry>RETURN statement</entry>
            <entry>N</entry>
          </row>
          <row>
            <entry>T321-06</entry>
            <entry>ROUTINES view</entry>
            <entry>N</entry>
          </row>
          <row>
            <entry>T321-07</entry>
            <entry>PARAMETERS view</entry>
            <entry>N</entry>
          </row>
        </tbody>
      </multitable>
    </appendix>
  </node>
  <node>
    <nodename>MAL Syntax</nodename>
    <nodenext>Conversion of MIL Programs</nodenext>
    <nodeprev>SQL 1999 Features</nodeprev>
    <nodeup>Appendices</nodeup>
    <appendix>
      <title>MAL syntax summary</title>
      <para>The MAL syntax is summarized below in extended BNF. Alternative constructs are seperated by | and grouped by parenthesis. Optional parts are marked with square brackets. A repetition is marked with either '+' or '*' to indicate at least once and many times, respectively. Lexical tokens are illustrated in small capitals.</para>
      <multitable>
        <columnfraction>15</columnfraction>
        <columnfraction>80</columnfraction>
        <tbody>
          <row>
            <entry>program</entry>
            <entry>: (statement ';') *</entry>
          </row>
          <row>
            <entry>statement</entry>
            <entry>: moduleStmt [helpinfo] | definition [helpinfo]</entry>
          </row>
          <row>
            <entry></entry>
            <entry>| includeStmt | stmt</entry>
          </row>
          <row>
            <entry>moduleStmt</entry>
            <entry>:  <code> MODULE</code> ident | <code> ATOM</code> ident [':'ident]</entry>
          </row>
          <row>
            <entry>includeStmt</entry>
            <entry>: <code> INCLUDE</code> identifier |  <code> INCLUDE</code> string_literal</entry>
          </row>
          <row>
            <entry>definition</entry>
            <entry>: <code> COMMAND </code> header <code> ADDRESS </code> identifier</entry>
          </row>
          <row>
            <entry></entry>
            <entry>| <code>PATTERN </code> header <code>ADDRESS</code>  identifier</entry>
          </row>
          <row>
            <entry></entry>
            <entry>|  <code> FUNCTION </code> header statement* <code> END </code> identifier</entry>
          </row>
          <row>
            <entry></entry>
            <entry>|  <code> FACTORY </code> header statement* <code> END </code> identifier</entry>
          </row>
          <row>
            <entry>helpinfo</entry>
            <entry>: <code> COMMENT</code> string_literal</entry>
          </row>
          <row>
            <entry>header</entry>
            <entry>: [ moduelName '.'] name '(' params ')' result</entry>
          </row>
          <row>
            <entry>result</entry>
            <entry>: paramType | '(' params ')'</entry>
          </row>
          <row>
            <entry>params</entry>
            <entry>: binding [',' binding]*</entry>
          </row>
          <row>
            <entry>binding</entry>
            <entry>: identifier typeName [ props ]</entry>
          </row>
          <row>
            <entry>typeName</entry>
            <entry>: scalarType | collectionType | ':' <code> ANY</code> ['_' digit]</entry>
          </row>
          <row>
            <entry>scalarType</entry>
            <entry>: ':' <code> identifier</code></entry>
          </row>
          <row>
            <entry>collectionType</entry>
            <entry>: ':' <code> BAT</code> ['[' colType ',' colType ']']</entry>
          </row>
          <row>
            <entry>colType</entry>
            <entry>: scalarType | anyType</entry>
          </row>
          <row>
            <entry>props</entry>
            <entry>: '{' property [ ',' property]* '}'</entry>
          </row>
          <row>
            <entry>property</entry>
            <entry>: identifier [ compare literal]</entry>
          </row>
          <row>
            <entry>compare</entry>
            <entry>: '=' | '&lt;' | '&lt;=' | '&gt;' | '&gt;=' | '!='</entry>
          </row>
          <row>
            <entry>stmt</entry>
            <entry>: [tag] varlist [':=' expr ]</entry>
          </row>
          <row>
            <entry>tag</entry>
            <entry>|  <code> RETURN</code> | <code> BARRIER</code> | <code> CATCH</code> |  <code> LEAVE</code> | <code> REDO</code> | <code>RAISE</code></entry>
          </row>
          <row>
            <entry>varlist</entry>
            <entry>: variable |  '(' variable [',' variable ] * ')'</entry>
          </row>
          <row>
            <entry>variable</entry>
            <entry>: identifier [ props ]</entry>
          </row>
          <row>
            <entry>expr</entry>
            <entry>: fcncall | [factor  operator] factor</entry>
          </row>
          <row>
            <entry>factor</entry>
            <entry>:  <code> literal_constant</code> | <code> nil</code> | var</entry>
          </row>
          <row>
            <entry>fcncall</entry>
            <entry>: moduleName '.' name '(' [args] ')'</entry>
          </row>
          <row>
            <entry>args</entry>
            <entry>: factor [',' factor]*</entry>
          </row>
        </tbody>
      </multitable>
      <example xml:space="preserve"></example>
    </appendix>
  </node>
  <node>
    <nodename>Conversion of MIL Programs</nodename>
    <nodenext>MAL Instruction Overview</nodenext>
    <nodeprev>MAL Syntax</nodeprev>
    <nodeup>Appendices</nodeup>
    <appendix>
      <title>Conversion of MIL programs</title>
      <section>
        <title>MIL compilation</title>
        <para>MonetDB comes with its programming language called MIL (Monet Interface Language). A large collection of MIL programs exists, which ideally should run without problems on the MonetDB version 5 Kernel. Unfortunately, life isn;t that easy. MIL was designed as a half-backed scripting language with dynamic typing, variable re-use with different types, little support for debugging, and permissive syntax. Furthermore, the compiler was intimately coupled with the runtime system, e.g. an identifier was immediately resolved against the modules being loaded and variables known within the prevaling scope. This was necessary to resolve their context dependent interpretation.</para>
        <para>In MonetDB Version 4 a cleanup of MIL has already taken place which strikes a balance between forcing users to migrate to MAL and to continue using their MIL code base. It is realized with a minimalistic compiler, which produces MAL code for a large fragment of the MIL language. There is, however, no information on the runtime status. In particular, it means there is no knowledge on pre-existing variables, type names, procedures, etc..</para>
        <para>With a little care many MIL programs can be compiled and run against the new kernel. The MonetDB test suites and predefined MIL proc's have been used to define the language boundary to be supported.</para>
        <para>In writing MIL code, the following rules should be kept obeyed:</para>
        <itemize>
          <itemfunction><bullet/></itemfunction>
          <item>
            <para>do not change the type of variables within their scope.</para>
          </item>
          <item>
            <para>do not use type identifiers as ordinary variables</para>
          </item>
          <item>
            <para>properly type a new variable when it is initialized with nil, e.g.  nil:int</para>
          </item>
        </itemize>
        <para>Consider the following old MIL program stored in the file <emph>my.mil</emph></para>
        <verbatim xml:space="preserve"><![CDATA[
proc hello(str s):void { s.print(); }
]]></verbatim>
        <para>The migration step involves loading the <code>mil</code> module, whereafter the file can be compiled.</para>
        <example xml:space="preserve">&gt;include mil;
&gt;mil.compile("my.mil");
function hello(s:str):void;
    _3 := io.print(s);
end hello;</example>
      </section>

      <section>
        <title>Conversion Pitfalls</title>
        <para>In this section we summarize the pitfalls and limitations encountered in using the MIL to MAL compiler.</para>
        <para><strong>Name spaces</strong>. The naming of functions has undergone a clean up action. Part of this name re-casting is dealt with in a transparent way for the user.</para>
        <para><strong>Multiplex operations</strong>. One of the old key features dropped is the generic multiplex operation. Although this language construct was dealt with rather efficiently in the MIL interpreter, we have opted for a more mundane approach. The multiplex operations were mostly used in the context of arithmetic expressions and coercions over BATs. In particular, those that have a <code>:void</code> head.</para>
        <para>These operations are now directly supported by C implementations in the modules <code>batcalc, batstr, batmath, batcolor</code>. The generic case is still available in the form of a optimizer request, i.e. <code>optimizer.multiplex(S,A1,...,An)</code><space/>The first argument should be a string literal that denotes the element operation over the remaining arguments. The optimzier bakes an interator block to produce the required result.</para>
        <para>Beware, in the older version the semantics of the multiplex was based on join semantics over the head of the argument BATs. This has been dropped as well.</para>
        <para><strong>Signature changes</strong>. Aside from syntax restrictions imposed, several command signatures and command names have been changed. They have to translated partly by hand or the MIL program should be prepared for a proper translation.</para>
        <para>For example, the BAT update routines do not return their target variable. This means you can not cascade a series of calls, e.g. the statement</para>
        <example xml:space="preserve"> a.select(1,2).access(BAT_WRITE).rename("C");
 b.insert(0,1).insert(1,2);</example>
        <para>should be split into multiple steps as follows:</para>
        <example xml:space="preserve"> a.select(1,2); a.access(BAT_WRITE); a.rename("C");
 b.insert(0,1); b.insert(1,2);</example>
        <para><strong>Runtime dependencies</strong>. A major rewrite of the MIL program is required when it inspects the runtime environment. See the bbp and inspection modules for information on the operations available.</para>
        <example xml:space="preserve"></example>
      </section>
    </appendix>
  </node>
  <node>
    <nodename>MAL Instruction Overview</nodename>
    <nodenext>MAL Instruction Help</nodenext>
    <nodeprev>Conversion of MIL Programs</nodeprev>
    <nodeup>Appendices</nodeup>
    <appendix>
      <title>MAL Instruction Overview</title>
      <para>The table below gives a condensed overview of the operations defined in each of the modules. Further details can be obtained using the MAL commandline interface (See tobedone).</para>
      <multitable>
        <columnfraction>24</columnfraction>
        <columnfraction>24</columnfraction>
        <columnfraction>24</columnfraction>
        <columnfraction>24</columnfraction>
        <tbody>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>aggr.avg</entry>
            <entry> aggr.max</entry>
            <entry> aggr.prod</entry>
            <entry> aggr.size</entry>
          </row>
          <row>
            <entry>aggr.count</entry>
            <entry> aggr.min</entry>
            <entry> aggr.product</entry>
            <entry> aggr.sum</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>alarm.alarm</entry>
            <entry> alarm.epoch</entry>
            <entry> alarm.time</entry>
          </row>
          <row>
            <entry>alarm.ctime</entry>
            <entry> alarm.prelude</entry>
            <entry> alarm.timers</entry>
          </row>
          <row>
            <entry>alarm.epilogue</entry>
            <entry> alarm.sleep</entry>
            <entry> alarm.usec</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>algebra.bandjoin</entry>
            <entry> algebra.hashsplit</entry>
            <entry> aggr.min</entry>
            <entry> algebra.sortT</entry>
          </row>
          <row>
            <entry>algebra.between</entry>
            <entry> algebra.histogram</entry>
            <entry> algebra.number</entry>
            <entry> algebra.sortTH</entry>
          </row>
          <row>
            <entry>algebra.betweenCO</entry>
            <entry> algebra.indexjoin</entry>
            <entry> algebra.outercrossproduct</entry>
            <entry> algebra.split</entry>
          </row>
          <row>
            <entry>algebra.betweenOC</entry>
            <entry> algebra.intersect</entry>
            <entry> algebra.outerjoin</entry>
            <entry> algebra.sum</entry>
          </row>
          <row>
            <entry>algebra.betweenOO</entry>
            <entry> algebra.join</entry>
            <entry> algebra.position</entry>
            <entry> algebra.sunion</entry>
          </row>
          <row>
            <entry>algebra.cardinality</entry>
            <entry> algebra.joinPath</entry>
            <entry> algebra.product</entry>
            <entry> algebra.sunique</entry>
          </row>
          <row>
            <entry>algebra.copy</entry>
            <entry> algebra.kdiff</entry>
            <entry> algebra.project</entry>
            <entry> algebra.thetajoin</entry>
          </row>
          <row>
            <entry>aggr.count</entry>
            <entry> algebra.kintersect</entry>
            <entry> algebra.sample</entry>
            <entry> algebra.topN</entry>
          </row>
          <row>
            <entry>aggr.count_no_nil</entry>
            <entry> algebra.kunion</entry>
            <entry> algebra.sdifference</entry>
            <entry> algebra.tunique</entry>
          </row>
          <row>
            <entry>algebra.difference</entry>
            <entry> algebra.kunique</entry>
            <entry> algebra.select</entry>
            <entry> algebra.uhashsplit</entry>
          </row>
          <row>
            <entry>algebra.exist</entry>
            <entry> algebra.like</entry>
            <entry> algebra.selectH</entry>
            <entry> algebra.union</entry>
          </row>
          <row>
            <entry>algebra.fetch</entry>
            <entry> algebra.markH</entry>
            <entry> algebra.semijoin</entry>
            <entry> algebra.unique</entry>
          </row>
          <row>
            <entry>algebra.fetchjoin</entry>
            <entry> algebra.markT</entry>
            <entry> algebra.sintersect</entry>
            <entry> algebra.uselect</entry>
          </row>
          <row>
            <entry>algebra.find</entry>
            <entry> aggr.max</entry>
            <entry> algebra.slice</entry>
          </row>
          <row>
            <entry>algebra.fragment</entry>
            <entry> algebra.merge</entry>
            <entry> algebra.sort</entry>
          </row>
          <row>
            <entry>algebra.hashjoin</entry>
            <entry> algebra.mergejoin</entry>
            <entry> algebra.sortHT</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>array.grid</entry>
            <entry> array.print</entry>
            <entry> array.product</entry>
            <entry> array.project</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>bat.append</entry>
            <entry> bat.hasReadMode</entry>
            <entry> bat.new</entry>
            <entry> bat.setMemoryAdvise</entry>
          </row>
          <row>
            <entry>bat.delete</entry>
            <entry> bat.hasWriteMode</entry>
            <entry> bat.pack</entry>
            <entry> bat.setMemoryMap</entry>
          </row>
          <row>
            <entry>bat.getAccess</entry>
            <entry> bat.info</entry>
            <entry> bat.replace</entry>
            <entry> bat.setName</entry>
          </row>
          <row>
            <entry>bat.getAlpha</entry>
            <entry> bat.insert</entry>
            <entry> bat.reverse</entry>
            <entry> bat.setPersistent</entry>
          </row>
          <row>
            <entry>bat.getBatSize</entry>
            <entry> bat.isCached</entry>
            <entry> bat.revert</entry>
            <entry> bat.setReadMode</entry>
          </row>
          <row>
            <entry>bat.getCapacity</entry>
            <entry> bat.isPersistent</entry>
            <entry> bat.save</entry>
            <entry> bat.setRole</entry>
          </row>
          <row>
            <entry>bat.getDelta</entry>
            <entry> bat.isSorted</entry>
            <entry> bat.setAccess</entry>
            <entry> bat.setSequenceBase</entry>
          </row>
          <row>
            <entry>bat.getHeadType</entry>
            <entry> bat.isSortedReverse</entry>
            <entry> bat.setAppendMode</entry>
            <entry> bat.setSet</entry>
          </row>
          <row>
            <entry>bat.getHeat</entry>
            <entry> bat.isSynced</entry>
            <entry> bat.setCold</entry>
            <entry> bat.setSorted</entry>
          </row>
          <row>
            <entry>bat.getName</entry>
            <entry> bat.isTransient</entry>
            <entry> bat.setColumn</entry>
            <entry> bat.setTransient</entry>
          </row>
          <row>
            <entry>bat.getRole</entry>
            <entry> bat.isaKey</entry>
            <entry> bat.setGarbage</entry>
            <entry> bat.setWriteMode</entry>
          </row>
          <row>
            <entry>bat.getSequenceBase</entry>
            <entry> bat.isaSet</entry>
            <entry> bat.setHash</entry>
            <entry> bat.unload</entry>
          </row>
          <row>
            <entry>bat.getTailType</entry>
            <entry> bat.load</entry>
            <entry> bat.setHot</entry>
            <entry> bat.unpack</entry>
          </row>
          <row>
            <entry>bat.hasAppendMode</entry>
            <entry> bat.mirror</entry>
            <entry> bat.setKey</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>batcalc.!=</entry>
            <entry> batcalc./</entry>
            <entry> batcalc.dbl</entry>
            <entry> batcalc.not</entry>
          </row>
          <row>
            <entry>batcalc.%</entry>
            <entry> batcalc.&lt;</entry>
            <entry> batcalc.flt</entry>
            <entry> batcalc.oid</entry>
          </row>
          <row>
            <entry>batcalc.*</entry>
            <entry> batcalc.&lt;=</entry>
            <entry> batcalc.ifthen</entry>
            <entry> batcalc.or</entry>
          </row>
          <row>
            <entry>batcalc.+</entry>
            <entry> batcalc.==</entry>
            <entry> batcalc.ifthenelse</entry>
            <entry> batcalc.project</entry>
          </row>
          <row>
            <entry>batcalc.++</entry>
            <entry> batcalc.&gt;</entry>
            <entry> batcalc.init</entry>
            <entry> batcalc.sht</entry>
          </row>
          <row>
            <entry>batcalc.-</entry>
            <entry> batcalc.&gt;=</entry>
            <entry> batcalc.int</entry>
            <entry> batcalc.xor</entry>
          </row>
          <row>
            <entry>batcalc.<ndash/></entry>
            <entry> batcalc.and</entry>
            <entry> batcalc.lng</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>batcolor.blue</entry>
            <entry> batcolor.green</entry>
            <entry> batcolor.red</entry>
            <entry> batcolor.value</entry>
          </row>
          <row>
            <entry>batcolor.cb</entry>
            <entry> batcolor.hsv</entry>
            <entry> batcolor.rgb</entry>
          </row>
          <row>
            <entry>batcolor.color</entry>
            <entry> batcolor.hue</entry>
            <entry> batcolor.saturation</entry>
          </row>
          <row>
            <entry>batcolor.cr</entry>
            <entry> batcolor.luminance</entry>
            <entry> batcolor.str</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>batmath.acos</entry>
            <entry> batmath.cos</entry>
            <entry> batmath.fmod</entry>
            <entry> batmath.sinh</entry>
          </row>
          <row>
            <entry>batmath.asin</entry>
            <entry> batmath.cosh</entry>
            <entry> batmath.log</entry>
            <entry> batmath.sqrt</entry>
          </row>
          <row>
            <entry>batmath.atan</entry>
            <entry> batmath.exp</entry>
            <entry> batmath.log10</entry>
            <entry> batmath.tan</entry>
          </row>
          <row>
            <entry>batmath.atan2</entry>
            <entry> batmath.fabs</entry>
            <entry> batmath.pow</entry>
            <entry> batmath.tanh</entry>
          </row>
          <row>
            <entry>batmath.ceil</entry>
            <entry> batmath.floor</entry>
            <entry> batmath.sin</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>batstr.+</entry>
            <entry> batstr.length</entry>
            <entry> batstr.search</entry>
            <entry> batstr.toLower</entry>
          </row>
          <row>
            <entry>batstr.==</entry>
            <entry> batstr.ltrim</entry>
            <entry> batstr.startsWith</entry>
            <entry> batstr.toUpper</entry>
          </row>
          <row>
            <entry>batstr.bytes</entry>
            <entry> batstr.match</entry>
            <entry> batstr.str</entry>
            <entry> batstr.trim</entry>
          </row>
          <row>
            <entry>batstr.chrAt</entry>
            <entry> batstr.r_search</entry>
            <entry> batstr.string</entry>
            <entry> batstr.unicodeAt</entry>
          </row>
          <row>
            <entry>batstr.endsWith</entry>
            <entry> batstr.rtrim</entry>
            <entry> batstr.substitute</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>bbp.bind</entry>
            <entry> bbp.getDirty</entry>
            <entry> bbp.getNames</entry>
            <entry> bbp.open</entry>
          </row>
          <row>
            <entry>bbp.close</entry>
            <entry> bbp.getHeadType</entry>
            <entry> bbp.getObjects</entry>
            <entry> bbp.prelude</entry>
          </row>
          <row>
            <entry>bbp.commit</entry>
            <entry> bbp.getHeat</entry>
            <entry> bbp.getRNames</entry>
            <entry> bbp.release</entry>
          </row>
          <row>
            <entry>bbp.deposit</entry>
            <entry> bbp.getKind</entry>
            <entry> bbp.getRefCount</entry>
            <entry> bbp.releaseAll</entry>
          </row>
          <row>
            <entry>bbp.destroy</entry>
            <entry> bbp.getLRefCount</entry>
            <entry> bbp.getStatus</entry>
            <entry> bbp.take</entry>
          </row>
          <row>
            <entry>bbp.discard</entry>
            <entry> bbp.getLocation</entry>
            <entry> bbp.getTailType</entry>
            <entry> bbp.toString</entry>
          </row>
          <row>
            <entry>bbp.getCount</entry>
            <entry> bbp.getName</entry>
            <entry> bbp.iterator</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>blob.nitems</entry>
            <entry> blob.null</entry>
            <entry> blob.toblob</entry>
            <entry> blob.tostring</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>box.close</entry>
            <entry> box.discard</entry>
            <entry> box.open</entry>
            <entry> box.take</entry>
          </row>
          <row>
            <entry>box.deposit</entry>
            <entry> box.getBoxNames</entry>
            <entry> box.release</entry>
            <entry> box.toString</entry>
          </row>
          <row>
            <entry>box.destroy</entry>
            <entry> box.iterator</entry>
            <entry> box.releaseAll</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>bstream.create</entry>
            <entry> bstream.destroy</entry>
            <entry> bstream.read</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>calc.!=</entry>
            <entry> calc.&gt;=</entry>
            <entry> calc.getBATidentifier</entry>
            <entry> calc.oid</entry>
          </row>
          <row>
            <entry>calc.%</entry>
            <entry> calc.&gt;&gt;</entry>
            <entry> calc.ifthenelse</entry>
            <entry> calc.or</entry>
          </row>
          <row>
            <entry>calc.*</entry>
            <entry> calc.abs</entry>
            <entry> calc.int</entry>
            <entry> calc.ptr</entry>
          </row>
          <row>
            <entry>calc.+</entry>
            <entry> calc.and</entry>
            <entry> calc.inv</entry>
            <entry> calc.setoid</entry>
          </row>
          <row>
            <entry>calc.-</entry>
            <entry> calc.bat</entry>
            <entry> calc.isnil</entry>
            <entry> calc.sht</entry>
          </row>
          <row>
            <entry>calc./</entry>
            <entry> calc.between</entry>
            <entry> calc.isnotnil</entry>
            <entry> calc.str</entry>
          </row>
          <row>
            <entry>calc.&lt;</entry>
            <entry> calc.bit</entry>
            <entry> calc.lng</entry>
            <entry> calc.void</entry>
          </row>
          <row>
            <entry>calc.&lt;&lt;</entry>
            <entry> calc.chr</entry>
            <entry> calc.max</entry>
            <entry> calc.xor</entry>
          </row>
          <row>
            <entry>calc.&lt;=</entry>
            <entry> calc.dbl</entry>
            <entry> calc.min</entry>
          </row>
          <row>
            <entry>calc.==</entry>
            <entry> calc.flt</entry>
            <entry> calc.newoid</entry>
          </row>
          <row>
            <entry>calc.&gt;</entry>
            <entry> calc.getBAT</entry>
            <entry> calc.not</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>chop.getHead</entry>
            <entry> chop.hasMoreChunks</entry>
            <entry> chop.newChunkIterator</entry>
          </row>
          <row>
            <entry>chop.getTail</entry>
            <entry> chop.hasMoreElements</entry>
            <entry> chop.newIterator</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>clients.clearDebug</entry>
            <entry> clients.getLogins</entry>
            <entry> clients.quit</entry>
            <entry> clients.setListing</entry>
          </row>
          <row>
            <entry>clients.getId</entry>
            <entry> clients.getScenario</entry>
            <entry> clients.setDebug</entry>
            <entry> clients.setScenario</entry>
          </row>
          <row>
            <entry>clients.getInfo</entry>
            <entry> clients.getUsers</entry>
            <entry> clients.setHistory</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>color.blue</entry>
            <entry> color.green</entry>
            <entry> color.print</entry>
            <entry> color.saturation</entry>
          </row>
          <row>
            <entry>color.cb</entry>
            <entry> color.hsv</entry>
            <entry> color.printf</entry>
            <entry> color.str</entry>
          </row>
          <row>
            <entry>color.color</entry>
            <entry> color.hue</entry>
            <entry> color.red</entry>
            <entry> color.value</entry>
          </row>
          <row>
            <entry>color.cr</entry>
            <entry> color.luminance</entry>
            <entry> color.rgb</entry>
            <entry> color.ycc</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>const.close</entry>
            <entry> const.discard</entry>
            <entry> const.open</entry>
            <entry> const.releaseAll</entry>
          </row>
          <row>
            <entry>const.deposit</entry>
            <entry> const.hasMoreElements</entry>
            <entry> const.prelude</entry>
            <entry> const.take</entry>
          </row>
          <row>
            <entry>const.destroy</entry>
            <entry> const.newIterator</entry>
            <entry> const.release</entry>
            <entry> const.toString</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>crackers.crack</entry>
            <entry> crackers.getPiece</entry>
            <entry> crackers.new</entry>
            <entry> crackers.selectPieces</entry>
          </row>
          <row>
            <entry>crackers.drop</entry>
            <entry> crackers.hasMoreElements</entry>
            <entry> crackers.newIterator</entry>
          </row>
          <row>
            <entry>crackers.dropView</entry>
            <entry> crackers.info</entry>
            <entry> crackers.select</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>date.!=</entry>
            <entry> date.&lt;=</entry>
            <entry> date.&gt;</entry>
            <entry> date.isnil</entry>
          </row>
          <row>
            <entry>date.&lt;</entry>
            <entry> date.=</entry>
            <entry> date.&gt;=</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>daytime.!=</entry>
            <entry> daytime.&lt;=</entry>
            <entry> daytime.&gt;</entry>
            <entry> daytime.isnil</entry>
          </row>
          <row>
            <entry>daytime.&lt;</entry>
            <entry> daytime.=</entry>
            <entry> daytime.&gt;=</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>factory.getCaller</entry>
            <entry> factory.getOwners</entry>
            <entry> factory.getTimeStampIn</entry>
            <entry> factory.setLocation</entry>
          </row>
          <row>
            <entry>factory.getLocations</entry>
            <entry> factory.getPlants</entry>
            <entry> factory.getTimeStampOut</entry>
            <entry> factory.shutdown</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>group.avg</entry>
            <entry> group.max</entry>
            <entry> group.refine</entry>
          </row>
          <row>
            <entry>group.count</entry>
            <entry> group.min</entry>
            <entry> group.size</entry>
          </row>
          <row>
            <entry>group.group</entry>
            <entry> group.prelude</entry>
            <entry> group.sum</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>inspect.getAtomNames</entry>
            <entry> inspect.getDefinition</entry>
            <entry> inspect.getModule</entry>
            <entry> inspect.getTypeName</entry>
          </row>
          <row>
            <entry>inspect.getAtomSizes</entry>
            <entry> inspect.getFunction</entry>
            <entry> inspect.getSignature</entry>
          </row>
          <row>
            <entry>inspect.getAtomSuperNames</entry>
            <entry> inspect.getKind</entry>
            <entry> inspect.getType</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>io.export</entry>
            <entry> io.print</entry>
            <entry> io.prompt</entry>
            <entry> io.stdout</entry>
          </row>
          <row>
            <entry>io.ftable</entry>
            <entry> io.printf</entry>
            <entry> io.stderr</entry>
            <entry> io.table</entry>
          </row>
          <row>
            <entry>io.import</entry>
            <entry> io.printft</entry>
            <entry> io.stdin</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>lock.create</entry>
            <entry> lock.set</entry>
            <entry> lock.try</entry>
          </row>
          <row>
            <entry>lock.destroy</entry>
            <entry> lock.tostr</entry>
            <entry> lock.unset</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>mal.assert</entry>
            <entry> mal.newRange</entry>
            <entry> mal.raise</entry>
            <entry> mal.source</entry>
          </row>
          <row>
            <entry>mal.call</entry>
            <entry> mal.nextElement</entry>
            <entry> mal.register</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>manual.create</entry>
            <entry> manual.createHelp</entry>
            <entry> manual.createOverview</entry>
            <entry> manual.help</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>mapi.epilogue</entry>
            <entry> mapi.listen_ssl</entry>
            <entry> mapi.resume</entry>
            <entry> mapi.suspend</entry>
          </row>
          <row>
            <entry>mapi.listen</entry>
            <entry> mapi.prelude</entry>
            <entry> mapi.stop</entry>
            <entry> mapi.trace</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>mdb.List</entry>
            <entry> mdb.getExceptionVariable</entry>
            <entry> mdb.inspect</entry>
            <entry> mdb.setTrace</entry>
          </row>
          <row>
            <entry>mdb.getDefinition</entry>
            <entry> mdb.getStackDepth</entry>
            <entry> mdb.list</entry>
            <entry> mdb.start</entry>
          </row>
          <row>
            <entry>mdb.getExceptionContext</entry>
            <entry> mdb.getStackFrame</entry>
            <entry> mdb.setCatch</entry>
            <entry> mdb.stop</entry>
          </row>
          <row>
            <entry>mdb.getExceptionReason</entry>
            <entry> mdb.getStackTrace</entry>
            <entry> mdb.setTimer</entry>
            <entry> mdb.var</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>mmath.acos</entry>
            <entry> mmath.exp</entry>
            <entry> mmath.log</entry>
            <entry> mmath.sqrt</entry>
          </row>
          <row>
            <entry>mmath.asin</entry>
            <entry> mmath.fabs</entry>
            <entry> mmath.log10</entry>
            <entry> mmath.srand</entry>
          </row>
          <row>
            <entry>mmath.atan</entry>
            <entry> mmath.finite</entry>
            <entry> mmath.pow</entry>
            <entry> mmath.tan</entry>
          </row>
          <row>
            <entry>mmath.atan2</entry>
            <entry> mmath.floor</entry>
            <entry> mmath.rand</entry>
            <entry> mmath.tanh</entry>
          </row>
          <row>
            <entry>mmath.ceil</entry>
            <entry> mmath.fmod</entry>
            <entry> mmath.round</entry>
          </row>
          <row>
            <entry>mmath.cos</entry>
            <entry> mmath.isinf</entry>
            <entry> mmath.sin</entry>
          </row>
          <row>
            <entry>mmath.cosh</entry>
            <entry> mmath.isnan</entry>
            <entry> mmath.sinh</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>mtime.add</entry>
            <entry> mtime.date_sub_sec_interval</entry>
            <entry> mtime.milliseconds</entry>
            <entry> mtime.start_dst</entry>
          </row>
          <row>
            <entry>mtime.adddays</entry>
            <entry> mtime.day</entry>
            <entry> mtime.minutes</entry>
            <entry> mtime.time_synonyms</entry>
          </row>
          <row>
            <entry>mtime.addmonths</entry>
            <entry> mtime.dayname</entry>
            <entry> mtime.month</entry>
            <entry> mtime.timestamp</entry>
          </row>
          <row>
            <entry>mtime.addyears</entry>
            <entry> mtime.daynum</entry>
            <entry> mtime.monthname</entry>
            <entry> mtime.timezone</entry>
          </row>
          <row>
            <entry>mtime.compute</entry>
            <entry> mtime.dayofweek</entry>
            <entry> mtime.monthnum</entry>
            <entry> mtime.tzone</entry>
          </row>
          <row>
            <entry>mtime.current_date</entry>
            <entry> mtime.dayofyear</entry>
            <entry> mtime.msecs</entry>
            <entry> mtime.tzone_local</entry>
          </row>
          <row>
            <entry>mtime.current_time</entry>
            <entry> mtime.daytime</entry>
            <entry> mtime.olddate</entry>
            <entry> mtime.weekday</entry>
          </row>
          <row>
            <entry>mtime.current_timestamp</entry>
            <entry> mtime.diff</entry>
            <entry> mtime.oldduration</entry>
            <entry> mtime.weekofyear</entry>
          </row>
          <row>
            <entry>mtime.date</entry>
            <entry> mtime.dst</entry>
            <entry> mtime.prelude</entry>
            <entry> mtime.year</entry>
          </row>
          <row>
            <entry>mtime.date_add_month_interval</entry>
            <entry> mtime.end_dst</entry>
            <entry> mtime.rule</entry>
          </row>
          <row>
            <entry>mtime.date_add_sec_interval</entry>
            <entry> mtime.hours</entry>
            <entry> mtime.seconds</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>optimizer.aliasRemoval</entry>
            <entry> optimizer.emptySet</entry>
            <entry> optimizer.multiplex</entry>
            <entry> optimizer.setDebug</entry>
          </row>
          <row>
            <entry>optimizer.clrDebug</entry>
            <entry> optimizer.expressionAccumulation</entry>
            <entry> optimizer.optimize</entry>
            <entry> optimizer.showFlowGraph</entry>
          </row>
          <row>
            <entry>optimizer.commonExpressionRemoval</entry>
            <entry> optimizer.factorize</entry>
            <entry> optimizer.partitionedQuery</entry>
            <entry> optimizer.showPlan</entry>
          </row>
          <row>
            <entry>optimizer.costEstimation</entry>
            <entry> optimizer.garbageCollector</entry>
            <entry> optimizer.peephole</entry>
            <entry> optimizer.singleton</entry>
          </row>
          <row>
            <entry>optimizer.deadCodeRemoval</entry>
            <entry> optimizer.macroContraction</entry>
            <entry> optimizer.prelude</entry>
            <entry> optimizer.strengthReduction</entry>
          </row>
          <row>
            <entry>optimizer.dumpQEP</entry>
            <entry> optimizer.macroExpansion</entry>
            <entry> optimizer.reduce</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>partitions.close</entry>
            <entry> partitions.discard</entry>
            <entry> partitions.insert</entry>
            <entry> partitions.releaseAll</entry>
          </row>
          <row>
            <entry>partitions.compress</entry>
            <entry> partitions.dump</entry>
            <entry> partitions.newIterator</entry>
            <entry> partitions.setCapacity</entry>
          </row>
          <row>
            <entry>partitions.delete</entry>
            <entry> partitions.getLastPartition</entry>
            <entry> partitions.open</entry>
            <entry> partitions.take</entry>
          </row>
          <row>
            <entry>partitions.deposit</entry>
            <entry> partitions.getRange</entry>
            <entry> partitions.prelude</entry>
            <entry> partitions.toString</entry>
          </row>
          <row>
            <entry>partitions.destroy</entry>
            <entry> partitions.hasMoreElements</entry>
            <entry> partitions.release</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>pcre.compile</entry>
            <entry> pcre.null</entry>
            <entry> pcre.uselect</entry>
          </row>
          <row>
            <entry>pcre.match</entry>
            <entry> pcre.select</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>profiler.activate</entry>
            <entry> profiler.dumpTrace</entry>
            <entry> profiler.setEndPoint</entry>
            <entry> profiler.setStartPoint</entry>
          </row>
          <row>
            <entry>profiler.clearTrace</entry>
            <entry> profiler.getTrace</entry>
            <entry> profiler.setFilter</entry>
            <entry> profiler.start</entry>
          </row>
          <row>
            <entry>profiler.closeStream</entry>
            <entry> profiler.openStream</entry>
            <entry> profiler.setNone</entry>
            <entry> profiler.startTrace</entry>
          </row>
          <row>
            <entry>profiler.clrFilter</entry>
            <entry> profiler.setAll</entry>
            <entry> profiler.setOfflineProfiling</entry>
            <entry> profiler.stop</entry>
          </row>
          <row>
            <entry>profiler.deactivate</entry>
            <entry> profiler.setCachedProfiling</entry>
            <entry> profiler.setOnlineProfiling</entry>
            <entry> profiler.stopTrace</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>rule.define</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>sema.create</entry>
            <entry> sema.destroy</entry>
            <entry> sema.down</entry>
            <entry> sema.up</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>statistics.close</entry>
            <entry> statistics.getCount</entry>
            <entry> statistics.getSize</entry>
            <entry> statistics.releaseAll</entry>
          </row>
          <row>
            <entry>statistics.deposit</entry>
            <entry> statistics.getHistogram</entry>
            <entry> statistics.hasMoreElements</entry>
            <entry> statistics.take</entry>
          </row>
          <row>
            <entry>statistics.destroy</entry>
            <entry> statistics.getHotset</entry>
            <entry> statistics.newIterator</entry>
            <entry> statistics.toString</entry>
          </row>
          <row>
            <entry>statistics.discard</entry>
            <entry> statistics.getMax</entry>
            <entry> statistics.open</entry>
            <entry> statistics.update</entry>
          </row>
          <row>
            <entry>statistics.dump</entry>
            <entry> statistics.getMin</entry>
            <entry> statistics.prelude</entry>
          </row>
          <row>
            <entry>statistics.forceUpdate</entry>
            <entry> statistics.getObjects</entry>
            <entry> statistics.release</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>status.cpuStatistics</entry>
            <entry> status.ioStatistics</entry>
            <entry> status.mem_cursize</entry>
            <entry> status.vm_cursize</entry>
          </row>
          <row>
            <entry>status.gdkEnv</entry>
            <entry> status.memStatistics</entry>
            <entry> status.mem_maxsize</entry>
            <entry> status.vm_maxsize</entry>
          </row>
          <row>
            <entry>status.gdkThread</entry>
            <entry> status.memUsage</entry>
            <entry> status.vmUsage</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>str.+</entry>
            <entry> str.length</entry>
            <entry> str.startsWith</entry>
            <entry> str.trim</entry>
          </row>
          <row>
            <entry>str.STRprelude</entry>
            <entry> str.ltrim</entry>
            <entry> str.str</entry>
            <entry> str.unicode</entry>
          </row>
          <row>
            <entry>str.chrAt</entry>
            <entry> str.nbytes</entry>
            <entry> str.string</entry>
            <entry> str.unicodeAt</entry>
          </row>
          <row>
            <entry>str.codeset</entry>
            <entry> str.r_search</entry>
            <entry> str.substitute</entry>
          </row>
          <row>
            <entry>str.endsWith</entry>
            <entry> str.rtrim</entry>
            <entry> str.toLower</entry>
          </row>
          <row>
            <entry>str.iconv</entry>
            <entry> str.search</entry>
            <entry> str.toUpper</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>stream.blocked</entry>
            <entry> stream.openReadBytes</entry>
            <entry> stream.readStr</entry>
            <entry> stream.socketWriteBytes</entry>
          </row>
          <row>
            <entry>stream.close</entry>
            <entry> stream.openWrite</entry>
            <entry> stream.socketRead</entry>
            <entry> stream.writeInt</entry>
          </row>
          <row>
            <entry>stream.flush</entry>
            <entry> stream.openWriteBytes</entry>
            <entry> stream.socketReadBytes</entry>
            <entry> stream.writeStr</entry>
          </row>
          <row>
            <entry>stream.openRead</entry>
            <entry> stream.readInt</entry>
            <entry> stream.socketWrite</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>tablet.display</entry>
            <entry> tablet.input</entry>
            <entry> tablet.setColumn</entry>
            <entry> tablet.setDelimiter</entry>
          </row>
          <row>
            <entry>tablet.dump</entry>
            <entry> tablet.lastPage</entry>
            <entry> tablet.setColumnBracket</entry>
            <entry> tablet.setFormat</entry>
          </row>
          <row>
            <entry>tablet.finish</entry>
            <entry> tablet.load</entry>
            <entry> tablet.setColumnDecimal</entry>
            <entry> tablet.setPivot</entry>
          </row>
          <row>
            <entry>tablet.firstPage</entry>
            <entry> tablet.nextPage</entry>
            <entry> tablet.setColumnName</entry>
            <entry> tablet.setProperties</entry>
          </row>
          <row>
            <entry>tablet.getPage</entry>
            <entry> tablet.output</entry>
            <entry> tablet.setColumnNull</entry>
            <entry> tablet.setRowBracket</entry>
          </row>
          <row>
            <entry>tablet.getPageCnt</entry>
            <entry> tablet.page</entry>
            <entry> tablet.setColumnPosition</entry>
            <entry> tablet.setStream</entry>
          </row>
          <row>
            <entry>tablet.header</entry>
            <entry> tablet.prevPage</entry>
            <entry> tablet.setColumnWidth</entry>
            <entry> tablet.setTableBracket</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>thread.exec</entry>
            <entry> thread.kill</entry>
            <entry> thread.terminate</entry>
          </row>
          <row>
            <entry>thread.isDead</entry>
            <entry> thread.suspend</entry>
            <entry> thread.wait</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>timestamp.!=</entry>
            <entry> timestamp.=</entry>
            <entry> timestamp.epoch</entry>
          </row>
          <row>
            <entry>timestamp.&lt;</entry>
            <entry> timestamp.&gt;</entry>
            <entry> timestamp.isnil</entry>
          </row>
          <row>
            <entry>timestamp.&lt;=</entry>
            <entry> timestamp.&gt;=</entry>
            <entry> timestamp.unix_epoch</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>transaction.abort</entry>
            <entry> transaction.clean</entry>
            <entry> transaction.delta</entry>
          </row>
          <row>
            <entry>transaction.alpha</entry>
            <entry> transaction.commit</entry>
            <entry> transaction.sync</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>tzone.str</entry>
            <entry> tzone.timestamp</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>unix.getenv</entry>
            <entry> unix.setenv</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>url.getAnchor</entry>
            <entry> url.getDomain</entry>
            <entry> url.getProtocol</entry>
            <entry> url.isaURL</entry>
          </row>
          <row>
            <entry>url.getBasename</entry>
            <entry> url.getExtension</entry>
            <entry> url.getQuery</entry>
            <entry> url.newurl</entry>
          </row>
          <row>
            <entry>url.getContent</entry>
            <entry> url.getFile</entry>
            <entry> url.getQueryArg</entry>
            <entry> url.url</entry>
          </row>
          <row>
            <entry>url.getContext</entry>
            <entry> url.getHost</entry>
            <entry> url.getRobotURL</entry>
          </row>
          <row>
            <entry>url.getDirectory</entry>
            <entry> url.getPort</entry>
            <entry> url.getUser</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>user.main</entry>
          </row>
        </tbody>
      </multitable>
    </appendix>
  </node>
  <node>
    <nodename>MAL Instruction Help</nodename>
    <nodeprev>MAL Instruction Overview</nodeprev>
    <nodeup>Appendices</nodeup>
    <appendix>
      <title>MAL Instruction Help</title>
      <para>The table below summarizes the first commentary line encountered in the system associated with a MAL operation.</para>
      <multitable>
        <columnfraction>24</columnfraction>
        <columnfraction>24</columnfraction>
        <columnfraction>24</columnfraction>
        <columnfraction>24</columnfraction>
        <tbody>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>aggr.avg</entry>
            <entry> aggr.count_no_nil</entry>
            <entry> aggr.min</entry>
            <entry> aggr.sum</entry>
          </row>
          <row>
            <entry>aggr.cardinality</entry>
            <entry> aggr.histogram</entry>
            <entry> aggr.product</entry>
          </row>
          <row>
            <entry>aggr.count</entry>
            <entry> aggr.max</entry>
            <entry> aggr.size</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>alarm.alarm</entry>
            <entry> alarm.epoch</entry>
            <entry> alarm.time</entry>
          </row>
          <row>
            <entry>alarm.ctime</entry>
            <entry> alarm.prelude</entry>
            <entry> alarm.timers</entry>
          </row>
          <row>
            <entry>alarm.epilogue</entry>
            <entry> alarm.sleep</entry>
            <entry> alarm.usec</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>algebra.antijoin</entry>
            <entry> algebra.groupby</entry>
            <entry> algebra.merge</entry>
            <entry> algebra.sort</entry>
          </row>
          <row>
            <entry>algebra.bandjoin</entry>
            <entry> algebra.hashjoin</entry>
            <entry> algebra.mergejoin</entry>
            <entry> algebra.sortHT</entry>
          </row>
          <row>
            <entry>algebra.between</entry>
            <entry> algebra.hashsplit</entry>
            <entry> algebra.number</entry>
            <entry> algebra.sortHead</entry>
          </row>
          <row>
            <entry>algebra.betweenCO</entry>
            <entry> algebra.indexjoin</entry>
            <entry> algebra.outerjoin</entry>
            <entry> algebra.sortTH</entry>
          </row>
          <row>
            <entry>algebra.betweenOC</entry>
            <entry> algebra.intersect</entry>
            <entry> algebra.position</entry>
            <entry> algebra.split</entry>
          </row>
          <row>
            <entry>algebra.betweenOO</entry>
            <entry> algebra.join</entry>
            <entry> algebra.project</entry>
            <entry> algebra.sunion</entry>
          </row>
          <row>
            <entry>algebra.copy</entry>
            <entry> algebra.joinPath</entry>
            <entry> algebra.revert</entry>
            <entry> algebra.sunique</entry>
          </row>
          <row>
            <entry>algebra.crossproduct</entry>
            <entry> algebra.kdifference</entry>
            <entry> algebra.sample</entry>
            <entry> algebra.thetajoin</entry>
          </row>
          <row>
            <entry>algebra.difference</entry>
            <entry> algebra.kintersect</entry>
            <entry> algebra.sdifference</entry>
            <entry> algebra.topN</entry>
          </row>
          <row>
            <entry>algebra.exist</entry>
            <entry> algebra.kunion</entry>
            <entry> algebra.select</entry>
            <entry> algebra.tunique</entry>
          </row>
          <row>
            <entry>algebra.fetch</entry>
            <entry> algebra.kunique</entry>
            <entry> algebra.selectH</entry>
            <entry> algebra.uhashsplit</entry>
          </row>
          <row>
            <entry>algebra.fetchjoin</entry>
            <entry> algebra.like</entry>
            <entry> algebra.semijoin</entry>
            <entry> algebra.union</entry>
          </row>
          <row>
            <entry>algebra.find</entry>
            <entry> algebra.markH</entry>
            <entry> algebra.sintersect</entry>
            <entry> algebra.unique</entry>
          </row>
          <row>
            <entry>algebra.fragment</entry>
            <entry> algebra.markT</entry>
            <entry> algebra.slice</entry>
            <entry> algebra.uselect</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>array.grid</entry>
            <entry> array.print</entry>
            <entry> array.product</entry>
            <entry> array.project</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>bat.append</entry>
            <entry> bat.hasReadMode</entry>
            <entry> bat.new</entry>
            <entry> bat.setMemoryAdvise</entry>
          </row>
          <row>
            <entry>bat.delete</entry>
            <entry> bat.hasWriteMode</entry>
            <entry> bat.pack</entry>
            <entry> bat.setMemoryMap</entry>
          </row>
          <row>
            <entry>bat.getAccess</entry>
            <entry> bat.info</entry>
            <entry> bat.replace</entry>
            <entry> bat.setName</entry>
          </row>
          <row>
            <entry>bat.getAlpha</entry>
            <entry> bat.insert</entry>
            <entry> bat.reverse</entry>
            <entry> bat.setPersistent</entry>
          </row>
          <row>
            <entry>bat.getBatSize</entry>
            <entry> bat.isCached</entry>
            <entry> bat.revert</entry>
            <entry> bat.setReadMode</entry>
          </row>
          <row>
            <entry>bat.getCapacity</entry>
            <entry> bat.isPersistent</entry>
            <entry> bat.save</entry>
            <entry> bat.setRole</entry>
          </row>
          <row>
            <entry>bat.getDelta</entry>
            <entry> bat.isSorted</entry>
            <entry> bat.setAccess</entry>
            <entry> bat.setSequenceBase</entry>
          </row>
          <row>
            <entry>bat.getHeadType</entry>
            <entry> bat.isSortedReverse</entry>
            <entry> bat.setAppendMode</entry>
            <entry> bat.setSet</entry>
          </row>
          <row>
            <entry>bat.getHeat</entry>
            <entry> bat.isSynced</entry>
            <entry> bat.setCold</entry>
            <entry> bat.setSorted</entry>
          </row>
          <row>
            <entry>bat.getName</entry>
            <entry> bat.isTransient</entry>
            <entry> bat.setColumn</entry>
            <entry> bat.setTransient</entry>
          </row>
          <row>
            <entry>bat.getRole</entry>
            <entry> bat.isaKey</entry>
            <entry> bat.setGarbage</entry>
            <entry> bat.setWriteMode</entry>
          </row>
          <row>
            <entry>bat.getSequenceBase</entry>
            <entry> bat.isaSet</entry>
            <entry> bat.setHash</entry>
            <entry> bat.unload</entry>
          </row>
          <row>
            <entry>bat.getTailType</entry>
            <entry> bat.load</entry>
            <entry> bat.setHot</entry>
            <entry> bat.unpack</entry>
          </row>
          <row>
            <entry>bat.hasAppendMode</entry>
            <entry> bat.mirror</entry>
            <entry> bat.setKey</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>batcalc.!=</entry>
            <entry> batcalc./</entry>
            <entry> batcalc.dbl</entry>
            <entry> batcalc.not</entry>
          </row>
          <row>
            <entry>batcalc.%</entry>
            <entry> batcalc.&lt;</entry>
            <entry> batcalc.flt</entry>
            <entry> batcalc.oid</entry>
          </row>
          <row>
            <entry>batcalc.*</entry>
            <entry> batcalc.&lt;=</entry>
            <entry> batcalc.ifthen</entry>
            <entry> batcalc.or</entry>
          </row>
          <row>
            <entry>batcalc.+</entry>
            <entry> batcalc.==</entry>
            <entry> batcalc.ifthenelse</entry>
            <entry> batcalc.project</entry>
          </row>
          <row>
            <entry>batcalc.++</entry>
            <entry> batcalc.&gt;</entry>
            <entry> batcalc.init</entry>
            <entry> batcalc.sht</entry>
          </row>
          <row>
            <entry>batcalc.-</entry>
            <entry> batcalc.&gt;=</entry>
            <entry> batcalc.int</entry>
            <entry> batcalc.str</entry>
          </row>
          <row>
            <entry>batcalc.<ndash/></entry>
            <entry> batcalc.and</entry>
            <entry> batcalc.lng</entry>
            <entry> batcalc.xor</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>batcolor.blue</entry>
            <entry> batcolor.green</entry>
            <entry> batcolor.red</entry>
            <entry> batcolor.value</entry>
          </row>
          <row>
            <entry>batcolor.cb</entry>
            <entry> batcolor.hsv</entry>
            <entry> batcolor.rgb</entry>
          </row>
          <row>
            <entry>batcolor.color</entry>
            <entry> batcolor.hue</entry>
            <entry> batcolor.saturation</entry>
          </row>
          <row>
            <entry>batcolor.cr</entry>
            <entry> batcolor.luminance</entry>
            <entry> batcolor.str</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>batmath.acos</entry>
            <entry> batmath.cos</entry>
            <entry> batmath.fmod</entry>
            <entry> batmath.sinh</entry>
          </row>
          <row>
            <entry>batmath.asin</entry>
            <entry> batmath.cosh</entry>
            <entry> batmath.log</entry>
            <entry> batmath.sqrt</entry>
          </row>
          <row>
            <entry>batmath.atan</entry>
            <entry> batmath.exp</entry>
            <entry> batmath.log10</entry>
            <entry> batmath.tan</entry>
          </row>
          <row>
            <entry>batmath.atan2</entry>
            <entry> batmath.fabs</entry>
            <entry> batmath.pow</entry>
            <entry> batmath.tanh</entry>
          </row>
          <row>
            <entry>batmath.ceil</entry>
            <entry> batmath.floor</entry>
            <entry> batmath.sin</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>batstr.!=</entry>
            <entry> batstr.length</entry>
            <entry> batstr.search</entry>
            <entry> batstr.toUpper</entry>
          </row>
          <row>
            <entry>batstr.+</entry>
            <entry> batstr.like</entry>
            <entry> batstr.startsWith</entry>
            <entry> batstr.trim</entry>
          </row>
          <row>
            <entry>batstr.==</entry>
            <entry> batstr.ltrim</entry>
            <entry> batstr.str</entry>
            <entry> batstr.unicodeAt</entry>
          </row>
          <row>
            <entry>batstr.bytes</entry>
            <entry> batstr.match</entry>
            <entry> batstr.string</entry>
          </row>
          <row>
            <entry>batstr.chrAt</entry>
            <entry> batstr.r_search</entry>
            <entry> batstr.substitute</entry>
          </row>
          <row>
            <entry>batstr.endsWith</entry>
            <entry> batstr.rtrim</entry>
            <entry> batstr.toLower</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>bbp.bind</entry>
            <entry> bbp.getDirty</entry>
            <entry> bbp.getNames</entry>
            <entry> bbp.open</entry>
          </row>
          <row>
            <entry>bbp.close</entry>
            <entry> bbp.getHeadType</entry>
            <entry> bbp.getObjects</entry>
            <entry> bbp.prelude</entry>
          </row>
          <row>
            <entry>bbp.commit</entry>
            <entry> bbp.getHeat</entry>
            <entry> bbp.getRNames</entry>
            <entry> bbp.release</entry>
          </row>
          <row>
            <entry>bbp.deposit</entry>
            <entry> bbp.getKind</entry>
            <entry> bbp.getRefCount</entry>
            <entry> bbp.releaseAll</entry>
          </row>
          <row>
            <entry>bbp.destroy</entry>
            <entry> bbp.getLRefCount</entry>
            <entry> bbp.getStatus</entry>
            <entry> bbp.take</entry>
          </row>
          <row>
            <entry>bbp.discard</entry>
            <entry> bbp.getLocation</entry>
            <entry> bbp.getTailType</entry>
            <entry> bbp.toString</entry>
          </row>
          <row>
            <entry>bbp.getCount</entry>
            <entry> bbp.getName</entry>
            <entry> bbp.iterator</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>blob.nitems</entry>
            <entry> blob.null</entry>
            <entry> blob.toblob</entry>
            <entry> blob.tostring</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>box.close</entry>
            <entry> box.discard</entry>
            <entry> box.open</entry>
            <entry> box.take</entry>
          </row>
          <row>
            <entry>box.deposit</entry>
            <entry> box.getBoxNames</entry>
            <entry> box.release</entry>
            <entry> box.toString</entry>
          </row>
          <row>
            <entry>box.destroy</entry>
            <entry> box.iterator</entry>
            <entry> box.releaseAll</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>bstream.create</entry>
            <entry> bstream.destroy</entry>
            <entry> bstream.read</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>calc.!=</entry>
            <entry> calc.&gt;=</entry>
            <entry> calc.getBATidentifier</entry>
            <entry> calc.not</entry>
          </row>
          <row>
            <entry>calc.%</entry>
            <entry> calc.&gt;&gt;</entry>
            <entry> calc.ifthenelse</entry>
            <entry> calc.oid</entry>
          </row>
          <row>
            <entry>calc.*</entry>
            <entry> calc.abs</entry>
            <entry> calc.int</entry>
            <entry> calc.or</entry>
          </row>
          <row>
            <entry>calc.+</entry>
            <entry> calc.and</entry>
            <entry> calc.inv</entry>
            <entry> calc.ptr</entry>
          </row>
          <row>
            <entry>calc.-</entry>
            <entry> calc.bat</entry>
            <entry> calc.isnil</entry>
            <entry> calc.setoid</entry>
          </row>
          <row>
            <entry>calc./</entry>
            <entry> calc.between</entry>
            <entry> calc.isnotnil</entry>
            <entry> calc.sht</entry>
          </row>
          <row>
            <entry>calc.&lt;</entry>
            <entry> calc.bit</entry>
            <entry> calc.length</entry>
            <entry> calc.str</entry>
          </row>
          <row>
            <entry>calc.&lt;&lt;</entry>
            <entry> calc.chr</entry>
            <entry> calc.lng</entry>
            <entry> calc.void</entry>
          </row>
          <row>
            <entry>calc.&lt;=</entry>
            <entry> calc.dbl</entry>
            <entry> calc.max</entry>
            <entry> calc.xor</entry>
          </row>
          <row>
            <entry>calc.==</entry>
            <entry> calc.flt</entry>
            <entry> calc.min</entry>
          </row>
          <row>
            <entry>calc.&gt;</entry>
            <entry> calc.getBAT</entry>
            <entry> calc.newoid</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>chopper.getHead</entry>
            <entry> chopper.getTail</entry>
            <entry> chopper.hasMoreElements</entry>
            <entry> chopper.newIterator</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>clients.addUser</entry>
            <entry> clients.getLogins</entry>
            <entry> clients.newPassword</entry>
            <entry> clients.setScenario</entry>
          </row>
          <row>
            <entry>clients.checkPermission</entry>
            <entry> clients.getPasswords</entry>
            <entry> clients.quit</entry>
            <entry> clients.trace</entry>
          </row>
          <row>
            <entry>clients.delUser</entry>
            <entry> clients.getPermissions</entry>
            <entry> clients.setDebug</entry>
          </row>
          <row>
            <entry>clients.getId</entry>
            <entry> clients.getScenario</entry>
            <entry> clients.setHistory</entry>
          </row>
          <row>
            <entry>clients.getInfo</entry>
            <entry> clients.getUsers</entry>
            <entry> clients.setListing</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>color.blue</entry>
            <entry> color.green</entry>
            <entry> color.print</entry>
            <entry> color.saturation</entry>
          </row>
          <row>
            <entry>color.cb</entry>
            <entry> color.hsv</entry>
            <entry> color.printf</entry>
            <entry> color.str</entry>
          </row>
          <row>
            <entry>color.color</entry>
            <entry> color.hue</entry>
            <entry> color.red</entry>
            <entry> color.value</entry>
          </row>
          <row>
            <entry>color.cr</entry>
            <entry> color.luminance</entry>
            <entry> color.rgb</entry>
            <entry> color.ycc</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>const.close</entry>
            <entry> const.epiloque</entry>
            <entry> const.prelude</entry>
            <entry> const.toString</entry>
          </row>
          <row>
            <entry>const.deposit</entry>
            <entry> const.hasMoreElements</entry>
            <entry> const.release</entry>
          </row>
          <row>
            <entry>const.destroy</entry>
            <entry> const.newIterator</entry>
            <entry> const.releaseAll</entry>
          </row>
          <row>
            <entry>const.discard</entry>
            <entry> const.open</entry>
            <entry> const.take</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>crackers.addOne</entry>
            <entry> crackers.crack_SM</entry>
            <entry> crackers.newIterator</entry>
            <entry> crackers.zcrackOrdered_SM</entry>
          </row>
          <row>
            <entry>crackers.addTwo</entry>
            <entry> crackers.crack_sm</entry>
            <entry> crackers.printIndex</entry>
            <entry> crackers.zcrackOrdered_is</entry>
          </row>
          <row>
            <entry>crackers.crack</entry>
            <entry> crackers.crack_validate</entry>
            <entry> crackers.range</entry>
            <entry> crackers.zcrackOrdered_sm</entry>
          </row>
          <row>
            <entry>crackers.crackOrdered_MK</entry>
            <entry> crackers.destroy</entry>
            <entry> crackers.select</entry>
            <entry> crackers.zcrackOrdered_validate</entry>
          </row>
          <row>
            <entry>crackers.crackOrdered_SM</entry>
            <entry> crackers.getPiece</entry>
            <entry> crackers.selectPieces</entry>
            <entry> crackers.zcrack_MK</entry>
          </row>
          <row>
            <entry>crackers.crackOrdered_is</entry>
            <entry> crackers.hasMoreElements</entry>
            <entry> crackers.setGranule</entry>
            <entry> crackers.zcrack_SM</entry>
          </row>
          <row>
            <entry>crackers.crackOrdered_sm</entry>
            <entry> crackers.info</entry>
            <entry> crackers.setLimit</entry>
            <entry> crackers.zcrack_sm</entry>
          </row>
          <row>
            <entry>crackers.crackOrdered_validate</entry>
            <entry> crackers.new</entry>
            <entry> crackers.uselect</entry>
            <entry> crackers.zcrack_validate</entry>
          </row>
          <row>
            <entry>crackers.crack_MK</entry>
            <entry> crackers.newIndex</entry>
            <entry> crackers.zcrackOrdered_MK</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>date.!=</entry>
            <entry> date.&lt;=</entry>
            <entry> date.&gt;</entry>
            <entry> date.date</entry>
          </row>
          <row>
            <entry>date.&lt;</entry>
            <entry> date.=</entry>
            <entry> date.&gt;=</entry>
            <entry> date.isnil</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>daytime.!=</entry>
            <entry> daytime.&lt;=</entry>
            <entry> daytime.&gt;</entry>
            <entry> daytime.isnil</entry>
          </row>
          <row>
            <entry>daytime.&lt;</entry>
            <entry> daytime.=</entry>
            <entry> daytime.&gt;=</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>factory.getCaller</entry>
            <entry> factory.getOwners</entry>
            <entry> factory.getTimeStampIn</entry>
            <entry> factory.setLocation</entry>
          </row>
          <row>
            <entry>factory.getLocations</entry>
            <entry> factory.getPlants</entry>
            <entry> factory.getTimeStampOut</entry>
            <entry> factory.shutdown</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>group.avg</entry>
            <entry> group.max</entry>
            <entry> group.prelude</entry>
            <entry> group.size</entry>
          </row>
          <row>
            <entry>group.count</entry>
            <entry> group.min</entry>
            <entry> group.refine</entry>
            <entry> group.sum</entry>
          </row>
          <row>
            <entry>group.derive</entry>
            <entry> group.new</entry>
            <entry> group.refine_reverse</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>inet.!=</entry>
            <entry> inet.&gt;</entry>
            <entry> inet.host</entry>
            <entry> inet.new</entry>
          </row>
          <row>
            <entry>inet.&lt;</entry>
            <entry> inet.&gt;=</entry>
            <entry> inet.hostmask</entry>
            <entry> inet.setmasklen</entry>
          </row>
          <row>
            <entry>inet.&lt;&lt;</entry>
            <entry> inet.&gt;&gt;</entry>
            <entry> inet.isnil</entry>
            <entry> inet.text</entry>
          </row>
          <row>
            <entry>inet.&lt;&lt;=</entry>
            <entry> inet.&gt;&gt;=</entry>
            <entry> inet.masklen</entry>
          </row>
          <row>
            <entry>inet.&lt;=</entry>
            <entry> inet.abbrev</entry>
            <entry> inet.netmask</entry>
          </row>
          <row>
            <entry>inet.=</entry>
            <entry> inet.broadcast</entry>
            <entry> inet.network</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>inspect.getAddress</entry>
            <entry> inspect.getComment</entry>
            <entry> inspect.getModule</entry>
            <entry> inspect.getTypeIndex</entry>
          </row>
          <row>
            <entry>inspect.getAddresses</entry>
            <entry> inspect.getDefinition</entry>
            <entry> inspect.getSignature</entry>
            <entry> inspect.getTypeName</entry>
          </row>
          <row>
            <entry>inspect.getAtomNames</entry>
            <entry> inspect.getEnvironment</entry>
            <entry> inspect.getSignatures</entry>
          </row>
          <row>
            <entry>inspect.getAtomSizes</entry>
            <entry> inspect.getFunction</entry>
            <entry> inspect.getSize</entry>
          </row>
          <row>
            <entry>inspect.getAtomSuperNames</entry>
            <entry> inspect.getKind</entry>
            <entry> inspect.getType</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>io.export</entry>
            <entry> io.print</entry>
            <entry> io.prompt</entry>
            <entry> io.stdout</entry>
          </row>
          <row>
            <entry>io.ftable</entry>
            <entry> io.printf</entry>
            <entry> io.stderr</entry>
            <entry> io.table</entry>
          </row>
          <row>
            <entry>io.import</entry>
            <entry> io.printft</entry>
            <entry> io.stdin</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>language.assert</entry>
            <entry> language.newRange</entry>
            <entry> language.raise</entry>
            <entry> language.source</entry>
          </row>
          <row>
            <entry>language.call</entry>
            <entry> language.nextElement</entry>
            <entry> language.register</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>lock.create</entry>
            <entry> lock.set</entry>
            <entry> lock.try</entry>
          </row>
          <row>
            <entry>lock.destroy</entry>
            <entry> lock.tostr</entry>
            <entry> lock.unset</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>manual.completion</entry>
            <entry> manual.createHelp</entry>
            <entry> manual.help</entry>
          </row>
          <row>
            <entry>manual.create</entry>
            <entry> manual.createOverview</entry>
            <entry> manual.search</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>mat.expand</entry>
            <entry> mat.iterator</entry>
            <entry> mat.pack</entry>
          </row>
          <row>
            <entry>mat.info</entry>
            <entry> mat.new</entry>
            <entry> mat.print</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>mdb.List</entry>
            <entry> mdb.getExceptionVariable</entry>
            <entry> mdb.inspect</entry>
            <entry> mdb.setTrace</entry>
          </row>
          <row>
            <entry>mdb.getDefinition</entry>
            <entry> mdb.getStackDepth</entry>
            <entry> mdb.list</entry>
            <entry> mdb.start</entry>
          </row>
          <row>
            <entry>mdb.getExceptionContext</entry>
            <entry> mdb.getStackFrame</entry>
            <entry> mdb.setCatch</entry>
            <entry> mdb.stop</entry>
          </row>
          <row>
            <entry>mdb.getExceptionReason</entry>
            <entry> mdb.getStackTrace</entry>
            <entry> mdb.setTimer</entry>
            <entry> mdb.var</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>mkey.bulk_rotate_xor_hash</entry>
            <entry> mkey.hash</entry>
            <entry> mkey.rotate</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>mmath.acos</entry>
            <entry> mmath.exp</entry>
            <entry> mmath.log</entry>
            <entry> mmath.sqrt</entry>
          </row>
          <row>
            <entry>mmath.asin</entry>
            <entry> mmath.fabs</entry>
            <entry> mmath.log10</entry>
            <entry> mmath.srand</entry>
          </row>
          <row>
            <entry>mmath.atan</entry>
            <entry> mmath.finite</entry>
            <entry> mmath.pow</entry>
            <entry> mmath.tan</entry>
          </row>
          <row>
            <entry>mmath.atan2</entry>
            <entry> mmath.floor</entry>
            <entry> mmath.rand</entry>
            <entry> mmath.tanh</entry>
          </row>
          <row>
            <entry>mmath.ceil</entry>
            <entry> mmath.fmod</entry>
            <entry> mmath.round</entry>
          </row>
          <row>
            <entry>mmath.cos</entry>
            <entry> mmath.isinf</entry>
            <entry> mmath.sin</entry>
          </row>
          <row>
            <entry>mmath.cosh</entry>
            <entry> mmath.isnan</entry>
            <entry> mmath.sinh</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>mserver.connect</entry>
            <entry> mserver.explain</entry>
            <entry> mserver.malclient</entry>
            <entry> mserver.stop</entry>
          </row>
          <row>
            <entry>mserver.epilogue</entry>
            <entry> mserver.listen</entry>
            <entry> mserver.prelude</entry>
            <entry> mserver.suspend</entry>
          </row>
          <row>
            <entry>mserver.error</entry>
            <entry> mserver.listen_ssl</entry>
            <entry> mserver.resume</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>mtime.add</entry>
            <entry> mtime.dayname</entry>
            <entry> mtime.month</entry>
            <entry> mtime.time_synonyms</entry>
          </row>
          <row>
            <entry>mtime.adddays</entry>
            <entry> mtime.daynum</entry>
            <entry> mtime.monthname</entry>
            <entry> mtime.timestamp</entry>
          </row>
          <row>
            <entry>mtime.addmonths</entry>
            <entry> mtime.dayofweek</entry>
            <entry> mtime.monthnum</entry>
            <entry> mtime.timestamp_add_month_interval</entry>
          </row>
          <row>
            <entry>mtime.addyears</entry>
            <entry> mtime.dayofyear</entry>
            <entry> mtime.msec</entry>
            <entry> mtime.timestamp_add_sec_interval</entry>
          </row>
          <row>
            <entry>mtime.compute</entry>
            <entry> mtime.daytime</entry>
            <entry> mtime.msecs</entry>
            <entry> mtime.timestamp_sub_month_interval</entry>
          </row>
          <row>
            <entry>mtime.current_date</entry>
            <entry> mtime.diff</entry>
            <entry> mtime.olddate</entry>
            <entry> mtime.timestamp_sub_sec_interval</entry>
          </row>
          <row>
            <entry>mtime.current_time</entry>
            <entry> mtime.dst</entry>
            <entry> mtime.oldduration</entry>
            <entry> mtime.timezone</entry>
          </row>
          <row>
            <entry>mtime.current_timestamp</entry>
            <entry> mtime.end_dst</entry>
            <entry> mtime.prelude</entry>
            <entry> mtime.tzone</entry>
          </row>
          <row>
            <entry>mtime.date</entry>
            <entry> mtime.epilogue</entry>
            <entry> mtime.rule</entry>
            <entry> mtime.tzone_local</entry>
          </row>
          <row>
            <entry>mtime.date_add_month_interval</entry>
            <entry> mtime.hours</entry>
            <entry> mtime.seconds</entry>
            <entry> mtime.weekday</entry>
          </row>
          <row>
            <entry>mtime.date_add_sec_interval</entry>
            <entry> mtime.local_timezone</entry>
            <entry> mtime.start_dst</entry>
            <entry> mtime.weekofyear</entry>
          </row>
          <row>
            <entry>mtime.date_sub_sec_interval</entry>
            <entry> mtime.milliseconds</entry>
            <entry> mtime.time_add_sec_interval</entry>
            <entry> mtime.year</entry>
          </row>
          <row>
            <entry>mtime.day</entry>
            <entry> mtime.minutes</entry>
            <entry> mtime.time_sub_sec_interval</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>optimizer.aliasRemoval</entry>
            <entry> optimizer.dumpQEP</entry>
            <entry> optimizer.macroExpansion</entry>
            <entry> optimizer.reduce</entry>
          </row>
          <row>
            <entry>optimizer.clrDebug</entry>
            <entry> optimizer.emptySet</entry>
            <entry> optimizer.multiplex</entry>
            <entry> optimizer.setDebug</entry>
          </row>
          <row>
            <entry>optimizer.coercions</entry>
            <entry> optimizer.expressionAccumulation</entry>
            <entry> optimizer.multitable</entry>
            <entry> optimizer.showFlowGraph</entry>
          </row>
          <row>
            <entry>optimizer.commonExpressionRemoval</entry>
            <entry> optimizer.factorize</entry>
            <entry> optimizer.optimize</entry>
            <entry> optimizer.showPlan</entry>
          </row>
          <row>
            <entry>optimizer.costEstimation</entry>
            <entry> optimizer.garbageCollector</entry>
            <entry> optimizer.partitionedQuery</entry>
            <entry> optimizer.singleton</entry>
          </row>
          <row>
            <entry>optimizer.crack</entry>
            <entry> optimizer.generators</entry>
            <entry> optimizer.peephole</entry>
            <entry> optimizer.strengthReduction</entry>
          </row>
          <row>
            <entry>optimizer.deadCodeRemoval</entry>
            <entry> optimizer.macroContraction</entry>
            <entry> optimizer.prelude</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>partitions.close</entry>
            <entry> partitions.discard</entry>
            <entry> partitions.hasMoreElements</entry>
            <entry> partitions.release</entry>
          </row>
          <row>
            <entry>partitions.compress</entry>
            <entry> partitions.dump</entry>
            <entry> partitions.insert</entry>
            <entry> partitions.releaseAll</entry>
          </row>
          <row>
            <entry>partitions.delete</entry>
            <entry> partitions.epilogue</entry>
            <entry> partitions.newIterator</entry>
            <entry> partitions.setCapacity</entry>
          </row>
          <row>
            <entry>partitions.deposit</entry>
            <entry> partitions.getLastPartition</entry>
            <entry> partitions.open</entry>
            <entry> partitions.take</entry>
          </row>
          <row>
            <entry>partitions.destroy</entry>
            <entry> partitions.getRange</entry>
            <entry> partitions.prelude</entry>
            <entry> partitions.toString</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>pbm.close</entry>
            <entry> pbm.epilogue</entry>
            <entry> pbm.getNextName</entry>
            <entry> pbm.setReadMode</entry>
          </row>
          <row>
            <entry>pbm.compress</entry>
            <entry> pbm.generator</entry>
            <entry> pbm.getRange</entry>
            <entry> pbm.setWriteMode</entry>
          </row>
          <row>
            <entry>pbm.deposit</entry>
            <entry> pbm.getComponents</entry>
            <entry> pbm.newIterator</entry>
            <entry> pbm.take</entry>
          </row>
          <row>
            <entry>pbm.destroy</entry>
            <entry> pbm.getLast</entry>
            <entry> pbm.open</entry>
          </row>
          <row>
            <entry>pbm.discard</entry>
            <entry> pbm.getNames</entry>
            <entry> pbm.prelude</entry>
          </row>
          <row>
            <entry>pbm.dump</entry>
            <entry> pbm.getNextElement</entry>
            <entry> pbm.releaseAll</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>pcre.compile</entry>
            <entry> pcre.null</entry>
            <entry> pcre.select</entry>
          </row>
          <row>
            <entry>pcre.like</entry>
            <entry> pcre.prelude</entry>
            <entry> pcre.sql2pcre</entry>
          </row>
          <row>
            <entry>pcre.match</entry>
            <entry> pcre.replace</entry>
            <entry> pcre.uselect</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>pqueue.dequeue_max</entry>
            <entry> pqueue.enqueue_min</entry>
            <entry> pqueue.topn_min</entry>
          </row>
          <row>
            <entry>pqueue.dequeue_min</entry>
            <entry> pqueue.init</entry>
            <entry> pqueue.topreplace_max</entry>
          </row>
          <row>
            <entry>pqueue.enqueue_max</entry>
            <entry> pqueue.topn_max</entry>
            <entry> pqueue.topreplace_min</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>profiler.activate</entry>
            <entry> profiler.dumpTrace</entry>
            <entry> profiler.setFilter</entry>
            <entry> profiler.startTrace</entry>
          </row>
          <row>
            <entry>profiler.cleanup</entry>
            <entry> profiler.getTrace</entry>
            <entry> profiler.setNone</entry>
            <entry> profiler.stop</entry>
          </row>
          <row>
            <entry>profiler.clearTrace</entry>
            <entry> profiler.openStream</entry>
            <entry> profiler.setOfflineProfiling</entry>
            <entry> profiler.stopTrace</entry>
          </row>
          <row>
            <entry>profiler.closeStream</entry>
            <entry> profiler.setAll</entry>
            <entry> profiler.setOnlineProfiling</entry>
          </row>
          <row>
            <entry>profiler.clrFilter</entry>
            <entry> profiler.setCachedProfiling</entry>
            <entry> profiler.setStartPoint</entry>
          </row>
          <row>
            <entry>profiler.deactivate</entry>
            <entry> profiler.setEndPoint</entry>
            <entry> profiler.start</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>sema.create</entry>
            <entry> sema.destroy</entry>
            <entry> sema.down</entry>
            <entry> sema.up</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>statistics.close</entry>
            <entry> statistics.forceUpdate</entry>
            <entry> statistics.getObjects</entry>
            <entry> statistics.release</entry>
          </row>
          <row>
            <entry>statistics.deposit</entry>
            <entry> statistics.getCount</entry>
            <entry> statistics.getSize</entry>
            <entry> statistics.releaseAll</entry>
          </row>
          <row>
            <entry>statistics.destroy</entry>
            <entry> statistics.getHistogram</entry>
            <entry> statistics.hasMoreElements</entry>
            <entry> statistics.take</entry>
          </row>
          <row>
            <entry>statistics.discard</entry>
            <entry> statistics.getHotset</entry>
            <entry> statistics.newIterator</entry>
            <entry> statistics.toString</entry>
          </row>
          <row>
            <entry>statistics.dump</entry>
            <entry> statistics.getMax</entry>
            <entry> statistics.open</entry>
            <entry> statistics.update</entry>
          </row>
          <row>
            <entry>statistics.epilogue</entry>
            <entry> statistics.getMin</entry>
            <entry> statistics.prelude</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>status.batStatistics</entry>
            <entry> status.getThreads</entry>
            <entry> status.mem_cursize</entry>
            <entry> status.vm_maxsize</entry>
          </row>
          <row>
            <entry>status.cpuStatistics</entry>
            <entry> status.ioStatistics</entry>
            <entry> status.mem_maxsize</entry>
          </row>
          <row>
            <entry>status.getDatabases</entry>
            <entry> status.memStatistics</entry>
            <entry> status.vmStatistics</entry>
          </row>
          <row>
            <entry>status.getPorts</entry>
            <entry> status.memUsage</entry>
            <entry> status.vm_cursize</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>str.+</entry>
            <entry> str.length</entry>
            <entry> str.rtrim</entry>
            <entry> str.suffix</entry>
          </row>
          <row>
            <entry>str.STRepilogue</entry>
            <entry> str.like</entry>
            <entry> str.search</entry>
            <entry> str.toLower</entry>
          </row>
          <row>
            <entry>str.STRprelude</entry>
            <entry> str.locate</entry>
            <entry> str.space</entry>
            <entry> str.toUpper</entry>
          </row>
          <row>
            <entry>str.ascii</entry>
            <entry> str.ltrim</entry>
            <entry> str.startsWith</entry>
            <entry> str.trim</entry>
          </row>
          <row>
            <entry>str.chrAt</entry>
            <entry> str.nbytes</entry>
            <entry> str.str</entry>
            <entry> str.unicode</entry>
          </row>
          <row>
            <entry>str.codeset</entry>
            <entry> str.prefix</entry>
            <entry> str.string</entry>
            <entry> str.unicodeAt</entry>
          </row>
          <row>
            <entry>str.endsWith</entry>
            <entry> str.r_search</entry>
            <entry> str.stringlength</entry>
          </row>
          <row>
            <entry>str.iconv</entry>
            <entry> str.repeat</entry>
            <entry> str.substitute</entry>
          </row>
          <row>
            <entry>str.insert</entry>
            <entry> str.replace</entry>
            <entry> str.substring</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>streams.blocked</entry>
            <entry> streams.openReadBytes</entry>
            <entry> streams.readStr</entry>
            <entry> streams.socketWriteBytes</entry>
          </row>
          <row>
            <entry>streams.close</entry>
            <entry> streams.openWrite</entry>
            <entry> streams.socketRead</entry>
            <entry> streams.writeInt</entry>
          </row>
          <row>
            <entry>streams.flush</entry>
            <entry> streams.openWriteBytes</entry>
            <entry> streams.socketReadBytes</entry>
            <entry> streams.writeStr</entry>
          </row>
          <row>
            <entry>streams.openRead</entry>
            <entry> streams.readInt</entry>
            <entry> streams.socketWrite</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>tablet.display</entry>
            <entry> tablet.input</entry>
            <entry> tablet.setColumn</entry>
            <entry> tablet.setDelimiter</entry>
          </row>
          <row>
            <entry>tablet.dump</entry>
            <entry> tablet.lastPage</entry>
            <entry> tablet.setColumnBracket</entry>
            <entry> tablet.setFormat</entry>
          </row>
          <row>
            <entry>tablet.finish</entry>
            <entry> tablet.load</entry>
            <entry> tablet.setColumnDecimal</entry>
            <entry> tablet.setPivot</entry>
          </row>
          <row>
            <entry>tablet.firstPage</entry>
            <entry> tablet.nextPage</entry>
            <entry> tablet.setColumnName</entry>
            <entry> tablet.setProperties</entry>
          </row>
          <row>
            <entry>tablet.getPage</entry>
            <entry> tablet.output</entry>
            <entry> tablet.setColumnNull</entry>
            <entry> tablet.setRowBracket</entry>
          </row>
          <row>
            <entry>tablet.getPageCnt</entry>
            <entry> tablet.page</entry>
            <entry> tablet.setColumnPosition</entry>
            <entry> tablet.setStream</entry>
          </row>
          <row>
            <entry>tablet.header</entry>
            <entry> tablet.prevPage</entry>
            <entry> tablet.setColumnWidth</entry>
            <entry> tablet.setTableBracket</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>timestamp.!=</entry>
            <entry> timestamp.=</entry>
            <entry> timestamp.epoch</entry>
          </row>
          <row>
            <entry>timestamp.&lt;</entry>
            <entry> timestamp.&gt;</entry>
            <entry> timestamp.isnil</entry>
          </row>
          <row>
            <entry>timestamp.&lt;=</entry>
            <entry> timestamp.&gt;=</entry>
            <entry> timestamp.unix_epoch</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>transaction.abort</entry>
            <entry> transaction.clean</entry>
            <entry> transaction.delta</entry>
          </row>
          <row>
            <entry>transaction.alpha</entry>
            <entry> transaction.commit</entry>
            <entry> transaction.sync</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>tzone.str</entry>
            <entry> tzone.timestamp</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>unix.getenv</entry>
            <entry> unix.setenv</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>url.getAnchor</entry>
            <entry> url.getDomain</entry>
            <entry> url.getProtocol</entry>
            <entry> url.isaURL</entry>
          </row>
          <row>
            <entry>url.getBasename</entry>
            <entry> url.getExtension</entry>
            <entry> url.getQuery</entry>
            <entry> url.new</entry>
          </row>
          <row>
            <entry>url.getContent</entry>
            <entry> url.getFile</entry>
            <entry> url.getQueryArg</entry>
            <entry> url.url</entry>
          </row>
          <row>
            <entry>url.getContext</entry>
            <entry> url.getHost</entry>
            <entry> url.getRobotURL</entry>
          </row>
          <row>
            <entry>url.getDirectory</entry>
            <entry> url.getPort</entry>
            <entry> url.getUser</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>user.main</entry>
          </row>
          <row>
            <entry></entry>
          </row>
          <row>
            <entry>zrule.define</entry>
          </row>
        </tbody>
      </multitable>
    </appendix>
  </node>
</texinfo>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-indent-step:1
sgml-indent-data:nil
End:
-->
