@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.
@f dc_receptor
@a M.L. Kersten
@+ Receptor control

A receptor controls the interaction with external devices
delivering event tuples for processing. It is implemented as
a separate thread of control, which accepts connections
from remote users and issues an acknowledgement using
a hardwired authorization scheme.

Each channel gets a private thread to receive the events
and update a private receptor table. The current 
implementation allows just one device to hook up to an access point.

The events are collected in two tables. The private
table is used to store the events as they arrive over
the communication channel. Statistics are collected on the
inter-arrival time to provide a basis for scheduling
decisions.

The public table is controlled by a pump query.
It is a copy of the private table created when a pump
query is activated and needs its content. 
The benefit of this approach is that the query and
channel manager do not have to regulate their activities
using expensive locking. It is only required at the moment
the private buffer is turned into a public buffer.
The public table is cleared when the receptor releases it.

The content of the private table is fully controlled by the
receptor thread. The default policy is to discard
all tuples from the binary as soon as
have been stored in the public table.
A more refined scheme can be encoded in a separate 'drain'
query, which is called after the secondary table has been
filled and released to the query thread.

Tuples can be silently droppped when their timeout
expires. This is piggybacked on the transfer of tuples
to the secondary table and when we run into resource
problems.
@mal

command datacell.getReceptorStatus(nme:str)
address DCgetReceptorStatus
comment "Display the actual state of a receptor.";

command datacell.bindReceptor(sname:str,pname:str) 
		(public:bat[:void,:any$1],private:bat[:void,:any$1])
address DCbindReceptor
comment "Provide private access to a column.";

command datacell.bindReceptorTuple(sname:str,pname:str) 
		(head:any$1,tail:any$2)
address DCbindReceptorTuple
comment "Extract a single tuple from the public bats.";

command datacell.bindReceptor(sname:str,pname:str) :bat[:void,:any$1]
address DCbindReceptorPublic
comment "Provide private access to a public version of a column.";

@{
@- Implementation
The implementation is based on the assumption that 
the sensor produces information for a designated collection
of BATs. A separate process is created for each sensor to receive
and analyse the data. 

@h
#ifndef _DCRECEPTOR_DEF
#define _DCRECEPTOR_DEF

/* #define DEBUG_DC_RECEPTOR*/

#include "datacell.h"


typedef struct {
	int socket;
	/*str sname; does not work */
} *SensorInfo;

dc_export str DCstartChannel(DCpump p, bstream *bs);
dc_export str DClistenReceptor(DCpump p, str *Usockfile);
dc_export str DClistenThread(SensorInfo sensor);
dc_export int DCrollforward(DCpump p);
dc_export void DCreleaseReceptor(DCpump p);
#endif /* _DCRECEPTOR_DEF */
@c
#include "dc_receptor.h"

#ifndef DC_H
#define DC_H

#define NEW_ARRAY( type, size )	(type*)GDKmalloc((size)*sizeof(type))
#define STREQ(a, b) 		(strcmp(a, b)==0)

#endif /* DC_H */

#include "mal.h"

#include <stream.h>		/* for stream */

#ifdef HAVE_SYS_SOCKET_H
# include <sys/socket.h>
#endif
#ifdef HAVE_SYS_UN_H
#include <sys/un.h>
#endif

#define SOCKPTR struct sockaddr *
#if HAVE_SOCKLEN_T
#define SOCKLEN socklen_t
#else
#define SOCKLEN int
#endif

#ifdef HAVE_OPENSSL
#include <openssl/ssl.h>
#include <openssl/err.h>
#endif

#include "mtime.h"

static int usock = -1;

static DCpump channel;		/* insecure channel between threads! */

mal_export str DCgetReceptorStatus(int *ret);
mal_export str DCbindReceptor(int *retpublic, int *retprivate, str *name, str *cname);
mal_export str DCbindReceptorTuple(int *retpublic, int *retprivate, str *name, str *cname);
mal_export str DClistenReceptor(DCpump p, str *Usockfile);
mal_export str DCstartChannel(DCpump p, bstream *bs);
mal_export str DClistenThread(SensorInfo sensor);
str
DCgetReceptorStatus(int *ret)
{
	BAT *bn = DCcontainer(TYPE_int, pumplimit);
	DCpump p;
	oid o = oid_nil;

	for (p = pumps; p < pumps + pumplimit; p++)
		if (p->name && p->kind == RECEPTOR) {
			BUNins(bn, &o, &p->status);
		}
	BBPincref(*ret = bn->batCacheid, TRUE);
	BBPunfix(*ret);
	return MAL_SUCCEED;
}

@-
Gaining access to a column also sets the lock to avoid interference
of other pumps. All tuples are obtained from the public BATs, which
are cleaned out by the data pump release
@c
int
DCrollforward(DCpump p)
{
	int i;
	BAT *b;
	size_t cnt;

	if ((cnt = BATcount(p->public[0])) == 0 && BATcount(p->private[0]) == 0)
		return 0;
	if (cnt)
		return 1;
#ifdef DEBUG_DC_RECEPTOR
	printf("#roll receptor forward\n");
#endif
	mal_set_lock(p->lock, "datacellIsolate");
	for (i = 0; i < p->cols; i++) {
#ifdef DEBUG_DC_RECEPTOR
		printf("#roll receptor forward %d\n", i);
#endif
		b = p->public[i];
		p->public[i] = p->private[i];
		p->private[i] = b;
	}
	cnt = BATcount(p->public[0]);
	p->pending -= cnt;
	mal_unset_lock(p->lock, "datacellIsolate");

	return 1;
}

void
DCreleaseReceptor(DCpump p)
{
	int i;

	for (i = 0; i < p->cols; i++)
		BATclear(p->public[i]);
}

str
DCbindReceptor(int *retpublic, int *retprivate, str *name, str *cname)
{
	DCpump p;
	int i;

	p = DClocatePump(*name);
	if (p == 0)
		return throwMessage("datacell.bindReceptor", "unknown receptor");
	if (p->kind != RECEPTOR)
		return throwMessage("datacell.bindReceptor", "unknown receptor");
	mal_set_lock(p->lock, "datacellIsolate");
	for (i = 0; i < p->cols; i++)
		if (strcmp(p->columns[i], *cname) == 0) {
			if (p->usedby && p->usedby != p - pumps) {
				mal_unset_lock(p->lock, "datacellIsolate");

				return throwMessage("datacell.bindReceptor", "Pump still in use\n");
			}

			BBPincref(*retpublic = p->public[i]->batCacheid, TRUE);
			BBPincref(*retprivate = p->private[i]->batCacheid, TRUE);
			p->usedby = p - pumps;
			break;
		}
	mal_unset_lock(p->lock, "datacellIsolate");

	return MAL_SUCCEED;
}

@-
It is also possible to pick up a single tuple from the public part.
@c
str
DCbindReceptorTuple(int *retpublic, int *retprivate, str *name, str *cname)
{
	DCpump p;
	int i;

	p = DClocatePump(*name);
	if (p == 0)
		return throwMessage("datacell.bindReceptor", "unknown receptor");
	if (p->kind != RECEPTOR)
		return throwMessage("datacell.bindReceptor", "unknown receptor");
	mal_set_lock(p->lock, "datacellIsolate");
	for (i = 0; i < p->cols; i++)
		if (strcmp(p->columns[i], *cname) == 0) {
			if (p->usedby && p->usedby != p - pumps) {
				mal_unset_lock(p->lock, "datacellIsolate");

				return throwMessage("datacell.isolate", "Pump still in use\n");
			}

			BBPincref(*retpublic = p->public[i]->batCacheid, TRUE);
			BBPincref(*retprivate = p->private[i]->batCacheid, TRUE);
			p->usedby = p - pumps;
			break;
		}
	mal_unset_lock(p->lock, "datacellIsolate");

	return MAL_SUCCEED;
}

str
DCbindReceptorPublic(int *retpublic, str *name, str *cname)
{
	DCpump p;
	int i;

	p = DClocatePump(*name);
	if (p == 0)
		return throwMessage("datacell.bindReceptor", "unknown receptor");
	if (p->kind != RECEPTOR)
		return throwMessage("datacell.bindReceptor", "unknown receptor");
	mal_set_lock(p->lock, "datacellIsolate");
	for (i = 0; i < p->cols; i++)
		if (strcmp(p->columns[i], *cname) == 0) {
			if (p->usedby && p->usedby != p - pumps) {
				mal_unset_lock(p->lock, "datacellIsolate");

				return throwMessage("datacell.isolate", "Pump still in use\n");
			}
			p->usedby = p - pumps;
			BBPincref(*retpublic = p->public[i]->batCacheid, TRUE);
			break;
		}
	mal_unset_lock(p->lock, "datacellIsolate");

	return MAL_SUCCEED;
}

@-
The process thread for a channel should differentiate between
receptor/emitter and active/passive communication.
@c
str
DClistenReceptor(DCpump p, str *Usockfile)
{
	struct sockaddr_in server;
	int sock = -1;
	SensorInfo sensor = GDKmalloc(sizeof(SensorInfo));

#ifdef HAVE_SYS_UN_H
	struct sockaddr_un userver;
#endif
	SOCKLEN length = 0;
	int on = 1;
	int i = 0;
	int pid, *pidp = &pid;
	char *usockfile, host[512];

	channel = p;
	if (Usockfile == NULL || *Usockfile == 0 || strcmp(*Usockfile, str_nil) == 0)
		usockfile = NULL;
	else {
#ifdef HAVE_SYS_UN_H
		usockfile = GDKstrdup(*Usockfile);
#else
		usockfile = NULL;
		GDKwarning("DClistenReceptor: Unix domain sockets are not supported\n");
#endif
	}

	if (p->port <= 0 && usockfile == NULL)
		return throwMessage("datacell.listen", "no port or socket file specified\n");

	if (p->port > 0) {
		sock = socket(AF_INET, SOCK_STREAM, 0);
		if (sock < 0)
			return throwMessage("datacell.listen", "creation of stream socket failed\n");
@-
Set server port and allow network connections from any workstation.
Bind the socket to the server port.
The port id should be obtained from the Homes file.
@c
		server.sin_family = AF_INET;
		server.sin_addr.s_addr = INADDR_ANY;
		server.sin_port = htons((unsigned short) ((p->port) & 0xFFFF));
		for (i = 0; i < 8; i++)
			server.sin_zero[i] = 0;

		setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (char *) &on, sizeof on);

		length = (SOCKLEN) sizeof(server);
		if (bind(sock, (SOCKPTR) & server, length) < 0)
			return throwMessage("datacell.listen", "binding to stream socket failed\n");
@-
Get the new information for the server socket and start listening.
@c
		if (getsockname(sock, (SOCKPTR) & server, &length) < 0)
			return throwMessage("datacell.listen", "Failed getting socket name\n");
		listen(sock, 1);
	}
#ifdef HAVE_SYS_UN_H
	if (usockfile) {
		usock = socket(AF_UNIX, SOCK_STREAM, 0);
		if (usock < 0) {
			unlink(usockfile);
			return throwMessage("datacell.listen", "creation of Unix socket failed\n");
		}
		userver.sun_family = AF_UNIX;
		strncpy(userver.sun_path, usockfile, sizeof(userver.sun_path));

		length = (SOCKLEN) sizeof(userver);
		if (bind(usock, (SOCKPTR) & userver, length) < 0) {
			unlink(usockfile);
			return throwMessage("datacell.listen", "binding to Unix socket file failed\n");
		}
		listen(usock, 1);
	}
#endif

#ifdef DEBUG_DC_RECEPTOR
	THRprintf(GDKerr, "DClisten:Network started at %d\n", p->port);
#endif
	sensor->socket = sock;

	p->status = 1;
	if (MT_create_thread((MT_Id *) pidp, (void (*)(void *)) DClistenThread, sensor) < 0) {
		return throwMessage("datacell.listen", "starting thread failed");
	}
#ifdef HAVE_SYS_UN_H
	if (usockfile)
		unlink(usockfile);
#endif
	if (p->host == 0)
		gethostname(host, (int) 512);
	else
		strcpy(host, p->host);
#ifdef DEBUG_DC_RECEPTOR
	{
		char msg[512];

		snprintf(msg, (int) 512, "#Ready to read sensor data from connection %s:%d\n", host, p->port);
		stream_printf(GDKout, "%s", msg);
	}
#endif
	return MAL_SUCCEED;
}

@+ The collector
Each sensor once activate is controlled by a separate thread,
which listens to the port until the sensor is released.
If the stream breaks, it will save the data to disk and
also once every 1000 events (to be refined)

The current implementation taps into the ASCII io reader,
which means we are expecting MonetDB tuple format descriptions.
Furthermore, we overload the first and last table field operation
to acquire and release the lock held on the receptor.
This way, a pump query can step in and collect the events
received.
@c
ptr *
singleRecognition(void *extra, int type, char *s)
{
	DCpump p = (DCpump) extra;
	ptr i;
	oid o = oid_nil;
	timestamp ts;

	i = TABLETadt_frStr(extra, type, s);
	/* insert a time stamp */
	MTIMEcurrent_timestamp(&ts);
	BUNins(p->private[0], &o, &ts);
	return i;
}

ptr *
startRecognition(void *extra, int type, char *s)
{
	return TABLETadt_frStr(extra, type, s);
}

ptr *
endRecognition(void *extra, int type, char *s)
{
	DCpump p = (DCpump) extra;
	timestamp ts;
	oid o = oid_nil;

	/* insert a time stamp */
	MTIMEcurrent_timestamp(&ts);
	BUNins(p->private[0], &o, &ts);
	return TABLETadt_frStr(extra, type, s);
}

str
DCstartChannel(DCpump p, bstream *bs)
{
	Tablet as;
	int i, res, k = 0;
	Column *fmt;

#ifdef DEBUG_DC_RECEPTOR
	stream_printf(GDKout, "#Start sensor reception %s %d columns\n", p->name, p->cols);
#endif
	fmt = as.format = (Column *) GDKmalloc(sizeof(Column) * (MAXEVENTFIELDS + 1));
	memset((char *) fmt, 0, sizeof(Column) * (MAXEVENTFIELDS + 1));
	as.offset = 0;
	as.nr_attrs = 0;
	as.nr = (size_t) oid_nil;

	/* construct the read structure */
	/* the first column should be dealt with separately */
	/* it should contain the timestamps */
	for (i = 1; i < p->cols; i++) {
		fmt[k].name = p->columns[i];
		fmt[k].bval = p->private[i];
#ifdef DEBUG_DC_RECEPTOR
		stream_printf(GDKerr, "#added field %s\n", fmt[k].name);
#endif
		fmt[k].sep = GDKstrdup((char *) ",");
		fmt[k].seplen = (int) strlen(fmt[k].sep);
		fmt[k].adt = fmt[k].bval->ttype;
		fmt[k].type = (char *) getTypeName(fmt[k].adt);
		fmt[k].tostr = &TABLETadt_toStr;
		fmt[k].frstr = &TABLETadt_frStr;
		fmt[k].extra = NULL;
		k++;
	}
	GDKfree(fmt[k - 1].sep);
	fmt[k - 1].sep = GDKstrdup((char *) "\n");
	fmt[k - 1].seplen = (int) strlen(fmt[k - 1].sep);
	as.nr_attrs = k;
	fmt[0].frstr = &startRecognition;
	fmt[0].extra = (void *) p;
	fmt[k - 1].frstr = &endRecognition;
	fmt[k - 1].extra = (void *) p;
	if (k - 1 == 0)
		fmt[0].frstr = &singleRecognition;
	/* here we fork and prepare for reading */
#ifdef DEBUG_DC_RECEPTOR
	stream_printf(GDKerr, "#start loading sensor data\n");
#endif
@-
Reading the stream is interleaved with interactions from the
pump scheduler. During the actual parsing of information the
pump scheduler is locked out from accessing the receptor table.
This scheme works under the assumption that the TABLEload_file
is interrupted with each stream_flush from the sensorSource.
@c
	res = 1;
	while (p->status && res > 0 && !stream_errnr(bs->s)) {
		lng start = GDKusec();
		bs->eof = 0;

		as.nr = ~(size_t) 0;
		res = TABLETload_file(&as, bs);

#ifdef DEBUG_DC_RECEPTOR
		stream_printf(GDKerr, "#load %d events\n", res);
#endif
		p->ticks += GDKusec() - start;
		p->pending += res;
		p->received += res;
		if (res)
			p->calls++;
	}
	for (i = 0; i < k; i++) {
		GDKfree(fmt[i].sep);
	}
	GDKfree(fmt);
	return MAL_SUCCEED;
#ifdef DEBUG_DC_RECEPTOR
	stream_printf(GDKerr, "#finished receiving data\n");
#endif
}

@-
The listen thread operation now simply opens the connection
and passed control to the file loading.
@c

str
DClistenThread(SensorInfo sensor)
{
	char *msg = 0;
	stream *fdin;
	bstream *bs;

#ifdef DEBUG_DC_RECEPTOR
	stream_printf(GDKerr, "#Reading thread started\n");
#endif
	do {
		int retval;
		struct timeval tv;
		fd_set fds;
		int msgsock;
		int sock = sensor->socket;

		FD_ZERO(&fds);
		if (sock >= 0)
			FD_SET(sock, &fds);
#ifdef HAVE_SYS_UN_H
		if (usock >= 0)
			FD_SET(usock, &fds);
#endif
		/* Wait up to 0.5 seconds. */
		tv.tv_sec = 0;
		tv.tv_usec = 500;

		/* temporarily use msgsock to record the larger of sock and usock */
		msgsock = sock;
#ifdef HAVE_SYS_UN_H
		if (usock > sock)
			msgsock = usock;
#endif
		retval = select(msgsock + 1, &fds, NULL, NULL, &tv);
		if (retval == 0) {
			/* nothing interesting has happened */
			continue;
		}
		if (retval < 0) {
			if (MT_geterrno() != EINTR) {
				msg = "select failed\n";
				goto error;
			}
			continue;
		}
		if (sock >= 0 && FD_ISSET(sock, &fds)) {
			if ((msgsock = accept(sock, (SOCKPTR) 0, (SOCKLEN *) 0)) < 0) {
				if (MT_geterrno() != EINTR) {
					msg = "accept failed\n";
					goto error;
				}
				continue;
			}
#ifdef HAVE_SYS_UN_H
		} else if (usock >= 0 && FD_ISSET(usock, &fds)) {
			if ((msgsock = accept(usock, (SOCKPTR) 0, (SOCKLEN *) 0)) < 0) {
				if (MT_geterrno() != EINTR) {
					msg = "accept failed\n";
					goto error;
				}
				continue;
			}
#endif
		} else
			continue;
#ifdef DEBUG_DC_RECEPTOR
		stream_printf(GDKerr, "#receptor connection request:accepted\n");
#endif
		fdin = socket_rstream(msgsock, "DataCell receptor input");

		if (fdin == 0 || stream_errnr(fdin)) {
			GDKsyserror("DClisten:fdin problems\n");
			continue;
		}

		fdin = block_stream(fdin);

#ifdef DEBUG_DC_RECEPTOR
		stream_printf(GDKerr, "#DClisten:channel accepted %d\n", msgsock);
#endif
		bs = bstream_create(fdin, 4 * BLOCK);

		/* now read the stream until it is closed */
		msg = DCstartChannel(channel, bs);

#ifdef DEBUG_DC_RECEPTOR
		stream_printf(GDKerr, "#DClisten:channel reading finished\n");
#endif

	} while (msg == MAL_SUCCEED);
      error:
	return throwMessage("datacell.listen", msg);
}

@}
