@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.
@f dc_compiler
@a M.L. Kersten
@+ The pump queries
The transformations within the DataCell are described by
ordinary SQL batches that empty containers and produce
result.

This requires a link with the SQL compiler to delegate
compilation of the expressions into a MAL function.

@- Implementation
@mal
command datacell.compiler(name:str,expr:str):str
address DCsqlCompiler
comment "Compile the expression into a MAL program";

command datacell.pump(name:str, lang:str, query:str)
address DCpumpDefinition
comment "Define a data pump query.";
@-
@{
@h
#ifndef _DATACELL_COMPILER
#define _DATACELL_COMPILER

#define DEBUG_DATACELL

#include "mal.h"
#include "datacell.h"

dc_export str SQLcompile(str *ret, str *expr, int *flag);
dc_export str DCmakePlans(int *ret, str *nme, str *newname);
dc_export str DCsqlReshuffle(MalBlkPtr mb, str newname);
dc_export void DCflowDependencies(DCpump p);

#endif /* _DATACELL_COMPILER */
@-
@c
#include "dc_compiler.h"
#include "mal_client.h"
#include "mal_namespace.h"
#include "mal_interpreter.h"
#include "mal_exception.h"
#include "mal_builder.h"
#include "../optimizer/mal_optimizer.h"
#include "../optimizer/mal_emptyset.h"
#include "../optimizer/mal_singleton.h"
#include "../optimizer/mal_peephole.h"
#include "../modules/mal/tablet.h"

#define _DC_COMPILE_DEBUG

@-
The DataCell containers are all mapped to relational tables
in SQL terms. This is the basis for compiling the queries.
The implementation currently generates the schema from scratch
to study its overhead later on from re-use

To simplify the current implementation, all table
definitions are immediately sent to the SQL compiler.
We keep track on their number and avoid sending them twice.
This only works in a growing system.
@c
static int containers = 0;

str
MAL2SQLtype(int tpe)
{
	switch (tpe) {
	case TYPE_str:
		return GDKstrdup("varchar");
	case TYPE_chr:
		return GDKstrdup("char");
	case TYPE_lng:
		return GDKstrdup("long");
	case TYPE_bit:
		return GDKstrdup("boolean");
	case TYPE_dbl:
		return GDKstrdup("double");
	case TYPE_flt:
		return GDKstrdup("float");
	}
	return getTypeName(tpe);
}

str
SQLcompile(str *ret, str *expr, int *flag)
{
	(void) ret;
	(void) expr;
	(void) flag;
	return MAL_SUCCEED;
}

str
DCcompileQuery(str *ret, str *expr, str *name)
{
	DCpump p;
	char *buf;
	int k = 0;
	size_t i = 0, len = 0;
	str msg = MAL_SUCCEED, tpe;
	int flag = 0;		/* do not keep the catalog changes */

	len = pumpindex * 1024;
	buf = alloca(len);

	for (p = pumps; p < pumps + pumpindex; p++)
		if (p->name) {
			i = 0;
			buf[i] = 0;
			sprintf(buf, "create table %s (", p->name);
			i += strlen(buf);
			for (k = 0; k < p->cols; k++) {
				tpe = MAL2SQLtype(p->types[k]);
				if (k)
					sprintf(buf + i, ", %s %s", p->columns[k], tpe);
				else
					sprintf(buf + i, "%s %s", p->columns[k], tpe);
				i += strlen(buf + i);
				GDKfree(tpe);
			}
			sprintf(buf + i, ");\n");
			i += strlen(buf + i);
			i += strlen(buf + i);
			if (k > 0) {
				msg = SQLcompile(ret, &buf, &flag);
				if (msg)
					stream_printf(GDKout, "%s", msg);
				/* ignore possible errors raised by duplicate definition */
				getClient()->errbuf[0] = 0;
			}
#ifdef _DC_COMPILE_DEBUG
			stream_printf(GDKout, "SQL:\n%s\n", buf);
			stream_printf(GDKout, "returns:%s\n", msg);
#endif
			containers++;
		}
	i = 0;
	buf[i] = 0;
	flag = 0;

#ifdef _DC_COMPILE_DEBUG
	stream_printf(GDKout, "SQL:\n%s\n", buf);
#endif

	if (i + strlen(*expr) < len) {
		sprintf(buf + i, "%srollback;", *expr);
	} else
		sprintf(buf + i, "too long;");
#ifdef _DC_COMPILE_DEBUG
	stream_printf(GDKout, "datacell.compile:%s\n", *expr);
	stream_printf(GDKout, "SQL:\n%s\n", buf);
#endif
	msg = SQLcompile(ret, &buf, &flag);
	if (msg == MAL_SUCCEED) {
		msg = DCmakePlans(&flag, ret, name);
	}
	return msg;
}

str
DCsqlCompiler(str *ret, str *name, str *expr)
{
	return DCcompileQuery(ret, expr, name);
}

str
DCpumpDefinition(int *ret, str *name, str *lang, str *qry)
{
	DCpump p;
	str prg, msg = MAL_SUCCEED;
	Symbol s;

	(void) ret;

	if (DClocatePump(*name))
		return throwMessage("datacell.pump", "pump re-defined");
	p = DCnewPump();
	DCstamp(p);
	if (p->cols < p->cap) {
		p->columns[p->cols] = GDKstrdup("duration");
		p->types[p->cols] = TYPE_int;
		p->private[p->cols] = DCcontainer(TYPE_int, 256);
		p->public[p->cols++] = DCcontainer(TYPE_int, 256);
		p->columns[p->cols] = GDKstrdup("status");
		p->types[p->cols] = TYPE_str;
		p->private[p->cols] = DCcontainer(TYPE_str, 256);
		p->public[p->cols++] = DCcontainer(TYPE_str, 256);
	} else
		return throwMessage("datacell.define", "out of column space");
	p->kind = NUCLEUS;
	p->name = GDKstrdup(*name);
	p->lang = GDKstrdup(*lang);
	p->query = GDKstrdup(*qry);
	p->scheduler = 1;	/* default to naive scheduling */
	if (strcmp("sql", *lang) == 0) {
		msg = DCcompileQuery(&prg, qry, name);
		/* renameFunction(prg,"pumps",*name); */
		p->mal[0] = GDKstrdup(*name);
		s = findMALSymbol(putName("pumps", 5), putName(*name, strlen(*name)));
		if (s == 0)
			return throwMessage("datacell.pump", "symbol not found");
		p->malblk[0] = s->def;
		/* DCflowDependencies(p); */
	} else
		return throwMessage("datacell.pump", "Non-supported language");
	return msg;
}

@-
The output of the SQL compiler is first cleaned up, such that
it becomes easier to manipulate.
This cleanup involves removal of all sql.column and sql.output
statements, while the sql.bind instruction should be replaced
with the datacell bind operation.
@= tstName
	( getName(@2,strlen(@2)) == moduleId(@1) &&
	  getName(@3,strlen(@3)) == functionId(@1) )
@-
The code should comply with the optimizer policies, such
as performing double checks before the function returns
the new code block.
@c
str
DCplan(MalBlkPtr mb, str newname)
{
	lng clk = GDKusec();
	int i, j, k, actions = 0;
	InstrPtr p, q;
	int *emptyset, z = 0;

	emptyset = alloca(mb->stop * sizeof(int *));
	for (j = i = 1; i < mb->stop; i++) {
		p = getInstrPtr(mb, i);
		if (@:tstName(p,"sql","output")@ || @:tstName(p,"sql","column")@) {
			/* skip it */
			freeInstruction(p);
			continue;
		}
		if (@:tstName(p,"bat","setWriteMode")@) {
			for (k = j - 1; k >= 0; k--) {
				q = getInstrPtr(mb, k);
				if (getArg(p, 1) == getArg(q, 0) && @:tstName(q,"datacell","bind")@) {
					/* no duplicate mode setting */ ;
					freeInstruction(p);
					break;
				}
			}
			continue;
		}
		if (@:tstName(p,"sql","bind_dbat")@) {
			if (isReceptor(getVarLiteral(mb, getArg(p, 2)))) {
				emptyset[z++] = getArg(p, 0);
				freeInstruction(p);
				continue;
			} else if (isEmitter(getVarLiteral(mb, getArg(p, 2)))) {
				emptyset[z++] = getArg(p, 0);
				freeInstruction(p);
				continue;
			}
@-
The dbat can only be dropped for connection points.[todo]
@c
		}
		if (@:tstName(p,"sql","bind")@) {
			/* tst name to determine its kind */
			if (isReceptor(getVarLiteral(mb, getArg(p, 2)))) {
				delArgument(p, 4);
				delArgument(p, 1);
				setFunctionId(p, putName("bindReceptor", 12));
			}
			if (isEmitter(getVarLiteral(mb, getArg(p, 2)))) {
				delArgument(p, 4);
				delArgument(p, 1);
				setFunctionId(p, putName("bindEmitter", 11));
			}
			setModuleId(p, putName("datacell", 8));
			typeChecker(getClient()->nspace, mb, p, TRUE);
		}
		getInstrPtr(mb, j) = p;
		j++;
	}
	mb->stop = j;
#ifdef _DC_COMPILE_DEBUG
	stream_printf(GDKout, "finished reduction :%d errors:\n", mb->errors);
	printFunction(GDKout, mb, LIST_MAL_ALL);
#endif
@-
We now can propagate knowledge about empty sets and perform
some peephole optimization.
@c
	ESevaluate(mb, z, emptyset);
	PHoptimizer(mb, 0, 0);
	DCsqlReshuffle(mb, newname);
	optimizerCheck(mb, "datacell.reduce", actions, GDKusec() - clk);
	printFunction(GDKout, mb, LIST_MAL_ALL);
	return MAL_SUCCEED;
}

str
DCmakePlans(int *ret, str *nme, str *newname)
{
	Symbol s;
	MalBlkPtr mb;
	DCpump pump;
	InstrPtr p;
	char buf[128];
	int i, idx, *es;

	(void) ret;
	s = findMALSymbol(putName("user", 4), putName(*nme, strlen(*nme)));
	if (s == 0)
		return throwMessage("datacell.makePlans", "symbol not found");
	pump = DClocatePump(*newname);
	if (pump == 0)
		return throwMessage("datacell.makePlans", "pump not found");
	mb = s->def;

	es = alloca(mb->vtop);
	PHoptimizer(mb, 0, 0);
@-
We are using three different plans based on the cardinality of the
first receptor argument.
@c
	i = getArg(getInstrPtr(mb, 0), 0);

	pump->mal[0] = GDKstrdup(*newname);
	s = newSymbol(putName(*newname, strlen(*newname)), FUNCTIONsymbol);
	GDKfree(s->def);
	s->def = pump->malblk[0] = copyMalBlk(mb);
	p = getInstrPtr(s->def, 0);
	setModuleId(p, putName("pumps", 5));
	setFunctionId(p, putName(*newname, strlen(*newname)));
	s->def->var[i]->name = GDKstrdup(*newname);

	insertSymbol(getClient()->nspace, s);

	snprintf(buf, 128, "%s0", *newname);
	pump->mal[1] = GDKstrdup(buf);
	s = newSymbol(putName(buf, strlen(buf)), FUNCTIONsymbol);
	GDKfree(s->def);
	s->def = pump->malblk[1] = copyMalBlk(mb);
	p = getInstrPtr(s->def, 0);
	setModuleId(p, putName("pumps", 5));
	setFunctionId(p, putName(buf, strlen(buf)));
	s->def->var[i]->name = GDKstrdup(buf);

	insertSymbol(getClient()->nspace, s);

	snprintf(buf, 128, "%s1", *newname);
	pump->mal[2] = GDKstrdup(buf);
	s = newSymbol(putName(buf, strlen(buf)), FUNCTIONsymbol);
	GDKfree(s->def);
	s->def = pump->malblk[2] = copyMalBlk(mb);
	p = getInstrPtr(s->def, 0);
	setModuleId(p, putName("pumps", 5));
	setFunctionId(p, putName(buf, strlen(buf)));
	s->def->var[i]->name = GDKstrdup(buf);

	insertSymbol(getClient()->nspace, s);

#ifdef _DC_COMPILE_DEBUG
	stream_printf(GDKout, "start reduction %s:\n", (mb->errors ? "errors" : ""));
	printFunction(GDKout, s->def, LIST_MAL_ALL);
#endif
@-
The raw MAL programs are first refined to deal also
with the empty set and singleton set.
@c
	idx = 0;
	for (i = 0; i < mb->stop; i++) {
		p = getInstrPtr(mb, i);
		if (@:tstName(p,"sql","bind")@ &&isReceptor(getVarLiteral(mb, getArg(p, 2)))) {
			es[idx] = getArg(p, 0);
			idx++;
		}
	}
	DCplan(pump->malblk[0], *newname);

	printf("OPTIMIZE EMPTYSET TO ARGUMENT %d\n", es[0]);
	ESevaluate(pump->malblk[1], idx, es);
	DCplan(pump->malblk[1], *newname);

	if (idx > 0) {
		DCplan(pump->malblk[2], *newname);
		printf("OPTIMIZE SINGLETONSET ON ARGUMENT %d\n", es[0]);
		STevaluate(pump->malblk[2], idx, es);
		DCoptimizer(pump->malblk[2], 0, 0);
	}
	return MAL_SUCCEED;
}

@-
The final step in the preparation of the pump plan is to
separate the reading/writing of the connection point tables
and to guarantee there is no interference from concurrency.
This relies on functions in the datacell to make a private
copy available for the routine and to securely write
the result into an emitter table.
@c
str
isEmitterDestination(MalBlkPtr mb, int varid)
{
	InstrPtr p;
	int i;

	for (i = 0; i < mb->stop; i++) {
		p = getInstrPtr(mb, i);
		if (getArg(p, 0) == varid && strcmp(functionId(p), "bindEmitter") == 0) {
			return getVarLiteral(mb, getArg(p, 1));
		}
	}
	return 0;
}

str
DCsqlReshuffle(MalBlkPtr mb, str newname)
{
	int i, j, limit;
	InstrPtr p, *old;
	str *points, unit;
	int u = 0;

#ifdef _DC_COMPILE_DEBUG
	stream_printf(GDKout, "start reshuffle :\n");
#endif
	(void) newname;
	old = mb->stmt;

	limit = mb->stop;
	points = alloca(mb->stop * sizeof(str));
	newMalBlkStmt(mb, mb->stop + 4);

	pushInstruction(mb, old[0]);
@-
First step is to collect the receptor/emitter bindings.
@c
	for (i = 1; i < limit - 1; i++)
		if (strncmp(functionId(old[i]), "bind", 4) == 0 && strcmp(moduleId(old[i]), "datacell") == 0) {
			pushInstruction(mb, old[i]);
			unit = getVarLiteral(mb, getArg(old[i], 1));
			for (j = 0; j < u; j++)
				if (strcmp(points[j], unit) == 0)
					break;
			if (j == u)
				points[u++] = unit;
		} else if (match(old[i], "bat", "append") && (unit = isEmitterDestination(mb, getArg(old[i], 1)))) {
			setFunctionId(old[i], putName("keep", 4));
			setModuleId(old[i], putName("datacell", 8));
			old[i] = setArgument(mb, old[i], 1, newConstant(mb, TYPE_str, GDKstrdup(unit), TRUE));
			pushInstruction(mb, old[i]);
		} else
			pushInstruction(mb, old[i]);
@- 
The receptor can be released, because we have consumed all
relevant information.
@c
	for (j = u - 1; j >= 0; j--) {
		p = newFcnCall(mb, getName("datacell", 8), getName("release", 7));
		pushStr(mb, p, points[j]);
		setVarType(mb, getArg(p, 0), TYPE_void);
	}
	pushInstruction(mb, old[i]);	/* end instruction */
	GDKfree(old);
	return MAL_SUCCEED;
}

@-
After the compilation to the DataCell has been completed,
it is possible to automatically derive the inflow and outflow
relationships for the pump. This information is stored in the
pump descriptor directly.
@c
void
DCflowDependencies(DCpump p)
{
	int in, out, i, j, k;
	str nme;
	InstrPtr q;
	Symbol s;
	MalBlkPtr mb;

#ifdef _DC_COMPILE_DEBUG
	stream_printf(GDKout, "derive flow dependencies \n");
#endif
	for (i = 0; i < p->cap && p->mal[i]; i++) {
		s = findMALSymbol(putName("user", 4), putName(p->mal[i], strlen(p->mal[i])));
		if (s == 0)
			continue;
		mb = s->def;
		for (j = 0; j < p->cap && p->source[j]; j++)
			GDKfree(p->source[j]);
		in = 0;
		for (j = 0; j < p->cap && p->sink[j]; j++)
			GDKfree(p->source[j]);
		out = 0;
		for (j = 1; j < mb->stop; j++) {
			q = getInstrPtr(mb, j);
			if (match(q, "datacell", "bindReceptorPublic")) {
				nme = getVarLiteral(mb, getArg(q, 2));
				for (k = 0; k < in; k++)
					if (strcmp(p->source[k], nme))
						p->source[in++] = GDKstrdup(nme);
					else
						goto skipit;
#ifdef _DC_COMPILE_DEBUG
				stream_printf(GDKout, "add source :%s\n", nme);
#endif
			} else if (match(q, "datacell", "bindEmitter")) {
				nme = getVarLiteral(mb, getArg(q, 2));
				for (k = 0; k < out; k++)
					if (strcmp(p->sink[k], nme))
						p->sink[out++] = GDKstrdup(nme);
					else
						goto skipit;
#ifdef _DC_COMPILE_DEBUG
				stream_printf(GDKout, "add sink :%s\n", nme);
#endif
			}
		}
	      skipit:;
	}
}

@}
