@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.

@f mil
@t MIL Scenario implementation
@a M Kersten 
@v 0
@* MIL Scenario implementation
The MonetDB Interpreter Language (MIL) has been replaced by a more
rigid, but much faster intermediate language. To support some backward
compatibility a MIL scenario framework has been designed, which gives
MIL diehards the means to migrate their old code. Simple instructions,
i.e. without runtime dependent type resolution, can be executed as well.

An old program <prg> can be precompiled to MIL using the 
command line
Mserver --dbinit="include mil;mil.compile();" <prg>
[CHECK]
@mal
module mil;

command start():void 
address CMDMILsession
comment "Switch to processing MIL statements";

command compile():void 
address CMDMILcompileOnly
comment "Compile a MIL program, don;t execute";

command compile(fname:str):void 
address CMDMILcompile
comment "Compile a MIL file, don;t execute";

# mil.line is obsolete, produced by previous compiler
command line(msg:str):void
address MILline
comment "Produce comment for tracking the MIL code produced";

include mil_utils;
#include mil_commands; needs some work
@h
#ifndef _MIL_SCENARIO_H
#define _MIL_SCENARIO_H
#include "mal_function.h"
#include "mal_client.h"
#include "mal_session.h"
#include "mal_parser.h"

#ifdef _MSC_VER
#ifndef LIBMIL
#define mil_export extern __declspec(dllimport)
#else
#define mil_export extern __declspec(dllexport)
#endif
#else
#define mil_export extern
#endif

mil_export str MILreader(Client c);
mil_export str MILparser(Client c);
mil_export str MILengine(Client c);
mil_export void enterMILscope(Client c);
mil_export void leaveMILscope(Client c);
#endif
@-
The MIL compilation environment is tagged with the client record.
The identifiers form a linear list. The scope list tells for each how
many variables are introduced, such that trimming the scope list is easy.
@c
#include "mal_interpreter.h"
#include "mal_linker.h"
#include "mil.h"
#include "mil_parser.h"

/* #define _MIL_SCENARIO_DEBUG*/

mil_export str MILline(int *ret, str *msg);
mil_export str CMDMILcompileOnly(int *ret);
mil_export str CMDMILcompile(int *ret, str *fname);
mil_export str CMDMILsession(str *ret);

str
MILinit(Client cntxt)
{
#ifdef _MIL_SCENARIO_DEBUG
	stream_printf(GDKout, "#MILinit MonetDB V5\n");
#endif
	/* load the modules */
	malInclude(cntxt, "mil_algebra_procs", "mil_algebra_procs", 0);
	malInclude(cntxt, "mil_system_procs", "mil_system_procs", 0);
	(void) cntxt;
	return MAL_SUCCEED;
}

str
MILexit(Client cntxt)
{
	(void) cntxt;
	/* nothing to be done */
	return MAL_SUCCEED;
}

str
MILinitClient(Client c)
{
	if (c->yycur) {
		c->fdin->pos += c->yycur;
		c->yycur = 0;
		c->fdin->buf[c->fdin->pos] = 0;
	}
#ifdef _MIL_SCENARIO_DEBUG
	stream_printf(GDKout, "#MILinitClient\n");
#endif
	if (c->state[PARSER] == 0) {
		MILbackend be = newMILbackend();

		c->state[PARSER] = (void *) be;
	}
	c->fdin->eof = 1;	/* force prompt on first iteration */
	return MAL_SUCCEED;
}

str
MILexitClient(Client c)
{
#ifdef _MIL_SCENARIO_DEBUG
	stream_printf(GDKout, "#MILexitClient\n");
#endif
	if (c->state[PARSER]) {
		GDKfree(c->state[PARSER]);
		c->state[PARSER] = 0;
	}
	MALexitClient(c);
	return MAL_SUCCEED;
}

@-
The MIL reader collects a (sequence) of statements from the input
stream, but only when no unresolved 'nxt' character is visible.
Actually, we can use the MAL reader for this purpose.
@c
str
MILreader(Client c)
{
	int go = TRUE;
	lng T0;
	bstream *in = c->fdin;
	MILbackend be = (MILbackend) c->state[PARSER];
	int language = 'M';	/* 'M' for MIL, 'D' for debugger */

#ifdef _MIL_SCENARIO_DEBUG
	stream_printf(GDKout, "#MILparser: start reading MIL block\n");
#endif
	if (c->mode <= FINISHING)
		return throwMessage("MILreader", "end of MIL input\n");

@-
Continue processing any left-over input from the previous round.
@c
	T0 = GDKusec();
	/* clean the input buffer, we eat it all */
	c->fdin->pos = c->fdin->len;
	c->fdin->eof = 1;
#ifdef _MIL_SCENARIO_DEBUG
	stream_printf(GDKout, "#pos %d len %d\n", in->pos, in->len);
#endif
	if (in->pos >= in->len) {
		ssize_t rd;

		assert(in->pos == in->len);

		if (in->eof || !isa_block_stream(in->s)) {
			language = 0;

			if (go && (stream_write(c->fdout, c->prompt, c->promptlength, 1) != 1 || stream_flush(c->fdout))) {
				go = FALSE;
			}
			in->eof = 0;
		}
		if (go && (rd = bstream_next(in)) <= 0) {
#ifdef _MIL_SCENARIO_DEBUG
			stream_printf(GDKout, "#rd %d  eof %d\n", rd, in->eof);
#endif
			if (language == 'D' && in->eof == 0)
				return 0;
			if (rd == 0 && in->eof) {
				/* we hadn't seen the EOF before, so just try again
				   (this time with prompt) 
				   MILreader(c);
				 */
				go = FALSE;
			} else if (rd == 0 && in->eof == 0) {
				return 0;
			} else {
				go = FALSE;
			}
			if (go && !isAdministrator(c) && language == 0)
				language = in->buf[in->pos++];
		}
	}
#ifdef _MIL_SCENARIO_DEBUG
	stream_printf(GDKout, "#MIL blk:%s\n", in->buf + in->pos);
#endif
	if (!go || (strncmp(CURRENT(c), "quit", 4) == 0)) {
		in->pos = in->len;	/* skip rest of the input */
		c->mode = FINISHING;
		return throwMessage("MILreader", "end of MIL input\n");
	}
	be->readtime = (long) (GDKusec() - T0);
	return MAL_SUCCEED;
}

@- 
Now we have an input buffer with the MIL program. This can be processed by the M2m
parser. 
@= restoreState
	showErrors();
	if( c->listing)
			printFunction(c->fdout,c->curprg->def, c->listing);
	stream_flush(c->fdout);
	/*initClientPrg(c,"main");*/
	/*resetInstructions(c->curprg->def, oldstate.stop);*/
	/* resetVariables(c->curprg->def, @1, oldstate.vtop);*/
@c

str
MILparserAll(Client c, int flag)
{
	lng T0 = 0;
	str msg = MAL_SUCCEED;
	MILbackend be = c->state[PARSER];
	InstrPtr p;

#ifdef _MIL_SCENARIO_DEBUG
	stream_printf(GDKout, "compile:%s\n", CURRENT(c));
#endif
	if (be == NULL) {
		/* MIL context not yet initialized, catchup */
		MILinitClient(c);
		be = c->state[PARSER];
		if (be == NULL)
			GDKfatal("MILparser", "internal error\n");
	}
	T0 = GDKusec();
	c->curprg->def->errors = 0;

@-
Prescan the input to make processing easier
@c
	nextChar(c);
	c->yycur--;
	prepareMalBlk(c->curprg->def, CURRENT(c));
	if (parseMILprg(c, c->curprg->def) || c->curprg->def->errors || c->errbuf[0]) {
		@:restoreState(0)@
		return throwMessage("MILparser", "Parser errors\n");
	}

@-
The parser has received a MIL correct statement. Now it is time
to check the MAL program.
@c
	/* empty blocks can be skipped */
	if (c->curprg->def->stop == 1) {
#ifdef MIL_SCENARIO_DEBUG
		stream_printf(GDKout, "#empty MIL block ignored\n");
#endif
		return MAL_SUCCEED;
	}
	p = getInstrPtr(c->curprg->def, 0);
	if (p->token != FUNCTIONsymbol) {
		@:restoreState(0)@
		return throwMessage("MILparser", "Function signature error\n");
	}
	pushEndInstruction(c->curprg->def);
	chkProgram(c->nspace, c->curprg->def);
	trimMalBlk(c->curprg->def);

	if (c->curprg->def->errors) {
#ifdef MIL_SCENARIO_DEBUG
		printFunction(c->fdout, c->curprg->def, LIST_MAL_ALL);
		stream_printf(GDKout, "#errors found ignored\n");
#endif
		@:restoreState(0)@
		return throwMessage("MILparser", "Semantic errors\n");
	}
	if (flag)
		printFunction(c->fdout, c->curprg->def, LIST_MAL_ALL);
#ifdef _MIL_SCENARIO_DEBUG
	else
		printFunction(c->fdout, c->curprg->def, LIST_MAL_ALL);
#endif
	stream_flush(c->fdout);
	be->parsetime = (long) (GDKusec() - T0);
	return msg;
}

str
MILparser(Client c)
{
	return MILparserAll(c, 0);
}

str
MILparser2(Client c)
{
	return MILparserAll(c, 1);
}

@-
Programs that pass the parsing and semantic checks can be taken into
execution.
@c
str
MILengine(Client c)
{
	lng T0;
	str msg = MAL_SUCCEED;
	MalStkPtr oldglb = c->glb;
	MILbackend be = (MILbackend) c->state[PARSER];

	if (c->curprg->def == 0)
		return throwMessage("MILengine", "Program contains errors\n");
#ifdef MIL_SCENARIO_DEBUG
	stream_printf(GDKout, "#Ready to execute MIL statements\n");
#endif
	if (c->curprg->def->errors) {
		@:restoreState@
		return throwMessage("MILengine", "Program contains errors\n");
	}
	T0 = GDKusec();
	if (c->curprg->def->stop == 1) {
#ifdef MIL_SCENARIO_DEBUG
		stream_printf(GDKout, "#empty MIL block ignored\n");
#endif
		return MAL_SUCCEED;	/* empty block */
	}
	if (c->glb) {
		if (c->curprg->def && c->glb->stksize < c->curprg->def->vsize)
			c->glb = reallocGlobalStack(c->glb, c->curprg->def->vsize);
		c->glb->stktop = c->curprg->def->vtop;
		c->glb->blk = c->curprg->def;
		c->glb->cmd = (c->itrace ? 'n' : 0);
	}
	if (c->listing)
		printFunction(GDKout, c->curprg->def, c->listing);
	if (c->glb)
		c->glb->pcup = 0;
	msg = runMAL(c, c->curprg->def, 1, 0, c->glb, 0);
	if (msg) {
		GDKerror(msg);
		if (!c->listing)
			printFunction(c->fdout, c->curprg->def, c->listing);
		showErrors();
	}
	resetInstructions(c->curprg->def, 1);
	resetVariables(c->curprg->def, c->glb, 0);
	c->curprg->def->errors = 0;
	c->glb = oldglb;
	be->exectime = (long) (GDKusec() - T0);
	return msg;
}

str
CMDMILsession(str *ret)
{
	str msg = MAL_SUCCEED;

	stream_printf(GDKout, "#Continue as MIL session\n");
	msg = setScenario(getClient(), "mil");
	*ret = 0;
	return msg;
}

str
CMDMILcompile(int *ret, str *fname)
{
	str msg = MAL_SUCCEED;
	Client c = getClient();
	char buf[1024];

	(void) ret;
	snprintf(buf, 1024, "%s/%s", c->cwd, *fname);
	setScenario(c, "milCompiler");
@-
Prescan the input to make processing easier
@c
	nextChar(c);
	c->yycur--;
	malInclude(c, buf, NULL, LIST_MAL_INSTR);
	showErrors();
	resetScenario(c);
	initClientPrg(c, "main");
	return msg;
}

str
CMDMILcompileOnly(int *ret)
{
	Client c;

	(void) ret;
	c = getClient();
	c->listing = LIST_MAL_INSTR;
	stream_printf(GDKout, "#Continue as MIL session\n");
	setScenario(c, "milCompiler");
	return MAL_SUCCEED;
}

str
MILline(int *ret, str *msg)
{
	(void) ret;
	stream_printf(GDKout, "#%s\n", *msg);
	return MAL_SUCCEED;
}
