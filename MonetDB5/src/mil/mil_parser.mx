@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.

@f mil_parser
@a M. L. Kersten
@v 3.0
@+ MIL compiler
MonetDB comes with its programming language called MIL
(Monet Interface Language). A large collection of MIL programs exists,
which ideally should run without problems on the MonetDB version 5 Kernel.
Unfortunately, life isn;t that easy. 
MIL was designed as a half-backed scripting language with
dynamic typing, variable re-use with different types,
little support for debugging, and permissive syntax.
Furthermore, the compiler was intimately coupled with the
runtime system, e.g. an identifier was immediately resolved
against the modules being loaded and variables known within the prevaling
scope.
This was necessary to resolve their context dependent interpretation.

In MonetDB 4.4 a cleanup of MIL has already taken place which strikes
a balance between forcing users to migrate to MAL and
to continue using their MIL code base. 
It is realized with a minimalistic compiler, which produces
MAL code for a large fragment of the MIL language. 
There is no information on the runtime status. 
In particular, it means there is no knowledge on pre-existing 
variables, type names, procedures, etc..

With a little care most MIL programs can be compiled
and run against the new kernel. 
The MonetDB test suites and predefined MIL proc's
have been used to define the language boundary to be supported.

In writing MIL code, the following rules should be kept obeyed:
@itemize
\begin{verbatim}
@item 
do not change the type of variables within their scope.
@item 
do not use type identifiers as ordinary variables
@item 
make the type of a 'nil' value explicity, e.g.  nil -> int(nil).
@end itemize
@{
@+ Implementation notes
The MIL parser is a recursive-descend implementation.
The parser produced follows the structure of the MAL parser
and produces a MAL block for direct execution.

The compiler has built-in knowledge of the types of Monet 4 and will
silently replace them with a type identifier. Likewise, an procedure
identifier mapping table is used to ease migration to the new setting.

@}
@-
Aside from syntax restrictions imposed, several command
signatures and command names have been changed.
They have to translated partly by hand.

For example, the BAT update routines do not return
their target variable. This means you can not cascade a series
of calls, e.g. the statement 
@example
 a.select(1,2).access(BAT_WRITE).rename("C");
 b.insert(0,1).insert(1,2);
@end example
should be split into multiple steps as follows:
@example
 a.select(1,2); a.access(BAT_WRITE); a.rename("C");
 b.insert(0,1); b.insert(1,2);
@end example

A major rewrite of the MIL program is required when
it inspects the runtime environment. See the bbp and inspection modules
for information on the operations available.
@{
@+ The lexical analyzer
It uses the features offered by the MAL parser.
@h
#ifndef _MIL_PARSER_H
#define _MIL_PARSER_H

#include "mal_builder.h"
#include "mal_parser.h"

#undef currChar
#define MAXSCOPES 128

typedef struct IDS {
	str nme;
	int varid;		/* MAL equivalent */
	int global;		/* constant */
	struct IDS *peer;
} *Ids;

typedef struct {
	Ids variables;
	int scopes[MAXSCOPES], lastscope;
	int iterators[MAXSCOPES];
	int itop;
	int block[MAXSCOPES];
	int btop;
	int constantdeclaration;
	long readtime;
	long parsetime;
	long exectime;
} *MILbackend;


mil_export MILbackend newMILbackend(void);
mil_export int parseMILprg(Client cntxt, MalBlkPtr curPrg);

#endif /* _MIL_PARSER_H */
@c
#include "mal_interpreter.h"
#include "mal_builder.h"
#include "mal_parser.h"
#include "mil.h"
#include "mil_parser.h"
extern int MALkeyword(Client cntxt, str kw, int length);


mil_export str mapfcn(str n);
mil_export str mapmod(str n);
mil_export int ismapped(str n);

#define BE(X) ((MILbackend)(X->state[PARSER]))
#define needMore(X)  currChar(X)	/* need at least one more character */
#define advanceMore(X,Y) {advance(X,Y); needMore(X);}

extern int parseMILtype(Client cntxt, MalBlkPtr currBlk, str tnme);
extern int parseMILexpr(Client cntxt, MalBlkPtr currBlk);
extern int parseMILfactor(Client cntxt, MalBlkPtr currBlk);
extern void parseMILstmt(Client cntxt, MalBlkPtr currBlk);
extern int parseMILstmtAll(Client cntxt, MalBlkPtr currBlk);
extern void parseMILstmtend(Client cntxt, MalBlkPtr currBlk);
extern void parseMILblock(Client cntxt, MalBlkPtr currBlk);
extern int parseMILfunctioncall(Client cntxt, MalBlkPtr currBlk, str nme);
extern void parseMILbatloop(Client cntxt, MalBlkPtr currBlk, int lhs);
extern str parseWarning(Client cntxt, str msg);

@-
The MIL parser may request for more information to complete a parsing request.
@c
char
currChar(Client c)
{
	if (*CURRENT(c) == 0) {
		MILreader(c);
		c->yycur = 0;
	}
	return *CURRENT(c);
}

@-
The name space for MIL is nested. This means we have to map names according
to the scope in which they are introduced. Furthermore, we have to keep track
of the scope depth. 
This compilation information is retained in the parser state, attached to the
client record;
@+ The Parser
Unlike MonetDB V4.3 the client is responsible to collect the
input for parsing in a single string before calling the parser.
Once the input is available parsing runs in a critial section for
a single client thread.

@= restoreState
    if( c->listing)
		printFunction(c->fdout,c->curprg->def, c->listing);
	resetInstructions(c->curprg->def, oldstate.stop);
	resetVariables(c->curprg->def, @1, oldstate.vtop);

@mal
@c
MILbackend
newMILbackend()
{
	MILbackend be;

	be = GDKmalloc(sizeof(*be));
	memset(be, 0, sizeof(*be));
	return be;
}

void
resetMILbackend(Client cntxt)
{
	MILbackend be;

	be = BE(cntxt);
	memset(be, 0, sizeof(*be));
}

void
enterMILscope(Client cntxt)
{
	MILbackend be;

	be = (MILbackend) cntxt->state[PARSER];
	if (be->lastscope == MAXSCOPES - 1) {
		GDKerror("Too deeply nested\n");
		return;
	}
	be->lastscope++;
}

void
leaveMILscope(Client cntxt)
{
	MILbackend be;

	be = (MILbackend) cntxt->state[PARSER];
	if (be->lastscope == 0) {
		GDKerror("Scope nesting error\n");
		return;
	}
	be->scopes[be->lastscope] = 0;
	be->lastscope--;
}

int
getLastIterator(MILbackend be)
{
	if (be->itop == 0) {
		GDKerror("#ERROR: no barrier label left on stack\n");
		return 0;
	}
	return be->iterators[be->itop - 1];
}

void
pushIterator(MILbackend be, int varid)
{
	if (be->itop == MAXSCOPES) {
		GDKfatal("FATAL: iterator depth exceeded\n");
	}
	be->iterators[be->itop] = varid;
	be->itop++;
}

void
popIterator(MILbackend be)
{
	if (be->itop == 0) {
		GDKerror("#ERROR: no barrier label to pop on stack\n");
		return;
	}
	be->itop--;
}

void
resetIterator(MILbackend be)
{
	be->itop = 0;
}

int
getLastBlock(MILbackend be)
{
	if (be->btop == 0) {
		GDKerror("#ERROR: no block label left on stack\n");
		return 0;
	}
	return be->block[be->btop - 1];
}

void
enterBlock(MILbackend be, int varid)
{
	if (be->btop == MAXSCOPES) {
		GDKfatal("FATAL: scope depth exceeded\n");
	}
	be->block[be->btop] = varid;
	be->btop++;
}

void
leaveBlock(MILbackend be)
{
	if (be->btop == 0) {
		GDKerror("#ERROR: no scope id on stack\n");
		return;
	}
	be->btop--;
}

void
resetBlock(MILbackend be)
{
	be->btop = 0;
}

@+ Symbol table
The MIL name space is a collection of nested scopes.
This means we have to keep track on the identifiers
introduced in a block and issue a bind operation before using them.
@c
void
leaveScope(MILbackend be)
{
	int i = be->scopes[be->lastscope];
	Ids id;

	for (; i > 0; i--) {
		id = be->variables;
		be->variables = id->peer;
		GDKfree(id->nme);
		GDKfree(id);
	}
	be->scopes[be->lastscope] = 0;
	if (be->lastscope > 0)
		be->lastscope--;
}

void
newId(Client cntxt, str nme, int varid)
{
	MILbackend be = BE(cntxt);
	Ids m;

	m = (Ids) GDKmalloc(sizeof(*m));
	m->peer = be->variables;
	m->nme = nme;
	m->varid = varid;
	m->global = BE(cntxt)->constantdeclaration > 1;

	be->variables = m;
	be->scopes[be->lastscope]++;
}

int
fndId(MILbackend be, str nme)
{
	Ids n;

	for (n = be->variables; n; n = n->peer) {
		if (strcmp(n->nme, nme) == 0)
			return n->varid;
	}
	return 0;

}

#define NL(X) ((X)=='\n' || (X)=='\r')

void
parseMILinput(Client cntxt, MalBlkPtr currBlk)
{
	InstrPtr currInstr;
	int len = 0;
	char *c = CURRENT(cntxt);

	currInstr = newInstruction(REMsymbol);
	while (*c && !NL(*c)) {
		c++;
		len++;
	}
	c = GDKmalloc(len + 1);
	strncpy(c, CURRENT(cntxt), len);
	c[len] = 0;
	getArg(currInstr, 0) = newConstant(currBlk, TYPE_str, c, FALSE);
	pushInstruction(currBlk, currInstr);
}

void
skipMILspace(Client cntxt, MalBlkPtr currBlk)
{
	char *s = CURRENT(cntxt);

	for (;;) {
		switch (*s++) {
		case '#':
			while (currChar(cntxt) && currChar(cntxt) != '\n')
				nextChar(cntxt);
		case '\n':
		case '\r':
			nextChar(cntxt);
			parseMILinput(cntxt, currBlk);
			continue;
		case ' ':
		case '\t':
			nextChar(cntxt);
			continue;
		default:
			return;
		}
	}
}


@-
MIL variable may refer to globals, constants, parameterless functions,
and persistent BATs. These cases are handled by a pattern in the 
MIL interpreter, except for the built-in types, which are expected to exist.
Typename should be replaced by the MAL type identifier.
@c
str typeNames[] = { "void", "bit", "chr", "sht", "bat", "int", "oid", "ptr",
	"flt", "dbl", "lng", "str", "url", "lock", "sema", "blob", "fstream",
	"decimal", "bipipe", "tzone", "date", "daytime", "rule", "timestamp", 0
};

str multiplexOp[] = { " ", "+", "++", "-", "--", "/", "*", "%", ">", "<", "<=", ">=", "==", "!=", "and",
	"or", "not", "void", "bit", "chr", "sht", "bat", "int", "oid", "ptr",
	"flt", "dbl", "lng", "str", "asin", "acos", "atan", "cos", "sin",
	"tan", "cosh", "sinh", "tanh", "exp", "log", "log10", "sqrt",
	"ceil", "fabs", "floor", "round", "fmod", "atan2", "pow",
	"ifthen", "ifthenelse", 0
};

int
isMultiplexOp(str nme)
{
	int i;

	for (i = 0; multiplexOp[i]; i++)
		if (idcmp(nme, multiplexOp[i]) == 0)
			return i;
	return 0;
}

@+ The parser
The inplace operators in MIL are not supported.
@c

str
parseMILoperator(Client cntxt)
{
	int len;

	if (currChar(cntxt) == ':') {
		parseError(cntxt, "in-place operators are not supported\n");
		return NULL;
	}
	len = operatorLength(cntxt);
	if (len > 0)
		return operatorCopy(cntxt, len);
	len = idLength(cntxt);
	if (len > 0)
		return idCopy(cntxt, len);
	return NULL;
}

int
parseMILvariable(Client cntxt, MalBlkPtr currBlk, str nme)
{
	InstrPtr currInstr;
	int varid = 0, i, fnd = 0;

	if ((i = fndId(BE(cntxt), nme))) {
		varid = findVariable(currBlk, nme);
		if (varid < 0)
			varid = i;
	}
	for (i = 0; typeNames[i]; i++)
		if (strcmp(typeNames[i], nme) == 0) {
			char buf[64];

			snprintf(buf, 64, ":%s", nme);
			varid = newTypeVariable(currBlk, getTypeIndex(nme, strlen(nme), TYPE_any));
			newId(cntxt, nme, varid);
			if (BE(cntxt)->constantdeclaration) {
				isConstant(currBlk, varid) = 1;
			}
			fnd++;
			break;
		}
	if (fnd == 0 && varid == 0) {
		/* should check for pre-defined stuff as well */
		currInstr = newStmt(cntxt->curprg->def, "mil", "take");
		pushStr(cntxt->curprg->def, currInstr, nme);
		varid = getArg(currInstr, 0);
		setVarUsed(currBlk, varid, TRUE);
		newId(cntxt, nme, varid);
		return varid;
	}

	return varid;
}

int
parseMILassignment(Client cntxt, MalBlkPtr currBlk, str nme)
{
	InstrPtr currInstr;
	int varid, i;

	varid = fndId(BE(cntxt), nme);
	if (varid == 0 || varid > currBlk->vtop) {
		if (!BE(cntxt)->constantdeclaration)
			parseWarning(cntxt, "Variable not declared\n");
		varid = newVariable(currBlk, nme, TYPE_any);
		newId(cntxt, nme, varid);
		if (BE(cntxt)->constantdeclaration)
			isConstant(currBlk, varid) = 1;
	}
	currInstr = newInstruction(ASSIGNsymbol);
	setDestVar(currInstr, varid);
	setVarInitialized(currBlk, varid);
	i = parseMILexpr(cntxt, currBlk);
	pushArgument(currBlk, currInstr, i);
	pushInstruction(currBlk, currInstr);
	return varid;
}

int
parseMILfunctioncall(Client cntxt, MalBlkPtr currBlk, str nme)
{
	InstrPtr currInstr;
	int varid, i;

	if (currChar(cntxt) != '(') {
		parseError(cntxt, "'('expected\n");
		return 0;
	}
	advanceMore(cntxt, 1);
	skipMILspace(cntxt, currBlk);

	currInstr = newInstruction(ASSIGNsymbol);
	/* detect multiplex and group operators */
	if (*nme == '[' || *nme == '{') {
		nme[strlen(nme) - 1] = 0;
		if (*nme == '[') {
			setModuleId(currInstr, putName("mil", 9));
			setFunctionId(currInstr, putName("multiplex", 9));
		} else {
			setModuleId(currInstr, putName("mil", 9));
			setFunctionId(currInstr, putName("group", 5));
		}
		pushStr(currBlk, currInstr, nme + 1);
		GDKfree(nme);
	} else {
		str m, f;

		m = mapmod(nme);
		f = mapfcn(nme);
		setModuleId(currInstr, putName(m, strlen(m)));
		setFunctionId(currInstr, putName(f, strlen(f)));
		GDKfree(m);
		GDKfree(f);
	}

	varid = getDestVar(currInstr) = newTmpVariable(currBlk, TYPE_any);
	setVarInitialized(currBlk, varid);

	while (currChar(cntxt) != ')') {
		skipMILspace(cntxt, currBlk);
		i = parseMILexpr(cntxt, currBlk);
		pushArgument(currBlk, currInstr, i);
		skipMILspace(cntxt, currBlk);
		if (currChar(cntxt) == ',') {
			advanceMore(cntxt, 1);
		} else if (currChar(cntxt) != ')') {
			parseError(cntxt, "',' expected\n");
			break;
		}
		skipMILspace(cntxt, currBlk);
	}
	if (currChar(cntxt) == ')') {
		advanceMore(cntxt, 1);
	}

	pushInstruction(currBlk, currInstr);
	return varid;
}

@-
The path expressions starting with an identifier are a shortcut
for a function call whose first argument is factored out.
@c
int
parseMILpathexpr(Client cntxt, MalBlkPtr currBlk, int varid)
{
	InstrPtr currInstr;
	int newvar, j, k;
	str nme;
	char c[1024];

	advanceMore(cntxt, 1);
	skipMILspace(cntxt, currBlk);

	if (currChar(cntxt) == '[' || currChar(cntxt) == '{') {
		c[0] = currChar(cntxt);
		advance(cntxt, 1);
		nme = parseMILoperator(cntxt);
		k = strlen(nme);
		strcpy(c + 1, nme);
		GDKfree(nme);
		if ((c[0] == '[' && currChar(cntxt) != ']') || (c[0] == '{' && currChar(cntxt) != '}'))
			parseError(cntxt, "']/ or '}' expected\n");
		else {
			c[k + 1] = currChar(cntxt);
			c[k + 2] = 0;
			nextChar(cntxt);
		}
		newvar = parseMILfunctioncall(cntxt, currBlk, GDKstrdup(c));
		currInstr = currBlk->stmt[currBlk->stop - 1];

		k = currInstr->retc + 1;
	} else {
		nme = parseMILoperator(cntxt);
		if (nme == 0) {
			parseError(cntxt, "<identifier> or <operator> expected\n");
			return varid;
		}
		newvar = parseMILfunctioncall(cntxt, currBlk, nme);
		currInstr = currBlk->stmt[currBlk->stop - 1];

		k = currInstr->retc;
	}
	setVarUsed(currBlk, varid, TRUE);
	setVarUsed(currBlk, newvar, TRUE);
	/* shuffle arguments arround */
	pushArgument(currBlk, currInstr, varid);
	for (j = currInstr->argc - 1; j > k; j--)
		currInstr->argv[j] = currInstr->argv[j - 1];
	currInstr->argv[j] = varid;
	skipMILspace(cntxt, currBlk);
	if (currChar(cntxt) == '.')
		return parseMILpathexpr(cntxt, currBlk, newvar);

	return newvar;
}

int
parseMILfactor(Client cntxt, MalBlkPtr currBlk)
{
	int varid = 0, len, tpe;
	char bracket;
	char newname[1024];
	str nme;

	if ((len = stringLength(cntxt))) {
		advance(cntxt, 1);
		nme = idCopy(cntxt, len - 2);
		advance(cntxt, 1);
		varid = newConstant(currBlk, TYPE_str, nme, FALSE);
	} else if ((nme = charCst(cntxt))) {
		varid = newConstant(currBlk, TYPE_chr, nme, FALSE);
	} else if ((len = cstLength(cntxt, &tpe)) > 0) {
		/* factor */
		nme = idCopy(cntxt, len);
		varid = newConstant(currBlk, tpe, nme, TRUE);
	} else if ((len = idLength(cntxt)) > 0) {
		nme = idCopy(cntxt, len);
		skipMILspace(cntxt, currBlk);
		if (keyphrase2(cntxt, ":="))
			varid = parseMILassignment(cntxt, currBlk, nme);
		else if (currChar(cntxt) == '(') {
			varid = parseMILfunctioncall(cntxt, currBlk, nme);
		} else
			varid = parseMILvariable(cntxt, currBlk, nme);
	} else if (currChar(cntxt) == '(') {
		/* ( expr ) */
		advanceMore(cntxt, 1);
		skipMILspace(cntxt, currBlk);
		varid = parseMILexpr(cntxt, currBlk);
		if (!keyphrase1(cntxt, ")")) {
			parseError(cntxt, "')' expected\n");
		}
		skipMILspace(cntxt, currBlk);
	} else if (currChar(cntxt) == '[' || currChar(cntxt) == '{') {
		bracket = currChar(cntxt);

		advanceMore(cntxt, 1);
		len = idLength(cntxt);
		if (len == 0) {
			len = operatorLength(cntxt);
			if (len == 0) {
				parseError(cntxt, "<identifier> or <operator> expected\n");
				return newTmpVariable(currBlk, TYPE_any);
			} else
				nme = operatorCopy(cntxt, len);
		} else
			nme = idCopy(cntxt, len);
		if ((bracket == '[' && currChar(cntxt) != ']') || (bracket == '{' && currChar(cntxt) != '}')) {
			parseError(cntxt, "']' or '}' expected\n");
			return newTmpVariable(currBlk, TYPE_any);
		}
		advanceMore(cntxt, 1);
		snprintf(newname, 1024, "%c%s%c", bracket, nme, bracket);
		varid = parseMILfunctioncall(cntxt, currBlk, GDKstrdup(newname));
	}
	skipMILspace(cntxt, currBlk);
	if (currChar(cntxt) == '.') {
		varid = parseMILpathexpr(cntxt, currBlk, varid);
	}
	return varid;
}

@-
The expression stack should be reduced each time we push an operator
with lower priority

@= exprCode
	/* all operators have equal priority */
	for(i= @1; i>0; i--){
		str f,m;
		if(@2 && priority[i] >= priority[i-1]) break;
		currInstr= newInstruction(ASSIGNsymbol);
		f= mapfcn(ostk[i-1]);
		m= mapmod(ostk[i-1]);
		setModuleId(currInstr, putName(m,strlen(m)));
		setFunctionId(currInstr, putName(f,strlen(f)));
		pushArgument(currBlk,currInstr,stk[i-1]);
		pushArgument(currBlk,currInstr,stk[i]);
		stk[i-1]= lhs= newTmpVariable(currBlk,TYPE_any);
		setDestVar(currInstr,lhs);
		setVarInitialized(currBlk,lhs);
		priority[i-1] = priority[i+1];
		ostk[i-1] = ostk[i+1];
		pushInstruction(currBlk,currInstr);
		top--;
	}
@c
int
parseMILexpr(Client cntxt, MalBlkPtr currBlk)
{
	InstrPtr currInstr;
	int i, stk[32], priority[32], top, lhs;
	str operator, ostk[32];

	top = 0;
	stk[top] = lhs = parseMILfactor(cntxt, currBlk);
	skipMILspace(cntxt, currBlk);
	if (currChar(cntxt) == '@') {
		advanceMore(cntxt, 1);
		parseMILbatloop(cntxt, currBlk, lhs);
		return lhs;
	}
	do {
		operator= parseMILoperator(cntxt);

		if (operator == NULL)
			break;	/* priority to do */
		/* handle precedence */
		ostk[top] = operator;
		priority[top] = 1;	/* refine later */

		needMore(cntxt);
		skipMILspace(cntxt, currBlk);
		stk[++top] = parseMILfactor(cntxt, currBlk);
		@:exprCode(top - 1, TRUE)@
	} while (1);
	@:exprCode(top, FALSE)@
	return lhs;
}

void
parseMILstmtend(Client cntxt, MalBlkPtr currBlk)
{
	(void) currBlk;
	if (currChar(cntxt) != ';' && currChar(cntxt) != '}') {
		parseError(cntxt, "';' expected\n");
	} else
		advance(cntxt, 1);
}

void
parseMILstmt(Client cntxt, MalBlkPtr currBlk)
{
	if (currChar(cntxt) == '{') {
		parseMILblock(cntxt, currBlk);
	} else {
		parseMILexpr(cntxt, currBlk);
		skipMILspace(cntxt, currBlk);
		if (currChar(cntxt) == ';')
			nextChar(cntxt);
		/* parseMILstmtend(cntxt,currBlk); */
	}
}
void
parseMILblock(Client cntxt, MalBlkPtr currBlk)
{
	if (keyphrase2(cntxt, "{/")) {
		advanceMore(cntxt, 1);
		skipMILspace(cntxt, currBlk);
		enterMILscope(cntxt);
		do {
			if (keyphrase2(cntxt, "/}") == 0)
				break;
			parseMILstmtAll(cntxt, currBlk);
		} while (currChar(cntxt) != '}');
		advance(cntxt, 2);
		leaveMILscope(cntxt);
	} else if (currChar(cntxt) == '{') {
		advanceMore(cntxt, 1);
		enterMILscope(cntxt);
		do {
			skipMILspace(cntxt, currBlk);
			if (currChar(cntxt) == '}')
				break;
			parseMILstmtAll(cntxt, currBlk);
		} while (currChar(cntxt) != '}');
		advance(cntxt, 1);
		leaveMILscope(cntxt);
	} else
		parseMILstmtAll(cntxt, currBlk);
}

int
parseMILbatstmt(Client cntxt, MalBlkPtr currBlk)
{
	InstrPtr currInstr;
	int arg, varid;

	varid = newTmpVariable(currBlk, TYPE_bat);

	skipMILspace(cntxt, currBlk);
	if (currChar(cntxt) != '(') {
		parseError(cntxt, "'(' expected\n");
		return varid;
	}
	nextChar(cntxt);
	arg = parseMILexpr(cntxt, currBlk);
	currInstr = newInstruction(ASSIGNsymbol);
	setModuleId(currInstr, putName("bbp", 3));
	setFunctionId(currInstr, putName("new", 3));
	setDestVar(currInstr, varid);
	setVarInitialized(currBlk, getDestVar(currInstr));
	pushArgument(currBlk, currInstr, arg);
	pushInstruction(currBlk, currInstr);
	skipMILspace(cntxt, currBlk);
	if (currChar(cntxt) != ')') {
		parseError(cntxt, "'(' expected\n");
	} else {
		nextChar(cntxt);
		skipMILspace(cntxt, currBlk);
		if (currChar(cntxt) == '.')
			return parseMILpathexpr(cntxt, currBlk, varid);
	}

	return varid;
}

void
parseMILifstmt(Client cntxt, MalBlkPtr currBlk)
{
	InstrPtr currInstr;
	int cvar, lhs;

	skipMILspace(cntxt, currBlk);
	if (currChar(cntxt) != '(') {
		parseError(cntxt, "'(' expected\n");
	} else {
		advanceMore(cntxt, 1);
	}
	lhs = parseMILexpr(cntxt, currBlk);
	skipMILspace(cntxt, currBlk);
	if (currChar(cntxt) != ')') {
		parseError(cntxt, "')' expected\n");
	} else {
		advanceMore(cntxt, 1);
	}

	cvar = newTmpVariable(currBlk, TYPE_bit);

	currInstr = newInstruction(ASSIGNsymbol);
	setDestVar(currInstr, cvar);

	setVarInitialized(currBlk, getDestVar(currInstr));
	setVarUsed(currBlk, cvar, TRUE);

	pushArgument(currBlk, currInstr, lhs);
	currInstr->barrier = BARRIERsymbol;
	pushInstruction(currBlk, currInstr);

	parseMILstmt(cntxt, currBlk);

	currInstr = newInstruction(EXITsymbol);
	setDestVar(currInstr, cvar);

	setVarInitialized(currBlk, getDestVar(currInstr));
	currInstr->barrier = EXITsymbol;
	pushInstruction(currBlk, currInstr);

	skipMILspace(cntxt, currBlk);
	if (MALkeyword(cntxt, "else", 4)) {
		cvar = newTmpVariable(currBlk, TYPE_bit);
		setVarUsed(currBlk, cvar, TRUE);

		currInstr = newInstruction(ASSIGNsymbol);
		setDestVar(currInstr, cvar);
		setVarInitialized(currBlk, cvar);

		setFunctionId(currInstr, putName("not", 3));
		pushArgument(currBlk, currInstr, lhs);
		currInstr->barrier = BARRIERsymbol;
		pushInstruction(currBlk, currInstr);

		parseMILstmtAll(cntxt, currBlk);

		currInstr = newInstruction(EXITsymbol);
		setDestVar(currInstr, cvar);

		currInstr->barrier = EXITsymbol;
		pushInstruction(currBlk, currInstr);
	}
}
void
parseMILbatloop(Client cntxt, MalBlkPtr currBlk, int lhs)
{
	int cvar, hvar, tvar;
	InstrPtr currInstr;

	skipMILspace(cntxt, currBlk);
	if (currChar(cntxt) == '[') {
		nextChar(cntxt);
		skipMILspace(cntxt, currBlk);
		parseMILexpr(cntxt, currBlk);
		if (currChar(cntxt) == ']')
			nextChar(cntxt);
		else
			parseError(cntxt, "']' expected\n");
	}
	if (!MALkeyword(cntxt, "batloop", 7))
		parseError(cntxt, "'batloop' expected\n");
	skipMILspace(cntxt, currBlk);
	if (!MALkeyword(cntxt, "()", 2))
		parseError(cntxt, "'()' expected\n");
	skipMILspace(cntxt, currBlk);

	cvar = newTmpVariable(currBlk, TYPE_lng);
	pushIterator(BE(cntxt), cvar);

	hvar = newTmpVariable(currBlk, TYPE_any);
	tvar = newTmpVariable(currBlk, TYPE_any);

	currInstr = newInstruction(ASSIGNsymbol);
	setModuleId(currInstr, putName("chopper", 7));
	setFunctionId(currInstr, putName("newIterator", 11));
	setDestVar(currInstr, cvar);
	setVarInitialized(currBlk, cvar);
	setVarUsed(currBlk, cvar, TRUE);

	pushArgument(currBlk, currInstr, hvar);
	setVarInitialized(currBlk, hvar);
	setVarUsed(currBlk, hvar, TRUE);
	pushArgument(currBlk, currInstr, tvar);
	setVarInitialized(currBlk, tvar);
	setVarUsed(currBlk, tvar, TRUE);

	currInstr->retc = currInstr->argc;
	currInstr->barrier = BARRIERsymbol;
	pushArgument(currBlk, currInstr, lhs);
	pushInstruction(currBlk, currInstr);

	enterBlock(BE(cntxt), cvar);

	newId(cntxt, GDKstrdup("$H"), hvar);
	newId(cntxt, GDKstrdup("$HEAD"), hvar);
	newId(cntxt, GDKstrdup("$h"), hvar);
	newId(cntxt, GDKstrdup("$head"), hvar);
	newId(cntxt, GDKstrdup("$T"), tvar);
	newId(cntxt, GDKstrdup("$TAIL"), tvar);
	newId(cntxt, GDKstrdup("$t"), tvar);
	newId(cntxt, GDKstrdup("$tail"), tvar);

	parseMILstmt(cntxt, currBlk);

	currInstr = newInstruction(ASSIGNsymbol);
	setModuleId(currInstr, putName("chopper", 7));
	setFunctionId(currInstr, putName("hasMoreElements", 15));
	setDestVar(currInstr, cvar);

	pushArgument(currBlk, currInstr, hvar);
	pushArgument(currBlk, currInstr, tvar);

	currInstr->retc = currInstr->argc;
	currInstr->barrier = REDOsymbol;
	pushArgument(currBlk, currInstr, lhs);
	pushInstruction(currBlk, currInstr);

	currInstr = newInstruction(EXITsymbol);
	setDestVar(currInstr, cvar);

	pushArgument(currBlk, currInstr, hvar);
	pushArgument(currBlk, currInstr, tvar);

	currInstr->retc = currInstr->argc;
	currInstr->barrier = EXITsymbol;
	pushInstruction(currBlk, currInstr);

	popIterator(BE(cntxt));
	leaveBlock(BE(cntxt));
}

void
parseMILwhilestmt(Client cntxt, MalBlkPtr currBlk)
{
	InstrPtr currInstr;
	int cvar, lhs, tvar;

	skipMILspace(cntxt, currBlk);
	if (currChar(cntxt) != '(') {
		parseError(cntxt, "'(' expected\n");
	} else {
		advanceMore(cntxt, 1);
	}

	cvar = newTmpVariable(currBlk, TYPE_bit);

	currInstr = newInstruction(ASSIGNsymbol);
	setDestVar(currInstr, cvar);
	setVarUsed(currBlk, cvar, TRUE);

	setVarInitialized(currBlk, getDestVar(currInstr));
	pushArgument(currBlk, currInstr, tvar = newConstant(currBlk, TYPE_bit, GDKstrdup("TRUE"), FALSE));

	currInstr->barrier = BARRIERsymbol;
	pushInstruction(currBlk, currInstr);
	enterBlock(BE(cntxt), cvar);

	lhs = parseMILexpr(cntxt, currBlk);
	skipMILspace(cntxt, currBlk);
	if (currChar(cntxt) != ')') {
		parseError(cntxt, "')' expected\n");
	} else {
		advanceMore(cntxt, 1);
	}

	currInstr = newInstruction(ASSIGNsymbol);
	setDestVar(currInstr, cvar);

	setFunctionId(currInstr, putName("not", 3));
	pushArgument(currBlk, currInstr, lhs);
	currInstr->barrier = LEAVEsymbol;
	pushInstruction(currBlk, currInstr);

	parseMILstmt(cntxt, currBlk);

	currInstr = newInstruction(ASSIGNsymbol);
	setDestVar(currInstr, cvar);
	pushArgument(currBlk, currInstr, tvar);

	currInstr->barrier = REDOsymbol;
	pushInstruction(currBlk, currInstr);

	currInstr = newInstruction(EXITsymbol);
	setDestVar(currInstr, cvar);

	currInstr->barrier = EXITsymbol;
	pushInstruction(currBlk, currInstr);
	leaveBlock(BE(cntxt));
}

void
parseMILvarstmt(Client cntxt, MalBlkPtr currBlk)
{
	InstrPtr currInstr;
	int len, varid, lhs;
	str nme;

	skipMILspace(cntxt, currBlk);

	len = idLength(cntxt);
	while (len > 0) {
		nme = idCopy(cntxt, len);
		varid = newVariable(currBlk, nme, TYPE_any);
		newId(cntxt, nme, varid);
		if (BE(cntxt)->constantdeclaration)
			isConstant(currBlk, varid) = 1;
		skipMILspace(cntxt, currBlk);
		if (keyphrase2(cntxt, ":=")) {
			skipMILspace(cntxt, currBlk);
			lhs = parseMILexpr(cntxt, currBlk);
			currInstr = newInstruction(ASSIGNsymbol);
			setDestVar(currInstr, varid);
			setVarInitialized(currBlk, getDestVar(currInstr));
			pushArgument(currBlk, currInstr, lhs);
			pushInstruction(currBlk, currInstr);
		}
		skipMILspace(cntxt, currBlk);
		if (currChar(cntxt) != ',')
			break;
		nextChar(cntxt);
		skipMILspace(cntxt, currBlk);
		len = idLength(cntxt);
	}
}

void
parseMILundefstmt(Client cntxt, MalBlkPtr currBlk)
{
	int len;

	(void) currBlk;
	skipMILspace(cntxt, currBlk);
	len = idLength(cntxt);
	if (len == 0)
		parseError(cntxt, "<identifier> expected\n");
}

void
parseMILreturnstmt(Client cntxt, MalBlkPtr currBlk)
{
	InstrPtr currInstr;
	int lhs;

	skipMILspace(cntxt, currBlk);
	lhs = parseMILexpr(cntxt, currBlk);
	currInstr = newInstruction(ASSIGNsymbol);
	setDestVar(currInstr, getArg(getInstrPtr(currBlk, 0), 0));
	setVarInitialized(currBlk, getDestVar(currInstr));
	pushArgument(currBlk, currInstr, lhs);
	currInstr->barrier = RETURNsymbol;
	pushInstruction(currBlk, currInstr);
}

int
parseMILtype(Client cntxt, MalBlkPtr currBlk, str tnme)
{
	int len, tpe, ht, tt;

	tpe = getTypeIndex(tnme, strlen(tnme), -1);
	if (tpe == TYPE_bat) {
		if (currChar(cntxt) == '[') {
			advanceMore(cntxt, 1);
			len = idLength(cntxt);
			ht = getTypeIndex(CURRENT(cntxt), len, -1);
			advanceMore(cntxt, len);
			skipMILspace(cntxt, currBlk);
			if (currChar(cntxt) != ',')
				parseError(cntxt, "',' expected\n");
			advanceMore(cntxt, 1);
			len = idLength(cntxt);
			tt = getTypeIndex(CURRENT(cntxt), len, -1);
			advanceMore(cntxt, len);
			skipMILspace(cntxt, currBlk);
			if (currChar(cntxt) != ']')
				parseError(cntxt, "',' expected\n");
			advance(cntxt, 1);
			tpe = newBatType(ht, tt);
		}
	}
	return tpe;
}

void
parseMILparameter(Client cntxt, MalBlkPtr currBlk, InstrPtr currInstr)
{
	int vararg = 0, len, tpe, varid;
	str tnme, nme;

	if (MALkeyword(cntxt, "...", 3))
		vararg = 1;
	len = idLength(cntxt);
	if (len == 0) {
		parseError(cntxt, "<identifier> or <type> expected\n");
		return;
	}
	tnme = idCopy(cntxt, len);
	tpe = parseMILtype(cntxt, currBlk, tnme);

	if (tpe == TYPE_any) {
		nme = tnme;
	} else {
		skipMILspace(cntxt, currBlk);
		len = idLength(cntxt);
		if (len == 0) {
			parseError(cntxt, "<identifier> expected\n");
			return;
		}
		nme = idCopy(cntxt, len);
	}
	varid = newVariable(currBlk, nme, tpe);
	pushArgument(currBlk, currInstr, varid);
	newId(cntxt, GDKstrdup(nme), varid);
	skipMILspace(cntxt, currBlk);
	if (vararg) {
		if (!MALkeyword(cntxt, "...", 3))
			parseError(cntxt, "'...' expected\n");
		skipMILspace(cntxt, currBlk);
	}
}

void
parseMILprocdef(Client cntxt, MalBlkPtr currBlk)
{
	int varid;
	str nme;
	Symbol curPrg;
	InstrPtr currInstr;

	resetMILbackend(cntxt);
	skipMILspace(cntxt, currBlk);
	nme = parseMILoperator(cntxt);
	if (nme == 0) {
		parseError(cntxt, "<identifier> or <operator> expected\n");
		return;
	}
	needMore(cntxt);
	skipMILspace(cntxt, currBlk);
	if (currChar(cntxt) == ';')
		return;
	if (currChar(cntxt) != '(')
		parseError(cntxt, "'(' expected\n");
	else {
		advanceMore(cntxt, 1);
	}
	skipMILspace(cntxt, currBlk);

	/* temporary suspend capturing in the main block */
	if (cntxt->backup && currBlk && currBlk->errors == 0)
		GDKfatal("mal_parser: unexpected recursion\n");
	cntxt->backup = cntxt->curprg;

	curPrg = newFunction(nme, FUNCTIONsymbol);
	cntxt->curprg = curPrg;
	currBlk = curPrg->def;
	currInstr = getSignature(curPrg);
	varid = newVariable(currBlk, GDKstrdup(nme), TYPE_any);
	setDestVar(currInstr, varid);
	setVarInitialized(currBlk, getDestVar(currInstr));

	enterMILscope(cntxt);
	while (currChar(cntxt) != ')') {
		/* parse argument */
		parseMILparameter(cntxt, currBlk, currInstr);
		skipMILspace(cntxt, currBlk);
		if (currChar(cntxt) == ',') {
			advanceMore(cntxt, 1);
		} else if (currChar(cntxt) != ')') {
			parseError(cntxt, "')' expected\n");
			break;
		}
		skipMILspace(cntxt, currBlk);
	}
	if (currChar(cntxt) == ')') {
		advanceMore(cntxt, 1);
	}
	skipMILspace(cntxt, currBlk);
	if (currChar(cntxt) == ':') {
		int len;

		advanceMore(cntxt, 1);
		skipMILspace(cntxt, currBlk);
		len = idLength(cntxt);
		if (len == 0)
			parseError(cntxt, "<type> expected\n");
		else {
			nme = idCopy(cntxt, len);
			setVarType(currBlk, varid, parseMILtype(cntxt, currBlk, nme));
			GDKfree(nme);
		}
	}

	parseMILstmt(cntxt, curPrg->def);
	leaveMILscope(cntxt);

	pushEndInstruction(currBlk);
	insertSymbol(cntxt->nspace, curPrg);
	trimMalBlk(currBlk);
	chkProgram(cntxt->nspace, currBlk);
	if (cntxt->backup) {
		cntxt->curprg = cntxt->backup;
		cntxt->backup = 0;
	}
	if (cntxt->listing)
		printFunction(GDKout, currBlk, cntxt->listing);
	showErrors();
}

void
parseMILbreakstmt(Client cntxt, MalBlkPtr currBlk)
{
	InstrPtr currInstr;

	currInstr = newInstruction(ASSIGNsymbol);
	currInstr->barrier = LEAVEsymbol;
	setDestVar(currInstr, getLastBlock(BE(cntxt)));
	setVarInitialized(currBlk, getDestVar(currInstr));
	pushArgument(currBlk, currInstr, newConstant(currBlk, TYPE_bit, GDKstrdup("true"), FALSE));
	pushInstruction(currBlk, currInstr);
}


int
parseMILstmtAll(Client cntxt, MalBlkPtr currBlk)
{
	char c;

	skipMILspace(cntxt, currBlk);
	while ((c = *CURRENT(cntxt))) {
		switch (c) {
		case '#':
			while (currChar(cntxt) && currChar(cntxt) != '\n')
				nextChar(cntxt);
		case '\n':
		case '\r':
		case '\f':
			nextChar(cntxt);
			if (*CURRENT(cntxt))
				parseMILinput(cntxt, currBlk);
			continue;
		case '\t':
		case ' ':
			nextChar(cntxt);
			break;
		case 0:
			return cntxt->curprg->def->errors;
		case '/':
			if (keyphrase2(cntxt, "/}")) {
				return cntxt->curprg->def->errors;
			}
			goto MILstmt2;
		case '{':
			parseMILblock(cntxt, currBlk);
			break;
		case '}':
			return cntxt->curprg->def->errors;
		case 'b':
		case 'B':
			if (MALkeyword(cntxt, "break", 5))
				parseMILbreakstmt(cntxt, currBlk);
			if (MALkeyword(cntxt, "bat", 3))
				parseMILbatstmt(cntxt, currBlk);
			else
				goto MILstmt2;
			break;
		case 'c':
		case 'C':
			if (MALkeyword(cntxt, "const", 5))
				BE(cntxt)->constantdeclaration = 1;
			goto MILstmt2;
			break;
		case 'i':
		case 'I':
			if (MALkeyword(cntxt, "if", 2))
				parseMILifstmt(cntxt, currBlk);
			else
				goto MILstmt2;
			break;
		case 'r':
		case 'R':
			if (MALkeyword(cntxt, "return", 6))
				parseMILreturnstmt(cntxt, currBlk);
			else
				goto MILstmt2;
			break;
		case 'v':
		case 'V':
			if (MALkeyword(cntxt, "var", 3))
				parseMILvarstmt(cntxt, currBlk);
			else
				goto MILstmt2;
			break;
		case 'w':
		case 'W':
			if (MALkeyword(cntxt, "while", 5))
				parseMILwhilestmt(cntxt, currBlk);
			else
				goto MILstmt2;
			break;
		default:
		      MILstmt2:
			parseMILstmt(cntxt, currBlk);
			if (cntxt->curprg->def->errors >= MAXERRORS)
				return cntxt->curprg->def->errors;
		}
	}
	return cntxt->curprg->def->errors;
}

int
parseMILprg(Client cntxt, MalBlkPtr currBlk)
{
	char c;

	if (*CURRENT(cntxt))
		parseMILinput(cntxt, currBlk);
	while ((c = *CURRENT(cntxt))) {
		switch (c) {
		case '#':
			while (currChar(cntxt) && currChar(cntxt) != '\n')
				nextChar(cntxt);
			continue;
		case '\n':
		case '\r':
		case '\f':
			nextChar(cntxt);
			if (*CURRENT(cntxt))
				parseMILinput(cntxt, currBlk);
			continue;
		case ';':
			BE(cntxt)->constantdeclaration = 0;
		case '\t':
		case ' ':
			nextChar(cntxt);
			break;
		case 0:
			return cntxt->curprg->def->errors;
		case '}':
		case ')':	/* loose closing bracket */
			nextChar(cntxt);
			break;
		case 'c':
		case 'C':
			if (MALkeyword(cntxt, "const", 5)) {
				BE(cntxt)->constantdeclaration = 2;	/* external constant */
				parseMILstmt(cntxt, currBlk);
				BE(cntxt)->constantdeclaration = 0;
			} else
				goto MILstmt;
			break;
		case 'p':
		case 'P':
			if (MALkeyword(cntxt, "proc", 4))
				parseMILprocdef(cntxt, currBlk);
			else
				goto MILstmt;
			break;
		case 'v':
		case 'V':
			if (MALkeyword(cntxt, "var", 3))
				parseMILvarstmt(cntxt, currBlk);
			else
				goto MILstmt;
			break;
		case 'u':
		case 'U':
			if (MALkeyword(cntxt, "undef", 5))
				parseMILundefstmt(cntxt, currBlk);
			else
				goto MILstmt;
			break;
		default:
		      MILstmt:
			parseMILstmt(cntxt, currBlk);
			if (cntxt->curprg->def->errors >= MAXERRORS)
				return cntxt->curprg->def->errors;
		}
	}
	return cntxt->curprg->def->errors;
}

@-
Display the error information for the current client.
An arrow and state number is printed at the "appropriate" place. 
If no lookahead character is a used and the next character is a newline,
we should also copy the input .
This code fragment is largely copied from the MAL parser, which also
included an automatic skiptoend not required here.
@c
str
parseWarning(Client cntxt, str msg)
{
	Symbol curPrg;
	MalBlkPtr curBlk;
	char buf[10 * 1024];
	char *s = buf, *t, *l = lastline(cntxt);
	long i;

	curPrg = cntxt->curprg;
	curBlk = curPrg->def;
	if (curBlk)
		curBlk->errors++;

	/* accidental %s directives in the lastline can
	   crash the vfsprintf later => escape them */
	for (t = l; *t && *t != '\n'; t++) {
		if (*t == '%')
			*s++ = '%';
		*s++ = *t;
	}
	*s++ = '\n';
	*s++ = '!';
	/* produce the position marker */
	i = position(cntxt) + strlen(GDKERROR) - 1;
	for (; i > 0; i--) {
		*s++ = ((l && *(l + 1) && *l++ != '\t')) ? ' ' : '\t';
	}
	*s++ = '^';
	*s = 0;

	if (msg == 0)
		msg = "can't help you here, sorry.\n";
	if (strlen(msg) + strlen(buf) < 1020)
		snprintf(s, 1020, "%s", msg);
	GDKerror(buf);
	return 0;
}

@}
