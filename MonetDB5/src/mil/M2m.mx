@a M.L. Kersten
@v 1.0
@* Standalone MIL parser

This program is an off-line compiler for mil programs developed on
pre-Version 5. The approach taken is to be able to compile mil
programs as they appear in the modules, without too many facilities
for the interpreter.

Input is obtained from a file argument.

The underlying parser is to be included in a Mapi-mil front-end or
the applications at a later stage.

@c
#include <gdk.h>
#include "monet_options.h"
#include "mal_type.h"	/* for idcmp() */
#include "mil_parser.h"	/* for mil_push() */

void advice();
void mil_code_prelude();

#define MAXSCRIPT 64
extern void showmappings();
extern int yyparse();
str	mil_script[MAXSCRIPT];
char	mil_cwd[PATHLENGTH];

void usage(){
	printf("usage:M2m <file.mil>\n");
	exit(-1);
}
@-
A welcoming message is displayed to inform the user about recent
changes. 
@c
str absolute_path(str s) {
        if (!MT_path_absolute(s)) {
                str ret = (str)GDKmalloc(strlen(s) + strlen(mil_cwd) + 2);
                sprintf(ret, "%s%c%s", mil_cwd, DIR_SEP, s);
                return ret;
        }
        return GDKstrdup(s);
}

int main(int argc,char ** av)
{
	/* Stefan: "buf" wasn't initialized, so I set it to NULL.
	 * It is initialized eventually initialized after the line
	 * "The files are processed as one big program", 
         * however, that's too late for "case 'c'" in the 
	 * option-checking "while(1)" loop ...
	 */
        char *buf = NULL, *ptr, *prog = *av, *config = NULL;
        opt *set = NULL;
        int i,debug = 0, setlen = 0;
	int k,len,totlen;
	char *dbname, *dbfarmval, dbfarm[BUFSIZ];

	static struct option long_options[] =
             {
               {"config", 1, 0, 'c'},
               {"dbname", 1, 0, 0},
               {"dbfarm", 1, 0, 0},
               {"debug", 2, 0, 'd'},
               {"help", 0, 0, '?'},
               {"set", 1, 0, 's'},
               {0, 0, 0, 0}
             };

        if (getcwd(mil_cwd, PATHLENGTH-1)  == NULL ){
                perror("pwd");
                GDKfatal("mil_init: could not determine current directory\n");
        }

	if (!(setlen = mo_builtin_settings(&set)) )
		usage(prog);

	while(1){
		int option_index = 0;

		int c = getopt_long( argc, av, "c:d::?s:", 
				long_options, &option_index);

		if (c == -1)
			break;

		switch (c){
		case 0:
			if (strcmp(long_options[option_index].name, 
						"dbname") == 0){
				setlen = mo_add_option( &set, setlen, 
					opt_cmdline, "gdk_dbname", optarg );
				break;
			}
			if (strcmp(long_options[option_index].name, 
						"dbfarm") == 0){
				setlen = mo_add_option( &set, setlen, 
					opt_cmdline, "gdk_dbfarm", optarg );
				break;
			}
			usage(prog);
			break;
		case 'c':
			if( *optarg!='/' && *optarg !='.') {
                                snprintf(buf,BUFSIZ,"%s/%s",mil_cwd,optarg);
                                config= strdup(buf);
                        } else config = strdup(optarg);
			break;
		case 'd':
			debug=1;
			if (optarg){ 
				setlen = mo_add_option( &set, setlen, 
					opt_cmdline, "gdk_debug", optarg );
			}
			break;
		case 's': {
			/* should add option to a list */
			char *tmp = strchr(optarg, '=');

			if (tmp){
				*tmp = '\0';
				setlen = mo_add_option( &set, setlen, 
					opt_cmdline, optarg, tmp+1 );
			} else {
				fprintf(stderr, "ERROR: wrong format %s\n", 
					optarg);
			}
		 } break;
		case '?':
			usage(prog);
		default:
			fprintf( stderr, 
			    "ERROR: getopt returned character code 0%o ??\n",c);
			usage(prog);
		}
	}

	if (config){
                int k;
                setlen = mo_config_file(&set, setlen, config );
                /* replace the monet_pid option with config */
                /* update the configuration parameter itself */
                for(k=0;k<setlen;k++)
                if( idcmp(set[k].name,"monet_pid")==0){
                        strcpy(set[k].name,"gdk_config");
                        set[k].value= absolute_path(config);
                        break;
                }

		free(config);
	} else {
		if (!(setlen = mo_system_config(&set, setlen)) )
			usage(prog);
	}

	i = 0;
	mil_script[i] = NULL;
	while(optind < argc){
		mil_script[i] = absolute_path(av[optind]);
		mil_script[i+1] = NULL;
		optind++;
		i++;
	}

	if (debug)
		mo_print_options(set, setlen);
#ifdef MSERVER_DEBUG
	else	mo_print_options(set,setlen);
#endif
	dbname = mo_find_option(set, setlen, "gdk_dbname");
	dbfarmval = mo_find_option(set, setlen, "gdk_dbfarm");
        strcpy(dbfarm, dbfarmval );
        mo_substitute(set, setlen, dbfarm);

	if (!GDKinit(dbname, dbfarm)) return 1; /* ERROR? */
@-
The files are processed as one big program
@c
	i=0;
	len = totlen = 8*8192;
	ptr = buf= (char*) GDKmalloc(totlen);
	for(k=0;mil_script[k]!= 0; k++) {
		FILE *fd;
		char fname[PATHLENGTH];

		snprintf(fname,PATHLENGTH,"%s",mil_script[k]);
		fd = fopen(fname,"rb");
		if (fd == 0) {
			printf("mil: could not open file: %s\n", fname);
			exit (-1);
		}

		while((i+=fread(ptr, 1, len , fd)) == totlen) {
			len = totlen; totlen *= 2;
			ptr = GDKmalloc(totlen);
			memcpy(ptr, buf, len);
			GDKfree(buf);
			buf = ptr; ptr += len;
		}
		fclose(fd);
		buf[i] = 0;
	}
	mil_code_prelude();
	mil_push(buf);	/*no need to copy here */
	yyparse();
	showmappings();
	mo_free_options(set,setlen);

	return 0;
}

void mil_code_prelude(){
        printf("# Monet Mil to Mal compiler\n");
        printf("# Copyright (c) 2001-2003, CWI. ");
        printf("All rights reserved.\n");
	printf("\n# Predefined code segment\n");
	advice();
}
/* The compiler does not compile everything */
char *hlp[]={
"The compiler can not guarantee an accurate compilation,",
"because MIL unlike MAL is a dynamically typed language.",
"A few guidelines to maximize usefullness.",
"- make the type of variables explicit, in particular 'nil'",
"- upon advice of M2m to remap identifiers, change it in your program directly",
"- positional arguments, ie $1,$2,..., can not be compiled in isolation",
"","","Perhaps someone will develop a complete MIL interpreter",
"on top of the MAL kernel in the future",
0
};
void advice(){
	int i;
	for(i=0; hlp[i]; i++) printf("#%s\n",hlp[i]);
}
