@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@a M. Kersten
@v 0.0
@+ Factories 
A convenient programming construct is the co-routine, which
is specified as an ordinary function, but maintains its
own state between calls, and permits re-entry other than
by the first statement. 

For simple cases, e.g. implementation of a random function,
it suffices to ensure that the state is secured between calls.
But, in a database context there are multiple clients
active. This means we have to be more precise on the relationship
between a co-routine and the client for which it works.

The co-routine concept researched in Monet 5 is the notion of a 'factory',
which consists of 'factory plants' at possibly different locations and
with different policies to handle client requests.
Factory management is limited to its owner, which is derived from the module
in which it is placed. By default Admin is the owner of all modules.

The random generator example is used to illustrate its definition and use.
@example
factory random(seed:int,limit:int):int;
    rnd:=seed;
    lim:= limit;
barrier lim;
    leave lim:= lim-1;
    rnd:= rnd*125;
    yield rnd:= rnd % 32676;
    redo lim;
exit lim;
end random;
@end example

The first time this factory is called, a factory plant
is created in the local system to handle the requests.
The plant carries the stack frame and synchronizes access.

In this case it initializes the generator. 
The random number is generated and @code{yield}  as
a result of the call. The factory process is then put to sleep.
The second call received by the factory wakes it up at the
point where it went to sleep. In this case it will
find a @code{redo} statement and produces the next random number.
Note that also in this case a seed and limit value are
expected, but they are ignored in the body.
This factory can be called upon to generate at most 'limit'
random numbers using the 'seed' to initialize the generator.
Thereafter it is being removed, i.e. reset to the original state.

A cooperative group of factories can be readily constructed.
For example, assume we would like the
random factories to respond to both @code{random(seed,limit)} 
and @code{random()}. This can be defined as follows:
@example
factory random(seed:int,limit:int):int;
    rnd:=seed;
    lim:= limit;
    box.deposit(rnd);
barrier lim;
    LEAVE lim:= lim-1;
    rnd:= rnd*125;
    YIELD rnd:= rnd % 32676;
    REDO lim;
exit lim;
end random;

factory random():int;
barrier forever:=true;
    yield random(0,0);
    redo forever;
exit forever;
end random;
@end example

@- Client support
The factory produces elements for multiple clients.
Sharing the factory state, parallel processing,
or even remote processing is up to the factory owner.
They are set through properties for the factory plant.

The default policy is to instantiate one shared
plant for each factory. If necessary, the factory
can keep track of a client list to differentiate
the states.
A possible implementation would be:
@example
factory random(seed:int,clientid:int):int;
    clt:= new(:int,:int);
    insert(clt,clientid,seed);
barrier always:=true;
    rnd:= find(clt,clientid);
catch   rnd; #failed to find client
    insert(clt,clientid,seed);
    rnd:= find(clt,clientid);
exit    rnd;
    rnd:= rnd * 125;
    rnd:= rnd % 32676;
    replace(clt,clientid,rnd);
    yield rnd;
    redo always;
exit always;
end random;
@end example

The operators to built client aware factories are,
@code{factory.getCaller()}, which returns a client 
index, @code{factory.getModule()} and @code{factory.getFunction()}, 
which returns the identity of scope enclosed.

To illustrate, the client specific random generator
can be shielded using the factory:
@example
factory random(seed:int):int;
barrier always:=true;
    clientid:= factory.getCaller();
    yield random(seed, clientid);
    redo always;
exit always;
end random;
@end example

@- Complex factory examples 
One interesting use of the factory scheme is to model
a volcano-style query processor. Each node in the query
tree is an iterator that calls upon the operands to produce
a chunk, which are combined into a new  chunk for concumption
of the parent. The prototypical join(R,S) query illustrates it.
The plan does not test for all boundary conditions, it merely
implements a nested loop. The end of a sequence is identified
by a NIL chunk.

@example
factory query();
    Left:= bind("relationA");
    Right:= bind("relationB");
    rc:= joinStep(Left,Right);
barrier rc!= nil;
    print(rc);
    rc:= joinStep(Left,Right);
    redo rc!= nil;
exit rc;
end query;

#nested loop join
factory joinStep(Left:bat[:any,:any],Right:bat[:any,:any]):bat[:any,:any];
    lc:= chunkStep(Left);
barrier outer:= lc != nil;
    rc:= chunkStep(Right);
    barrier inner:= rc != nil;
        chunk:= join(lc,rc);
        yield chunk;
        rc:= chunkStep(Right);
        redo inner:= rc != nil;
    exit inner;
    lc:= chunkStep(Left);
    redo outer:= lc != nil;
exit outer;
    # we have seen everything
    return nil;
end joinStep;

#factory for left branch
factory chunkStepL(L:bat[:any,:any]):bat[:any,:any];
    i:= 0;
    j:= 20;
    cnt:= count(L);
barrier outer:= j<cnt;
    chunk:= slice(L,i,j);
    i:= j;
    j:= i+ 20;
    yield chunk;
    redo loop:= j<cnt;
exit outer;
    # sent last portion
    chunk:= slice(L,i,cnt);
    yielD chunk;
    return nil;
end chunkStep;

#factory for right leg
factory chunkStepR(L:bat[:any,:any]):bat[:any,:any];
@end example

So far we haven;t re-used the pattern that both legs are
identical. This could be modeled by a generic chunk factory.
Choosing a new factory for each query steps reduces the 
administrative overhead.

The Factory concept is still rather experimental and many
questions should be considered, e.g.
What is the lifetime of a factory? Does it persists after
all clients has disappeared?
What additional control do you need? Can you throw an
exception to a Factory?

@{
@h
#ifndef _MAL_FACTORY_H
#define _MAL_FACTORY_H

/* #define DEBUG_MAL_FACTORY  */

#include "mal.h"
#include "mal_client.h"
#include "mal_instruction.h"
#include "mal_interpreter.h"
#include "mal_function.h"
#include "mal_exception.h"

#define POLICYimmediate 1	/* let user wait for reply */
#define POLICYprivate   2	/* each client its own plants */

mal_export str callFactory(Client cntxt, MalBlkPtr mb, MalBlkPtr mbcaller, MalStkPtr stk, InstrPtr pci);
mal_export str yieldFactory(MalBlkPtr mb, InstrPtr p, int pc);
mal_export str returnFactory(MalBlkPtr mb, InstrPtr pp, int pc);
mal_export str finishFactory(MalBlkPtr mb, InstrPtr pp, int pc);
mal_export str shutdownFactory(MalBlkPtr mb);
#endif /*  _MAL_FACTORY_H */
@-
The initial implementation is geared at a central
factory plant manager, which is called to forward
any factory call to their proper destination.

The factory plants are collected in a global,
limited table for now.
@c
#include "mal_factory.h"

typedef struct {
	int id;			/* unique plant number */
	MalBlkPtr factory;
	MalStkPtr stk;		/* private state */
	int pc;			/* where we are */
	int inuse;		/* able to handle it */
	int next;		/* next plant of same factory */
	int policy;		/* flags to control behavior */
	str location;		/* where the factoryMgr resides */

	Client client;		/* who called it */
	MalBlkPtr caller;	/* from routine */
	MalStkPtr env;		/* with the stack  */
	InstrPtr pci;		/* with the instruction */
} PlantRecord, *Plant;

#define MAXPLANTS 256
static PlantRecord plants[MAXPLANTS];
static int lastPlant;
static int plantId = 1;

mal_export Plant newPlant(MalBlkPtr mb);

str
callFactory(Client cntxt, MalBlkPtr mb, MalBlkPtr mbcaller, MalStkPtr stk, InstrPtr pci)
{
	Plant u = 0, pl, plim, lastone = 0;
	int i, k;
	InstrPtr psig = getInstrPtr(mb, 0);
	ValPtr lhs, rhs;
	char cmd;
	str msg;

#ifdef DEBUG_MAL_FACTORY
	stream_printf(GDKout, "factoryMgr called\n");
#endif
	plim = plants + lastPlant;
	/* the lookup can be largely avoided by handing out the index
	   upon factory definition. todo
	 */
	for (pl = plants; pl < plim; pl++)
		if (pl->factory == mb) {
			lastone = pl;
			if (!pl->inuse) {
				u = pl;
				break;
			} else if (pl->next)
				pl = plants + pl->next - 1;
		}
	if (u == 0) {
		/* initialize a new plant using the owner policy */
		pl = newPlant(mb);
		if (pl == NULL)
			return throwMessage("factoryMgr", "No factory space left\n");
		if (lastone)
			lastone->next = plants - pl;
	}
	if (pl->location)
		return throwMessage("factoryMgr", "No remote access allowed\n");

@-
We have found a factory to process the request.
Let's call it as a synchronous action, without concern on parallelism.
@c
	/* remember context */
	pl->client = cntxt;
	pl->caller = mbcaller;
	pl->env = stk;
	pl->pci = pci;
	pl->inuse = 1;
	/* inherit debugging */
	cmd = pl->stk->cmd = stk->cmd;

	/* copy the calling arguments onto the stack 
	   of the factory */
	i = psig->retc;
	for (k = pci->retc; i < pci->argc; i++, k++) {
		lhs = &pl->stk->stk[getArg(psig, k)];
		/* variable arguments ? */
		if (k == psig->argc - 1)
			k--;

		rhs = &pl->env->stk[getArg(pci, i)];
		VALcopy(lhs, rhs);
	}
	if (mb->errors)
		return throwMessage("factory.call", "Factory contains errors");
	if (u == 0)
		msg = runMAL(cntxt, mb, 1, 0, pl->stk, 0);
	else
		msg = reenterMAL(cntxt, mb, pl->pc, -1, pl->stk, 0, 0);
	/* propagate change in debugging status */
	if (cmd && pl->stk->cmd != cmd && cmd != 'x')
		for (; stk; stk = stk->up)
			stk->cmd = pl->stk->cmd;
	return msg;
}

@-
A new plant is constructed. The properties of the factory
should be known upon compile time. They are retrieved from
the signature of the factory definition.
@c
Plant
newPlant(MalBlkPtr mb)
{
	Plant p, plim;

#ifdef DEBUG_MAL_FACTORY
	stream_printf(GDKout, "newPlant called\n");
#endif
	plim = plants + lastPlant;
	for (p = plants; p < plim && p->factory; p++)
		;
	if (lastPlant == MAXPLANTS)
		return 0;
	if (p == plim)
		lastPlant++;
	p->factory = mb;
	p->id = plantId++;

	p->pc = 1;		/* where we start */
	p->stk = newGlobalStack(mb->vsize);
	p->stk->blk = mb;
	p->stk->keepAlive = TRUE;
	return p;
}

@-
Upon reaching the yield operator, the factory is
suspended until the next request arrives.
The information in the target list should be delivered
to the caller stack frame.
@c
Plant
yieldResult(MalBlkPtr mb, InstrPtr p, int pc)
{
	Plant pl, plim = plants + lastPlant;
	ValPtr lhs, rhs;
	int i;

	(void) p;
	(void) pc;
	for (pl = plants; pl < plim; pl++)
		if (pl->factory == mb) {
			for (i = 0; i < p->retc; i++) {
#ifdef DEBUG_MAL_FACTORY
				printf("lhs %d rhs %d\n", getArg(pl->pci, i), getArg(p, i));
#endif
				rhs = &pl->stk->stk[getArg(p, i)];
				lhs = &pl->env->stk[getArg(pl->pci, i)];
				VALcopy(lhs, rhs);
			}
			return pl;
		}
	return NULL;
}

str
yieldFactory(MalBlkPtr mb, InstrPtr p, int pc)
{
	Plant pl;

	pl = yieldResult(mb, p, pc);
	if (pl) {
		pl->inuse = 0;
		pl->pc = pc + 1;
		pl->client = NULL;
		pl->caller = NULL;
		pl->pci = NULL;
		pl->env = NULL;
		return MAL_SUCCEED;
	}
	return throwMessage("yieldFactory", "No factory found\n");
}

@-
A return from a factory implies a YIELD action followed
by closing it.
@c
str
returnFactory(MalBlkPtr mb, InstrPtr pp, int pc)
{
	Plant pl;

	pl = yieldResult(mb, pp, pc);
	if (pl)
		return shutdownFactory(mb);
	return throwMessage("yieldFactory", "No factory found\n");
}

@-
A return from a factory body implies removal of
all state information.
This code should also prepare for handling factories
that are still running threads in parallel.
@c
str
shutdownFactory(MalBlkPtr mb)
{
	Plant pl, plim;

#ifdef DEBUG_MAL_FACTORY
	stream_printf(GDKout, "shutdownFactory called\n");
#endif
	plim = plants + lastPlant;
	for (pl = plants; pl < plim; pl++)
		if (pl->factory == mb) {
			pl->factory = 0;
			pl->inuse = 0;
			pl->client = NULL;
			pl->caller = NULL;
			pl->pci = NULL;
			pl->env = NULL;
		}
	return MAL_SUCCEED;
}

str
finishFactory(MalBlkPtr mb, InstrPtr pp, int pc)
{
	(void) pp;
	(void) pc;
	return shutdownFactory(mb);
}

@- Enquiry operations.
All access to the plant administration is organized here.
@c

@}
