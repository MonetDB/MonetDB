@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f mal
@* Introduction to MonetDB 
The MonetDB product family consists of a large number of components
developed within out group over the last decade. Some components have
already been shipped to happy customers, some are still in the making,
and others have found a resting place in the attic.

The MonetDB architecture is designed to accommodate a wide-spectrum 
of standardized query language front-ends (SQL, XQuery),
a variety of query transformation schemes, and
different execution platforms (interpreted MAL, dynamic compilation).

Version 5 expands the MonetDB software infrastructure, distributed
already in the open source community. 
The most notable differences are its
improved software stack and a new interface language,
which turns the database server back-end into an
abstract database machine with its associated assembler language (MAL).
It supports backward compatibility of interfaces, tools, and 
source sharing where feasible within the limited scope of resources available.

In the remainder of this section we shortly introduce the
MonetDB product family, the design considerations and
a quick overview of the MonetDB Version 5 architecture.

@menu
* Design considerations::
* Architecture overview::
* MAL synopsis::
* MAL execution::
* Backward compatibility::
* Session scenarios::
* Scenario management::
* Client administration ::
@end menu
@node  Design considerations, Architecture overview, MonetDB overview ,MonetDB overview
@+ Design considerations
Redesign of the MonetDB software stack was driven by the need to
reduce the Total Execution Cost (TEC) for query execution.
The TEC is what an end-user or application program will
notice. The TEC is composed on several cost factors:
@itemize
@item  API message handling
@item  Parsing and semantic analysis
@item  Optimization and plan generation
@item  Data access to the tables
@item  Execution of the query terms
@item  Result delivery to the application
@end itemize

Choosing an architecture for processing database operations pre-supposes an
intuition on where and how the cost will be distributed. In an OLTP
setting you expect most of the cost to be in (P,O), while in OLAP it will
be (D,E,R). In a distributed setting the components (O,D,E) are dominant.
Web-applications would focus on (A,E,R).

However, such a simple first characterization ignores the wide-spread
differences that can be experienced at each level. To illustrate,
in D and R it makes a big difference whether the data is already in the
cache or still on disk. Within E it makes a big difference whether you
are comparing two integers, performing a math function such as Gaussian, or
a regular expression evaluation on a string.
As a result, intense optimization in one area may become completely invisible
due to being overshadowed by other cost factors.

The Version 5 infrastructure is designed to ease addressing each
of these cost factors in a well-defined way, while retaining an
option to combine the components needed for a particular situation.
This results in an architecture to assemble the components
for a particular application domain and hardware platform.

The primary interface to the database kernel is still based on
the exchange of text in the form of queries and simply formatted results.
This interface is designed for ease of interpretation, versatility and
flexible to accommodate system debugging and application tool development.
Although a textual interface potentially leads to a performance degradation,
our experience with earlier system versions
showed that the overhead can be kept within acceptable limits.
Moreover, a textual interface reduces the programming
effort otherwise needed to develop test and application programs.

@node Architecture overview, MAL synopsis, Design considerations, MonetDB overview
@+ Architecture overview
The software stack for Version 5 is shown in Figure
 @c image{architecture}
The top layer consists of the query language processors and their
strategic optimizers. Moreover, each language comes with its language
oriented catalog, which may, but need not be stored in the MonetDB database.

@node MAL synopsis, MAL execution, Architecture overview,  MonetDB overview
@+ MonetDB Assembler Language (MAL)
The target language for Version 5 is an assembler-like language,
derived as a subset of the Monet Interface Language introduced
previously. This language provides the textual interface to
the back-end, the communication between (independent) family components,
and the API.

Its design is geared to provide a controlled setting for the
query processors. They can produce algebraic representations
of query plans, which by the MAL optimizers are turned into
physical execution plans.
In this process an execution paradigm is chosen to best fit
the engines available and application needs.

The novel container model for MAL objects is a balance between hardwired
decisions based on the typing scheme
and hooks to implement those as user-defined extensions.
For example, objects can be assembled in @emph{ box}es, which come
with a simple management protocol. Their implementation can be
geared towards any management style required, e.g. delivery of
read-only objects for query processing, transparency to external
resources through wrappers, and high-volume transaction support.

Much in the spirit of Version 4
MAL can be readily extended with user defined types and
service modules. 
Furthermore, the language design is meant to support the
full breath of computational paradigms deployed in a database
setting. In particular, it should provide a clean infrastructure
to implement triggers and stream-based database applications.
Its design and implementation takes the functionality a 
significant step further. To name a few:
@itemize
@item All instructions are strongly typed before being executed. 
@item Polymorphic functions are supported. 
They act as templates that produce strongly typed instantiations when needed.
@item Function style expressions where 
each assignment instruction can receive multiple target results;
it forms a point in the dataflow graph. 
@item Co-routines (Factories) support and building
streaming applications.
@item Properties are associated with the program code for
ease of optimization and scheduling.
@end itemize
@-
@{
@+ Critical sections and semaphores
Monet V5 is implemented as a collection of threads. This calls for extreme
care in coding. At several places locks and semaphores are necessary
to achieve predictable results. In particular, after they are created
and when they are inspected or being modified to take decisions.
 
In the current implementation the following list of locks and semaphores
is used in the Monet layer:
 
@mal
@+ Monet Basic Definitions 
Definitions that need to included in every file of the Monet system,
as well as in user defined module implementations.
@h
#ifndef _MAL_H
#define _MAL_H

#include <gdk.h>
#include <gdk_utils.h>
#include <stream.h>

#ifdef _MSC_VER
#ifndef LIBMAL
#define mal_export extern __declspec(dllimport)
#else
#define mal_export extern __declspec(dllexport)
#endif
#else
#define mal_export extern
#endif

@+ Monet Calling Options
The number of invocation arguments is kept to a minimum.
See the MonetDB5.conf file for additional system variable settings
@
@h
#define MAXSCRIPT 64

mal_export void monet_hello();

mal_export char            monet_cwd[PATHLENGTH];
mal_export int             monet_welcome; 
mal_export str             *monet_script;

#define mal_set_lock(X,Y) if(GDKprotected) MT_set_lock(X,Y)
#define mal_unset_lock(X,Y) if(GDKprotected) MT_unset_lock(X,Y)
#define mal_up_sema(X,Y) if(GDKprotected) MT_up_sema(X,Y)
#define mal_down_sema(X,Y) if(GDKprotected) MT_down_sema(X,Y)
@c 
#include <mal.h>
char monet_cwd[PATHLENGTH] = { 0 };
int monet_welcome = 1;
str *monet_script;
@}
@-
@node MAL execution, Backward compatibility, MAL synopsis , MonetDB overview
@- MonetDB bootstrap

Startup of the MonetDB engine leads to loading the system kernel
libraries as defined in a bootstrap script @code{mal_init.mx}.
The global symbol table is initialized with signatures, and
the pre-compiled commands and pattern code blocks are loaded. 
Expect tens of modules and hundreds of operations to become readily available.

The corresponding libraries may be statically linked or dynamically loaded.
Failure to find the startup-files terminates to session, because
there is no way to activate a linked procedure.
The location of the libraries is decribed in the MonetDB configuration
file.

Unlike previous versions, we do not allow for dropping of modules with
linked code.
The rational behind this design decision is that the feature
was hardly used and severely complicates the code base.
In particular, upon each access to the global symbol table we have to be
prepaired that concurrent threads my be actively changing its structure.
Especially, dropping modules may cause sever problems by not being
able to detect references kept around.
This danger required all accesses to global information to be packaged
in a critical section, which was known to be a performance hindrence.

@-
@node Backward compatibility, Session scenarios ,MAL execution, MonetDB overview
@- Backward compatibility
The oldest MonetDB software runs back to the early nineties and
users have based their business
critical applications on the platform since the mid-nineties.
This long history creates
a challenge in a research laboratory setting to find an evoluationary
software developement track. Fortunately, the core development team
is still at CWI and is dedicated to maintain the software base.
Ofcourse, within the confines of limited resources available
and in balance with the primary research activities.

The development of Version 5 was driven by the following 
compatibility requirements:
@itemize
@item The programming interface technology (ODBC, JDBC, Mapi)
are all retained to reduce impact on external applications.
@item SQL and XQuery should compile 
directly on both old and new versions. 
@item The MIL language is depreciated, but MIL programs can
mostly be converted to the MAL language.@footnote{
Only those features are compiled that do not require runtime
knowledge on the typing structure.}
@item The kernel library GDK remains the primary
execution engine, but it
should also facilitate alternatives, such as the column buffer manager, and 
possibly the X100 kernel.
@item The key extension modules to the GDK kernel
are mostly carried over without change.
@item Nested BATs are not supported anymore, due to unnecessary
complexity at the language layer. However, the concept of a BAT type
is retained, it denotes the bat of interest with a guarantee
that the bat was not removed after it got referenced.
@item Auxiliary search paths are not supported, due to lack
of interest in Version 4 user community and alternatives based on
the BAT algebra.
@end itemize

@{
@h

mal_export int             mal_debug;
mal_export MT_Lock  mal_contextLock;

mal_export int mal_init();

/* This should be here, but cannot, as "Client" isn't known, yet ... |-(
 * For now, we move the prototype declaration to src/mal/mal_client.c,
 * the only place where it is currently used. Maybe, we should concider
 * also moving the implementation there...
 */
/* mal_export void mal_exit(Client cntxt); */   
/* used in src/mal/mal_client.c */

#define MALprofiler 1       /* activate the profiler */
/* #undef MALprofiler*/


/* Listing modes are globally known */
#define LIST_INPUT      1       /* echo original input */
#define LIST_MAL_INSTR  2       /* show mal instruction */
#define LIST_MAL_TYPE   4       /* show type resolutoin */
#define LIST_MAL_BIND   8       /* show binding information*/
#define LIST_MAL_ALL    (LIST_MAL_INSTR | LIST_MAL_TYPE | LIST_MAL_BIND)

#define MAL_SUCCEED ((str) 0) /* apparently no error */
#define MALexception    "MALexception"

#define STRUCT_ALIGNED

#ifndef MAXPATHLEN
#define MAXPATHLEN 1024
#endif

#endif /*  _MAL_H*/
@c
#include "mal_client.h"
#include "mal_linker.h"
#include "mal_session.h"
#include "mal_parser.h"
#include "mal_interpreter.h"
#include "mal_namespace.h"  /* for initNamespace() */

int             mal_debug= 0;
MT_Lock     mal_contextLock=0;
@-
Initialization of the MAL context
The compiler directive STRUCT_ALIGNED tells that the
fields in the VALrecord all start at the same offset.
This knowledge avoids low-level type decodings, but should
be assured at least once for each platform.
@c

void tstAligned()
{
    int allAligned=0;
    ValRecord v;
    ptr val, base;
    base = (ptr) & v.val.ival; 
    val= (ptr) & v.val.bval; if(val != base){ allAligned = -1; }
    val= (ptr) & v.val.cval[0]; if(val != base){ allAligned = -1; }
    val= (ptr) & v.val.shval; if(val != base){ allAligned = -1; }
    val= (ptr) & v.val.br.id; if(val != base){ allAligned = -1; }
    val= (ptr) & v.val.ival; if(val != base){ allAligned = -1; }
    val= (ptr) & v.val.oval; if(val != base){ allAligned = -1; }
    val= (ptr) & v.val.pval; if(val != base){ allAligned = -1; }
    val= (ptr) & v.val.fval; if(val != base){ allAligned = -1; }
    val= (ptr) & v.val.dval; if(val != base){ allAligned = -1; }
    val= (ptr) & v.val.lval; if(val != base){ allAligned = -1; }
    val= (ptr) & v.val.sval; if(val != base){ allAligned = -1; }
#ifdef STRUCT_ALIGNED
    if(allAligned<0)
        GDKfatal("Recompile with STRUCT_ALIGNED flag disabled\n");
#else
    if(allAligned==0)
        GDKfatal("Recompile with STRUCT_ALIGNED flag enabled\n");
#endif
}
int mal_init(){
    mal_contextLock= MT_create_lock();
    tstAligned();
    initNamespace();
    initParser();
	if( malBootstrap() == 0) {
		showErrors();
		return -1;
	}
    return 0;
}
@-
Upon exit we should attempt to remove all allocated memory explicitly.
This seemingly superflous action is necessary to simplify memory leakage
problems later on.
Unfortunately the GDK layer is does not clean-up upon exit.
@c
void mal_exit(Client cntxt){
#ifdef MALprofiler
    profileReport( cntxt->nspace,1, open_wastream("/tmp/Monet.prof"));
#endif
    freeModuleList(cntxt->nspace);
    cntxt->nspace = 0;
    freeBoxes();
    mal_scope = 0;
    unloadModuleLibraries();
    TMcommit();
    finishNamespace();
	killClient(cntxt);
    GDKexit(0);
}
@}
