@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f mal
@* Introduction to MonetDB Version 5
The MonetDB product family consists of a large number of components
developed within our group over the last decade. Some components have
already been shipped to happy customers, some are still in the making,
and others have found a resting place in the attic.

The MonetDB architecture is designed to accommodate a wide-spectrum 
of standardized query language front-ends (SQL, XQuery),
a variety of query transformation schemes, and
different execution platforms (interpreted materialized or
pipelined, dynamic compilation).

MonetDB Version 5 is a major release of our software infrastructure.
The most notable differences are its greatly
improved software stack and a new interface language,
which turns the database server back-end into an
abstract database machine with its associated assembler language (MAL).
It supports backward compatibility of interfaces, tools, and 
source sharing where feasible within the limited scope of resources available.

In the remainder of this section we shortly introduce the
MonetDB Version 5 design considerations and
a quick overview of the its architecture.

@menu
* Design considerations::
* Architecture overview::
* MAL synopsis::
* MAL execution::
* Backward Compatibility::
* Session Scenarios::
* Scenario management::
* Client administration ::
@end menu
@node  Design considerations, Architecture overview, MonetDB Overview ,MonetDB Overview
@+ Design considerations
Redesign of the MonetDB software stack was driven by the need to
reduce the effort to extend the system into novel directions
and to reduce the Total Execution Cost (TEC).
The TEC is what an end-user or application program will notice. 
The TEC is composed on several cost factors:
@itemize 
@item  A)
API message handling
@item  P)
Parsing and semantic analysis
@item  O)
Optimization and plan generation
@item  D)
Data access to the persistent store
@item  E)
Execution of the query terms
@item R)
Result delivery to the application
@end itemize

Choosing an architecture for processing database operations pre-supposes an
intuition on where and how the cost will be distributed. In an OLTP
setting you expect most of the cost to be in (P,O), while in OLAP it will
be (D,E,R). In a distributed setting the components (O,D,E) are dominant.
Web-applications would focus on (A,E,R).

Such a simple characterization ignores the wide-spread
differences that can be experienced at each level. To illustrate,
in D) and R) it makes a big difference whether the data is already in the
cache or still on disk. With E) it makes a big difference whether you
are comparing two integers, evaluation of a mathematical function,
e.g. Gaussian, or a regular expression evaluation on a string.
As a result, intense optimization in one area may become completely invisible
due to being overshadowed by other cost factors.

The Version 5 infrastructure is designed to ease addressing each
of these cost factors in a well-defined way, while retaining the
flexibility to combine the components needed for a particular situation.
This results in an architecture to assemble the components
for a particular application domain and hardware platform.

The primary interface to the database kernel is still based on
the exchange of text in the form of queries and simply formatted results.
This interface is designed for ease of interpretation, versatility and
flexible to accommodate system debugging and application tool development.
Although a textual interface potentially leads to a performance degradation,
our experience with earlier system versions
showed that the overhead can be kept within acceptable bounds.
Moreover, a textual interface reduces the programming
effort otherwise needed to develop test and application programs.

@node Architecture overview, MAL synopsis, Design considerations, MonetDB Overview
@+ Architecture overview
The architecture is built around three independent components:
the MonetDB server, the MonetDB guardian, and the client application.
The MonetDB server is the heart of the system, it manages a single
physical database on one machine for all (concurrent) applications.
The guardian program works along side a single server, keeping
an eye on its behavior. If the server accidently crashes, it is this program
that will attempt an automatic restart.
Server and guardian are managed with the @code{monetdb} script,
introduced in @ref{Start and Stop the Server}.

The top layer consists of applications written in your favorite
language.
They provide both specific functionality
for a particular product, e.g. Proximity,
and generic functionality, e.g. the Aquabrowser.
The applications communicate with the server 
using a de-facto standard interface packaged as a library
e.g. JDBC, ODBC, Perl, PHP, etc..

The prime query language processors available in the MonetDB family are
SQL and XQuery. The former supports the core functionality
of SQL:1999 and extends into SQL:2003. The latter is based on
the W3C standard and includes the XUpdate functionality.
The query language processors each manage their own private catalog structure.
Software bridges, e.g. import/export routines, are used to
share data between language paradigms.

For each a language specific, strategic optimizer is included. 
It uses knowledge on the language semantics and general
heuristics, such as pushing down selections through
joins, to derive better programs.

@node MAL synopsis, MAL execution, Architecture overview,  MonetDB Overview
@+ MonetDB Assembler Language (MAL)
The target language for the query compilers is an assembler-like language,
called the MonetDB Assembler Language (MAL).
It is a simplified subset of the Monet Interface Language introduced
previously. The language provides a direct the textual interface to
the server back-end, i.e. MAL is a language available to applications
as well.

Its design is geared to provide a controlled setting for the
query processors. They can produce algebraic representations
of query plans, which by the MAL optimizers are turned into
physical execution plans.
In this process an execution paradigm is chosen to best fit
the engines available and application needs.

The @emph{box} container model for MAL objects is a balance 
between hardwired decisions based on the typing scheme
and hooks to implement those as user-defined extensions.
For example, objects can be assembled in @emph{ box}es, which come
with a simple management protocol. Their implementation can be
geared towards any management style required, e.g. delivery of
read-only objects for query processing, transparency to external
resources through wrappers, and high-volume transaction support.

Much in the spirit of Version 4
MAL can be readily extended with user defined types and
service modules. 
Furthermore, the language design is meant to support the
full breath of computational paradigms deployed in a database
setting. In particular, it should provide a clean infrastructure
to implement triggers and stream-based database applications.
Its design and implementation takes the functionality a 
significant step further. To name a few:
@itemize @bullet
@item All instructions are strongly typed before being executed. 
@item Polymorphic functions are supported. 
They act as templates that produce strongly typed instantiations when needed.
@item Function style expressions where 
each assignment instruction can receive multiple target results;
it forms a point in the dataflow graph. 
@item Co-routines (Factories) support building streaming applications.
@item Properties are associated with the program code for
ease of optimization and scheduling.
@end itemize
@-
@{
@+ Critical sections and semaphores
Monet V5 is implemented as a collection of threads. This calls for extreme
care in coding. At several places locks and semaphores are necessary
to achieve predictable results. In particular, after they are created
and when they are inspected or being modified to take decisions.
 
In the current implementation the following list of locks and semaphores
is used in the Monet layer:
 
@mal
@+ Monet Basic Definitions 
Definitions that need to included in every file of the Monet system,
as well as in user defined module implementations.
@h
#ifndef _MAL_H
#define _MAL_H

#include <mal_config.h>
#include <gdk.h>
#include <gdk_utils.h>
#include <stream.h>

#ifdef NATIVE_WIN32
#ifndef LIBMAL
#define mal_export extern __declspec(dllimport)
#else
#define mal_export extern __declspec(dllexport)
#endif
#else
#define mal_export extern
#endif

@+ Monet Calling Options
The number of invocation arguments is kept to a minimum.
See the MonetDB5.conf file for additional system variable settings
@
@h
#define MAXSCRIPT 64

mal_export void monet_hello();

mal_export char            monet_cwd[PATHLENGTH];
mal_export int             monet_welcome; 
mal_export str             *monet_script;
mal_export int 				monet_daemon;

#define mal_set_lock(X,Y) if(GDKprotected) MT_set_lock(X,Y)
#define mal_unset_lock(X,Y) if(GDKprotected) MT_unset_lock(X,Y)
#define mal_up_sema(X,Y) if(GDKprotected) MT_up_sema(X,Y)
#define mal_down_sema(X,Y) if(GDKprotected) MT_down_sema(X,Y)
@c 
#include <mal.h>

char monet_cwd[PATHLENGTH] = { 0 };
int monet_welcome = 1;
str *monet_script;
int monet_daemon=0;
@}
@-
@node MAL execution, Session Scenarios, MAL synopsis , MonetDB Overview
@- MonetDB bootstrap

Startup of the MonetDB server leads to loading the system kernel
libraries as defined in a bootstrap script @code{mal_init.mx}.
Its default location is decribed in the MonetDB configuration file.
Failure to find the startup-file terminates the session.
The global symbol table is initialized with function signatures, and
the pre-compiled commands and pattern code blocks are loaded. 
The libraries may be dynamically loaded by default.
Expect tens of modules and hundreds of operations to become readily available.

Modules once loaded can not be dropped without restarting the server.
The rational behind this design decision is that a dynamic load/drop feature
is often hardly used and severely complicates the code base.
In particular, upon each access to the global symbol table we have to be
prepaired that concurrent threads my be actively changing its structure.
Especially, dropping modules may cause sever problems by not being
able to detect all references kept around.
This danger required all accesses to global information to be packaged
in a critical section, which is known to be a severe performance hindrence.

@{
@h

mal_export MT_Lock  mal_contextLock;

mal_export int mal_init();
mal_export void mal_exit();

/* This should be here, but cannot, as "Client" isn't known, yet ... |-(
 * For now, we move the prototype declaration to src/mal/mal_client.c,
 * the only place where it is currently used. Maybe, we should concider
 * also moving the implementation there...
 */

#define MALprofiler 1       /* activate the profiler */
/* #undef MALprofiler*/


/* Listing modes are globally known */
#define LIST_INPUT      1       /* echo original input */
#define LIST_MAL_INSTR  2       /* show mal instruction */
#define LIST_MAL_TYPE   4       /* show type resolutoin */
#define LIST_MAL_ALL    (LIST_MAL_INSTR | LIST_MAL_TYPE )

#define MAL_SUCCEED ((str) 0) /* apparently no error */
#define MALexception    "MALexception"

#define STRUCT_ALIGNED

#ifndef MAXPATHLEN
#define MAXPATHLEN 1024
#endif

#endif /*  _MAL_H*/
@c
#include "mal_client.h"
#include "mal_linker.h"
#include "mal_session.h"
#include "mal_parser.h"
#include "mal_interpreter.h"
#include "mal_namespace.h"  /* for initNamespace() */

MT_Lock     mal_contextLock=0;
@-
Initialization of the MAL context
The compiler directive STRUCT_ALIGNED tells that the
fields in the VALrecord all start at the same offset.
This knowledge avoids low-level type decodings, but should
be assured at least once for each platform.
@c

void tstAligned()
{
	int allAligned=0;
	ValRecord v;
	ptr val, base;
	base = (ptr) & v.val.ival; 
	val= (ptr) & v.val.bval; if(val != base){ allAligned = -1; }
	val= (ptr) & v.val.cval[0]; if(val != base){ allAligned = -1; }
	val= (ptr) & v.val.shval; if(val != base){ allAligned = -1; }
	val= (ptr) & v.val.br.id; if(val != base){ allAligned = -1; }
	val= (ptr) & v.val.ival; if(val != base){ allAligned = -1; }
	val= (ptr) & v.val.oval; if(val != base){ allAligned = -1; }
	val= (ptr) & v.val.pval; if(val != base){ allAligned = -1; }
	val= (ptr) & v.val.fval; if(val != base){ allAligned = -1; }
	val= (ptr) & v.val.dval; if(val != base){ allAligned = -1; }
	val= (ptr) & v.val.lval; if(val != base){ allAligned = -1; }
	val= (ptr) & v.val.sval; if(val != base){ allAligned = -1; }
#ifdef STRUCT_ALIGNED
	if(allAligned<0)
	    GDKfatal("Recompile with STRUCT_ALIGNED flag disabled\n");
#else
	if(allAligned==0)
	    GDKfatal("Recompile with STRUCT_ALIGNED flag enabled\n");
#endif
}
int mal_init(){
	mal_contextLock= MT_create_lock();
	tstAligned();
	initNamespace();
	initParser();
	if( malBootstrap() == 0) {
		showErrors();
		return -1;
	}
	return 0;
}
@-
Upon exit we should attempt to remove all allocated memory explicitly.
This seemingly superflous action is necessary to simplify analyis of
memory leakage problems later on.
@c
void mal_exit(Client cntxt){
#ifdef MALprofiler
	stream *f;
	profileReport( cntxt->nspace,1, f= open_wastream("/tmp/Monet.prof"));
	close_stream(f);
#endif
	/* early exit to solve random crashes, needs work */
	MT_global_exit(0);

	freeBoxes();
	freeModuleList(cntxt->nspace);
	mal_scope = 0;
	unloadModuleLibraries(); 

	finishNamespace();
	if( cntxt->cwd)
		GDKfree(cntxt->cwd);
	if( cntxt->prompt)
		GDKfree(cntxt->prompt);
	if( cntxt->errbuf)
		GDKfree(cntxt->errbuf);
	if( cntxt->bak)
		GDKfree(cntxt->bak);
	if( cntxt->fdin){
		/* missing protection against closing stdin stream */
		(void) stream_close(cntxt->fdin->s);
		(void) stream_destroy(cntxt->fdin->s);
		(void) bstream_destroy(cntxt->fdin);
	}
	if( cntxt->fdout && cntxt->fdout != GDKstdout) {
		(void) stream_close(cntxt->fdout);
		(void) stream_destroy(cntxt->fdout);
	}
	system("rm -f .*.port");
/*	GDKexit(0);  */
	MT_global_exit(0);
}
@}
