@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@a M.L. Kersten
@* Program Debugging

In practice it is hard to write a correct MAL program the
first time around. Instead, it is more often constructed by
trial-and-error. As long as there are syntax and semantic errors
the MAL compiler provides a sufficient handle to proceed. Once
it passes the compiler we have to resort to a debugger to
assess its behavior.

@menu
* The MAL Debugger::
* Handling Breakpoints::
* Runtime Inspection::
@end menu
@node The MAL Debugger, Handling Breakpoints, Program Debugging, TOC
@+ The MAL debugger
To ease debugging and performance monitoring, the MAL interpreter
comes with a gdb-like debugger.
An illustrative session elicits the functionality offered.

@example
>function test(i:int):str;
>	io.print(i);
>	i:= i*2;
>	b:= bbp.new(:int,:int);
>	bat.insert(b,1,i);
>	io.print(b);
>	return test:= "ok";
>end test;
>user.test(1);
[ 1 ]
#-----------------#
# h     t         # name
# int   int       # type
#-----------------#
[ 1,      2       ]
@end example

The debugger can be entered at any time using the call mdb.start().
An overview of the available commands is readily available.
@example
>mdb.start();
#mdb !end main;
mdb>help
next       -- Advance to next statement
continue   -- Continue program being debugged
break      -- set breakpoint on current instruction
break <var>    -- break on assignment to <var>
delete <var>   -- remove break point <var>
step       -- advance to next MAL instruction
module     -- display the module signatures
finish     -- finish current call
exit       -- terminate current call
quit       -- turn off debugging
list <fcn> -- list current program block
List <fcn> -- list with type information
var  <fcn>  -- print symbol table for module
optimizer <idx>  -- display program after optimizer step
print <var>    -- display value of a variable
print <var> <cnt>[<first>] -- display BAT chunk
info <var>     -- display bat variable properties
run        -- restart current procedure
where      -- print stack trace
down       -- go down the stack
up         -- go up the stack
timer      -- produce micro-second response time
io         -- produce page activity trace
help       -- this message
mdb>
@end example

We walk our way through a debugging session, highlighting the
effects of the debugger commands.
The call to mdb.start() has been encapsulated in a complete
MAL function, as shown by issuing the list command.
A more detailed listing shows the binding to the C-routine
and the result of type resolution.
@example
>mdb.start();
#end main;
mdb>l
function user.main():int;
    mdb.start();
end main;
mdb>L
function user.main():int;       # 0  (main:int)
    mdb.start();        # 1 MDBstart (_1:void)
end main;       # 2
@end example
The user module is the default place for function defined at
the console. The modules loaded can be shown typeing the
command 'modules' or 'module'(or 'm'  for short). 
The former merely enumerates the module names, the latter also shows 
the names of the function in each.
The function signatures become visible using the module and optionally
the function name.
@example
mdb>m alarm
#command alarm.alarm(secs:int,action:str):void address ALARMsetalarm;
#command alarm.ctime():str address ALARMctime;
#command alarm.epilogue():void address ALARMepilogue;
#command alarm.epoch():int address ALARMepoch;
#command alarm.prelude():void address ALARMprelude;
#command alarm.sleep(secs:int):void address ALARMsleep;
#command alarm.time():int address ALARMtime;
#command alarm.timers():bat[:str,:str] address ALARMtimers;
#command alarm.usec():lng address ALARMusec;
mdb>m alarm.sleep
#command alarm.sleep(secs:int):void address ALARMsleep;
mdb>
@end example
The debugger mode is left with a <return>.
Any subsequent MAL instruction re-activates the debugger to
await for commands. The default operation is to step through
the execution using the 'next' ('n') or 'step' ('s) commands,
as shown below.
@example
>user.test(1);
#    user.test(1);
mdb>n
#    io.print(i);
mdb>
[ 1 ]
#    i := calc.*(i,2);
mdb>
#    b := bbp.new(:int,:int);
mdb>
@end example
The last instruction show is ready to be executed, which means
the calculation has already been finished. The value assigned
to a variable can be
shown using a print statement, which contains the location of
the variable on the stack frame, its name, its value and type.
The complete stack frame becomes visible with 'values' ('v')
command:
@example
#    bat.insert(b,1,i);
mdb>
#    io.print(b);
mdb>v
#Stack for 'test' size=32 top=11
#[0] test        = nil:str
#[1] i   = 4:int
#[2] _2  = 0:int   unused
#[3] _3  = 2:int  constant
#[4] b   = <tmp_1226>:bat[:int,:int]   count=1 lrefs=1 refs=0
#[5] _5  = 0:int   type variable
#[6] _6  = nil:bat[:int,:int]   unused
#[7] _7  = 1:int  constant
#[8] _8  = 0:int   unused
#[9] _9  = "ok":str  constant
@end example
The variables marked 'unused' have been introduced as temporary variables,
but which are not referenced in the remainder of the program.
It also illustrates basic BAT properties, a complete description of which
can be obtained using the 'info' ('i') command.
A sample of the BAT content can be printed passing tuple indices, e.g.
'print b 10 10' prints the second batch of ten tuples.

@node Handling Breakpoints, Runtime Inspection, The MAL Debugger, TOC
@+ Handling Breakpoints
A powerful mechanism for debugging a program is to set breakpoints
during the debugging session.
In MAL they are designated by the <operator> or <variable> name.
As soon as the variable recieves a new value  or the operation
is called the debugger is activated.

The snippet below illustrates the reaction to set a break point
on assignment to variable 'i'. The current implementation is limited,
because the breakpoint can only be set within a visibile program
context. Setting arbitrary breakpoints is on the feature request list.
@example
>mdb.start();
#end main;
mdb>
>user.test(1);
#    user.test(1);
mdb>b i
breakpoint on 'i' not set
mdb>n
#    io.print(i);
mdb>break i
mdb>c
[ 1 ]
#    i := calc.*(i,2);
mdb>
@end example

The interpreter can be instructed to call the debugger as soon as an exception
is raised. Simply add the instruction @code{mdb.setCatch(true)}.
@node Runtime Inspection, Execution Profiling, Handling Breakpoints,  TOC
@+ Runtime Inspection and Reflection
Part of the debugger functionality can also be used directly with
MAL instructions.
The execution trace of a snippet of code can be visualized 
encapsulation with @code{mdb.setTrace(true)} and @code{mdb.setTrace(false)}.
Likewise, the performance can be monitored with the command @code{mdb.setTimer(on/off)}.
Using a boolean argument makes it easy to control the (performance) trace
at run time. The following snippet shows the effect of patching
the test case.
@example
>function test(i:int):str;
>	mdb.setTrace(true);
>	io.print(i);
>	i:= i*2;
>	b:= bbp.new(:int,:int);
>	bat.insert(b,1,i);
>	io.print(b);
>	mdb.setTrace(false);
>	return test:= "ok";
>end test;
>user.test(1);
#    mdb.setTrace(_3=true)
[ 1 ]
#    io.print(i=1)
#    i := calc.*(i=2, _5=2)
#    b := bbp.new(_7=0, _8=0)
#    bat.insert(b=<tmp_1226>, _10=1, i=2)
#-----------------#
# h     t         # name
# int   int       # type
#-----------------#
[ 1,      2       ]
#    io.print(b=<tmp_1226>)
#   261 usec!    user.test(_2=1)
>
@end example

The command setTimer() produces timing statistics in micro-seconds. 
Aside from the time spent in each statement
separately, it accumulate the timeing for the complete call.
The time spent on preparing the trace information is excluded
from the time reported.
For more detailed timing information the Linux
tool @emph{valgrind} may be of help.

@example
>function test(i:int):str;
>	mdb.setTimer(true);
>	io.print(i);
>	i:= i*2;
>	b:= bbp.new(:int,:int);
>	bat.insert(b,1,i);
>	io.print(b);
>	mdb.setTimer(false);
>	return test:= "ok";
>end test;
>user.test(1);
#     6 usec#    mdb.setTimer(_3=true)
[ 1 ]
#    43 usec#    io.print(i=1)
#     5 usec#    i := calc.*(i=2, _5=2)
#    24 usec#    b := bbp.new(_7=0, _8=0)
#    10 usec#    bat.insert(b=<tmp_1226>, _10=1, i=2)
#-----------------#
# h     t         # name
# int   int       # type
#-----------------#
[ 1,      2       ]
#   172 usec#    io.print(b=<tmp_1226>)
#   261 usec#    user.test(_2=1)
@end example

It is also possible to activate the debugger from within a program 
using @code{mdb.start()}. It remains in this mode until 
you either issue a quit command, or the command mdb.stop() instruction is
encountered. 
The debugger is only activated when the user can direct its execution
from the client interface. Otherwise, there is no proper input channel
and the debugger will run in trace mode.

The program listing functionality of the debugger is 
also captured in the MAL debugger module. The current code
block can be listed using @code{mdb.list()} and @code{mdb.List()}.
An arbitrary code block can be shown with  @code{mdb.list}(@emph{module},@emph{function})
and @code{mdb.List}(@emph{module},@emph{function}).
A BAT representation of the current function is return by @code{mdb.getDefinition()}@.

The symbol table and stack content, if available, can be shown with
the operations @code{mdb.var()} and @code{mdb.list}(@emph{module},@emph{function})
Access to the stack frames may be helpful in the context of exception handling.
The operation @code{mdb.getStackDepth()} gives the depth and individual
elements can be accessed as BATs using @code{mdb.getStackFrame(@emph{n})}.
The top stack frame is accessed using @code{mdb.getStackFrame()}.
@{
@- Compilation control
Being able to debug comes at a price.
It should be possible to turn off the feature at compile time.

@h
#ifndef _MAL_DEBUGGER_H
#define _MAL_DEBUGGER_H

#include "mal_scenario.h"
#include "mal_client.h"

#define MAL_DEBUGGER		/* debugger is active */

#define MAXBREAKS 32

mal_export int MDBdelay;	/* do not immediately react */
typedef struct {
	MalBlkPtr brkBlock[MAXBREAKS];
	int brkVar[MAXBREAKS];
	char brkCmd[MAXBREAKS];
	str brkVarName[MAXBREAKS];
	int brkTop;
} mdbStateRecord, *mdbState;

mal_export void mdbSetBreakpoint(Client cntxt, MalBlkPtr mb, InstrPtr p, str name, char cmd);
mal_export void mdbClrBreakpointName(Client cntxt, str name);
mal_export void mdbShowBreakpoints(Client cntxt);
mal_export void mdbCommand(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p, int pc);
mal_export int mdbSession();
mal_export void mdbStep(Client cntxt, MalBlkPtr mb, MalStkPtr stk, int pc);
mal_export void mdbHelp(stream *f);
mal_export void printStackElm(stream *f, MalBlkPtr mb, VarPtr n, ValPtr v, int index, size_t cnt, int first);
mal_export void printBATelm(stream *f, int i, size_t cnt, size_t first);
mal_export void printStack(stream *f, MalBlkPtr mb, MalStkPtr s);
mal_export void printBatInfo(stream *f, VarPtr n, ValPtr v);
mal_export void printTraceCall(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mal_export str call2str(MalBlkPtr mb, MalStkPtr stk, int pc, int extra);

mal_export str runMALDebugger(Symbol s);
mal_export void printBBPinfo(stream *out);

mal_export void resetOptimizerDebugger();
mal_export void optimizerDebug(MalBlkPtr mb, str name, int actions, lng usec);
mal_export str optimizeMALBlock(MalBlkPtr mb);
mal_export void showOptimizerStep(int i, int flg);
mal_export void showOptimizerHistory();
mal_export str debugOptimizers(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
#endif /* _MAL_DEBUGGER_h */
@+ Debugger framework
Before the interpreter is allowed to proceed we give control
to the user to alter the trace/debugger options.
@c
#include "mal_debugger.h"
#include "mal_atom.h"		/* for showAtoms() */
#include "mal_interpreter.h"	/* for getArgReference() */
#include "mal_linker.h"		/* for getAddress() */
#include "mal_module.h"		/* for showModuleStatistics() */
#include "mal_parser.h"
#include "mal_namespace.h"


int MDBdelay;			/* do not immediately react */

#define skipBlanc(c,X)    while(*(X) && isspace((int)*X)){ X++; }
#define skipNonBlanc(c,X) while(*(X) && !isspace((int) *X)){ X++; }
#define skipWord(c,X) 	  skipNonBlanc(c,X); skipBlanc(c,X);
@-
Each client has its own breakpoint administration, kept in a global table.
Although a little space consumptive, it is the easiest to maintain
and much less expensive as reserving debugger space in each instruction.
@c
mdbStateRecord mdbTable[MAL_MAXCLIENTS];

char
isBreakpoint(Client cntxt, InstrPtr p)
{
	int i, j;

	for (i = 0; i < mdbTable[cntxt->idx].brkTop; i++) {
		if (functionId(p) && strcmp(functionName(p), mdbTable[cntxt->idx].brkVarName[i]) == 0)
			return mdbTable[cntxt->idx].brkCmd[i];
		for (j = 0; j < p->retc; j++)
			if (p->argv[j] == mdbTable[cntxt->idx].brkVar[i])
				return mdbTable[cntxt->idx].brkCmd[i];
	}
	return 0;
}

@-
Break points can be set on assignment to a specific variable
or specific operation.
@c
void
mdbSetBreakpointName(Client cntxt, MalBlkPtr mb, str name, char cmd)
{
	int i, j, cnt = 0;
	InstrPtr p;

	for (i = 0; i < mb->stop; i++) {
		p = getInstrPtr(mb, i);
		if (functionId(p) && strcmp(functionName(p), name) == 0) {
			mdbSetBreakpoint(cntxt, mb, p, name, cmd);
			cnt++;
			continue;
		}
		for (j = 0; j < p->retc; j++)
			if (strcmp(getArgName(mb, p, j), name) == 0) {
				mdbSetBreakpoint(cntxt, mb, p, name, cmd);
				cnt++;
				continue;
			}
	}
	if (cnt == 0)
		stream_printf(cntxt->fdout, "breakpoint on '%s' not set\n", name);
}

@-
A breakpoint should be set once for each combination
@c
void
mdbSetBreakpoint(Client cntxt, MalBlkPtr mb, InstrPtr p, str name, char cmd)
{
	mdbState mdb = mdbTable + cntxt->idx;
	int i;

	for (i = 0; i < mdb->brkTop; i++)
		if (mdb->brkBlock[i] == mb && strcmp(mdb->brkVarName[i], name) == 0)
			return;
	mdb->brkBlock[mdb->brkTop] = mb;
	mdb->brkVar[mdb->brkTop] = getDestVar(p);
	mdb->brkVarName[mdb->brkTop] = GDKstrdup(name);
	mdb->brkCmd[mdb->brkTop] = cmd;
	if (mdb->brkTop + 1 < MAXBREAKS)
		mdb->brkTop++;
}

void
mdbShowBreakpoints(Client cntxt)
{
	int i;
	mdbState mdb = mdbTable + cntxt->idx;

	for (i = 0; i < mdb->brkTop; i++)
		stream_printf(cntxt->fdout, "breakpoint on '%s' with id %d\n", mdb->brkVarName[i], mdb->brkVar[i]);
}

void
mdbClrBreakpoint(Client cntxt, InstrPtr p)
{
	int i, j = 0;
	mdbState mdb = mdbTable + cntxt->idx;

	for (i = 0; i < mdb->brkTop; i++) {
		mdb->brkVar[j] = mdb->brkVar[i];
		mdb->brkVarName[j] = mdb->brkVarName[i];
		mdb->brkCmd[j] = mdb->brkCmd[i];
		mdb->brkBlock[j] = mdb->brkBlock[i];
		if (mdb->brkVar[i] != getDestVar(p))
			j++;
		else {
			GDKfree(mdb->brkVarName[i]);
			mdb->brkVarName[i] = 0;
		}

	}
	mdb->brkTop = j;
}

void
mdbClrBreakpointName(Client cntxt, str name)
{
	int i, j = 0;
	mdbState mdb = mdbTable + cntxt->idx;

	for (i = 0; i < mdb->brkTop; i++) {
		mdb->brkVar[j] = mdb->brkVar[i];
		mdb->brkVarName[j] = mdb->brkVarName[i];
		mdb->brkCmd[j] = mdb->brkCmd[i];
		mdb->brkBlock[j] = mdb->brkBlock[i];
		if (strcmp(mdb->brkVarName[i], name))
			j++;
		else {
			GDKfree(mdb->brkVarName[i]);
			mdb->brkVarName[i] = 0;
		}
	}
	mdb->brkTop = j;
}

@-
The instruction call stack is the most common command.
Prepare a string for an instruction call. The flag indicates
a need for position information as well.
@c
str
call2str(MalBlkPtr mb, MalStkPtr stk, int pc, int extra)
{
	InstrPtr p;
	char target[BLOCK], buf[BLOCK];
	int l, k;

	p = getInstrPtr(mb, pc);
	if (p != NULL) {
		target[0] = 0;
		fillTarget(mb, p, target);
		if (moduleId(p) && functionId(p)) {
			snprintf(buf, BLOCK, "%s%s.%s(", target, moduleName(p), functionName(p));
			for (k = p->retc; k < p->argc; k++) {
				str msg = 0;
				ValPtr v = &stk->stk[getArg(p, k)];

				ATOMformat(v->vtype, VALptr(v), &msg);
				l = strlen(buf);
				snprintf(buf + l, BLOCK - l, "%s", msg);
				GDKfree(msg);
				if (k < p->argc - 1) {
					l = strlen(buf);
					snprintf(buf + l, BLOCK - l, ",");
				}
			}
			l = strlen(buf);
			snprintf(buf + l, BLOCK - l, ");");
		} else {
			strcpy(buf, instruction2str(mb, p, FALSE));
			strcpy(buf, target);
		}
	}
	if (extra) {
		p = getInstrPtr(mb, 0);
		l = strlen(buf);
		snprintf(buf + l, BLOCK - l, " at #%d in %s", pc, functionName(p));
	}
	return GDKstrdup(buf);
}

void
printCall(Client cntxt, MalBlkPtr mb, MalStkPtr stk, int pc)
{
	str msg;

	msg = call2str(mb, stk, pc, TRUE);
	stream_printf(cntxt->fdout, "%s\n", msg);
	GDKfree(msg);
}

@-
Beware, the printTraceCall is a rather expensive routine and obscures
the actual timing. We therefore compensate the global timing maintained
@c
void
printTraceCall(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	int k;
	str msg;
	str s;

	msg = instruction2str(mb, p, FALSE);
	s = strchr(msg, '(');
	if (p->retc > 1 && s) {
		s = strchr(s + 1, '(');
	}
	if (s) {
		s++;
		*s = 0;
		stream_printf(cntxt->fdout, "%s", msg);
		for (k = p->retc; k < p->argc; k++) {
			VarPtr v = getVar(mb, getArg(p, k));
			ValPtr val = &stk->stk[getArg(p, k)];

			if (v->tmpindex == 0)
				stream_printf(cntxt->fdout, "%s=", v->name);
			else
				stream_printf(cntxt->fdout, "%c%d=", TMPMARKER, v->tmpindex);
			ATOMprint(val->vtype, VALptr(val), cntxt->fdout);
			if (k < p->argc - 1)
				stream_printf(cntxt->fdout, ", ");
		}
		stream_printf(cntxt->fdout, ")\n");
	} else
		stream_printf(cntxt->fdout, "%s\n", msg);
	GDKfree(msg);
}

@+ MAL parser
The debugger structure is inherited from GDB.
The routine mdbCommand is called with p=0 after finishing a mal- function call
and before continuing at the next level of invocation.
The commands are self-explanatory.

The prompt string sent to the user indicates the debugger mode.
@c
#define MDBstatus(X) if(cntxt->fdout) \
	stream_printf(cntxt->fdout,"#MonetDB Debugger %s\n", (X?"on":"off"));

void
mdbCommand(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p, int pc)
{
	int m = 1;
	char *b, *c;
	bstream *oldin;
	stream *out = cntxt->fdout;
	int listing = cntxt->listing;
	char *oldprompt = cntxt->prompt;
	int oldpromptlength = cntxt->promptlength;

	if (p != NULL) 
		printInstruction(out, mb, p, listing);
	if (cntxt == mal_clients) {
		cntxt->prompt = "mdb>";
		cntxt->promptlength = 4;
	}
	oldin = cntxt->fdin;
	cntxt->fdin = getConsole(cntxt);
	cntxt->fdin->pos += cntxt->yycur;
	cntxt->yycur = 0;
	cntxt->fdin->buf[cntxt->fdin->pos] = 0;
	do {
		if (cntxt->phase[READER]) {
			if ((*cntxt->phase[READER]) (cntxt)) {
				break;
			}
		} else if (readConsole(cntxt) <= 0) {
			break;
		}
		b = CURRENT(cntxt);

		/* terminate the line with zero */
		c = strchr(b, '\n');
		if (c) {
			*c = 0;
			cntxt->fdin->pos += (c - b) + 1;
		} else {
			cntxt->fdin->pos = cntxt->fdin->len;
		}

		skipBlanc(cntxt, b);
		switch (*b) {
		case 0:
			m = 0;
			break;
		case 'a':
			if (strncmp("atoms", b, 5) == 0)
				showAtoms(out);
			break;
		case 'C':
			/* catch the next exception */
			stk->cmd = 'C';
			break;
		case 'c':
			if (strncmp("call", b, 4) == 0) {
				GDKerror("call instruction not yet implemented\n");
				break;
			}
			stk->cmd = 'c';
			skipWord(cntxt, b);
			m = 0;
			break;
		case 'h':
			mdbHelp(out);
			break;
		case 'e':
		{
			/* terminate the execution for ordinary functions only */
			if (strncmp("exit", b, 4) == 0) {
		case 'x':
				if (!(getInstrPtr(mb, 0)->token == FACcall)) {
					stk->cmd = 'x';
					cntxt->fdin = oldin;
					cntxt->prompt = oldprompt;
					cntxt->promptlength = oldpromptlength;
				}
			}
			return;
		}
		case 'q':
		{
			MalStkPtr su;

			/* return from this debugger */
			for (su = stk; su; su = su->up)
				su->cmd = 0;
			cntxt->itrace = 0;
			cntxt->timer = 0;
			/* MDBstatus(0); */
			cntxt->fdin = oldin;
			cntxt->prompt = oldprompt;
			cntxt->promptlength = oldpromptlength;
			return;
		}
		case 'f':	/* finish */
		case 'n':	/* next */
		case 's':	/* step */
			if (strncmp("scenarios", b, 3) == 0) {
				showAllScenarios(out);
			} else if (strncmp("scenario", b, 3) == 0) {
				showScenarioByName(out, cntxt->scenario);
			} else if (strncmp("scope", b, 3) == 0) {
				showModuleStatistics(out, cntxt->nspace);
				break;
			}
			stk->cmd = *b;
			m = 0;
			break;
		case 'm':	/* display a module */
		{
			str modname, fcnname;
			Module fsym;
			Symbol fs;
			int i;

			if (strncmp("modules", b, 7) == 0) {
				showModules(out, cntxt->nspace);
				continue;
			}

			skipWord(cntxt, b);
			if (*b) {
				modname = b;
				fcnname = strchr(b, '.');
				if (fcnname) {
					*fcnname = 0;
					fcnname++;
				}
				fsym = findModule(cntxt->nspace, putName(modname, strlen(modname)));

				if (fsym == cntxt->nspace && strcmp(modname,"user") ) {
					stream_printf(out, "module '%s' not found\n", modname);
					continue;
				}
				for (i = 0; i < MAXSCOPE; i++) {
					fs = fsym->subscope[i];
					while (fs != NULL) {
						if (fcnname == NULL)
							printSignature(out, fs, 0);
						else if (strcmp(fcnname, getFcnName(fs->def)) == 0)
							printSignature(out, fs, 0);
						fs = fs->peer;
					}
				}
				continue;
			}
		}
			break;
		case 't':	/* trace breakpoint */
			if (strncmp("trace", b, 5) == 0) {
				skipWord(cntxt, b);
				skipBlanc(cntxt, b);
				if (strchr(b, '\n'))
					*strchr(b, '\n') = 0;
				traceFcnName = GDKstrdup(b);
			} else if (strncmp("timer", b, 5) == 0) {
				if (cntxt->timer == 0)
					cntxt->timer = GDKusec();
				else
					cntxt->timer = 0;
				stk->cmd = 0;
			}
			break;
		case 'v':{	/* show the symbol table and bindings */
			str modname, fcnname;
			Module fsym;
			Symbol fs;
			int i;

			skipWord(cntxt, b);
			if (*b != 0) {
				modname = b;
				fcnname = strchr(b, '.');
				if (fcnname == NULL) {
					fsym = findModule(cntxt->nspace, putName(modname, strlen(modname)));
					if (fsym == 0) {
						stream_printf(out, "%s module not found\n", modname);
						continue;
					}
					for (i = 0; i < MAXSCOPE; i++) {
						fs = fsym->subscope[i];
						while (fs != NULL) {
							printStack(out, fs->def, 0);
							fs = fs->peer;
						}
					}
					continue;
				}
				*fcnname = 0;
				fcnname++;
				fsym = findModule(cntxt->nspace, putName(modname, strlen(modname)));
				if (fsym == 0) {
					stream_printf(out, "%s module not found\n", modname);
					continue;
				}
				/* display the overloaded symbol definition */
				for (i = 0; i < MAXSCOPE; i++) {
					fs = fsym->subscope[i];
					while (fs != NULL) {
						if (strcmp(fs->name, fcnname) == 0)
							printStack(out, fs->def, 0);
						fs = fs->peer;
					}
				}
			} else
				printStack(out, mb, stk);
			break;
		}
		case 'b':
			if (strcmp(b, "bbp") == 0) {
				int i;

				for (i = 1; i < BBPsize; i++)
					if (BBP_logical(i) && BBP_cache(i)) {
						stream_printf(out, "[%d] %s lref = %d ref= %d ", i, BBP_logical(i), BBP_lrefs(i), BBP_refs(i));
						stream_printf(out, " dirty=%d \n", BATdirty(BBP_cache(i)));
					}
				continue;
			}
			if (strcmp(b, "breakpoints") == 0) {
				mdbShowBreakpoints(cntxt);
				continue;
			}
			if (strncmp(b, "break", 5) == 0)
				b += 4;
			if (isspace((int) b[1])) {
				skipWord(cntxt, b);
				if (*b && !isspace((int) *b))
					/* set breakpoints by name */
					mdbSetBreakpointName(cntxt, mb, b, 's');
				else
					mdbSetBreakpoint(cntxt, mb, p, getArgName(mb, p, 0), 's');
				continue;
			}
			continue;
		case 'd':
			if (strncmp(b, "down", 2) == 0 && stk->down != NULL) {
				stream_printf(out, "%sgo down the stack\n", "#mdb ");
				stk = stk->down;
				mb = stk->blk;
				break;
			}
			skipWord(cntxt, b);
			/* get rid of break point */
			if (*b && !isspace((int) *b)) {
				mdbClrBreakpointName(cntxt, b);
			} else {
				mdbClrBreakpoint(cntxt, p);
			}
			continue;
		case 'i':
		{
			int i;
			char *t;

			if (strncmp("io", b, 2) == 0) {
				if (cntxt->timer == 0)
					cntxt->timer = GDKusec();
#ifdef HAVE_SYS_RESOURCE_H
				getrusage(RUSAGE_SELF, &cntxt->resource);
				stream_printf(out, "#maxrss %d ixrss=%d idrss=%d isrss=%d" " minflt=%d majflt=%d nswap=%d inblock=%d oublock=%d\n", cntxt->resource.ru_maxrss, cntxt->resource.ru_ixrss, cntxt->resource.ru_idrss, cntxt->resource.ru_isrss,
					      cntxt->resource.ru_minflt, cntxt->resource.ru_majflt, cntxt->resource.ru_nswap, cntxt->resource.ru_inblock, cntxt->resource.ru_oublock);
#endif
				continue;
			}
			skipWord(cntxt, b);
			t = b;
			skipNonBlanc(cntxt, t);
			*t = 0;
			/* search the symbol */
			i = findVariable(mb, b);
			if (i < 0) {
				stream_printf(out, "%s Symbol not found\n", "#mdb ");
			} else {
				printBatInfo(out, getVar(mb, i), stk->stk + i);
			}
			continue;
		}
		case 'p':
		{
			size_t size = 0, first = 0;
			int i;
			char *t;

			skipWord(cntxt, b);
			t = b;
			skipNonBlanc(cntxt, t);
			*t = 0;
			/* you can identify a start and length */
			t++;
			skipBlanc(cntxt, t);
			if (isdigit((int) *t)) {
				size = atol(t);
				skipWord(cntxt, t);
				if (isdigit((int) *t))
					first = atol(t);
			}
			/* search the symbol */
			i = findVariable(mb, b);
			if (i < 0) {
				i = BBPindex(b);
				if (i != 0)
					printBATelm(out, i, size, first);
				else
					stream_printf(out, "%s Symbol not found\n", "#mdb ");
				continue;
			}
			printStackElm(out, mb, getVar(mb, i), stk->stk + i, i, size, first);
			continue;
		}
		case 'S':
			dumpNamespaceStatistics(out, 1);
			break;
		case 'u':
			if (stk->up == NULL)
				break;
			stream_printf(out, "%s go up the stack\n", "#mdb ");
			stk = stk->up;
			mb = stk->blk;
			printCall(cntxt, mb, stk, pc);
			continue;
		case 'w':
		{
			MalStkPtr w;
			MalBlkPtr mw = mb;
			int pci = pc;	/*  how to find enclosing pc */

			for (w = stk; w != NULL; w = w->up) {
				mw = w->blk;
				stream_printf(out, "#mdb ");
				printCall(cntxt, mw, w, pci);
				if (w->up)
					pci = w->up->pcup;
			}
			continue;
		}
@-
While debugging it should be possible to inspect the symbol
table using the 'module.function' name. The default is to list all
signatures satisfying the pattern.
@c
		case 'L':
		case 'l':	/* list the current code block */
		{
			str modname, fcnname;
			Module fsym;
			Symbol fs;
			int i, lstng;

			lstng = /* listing | */ (*b == 'L' ? LIST_MAL_ALL : LIST_MAL_INSTR);
			skipWord(cntxt, b);
			if (*b != 0) {
				modname = b;
				fcnname = strchr(b, '.');
				if (fcnname == NULL) {
					fsym = findModule(cntxt->nspace, putName(modname, strlen(modname)));
					if (fsym == 0) {
						stream_printf(out, "%s module not found\n", modname);
						continue;
					}
					for (i = 0; i < MAXSCOPE; i++) {
						fs = fsym->subscope[i];
						while (fs != NULL) {
							printFunction(out, fs->def, lstng);
							fs = fs->peer;
						}
					}
					continue;
				}
				*fcnname = 0;
				fcnname++;
				fsym = findModule(cntxt->nspace, putName(modname, strlen(modname)));
				if (fsym == 0) {
					stream_printf(out, "%s module not found\n", modname);
					continue;
				}
				/* display the overloaded symbol definition */
				if (displayModule(out, fsym, fcnname, lstng) == 0) {
					stream_printf(out, "%sSymbol '%s.%s' not found\n", "#mdb ", modname, fcnname);
				}
			} else {
				printFunction(out, mb, lstng);
			}
			continue;
		}
		case 'o':
		case 'O':	/* optimizer steps */
		{
			int flg = *b == 'o' ? LIST_MAL_INSTR : LIST_MAL_ALL;
			int idx;

			skipWord(cntxt, b);
			if (*b) {
				idx = atoi(b);
				showOptimizerStep(idx, flg);
			} else
				showOptimizerHistory();
			break;
		}
		case 'r':	/* reset program counter */
			stream_printf(out, "%s restart with current stack\n", "#mdb ");
			stk->cmd = 'r';
			break;
		default:
			stream_printf(out, "%s debugger command expected\n", "#mdb ");
			mdbHelp(out);
		}
	} while (m);
	cntxt->fdin = oldin;
	cntxt->prompt = oldprompt;
	cntxt->promptlength = oldpromptlength;
}

static int mdbSessionActive;
int mdbSession(){
	return mdbSessionActive;
}
void
mdbStep(Client cntxt, MalBlkPtr mb, MalStkPtr stk, int pc)
{
	InstrPtr p;

	mdbSessionActive= 1; /* for name completion */
	switch (stk->cmd) {
	case 'c':
		p = getInstrPtr(mb, pc);
		if (isBreakpoint(cntxt, p))
			mdbCommand(cntxt, mb, stk, p, pc);
		break;
	case 's':
	case 'n':
		p = getInstrPtr(mb, pc);
		mdbCommand(cntxt, mb, stk, p, pc);
		break;
	case 'C':
		mdbSessionActive= 0; /* for name completion */
	}
	if( mb->errors) {
		MalStkPtr su;

		/* return from this debugger */
		for (su = stk; su; su = su->up)
			su->cmd = 0;
		stk->cmd = 'x';	/* will force a graceful termination */
	}
	if( mdbSessionActive== 0) return;
	showErrors();
	if (cntxt->timer)
		cntxt->timer = GDKusec();
	stream_flush(cntxt->fdout);
	mdbSessionActive= 0; /* for name completion */
}

@-
It would come in handy if at any time you could activate
the debugger on a specific function. This calls for the
creation of a minimal execution environment first.
@c
str
runMALDebugger(Symbol s)
{
	Client c = getClient();

	c->itrace = 'n';
	runMAL(c, s->def, 1, 0, 0, 0);
	return MAL_SUCCEED;
}

@+ Utilities
Dumping a stack on a file is primarilly used for debugging.
Printing the stack requires access to both the symbol table and
the stackframes in most cases.
Beware that a stack frame need not be initialized with null values.
It has been zeroed upon creation.

The routine  can also be used to inspect the symbol table of
arbitrary functions.
@c
void
printStack(stream *f, MalBlkPtr mb, MalStkPtr s)
{
	int i = 0;

	if (s) {
		stream_printf(f, "#Stack '%s' size=%d top=%d\n",
				getInstrPtr(mb, 0)->fcnname, s->stksize, s->stktop);
		for (; i < mb->vtop; i++)
			printStackElm(f, mb, getVar(mb, i), s->stk + i, i, 0, 0);
	} else
		for (; i < mb->vtop; i++)
			printStackElm(f, mb, getVar(mb, i), 0, i, 0, 0);
}

void
printBATelm(stream *f, int i, size_t cnt, size_t first)
{
	BAT *b, *bs;
	str tpe /*,nme */ ;

	b = BATdescriptor(i);
	if (b) {
		/* nme= BATgetId(b); */
		tpe = getTypeName(newBatType(b->htype, b->ttype));
		/* ignore ref count of this call */
		stream_printf(f, "type=%s count=%d lrefs=%d refs=%d \n", tpe, 
				BATcount(b), BBP_lrefs(ABS(b->batCacheid)), 
				BBP_refs(ABS(b->batCacheid)) - 1);
		if (cnt < BATcount(b)) {
			stream_printf(f, "Sample %d out of %d\n", cnt, BATcount(b));
		}
		/* cut out a portion of the BAT for display */
		bs = BATslice(b, first, first + cnt);

		if (bs == NULL)
			stream_printf(f, "Failed to take chunk\n");
		else
			BATmultiprintf(f, 2, &bs, TRUE, 0, TRUE);
		BBPunfix(bs->batCacheid);

		BBPunfix(b->batCacheid);
		GDKfree(tpe);
	}
}

void
printStackElm(stream *f, MalBlkPtr mb, VarPtr n, ValPtr v, int index, size_t cnt, int first)
{
	str nme, nmeOnStk;
	char nmebuf[PATHLENGTH];

	(void) mb;		/* fool the compiler */
	if (n->tmpindex) {
		snprintf(nmebuf, PATHLENGTH, "%c%d", TMPMARKER, n->tmpindex);
		nme = nmebuf;
	} else
		nme = n->name;
	stream_printf(f, "#[%d] %s\t= ", index, nme);
	if (n->type == TYPE_void)
		stream_printf(f, "nil");
	else if (v)
		ATOMprint(v->vtype, VALptr(v), f);
	else if (n->literal)
		stream_printf(f, "%s", n->literal);

	nme = getTypeName(n->type);
	stream_printf(f, ":%s", nme);
	nmeOnStk = v ? getTypeName(v->vtype) : GDKstrdup(nme);
	if (strcmp(nmeOnStk, nme)) {
		if (isaBatType(n->type)) {
			BAT *b;

			b = BATdescriptor(v->val.ival);
			if (b) {
				nmeOnStk = getTypeName(newBatType(b->htype, b->ttype));
				if (strcmp(nme, nmeOnStk))
					stream_printf(f, " != :%s", nmeOnStk);
				BBPunfix(b->batCacheid);
			}
		} else if (!(isaBatType(n->type) && strcmp(nmeOnStk, "BAT") == 0))
			stream_printf(f, " != %s", nmeOnStk);
	}
	stream_printf(f, " %s", (n->isaconstant ? " constant" : ""));
	stream_printf(f, " %s", (n->isatypevar ? " type variable" : ""));
	GDKfree(nme);
	GDKfree(nmeOnStk);

	if (!n->isused)
		stream_printf(f, " unused");
	if (cnt && isaBatType(n->type) && v && v->val.ival) {
		BAT *b, *bs;

		b = BATdescriptor(v->val.ival);
		if (b == NULL) {
			stream_printf(f, "Could not access descriptor\n");
			return;
		}
		stream_printf(f, "\n");
		if (cnt <= BATcount(b)) {
			stream_printf(f, "Sample %d out of %d\n", cnt, BATcount(b));
		}
		/* cut out a portion of the BAT for display */
		bs = BATslice(b, first, first + cnt);

		if (bs == NULL)
			stream_printf(f, "Failed to take chunk\n");
		else
			BATmultiprintf(f, 2, &bs, TRUE, 0, TRUE);
		BBPunfix(bs->batCacheid);

		BBPunfix(b->batCacheid);
	} else if (isaBatType(n->type) && v) {
		BAT *b;

		b = BATdescriptor(v->val.ival);
		if (b) {
			/* ignore ref count of this call */
			stream_printf(f, " count=%d lrefs=%d refs=%d", 
				BATcount(b), BBP_lrefs(ABS(b->batCacheid)), 
				BBP_refs(ABS(b->batCacheid)) - 1);
			BBPunfix(b->batCacheid);
		}
	} else if (cnt && isaColType(n->type) && v && v->val.ival) {
		stream_printf(f, "Operation not yet implemented for :col types\n");
	}
	stream_printf(f, "\n");
}

void
printBatInfo(stream *f, VarPtr n, ValPtr v)
{
	if (isaBatType(n->type) && v->val.ival) {
		int bid;
		int ret;
		MALfcn fcn;

		fcn = getAddress("bat","BKCinfo", 0);
		if (fcn) {
			BAT *b;

			bid = v->val.ival;
			stream_printf(f, "Show info for %d\n", bid);
			(*fcn) (&ret, &bid);
			stream_printf(f, "got the info bat from %d\n", bid);
			b = BATdescriptor(ret);
			if (b == NULL) {
				stream_printf(f, "Could not access descriptor\n");
				return;
			}
			BATmultiprintf(f, 2, &b, TRUE, 0, TRUE);
			BBPunfix(b->batCacheid);
		}
	}
}

@-
The memory positions for the BATs is useful information to
asses for memory fragmentation.
@= heapinfo
hp= b->@1;
if(hp && hp->base){
    stream_printf(GDKout,"\t@1=%d size=%d\n",hp->base, hp->size);}
@= hashinfo
h= b->@1;
if(h && h->mask){
        stream_printf(GDKout,"\t@1=%d size=%d\n",h, sizeof(*h));
        stream_printf(GDKout,"\t@1link=%d size=%d\n",h->link,
                (h->mask+h->lim+1)*sizeof(int));
}
@-
The memProfileVector routine produces a character string to represent
the usage of memory by BAT information. The characters are interpreted
as follows:
.=unused, X=completely used, [0-9]=small elements within the granule
More then 9 elements makes it full.
@= setVector
    start= (((long)@1)-min)/granule;
    lim= (((long)@1)-min + @2)/granule;
    stream_printf(GDKout,"start %d lim %d\n",start,lim);

@c
str
memProfileVector(int cells)
{
	str v = GDKmalloc(cells + 1);
	int i;
#ifdef HAVE_SBRK
	long max = (long) sbrk(0);
	long min = 0;
	long granule = 0;
#endif

	if (cells <= 0) {
		GDKerror("memProfileVector:positive argument expected\n");
		return GDKstrdup("");
	}
	v = GDKmalloc(cells + 1);
	if (v == 0)
		GDKfatal("memProfileVector:malloc failure\n");

	for (i = 0; i < cells; i++)
		v[i] = '.';
	v[i] = 0;

	for (i = 1; i < BBPsize; i++)
		if (BBP_status(i) & BBPLOADED) {
			BAT *b = BATdescriptor(i);
			Heap *hp;
			Hash *h;
#ifdef HAVE_SBRK
			long start, lim;
#endif

			stream_printf(GDKout, "\tdesc=%d size=%d\n", b, sizeof(*b));
			hp = b->batBuns;
			stream_printf(GDKout, "\tbuns=%d size=%d\n", hp->base, hp->size);
#ifdef HAVE_SBRK
			if (min == 0) {
				min = (long) b;
				max = min + GDKmem_heapsize();
				granule = (max - min) / cells;
				stream_printf(GDKout, "granule %dK\n", granule / 1024);
			}
			@:setVector(b, sizeof(*b))@
			@:setVector(hp->base, hp->size)@
#endif

			@:heapinfo(hheap)@
			@:heapinfo(theap)@
			@:hashinfo(hhash)@
			@:hashinfo(thash)@
			BBPunfix(b->batCacheid);
		}
	return v;
}

void
printBBPinfo(stream *out)
{
	str v;

	stream_printf(out, "#BBP memory layout\n");
	stream_printf(out, "#heap maximum =%d/M\n", GDKmem_heapsize() / (1024 * 1024));
	v = memProfileVector(32);
	stream_printf(out, "#%s\n", v);
	GDKfree(v);
#ifdef GDK_VM_KEEPHISTO
	stream_printf(out, "#BBP VM history available\n");
#else
	stream_printf(out, "#BBP VM history not available\n");
#endif
}

@-
Some utilities for the debugger
@c
void
mdbHelp(stream *f)
{
	stream_printf(f, "next       -- Advance to next statement\n");
	stream_printf(f, "continue   -- Continue program being debugged\n");
	stream_printf(f, "break      -- set breakpoint on current instruction\n");
	stream_printf(f, "break <var>    -- break on assignment to <var>\n");
	stream_printf(f, "delete <var>   -- remove break point <var>\n");
	stream_printf(f, "step       -- advance to next MAL instruction\n");
	stream_printf(f, "modules    -- show module list\n");
	stream_printf(f, "module     -- display a module signatures\n");
	stream_printf(f, "atoms      -- show atom list\n");
	stream_printf(f, "finish     -- finish current call\n");
	stream_printf(f, "exit       -- terminate executionr\n");
	stream_printf(f, "quit       -- turn off debugging\n");
	stream_printf(f, "list <fcn> -- list current program block\n");
	stream_printf(f, "List <fcn> -- list with type information\n");
	stream_printf(f, "var  <fcn>  -- print symbol table for module\n");
	stream_printf(f, "optimizer <idx>  -- display program after optimizer step\n");
	stream_printf(f, "print <var>    -- display value of a variable\n");
	stream_printf(f, "print <var> <cnt>[<first>] -- display BAT chunk\n");
	stream_printf(f, "info <var>     -- display bat variable properties\n");
	stream_printf(f, "run        -- restart current procedure\n");
	stream_printf(f, "where      -- print stack trace\n");
	stream_printf(f, "down       -- go down the stack\n");
	stream_printf(f, "up         -- go up the stack\n");
	stream_printf(f, "timer      -- produce micro-second response time\n");
	stream_printf(f, "io         -- produce page activity trace \n");
	stream_printf(f, "help       -- this message\n");
}

@+ Optimizer debugging
The modular approach to optimize a MAL program brings with it the
need to check individual steps. Two options come to mind. If in
debug mode we could stop after each optimizer action for inspection.
Alternatively, we keep a history of all MAL program versions for
aposteriori analysis.

The latter is implemented first.
@{
A global stack is used for simplity, later we may have to
make it thread safe by assigning it to a client record.
@c
int isInvariant(MalBlkPtr mb, int pcf, int pcl, int varid);

str
debugOptimizers(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	Client cntxt = getClient();

	(void) stk;

	cntxt->debugOptimizer = cntxt->debugOptimizer ? FALSE : TRUE;
	if (pci)
		removeInstruction(mb, pci);
	return MAL_SUCCEED;
}

#define MAXSTEPS 128
struct {
	str title;
	int actions;
	lng usec;
	MalBlkPtr mb;
} optimizerHistory[MAXSTEPS];
static int optTop;

void
optimizerDebug(MalBlkPtr mb, str name, int actions, lng usec)
{
	Client c = getClient();

	if (!c->itrace)
		return;
	if (optTop + 1 == MAXSTEPS)
		return;
	optimizerHistory[optTop].title = GDKstrdup(name);
	optimizerHistory[optTop].actions = actions;
	optimizerHistory[optTop].usec = usec;
	optimizerHistory[optTop].mb = copyMalBlk(mb);
	optTop++;
}

void
resetOptimizerDebugger()
{
	int i;

	if (optTop) {
		/* garbage collect */
		for (i = 0; i < optTop; i++) {
			freeMalBlk(optimizerHistory[i].mb);
			GDKfree(optimizerHistory[i].title);
		}
	}
	optTop = 0;
}

void
showOptimizerStep(int i, int flg)
{
	if (i < optTop) {
		stream_printf(GDKout, "%s\n", optimizerHistory[i].title);
		printFunction(GDKout, optimizerHistory[i].mb, flg);
	}
}
void
showOptimizerHistory()
{
	int i;
	stream *fd = GDKout;

	for (i = 0; i < optTop; i++)
		stream_printf(fd, "[%d] %s \tactions=%2d time " LLFMT " usec\n", i, optimizerHistory[i].title, optimizerHistory[i].actions, optimizerHistory[i].usec);
}

@}
