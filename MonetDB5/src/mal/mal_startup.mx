@t MAL startup
@a M. Kersten
@v 0.0
@+ Serving Clients

For the time being we distinguish two classes of clients.
The primary client is the 'Admin', which runs directly
against the server. 
It works as a console and will be the recipient of major error messages.

Secondary lients gain access to the Monet server through a internet connection.
Access through the internet requires a Monet client program at the
source, but ordinary telnet connections can be applied when the internet
port number of the database server is publicised.

Each user has a separate scope, but the secondary clients have shared
access to the definitions available to the administrator.
The global scope and private scopes are separated by an a priori known
scope name "MAL_scope". 

@h
/*
 * The contents of this file are subject to the Monet Public
 * License Version 1.1 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy of
 * the License at http://www.monetsolutions.com/Download/Licensing/MonetPL-1.1.
html
 * 
 * Software distributed under the License is distributed on an "AS
 * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 * 
 * The Original Code is the Monet Database System.
 * 
 * The Initial Developer of the Original Code is CWI.
 * Portions created by CWI are Copyright (C) 1997-2001 CWI.  
 * All Rights Reserved.
 * 
 * Contributor(s): Martin Kersten <Martin.Kersten@cwi.nl>
 */
#ifndef _MAL_STARTUP_H
#define _MAL_STARTUP_H

#include "mal_client.h"

#define SRVINIT "startup.mal"
#define SRVORIGIN "share/Monet/startup.mal"

mal_export int malStartupAdmin(int listing);
mal_export void serveClient(void *dummy);
mal_export void resetClientPrg(Client cntxt);
mal_export void closeClientPrg(Client cntxt, int flag);
#endif /*  _MAL_STARTUP_H*/
@-
The startup script for databases recides in the administrator's
directory of each database. Upon need, its location can be overruled 
using the configuration scripts.
If initialization of the server is successful, then the MAL_scope symbol
position is being returned as the namespace entry point for the client.
@c
#include "mal_startup.h"

void startupPrelude(Client c, str fnme1, str fnme2)
{	char buf[PATHLENGTH];
	FILE *fd;
	int i;

	snprintf(buf,PATHLENGTH,"%s/",GDKdirStr);
	i= strlen(buf);
	snprintf(buf+i,PATHLENGTH-i,"%s",fnme1);
	SLASH_2_DIR_SEP(buf);
	if( (fd= fopen(buf,"r")) == NULL){
		snprintf(buf,PATHLENGTH,"%s/",GDKdistrStr);
		i= strlen(buf);
		snprintf(buf+i,PATHLENGTH-i,"%s",fnme2);
		SLASH_2_DIR_SEP(buf);
		if( (fd= fopen(buf,"r")) == NULL){
			GDKerror("FATAL:server file '%s' missing\n",fnme2);
			return;
		}
	} 
	fclose(fd);
	malImport(c,buf,0);
}

int malStartupAdmin(int listing){
	Client c;
	c= initClient(GDKstrdup("Admin"),NULL,0);
	c->nspace= newScope(NULL, GDKstrdup("Admin"));
	initLibraries();
	startupPrelude(c,SRVINIT,SRVORIGIN);
	mal_scope = c->nspace->outer;
	showErrors(c);
	/* showScopeTrail(stdout,c->nspace);*/
	return 1;
}
@+ Client main routine
Every client has a 'main' function to collect the statements.
Once the END instruction has been found, it is added to the
symbol table and a fresh container is being constructed.
Note, this scheme makes testing for recursive function calls a
little more difficult. Therefore, type checking should be performed
afterwards.

In interactive mode,  the closing statement is never reached.
The 'main' procedure is typically cleaned between successive external
messages except for its variables, which are considerd global.
@c

void resetClientPrg(Client cntxt){
        InstrPtr p;
        MalBlkPtr mb;

        cntxt->curprg = newFunction(GDKstrdup("main"));
        mb = cntxt->curprg->def;
        p = getSignature(cntxt->curprg);
        p->modname= GDKstrdup(cntxt->nspace->name);
        setVarType(mb,findVariable(mb,"main"), TYPE_int);
}
void closeClientPrg(Client cntxt, int flag){
        InstrPtr p;
        MalBlkPtr mb;
	int i;

	mb = cntxt->curprg->def;
	i = mb->stop-1;
	/* ignore empty MAL function blocks */
	p = getInstrPtr(mb,0);
	if( !(i==0 && p->token == FUNCTIONsymbol)){
		insertSymbol(cntxt->nspace,cntxt->curprg);
	} else{
		if(!flag ) /* comming from parseCommandPattern */
		{
			freeMalBlk(mb);
		} else {
		printf("freeing unused block %d \n",i);
			freeMalBlk(mb);
		}
		/* garbage collect prg ? no just empty file*/
		return;
	}
	if( flag){
		p = getInstrPtr(mb,i);
		if( p->token != ENDDEFsymbol)
			pushEndInstruction(mb);
	}
	trimMalBlk(mb);
	chkProgram(cntxt->nspace, cntxt->curprg->def);
	showErrors(cntxt);
	if( cntxt->backup){
		cntxt->curprg = cntxt->backup;
		cntxt->backup = 0;
	} else resetClientPrg(cntxt);
}

