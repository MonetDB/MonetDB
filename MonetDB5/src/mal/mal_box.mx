@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@a M.L. Kersten
@* Boxed variables
Clients sessions often come with a global scope of variable settings.
Access to these global variables should be easy,
but they should also provide protection against concurrent update
when the client wishes to perform parallel processing.
Likewise, databases, query languages, etc. may define constants and variables
accessible, e.g. relational schemas, to a selected user group.

The approach taken is to rely on persistent object spaces
as pioniered in Lynda and -later- JavaSpaces.
They are called boxes in MonetDB and act as managed containers 
for persistent variables.

Before a client program  can interact with a box, it
should open it, passing qualifying authorization
information and parameters to instruct the box-manager
of the intended use. A built-in box is implicitly
opened when you request for its service.

At the end of a session, the box should be closed. Some box-managers
may implement a lease-scheme to automatically close interaction
with a client when the lease runs out. Likewise, the box can
be notified when the last reference to a leased object
ceases to exist.

A box can be extended with a new object using the function
deposit(name) with name a local variable.
The default implementation silently accepts any new definition of the box.
If the variable was known already in the box, its value is overwritten.

A local copy of an object can be obtained using the
pattern 'take(name,[param])', where name denotes the variable
of interest. The type of the receiving variable should
match the one known for the object. Whether an actual 
copy is produced or a reference to a shared object
is returned is defined by the box manager.

The object is given back to the box manager calling 'release(name)'.
It may update the content of the repository accordingly, release locks,
and move the value to persistent store. Whatever the semantics
of the box requires. [The default implementation is a no-op]

Finally, the object manager can be requested to 'discard(name)'
a variable completely.  The default implementation is to reclaim
the space in the box.

Concurrency control, replication services, as well as access
to remote stores may be delegated to a box manager.
Depending on the intended semantics, the box manager
may keep track of the clients holding links to this members, 
provide a traditional 2-phase
locking scheme, optimistic control, or check-out/check-in scheme.
In all cases, these management issues are transparant to the
main thread (=client) of control, which operates on a temporary
snapshot. For the time being we realize the managers as critical
code sections, i.e. one client is permitted access to the box space
at a time.

Example: consider the client function:
@example
function myfcn():void;
    b:bat[:oid,:int] := bbp.take("mytable");
    c:bat[:int,:str] := sql.take("person","age");
    d:= intersect(b,c);
    io.print(d);
    u:str:= client.take(user);
    io.print(u);
    client.release(user);
end function;
@end example

The function binds to a copy from the local persistent BAT space,
much like bat-names are resolved in earlier versions. The second
statement uses an implementation of take that searches a variable
of interest using two string properties. It illustrates that
a box manager is free to extend/overload the predefined scheme, 
which is geared towards storing MAL variables.

The result bat 'c' is temporary and disappears upon garbage
collection. The variable 'u' is looked up as the string object user.

Note that BATs b and c need be released at some point. In general
this point in time does not coincide with a computational boundary
like a function return. During a session, several bats may be taken
out of the box, being processed, and only at the end of a session 
being released. In this example, it means that the reference to
b and c is lost at the end of the function (due to garbarge collection)
and that subsequent use requires another take() call.
The box manager bbp is notified of the implicit release and
can take garbage collection actions.

The box may be inspected at several times during a scenario run.
The first time is when the MAL program is type-checked for the
box operations. Typechecking a take() function is tricky.
If the argument is a string literal, the box can be queried
directly for the objects' type.
If found, its type is matched against the lhs variable. 
This strategy fails in the situation when at
runtime the object is subsequently replaced by another 
typed-instance in the box. We assume this not to happen and
the exceptions it raises a valuable advice to reconsider
the programming style.

The type indicator for the destination variable should be
provided to proceed with proper type checking. 
It can resolve overloaded function selection. 

Inspection of the Box can be encoded using an iterator at the MAL
layer and relying on the functionality of the box.
However, to improve introspection, we assume that all box 
implementations provide a few rudimentary functions, called objects(arglist)
and dir(arglist). The function objects() produces a BAT with
the object names, possibly limited to those identified by
the arglist.

@+ Future
The world of boxes has not been explored deeply yet.
It is envisioned that it could play a role to import/export
different objects, e.g.
introduce xml.take() which converts an XML document to a BAT,
jpeg.take() similer for an image.

Nesting boxes (like Russian dolls) is possible. It provides a simple
containment scheme between boxes, but in general will interfere with
the semantics of each box. 

Each box has [should] have an access control list, which names
the users having permission to read/write its content.
The first one to create the box becomes the owner. He may grant/revoke
access to the box to users on a selective basis.

@- Session box
Aside from box associated with the modules, a session box is created
dynamically on behalf of each client. Such boxes are considered private
and require access by the user name (and password). 
At the end of a session they are closed, which means that they are
saved in persistent store until the next session starts.
For example:
@example
function m():void;
    box.open("client_name");
    box.deposit("client_name","pi",3.417:flt);
    f:flt := box.take("client_name","pi");
    io.print(t);
    box.close("client_name");
end function;
@end example
@-
In the namespace it is placed subordinate to any space introduced by the
system administrator. It will contain global client data, e.g.
user, language, database, port, and any other session parameter.
The boxes are all collected in the context of the database directory,
i.e. the directory <dbfarm>/box

@- Garbage collection
The key objects managed by MonetDB are the persistent BATs, which
call for an efficient scheme to make them accessible for manipulation
in the MAL procedures taking into account a possibly hostile
parallel access.

Most kernel routines produce BATs as a result, which will be referenced 
from the runtime stack. They should be garbage collected as soon as
deemed possible to free-up space. By default, temporary results are
garbage collected before returning from a MAL function.

@- Polymorphic globals
The top level interaction keeps a 'box' with global variables,
i.e. each MAL statement is interpreted in an already initialized
stack frame.
This causes the following problems: 1) how to get rid of global variables
and 2) how to deal with variables that can take 'any' type.
It is illustrated as follows:
@example
f:= mil.take("GT");
io.print(f);
@end example
When executed in the context of a function, the answer will be
simple [ 1 ]. The variable type need not be defined, because
the print operation can handle any type using the concrete
type associated with f on the stack.

However, when executed interactively, statement by statement,
the answer printed will be [ 0 ]. The reason is that both
statements are converted into a function and executed independently.
Between function calls the variables are reset, i.e. temporary
variables are removed and others are re-initialized. [check]

@{
@h
#ifndef _MAL_BOX_H
#define _MAL_BOX_H
#include "mal_stack.h"
#include "mal_instruction.h"

/*#define DEBUG_MAL_BOX */

typedef struct BOX {
	MT_Lock lock;		/* provide exclusive access */
	str name;
	MalBlkPtr sym;
	MalStkPtr val;
} *Box, BoxRecord;

mal_export Box newBox(str name);
mal_export Box findBox(str name);
mal_export Box openBox(str name);
mal_export int closeBox(str name, int flag);
mal_export void destroyBox(str name);
mal_export str boxFileName(Box box, str extension);
mal_export int saveBox(Box box, int flag);
mal_export void loadBox(str nme);
mal_export int releaseAllBox(Box box);

mal_export int depositBox(Box box, str name, ValPtr val);
mal_export void insertToBox(Box box, str name, str val);
mal_export int takeBox(Box box, str name, ValPtr val, int tpe);
mal_export int bindBAT(Box box, str name, str location);
mal_export int releaseBox(Box box, str name);
mal_export int discardBox(Box box, str name);
mal_export str getBoxName(Box box, lng i);
mal_export str getBoxNames(int *bid);
mal_export str toString(Box box, lng i);
mal_export int nextBoxElement(Box box, lng *cursor, ValPtr v);

mal_export stream *prepareSaveBox(Box box, str *boxfile, str *boxfilebak);
mal_export void printSomeBox(stream *fd, int k);
mal_export void printBox(stream *fd, Box obj);
mal_export void freeBoxes();
#endif /* _MAL_BOX_H */
@-
The hierarchy of object spaces ends at the root of the tree.
This is a dummy element and should contain system-wide objects
only.
@= newBOX
    obj= (Box) GDKmalloc(sizeof(BoxRecord));
    memset((char*) obj, 0, sizeof(BoxRecord));
    obj->name= GDKstrdup(name);
    obj->sym=  newMalBlk(MAXVARS,MAXSTMTS);
    obj->val = newGlobalStack(MAXVARS);
    if( GDKprotected)
        obj->lock= MT_create_lock();
@-
@c
#include "mal_box.h"
#include "mal_interpreter.h"	/* for garbageCollector() & garbageElement() */
#include "mal_client.h"		/* for getClient() */
#include "mal_debugger.h"	/* for printStack() */
#include "mal_import.h"		/* for malInclude() */

#define MAXSPACES 64		/* >MAXCLIENTS+ max modules !! */
Box box[MAXSPACES];

Box
newBox(str name)
{
	Box obj = 0;
	int i;

	mal_set_lock(mal_contextLock, "newBox");
#ifdef DEBUG_MAL_BOX
	stream_printf(GDKout, "create new box '%s'\n", name);
#endif
	for (i = 0; i < MAXSPACES; i++)
		if (box[i] != NULL && idcmp(name, box[i]->name) == 0) {
			mal_unset_lock(mal_contextLock, "newBox");
			GDKwarning("newBox:duplicate box definition\n");
			return box[i];
		}
	for (i = 0; i < MAXSPACES; i++)
		if (box[i] == NULL) {
			@:newBOX@
			box[i] = obj;
			break;
		}
	mal_unset_lock(mal_contextLock, "newBox");
	if (i == MAXSPACES)
		GDKerror("too many boxes\n");
#ifdef DEBUG_MAL_BOX
	stream_printf(GDKout, "succeeded at %d\n", i);
#endif
	return obj;

}

void
freeBoxes()
{
	int i;

	for (i = 0; i < MAXSPACES; i++)
		if (box[i]) {
			garbageCollectAll(box[i]->sym, box[i]->val);
			GDKfree(box[i]->name);
			freeMalBlk(box[i]->sym);
			GDKfree(box[i]->val);
			GDKfree(box[i]);
			box[i] = 0;
		}
}

Box
findBox(str name)
{
	int i;

	mal_set_lock(mal_contextLock, "findBox");

	for (i = 0; i < MAXSPACES; i++)
		if (box[i] != NULL && idcmp(name, box[i]->name) == 0) {
#ifdef DEBUG_MAL_BOX
			stream_printf(GDKout, "found the box '%s' %d\n", name, i);
#endif
			mal_unset_lock(mal_contextLock, "findBox");
			return box[i];
		}
	mal_unset_lock(mal_contextLock, "findBox");
#ifdef DEBUG_MAL_BOX
	stream_printf(GDKout, "could not find the box '%s' \n", name);
#endif
	return 0;

}

Box
openBox(str name)
{
	Box box = findBox(name);

	if (box)
		return box;
	box = newBox(name);
	loadBox(name);
	return box;
}

int
closeBox(str name, int flag)
{
	Box box;

	(void) flag;		/* fool the compiler */
	if ((box = findBox(name))) {
		saveBox(box, flag);
		return 0;
	}
	return -1;
}

void
destroyBox(str name)
{
	int i, j;
	str boxfile;

	mal_set_lock(mal_contextLock, "destroyBox");
	for (i = j = 0; i < MAXSPACES; i++) {
		if (idcmp(box[j]->name, name) == 0) {
			free(box[i]->name);
			freeMalBlk(box[i]->sym);
			freeStack(box[i]->val);
			boxfile = boxFileName(box[i], 0);
			unlink(boxfile);
			GDKfree(boxfile);
		} else
			box[i] = box[j++];
	}
	mal_unset_lock(mal_contextLock, "destroyBox");

}

@+ Operations
The deposit operation silently accepts any request to store
an element.
@c
int
depositBox(Box box, str name, ValPtr val)
{
	int i;
	ValPtr v;

	i = findVariable(box->sym, name);
	if (i < 0) {
		i = newVariable(box->sym, GDKstrdup(name), val->vtype);
		chkStack(box->val, i);
	}
	v = &box->val->stk[i];
	box->val->stktop++;
	VALcopy(v, val);
#ifdef DEBUG_MAL_BOX
	stream_printf(GDKout, "depositBox: entered '%s' at %d type %d\n", name, i, v->vtype);
#endif
	return 0;
}

void
insertToBox(Box box, str nme, str val)
{
	ValRecord vr;

	vr.vtype = TYPE_str;
	vr.val.pval = val;
	depositBox(box, nme, &vr);
}

@-
Taking an element from a box is only permitted if the type of
the receiver matches the type of the source.
@c
int
takeBox(Box box, str name, ValPtr val, int tpe)
{
	int i;
	ValPtr v;

	i = findVariable(box->sym, name);
#ifdef DEBUG_MAL_BOX
	stream_printf(GDKout, "takeBox: found '%s' at %d\n", name, i);
#endif
	if (i < 0)
		return i;
	v = &box->val->stk[i];
	if (val->vtype != v->vtype && v->vtype != TYPE_any && tpe != TYPE_any) {
#ifdef DEBUG_MAL_BOX
		stream_printf(GDKout, "takeBox:type error %d,%d\n", val->vtype, box->val->stk[i].vtype);
#endif
		return -1;
	}
	VALcopy(val, &box->val->stk[i]);
	if (val->vtype == TYPE_bat)
		BBPincref(val->val.br.id, TRUE);

#ifdef DEBUG_MAL_BOX
	stream_printf(GDKout, "takeBox:'%s' from '%s'\n", name, box->name);
#endif
	return 0;
}

@-
The function bindBAT relates a logical BAT name with a physical
representation. The bind commands are typically found in the boxes,
which provide users a partial view over the BAT storage area.
That is, all bats bound can be taken out of the box upon need.
A variable can be rebound to another BAT at any time.
@c
int
bindBAT(Box box, str name, str location)
{
	int i;
	ValPtr v;

	i = findVariable(box->sym, name);
	if (i < 0)
		i = newVariable(box->sym, GDKstrdup(name), TYPE_any);
	v = &box->val->stk[i];
	v->val.br.id = BBPindex(location);

	if (v->val.br.id == 0)
		return -1;
	v->vtype = TYPE_bat;
#ifdef DEBUG_MAL_BOX
	stream_printf(GDKout, "bindBox:'%s' to '%s' [%d] in '%s'\n", name, location, v->val.br.id, box->name);
#endif
	return 0;
}

int
releaseBox(Box box, str name)
{
	int i;

#ifdef DEBUG_MAL_BOX
	stream_printf(GDKout, "releaseBox:%s from %s\n", name, box->name);
#endif
	i = findVariable(box->sym, name);
	if (i < 0)
		return i;
	return 0;
}

int
releaseAllBox(Box box)
{
#ifdef DEBUG_MAL_BOX
	stream_printf(GDKout, "releaseAllBox:%s \n", box->name);
#else
	(void) box;
#endif
	return 0;
}

int
discardBox(Box box, str name)
{
	int i, j;

#ifdef DEBUG_MAL_BOX
	stream_printf(GDKout, "discardBox:%s from %s\n", name, box->name);
#endif
	i = findVariable(box->sym, name);
	if (i < 0)
		return i;
	garbageElement(&box->val->stk[i]);
	for (j = i; j < box->sym->vtop - 2; j++) {
		box->sym->var[j] = box->sym->var[j + 1];

		VALcopy(&box->val->stk[j], &box->val->stk[j + 1]);
	}
	box->sym->vtop--;
	box->val->stktop--;
	return 0;
}

@+
The elements can be obtained using iterator, which returns the name
of the next element in the box.
@c
int
nextBoxElement(Box box, lng *cursor, ValPtr v)
{
	if (*cursor >= box->sym->vtop) {
		*cursor = -1;
		return 0;
	}
	garbageElement(v);
	v->vtype = TYPE_str;
	v->val.pval = getBoxName(box, *cursor);
	*cursor = *cursor + 1;
	return 0;
}

str
getBoxName(Box box, lng i)
{
	str s;

	s = getVarName(box->sym, (int) i);
	return GDKstrdup(s);
}

str
toString(Box box, lng i)
{
	(void) box;
	(void) i;		/* fool the compiler */
	return GDKstrdup("");
}

str
getBoxNames(int *bid)
{
	BAT *b;
	int i;

	b = BATnew(TYPE_int, TYPE_str, (size_t) MAXSPACES);
	for (i = 0; i < MAXSPACES; i++)
		if (box[i] != NULL) {
			BUNins(b, &i, box[i]->name);
		}
	BBPincref(*bid = b->batCacheid, TRUE);
	BBPunfix(*bid);
	return MAL_SUCCEED;
}

@+ Persistency
The content of a box is saved on a file for subsequent re-use.
The storage is explicitly in terms of MAL operations.
For BAT objects, the corresponding object is made persistent.
Note that the user can not control these operations directly.
The box container is created if it did not yet exist.
@c
str
boxFileName(Box box, str backup)
{
	char boxfile[PATHLENGTH];
	int i = 0;
	stream *f;

	snprintf(boxfile, PATHLENGTH, "%s/%s/box", GDKgetenv("gdk_dbfarm"), GDKgetenv("gdk_dbname"));
	if( (f= open_wstream(boxfile)) )
		stream_close(f);
	else {
		mkdir(boxfile,0755);
		if( (f= open_wstream(boxfile)) )
			stream_close(f);
		else {
            GDKerror("boxFileName:can not create box directory\n");
            return NULL;
		}
	}
	i = strlen(boxfile);
	if (backup) {
		snprintf(boxfile + i, PATHLENGTH - i, "/%s/", backup);
		if( (f= open_wstream(boxfile)) )
			stream_close(f);
		else {
			mkdir(boxfile,0755);
			if( (f= open_wstream(boxfile)) )
				stream_close(f);
			else {
				GDKerror("boxFileName:can not create box directory\n");
				return NULL;
			}
		}
		i = strlen(boxfile);
	}
	snprintf(boxfile + i, PATHLENGTH - i, "/%s.box", box->name);
	return GDKstrdup(boxfile);
}

stream *
prepareSaveBox(Box box, str *boxfile, str *boxfilebak)
{
	stream *f;

	*boxfile = boxFileName(box, 0);
	*boxfilebak = boxFileName(box, "backup");

	if (*boxfile == 0) {
		GDKerror("saveBox:can not determine box file\n");
		return 0;
	}
	if (rename(*boxfile, *boxfilebak)) {
#ifdef DEBUG_MAL_BOX
		stream_printf(GDKout, "saveBox:can not rename %s\n", boxfile);
#endif
		GDKerror("saveBox:can not rename backup\n");
		GDKfree(*boxfile);
		GDKfree(*boxfilebak);
		return 0;
		}

	f = open_wastream(*boxfile);
#ifndef S_IRUSR
#define S_IRUSR 0400
#define S_IWUSR 0200
#endif
	if (f != NULL)
		chmod(*boxfile, (S_IRUSR | S_IWUSR));
	else
		GDKerror("saveBox:can not create box file\n");
	GDKfree(*boxfile);
	GDKfree(*boxfilebak);
	return f;
}

int
saveBox(Box box, int flag)
{
	int i;
	stream *f;
	ValPtr v;
	str boxfile, boxfilebak;

	(void) flag;

	f = prepareSaveBox(box, &boxfile, &boxfilebak);
	if (f == NULL)
		return 1;
#ifdef DEBUG_MAL_BOX
	stream_printf(GDKout, "saveBox:created %s\n", boxfile);
#endif
	for (i = 0; i < box->sym->vtop; i++) {
		v = &box->val->stk[i];
		if (v->vtype == TYPE_bat) {
			BAT *b = (BAT *) BBPgetdesc(v->val.br.id);

			if (b && b->batPersistence & PERSISTENT)
				stream_printf(f, "%s.bind(\"%s\",\"%s\");\n", box->name, getVarName(box->sym, i), BBPname(v->val.br.id));
		} else {
			stream_printf(f, "%s := ", getVarName(box->sym, i));
			ATOMprint(v->vtype, VALptr(v), f);
			stream_printf(f, ":%s;\n", getTypeName(v->vtype));
			stream_printf(f, "%s.deposit(\"%s\",%s);\n", box->name, getVarName(box->sym, i), getVarName(box->sym, i));
		}
	}
	stream_close(f);
	if (rename(boxfilebak, boxfile)) {
		GDKfree(boxfile);
		GDKfree(boxfilebak);
		return -1;
	}
	GDKfree(boxfile);
	GDKfree(boxfilebak);
	return 0;
}

@-
Loading a box is equivalent to reading a script.
@c
#ifndef R_OK
#define R_OK 4
#endif

void
loadBox(str name)
{
	char boxfile[PATHLENGTH];
	int i = 0;

	snprintf(boxfile, PATHLENGTH, "%s/%s/box/", GDKgetenv("gdk_dbfarm"), GDKgetenv("gdk_dbname"));
	i = strlen(boxfile);
	snprintf(boxfile + i, PATHLENGTH - i, "%s.box", name);
#ifdef DEBUG_MAL_BOX
	stream_printf(GDKout, "loadBox:start loading the file %s\n", boxfile);
#endif
	if (access(boxfile, R_OK) == 0) {
		malInclude(getClient(), boxfile, 0, 0);
#ifdef DEBUG_MAL_BOX
		stream_printf(GDKout, "loadBox:loaded the file %s\n", boxfile);
#endif
	}
}

@+ Utilities
Utilities for the debugger permit dumping of all the object
spaces.
@c
void
printBox(stream *fd, Box obj)
{
	printStack(fd, obj->sym, obj->val);
}

void
printSomeBox(stream *fd, int k)
{
	if (box[k] == 0) {
		GDKerror("printSomeBox:illegal space id\n");
	} else
		printBox(fd, box[k]);
}

@}
