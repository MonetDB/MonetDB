@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@a M.L.Kersten
@+ Atomary types 
MonetDB supports an extensible type system to accomodate a wide
spectrum of database kernels and application needs.
The type administration keeps track of their properties and
provides access to the underlying implementations.

MAL recognizes the definition of a new
atom type by replacing the @code{module} keyword with @code{atom}.
Atoms definitions require special care, because their definition and 
properties should be communicated with the GDK kernel library.
The commands defined in an @code{atom } block are screened as of interest 
to the gdk_atom library. 

MonetDB comes with the hardwired types @code{bit,chr,sht,int,lng,oid,flt,
dbl,str} and @code{bat}, the representation of a bat identifier.
The kernel code has been optimized to deal with these types efficiently,
i.e. without unnecessary function call overheads.

A small collection of user-defined @code{atom} types is shipped with the sysem.
They implement types considered essential for end-user applications,
such as @code{color, date, time, blob}, and @code{url}.
They are implemented using the type extension mechanism described below.
As such, they provide examples for future extensions.
A concrete example is the 'blob' datatype in the MonetDB atom module
library(see ../modules/atoms/blob.mx)

@- Defining your own types
For the courageous at heart, you may enter the difficult world
of extending the kernel library. The easiest way is to derive
the atom modules from one shipped in the source distributie.
More involved atomary types require a study of the
documentation associated with the atom structures (gdk_atoms),
because you have to develop a handful routines complying with the
signatures required in the GDK library.
They are registered upon loading the @code{atom} module.
@{
@-
The atom registration functions perform the necessary
type checks, but relies on the user to comply with this signature in
its C-implementation. The ruler calls are part of a module
initialization routine.
@-
Functions passed to the GDK kernel are not directly accessible
as MAL routines, because their implementation requires a
GDK-specific signature. (See GDK documentation)
They are renamed to an non-parseable function, effectively shielding
them from the MAL programmer.
@-
This feature is of particular interest to system experts. 
It is not meant for end-users trying to intruduce record- or 
struct-like objects in the database. They better decompose
the complex object structure and represent the components in
different BATs.
@h
#ifndef _MAL_ATOM_H
#define _MAL_ATOM_H

/* #define MAL_ATOM_DEBUG  */

#include "mal_instruction.h"
mal_export void malAtomDefinition(str name,int tpe);
mal_export int malAtomProperty(MalBlkPtr mb, InstrPtr pci);
mal_export int malAtomArray(int tpe, int idx);
mal_export int malAtomFixed(int size, int align, char *name);
mal_export void showAtoms(stream *fd);  /* used in src/mal/mal_debugger.c */

#endif /*  _MAL_ATOM_H*/
@+
Every MAL command introduced in an atom module should be checked
to detect overloading of a predefined function.
Subsequently, we update the BAT atom structure.
The function signatures should be parameter-less, which
enables additional functions with the same name to appear
as ordinary mal operators.

@-
A few fields are set only once, at creation time.
They should be implemented with parameter-less functions.
@= setItem
if( idcmp(@1,name) || pci->argc != 1)
    return 0;
else{
#ifdef MAL_ATOM_DEBUG
    stream_printf(GDKout,"set the atom property %s.%s\n",
        moduleName(pci),functionName(pci));
#endif
    BATatoms[tpe].@2= (@4) (*pci->fcn)();
    setAtomName(pci);
    return 1;
}
@-

@= setItemInt
if( idcmp(@1,name) || pci->argc != 1)
    return 0;
#ifdef MAL_ATOM_DEBUG
    stream_printf(GDKout,"set the atom property %s.%s\n",
        moduleName(pci),functionName(pci));
#endif
    BATatoms[tpe].@2= (*pci->fcn)();
    setAtomName(pci);
    return 1;
@c
#include "mal_atom.h"
#include "mal_namespace.h"

#ifndef MAXPATHLEN
#define MAXPATHLEN 1024
#endif

void setAtomName(InstrPtr pci){
    char buf[MAXPATHLEN];
    snprintf(buf,MAXPATHLEN,"#%s", functionName(pci));
    setFunctionId(pci, putName(buf,strlen(buf)));
#ifdef MAL_ATOM_DEBUG
    stream_printf(GDKout,"replaced the function %s.%s\n",
        moduleName(pci),functionName(pci));
#endif
}

int malAtomProperty(MalBlkPtr mb, InstrPtr pci){
    str name= functionName(pci);
    int tpe = getTypeIndex(moduleName(pci), strlen(moduleName(pci)), TYPE_any);
    (void) mb; /* fool compilers */
#ifdef MAL_ATOM_DEBUG
    stream_printf(GDKout,"Atomproperty %s.%s\n",
        moduleName(pci),functionName(pci));
#endif
    if( pci->fcn == 0)
        GDKwarning("malAtomProperty:function not bound\n");
    if( tpe<0 || tpe>= GDKatomcnt)
        GDKfatal("malAtomProperty:illegal type name:%s",name);
    switch(name[0]){
    case 'd': 
        if( idcmp("del",name)==0 && pci->argc==1){
            BATatoms[tpe].atomDel= (void (*)(Heap *, var_t *)) pci->fcn;
            setAtomName(pci);
            return 1;
        }
        break;
    case 'c': 
        if( idcmp("cmp",name)==0 && pci->argc==1){
            BATatoms[tpe].atomCmp= (int (*)(ptr, ptr)) pci->fcn;
            setAtomName(pci);
            return 1;
        } 
        if( idcmp("convert",name)==0 && pci->argc==1){
            BATatoms[tpe].atomConvert= (void (*)(ptr, int)) pci->fcn;
            setAtomName(pci);
            return 1;
        } 
        break;
    case 'f': 
        if( idcmp("fromstr",name)==0 && pci->argc==1){
            BATatoms[tpe].atomFromStr= (int (*)(str, int *, ptr *)) pci->fcn;
            setAtomName(pci);
            return 1;
        } 
        if( idcmp("fix",name)==0 && pci->argc==1){
            BATatoms[tpe].atomFix= (int (*)(ptr)) pci->fcn;
            setAtomName(pci);
            return 1;
        } 
        break;
    case 'h':
        if( idcmp("heap",name)==0 && pci->argc==1){
            BATatoms[tpe].atomHeap= (void (*)(Heap *, size_t)) pci->fcn;
            setAtomName(pci);
            return 1;
        } 
        if( idcmp("heapconvert",name)==0 && pci->argc==1){
            BATatoms[tpe].atomHeapConvert= (void (*)(Heap *, int)) pci->fcn;
            setAtomName(pci);
            return 1;
        } 
        if( idcmp("hash",name)==0 && pci->argc==1){
            BATatoms[tpe].atomHash= (hash_t (*)(ptr)) pci->fcn;
            setAtomName(pci);
            return 1;
        } 
        if( idcmp("heapcheck",name)==0 && pci->argc==1){
            BATatoms[tpe].atomHeapCheck= (int (*)(Heap *, HeapRepair *)) pci->fcn;
            setAtomName(pci);
            return 1;
        } 
        break;
    case 'l': 
        if( idcmp("length",name)==0 && pci->argc==1){
            BATatoms[tpe].atomLen= (int (*)(ptr)) pci->fcn;
            setAtomName(pci);
            return 1;
        } 
        break;
    case 'n':
/* 64 bit issue
          @:setItem("null",atomNull,TYPE_ptr,lng)@ 
*/
        if( idcmp("nequal",name)==0 && pci->argc==1){
            BATatoms[tpe].atomCmp= (int (*)(ptr, ptr)) pci->fcn;
            setAtomName(pci);
            return 1;
        }
        break; 
    case 'p': 
        if( idcmp("put",name)==0 && pci->argc==1){
            BATatoms[tpe].atomPut= (var_t (*)(Heap *, var_t *, ptr)) pci->fcn;
            setAtomName(pci);
            return 1;
        } 
        break;
    case 's': 
          @:setItem("storage",storage,TYPE_int,long); break;
    case 't': 
        if( idcmp("tostr",name)==0 && pci->argc==1){
            BATatoms[tpe].atomToStr= (int (*)(str *, int *, ptr)) pci->fcn;
            setAtomName(pci);
            return 1;
        } 
        break;
    case 'u': 
        if( idcmp("unfix",name)==0 && pci->argc==1){
            BATatoms[tpe].atomUnfix= (int (*)(ptr)) pci->fcn;
            setAtomName(pci);
            return 1;
        } 
        break;
    case 'v': @:setItem("varsized",varsized,TYPE_int,long)@ 
    }
    return 0;
}
@-
Atoms are constructed incrementally in the kernel using the
ATOMproperty function. It takes an existing type as a base
to derive a new one.
The most tedisous work is to check the signature types of the functions
acceptable for the kernel.
@c

void malAtomDefinition(str name, int tpe){
    int i;

    if(strlen(name) >= IDLENGTH){
        GDKerror("Atom name '%s' too long\n", name);
        return;
    }
    if( ATOMindex(name)>=0){
        GDKerror("Redefinition of atom '%s'\n", name);
        return;
    }
    if( tpe<0 || tpe >=GDKatomcnt){
        GDKerror("Undefined atom inheritance '%s'\n", name);
        return;
    }
#ifdef MAL_ATOM_DEBUG
    stream_printf(GDKout,"introduce a new atom type '%s'  %d\n",name,tpe);
#endif
    
    ATOMproperty(name,"",  (int (*)()) 0);
    i= ATOMindex(name);
    memcpy((char*)(BATatoms+i),
        (char*)(BATatoms+tpe), sizeof(BATatoms[tpe]));
    strncpy(BATatoms[i].name, name, IDLENGTH);
    BATatoms[i].storage= BATatoms[tpe].storage;
}
@-
User defined modules may introduce fixed sized types
to store information in BATs.
@c
int malAtomFixed(int size, int align, char *name)
{
    int i = 0;

    ATOMproperty(name,"",  (int (*)()) 0);
    i= ATOMindex(name);
    memcpy((char*)(BATatoms+i),
        (char*)(BATatoms+TYPE_chr), sizeof(BATatoms[TYPE_chr]));
    strncpy(BATatoms[i].name, name, IDLENGTH);
    BATatoms[i].storage= i;
    BATatoms[i].size = size;
    BATatoms[i].align = align;
    BATatoms[i].linear = FALSE;
    return i;
}
int malAtomArray(int tpe, int size){
    int i;
    char name[IDLENGTH];
    str nme;

    nme = getTypeName(tpe);
    stream_printf(GDKout,"enter a new array type definition %s %d\n", nme,size);
    snprintf(name,IDLENGTH,"%s_", nme);
    i= strlen(name);
    snprintf(name+i,IDLENGTH-i,"%d", size);
    GDKfree(nme);
    if(strlen(name) >= IDLENGTH){
        GDKerror("Atom name '%s' too long\n", name);
        return -1;  /* ERROR! */
    }
#ifdef MAL_ATOM_DEBUG
    stream_printf(GDKout,"new type name %s\n",name);
#endif
    ATOMproperty(name,"",  (int (*)()) 0);
    i= ATOMindex(name);
    memcpy((char*)(BATatoms+i),
        (char*)(BATatoms+tpe), sizeof(BATatoms[tpe]));
    strncpy(BATatoms[i].name, name, IDLENGTH);
    BATatoms[i].storage= tpe;
    BATatoms[i].size *= size;
    BATatoms[i].linear = FALSE;
#ifdef MAL_ATOM_DEBUG
    stream_printf(GDKout,"new type %d\n",i);
#endif
    return i;
}

void showAtoms(stream *fd){
    int i;
    for(i=0;BATatoms[i].name[0] && i<TYPE_any; i++){
        stream_printf(fd,"%s", BATatoms[i].name);
        if( BATatoms[i+1].name[0]) stream_printf(fd,",");
    }
    stream_printf(fd,"\n");
}
@}
