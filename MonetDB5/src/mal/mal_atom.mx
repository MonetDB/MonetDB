@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.
@a M.L.Kersten
@* Atomary types 
@T
Monet supports an extensible type system to accomodate a wide
spectrum of database kernels and application needs.
The type administration keeps track of their properties and
provides access to the underlying implementations.

The Monet Assembler Language recognizes the definition of a new
atom type by replacing the {\sc module} keyword with {\sc atom module}.
Atoms definitions require special care, because their definition and 
properties should be communicated with the GDK kernel library.
The commands defined in an {\sc atom module} block are screened as of interest 
to the gdk\_atom library. 

@+ Predefined types
The Monet kernel back-ends (GDK,x100) come with a set of built-in types.
The GDK atom structure is used to administer all types known.
A small collection of user-defined types are shipped with the sysem.
They implement types considered essential for end-user applications,
such as date, time, blob, and url.
They are implemented using the type extension mechanism described below.
As such, they provide examples for future extensions.
A concrete example is the 'blob' datatype in the Monet 5 atom module
library(see ../modules/atoms/blob.mx)

@+ User defined types
For the courageous at heart, you may enter the difficult world
of extending the kernel library. This calls for studying the
documentation associated with the atom structures (gdk_atoms),
because you have to develop routines complying with the
signatures required in the GDK library.
@-
The registration functions perform the necessary
type checks, but relies on the user to comply with this signature in
its C-implementation. The ruler calls are part of a module
initialization routine.
@-
Functions passed to the GDK kernel are not directly accessible
as MAL routines, because their implementation requires a
GDK-specific signature. (See GDK documentation)
They are renamed to an non-parseable function, effectively shielding
them from the MAL programmer.
@-
This feature is of particular interest to system experts. 
It is not meant for end-users trying to intruduce record- or 
struct-like objects in the database. They better decompose
the complex object structure and represent the components in
different BATs.
@+ Enumerated types
A common class of types are the enumerated types, i.e. a type
domain is enumerated (dynamically).
See for more information ../modules/mal/enum.mx
@{
@h
#ifndef _MAL_ATOM_H
#define _MAL_ATOM_H

/* #define MAL_ATOM_DEBUG  */

#include "mal_instruction.h"
mal_export void malAtomDefinition(str name,int tpe);
mal_export int malAtomProperty(MalBlkPtr mb, InstrPtr pci);
mal_export int malAtomPropertyInt(MalBlkPtr mb, InstrPtr pci);
mal_export int malAtomArray(int tpe, int idx);
mal_export int malAtomFixed(int size, int align, char *name);
mal_export void showAtoms(stream *fd);	/* used in src/mal/mal_debugger.c */

#endif /*  _MAL_ATOM_H*/
@+
Every MAL command introduced in an atom module should be checked
to detect overloading of a predefined function.
Subsequently, we update the BAT atom structure.
The function signatures should be parameter-less, which
enables additional functions with the same name to appear
as ordinary mal operators.

@= chkItem
if( idcmp(@1,name)==0 && pci->argc==1){
	BATatoms[tpe].@2= (@3 (*)()) pci->fcn;
	setAtomName(pci);
	return 1;
} 
@-
A few fields are set only once, at creation time.
They should be implemented with parameter-less functions.
@= setItem
if( idcmp(@1,name) || pci->argc != 1)
	return 0;
else{
#ifdef MAL_ATOM_DEBUG
	stream_printf(GDKout,"set the atom property %s.%s\n",
		moduleName(pci),functionName(pci));
#endif
	BATatoms[tpe].@2= (@4) (*pci->fcn)();
	setAtomName(pci);
	return 1;
}
@-

@= setItemInt
if( idcmp(@1,name) || pci->argc != 1)
	return 0;
else{
#ifdef MAL_ATOM_DEBUG
	stream_printf(GDKout,"set the atom property %s.%s\n",
		moduleName(pci),functionName(pci));
#endif
	BATatoms[tpe].@2= (@4) (*pci->fcn)();
	setAtomName(pci);
	return 1;
}
@c
#include "mal_atom.h"
void setAtomName(InstrPtr pci){
	char buf[MAXPATHLEN];
	snprintf(buf,MAXPATHLEN,"#%s", functionName(pci));
	GDKfree(pci->fcnname);
	setFunctionId(pci, GDKstrdup(buf));
#ifdef MAL_ATOM_DEBUG
	stream_printf(GDKout,"replaced the function %s.%s\n",
		moduleName(pci),functionName(pci));
#endif
}

int malAtomProperty(MalBlkPtr mb, InstrPtr pci){
	str name= functionName(pci);
	int tpe = getTypeIndex(moduleName(pci), strlen(moduleName(pci)));
	(void) mb; /* fool compilers */
#ifdef MAL_ATOM_DEBUG
	stream_printf(GDKout,"Atomproperty %s.%s\n",
		moduleName(pci),functionName(pci));
#endif
	if( pci->fcn == 0)
		GDKwarning("malAtomProperty:function not bound\n");
	if( tpe<0 || tpe>= GDKatomcnt)
		GDKfatal("malAtomProperty:illegal type name");
	switch(name[0]){
	case 'a': GDKwarning("illegal atom property"); break;
	case 'd': 
		if( idcmp("del",name)==0 && pci->argc==1){
			BATatoms[tpe].atomDel= (void (*)()) pci->fcn;
			setAtomName(pci);
			return 1;
		}
		break;
	case 'c': 
		if( idcmp("cmp",name)==0 && pci->argc==1){
			BATatoms[tpe].atomCmp= (int (*)()) pci->fcn;
			setAtomName(pci);
			return 1;
		} 
		if( idcmp("convert",name)==0 && pci->argc==1){
			BATatoms[tpe].atomConvert= (void (*)()) pci->fcn;
			setAtomName(pci);
			return 1;
		} 
		break;
	case 'f': 
		if( idcmp("fromstr",name)==0 && pci->argc==1){
			BATatoms[tpe].atomFromStr= (int (*)()) pci->fcn;
			setAtomName(pci);
			return 1;
		} 
		if( idcmp("fix",name)==0 && pci->argc==1){
			BATatoms[tpe].atomFix= (int (*)()) pci->fcn;
			setAtomName(pci);
			return 1;
		} 
		break;
	case 'h':
		if( idcmp("heap",name)==0 && pci->argc==1){
			BATatoms[tpe].atomHeap= (void (*)()) pci->fcn;
			setAtomName(pci);
			return 1;
		} 
		if( idcmp("heapconvert",name)==0 && pci->argc==1){
			BATatoms[tpe].atomHeapConvert= (void (*)()) pci->fcn;
			setAtomName(pci);
			return 1;
		} 
		if( idcmp("hash",name)==0 && pci->argc==1){
			BATatoms[tpe].atomHash= (hash_t (*)()) pci->fcn;
			setAtomName(pci);
			return 1;
		} 
		if( idcmp("heapcheck",name)==0 && pci->argc==1){
			BATatoms[tpe].atomHeapCheck= (int (*)()) pci->fcn;
			setAtomName(pci);
			return 1;
		} 
		break;
	case 'l': 
		if( idcmp("length",name)==0 && pci->argc==1){
			BATatoms[tpe].atomLen= (int (*)()) pci->fcn;
			setAtomName(pci);
			return 1;
		} 
		break;
	case 'n':
/* 64 bit issue
		  @:setItem("null",atomNull,TYPE_ptr,lng)@ 
*/
		if( idcmp("nequal",name)==0 && pci->argc==1){
			BATatoms[tpe].atomCmp= (int (*)()) pci->fcn;
			setAtomName(pci);
			return 1;
		}
		break; 
	case 'p': 
		if( idcmp("put",name)==0 && pci->argc==1){
			BATatoms[tpe].atomPut= (var_t (*)()) pci->fcn;
			setAtomName(pci);
			return 1;
		} 
		break;
	case 's': 
		  @:setItem("storage",storage,TYPE_int,long); break;
	case 't': 
		if( idcmp("tostr",name)==0 && pci->argc==1){
			BATatoms[tpe].atomToStr= (int (*)()) pci->fcn;
			setAtomName(pci);
			return 1;
		} 
		break;
	case 'u': 
		if( idcmp("unfix",name)==0 && pci->argc==1){
			BATatoms[tpe].atomUnfix= (int (*)()) pci->fcn;
			setAtomName(pci);
			return 1;
		} 
		break;
	case 'v': @:setItem("varsized",varsized,TYPE_int,long)@ 
	}
	return 0;
}
int malAtomPropertyInt(MalBlkPtr mb, InstrPtr pci){
	str name= functionName(pci);
	int tpe = getTypeIndex(moduleName(pci),strlen(moduleName(pci)));
	(void) mb; /* fool compiler */
	if( tpe<0 || tpe>= GDKatomcnt)
		GDKfatal("malAtomProperty:illegal type name");
	if( pci->fcn == 0)
		GDKwarning("malAtomProperty:function not bound\n");
	switch(name[0]){
	case 'a': @:setItemInt("align",align,TYPE_sht,long)@ break;
	case 'l': @:setItemInt("linear",linear,TYPE_sht,long)@ break;
	case 's': @:setItemInt("size",size,TYPE_sht,long)@ break;
	}
	return 0;
}
@-
Atoms are constructed incrementally in the kernel using the
ATOMproperty function. It takes an existing type as a base
to derive a new one.
The most tedisous work is to check the signature types of the functions
acceptable for the kernel.
@c

void malAtomDefinition(str name, int tpe){
	int i;

	if(strlen(name) >= IDLENGTH){
		GDKerror("Atom name '%s' too long\n", name);
		return;
	}
	if( ATOMindex(name)>=0){
		GDKerror("Redefinition of atom '%s'\n", name);
		return;
	}
	if( tpe<0 || tpe >=GDKatomcnt){
		GDKerror("Undefined atom inheritance '%s'\n", name);
		return;
	}
#ifdef MAL_ATOM_DEBUG
	stream_printf(GDKout,"introduce a new atom type '%s'  %d\n",name,tpe);
#endif
	
	ATOMproperty(name,"",  (int (*)()) 0);
	i= ATOMindex(name);
	memcpy((char*)(BATatoms+i),
		(char*)(BATatoms+tpe), sizeof(BATatoms[tpe]));
	strncpy(BATatoms[i].name, name, IDLENGTH);
	BATatoms[i].storage= BATatoms[tpe].storage;
}
@-
User defined modules may introduce fixed sized types
to store information in BATs.
@c
int malAtomFixed(int size, int align, char *name)
{
	int i = 0;

	ATOMproperty(name,"",  (int (*)()) 0);
	i= ATOMindex(name);
	memcpy((char*)(BATatoms+i),
		(char*)(BATatoms+TYPE_chr), sizeof(BATatoms[TYPE_chr]));
	strncpy(BATatoms[i].name, name, IDLENGTH);
	BATatoms[i].storage= i;
	BATatoms[i].size = size;
	BATatoms[i].align = align;
	BATatoms[i].linear = FALSE;
	return i;
}
int malAtomArray(int tpe, int size){
	int i;
	char name[IDLENGTH];
	str nme;

	nme = getTypeName(tpe);
	stream_printf(GDKout,"enter a new array type definition %s %d\n", nme,size);
	snprintf(name,IDLENGTH,"%s_", nme);
	i= strlen(name);
	snprintf(name+i,IDLENGTH-i,"%d", size);
	GDKfree(nme);
	if(strlen(name) >= IDLENGTH){
		GDKerror("Atom name '%s' too long\n", name);
		return -1;	/* ERROR! */
	}
#ifdef MAL_ATOM_DEBUG
	stream_printf(GDKout,"new type name %s\n",name);
#endif
	ATOMproperty(name,"",  (int (*)()) 0);
	i= ATOMindex(name);
	memcpy((char*)(BATatoms+i),
		(char*)(BATatoms+tpe), sizeof(BATatoms[tpe]));
	strncpy(BATatoms[i].name, name, IDLENGTH);
	BATatoms[i].storage= tpe;
	BATatoms[i].size *= size;
	BATatoms[i].linear = FALSE;
#ifdef MAL_ATOM_DEBUG
	stream_printf(GDKout,"new type %d\n",i);
#endif
	return i;
}

void showAtoms(stream *fd){
	int i;
	for(i=0;BATatoms[i].name[0] && i<TYPE_any; i++){
		stream_printf(fd,"%s", BATatoms[i].name);
		if( BATatoms[i+1].name[0]) stream_printf(fd,",");
	}
	stream_printf(fd,"\n");
}
@}
