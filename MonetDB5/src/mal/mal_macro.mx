@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f mal_macro
@a M. L. Kersten
@+ MAL macro processors
Two MAL optimizers are based on MAL macro expansion and contraction.
The former involves replacing individual instructions by a block of
MAL code.
The latter depicts the inverse operation, a group of instructions
is replaced by a single MAL assignment statement.

The macros structures considered are type-correct MAL functions only,
which means that replacement is not essential from a semantic
point of view. They could have been called, or the block need
not be compressed.

The optimizers form the basis for replacing code fragments.
In particular, it provides a handle to implement peep-hole
based optimization. 
The prototypical test case is the following template:
@example
function joinPath( a:bat[:any$1,:any$2],
                b:bat[:any$2,:any$3],
                c:bat[:any$3,:any4]):bat[:any$1,:any$4];
    z:= join(a,b);
    zz:= join(z,c);
    return zz;
end joinPath;
@end example

The MEoptimizer will hunt for occurrences of the instruction
joinPath() and replaces it with the body, i.e. it in-lines the code.
Conversely,  the MCoptimizer attempts to localize a block
of two join operations and,
when found, it is replaced by the call to joinPath.

The current implementation is limited to finding a consecutive
sequence, ending in a return-statement. The latter is needed to
properly embed the result in the enclosed environment.
It may be extended in the future to consider the flow of control as well.

After both operations the flow of control structure has to be
checked and fort contraction we also have to resolve the new
code, e.g. to bind the new instruction with an implementation.
(Or become part of a macro expansion)

The implementation is based on matching MAL instructions.
The operation malMatch takes two MAL instructions and returns true
if they are equivalent. This means they address the same function,
but also that their variables are isomorphic.
The generalization of malMatch is malFcnMatch, which checks
equivalence of a function body as an occurrence in another one.

The optimizers work on a specific symbol, module or act on all
known symbols.

@- Known issues. 
The functions subject to expansion or contraction should be
checked on 'proper' behavior.

The current implementation is extremely limited. 
The MCoptimizer does not recognize use of intermediate results 
outside the block being contracted. This should be checked and
it should block the replacement, unless the intermediates are part of
the return list.
Likewise, we assume here that the block has a single return
statement, which is also the last one to be executed.

The MCoptimizer can only expand functions. Factories already
carry a significant complex flow of control that is hard
to simulate in the nested flow structure of an arbitrary function.

The MEoptimizer can not deal with calls controlled by a barrier.
It would often require a rewrite of several other statements as well.

@{
@+ Implementation section
@h
#ifndef _MAL_MACRO_H_
#define _MAL_MACRO_H_

/* #define DEBUG_MAL_MACRO*/

#include "mal.h"
#include "mal_client.h"

mal_export int malMatch(InstrPtr p1, InstrPtr p2);
mal_export int malFcnMatch(MalBlkPtr m1, MalBlkPtr mb, int pc);
mal_export str ORCAMprocessor(MalBlkPtr mb, Symbol t);
mal_export str MACROprocessor(MalBlkPtr mb, Symbol t);
mal_export str MCoptimizerCommand(MalBlkPtr mb, MalStkPtr stk, InstrPtr p, str mod, str fcn);
#endif /* _MAL_MACRO_H_ */
@-
@c
#include "mal_macro.h"
#include "mal_interpreter.h"
#include "mal_namespace.h"
@-
The optimizer hooks are introduced first.
They are refered to from the optimizer module.
@c
int
malMatch(InstrPtr p1, InstrPtr p2)
{
	int i, j;

	if (functionId(p1) == 0 && functionId(p2) != 0)
		return 0;
	if (moduleId(p1) == 0 && moduleId(p2) != 0)
		return 0;
	if (moduleName(p1) != moduleName(p2))
		return 0;
	if (functionId(p2) == 0)
		return 0;
	if (idcmp(functionName(p1), functionName(p2)))
		return 0;
	if (p1->retc != p2->retc)
		return 0;
	if (p1->argc != p2->argc)
		return 0;
	if (p1->barrier != p2->barrier)
		return 0;
	for (i = 0; i < p1->argc; i++)
		for (j = i + 1; j < p1->argc; j++)
			if ((getArg(p1, i) == getArg(p1, j) && getArg(p2, i) != getArg(p2, j)) || (getArg(p1, i) != getArg(p1, j) && getArg(p2, i) == getArg(p2, j)))
				return 0;
	return 1;
}

@-
Matching a block calls for building two variable lists used.
The isomorphism can be determined after-wards using a single scan.
The candidate block is matched with mb starting at a given pc.
The candidate block is expected to defined as a function, including
a signature and end-statement. They are ignored in the comparison

Beware, the variables in the block being removed, could be
used furtheron in the program. [tricky to detect, todo]
@c
int
malFcnMatch(MalBlkPtr mc, MalBlkPtr mb, int pc)
{
	int i, j, k, lim;
	int *cvar, *mvar;
	int ctop = 0, mtop = 0;
	InstrPtr p, q;

	if (mb->stop - pc < mc->stop - 2)
		return 0;

	cvar = (int *) alloca(mc->vtop * MAXARG);

	mvar = (int *) alloca(mb->vtop * MAXARG);
	/* also trim the return statement */
	lim = pc + mc->stop - 3;
	k = 1;
	for (i = pc; i < lim; i++, k++) {
		p = getInstrPtr(mb, i);
		q = getInstrPtr(mc, k);
		if (malMatch(p, q) == 0)
			return 0;
		for (j = 0; j < p->argc; j++)
			cvar[ctop++] = getArg(p, j);

		for (j = 0; j < p->argc; j++)
			mvar[mtop++] = getArg(q, j);
	}
	assert(mtop == ctop);	/*shouldn;t happen */
#ifdef DEBUG_MAL_MACRO
	for (i = 0; i < ctop; i++)
		printf("match %d %d\n", cvar[i], mvar[i]);
#endif
	for (i = 0; i < ctop; i++)
		for (j = i + 1; j < ctop; j++)
			if ((cvar[i] == cvar[j] && mvar[i] != mvar[j]) ||(mvar[i] == mvar[j] && cvar[i] != cvar[j]))
				return 0;
	return 1;
}

@+ Macro expansions
The macro expansion routine walks through the MAL code block in search
the function to be expanded.  
The macro expansion process is restarted at the first new instruction.
A global is used to protect at (direct) recursive expansions
@c
#define MAXEXPANSION 256

int
inlineMALblock(MalBlkPtr mb, int pc, MalBlkPtr mc)
{
	int i, k, l, n, v;
	InstrPtr *ns, p;
	int *nv;

	ns = GDKmalloc((l = (mb->ssize + mc->ssize - 3)) * sizeof(InstrPtr));
	nv = alloca(mc->vtop * sizeof(int));
	p = getInstrPtr(mb, pc);
	v = p->argc - p->retc;
	k = 0;

	for (n = 0; n < mc->vtop; n++) {
		if (mc->var[n]->isaconstant)
			nv[n] = newConstant(mb, getVarType(mc, n), GDKstrdup(getVarLiteral(mc, n)), 1);
		else
			nv[n] = newTmpVariable(mb, getVarType(mc, n));
		isVarUsed(mb, nv[n]) = isVarUsed(mc, n);
		isVarInitialized(mb, nv[n]) = isVarInitialized(mc, n);
		k++;
	}
	for (n = 1; n < p->argc; n++)
		nv[n] = getArg(p, n);
#ifdef DEBUG_MAL_MACRO
	for (n = 1; n < mc->vtop; n++)
		printf("variable %d %d\n", n, nv[n]);
#endif
	k = 0;
	for (i = 0; i < pc; i++)
		ns[k++] = mb->stmt[i];

	/* copying stops at the first return statement */
	for (i = 1; i < mc->stop - 1; i++) {
		/* copy the instruction and fix variable references */
		p = mc->stmt[i];

		ns[k] = copyInstruction(p);
		if (p->barrier == RETURNsymbol || p->barrier == YIELDsymbol) {
			ns[k]->barrier = 0;
			if (p->token == RETURNsymbol || p->token == YIELDsymbol)
				ns[k]->token = ASSIGNsymbol;
			if (p->retc == p->argc)
				for (n = 0; n < p->retc; n++)
					pushArgument(mb, ns[k], nv[getArg(p, n)]);
			/* assign the result to variables */
			for (n = 0; n < p->retc; n++)
				getArg(ns[k], n) = getArg(mb->stmt[pc], n);

			k++;
			break;
		}
		for (n = 0; n < p->argc; n++) {
			/* fix the variable */
#ifdef DEBUG_MAL_MACRO
			printf("map %d  (%d) ", getArg(p, n), v);
#endif
			if (getArg(p, n) >= v) {
				getArg(ns[k], n) = nv[getArg(p, n)];
			} else {
				getArg(ns[k], n) = getArg(mb->stmt[pc], n);
			}
			isVarUsed(mb, getArg(ns[k], n)) = 1;
			isVarInitialized(mb, getArg(ns[k], n)) = 1;
		}
#ifdef DEBUG_MAL_MACRO
		printf("\n");
#endif
		k++;
	}
	for (i = pc + 1; i < mb->stop; i++)
		ns[k++] = mb->stmt[i];
	GDKfree(mb->stmt);
	mb->stmt = ns;

	mb->ssize = l;
	mb->stop = k;
	return pc;
}

@-
The macro processor should be carefull in replacing the
instruction. In particular, any RETURN or YIELD statement
should be replaced by a jump. For the time being,
we only allow for a single return statement at the end
of the block.
The semantic test is encapsulated in a routines.
@c

str
MACROvalidate(MalBlkPtr mb)
{
	int retseen = 0;
	int i;
	InstrPtr p = 0;

	if (getArgType(mb, getInstrPtr(mb, 0), 0) == TYPE_void)
		return 0;

	for (i = 1; retseen == 0 && i < mb->stop; i++) {
		p = getInstrPtr(mb, i);
		retseen = p->token == RETURNsymbol || p->token == YIELDsymbol || p->barrier == RETURNsymbol || p->barrier == YIELDsymbol;
	}
	if (retseen && i != mb->stop - 1)
		return throwMessage("optimizer.MACROvalidate", "RETURN statement is not the last one\n");
	return MAL_SUCCEED;
}

str
MACROprocessor(MalBlkPtr mb, Symbol t)
{
	InstrPtr q;
	int i, cnt = 0, last = -1;
	str msg = MAL_SUCCEED;

#ifdef DEBUG_MAL_MACRO
	printf("calling the MACRO processor\n");
#endif
	if (t == NULL)
		return msg;
	msg = MACROvalidate(t->def);
	if (msg)
		return msg;
	for (i = 0; i < mb->stop; i++) {
		q = getInstrPtr(mb, i);
		if (functionId(q) && idcmp(functionName(q), t->name) == 0 && getSignature(t)->token == FUNCTIONsymbol) {
#ifdef DEBUG_MAL_MACRO
			printf("Hit, replace macro call %s\n", t->name);
#endif
			if (i == last)
				return throwMessage("optimizer.MACROoptimizer", "duplicate macro expansion");

			last = i;
			i = inlineMALblock(mb, i, t->def);
			cnt++;
			if (cnt > MAXEXPANSION)
				return throwMessage("optimizer.MACROoptimizer", "too many macro expansions");
		}
	}
	return msg;
}

@}
@+ Macro inversions
Macro inversions map a consecutive sequences of MAL instructions
into a single call. Subsequence resolution will bind it with the proper
function. The pattern being replaced should be a self-standing
assignment. [could be improved]

The function being replaced should assign the result to
the signature variables. Otherwise it will be difficult
to assess which result to retain.
@{
@c
int
replaceMALblock(MalBlkPtr mb, int pc, MalBlkPtr mc)
{
	int i, j, k, lim;
	InstrPtr p, q, rq;
	int *cvar, *mvar;
	int ctop = 0, mtop = 0;

	/* collect variable map */
	cvar = (int *) alloca(mc->vtop * MAXARG);

	mvar = (int *) alloca(mb->vtop * MAXARG);
	lim = pc + mc->stop - 2;
	k = 1;
	for (i = pc; i < lim; i++, k++) {
		p = getInstrPtr(mb, i);
		q = getInstrPtr(mc, k);
		for (j = 0; j < p->argc; j++)
			cvar[ctop++] = getArg(q, j);

		for (j = 0; j < p->argc; j++)
			mvar[mtop++] = getArg(p, j);
	}
	assert(mtop == ctop);	/*shouldn;t happen */
#ifdef DEBUG_MAL_MACRO
	for (i = 0; i < ctop; i++)
		printf("match %d %d\n", cvar[i], mvar[i]);
#endif

	p = getInstrPtr(mb, pc);
	q = copyInstruction(getInstrPtr(mc, 0));	/* the signature */
	q->token = ASSIGNsymbol;
	mb->stmt[pc] = q;

	for (i = q->retc; i < q->argc; i++)
		for (j = 0; j < ctop; j++)
			if (q->argv[i] == cvar[j]) {
				q->argv[i] = mvar[j];
				break;
			}
	rq = getInstrPtr(mc, mc->stop - 2);
	for (i = 0; i < rq->retc; i++)
		for (j = 0; j < ctop; j++)
			if (rq->argv[i] == cvar[j]) {
				q->argv[i] = mvar[j];
				break;
			}
	freeInstruction(p);

	/* strip signature, return, and end statements */
	k = mc->stop - 3;
	j = pc + k;
	for (i = pc + 1; i < pc + k; i++)
		freeInstruction(mb->stmt[i]);

	for (i = pc + 1; i < mb->stop - k; i++)
		mb->stmt[i] = mb->stmt[j++];

	k = i;
	for (; i < mb->stop; i++)
		mb->stmt[i] = 0;

	mb->stop = k;
	return pc;
}

str
ORCAMprocessor(MalBlkPtr mb, Symbol t)
{
	MalBlkPtr mc = t->def;
	int i;
	str msg = MAL_SUCCEED;

	if (t == NULL || mc->stop < 3)
		return msg;
#ifdef DEBUG_MAL_MACRO
	printf("calling the ORCAM processor for %s\n", t->name);
#endif
	/* strip signature, return, and end statements */
	for (i = 1; i < mb->stop - mc->stop + 3; i++)
		if (malFcnMatch(mc, mb, i)) {
#ifdef DEBUG_MAL_MACRO
			printf("found match for %s at %d \n", t->name, i);
#endif
			msg = MACROvalidate(mc);
			if (msg == MAL_SUCCEED)
				replaceMALblock(mb, i, mc);
			else
				break;
		}
	chkProgram(getClient()->nspace, mb);
	return msg;
}

@-
The optimizer call infrastructure
@c
str
MCoptimizerCommand(MalBlkPtr mb, MalStkPtr stk, InstrPtr p, str mod, str fcn)
{
	Module s;
	Symbol t;
	str msg = MAL_SUCCEED;
	int j;

	(void) p;
	(void) stk;

	s = findModule(getClient()->nspace, putName(mod, strlen(mod)));
	if (s == 0)
		return throwException(MALEXCEPTION, "optimizer.@1optimizer", "module '%s' not found\n", fcn);
	if (s->subscope) {
		j = getSubScope(fcn);
		for (t = s->subscope[j]; t != NULL; t = t->peer)
			if (t->def->errors == 0) {
				if (getSignature(t)->token == FUNCTIONsymbol)
					/* call macro expansion */
					ORCAMprocessor(mb, t);
				if (msg)
					break;
			}
	}
	chkFlow(mb);
	chkDeclarations(mb, TRUE);
	return msg;
}

@}
