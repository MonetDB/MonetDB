@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@a M. Kersten
@v 0.0
@+ Some basic utiliteses
Passing strings between front-end and kernel often
require marshalling.
@{
@h
#ifndef MAL_UTILS_H
#define MAL_UTILS_H
#include "mal.h"

mal_export str quote(const char *msg, int size);
mal_export void unquote(char *msg);

#endif /* MAL_UTILS_H */
@-
At any point we should be able to construct an ascii representation of
the type descriptor. Including the variable references.
Unquoting of a string is done in place. It returns the start
of the unquoted part section.
@c
#include "mal_utils.h"

#define PLACEHOLDER '?'
void
unquote(char *msg)
{
	char *p = msg, *s;

	/* first skip over leading white space */
	while (*p && isspace((int) *p))
		p++;
	/* get quoted string and remove leading bracket first */
	p++;
	s = p;
	while (*p) {
		if (*p == '\\') {
			p++;
			switch (*p) {
			case 'n':
				*s = '\n';
				break;
			case 't':
				*s = '\t';
				break;
			case 'r':
				*s = '\r';
				break;
			case 'f':
				*s = '\f';
				break;
			case '0':
			case '1':
			case '2':
			case '3':
				/* this could be the start of
				   an octal sequence, check it
				   out */
				if (p[1] && p[2] && p[1] >= '0' && p[1] <= '7' && p[2] >= '0' && p[2] <= '7') {
					*s = ((p[0] - '0') << 6) | ((p[1] - '0') << 3) | (p[2] - '0');
					p += 2;
					break;
				}
				/* fall through */
			default:
				*s = *p;
				break;
			}
			p++;
		} else {
			*s = *p++;
		}
		s++;
	}
	*s = 0;			/* close string */
}

char *
quote(const char *msg, int size)
{
	char *s = GDKmalloc(strlen(msg) * 2 + 1);	/* we absolutely don't need more than this (until we start producing octal escapes */
	char *t = s;

	/* the condition is tricky: if initially size < 0, we must
	   continue until a NULL byte, else, size gives the number of
	   bytes to be copied */
	while (size < 0 ? *msg : size > 0) {
		if (size > 0)
			size--;
		switch (*msg) {
		case '"':
			*t++ = '\\';
			*t++ = '"';
			break;
		case '\n':
			*t++ = '\\';
			*t++ = 'n';
			break;
		case '\t':
			*t++ = '\\';
			*t++ = 't';
			break;
		case '\\':
			*t++ = '\\';
			*t++ = '\\';
			break;
		case '\0':
			*t++ = '\\';
			*t++ = '0';
			break;
		default:
			*t++ = *msg;
			break;
		}
		msg++;
		/* also deal with binaries */
	}
	*t = 0;
	return s;
}

@}
