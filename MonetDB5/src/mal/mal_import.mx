@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@a M. Kersten
@v 0.0
@+ Module import
The import statement simple switches the parser to a new input file, which
takes precedence. The context for which the file should be interpreted
is determined by the module name supplied.
Typically this involves a module, whose definitions are stored at 
a known location.
@{
@h
#ifndef _MAL_IMPORT_H
#define _MAL_IMPORT_H

#include "mal_exception.h"
#include "mal_client.h"
#include "mal_session.h"
#include "mal_utils.h"

mal_export void slash_2_dir_sep(str fname);
mal_export void malInclude(Client c, str name, str libname, int listing);
mal_export stream *malOpenSource(str fname);
mal_export str malLoadScript(str name, bstream **fdin);
mal_export void compileString(Client c, str s);
mal_export void callString(Client c, str s, int listing);
#endif /*  _MAL_IMPORT_H */
@-
The import context is located. If the module already exists, 
we should silently skip parsing the file. This is handled at the parser level.
The files are extracted from a default location,
namely the DBHOME/modules directory.

If the string starts with '/' or '~' the context is not changed.

Every IMPORT statement denotes a possible dynamic load library.
Make sure it is loaded as well.
@c
#include "mal_import.h"
#include "mal_interpreter.h"	/* for showErrors() */
#include "mal_linker.h"		/* for loadModuleLibrary() */

void
slash_2_dir_sep(str fname)
{
	char *s;

	for (s = fname; *s; s++)
		if (*s == '/')
			*s = '/';
}

stream *
malOpenSource(str fname)
{
	stream *fd = NULL;
	char path[PATHLENGTH];
	str fullname;

	strncpy(path, fname, PATHLENGTH);
	slash_2_dir_sep(path);
	fullname = MSP_locate_script(path);

	if (fullname) {
		fd = open_rastream(fullname);
		GDKfree(fullname);
	} else {
		fd = open_rastream(path);
	}
	return fd;
}

@-
The malLoadScript routine merely reads the contents of a file into
the input buffer of the client. It is typically used in situations
where an intermediate file is used to pass commands around.
@c
str
malLoadScript(str name, bstream **fdin)
{
	stream *fd;

	fd = malOpenSource(name);
	if (stream_errnr(fd) == OPEN_ERROR) {
		stream_destroy(fd);
		return throwException(MALEXCEPTION, "malInclude", "could not open file: %s\n", name);
	}
	*fdin = bstream_create(fd, 128 * BLOCK);
	return NULL;
}

@-
Beware that we have to isolate the execution of the source file
in its own environment. E.g. we have to removed the execution
state until we are finished.
The script being read my contain errors, such as non-balanced
brackets as indicated by blkmode.
It should be reset before continuing.
@-
@= restoreClient1
    c->fdin = oldfdin; 
    c->yycur = oldyycur; 
    c->listing = oldlisting;
    c->mode = oldmode;
    c->blkmode = oldblkmode;
	c->bak = oldbak;
	/* if(c->prompt) GDKfree(c->prompt); careful, avoid double */
    c->prompt = oldprompt;
	c->promptlength= strlen(c->prompt);
@= restoreClient2
    c->glb = oldglb;
    c->nspace = oldnspace;
    c->curprg = oldprg;
@= restoreClient
	@:restoreClient1()@
	@:restoreClient2()@
@= runPhase
    if(msg== MAL_SUCCEED && c->phase[@1] && (msg= (str) (*c->phase[@1])(c)) ){
		/* error occurred  and ignored */
		/* stream_printf(GDKout,"%s",msg);*/
		GDKfree(msg); msg=0;
		@:@2()@
		return;
    }

@c
void
malInclude(Client c, str name, str libname, int listing)
{
	str s;

	bstream *oldfdin = c->fdin;
	int oldyycur = c->yycur;
	int oldlisting = c->listing;
	int oldmode = c->mode;
	int oldblkmode = c->blkmode;
	str oldprompt = c->prompt;
	ClientInput *oldbak = c->bak;

	Module oldnspace = c->nspace;
	Symbol oldprg = c->curprg;
	MalStkPtr oldglb = c->glb;

	c->yycur = 0;
	c->prompt = GDKstrdup("");	/* do not produce visible prompts */
	c->promptlength = strlen(c->prompt);
	c->listing = listing;
	c->bak = NULL;

	c->fdin = NULL;
	if ((s = malLoadScript(name, &c->fdin))) {
		stream_printf(c->fdout, "%s\n", s);
@-
Load any associated module first, because this sets the context for
resolving addresses. 
@c
	} else if (libname) {
		s = (str) loadModuleLibrary(libname);
		if (s)
			stream_printf(c->fdout, "#WARNING: %s\n", s);
		initClientPrg(c, "main");	/* create new context */
		runScenario(c);
	} else {
		str msg = MAL_SUCCEED;

		initClientPrg(c, "main");	/* create new context */
		@:runPhase(READER,restoreClient1)@
		@:runPhase(PARSER,restoreClient1)@
		/* restore IO channel */
		if (c->fdin) {
			(void) stream_close(c->fdin->s);
			(void) stream_destroy(c->fdin->s);
			(void) bstream_destroy(c->fdin);
		}
		@:restoreClient1()@
		c->listing = listing;
		@:runPhase(OPTIMIZE,restoreClient2)@
		@:runPhase(SCHEDULER,restoreClient2)@
		@:runPhase(ENGINE,restoreClient2)@
		c->listing = oldlisting;
		@:restoreClient2()@
		return;
		/*runScenario(c); */
	}

	if (c->fdin) {
		(void) stream_close(c->fdin->s);
		(void) stream_destroy(c->fdin->s);
		(void) bstream_destroy(c->fdin);
	}

	@:restoreClient()@
}

@+ File and input processing
A recurring situation is to execute a stream of simple MAL instructions
stored on a file or comes from standard input. We parse one MAL 
instruction line at a time and attempt to execute it immediately.
Note, this precludes entereing complex MAL structures on the primary
input channel, because 1) this requires complex code to keep track
that we are in 'definition mode' 2) this requires (too) carefull
typing by the user, because he can not make an typeing error

Therefore, all compound code fragments should be loaded and executed
using the run(file) and callString command. It will parse the complete
file into a MAL program block and execute it.

Running looks much like an Import operation, except for the execution
phase. This is performed in the context of an a priori defined
stack frame. Life becomes a little complicated when the script contains
a definition.
@c
void
compileString(Client c, str s){
	bstream *oldfdin = c->fdin;
	int oldyycur = c->yycur;
	int oldlisting = c->listing;
	int oldmode = c->mode;
	int oldblkmode = c->blkmode;
	str oldprompt = c->prompt;
	ClientInput *oldbak = c->bak;
	Module oldnspace = c->nspace;
	Symbol oldprg = c->curprg;
	MalStkPtr oldglb = c->glb;
	int len = strlen(s);
	buffer *b;
	str msg = MAL_SUCCEED;
	str qry;

	c->yycur = 0;
	c->prompt = GDKstrdup("");	/* do not produce visible prompts */
	c->promptlength = strlen(c->prompt);
	c->listing = 0;
	c->bak = NULL;
	c->fdin = NULL;

	b = (buffer *) GDKmalloc(sizeof(buffer));
	if (s[len - 1] != '\n') {
		char *n = GDKmalloc(len + 1 + 1);

		strncpy(n, s, len);
		n[len] = '\n';
		n[len + 1] = 0;
		s = n;
		len++;
	}
	unquote(qry = GDKstrdup(s));
	buffer_init(b, qry, len);
	pushClientInput(c, bstream_create(buffer_rastream(b, "compileString"), b->len), 0, "");
	initClientPrg(c, "main");	/* create new context */
	@:runPhase(READER,restoreClient1)@
	@:runPhase(PARSER,restoreClient1)@
	/* restore IO channel */
	@:restoreClient1()@
	c->listing = oldlisting;
	@:restoreClient2()@
	GDKfree(qry);
}

void
callString(Client c, str s, int listing)
{
	bstream *oldfdin = c->fdin;
	int oldyycur = c->yycur;
	int oldlisting = c->listing;
	int oldmode = c->mode;
	int oldblkmode = c->blkmode;
	str oldprompt = c->prompt;
	ClientInput *oldbak = c->bak;
	Module oldnspace = c->nspace;
	Symbol oldprg = c->curprg;
	MalStkPtr oldglb = c->glb;
	int len = strlen(s);
	buffer *b;
	str msg = MAL_SUCCEED,qry;

	c->yycur = 0;
	c->prompt = GDKstrdup("");	/* do not produce visible prompts */
	c->promptlength = strlen(c->prompt);
	c->listing = listing;
	c->bak = NULL;
	c->fdin = NULL;

	b = (buffer *) GDKmalloc(sizeof(buffer));
	if (s[len - 1] != '\n') {
		char *n = GDKmalloc(len + 1 + 1);

		strncpy(n, s, len);
		n[len] = '\n';
		n[len + 1] = 0;
		s = n;
		len++;
	}
	unquote(qry = GDKstrdup(s));
	buffer_init(b, qry, len);
	pushClientInput(c, bstream_create(buffer_rastream(b, "callString"), b->len), listing, "");
	initClientPrg(c, "main");	/* create new context */
	@:runPhase(READER,restoreClient1)@
	@:runPhase(PARSER,restoreClient1)@
	/* restore IO channel */
	@:restoreClient1()@
	@:runPhase(OPTIMIZE,restoreClient2)@
	@:runPhase(SCHEDULER,restoreClient2)@
	@:runPhase(ENGINE,restoreClient2)@
	@:restoreClient2()@
	GDKfree(qry);
}

@}
