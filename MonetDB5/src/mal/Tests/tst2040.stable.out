stdout of test 'tst2040` in directory 'src/mal` itself:


# 08:01:00 >  
# 08:01:00 >  Mtimeout -timeout 60 Mserver "--config=/ufs/mk/monet5/Linux/etc/MonetDB5.conf" --debug=10 --set "monet_mod_path=/ufs/mk/monet5/Linux/lib/MonetDB5:/ufs/mk/opensource/MonetDB/Linux/lib/MonetDB" --set "gdk_dbfarm=/ufs/mk/monet5/Linux/var/MonetDB5/dbfarm" --set "sql_logdir=/ufs/mk/monet5/Linux/var/MonetDB5/log" --set mapi_port=42158 --set sql_port=55708 --set monet_prompt= --trace "--config=/ufs/mk/monet5/src/mal/Tests/All.conf" --dbname=mTests_src_mal  tst2040.mal </dev/null
# 08:01:00 >  

# Monet Database Server V4.99.19
# Copyright (c) 1993-2004, CWI. All rights reserved.
# Compiled for i686-redhat-linux-gnu/32bit; dynamically linked.
# config:/ufs/mk/monet5/Linux/etc/MonetDB5.conf
# dbfarm:/ufs/mk/monet5/Linux/var/MonetDB5/dbfarm
# dbname:mTests_src_mal
# Visit http://monetdb.cwi.nl/ for further information.
##The 2000 serie  is focussed on parallelism
## Example of a simple producer/consumer pair
#
#
#	cWait:= true;	#consumer put to sleep
#	pWait:= true;	#consumer put to sleep
#
#thread 	producer;	
#	printf("Created producer thread\n");
#barrier pBody:=true;
#barrier pWait;		# bussy loop to await for consumer 
#	printf("producer: sleep\n");
#	alarm.sleep(1);
#	redo pWait;
#exit 	pWait;
#	printf("produce an element\n");
#	pWait:= true;
#	cWait:= false;
#barrier b:= i==0;
#	leave producer;
#exit	b;
#	redo pBody;
#exit	pBody;
#	printf("Finished producer\n");
#exit	producer;
#
#thread consumer;
#	printf("Created consumer thread\n");
#barrier cBody:=true;
#barrier cWait;	
#	printf("consumer: sleep\n");
#	alarm.sleep(1);
#	redo cWait;
#exit 	cWait;
#	printf("consume element %d\n",i);
#barrier b:= i==0;
#	leave consumer;
#exit	b;
#	i:=i-1;
#	cWait:= true;
#	pWait:= false;
#	redo cBody;
#exit	cBody;
#	printf("Finished consumer\n");
#exit 	consumer;
#
#	i:= 2;
#	pWait:= false;
#	printf("await dead of producer/consumer\n");
#
!ERROR: 'io.printf' undefined in user.main[29]
!ERROR: MALresolve:user.main[40]:type mismatch bat[:any,:int] := int
!ERROR: barrier 'b' should be of type bit or number in main[14]
!ERROR: barrier 'b' should be of type bit or number in main[30]
!ERROR: 'i' may not be used before being set in main[14]
!ERROR: 'i' may not be used before being set in main[29]
!ERROR: 'i' may not be used before being set in main[30]
!ERROR: 'b' used outside declaration scope in main[30]
!ERROR: 'b' used outside declaration scope in main[32]
!ERROR: 'i' may not be used before being set in main[33]
!ERROR: 'i' used outside declaration scope in main[40]
function user.main():int;	# 0  (main:int)
    cWait := true;	# 1  (cWait:bit)<-($2:bit)
    pWait := true;	# 2  (pWait:bit)<-($2:bit)
thread producer;	# 3  (producer:any) jump 20
    io.printf("Created producer thread\n");	# 4 IOprint_str ($5:int)<-($6:str)
barrier pBody := true;	# 5  (pBody:bit)<-($2:bit) jump 18
barrier pWait;	# 6  (pWait:bit) jump 10
    io.printf("producer: sleep\n");	# 7 IOprint_str ($8:int)<-($9:str)
    alarm.sleep(1);	# 8 ALARMsleep ($10:void)<-($11:int)
    redo pWait;	# 9  (pWait:bit) jump 7
exit pWait;	# 10  (pWait:bit)
    io.printf("produce an element\n");	# 11 IOprint_str ($12:int)<-($13:str)
    pWait := true;	# 12  (pWait:bit)<-($2:bit)
    cWait := false;	# 13  (cWait:bit)<-($14:bit)
barrier b := batcalc.==(i,0);	# 14 CMDcmpEQcst (b:bat[:any,:bit])<-(i:bat[:any,:int])($17:int) jump 16
    leave producer;	# 15  (producer:any) jump 20
exit b;	# 16  (b:bat[:any,:bit])
    redo pBody;	# 17  (pBody:bit) jump 6
exit pBody;	# 18  (pBody:bit)
    io.printf("Finished producer\n");	# 19 IOprint_str ($18:int)<-($19:str)
exit producer;	# 20  (producer:any)
thread consumer;	# 21  (consumer:any) jump 39
    io.printf("Created consumer thread\n");	# 22 IOprint_str ($21:int)<-($22:str)
barrier cBody := true;	# 23  (cBody:bit)<-($2:bit) jump 37
barrier cWait;	# 24  (cWait:bit) jump 28
    io.printf("consumer: sleep\n");	# 25 IOprint_str ($24:int)<-($25:str)
    alarm.sleep(1);	# 26 ALARMsleep ($26:void)<-($11:int)
    redo cWait;	# 27  (cWait:bit) jump 25
exit cWait;	# 28  (cWait:bit)
    io.printf("consume element %d\n",i);	# 29  unknown ($27:any)<-($28:str)(i:bat[:any,:int])
barrier b := batcalc.==(i,0);	# 30 CMDcmpEQcst (b:bat[:any,:bit])<-(i:bat[:any,:int])($17:int) jump 32
    leave consumer;	# 31  (consumer:any) jump 39
exit b;	# 32  (b:bat[:any,:bit])
    i := batcalc.-(i,1);	# 33 CMDbatMINcst (i:bat[:any,:int])<-(i:bat[:any,:int])($11:int)
    cWait := true;	# 34  (cWait:bit)<-($2:bit)
    pWait := false;	# 35  (pWait:bit)<-($14:bit)
    redo cBody;	# 36  (cBody:bit) jump 24
exit cBody;	# 37  (cBody:bit)
    io.printf("Finished consumer\n");	# 38 IOprint_str ($29:int)<-($30:str)
exit consumer;	# 39  (consumer:any)
    i := 2;	# 40  unknown (i:bat[:any,:int])<-($31:int)
    pWait := false;	# 41  (pWait:bit)<-($14:bit)
    io.printf("await dead of producer/consumer\n");	# 42 IOprint_str ($32:int)<-($33:str)
end main;	# 43  

# 08:01:00 >  
# 08:01:00 >  Done.
# 08:01:00 >  

