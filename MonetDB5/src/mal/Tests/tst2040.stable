# Monet Database Server V5.0
# Copyright (c) 1993-2003, CWI. All rights reserved.
# compiled for 32biti686-pc-linux-gnu/32bit.
# config:/ufs/mk/monet_5/src/mal/Tests/tst.conf
# dbfarm:/ufs/mk/monet_5/Linux/var/MonetDB
# dbname:demo
##The 2000 serie  is focussed on parallelism
## Example of a simple producer/consumer pair
#
#
#	cWait:= true;	#consumer put to sleep
#	pWait:= true;	#consumer put to sleep
#
#thread 	producer;	
#	printf("Created producer thread\n");
#barrier pBody:=true;
#barrier pWait;		# bussy loop to await for consumer 
#	printf("producer: sleep\n");
#	alarm.sleep(1);
#	redo pWait;
#exit 	pWait;
#	printf("produce an element\n");
#	pWait:= true;
#	cWait:= false;
#barrier b:= i==0;
#	leave producer;
#exit	b;
#	redo pBody;
#exit	pBody;
#	printf("Finished producer\n");
#exit	producer;
#
#thread consumer;
#	printf("Created consumer thread\n");
#barrier cBody:=true;
#barrier cWait;	
#	printf("consumer: sleep\n");
#	alarm.sleep(1);
#	redo cWait;
#exit 	cWait;
#	printf("consume element %d\n",i);
#barrier b:= i==0;
#	leave consumer;
#exit	b;
#	i:=i-1;
#	cWait:= true;
#	pWait:= false;
#	redo cBody;
#exit	cBody;
#	printf("Finished consumer\n");
#exit 	consumer;
#
#	i:= 2;
#	pWait:= false;
#	printf("await dead of producer/consumer\n");
#
!ERROR: 'printf' undefined in Admin.main[29]
!ERROR: MALresolve:Admin.main[40]:type mismatch bat[any,int] := int
!ERROR: barrier 'b' should be of type bit or number in main[14]
!ERROR: barrier 'b' should be of type bit or number in main[30]
function Admin.main():int; #0  (main:int)
    cWait := true; #1  (cWait:bit)<-($2:bit)
    pWait := true; #2  (pWait:bit)<-($2:bit)
thread producer; #3  (producer:int) jump 20
    system.printf("Created producer thread\n"); #4 SYSprint_str ($5:int)<-($6:str)
barrier pBody := true; #5  (pBody:bit)<-($2:bit) jump 18
barrier pWait; #6  (pWait:bit) jump 10
    system.printf("producer: sleep\n"); #7 SYSprint_str ($8:int)<-($9:str)
    alarm.sleep(1); #8 CLKsleep ($10:void)<-($11:int)
    redo pWait; #9  (pWait:bit) jump 6
exit pWait; #10  (pWait:bit)
    system.printf("produce an element\n"); #11 SYSprint_str ($12:int)<-($13:str)
    pWait := true; #12  (pWait:bit)<-($2:bit)
    cWait := false; #13  (cWait:bit)<-($14:bit)
barrier b := batcalc.==(i,0); #14 CMDcmpEQcst (b:bat[any,bit])<-(i:bat[any,int])($17:int) jump 16
    leave producer; #15  (producer:int) jump 20
exit b; #16  (b:bat[any,bit])
    redo pBody; #17  (pBody:bit) jump 5
exit pBody; #18  (pBody:bit)
    system.printf("Finished producer\n"); #19 SYSprint_str ($18:int)<-($19:str)
exit producer; #20  (producer:int)
thread consumer; #21  (consumer:int) jump 39
    system.printf("Created consumer thread\n"); #22 SYSprint_str ($21:int)<-($22:str)
barrier cBody := true; #23  (cBody:bit)<-($2:bit) jump 37
barrier cWait; #24  (cWait:bit) jump 28
    system.printf("consumer: sleep\n"); #25 SYSprint_str ($24:int)<-($25:str)
    alarm.sleep(1); #26 CLKsleep ($26:void)<-($11:int)
    redo cWait; #27  (cWait:bit) jump 24
exit cWait; #28  (cWait:bit)
    printf("consume element %d\n",i); #29  unknown ($27:any)<-($28:str)(i:bat[any,int])
barrier b := batcalc.==(i,0); #30 CMDcmpEQcst (b:bat[any,bit])<-(i:bat[any,int])($17:int) jump 32
    leave consumer; #31  (consumer:int) jump 39
exit b; #32  (b:bat[any,bit])
    i := batcalc.-(i,1); #33 CMDbatMINcst (i:bat[any,int])<-(i:bat[any,int])($11:int)
    cWait := true; #34  (cWait:bit)<-($2:bit)
    pWait := false; #35  (pWait:bit)<-($14:bit)
    redo cBody; #36  (cBody:bit) jump 23
exit cBody; #37  (cBody:bit)
    system.printf("Finished consumer\n"); #38 SYSprint_str ($29:int)<-($30:str)
exit consumer; #39  (consumer:int)
    i := 2; #40  unknown (i:bat[any,int])<-($31:int)
    pWait := false; #41  (pWait:bit)<-($14:bit)
    system.printf("await dead of producer/consumer\n"); #42 SYSprint_str ($32:int)<-($33:str)
end main; #43  
>