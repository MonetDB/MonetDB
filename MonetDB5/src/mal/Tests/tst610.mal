#this test is used to monitor reference count setting
#create a persistent bat and destroy it in the next session
function refs():void;
    g:=bbp.getNames();
    gr:=bbp.getRefCount();
    gl:=bbp.getLRefCount();
    io.print(g,gr,gl);
end refs;

b:= bat.new(:int,:int);
#refs();
bat.insert(b,23,32);
#refs();
bat.setName(b,"tasks");
#refs();
bat.setPersistent(b);
#refs();
# it is committed 
io.print("open box");
bbp.open();
user.refs();
t:bat[:any_1,:any_2]:= bbp.bind("tasks");
io.print(t);
bbp.release(t);
user.refs();
io.print(t);
catch MALexception;
io.print("BAT was released");
exit MALexception;
# the bat is still visible, because the destroy only
# marks it for deletion at the end of session or
# when the reference counters drop to zero
t:bat[:any_1,:any_2]:= bbp.bind("tasks");
user.refs();
# to really remove, we get rid of the current
# references as well
bbp.destroy(t,true);
user.refs();
io.print(t);
catch MALexception;
io.print("BAT was destroyed");
exit MALexception;
z:bat[:any_1,:any_2]:= bbp.bind("tasks");
io.print(z);
#it is not in the box anymore either
catch MALexception;
io.print("BAT was removed from the box");
exit MALexception;
