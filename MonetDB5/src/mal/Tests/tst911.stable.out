stdout of test 'tst911` in directory 'src/mal` itself:


# 08:01:40 >  
# 08:01:40 >  Mtimeout -timeout 60 Mserver "--config=/ufs/mk/monet5/Linux/etc/MonetDB5.conf" --debug=10 --set "monet_mod_path=/ufs/mk/monet5/Linux/lib/MonetDB5:/ufs/mk/opensource/MonetDB/Linux/lib/MonetDB" --set "gdk_dbfarm=/ufs/mk/monet5/Linux/var/MonetDB5/dbfarm" --set "sql_logdir=/ufs/mk/monet5/Linux/var/MonetDB5/log" --set mapi_port=42158 --set sql_port=55708 --set monet_prompt= --trace "--config=/ufs/mk/monet5/src/mal/Tests/All.conf" --dbname=mTests_src_mal  tst911.mal </dev/null
# 08:01:40 >  

# Monet Database Server V4.99.19
# Copyright (c) 1993-2004, CWI. All rights reserved.
# Compiled for i686-redhat-linux-gnu/32bit; dynamically linked.
# config:/ufs/mk/monet5/Linux/etc/MonetDB5.conf
# dbfarm:/ufs/mk/monet5/Linux/var/MonetDB5/dbfarm
# dbname:mTests_src_mal
# Visit http://monetdb.cwi.nl/ for further information.
## analyse the overhead of chopping a table
## the multiplex code blocks.
#
#function choptest(b:bat[:void,:lng], size:lng, base:lng);
#    t0:= alarm.usec();
#    barrier (chk,c):= newChunkIterator(b,size);
#        t:= select(c, 256000:lng,266000:lng);
#        redo (chk,c):= hasMoreChunks(b,size);
#    exit (chk,c);
#
#    t1:= alarm.usec();
#    d0:= t1-t0;
#    printf("#chopped at %d",size);
#    printf(" %d",d0);
#    d0:= d0-base;
#    printf(" %d ",d0);
#    i:= 1000000:lng/size;
#    if:= flt(i);
#    df:= flt(d0);
#    f:= df/if;
#    printf(" at %f usec\n",f);
#end choptest;
function user.choptest(b:bat[:oid,:lng],size:lng,base:lng):void;#  0 choptest:void := user.choptest(b:bat[:oid,:lng], size:lng, base:lng) {G}
    t0 := alarm.usec();                 #  1 t0:lng := ALARMusec() 
barrier (chk,c):= bat.newIterator(b,size);#  2 (chk:lng, c:bat[:oid,:lng]) := CHPnewChunkIterator(b:bat[:oid,:lng], size:lng) {GJ5}
    t := algebra.select(c,256000:lng,266000:lng);#  3 t:bat[:oid,:lng] := ALGselect(c:bat[:oid,:lng], _8:lng, _9:lng) {G}
    redo (chk,c):= bat.hasMoreElements(b,size);#  4 (chk:lng, c:bat[:oid,:lng]) := CHPhasMoreChunks(b:bat[:oid,:lng], size:lng) {GJ3}
exit (chk,c);                           #  5 (chk:lng, c:bat[:oid,:lng]) 
    t1 := alarm.usec();                 #  6 t1:lng := ALARMusec() 
    d0 := calc.-(t1,t0);                #  7 d0:lng := CALCbinarySUBlnglng(t1:lng, t0:lng) 
    io.printf("#chopped at %d",size);   #  8 _12:void := IOprint_formatted_lng(_13:str, size:lng) 
    io.printf(" %d",d0);                #  9 _14:void := IOprint_formatted_lng(_15:str, d0:lng) 
    d0 := calc.-(d0,base);              # 10 d0:lng := CALCbinarySUBlnglng(d0:lng, base:lng) 
    io.printf(" %d ",d0);               # 11 _16:void := IOprint_formatted_lng(_17:str, d0:lng) 
    i := calc./(1000000:lng,size);      # 12 i:lng := CALCbinarycheckDIVlnglng(_19:lng, size:lng) 
    if := calc.flt(i);                  # 13 if:flt := CALClng2flt(i:lng) 
    df := calc.flt(d0);                 # 14 df:flt := CALClng2flt(d0:lng) 
    f := calc./(df,if);                 # 15 f:flt := CALCbinarycheckDIVfltflt(df:flt, if:flt) 
    io.printf(" at %f usec\n",f);       # 16 _23:void := IOprint_formatted_flt(_24:str, f:flt) 
end choptest;	# 17  
#
#b:= new(:void,:lng);
#barrier (go,i):= newRange(0:lng);
#	k:= rand();
#	l:= lng(k);
#	insert(b,nil,l);
#	redo (go,i):= nextElement(1:lng,1000000:lng);
#exit (go,i);
#
#t0:= alarm.usec();
#barrier doit:= true;
#    t:= select(b, 256000:lng,266000:lng);
#exit doit;
#t1:= alarm.usec();
#base:= t1-t0;
#printf("#select direct %d usec\n",base);
#
#choptest(b,100000:lng,base);
#choptest(b,10000:lng,base);
#choptest(b,1000:lng,base);
#choptest(b,100:lng,base);
#
#user.choptest(b,100000:lng,base);
#user.choptest(b,10000:lng,base);
#user.choptest(b,1000:lng,base);
#user.choptest(b,100:lng,base);
#
function user.main():void;              #  0 main:void := user.main() {G}
# analyse the overhead of chopping a table 
# the multiplex code blocks. 
    b := bat.new(:oid,:lng);            #  3 b:bat[:oid,:lng] := CMDBATnew(_4:oid, _5:lng) {G}
barrier (go,i):= language.newRange(0:lng);#  4 (go:bit, i:lng) := RNGnewRange_lng(_8:lng) {J9}
    k := mmath.rand();                  #  5 k:int := MATHrandint() 
    l := calc.lng(k);                   #  6 l:lng := CALCint2lng(k:int) 
    bat.insert(b,nil:oid,l);            #  7 _11:void := BKCinsert_bun(b:bat[:oid,:lng], _12:oid, l:lng) 
    redo (go,i):= language.nextElement(1:lng,1000000:lng);#  8 (go:bit, i:lng) := RNGnextElement_lng(_13:lng, _14:lng) {J5}
exit (go,i);                            #  9 (go:bit, i:lng) 
    t0 := alarm.usec();                 # 10 t0:lng := ALARMusec() 
barrier doit := true;                   # 11 doit:bit := _17:bit {J13}
    t := algebra.select(b,256000:lng,266000:lng);# 12 t:bat[:oid,:lng] := ALGselect(b:bat[:oid,:lng], _19:lng, _20:lng) {G}
exit doit;                              # 13 doit:bit 
    t1 := alarm.usec();                 # 14 t1:lng := ALARMusec() 
    base := calc.-(t1,t0);              # 15 base:lng := CALCbinarySUBlnglng(t1:lng, t0:lng) 
    io.printf("#select direct %d usec\n",base);# 16 _23:void := IOprint_formatted_lng(_24:str, base:lng) 
    user.choptest(b,100000:lng,base);   # 17 _25:void := user.choptest(b:bat[:oid,:lng], _26:lng, base:lng) 
    user.choptest(b,10000:lng,base);    # 18 _27:void := user.choptest(b:bat[:oid,:lng], _28:lng, base:lng) 
    user.choptest(b,1000:lng,base);     # 19 _29:void := user.choptest(b:bat[:oid,:lng], _30:lng, base:lng) 
    user.choptest(b,100:lng,base);      # 20 _31:void := user.choptest(b:bat[:oid,:lng], _32:lng, base:lng) 
end main;	# 21  
#select direct 23221 usec
#chopped at 100000 23384 163  at 16.299999 usec
#chopped at 10000 24141 920  at 9.200000 usec
#chopped at 1000 30694 7473  at 7.473000 usec
#chopped at 100 94699 71478  at 7.147800 usec

# 08:01:41 >  
# 08:01:41 >  Done.
# 08:01:41 >  

