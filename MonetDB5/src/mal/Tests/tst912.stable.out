stdout of test 'tst912` in directory 'src/mal` itself:


# 08:01:41 >  
# 08:01:41 >  Mtimeout -timeout 60 Mserver "--config=/ufs/mk/monet5/Linux/etc/MonetDB5.conf" --debug=10 --set "monet_mod_path=/ufs/mk/monet5/Linux/lib/MonetDB5:/ufs/mk/opensource/MonetDB/Linux/lib/MonetDB" --set "gdk_dbfarm=/ufs/mk/monet5/Linux/var/MonetDB5/dbfarm" --set "sql_logdir=/ufs/mk/monet5/Linux/var/MonetDB5/log" --set mapi_port=42158 --set sql_port=55708 --set monet_prompt= --trace "--config=/ufs/mk/monet5/src/mal/Tests/All.conf" --dbname=mTests_src_mal  tst912.mal </dev/null
# 08:01:41 >  

# Monet Database Server V4.99.19
# Copyright (c) 1993-2004, CWI. All rights reserved.
# Compiled for i686-redhat-linux-gnu/32bit; dynamically linked.
# config:/ufs/mk/monet5/Linux/etc/MonetDB5.conf
# dbfarm:/ufs/mk/monet5/Linux/var/MonetDB5/dbfarm
# dbname:mTests_src_mal
# Visit http://monetdb.cwi.nl/ for further information.
## analyse the overhead of chopping a table
## the multiplex code blocks.
#
#factory getChunk(b:bat[:void,:lng], size:lng)(bb:bit,c:bat[:void,:lng]);
#    (chk,c):= newChunkIterator(b,size);
#    bf:= true; # change in bb to crash
#barrier allways:= chk>0;
#    yield (bb,c):= (true,c);
#    (chk,c):= hasMoreChunks(b,size);
#    redo allways:= chk>0;
#exit allways;
#    printf("#factory done\n");
#    return (bb,c):= (false,c);
#end getChunk;
factory user.getChunk(b:bat[:oid,:lng],size:lng) (bb:bit,c:bat[:oid,:lng]);#  0 (bb:bit, c:bat[:oid,:lng]) := user.getChunk(b:bat[:oid,:lng], size:lng) {G}
    (chk,c):= bat.newIterator(b,size);  #  1 (chk:lng, c:bat[:oid,:lng]) := CHPnewChunkIterator(b:bat[:oid,:lng], size:lng) {G}
barrier allways := calc.>=(chk,0);      #  2 allways:bit := CALCcompGElngint(chk:lng, _7:int) {J6}
    yield (bb,c):= (true,c);            #  3 (bb:bit, c:bat[:oid,:lng]) := _8:bit, c:bat[:oid,:lng] {G}
    (chk,c):= bat.hasMoreElements(b,size);#  4 (chk:lng, c:bat[:oid,:lng]) := CHPhasMoreChunks(b:bat[:oid,:lng], size:lng) {G}
    redo allways := calc.>=(chk,0);     #  5 allways:bit := CALCcompGElngint(chk:lng, _7:int) {J3}
exit allways;                           #  6 allways:bit 
    io.print("#factory done\n");        #  7 _9:void := IOprint_val(_10:str) 
    return (bb,c):= (false,c);          #  8 (bb:bit, c:bat[:oid,:lng]) := _11:bit, c:bat[:oid,:lng] {G}
end getChunk;	# 9  
#
#function choptest(b:bat[:void,:lng], size:lng, base:lng);
#    t0:= alarm.usec();
#    barrier (tst,c):= getChunk(b,size);
#        t:= select(c, 256000:lng,266000:lng);
#        redo (tst,c):= getChunk(b,size);
#    exit (tst,c);
#
#    t1:= alarm.usec();
#    d0:= t1-t0;
#    printf("#chopped at %d",size);
#    printf(" %d",d0);
#    d0:= d0-base;
#    printf(" %d ",d0);
#    i:= 1000000:lng/size;
#    if:= flt(i);
#    df:= flt(d0);
#    f:= df/if;
#    printf(" at %f usec\n",f);
#end choptest;
function user.choptest(b:bat[:oid,:lng],size:lng,base:lng):void;#  0 choptest:void := user.choptest(b:bat[:oid,:lng], size:lng, base:lng) {G}
    t0 := alarm.usec();                 #  1 t0:lng := ALARMusec() 
barrier (tst,c):= user.getChunk(b,size);#  2 (tst:bit, c:bat[:oid,:lng]) := user.getChunk(b:bat[:oid,:lng], size:lng) {GJ5}
    t := algebra.select(c,256000:lng,266000:lng);#  3 t:bat[:oid,:lng] := ALGselect(c:bat[:oid,:lng], _8:lng, _9:lng) {G}
    redo (tst,c):= user.getChunk(b,size);#  4 (tst:bit, c:bat[:oid,:lng]) := user.getChunk(b:bat[:oid,:lng], size:lng) {GJ3}
exit (tst,c);                           #  5 (tst:bit, c:bat[:oid,:lng]) 
    t1 := alarm.usec();                 #  6 t1:lng := ALARMusec() 
    d0 := calc.-(t1,t0);                #  7 d0:lng := CALCbinarySUBlnglng(t1:lng, t0:lng) 
    i := calc./(1000000:lng,size);      #  8 i:lng := CALCbinarycheckDIVlnglng(_13:lng, size:lng) 
    if := calc.flt(i);                  #  9 if:flt := CALClng2flt(i:lng) 
    df := calc.flt(d0);                 # 10 df:flt := CALClng2flt(d0:lng) 
    f := calc./(df,if);                 # 11 f:flt := CALCbinarycheckDIVfltflt(df:flt, if:flt) 
    io.printf("#chopped at %d",size);   # 12 _17:void := IOprint_formatted_lng(_18:str, size:lng) 
    io.printf(" at %f usec\n",f);       # 13 _19:void := IOprint_formatted_flt(_20:str, f:flt) 
end choptest;	# 14  
#
#b:= bat.new(:void,:lng);
#barrier (go,i):= mal.newRange(0:lng);
#	k:= mmath.rand();
#	l:= calc.lng(k);
#	bat.insert(b,nil,l);
#	redo (go,i):= mal.nextElement(1:lng,1000000:lng);
#exit (go,i);
#
#t0:= alarm.usec();
#barrier doit:= true;
#    t:= select(b, 256000:lng,266000:lng);
#exit doit;
#t1:= alarm.usec();
#base:= t1-t0;
#printf("#select direct %d usec\n",base);
#
#choptest(b,100000:lng,base);
#choptest(b,10000:lng,base);
#choptest(b,1000:lng,base);
#choptest(b,100:lng,base);
#
#user.choptest(b,100000:lng,base);
#user.choptest(b,10000:lng,base);
#user.choptest(b,1000:lng,base);
#user.choptest(b,100:lng,base);
#
function user.main():void;              #  0 main:void := user.main() {G}
# analyse the overhead of chopping a table 
# the multiplex code blocks. 
    b := bat.new(:oid,:lng);            #  3 b:bat[:oid,:lng] := CMDBATnew(_4:oid, _5:lng) {G}
barrier (go,i):= language.newRange(0:lng);#  4 (go:bit, i:lng) := RNGnewRange_lng(_8:lng) {J9}
    k := mmath.rand();                  #  5 k:int := MATHrandint() 
    l := calc.lng(k);                   #  6 l:lng := CALCint2lng(k:int) 
    bat.insert(b,nil:oid,l);            #  7 _11:void := BKCinsert_bun(b:bat[:oid,:lng], _12:oid, l:lng) 
    redo (go,i):= language.nextElement(1:lng,1000000:lng);#  8 (go:bit, i:lng) := RNGnextElement_lng(_13:lng, _14:lng) {J5}
exit (go,i);                            #  9 (go:bit, i:lng) 
    t0 := alarm.usec();                 # 10 t0:lng := ALARMusec() 
barrier doit := true;                   # 11 doit:bit := _17:bit {J13}
    t := algebra.select(b,256000:lng,266000:lng);# 12 t:bat[:oid,:lng] := ALGselect(b:bat[:oid,:lng], _19:lng, _20:lng) {G}
exit doit;                              # 13 doit:bit 
    t1 := alarm.usec();                 # 14 t1:lng := ALARMusec() 
    base := calc.-(t1,t0);              # 15 base:lng := CALCbinarySUBlnglng(t1:lng, t0:lng) 
    io.printf("#select direct %d usec\n",base);# 16 _23:void := IOprint_formatted_lng(_24:str, base:lng) 
    user.choptest(b,100000:lng,base);   # 17 _25:void := user.choptest(b:bat[:oid,:lng], _26:lng, base:lng) 
    user.choptest(b,10000:lng,base);    # 18 _27:void := user.choptest(b:bat[:oid,:lng], _28:lng, base:lng) 
    user.choptest(b,1000:lng,base);     # 19 _29:void := user.choptest(b:bat[:oid,:lng], _30:lng, base:lng) 
    user.choptest(b,100:lng,base);      # 20 _31:void := user.choptest(b:bat[:oid,:lng], _32:lng, base:lng) 
end main;	# 21  
#select direct 7337 usec
[ "#factory done\n" ]
#chopped at 100000 at 850.000000 usec
[ "#factory done\n" ]
#chopped at 10000 at 99.680000 usec
[ "#factory done\n" ]
#chopped at 1000 at 15.923000 usec
[ "#factory done\n" ]
#chopped at 100 at 8.049500 usec

# 08:01:42 >  
# 08:01:42 >  Done.
# 08:01:42 >  

