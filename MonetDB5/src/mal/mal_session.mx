@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@a M. Kersten
@v 0.0
@- Server Bootstrapping

The MonetDB server uses a startup script to boot the system.
This script is an ordinary MAL program, but will mostly
consist of include statements to load modules of general interest.
The startup script is ran as user Admin.
Its location is described in Monet configuration file.
The default location is:  !!!###%%% TODO %%%###!!!

It may overwritten using a command line argument.

@{
@h
#ifndef _MAL_SESSION_H
#define _MAL_SESSION_H

#include "mal_scenario.h"

mal_export int malBootstrap(void);
mal_export void MSserveClient(void *dummy);
mal_export void MSinitClientPrg(Client cntxt, str nme);
mal_export void MSscheduleClient(str command, str challenge, bstream *fin, stream *fout);

mal_export str MALreader(Client c);
mal_export str MALexitClient(Client c);
mal_export str MALparser(Client c);
mal_export str MALengine(Client c);
mal_export void MSresetInstructions(MalBlkPtr mb, int start);
mal_export void MSresetVariables(MalBlkPtr mb, MalStkPtr glb, int start);
mal_export int MALcommentsOnly(MalBlkPtr mb);

#endif /*  _MAL_SESSION_H */

@c
#include "mal_session.h"
#include "mal_instruction.h"	/* for pushEndInstruction() */
#include "mal_interpreter.h"	/* for showErrors(), runMAL(), garbageElement(), garbageCollector() */
#include "mal_linker.h"		/* for initLibraries() */
#include "mal_parser.h"		/* for parseMAL() */
#include "mal_namespace.h"
#include "mal_readline.h"
#include "mal_authorize.h"
/* FIXME: doesn't work unfortunately
#include <status.h> */	/* for SYSgetDatabases(), SYSgetPorts() */

mal_export str SYSgetDatabases(int *ret);
mal_export str SYSgetPorts(int *ret, str *lang);

int
malBootstrap()
{
	Client c;
	str bootfile = "mal_init", bf;

	c = MCinitClient((oid)0, 0, 0);
	c->nspace = newModule(NULL, putName("user", 4));
	initLibraries();
	if (defaultScenario(c)) {
		GDKfatal("Failed to initialise default scenario");
		return 0;
	}
	bf = GDKgetenv("mal_bootstrap");
	if (bf)
		bootfile = bf;
	malInclude(c, bootfile, 0, 0);
	mal_scope = c->nspace;
	showErrors();
	return 1;
}

@+ Client main routine
Every client has a 'main' function to collect the statements.
Once the END instruction has been found, it is added to the
symbol table and a fresh container is being constructed.
Note, this scheme makes testing for recursive function calls a
little more difficult. Therefore, type checking should be performed
afterwards.

In interactive mode,  the closing statement is never reached.
The 'main' procedure is typically cleaned between successive external
messages except for its variables, which are considerd global.
This storage container is re-used when during the previous call
nothing was added.
At the end of the session we have to garbage collect the BATs
introduced.
@c

void
MSinitClientPrg(Client cntxt, str nme)
{
	InstrPtr p;
	MalBlkPtr mb;
	int i, cnt = 1;

	if (cntxt->curprg && idcmp(nme, cntxt->curprg->name) == 0) {
		mb = cntxt->curprg->def;
		for (i = 1; i < mb->stop; i++)
			if (mb->stmt[i]->token == REMsymbol)
				cnt++;
		if (mb->stop <= cnt + 1) {	/* complete comments */
			mb->typefixed = 0;
			mb->flowfixed = 0;
/* use instruction pools
			for (i--; i > 1; i--)
				freeInstruction(mb->stmt[i]);
*/

			mb->stop = 1;
			cntxt->glb = 0;
			return;
		}
	}
	cntxt->curprg = newFunction(putName(nme, strlen(nme)), FUNCTIONsymbol);
	mb = cntxt->curprg->def;
	p = getSignature(cntxt->curprg);
	setModuleScope(p, cntxt->nspace);
	setVarType(mb, findVariable(mb, nme), TYPE_void);
	insertSymbol(cntxt->nspace, cntxt->curprg);
	cntxt->glb = 0;
	assert(cntxt->curprg->def != NULL);
}

@}
@+ Client authorization
The default method to interact with the database server is to
connect using a port number. The first line received should contain
authorization information, such as user name and a possible session key.

No encryption scheme is performed yet.

An example initialization string would be "guest:23" which indicates access
of the client named 'guest' to a session previously started under identity 23.

@{
The scheduleClient receives a challenge response consisting of
user:password:lang:blocked:database.
@c
void
MSscheduleClient(str command, str challenge, bstream *fin, stream *fout)
{
	char *user = command, *algo = NULL, *passwd = NULL, *lang = NULL;
	char *database = NULL, *s;
	int key = 0;
	Client c;
	MT_Id p;

	/* decode first user:password:lang:blocked:database line */
	s = strchr(command, '\n');
	if (s)
		*s = 0;
	
	/* passwd */
	s = strchr(user, ':');
	if (s) {
		*s = 0;
		passwd = s + 1;
		/* decode algorithm, i.e. {plain}mypasswordchallenge */
		if (*passwd != '{') {
			stream_printf(fout, "!invalid password entry\n");
			stream_flush(fout);
			return;
		}
		algo = passwd + 1;
		s = strchr(algo, '}');
		if (!s) {
			stream_printf(fout, "!invalid password entry\n");
			stream_flush(fout);
			return;
		}
		*s = 0;
		passwd = s + 1;
	} else {
		stream_printf(fout, "!incomplete challenge '%s'\n", user);
		stream_flush(fout);
		return;
	}

	/* lang */
	s = strchr(passwd, ':');
	if (s) {
		*s = 0;
		lang = s + 1;
	} else {
		stream_printf(fout, "!incomplete challenge, missing language\n");
		stream_flush(fout);
		return;
	}

	/* blocked or not (we don't care here) */
	s = strchr(lang, ':');
	if (s) {
		*s = 0;
		database = s + 1;
	} else {
		stream_printf(fout, "!incomplete challenge, missing database\n");
		stream_flush(fout);
		return;
	}

	/* database */
	s = strchr(database, ':');
	if (s) {
		*s = 0;
		database = s + 1;
	} else {
		/* reset database variable, which we misused above, don't error,
		   as database is optional */
		database = NULL;
	}

	if (database && strcmp(database, GDKgetenv("gdk_dbname")) != 0) {
		BAT *b = NULL;
		BUN p, q;
		int bid = 0;
		str err = NULL, db = NULL, state = NULL;
		int found = 0;
		
		if ((err = SYSgetDatabases(&bid)) != NULL) {
			GDKerror(err);
			return;
		}

		if ((b = BATdescriptor(bid)) == NULL) {
			GDKerror("Cannot access BAT descriptor");
			return;
		}

		/* tell the BBP to leave this BAT alone: it's ours! */
		BBPfix(b->batCacheid);

		BATloop(b, p, q) {
			db    = BUNhead(b, p);
			state = BUNtail(b, p);

			/* match name of database */
			if (db && strcmp(db, database) == 0) {
				found = 1;
				break;
			}
		}

		if (!found) {
			stream_printf(fout, "!database '%s' does not exist\n", database);
		} else if (found && strcmp(state, "running") != 0) {
			stream_printf(fout, "!database '%s' currently unavailable\n", database);
		} else {
			/* ok, it appears to be running, now let's see if it also is
			   serving on a port */
			int port = 0;
			/* the BBP can have the database BAT back, we don't want it
			   any more */
			BBPunfix(b->batCacheid);

			/* take default language (mal), as language doesn't really
			   make sense with M5 anyway */
			if ((err = SYSgetPorts(&bid, NULL)) != NULL) {
				GDKerror(err);
				return;
			}

			if ((b = BATdescriptor(bid)) == NULL) {
				GDKerror("Cannot access BAT descriptor");
				return;
			}

			/* tell the BBP to leave this BAT alone: it's ours! */
			BBPfix(b->batCacheid);

			/* get the port number */
			BATloop(b, p, q) {
				db   = BUNhead(b, p);
				port = *(int *)BUNtail(b, p);

				/* match name of database */
				if (db && strcmp(db, database) == 0) {
					found = 1;
					break;
				}
			}
			if (port != int_nil) {
				/* hostname currently hardcoded... */
				stream_printf(fout, "^mapi:monetdb://%s:%d/%s?lang=%s&user=%s\n", "localhost", port, database, lang, user);
			} else {
				stream_printf(fout, "!database '%s' appears not to be ready\n", database);
			}
		}

		/* the BBP can have it back, we don't want it any more */
		BBPunfix(b->batCacheid);

		/* flush the error to the client, and abort further execution */
		stream_flush(fout);
		GDKfree(command);
		return;
	} else {
		str err;
		oid uid;

		/* access control: verify the credentials supplied by the user,
		 * no need to check for database stuff, because that is done per
		 * database itself (one gets a redirect) */
		err = AUTHcheckCredentials(&uid, &user, &passwd, &challenge, &algo, &lang);
		if (err != MAL_SUCCEED) {
			stream_printf(fout, "!%s\n", err);
			stream_flush(fout);
			GDKfree(command);
			return;
		}

		c = MCinitClient(uid, fin, fout);
		c->nspace = newModule(NULL, putName("user", 4));
		c->nspace->outer = mal_scope;
		c->sessionkey = key;

		if (!lang) {
			if ((s = defaultScenario(c))) {
				stream_printf(c->fdout, "!%s\n", s);
				stream_flush(c->fdout);
				c->mode = FINISHING;
			}
		} else if ((s = setScenario(c, lang)) != NULL) {
			stream_printf(c->fdout, "!%s\n", s);
			stream_flush(c->fdout);
			c->mode = FINISHING;
		}
	}

	MSinitClientPrg(c, "main");

	GDKfree(command);
	if (MT_create_thread(&p, MSserveClient, (void *) c) < 0) {
		GDKerror("initClient: can not fork new client\n");
		return;
	}
}

@+ Client services
After the client initialization has been finished, we
can start the interaction protocol. This involves parsing the
input in the context of an already defined procedure and upon
success, its execution.

In essence, this calls for an incremental parsing operation, 
because we should wait until a complete basic block has been detected.
Test, first collect the instructions before we take them all.
@-
In interactive mode, we should remove the instructions before
accepting new ones. The function signature remains the same
and the symbol table should also not be affected.
Aside from removing instruction, we should also condense the
variable stack, i.e. removing at least the temporary variables,
but maybe everything beyond a previous defined pont.

Beware that we have to cleanup the global stack as well. This to avoid
subsequent calls to find garbage information.
However, this action is only required after a successful execution.
Otherwise, garbage collection is not needed.
@c
void
MSresetInstructions(MalBlkPtr mb, int start)
{
	int i;
	InstrPtr p;

	for (i = start; i < mb->stop; i++) {
		p = getInstrPtr(mb, i);
		if (p)
			freeInstruction(p);
		mb->stmt[i] = NULL;
	}
	mb->stop = start;
}

void
MSresetVariables(MalBlkPtr mb, MalStkPtr glb, int start)
{
	int i, j;

	for (i = j = start; i < mb->vtop;) {
		if (isTmpVar(mb, i)) {
			clearVariable(mb, i);

			if (glb) {
				garbageElement(&glb->stk[i]);
				/* clean stack entry */
				glb->stk[i].vtype = TYPE_int;
				glb->stk[i].val.ival = 0;
				glb->stk[i].len = 0;
			}
			i++;
		} else {
			if (i != j) {
				VarPtr v= getVar(mb,j);
				mb->var[j]= mb->var[i];
				getVar(mb,i)= v;
				if (glb) {
					/* save stack state */
					glb->stk[j] = glb->stk[i];
					/* clean stack entry */
					glb->stk[i].vtype = TYPE_int;
					glb->stk[i].val.ival = 0;
					glb->stk[i].len = 0;
				}
			}
			i++;
			j++;
		}
	}
	mb->vtop = j;
}

@-
Here we start the first client. We need to initialize
the corresponding thread and allocate space for the 
global variables. Thereafter it is up to the scenario
interpreter to process input.
@c
void
MSserveClient(void *dummy)
{
	MalBlkPtr mb;
	Client c = (Client) dummy;
	str msg = 0;

	if (!isAdministrator(c))
		MCinitClientThread(c);
@-
A stack frame is initialized to keep track of global variables.
The scenarios are run until we finally close the last one.
@c
	mb = c->curprg->def;
	c->glb = newGlobalStack(MAXGLOBALS + mb->vsize);
	c->glb->stktop = mb->vtop;
	c->glb->blk = mb;

	if (c->scenario == 0)
		msg = defaultScenario(c);
	if (msg) {
		GDKerror("could not initialize default scenario\n");
		c->mode = FINISHING + 1;
	} else
		do {
			runScenario(c);
			if (c->mode == FINISHING)
				break;
			resetScenario(c);
		} while (c->scenario);
@-
At this stage we should clean out the MAL block
@c
	freeMalBlk(c->curprg->def);
	c->curprg->def= 0;

	if (c->mode > FINISHING) {
		if (isAdministrator(c)) {
			/* old OIDflushdelta =0; */
			if (c->scenario) {
				exitScenario(c);
			}
		}
	}
	if (!isAdministrator(c))
		MCcloseClient(c);
}

@+ MAL scenario components
The stages of processing user requests are controlled by a
scenario. The routines below are the default implementation.
The main issues to deal after parsing it to clean out the
Admin.main function from any information added erroneously.

Ideally this involves resetting the state of the client
'main' function, i.e. the symbol table is reset and any
instruction added should be cleaned. Beware that the instruction
table may have grown in size.

@= restoreState
	if( c->listing) 
		printFunction(c->fdout,c->curprg->def, c->listing);
	resetMalBlk(c->curprg->def,oldstate.stop);
/*
	MSresetInstructions(c->curprg->def, oldstate.stop);
*/
	MSresetVariables(c->curprg->def, 0, oldstate.vtop);
@c
str
MALexitClient(Client c)
{
	if (c->glb) {
		garbageCollectAll(c->curprg->def, c->glb);
		GDKfree(c->glb);
	}
	c->glb = 0;
	return 0;
}

str
MALreader(Client c)
{
	int r= 1;

	c->fdin->pos += c->yycur;
	c->yycur = 0;
	c->fdin->buf[c->fdin->pos] = 0;

	if( c == mal_clients){
		r= readConsole(c);
		if (r <0 && c->fdin->eof == 0 )
			r= MCreadClient(c);
		if( r > 0)
			return MAL_SUCCEED;
	} else
	if (MCreadClient(c) > 0)
		return MAL_SUCCEED;
	c->mode = FINISHING;
	if (c->fdin)
		c->fdin->buf[c->fdin->pos] = 0;
	else
		return throwMessage("MAL.reader", "Attempt to read beyond eof");
	return MAL_SUCCEED;
}

str
MALparser(Client c)
{
	InstrPtr p;
	MalBlkRecord oldstate;

	c->curprg->def->errors = 0;
	oldstate = *c->curprg->def;

	prepareMalBlk(c->curprg->def, CURRENT(c));
	if (parseMAL(c, c->curprg) || c->curprg->def->errors) {
		/* just complete it for visibility */
		pushEndInstruction(c->curprg->def);
		/* catched errors */
		showErrors();
		@:restoreState@
		return throwMessage("MAL.parser", "Syntax errors detected");
	}
	/* check for unfinished blocks */
	if (c->blkmode)
		return MAL_SUCCEED;
	/* empty files should be skipped as well */
	if (c->curprg->def->stop == 1)
		return MAL_SUCCEED;

	p = getInstrPtr(c->curprg->def, 0);
	if (p->token != FUNCTIONsymbol) {
		@:restoreState@
		return throwMessage("MAL.parser", "Function signature missing");
	}
	pushEndInstruction(c->curprg->def);
	trimMalBlk(c->curprg->def);
	chkProgram(c->nspace, c->curprg->def);
	if (c->curprg->def->errors) {
		showErrors();
		@:restoreState@
		return throwMessage("MAL.parser", "Semantic errors detected");
	}
	return MAL_SUCCEED;
}

int
MALcommentsOnly(MalBlkPtr mb)
{
	int i;

	for (i = 1; i < mb->stop; i++)
		if (mb->stmt[i]->token != REMsymbol)
			return 0;
	return 1;
}

str
MALengine(Client c)
{
	Symbol prg;
	str msg = 0;
	MalBlkRecord oldstate;

	oldstate.stop = 0;
	oldstate.vtop = 0;

	if( c->blkmode)
		return MAL_SUCCEED;
	prg = c->curprg;
	if (prg == NULL)
		return throwMessage("MAL.engine", "Main MAL function missing");

	if (prg->def->errors > 0) {
		showErrors();
		@:restoreState@
		return throwMessage("MAL.engine", "Program contains errors");
	}
	if (prg->def->stop == 1 || MALcommentsOnly(prg->def))
		return 0;	/* empty block */
	if (c->glb) {
		if (prg->def && c->glb->stksize < prg->def->vsize)
			c->glb = reallocGlobalStack(c->glb, prg->def->vsize);
		c->glb->stktop = prg->def->vtop;
		c->glb->blk = prg->def;
		c->glb->cmd = (c->itrace && c->itrace != 'C') ? 'n' : 0;
	}

	if (c->listing)
		printFunction(c->fdout, c->curprg->def, c->listing);

	if (c->glb)
		c->glb->pcup = 0;
	if (prg->def->errors == 0)
		msg = (str) runMAL(c, prg->def, 1, 0, c->glb, 0);
	else
		msg = MAL_SUCCEED;
	if (msg) {
		GDKerror(msg);
		if (!c->listing)
			printFunction(c->fdout, c->curprg->def, c->listing);
		showErrors();
	}
	resetMalBlk(prg->def,1);
	MSresetVariables(prg->def, c->glb, 0);
	prg->def->errors = 0;
	return msg;
}

/* copied over from modules/kernel/status */
@= Pseudo
        if (BBPindex("view_@1_@2") <= 0)
                BATname(b, "@2");
        BATroles(b,"@1","@2");
        BATmode(b,TRANSIENT);
        BATfakeCommit(b);
        *ret = b->batCacheid;
@c
#include <dirent.h>
str SYSgetDatabases(int *ret)
{
	BAT *b;
	DIR *d, *db;
	struct dirent *e;
	char buf[PATHLENGTH];
	FILE *f;
	int uid,pid;
	
	b = BATnew(TYPE_str, TYPE_str, 50);
	/* scan the parent for directories */
	d= opendir("..");
	while ( (e=readdir(d)) != NULL){
		if( *e->d_name == '.') continue;
		snprintf(buf,PATHLENGTH,"../%s",e->d_name);
		db= opendir(buf);
		if( db != NULL) {
			snprintf(buf,PATHLENGTH,"../%s/.gdk_lock",e->d_name);
			f= fopen(buf,"r");
			if( f  && fgets(buf,PATHLENGTH,f) != NULL){
				sscanf(buf,"USR=%d PID=%d %s", &uid,&pid,buf);
				/* w00t! for platform independence! (NOT!) */
				snprintf(buf,PATHLENGTH,"/proc/%d",pid);
				fclose(f);
			} else
				snprintf(buf,PATHLENGTH,"../%s/.mguardian.pid",e->d_name);
			/* not water-proof, PID can exist, and be alive, but not an
			   mserver, need to check process name */
			BUNins(b,e->d_name,(access(buf,F_OK)?"sleeping":"running"), FALSE);
			closedir(db);
		} 
	}
	(void) closedir(d);
	@:Pseudo(databases,mode)@
	return MAL_SUCCEED;
}

str SYSgetPorts(int *ret, str *lang)
{
	BAT *b;
	DIR *d, *db;
	struct dirent *e;
	char buf[PATHLENGTH];
	FILE *f;
	int port;
	str llang;
	
	/* if lang is NULL, default to "mal" */
	llang = (lang == NULL ? "mal" : *lang);
	b = BATnew(TYPE_str, TYPE_int, 50);
	/* scan the parent for directories */
	d= opendir("..");
	while ( (e=readdir(d)) != NULL){
		if( *e->d_name == '.') continue;
		snprintf(buf,PATHLENGTH,"../%s",e->d_name);
		db= opendir(buf);
		if( db != NULL) {
			snprintf(buf,PATHLENGTH,"../%s/.%s.port",e->d_name,llang);
			f= fopen(buf,"r");
			if( f  && fgets(buf,PATHLENGTH,f) != NULL){
				port= (int) strtol(buf,NULL,10);
				fclose(f);
			} else port = 0;
			BUNins(b, e->d_name, (ptr)(port==0? &int_nil: &port), FALSE);
			closedir(db);
		} 
	}
	(void) closedir(d);
	@:Pseudo(databases,port)@
	return MAL_SUCCEED;
}
@}
