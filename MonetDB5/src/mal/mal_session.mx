@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@a M. Kersten
@v 0.0
@- Server Bootstrapping

The MonetDB server uses a startup script to boot the system.
This script is an ordinary MAL program, but will mostly
consist of include statements to load modules of general interest.
The startup script is ran as user Admin.
Its location is described in Monet configuration file.
The default location is:

It may overwritten using a command line argument.

@{
@h
#ifndef _MAL_SESSION_H
#define _MAL_SESSION_H

#include "mal_scenario.h"

mal_export int malBootstrap();
mal_export void serveClient(void *dummy);
mal_export void initClientPrg(Client cntxt, str nme);
mal_export void scheduleClient(str command, bstream *fin, stream *fout);

mal_export str MALreader(Client c);
mal_export str MALexitClient(Client c);
mal_export str MALparser(Client c);
mal_export str MALengine(Client c);
mal_export void resetInstructions(MalBlkPtr mb, int start);
mal_export void resetVariables(MalBlkPtr mb, MalStkPtr glb, int start);

#endif /*  _MAL_SESSION_H */

@c
#include "mal_session.h"
#include "mal_instruction.h"	/* for pushEndInstruction() */
#include "mal_interpreter.h"	/* for showErrors(), runMAL(), garbageElement(), garbageCollector() */
#include "mal_linker.h"		/* for initLibraries() */
#include "mal_parser.h"		/* for parseMAL() */
#include "mal_namespace.h"

int
malBootstrap()
{
	Client c;
	str bootfile = "mal_init", bf;

	c = initClient(GDKstrdup("user"), NULL, 0, 0);
	c->nspace = newModule(NULL, putName("user", 5));
	initLibraries();
	if (defaultScenario(c))
		return 0;
	bf = GDKgetenv("mal_bootstrap");
	if (bf)
		bootfile = bf;
	malInclude(c, bootfile, 0, 0);
	mal_scope = c->nspace;
	showErrors();
	return 1;
}

@+ Client main routine
Every client has a 'main' function to collect the statements.
Once the END instruction has been found, it is added to the
symbol table and a fresh container is being constructed.
Note, this scheme makes testing for recursive function calls a
little more difficult. Therefore, type checking should be performed
afterwards.

In interactive mode,  the closing statement is never reached.
The 'main' procedure is typically cleaned between successive external
messages except for its variables, which are considerd global.
This storage container is re-used when during the previous call
nothing was added.
At the end of the session we have to garbage collect the BATs
introduced.
@c

void
initClientPrg(Client cntxt, str nme)
{
	InstrPtr p;
	MalBlkPtr mb;
	int i, cnt = 1;

	if (cntxt->curprg && idcmp(nme, cntxt->curprg->name) == 0) {
		mb = cntxt->curprg->def;
		for (i = 1; i < mb->stop; i++)
			if (mb->stmt[i]->token == REMsymbol)
				cnt++;
		if (mb->stop <= cnt + 1) {	/* complete comments */
			mb->typefixed = 0;
			mb->flowfixed = 0;
			for (i--; i > 1; i--)
				freeInstruction(mb->stmt[i]);

			mb->stop = 1;
			cntxt->glb = 0;
			return;
		}
	}
	cntxt->curprg = newFunction(putName(nme, strlen(nme)), FUNCTIONsymbol);
	mb = cntxt->curprg->def;
	p = getSignature(cntxt->curprg);
	setModuleScope(p, cntxt->nspace);
	setVarType(mb, findVariable(mb, nme), TYPE_int);
	insertSymbol(cntxt->nspace, cntxt->curprg);
	cntxt->glb = 0;
}

@}
@+ Client authorization
The default method to interact with the database server is to
connect using a port number. The first line received should contain
authorization information, such as user name and a possible session key.

No encryption scheme is performed yet.

An example initialization string would be "guest:23" which indicates access
of the client named 'guest' to a session previously started under identity 23.

@{
The scheduleClient receives a single block from the API.
The first line should represent a user. The remainder may
be a request to be handled. This way, a single message
can be used to issue a short (<8192byte,=BLOCK) transaction.
@c
void
scheduleClient(str command, bstream *fin, stream *fout)
{
	char *user = command, *passwd = NULL, *lang = NULL, *s;
	int key = 0;
	Client c;
	MT_Id p;

	/* decode first user:password:lang line */
	s = strchr(command, '\n');
	if (s)
		*s = 0;
	s = strrchr(command, ':');
	if (s) {
		*s = 0;
		lang = s + 1;
	}

	s = strchr(command, ':');
	if (s) {
		*s = 0;
		passwd = s + 1;
	}

	s = strchr(user, ':');
	if (s && *s) {
		*s = 0;
		s++;
		s = strchr(s, ':');
		if (s) {
			key = atol(s + 1);
		}
	}
	s = strchr(user, '\n');
	if (s)
		*s = 0;
	c = initClient(GDKstrdup(user), passwd, fin, fout);
	if (c->nspace) {
		GDKfree(c->nspace->name);
		c->nspace->name = GDKstrdup(user);
	} else {
		c->nspace = newModule(NULL, putName(user, strlen(user)));
		c->nspace->outer = mal_scope;
	}

	c->nspace->outer = mal_scope;
	c->sessionkey = key;

	if (!lang) {
		if ((s = defaultScenario(c))) {
			stream_printf(c->fdout, "!%s\n", s);
			stream_flush(c->fdout);
			return;
		}
	} else if ((s = setScenario(c, lang)) != NULL) {
		stream_printf(c->fdout, "!%s\n", s);
		stream_flush(c->fdout);
		return;
	}
	initClientPrg(c, "main");
	if (!isAdministrator(c))
		stream_printf(c->fdout, "%s\n", GDKgetenv("gdk_version"));

	GDKfree(command);
	if (MT_create_thread(&p, serveClient, (void *) c) < 0) {
		GDKerror("initClient: can not fork new client\n");
		return;
	}
}

@+ Client services
After the client initialization has been finished, we
can start the interaction protocol. This involves parsing the
input in the context of an already defined procedure and upon
success, its execution.

In essence, this calls for an incremental parsing operation, 
because we should wait until a complete basic block has been detected.
Test, first collect the instructions before we take them all.
@-
In interactive mode, we should remove the instructions before
accepting new ones. The function signature remains the same
and the symbol table should also not be affected.
Aside from removing instruction, we should also condense the
variable stack, i.e. removing at least the temporary variables,
but maybe everything beyond a previous defined pont.

Beware that we have to cleanup the global stack as well. This to avoid
subsequent calls to find garbage information.
However, this action is only required after a successful execution.
Otherwise, garbage collection is not needed.
@c
void
resetInstructions(MalBlkPtr mb, int start)
{
	int i;
	InstrPtr p;

	for (i = start; i < mb->stop; i++) {
		p = getInstrPtr(mb, i);
		if (p)
			freeInstruction(p);
		mb->stmt[i] = NULL;
	}
	mb->stop = start;
}

void
resetVariables(MalBlkPtr mb, MalStkPtr glb, int start)
{
	int i, j;

	for (i = j = start; i < mb->vtop;) {
		if (isTmpVar(mb, i)) {
			freeVariable(mb, i);
			mb->var[i] = 0;

			if (glb) {
				garbageElement(&glb->stk[i]);
				/* clean stack entry */
				glb->stk[i].vtype = TYPE_int;
				glb->stk[i].val.ival = 0;
				glb->stk[i].len = 0;
			}
			i++;
		} else {
			if (i != j) {
				copyVar(mb, j, i);
				if (glb) {
					/* save stack state */
					glb->stk[j] = glb->stk[i];
					/* clean stack entry */
					glb->stk[i].vtype = TYPE_int;
					glb->stk[i].val.ival = 0;
					glb->stk[i].len = 0;
				}
			}
			i++;
			j++;
		}

	}
	mb->vtop = j;
}

@-
Here we start the first client. We need to initialize
the corresponding thread and allocate space for the 
global variables. Thereafter it is up to the scenario
interpreter to process input.
@c
void
serveClient(void *dummy)
{
	MalBlkPtr mb;
	Client c = (Client) dummy;
	str msg = 0;

	if (!isAdministrator(c))
		initClientThread(c);
@-
A stack frame is initialized to keep track of global variables.
The scenarios are run until we finally close the last one.
@c
	mb = c->curprg->def;
	c->glb = newGlobalStack(MAXGLOBALS + mb->vsize);
	c->glb->stktop = mb->vtop;
	c->glb->blk = mb;

	if (c->scenario == 0)
		msg = defaultScenario(c);
	if (msg) {
		GDKerror("could not initialize default scenario\n");
		c->mode = FINISHING + 1;
	} else
		do {
			runScenario(c);
			if (c->mode == FINISHING)
				break;
			resetScenario(c);
		} while (c->scenario);

	if (c->mode > FINISHING) {
		if (isAdministrator(c)) {
			/* old OIDflushdelta =0; */
			if (c->scenario) {
				exitScenario(c);
			}
			TMcommit();
		}
	}
	if (!isAdministrator(c))
		closeClient(c);
}

@+ MAL scenario components
The stages of processing user requests are controlled by a
scenario. The routines below are the default implementation.
The main issues to deal after parsing it to clean out the
Admin.main function from any information added erroneously.

Ideally this involves resetting the state of the client
'main' function, i.e. the symbol table is reset and any
instruction added should be cleaned. Beware that the instruction
table may have grown in size.

@= restoreState
	if( c->listing) 
		printFunction(c->fdout,c->curprg->def, c->listing);
	resetInstructions(c->curprg->def, oldstate.stop);
	resetVariables(c->curprg->def, 0, oldstate.vtop);
@c
str
MALexitClient(Client c)
{
	if (c->glb) {
		garbageCollectAll(c->curprg->def, c->glb);
		GDKfree(c->glb);
	}
	c->glb = 0;
	return 0;
}

str
MALreader(Client c)
{
	int r= 1;

	c->fdin->pos += c->yycur;
	c->yycur = 0;
	c->fdin->buf[c->fdin->pos] = 0;

	if( c == mal_clients){
		r= readConsole(c);
		if (r <0 && c->fdin->eof == 0 )
			r= readClient(c);
		if( r > 0)
			return 0;
	} else
	if (readClient(c) > 0)
		return 0;
	c->mode = FINISHING;
	if (c->fdin)
		c->fdin->buf[c->fdin->pos] = 0;
	else
		return throwMessage("MALreader", "Attempt to read beyond eof");
	return MAL_SUCCEED;
}

str
MALparser(Client c)
{
	InstrPtr p;
	MalBlkRecord oldstate;

	c->curprg->def->errors = 0;
	oldstate = *c->curprg->def;

	prepareMalBlk(c->curprg->def, CURRENT(c));
	if (parseMAL(c, c->curprg) || c->curprg->def->errors) {
		/* just complete it for visibility */
		pushEndInstruction(c->curprg->def);
		/* catched errors */
		showErrors();
		@:restoreState@
		return throwMessage("MALparser", "syntax errors\n");
	}
	/* check for unfinished blocks */
	if (c->blkmode)
		return 0;
	/* empty files should be skipped as well */
	if (c->curprg->def->stop == 1)
		return 0;

	p = getInstrPtr(c->curprg->def, 0);
	if (p->token != FUNCTIONsymbol) {
		@:restoreState@
		return throwMessage("MALparser", "function signature missing\n");
	}
	pushEndInstruction(c->curprg->def);
	trimMalBlk(c->curprg->def);
	chkProgram(c->nspace, c->curprg->def);
	if (c->curprg->def->errors) {
		showErrors();
		@:restoreState@
		return throwMessage("MALparser", "semantic errors\n");
	}
	return 0;
}

int
MALcommentsOnly(MalBlkPtr mb)
{
	int i;

	for (i = 1; i < mb->stop; i++)
		if (mb->stmt[i]->token != REMsymbol)
			return 0;
	return 1;
}

str
MALengine(Client c)
{
	Symbol prg;
	str msg = 0;
	MalBlkRecord oldstate;

	oldstate.stop = 0;
	oldstate.vtop = 0;

	/* check for unfinished blocks */
	if (c->blkmode)
		return throwMessage("MALengine", "block not finished\n");
	prg = c->curprg;
	if (prg == NULL)
		return throwMessage("MALengine", "main function missing\n");

	if (prg->def->errors > 0) {
		showErrors();
		@:restoreState@
		return throwMessage("MALengine", "Program contains errors\n");
	}
	if (prg->def->stop == 1 || MALcommentsOnly(prg->def))
		return 0;	/* empty block */
	if (c->glb) {
		if (prg->def && c->glb->stksize < prg->def->vsize)
			c->glb = reallocGlobalStack(c->glb, prg->def->vsize);
		c->glb->stktop = prg->def->vtop;
		c->glb->blk = prg->def;
		c->glb->cmd = c->itrace ? 'n' : 0;
	}

	if (c->listing)
		printFunction(c->fdout, c->curprg->def, c->listing);

	if (c->glb)
		c->glb->pcup = 0;
	if (prg->def->errors == 0)
		msg = (str) runMAL(c, prg->def, 1, 0, c->glb, 0);
	else
		msg = MAL_SUCCEED;
	if (msg) {
		GDKerror(msg);
		if (!c->listing)
			printFunction(c->fdout, c->curprg->def, c->listing);
		showErrors();
	}
	resetInstructions(prg->def, 1);
	resetVariables(prg->def, c->glb, 0);
	prg->def->errors = 0;
	return msg;
}
@}
