@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.

@a M. Kersten
@v 1.0
@* Monet Assembler Language
The primary textual interface to the Monet kernel
is a simple, assembler-like language, called MAL. 
The language reflects the virtual machine architecture around the
kernel libraries and has been designed for speed of parsing,
ease of analysis, and ease of target compilation by query compilers.
The language is not meant as a primary programming language,
or scripting language. Such use is even discouraged.

Furthermore, a MAL program is considered a specification
of intended computation and data flow behavior. It should be
understood that its actual evaluation depends on the execution
paradigm chosen in the scenario. The program blocks can both
be interpreted as ordered sequences of assembler instructions,
as a representation of a data-flow graph that should be resolved.

The language uses a slightly different keyword connotation 
from programming language arena to make this distinction more evident.
In particular, flow of control keywords identify a point to chance
the interpretation order or denote a synchronization point.

The first statement of a MAL block is always taken up by a signature
description. (See functions)

@+ MAL instructions
MAL instructions have a simple format. 
Each instruction denotes a data-flow statement.
It is syntactically represented by an assignment, where
an expression (function call) delivers results to multiple target variables. 
Input variables changed in the process preferably also appear in
the target list, i.e. the instruction models the input/output flow.
This greatly simplifies future optimization decisions.

Variables are implicitly defined upon first use and take
on a type through a type classifier or inherit it from
the context in which they are used. 

Omission of target variables is allowed. Then the compiler
merely assigns temporary variables to hold the result of
the expression. They act as data sinks in the flow graph.

For parsing simplicity, each instruction fits on a single line.
Comment starts with a sharp '#' and continues to the end of the line.

Built-in operators adhere to the conventional syntax
as pre-, post-, and infix notations. They are translated
during parsing to the generic form.

The assignment patterns recognized are illustrated below.
@T
\begin{verbatim}
(t1,..,t32) := module.fcn(a1,..,a32);
t1 := module.fcn(a1,..,a32);
t1 := fcn(a1,..,a32);
t1 := v1 operator v2;
t1 := constant;
(t1,..,tn) := (c1,..,cn);
\end{verbatim}

Each operator is defined in a (user-defined) module.
Using the module name speeds-up the binding, but its use is optional.
Omission of the module name initiates a search for a possible
matching definition in a hierarchical ordered scope
structure. (See modules inheritance)

Variables and literal constants can be tagged with a type
qualifier. The literal value should fit the domain of the
type identified, e.g. 4:lng is valid, but "xyz":int raises an
error. [TODO]

Query languages like SQL are commonly mapped to an algebraic 
operator model. In our case, even simple SQL queries generate
a long sequence of MAL instructions.
They form a compact representation of 
both the administrative actions to ensure binding and transaction
control, the flow dependencies to produce the query result,
and the steps needed to prepare the result set for delivery to
the front-end.

Only when the algebraic structure is too limited (e.g. updates),
or the database back-end lacks feasible bulk operators,
one has to rely on more detailed flow of control primitives.
But even in that case, the basic blocks to be processed
by a MAL back-end are considered large, e.g. tens of simple
bulk assignment instructions.

@- Flow of control
@T
An assignment statement is turned into a flow of control statement
by tagging it with a control modifier.
The primary control flow modifiers are {\tt return} and {\tt yield}.
They mark the end of a function call and return one or more results
to the calling environment. 
The {\tt return} and {\tt yield} are followed by a target list
or an assignment, which is executed first.
The {\tt end} marker identifies the end of functional abstraction. 
Anything beyond it is ignored.

The flow of control within a MAL program block can be changed by
tagging an assignment with either
{\tt barrier}, {\tt leave}, {\tt redo}, or {\tt exit}.
The {\tt barrier} and {\tt exit} mark a block
to be interpreted when the barrier can be taken.

The {\tt barrier}, {\tt leave} and {\tt redo} are conditional 
flow modifiers, because they use the value of the first target 
variable after the expression has been evaluated to decide
on the action to be taken.
Built-in barrier controls exists for booleans and numeric values.
The barrier is opened when the first target variable holds
true, when its numeric value $>=$ 0, when it is a non-empty
string. The {\sc nil} value blocks entry in all cases.


Once inside the barrier you have an option to prematurely
{\tt leave} it at the exit statement
or to {\tt redo} interpretation just after the corresponding
barrier statement. Much like 'break' and 'continue' statements 
in C.
The control action is taken when the condition is met.

The {\tt exit} marks the exit for a block. Its optional assignment
can be used to re-initialize the barrier control variables
or wrap-up any related administration.

A control block is recognized by its target variable set.
This implies that nesting on the same target set is prohibited.

The barrier blocks can be properly nested to form
a hierarchy of basic blocks.
The control flow within and between blocks is
simple enough to deal with during an optimizer stage.
The {\tt redo} and {\tt leave} statements mark
the partial end of a block. Statements within these
blocks can be re-arranged according to the data-flow
dependencies. The order of partial blocks can not
be changed that easily. It depends on the mutual
exclusion of the data flows within each partial block.

Common guarded blocks in imperative languages are
the for-loop and if-then-else constructs.
They can be simulated as follows.

Consider the statement {\em for(i=1;i$<$10;i++) print(i)}.
The (optimized) MAL block to implement this becomes:
\begin{verbatim}
     V:= 1;
barrier B:= V<10;
     print(V);
     V:= V+1;
redo B:= V<10;
exit B;
\end{verbatim}

Translation of the statement {\em if(i$<$1) print("ok"); else print("wrong");}
becomes:
\begin{verbatim}
    i:=1; 
barrier ifpart:= i<1;
    print("ok");
exit ifpart;
barrier elsepart:= i>=1;
    print("wrong");
exit elsepart;
\end{verbatim}
Note that both guarded blocks can be interchanged without
affecting the outcome. Moreover, neither block would
have been entered if the variable happens to be assigned {\sc nil }

Beware that {\tt redo} is a flow modifier attached to an instruction.
The generic form of an iterator looks like
\begin{verbatim}
barrier i:= newIterator(T);
    elm:= getElement(T,i);
    ...
    leave i:= noMoreElements(T);
    ...
    redo i:= hasMoreElements(T);
exit i:= exitIterator(T);
\end{verbatim}
The semantics obeyed by the implementations should be as follows.
The redo expression updates the target variable {\em i} and control
proceeds at the first statement after the barrier when the
barrier is opened by {\em i}. If the barrier could not be
re-opened, execution proceeds with the first statement after
the redo.
Likewise, the leave control statement skips to the exit
when the control variable {\em i} shows a closed barrier block.
Otherwise, it continues with the next instruction.
Note, in both failed cases the control variable is 
possibly changed.

A recurring situation is to iterate over the elements in
a BAT. This is supported by an iterator implementation in
the bbp module as follows:
\begin{verbatim}
barrier (idx,hd,tl):= newIterator(B);
    ...
    redo (idx,hd,tl):= hasMoreElements(B);
exit i;
\end{verbatim}
Where idx is an integer to denote the row in the BAT,
hd and tl denote values of the current element.
This scheme is more efficient 
@{
@+ Parallel processing
@T
[rethink as factory]
The MAL interpreter supports spawning parallel workers,
who share a common stack frame. They are considered
cooperative and no low level transaction support
is included to align their work.

[Locking primitives should be provided]

The thread code starts with a flow of control modifier {\tt thread}
and ends with the corresponding {\tt exit}.
The assignment of the {\tt thread} should produce an integer
value initialized to 0, otherwise the thread is already considered
running and its handle contains a process id.

Example, the fragment below creates a parallel thread which
dies after a few seconds. The parent threads awaits for this 
event to happen. (See mal/Tests/tst2010.mal)
\begin{verbatim}
thread  hdl;    # should be zero to start
        printf("#Start thread with id %d\n",hdl);
        clkticks(2);
        printf("About to exit child\n");
exit    hdl;

        printf("Wait for child to exit too\n");
\end{verbatim}

[show thread inspection routines]

@-
@}
@+ The MAL instruction records
The data structure to represent a MAL block is kept simple.
It carries a sequence of MAL statements and a variable table.
Each instruction contains references to elements in the 
symbol table.

The MAL instruction is a code byte string overlaid with the
instruction pattern. This method leads to a large
allocated block, which can be easily freed, and
pattern makes it possible to accommodate a variable argument list.

Variable- and stmt- block together describe the
static part of a MAL procedure. It carries carry enough 
information to produce
a listing and to aid symbolic debugging. Ideally, the listing
of a MAL program is identical to the non-commented source.
This costs some space, but will improve readability and permits
instruction sequences generated internally also to be kept
around as ASCII text for later inclusion.

WARNING. The way we lay out the instructions means that 
you can prepare only one instruction at a time, because you don't
know how many arguments may be needed upfront.
[TODO, rather then breaking the original input into pieces,
it would be worthwhile to keep track of location of the
instruction in the source.]
@- Call encapsulation
The instruction records contain three optional pointers to functions:
beforeCall and afterCall. They are bound to the result type.
All expect a pointer to a VALrecord. The beforeCall is activated
just before you enter a routine and can be used to initialize
the stack frame, perform debugging, etc.etc.
The afterCall is activated after a successful return and can be
used to finalize the administration.
Typical use of beforeCall and afterCall are handling of BAT references,
but they can also be used to update a front-end.
@-
[Think, should beforeCall/afterCall also become part of the MAL functions?]
@{
For implementation reasons the maximum number of parameters is a
compile time constant. Its choice should be large enough to
accommodate the functions you have in mind. 
[TODO, the size is known after parsing]

@h
#ifndef _MAL_INSTR_H
#define _MAL_INSTR_H

#include "mal_type.h"
#include "mal_stack.h"
#include "mal_properties.h"

#define isaSignature(P)  ((P)->token >=COMMANDsymbol)

#ifdef MALprofiler
#ifdef HAVE_SYS_TIMES_H
# include <sys/times.h>
#endif
#endif

#define DEBUG_MAL_INSTR
#define MAXARG 16
#define MAXSTMTS 32
#define MAXVARS 32

typedef struct SYMDEF {
        struct SYMDEF   *peer;  /* where to look next */
        struct SYMDEF   *skip;  /* skip to next different symbol */
        str     name;
        int	kind;
        struct MALBLK   *def;    /* the details of the MAL fcn */
} *Symbol, SymRecord;

typedef struct VARRECORD{
	str     name;	/* argname or lexical value repr */
	malType	type;	/* internal type signature */
	int	gdktype; /* for backend */
        bit	isaconstant;	/* value cannot change */
        bit	isatypevar;	/* denotes a type variable */
        int	tmpindex;	/* temporary variable */
	short	isinit;	/* used once as destination */
	short	isused;	/* for stack copying scope */
	short   fixtype;/* the type has been fixed */
	short	garbage;/* remove upon function return */
	short	beginLifespan, endLifespan; /* for optimizers */
	str	literal;/* initial value string */
	PropertySet	props; /* private list of (name,value) pairs */
	ValRecord value;
} *VarPtr, VarRecord;

/* type check status is kept around to improve type checking efficiency */
#define TYPE_ERROR		-1
#define TYPE_UNKNOWN            0
#define TYPE_DYNAMIC            1
#define TYPE_BIND	        2
#define TYPE_FIXED              4

/* all functions return a string */
typedef str (*MALfcn)();

typedef struct {
	short	token;		/* instruction type */
	short	barrier;	/* flow of control modifier takes:
				   BARRIER, LEAVE, REDO, EXIT
				   CATCH, RAISE, THREAD*/
	short	typechk;	/* type check status */
	PropertySet	props; /* associated with function def */
@-
For performance analysis we keep track of the number of calls
and the total time spent while executing the instruction.
(See mal_profiler.mx)
@h
#ifdef MALprofiler
	short	trace;		/* facilitate filter-based profiling */
	struct  tms timer;	/* clock information */
	lng	clk;		/* microseconds clock */
	long	counter;
	long	ticks;		/* micro seconds spent */
#endif
	MALfcn	fcn;		/* resolved function address */
	MALfcn  beforeCall;	/* do something with the target object */
	MALfcn  afterCall;	/* do something with the result object */
	struct MALBLK *blk;	/* resolved MAL function address */
	int	garbage;	/* control is needed */
	int	jump;		/* controlflow program counter */
@-
The MAL instruction representation. The strings should be garbage collected
upon destruction of the definition.
@h
	str	modname;	/* module context */
	str	fcnname;	/* function name */
	short	polymorphic;	/* complex type analysis */
	short	varargs;	/* variable number of arguments */
	short	argc,retc,maxarg;/* total and result argument count */
	int	argv[1];	/* at least one entry */
} *InstrPtr, InstrRecord;

typedef struct MALBLK{
	str	binding;/* related C-function */
        str     help;   /* supportive commentary */
	PropertySet	props; /* private */
	struct MALBLK *alternative;
	int	vtop;		/* next free slot */
	int	vsize;	/* size of variable arena */
	VarRecord  **var;	/* Variable table */
	int	stop;		/* next free slot */
	int	ssize;	/* byte size of arena */
	InstrPtr *stmt;	/* Instruction location */
	int	errors;	/* left over errors */
} *MalBlkPtr, MalBlkRecord;

@-
Allocation of space assumes a rather exotic number of arguments.
Access to module and function name are cast in macros to prepare
for separate name space management.
@h
#define moduleId(P)		(P)->modname
#define setModuleId(P,S)	(P)->modname= S
#define moduleName(P)		(P)->modname
#define freeModuleName(P)	{(P)->modname=0;}
#define setModuleScope(P,S)	{(P)->modname= (S)==NULL?NULL: (S)->name;}

#define functionId(P)		(P)->fcnname
#define setFunctionId(P,S)	(P)->fcnname= S
#define functionName(P)		(P)->fcnname
#define freeFunctionName(P)	{ GDKfree((P)->fcnname); (P)->fcnname=0;}

#define getInstrPtr(M,I)	(M)->stmt[I]
#define getSignature(S)		getInstrPtr((S)->def,0)
#define getFcnName(M)		functionName(getInstrPtr(M,0))
#define getArgCount(M)		getInstrPtr(M,0)->argc
#define getModName(M)		moduleName(getInstrPtr(M,0))
#define getPrgSize(M)		(M)->stop

#define getVar(M,I)		(M)->var[I]
#define getVarLiteral(M,I) 	(M)->var[I]->literal
#define getVarTmp(M,I)		(M)->var[I]->tmpindex
#define getGDKtype(M,I)		(M)->var[I]->gdktype
#define isConstant(M,I)	((M)->var[I]->isaconstant)
#define isTypeVar(M,I)	((M)->var[I]->isatypevar)
#define isTmpVar(M,I)	((M)->var[I]->tmpindex)
#define isVarUsed(M,I) 		((M)->var[I]->isused)
#define isVarInitialized(M,I) 	((M)->var[I]->isinit)
#define isFixed(M,I)		((M)->var[I]->fixtype)
#define setFixed(M,I)		((M)->var[I]->fixtype= 1)
#define garbageControl(M,I)  	((M)->var[I]->garbage)
#define getVarConstant(M,I) 	((M)->var[I]->value)
#define getVarType(M,I)		((M)->var[I]->type)
#define getVarGDKType(M,I)		((M)->var[I]->gdktype)
#define copyVar(M,I,J)	freeVariable(M,I);(M)->var[I] = (M)->var[J];\
		(M)->var[J]= NULL;

#define getDestVar(P)	(P)->argv[0]
#define setDestType(M,P,V) 	setVarType((M),getDestVar(P),V)
#define getDestType(M,P) 	destinationType((M),(P))
#define getArg(P,I)	(P)->argv[I]
#define getArgName(M,P,I) 	getVarName((M),(P)->argv[I])
#define getArgType(M,P,I) 	getVarType((M),(P)->argv[I])
#define getArgDefault(M,P,I)	getVarLiteral((M),(P)->argv[I])

mal_export InstrPtr	newInstruction(int kind);
mal_export InstrPtr 	copyInstruction(InstrPtr p);
mal_export void 	oldmoveInstruction(InstrPtr dst, InstrPtr src);
mal_export void		clrInstruction(InstrPtr p);
mal_export void		freeInstruction(InstrPtr p);
mal_export void		clrFunction(InstrPtr p);
mal_export Symbol	newSymbol(str nme, int kind);
mal_export void 	freeSymbol(Symbol s);
mal_export void 	freeSymbolList(Symbol s);
mal_export MalBlkPtr 	newMalBlk(int maxvars, int maxstmts);
mal_export void 	prepareMalBlk(MalBlkPtr mb, str s);
mal_export void		freeMalBlk(MalBlkPtr mb);
mal_export MalBlkPtr	copyMalBlk(MalBlkPtr);
mal_export void		expandMalBlk(MalBlkPtr mb, int lines);
mal_export void		trimMalBlk(MalBlkPtr mb);
mal_export void 	moveInstruction(MalBlkPtr mb, int pc, int target);
mal_export void		removeInstruction(MalBlkPtr mb, int pc);
mal_export str 		operatorName(int i);

mal_export int		findVariable(MalBlkPtr mb, str name);
mal_export int		findTmpVariable(MalBlkPtr mb, int type);
mal_export int		findVariableLength(MalBlkPtr mb, str name,int len);
mal_export malType	getType(MalBlkPtr mb, str nme);
mal_export str		getVarName(MalBlkPtr mb, int i);
mal_export int		newVariable(MalBlkPtr mb, str name,malType type);
mal_export void		copyVariable(MalBlkPtr dst,MalBlkPtr src, VarPtr v);
mal_export void 	removeVariable(MalBlkPtr mb, int varid);
mal_export int		newTmpVariable(MalBlkPtr mb, malType type);
mal_export int		newTmpSink(MalBlkPtr mb, malType type);
mal_export int		newTypeVariable(MalBlkPtr mb, malType type);
mal_export void		delVariable(MalBlkPtr mb, int varid);
mal_export void		freeVariable(MalBlkPtr mb, int varid);
mal_export int		newConstant(MalBlkPtr mb, malType type, str val, int f);
/* mal_export int		isaSignature(InstrPtr p);*/

mal_export void		pushInstruction(MalBlkPtr mb, InstrPtr p);
mal_export InstrPtr	pushArgument(MalBlkPtr mb, InstrPtr p, int varid);
mal_export InstrPtr 	pushArgumentId(MalBlkPtr mb, InstrPtr p, str name);
mal_export void 	setVarInitialized(MalBlkPtr mb, int varid);
mal_export void		delArgument(InstrPtr p, int varid);
mal_export void		setVarType(MalBlkPtr mb, int i, int tpe);
mal_export void		setArgType(MalBlkPtr mb, InstrPtr p, int i, int tpe);
mal_export void		setReturnArgument(InstrPtr p, int varid);
mal_export malType	destinationType(MalBlkPtr mb, InstrPtr p);
mal_export str 		fcnClass(InstrPtr p);
mal_export void 	printInstruction(stream *fd, MalBlkPtr mb,InstrPtr p,int flg);
mal_export void		promptInstruction(stream *fd, MalBlkPtr mb,InstrPtr p,int flg);
mal_export void 	printSignature(stream *fd, Symbol s, int flg);
mal_export str		instruction2str(MalBlkPtr mb,InstrPtr p,int hidden);
mal_export str 		function2str(MalBlkPtr mb,int flg);
mal_export void 	pushEndInstruction(MalBlkPtr mb);	/* used in src/mal/mal_parser.c */


mal_export void strBeforeCall(ValPtr v,ValPtr bak);
mal_export void strAfterCall(ValPtr v,ValPtr bak);
mal_export void batBeforeCall(ValPtr v,ValPtr bak);
mal_export void batAfterCall(ValPtr v,ValPtr bak);
#endif /*  _MAL_INSTR_H*/
@c
#include "mal_instruction.h"
#include "mal_function.h"	/* for getPC() */

Symbol newSymbol(str nme, int kind){
	Symbol cur;
	if( nme == NULL){
		GDKfatal("@1:unexpected name (=null)\n");
	}
        cur = (Symbol) GDKmalloc(sizeof(SymRecord));
	if( cur == NULL){
		GDKfatal("@1: cannot initialize scope\n");
	}
	bzero((str)cur,sizeof(SymRecord));
	cur->name = nme;
	cur->kind = kind;
	cur->peer = NULL;
	cur->def = newMalBlk(MAXVARS,MAXSTMTS);
	return cur;
}
void freeSymbol(Symbol s){
        if(s==NULL) return;
        if( s->name) { GDKfree(s->name); s->name = NULL;}
        if( s->def) { freeMalBlk(s->def);s->def = NULL;}
        GDKfree(s);
}
void freeSymbolList(Symbol s){
	Symbol t= s;
	while(s){
		t= s->peer;
		s->peer= NULL;
		freeSymbol(s);
		s=t;
	}
}
 
MalBlkPtr newMalBlk(int maxvars, int maxstmts){
	MalBlkPtr mb;
	VarPtr *v;
	InstrPtr *p;

	v = (VarPtr *) GDKmalloc(sizeof(VarPtr) * maxvars);
	if( v== NULL )
		GDKfatal("newMalBlk:could not get variable storage\n");
	bzero(v, sizeof(VarPtr) * maxvars);
	p = (InstrPtr *)GDKmalloc(sizeof(InstrPtr) * maxstmts);
	if( p== NULL )
		GDKfatal("newMalBlk:could not get instruction storage\n");
	bzero((char *)p, sizeof(InstrPtr) * maxstmts);
	mb = (MalBlkPtr) GDKmalloc(sizeof(MalBlkRecord));
	if( mb== NULL )
		GDKfatal("newMalBlk:could not get storage\n");

	mb->var = v; mb->vtop = 0; mb->vsize = maxvars;
	mb->stmt = p; mb->stop = 0; mb->ssize = maxstmts;
	mb->help = mb->binding= NULL;
	mb->errors = 0;
	mb->props= NULL;
	mb->alternative= NULL;
	return mb;
}
@-
The freeMalBlk code is quite defensive. It is used to localize an
illegal re-use of a MAL blk.
@c
void freeMalBlk(MalBlkPtr mb){
	int i;
	/* InstrPtr p;

	p= getInstrPtr(mb,0); */
	for(i=0;i<mb->stop; i++){
		freeInstruction(getInstrPtr(mb, i));
		mb->stmt[i]= NULL;
	}
	mb->stop = 0;
	for(i=0;i<mb->vtop; i++)
		freeVariable(mb, i);
	mb->vtop = 0;
	GDKfree(mb->stmt); mb->stmt= 0;
	GDKfree(mb->var);  mb->var=0;
	if( mb->binding) GDKfree(mb->binding);  mb->binding=0;
	if( mb->help) GDKfree(mb->help); mb->help=0;
	if(mb->props) GDKfree(mb->props);
	mb->props= NULL;
	GDKfree(mb);
}
@-
The routine below should assure that all referenced structures
are private. The copying is memory conservative.
@c
MalBlkPtr copyMalBlk(MalBlkPtr old){
	MalBlkPtr mb;
	int i;

	mb = (MalBlkPtr) GDKmalloc(sizeof(MalBlkRecord));
	if( mb== NULL )
		GDKfatal("newMalBlk:could not get storage\n");
	bzero((char *) mb, sizeof(MalBlkRecord));
	mb->props= old->props;
	mb->alternative= old->alternative;
	mb->var = (VarPtr *)GDKmalloc(sizeof(VarPtr) * old->vsize);
	if( mb->var== NULL )
		GDKfatal("newMalBlk:could not get variable storage\n");
	mb->vsize = old->vsize;
	memcpy((char*) mb->var, old->var, sizeof(VarPtr) * old->vsize);

	mb->vtop = 0;
	for(i=0;i<old->vtop;i++){
		copyVariable(mb,old,getVar(old,i));
		mb->vtop++;
	}

	mb->stmt = (InstrPtr *)GDKmalloc(sizeof(InstrPtr) * old->ssize);
	if( mb->stmt== NULL )
		GDKfatal("newMalBlk:could not get instruction storage\n");
	bzero((char*) mb->stmt, sizeof(InstrPtr) * old->ssize);
	mb->stop = old->stop;
	mb->ssize = old->ssize;
	for(i=0; i<old->stop;i++)
		mb->stmt[i] = copyInstruction(old->stmt[i]);

	mb->help = old->help?GDKstrdup(old->help): NULL;
	mb->binding = old->binding?GDKstrdup(old->binding): NULL;
	mb->errors= old->errors;
	/* copy the properties as well */
	if(mb->props)
		mb->props = cpyPropertySet(old->props);
	return mb;
}
@-
The MalBlk structures potentially consume a lot a of space, because it
is not possible to precisely estimate the default sizes of the var and stmt
components. The routines below provide a mechanism to handle the issue.
The expandMalBlk routine takes the number of new-lines as a parameter
and guesses the size of variable and statement table.

Experience shows that trimming leads to memory fragmentation (140K lost
after Mserver init) and is therefore turned off.
@c
void trimexpand(MalBlkPtr mb, int varsize, int stmtsize){
	VarRecord **v;
	InstrPtr *stmt;
	int len;

	assert(varsize>0 && stmtsize>0);
	len = sizeof(ValPtr)* (mb->vtop+varsize);
	v= (VarRecord **) GDKmalloc(len);
	if( v== NULL)
		GDKfatal("newMalBlk:could not get variable storage\n");

	bzero((char*) v, len);
	memcpy((str) v, (str) mb->var, sizeof(ValPtr) * mb->vtop);
	if(mb->var) GDKfree(mb->var);
	mb->var = v;
	mb->vsize = mb->vtop+varsize;

	len = sizeof(InstrPtr) * (mb->ssize+stmtsize);
	stmt = (InstrPtr *)GDKmalloc(len);
	if( stmt== NULL )
		GDKfatal("newMalBlk:could not get instruction storage\n");
	bzero((char*) stmt, len);
	memcpy((str) stmt, (str) mb->stmt, sizeof(InstrPtr) * mb->stop);
	GDKfree(mb->stmt);
	mb->stmt= stmt;
	mb->ssize = mb->ssize + stmtsize;
}
void expandMalBlk(MalBlkPtr mb, int lines){
	int newlines= (int) (lines *1.1);
	if(newlines >mb->ssize || newlines>mb->vsize)
		trimexpand(mb,newlines,newlines);
}
void trimMalBlk(MalBlkPtr mb){
	(void) mb; /* fool the compiler */
	 /* printf("safe %d %d\n",mb->vtop, (mb->vsize-mb->vtop)*sizeof(VarPtr));
	trimexpand(mb,0); */
}
@-
Before compiling a large string, it makes sense to allocate approximately
enough space to keep the intermediate code. Otherwise, we end up with a
repeated extend on the MAL block, which really consumes a lot of memcpy
resources.
@c
void prepareMalBlk(MalBlkPtr mb, str s){
	int cnt=1;
	char *c;
	for(c=s;*c;c++)if( *c=='\n') cnt++;
	expandMalBlk(mb,cnt);
}

InstrPtr newInstruction(int kind){
	InstrPtr p;
	int space;

	space = (MAXARG-1) * sizeof(int)+ sizeof(InstrRecord);
	p = GDKmalloc(space);
	p->typechk = TYPE_UNKNOWN;
	setModuleId(p, NULL);
	setFunctionId(p, NULL);
	p->props= NULL;
	p->beforeCall = p->afterCall = 0;
	p->fcn= NULL;
	p->blk= NULL;
	p->polymorphic = 0;
	p->varargs = 0;
	p->argc= 1;
	p->retc= 1;
	p->maxarg= MAXARG;
	p->argv[0] = -1;	/* watch out for direct use in variable table*/
@-
Flow of control instructions are always marked as an assignment
with modifier
@c
	switch(kind){
	case BARRIERsymbol:	
	case REDOsymbol:	
	case LEAVEsymbol:	
	case EXITsymbol:	
	case RETURNsymbol:	
	case YIELDsymbol:	
	case CATCHsymbol:	
	case RAISEsymbol:	
	case THREADsymbol:	
		p->token= ASSIGNsymbol;
		p->barrier= kind;
		break;
	default:
		p->token = kind;
		p->barrier= 0;
	}
#ifdef MALprofiler
	p->timer.tms_utime = 0;
	p->timer.tms_stime = 0;
	p->timer.tms_cutime = 0;
	p->timer.tms_cstime = 0;
	p->clk = 0;
	p->ticks = 0;
	p->trace= 0;
	p->garbage=0;
	p->jump=0;
	p->counter= 0;
#endif
	return p;
}

@- 
Copying an instruction is space conservative.
@c

InstrPtr copyInstruction(InstrPtr p)
{
	InstrPtr new;
	new = (InstrPtr) GDKmalloc(sizeof(InstrRecord) + sizeof(int) * p->argc);
	oldmoveInstruction(new,p);
	return new;
}
void clrFunction(InstrPtr p){
	if(moduleId(p)) freeModuleName(p);
	if(functionId(p)) freeFunctionName(p);
	p->fcn= 0;
}
void clrInstruction(InstrPtr p){
	clrFunction(p);
	bzero((char*)p, sizeof(InstrRecord)+ (p->argc-1)*sizeof(int));
}
void freeInstruction(InstrPtr p){
	assert(p!=0);
	if(moduleId(p)) freeModuleName(p);
	if(functionId(p)) freeFunctionName(p);
	GDKfree(p);
}
@-
Moving instructions around calls for care, because all dependent
information should also be updated.
@c
void oldmoveInstruction(InstrPtr new, InstrPtr p){
	int space;

	space = sizeof(InstrRecord) + sizeof(int) * p->argc;
	memcpy((char*) new, (char*) p, space);
	setFunctionId(new, functionId(p)? GDKstrdup(functionName(p)): NULL);
	setModuleId(new, moduleId(p));
}
@-
Query optimizers walk their way through a MAL program block.
They require some primitives to move instructions around and
to remove superflous instructions. 

@c
void removeInstruction(MalBlkPtr mb, int pc){
	int i;
	InstrPtr p;
	
	p= getInstrPtr(mb,pc);
	 
	for(i=pc; i<mb->stop-1; i++)
		mb->stmt[i]= mb->stmt[i+1];
	mb->stop--;
	mb->stmt[i]=0;
	freeInstruction(p);	
}
void moveInstruction(MalBlkPtr mb, int pc, int target){
	(void) mb;  (void) pc;  (void)target;/* fool the compiler */
}
@-
Beware that the first argument of a signature is reserved for the function
return type , which should be equal to the destination variable type.

VarRecords are allocated on the variable stack.
Their index is returned for future reference.
@-
Use the information that a variable is at least one character
wide and terminated by a null-byte.
This means that we can speed up search when the variables
differ in the first two characters

Furthermore, temporary variables are already assigned to a specific
position in the variable table. This information can only be used
under the assumption that the code base is not modified on the
fly. Then the expensive search is started anyway.
It also means that input which does not comply with the intended
location of a temporary variable should be flagged as an error.
@= chkTemporary
	if( isTmpName(name)){
		i= atol(name+1);
		/* test validity*/
		if( i< mb->vtop-1 && isTmpVar(mb,i) && getVarTmp(mb,i) == i)
			return i;
		return -1;
	} 
@c
int findVariable(MalBlkPtr mb, str name){
	int i;
	@:chkTemporary@
	if( name == NULL) return -1;
	for(i=mb->vtop-1; i>=0; i--)
	if(!isTmpVar(mb,i) && idcmp(name, getVarName(mb,i) )==0)
		return i;
	return -1;
}
int findTmpVariable(MalBlkPtr mb, int type){
	int i;
	if( type == TYPE_any) return -1;
	for(i=mb->vtop-1; i>=0; i--)
	if(isTmpVar(mb,i) && getVarType(mb,i) == type )
		return i;
	return -1;
}
@-
The second version of findVariable assumes you have not
yet allocated a private structure. This is particularly
usefull during parsing, because most variables are already
defined. This way we safe GDKmalloc/GDKfree.
@c
int findVariableLength(MalBlkPtr mb, str name, int len){
	int i;
	int j;
	@:chkTemporary@
	if( name == NULL || len == 0) return -1;
	for(i= mb->vtop-1; i>=0; i--) 
	if( !isTmpVar(mb,i)){
		str s = getVarName(mb,i);
		for(j=0;j<len;j++)
		if( name[j]!=s[j]) break;
		if(j==len && s[j]==0) return i;
	}
	return -1;
}
@-
Note that getType also checks for type names directly.
They have preference over variable names.
@c
malType getType(MalBlkPtr mb, str nme){
	int i;
	i= findVariable(mb,nme);
	if( i< 0) return getTypeIndex(nme,strlen(nme));
	if( i>=0) return getVarType(mb,i);
	return TYPE_any;
}
@-
All variables are implicitly declared upon their first assignment. 
COMMANDS and FUNCTIONS should pass the types as strings and
convert them later on to the internal representation.

Lexical constants require some care. They typically appear as arguments
in operator/function calls. To simplify program analysis later on,
we stick to the situation that function/operator arguments are always
references to by variables. 
@- Reserved words
Although MAL has been designed as a minimal language, several
identifiers are not eligible as variables. The encoding below
is geared at simple and speed.
@c
int isReserved(str nme){
	switch(*nme){
	case 'A': case 'a': if( idcmp("atom",nme)==0) return 1;
		  break;
	case 'B': case 'b': if( idcmp("barrier",nme)==0) return 1;
		  break;
	case 'C': case 'c': if( idcmp("command",nme)==0) return 1;
		  break;
	case 'E': case 'e': if( idcmp("exit",nme)==0) return 1;
		  if( idcmp("end",nme)==0) return 1;
		  break;
	case 'F': case 'f': if( idcmp("false",nme)==0) return 1;
		  if( idcmp("function",nme)==0) return 1;
		  if( idcmp("factory",nme)==0) return 1;
		  break;
	case 'I': case 'i': if( idcmp("include",nme)==0) return 1;
		  break;
	case 'M': case 'm': if( idcmp("module",nme)==0) return 1;
		  break;
	case 'P': case 'p': if( idcmp("pattern",nme)==0) return 1;
		  break;
	case 'T': case 't': if( idcmp("thread",nme)==0) return 1;
		  if( idcmp("true",nme)==0) return 1;
		  break;
	}
	return 0;
}
@-
Beware, the symbol table structure assumes that it is relatively
cheap to perform a linear search to a variable or constant.

@= makeVarSpace
		if( mb->vtop == mb->vsize){
			VarPtr *new;
		int s= mb->vtop + MAXVARS;
		new= (VarPtr *) GDKmalloc(s * sizeof(VarPtr));
		/*printf("generate new variable block %d\n",s);*/
		if( new== NULL ){
			mb->errors++;
			GDKerror("newMalBlk:no storage left\n");
			return mb->vtop;
		}
		bzero(new, s * sizeof(VarPtr));
		memcpy((char*)new, (char*)mb->var, sizeof(VarPtr) * mb->vtop);
		GDKfree((str)mb->var);
		mb->vsize= s;
		mb->var= new;
		mb->var[mb->vtop-1]->gdktype= -1;
	} else if (mb->vtop >mb->vsize)
		GDKfatal("newVariable:variable administration\n");
@c
int newVariable(MalBlkPtr mb, str name, malType type){
        int n;
        
	@:makeVarSpace@
	n= findVariable(mb,name);
	/* check for redefined names */
	if( n>=0){
		if( type != TYPE_any){
		    if( getVarType(mb,n) != type  &&
		        getVarType(mb,n) != TYPE_any)
			GDKerror("'%s' type mismatch %d vs %d\n",
				name, getVarType(mb,n),type);
		}
		GDKfree(name);  /*possible not correct, check use!*/
		return n;
	}
	if( isTmpName(name)){
		int i= atol(name+1);
		/* test validity*/
		if( i > mb->vtop) {
			GDKerror("newVariable:variable %s mis-aligned\n",name);
			mb->errors++;
		} else
		if(i < mb->vtop && !isTmpVar(mb,i) ) {
			GDKerror("'%s' overwrites %s\n",
				name, getVarName(mb,i));
			mb->errors++;
		} 
	} 
	if( isReserved(name)){
		GDKerror("'%s' is a reserved identifier\n",name);
		mb->errors++;
	} 
	n = mb->vtop;
	getVar(mb,n) = (VarPtr) GDKmalloc(sizeof(VarRecord));
	bzero( (str) getVar(mb,n), sizeof(VarRecord));
	mb->var[n]->name = name;
	mb->var[n]->props = NULL;
	setVarType(mb,n,type);
	getVarLiteral(mb,n)= NULL;
	isConstant(mb,n) = FALSE;
	garbageControl(mb,n) = FALSE;
	isVarUsed(mb,n) = FALSE;
	isVarInitialized(mb,n) = FALSE;
	mb->vtop++;
	return n;
} 
@}
@- Temporary variables
Temporary target variable act as sinks in the data flow graph.
In this case, an optimizer can group them by underlying type and this way
reduce the symbol table size significantly.

Temporary variables are internally represented by their index into
the variable stack. Their default textual representation is '$'<digits>.
Temporary names  are recognized by the parser and an error is
produced if it does not satisfy this condition.

@{
Sharing of the temporary is only permitted if the type
is a priory known and not TYPE_any.
@c
int newTmpVariable(MalBlkPtr mb, malType type){
        int n;
        
	@:makeVarSpace@
	n = mb->vtop;
	if( getVar(mb,n)== NULL)
		getVar(mb,n) = (VarPtr) GDKmalloc(sizeof(VarRecord));
	bzero( (str) getVar(mb,n), sizeof(VarRecord));
	mb->var[n]->name = 0;
	mb->var[n]->props = NULL;
	getVarTmp(mb,n) = n;
	setVarType(mb,n,type);
	getVarLiteral(mb,n)= NULL;
	isConstant(mb,n) = FALSE;
	garbageControl(mb,n) = FALSE;
	isVarUsed(mb,n) = FALSE;
	isVarInitialized(mb,n) = FALSE;
	mb->vtop++;
	return n;
} 
int newTmpSink(MalBlkPtr mb, malType type){
        int n;
        
	n= findTmpVariable(mb,type);
	if( n >= 0 )
		return n;
	return newTmpVariable(mb,type);
}
int newTypeVariable(MalBlkPtr mb, malType type){
	int n;
	n= newTmpVariable(mb,type);
	isTypeVar(mb,n)= TRUE;
	return n;
}
void	delVariable(MalBlkPtr mb, int varid){
	if( varid== mb->vtop-1){
		GDKfree(getVar(mb,varid)); getVar(mb,varid)=0;
		mb->vtop--;
	}
}
void	copyVariable(MalBlkPtr dst, MalBlkPtr src, VarPtr v){
	VarPtr w;

	(void) src; /* fool the compiler */
	w = (VarPtr) GDKmalloc(sizeof(VarRecord));
	bzero( (str) w , sizeof(VarRecord));
        w->name = v->name? GDKstrdup(v->name):0;
        w->type = v->type;
        w->gdktype = v->gdktype;
        w->garbage = v->garbage;
        w->fixtype = v->fixtype;
        w->literal= v->literal? GDKstrdup(v->literal):NULL;
        w->isaconstant = v->isaconstant;
        w->isatypevar = v->isatypevar;
        w->tmpindex = v->tmpindex;
        w->isused = v->isused;
        w->isinit = v->isinit;
	VALcopy(&w->value,&v->value);
	dst->var[dst->vtop]= w;
}
@-
Beware, removing a variable
calls for a re-numbering of the variable indices used in the
program block. Assuming all new variables are appended only, we
merely have to take care of variable deletions.
@c
void removeVariable(MalBlkPtr mb, int varid){
	int i,j;
	InstrPtr p;
	for(i=0;i< mb->stop; i++){
		p= getInstrPtr(mb,i);
		for(j=0; j<p->argc; j++)
		if( p->argv[j]>varid) p->argv[j]--;
	}
	/* remove the variable from the symbol table */
	freeVariable(mb, varid);
	for(i= varid; i<mb->vtop-1; i++)
		mb->var[i] = mb->var[i+1]; 
	mb->vtop--;
}
void freeVariable(MalBlkPtr mb, int varid){
	VarPtr v;

	if(varid<0) return;
	v= getVar(mb,varid);
	if( v== NULL ) return;
	if( v->name) GDKfree(v->name); v->name = 0;
	if( v->literal) GDKfree(v->literal); v->literal= 0;
	if( v->isaconstant) VALclear(&v->value);
	if( v->props) freePropertySet(v->props);
	v->props=0;
	GDKfree(v);
	getVar(mb,varid) = NULL;
}
@}
@- MAL constants
Constants are stored in the symbol table and referenced
by a variable identifier.
This means that per MAL instruction, we may end up with
MAXARG entries in the symbol table. This may lead to long
searches for variables.
An optimization strategy deployed in the current
implementation is to look around for
a similar (constant) definition and to reuse its identifier.
This avoids an exploding symbol table with a lot
of temporary variables (as in tst400cHuge)

But then the question becomes how far to search?
Searching through all variables is only useful when the list remains short
or when the constant-variable-name is easily derivable from its literal
value and a hash-based index leads you quickly to it.

For the time being, we use a MAL system parameter, MAL_VAR_WINDOW,
to indicate the number of symbol table entries to consider.
Setting it to >= MAXARG will at least capture repeated use of a constant
within a single function call or repeated use within a small block
of code.

The final step is to prepare a GDK value record, from which
the internal representation can be obtained during
MAL interpretation.

The constant values are linked together to improve searching them.
This start of the constant list is kept in the MalBlk.
@{
@c
#define MAL_VAR_WINDOW	2*MAXARG

int newConstant(MalBlkPtr mb, malType type, str val, int niltst){
	int i,k,idx,parsetype=type;
	str s,colon = 0;
	ValPtr vr;
	int tonil= FALSE;

	k= mb->vtop - MAL_VAR_WINDOW;
	if( k<0) k=0;
	for(i= mb->vtop-1; i>=k;i--){
		VarPtr v= getVar(mb,i);
		if( v->type == type &&
		    v->literal && 
		    idcmp(v->literal,val)==0 ) {
			GDKfree(val);
			return i;
		}
	}
	idx= k = newTmpVariable(mb,type);
/* printf("new constant %d val %s %d\n",k,val,type);*/
	getVarLiteral(mb,k)= val;
	isConstant(mb,k) = 1;
	isVarUsed(mb,k) = FALSE;
	isVarInitialized(mb,k) = FALSE;
	vr = &getVarConstant(mb,k);
	tonil= niltst && strncmp(val,"nil",3)==0;

	/* remember the type classifier location */
	if( type != TYPE_str && type != TYPE_chr)
		colon = strchr(val,':');
	if( type == TYPE_str && strncmp(val,"nil",3)==0 && niltst){
		colon = strchr(val,':');
		tonil= TRUE;
	}
	if( colon) *colon = 0;
@-
@}
The current GDK layer does not perform a value range check.
Since constants are dealt with only once, it is performed here
as part of the parsing overhead.
Note that we support automatic coercion to a 
coerced type even in the case that a specific type specifier
has been given at the language level. A Warning is issued
to make the user aware of this situation.
@{
@c
	 /*switch( BATatoms[type].storage){*/
retryConstant:
	switch( parsetype){ 
	case TYPE_bit: { int x = (val[0]=='t' || val[0]=='T')?TRUE:FALSE;
			 vr->vtype= TYPE_bit;
			 vr->val.cval[0]= (tonil)?bit_nil:x; 
			 vr->val.cval[1]= 0;
			 vr->val.cval[2]= 0;
			 vr->val.cval[3]= 0;
			 break;
			}
	case TYPE_chr: 
			vr->vtype= TYPE_chr;
			vr->val.cval[0]= val[0];
			vr->val.cval[1]= 0;
			vr->val.cval[2]= 0;
			vr->val.cval[3]= 0;
			if( tonil) vr->val.cval[0] = chr_nil; 
			break;
	case TYPE_sht: {lng l;
			vr->vtype = type;
			if( tonil){ 
				vr->val.shval = sht_nil;
				break;
			} 
			l = strtol(val,NULL,0);
			if( l>= (1<<16) || l< -(1<<16)) {
				if( l< INT_MIN || l> INT_MAX ){	
					if(type== TYPE_sht)
						setVarType(mb, idx, TYPE_int);
					vr->vtype= TYPE_int;
					vr->val.ival = l;
				} else {
					if(type== TYPE_sht)
						setVarType(mb, idx, TYPE_lng);
					vr->vtype= TYPE_lng;
					vr->val.lval = l;
				}
			} else {
				vr->vtype= TYPE_sht;
				vr->val.shval= l;
			}
			break; }
	case TYPE_int: {lng l;
			vr->vtype = type;
			if( tonil){ 
				vr->val.ival = int_nil;
				break;
			} 
			l= strtol(val,NULL,0);
			if( l> INT_MAX || l < INT_MIN){
				if(type==TYPE_int)
					setVarType(mb,idx, TYPE_lng);
				vr->vtype= TYPE_lng;
				vr->val.lval= l;
			} else {
				vr->val.ival= l;
			}
			break;}
	case TYPE_void: 
	case TYPE_oid: {
			vr->vtype= type;
			if( tonil) {
				vr->val.oval = oid_nil;
				break;
			}
			vr->val.oval= strtol(val,NULL,10);
			break; }
	case TYPE_flt: {double d= strtod(val,NULL); 
			if( tonil) vr->val.fval = flt_nil; 
			else vr->val.fval= d;
			vr->vtype= type;
			break; }
	case TYPE_dbl: {double d= strtod(val,NULL);
			if( tonil) vr->val.dval = dbl_nil; 
			else vr->val.dval= d;
			vr->vtype= type;
			break;}
	case TYPE_lng: {lng l= strtoll(val,NULL,0);
			if( tonil) vr->val.lval = lng_nil; 
			else vr->val.lval= l;
			vr->vtype= type;
			break; }
	case TYPE_str: 
			vr->vtype= type;
			if( type != TYPE_str){
				/* an extern type */
				ptr *p = (ptr *) &vr->val.ival;
				(*BATatoms[type].atomFromStr)(val, &vr->len, p);
				break;
			}
			if( tonil) vr->val.sval = str_nil;
			else vr->val.sval= (str) GDKstrdup(val);
			vr->len= strlen((str) val);
			break;
@-
Extended types are always represented as string literals
and converted to the internal storage structure.
Beware that the typeFromStr routines generate storage space
for the new value. This should be garbage collected at the
end.
@c
	default:{ 
		ptr *p = (ptr *) &vr->val.ival;

		if( parsetype != BATatoms[parsetype].storage){
			parsetype = BATatoms[type].storage;
			goto retryConstant;
		}
		if( BATatoms[type].atomFromStr== 0) {
		s= getTypeName(type);
		GDKerror("newConstant:no string coercion for '%s'\n", s);
		GDKfree(s);
		break;
		}
#ifdef STRUCT_ALIGNED
		vr->vtype= type;
		(*BATatoms[type].atomFromStr)(val, &vr->len, p);
#else
		GDKerror("newConstants:missing implementation\n");
#endif
		}
	}
	/* restore original input */
	if(colon) *colon= ':';
	return idx;
}

/*
int isaSignature(InstrPtr p){
	switch(p->token){
	case FUNCTIONsymbol:
	case FACTORYsymbol:
	case COMMANDsymbol:
	case PATTERNsymbol:
		return TRUE;
	}
	return FALSE;
}
*/
@- Argument handling
The number of arguments for procedures is currently limited.
Furthermore, we should assure that no variable is referenced
before being assigned. 
Failure to obey should mark the instruction as type-error.
@c
InstrPtr pushArgument(MalBlkPtr mb, InstrPtr p, int varid){
        int n;
        
        n = p->argc;
        if( n == MAXARG-1){
		InstrPtr pn;
		int pc = 0;
		int space= (p->maxarg-1)*sizeof(int)+ sizeof(InstrRecord);
		pn = GDKmalloc(space+MAXARG*sizeof(int));
		memcpy((char *)pn,(char *)p,space);
		pn->maxarg= p->maxarg+MAXARG;
		pc= getPC(mb,p);
		if( pc>=0) mb->stmt[pc]= pn;
		GDKfree(p);
		p=pn;
        } 
	p->argc++;
	p->argv[n] = varid;
	isVarUsed(mb,varid) = TRUE;
	return p;
} 
void setVarInitialized(MalBlkPtr mb, int varid){
	isVarInitialized(mb,varid) = TRUE;
}
@-
Store the information of a destination variable in the signature structure of
each instruction. This code is largely equivalent to pushArgument,
but it is more efficient in searching and collecting the information.
[todo]
@c
InstrPtr pushArgumentId(MalBlkPtr mb, InstrPtr p,str name){
        int v;

	v= findVariable(mb,name);
	if( v<0) v= newVariable(mb,name,getTypeIndex(name,strlen(name)));
	else GDKfree(name);
	return pushArgument(mb,p,v);
}
@-
The alternative is to remove arguments from an instruction record.
This is typically part of instruction constructions.
@c
void delArgument(InstrPtr p, int idx){
	int i;
	for(i=idx;i<p->argc-1;i++)
		p->argv[i] = p->argv[i+1];
	p->argc--;
	if( idx < p->retc) p->retc--;
}

/* old stuff to test for errors
int getVarType(MalBlkPtr mb, int i) 
{
	if(i<0) { 
		GDKwarning("getVarType:array bound error %d %d\n",i, mb->vtop);
		return TYPE_any;
	}
	if( i >= mb->vsize) {
		GDKwarning("getVarType:array bound error %d %d\n",i, mb->vtop);
		return;
	}
	return mb->var[i]->type;
}
*/
void setVarType(MalBlkPtr mb, int i, int tpe) 
{
	if(i<0) return;
/*
	if( i >= mb->vsize) {
		GDKwarning("setVarType:array bound error %d %d %d\n",i,tpe, mb->vtop);
		return;
	}
*/
	mb->var[i]->type= tpe;
	mb->var[i]->gdktype= findGDKtype(tpe);
}
void setArgType(MalBlkPtr mb, InstrPtr p, int i, int tpe)
{
	if( p->argv[i] >=mb->vsize) {
		GDKwarning("setArgType:array bound error\n");
		return;
	}
	getDestVar(p) = i;
	mb->var[getDestVar(p)]->type = tpe;
}
void setReturnArgument(InstrPtr p, int i)
{
	getDestVar(p) = i;
}
@-
Temporary names are not materialized as strings unless necessary.
@c
str getVarName(MalBlkPtr mb, int i){
	str nme;
	char buf[PATHLENGTH];

	nme = mb->var[i]->name;
	if(nme ==0){
		snprintf(buf,PATHLENGTH,"%c%d",TMPMARKER,mb->var[i]->tmpindex);
		nme= mb->var[i]->name = GDKstrdup(buf);
	}
	return nme;
}
malType destinationType(MalBlkPtr mb, InstrPtr p){
	if( p->argc>0) return getVarType(mb, getDestVar(p));
	return TYPE_any;
}

@-
Instructions are simply appended to a MAL block.
It is also the place to collect information to speed-up use later on.
@c
void pushInstruction(MalBlkPtr mb, InstrPtr p){
	int i;

	i= mb->stop;
	if( i+1 >= mb->ssize){
		int space= (mb->ssize + MAXSTMTS) * sizeof(InstrPtr);
		InstrPtr *newblk= (InstrPtr *) GDKmalloc( space);
/*printf("resize instruction block to %d\n",  space);*/
		if( newblk== NULL){
			mb->errors++;
			GDKerror("pushInstruction:no storage left\n");
			return;
		}
		bzero((char*)newblk, space);
		memcpy(newblk,mb->stmt,mb->stop * sizeof(InstrPtr));
		mb->ssize += MAXSTMTS;
		GDKfree(mb->stmt);
		mb->stmt = newblk;
	}
@-
If the destination variable has not been set, introduce a temporary
variable to hold the result instead.
@c
	if( p->argv[0]<0) p->argv[0]= newTmpVariable(mb,TYPE_any);
	mb->stmt[i]= p;
	mb->stop++;
}
void pushEndInstruction(MalBlkPtr mb){
	InstrPtr p;
	p= newInstruction(ENDDEFsymbol);
	getDestVar(p) = findVariable(mb,functionName(getInstrPtr(mb,0)));
	p->argc =0;
	p->retc = 0;
	pushInstruction(mb,p);
}
@}
@- Reverse programming
Since MAL programs can be created on the fly by linked-in query
compilers, or transformed by optimizers, it becomes
mandatory to be able to produce textual correct MAL programs
from its internal representation.

No guarantee is given to produce the exact input for a reversed
MAL program, except that the output can be fed back for 
interpretation. Provided, the code did not produce an error.

@{
The hiddenInstruction operator assumes a sufficiently large block
to leave information on the signature behind.
@c
#define advance(X)  while(*(X))(X)++;

str typechkName(int i){
	switch(i){
	default:
	case TYPE_ERROR:	return " error";
	case TYPE_UNKNOWN: 	return " unknown";
	case TYPE_DYNAMIC:	return " dynamic";
	case TYPE_BIND:		return " bind";
	case TYPE_FIXED:	return "";
	}
}
str hiddenInstructionArgs(MalBlkPtr mb,InstrPtr p,str s){
	int i;
	str tpe;
	
	sprintf(s,"\t# %d %s%s ",
		getPC(mb,p), 
		((p->blk && p->blk->binding)? p->blk->binding:""),
		typechkName(p->typechk));
	advance(s);
	for(i=0;i<p->argc;i++)
	if( p->argv[i] >=0){
		str nme;
		char nmebuf[PATHLENGTH];

		if( i== p->retc) { sprintf(s,"<-"); advance(s);}
		tpe= getTypeName(getArgType(mb,p,i));
		if( isTmpVar(mb, getArg(p,i)) || isTypeVar(mb, getArg(p,i)) ) {
			snprintf(nmebuf,PATHLENGTH,"%c%d",TMPMARKER,
				getVarTmp(mb, getArg(p,i)));
			nme= nmebuf;
		} else nme = getArgName(mb,p,i);
		sprintf(s,"(%s:%s)", (nme?nme:"nil"), tpe);
		advance(s);
		GDKfree(tpe);
	}
	advance(s);
	if( p->jump) sprintf(s," jump %d",p->jump);
	advance(s);
	return s;
}
@-
It receives the space to store the definition
The MAL profiler dumps some performance data at the
beginning of each line.

@= performanceData
#ifdef MALprofiler
	if( p->counter ){
		double avg= (p->ticks+0.0)/p->counter;
		sprintf(t,"[%7ld, %5.2f] ",p->counter,avg);
	} 
	advance(t);
#endif
@-

@= showParam
		tpe= getTypeName(getArgType(mb,p,i));
		ps= getVar(mb,getArg(p,i))->props;
		pstring= propertySet2str(ps,0);
		advance(t);
		sprintf(t,"%s:%s%s",getArgName(mb,p,i),tpe,pstring);
		advance(t);
		if( i<p->@1-1) sprintf(t,",");
		if(pstring) { GDKfree(pstring); pstring=0;}
		GDKfree(tpe);
@c
str fcnClass(InstrPtr p){
	return operatorName(p->token);
}
str fcnDefinition(MalBlkPtr mb,InstrPtr p, str s,int flg ){
	int i;
	str t,tpe,pstring;
	PropertySet ps =0;

	t=s;
	sprintf(t,"%s%s ",(flg?"":"!"),fcnClass(p));

	advance(t);
	if( moduleId(p)) sprintf(t,"%s.",moduleName(p));
	advance(t);
	sprintf(t,"%s(",functionName(p));
	for(i=p->retc;i<p->argc;i++){ @:showParam(argc)@ }
	advance(t);
	if( p->varargs) sprintf(t,"...");
	advance(t);
	if( p->retc ==1){
		tpe= getTypeName(getArgType(mb,p,0));
		sprintf(t,"):%s",tpe);
		GDKfree(tpe);
		advance(t);
	} else {
		sprintf(t,") ("); t+= 3;
		for(i=0;i<p->retc;i++){ @:showParam(retc)@ }
		*t++ = ')';
	}
	if(mb->binding)
		sprintf(t," address %s;",mb->binding);
	else	sprintf(t,";");
#ifdef DEBUG_MAL_INSTR
	if( flg & (LIST_MAL_BIND | LIST_MAL_TYPE)){
		advance(t);
		hiddenInstructionArgs(mb,p,t);
	}
#endif
	return s;
}

@-
@= tabulate
	for(;tab>0;tab--) *t++= ' ';
	*t= 0;
	advance(t);
@-
Variables and MAL blocks, and instructions can be associated with a 
property list. At least for debugging purposes, the latest known value
should be displayed.
@= propertyList
	{char *tmp= propertySet2str(ps,0); strcat(t,tmp); GDKfree(tmp);}
	advance(t);
@c

str operatorName(int i){
	switch(i){
	case ASSIGNsymbol:	return ":=";
	case BARRIERsymbol:	return "barrier";
	case REDOsymbol:	return "redo";
	case LEAVEsymbol:	return "leave";
	case EXITsymbol:	return "exit";
	case RETURNsymbol:	return "return";
	case YIELDsymbol:	return "yield";
	case CATCHsymbol:	return "catch";
	case RAISEsymbol:	return "raise";
	case ENDsymbol:		return "end";
	case ENDDEFsymbol:	return "end";
	case FUNCTIONsymbol:	return "function";
	case FACTORYsymbol:	return "factory";
	case COMMANDsymbol:	return "command";
	case PATTERNsymbol:	return "pattern";
	case THREADsymbol:	return "thread";
	}
	return "Undefined";
}
str instruction2str(MalBlkPtr mb,InstrPtr p,int flg){
	int i,len=0,tab=4;
	str def,s,t,nme;
	int low,high;
	char nmebuf[PATHLENGTH];
	PropertySet ps=0;
	str pstring=0;

	len = 8196;
	s= GDKmalloc(len);
	if(flg) { s[0]=0; t=s; }
	else { s[0]='!'; s[1]=0; t= s+1; }
	/* @:performanceData@ */
	if( isTmpVar(mb, getArg(p,0)) ) {
		snprintf(nmebuf,PATHLENGTH,"%c%d",TMPMARKER,
			getVarTmp(mb, getArg(p,0)));
		nme= nmebuf;
	} else  nme = getArgName(mb,p,0);
	ps= getVar(mb,getArg(p,0))->props;
	pstring= propertySet2str(ps,0);
	advance(t);
	if( p->barrier){
		if( p->barrier == LEAVEsymbol || 
		    p->barrier == REDOsymbol || 
		    p->barrier == RETURNsymbol ||
		    p->barrier == YIELDsymbol ||
		    p->barrier == RAISEsymbol ){
			@:tabulate@
		}
		sprintf(t,"%s ",operatorName(p->barrier));
		advance(t);
	} else if( !functionStart(p) && !functionExit(p))
		@:tabulate@
	switch( p->token){
		case NOOPsymbol:
		case FCNcall:
		case FACcall:
		case PATcall:
		case CMDcall:
		case ASSIGNsymbol:
			if( p->argc<=1 && functionId(p)==NULL){
				sprintf(t,"%s%s",nme,pstring); 
			} else
			if( !getVarTmp(mb, getDestVar(p)) || isVarUsed(mb,getDestVar(p)) ){
				if( p->retc == 1){
					sprintf(t,"%s%s ",nme,pstring); 
					advance(t);
					if( p->argc > p->retc || functionId(p))
					{ 
						sprintf(t,":= ");t+=3;
					}
					break;
				} else {
					/* display multi-assignment */
					*t++ = '(';
					for(i=0;i<p->retc;i++){
						ps= getVar(mb,getArg(p,i))->props;
						pstring= propertySet2str(ps,i);
						sprintf(t,"%s%s",getArgName(mb,p,i),
							pstring);
						if(pstring){GDKfree(pstring);pstring=0;}
						advance(t);
						if( i<p->retc-1) 
							*t++= ',';
					}
					sprintf(t,")");t++;
					if( p->argc > p->retc || functionId(p))
					{ 
						sprintf(t,":= ");t+=3;
					}
				}
			}
			break;
		case ENDsymbol:
			sprintf(t,"%s ", operatorName(p->token)); break;
		case ENDDEFsymbol:
			if( isTmpVar(mb,getDestVar(p)) )
				sprintf(t,"end %c%d", TMPMARKER,
					getVarTmp(mb,getDestVar(p)) );
			else sprintf(t,"end %s",mb->var[getDestVar(p)]->name);
			break;
		case COMMANDsymbol:
		case FUNCTIONsymbol:
		case FACTORYsymbol:
		case PATTERNsymbol:
			return fcnDefinition(mb,p,s,flg); 
		default:
			sprintf(t," ?%d? ",p->token); 
	}
	GDKfree(pstring); pstring=0;
	advance(t);
	low= p->retc; high= p->argc;
	if( moduleId(p)) sprintf(t,"%s.",moduleName(p));
	advance(t);
	if( functionId(p) ) {
		sprintf(t,"%s(",functionName(p));
	} else if( p->argc>p->retc+1) sprintf(t,"(");

	for(i=low;i<high;i++){
		ps= getVar(mb,getArg(p,i))->props;
		pstring= propertySet2str(ps,0);
		advance(t);
		if( i+1==high && p->varargs ) {sprintf(t,"...");break;}
		if( (def=getArgDefault(mb,p,i)) != NULL){
			if( getArgType(mb,p,i)== TYPE_str)
				if( def== str_nil)
				     sprintf(t,"nil%s", pstring);
				else sprintf(t,"\"%s\"%s", def, pstring);
			else
			if( getArgType(mb,p,i)== TYPE_chr)
				if( *def== chr_nil)
				     sprintf(t,"nil%s", pstring);
				else sprintf(t,"'%s'%s", def, pstring);
			else	sprintf(t,"%s%s", def, pstring);
		} else {
			if( isTmpVar(mb, getArg(p,i)) ) {
				if( isVarInitialized(mb,getArg(p,i)) )
				sprintf(t,"%c%d", TMPMARKER, getVarTmp(mb,getArg(p,i)));
				advance(t);
				sprintf(t,"%s", pstring);
			} else 
			sprintf(t,"%s%s", mb->var[getArg(p,i)]->name,pstring);
		}
@-
Dump the type and value information.
@c
		advance(t);
		if(!isTmpVar(mb,getArg(p,i)) &&
		    idcmp("bat",getArgName(mb,p,i))==0 ){
			str hprop=0, tprop=0;
			str d1=getTypeName(getHeadType( getArgType(mb,p,i))),
			    d2 =getTypeName(getTailType(getArgType(mb,p,i)));
			hprop= propertySet2str(ps,1);
			tprop= propertySet2str(ps,2);
			if(hprop==NULL && tprop==NULL)
				sprintf(t,"[:%s,:%s]%s",d1,d2,pstring);
			else if(tprop==NULL)
				sprintf(t,"[:%s%s,:%s]%s",
					d1,hprop,d2,pstring);
			else if(hprop==NULL)
				sprintf(t,"[:%s,:%s%s]%s",
					d1,d2,tprop,pstring);
			else	sprintf(t,"[:%s%s,:%s%s]%s",
					d1,hprop,d2,tprop,pstring);
			GDKfree(hprop); GDKfree(tprop);
			GDKfree(d1); GDKfree(d2);
			advance(t);
		} else
                if(isTypeVar(mb,getArg(p,i)) ){
                        char *tnme= getTypeName(getArgType(mb,p,i));
                        sprintf(t,":%s%s",tnme,(pstring==NULL?"":pstring));
                        GDKfree(tnme);
                        advance(t);
                }

		if(i+1<high) sprintf(t,",");
		if(pstring){ GDKfree(pstring); pstring=0;}
	}
	advance(t);
	if(functionId(p) || p->argc>p->retc+1 ) sprintf(t,")");
	advance(t);
	sprintf(t,";");
	if( flg & (LIST_MAL_TYPE | LIST_MAL_BIND)){
		advance(t);
		t= hiddenInstructionArgs(mb,p,t);
	}
	advance(t);
	/* sprintf(t,"\n");*/
	if(t-s >len)
		GDKfatal("instruction2str:");
	return s;
}
str function2str(MalBlkPtr mb,int flg)
{
	str ps, *txt;
	int i,*len, totlen=0;

	txt= GDKmalloc(sizeof(str) * mb->stop);
	len= GDKmalloc(sizeof(int) * mb->stop);
	for(i=0;i<mb->stop; i++){
		txt[i]= instruction2str(mb, getInstrPtr(mb,i),flg);
		totlen+= len[i]= strlen(txt[i]);
	}
	ps= GDKmalloc(totlen + mb->stop+1 );
	totlen=0;
	for(i=0;i<mb->stop;i++){
		strncpy(ps+totlen,txt[i],len[i]);
		ps[totlen+len[i]]='\n';
		ps[totlen+len[i]+1]=0;
		totlen+= len[i]+1;
		GDKfree(txt[i]);
	}
	GDKfree(len);
	GDKfree(txt);
	return ps;
}
void promptInstruction(stream *fd, MalBlkPtr mb, InstrPtr p, int flg){
	str ps;
	if( fd == 0) GDKfatal("printInstruction:no file\n");
	ps= instruction2str(mb,p,flg);
	/* ps[strlen(ps)-1] = 0; remove '\n' */
	stream_printf(fd,"%s",ps);
	GDKfree(ps);
}
void printInstruction(stream *fd, MalBlkPtr mb, InstrPtr p,int flg){
	promptInstruction(fd,mb,p,flg);
	stream_printf(fd,"\n");
}

void printSignature(stream *fd, Symbol s, int flg){
	InstrPtr p;
	str txt= GDKmalloc(BLOCK);
	bzero(txt,BLOCK);
	p= getSignature(s);
	(void) fcnDefinition(s->def, p,txt, flg);
	stream_printf(fd,"%s\n",txt);
	GDKfree(txt);
}
@+ Garbage collection
Of particular interest is the beforeCall situations for strings and bats.
Before the interpreter calls a function, it should safeguard the
value(s) on top of the stack for garbage collection afterwards.
The before- and after- calls should find a scratch area on the value
stack to keep the backup information around. Currently, we only
garbage collect a single return value and use a fixed value record.

@c 
void strBeforeCall(ValPtr v, ValPtr bak){
	bak->val.sval= v->val.sval;
	bak->len = v->len;
}
void strAfterCall(ValPtr v, ValPtr bak) {
	if( v->val.sval != bak->val.sval) {
		if( bak->val.pval && bak->val.pval != str_nil) {
			if(bak->len) GDKfree(bak->val.pval);
			bak->len= 0;
		}       
		bak->val.pval= NULL;
	}
	v->len= 0;
}

void batBeforeCall(ValPtr v, ValPtr bak){
	if( v->vtype== TYPE_bat)
		bak->val.bval= v->val.bval;
	/*else stream_printf(GDKout,"batBeforeCall:unexpected BAT value\n");
	   it was garbage for sure */
}
@-
After the expression has been evaluated we can release any
pending BAT reference, but the logical reference should be
retained.
This code base assumes no concurrent actions on the same BAT,
otherwise dangling pointers could be created.
@c
void batAfterCall(ValPtr v, ValPtr bak){
	if(v->vtype!= TYPE_bat) {
		/* not ready yet  
		stream_printf(GDKout,"batAfterCall:unexpected BAT value\n"); */
		return;
	}
	if( v->val.bval == bak->val.bval) return;
	if( v->val.bval){
	/* int bid= ABS(v->val.bval);
	   printf("reference counting: %d lrefs=%d refs=%d",
		bid, BBP_lrefs(bid),BBP_refs(bid)); */
		BBPincref(v->val.bval,TRUE);
		if( BBP_refs(v->val.bval) )
			BBPunfix(v->val.bval);
	}
	if( bak->val.bval)
		BBPdecref(bak->val.bval,TRUE);
}
@}
