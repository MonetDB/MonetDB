@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@a M. Kersten
@v 0.0
@* The MAL Interpreter
The MAL interpreter always works in the context of a single user session,
which provides for storage access to global variables and modules.

Runtime storage for variables are allocated on the stack of the
interpreter thread. The physical stack is often limited in size,
which calls for safeguarding their value and garbage collection before returning.
A malicious procedure or implementation will lead to memory leakage.

A system command (linked C-routine) may be interested in extending the
stack. This is precluded, because it could interfere with the recursive
calling sequence of procedures. To accommodate the (rare) case, the routine
should issue an exception to be handled by the interpreter before retrying.
All other errors are turned into an exception, followed by continuing
at the exception handling block of the MAL procedure.

@{
@h
#ifndef _MAL_INTERPRET_H
#define _MAL_INTERPRET_H

#include "mal_client.h"
#include "mal_factory.h"
#include "mal_profiler.h"

@-
Activation of a thread requires construction of the argument list
to be passed by a handle.
@h
typedef struct{
    Client cntxt; 
    MalBlkPtr mb; 
    MalStkPtr stk; 
    int startpc,stoppc; 
    MalStkPtr env;
    InstrPtr pcicaller;
    InstrPtr pci;
} malTask;

/*#define DEBUG_MAL_INTERPRETER */
/*#define DEBUG_MAL_PARALLEL */
/*#define STACKTRACE*/
mal_export void showErrors(void);
mal_export str runMAL(Client c, MalBlkPtr mb, int startpc,
        MalBlkPtr mbcaller, MalStkPtr env, InstrPtr pcicaller);
mal_export str reenterMAL(Client cntxt, MalBlkPtr mb, int startpc,
	int stoppc, MalStkPtr stk, MalStkPtr env, InstrPtr pcicaller);
mal_export str runMALsequence( malTask *task);
mal_export void runMALtask(malTask *task);
mal_export void waitForChildren(MalStkPtr stk);
mal_export void garbageElement(ValPtr v);
mal_export void garbageCollector(MalBlkPtr mb, MalStkPtr stk);
mal_export void garbageCollectAll(MalBlkPtr mb, MalStkPtr stk);
mal_export void releaseBAT(MalBlkPtr mb, MalStkPtr stk, int bid);

mal_export ptr getArgValue(MalStkPtr stk, 
        InstrPtr pci, int k);
mal_export ptr getArgReference(MalStkPtr stk, 
        InstrPtr pci, int k);
mal_export str setDynamicType(MalBlkPtr mb, VarPtr v, int tpe, int pc);
#endif /*  _MAL_INTERPRET_H*/
@c
#include "mal_interpreter.h"
#include "mal_debugger.h"   /* for mdbStep() */
#include "mal_type.h"       

@-
We can speed up the copying, provided we ignore copying ptr-based
objects.
@c
#define VALcopy2(lhs,rhs) if( rhs->vtype < TYPE_str) *lhs = *rhs; else VALcopy(lhs,rhs);

ptr getArgValue(MalStkPtr stk, InstrPtr pci, int k){
    int j=0;
    ValRecord *v;
    ptr val = NULL;
    int tpe ;

    j = pci->argv[k];
    v= &stk->stk[j];
    tpe = v->vtype;
tstagain:
    switch(tpe){
    /* switch(ATOMstorage(v->vtype)){ */
    case TYPE_void: val= (ptr) & v->val.ival; break;
    case TYPE_bit: val= (ptr) & v->val.cval[0]; break;
    case TYPE_chr: val= (ptr) & v->val.cval[0]; break;
    case TYPE_sht: val= (ptr) & v->val.shval; break;
    case TYPE_bat: val= (ptr) & v->val.br.id; break;
    case TYPE_int: val= (ptr) & v->val.ival; break;
    case TYPE_oid: val= (ptr) & v->val.oval; break;
    case TYPE_ptr: val= (ptr) v->val.pval; break;/*!!*/
    case TYPE_flt: val= (ptr) & v->val.fval; break;
    case TYPE_dbl: val= (ptr) & v->val.dval; break;
    case TYPE_lng: val= (ptr) & v->val.lval; break;
    case TYPE_str: val= (ptr) v->val.sval; break;/*!!*/
    default:
        tpe= ATOMstorage(tpe);
        goto tstagain;
/*
    val= (ptr) v->val.pval; 
    GDKerror("evalParameters:unknown value type\n");*/
    }
    return val;
} 
@-
Alternatively, the routines can obtain a reference to a particular
value. This is particularly handy for the optimizers, while the former
is mostly used to prepare a call to the linked libraries.
The struct alignment leads to 40% gain in simple instructions when set.
@c
INLINE
ptr getArgReference(MalStkPtr stk, InstrPtr pci, int k)
{
#ifdef STRUCT_ALIGNED
    return (ptr) & stk->stk[pci->argv[k]].val.ival;
#else
    int j=0;
    ValRecord *v=0;
    ptr ret = NULL;

    j = pci->argv[k];
    v= &stk->stk[j];

    switch(ATOMstorage(v->vtype)){
    case TYPE_void: ret= (ptr) & v->val.ival; break;
    case TYPE_bit: ret= (ptr) & v->val.cval[0]; break;
    case TYPE_chr: ret= (ptr) & v->val.cval[0]; break;
    case TYPE_sht: ret= (ptr) & v->val.shval; break;
    case TYPE_bat: ret= (ptr) & v->val.br.id; break;
    case TYPE_int: ret= (ptr) & v->val.ival; break;
    case TYPE_oid: ret= (ptr) & v->val.oval; break;
    case TYPE_ptr: ret= (ptr) & v->val.pval; break;
    case TYPE_flt: ret= (ptr) & v->val.fval; break;
    case TYPE_dbl: ret= (ptr) & v->val.dval; break;
    case TYPE_lng: ret= (ptr) & v->val.lval; break;
    case TYPE_str: ret= (ptr) & v->val.sval; break;
    default:
         ret= (ptr) & v->val.pval; 
    }
    return ret;
#endif
} 
void showErrors(){
    Client cntxt= getClient();
    int i;
    if( cntxt->errbuf==0 ) return;
    if( *cntxt->errbuf){
        i= strlen(cntxt->errbuf);
        stream_printf(cntxt->fdout,"%s",cntxt->errbuf);
        if( cntxt->errbuf[i-1]!='\n') 
            stream_printf(cntxt->fdout,"\n");
        stream_flush(cntxt->fdout);
        *cntxt->errbuf=0;
    }
}

str runMAL(Client cntxt, MalBlkPtr mb, int startpc, MalBlkPtr mbcaller, 
       MalStkPtr env, InstrPtr pcicaller){
    MalStkPtr stk= NULL;
    int i;
    ValPtr lhs,rhs;
    InstrPtr pci=0;
    malTask task;
    str ret;

    if( mb->errors){
        char buf[2*PATHLENGTH];
        showErrors();
        sprintf(buf, "'%s.%s' contains errors\n",
            getModName(mb),getFcnName(mb));
		if( cntxt->itrace == 0 )
			return raiseException(mb,0,"SyntaxError",buf);
    }
@-
Prepare a new interpreter call. This involves two steps, (1) allocate
the minimum amount of stack space needed, some slack resources
are included to permit code optimizers to add a few variables at run time,
(2) copying the arguments into the new stack frame.
Notice that arguments are always the first entries on the stack.

The env stackframe is set when a MAL function is called recursively.
Alternatively, there is no caller but a stk to be re-used for interpretation.
We assume here that it aligns with the variable table of the routine
being called.
@c
    /* allocate space for value stack */
    /* the global stack should be large enough */
    if( mbcaller== NULL && env != NULL){
        stk = env;
        if( mb != stk->blk) 
            GDKerror("runMAL:misalignment of symbols\n");
        if( mb->vtop > stk->stksize) {
            GDKerror("stack too small");
        }
        pci= pcicaller;
    } else {
        newStack(stk,mb->vsize);
		memset((char *) stk, 0, stackSize(mb->vtop));
		stk->stktop= mb->vtop; 
		stk->stksize= mb->vsize;
		stk->blk= mb;
		stk->cmd= cntxt->itrace; /* set debug mode */
        if( env) {
            stk->stkdepth= stk->stksize + env->stkdepth;
            @:safeguardStack@
        }
    } 
    if( stk->stktop>stk->stksize) GDKerror("Unexpected");

    if( env && mbcaller){
        InstrPtr pp;
        int k;
@-
Beware, a function signature f(a1..an):(b1..bn) is parsed in such a way that
the symbol table and stackframe contains the sequence 
f,a1..an,b1..bn. This slightly complicates the implementation
of the return statement.
@c
        pci= pcicaller;
        pp = getInstrPtr(mb, 0);
        /* set return type */
        lhs = &stk->stk[0];
        lhs->vtype =getVarGDKType(mb,0);
        if(lhs->vtype <0)
            GDKerror("unexpected type error\n");
        /* stream_printf(GDKout,"recursive MAL "
                "function call %s[%d]\n",
            functionName(pci),pcicaller); */
        i= pci->retc;
        for(k=pp->retc; i<pci->argc; i++,k++){
            lhs = &stk->stk[pp->argv[k]];
            /* variable arguments ? */
            if( k== pp->argc-1) k--; 

            rhs = &env->stk[pci->argv[i]];
            VALcopy2(lhs,rhs);
			if( lhs->vtype == TYPE_bat)
				BBPincref(lhs->val.br.id, TRUE);
        }
        stk->up = env;
        env->down = stk;
    } 
@-
An optimization is to copy all constant variables used in functions immediately
onto the value stack. Then we do not have to check for their location
later on any more. At some point, the effect is optimal, if at least several
constants are referenced in a function (a gain on tst400a of 20% has been 
observed due the small size of the function).

Moreover, we have to copy the result types to the stack for later
use. The stack value is cleared to avoid misinterpretation of left-over
information. Since a stack frame may contain values of a previous call,
we should first remove garbage. A problematic case is when
the variable accepts any type, then we leave it up to the 
pattern operators to deal with it.
@c
    for(i= (env && mbcaller)?pci->argc:1; i< mb->vtop; i++)
    if( isConstant(mb,i) && isVarUsed(mb,i) ){
        lhs = &stk->stk[i];
        rhs = &getVarConstant(mb,i);
        VALcopy2(lhs,rhs);
    } else {
        int tpe= getVarType(mb,i);
        lhs = &stk->stk[i];
        if( tpe != TYPE_any)
            lhs->vtype = getVarGDKType(mb,i);
    }
#ifdef STACKTRACE
    stream_printf(GDKout,"Stack before loop\n");
    printStack(GDKout,mb,stk); fflush(GDKout);
#endif

    task.cntxt= cntxt; 
    task.mb= mb; 
    task.stk=stk; 
    task.startpc=startpc; 
	task.stoppc = 0; /* continue to end */
    task.env=env;
    task.pcicaller=pcicaller;
    task.pci= 0;

    if(env && stk->cmd!='f') stk->cmd = env->cmd ;
    ret= runMALsequence(&task);

    @:waitForChildren@
    /* pass the debug mode */
    if(env && stk->cmd!='f') env->cmd = stk->cmd; 
#ifdef STACKTRACE
    stream_printf(GDKout,"Stack after loop\n");
    printStack(GDKout,mb,stk); fflush(GDKout);
#endif
    if( !stk->keepAlive && garbageControl(getInstrPtr(mb,0)) ){
		if( env!= stk) 
                garbageCollectAll(mb,stk);
        else garbageCollector(mb,stk);
	}
    return ret;
}
@-
@+ Single instruction
It is possible to re-enter the interpreter at a specific place.
This is used in the area where we need to support co-routines.

A special case for MAL interpretation is to execute just one instruction.
This is typically used by optimizers and schedulers that need part of the 
answer to direct their actions. Or, a dataflow scheduler could step in
to enforce a completely different execution order.
@c
str reenterMAL(Client cntxt, MalBlkPtr mb, int startpc, int stoppc,
	MalStkPtr stk, MalStkPtr env, InstrPtr pcicaller)
{
    malTask task;
    str ret;
	task.cntxt= cntxt;
	task.mb= mb;
	task.stk=stk;
	task.startpc=startpc;
	task.stoppc=stoppc;
	task.env=env;
	task.pcicaller=pcicaller;
	task.pci= 0;

	if(env && stk && stk->cmd!='f') stk->cmd = env->cmd ;

	ret= runMALsequence(&task);

	@:waitForChildren@
	/* pass the debug mode */
	if(env && stk->cmd!='f') env->cmd = stk->cmd;
#ifdef STACKTRACE
	stream_printf(GDKout,"Stack after loop\n");
	printStack(GDKout,mb,stk); fflush(GDKout);
#endif
    if( !stk->keepAlive && garbageControl(getInstrPtr(mb,0)) ){
		if( env!= stk)
			garbageCollectAll(mb,stk);
        else garbageCollector(mb,stk);
	}
	return ret;
}
@-
The core of the interpreter is presented next. It takes the context information
and starts the interpretation at the designated instruction.
Note that the stack frame is aligned and initialized in the enclosing routine.
This way we prepare the route for running parallel threads.
@c
str runMALsequence( malTask *task)
{   
    Client cntxt= task->cntxt; 
    MalBlkPtr mb= task->mb; 
    MalStkPtr stk= task->stk;
    MalStkPtr env= task->env;
    InstrPtr pcicaller= task->pcicaller;
    int childProcess= task->pci?getDestVar(task->pci):0;

    ValPtr lhs,rhs,v;
    int stkpc,i,k; 
    InstrPtr pci=0; 
    int stkexception;
    str ret=0;
	int backup[MAXARG];
	str sbackup[MAXARG];
	lng total=0;
    @:performanceVariables@

	if( cntxt->timer)
		cntxt->timer= GDKusec();
		
MALrestart:
    stkpc = task->startpc;
    stkexception = -1;
    while(stkpc < mb->stop && stkpc != task->stoppc ){
        pci = getInstrPtr(mb,stkpc);
        if( stk->cmd  ) {
			mdbStep(cntxt,mb,stk,stkpc);
            if( stk->cmd == 'x') goto MALevalExit;
        }

        @:MALinterpret@
    }
MALevalExit:
    @:finishChild@
    if( stkexception >= 0) {
		if( ret )
			ret= appendException(mb,mb->stop-1,
				getVarName(mb,stkexception),
				"Exception not catched", ret);
		else
        if(stk->stk[stkexception].vtype== TYPE_str)
			ret= appendException(mb,mb->stop-1,MALexception, 
			"Exception not catched", 
            stk->stk[stkexception].val.sval);
		else
			ret= appendException(mb,mb->stop-1,MALexception, 
			"Exception not catched", "");
    }
    return ret;
}
void runMALtask(malTask *task){
    ValPtr v;
#ifdef DEBUG_MAL_PARALLEL
    stream_printf(GDKout,"create childs in stk %d %d %d\n", 
        (void *) task, task->stk->shares, &task->stk->shares);
    stream_printf(GDKout," task->cntxt = %d\n",task->cntxt);
    stream_printf(GDKout," task->mb = %d\n",task->mb);
    stream_printf(GDKout," task->stk = %d\n",task->stk);
    stream_printf(GDKout," task->startpc = %d\n",task->startpc);
    stream_printf(GDKout," task->stoppc = %d\n",task->stoppc);
    stream_printf(GDKout," task->env = %d\n",task->env);
    stream_printf(GDKout," task->pcicaller = %d\n",
                    task->pcicaller);
    stream_printf(GDKout," task->pci = %d\n",task->pci);
    stream_printf(GDKout,"childs sets return variable %d \n",
        getDestVar(task->pci));
    stream_printf(GDKout,"start parallel sequence\n");
#endif
    v= &task->stk->stk[ getDestVar(task->pci)];
    v->val.ival=  (int) MT_getpid();
    runMALsequence(task);
    GDKfree(task);
}
@+ Safeguarding
The physical stack for each thread is an operating system parameter.
We do not want recursive programs crashing the server, so once in
a while we check whether we are running dangerously low on available
stack space.

This situation can be detected by calling upon the GDK functionality
of by limiting the depth of a function calls.
@-
@= safeguardStack
/* Expensive? 70 msec for 1M calls another solution is needed.*/
    if (stk->stkdepth > (size_t) 50 * 1024 && THRhighwater()) {
        GDKerror("interpret: running out of "
         "physical stack space!\n");
    return raiseException(mb,0,"Interpreter","Stack overflow");
    }

@+ The interpreter loop
The interpreter is geared towards execution a MAL procedure together
with all its decendant invocations. As such, it provides the 
MAL abtract machine processor.

The value-stack frame of the surrounding scope is needed to resolve
binding values.  Getting (putting) a value from (into) a surrounding
scope should be guarded with the exclusive access lock.
This situation is encapsulated by a bind() function call, whose parameters
contain the access mode required.

The formal procedure arguments are assumed to always occupy the first
elements in the value stack.
@+ The major switch

@= MALinterpret
    @:beginProfile@
    ret = 0;
    switch( pci->token){
    case ASSIGNsymbol:
        @:assignStmt@ 
        break;
    case PATcall: @:patterncall@ break;
    case CMDcall: @:commandcall@ break;
    case FACcall: @:factorycall@ break;
    case FCNcall: @:functioncall@ break;
    case NOOPsymbol:
	case REMsymbol:
    case COMMANDsymbol:
    case FUNCTIONsymbol:
    case FACTORYsymbol:
        break;
    case ENDsymbol: 
        if( getInstrPtr(mb,0)->token == FACTORYsymbol)
            ret= shutdownFactory(mb);
		if( total  )
			cntxt->timer= GDKusec()-total;
		if( pcicaller && garbageControl(getInstrPtr(mb,0)) )
			garbageCollectAll(mb, stk);
        @:endProfile@
        goto MALevalExit;
    default:
        GDKerror("ERROR:MALeval:unkown operation\n");
        @:endProfile@
        goto MALevalExit;
    }
    @:MALflowofcontrol@
    @:endProfile@
@-
After the expression has been evaluated we should check for a
possible change in the control flow. 
@= MALflowofcontrol
    switch(pci->barrier){
    case BARRIERsymbol:
        @:barrierControl@ stkpc++;
        break;
    case LEAVEsymbol:
        @:finishChild@
    case REDOsymbol:
        v= &stk->stk[getDestVar(pci)];
        /* skip to end of barrier, depending on the type */
        switch(v->vtype){
        case TYPE_bit:
            if( v->val.cval[0] == TRUE && v->val.cval[0] != bit_nil)
                stkpc= pci->jump; 
            else stkpc++;
            break;
        case TYPE_str:
            if( v->len > 0 && v->val.pval!= str_nil )
                stkpc= pci->jump; 
            else stkpc++;
            break;
        case TYPE_sht:
            if( v->val.shval >= 0 && v->val.shval!= sht_nil )
                stkpc= pci->jump; 
            else stkpc++;
            break;
        case TYPE_int:
            if( v->val.ival >= 0 && v->val.ival!= int_nil )
                stkpc= pci->jump; 
            else stkpc++;
            break;
        case TYPE_lng:
            if( v->val.lval >= 0 && v->val.lval!= lng_nil)
                stkpc= pci->jump; 
            else 
        default:
                stkpc++;
        }
        break;
    case CATCHsymbol:
        /* catch blocks are skipped unless 
           searched for explicitly*/
        if(stkexception < 0) { 
            stkpc= pci->jump; 
            break;
        }
        stkexception = -1;
        stkpc++; 
        break;
    case EXITsymbol:
        @:finishChild@
        if( getDestVar(pci) == stkexception) 
            stkexception = -1; 
        stkpc++; 
        break;
    case RAISEsymbol:
        stkexception = getDestVar(pci);
        if( getVarType(mb, getDestVar(pci))== TYPE_str){
            ret= raiseException(mb, stkpc, 
                getVarName(mb, getDestVar(pci)), 
                stk->stk[getDestVar(pci)].val.sval);
        } else
            ret= raiseException(mb,stkpc, 
                getVarName(mb, getDestVar(pci)), 
                "Exception raised\n");
        @:skipToCatch(stkexception)@
        break;
    case THREADsymbol:
        @:createChild@
        stkpc++;
        break;
    case YIELDsymbol: /* to be defined */
        return yieldFactory( mb, pci, stkpc);
    case RETURNsymbol:
        /* Return from factory involves cleanup */

        if( getInstrPtr(mb,0)->token == FACTORYsymbol){
            ret= returnFactory(mb, pci, stkpc);
            @:endProfile@
            goto MALevalExit;
        }
        /* a fake multi-assignment */
        if( env != NULL && pcicaller != NULL){
            InstrPtr pp=pci;
            @:endProfile@
            pci= pcicaller;
            for(i=0;i < pci->retc; i++){
                rhs = &stk->stk[pp->argv[i]];
                lhs = &env->stk[pci->argv[i]];
                VALcopy2(lhs,rhs);
                if( needsCleanup(pci)){
                    for(k= pci->retc; k< pci->argc; k++)
                        if( getArg(pci,k) == getArg(pci,i) ) goto noinc;
                    if( lhs->vtype == TYPE_bat )
                        BBPincref(lhs->val.br.id, TRUE); 
                }
				noinc:;
            }
            if( garbageControl(getInstrPtr(mb,0)) )
                garbageCollectAll(mb, stk);
			/* propagate fake response time */
			if( total )
				cntxt->timer= GDKusec()-total;
            goto MALevalExit;
        } 
        @:endProfile@
        goto MALevalExit;
    default:
        if( getDestVar(pci) == stkexception) 
            stkexception = -1; 
        stkpc++; 
    }

@+ Assignment command
The assignment statement copies values around on the stack frame,
including multiple assignments.

Pushing constants/initial values onto the stack is a separate operation.
It takes the constant value discovered at compile time and stored in the
symbol table and moves it to the stackframe location. This activity
is made part of the start-up procedure.

The before after calls should be reconsidered here, because
their. They seem superflous and the way they are used will
cause errors in multi-assignment statements.
@-
@= assignStmt
{	
	@:safeTarget@
    for(k=0, i=pci->retc; k<pci->retc && i<pci->argc; i++,k++){
        lhs = &stk->stk[pci->argv[k]];
        rhs = &stk->stk[pci->argv[i]];
        VALcopy2(lhs,rhs);
		if( lhs->vtype == TYPE_bat)
			BBPincref(lhs->val.br.id, TRUE);
    }
	@:restoreTarget@
    ret = 0;
}
@-
@}
@+ MAL API
The linkage between MAL interpreter and compiled C-routines
is kept as simple as possible.
Basically we distinguish four kinds of calling conventions:
CMDcall, FCNcall, THRDcall, and  PATcall.
The FCNcall indicates calling a MAL procedure, which leads
to a recursive call to the interpreter. 

CMDcall initiates calling a linked function, passing pointers 
to the parameters and result variable, i.e.  f(ptr a0,..., ptr aN)
The function returns a MAL-SUCCEED upon success and a pointer
to an exception string upon failure.
Failure leads to raise-ing an exception in the interpreter loop,
by either looking up the relevant exception message in the module
administration or construction of a standard string.
Upon successfull return, we update the ValRecord with length indications.

The THRDcall initiates a separate thread of control, which 
receives requests for execution through a event-pool.
[details later]

The PATcall initiates a call which contains the MAL context.
i.e. f(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
The blk provides access to the code definitions. It is primarilly
used by routines intended to manipulate the code base itself, such
as the optimizers. The Mal stack frame pointer provides access
to the values maintained. The arguments passed are offsets
into the stack frame rather than pointers to the actual value.

BAT parameters require some care. Ideally, a BAT should not be kept
around long. This would mean that each time we access a BAT it has to be
pinned in memory and upon leaving the function, it is unpinned.
This degrades performance significantly. 
After the parameters are fixed, we can safely free the destination
variable and re-initialize it to nil;

@{
The policy implemented here is to make pin/unpin decisions part of
the bind(namespace, batname, mode) operation. [todo]

@= safeTarget
    if( needsCleanup(pci) ){ 
		for(i=0; i<pci->retc; i++) {
			sbackup[i]= 0;  
			backup[i]= 0;  
			if( stk->stk[getArg(pci,i)].vtype == TYPE_bat)
				backup[i]= stk->stk[getArg(pci,i)].val.br.id;
			else if( stk->stk[getArg(pci,i)].vtype == TYPE_str){
					backup[i]= stk->stk[getArg(pci,i)].len;
					sbackup[i]= stk->stk[getArg(pci,i)].val.sval;
			} 
		}
	} 
@= restoreTarget
    if( needsCleanup(pci) ){ 
		for(i=0; i<pci->retc; i++)
		if( stk->stk[getArg(pci,i)].vtype == TYPE_bat){
			if( backup[i] ){
				BBPdecref(backup[i],TRUE);
			} 
 			if(!isVarUsed(mb,getArg(pci,i)) ){
				garbageElement(&stk->stk[getArg(pci,i)]);
			}
		} else 
		if( stk->stk[getArg(pci,i)].vtype == TYPE_str){
			int a= getArg(pci,i);
			if( sbackup[i] && sbackup[i]!= stk->stk[a].val.sval){
				if( backup[i] > 0) 
					GDKfree(sbackup[i]);
				backup[i]=0;
			} 
 			if(!isVarUsed(mb,a) ){
				garbageElement(&stk->stk[a]);
			}
		} 
	}
@-
@= commandcall
{	
	@:safeTarget
    /* improve performance with 20 ms/1M calls*/
    switch(pci->argc){
    case 0 : ret = (str) (*pci->fcn)(); break;
    case 1 : ret = (str) (*pci->fcn)(
			(ptr) getArgReference(stk,pci,0)); break;
    case 2 : ret = (str) (*pci->fcn)(
			(ptr) getArgReference(stk,pci,0),
			(ptr) getArgReference(stk,pci,1)); 
                break;
    case 3 : ret = (str) (*pci->fcn)(
			(ptr) getArgReference(stk,pci,0),
			(ptr) getArgReference(stk,pci,1),
			(ptr) getArgReference(stk,pci,2)); 
                break;
    case 4 : ret = (str) (*pci->fcn)(
			(ptr) getArgReference(stk,pci,0),
			(ptr) getArgReference(stk,pci,1),
			(ptr) getArgReference(stk,pci,2),
			(ptr) getArgReference(stk,pci,3)); 
                break;
    case 5 : ret = (str) (*pci->fcn)(
			(ptr) getArgReference(stk,pci,0),
			(ptr) getArgReference(stk,pci,1),
			(ptr) getArgReference(stk,pci,2),
			(ptr) getArgReference(stk,pci,3), 
			(ptr) getArgReference(stk,pci,4)); 
                break;
    case 6 : ret = (str) (*pci->fcn)(
			(ptr) getArgReference(stk,pci,0),
			(ptr) getArgReference(stk,pci,1),
			(ptr) getArgReference(stk,pci,2),
			(ptr) getArgReference(stk,pci,3),
			(ptr) getArgReference(stk,pci,4),
			(ptr) getArgReference(stk,pci,5)); 
                break;
    case 7 : ret = (str) (*pci->fcn)(
			(ptr) getArgReference(stk,pci,0),
			(ptr) getArgReference(stk,pci,1),
			(ptr) getArgReference(stk,pci,2),
			(ptr) getArgReference(stk,pci,3),
			(ptr) getArgReference(stk,pci,4),
			(ptr) getArgReference(stk,pci,5),
			(ptr) getArgReference(stk,pci,6)); 
                break;
    case 8 : ret = (str) (*pci->fcn)(
			(ptr) getArgReference(stk,pci,0),
			(ptr) getArgReference(stk,pci,1),
			(ptr) getArgReference(stk,pci,2),
			(ptr) getArgReference(stk,pci,3),
			(ptr) getArgReference(stk,pci,4),
			(ptr) getArgReference(stk,pci,5),
			(ptr) getArgReference(stk,pci,6),
			(ptr) getArgReference(stk,pci,7)); 
                break;
    case 9 : ret = (str) (*pci->fcn)(
			(ptr) getArgReference(stk,pci,0),
			(ptr) getArgReference(stk,pci,1),
			(ptr) getArgReference(stk,pci,2),
			(ptr) getArgReference(stk,pci,3),
			(ptr) getArgReference(stk,pci,4),
			(ptr) getArgReference(stk,pci,5),
			(ptr) getArgReference(stk,pci,6),
			(ptr) getArgReference(stk,pci,7),
			(ptr) getArgReference(stk,pci,8)); 
                break;
    default:
        ret= raiseException(mb,stkpc,MALexception,
            "too many arguments for command call\n");
    }
	@:restoreTarget@
    @:resultParameter@
}
@-
@= patterncall
    if( pci->fcn== NULL)
        ret= raiseException(mb,stkpc,MALexception,
            "address of pattern missing\n");
    else {
		@:safeTarget@
        ret = (str) (*pci->fcn)(mb,stk,pci);
		@:restoreTarget@
        @:resultParameter@
    }
@-
MAL function calls are relatively expensive, because they have to assemble
a new stack frame and do housekeeping, such as garbagecollection of all
non-returned values.

@-
@= functioncall
{	
    stk->pcup = stkpc;
    @:safeTarget@
    ret= runMAL(cntxt,pci->blk,1,mb,stk,pci);
    @:restoreTarget@
    @:resultParameter@
}
@-
Factory calls are more involved. At this stage it is a synchrononous
call to the factory manager.
Factory calls should deal with the reference counting.
@= factorycall
    if( pci->blk== NULL)
        ret= raiseException(mb,stkpc,MALexception,
            "reference to MAL function missing\n");
    else
        ret= callFactory(cntxt,pci->blk,mb,stk,pci);
    @:resultParameter@
@-
The type dispatching table in getArgValue can be removed if we 
determine at compile time the address offset within a ValRecord. 
We leave this optimization for the future, it leads to about 10%
improvement (100ms for 1M calls).
@-
Upon return of the function we may be interested in the result
and we have to do some housekeeping, such as string length adjustment.

@-
@= resultParameter
    @:exceptionHndlr@

@+ Flow of control statements
Each assignment (function call) may be part of the initialization
of a barrier- block. In that case we have to test the
outcome of the operation and possibly skip the block altogether.
The latter is implemented as a linear scan for the corresponding
labeled statemtent. This might be optimized later.

@= barrierControl
{   v= &stk->stk[getDestVar(pci)];
    /* skip to end of barrier, depends on the type */
    switch(v->vtype){
    case TYPE_bit:
        if( v->val.cval[0] == FALSE || v->val.cval[0] == bit_nil)
            stkpc= pci->jump;
        break;
    case TYPE_chr:
        if( v->val.cval[0] == chr_nil )
            stkpc= pci->jump;
        break;
    case TYPE_oid:
        if( v->val.ival == oid_nil )
            stkpc= pci->jump;
        break;
    case TYPE_sht:
        if( v->val.shval < 0 || v->val.shval == sht_nil)
            stkpc= pci->jump; 
        break;
    case TYPE_int:
        if( v->val.ival < 0 || v->val.ival == int_nil)
            stkpc= pci->jump; 
        break;
    case TYPE_lng:
        if( v->val.lval < 0 || v->val.lval == lng_nil)
            stkpc= pci->jump; 
        break;
    case TYPE_flt:
    case TYPE_dbl:
        if( v->val.dval < 0 || v->val.dval == dbl_nil)
            stkpc= pci->jump; 
        break;
    case TYPE_str:
        if( v->len == 0 || v->val.pval == str_nil)
            stkpc= pci->jump; 
        break;
    default:
        ret= raiseException(mb,stkpc,
                getVarName(mb, getDestVar(pci)), 
            "Unknown barrier type\n");
    }
}

@-
You can skip to a catch block by searching for the corresponding 'lab'
The return value should be set to pass the error automatically upon
reaching end of function block.
@-
@= skipToCatch
	if( stk->cmd == 'C') {
		stk->cmd = 'n';
		mdbStep(cntxt,mb,stk,stkpc);
		if( stk->cmd == 'x') goto MALevalExit;
	}
    /* skip to catch block or end */
    for( ; stkpc<mb->stop; stkpc++){
    InstrPtr l= getInstrPtr(mb,stkpc);
    if( l->barrier == CATCHsymbol ){
        int j= -1;
        for(j=0;j<l->retc; j++)
        if( getArg(l,j) == @1) break;
        if(j>=0) break;
    } }
    if( stkpc== mb->stop) {
        @:endProfile@ 
        goto MALevalExit;
    }
@-
Each time we enter a barrier block, we could keep its position in the
interpreter stack frame. It forms the starting point to issue a redo.
Unfortunately, this does not easily work in the presence of optimizers, which
may change the order/block structure. Therefore, we simple have to search
the beginning or ensure that during chkProgram the barrier/redo/leave/catch
jumps are re-established.

@-
@= redoControl
    stkpc = pci->jump;
    @:endProfile@
    pci= getInstrPtr(mb,stkpc);
    if( pci->barrier == THREADsymbol){
        /* restart thread body */
        stkpc++;
    } else
    /* semantic validity of redo stmt has been checked already */
    /* continue re-execution of the barrier statement */
    continue;
@-
@}
@+ Parallel processing
The MAL interpreter can be cloned to obtain parallel running threads.
Such threads share the stackframe of the caller for data exchange.
The consequence is that a thread may only terminate when it is
not the parent of one or more children
administered on a stack-frame variable.

A thread block encountered in a MAL program leads to at most
one thread instance. This is detected by setting the thread
variable to the process id. The thread block is skipped when it
has already been set. 

A thread can be separated from its parent using the command
thread.exec(arguments). The thread identity is being returned.

Wait for all children to end. Using a timer to control malicious
children does not work in general, because you don;t know
what default will work. Instead, the list of children 
threads should be accessible.

Factories that encountered an exception should decrease
the share count as well. This will terminate its
existence.
@{
@-
@= waitForChildren
if(stk->shares) {
    if( ret && getInstrPtr(mb,0)->token == FACTORYsymbol){
        printf("release stack for factory\n");
        shutdownFactory(mb);
    } else
    waitForChildren(stk);
}
@c
void waitForChildren(MalStkPtr stk){
    int i= stk->shares;
    while(i>0 ) { 
        mal_set_lock(stk->stklock,"finishChild");
        i= stk->shares;
        mal_unset_lock(stk->stklock,"finishChild");
#ifdef DEBUG_MAL_PARALLEL
        stream_printf(GDKout,"%d awaiting childs\n",
            MT_getpid());
#endif
        MT_sleep_ms(1000); 
    }
}
@-
Joining a process thread is controlled with a lock part of the stack frame

@-
@= createChild
{   MT_Id pid;
    malTask *task= (malTask*) GDKmalloc(sizeof(malTask));
    ValPtr vp= &stk->stk[getDestVar(pci)];

    if( vp->val.ival){
        /* thread already running */
        stkpc= pci->jump;
        break;
    }
    GDKprotect();
    if(stk->stklock== 0 && GDKprotected) stk->stklock= MT_create_lock();
    mal_set_lock(stk->stklock,"createChild");
    if( stk->shares == MAXSHARES){
        ret= raiseException(mb,stkpc,MALexception,
                    "too many threads\n");
        stkexception= findVariable(mb,"MALexception");
        @:exceptionHndlr@
        break; /* out of instruction switch */
    } 
    vp->val.ival = 1; /* already created, temporary identity */
    stk->childs[stk->shares]= getDestVar(pci);
    stk->shares++;
    mal_unset_lock(stk->stklock,"createChild");
    task->cntxt= cntxt; 
    task->mb= mb; 
    task->stk=stk; 
    task->startpc=stkpc+1; 
	task->stoppc = 0;
    task->env=env;
    task->pcicaller=pcicaller;
    task->pci= pci;

#ifdef DEBUG_MAL_PARALLEL
    stream_printf(GDKout,"started parallel thread,");
    stream_printf(GDKout," task->cntxt = %d\n",task->cntxt);
    stream_printf(GDKout," task->mb = %d\n",task->mb);
    stream_printf(GDKout," task->stk = %d\n",task->stk);
    stream_printf(GDKout," task->startpc = %d\n", task->startpc);
    stream_printf(GDKout," task->stoppc = %d\n", task->stoppc);
    stream_printf(GDKout," task->env = %d\n",task->env);
    stream_printf(GDKout," task->pcicaller = %d\n",
                task->pcicaller);
    stream_printf(GDKout," task->pci = %d\n",task->pci);
    printInstruction(GDKout, mb, pci,LIST_MAL_ALL);
#endif
    MT_create_thread(&pid, (void (*) (void *))runMALtask, (void*) task);
    stkpc= pci->jump; /* search end of parallel block */
}
@= finishChild
    if( childProcess && childProcess== getDestVar(pci)){
        int j,k,lim;
        mal_set_lock(stk->stklock,"finishChild");
#ifdef DEBUG_MAL_PARALLEL
    stream_printf(GDKout,"finish the child "
        "%d %s\n",childProcess, 
            getVarName(mb,childProcess));
#endif
        lim= stk->shares;
        for(k=j=0;j<lim;j++)
        if( stk->childs[j]!= childProcess)
            stk->childs[k++]= stk->childs[j];
        else    stk->shares--;
        childProcess=0;
        mal_unset_lock(stk->stklock,"finishChild");
#ifdef DEBUG_MAL_PARALLEL
    stream_printf(GDKout,"finished childs in stk "
        "%d %d\n",stk->shares, &stk->shares);
#endif
        if(stkexception != -1){
            /* pass exception as GDK error */
            GDKerror("non-catched thread exception\n");
        }
        goto MALevalExit;
    }
#ifdef DEBUG_MAL_PARALLEL
    else
    stream_printf(GDKout,"finish the child  ignored "
        "%d %s\n",childProcess, 
            getVarName(mb,childProcess));
#endif
@-
@}
@+ Exception handling
Calling a built-in or user-defined routine may lead to an error, a
cached status message to be dealt with in MAL, or as an error status in Mapi.
@{
[there are about 55 GDKerror calls in gdk, 91 in monet, and 167 in 
the modules/plain/*.  The number of fatal errors is 26,7, 2, respectively.]
@}

To improve error handling in MAL, an exception handling
scheme based on @code{catch}-@code{exit} blocks. The @code{catch}
statement identifies a (string-valued) variable, which carries the 
exception message from
the originally failed routine or @code{raise} exception assignment.
During normal processing @code{catch}-@code{exit} blocks are simply skipped.
Upon receiving an exception status from a function call, we set the 
exception variable and skip to the first associated @code{catch}-@code{exit} 
block.
MAL interpretation then continues until it reaches the end of the block.
If no exception variable was defined, we should abandon the function
alltogether searching for a catch block at a higher layer.

@{
For the time being we have ignored cascaded/stacked exceptions.
The policy is to pass the first recognized exception to a context
in which it can be handled.

@}
@-
Exceptions raised within a linked-in function requires some care.
First, the called procedure does not know anything about the MAL
interpreter context. Thus, we need to return all relevant information
upon leaving the linked library routine.

Second, exceptional cases can be handled deeply in the recursion, where they
may also be handled, i.e. by issueing an GDKerror message. The upper layers
merely receive a negative integer value to indicate occurrence of an
error somewhere in the calling sequence.
We have to also look into GDKerrbuf to see if there was
an error raised deeply inside the system.

The policy is to require all C-functions to return a string-pointer. 
Upon successfull call, this string function is NULL. Otherwise it contains an
encoding of the exceptional state encountered. This message
starts with the exception identifer, followed by contextual details.
@{

@= exceptionHndlr
if( cntxt->timer){
    lng n= GDKusec();
    lng l= n - cntxt->timer;
    total += l;
    if( stk->cmd != 'T' && stk->cmd != 'C')
        stream_printf(cntxt->fdout,"#%6d usec",l);
#ifdef HAVE_SYS_RESOURCE_H
    if( cntxt->resource.ru_minflt > 0){
        struct rusage ru;
        getrusage(RUSAGE_SELF,&ru);
        if( ru.ru_inblock - cntxt->resource.ru_inblock > 0)
            stream_printf(cntxt->fdout," %3d R",
                ru.ru_inblock - cntxt->resource.ru_inblock);
        if( ru.ru_oublock - cntxt->resource.ru_oublock > 0)
            stream_printf(cntxt->fdout," %3d W",
                ru.ru_oublock - cntxt->resource.ru_oublock);
        cntxt->resource= ru;
    }
#endif
    printTraceCall(cntxt,mb,stk,stkpc);
    cntxt->timer= GDKusec();
}

if( ret != MAL_SUCCEED ) {
    str msg = 0, nxt;
    int symid= -1;
	if( stk->cmd  ) {
        stream_printf(cntxt->fdout,"!ERROR: %s\n",ret);
		stk->cmd='n';
		mdbStep(cntxt,mb,stk,stkpc);
		if( stk->cmd == 'x' ) goto MALevalExit;
		if( stk->cmd == 'q' ) goto MALevalExit;
		if( stk->cmd == 'r') {
			stk->cmd = 'n';
			goto MALrestart;
		}
	}
    if(ret ) msg= strchr(ret,':');
    if( msg) {
        *msg= 0;
        symid = findVariableLength(mb,ret,msg-ret);
        *msg=':';
    } else {
        if( ret == MAL_SUCCEED){
            if( cntxt->errbuf){
                ret= msg= GDKstrdup(cntxt->errbuf);
                *cntxt->errbuf= 0;
            } else ret= msg = GDKstrdup("unspecified error\n");
            symid = findVariable(mb,"GDKerror");
        } else {
            stkexception = getDestVar(pci);
            stkpc++;
            @:endProfile@
            continue;
        }
    }
    stkexception = symid; 
    if( symid == -1){
        @:endProfile@
        goto MALevalExit;
    }
    msg++;
    /* assure correct variable type */
    nxt= (str) setDynamicType(mb,getVar(mb,symid),TYPE_str,stkpc);
    if( nxt == 0){
        v=  &stk->stk[symid];
        if( getVarType(mb,symid) == TYPE_any)
            setVarType(mb, symid, TYPE_str);
        v->vtype = TYPE_str;
        v->val.pval= GDKstrdup(locateException(mb,stkpc,ret));
        v->len= strlen(v->val.pval);
        GDKfree(ret);
        ret = 0;
    } else GDKfree(nxt);
    /* position yourself at the catch instruction for further decisions */
    @:skipToCatch(symid)@
    pci= getInstrPtr(mb,stkpc);
}
@-
During instruction interpretation we may have to be
assured that the type associated with a destination variable
is in line with the result of an operation or exceoption.
@c
str setDynamicType(MalBlkPtr mb, VarPtr v, int tpe, int pc){
    char buf[2*PATHLENGTH];
    if( v->type ==tpe) return 0;
    if( v->type == TYPE_any) return 0;
    sprintf(buf,"variable '%s' has already type %s (!=%s)\n",
        v->name, getTypeName(v->type), getTypeName(tpe));
    return raiseException(mb,pc, "typeException",buf);
}

@-
@}
@+ BAT reference counting
A key issue is to deal with temporary BATs in an efficient way.
References to bats in the buffer pool may cause dangling references
at the language level. This appears as soons as your share
a reference and delete the BAT from one angle. If not carefull, the
dangling pointer may subsequently be associated with another BAT

Dangling references can be dealt with in several ways.
First, we could increase the reference count each time a BAT
becomes shared and rely on the garbage collector to properly
decrement the count before abanding a execution frame.
Second, we could try to avoid dangling pointers by permitting
just one reference per BAT. This doesn't work, because we may
keep BAT-views around, which depend on the existence of the
underlying BAT.

@{
Look further in mal_instruction.mx for the before/after calls.
@}

@+ Garbage collection
Garbage collection is relatively straightforward, because most values are
retained on the stackframe of an interpreter call. However, two storage
types and possibly user-defined type garbage collector definitions
require attention. [TAKE CARE OF fixable atoms !!]

All string values are private to the VALrecord, which means they
have to be freed explicitly before a MAL function returns. 
The first step is to always safe the destination variable
before a function call is made.
@{
@-
@c
void garbageElement(ValPtr v)
{   
    if( v->vtype == TYPE_str) {
		if(v->len && v->val.pval) {
			GDKfree(v->val.pval);
			v->val.pval= NULL;
		}
		v->len= 0;
		return;
    }
    if( v->vtype== TYPE_bat && v->val.bval) {
@}
@-
All operations are responsible to properly set the
reference count of the BATs being produced or destroyed.
The exception are the target BAT variables. Their
reference is saved until the operation is finished.
They the reference can be reduced (due to overwrite
of the target variable) or retained(the operation failed).

Actually, the libraries should not leave the
physical reference count being set. This is only
allowed during a GDK operation. All references
should be logical.
@-
@{
@c
        int bid= ABS(v->val.bval);
        /* printf("garbage collecting: %d lrefs=%d refs=%d\n",
            bid, BBP_lrefs(bid),BBP_refs(bid));*/
		if( bid == 0) return;
        if( BBP_lrefs(bid) )
            BBPdecref(bid,TRUE);
        v->val.bval =0;
    }
}
@-
@}

Before we return from the interpreter, we should free all
dynamically allocated objects and adjust the BAT reference counts.
Early experience shows that for small stack frames the overhead
is about 200 ms for a 1M function call loop (tst400e). This means that
for the time being we do not introduce more complex garbage
administration code.

Also note that for top-level stack frames (no environment available),
we should retain the value stack because it acts as a global variables. 
This situation is indicated by the 'global' in the stack frame. 
@{
Upon termination of the session, the stack should be cleared.
Beware that variables may be know polymorphic, their actual
type should be saved for variables that recide on a global
stack frame.
@c
void garbageCollector(MalBlkPtr mb, MalStkPtr stk)
{   int k;
	ValPtr v;

#ifdef STACKTRACE
    stream_printf(GDKout,"--->stack before garbage collector,"
            " forceall %d\n",forceall);
    printStack(GDKout,mb,stk);
#endif
    for(k=0;k<mb->vtop; k++) {
        if(isVarGarbage(mb,k) && isTmpVar(mb,k)){
            garbageElement(v= &stk->stk[k]);
            v->vtype= TYPE_int;
            v->val.ival= int_nil;
        }
    }
#ifdef STACKTRACE
    stream_printf(GDKout,"--->stack after garbage collector,"
            " forceall %d\n",forceall);
    printStack(GDKout,mb,stk);
#endif
}
void garbageCollectAll(MalBlkPtr mb, MalStkPtr stk)
{   int k;
	ValPtr v;

    for(k=0;k<mb->vtop; k++) 
	if( isVarGarbage(mb,k)) {
            garbageElement(v= &stk->stk[k]);
            v->vtype= TYPE_int;
            v->val.ival= int_nil;
    }
}
@-
Sometimes it helps to release a BAT when it won;t be used anymore.
In this case, we have to assure that all references are cleared
as well. The routine below performs this action in the local
stack frame and its parents only.
@c
void releaseBAT(MalBlkPtr mb, MalStkPtr stk, int bid)
{   int k;

#ifdef STACKTRACE
    stream_printf(GDKout,"--->release BAT %d \n", bid);
    printStack(GDKout,mb,stk);
#endif
   do{
		for(k=0;k<mb->vtop; k++) 
		if( stk->stk[k].vtype== TYPE_bat && abs(stk->stk[k].val.br.id)==bid) {
			BBPdecref(bid,TRUE);
			stk->stk[k].val.ival= 0;
		}
#ifdef STACKTRACE
		stream_printf(GDKout,"--->stack after release BAT %d\n", bid);
		printStack(GDKout,mb,stk);
#endif
		if(stk->up){
			stk= stk->up;
			mb= stk->blk;
		}else break;
    } while(stk);
}

@-
@}
@+ Performance section
The interpreter has a built-in performance monitor hook, which is
activated using the compile option MALprofiler. Activation can lead to
a significant performance degradation, because for all traced functions
we have to keep track of essential system counter information.

@{
@= performanceVariables
#ifdef MALprofiler
    lng newclk=0;
#endif
@= beginProfile
#ifdef MALprofiler
    if( malProfileMode == 0)
        /* mostly true */;
    else {
        pci->clk= GDKusec();
        time(&pci->clock);
#ifdef HAVE_TIMES
        times(&pci->timer);
#endif
    }
#endif
@= endProfile
#ifdef MALprofiler
    if( malProfileMode == 0)
        /* mostly true */;
    else{
        newclk= GDKusec();
        pci->counter++;
        pci->ticks += (long) (newclk - pci->clk);
		if( pci->clk)
			profilerEvent(cntxt->nspace,mb,stk,pci);
    }
#endif
@}
