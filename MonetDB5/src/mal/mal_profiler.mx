@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2007 CWI.
@' All Rights Reserved.

@a M. Kersten
@v 0.0
@* The MAL Profiler
A key issue in the road towards a high performance implementation
is to understand where resources are being spent. This information
can be obtained using different tools and at different levels of
abstraction.
A coarse grain insight for a particular application can be obtained
using injection of the necessary performance
capturing statements in the instruction sequence.
Fine-grain, platform specific information can be obtained using
existing profilers, like valgrind (http://www.valgrind.org),
or hardware performance counters.

The MAL profiler collects detailed performance information, such
as cpu, memory and statement information. It is optionally extended
with IO activity, which is needed for coarse grain profiling only,
and estimated bytes read/written by an instruction.

The execution profiler is supported by hooks in the MAL interpreter.
The default strategy is to ship an event record immediately over a stream
to a separate performance monitor, formatted as a tuple.
An alternative strategy is preparation for off-line performance analysis.

Reflective performance analysis is supported by an event cache,
the event log becomes available as a series of BATs.
@menu
* Event Filtering ::
* Event Caching::
@end menu

@node Event Filtering, Event Caching, The MAL Profiler, The MAL Profiler
@+ Event Filtering 
The profiler supports selective retrieval of such information by
tagging the instructions of interest. This means that a profiler
call has a global effect,
all concurrent users are affected by the performance overhead.
Therefore, it is of primary interest to single user sessions.

The example below illustrates how the different performance
counter groups are activated, instructions are filtered for
tracking, and where the profile information is retained for
a posteriori analysis. 
@example
#profiler.activate("event");
#profiler.activate("pc");
#profiler.activate("operation");
profiler.activate("time");
profiler.activate("ticks");
#profiler.activate("cpu");
#profiler.activate("memory");
#profiler.activate("io");
#profiler.activate("bytes");
#profiler.activate("diskspace");
profiler.activate("statement");
profiler.setFilter("*","insert");
profiler.setFilter("*","print");

profiler.openStream("/tmp/MonetDBevents");
profiler.start();
b:= bbp.new(:int,:int);
bat.insert(b,1,15);
bat.insert(b,2,4);
bat.insert(b,3,9);
io.print(b);
profiler.stop();
profiler.closeStream();
@end example

We are interested in all functions name @sc{insert} and @sc{print}. 
A wildcard can be used to signify any name, e.g.
no constraints are put on the module in which the operations
are defined.
Several profiler components are ignored, shown by commenting
out the code line.

Execution of the sample leads to the creation of a file with
the following content. The ticks are measured in micro-seconds.

@verbatim
# time, ticks,  stmt  # name
[ "15:17:56",   12,   "_27 := bat.insert(<tmp_15>{3},1,15);" ]
[ "15:17:56",   2,    "_30 := bat.insert(<tmp_15>{3},2,4);"  ]
[ "15:17:56",   2,    "_33 := bat.insert(<tmp_15>{3},3,9);"  ]
[ "15:17:56",   245,  "_36 := io.print(<tmp_15>{3});",   ]
@end verbatim

@node Event Caching, Stethoscope, Event Filtering, The MAL Profiler
@+ Event Caching
Aside from shipping events to a separate process, the profiler
can keep the events in a local @sc{BAT} group.
It is the default when no target file has been opened
to collect the information.

Ofcourse, every measurement scheme does not come for free and may
even obscure performance measurements obtained through e.g. valgrind.
The separate event caches can be accessed using the 
operator @sc{profiler.getTrace}(@emph{name}).
The current implementation only supports 
access to @sc{time},@sc{ticks},@sc{pc},@sc{statement}.
The event cache can be cleared with @sc{profiler.clearTrace()}.

Consider the following MAL program snippet:
@example
profiler.setAll();
profiler.start();
b:= bbp.new(:int,:int);
bat.insert(b,1,15);
io.print(b);
profiler.stop();
s:= profiler.getTrace("statement");
t:= profiler.getTrace("ticks");
io.print(s,t);
@end example
The performance result of the program execution becomes:
@verbatim
#---------------------------------------------------------#
# h     t                                       t         # name
# int   str                                     int       # type
#---------------------------------------------------------#
[ 1,      "b := bbp.new(0,0);",                   51      ]
[ 2,      "$6 := bat.insert(<tmp_22>,1,15);",     16      ]
[ 3,      "$9 := io.print(<tmp_22>);",            189     ]
@end verbatim

@+ Monitoring Variables
The easiest scheme to obtain performance data is to
retrieve the performance properties of an instruction
directly after it has been executed using getEvent().
It reads the profiling stack maintained, provided you
have started monitoring.
@example
profiler setFilter(b);
profiler.start();
....
b:= algebra.select(a,0 1000); # some expensive operation
(clk, memread, memwrite):= profiler.getEvent();
...
profiler.stop();
@end example
@{
The profiler is activated by defining MALprofiler in the source tree.
This leads to securing space for the counters and for code
in the interpreter to collect the information.

@h
#ifndef _MAL_PROFILER_H
#define _MAL_PROFILER_H

#include "mal_client.h"

#ifdef HAVE_SYS_TIMES_H
# include <sys/times.h>
#endif

#if defined(SOLARIS) && OSVER < 560
#include "/usr/ucbinclude/sys/rusage.h"
#include "/usr/ucbinclude/sys/resource.h"
#endif

#ifdef HAVE_SYS_RESOURCE_H
#include <sys/resource.h>
typedef struct rusage Rusage;
#endif

typedef struct tms Tms;
typedef struct mallinfo Mallinfo;

mal_export str activateCounter(str name);
mal_export str deactivateCounter(str name);
mal_export str openProfilerStream(void);
mal_export str closeProfilerStream(void);

mal_export void initProfiler(MalBlkPtr mb);
mal_export void profilerEvent(Module cntxt, MalBlkPtr mb, MalStkPtr stk, int pc);
mal_export str setLogFile(Module cntxt, str fname);
mal_export str setLogStream(Module cntxt, str host, int port);
mal_export str setStartPoint(Module cntxt, str mod, str fcn);
mal_export str setEndPoint(Module cntxt, str mod, str fcn);

mal_export int profilerAvailable(void);
mal_export str startProfiling(void);
mal_export str stopProfiling(void);
mal_export str cleanupProfiler(void);

mal_export int instrFilter(InstrPtr pci, str mod, str fcn);
mal_export void setFilter(Module cntxt, str mod, str fcn);
mal_export void setFilterOnBlock(MalBlkPtr mb, str mod, str fcn);
mal_export void clrFilter(Module cntxt, str mod, str fcn);
mal_export void setFilterVariable(MalBlkPtr mb, int i);
mal_export void clrFilterVariable(MalBlkPtr mb, int i);

mal_export void MPresetProfiler(stream *fdout);

mal_export int malProfileMode;

mal_export void clearTrace(void);
mal_export BAT *getTrace(str ev);

mal_export int getDiskSpace(void);
#define DEBUG_MAL_PROFILER

#endif
@+ Performance tracing
The interpreter comes with several variables to hold performance
related data.
Every MAL instruction record is extended with two fields: counter and timer.
The counter is incremented each time the instruction is taken into
execution. Upon return, the timer is incremented with the microseconds
spent.
In addition to the default performance data collection,
the user can request performance events to be collected on a statement
basis. Care should be taken, because it leads to a large trace file,
unless the results are directly passed to a performance monitor
front-end for filtering and summarization.

The performance monitor has exclusive access to the event file, which
avoid concurrency conflicts amongst clients. It avoid cluthered
event records on the event stream. Since this event stream is owned
by a client, we should ensure that the profiler is automatically be
reset once the owner leaves. The routine profilerReset() handles the case.
@c
#include "mal_config.h"
#include "mal_function.h"
#include "mal_profiler.h"
#include "mal_debugger.h"

static MT_Lock profileLock ;
static stream *eventstream = 0;

#ifdef MALprofiler
static int profileLockInitialized = 0;
static int offlineProfiling = FALSE;
static int cachedProfiling = FALSE;
static str myname=0;

int
profilerAvailable(void)
{
	return 1;
}
static void offlineProfilerEvent(Module cntxt, MalBlkPtr mb, MalStkPtr stk, int pc);
static void cachedProfilerEvent(Module cntxt, MalBlkPtr mb, MalStkPtr stk, int pc);
#else
int
profilerAvailable(void)
{
	return 0;
}

#endif
static void initTrace(void);

int malProfileMode = 0;		/* global flag to indicate profiling mode */
static int profileAll = 0;	/* all instructions should be profiled */
static int delayswitch = 0;	/* to wait before sending the profile info */

@c
#define PROFevent   0
#define PROFpc      1
#define PROFoper    2
#define PROFtime    3
#define PROFticks   4
#define PROFcpu     5
#define PROFmemory  6
#define PROFio      7
#define PROFbytes   8
#define PROFdisk    9	
#define PROFstmt   10
#define PROFaggr   11

static struct {
	str name;		/* which logical counter is needed */
	int status;		/* trace it or not */
} profileCounter[] = {
	/*  0 */  { "event", 0},
	/*  1 */  { "pc", 0},
	/*  2 */  { "operation", 0},
	/*  3 */  { "time", 0},
	/*  4 */  { "ticks", 0},
	/*  5 */  { "cpu", 0},
	/*  6 */  { "memory", 0},
	/*  7 */  { "io", 0},
	/*  8 */  { "bytes", 0},
	/*  9 */  { "disk", 0},
	/*  10 */  { "statement", 0},
	/*  11 */  { "aggregate", 0},
	/*  12 */  { 0, 0}
};

@-
The counters can be set individually. 
@= setCounter
	int i;
	for(i=0; profileCounter[i].name;i++)
	if( strcmp(profileCounter[i].name,name)==0){
	    profileCounter[i].status = @1 ;
	    return 0;
	}
	throw(MAL, "@2", "profile counter '%s' undefined",name);
@c
str
activateCounter(str name)
{
	@:setCounter(1, activateCounter)@
}

str
deactivateCounter(str name)
{
	@:setCounter(0, deactivateCounter)@
}

@-
The parameter of getEventStream is the return value of the enclosing function:
	profilerEvent:  none/void
	setStartPoint:  a str
	setEndPoint:    a str
@= getEventStream
	if( ! profileLockInitialized) {
		MT_lock_init(&profileLock,"M5_profileLock");
		profileLockInitialized= 1;
	}
	mal_set_lock(profileLock,"profileLock");
	if( eventstream == NULL) {
	    mal_unset_lock(profileLock,"profileLock");
	    return @1;
	}
@+ Offline processing
The offline processing structure is the easiest. We merely have to
produce a correct tuple format for the front-end.
@c
#define log(X,Y) if(eventstream) stream_printf(eventstream,X,Y);
#define log0(X) if(eventstream) stream_printf(eventstream,X);
#define log2(X,Y,Z) if(eventstream) stream_printf(eventstream,X,Y,Z);
#define flushLog() if(eventstream) stream_flush(eventstream);

@- Event dispatching
The profiler strategy is encapsulated here
Note that the profiler itself should lead to event generations.
@c
void
profilerEvent(Module cntxt, MalBlkPtr mb, MalStkPtr stk, int pc)
{
#ifdef MALprofiler
	if( mb->profiler == NULL) return;
	if( myname == 0)
		myname= putName("profiler",8);
	if( getModuleId(getInstrPtr(mb,pc)) == myname)
		return;
	if (offlineProfiling)
		offlineProfilerEvent(cntxt, mb, stk, pc);
	if (cachedProfiling)
		cachedProfilerEvent(cntxt, mb, stk, pc);
	flushLog();
#else
	(void) cntxt;
	(void) mb;
	(void) stk;
	(void) pc;
#endif
}

#ifdef MALprofiler

static void
offlineProfilerHeader(void)
{
	@:getEventStream()@	/* profilerEvent -> void */
	log0("# ");
	if (profileCounter[PROFevent].status) {
		log0("event\t");
	} 
	if (profileCounter[PROFpc].status) {
		log0("function,\tline,\t");
	}
	if (profileCounter[PROFtime].status) {
		log0("time,\t");
	}
	if (profileCounter[PROFticks].status) {
		log0("usec,\t");
	}
	if (profileCounter[PROFcpu].status) {
		log0("utime,\t");
		log0("cutime,\t");
		log0("stime,\t");
		log0("cstime,\t");
	}

	if (profileCounter[PROFmemory].status) {
		log0("maxrss,\t");
		log0("arena,\t");
		log0("ordblks,\t");
		log0("smblks,\t");
		log0("hblkhd,\t");
		log0("hblks,\t");
		log0("fsmblks,\t");
		log0("uordblks,\t");
	}
	if (profileCounter[PROFio].status) {
		log0("pg reclaim,\t");
		log0("pg faults,\t");
		log0("swaps,\t");
		log0("blk reads,\t");
		log0("blk writes,\t");
		log0("ctxt switch,\t");
		log0("inv switch,\t");
	}
	if (profileCounter[PROFbytes].status)
		log0("ibytes,\t obytes,\t");
	if (profileCounter[PROFdisk].status)
		log0("diskspace,\t");
	if (profileCounter[PROFaggr].status)
		log0("count,\t clkticks,\t");
	if (profileCounter[PROFstmt].status) {
		log0("stmt,\t");
	}
	log0("# name\n");
	mal_unset_lock(profileLock, "profileLock");
}

void
offlineProfilerEvent(Module cntxt, MalBlkPtr mb, MalStkPtr stk, int pc)
{
	static struct mallinfo prevMalloc;
	InstrPtr pci = getInstrPtr(mb,pc);

#ifdef HAVE_SYS_RESOURCE_H
	static struct rusage prevUsage;
	struct rusage infoUsage;
#endif
	static int eventcounter;
#ifdef HAVE_TIMES
	struct tms newTms;
#endif
	struct mallinfo infoMalloc;
	str stmt, c;

	(void) cntxt;

	if (delayswitch > 0) {
		/* first call to profiled */
		offlineProfilerHeader();
		delayswitch--;
	}
	@:getEventStream()@	/* profilerEvent -> void */
	if (delayswitch == 0) {
		delayswitch = -1;
	}
	if (!profileAll && mb->profiler[pc].trace == FALSE)
		return;
#ifdef HAVE_TIMES
	times(&newTms);
#endif
	infoMalloc = MT_mallinfo();
#ifdef HAVE_SYS_RESOURCE_H
	getrusage(RUSAGE_SELF, &infoUsage);
#endif

	/* make basic profile event tuple  */
	log0("[ ");
	if (profileCounter[PROFevent].status) {
		log("%d,\t", eventcounter);
	} 
	if (profileCounter[PROFpc].status) {
		str mod = "";
		str fcn = "";

		if (stk->blk){
			mod = getModuleId(getInstrPtr(stk->blk, 0));
			fcn = getFunctionId(getInstrPtr(stk->blk, 0));
		}
		log2("\"%s.%s\",\t", mod,fcn);
		log("%d,\t", getPC(mb, pci));
	}
	if (profileCounter[PROFoper].status) {
		if( getModuleId(pci) && getFunctionId(pci)){
			log2("\"%s.%s\",\t",
					getModuleId(pci), getFunctionId(pci));
		} else
 			log("\"%s\",\t",operatorName(pci->token));
	}
	if (profileCounter[PROFtime].status) {
		char *tbuf, *c;

		tbuf= ctime(&mb->profiler[pc].clock);
		c = strchr(tbuf, '\n');
		if (c) {
			c[-5] = '"';
			c[-4] = 0;
		}
		tbuf[10] = '"';
		log("%s,\t", tbuf + 10);
	}
	if (profileCounter[PROFticks].status) {
		log("%d,\t", mb->profiler[pc].ticks);
	}
#ifdef HAVE_TIMES
	if (profileCounter[PROFcpu].status && delayswitch<0) {
		log("%d,\t", newTms.tms_utime - mb->profiler[pc].timer.tms_utime);
		log("%d,\t", newTms.tms_cutime - mb->profiler[pc].timer.tms_cutime);
		log("%d,\t", newTms.tms_stime - mb->profiler[pc].timer.tms_stime);
		log("%d,\t", newTms.tms_cstime - mb->profiler[pc].timer.tms_cstime);
	}
#endif

	if (profileCounter[PROFmemory].status && delayswitch<0) {
#ifdef HAVE_SYS_RESOURCE_H
		log("%d,\t", infoUsage.ru_maxrss);
#endif
		log("%d,\t", infoMalloc.arena - prevMalloc.arena);
		log("%d,\t", infoMalloc.ordblks - prevMalloc.ordblks);
		log("%d,\t", infoMalloc.smblks - prevMalloc.smblks);
		log("%d,\t", infoMalloc.hblkhd - prevMalloc.hblkhd);
		log("%d,\t", infoMalloc.hblks - prevMalloc.hblks);
		log("%d,\t", infoMalloc.fsmblks - prevMalloc.fsmblks);
		log("%d,\t", infoMalloc.uordblks - prevMalloc.uordblks);
		prevMalloc = infoMalloc;
	}
#ifdef HAVE_SYS_RESOURCE_H
	if (profileCounter[PROFio].status && delayswitch<0) {
		log("%d,\t", infoUsage.ru_minflt - prevUsage.ru_minflt);
		log("%d,\t", infoUsage.ru_majflt - prevUsage.ru_majflt);
		log("%d,\t", infoUsage.ru_nswap - prevUsage.ru_nswap);
		log("%d,\t", infoUsage.ru_inblock - prevUsage.ru_inblock);
		log("%d,\t", infoUsage.ru_oublock - prevUsage.ru_oublock);
		log("%d,\t", infoUsage.ru_nvcsw - prevUsage.ru_nvcsw);
		log("%d,\t", infoUsage.ru_nivcsw - prevUsage.ru_nivcsw);
		prevUsage = infoUsage;
	}
#endif
	if (profileCounter[PROFbytes].status) {
		log("%d,\t", mb->profiler[pc].ibytes);
		log("%d,\t", mb->profiler[pc].obytes);
	}
	if (profileCounter[PROFdisk].status) {
		log("%d,\t", getDiskSpace());
	}
	if (profileCounter[PROFaggr].status) 
		log2("%d,\t%d,\t", mb->profiler[pc].counter, mb->profiler[pc].clk);
	
	if (profileCounter[PROFstmt].status) {
		/* generate actual call statement */
		stmt = call2str(mb, stk, getPC(mb, pci),1);
		c = stmt+1;

		while (c && *c && isspace((int) *c))
			c++;
		log(" \"%s\"", c);
	}
	log0(" ]\n");
	eventcounter++;
	mal_unset_lock(profileLock, "profileLock");
}
#endif
@+ Postprocessing events
The events may be sent for offline processing through a
stream, including "stdout".
@c
str
setLogFile(Module cntxt, str fname)
{
	(void) cntxt;		/* still unused */
#ifdef MALprofiler
	if( ! profileLockInitialized) {
		MT_lock_init(&profileLock,"M5_profileLock");
		profileLockInitialized= 1;
	}
	mal_set_lock(profileLock, "profileLock");
	if( strcmp(fname,"stdout")==0)
		eventstream = MCgetClient()->fdout;
	else
		eventstream = open_wastream(fname);
	if (eventstream == NULL) {
		throw(IO, "mal.profiler", "Could not create event stream file");
	}
	mal_unset_lock(profileLock, "profileLock");
#else
	(void) fname;
	stream_printf(GDKout, "# MonetDB not compiled for profiling\n");
#endif
	return MAL_SUCCEED;
}

str
setLogStream(Module cntxt, str host, int port)
{
	(void) cntxt;		/* still unused */
#ifdef MALprofiler
	if( ! profileLockInitialized) {
		MT_lock_init(&profileLock,"M5_profileLock");
		profileLockInitialized= 1;
	}
	mal_set_lock(profileLock, "profileLock");
	if ((eventstream = udp_wastream(host, port, "profileStream")) == NULL)
		throw(IO, "mal.profiler", "Could not create event stream");
	if (eventstream)
		eventstream = wbstream(eventstream, BUFSIZ);
	mal_unset_lock(profileLock, "profileLock");
#else
	(void) host;
	(void) port;
	stream_printf(GDKout, "# MonetDB not compiled for profiling\n");
#endif
	return MAL_SUCCEED;
}

str
openProfilerStream(void)
{
	Client c = MCgetClient();

	malProfileMode = TRUE;
	eventstream = c->fdout;
	delayswitch = 1;	/* avoid an incomplete initial profile event */
	return MAL_SUCCEED;
}

str
closeProfilerStream(void)
{
	eventstream = NULL;
	malProfileMode = FALSE;
	return MAL_SUCCEED;
}

str
setStartPoint(Module cntxt, str mod, str fcn)
{
	(void) cntxt;
	(void) mod;
	(void) fcn;		/* still unused */
#ifdef MALprofiler
	@:getEventStream(MAL_SUCCEED /*? or MAL_? ? */ )@
	stream_printf(GDKout, "# start point not set\n");
	mal_unset_lock(profileLock, "profileLock");
#else
	stream_printf(GDKout, "# Monet not compiled for profiling\n");
#endif
	return MAL_SUCCEED;
}

str
setEndPoint(Module cntxt, str mod, str fcn)
{
	(void) cntxt;
	(void) mod;
	(void) fcn;		/* still unused */
#ifdef MALprofiler
	@:getEventStream(MAL_SUCCEED /*? or MAL_? ? */ )@
	stream_printf(GDKout, "# end point not set\n");
	mal_unset_lock(profileLock, "profileLock");
#else
	stream_printf(GDKout, "# Monet not compiled for profiling\n");
#endif
	return MAL_SUCCEED;
}

@-
When you receive the message to start profiling, we
should wait for the next instruction the stream
is initiated. This is controlled by a delay-switch
@c
str
startProfiling(void)
{
#ifdef MALprofiler
	if (eventstream != NULL) {
		offlineProfiling=TRUE;
		delayswitch = 1;
	} else
		cachedProfiling=TRUE;
	initTrace();
	malProfileMode = TRUE;
#endif
	return MAL_SUCCEED;
}

str
stopProfiling(void)
{
#ifdef MALprofiler
	malProfileMode = FALSE;
	offlineProfiling= FALSE;
	cachedProfiling= FALSE;
#endif
	return MAL_SUCCEED;
}

@-
A front-end may request the information using a
polling operation, i.e. sending an empty command.
A semaphore can be used to notify threads that
a new element has become available for shipping.
@c
@-
The resetProfiler is called when the owner of the event stream
leaves the scene. (Unclear if parallelism may cause errors)
@c
void
MPresetProfiler(stream *fdout)
{
	if (fdout != eventstream)
		return;
	mal_set_lock(profileLock, "profileLock");
	eventstream = 0;
	mal_unset_lock(profileLock, "profileLock");
}

@-
Performance tracing is triggered on an instruction basis
or a the global flag 'profileAll' being set.
Calling setFilter(M,F) switches the performance tracing
bit in the instruction record. The routine clrFilter
clears all performance bits.

The routines rely on waking their way through the
instructions space from a given context. This has been
abstracted away.
@c
int
instrFilter(InstrPtr pci, str mod, str fcn)
{
#ifdef MALprofiler
	if (getFunctionId(pci) &&  fcn && mod &&
		(*fcn == '*' || fcn== getFunctionId(pci))  &&
		(*mod == '*' || mod== getModuleId(pci))
	)
		return 1;
#else
	(void) pci;
	(void) mod;
	(void) fcn;
	stream_printf(GDKout, "# Monet not compiled for profiling\n");
#endif
	return 0;
}

@-
The last filter values are saved as replacement for missing
arguments. It can be used to set the profile bits for modules
that has not been checked yet, e.g created on the fly.
@c
static str modFilter[32], fcnFilter[32];
static int topFilter;

void
setFilterOnBlock(MalBlkPtr mb, str mod, str fcn){
	int cnt,k,i;
	InstrPtr p;

	initProfiler(mb);
	for (k = 0; k < mb->stop; k++) {
		p = getInstrPtr(mb, k);
		cnt =0;
		for(i=0;i<topFilter; i++)
		cnt += instrFilter(p,modFilter[i],fcnFilter[i]);
		mb->profiler[k].trace = profileAll || cnt ||
								(mod && fcn && instrFilter(p, mod, fcn));
	}
}

void
setFilter(Module cntxt, str mod, str fcn)
{
#ifdef MALprofiler
	int j;
	Module s = cntxt;
	Symbol t;

	(void) cntxt;
	profileAll = strcmp(mod, "*") == 0 && strcmp(fcn, "*") == 0;

	if( ! profileLockInitialized) {
		MT_lock_init(&profileLock,"M5_profileLock");
		profileLockInitialized= 1;
	}
	mal_set_lock(profileLock, "profileLock");
	if( mod && fcn && topFilter<32){
		modFilter[topFilter]= putName(mod,strlen(mod));
		fcnFilter[topFilter++]= putName(fcn,strlen(fcn));
	} 
	while (s != NULL) {
		if (s->subscope)
			for (j = 0; j < MAXSCOPE; j++)
				if (s->subscope[j]) {
					for (t = s->subscope[j]; t != NULL; t = t->peer){
						if(t->def )
							setFilterOnBlock(t->def,mod,fcn);
					}
				}
		s = s->outer;
	}
	mal_unset_lock(profileLock, "profileLock");
#else
	(void) cntxt;
	(void) mod;
	(void) fcn;
	stream_printf(GDKout, "# Monet not compiled for profiling\n");
#endif
}

@-
Watch out. The profiling bits are only set for the shared modules and
the private main(). The profiler setFilter should explicitly be called in
each separate top level routine.
@c
void
clrFilter(Module cntxt, str mod, str fcn)
{
#ifdef MALprofiler
	int j, k;
	Module s = cntxt;
	Symbol t;
	MalBlkPtr mb;

	(void) mod;
	(void) fcn;		/* still unused */

	if( ! profileLockInitialized) {
		MT_lock_init(&profileLock,"M5_profileLock");
		profileLockInitialized= 1;
	}
	mal_set_lock(profileLock, "profileLock");
	for(j=0; j<topFilter; j++){
		modFilter[j]=NULL;
		fcnFilter[j]=NULL;
	}
	topFilter=0;
	profileAll = FALSE;
	while (s != NULL) {
		if (s->subscope)
			for (j = 0; j < MAXSCOPE; j++)
				if (s->subscope[j]) {
					for (t = s->subscope[j]; t != NULL; t = t->peer) {
						if(t->def && (mb=t->def)->profiler)
						for (k = 0; k < t->def->stop; k++)
						if( instrFilter(getInstrPtr(t->def, k), mod, fcn) ){
							mb->profiler[k].trace = FALSE;
						}
					}
				}
		s = s->outer;
	}
	mal_unset_lock(profileLock, "profileLock");
#else
	(void) cntxt;
	(void) mod;
	(void) fcn;
	stream_printf(GDKout, "# Monet not compiled for profiling\n");
#endif
}
@-
The instructions to be monitored can also be identified
using a variable. Any instruction that references it
is traced. Beware, this operation should be executed
in the context of the function to avoid loosing
track due to optimizers re-assigning names.
@c
void
setFilterVariable(MalBlkPtr mb, int arg){
	int i,k;
	InstrPtr p;

	for(i=0; i< mb->stop; i++){
		p= getInstrPtr(mb,i);
		for( k=0; k<p->argc; k++)
		if( getArg(p,k) == arg){
				initProfiler(mb);
				mb->profiler[i].trace = TRUE;
		}
	}
}
void
clrFilterVariable(MalBlkPtr mb, int arg){
	int i,k;
	InstrPtr p;

	for(i=0; i< mb->stop; i++){
		p= getInstrPtr(mb,i);
		for( k=0; k<p->argc; k++)
		if( getArg(p,k) == arg){
				mb->profiler[i].trace = FALSE;
		}
	}
}

@+ Tracing
The events being captured are stored in separate BATs.
They are made persistent to accumate information over
multiple sessions. This means it has to be explicitly reset
to avoid disc overflow.
@c
static int TRACE_init=0;
static BAT *TRACE_id_time=0;
static BAT *TRACE_id_ticks=0;
static BAT *TRACE_id_pc=0;
static BAT *TRACE_id_modfcn=0;
static BAT *TRACE_id_stmt=0;
static BAT *TRACE_id_ibytes=0;
static BAT *TRACE_id_obytes=0;
static BAT *TRACE_id_diskspace=0;

static BAT *
TRACEcreate(str hnme, str tnme, int ht, int tt)
{
	BAT *b;
	char buf[128];

	snprintf(buf, 128, "trace_%s_%s", hnme, tnme);
	b = BATdescriptor(BBPindex(buf));
	if (b)
		return b;

	b = BATnew(ht, tt, 256);
	if (b == NULL)
		GDKfatal("STAT_create: could not allocate.");

	BATkey(b, TRUE);
	BBPrename(b->batCacheid, buf);
	BATmode(b, PERSISTENT);
	BATcommit(b);
	return b;
}

void
initTrace(void)
{
	if (TRACE_init)
		return;		/* already initialized */
	mal_set_lock(mal_contextLock, "trace");
	TRACE_id_time = TRACEcreate("id", "time", TYPE_int, TYPE_str);
	TRACE_id_ticks = TRACEcreate("id", "ticks", TYPE_int, TYPE_int);
	TRACE_id_pc = TRACEcreate("id", "pc", TYPE_int, TYPE_str);
	TRACE_id_modfcn = TRACEcreate("id", "modfcn", TYPE_int, TYPE_str);
	TRACE_id_stmt = TRACEcreate("id", "statement", TYPE_int, TYPE_str);
	TRACE_id_ibytes = TRACEcreate("id", "ibytes", TYPE_int, TYPE_int);
	TRACE_id_obytes = TRACEcreate("id", "obytes", TYPE_int, TYPE_int);
	TRACE_id_diskspace = TRACEcreate("id", "diskspace", TYPE_int, TYPE_int);
	TRACE_init = 1;
	mal_unset_lock(mal_contextLock, "trace");
}

#define CLEANUPprofile(X)  if(X) { BBPdecref((X)->batCacheid, TRUE); (X)->batPersistence= TRANSIENT; } (X)= NULL;
str
cleanupProfiler(){
	mal_set_lock(mal_contextLock, "cleanup");
	CLEANUPprofile( TRACE_id_time );
	CLEANUPprofile( TRACE_id_pc );
	CLEANUPprofile( TRACE_id_modfcn );
	CLEANUPprofile( TRACE_id_stmt );
	CLEANUPprofile( TRACE_id_ibytes );
	CLEANUPprofile( TRACE_id_obytes );
	CLEANUPprofile( TRACE_id_diskspace );
	TRACE_init = 0;
	mal_unset_lock(mal_contextLock, "cleanup");
	return MAL_SUCCEED;
}

void
clearTrace(void)
{
	initTrace();
	/* drop all trace tables */
	BATclear(TRACE_id_time);
	BATclear(TRACE_id_ticks);
	BATclear(TRACE_id_pc);
	BATclear(TRACE_id_modfcn);
	BATclear(TRACE_id_stmt);
}

BAT *
getTrace(str nme)
{
	initTrace();
	if (strcmp(nme, "time") == 0)
		return TRACE_id_time;
	if (strcmp(nme, "ticks") == 0)
		return TRACE_id_ticks;
	if (strcmp(nme, "pc") == 0)
		return TRACE_id_pc;
	if (strcmp(nme, "modfcn") == 0)
		return TRACE_id_modfcn;
	if (strcmp(nme, "statement") == 0)
		return TRACE_id_stmt;
	if (strcmp(nme, "ibytes") == 0)
		return TRACE_id_ibytes;
	if (strcmp(nme, "obytes") == 0)
		return TRACE_id_obytes;
	if (strcmp(nme, "diskspace") == 0)
		return TRACE_id_diskspace;
	return NULL;
}

#ifdef MALprofiler
void
cachedProfilerEvent(Module cntxt, MalBlkPtr mb, MalStkPtr stk, int pc)
{
	/* static struct mallinfo prevMalloc; */
	/* static struct rusage   prevUsage; */
	static int eventcounter;
#ifdef HAVE_TIMES
	struct tms newTms;
#endif

	/* struct mallinfo infoMalloc; */
#ifdef HAVE_SYS_RESOURCE_H
	struct rusage infoUsage;
#endif
	str stmt, c;
	int evnt;
	InstrPtr pci= getInstrPtr(mb,pc);

	(void) cntxt;

	if (TRACE_init == 0)
		return;
	if (delayswitch > 0) {
		/* first call to profiled */
		delayswitch--;
		return;
	}
	if (delayswitch == 0) {
		delayswitch = -1;
	}
	if (!( profileAll || mb->profiler[pc].trace ) )
		return;
#ifdef HAVE_TIMES
	times(&newTms);
#endif
	/* infoMalloc = MT_mallinfo(); */
#ifdef HAVE_SYS_RESOURCE_H
	getrusage(RUSAGE_SELF, &infoUsage);
#endif
	mal_set_lock(profileLock, "profileLock");
	evnt = TRACE_init++;

	/* update the Trace tables */
	if (profileCounter[PROFpc].status) {
		char buf[1024];

		snprintf(buf, 1024, "%s.%s[%d]", 
			getModuleId(getInstrPtr(mb, 0)), 
			getFunctionId(getInstrPtr(mb, 0)), getPC(mb, pci));
		BUNins(TRACE_id_pc, &evnt, buf, FALSE);
		if (getModuleId(pci) && getFunctionId(pci)) {
			snprintf(buf, 1024, "%s.%s", 
				getModuleId(pci), 
				getFunctionId(pci));
		} else {
			snprintf(buf, 1024, "%s", operatorName(pci->token));
		}
		BUNins(TRACE_id_modfcn, &evnt, buf, FALSE);
	}
	if (profileCounter[PROFtime].status) {
		char *tbuf, *c;

		tbuf= ctime(&mb->profiler[pc].clock);
		c = strchr(tbuf, '\n');
		if (c) {
			c[-5] = '"';
			c[-4] = 0;
		}
		tbuf[10] = '"';
		BUNins(TRACE_id_time, &evnt, tbuf + 10, FALSE);
	}
	if (profileCounter[PROFticks].status) {
		BUNins(TRACE_id_ticks, &evnt, &mb->profiler[pc].ticks, FALSE);
	}
	if (profileCounter[PROFstmt].status) {
		/* generate actual call statement */
		stmt = call2str(mb, stk, getPC(mb, pci),1);
		c = stmt;

		while (c && *c && (isspace((int) *c) || *c == '!'))
			c++;
		BUNins(TRACE_id_stmt, &evnt, c, FALSE);
		GDKfree(stmt);
	}
/* The remainder requires their own BATs
#ifdef HAVE_TIMES
	if( profileCounter[PROFcpu].status ){
	    log("%d,\t", newTms.tms_utime - mb->profiler[pc].timer.tms_utime);
	    log("%d,\t", newTms.tms_cutime - mb->profiler[pc].timer.tms_cutime);
	    log("%d,\t", newTms.tms_stime - mb->profiler[pc].timer.tms_stime);
	    log("%d,\t", newTms.tms_cstime - mb->profiler[pc].timer.tms_cstime);
	}
#endif

	if( profileCounter[PROFmemory].status ){
#ifdef HAVE_SYS_RESOURCE_H
	    log("%d,\t",infoUsage.ru_maxrss);
#endif
	    log("%d,\t", infoMalloc.arena-prevMalloc.arena);
	    log("%d,\t", infoMalloc.ordblks-prevMalloc.ordblks);
	    log("%d,\t", infoMalloc.smblks-prevMalloc.smblks);
	    log("%d,\t", infoMalloc.hblkhd-prevMalloc.hblkhd);
	    log("%d,\t", infoMalloc.hblks-prevMalloc.hblks);
	    log("%d,\t", infoMalloc.fsmblks-prevMalloc.fsmblks);
	    log("%d,\t", infoMalloc.uordblks-prevMalloc.uordblks);
	    prevMalloc = infoMalloc;
	}
	if( profileCounter[PROFio].status ){
#ifdef HAVE_SYS_RESOURCE_H
	    log("%d,\t", infoUsage.ru_minflt- prevUsage.ru_minflt);
	    log("%d,\t", infoUsage.ru_majflt- prevUsage.ru_majflt);
	    log("%d,\t", infoUsage.ru_nswap- prevUsage.ru_nswap);
	    log("%d,\t", infoUsage.ru_inblock- prevUsage.ru_inblock);
	    log("%d,\t", infoUsage.ru_oublock- prevUsage.ru_oublock);
	    log("%d,\t", infoUsage.ru_nvcsw- prevUsage.ru_nvcsw);
	    log("%d,\t", infoUsage.ru_nivcsw- prevUsage.ru_nivcsw);
	    prevUsage = infoUsage;
#endif
	}
*/
	if (profileCounter[PROFbytes].status) {
		BUNins(TRACE_id_ibytes, &evnt, &mb->profiler[pc].ibytes, FALSE);
		BUNins(TRACE_id_obytes, &evnt, &mb->profiler[pc].obytes, FALSE);
	}
	if (profileCounter[PROFdisk].status) {
		int disk= getDiskSpace();
		BUNins(TRACE_id_diskspace, &evnt, &disk, FALSE);
	}
	eventcounter++;
	mal_unset_lock(profileLock, "profileLock");
}
#endif
@-
The profile vector is added to the MAL block the first time we
have to safe monitor information.
@c
void initProfiler(MalBlkPtr mb){
	if( mb->profiler) return;
	mb->profiler = (ProfPtr) GDKzalloc(mb->ssize*sizeof(ProfRecord));
}
int
getDiskSpace()
{
	BAT *b;
	int i,size=0;

	for (i = 1; i < BBPsize; i++)
		if (BBP_logical(i) && (BBP_refs(i) || BBP_lrefs(i)) ) {
			b= BATdescriptor(i);
			if( b){
				size += sizeof(BAT);
				if (!isVIEW(b)) {
					size_t cnt = BATcount(b);

					size += headsize(b,cnt);
					size += tailsize(b,cnt);
					/* the upperbound is used for the heaps */
					if (b->hheap)
						size += b->hheap->size;
					if (b->theap)
						size += b->theap->size;
					if (b->H->hash)
						size += sizeof(hash_t) * cnt;
					if (b->T->hash)
						size += sizeof(hash_t) * cnt;
				}
				BBPunfix(i);
			}
		}
	return size;
}
@}
