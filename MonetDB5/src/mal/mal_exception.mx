@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f mal_exception
@a M. Kersten
@v 0.0

@+ Exception handling
MAL comes with an exception handling mechanism, similar in style
as found in modern programming languages.
Exceptions are considered rare situations that alter
the flow of control to a place where they can be handled.
After the exceptional case has been handled the following options exist
a) continue where it went wrong, b) retry the failed instruction,
c) leave the block where the exception was handled,
or d) pass the exception to an enclosing call.
The current implementation of the MAL interpreter only supports c) and d).

@- Exception control
The exception handling keywords are: @code{catch} and @code{raise}
The @code{catch}  marks a point in the dataflow where
an exception raised can be dealt with. Any statement between the
point where it is raised and the catch block is ignored.
Moreover, the @code{ catch} ... @code{ exit} block is ignored when
no errors have occurred in the preceeding dataflow structure.
Within the catch block, the exception variable can be manipulated
without constraints.

An exception message is linked with a exception variable of
type string. If this variable is defined in the receiving block,
the exception message can be delivered. Otherwise, it
implicitly raises the exception in the surrounding scope.

After an exception has been dealt with the catch block can be left
at the normal @code{exit} with the option @code{leave} or
continue after the failed instruction using a @code{redo}.
The latter case assumes the catched code block has been able to provide
an alternative for the failed instruction.

Both @code{leave} and @code{redo} are conditional flow of control modifiers,
which trigger on a non-empty string variable.
An exception raised within a catch-block terminates
the function and returns control to the enclosing environment.

The argument to the catch statement is a target list,
which holds the exception variables you are interested in.
[??An expression evaluated with the catch statement is executed
after the block has been entered only. It could be used to
initialize the exception variables further.]

The snippet below illustrates how an exception raised
in the function @code{io.read} is catched using the exception variable IOerror.
After dealing with it locally, it raises a new exception @code{ FATALerror}
for the enclosing call.

@example
    io.write("Welcome");
    ...
catch IOerror;
    print("input error on reading password");
raise FATALerror:= "Can't handle it";
exit IOerror;
@end example

Since @code{catch} is a flow control modifier it can be attached to any
assignment statement. This statement is executed whenever there is no
exception outstanding, but will be ignored when control is moved
to the block otherwise.

@- Builtin exceptions 
The policy implemented in the MAL modules, and recognized by
the interpreter, is to return a string value by default.
A NULL return value indicates succesful execution; otherwise
the string encodes information to analyse the error occurred.

This string pattern is strictly formatted and easy to analyse.
It starts with the name of the exception variable to
be set, followed by an indication where the exception was
raise, i.e. the function name and the program counter,
and concludes with specific information needed to interpret 
and handle the exception.

For example, the exception string 
@code{ 'MALexception:Admin.main[2]:address of function missing'}
denotes an exception raised while typechecking a MAL program.

The exceptions captured within the kernel are marked as 'GDKerror'.
At that level there is no knowledge about the MAL context, which
makes interpretation difficult for the average programmer.
Exceptions in the MAL language layer are denoted by 'MALerror',
and query language exceptiosn fall in their own class, e.g. 'SQLerror'.
Exceptions can be cascaded to form a trail of exceptions recognized
during the exection.

[Modules should define exceptions being raised]
@{
@-
@h
#ifndef _MAL_EXCEPTION_H
#include "mal_instruction.h"
/*VARARGS*/
mal_export str	throwException(str nme, str fcn, char *format, ...);
mal_export str	raiseException(MalBlkPtr mb, int pc, str name, str msg);
mal_export str	appendException(MalBlkPtr mb, int pc, str name, str msg,str old);
mal_export str	locateException(MalBlkPtr mb, int pc, str oldmsg);
mal_export void	showException(MalBlkPtr mb, int pc, str name, str msg);

#define MALEXCEPTION "MALexception"
#define throwMessage(Fcn,Msg)   throwException(MALEXCEPTION,Fcn,"%s",Msg)
/* Fabian's convenience `tools' */
mal_export str  stackException(str prev, str fcn, char *format, ...);
#define throw(TPE, FCN, MSG) \
	return(throwException(TPE, FCN, "%d %s", __LINE__, MSG));
#define throwf(TPE, FCN, FMT, ARG) \
	return(throwException(TPE, FCN, "%d " FMT, __LINE__, ARG));
#define throwf2(TPE, FCN, FMT, ARG1, ARG2) \
	return(throwException(TPE, FCN, FMT, ARG1, ARG2));
#define throwf3(TPE, FCN, FMT, ARG1, ARG2, ARG3) \
	return(throwException(TPE, FCN, FMT, ARG1, ARG2, ARG3));
#define rethrow(FCN, TMP, PRV) \
	if ((TMP = stackException(PRV, FCN, "%d", __LINE__)) != MAL_SUCCEED) { \
		GDKfree(PRV); \
		return(TMP); \
	}
#define throwIllArg(FCN, MSG) \
	throw("IllegalArgumentException", FCN, MSG);
#define throwIllArgf(FCN, FMT, ARG) \
	throwf("IllegalArgumentException", FCN, FMT, ARG);
#define throwOutOfBnds(FCN, MSG) \
	throw("OutOfBoundsException", FCN, MSG);
#define throwOutOfBndsf(FCN, FMT, ARG) \
	throwf("OutOfBoundsException", FCN, FMT, ARG);
#define throwIO(FCN, MSG) \
	throw("IOException", FCN, MSG);
#define throwIOf(FCN, FMT, ARG) \
	throwf("IOException", FCN, FMT, ARG);
#define throwMal(FCN, MSG) \
	throw("MALException", FCN, MSG);
#define throwMalf(FCN, FMT, ARG) \
	throwf("MALException", FCN, FMT, ARG);

#endif /*  _MAL_EXCEPTION_H*/

@-
@c
#include "mal_exception.h"

str appendException(MalBlkPtr mb, int pc, str name, str msg,str oldmsg){
        char buf[4196];
    int i;
    str s,fcn;

    s = mb? getModName(mb): "";
    fcn= mb? getFcnName(mb):"";
    buf[0]=0;
	i= 0;
    if(oldmsg) snprintf(buf+i,4196,"%s",oldmsg);
    i= strlen(buf);
    if(name) snprintf(buf+i,4196-i,"%s:", name);
    i= strlen(buf);
    if(s) snprintf(buf+i,4196-i,"%s.",s);
    i= strlen(buf);
    snprintf(buf+i,4196-i,"%s",fcn);
    i= strlen(buf);
    snprintf(buf+i,4196-i,"[%d]",pc);
    i= strlen(buf);
    if(msg) snprintf(buf+i,4196-i,":%s",msg);
    i= strlen(buf);
    if( buf[i-1]!='\n'){ buf[i]='\n'; buf[i+1]=0;}
	return GDKstrdup(buf);
}
str locateException(MalBlkPtr mb, int pc, str oldmsg){
    str s, msg=0,name=0;

    if( (s= strchr(oldmsg,':'))){
        *s =0;
        name= oldmsg;
        msg= s+1;
    } else msg=oldmsg;
    return appendException(mb,pc,name,msg,0);
}
@-
The linked libraries should use the throwException to signal
an erroneous situation. It takes the name of MAL exception name
to be raised.
@c
/*VARARGS*/
str throwException(str nme, str fcn, char *format, ...){
	char message[GDKMAXERRLEN];
	int len = strlen(MALexception)+1;
	va_list ap;

	sprintf(message,"%s:%s:",nme,fcn);
	len= strlen(message);
	va_start(ap, format);
	vsnprintf(message + len, GDKMAXERRLEN-(len+2), format, ap);
	va_end(ap);

	return GDKstrdup(message);
}

/**
 * Appends the given format stuff to a previous message.  If the message
 * is empty (MAL_SUCCEED), the same message is returned immediately.
 */
str stackException(str prev, str fcn, char* format, ...) {
	char message[GDKMAXERRLEN];
	int len;
	va_list ap;

	/* don't do anything if the previous message was no Exception */
	if (prev == MAL_SUCCEED) return(prev);

	len = sprintf(message, "%s\n    at %s:", prev, fcn);
	va_start(ap, format);
	vsnprintf(message + len, GDKMAXERRLEN - (len + 2), format, ap);
	va_end(ap);

	return(GDKstrdup(message));
}

str raiseException(MalBlkPtr mb, int pc, str name, str msg){
    return appendException(mb,pc,name,msg,"");
}
void showException(MalBlkPtr mb, int pc, str name, str msg){
    str n;
    n= raiseException(mb,pc,name,msg);
    GDKerror(n);
    GDKfree(n);
}
@}
