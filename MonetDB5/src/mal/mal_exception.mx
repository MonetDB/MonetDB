@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f mal_exception
@a M. Kersten
@v 0.0

@+ Exception handling
MAL comes with an exception handling mechanism, similar in style
as found in modern programming languages.
Exceptions are considered rare situations that alter
the flow of control to a place where they can be handled.
After the exceptional case has been handled the following options exist
a) continue where it went wrong, b) retry the failed instruction,
c) leave the block where the exception was handled,
or d) pass the exception to an enclosing call.
The current implementation of the MAL interpreter only supports c) and d).

@- Exception control
The exception handling keywords are: @code{catch} and @code{raise}
The @code{catch}  marks a point in the dataflow where
an exception raised can be dealt with. Any statement between the
point where it is raised and the catch block is ignored.
Moreover, the @code{ catch} ... @code{ exit} block is ignored when
no errors have occurred in the preceeding dataflow structure.
Within the catch block, the exception variable can be manipulated
without constraints.

An exception message is linked with a exception variable of
type string. If this variable is defined in the receiving block,
the exception message can be delivered. Otherwise, it
implicitly raises the exception in the surrounding scope.

After an exception has been dealt with the catch block can be left
at the normal @code{exit} with the option @code{leave} or
continue after the failed instruction using a @code{redo}.
The latter case assumes the catched code block has been able to provide
an alternative for the failed instruction.

Both @code{leave} and @code{redo} are conditional flow of control modifiers,
which trigger on a non-empty string variable.
An exception raised within a catch-block terminates
the function and returns control to the enclosing environment.

The argument to the catch statement is a target list,
which holds the exception variables you are interested in.

The snippet below illustrates how an exception raised
in the function @code{io.read} is catched using the exception variable IOerror.
After dealing with it locally, it raises a new exception @code{ FATALerror}
for the enclosing call.

@example
	io.write("Welcome");
	...
catch IOerror:str;
	print("input error on reading password");
raise FATALerror:= "Can't handle it";
exit IOerror;
@end example

Since @code{catch} is a flow control modifier it can be attached to any
assignment statement. This statement is executed whenever there is no
exception outstanding, but will be ignored when control is moved
to the block otherwise.

@- Builtin exceptions 
The policy implemented in the MAL modules, and recognized by
the interpreter, is to return a string value by default.
A NULL return value indicates succesful execution; otherwise
the string encodes information to analyse the error occurred.

This string pattern is strictly formatted and easy to analyse.
It starts with the name of the exception variable to
be set, followed by an indication where the exception was
raise, i.e. the function name and the program counter,
and concludes with specific information needed to interpret 
and handle the exception.

For example, the exception string 
@code{ 'MALexception:Admin.main[2]:address of function missing'}
denotes an exception raised while typechecking a MAL program.

The exceptions captured within the kernel are marked as 'GDKerror'.
At that level there is no knowledge about the MAL context, which
makes interpretation difficult for the average programmer.
Exceptions in the MAL language layer are denoted by 'MALerror',
and query language exceptiosn fall in their own class, e.g. 'SQLerror'.
Exceptions can be cascaded to form a trail of exceptions recognized
during the exection.

@{
@f mal_errors
@+ Error Handling
Internationalization and consistent error reporting is helped by a
central place of all kernel error messages. 
They are split into @code{fatal}, code{errors} and @code{warnings}.
The second category is the system component in which it is raised.

The first attempt: grep on src/MAL module.

@-
@f mal_exception
@h
#ifndef _MAL_EXCEPTION_H
#include "mal_instruction.h"
/*VARARGS*/
mal_export str	throwException(str nme, str fcn, char *format, ...);
mal_export str	raiseException(MalBlkPtr mb, int pc, str name, str msg);
mal_export str	appendException(MalBlkPtr mb, int pc, str name, str msg,str old);
mal_export str	locateException(MalBlkPtr mb, int pc, str oldmsg);
mal_export void	showException(MalBlkPtr mb, int pc, str name, str msg);

#define MALEXCEPTION "MALexception"
#define throwMessage(Fcn,Msg)   throwException(MALEXCEPTION,Fcn,"%s",Msg)
/* Fabian's convenience `tools' */
#ifdef USE_NICE_N_SHINY_EXCEPTIONS
mal_export str  createException(str name, str func, str file, int line, char *format, ...);
mal_export str  stackException(str prev, str func, str file, int line);
mal_export str  getBasename(const str in);
#define throw(TPE, FCN, MSG) \
	return(createException(TPE, FCN, getBasename(__FILE__), __LINE__, "%s", MSG));
#define throwf(TPE, FCN, FMT, ARG) \
	return(createException(TPE, FCN, getBasename(__FILE__), __LINE__, FMT, ARG));
#define throwf2(TPE, FCN, FMT, ARG1, ARG2) \
	return(createException(TPE, FCN, getBasename(__FILE__), __LINE__, FMT, ARG1, ARG2));
#define throwf3(TPE, FCN, FMT, ARG1, ARG2, ARG3) \
	return(createException(TPE, FCN, getBasename(__FILE__), __LINE__, FMT, ARG1, ARG2, ARG3));
#define rethrow(FCN, TMP, PRV) \
	if ((TMP = stackException(PRV, FCN, getBasename(__FILE__), __LINE__)) != MAL_SUCCEED) { \
		GDKfree(PRV); \
		return(TMP); \
	}
#else /* no shiny exceptions */
#define throw(TPE, FCN, MSG) \
	return(throwException(TPE, FCN, "%s", MSG))
#define throwf(TPE, FCN, FMT, ...) \
	return(throwException(TPE, FCN, FMT , ## __VA_ARGS__))
#define rethrow(FCN, TMP, PRV) \
	if ((TMP = PRV) != MAL_SUCCEED) return(TMP);
#endif
#define throwIllArg(FCN, MSG) \
	throw("IllegalArgumentException", FCN, MSG);
#define throwIllArgf(FCN, FMT, ...) \
	throwf("IllegalArgumentException", FCN, FMT , ## __VA_ARGS__);
#define throwOutOfBnds(FCN, MSG) \
	throw("OutOfBoundsException", FCN, MSG);
#define throwOutOfBndsf(FCN, FMT, ...) \
	throwf("OutOfBoundsException", FCN, FMT , ## __VA_ARGS__);
#define throwIO(FCN, MSG) \
	throw("IOException", FCN, MSG);
#define throwIOf(FCN, FMT, ...) \
	throwf("IOException", FCN, FMT , ## __VA_ARGS__);
#define throwMal(FCN, MSG) \
	throw(MALEXCEPTION, FCN, MSG);
#define throwMalf(FCN, FMT, ...) \
	throwf(MALEXCEPTION, FCN, FMT , ## __VA_ARGS__);

#endif /*  _MAL_EXCEPTION_H*/

@-
@c
#include "mal_exception.h"

str appendException(MalBlkPtr mb, int pc, str name, str msg,str oldmsg){
	char buf[4196];
	int i;
	str s,fcn;

	s = mb? getModName(mb): "";
	fcn= mb? getFcnName(mb):"";
	buf[0]=0;
	i= 0;
	if(oldmsg) snprintf(buf+i,4196,"%s",oldmsg);
	i= strlen(buf);
	if(name) snprintf(buf+i,4196-i,"%s:", name);
	i= strlen(buf);
	if(s) snprintf(buf+i,4196-i,"%s.",s);
	i= strlen(buf);
	snprintf(buf+i,4196-i,"%s",fcn);
	i= strlen(buf);
	snprintf(buf+i,4196-i,"[%d]",pc);
	i= strlen(buf);
	if(msg) snprintf(buf+i,4196-i,":%s",msg);
	i= strlen(buf);
	if( buf[i-1]!='\n'){ buf[i]='\n'; buf[i+1]=0;}
	return GDKstrdup(buf);
}
str locateException(MalBlkPtr mb, int pc, str oldmsg){
	str s, msg=0,name=0;

	if( (s= strchr(oldmsg,':'))){
		*s =0;
		name= oldmsg;
		msg= s+1;
	} else msg=oldmsg;
	return appendException(mb,pc,name,msg,0);
}
@-
The linked libraries should use the throwException to signal
an erroneous situation. It takes the name of MAL exception name
to be raised.
@c
/*VARARGS*/
str throwException(str nme, str fcn, char *format, ...){
	char message[GDKMAXERRLEN];
	int len = strlen(MALexception)+1;
	va_list ap;

	sprintf(message,"%s:%s:",nme,fcn);
	len = strlen(message);
	va_start(ap, format);
	vsnprintf(message + len, GDKMAXERRLEN-(len+2), format, ap);
	va_end(ap);

	return GDKstrdup(message);
}

/**
 * Creates a new exception using the given name, message, function,
 * location and line number.
 */
str createException(str name, str func, str file, int line, char *format, ...) {
	char message[GDKMAXERRLEN];
	int len;
	va_list ap;

	snprintf(message, GDKMAXERRLEN, "%s: ", name);
	len = strlen(message);
	va_start(ap, format);
	len += vsnprintf(message + len, GDKMAXERRLEN-(len+2), format, ap);
	va_end(ap);
	snprintf(message + len, GDKMAXERRLEN - (len + 2), "\n    at %s(%s:%d)", func, file, line);

	return GDKstrdup(message);
}

/**
 * Appends the given function, file and line number a previous
 * exception.  If the message is empty (MAL_SUCCEED), the same message
 * is returned immediately.
 */
str stackException(str prev, str func, str file, int line) {
	char message[GDKMAXERRLEN];
	char *bt;

	/* don't do anything if the previous message was no Exception */
	if (prev == MAL_SUCCEED) return(prev);

	/* find the point where the backtrace starts */
	bt = strstr(prev, "\n    at");
	if (bt == NULL) bt = "";
	*bt++ = '\0';
	sprintf(message, "%s\n    at %s(%s:%d)\n%s", prev, func, file, line, bt);

	return(GDKstrdup(message));
}

/**
 * Returns the basename of the given string.  The basename is
 * interpreted as the part of the input string after the last '/'
 * character, or the full string if no '/' is found.
 */
str getBasename(const str in) {
	int i = strlen(in);
	for (; i >= 0 && in[i] != '/'; i--);
	return(in + i + 1);
}

str raiseException(MalBlkPtr mb, int pc, str name, str msg){
	return appendException(mb,pc,name,msg,"");
}
void showException(MalBlkPtr mb, int pc, str name, str msg){
	str n;
	n= raiseException(mb,pc,name,msg);
	GDKerror(n);
	GDKfree(n);
}
@}
