@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008-2010 MonetDB B.V.
@' All Rights Reserved.

@f run_octopus
@a M. Kersten
@+ Octopus scheduling
The octopus modules enable compute cloud based processing of SQL queries.
The optimizer splits a plan managed by the mitosis and mergetable into
independent functions by backtracking the instruction flow starting
at the aggregation points.
This leads to a series of MAL functions with possibly quite some
instruction overlap when run at a single node, 
which will not be a problem when the recycler is active.

The octopus scheduler takes over control of a MAL execution by
re-directing requests to multiple sites. If there are no sites known,
then the code is executed linearly as is.

The scheduler runs all tentacles asynchronously if possible.
To make our live easier, we assume that all tentacles are
grouped together in a guarded block as follows:

@verbatim
barrier (parallel,version):= scheduler.octopus();
a:= octopus.exec_qry(sitename,fcnname,version,arg...);
...
b:= octopus.exec_qry(sitename,fcnname,version,arg...);
z:= mat.pack(a,...,b);
exit (parallel,version);
@end verbatim

This way the scope of the instructions can be easily deduced.
Moreover, the underlying data flow execution facility can
be used to schedule and initiate interaction with remote sites.
The octopus scheduler merely ensures that there are enough
work threads available.

To make the octopus work, the scheduler needs a list of databases
to play with. This list it gets from Merovingian by resolving
all with the property 'shared=octopus' (set by monetdb).
The default is to use the local database as a target.
@{
@mal
pattern scheduler.octopus(t:int)(:bit,version:int)
address OCTOPUSrun
comment "Run the program block in parallel, but don't wait longer then t seconds. Also fix a consistent database version.";
@h
#ifndef _RUN_OCTOPUS
#define _RUN_OCTOPUS
#include "mal.h"
#include "mal_instruction.h"
#include "mal_client.h"

/* #define DEBUG_RUN_OCTOPUS 		 to trace processing */

#ifdef WIN32
#ifndef LIBRUN_OCTOPUS
#define octopus_export extern __declspec(dllimport)
#else
#define octopus_export extern __declspec(dllexport)
#endif
#else
#define octopus_export extern
#endif

octopus_export str OCTOPUSrun(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
#endif /* MAL_RUN_OCTOPUS */

@+ Octopus scheduling implementation
The discovery phase consists of establishing connections with
the (remote) database servers.
@c
#include "mal_config.h"
#include "mal_interpreter.h"
#include "mat.h"
#include "run_octopus.h"
#include "optimizer.h"
#include <mapilib/Mapi.h>
#include "remote.h"
#include "mal_sabaoth.h"

typedef struct REGMAL{
	str fcn;
	struct REGMAL *nxt;
} *Registry;

typedef struct {
	str name;
	str uri;
	str usr;
	str pwd;
	Registry nxt;	/* list of registered queries */
} Worker;

#define MAXSITES 2048	/* should become dynamic at some point */
static Worker workers[MAXSITES];
static int nroctopus = 0;

static str
OCTOPUSdiscover(Client cntxt){
	bat bid = 0;
	BAT *b;
	BUN p,q;
	str msg = MAL_SUCCEED;
	BATiter bi;
	char buf[BUFSIZ]= "*/octopus", *s= buf;

	if (nroctopus ==MAXSITES) 
		throw(MAL,"octopus.discover",OPERATION_FAILED "No octopus worker left");

	msg = RMTresolve(&bid,&s);
	if ( msg != MAL_SUCCEED){
		/* there is a last resort, yourself */
		SABAOTHgetLocalConnection(&s);
		snprintf(buf,BUFSIZ,"worker_%d",nroctopus);
		workers[nroctopus].name = GDKstrdup(buf);
		workers[nroctopus].uri = s;
		workers[nroctopus].usr = GDKstrdup("monetdb");
		workers[nroctopus].pwd = GDKstrdup("monetdb");
#ifdef DEBUG_RUN_OCTOPUS
		stream_printf(cntxt->fdout,"Worker site %d %s\n", nroctopus, s);
#else
		(void) cntxt;
#endif
		nroctopus++;
		return MAL_SUCCEED;
	}
	b = BATdescriptor(bid);
	if ( b == NULL)
		throw(MAL,"octopus.discover",OPERATION_FAILED "No octopus worker list available");

	bi= bat_iterator(b);
	BATloop(b,p,q){
		str t= (str) BUNtail(bi,p);

		if (nroctopus ==MAXSITES) 
			throw(MAL,"octopus.discover",OPERATION_FAILED "No octopus worker left");
		snprintf(buf,BUFSIZ,"worker_%d",nroctopus);
		workers[nroctopus].name = GDKstrdup(buf);
		workers[nroctopus].usr = GDKstrdup("monetdb");
		workers[nroctopus].uri = GDKstrdup(t);
		workers[nroctopus].pwd = GDKstrdup("monetdb");
#ifdef DEBUG_RUN_OCTOPUS
		stream_printf(cntxt->fdout,"Worker site %d %s\n", nroctopus, t);
#endif
		nroctopus++;
	}
#ifdef DEBUG_RUN_OCTOPUS
		stream_printf(cntxt->fdout,"Octopus workers %d\n",nroctopus);
#endif
	BBPreleaseref(bid);
	return MAL_SUCCEED;
}

@-
We first register the tentacle code at all worker sites and keep
a list of those already sent.
@c
static int
OCTOPUSfind(Worker s, str qry){
	Registry r;
	for ( r= s.nxt; r; r= r->nxt)
	if ( strcmp(qry, r->fcn)==0)
		return 1;
	return 0;
}

@-
The functions called by the octopus.exec_qry are to be
registered at all sites. We assume for the time being
that all instructions registered are unique.
@c
static str
OCTOPUSregister(Client cntxt, MalBlkPtr mb, InstrPtr p)
{
	int i,ret;
	str conn, fname, msg = MAL_SUCCEED;

	fname = getVarConstant(mb,getArg(p,2)).val.sval;
	for ( i= 0; i< nroctopus; i++){
#ifdef DEBUG_RUN_OCTOPUS
		stream_printf(cntxt->fdout,"connect to worker %s\n", workers[i].uri);
#else
		(void) cntxt;
#endif
		msg= RMTconnect(&conn, &workers[i].uri, &workers[i].usr, &workers[i].pwd);
		if (msg ){
			stream_printf(cntxt->fdout,"!%s\n",msg);
			if (msg != M5OutOfMemory)
				GDKfree(msg);
			msg = NULL;
			(void) RMTdisconnect(&ret,&conn);
			continue;
		}
		if( !OCTOPUSfind(workers[i], fname) ){
			msg = RMTregisterInternal(cntxt, conn, octopusRef, fname);

#ifdef DEBUG_RUN_OCTOPUS
			stream_printf(cntxt->fdout,"octopus.%s registered at site %s\n",
				fname,workers[i].uri);
			stream_printf(cntxt->fdout,"reply: %s\n",msg?msg:"ok");
#endif
			if ( msg == MAL_SUCCEED){
				Registry r= (Registry) GDKzalloc(sizeof(struct REGMAL));
				r->fcn = GDKstrdup(getFunctionId(p));
				r->nxt = workers[i].nxt;
				workers[i].nxt = r;
			}
		}
		(void) RMTdisconnect(&ret,&conn);
	}
	GDKfree(conn);
	return msg;
}
@-
The work division looks at the system opportunities and
replaces all null valued target site references in all instructions.
The first policy is to simply perform round robin.
The more advanced way is to negotiat with the remote sites.
@c
static str
OCTOPUSworkdivision(Client cntxt, MalBlkPtr mb, MalStkPtr stk, int pc)
{
	static int rr=0,i;
	str msg = MAL_SUCCEED;
	InstrPtr p;
	ValPtr cst;

	for (; pc< mb->stop && workers[rr].uri; pc++){
		p= getInstrPtr(mb,pc);
		if ( p->barrier == EXITsymbol || getFunctionId(p)== packRef)
			break;
		i = getArg(p,1);
		assert( isVarConstant(mb, i) && getVarType(mb,i)== TYPE_str);
		cst = &getVarConstant(mb, i);
		if ( strncmp(cst->val.sval,"mapi:monetdb://",15) == 0){
#ifdef DEBUG_RUN_OCTOPUS
			stream_printf(cntxt->fdout,"reuse of worker %s\n",cst->val.sval);
			printInstruction(cntxt->fdout,mb,0,p,LIST_MAL_STMT);
#endif
			continue;
		}
		garbageElement(cntxt, &stk->stk[i]);
		stk->stk[i].val.sval = GDKstrdup(workers[rr].uri);
		stk->stk[i].len = (int) strlen(stk->stk[i].val.sval);
#ifdef DEBUG_RUN_OCTOPUS
		stream_printf(cntxt->fdout,"octopus site selected %s %s\n",workers[rr].name, workers[rr].uri);
		printInstruction(cntxt->fdout,mb,0,p,LIST_MAL_STMT);
#else
		(void) cntxt;
#endif
		rr= (rr+1) % nroctopus;
	}
	return msg;
}
@-
The scheduler runs all tentacles asynchronously.
We should be careful in accessing a site that runs out
of clients or any failure. It may cause the system to
wait forever.

The version argument indicates the tentacles
if it is time to refresh their caches. 
It should be obtained from the recycler where we
know when updates have been taken place.

The time-out parameter is not used yet.
@c
str
OCTOPUSrun(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	bit *res = (bit*) getArgReference(stk,pci,0);
	int *version = (int*) getArgReference(stk,pci,1);
	int j, start, stop, threadcnt=0;
	InstrPtr p;
	str msg = MAL_SUCCEED;
	*res = 0;	/* execute the block */
	*version = 0;

	msg= OCTOPUSdiscover(cntxt);
	if ( msg )
		return msg; 

	start= getPC(mb,pci) + 1;
	for (j= start; j<mb->stop ; j++){
		p= getInstrPtr(mb,j);
		if ( p->barrier == EXITsymbol  || getFunctionId(p)== packRef)
			break;
		if (nroctopus > 0) {
			msg= OCTOPUSregister(cntxt,mb,p);
			if ( msg && strstr(msg,"already defined on the remote site")==0 )
				return msg;
			threadcnt++;
		}
	}
	stop =j;

	msg= OCTOPUSworkdivision(cntxt,mb,stk,start);
	if ( msg )
		return msg;

	*res =1;
	/* if necessary increase the worker set */
	/* DFLOWworkers(threadcnt); */
	(void) threadcnt;
	return runMALdataflow(cntxt,mb,start,stop,stk,0,pci);
}
@}
