@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f calc
@a N.J. Nes, P. Boncz, M. Kersten, A. de Vries
@v 2.0
@* Basic arithmetic 
This module is an extended version of the V4 arithmetic module.
It implements the arithmetic operations on the built-in types,
@emph{chr}, @emph{sht}, @emph{int}, @emph{flt}, @emph{dbl} and @emph{lng}.
All combinations are implemented. Limited combinations are implemented
for @emph{bit}, @emph{oid} and @emph{str}. 

@table @code
@item[binary operators]
The implemented operators are first of all all comparison that return a 
TRUE/FALSE value (@emph{bit} values), i.e. 
@emph{<=}, @emph{<}, @emph{==}, @emph{!=}, @emph{>=}, and @emph{>=}.

The module also implements the operators @emph{+}, @emph{-}, @emph{*} and @emph{/}. 
The rules for the return types operators is as follows.
If one of the input types is a floating point the result will be a
floating point.  The largest type of the input types is taken. 

The @emph{max} and @emph{min} functions return the maximum and minimum of 
the two input parameters.

@item[unary operators]
This module also implements the unary @emph{abs}() function, which calculates 
the absolute value of the given input parameter, as well as the @emph{-} unary
operator. 

The @emph{inv} unary operation calculates the inverse of the input value. 
An error message is given when the input value is zero.

@item[bitwise operators]
For integers there are some additional operations. The @emph{\%} operator
implements the congruent modulo operation. The @emph{<<} and @emph{>>} 
are the left and right bit shift. The @emph{or}, @emph{and}, @emph{xor} and 
@emph{not} for integers are implemented as bitwise boolean operations. 

@item[boolean operators]
The @emph{or}, @emph{and}, @emph{xor} and @emph{not} for the bit atomic type 
in MIL (this corresponds to what is normally called boolean)
are implemented as the logic operations.

@item[random numbers]
This module also contains the rand and srand functions. The @emph{srand}() 
function initializes the random number generator using a seed value. The 
subsequent calls to @emph{rand}() are pseudo random numbers (with the same 
seed the sequence can be repeated).
@end table

The general interpretation for the NIL value is "unknown".
This semantics mean that any operation that receives at least one NIL 
value, will produce a NIL value in the output for sure.

The only exception to this rule are the "==" and "!=" equality 
test routines (it would otherwise become rather difficult to test 
whether a value is nil). 

The collection of type conversion routines are included here as well.

The definitions shown are limited to the Mx macros.
This should be sufficient to understand the functionality
at the cost of precision.
In most situations the macros are expanded using the
built-in type set (int,lng,sht,bit,oid,flt,...) 
@= mal_isnil
	command isnil(v:@1) :bit 
	address CALCisnil_@1
	comment "is a value nil?";
	command isnotnil(v:@1) :bit 
	address CALCisnotnil_@1
	comment "is a value not equal to nil?";
@-
[Mx bug, space required here]

@{
@mal
module calc;

	@:mal_isnil(chr)@
	@:mal_isnil(bit)@
	@:mal_isnil(sht)@
	@:mal_isnil(int)@
	@:mal_isnil(oid)@
	@:mal_isnil(flt)@
	@:mal_isnil(lng)@
	@:mal_isnil(dbl)@
	@:mal_isnil(str)@
command isnil(v:void) :bit 
address CALCisnil_void
comment "is a value nil?";
command isnotnil(v:void) :bit 
address CALCisnotnil_void
comment "is a value not equal to nil?";
@}
@+ Comparison operations
The @emph{eq_ops} and @emph{cmp_ops} Mx macro implements the interface to the
arithmetic comparisons. Note that comparison operators with different
operand types are already supported in the kernel, but are not nearly as fast,
(because they have to convert values on the fly).  
The code expansion is organized such that
the least interesting one is pushed onto the symbol table stack first.

@= eq_ops
        command ==(left:@1, right:@2) :bit 
        address CALCcompEQ@1@2;
        command !=(left:@1, right:@2) :bit 
        address CALCcompNEQ@1@2;
@= cmp_ops
        @:eq_ops(@1,@2)@

        command <(left:@1, right:@2) :bit 
        address CALCcompLT@1@2;
        command <=(left:@1, right:@2) :bit 
        address CALCcompLE@1@2;
        command >=(left:@1, right:@2) :bit 
        address CALCcompGE@1@2;
        command >(left:@1, right:@2) :bit 
        address CALCcompGT@1@2;
        command between(val:@1, low:@1, high:@1) :bit 
        address CALCcompBetween@1;
@{
@mal

        @:cmp_ops(oid,oid)@
        @:cmp_ops(flt,flt)@
        @:cmp_ops(flt,dbl)@
        @:cmp_ops(dbl,dbl)@

        @:cmp_ops(chr,chr)@
        @:cmp_ops(chr,sht)@
        @:cmp_ops(chr,int)@
        @:cmp_ops(chr,lng)@

        @:eq_ops(bit,chr)@
        @:eq_ops(bit,sht)@
        @:eq_ops(bit,int)@
        @:eq_ops(bit,lng)@

        @:cmp_ops(sht,chr)@
        @:cmp_ops(sht,sht)@
        @:cmp_ops(sht,int)@
        @:cmp_ops(sht,lng)@

        @:cmp_ops(int,chr)@
        @:cmp_ops(int,sht)@
        @:cmp_ops(int,int)@
        @:cmp_ops(int,lng)@

        @:cmp_ops(lng,chr)@
        @:cmp_ops(lng,sht)@
        @:cmp_ops(lng,int)@
        @:cmp_ops(lng,lng)@

        @:cmp_ops(str,str)@
@}
@+ Arithmetic computation 
The operators @{ +, -, *, /, % @} are handled here.
The macro expects three parameters, two input atomic types and a result type. 
@mal
command %(left:chr, right:int) :int 
address CALCbinaryMODchrint;
command %(left:sht, right:int) :int 
address CALCbinaryMODshtint;
command %(left:int, right:int) :int 
address CALCbinaryMODintint;
command %(left:lng, right:int) :int 
address CALCbinaryMODlngint;
command %(left:lng, right:lng) :lng 
address CALCbinaryMODlnglng;
command %(left:int, right:chr) :chr 
address CALCbinaryMODintchr;
command %(left:int, right:sht) :sht 
address CALCbinaryMODintsht;

command +(l:str,r:str):str
address CALCstrConcat
comment "Concatenate two strings";
command +(l:str,r:int):str
address CALCstrConcatInt
comment "Concatenate two strings";

@= mal_calc_ops
        command +(left:@1, right:@2) :@3 
        address CALCbinaryADD@1@2; 
        command -(left:@1, right:@2) :@3 
        address CALCbinarySUB@1@2;
        command *(left:@1, right:@2) :@3 
        address CALCbinaryMUL@1@2;
        command /(left:@1, right:@2) :@3 
        address CALCbinarycheckDIV@1@2;
@{
@-
The coercions described below ensure that there is never any information loss.
@mal

	@:mal_calc_ops(flt,chr,flt)@
	@:mal_calc_ops(flt,sht,flt)@
	@:mal_calc_ops(flt,int,flt)@
	@:mal_calc_ops(flt,lng,flt)@
	@:mal_calc_ops(flt,flt,flt)@
	@:mal_calc_ops(flt,dbl,dbl)@

	@:mal_calc_ops(dbl,chr,dbl)@
	@:mal_calc_ops(dbl,sht,dbl)@
	@:mal_calc_ops(dbl,int,dbl)@
	@:mal_calc_ops(dbl,lng,dbl)@
	@:mal_calc_ops(dbl,flt,dbl)@
	@:mal_calc_ops(dbl,dbl,dbl)@

	@:mal_calc_ops(oid,oid,oid)@

	@:mal_calc_ops(chr,chr,chr)@
	@:mal_calc_ops(chr,sht,sht)@
	@:mal_calc_ops(chr,int,int)@
	@:mal_calc_ops(chr,lng,lng)@
	@:mal_calc_ops(chr,flt,flt)@
	@:mal_calc_ops(chr,dbl,dbl)@

	@:mal_calc_ops(sht,chr,sht)@
	@:mal_calc_ops(sht,sht,sht)@
	@:mal_calc_ops(sht,int,int)@
	@:mal_calc_ops(sht,lng,lng)@
	@:mal_calc_ops(sht,flt,flt)@
	@:mal_calc_ops(sht,dbl,dbl)@

	@:mal_calc_ops(int,chr,int)@
	@:mal_calc_ops(int,sht,int)@
	@:mal_calc_ops(int,int,int)@
	@:mal_calc_ops(int,lng,lng)@
	@:mal_calc_ops(int,flt,flt)@
	@:mal_calc_ops(int,dbl,dbl)@

	@:mal_calc_ops(lng,chr,lng)@
	@:mal_calc_ops(lng,sht,lng)@
	@:mal_calc_ops(lng,int,lng)@
	@:mal_calc_ops(lng,lng,lng)@
	@:mal_calc_ops(lng,flt,flt)@
	@:mal_calc_ops(lng,dbl,dbl)@
@}
@+ Binary  operations { max, min, }
@= mal_binary_ops
        command max(l:@1, r:@1) :@1 
        address CALCbinaryMAX@2; 
        command min(l:@1, r:@1) :@1 
        address CALCbinaryMIN@2;
@{
@-
@mal
	@:mal_binary_ops(chr,chr)@
	@:mal_binary_ops(sht,sht)@
	@:mal_binary_ops(int,int)@
	@:mal_binary_ops(oid,oid)@
	@:mal_binary_ops(flt,flt)@
	@:mal_binary_ops(lng,lng)@
	@:mal_binary_ops(dbl,dbl)@
@}
@+ Unary operations { abs, inv }
The unary operators include coercion routines for built-in types
@= mal_unary_ops
        command abs(x:@1) :@1 
        address CALCunary@1ABS 
        comment "absolute value";
        command inv(x:@1) :@1 
        address CALCunarycheck@1INV 	
        comment "inverse value (1/x)";
        command -(x:@1) :@1 
        address CALCunary@1NEG 
        comment "negative value";
@{
@-
@mal
	@:mal_unary_ops(dbl)@
	@:mal_unary_ops(flt)@
	@:mal_unary_ops(chr)@
	@:mal_unary_ops(sht)@
	@:mal_unary_ops(int)@
	@:mal_unary_ops(lng)@
@}
@-
Coercion functions are typical used in multiplex calls.
@= mal_coercion
        command @1(x:@2):@1 
        address CALC@22@1 
        comment "coercion @2 to @1";
@{
@= scalar_coercion
	@:mal_coercion(@1,oid)@
	@:mal_coercion(@1,bit)@
	@:mal_coercion(@1,sht)@
	@:mal_coercion(@1,int)@
	@:mal_coercion(@1,lng)@
	@:mal_coercion(@1,flt)@
	@:mal_coercion(@1,dbl)@
@mal
	@:mal_coercion(bit,bit)@
	@:mal_coercion(bit,sht)@
	@:mal_coercion(bit,int)@
	@:mal_coercion(bit,lng)@
	@:mal_coercion(bit,flt)@
	@:mal_coercion(bit,dbl)@

	@:scalar_coercion(bit)@
	@:scalar_coercion(chr)@
	@:scalar_coercion(lng)@
	@:scalar_coercion(int)@
	@:scalar_coercion(sht)@

	@:mal_coercion(oid,oid)@
	@:mal_coercion(oid,lng)@
	@:mal_coercion(oid,sht)@
	@:mal_coercion(oid,int)@

	@:mal_coercion(flt,flt)@
	@:mal_coercion(flt,dbl)@
	@:mal_coercion(flt,sht)@
	@:mal_coercion(flt,int)@
	@:mal_coercion(flt,lng)@

	@:mal_coercion(dbl,dbl)@
	@:mal_coercion(dbl,flt)@
	@:mal_coercion(dbl,sht)@
	@:mal_coercion(dbl,int)@
	@:mal_coercion(dbl,lng)@

	@:mal_coercion(str,sht)@
	@:mal_coercion(str,int)@
	@:mal_coercion(str,lng)@
	@:mal_coercion(str,flt)@
	@:mal_coercion(str,dbl)@

	@:mal_coercion(chr,chr)@
	@:mal_coercion(chr,sht)@
	@:mal_coercion(chr,int)@
	@:mal_coercion(chr,lng)@

	@:mal_coercion(ptr,lng)@

@}
@+ Boolean operations { or, xor, and, not }
@mal
command or(left:bit, right:bit) :bit 
address CALCbinaryORbit;
command and(left:bit, right:bit) :bit 
address CALCbinaryANDbit;
command xor(left:bit, right:bit) :bit 
address CALCbinaryXORbit;
command not(left:bit) :bit 
address CALCunarybitNOT ;
command ifthenelse(b:bit,t:any_1,tpe:any_1,f:any_1):any_1 
address CALCswitchbit;

@+ Bitwise operations
Cardinal numerical types (inclusing @emph{chr} can be regarded as a bit
array. Specific operations work with this interpretation.
@= mal_bitwise_ops
        command or(left:@1, right:@1) :@1 
        address CALCbinaryOR@1@1;
        command and(left:@1, right:@1) :@1 
        address CALCbinaryAND@1@1;
        command xor(left:@1, right:@1) :@1 
        address CALCbinaryXOR@1@1;
        command not(left:@1) :@1 
        address CALCunary@1NOT;
        command <<(left:@1,right:int) :@1 
        address CALCbinaryLSH@1int;
        command >>(left:@1, right:int) :@1 
        address CALCbinaryRSH@1int;
@{
@mal
	@:mal_bitwise_ops(chr)@
	@:mal_bitwise_ops(sht)@
	@:mal_bitwise_ops(int)@
	@:mal_bitwise_ops(lng)@
@}
@+ Type coercions
The Monet kernel contains a few built-in atomic types together
with useful functions. 
Those accessible at the MAL command level are introduced below.

@= convertCmd
        command @1(v:str):@1 
        address CALCstr2@1;
        command str(v:@1):str 
        address CALC@12str;
        command @1(v:void) :@1 
        address CALCnil2@1;

@{
@mal
@:convertCmd(oid)@
@:convertCmd(sht)@
@:convertCmd(int)@
@:convertCmd(lng)@
@:convertCmd(flt)@
@:convertCmd(dbl)@
@:convertCmd(bit)@
@:convertCmd(ptr)@
@:convertCmd(chr)@

command bat(v:str):bat[:any_1,:any_2] 
address CALCstr2bat;
command str(v:bat[:any_1,:any_2]):str 
address CALCbat2str;
command bat(v:void) :bat[:any_1,:any_2] 
address CALCnil2bat;

command str(v:void) :str 
address CALCnil2str;
command str(v:str) :str 
address CALCstr2str;

command void(v:void) :void 
address CALCnil2void;
command void(v:int) :void 
address CALCint2void;
command void(v:sht) :void 
address CALCsht2void;
command void(v:lng) :void 
address CALClng2void;

command setoid(v:int)
address intSetoidImpl;
command setoid(v:lng)
address lngSetoidImpl;
command setoid(v:oid)
address oidSetoidImpl;

command getBATidentifier(b:bat[:any_1,:any_2]):bat
address CALCbat2batid
comment "Coerce bat to BAT identifier";
command getBAT(b:bat):bat[:any_1,:any_2]
address CALCbatid2bat
comment "Coerce bat to BAT identifier";

@}
@-
We should also deal with superflous operations, such as int(v:int).
This is a noop operation that should ideally be filtered out with
the code squeezer. [TODO]
@+ OID utility functions
@mal
command newoid() :oid 
address CALCnewoidBase
comment "Generate a new oid. Equivalent to newoid(0,1)";

command newoid(incr:lng) :oid 
address CALCnewoidInclng;
command newoid(incr:int) :oid 
address CALCnewoidInc
comment "Reserves a range of consecutive unique OIDs; returns the lowest 
        in range.  equivalent to newoid(0,incr)";

command setoid(base:oid) :oid 
address CALCsetoidInc
comment "Sets the oid range of consecutive unique OIDs; returns the 
        lowest in range.";

command setoid() :oid 
address CALCsetoidBase
comment "Equivalent to setoid(1:oid).";
@{
@+ Example script 
The following example MIL script will do each operation in the
calc module. It can be used for testing and the M2m compiler.

@mil
setoid(oid(20000000));
chr1 := 'a';
chr2 := 'c';
sht1 := sht(2);
sht2 := sht(5);
int1 := 5;
int2 := 2;
flt1 := 2.5;
flt2 := 5.4;
dbl1 := dbl(-2.500001);	       # may also need string since float is default
dbl2 := dbl(54.00456789);      # real and is less significant	
lng1 := lng("-9000000000000"); # string needed because lng doesn't fit in an
lng2 := lng("5400456789");     # int
oid1 := oid(int1);
oid2 := oid(int2);

@:mil_comp_ops('a','z')@
@:mil_comp_ops(sht1,sht2)@
@:mil_comp_ops(int1,int2)@
@:mil_comp_ops(flt1,flt2)@
@:mil_comp_ops(dbl1,dbl2)@
@:mil_comp_ops("abcde","abcdf")@

@:mil_calc_ops(chr1,chr2)@
@:mil_calc_ops(chr1,sht2)@
@:mil_calc_ops(chr1,int2)@
@:mil_calc_ops(chr1,lng2)@
@:mil_calc_ops(chr1,flt2)@
@:mil_calc_ops(chr1,dbl2)@

@:mil_calc_ops(sht1,chr2)@
@:mil_calc_ops(sht1,sht2)@
@:mil_calc_ops(sht1,int2)@
@:mil_calc_ops(sht1,lng2)@
@:mil_calc_ops(sht1,flt2)@
@:mil_calc_ops(sht1,dbl2)@

@:mil_calc_ops(int1,chr2)@
@:mil_calc_ops(int1,sht2)@
@:mil_calc_ops(int1,int2)@
@:mil_calc_ops(int1,lng2)@
@:mil_calc_ops(int1,flt2)@
@:mil_calc_ops(int1,dbl2)@

@:mil_calc_ops(lng1,chr2)@
@:mil_calc_ops(lng1,sht2)@
@:mil_calc_ops(lng1,int2)@
@:mil_calc_ops(lng1,lng2)@
@:mil_calc_ops(lng1,flt2)@
@:mil_calc_ops(lng1,dbl2)@

@:mil_calc_ops(flt1,chr2)@
@:mil_calc_ops(flt1,sht2)@
@:mil_calc_ops(flt1,int2)@
@:mil_calc_ops(flt1,lng2)@
@:mil_calc_ops(flt1,flt2)@
@:mil_calc_ops(flt1,dbl2)@

@:mil_calc_ops(dbl1,chr2)@
@:mil_calc_ops(dbl1,sht2)@
@:mil_calc_ops(dbl1,int2)@
@:mil_calc_ops(dbl1,lng2)@
@:mil_calc_ops(dbl1,flt2)@
@:mil_calc_ops(dbl1,dbl2)@

@:mil_calc_ops(oid1,oid2)@

max(sht1,sht2).print;
max(int1,int2).print;
max(lng1,lng2).print;
max(flt1,flt2).print;
max(dbl1,dbl2).print;

min(sht1,sht2).print;
min(int1,int2).print;
min(flt1,flt2).print;
min(dbl1,dbl2).print;
min(lng1,lng2).print;

abs(sht2).print;
abs(int2).print;
abs(flt2).print;
abs(dbl2).print;
abs(lng2).print;

@:mil_calc_ops(oid1,oid2)@
max(oid1,oid2).print;
min(oid1,oid2).print;

inv(sht2).print;
inv(int2).print;
inv(flt2).print;
inv(dbl2).print;
inv(lng2).print;

(int1% int2).print;
(int1<<int2).print;
(int1>>int2).print;

(int1 or  int2).print;
(int1 and int2).print;
(int1 xor int2).print;
not(int2).print;

bit1 := true;
bit2 := false;
(bit1 or  bit2).print;
(bit1 and bit2).print;
(bit1 xor bit2).print;
not(bit2).print;

srand( 1234 );
rand().print;
quit;
@-
The @emph{comp_ops} implements the mil example script comparison 
operations.  It gets two parameters which are the operants for the operations.

@= mil_comp_ops
 (@1 < @2).print;  (@2 < @1).print;  (@1 < @1).print;
(@1 <= @2).print; (@2 <= @1).print; (@1 <= @1).print;
 (@1 = @2).print;  (@2 = @1).print;  (@1 = @1).print;
(@1 >= @2).print; (@2 >= @1).print; (@1 >= @1).print;
 (@1 > @2).print;  (@2 > @1).print;  (@1 > @1).print;
@

The @emph{calc_ops} implements the mil example script arithmetic 
operations.  It gets two parameters which are the operants for the operations.

@= mil_calc_ops
(@1 + @2).print;
(@1 - @2).print;
(@1 * @2).print;
(@1 / @2).print;
@

@{
@* Implementation
The implementation below differs from the pre-V5 implementation in
that all strings and pointers are passed by reference, rather than
by value. Since it is unclear in the module implementation whether
such references are static or refer to dynamic allocated space,
we have to be conservative. All deallocation calls should be prepared
and handled by the environment.
For this module this won't be a problem, because we do not change
the string representations.
@h
#ifndef __calc_H__
#define __calc_H__

#include "gdk.h"

#endif /* __calc_H__ */
@}

@c
#include "calc.h"
#include "stdlib.h"
#include "mal.h"
#include "mal_exception.h"

/* third param indicates return value if one of the params is nil */
@:c_comp_ops(<,LT)@
@:c_comp_ops(<=,LE)@
@:c_comp_ops(==,EQ)@
@:c_comp_ops(!=,NEQ)@
@:c_comp_ops(>=,GE)@
@:c_comp_ops(>,GT)@

@:c_calc_ops(chr,chr,chr)@
@:c_calc_ops(chr,sht,sht)@
@:c_calc_ops(chr,int,int)@
@:c_calc_ops(chr,lng,lng)@
@:c_calc_ops(chr,flt,flt)@
@:c_calc_ops(chr,dbl,dbl)@

@:c_calc_ops(sht,chr,sht)@
@:c_calc_ops(sht,sht,sht)@
@:c_calc_ops(sht,int,int)@
@:c_calc_ops(sht,lng,lng)@
@:c_calc_ops(sht,flt,flt)@
@:c_calc_ops(sht,dbl,dbl)@

@:c_calc_ops(int,chr,int)@
@:c_calc_ops(int,sht,int)@
@:c_calc_ops(int,int,int)@
@:c_calc_ops(int,lng,lng)@
@:c_calc_ops(int,flt,flt)@
@:c_calc_ops(int,dbl,dbl)@

@:c_calc_ops(lng,chr,lng)@
@:c_calc_ops(lng,sht,lng)@
@:c_calc_ops(lng,int,lng)@
@:c_calc_ops(lng,lng,lng)@
@:c_calc_ops(lng,flt,flt)@
@:c_calc_ops(lng,dbl,dbl)@

@:c_calc_ops(flt,chr,flt)@
@:c_calc_ops(flt,sht,flt)@
@:c_calc_ops(flt,int,flt)@
@:c_calc_ops(flt,lng,flt)@
@:c_calc_ops(flt,flt,flt)@
@:c_calc_ops(flt,dbl,dbl)@

@:c_calc_ops(dbl,chr,dbl)@
@:c_calc_ops(dbl,sht,dbl)@
@:c_calc_ops(dbl,int,dbl)@
@:c_calc_ops(dbl,lng,dbl)@
@:c_calc_ops(dbl,flt,dbl)@
@:c_calc_ops(dbl,dbl,dbl)@

@:c_calc_ops(oid,oid,oid)@

#define calc_abs(s) ((s)>0)?(s):-(s)
@:calc_unop(ABS,calc_abs,chr)@
@:calc_unop(ABS,calc_abs,sht)@
@:calc_unop(ABS,calc_abs,int)@
@:calc_unop(ABS,calc_abs,flt)@
@:calc_unop(ABS,calc_abs,dbl)@
@:calc_unop(ABS,calc_abs,lng)@

#define calc_inv(s) (1/(s))
@:check_unop(INV,calc_inv,chr)@
@:check_unop(INV,calc_inv,sht)@
@:check_unop(INV,calc_inv,int)@
@:check_unop(INV,calc_inv,flt)@
@:check_unop(INV,calc_inv,dbl)@
@:check_unop(INV,calc_inv,lng)@

#define calc_neg(s) (-(s))
@:calc_unop(NEG,calc_neg,chr)@
@:calc_unop(NEG,calc_neg,sht)@
@:calc_unop(NEG,calc_neg,int)@
@:calc_unop(NEG,calc_neg,flt)@
@:calc_unop(NEG,calc_neg,dbl)@
@:calc_unop(NEG,calc_neg,lng)@

@:any_binary_minmax(MIN,<=)@
@:any_binary_minmax(MAX,>)@

#define calc_max(s1,s2) ((s1)>(s2))?(s1):(s2)
@:calc_macrobinop(MAX,calc_max,chr)@
@:calc_macrobinop(MAX,calc_max,sht)@
@:calc_macrobinop(MAX,calc_max,int)@
@:calc_macrobinop(MAX,calc_max,oid)@
@:calc_macrobinop(MAX,calc_max,flt)@
@:calc_macrobinop(MAX,calc_max,dbl)@
@:calc_macrobinop(MAX,calc_max,lng)@

#define calc_min(s1,s2) ((s1)<(s2))?(s1):(s2)
@:calc_macrobinop(MIN,calc_min,chr)@
@:calc_macrobinop(MIN,calc_min,sht)@
@:calc_macrobinop(MIN,calc_min,int)@
@:calc_macrobinop(MIN,calc_min,oid)@
@:calc_macrobinop(MIN,calc_min,flt)@
@:calc_macrobinop(MIN,calc_min,dbl)@
@:calc_macrobinop(MIN,calc_min,lng)@

@:calc_binop(MOD,%,chr,int,int)@
@:calc_binop(MOD,%,sht,int,int)@
@:calc_binop(MOD,%,int,int,int)@
@:calc_binop(MOD,%,lng,int,int)@
@:calc_binop(MOD,%,lng,lng,lng)@
@:calc_binop(MOD,%,int,chr,chr)@
@:calc_binop(MOD,%,int,sht,sht)@

@:c_bitwise_ops(chr)@
@:c_bitwise_ops(sht)@
@:c_bitwise_ops(int)@
@:c_bitwise_ops(lng)@

@:c_shift_ops(chr)@
@:c_shift_ops(sht)@
@:c_shift_ops(int)@

mal_export str CALCstrConcat(str *ret, str *l, str *r);
str
CALCstrConcat(str *ret, str *l, str *r)
{
	str s;

	s = GDKmalloc(strlen(*l) + strlen(*r) + 1);
	strcpy(s, *l);
	strcat(s, *r);
	*ret = s;
	return MAL_SUCCEED;
}

mal_export str CALCstrConcatInt(str *ret, str *l, int *r);
str
CALCstrConcatInt(str *ret, str *l, int *r)
{
	str s;
	int len = strlen(*l) + 32;

	s = GDKmalloc(len);
	snprintf(s, len, "%s%d", *l, *r);
	*ret = s;
	return MAL_SUCCEED;
}

mal_export str CALCbinaryRSHlngint(lng *ret, lng *val, int *shift);
str
CALCbinaryRSHlngint(lng *ret, lng *val, int *shift)
{
	if (*val == lng_nil || *shift == int_nil) {
		*ret = lng_nil;
	} else {
		*ret = *val >> *shift;
	}
	return MAL_SUCCEED;
}

mal_export str CALCbinaryLSHlngint(lng *ret, lng *val, int *shift);
str
CALCbinaryLSHlngint(lng *ret, lng *val, int *shift)
{
	if (*val == lng_nil || *shift == int_nil) {
		*ret = lng_nil;
	} else {
		*ret = *val << *shift;
	}
	return MAL_SUCCEED;
}

mal_export str CALCbinaryANDbit(bit *retval, bit *v1, bit *v2);
str
CALCbinaryANDbit(bit *retval, bit *v1, bit *v2)
{
	if (*v1 == FALSE || *v2 == FALSE) {
		*retval = FALSE;
	} else if (*v1 == bit_nil || *v2 == bit_nil) {
		*retval = bit_nil;
	} else {
		*retval = TRUE;
	}
	return MAL_SUCCEED;
}

mal_export str CALCbinaryORbit(bit *retval, bit *v1, bit *v2);
str
CALCbinaryORbit(bit *retval, bit *v1, bit *v2)
{
	if (*v1 && *v1 != bit_nil) {
		*retval = TRUE;
	} else if (*v2 && *v2 != bit_nil) {
		*retval = TRUE;
	} else if (*v1 == bit_nil || *v2 == bit_nil) {
		*retval = bit_nil;
	} else {
		*retval = *v1 || *v2;
	}
	return MAL_SUCCEED;
}

mal_export str CALCbinaryXORbit(bit *retval, bit *v1, bit *v2);
str
CALCbinaryXORbit(bit *retval, bit *v1, bit *v2)
{
	if (*v1 == bit_nil || *v2 == bit_nil) {
		*retval = bit_nil;
	} else {
		*retval = ((*v1 && *v2 == FALSE) || (*v1 == FALSE && *v2));
	}
	return MAL_SUCCEED;
}

mal_export str CALCunarybitNOT(bit *retval, bit *value);
str
CALCunarybitNOT(bit *retval, bit *value)
{
	if (*value == bit_nil) {
		*retval = bit_nil;
	} else {
		*retval = (*value) ? FALSE : TRUE;
	}
	return MAL_SUCCEED;
}

mal_export str CALCswitchbit(ptr retval, bit *b, ptr v1, int tpe, ptr v2);
str
CALCswitchbit(ptr retval, bit *b, ptr v1, int tpe, ptr v2)
{
	ptr p;

	(void) retval;
	(void) b;
	(void) v1;
	(void) v2;		/* fool compiler */
	return throwMessage("ifthenelse", "not yet implemented\n");
	if (*b == bit_nil) {
		return MAL_SUCCEED;
		p = ATOMnilptr(tpe);
	} else if (*b) {
		p = v1;
	} else {
		p = v2;
	}
	if (ATOMextern(tpe)) {
		*(ptr **) retval = ATOMdup(tpe, p);
	} else {
		memcpy(retval, p, ATOMsize(tpe));
	}
	return MAL_SUCCEED;
}


@-
The @emph{c_comp} and @emph{c_comp_ops} macros implement the mil comparison 
operations.

@= any_binary_minmax
mal_export str CALCbinary@1any(ptr ret, ptr v1, int t, ptr v2);
str CALCbinary@1any(ptr ret, ptr v1, int t, ptr v2){
	int (*cmp)(ptr,ptr) = BATatoms[t].atomCmp;
	ptr src, nil = ATOMnilptr(t);
	if ((*cmp)(v1, nil) == 0 || (*cmp)(v2, nil) == 0) {
		src = nil;
	} else {
		src = ((*cmp)(v1, v2) @2 0)?v1:v2;
	}
	if (ATOMextern(t)) {
		int s = ATOMlen(t, src);
		str buf = *(str*) ret = (char*) GDKmalloc(s);
		memcpy(buf, src, s);
	} else {
		memcpy(ret, src, ATOMsize(t));
	}
	return MAL_SUCCEED;
}

@= c_comp_op
mal_export str CALCcomp@4@2@3(bit *retval, @2 *v1, @3 *v2);
str CALCcomp@4@2@3(bit *retval, @2 *v1, @3 *v2){
	if (*v1 == @2_nil || *v2 == @3_nil) {
		*retval = bit_nil;
	} else {
		*retval = *v1 @1 *v2;	
	}
	return MAL_SUCCEED;
}
@= c_comp_ops
        @:c_comp_op(@1,oid,oid,@2)@
        @:c_comp_op(@1,flt,flt,@2)@
        @:c_comp_op(@1,flt,dbl,@2)@
        @:c_comp_op(@1,dbl,dbl,@2)@

        @:c_comp_op(@1,chr,chr,@2)@
        @:c_comp_op(@1,chr,sht,@2)@
        @:c_comp_op(@1,chr,int,@2)@
        @:c_comp_op(@1,chr,lng,@2)@

        @:c_comp_op(@1,bit,chr,@2)@
        @:c_comp_op(@1,bit,sht,@2)@
        @:c_comp_op(@1,bit,int,@2)@
        @:c_comp_op(@1,bit,lng,@2)@

        @:c_comp_op(@1,sht,chr,@2)@
        @:c_comp_op(@1,sht,sht,@2)@
        @:c_comp_op(@1,sht,int,@2)@
        @:c_comp_op(@1,sht,lng,@2)@

        @:c_comp_op(@1,int,chr,@2)@
        @:c_comp_op(@1,int,sht,@2)@
        @:c_comp_op(@1,int,int,@2)@
        @:c_comp_op(@1,int,lng,@2)@

        @:c_comp_op(@1,lng,chr,@2)@
        @:c_comp_op(@1,lng,sht,@2)@
        @:c_comp_op(@1,lng,int,@2)@
        @:c_comp_op(@1,lng,lng,@2)@

mal_export str CALCcomp@2strstr(bit *retval, str *s1, str *s2);
str CALCcomp@2strstr(bit *retval, str *s1, str *s2){
	if (strNil(*s1) || strNil(*s2)) {
		*retval = bit_nil; 
	} else {
		*retval = (strcmp(*s1,*s2) @1 0);
	}
	return MAL_SUCCEED;
}
mal_export str CALCcomp@2any(bit *retval, ptr *v1, int tpe, ptr *v2);
str CALCcomp@2any(bit *retval, ptr *v1, int tpe, ptr *v2){
	int (*cmp)(ptr,ptr) = BATatoms[tpe].atomCmp;
	ptr nil = ATOMnilptr(tpe);

	if ((*cmp)(*v1, nil) == 0 || (*cmp)(*v2, nil) == 0) {
		*retval = bit_nil; 
	} else {
		*retval = ((*cmp)( *v1, *v2) @1 0);
	}
	return MAL_SUCCEED;
}
@c
@:c_between_op(chr)@
@:c_between_op(sht)@
@:c_between_op(int)@
@:c_between_op(oid)@
@:c_between_op(flt)@
@:c_between_op(dbl)@
@:c_between_op(lng)@
mal_export str CALCcompBetweenstr(bit *retval, str *val, str *low, str *high);
str
CALCcompBetweenstr(bit *retval, str *val, str *low, str *high)
{
	int val_nil = strNil(*val);
	int low_nil = strNil(*low);
	int high_nil = strNil(*high);

	if (val_nil || (low_nil && high_nil)) {
		*retval = bit_nil;
	} else if (low_nil) {
		*retval = (strcmp(*val, *high) <= 0);
	} else if (high_nil) {
		*retval = (strcmp(*low, *val) <= 0);
	} else {
		*retval = (strcmp(*low, *val) <= 0 && strcmp(*val, *high) <= 0);
	}
	return MAL_SUCCEED;
}

mal_export str CALCcompBetweenany(bit *retval, ptr *val, int tpe, ptr *low, ptr *high);
str
CALCcompBetweenany(bit *retval, ptr *val, int tpe, ptr *low, ptr *high)
{
	int (*cmp) (ptr, ptr) = BATatoms[tpe].atomCmp;
	ptr nilptr = ATOMnilptr(tpe);
	int val_nil = ((*cmp) (*val, nilptr) == 0);
	int low_nil = ((*cmp) (*low, nilptr) == 0);
	int high_nil = ((*cmp) (*high, nilptr) == 0);

	if (val_nil || (low_nil && high_nil)) {
		*retval = bit_nil;
	} else if (low_nil) {
		*retval = ((*cmp) (*val, *high) <= 0);
	} else if (high_nil) {
		*retval = ((*cmp) (*low, *val) <= 0);
	} else {
		*retval = ((*cmp) (*low, *val) <= 0 && (*cmp) (*val, *high) <= 0);
	}
	return MAL_SUCCEED;
}

@= c_isnil
mal_export str CALCisnil_@1(bit *retval, @1 *val);
str CALCisnil_@1(bit *retval, @1 *val) {
	*retval = (*val == @1_nil);
	return MAL_SUCCEED;
}
mal_export str CALCisnotnil_@1(bit *retval, @1 *val);
str CALCisnotnil_@1(bit *retval, @1 *val) {
	*retval = (*val != @1_nil);
	return MAL_SUCCEED;
}
mal_export str CALCnil2@1(@1 *retval, ptr val);
str CALCnil2@1(@1 *retval, ptr val){
	(void) val;/* fool compiler */
	memcpy(retval, ATOMnilptr(TYPE_@1), ATOMsize(TYPE_@1));
	return MAL_SUCCEED;
}
@c
@:c_isnil(bit)@
@:c_isnil(chr)@
@:c_isnil(sht)@
@:c_isnil(int)@
@:c_isnil(oid)@
@:c_isnil(flt)@
@:c_isnil(lng)@
@:c_isnil(dbl)@
@:c_isnil(ptr)@
@:c_isnil(bat)@

mal_export str CALCisnil_str(bit *retval, str *val);
str
CALCisnil_str(bit *retval, str *val)
{
	*retval = strcmp(*val, ATOMnilptr(TYPE_str)) == 0;
	return MAL_SUCCEED;
}

mal_export str CALCisnotnil_str(bit *retval, str *val);
str
CALCisnotnil_str(bit *retval, str *val)
{
	*retval = strcmp(*val, ATOMnilptr(TYPE_str));
	return MAL_SUCCEED;
}

mal_export str CALCstr2nil(str *retval, str *val);
str
CALCstr2nil(str *retval, str *val)
{
	(void) val;		/* fool compiler */
	*retval = GDKstrdup(ATOMnilptr(TYPE_str));
	return MAL_SUCCEED;
}

mal_export str CALCisnil_any(bit *retval, ptr *val, int tpe);
str
CALCisnil_any(bit *retval, ptr *val, int tpe)
{
	ptr nilval = ATOMnilptr(tpe);

	*retval = (ATOMcmp(tpe, nilval, *val) == 0);
	return MAL_SUCCEED;
}

mal_export str CALCisnil_void(bit *retval, oid *val);
str
CALCisnil_void(bit *retval, oid *val)
{
	*retval = (*val == oid_nil);
	return MAL_SUCCEED;
}

mal_export str CALCisnotnil_void(bit *retval, oid *val);
str
CALCisnotnil_void(bit *retval, oid *val)
{
	*retval = (*val != oid_nil);
	return MAL_SUCCEED;
}

@= c_between_op
mal_export str CALCcompBetween@1(bit *retval, @1 *v, @1 *low, @1 *high);
str CALCcompBetween@1(bit *retval, @1 *v, @1 *low, @1 *high){
	if (*v == @1_nil || (*low == @1_nil && *high == @1_nil)) {
		*retval = bit_nil;
	} else if (*low == @1_nil) {
		*retval = (*v <= *high);
	} else if (*high == @1_nil) {
		*retval = (*low <= *v);
	} else {
		*retval = (*low <= *v) && (*v <= *high);	
	}
	return MAL_SUCCEED;
}
@-
The @emph{c_calc_ops} implement the arithmetic operations on the given type.
The @emph{c_calc_ops} macro gets three arguments, two input types and a 
result type. 

@= c_calc_ops
@:calc_binop(ADD,+,@1,@2,@3)@
@:calc_binop(SUB,-,@1,@2,@3)@
@:calc_binop(MUL,*,@1,@2,@3)@
@:check_binop(DIV,/,@1,@2,@3)@
@

@= calc_unop
mal_export str CALCunary@3@1(@3 *res , @3 *a );
str CALCunary@3@1(@3 *res , @3 *a ) {
#ifdef DEBUG
	printf( "CALCunary@3@1\n");
#endif
   if (*a == @3_nil) {
       *res = @3_nil;
   } else {   
       *res = @2 (*a);
   }
   return(MAL_SUCCEED);
}
@

@= check_unop
mal_export str CALCunarycheck@3@1(@3 *res , @3 *a );
str CALCunarycheck@3@1(@3 *res , @3 *a ) {
#ifdef DEBUG
	printf( "CALCunary@3@1\n");
#endif
   if (*a == 0 || *a == @3_nil) {
	*res = @3_nil;
   } else {
   	*res = @2 (*a);
   }
   return(MAL_SUCCEED);
}
@

@= calc_binop
mal_export str CALCbinary@1@3@4(@5 *res, @3 *a, @4 *b );
str CALCbinary@1@3@4(@5 *res, @3 *a, @4 *b ) {
#ifdef DEBUG
	printf( "CALCbinary@1@3@4\n");
#endif
   if (*a == @3_nil || *b == @4_nil) {
	*res = @5_nil;
   } else {
   	*res = ((@5)(*a)) @2 ((@5)(*b));
   }
   return(MAL_SUCCEED);
}
@

@= check_binop
mal_export str CALCbinarycheck@1@3@4(@5 *res, @3 *a, @4 *b );
str CALCbinarycheck@1@3@4(@5 *res, @3 *a, @4 *b ) {
#ifdef DEBUG
	printf( "CALCbinarycheck@1@3@4\n");
#endif
   if (*a == @3_nil || *b == 0 || *b == @4_nil) {
	*res = @5_nil;
   } else {
   	*res = ((@5)(*a)) @2 ((@5)(*b));
   }
   return(MAL_SUCCEED);
}
@


@= c_bitwise_ops
@:calc_binop(OR,|,@1,@1,@1)@
@:calc_binop(AND,&,@1,@1,@1)@
@:calc_binop(XOR,^,@1,@1,@1)@
@:calc_unop(NOT,~,@1)@

@= c_shift_ops
@:calc_binop(LSH,<<,@1,int,@1)@
@:calc_binop(RSH,>>,@1,int,@1)@

@= calc_macrobinop
mal_export str CALCbinary@1@3(@3 *res , @3 *a, @3 *b );
str CALCbinary@1@3(@3 *res , @3 *a, @3 *b ) {
#ifdef DEBUG
	printf( "CALCbinary@1@3\n");
#endif
   if (*a == @3_nil || *b == @3_nil) {
	*res = @3_nil;
   } else {
   	*res = @2 (*a,*b);
   }
   return(MAL_SUCCEED);
}
@
Coercions do not check on information loss
@= mal_coercion_impl2
mal_export str CALC@22@1(@1 *res, @2 *a);
str CALC@22@1(@1 *res, @2 *a)
{
	char buf[1024];
	sprintf(buf,"%@3",*a);
	*res = (@1) GDKstrdup(buf);
	return MAL_SUCCEED;
}
@-
@= mal_coercion_impl
mal_export str CALC@22@1(@1 *res, @2 *a);
str CALC@22@1(@1 *res, @2 *a)
{
	*res= (@1) *a;
	return MAL_SUCCEED;
}
@-
@c
@:mal_coercion_impl(bit,bit)@
@:mal_coercion_impl(bit,oid)@
@:mal_coercion_impl(bit,chr)@
@:mal_coercion_impl(bit,sht)@
@:mal_coercion_impl(bit,int)@
@:mal_coercion_impl(bit,lng)@
@:mal_coercion_impl(bit,flt)@
@:mal_coercion_impl(bit,dbl)@

@:mal_coercion_impl(lng,oid)@
@:mal_coercion_impl(lng,chr)@
@:mal_coercion_impl(lng,bit)@
@:mal_coercion_impl(lng,sht)@
@:mal_coercion_impl(lng,int)@
@:mal_coercion_impl(lng,lng)@
@:mal_coercion_impl(lng,flt)@
@:mal_coercion_impl(lng,dbl)@

@:mal_coercion_impl(sht,oid)@
@:mal_coercion_impl(sht,bit)@
@:mal_coercion_impl(sht,chr)@
@:mal_coercion_impl(sht,sht)@
@:mal_coercion_impl(sht,int)@
@:mal_coercion_impl(sht,lng)@
@:mal_coercion_impl(sht,flt)@
@:mal_coercion_impl(sht,dbl)@

@:mal_coercion_impl(int,oid)@
@:mal_coercion_impl(int,bit)@
@:mal_coercion_impl(int,chr)@
@:mal_coercion_impl(int,sht)@
@:mal_coercion_impl(int,int)@
@:mal_coercion_impl(int,lng)@
@:mal_coercion_impl(int,flt)@
@:mal_coercion_impl(int,dbl)@

@:mal_coercion_impl(oid,bit)@
@:mal_coercion_impl(oid,chr)@
@:mal_coercion_impl(oid,oid)@
@:mal_coercion_impl(oid,lng)@
@:mal_coercion_impl(oid,sht)@
@:mal_coercion_impl(oid,int)@

@:mal_coercion_impl(flt,flt)@
@:mal_coercion_impl(flt,dbl)@
@:mal_coercion_impl(flt,sht)@
@:mal_coercion_impl(flt,chr)@
@:mal_coercion_impl(flt,int)@
@:mal_coercion_impl(flt,lng)@

@:mal_coercion_impl(dbl,dbl)@
@:mal_coercion_impl(dbl,flt)@
@:mal_coercion_impl(dbl,sht)@
@:mal_coercion_impl(dbl,int)@
@:mal_coercion_impl(dbl,chr)@
@:mal_coercion_impl(dbl,lng)@

@:mal_coercion_impl(chr,bit)@
@:mal_coercion_impl(chr,chr)@
@:mal_coercion_impl(chr,oid)@
@:mal_coercion_impl(chr,flt)@
@:mal_coercion_impl(chr,dbl)@
@:mal_coercion_impl(chr,sht)@
@:mal_coercion_impl(chr,int)@
@:mal_coercion_impl(chr,lng)@


mal_export str CALClng2ptr(ptr *res, lng *a);
str
CALClng2ptr(ptr *res, lng *a)
{
	(void) res;
	(void) a;		/* fool compiler */
	return MAL_SUCCEED;
}

mal_export str CALCptr2lng(lng *res, ptr *a);
str
CALCptr2lng(lng *res, ptr *a)
{
	(void) res;
	(void) a;		/* fool compiler */
	return MAL_SUCCEED;
}

@-
Old stuff, probably wrong
	@:mal_coercion_impl2(str,sht,d)@
	@:mal_coercion_impl2(str,int,d)@
	@:mal_coercion_impl2(str,lng,D)@
	@:mal_coercion_impl2(str,flt,f)@
	@:mal_coercion_impl2(str,dbl,f)@
@+ The Coercion implementation
The conversion routines are relatively easy to define.
@= convertImpl

mal_export str CALCstr2@1(@1 *ret, str *val);
str CALCstr2@1(@1 *ret, str *val){
	int l = sizeof(@1);
	(void) @1FromStr(*val, &l, &ret);
	return MAL_SUCCEED;
}
mal_export str CALC@12str(str *ret, @1 *val);
str CALC@12str(str *ret, @1 *val){
	int l=0;

	if(*ret) l=strlen(*ret);
	(void) @1ToStr(ret,&l,val);
	return MAL_SUCCEED;
}
str @1FromvoidImpl(@1 *ret, void *val){
	(void) val; /* fool compiler */
	memcpy(ret, ATOMnilptr(TYPE_@1), ATOMsize(TYPE_@1));
	return MAL_SUCCEED;
}
@-
Strings have to be dealt with differently, because
we recieve a pointer to the string directly.
To make it work properly, we need a call be reference
in those places where we leave a result behind.
@c
str
voidFromStrImpl(void *ret, str val)
{
	(void) val;		/* fool compiler */
	memcpy(ret, ATOMnilptr(TYPE_void), ATOMsize(TYPE_void));
	return MAL_SUCCEED;
}

mal_export str CALCnil2str(str *ret, void *val);
str
CALCnil2str(str *ret, void *val)
{
	(void) val;		/* fool compiler */
	*ret = GDKstrdup(str_nil);
	return MAL_SUCCEED;
}

mal_export str CALCstr2str(str *ret, str *val);
str
CALCstr2str(str *ret, str *val)
{
	*ret = GDKstrdup(*val);
	return MAL_SUCCEED;
}

mal_export str CALCstr2oid(oid *ret, str *val);
str
CALCstr2oid(oid *ret, str *val)
{
	int l = strlen(*val);

	(void) OIDfromStr(*val, &l, (ptr) ret);
	return MAL_SUCCEED;
}

mal_export str CALCoid2str(str *ret, oid *val);
str
CALCoid2str(str *ret, oid *val)
{
	int l = sizeof(oid);

	(void) OIDtoStr(ret, &l, val);
	return MAL_SUCCEED;
}

mal_export str CALCnil2void(oid *ret, ptr *val);
str
CALCnil2void(oid *ret, ptr *val)
{
	(void) val;		/* fool compiler */
	*ret = oid_nil;
	return MAL_SUCCEED;
}

mal_export str CALClng2void(oid *ret, lng *val);
str
CALClng2void(oid *ret, lng *val)
{
	*ret = (oid) *val;
	return MAL_SUCCEED;
}

mal_export str CALCsht2void(oid *ret, sht *val);
str
CALCsht2void(oid *ret, sht *val)
{
	*ret = *val;
	return MAL_SUCCEED;
}

mal_export str CALCint2void(oid *ret, int *val);
str
CALCint2void(oid *ret, int *val)
{
	*ret = *val;
	return MAL_SUCCEED;
}

mal_export str oidFromoidImpl(oid *ret, oid *val);
str
oidFromoidImpl(oid *ret, oid *val)
{
	*ret = *val;
	return MAL_SUCCEED;
}

mal_export str oidFromvoidImpl(oid *ret, void *val);
str
oidFromvoidImpl(oid *ret, void *val)
{
	(void) val;		/* fool compiler */
	memcpy(ret, ATOMnilptr(TYPE_oid), ATOMsize(TYPE_oid));
	return MAL_SUCCEED;
}

mal_export str CALCbat2batid(int *ret, int *bid);
str
CALCbat2batid(int *ret, int *bid)
{
	BAT *b;

	b = BATdescriptor(*bid);
	if (b == 0)
		throwMessage("calc.:bat", "Bat does not exist");
	*ret = b->batCacheid;
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

mal_export str CALCbatid2bat(int *bid, int *ret);
str
CALCbatid2bat(int *bid, int *ret)
{
	BAT *b;

	b = BATdescriptor(*ret);
	if (b == 0)
		throwMessage("calc.:bat", "Bat does not exist");
	*bid = b->batCacheid;
	BBPincref(*bid, TRUE);
	BBPunfix(*bid);
	return MAL_SUCCEED;
}

@:convertImpl(sht)@
@:convertImpl(int)@
@:convertImpl(lng)@
@:convertImpl(flt)@
@:convertImpl(dbl)@
@:convertImpl(bit)@
@:convertImpl(ptr)@
@:convertImpl(bat)@
@:convertImpl(chr)@

@-
@= setoidCode
mal_export str @1SetoidImpl(str *ret, @1 *v);
str @1SetoidImpl(str *ret, @1 *v){
	(void) ret; /* fool compiler */
	OIDbase((oid) *v);
	return MAL_SUCCEED;
}
@c
@:setoidCode(oid)@
@:setoidCode(lng)@
@:setoidCode(int)@

@-
Type conversion template. Only allowed then no information is lost.

@= coercionImpl
mal_export str @1From@2Impl(@1 *res, @2 *val);
str @1From@2Impl(@1 *res, @2 *val){
	*res = (@1) *val;
	return MAL_SUCCEED;
}
@c
@:coercionImpl(lng,oid)@
@:coercionImpl(lng,int)@
@:coercionImpl(lng,sht)@
@:coercionImpl(lng,bit)@
@:coercionImpl(int,sht)@
@:coercionImpl(int,bit)@
@:coercionImpl(dbl,flt)@
@:coercionImpl(oid,lng)@
@:coercionImpl(oid,int)@
@:coercionImpl(oid,sht)@

mal_export str shtFromlngImpl(sht *res, lng *val);
str
shtFromlngImpl(sht *res, lng *val)
{
	/* perform a range check !! */
	if (*val < 0 || *val > 255)
		return throwMessage("calc.coercion", "error lng->sht");
	*res = (sht) *val;
	return MAL_SUCCEED;
}

mal_export str shtFromintImpl(sht *res, int *val);
str
shtFromintImpl(sht *res, int *val)
{
	/* perform a range check !! */
	if (*val < 0 || *val > 255)
		return throwMessage("calc.coercion", "error int->sht");
	*res = *val;
	return MAL_SUCCEED;
}

@+ Value, Types and Variables
The routines below implement the OID utility functions.
@c
mal_export str CALCnewoidBase(oid *res);
str
CALCnewoidBase(oid *res)
{
	*res = OIDnew(1);
	return MAL_SUCCEED;
}

mal_export str CALCnewoidInc(oid *res, int *inc);
str
CALCnewoidInc(oid *res, int *inc)
{
	if (*inc <= 0)
		*res = OIDnew(1);
	else {
		*res = OIDnew(*inc);
	}
	return MAL_SUCCEED;
}

mal_export str CALCnewoidInclng(oid *res, lng *inc);
str
CALCnewoidInclng(oid *res, lng *inc)
{
	if (*inc <= 0)
		*res = OIDnew(1);
	else {
		*res = OIDnew((size_t) *inc);
	}
	return MAL_SUCCEED;
}

mal_export str CALCsetoidBase(oid *res);
str
CALCsetoidBase(oid *res)
{
	*res = OIDbase(1);
	return MAL_SUCCEED;
}

mal_export str CALCsetoidInc(oid *res, oid *inc);
str
CALCsetoidInc(oid *res, oid *inc)
{
	*res = OIDbase(*inc);
	return MAL_SUCCEED;
}

@}
