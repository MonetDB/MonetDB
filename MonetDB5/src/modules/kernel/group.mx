@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2007 CWI.
@' All Rights Reserved.

@f group
@a M.L. Kersten, P. Boncz, A.P. de Vries, N.J. Nes
@v 2.3
@+ The group module
This module contains the primitives to construct, derive, and
perform statistical operations on BATs representing groups.
The default scheme in Monet is to assume the head to represent
the group identifier and the tail an element in the group.

Groups play an important role in datamining, where they are used
to construct cross-tables. Such cross tables over a single
BAT are already supported by the histogram function.
This module provides extensions to support identification of groups in a
(multi-)dimensional space.

The module implementation has a long history. The first implementation
provided several alternatives to produce/derive the grouping.
A more complete (and complex) scheme was derived during its
extensive use in the context of the Data Distilleries  product.
The current implementation is partly a cleanup of this code-base,
but also enables provides better access to the intermediate
structures produced in the process, i.e. the histogram and
the sub-group mapping. They can be used for various optimization
schemes at the MAL level.

The prime limitation of the current implementation is that an
underlying database of @{oid->any@} BATs is assumed.
This enables representation of each group using an oid,
and the value representation of the group can be accordingly be
retrieved easily. An optimized implementation in which we use positional
integer id's (as embodied by Monet's void type) is also available.

This limitation on (v)oid-headers is marginal. The primitive GRPsplit
produces for any BAT two copies with both a (v)oid header.
@- Algorithms
There are several approaches to build a cross table. The one chosen here
is aimed at incremental construction, such that re-use of intermediates
becomes possible. Starting with the first dimension, a BAT is derived to
represent the various groups, called a @emph{GRP BAT} or cross-table BAT.

@- Cross Table (GRP)
A cross table is an <oid,oid> BAT where the first (head) denotes a tuple in
the cross table and the second (tail) marks all identical lists.
The tail-oids contain group identifiers; that is, @emph{this value is equal
@strong{iff} two tuples belong to the same group}. The group identifiers are
chosen from the domain of the tuple-identifiers. This simplifies
getting back to the original tuples, when talking about a group.
If the tuple-oid of 'John' is chosen as a group-id, you might view this
as saying that each member of the group is 'like John' with respect
to the grouping-criterion.

@- 
Successively the subgroups can be identified by modifying the GRP BAT or
to derive a new GRP BAT for the subgroups. After all groups have been
identified this way, a BAT histogram operation can be used to obtain
the counts of each data cube. Other aggregation operations using the MIL
set aggregate construct @{X@}(bat) 
can be used as well; note for instance that histogram == @{count@}(b.reverse()).

The Monet interface module specification is shown below.
Ideally we should defined stronger type constraints, e.g.
command group.new(attr:bat[@{void,oid@},:any_1]
@{
@mal
module group;

command new(b:bat[:any_1,:any_2], start:int, incr:int, grpsize:int)
			:bat[:any_1,:int] 
address GRPgroup0
comment "Produces a new BAT with identical head column, and in the tail 
		column groups of equally valued integers within each group. 
		Parameters: a start group -value, -number increment, -size.";

command new(attr:bat[:any_1,:any_2] )
	(histo:bat[:any_1,:int], grp:bat[:any_1,:void]) 
address GRPgroup;

command new(attr:bat[:any_1,:any_2] )
	(histo:bat[:any_1,:int], grp:bat[:any_1,:oid]) 
address GRPgroup;

command new(attr:bat[:any_1,:any_2], N:int, rng:int)
	(histo:bat[:any_1,:int],grp:bat[:any_1,:oid]) 
address GRPgroup_custom
comment "Cross tabulation group initialization like GRPgroup, but with 
		user provided #bits in hashmask and #distinct values in range.";

command derive(hist:bat[:any_1,:int], map:bat[:any_1,:oid], attr:bat[:any_1,:any_2])
	(histo:bat[:any_1,:int],grp:bat[:any_1,:oid]) 
address GRPderive
comment "Cross tabulation group extension step.  Returned head values are 
		identical as in 'ct'. Tail values are from the same domain and 
		indicate further refinement of the groups in 'ct', taking into 
		account also the tail-values in 'attr'.";
command derive(histo:bat[:void,:int], map:bat[:void,:oid], attr:bat[:oid,:any_2])
	(hist:bat[:oid,:int],grp:bat[:oid,:oid]) 
address GRPderive;

command refine(b:bat[:any_2,:any_3], a:bat[:any_2,:any_1]) :bat[:any_2,:oid] 
address GRPrefine
comment "refine the ordering of a tail-ordered BAT by sub-ordering on the 
		values of a second bat 'a' (where the heads of a and b match 1-1).
		The effect of this is similar to (hash-based) GRPderive, with the 
		distinction that the group ids respect the ordering of the group 
		values.";

command refine(b:bat[:oid,:any_3], a:bat[:void,:any_1]) :bat[:oid,:oid] 
address GRPrefine;
command refine(b:bat[:void,:any_3], a:bat[:oid,:any_1]) :bat[:oid,:oid] 
address GRPrefine;

command refine_reverse(b:bat[:any_2,:any_3], a:bat[:any_2,:any_1]) :bat[:any_2,:oid] 
address GRPrefine_rev
comment "refine the ordering of a tail-ordered BAT by sub-ordering on the 
		values of a second bat 'a' (where the heads of a and b match 1-1).
		The effect of this is similar to (hash-based) GRPderive, with the 
		distinction that the group ids respect the ordering of the group 
		values.";
@-
@+ Group Aggregate operations

This module also contains some efficient aggregate functions over
groups that compute their result in one scan.

For the groups we assume a bat structure where the head indicates the group
and the tail contains the group elements. This leads to the situation that
most value-based operators work on the tail, while counting groups
is focussed on the head.
@= grpSignature
command sum(b:bat[:any_2,:@1], e:bat[:any_2,:any_1]) :bat[:any_2,:@1] 
address GRPsum_@1_@1
comment "grouped tail sum";

command sum(b:bat[:any_2,:@1], size:int) :bat[:any_2,:@1] 
address GRPwindowsum_@1
comment "Tail sum of groups of a fixed size";

command sum(b:bat[:any_2,:@1], size:int, shift:int) :bat[:any_2,:@1] 
address GRPslidingsum_@1
comment "Tail sum of groups of a sliding window of fixed size";

command avg(b:bat[:any_2,:@1], e:bat[:any_2,:any_1]) :bat[:any_2,:@1] 
address GRPavg_@1
comment "grouped tail average";

@-
Not used yet
#command min(b:bat[:any_2,:@1], size:int) :bat[:any_2,:@1] 
#address GRPwindowmin@1
#comment "Tail minimum of groups of a fixed size";
#command max(b:bat[:any_2,:@1], size:int) :bat[:any_2,:@1] 
#address GRPwindowmax@1
#comment "Tail minimum of groups of a fixed size";
@mal
	@:grpSignature(bte)@
	@:grpSignature(sht)@
	@:grpSignature(int)@
	@:grpSignature(lng)@
	@:grpSignature(wrd)@
	@:grpSignature(flt)@
	@:grpSignature(dbl)@
	@:grpSignature(oid)@

command min(b:bat[:any_2,:any_1], e:bat[:any_2,:any_3]) :bat[:any_2,:any_1] 
address GRPmin
comment "Grouped tail minimum";
command max(b:bat[:any_2,:any_1], e:bat[:any_2,:any_3]) :bat[:any_2,:any_1] 
address GRPmax
comment "Grouped tail maximum";

command count(b:bat[:any_2,:any_1], e:bat[:any_2,:any_3], nonils:bit) :bat[:any_2,:int] 
address GRPaggr_count
comment "Grouped count";
command size(b:bat[:any_2,:bit], e:bat[:any_2,:any_1]) :bat[:any_2,:wrd] 
address GRPsize
comment "Grouped count of true values";

@-
We need a few routines to support MonetDB/XQ implementation.
They are focussed on edge BATs [:oid,:oid] where the tail is
assumed a sequence and the head denotes a group.
Finding the first and last element maps into finding
the min/max oid within a group.
@= xqMinMaxDef
command min(b:bat[:oid,:@1]):bat[:oid,:@1]
address GRPmin_oid_@1
comment "Select the minimum element of each group";

command max(b:bat[:oid,:@1]):bat[:oid,:@1]
address GRPmax_oid_@1
comment "Select the minimum element of each group";

@mal
 @:xqMinMaxDef(oid)@
 @:xqMinMaxDef(bte)@
 @:xqMinMaxDef(sht)@
 @:xqMinMaxDef(int)@
 @:xqMinMaxDef(lng)@
 @:xqMinMaxDef(wrd)@
 @:xqMinMaxDef(flt)@
 @:xqMinMaxDef(dbl)@

command prelude()
address GRPprelude;

group.prelude();
@+ Implementation Code
Inclusion of the xtables requires some preliminary definitions
and als renaming :group by something else, because Mx can;t handle
macros identical to file names.
@h
#ifndef _GROUP_H_
#define _GROUP_H_
#include "gdk.h"

extern int CTderive(BAT **B, BAT **H, BAT *ct_hist, BAT *ct_map, BAT *b);
extern int CTgroup(BAT **B, BAT **H, BAT *b);

#endif /* _GROUP_H_ */
@c
#include "mal_config.h"
#include "group.h"
#include "algebra.h"
static int TYPE_mapentry;


int
grp_new(BAT *b, BAT *h)
{
	if (h) {
		BATkey(h, TRUE);
		h->tsorted = 0;
		if ((h->hsorted = BAThordered(b)) & 1) {
			if (BATcount(h) == BATcount(b)) {
				ALIGNsetH(h, BATmirror(b));
			}
		} else if (BATorder(h) == NULL) {
			BBPreclaim(h);
			return GDK_FAIL;
		}
		BBPkeepref(h->batCacheid);
	} else {
		assert(h);
	}
	BBPkeepref(b->batCacheid);
	return GDK_SUCCEED;
}


@+ Core Grouping Algorithms
We use hash-grouping all the way. This implementation employs
a simple sequential scan through the operands, adding group
values to a hash-table. This hash-table gives access to the group
identifiers, which are always OIDs.

This strategy is also followed on binary groupings; here
we construct a special integer consisting of the XORed hashnumber
of both columns. In such a way, we can build a hash table on
map_entries (instead of simple atomic values -- the unary case).

In the unary group case, we optimized processing on 1-byte
and 2-byte values by using direct mapping in an array instead of
hashing.
@c
#define HASH_bte(p) ((hash_t) (*(unsigned char*) (p)))
#define HASH_sht(p) ((hash_t) (*(unsigned short*) (p)))
#define HASH_int(p) ((hash_t) *(unsigned int*) (p))
#define HASH_lng(p) ((hash_t)(((unsigned int*)(p))[0]^((unsigned int*)(p))[1]))
#define HASH_any(p) ((*hashfcn)(p))

#define match_sync(bi,p,r) r++
#define match_hash(bi,p,r) BUNfndOID(r,bi,p); if (r == BUN_NONE) continue;

#define declare_atom int any = b->ttype; hash_t (*hashfcn)(ptr) = BATatoms[any].atomHash;
#define declare_simple	/* any and hash would otherwise give unused variable warning */

#define htype_sync(b) BAThdense(b)?TYPE_void:TYPE_oid
#define htype_hash(b) TYPE_oid

#define ttype_simple(b,t) t
#define ttype_atom(b,t) b->ttype

#define STANDARD_MASK ((hash_t) 1023)

/*
   Note:
	following macros take advantage of clustered property;
	if b is clustered, then we can stop early traversing collision lists.

	BTW, simply stopping possibly breaks chain construction, so the resulting
	map is not directly reuseable as a hash table; the current Monet cannot
	however handle multiple accellerators, so this ain't a real problem for now :)
 */

#define declare_unclustered	/* avoid warning */
#define declare_clustered   int samecluster = TRUE;

#define chain_unclustered   for (zz = hash[c]; zz != HASH_MAX; zz = e->link)
#define chain_clustered     for (zz = hash[c]; (zz != HASH_MAX) && (samecluster); zz = e->link)

#define tst_grp_unclustered(eq,p,t)    (eq(p, tcur, t))
#define tst_grp_clustered(eq,p,t)      (samecluster = eq(p, tcur, t))

#define tst_derive_unclustered(eq,p,t) (e->hcur == hcur && eq(p, tcur, t))
#define tst_derive_clustered(eq,p,t)   ((samecluster = e->hcur == hcur) && eq(p, tcur, t))

typedef struct {
	oid hcur;		/* old group id */
	hash_t link;		/* hash link */
	oid gid;		/* new group id */
	int cnt;		/* histogram count */
} mapentry_t;

typedef struct {
	BAT *map;		/* [mapentry,value] elements */
	hash_t *hash, mask;	/* hash buckets and mask */
	Heap hp;		/* storage for hash buckets */
} map_T;

@:map_init_def(STANDARD,STANDARD_MASK,4096)@
@:map_init_def(CUSTOM,custom_MASK,custom_rng)@

@= map_init_def
#define map_init_@1(map,hash,mask,entry,mapsize)			\
	if (m) {							\
		map = m->map; hash = m->hash; mask = m->mask;		\
	} else {							\
		hash_t _yy;						\
		map = BATnew(TYPE_mapentry, tailtype(b,TRUE), @3);	\
		hash = (hash_t*) GDKmalloc((int)(sizeof(hash_t)*((mask=@2)+1))); \
		for (_yy=0; _yy<=@2; _yy++) {				\
			hash[_yy] = HASH_MAX;				\
		}							\
	}								\
	entry.cnt = 1;							\
	mapsize = BUNlast(map);
@c
#if 0
static void
map_free(map_T m)
{
	BBPreclaim(m.map);
	HEAPfree(&m.hp);
}
#endif

#ifndef offsetof
#define offsetof(type, member)	((size_t) &((type *) 0)->member)
#endif

static BAT *
map2histo(BAT *map)
{
	BUN p, q;
	BAT *bn;
	int sz;

	if (map == NULL || map->htype != TYPE_mapentry || isVIEW(map) || map->batSharecnt > 1 || BATgetaccess(map) != BAT_WRITE) {
		if (map)
			BBPreclaim(map);
		return NULL;
	}
	sz = BATcount(map);
	bn = BATnew(TYPE_oid,TYPE_int,sz);
	BATloop(map, p, q) {
		bunfastins(bn, 
			&((mapentry_t*)Hloc(map, p))->gid, 
			&((mapentry_t*)Hloc(map, p))->cnt);
	}
	BATkey(BATmirror(bn),FALSE);
	bn->tsorted = 0;
bunins_failed:
	if (map)
		BBPreclaim(map);
	return bn;
}
@}
@-
The group macro is split along three dimensions:
@multitable @columnfractions 0.2 0.8
@item [type:] 
@tab
Type specific implementation for selecting the right
hash function and data size etc.;
@item [clustered:] 
@tab
The @{clustered and unclustered@} select the
appropriate algorithm, i.e., with or without taking advantage of 
an order of values in the parent groups;
@item [physical properties:] 
@tab
Values @{standard and custom@}, 
choosing between a fixed predefined and a custom hashmask. Custom
allows the user to determine the size of the hashmask (and indirectly
the estimated size of the result). The hashmask is $2^n - 1$ where $n$
is given by the user, or 1023 otherwise, and the derived result
size is $4 \cdot 2^n$.
@end multitable

Further research should point out whether fitting a simple statistical
model (possibly a simple mixture model) can help choose these parameters
automatically; the current idea is that the user (which could be a
domain-specific extension of the higher-level language) knows the
properties of the data, especially for IR in which the standard grouping
settings differ significantly from the original datamining application.
@{
@c
#define group_params_STANDARD	/* fixed */
#define group_params_CUSTOM   hash_t custom_MASK, int custom_rng,

@= groupAll
BAT *
CTgroup_@1_@4_@5(group_params_@5 BAT *b, BAT *bn, map_T *m)
{
	BATiter bi = bat_iterator(b), mapi;
	oid *hdst = (oid*) Hloc(bn, BUNfirst(bn)), *dst = (oid*) Tloc(bn, BUNfirst(bn));
	hash_t *hash, mask;
	size_t zz, mapsize;
	mapentry_t entry, *e;
	BUN p, q, r;
	BAT *map = NULL;
	declare_@3

	map_init_@5(map,hash,mask,entry,mapsize);
	if (map == NULL)
		return NULL;

	mapi = bat_iterator(map);
	/* core hash grouping algorithm */
	BATloop(b, p, q) {
		declare_@4
		ptr tcur = BUN@2(bi,p);

		/* hash-lookup of 'tcur' in map */
		hash_t c = HASH_@1(tcur);
		c = mix_int(c) & mask;
		chain_@4 {
			r = zz;
			e = (mapentry_t*) BUNhloc(mapi,r);
			if (tst_grp_@4(@3_EQ, BUN@2(mapi,r), @1)) {
				if (m == NULL)
					e->cnt++;
				goto found;
			}
		}

		/* not found-> insert new element in map (and hash) */
		if (m) {
			zz = mapsize;
		} else {
			entry.gid = *(oid*) BUNhead(bi,p);
		}
		entry.link = hash[c];
		hash[c] = mapsize++;
		bunfastins(map, &entry, tcur);
		e = &entry;

		/* TODO fix head by a column copy */
found:		/* ultra-fast 'insert' of [oid,gid] into ct */
		if (bn->htype)
			*hdst++ = *(oid*) BUNhead(bi,p);
		*dst++ = m?zz:e->gid;
	}
	BATsetcount(bn, BATcount(b));
	bn->tsorted = 0;
	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
	ALIGNsetH(bn,b);
	if (hash && !m)
		GDKfree(hash);
	return m ? NULL : map2histo(map);
bunins_failed:
	BBPreclaim(bn);
	if (hash && !m)
		GDKfree(hash);
	return NULL;
}
@c
static int
tailtype(BAT *b, int str_trick)
{
	int tpe = ATOMstorage(b->ttype);	/* standard type remappings */

	/* more daring remappings possible under simple equality */
	switch (tpe) {
	case TYPE_chr:
		return TYPE_bte;
	case TYPE_flt:
		return TYPE_int;
	case TYPE_dbl:
		return TYPE_lng;
	case TYPE_str:
		if (str_trick && GDK_ELIMDOUBLES((b->theap)))
			return TYPE_var;	/* string offsets are identifying integers */
	}
	return tpe;
}

/* Generate both 'normal' CTgroup and clustered CTgroups */
@= wrappedgroupinner
@:groupAll(bte,tloc,simple,@1,@2)@
@:groupAll(sht,tloc,simple,@1,@2)@
@:groupAll(int,tloc,simple,@1,@2)@
@:groupAll(lng,tloc,simple,@1,@2)@
@:groupAll(any,tail,atom,@1,@2)@

/* Generate both 'normal' CTgroup and parameterized CTgroups */
@= wrappedgroupouter
@:wrappedgroupinner(unclustered,@1)@
@:wrappedgroupinner(clustered,@1)@

@c
@:wrappedgroupouter(STANDARD)@
@:wrappedgroupouter(CUSTOM)@

@= returnvalue
	@1 =
@c
#define declare_mask_STANDARD	/* fixed */
#define declare_mask_CUSTOM	hash_t mask = (1 << *N) - 1;

int
CTgroup(BAT **retval,		/* put pointer to BAT[oid,oid] record here. */
	BAT **hbat,		/* put histogram BAT here */
	BAT *b			/* pointer to BAT[oid,oid] record. */
)
{
	@:CTgroupbody(STANDARD)@
}

int
CTgroup_custom(BAT **retval,	/* put pointer to BAT[oid,oid] record here. */
   BAT **hbat,	/* put histogram BAT here */
   BAT *b,		/* pointer to BAT[oid,oid] record. */
   int *N,		/* number of bits for hashmask */
   int *rng		/* expected number of entries in map */
)
{
	@:CTgroupbody(CUSTOM)@
}

static int 
bits(size_t i)
{
	int sh;

	assert(i>0);
        for (sh = 0; i != 0; sh++) {
                i >>= 1;
        }
	return sh;
}


@= CTgroupbody
	BAT *histo = NULL, *bn = NULL;
	declare_mask_@1

	/* b->tkey, simply return mirror(0), and hist = project(reverse(bn),1) */
	if (b->tkey) {
		int one = 1;
		BAT *v = VIEWcombine(b);

		bn = v;
		if (b->batRestricted == BAT_WRITE) {
			bn = BATcopy(v, v->htype, v->ttype, FALSE);
			BBPreclaim(v);
		}
		histo = BATconst(BATmirror(bn), TYPE_int, &one);
	} else {
		bn = BATnew(b->htype, TYPE_oid, BATcount(b));
		if (bn == NULL) {
			return GDK_FAIL;
		}
		/* Poor man's clustered test: sorted & !keyed => clustered  */
		if ( ((b->tsorted)&1) && !(b->tkey) ) {
			@:choosegroup@1(tailtype(b,TRUE),bn,NULL,clustered,histo)@
		} else {
			@:choosegroup@1(tailtype(b,TRUE),bn,NULL,unclustered,histo)@
		}
		if (histo == NULL) {
			BBPreclaim(bn);
			return GDK_FAIL;
		}
		bn->tsorted = 0;
	}
	if (BATcount(histo) == BATcount(bn)) {
		BATkey(BATmirror(bn),TRUE);
	}
	ALIGNsetH(bn, b);
	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
	*retval = bn;
	*hbat = histo;
	return grp_new(bn, histo);

@= choosegroupSTANDARD
	/* Choose appropriate @4 CTgroup implementation */
	switch(@1) {
	case TYPE_bte:
		@?@5:returnvalue(@5)@ CTgroup_bte_@4_STANDARD(b,@2,@3);
		break;
	case TYPE_sht:
		@?@5:returnvalue(@5)@ CTgroup_sht_@4_STANDARD(b,@2,@3);
		break;
	case TYPE_int:
		@?@5:returnvalue(@5)@ CTgroup_int_@4_STANDARD(b,@2,@3);
		break;
	case TYPE_lng:
		@?@5:returnvalue(@5)@ CTgroup_lng_@4_STANDARD(b,@2,@3);
		break;
	default:
		@?@5:returnvalue(@5)@ CTgroup_any_@4_STANDARD(b,@2,@3);
		break;
	}

@= choosegroupCUSTOM
	/* Choose appropriate @4 CTgroup implementation */
	switch(@1) {
	case TYPE_bte:
		@?@5:returnvalue(@5)@ CTgroup_bte_@4_CUSTOM(mask,*rng,b,@2,@3);
		break;
	case TYPE_sht:
		@?@5:returnvalue(@5)@ CTgroup_sht_@4_CUSTOM(mask,*rng,b,@2,@3);
		break;
	case TYPE_int:
		@?@5:returnvalue(@5)@ CTgroup_int_@4_CUSTOM(mask,*rng,b,@2,@3);
		break;
	case TYPE_lng:
		@?@5:returnvalue(@5)@ CTgroup_lng_@4_CUSTOM(mask,*rng,b,@2,@3);
		break;
	default:
		@?@5:returnvalue(@5)@ CTgroup_any_@4_CUSTOM(mask,*rng,b,@2,@3);
		break;
	}

@c
#define SAMPLE_SIZE 	1024
hash_t
derive_mask( BAT *ct_map, BAT *ct_histo, BAT *b)
{
	size_t cnt = BATcount(b);
	int n = bits(BATcount(ct_histo)), *N = &n;

	if (BATcount(b) > (SAMPLE_SIZE<<3)) {
		BAT *s = BATsample(b, SAMPLE_SIZE);
		BUN p, q;
		BAT *histo, *map;
		hash_t r = 0;

		if (CTderive(&map, &histo, ct_histo, ct_map, s) != GDK_SUCCEED){
			BBPunfix(s->batCacheid);
			return GDK_FAIL;
		}
		BBPunfix(s->batCacheid);
		BBPfix(histo->batCacheid);
		BBPfix(map->batCacheid);
		BATloop(histo, p, q) {
			/* + 4 for a average chain list of 4 */
			r += ((dbl)cnt/SAMPLE_SIZE)/(*(int*)Tloc(histo,p)+4);
		}
		BBPunfix(histo->batCacheid);
		BBPunfix(map->batCacheid);
		if (bits(r) > *N)
			return (1<<bits(r))-1;
	}
	/* default to */
	return (1<<*N) - 1;
}

@= derive
static BAT *
CTderive_@1_@2_@5(BAT* ct_map, BAT *ct_histo, BAT *b, BAT *bn, map_T *m)
{
	BATiter bi = bat_iterator(b), mapi, ct_mapi = bat_iterator(ct_map);
	oid *hdst = (oid*) Hloc(bn, BUNfirst(bn)), *dst = (oid*) Tloc(bn, BUNfirst(bn));
	size_t zz, mapsize;
	hash_t *hash;
	BUN p, q, r, cp = BUNfirst(ct_map) - 1;
	mapentry_t entry, *e;
	BAT *map;
	declare_@4
	hash_t mask = derive_mask(ct_map, ct_histo, b); 
	int custom_rng = BATcount(ct_histo); /* expected number of groups */
	hash_t custom_MASK = mask;

	map_init_CUSTOM(map,hash,mask,entry,mapsize);
	if (map == NULL)
		return NULL;

	mapi = bat_iterator(map);
	/* core hash grouping algorithm */
	BATloop(b, p, q) {
		ptr tcur = BUN@3(bi,p);
		hash_t c;
		oid hcur;
		declare_@5

		/* find corresponding value in 'ct_map' */
		match_@1(ct_mapi, BUNhead(bi,p), cp);
		hcur = *(oid*) BUNtloc(ct_mapi,cp);

		/* hash-lookup of [hcur,tcur] in map */
		c = (((hash_t) hcur) ^ HASH_@2(tcur));
		c = mix_int(c) & mask;
		chain_@5 {
			r = zz;
			e = (mapentry_t*) Hloc(map,r);
			if (tst_derive_@5(@4_EQ, BUN@3(mapi,r), @2)) {
				if (m == NULL)
					e->cnt++;
				goto found;
			}
		}
		/* not found-> insert new element in map (and hash) */
		if (m) {
			zz = mapsize;
		} else {
			entry.gid = *(oid*) BUNhead(bi,p);
		}
		entry.hcur = hcur;
		entry.link = hash[c];
		hash[c] = mapsize++;
		bunfastins(map, &entry, tcur);
		e = &entry;

		/* TODO fix head by a column copy */
found:		/* ultra-fast 'insert' of [oid,gid] into result ct */
		if (bn->htype)
			*hdst++ = *(oid*) BUNhead(bi,p);
		*dst++ = m?zz:e->gid;
	}
	BATsetcount(bn, (dst-(oid*)bn->T->heap.base)); 
	if (hash && !m)
		GDKfree(hash);
	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
	return m?NULL:map2histo(map);
bunins_failed:
	if (hash && !m)
		GDKfree(hash);
	BBPreclaim(bn);
	return NULL;
}

@c

/* Generate both 'normal' CTderive and clustered CTderive */
@= wrappedderive
@:derive(sync,bte,tloc,simple,@1)@
@:derive(sync,sht,tloc,simple,@1)@
@:derive(sync,int,tloc,simple,@1)@
@:derive(sync,lng,tloc,simple,@1)@
@:derive(sync,any,tail,atom,@1)@
@:derive(hash,bte,tloc,simple,@1)@
@:derive(hash,sht,tloc,simple,@1)@
@:derive(hash,int,tloc,simple,@1)@
@:derive(hash,lng,tloc,simple,@1)@
@:derive(hash,any,tail,atom,@1)@
@c
@:wrappedderive(unclustered)@
@:wrappedderive(clustered)@

@= choosederive
	/* Choose appropriate (@1 && @2) CTderive implementation */
	switch(tt) {
	case TYPE_bte:
		histo = CTderive_@1_bte_@2(ct_map,ct_histo,b,bn,m);
		break;
	case TYPE_sht:
		histo = CTderive_@1_sht_@2(ct_map,ct_histo,b,bn,m);
		break;
	case TYPE_int:
		histo = CTderive_@1_int_@2(ct_map,ct_histo,b,bn,m);
		break;
	case TYPE_lng:
		histo = CTderive_@1_lng_@2(ct_map,ct_histo,b,bn,m);
		break;
	default:
		histo = CTderive_@1_any_@2(ct_map,ct_histo,b,bn,m);
		break;
	}
@c
int
derive(BAT **H, BAT **M, BAT *ct_histo, BAT *ct_map, BAT *b, int tt, map_T *m)
{
	BAT *histo = NULL, *bn = NULL;
	int synced = ALIGNsynced(ct_map, b);

	/* create the result bat 'bn' */
	int ht = (synced && BAThdense(b)) ? TYPE_void : TYPE_oid;

	if (!ct_map->tkey) { /* cannot derive more groups */
		bn = BATnew(ht, TYPE_oid, BATcount(b));
		if (bn == NULL) {
			return GDK_FAIL;
		}

		/* CTderive with correct lookup method (hash,synced) and type */
		if (synced) {
			if (((ct_map->tsorted) & 1)) {
				@:choosederive(sync,clustered)@
			} else {
				@:choosederive(sync,unclustered)@
			}
		} else {
			if (((ct_map->tsorted) & 1)) {
				@:choosederive(hash,clustered)@
			} else {
				@:choosederive(hash,unclustered)@
			}
		}
		if (histo == NULL) {
			assert(histo);
			BBPunfix(bn->batCacheid);
		}

		/* postprocess the result bat 'bn' */
		bn->tsorted = 0;
		if (BATcount(bn) == BATcount(b)) {
			ALIGNsetH(bn, b);
		} else {
			bn->hsorted = BAThordered(b);
			if (b->hkey)
				BATkey(bn, TRUE);
		}

	} else {
		bn = ct_map;
		histo = ct_histo;
		if (!synced) {
			bn = BATsemijoin(ct_map, b);
			histo = BATsemijoin(ct_histo, BATmirror(bn));
		} else {
			BBPfix(ct_map->batCacheid);
			BBPfix(ct_histo->batCacheid);
		}
	}
	*M = bn;
	*H = histo;
	return grp_new(bn, histo);
}

int
CTderive(BAT **M, BAT **H, BAT *ct_histo, BAT *ct_map, BAT *b)
{
	int ret;

	ret = derive(H, M, ct_histo, ct_map, b, tailtype(b, TRUE), NULL);
	return ret;
}

@-
The routine CThistosum takes an grouping and a histogram and produces
a new histogram by summing the old values within the same group.
@c
int
CThistosum(
	BAT**	retval,	/* put pointer to BAT[oid,int] record here. */
	BAT*	b,	/* pointer to BAT[oid,oid] record. */
	BAT*	c	/* pointer to BAT[oid,int] record. */
)
{
	BATiter bi = bat_iterator(b), resi;
	BAT *res = BATnew(TYPE_oid, TYPE_int, BATcount(b));
	BUN p, q, qb;
	int i, *z;
	oid *ot, *oh;

	(void) c;
	if (res == NULL) {
		return GDK_FAIL;
	}
	resi = bat_iterator(res);
	BATloop(b, p, q) {
		oh = (oid *) BUNhloc(bi, p);
		i = *(int *) BUNtloc(bi, p);

		BUNfndOID(qb, bi, oh);
		if (qb == BUN_NONE) {
			GDKerror("CThistosum: Matching count entry not found\n");
			continue;
		}
		ot = (oid *) BUNtloc(bi, qb);

		BUNfndOID(qb, resi, ot);
		if (qb == BUN_NONE) {
			BUNins(res, ot, &i, FALSE);
		} else {
			z = (int *) BUNtloc(resi, qb);
			*z += i;
		}
	}
	res->hsorted = res->tsorted = 0;
	if (!(res->batDirty&2)) res = BATsetaccess(res, BAT_READ);
	*retval = res;
	return GDK_SUCCEED;
}

int
CTsubhisto(BAT **ret, BAT *sel, BAT *grp, BAT *dom)
{
	BATiter seli = bat_iterator(sel);
	bit *filter = (bit *) BUNtloc(seli, BUNfirst(sel));
	size_t size = BATcount(dom);
	hash_t yy, mask, *hash = NULL;
	BUN r, p, q;
	BAT *bn = BATnew(TYPE_oid, TYPE_int, size);
	BAT *lnk = BATnew(TYPE_oid, TYPE_void, size);
	int *hcnt = (int*)Tloc(bn, BUNfirst(bn));
	oid *hcur = (oid*)Hloc(bn, BUNfirst(bn));
	oid *link = (oid*)Hloc(lnk, BUNfirst(lnk));
	oid *hdom = (oid*)Hloc(dom, 0);

	if (bn == NULL)
		return GDK_FAIL;

	/* we know the domain; go for perfect hashing */
	for (mask = 1; mask < size; mask <<= 1)
		;
	if (mask < 256)
		mask = 256;
	hash = (hash_t *) GDKmalloc(sizeof(hash_t) * mask);
	if (hash == NULL) {
		BBPreclaim(bn);
		return GDK_FAIL;
	}
	for (yy = 0; yy < mask; yy++) {
		hash[yy] = HASH_MAX;
	}
	mask--;

	/* insert all values in the hash table, and in bn with count zero */
	r = 0;
	yy = 0;
	BATloop(dom, p, q) {
		oid v = hdom[p];
		hash_t c = v & mask;

		hcur[r] = v;
		link[r] = hash[c];
		hcnt[r] = 0;
		r++;
		hash[c] = yy;
		yy++;
	}
	BATsetcount(bn, r);
	bn->tsorted = 0;

	/* add the counts for this selection using the hash table */
	BATloop(grp, p, q) {
		if (*filter == TRUE) {
			oid v = *(oid *) Tloc(grp, p);
			hash_t c = v & mask;

			for (yy = hash[c]; yy != HASH_MAX; yy = link[r]) {
				r = yy;
				if (hcur[r] == v) {
					hcnt[r]++;
					break;
				}
			}
		}
		filter++;

	}
	GDKfree(hash);
	BBPreclaim(lnk);
	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
	*ret = bn;
	return GDK_SUCCEED;
}

@+ Support for Order-by
@c
#define DEFAULT_SIZE 10000

static INLINE int 
sort_flush(var_t *off, oid *o, size_t size, int tpe, char *base, oid *hdst, oid *tdst, oid *idp, int reverse)
{
	int (*cmp) (ptr, ptr) = BATatoms[tpe].atomCmp;
	oid id = *idp + 1;
	ptr cur, val;
	size_t i;

	/* StM: we don't need to sort voids, do we??? */
	if (tpe != TYPE_void) {
		/* qsort works fine for small amount of tuples; with few duplicates */
		if (reverse) {
			GDKqsort_rev(off, o, base, size, sizeof(var_t), sizeof(oid), tpe);
		} else {
			GDKqsort(off, o, base, size, sizeof(var_t), sizeof(oid), tpe);
		}
	}

	cur = base + off[0];
	for (i=0; i < size; i++) {
		val = base + off[i];
		if ((*cmp) (cur, val)) {
			cur = val;
			id++;
		}
		*hdst++ = o[i];
		*tdst++ = id;
	}
	*idp = id;

	return i;
}

static int
refine(BAT **res, BAT *b, BAT *a, int rv)
{
	str rev = rv ? "_rev" : "";
	BAT *bn = NULL;

	if (BATcount(b) != BATcount(a)) {
		GDKerror("CTrefine%s: both BATs must have the same cardinality and their heads must form a 1-1 match.\n", rev);
		return GDK_FAIL;
	}
@(
	/* checking only the key property is too strict,
	 * as it might not be set although it does hold;
	 * exhaustively checking keyness is too expensive;
	 * hence, we just don't check, and keep our fingers crossed...
	 */
	if (!(b->hkey && a->hkey)) {
		if (a->hkey) {
			GDKerror("CTrefine%s: head of first BAT is not unique (key);", rev);
		} else if (b->hkey) {
			GDKerror("CTrefine%s: head of second BAT is not unique (key);", rev);
		} else {
			GDKerror("CTrefine%s: heads of both BATs are not unique (key);", rev);
		}
		GDKerror("CTrefine%s: heads of both BATs must be unique (key) to form a 1-1 match.\n", rev);
		return GDK_FAIL;
	}
@)
	if (b->tkey) {		/* if key, no further refinements can take place */
		bn = BATmark(b, 0);
	} else {
		int (*cmp) (ptr, ptr) = BATatoms[b->ttype].atomCmp, cnt = 0;
		BUN p, q, r, last = BUNfirst(b);
		char *base = a->theap ? NULL : a->T->heap.base, *this = NULL;
		size_t cur, end, off;
		var_t *offp;
		oid *ids;
		bit a_void = (a->ttype == TYPE_void);
		int xx, tpe = a_void ? TYPE_oid : a->ttype;
		size_t size = DEFAULT_SIZE;
		oid *hdst, *tdst, o, *op = &o, id = 0;
		BATiter ai = bat_iterator(a), bi = bat_iterator(b);

		/* create tmp BAT that holds one cluster; estimate required size using sampling */
		if (BATcount(b) > DEFAULT_SIZE) {
			BAT *histo = NULL, *sample = BATsample(b, DEFAULT_SIZE);

			if (sample) {
				histo = BAThistogram(sample);
				if (histo) {
					BATmax(histo, &xx);
					if (xx > 1)
						size = MAX(size, (size_t) (xx * (((float) BATcount(b)) / DEFAULT_SIZE)));
					BBPreclaim(histo);
				}
				BBPreclaim(sample);
			}
			if (histo == NULL)
				return GDK_FAIL;
		}
		/* create a temporary BAT of the estimated size holding pointers to the a tail atoms */
		cur = 0;
		end = size;
		offp = (var_t*) GDKmalloc(size * sizeof(var_t));
		ids = (oid*) GDKmalloc(size * sizeof(oid));
		if (offp == NULL || ids == NULL) {
			if (offp) GDKfree(offp);
			if (ids) GDKfree(ids);
			return GDK_FAIL;
		}
		if (a_void) {
			base = this = (char*) GDKmalloc(size * sizeof(oid));
			if (base == NULL) {
				GDKfree(offp);
				GDKfree(ids);
				return GDK_FAIL;
			}
		}

		/* create result BAT */
		bn = BATnew(TYPE_oid, TYPE_oid, BATcount(b));
		if (bn == NULL) {
			GDKfree(offp);
			GDKfree(ids);
			if (a_void)
				GDKfree(base);
			return GDK_FAIL;
		}
		bn->hsorted = bn->tsorted = FALSE;
		hdst = (oid *) Hloc(bn,BUNfirst(bn));
		tdst = (oid *) Tloc(bn,BUNfirst(bn));

		if (a_void) {
			@:refine_loop(@:refine_void_1@,@:refine_void_2@,GDKfree(base);,this = base;)@
		} else {
			@:refine_loop()@
		}
@= refine_void_2
	off = (size_t) (this - base);
	base = (char*) GDKrealloc(base, size * sizeof(oid));
	this = base + off;
@= refine_void_1
	*(oid*)this = a->tseqbase+r;
	r = this - base;
@= refine_loop
		/* merge-scan tail of b, finding chunks with equal values; then sort each chunk on a */
		BATloop(b, p, q) {
			if ((*cmp) (BUNtail(bi, last), BUNtail(bi, p))) {
				cnt = sort_flush(offp, ids, cur, tpe, base ? base : a->theap->base, hdst, tdst, &id, rv);
				hdst += cnt;
				tdst += cnt;

				last = p;
				cur = 0;
				@4
			}
			o = *(oid *) BUNhead(bi, p);
			BUNfndOID(r, ai, op);
			if (r == BUN_NONE) {
				GDKerror("CTrefine%s: value "SZFMT"@0 not found in head of second BAT;\n"
					 "CTrefine%s: heads of both BATs do not form a 1-1 match.\n", rev, (size_t) o, rev);
				BBPreclaim(bn);
				GDKfree(offp);
				GDKfree(ids);
				@3
				return GDK_FAIL;
			}
			if (cur >= end) {
				offp = (var_t*) GDKrealloc(offp, (size *= 2) * sizeof(var_t));
				ids = (oid*) GDKrealloc(ids, size * sizeof(oid));
				end = size;
				@2
			}
			@1
			offp[cur] = (base) ? r<<a->T->shift : ((var_t*)a->T->heap.base)[r];
			ids[cur] = o;
			cur++;
			this += sizeof(oid);
		}
@c
		cnt = sort_flush(offp, ids, cur, tpe, base ? base : a->theap->base, hdst, tdst, &id, rv);
		hdst += cnt;
		tdst += cnt;

		GDKfree(offp);
		GDKfree(ids);
		if (a_void)
			GDKfree(base);
		BATsetcount(bn, (((char*) hdst) - bn->H->heap.base)/Tsize(bn));
		bn->tsorted = GDK_SORTED;
	}
	*res = bn;
	return GDK_SUCCEED;
}

int
CTrefine(BAT **res, BAT *b, BAT *a)
{
	return refine(res, b, a, FALSE);
}

int
CTrefine_rev(BAT **res, BAT *b, BAT *a)
{
	return refine(res, b, a, TRUE);
}

@- Wrapping
Wrapping the version 4 xtables code base
@c
#include "mal.h"
#include "mal_exception.h"
#include "mal_atom.h"

#ifdef WIN32
#ifndef LIBGROUP
#define group_export extern __declspec(dllimport)
#else
#define group_export extern __declspec(dllexport)
#endif
#else
#define group_export extern
#endif

@-
Recall that we only support void- and oid- typed heads.
This is captured as a runtime check in the implementation.
@= chkHeader
	if(@1->htype != TYPE_oid && @1->htype != TYPE_void)
		throw(MAL, "group.@2", "(v)oid head required\n");
@c
group_export str GRPprelude(void);
str
GRPprelude(void)
{
	/* printf("#init group\n"); */
	TYPE_mapentry = malAtomFixed(sizeof(mapentry_t), sizeof(oid), "mapentry");
	return MAL_SUCCEED;
}

group_export str GRPgroup0(int *ret, int *bid, int *start, int *incr, int *grpsize);
str
GRPgroup0(int *ret, int *bid, int *start, int *incr, int *grpsize)
{
	BAT *result, *b;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "group.group", "Cannot access descriptor");
	}

	result = BATgroup(b, *start, *incr, *grpsize);
	if (result == 0)
		throw(MAL, "GRPgroup0", "Failed to group");
	*ret = result->batCacheid;
	BBPkeepref(*ret);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}

group_export str GRPgroup_custom(int *rethisto, int *retbid, int *bid, int *N, int *rng);
group_export str GRPgroup(int *rethisto, int *retbid, int *bid);
str
GRPgroup(int *rethisto, int *retbid, int *bid)
{
	BAT *histo = 0, *b, *bn = 0;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "group.group", "Cannot access descriptor");
	}
	if (BATcount(b) > 1024*1024 &&
	    (b->ttype == TYPE_int || b->ttype == TYPE_lng)) { 
		int N = BATcount(b), one = 1;
		assert(N);
		if (b->ttype == TYPE_int) {
			int h, l;
			BATmax(b,&h);
			BATmin(b,&l);
			if (h != int_nil && l != int_nil && h-l < N && h-l > 0) 
				N = h-l;
		} else if (b->ttype == TYPE_lng) {
			lng h, l;
			BATmax(b,&h);
			BATmin(b,&l);
			if (h != lng_nil && l != lng_nil && (int)(h-l) < N && (int)(h-l) > 0) 
				N = (int)(h-l);
		}
		N = bits(N);
		assert(N);
		BBPunfix(b->batCacheid);
		return GRPgroup_custom(rethisto, retbid, bid, &N, &one);
	}
	@:chkHeader(b,GRPgroup)@
	CTgroup(&bn, &histo, b);
	*rethisto = histo ? histo->batCacheid : 0;
	*retbid = bn->batCacheid;
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}

str
GRPgroup_custom(int *rethisto, int *retbid, int *bid, int *N, int *rng)
{
	BAT *histo = 0, *b, *bn = 0;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "group.group", "Cannot access descriptor");
	}
	@:chkHeader(b,GRPgroup)@
	CTgroup_custom(&bn, &histo, b, N, rng);
	*rethisto = histo ? histo->batCacheid : 0;
	*retbid = bn->batCacheid;
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}

group_export str GRPderive(int *hid, int *mid, int *ct_histoid, int *ct_mapid, int *bid);
str
GRPderive(int *hid, int *mid, int *ct_histoid, int *ct_mapid, int *bid)
{
	BAT *ct_map, *ct_histo, *b;
	BAT *bn = NULL, *histo = NULL;

	if ((ct_map = BATdescriptor(*ct_mapid)) == NULL) {
		throw(MAL, "group.derive", "Cannot access descriptor");
	}
	@:chkHeader(ct_map,GRPderive)@
	if ((ct_histo = BATdescriptor(*ct_histoid)) == NULL) {
		BBPreleaseref(ct_map->batCacheid);
		throw(MAL, "group.derive", "Cannot access descriptor");
	}
	@:chkHeader(ct_histo,GRPderive)@
	if ((b = BATdescriptor(*bid)) == NULL) {
		BBPreleaseref(ct_map->batCacheid);
		BBPreleaseref(ct_histo->batCacheid);
		throw(MAL, "group.derive", "Cannot access descriptor");
	}
	@:chkHeader(b,GRPderive)@
	if( derive(&histo, &bn, ct_histo, ct_map, b, tailtype(b, TRUE), NULL) == GDK_FAIL){
		BBPreleaseref(b->batCacheid);
		BBPreleaseref(ct_map->batCacheid);
		BBPreleaseref(ct_histo->batCacheid);
		throw(MAL, "group.derive","Could not derive group");
	}

	*mid = bn->batCacheid;
	*hid = histo->batCacheid;
	BBPreleaseref(b->batCacheid);
	BBPreleaseref(ct_map->batCacheid);
	BBPreleaseref(ct_histo->batCacheid);
	return MAL_SUCCEED;
}

group_export str GRPsubhisto(int *retid, int *selid, int *grpid, int *domid);
str
GRPsubhisto(int *retid, int *selid, int *grpid, int *domid)
{
	BAT *sel, *grp, *dom;
	BAT *bn;

	if ((sel = BATdescriptor(*selid)) == NULL) {
		throw(MAL, "group.subhisto", "Cannot access descriptor");
	}
	if ((grp = BATdescriptor(*grpid)) == NULL) {
		BBPreleaseref(sel->batCacheid);
		throw(MAL, "group.subhisto", "Cannot access descriptor");
	}
	@:chkHeader(grp,GRPsubhisto)@
	if ((dom = BATdescriptor(*domid)) == NULL) {
		throw(MAL, "group.subhisto", "Cannot access descriptor");
	}

	if ((dom = BATdescriptor(*domid)) == NULL) {
		BBPreleaseref(sel->batCacheid);
		BBPreleaseref(grp->batCacheid);
		throw(MAL, "group.subhisto", "Cannot access descriptor");
	}
	CTsubhisto(&bn, sel, grp, dom);
	*retid = bn->batCacheid;
	BBPkeepref(*retid);
	BBPreleaseref(sel->batCacheid);
	BBPreleaseref(grp->batCacheid);
	BBPreleaseref(dom->batCacheid);
	return MAL_SUCCEED;
}

group_export str GRPrefine(int *retid, int *bid, int *aid);
str
GRPrefine(int *retid, int *bid, int *aid)
{
	BAT *b, *a;
	BAT *bn;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "group.refine", "Cannot access descriptor");
	}
	@:chkHeader(b,GRPrefine)@
	if ((a = BATdescriptor(*aid)) == NULL) {
		BBPreleaseref(b->batCacheid);
		throw(MAL, "group.refine", "Cannot access descriptor");
	}
	@:chkHeader(a,GRPrefine)@

	CTrefine(&bn, b, a);
	*retid = bn->batCacheid;
	BBPkeepref(*retid);
	BBPreleaseref(b->batCacheid);
	BBPreleaseref(a->batCacheid);
	return MAL_SUCCEED;
}

group_export str GRPrefine_rev(int *retid, int *bid, int *aid);
str
GRPrefine_rev(int *retid, int *bid, int *aid)
{
	BAT *b, *a;
	BAT *bn;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "group.refine", "Cannot access descriptor");
	}
	@:chkHeader(b,GRPrefine_rev)@
	if ((a = BATdescriptor(*aid)) == NULL) {
		BBPreleaseref(b->batCacheid);
		throw(MAL, "group.refine", "Cannot access descriptor");
	}
	@:chkHeader(a,GRPrefine_rev)@

	CTrefine_rev(&bn, b, a);
	BBPreleaseref(b->batCacheid);
	BBPreleaseref(a->batCacheid);
	if (!bn)
		throw(MAL, "group.refine", "Failed");
	BBPkeepref(*retid = bn->batCacheid);
	return MAL_SUCCEED;
}

@-

These implementations need just one scan and a simple hash-maintained data
structure to compute a group of common aggregates.

With group OIDs spanning a range of less SMALL_AGGR_MAX (the actual number
of groups might be even less, in case there are "holes" in the group OID
range), we use a simple array as temporary sum/cnt table on order to benefit
from positional lookups; with size of sum <= 8 bytes and size of cnt == 4
bytes, we stay below 16 KBytes, i.e., within (almost) any L1 cache

@c
#define SMALL_AGGR_MAX 1024

@-
@= large_aggr_sum
	if (BATprepareHash(bn)) {
		BBPreclaim(bn);
		return GDK_FAIL;
	}
	BATloop(b, p, q) {
		oid *h = (oid*) BUNhead(bi,p);
		@1 *t = (@1*) BUN@2(bi,p);

		BUNfndOID(r, bni, h);
		if (r != BUN_NONE) {
			@3 *dst = (@3*) BUN@2(bni, r);
			if (*dst != @3_nil) {
				if (*t == @1_nil) {
					*dst = @3_nil;
				} else {
					*dst += *t;
				}
			}
		}
	}
@-
@= small_aggr_sum
	sums = (@3*) GDKmalloc(range*sizeof(@3));
	for (i = 0; i < range; i++) 
		sums[i] = zero;
	BATloop(b, p, q) {
		oid h = (*(oid*) BUNhead(bi,p)) - min;
		@1 *t = (@1*) BUN@2(bi,p);

		if (h < range) {
			@3 *dst = sums + h;
			if (*dst != @3_nil) {
				if (*t == @1_nil) {
					*dst = @3_nil;
				} else {
					*dst += *t;
				}
			}
		}
	}
	BATloop(bn, p, q) {
		oid h = (*(oid*) BUNhead(bni,p)) - min;
		*(@3*)BUN@2(bni, p) = sums[h];
	}
	GDKfree(sums);
@= large_aggr_prod
	if (BATprepareHash(bn)) {
		BBPreclaim(bn);
		return GDK_FAIL;
	}
	BATloop(b, p, q) {
		oid *h = (oid*) BUNhead(bi,p);
		@1 *t = (@1*) BUN@2(bi,p);

		BUNfndOID(r, bni, h);
		if (r != BUN_NONE) {
			@3 *dst = (@3*) BUN@2(bni, r);
			if (*dst != @3_nil) {
				if (*t == @1_nil) {
					*dst = @3_nil;
				} else {
					*dst *= *t;
				}
			}
		}
	}
@c
@= small_aggr_prod
	prods = (@3*) GDKmalloc(range*sizeof(@3));
	for (i = 0; i < range; i++)
		prods[i] = one;
	BATloop(b, p, q) {
		oid h = (*(oid*) BUNhead(bi,p)) - min;
		@1 *t = (@1*) BUN@2(bi,p);

		if (h < range) {
			@3 *dst = prods + h;
			if (*dst != @3_nil) {
				if (*t == @1_nil) {
					*dst = @3_nil;
				} else {
					*dst *= *t;
				}
			}
		}
	}
	BATloop(bn, p, q) {
		oid h = (*(oid*) BUNhead(bni,p)) - min;
		*(@3*)BUN@2(bni, p) = prods[h];
	}
        GDKfree(prods);
@= large_aggr_avg
	cnt  = (size_t*) GDKmalloc(BATcount(e)*sizeof(size_t));
	memset(cnt, 0, BATcount(e)*sizeof(size_t));
	if (BATprepareHash(bn)) {
		GDKfree(cnt);
		BBPreclaim(bn);
		return GDK_FAIL;
	}
	BATloop(b, p, q) {
		oid *h = (oid*) BUNhead(bi,p);
		@1 *t = (@1*) BUN@2(bi,p);

		BUNfndOID(r,bni,h);
		if (r != BUN_NONE) {
			dbl *dst = (dbl*) BUN@2(bni, r);
			if (*dst != dbl_nil) {
				if (*t == @1_nil) {
					*dst = dbl_nil;
				} else {
					*dst += *t;
				}
				cnt[r-off]++;
			}
		}
	}
	/* postprocess by dividing sums by counts */
	BATloop(bn, p, q) {
		dbl *dst = (dbl*) BUN@2(bni, p);
		if (cnt[yy] == 0) {
			*dst = dbl_nil;
		} else if (*dst != dbl_nil) {
			*dst = (dbl) (*dst / cnt[yy]);
		} yy++;
	}
	GDKfree(cnt);
@c
@= small_aggr_avg
	sums = (dbl*) GDKmalloc(range*sizeof(dbl));
	cnt  = (size_t*) GDKmalloc(range*sizeof(size_t));
	for (i = 0; i < range; i++)
		sums[i] = zero;
	memset(cnt, 0, range*sizeof(size_t));
	BATloop(b, p, q) {
		oid h = (*(oid*) BUNhead(bi,p)) - min;
		@1 *t = (@1*) BUN@2(bi,p);

		if (h < range) {
			dbl *dst = sums + h;
			if (*dst != dbl_nil) {
				if (*t == @1_nil) {
					*dst = dbl_nil;
				} else {
					*dst += *t;
				}
				cnt[h]++;
			}
		}
	}
	/* postprocess by dividing sums by counts */
	BATloop(bn, p, q) {
		oid h = (*(oid*) BUNhead(bni,p)) - min;
		dbl *dst = (dbl*) BUN@2(bni, p);
		if (cnt[h] == 0 || sums[h] == dbl_nil) {
			*dst = dbl_nil;
		} else {
			*dst = (dbl) (sums[h]/cnt[h]);
		}
	}
        GDKfree(sums);
	GDKfree(cnt);

@= arithsumprod
group_export str GRPsum_@1_@3(int *retval, int *bid, int  *eid, bit *ignore_nils);
str GRPsum_@1_@3(int *retval, int *bid, int  *eid, bit *ignore_nils)
{
	BAT *b = NULL, *e = NULL;
	BAT *bn = BATnew(e->htype, BATttype(b), BATcount(e));
	BATiter ei, bi, bni;
	@3 zero = (@3) 0, *sums;
	BUN p, q, r;
	oid i, range, min, max;

	if (bn == NULL)
		throw(MAL, "group.sum", "Cannot create descriptor");

	(void) ignore_nils; /* fool compiler */
	if( (b= BATdescriptor(*bid)) == NULL ){
		throw(MAL, "group.sum", "Cannot access descriptor");
	}

	@:chkHeader(b,GRPsum_@1_@3)@
	if( (e= BATdescriptor(*eid)) == NULL ){
		BBPreleaseref(b->batCacheid);
		throw(MAL, "group.sum", "Cannot access descriptor");
	}
	@:chkHeader(e,GRPsum_@1_@3)@
	/* init: set all sums to zero */
	bn->tsorted = bn->hsorted = 0;
	ALIGNsetH(bn, e);
	ei = bat_iterator(e);
	bi = bat_iterator(b);
	bni = bat_iterator(bn);

	if (BAThordered(e)&1) {
		min = *(oid*)BUNhead(ei, BUNfirst(e));
		BATloop(e, p, q) {
			if (BUNfastins(bn, BUNhead(ei,p), &zero) == NULL) {
				BBPreclaim(bn);
				return GDK_FAIL;
			}
		}
		max = *(oid*)BUNhead(ei, BUNlast(e)-1);
	} else {
		min = max = *(oid*)BUNhead(ei, BUNfirst(e));
		BATloop(e, p, q) {
			if (BUNfastins(bn, BUNhead(ei,p), &zero) == NULL) {
				BBPreclaim(bn);
				return GDK_FAIL;
			}
			i = *(oid*)BUNhead(ei, p);
			if (i < min)
				min = i;
			else if (i > max)
				max = i;
		}
	}
	range = max - min + 1;

	/* scan b, and add values to sums in-place */
	if (range > SMALL_AGGR_MAX) {
		ALGODEBUG THRprintf(GDKout, "#CMDaggr_sum_@1_@3: range(=" SZFMT ") > SMALL_AGGR_MAX(=%d)  => large_aggr_sum\n",(size_t) range,SMALL_AGGR_MAX);
		@:large_aggr_sum(@1,@2,@3)@
	} else {
		ALGODEBUG THRprintf(GDKout, "#CMDaggr_sum_@1_@3: range(=" SZFMT ") <= SMALL_AGGR_MAX(=%d)  => small_aggr_sum\n",(size_t) range,SMALL_AGGR_MAX);
		@:small_aggr_sum(@1,@2,@3)@
	}
	BBPkeepref(*retval = bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	BBPreleaseref(e->batCacheid);
	return MAL_SUCCEED;
}

group_export str GRPprod_@1_@3(int *retval, int *bid, int  *eid, bit *ignore_nils);
str GRPprod_@1_@3(int *retval, int *bid, int  *eid, bit *ignore_nils)
{
	BAT *bn, *b, *e;
	BATiter ei, bi, bni;
	@3 one = (@3) 1, *prods;
	BUN p, q, r;
	oid i, range, min, max;

	(void) ignore_nils; /* fool compiler */
	if( (b= BATdescriptor(*bid)) == NULL ){
		throw(MAL, "group.prod", "Cannot access descriptor");
	}

	@:chkHeader(b,GRPprod_@1_@3)@
	if( (e= BATdescriptor(*eid)) == NULL ){
		BBPreleaseref(b->batCacheid);
		throw(MAL, "group.prod", "Cannot access descriptor");
	}
 	bn = BATnew(e->htype, TYPE_@3, BATcount(e));
	if (bn == NULL)
		throw(MAL, "group.prod", "Cannot create descriptor");

	@:chkHeader(e,GRPprod_@1_@3)@
	/* init: set all prods to one */
	bn->tsorted = bn->hsorted = 0;
	ALIGNsetH(bn, e);
	ei = bat_iterator(e);
	bi = bat_iterator(b);
	bni = bat_iterator(bn);

	if (BAThordered(e)&1) {
		min = *(oid*)BUNhead(ei, BUNfirst(e));
		BATloop(e, p, q) {
			if (BUNfastins(bn, BUNhead(ei,p), &one) == NULL) {
				BBPreclaim(bn);
				return GDK_FAIL;
			}
		}
		max = *(oid*)BUNhead(ei, BUNlast(e)-1);
	} else {
		min = max = *(oid*)BUNhead(ei, BUNfirst(e));
		BATloop(e, p, q) {
			if (BUNfastins(bn, BUNhead(ei,p), &one) == NULL) {
				BBPreclaim(bn);
				return GDK_FAIL;
			}
			i = *(oid*)BUNhead(ei, p);
			if (i < min)
				min = i;
			else if (i > max)
				max = i;
		}
	}
	range = max - min + 1;

	/* scan b, and mul values to prods in-place */
	if (range > SMALL_AGGR_MAX) {
		ALGODEBUG THRprintf(GDKout, "#CMDaggr_prod_@1_@3: range(=" SZFMT ") > SMALL_AGGR_MAX(=%d)  => large_aggr_prod\n",(size_t) range,SMALL_AGGR_MAX);
		@:large_aggr_prod(@1,@2,@3)@
	} else {
		ALGODEBUG THRprintf(GDKout, "#CMDaggr_prod_@1_@3: range(=" SZFMT ") <= SMALL_AGGR_MAX(=%d)  => small_aggr_prod\n",(size_t) range,SMALL_AGGR_MAX);
		@:small_aggr_prod(@1,@2,@3)@
	}
	BBPkeepref(*retval = bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	BBPreleaseref(e->batCacheid);
	return MAL_SUCCEED;
}
@c
@:arithsumprod(bte,tloc,bte)@
@:arithsumprod(bte,tloc,sht)@
@:arithsumprod(bte,tloc,int)@
@:arithsumprod(bte,tloc,wrd)@
@:arithsumprod(bte,tloc,lng)@
@:arithsumprod(sht,tloc,sht)@
@:arithsumprod(sht,tloc,int)@
@:arithsumprod(sht,tloc,wrd)@
@:arithsumprod(sht,tloc,lng)@
@:arithsumprod(int,tloc,int)@
@:arithsumprod(int,tloc,wrd)@
@:arithsumprod(int,tloc,lng)@
@:arithsumprod(wrd,tloc,wrd)@
@:arithsumprod(wrd,tloc,lng)@
@:arithsumprod(lng,tloc,lng)@
@:arithsumprod(oid,tloc,oid)@
@:arithsumprod(flt,tloc,flt)@
@:arithsumprod(flt,tloc,dbl)@
@:arithsumprod(dbl,tloc,dbl)@

@= arithavg
group_export str GRPavg_@1(int *ret, int *bid, int *eid);
str GRPavg_@1(int *ret, int *bid, int *eid)
{
	BAT *b = NULL, *e = NULL;
	BAT *bn = BATnew(e->htype, BATttype(b), BATcount(e));
	BATiter ei, bi, bni;
	size_t yy = 0, off;
	size_t *cnt;
	oid i, range, min, max;
	dbl zero = (dbl) 0, *sums;
	BUN p, q, r;

	if (bn == NULL)
		throw(MAL, "group.avg", "Cannot create descriptor");

	if ((b = BATdescriptor(*bid)) == NULL ){
		throw(MAL, "group.avg", "Cannot access descriptor");
	}
	@:chkHeader(b,GRPavg_@1)@
	if( (e= BATdescriptor(*eid)) == NULL ){
		BBPreleaseref(b->batCacheid);
		throw(MAL, "group.@1", "Cannot access descriptor");
	}
	@:chkHeader(e,GRPavg_@1)@
	off = BUNfirst(bn);
	/* init sums and counts to zero */
	bn->tsorted = bn->hsorted = 0;
	ALIGNsetH(bn, e);
	ei = bat_iterator(e);
	bi = bat_iterator(b);
	bni = bat_iterator(bn);

	if (BAThordered(e)&1) {
		min = *(oid*)BUNhead(ei, BUNfirst(e));
		BATloop(e, p, q) {
			if (BUNfastins(bn, BUNhead(ei,p), &zero) == NULL) {
				BBPreclaim(bn);
				return GDK_FAIL;
			}
		}
		max = *(oid*)BUNhead(ei, BUNlast(e)-1);
	} else {
		min = max = *(oid*)BUNhead(ei, BUNfirst(e));
		BATloop(e, p, q) {
			if (BUNfastins(bn, BUNhead(ei,p), &zero) == NULL) {
				BBPreclaim(bn);
				return GDK_FAIL;
			}
			i = *(oid*)BUNhead(ei, p);
			if (i < min)
				min = i;
			else if (i > max)
				max = i;
		}
	}
	range = max - min + 1;

	/* scan b, adding sums, and incrementing counts */
	if (range > SMALL_AGGR_MAX) {
		ALGODEBUG THRprintf(GDKout, "#CMDaggr_avg_@1: range(=" SZFMT ") > SMALL_AGGR_MAX(=%d)  =>  large_aggr_avg\n",(size_t) range,SMALL_AGGR_MAX);
		@:large_aggr_avg(@1,@2)@
	} else {
		ALGODEBUG THRprintf(GDKout, "#CMDaggr_avg_@1: range(=" SZFMT ") <= SMALL_AGGR_MAX(=%d)  =>  small_aggr_avg\n",(size_t) range,SMALL_AGGR_MAX);
		@:small_aggr_avg(@1,@2)@
	}
	BBPkeepref(*ret= bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	BBPreleaseref(e->batCacheid);
	return MAL_SUCCEED;
}
@c
@:arithavg(bte,tloc)@
@:arithavg(sht,tloc)@
@:arithavg(int,tloc)@
@:arithavg(wrd,tloc)@
@:arithavg(oid,tloc)@
@:arithavg(lng,tloc)@
@:arithavg(flt,tloc)@
@:arithavg(dbl,tloc)@

@= arithvar
int
CMDaggr_variance_@1(BAT **ret, BAT *b, BAT *e)
{
	size_t nElements = BATcount(e);
	BAT *bn = *ret = BATnew(e->htype, BATttype(b), nElements);
	BATiter ei = bat_iterator(e), bi = bat_iterator(b);
	size_t off, idx = 0;
	int *cnt ;
	dbl *sum ;
	dbl *sumsquares ;
	@1 zero = (@1) 0;
	BUN p, q, r;
	oid previousOid = oid_nil;

	if (bn == NULL)
		return GDK_FAIL;
	off = BUNfirst(e);
	cnt = (int*) GDKmalloc(nElements*sizeof(int));
	if (cnt == NULL) {
		BBPreclaim(bn);
		return GDK_FAIL;
	}
	sum = (dbl*) GDKmalloc(nElements*sizeof(dbl));
	if (sum == NULL) {
		BBPreclaim(bn);
		GDKfree(cnt);
		return GDK_FAIL;
	}
	sumsquares = (dbl*) GDKmalloc(nElements*sizeof(dbl));
	if (sumsquares == NULL) {
		BBPreclaim(bn);
		GDKfree(cnt);
		GDKfree(sum);
		return GDK_FAIL;
	}

	/* scan b, adding sums, and incrementing counts */
	if (BATprepareHash(bn)) {
		BBPreclaim(bn);
		GDKfree(cnt);
		GDKfree(sum);
		GDKfree(sumsquares);
		return GDK_FAIL;
	}

	/* init sums and counts to zero */
	memset(cnt, 0, nElements*sizeof(int));
	memset(sum, 0, nElements*sizeof(dbl));
	memset(sumsquares, 0, nElements*sizeof(dbl));

	BATloop(b, p, q) {
		oid *h = (oid*) BUNhead(bi,p);
		if (*h != previousOid) {
			previousOid = *h;
			BUNfndOID(r,ei,h);
			if (r == BUN_NONE)
				continue;
			idx = r-off;
		}

		if (cnt[idx] != int_nil) {
			@1 v = *(@1*) BUNtloc(bi,p);
			if (v == @1_nil) {
				cnt[idx] = int_nil;
			} else {
				cnt[idx]++;
				sum[idx] += v;
				sumsquares[idx] += (v * v);
			}
		}
	}

	/* postprocess by dividing sumsquares and sum by counts and
	   substracting square of the averages from the average sum of
	   squares */
	idx = 0;
	BATloop(e, p, q) {
		if (cnt[idx] == int_nil) {
			@1 _nil = @1_nil;
			if (BUNfastins(bn, BUNhead(ei,p), (ptr)&_nil) == NULL) {
				*ret = NULL;
				break;
			}
		} else if (cnt[idx] <= 1) {
			if (BUNfastins(bn, BUNhead(ei,p), &zero) == NULL) {
				*ret = NULL;
				break;
			}
		} else {
			dbl avg = (sum[idx] / cnt[idx]);
			@1 variance = (@1) (sumsquares[idx] / cnt[idx] - (avg * avg));
			if (BUNfastins(bn, BUNhead(ei,p), &variance) == NULL) {
				*ret = NULL;
				break;
			}
		}
		idx++;
	}
	GDKfree(cnt);
	GDKfree(sum);
	if (!*ret) {
		BBPreclaim(bn);
		return GDK_FAIL;
	}
	bn->hsorted = bn->tsorted = 0;
	ALIGNsetH(bn, e);
	return GDK_SUCCEED;
}
@c
@:arithvar(bte)@
@:arithvar(sht)@
@:arithvar(int)@
@:arithvar(wrd)@
@:arithvar(lng)@
@:arithvar(flt)@
@:arithvar(dbl)@

@= extreme
static int 
CMDaggr_@1_@3(BAT **ret, BAT *b, BAT *e)
{
	BAT *bn = *ret = BATnew(e->htype, BATttype(b), BATcount(e));
	BATiter ei = bat_iterator(e), bi = bat_iterator(b);
	int (*cmp)(ptr,ptr);
	ptr nil;
	size_t yy = 0, off;
	@3 *extremes;
	BUN p, q, r;

	if (bn == NULL)
		return GDK_FAIL;
	cmp = BATatoms[bn->ttype].atomCmp;
	nil = ATOMnilptr(bn->ttype);
	off = BUNfirst(e);
	extremes = (@3*) GDKmalloc(BATcount(e)*sizeof(@3));
	if (extremes == NULL) {
		BBPreclaim(bn);
		return GDK_FAIL;
	}

	/* init: set all extremes to the zero pointer */
	@:extreme_init_@3(@4)@

	/* scan b and replace totals by the extreme value (just pointers to vals in b) */
	if (BATprepareHash(e)) {
		BBPreclaim(bn);
		GDKfree(extremes);
		return GDK_FAIL;
	}
	BATloop(b, p, q) {
		oid *h = (oid*) BUNhead(bi,p);
		ptr t =  BUNtail(bi,p);

		BUNfndOID(r,ei,h);
		if (r != BUN_NONE) {
			@:extreme_body_@3(@2)@
		}
	}
	/* insert the extreme values into the result */
	yy = 0;
	BATloop(e, p, q) {
		@3 val = extremes[yy++];
		if (BUNfastins(bn, BUNhead(ei,p), @:extreme_tail_@3@) == NULL) {
			ret = NULL;
			break;
		}
	}
	GDKfree(extremes);
	if (!ret) {
		BBPreclaim(bn);
		return GDK_FAIL;
	}
	bn->tsorted = bn->hsorted = 0;
	ALIGNsetH(bn, e);
	return GDK_SUCCEED;
}
@= extreme_init_oid
	for (yy = 0 ; yy < BATcount(e) ; yy++) extremes[yy] = GDK_oid_@1;
@= extreme_init_ptr
	memset(extremes, 0, BATcount(e)*sizeof(ptr));
@= extreme_body_oid
			oid *val = extremes + r - off;
			if (*val != *(oid*)nil) {
				if ((*cmp)(t,nil) == 0) {
					*val = *(oid*)nil;
				} else if ((*cmp)(t,val) @1 0) {
					*val = *(oid*)t;
				}
			}
@= extreme_body_ptr
			ptr *val = extremes + r - off;
			if (*val != nil) {
				if ((*cmp)(t,nil) == 0) {
					*val = nil;
				} else if (*val == NULL || (*cmp)(t,*val) @1 0) {
					*val = t;
				}
			}
@= extreme_tail_oid
	&val
@= extreme_tail_ptr
	val?val:nil
@= extreme_
@:extreme(@1,@2,oid,@3)@
@:extreme(@1,@2,ptr,@3)@
str
GRP@1(int *retval, int *bid, int *eid)
{
	BAT *b = NULL, *e = NULL, *bn;
	int res = 0;

	if ((b = BATdescriptor(*bid)) == NULL ){
		throw(MAL, "group.@1", "Cannot access descriptor");
	}
	@:chkHeader(b,GRP@1)@
	if ((e = BATdescriptor(*eid)) == NULL ){
		BBPreleaseref(b->batCacheid);
		throw(MAL, "group.@1", "Cannot access descriptor");
	}
	@:chkHeader(e,GRP@1)@

	if (b->ttype == TYPE_void) {
		res = CMDaggr_@1_oid(&bn, b, e);
	} else {
		res = CMDaggr_@1_ptr(&bn, b, e);
	}
	BBPreleaseref(b->batCacheid);
	BBPreleaseref(e->batCacheid);
	if (!res)
		throw(MAL, "group.@1", "Cannot access descriptor");
	BBPkeepref(*retval = bn->batCacheid);
	return MAL_SUCCEED;
}
@c
@:extreme_(min,<,max)@
@:extreme_(max,>,min)@

@-
The simple extreme operations exploit the grouping and order
properties to speed up the process.
@= xqMinMaxImpl
group_export str GRP@1_oid_@2(int *retval, int *bid);
str GRP@1_oid_@2(int *retval, int *bid)
{
	BATiter bi, bni;
	BAT *b;
	BAT *bn;
	oid grp= oid_nil;
	@2 *val= 0;
	BUN p, q;

	if( (b= BATdescriptor(*bid)) == NULL ){
		throw(MAL, "group.@1", "Cannot access descriptor");
	}
	/* use expensive operation when the BAT is not ordered on the head */
	if( !(b->hsorted&1) ){
		/* determine groups first */
		BBPreleaseref(b->batCacheid);
		throw(MAL, "group","not yet implemented");
	}

	@:chkHeader(b,GRP@1_oid_@2)@

	bn = BATnew(BAThtype(b), BATttype(b), BATcount(b));

	bi = bat_iterator(b);
	bni = bat_iterator(bn);
	BATloop(b, p, q) {
		oid h = *(oid*) BUNhead(bi,p);
		@2 t =  *(@2*) BUNtail(bi,p);

		if( h != grp){
			/* switch to a new group */
			BUNins(bn, &h, &t, FALSE);
			grp= h;
			val = (@2*) BUNtail(bni,BUNlast(bn)-1);
		} else if( t @3 *val )
			*val = t;
	}
	bn->hsorted = b->hsorted ;
	bn->tsorted = b->tsorted ;
	BBPkeepref(*retval= bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}
@c
 @:xqMinMaxImpl(min,oid,<)@
 @:xqMinMaxImpl(min,bte,<)@
 @:xqMinMaxImpl(min,sht,<)@
 @:xqMinMaxImpl(min,int,<)@
 @:xqMinMaxImpl(min,lng,<)@
 @:xqMinMaxImpl(min,wrd,<)@
 @:xqMinMaxImpl(min,flt,<)@
 @:xqMinMaxImpl(min,dbl,<)@
 @:xqMinMaxImpl(max,oid,>)@
 @:xqMinMaxImpl(max,bte,>)@
 @:xqMinMaxImpl(max,sht,>)@
 @:xqMinMaxImpl(max,int,>)@
 @:xqMinMaxImpl(max,lng,>)@
 @:xqMinMaxImpl(max,wrd,>)@
 @:xqMinMaxImpl(max,flt,>)@
 @:xqMinMaxImpl(max,dbl,>)@

@c
@= large_aggr_count
	if (BATprepareHash(bn)) {
		BBPreclaim(bn);
		return GDK_FAIL;
	}
	BATloop(b, p, q) {
		oid *h = (oid*) BUNhead(bi,p);

		BUNfndOID(r, bni, h);
		if (r != BUN_NONE) {
			ptr t = BUNtail(bi,p);
			(void) t; /* silence compiler about unused variable */
			@1 {
				int *dst = (int*) BUNtloc(bni, r);
				(*dst)++;
			}
		}
	}
@c
@= small_aggr_count
	cnt  = (int*) GDKmalloc(range*sizeof(int));
	memset(cnt, 0, range*sizeof(int));
	BATloop(b, p, q) {
		oid h = (*(oid*) BUNhead(bi,p)) - min;

		if (h < range) {
			ptr t = BUNtail(bi,p);
			(void) t; /* silence compiler about unused variable */
			@1 {
				cnt[h]++;
			}
		}
	}
	BATloop(bn, p, q) {
		oid h = (*(oid*) BUNhead(bni,p)) - min;
		*(int*)BUNtloc(bni, p) = cnt[h];
	}
        GDKfree(cnt);
@c

group_export str GRPaggr_count(int *retval, int *bid, int *eid, bit *ignore_nils);
str
GRPaggr_count(int *retval, int *bid, int *eid, bit *ignore_nils)
{
/* XXX in a large BAT, it is conceivable that there are head elements
   that occur more often than fits in an "int", so the return BAT
   should really have a tail type of size_t.
 */
	BAT *bn, *b = NULL, *e = NULL;
	BATiter ei, bi, bni;
	int zero = 0, *cnt;
	BUN p, q, r;
	oid i, range, min, max;
	int btt;
	ptr bt_nil;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "group.count", "Cannot access descriptor");
	}

	@:chkHeader(b,GRPaggr_count)@
	if ((e = BATdescriptor(*eid)) == NULL) {
		BBPreleaseref(b->batCacheid);
		throw(MAL, "group.count", "Cannot access descriptor");
	}
	@:chkHeader(e,GRPaggr_count)@

	bn = BATnew(e->htype, TYPE_int, BATcount(e));
	if (bn == NULL)
		throw(MAL, "group.count", "Cannot create descriptor");
	btt = b->ttype;
	bt_nil = ATOMnilptr(b->ttype);

	/* init: set all sums to zero */
	bn->tsorted = bn->hsorted = 0;
	ALIGNsetH(bn, e);
	ei = bat_iterator(e);
	bi = bat_iterator(b);
	bni = bat_iterator(bn);
	if (BAThordered(e) & 1) {
		min = *(oid *) BUNhead(ei, BUNfirst(e));
		BATloop(e, p, q) {
			if (BUNfastins(bn, BUNhead(ei, p), &zero) == NULL) {
				BBPreclaim(bn);
				throw(MAL, "group.count", "Insert Failed");
			}
		}
		max = *(oid *) BUNhead(ei, BUNlast(e) - 1);
	} else {
		min = max = *(oid *) BUNhead(ei, BUNfirst(e));
		BATloop(e, p, q) {
			if (BUNfastins(bn, BUNhead(ei, p), &zero) == NULL) {
				BBPreclaim(bn);
				throw(MAL, "group.count", "Insert Failed");
			}
			i = *(oid *) BUNhead(ei, p);
			if (i < min)
				min = i;
			else if (i > max)
				max = i;
		}
	}
	range = max - min + 1;

	/* scan b, and add increment totals for true values */
	if (range > SMALL_AGGR_MAX) {
		if (*ignore_nils) {
			ALGODEBUG THRprintf(GDKout, "#CMDaggr_count: range(=" SZFMT ") > SMALL_AGGR_MAX(=%d)  =>  large_aggr_count(if (ATOMcmp(btt,t,bt_nil)))\n", (size_t) range, SMALL_AGGR_MAX);

			@:large_aggr_count(if(ATOMcmp(btt,t,bt_nil)))@
		} else {
			ALGODEBUG THRprintf(GDKout, "#CMDaggr_count: range(=" SZFMT ") > SMALL_AGGR_MAX(=%d)  =>  large_aggr_count()\n", (size_t) range, SMALL_AGGR_MAX);

			@:large_aggr_count()@
		}
	} else {
		if (*ignore_nils) {
			ALGODEBUG THRprintf(GDKout, "#CMDaggr_count: range(=" SZFMT ") <= SMALL_AGGR_MAX(=%d)  =>  small_aggr_count(if (ATOMcmp(btt,t,bt_nil)))\n", (size_t) range, SMALL_AGGR_MAX);

			@:small_aggr_count(if(ATOMcmp(btt,t,bt_nil)))@
		} else {
			ALGODEBUG THRprintf(GDKout, "#CMDaggr_count: range(=" SZFMT ") <= SMALL_AGGR_MAX(=%d)  =>  small_aggr_count()\n", (size_t) range, SMALL_AGGR_MAX);

			@:small_aggr_count()@
		}
	}
	BBPkeepref(*retval = bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	BBPreleaseref(e->batCacheid);
	return MAL_SUCCEED;
}

group_export str GRPsize(int *retval, int *bid, int *eid);
str
GRPsize(int *retval, int *bid, int *eid)
{
	BAT *bn, *b = NULL, *e = NULL;
	BATiter ei, bi, bni;
	wrd zero = 0;
	BUN p, q, r;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "group.size", "Cannot access descriptor");
	}

	@:chkHeader(b,GRPsize)@
	if ((e = BATdescriptor(*eid)) == NULL) {
		BBPreleaseref(b->batCacheid);
		throw(MAL, "group.size", "Cannot access descriptor");
	}
	@:chkHeader(e,GRPsize)@

	bn = BATnew(e->htype, TYPE_wrd, BATcount(e));
	if (bn == NULL)
		throw(MAL, "group.size", "Cannot create descriptor");
	/* init: set all sums to zero */
	bn->tsorted = bn->hsorted = 0;
	ALIGNsetH(bn, e);
	ei = bat_iterator(e);
	bi = bat_iterator(b);
	bni = bat_iterator(bn);
	BATloop(e, p, q) {
		if (BUNfastins(bn, BUNhead(ei, p), &zero) == NULL) {
			BBPreclaim(bn);
			throw(MAL, "group.count", "Insert Failed");
		}
	}
	/* scan b, and add increment totals for true values */
	if (BATprepareHash(bn)) {
		BBPreclaim(bn);
		return GDK_FAIL;
	}
	BATloop(b, p, q) {
		if (*(bit *) BUNtloc(bi, p) == TRUE) {
			oid *h = (oid *) BUNhead(bi, p);

			BUNfndOID(r, bni, h);
			if (r != BUN_NONE) {
				wrd *dst = (wrd *) BUNtloc(bni, r);

				(*dst)++;
			}
		}
	}
	BBPkeepref(*retval = bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	BBPreleaseref(e->batCacheid);
	return MAL_SUCCEED;
}

@-
The window aggregate functions
@= windowsum
group_export str GRPslidingsum_@1(int *retval, int *bid, int  *size, int *shift);
str GRPslidingsum_@1(int *retval, int *bid, int  *size, int *shift)
{
	BATiter bi;
	BAT *b, *bn;
	@2 sum;
	oid o= oid_nil;
	BUN p, q;
	int i;

	if( *shift <=0){
		throw(MAL, "group.sum", "Illegal shift value");
	}
		
	if( (b= BATdescriptor(*bid)) == NULL ){
		throw(MAL, "group.sum", "Cannot access descriptor");
	}
	@:chkHeader(b,GRPwindowsum_@1)@

	/* init: set all sums to zero */
	bn= BATnew( TYPE_void, TYPE_@2, BATcount(b)/ *size +1);
	bn->tsorted = bn->hsorted = 0;
	BATseqbase(bn,0);

	i = *size;
	sum =0;
	bi = bat_iterator(b);
	BATloop(b, p, q) {
		sum += *(@1*) BUNtail(bi,p);
		if (--i == 0){
			BUNfastins(bn, &o, &sum);
			/* slide here */
			if (*size != *shift ){
				p -= (*size-*shift);
			}
			i = *size;
			sum =0;
		}
	}
	if(i != *size)
		BUNfastins(bn, &o, &sum);

	*retval= bn->batCacheid;
	BBPkeepref(*retval);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}
group_export str GRPwindowsum_@1(int *retval, int *bid, int  *size);
str GRPwindowsum_@1(int *retval, int *bid, int  *size){
	return GRPslidingsum_@1(retval,bid,size,size);
}
@c
@:windowsum(bte,lng)@
@:windowsum(sht,lng)@
@:windowsum(int,lng)@
@:windowsum(lng,lng)@
@:windowsum(oid,lng)@
@:windowsum(wrd,lng)@
@:windowsum(flt,dbl)@
@:windowsum(dbl,dbl)@
@}
