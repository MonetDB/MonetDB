@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2004 CWI.
@' All Rights Reserved.
@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f bat
@t Binary Association Tables
@v 2.0
@a Peter Boncz, M.L. Kersten
@* Introduction
@T
This module contains the commands and patterns to manage Binary 
Association Tables (BATs). The relational operations you can execute
on BATs have the form of a neat algebra, described in algebra.mx

But a database system needs more that just this algebra, since often it
is crucial to do table-updates (this would not be permitted in a strict
algebra).

All commands needed for BAT updates, property management,
search accellerator management, basic I/O, persistency, and storage options
can be found in this module.

@* Module Definition
Type parameters are represented by short integers. The MAL frontend
defines constants to simplify the mapping from type identifier to value.

All parameters to the modules are passed by reference.
In particular, this means that string values are passed to the module 
layer as (str *)
and we have to de-reference them before entering the gdk library.
(Actual a design error in gdk to differentiate passing int/str)
This calls for knowlegde on the underlying BAT typs`s
@= derefStr
	{ int _tpe= ATOMstorage(@1->@2type);
	if( _tpe == TYPE_str || _tpe > TYPE_str )
	{ if(@3== 0 || *(str*)@3==0) @3= str_nil; else @3 = *(str *)@3; }}
@-
The code speaks for itself
@mal

module bat;

command bat(ht:int, tt:int) : bat[any,any] = CMDnewBat
comment "Creates a new empty transient BAT, with head- and tail-types as indicated.";

command bat(ht:int, tt:int, size:int) : bat[any,any] = CMDnewBat2
comment "Creates a new empty BAT, directly allocating for 'size' elements.";

command bat(ht:int, tt:int, size:lng) : bat[any,any] = CMDnewBATlng
comment "Creates a new empty BAT, directly allocating for 'size' elements.";

command reverse(b:bat[any::1,any::2]) : bat[any::2,any::1] = CMDreverse
comment "Returns the reverse view of a BAT (head is tail and tail is head).
 BEWARE:  no copying is involved; input and output refer to the same object!";

command mirror(b:bat[any::1,any]) : bat[any::1,any::1] = CMDmirror
comment "Returns the head-mirror image of a BAT (two head columns).";

command convert(b:bat[any::1,any::2] ) : bat[any::1,any::2] = CMDconvert
comment "Convert the contents of a BAT from little-endian to big-endian and vice versa.
 THIS command SHOULD NOT BE USED FROM MAL! DANGEROUS! DEBUGGING PURPOSES ONLY!";

command order(b:bat[any::1,any::2]) : bat[any::1,any::2] = CMDorder
comment "Sorts the BAT itself, in place. ";

command revert(b:bat[any::1,any::2]) : bat[any::1,any::2] = CMDrevert
comment "Puts all BUNs in a BAT in reverse order. (Belongs to the BAT sequence module)";

@- BAT properties 
Properties of BATs not necessarily require loading the BAT completely.
The BAT identifier can be used to access the descriptors.
These properties can be inspected with the {\tt info(BAT[any,any]) : BAT[str,str] } c
ommand:
\begin{verbatim}
> car_age.info.print;
#---------------------------------#
# BAT:               tmp_31       #
# (str)              (str)        #
#---------------------------------#
[ "batId",           "car_age"    ] # logical bat name
[ "batCacheid",      "26"         ] # BBP index
[ "batParentid",     "0"          ] # set if a BAT is a view
[ "head",            "void"       ] # physical head-type
[ "tail",            "int"        ] # physical tail-type
[ "batPersistence",  "persistent" ] # transient/session/persistent
[ "batRestricted",   "updatable"  ] # read-only/append-only/updatable
[ "batDirty",        "clean"      ] # clean/dirty
[ "batRefcnt",       "1"          ] # physical refcount
[ "batLRefcnt",      "1"          ] # logical refcount (total)
[ "batPlevel",       "1"          ] # logical refcount (persistent part)
[ "batSet",          "0"          ] # [head,tail] combinations are unique
[ "batCopiedtodisk", "1"          ] # has been saved or not
\end{verbatim}

Per column, a number of properties are kept. We only show the head-properties; the tail properties 
have the first character of their named replaced by 't' ({\tt sorted}, {\tt tdense}, etc.):

\begin{verbatim}
[ "hsorted",         "1"          ] # column is known to be sorted
[ "hdense",          "1"          ] # column is known to be densely ascended 
[ "hseqbase",        "0@0"        ] # if densely ascending (i.e. 0@0, 1@0, @,0, ...): first value
[ "hacctype",        "null"       ] # name of user-defined accelerator
[ "hindex",          "absent"     ] # name of built-in accelerator: hash or index (T-tree) 
\end{verbatim}

As described in the @[<a href="www/gdk.html#mod_1_3_0">GDK Technical Reference</a>@,
BATs store their data in one to five heaps, of which at least one called {\tt batBuns}
is present always. For each column type that is {\em variable-sized} - like {\tt str} - another 
heap might be present ({\tt hheap} and {\tt theap}). If a column has a user-defined search 
accelerator, more heaps may be present (({\tt haccelerator} and {\tt taccelerator}). 

\begin{verbatim}
[ "batBuns.free",    "400004"     ] # occupied size in bytes
[ "batBuns.size",    "400012"     ] # allocated size in bytes
[ "batBuns.maxsize", "400012"     ] # reserver virtual memory in bytes
[ "batBuns.storage", "malloced"   ] # malloced/mmap/priv
\end{verbatim}

Properties steer the algorithms that Monet uses to execute algebra command. For instance,
the {\tt find(BAT[any::1,any::2] b, any:;1) : any::2) that looks up a tail value by head,
uses binary search if and only if the head column is sorted (in other cases, hash-lookup
and scan are execution options). 

Sometimes new (extension) code contains bugs in the property management, leaving false
properties on produced BATs. You can imagine that later on, this leads to additional
bugs, as e,g, the binary search algorithms will yield erroneous results on a non-sorted
sequence.

[OBSOLETE]
To make problem detection easier, the MIL interpreter contains property checking code,
that is set with via the  {\tt debugmask(int)} command:
\begin{description}
\item[2] {\tt debugmask(debugmask() and 2)} causes that all properties on
newly created BATs to be checked. You must realize that finding out that a column is sorted 
({\tt hsorted/tsorted}) costs a full scan, and finding out that it contains unique values
({\tt hkeyed/tkeyed}) costs a full scan plus the creation of a full hash index.  
\item[8] {\tt debugmask(debugmask() and 8)} causes that all properties on
{\bf all} BATs handled by the MIL interpreter to be checked. This will catch all property errors. 
\end{description}

By default, both bits in the {\tt debugmask} are off, which gives fastest performance.
@-

@mal
command info ( b:BAT) : bat[str,str] = CMDinfo
comment "Produce a BAT containing info about a BAT in [attribute,value] format.
 It contains all properties of the BAT record. See the BAT documentation in
 GDK for more information.";
 
command getCapacity ( b:bat[any,any] ) : lng = CMDgetCapacity
comment "Returns the current allocation size (in max number of elements) of a BAT.";

command getHeadType ( b:bat[any,any] ) : int = CMDgetHeadType
comment "Returns the type of the head column of a BAT, 
as an integer type number.";
 
command getTailType( b:bat[any,any] ) : int = CMDgetTailType
comment "Returns the type of the tail column of a BAT, 
as an integer type number.";
 
command getRole ( bid:bat[any,any] ) : str = CMDgetRole
comment "Returns the rolename of the head column of a BAT.";
 
command setKey( b:bat[any::1,any::2], mode:bit) :bat[any::1,any::2] = CMDsetkey
comment "Sets the 'key' property of the head column to 'mode'. In 'key' mode, 
 the kernel will silently block insertions that cause a duplicate entries
 in the head column. 
 KNOWN BUG: when 'key' is set to TRUE, this function does not automatically 
 eliminate duplicates. Use b := b.kunique;";

command isaKey( b:bat[any,any]) : bit = CMDgetkey
comment "return whether the head column of a BAT is unique (key).";

command setSet( b:bat[any::1,any::2], mode:bit) : bat[any::1,any::2] = CMDsetset
comment "Sets the 'set' property on this BAT to 'mode'. In 'set' mode, the kernel 
 will silently block insertions that cause a duplicate BUN [head,tail] entries
 in the BAT. 
 KNOWN BUG: when 'set' is set to TRUE, this function does not automatically 
 eliminate duplicates. Use b := b.sunique;
 Returns the BAT itself.";

command isaSet( b:bat[any,any]) : bit = CMDisaSet
comment "return whether the BAT mode is set to unique.";

command setAccess( b:bat[any::1,any::2], mode:str) : bat[any::1,any::2] = CMDsetAccess
comment "Try to change the update access priviliges to this BAT. Mode:
 r[ead-only]      - allow only read access.
 a[append-only]   - allow reads and insertions of new elements.
 w[riteable]      - allow reads, insertions, and updates.
 BATs are updateable by default. On making a BAT readonly, all 
 subsequent updates fail with an error message.
 Returns the BAT itself.";

command setAppendMode( b:bat[any::1,any::2]):bat[any::1,any::2] =CMDsetAppendMode
comment "Change access privilige of BAT to append only";

command setReadMode( b:bat[any::1,any::2]) : bat[any::1,any::2] = CMDsetReadMode
comment "Change access privilige of BAT to read only";

command setWriteMode( b:bat[any::1,any::2]):bat[any::1,any::2] = CMDsetWriteMode
comment "Change access privilige of BAT to read and write";

command getAccess( b:bat[any,any]):chr = CMDgetAccess
comment "return the access mode attached to this BAT as a character.";

command hasAppendMode( b:bat[any,any]):bit = CMDhasAppendMode
comment "return true if to this BAT is append only.";

command hasWriteMode( b:bat[any,any]):bit = CMDhasWriteMode
comment "return true if to this BAT is read and write.";

command hasReadMode( b:bat[any,any]):bit = CMDhasReadMode
comment "return true if to this BAT is read only.";


command getSequenceBase( b:bat[void,any]): oid = CMDgetSequenceBase
comment "Get the sequence base for the void column of a BAT.";
command getSequenceBase( b:bat[oid,any]): oid = CMDgetSequenceBase;

command setSequenceBase( b:bat[void,any::1], seqbase:oid):int 
			= CMDsetSequenceBase
comment "Set the sequence base for the void column of a BAT.";
command setSequenceBase( b:bat[oid,any::1], seqbase:oid):int 
			= CMDsetSequenceBase;

command setSorted(b:bat[any,any]) : bit = CMDsetSorted
comment "Assure BAT is ordered on head.";

command isSorted(b:bat[any,any]) : bit = CMDisSorted
comment "Returns whether a BAT is ordered on head or not.";

command getBatSize(b:bat[any,any]) : str = CMDbatsize_str;
command getBatSize(b:bat[any,any]) : int = CMDbatsize
comment "A version of BATsize that does not require loading the BAT.";


command getBATrefcnt(b:bat) : int = getBATrefcnt
comment "Utility for debugging MAL interpreter";

@- BAT updates
Update commands come in many disguises.  Note that we don;t return
the BAT id, but merely a success/failure code.
@mal
command insert(b:bat[any::1, oid], src:bat[any::1,void]) 
				: bat[any::1,any::2] = CMDinsert_bat
comment "Insert all BUNs of the second BAT into the first. This
case should be removed, because it is a hack for SQL";

command insert(b:bat[any::1, any::2], src:bat[any::1,any::2]) 
				: void = CMDinsert_bat
comment "Insert all BUNs of the second BAT into the first.";

command insert(b:bat[any::1, any::2], h:any::1, t:any::2) 
				: void = CMDinsert_bun
comment "Insert one BUN[h,t] in a BAT.";

command insert(b:bat[void,any::1],v:any::1): void = CMDinsert_void_bun
comment "Insert a value in a 'void' bat";

command replace(b:bat[any::1, any::2], src:bat[any::1,any::2]) 
				: bat[any::1,any::2] = CMDreplace_bat
comment "Perform replace for all BUNs of the second BAT into the first.";

command replace(b:bat[any::1, any::2], h:any::1, t:any::2) 
				: bat[any::1,any::2] = CMDreplace_bun
comment "Replace the tail value of one BUN that has some head value.";

# The SQL append/replace commands

command append( i:BAT[oid,any::1],u:BAT[oid,any::1] ):BAT[oid,any::1] 
	= CMDoid_bat_append_oid_bat_wrap
comment "append the content of u to i (renumbers u-oids' to unique numbers)";

command append(i:BAT[oid,any::1], u:any::1):BAT[oid,any::1] 
	= CMDoid_bat_append_val_wrap
comment "append the value u to i";

command append( i:BAT[void,any::1], u:BAT[void,any::1] ):BAT[void,any::1] 
	= CMDbat_append_void_bat_wrap
comment "append the content of u to i";

command append( i:BAT[void,any::1], u:BAT[oid,any::1]):BAT[void,any::1] 
	= CMDbat_append_oid_bat_wrap
comment "append the content of u to i";

command append( i:BAT[void,any::1], u:any::1):BAT[void,any::1] 
	= CMDbat_append_val_wrap
comment "append the value u to i";

command append(i:BAT[oid,void], u:BAT[oid,void]):BAT[oid,void] 
	= CMDbat_append_oidvoid_bat_wrap
comment "Special case append for empty bats, works around impossible void,void case";

command replace( o:BAT[void,any::1], d:BAT[oid,any::1]):BAT[void,any::1] 
	= CMDbat_replace_oid_bat_wrap
comment "inplace replace values on the given locations";

#end SQL enhancement

command destroy(b:bat):void= CMDdestroy;
command destroy(s:str,immediately:bit):void = CMDdestroy_bat
comment "Schedule bat for removal upon session commit";

command delete(b:bat[any::1, any::2], h:any::1, t:any::2) 
				: void = CMDdelete_bun
comment "Delete one specific BUN.";

command delete(b:bat[any::1, any::2], h:any::1) 
				: void = CMDdelete_head
comment "Delete all BUNs with a certain head value.";

command clear(b:bat[any::1, any::2]) : void = CMDdelete_all
comment "Delete all BUNs in a BAT.";

command delete(b:bat[any::1, any::2]) : void = CMDdelete_all
comment "Delete all BUNs in a BAT.";

command delete(b:bat[any::1, any::2], src:bat[any::1,any]) 
				: void = CMDdelete_bat_head
comment "Delete from the first BAT all BUNs with a head value that is in the second.";

command deleteBuns(b:bat[any::1, any::2], src:bat[any::1,any::2]) 
				: void = CMDdelete_bat_bun
comment "Delete from the first BAT all BUNs with a corresponding BUN in the second.";

command getAlpha(b:bat[any::1,any::2]):bat[any::1,any::2] = CMDgetAlpha
comment "Obtain the list of BUNs added";
command getDelta(b:bat[any::1,any::2]):bat[any::1,any::2] = CMDgetDelta
comment "Obtain the list of BUNs deleted";
@- BAT I/O, Persistency
@T
The BAT Buffer Pool (BBP) manages all known BATs. It administers
their logical and physical names and a reference count. BATs can
either be {\em persistent} or {\em transient}. The BBP also manages
swapping on a BAT level: a BAT is either loaded entirely or not.
MAL variables of type {\tt bat} can either be loaded or not. When 
the Monet server is started, all BATs are swapped out. If an unloaded
bat-variable is used as an operand in a command, it is automatically 
loaded.  The BBP applies a simple but effective LRU based swapping 
algorithm. BATs have a {\em heat}, which drops over time, and is 
increased when a BAT is used by some command.  If the size of the 
allocated arena gets to be large, BATs may be swapped out. 

Note, we should move old-fashioned mil operator definitions
into a separate module. 

@mal
command setName ( b:bat[any::1,any::2] , s:str) : bat[any::1,any::2] = CMDsetName
comment "Give a logical name to a BAT. ";

command getName ( b:bat[any,any]) : str = CMDbbpname
comment "Gives back the logical name of a BAT.";

command setRole( b:bat[any::1,any::2] , h:str, t:str):bat[any::1,any::2]
	= CMDsetRole
comment "Give a logical name to the columns of a BAT.";

command setColumn( b:bat[any::1,any::2],t:str):bat[any::1,any::2] = CMDsetColumn
comment "Give a logical name to the tail column of a BAT.";
command setColumn( b:bat[any::1,any::2] , h:str, t:str):bat[any::1,any::2]
        = CMDsetColumns
comment "Give both columns of a BAT a new name.";


command isTransient( b:BAT) :bit = CMDisTransient;
command setTransient( b:BAT) :bit = CMDsetTransient
comment "Make the BAT transient.  Returns boolean which indicates if the
BAT administration has indeed changed.";

command isPersistent( b:BAT) : bit = CMDisPersistent;
command setPersistent( b:BAT) : bit = CMDsetPersistent
comment "Make the BAT persistent.  Returns boolean which indicates if the
BAT administration has indeed changed.";

command save(nme:bat[any,any]) : bit = CMDsave2;

command save(nme:str) : bit = CMDsave
comment "Save a BAT to storage, if it was loaded and dirty. 
Returns whether IO was necessary.
Please realize that calling this function violates 
the atomic commit protocol!!";


command load(name:str) : bat[any,any] = CMDload
comment "Load a particylar bat from disk";

command unload(name:str) : bit = CMDunload
comment "Swapout a BAT to disk. Transient BATs can also be swapped out.
 Returns whether the unload indeed happened. ";

command isCached(b:bat[any,any]):bit = CMDisCached
comment "Bat is stored in main memory.";

command setHot(name:str) :void = CMDhot
comment "Makes a BAT very hot for the BBP. The chance of being chosen 
for swapout is small, afterwards.  Returns the BAT itself.";

command heat(name:str) :lng = CMDheat
comment "Return the current BBP heat (LRU stamp)";

command setCold(nme:str) :void = CMDcold
comment "Makes a BAT very cold for the BBP. The chance of being choses 
for swapout is big, afterwards.  Returns the BAT itself.";

command setCold(b:BAT) :void = CMDcoldBAT;
command setHot(b:BAT) :void = CMDhotBAT;

@- Heap Specific Commands
@T
BATs are stored in memory in a number of Heap objects. A heap is nothing
more than a contiguous range of memory. Bats are saved to disk by just writing
away their image. This approach without pointer swizzling makes it possible 
to either load an image into an alloced range of memory (STORE\_MEM), or 
memory-map (STORE\_MMAP) an image into virtual memory.

The heap images of a BAT are stored in the {\tt $MONETHOME/dbfarm/$DB/bat/} 
directory.  For each bat X, the following heaps are stored:
\begin{description}
\item[X.buns] an array with all the fixed-size parts of all BUNs.
\item[X.hheap] if the head column contains a variable sized atoms (e.g. str),
then the fixed-size part of a BUN contains an integer byte-offset into 
the heap. String values themself are stored in this the X.hheap. 
\item[X.theap] similar to X.hheap, but for the tail column.
\item[X.hacc]. On each column, you might create {\em persistent accelerator
structures}. Monet has two builtin accelerators (index and hash), but they
are normally constructed on the fly. They are transient. Only hash-tables
you can be made persistent. User-defined accelerators are always persistent.
Only one persistent accelerator can exist per head column. It is stored in 
the X.hacc heap.
\item[X.tacc] similar to X.hacc, but for the tail column. 
\end{description}

Each of these heaps can be {\bf compressed} using the unix {\tt compress}
utility forming a X.ext.Z file. Monet wil automatically decompress it
upon load. Compressed heaps cannot be memory mapped.

A final file present for each t in the BAT directory is:
\begin{description}
\item[X.desc] the BAT descriptor. Stores most of the properties of a BAT.
\end{description}
@
For more technical information on BATs, we refer to the 
@[<a href="http://www.cwi.nl/~monet/www/scw/gdk/470_pseudo.html">GDK</a>@
documentation.
@mal
command mmap(b:BAT, buns_mode:int, hheap_mode:int, theap_mode:int, 
		hacc_mode:int, tacc_mode:int) : bit = CMDmmap
comment "For each individual heap, you can change the allocation mode to 
 either STORE_MEM or STORE_MMAP. Passing an int(nil) means: no change.
 Changing a dirty STORE_MEM heap into STORE_MMAP, will cause a BAT save 
 (this has to happen before the heap can be mapped into virtual memory). 
 These modes are persistent. ";

command mmap(b:BAT, mode:int): bit = CMDmmap2
comment "Alias for mmap(b,mode,mode,mode,mode,mode)";

command madvise(b:BAT, buns_mode:int, hheap_mode:int, theap_mode:int, 
		hacc_mode:int, tacc_mode:int) : bit = CMDmadvise
comment "Modern Operating Systems allow users to influence the buffer management
 policy of virtual memory. This is a crucial feature for database systems,
 and eliminates the need to reimplement the OS in a database buffer manager.
 The supported flags are BUF_NORMAL (the normal adaptive kernel algorithm),
 BUF_RANDOM (no page prefetching), BUF_SEQUENTIAL (prefetch and swapout),
 BUF_WILLNEED (load everything with prefetch), BUF_DONTNEED (swapout).
 These buffer management modes are not persistent.
 Returns the BAT operated upon.";

command madvise(b:BAT, mode:int):bit = CMDmadvise2
comment "alias for madvise(b,mode,mode,mode,mode,mode)";

@- ASCII import, export
The below commands load and save a BAT from/to an ASCII dump. These
functions are efficient but work only for binary tables. For printing
ASCII n-ary tables you can use the @#print@(bat1,bat2,..) command
from the system.mx module.
@mal
command export(b:BAT, filepath:str):bit  = CMDexport
comment "Export a BAT as ASCII to a file. If the 'filepath' is not absolute, it
 is put into the .../dbfarm/$DB directory. Success of failure is indicated.";

command import(b:BAT, filepath:str) : bit = CMDimport
comment "Import a BAT from an ASCII dump. The new tuples are *inserted* into the
 parameter BAT. You have to create it! Its signature must match the dump, 
 else parsing errors will occur and FALSE is returned.";

@- BAT Accelerators
@T
[WILL BECOME OBSOLETE]
Search accelerators are datastructures that are used to speed up 
access to data in BATs. Monet comes with the builtin accelerators
{\tt index}, meaning binary tree index, and {\tt hash} meaning 
bucket-chained hash table. The extension facilities of Monet allow
more accelerators to be defined by users. Exanples are the {\tt rtree}
and {\tt datavector}. 

\begin{verbatim}
>monet_acctbl.print;
#-------------------------#
# h             | t       #
#-------------------------#
[ "hash",         1       ]
[ "index",        2       ]
\end{verbatim}
@
More info on how to write new search accelerators can be found in the
@[<a href="../mel.html">MEL documentation</a>@.
@mal
command accbuild(b:bat[any,any], acctype:int):bit = CMDaccbuild_std
comment "Build an accelerator on the head column of b. The builtin accelerator
 types index and hash will be created as transient accelerators. They
 will not be saved on disk. User-defined accelerators must always be
 persistent." ;

command accbuild(b:bat[any,any], acctype:int, param:ptr):int = CMDaccbuild
comment "like accbuild(bat[any,any] b, int acctype), but with a parameter that
 is provide to the specific accelerator build routine.";

command accdestroy(b:bat[any,any], acctype:int) = CMDaccdestroy
comment "Destroy the accelerator of type 'acctype'  that is present on
 the head-type of b.";

command accpresent(b:bat[any,any] ) : int = CMDaccpresent
comment "Returns the accelerator type of the *persistent* accelerator present 
 on the head column of b. Note that index and hash accelerators are
 generally *not* persistent, and will not be returned by this function!";
  
command hasHash(b:bat[any,any]):bit = CMDhasHash;
command setHash(b:bat[any,any],prop:bit):bit = CMDsetHash;
command hasIndex(b:bat[any,any]):bit = CMDhasIndex;
command setIndex(b:bat[any,any],prop:bit):bit = CMDsetIndex;

@- Synced BATs
The binary model of Monet has important advantages when working in
main-memory. Tables are thin and very efficiently processed. The binary
model gives rise, however, to a larger-than-normal number of join
and semijoin operations. Relations are split up in vertical parts that
are very much related to each other. Then, for instance, multiple
similar semijoins occur on different vertical parts. By equipping the
kernel with knowledge about the correspondence of these parts, we
can greatly limit the amount of work to be done.

When two BATs effectively contain the same sequence of head elements,
we call them 'synced'. This is implemented by storing a very large 
OID for each column. An update to the column destroys this OID.
By comparing two OIDs the Monet kernel can very quickly decide that
two columns are exactly equal. All BAT algebra operations propagate
these 'sync' OIDs with their own propagation rules.
@mal
command isSynced (b1:bat[any,any], b2:bat[any,any]) : bit = CMDisSynced
comment "Tests whether two BATs are synced or not. ";

@- Constants
The following constants have not been integrated in the code base
@mal
#Constants have been added to mal/const.mx prelude
#    STORE_MEM   := 0;     # load into GDKmalloced memory
#    STORE_MMAP  := 1;     # mmap() into virtual memory
#    STORE_COMPR := 2;     # currently not implemented this way
#    BUF_NORMAL    := 0;   # No further special treatment
#    BUF_RANDOM    := 1;   # Expect random page references
#    BUF_SEQUENTIAL:= 2;   # Expect sequential page references
#    BUF_WILLNEED  := 3;   # Will need these pages
#    BUF_DONTNEED  := 4;   # Don't need these pages

@{
@{
@* Implementation Code
In Version 5, we are not going to support recursive BATs.
It is up to the programmer to translate a bat into a
bat-name or batCacheid

@= batconvert
	(BAT@2type(@1) == TYPE_bat)?&((BAT*)@2)->batCacheid:@2

@+ Information Functions
In most cases we pass a BAT identifier, which should be unified
with a BAT descriptor. Upon failure we can simply abort the function.

@= getBATdescriptor
	if( BBPcheck(*@2,"@4")==0) 
                return throwMessage("bat.@4", "cannot access bat @2 in bbp");
	@3= (BAT*) BBPgetdesc(*@2);
	if( @3 == NULL) { *@1 = 0;
                return throwMessage("bat.@4", "cannot access descriptor @2");
	}
	if(*@2 <0) @3 = BATmirror(@3);
@= getBATdescriptor2
	if( BBPcheck(*@2,"@4")== 0 ) 
                return throwMessage("bat.@4", "cannot access bat @2 in bbp");
	@3= (BAT*) BBPgetdesc(*@2);
	if( @3 == NULL) { *@1 = 0;
                return throwMessage("bat.@4", "cannot access descriptor @2");
	}
	if(*@2 <0) @3 = BATmirror(@3);
@-
At this stage of the game, we should translate
the arguments of BATnew into types.
Beware, a void column type is turned into a virtual oid type immediately
by setting the sequential base.
@+ Minimum and Maximum
The routines @`BATmin_@5(b) and @`BATmax_@5(b) compute the minimum and
maximum value of the tail column of a BAT.
Aggregate values are calculated just before they are requested by
the user. They are not maintained continuously, because we expect
them to be used sparsely.
@-
@= atomaggr
    if (s > 0 && !(BATtordered(b)&1)) {
        char* nil = BATatoms[t].atomNull;
        BUN p,q;
        int xx;
        BATloopFast(b, p, q, xx) {
            x = (ptr) BUNt@2(b, p);
            if (@3_CMP(x, nil, @4) == 0) {
                v = nil; break;
            }
            if (@3_@5(x, v, @4)) {
                v = x;
            }
        }
    }
    if (aggr) {
       memcpy(aggr, x=v, ATOMsize(t));
    } else {
       /* alloc new space and copy the atom into it */
       s = ATOMlen(t, v);
       memcpy(x = (ptr) GDKmalloc(s), v, s);
   }
@= voidaggr
    if (aggr) {
        *(oid *) aggr = *(oid *) (x=v);
    } else {
        /* alloc new space and copy the atom into it */
        memcpy(x = (ptr) GDKmalloc(sizeof(oid)), v, s);
    }
@= aggrmin
    v = (s == 0)?ATOMnilptr(t):BUNtail(b, BUNfirst(b));
    @:@5aggr(@1,@2,@3,@4,LT)@
@= aggrmax
    v = (s == 0)?ATOMnilptr(t):BUNtail(b, BUNlast(b)-BUNsize(b));
    @:@5aggr(@1,@2,@3,@4,GT)@

@= BATaggr
ptr BAT@1(BAT *b, ptr aggr) {
        int t;
        size_t s;
        ptr v, x;

        BATcheck(b, "BAT@1");
        s = BATcount(b);
        t = b->ttype;
        if (BATtvoid(b)) {
            @:aggr@1(chr,loc,simple,chr,void)@
        } else {
            switch(ATOMstorage(t)) {
            case TYPE_chr: @:aggr@1(chr,loc,simple,chr,atom)@ break;
            case TYPE_sht: @:aggr@1(sht,loc,simple,sht,atom)@ break;
            case TYPE_int: @:aggr@1(int,loc,simple,int,atom)@ break;
            case TYPE_flt: @:aggr@1(flt,loc,simple,flt,atom)@ break;
            case TYPE_dbl: @:aggr@1(dbl,loc,simple,dbl,atom)@ break;
            case TYPE_lng: @:aggr@1(lng,loc,simple,lng,atom)@ break;
            default: if (b->tvarsized) {
                           @:aggr@1(chr,var,atom,t,atom)@ break;
                     } else {
                           @:aggr@1(chr,loc,atom,t,atom)@ break;
            }        }
        }
        return x;
}

@h
#ifndef _BAT_H_
#define _BAT_H_

#include <gdk.h>
#include <mal.h>

mal_export str CMDsetRole(int *r, int *bid, str *hname, str *tname);

#endif /*_BAT_H_*/
@-
to be included at a later stage
            case TYPE_uchr: @:aggr@1(uchr,loc,simple,uchr,atom)@ break;
@c
#include "gdk.h"
#include <stream.h>
#include "mal_function.h"

@:BATaggr(min)@
@:BATaggr(max)@


str CMDnewBat2(int *res, int *ht, int *tt, size_t *cap){
	BAT *b;

	if( *ht<0 || *ht >= GDKatomcnt ||
	    *tt<0 || *tt >= GDKatomcnt){
		return throwMessage("bat.new", "type values out of range");
	}
	b = BATnew(*ht,*tt,*cap);
	if( b){
		*res= b->batCacheid;
		BBPincref(b->batCacheid,TRUE);
		return MAL_SUCCEED;
	}
	return  throwMessage("bat.new", "GDKerror");
}
str CMDnewBATlng(int *res, int *ht, int *tt){
	size_t cap= (size_t) *tt;
	return CMDnewBat2(res,ht,tt,&cap);
}
str CMDnewBat(int *res, int *ht, int *tt){
	size_t cap=0;
	return CMDnewBat2(res,ht,tt,&cap);
}

str CMDreverse(int *ret, int *bid){
	BAT *b;
	@:getBATdescriptor(ret,bid,b,reverse)@
	*ret= -b->batCacheid;
	BBPfix(b->batCacheid);
	return MAL_SUCCEED;
} 

str CMDmirror(int *ret, int *bid){
	BAT *b, *v;
	@:getBATdescriptor(ret,bid,b,mirror)@
	v = VIEWcombine(b);
	if (b->batRestricted == BAT_WRITE) {
		BAT *bc = BATrcopy(v);
		BBPreclaim(v);
                v = bc;
        }
        if(v) {
                BBPfix(b->batCacheid);
                *ret = v->batCacheid;
                return MAL_SUCCEED;
        }

	*ret = 0;
	return throwMessage("bat.mirror", "GDKerror");
}

str CMDconvert(int *ret, int *bid){
	BAT *b;
	@:getBATdescriptor(ret,bid,b,convert)@
	BATconvert(b,CONV_HTON);
	BBPfix(b->batCacheid);
	*ret = b->batCacheid;
	return MAL_SUCCEED;
}

str CMDrevert(int *ret, int *bid){
	BAT *b;
	@:getBATdescriptor(ret,bid,b,revert)@
	BATrevert(b);
	BBPfix(b->batCacheid);
	*ret = b->batCacheid;
	return MAL_SUCCEED;
}

str CMDorder(int *ret, int *bid){
	BAT *b;
	@:getBATdescriptor(ret,bid,b,order)@
	BATorder(b);
	BBPfix(b->batCacheid);
	*ret = b->batCacheid;
	return MAL_SUCCEED;
}
@-
Insertions into the BAT may involve void types (=no storage required)
These cases should actually be captured during BUNins, because they
may emerge internally as well.
@= void_insertbun
if (b->@1type == TYPE_void && *(oid*) @1 != oid_nil &&
    *(oid*) @1 != (b->@1seqbase + BUNgetpos(b, BUNlast(b))))
{
printf("val %d seqbase %d pos %d\n", *(oid*)@1,
	b->@1seqbase,  BUNgetpos(b, BUNlast(b)) );
      return throwMessage("bat.insert", " insert non-nil values in a void column.");
}
@c
str CMDinsert_void_bun(int *r, int *bid, ptr t) {
	BAT *b;
	oid h= oid_nil;
	@:getBATdescriptor2(r,bid,b,insert)@
	@:derefStr(b,t,t)@
	BUNins(b,(ptr)&h, @:batconvert(b,t)@); 
	return MAL_SUCCEED;
} 

str CMDinsert_bun(int *r, int *bid, ptr h, ptr t) {
	BAT *b;
	@:getBATdescriptor2(r,bid,b,insert)@
	@:derefStr(b,h,h)@
	@:derefStr(b,t,t)@
	BUNins(b, @:batconvert(b,h)@, @:batconvert(b,t)@); 
	return MAL_SUCCEED;
} 

str CMDinsert_bat(int *r, int *bid, int *sid){
	BAT *b, *s;
	@:getBATdescriptor2(r,bid,b,insert)@
	@:getBATdescriptor2(r,sid,s,insert)@
	BATins(b,s);
	return MAL_SUCCEED;
} 

str CMDreplace_bun(int *r, int *bid, ptr h, ptr t) {
	BAT *b;
	@:getBATdescriptor2(r,bid,b,replace)@
	@:derefStr(b,h,h)@
	@:derefStr(b,t,t)@
	BUNreplace(b, @:batconvert(b,h)@, @:batconvert(b,t)@);
	BBPfix(b->batCacheid);
	*r = b->batCacheid;
	return MAL_SUCCEED;
} 

str CMDreplace_bat(int *r, int *bid, int *sid){
	BAT *b,*s;
	@:getBATdescriptor2(r,bid,b,replace)@
	@:getBATdescriptor2(r,sid,s,replace)@
	BATreplace(b,s);
	BBPfix(b->batCacheid);
	*r = b->batCacheid;
	return MAL_SUCCEED;
} 

str CMDdestroy_bat(int *r,str *input, int *immediately) {
	int bid= BBPindex(*input);
	*r= FALSE;
        if (bid ) {
                BBPfix(bid);
                if (BBPindex(*input) == bid) {
                        BAT *b = BBPquickdesc(ABS(bid), FALSE);
                        if (*immediately == FALSE) {
                                b->batKeeparound = 1;
                                b->batDirtydesc = 1;
                        }
                        BATmode(b, TRANSIENT);
                        *r = TRUE;
                }
                BBPunfix(bid);
        }
	*r = TRUE;
	return MAL_SUCCEED;
} 
str CMDdestroy(int *r,int *bid) {
	int immediately= TRUE;
	BAT *b;
	@:getBATdescriptor2(r,bid,b,replace)@
	return CMDdestroy_bat(r,&b->batId,&immediately);
}
str CMDdelete_bun(int *r, int *bid, ptr h, ptr t) {
	BAT *b;
	@:getBATdescriptor2(r,bid,b,delete)@
	@:derefStr(b,h,h)@
	@:derefStr(b,t,t)@
	BUNdel(b,h,t);
	return MAL_SUCCEED;
} 

str CMDdelete_head(int *r, int *bid, ptr h) {
	BAT *b;
	@:getBATdescriptor2(r,bid,b,delete)@
	@:derefStr(b,h,h)@
	BUNdelHead(b, @:batconvert(b,h)@);
	return MAL_SUCCEED;
} 

str CMDdelete_all(int *r, int *bid) {
	BAT *b;
	@:getBATdescriptor2(r,bid,b,delete)@
	BATclear(b);
	return MAL_SUCCEED;
} 

str CMDdelete_bat_bun(int *r, int *bid, int *sid){
	BAT *b,*s;
	@:getBATdescriptor2(r,bid,b,delete)@
	@:getBATdescriptor2(r,sid,s,delete)@
	BATdel(b,s);
	return MAL_SUCCEED;
} 

str CMDdelete_bat_head(int *r, int *bid, int *sid){
	BAT *b,*s;
	@:getBATdescriptor2(r,bid,b,delete)@
	@:getBATdescriptor2(r,sid,s,delete)@
	BATdelHead(b,s);
	return MAL_SUCCEED;
} 
/* The SQL frontend uses void-head bats */
void bun_inplace(BAT *b, oid id, ptr val )
{
	BUN p = NULL;
	BUN oldInserted = b->batInserted;

        assert(b->htype == TYPE_void);
        assert(b->hseqbase == 0);
        assert(BATcount(b) > id);


	b->batInserted = NULL;
	BUNfndVOID(p, b, (ptr)&id);
        assert(p >= b->batInserted); /* we don't want delete/ins */
	(void) BUNinplace(b, p, (ptr)&id, val);
	b->batInserted = oldInserted;
}

size_t void_delete_bat( BAT *b, BAT *d, int delta){
	size_t nr = 0;
	BUN r,s;
	ptr nil = ATOMnilptr(b->ttype);

        if (delta) {
            for (r = d->batInserted; r < BUNlast(d); r = BUNnext(d, r)) {
                oid delid = *(oid*)BUNtail(d,r);
                bun_inplace(b,  delid, nil);
                nr++;
            }
        } else {
            BATloop(d, r, s){
                oid delid = *(oid*)BUNtail(d,r);
                bun_inplace(b,  delid, nil);
                nr++;
            }
        }
	return nr;
}
size_t void_insert_delta( BAT *b, BAT *u ){
        size_t nr = 0;
        BUN r;
        oid nil = oid_nil;

        for (r = u->batInserted; r < BUNlast(u); r = BUNnext(u, r)) {
                BUNins(b,  (ptr)&nil, BUNtail(u,r));
                nr++;
        }
        return nr;
}

size_t void_replace_delta( BAT *b, BAT *u){
        size_t nr = 0;
        BUN r;

        for (r = u->batInserted; r < BUNlast(u); r = BUNnext(u, r)) {
                oid updid = *(oid*)BUNhead(u,r);
                ptr val = BUNtail(u,r);
                bun_inplace(b,  updid, val);
                nr++;
        }
        return nr;
}

size_t void_replace_bat( BAT *b, BAT *u){
	size_t nr = 0;
	BUN r,s;

	BATloop(u, r, s){
		oid updid = *(oid*)BUNhead(u,r);
		ptr val = BUNtail(u,r);
		bun_inplace(b,  updid, val);
		nr++;
	}
	return nr;
}


size_t void_insert_bat( BAT *b, BAT *u){
	size_t nr = 0;
	BUN r,s;
	oid nil = oid_nil;

	BATloop(u, r, s){
		BUNins(b,  (ptr)&nil, BUNtail(u,r));
		nr++;
	}
	return nr;
}

size_t void_append_bat( BAT *b, BAT *u){
        size_t sz = BUNsize(u);
	size_t sbase = b->hseqbase + BATcount(b);
	BATseqbase(u, sbase);
	BATins(b, u);
	return sz;
}
str CMDbat_append_void_bat_wrap( int *r, int *bid, int *uid )
{
	BAT *i, *u;
	@:getBATdescriptor2(r,bid,i,append)@
	@:getBATdescriptor2(r,uid,u,append)@
	void_append_bat( i, u );
	BBPfix(i->batCacheid);
	*r = i->batCacheid;
	return MAL_SUCCEED;
}

str CMDbat_append_oid_bat_wrap( int *r, int *bid, int *uid )
{
	BAT *i, *u;
	@:getBATdescriptor2(r,bid,i,append)@
	@:getBATdescriptor2(r,uid,u,append)@
	void_insert_bat( i, u );
	BBPfix(i->batCacheid);
	*r = i->batCacheid;
	return MAL_SUCCEED;
}

str CMDbat_append_oidvoid_bat_wrap( int *r, int *bid, int *uid )
{
	BAT *i, *u;
	@:getBATdescriptor2(r,bid,i,append)@
	@:getBATdescriptor2(r,uid,u,append)@
	assert(BATcount(i)==0 && BATcount(u) == 0);
	BBPfix(i->batCacheid);
	*r = i->batCacheid;
	return MAL_SUCCEED;
}

str CMDoid_bat_append_oid_bat_wrap( int *res, int *bid, int *uid )
{
	BUN r=0,s;
        oid o;
	BAT *i, *u;
	@:getBATdescriptor2(r,bid,i,append)@
	@:getBATdescriptor2(r,uid,u,append)@
	
	assert(i->htype == TYPE_oid && u->htype == TYPE_oid);
	BATmax(BATmirror(i),&o);
	o++;
	BATloop(u, r, s){
		oid h = *(oid*)BUNhead(u,r) + o;
		BUNins(i, &h,  BUNtail(u,r));
        }
	BBPfix(i->batCacheid);
	*res = i->batCacheid;
	return MAL_SUCCEED;
}

str CMDoid_bat_append_val_wrap( int *r, int *bid, ptr u)
{
        oid o;
	BAT *i;
	@:getBATdescriptor2(r,bid,i,append)@

	assert(i->htype == TYPE_oid);
	BATmax(BATmirror(i),&o);
	o++;
	@:derefStr(i,t,u)@
	BUNins( i, (ptr) & o, u );
	BBPfix(i->batCacheid);
	*r = i->batCacheid;
	return MAL_SUCCEED;
}


str CMDbat_append_val_wrap( int *r, int *bid, ptr u)
{
	BAT *i;
	@:getBATdescriptor2(r,bid,i,append)@
	oid h = i->hseqbase + BATcount(i);
	@:derefStr(i,t,u)@
	BUNins( i, (ptr) & h, u );
	BBPfix(i->batCacheid);
	*r = i->batCacheid;
	return MAL_SUCCEED;
}

str CMDbat_replace_oid_bat_wrap( int *r, int *bod, int *did )
{
	BAT *o, *d;
	@:getBATdescriptor2(r,bod,o,replace)@
	@:getBATdescriptor2(r,did,d,replace)@
	void_replace_bat( o, d );
	BBPfix(o->batCacheid);
	*r = o->batCacheid;
	return MAL_SUCCEED;
}
/*end of SQL enhancement */

str CMDgetAlpha(int *r, int *bid) {
	BAT *b,*c;
	@:getBATdescriptor(r,bid,b,getInserted)@
	BBPfix(b->batCacheid);
	c= BATalpha(b);
	*r = c->batCacheid;
	return MAL_SUCCEED;
} 
str CMDgetDelta(int *r, int *bid) {
	BAT *b,*c;
	@:getBATdescriptor(r,bid,b,getInserted)@
	BBPfix(b->batCacheid);
	c= BATdelta(b);
	*r = c->batCacheid;
	return MAL_SUCCEED;
} 
@- Property management
All property operators should ensure exclusive access to the BAT
descriptor.
@c
/* descriptors may be unloaded by BBPtrim, so secure them with a hotfix while in use */
static BAT* lock_desc(bat bid) {
        BBPfix(bid);
        return (BAT*) BBPgetdesc(bid);
}

static void unlock_desc(bat bid) {
        BBPunfix(bid);
}

str CMDgetCapacity(lng *res, int *bid) {
        if (BBPcheck((bat)*bid, "CMDcapacity")) {
                BAT *b = (BAT*) lock_desc((bat)*bid);
		BBPfix(*bid);
                if (b == NULL) {
                        *res = lng_nil;
                } else {
                        *res = (lng) BATcapacity(b);
                }
		unlock_desc(*bid);
        }
	return MAL_SUCCEED;
}

str CMDgetHeadType(int *res, int *bid) {
        if (BBPcheck((bat)*bid, "CMDhtype")) {
                BAT *b = (BAT*) lock_desc((bat)*bid);
		BBPfix(*bid);
                if (b == NULL) {
                        *res = TYPE_void;
                } else {
                        *res = ((bat)*bid > 0)?BAThtype(b):BATttype(b);
                }
		unlock_desc(*bid);
        }
	return MAL_SUCCEED;
}
str CMDgetTailType(int *res, int *bid) {
        if (BBPcheck((bat)*bid, "CMDttype")) {
                BAT *b = (BAT*) lock_desc((bat)*bid);
		BBPfix(*bid);
                if (b == NULL) {
                        *res = TYPE_void;
                } else {
                        *res = ((bat)*bid > 0)?BATttype(b):BAThtype(b);
                }
		unlock_desc(*bid);
        }
	return MAL_SUCCEED;
}
str CMDgetRole(str *res, int *bid) {
	BAT *b;
	@:getBATdescriptor(res,bid,b,getType)@
	*res = GDKstrdup((*bid > 0)?b->hident:b->tident);
	return MAL_SUCCEED;
}

str CMDsetkey(int *res, int *bid, bit *param) {
	BAT *b;
	@:getBATdescriptor(res,bid,b,setkey)@
	BATkey(b, *param?BOUND2BTRUE:FALSE);
	BBPfix(b->batCacheid);
	*res = b->batCacheid;
        return MAL_SUCCEED;
}

str CMDsetset(int *res, int *bid, bit *param) {
	BAT *b;
	@:getBATdescriptor(res,bid,b,setset)@
	BATset(b, *param?BOUND2BTRUE:FALSE);
	BBPfix(b->batCacheid);
	*res = b->batCacheid;
        return MAL_SUCCEED;
}
str CMDisaSet(int *res, int *bid) {
	BAT *b;
	@:getBATdescriptor(res,bid,b,setset)@
	*res = b->batSet;
        return MAL_SUCCEED;
}

str CMDsetSorted(bit *res, int *bid) {
	BAT *b;
	@:getBATdescriptor(res,bid,b,isSorted)@
	BATorder(b);
        *res = BATordered(b)?1:0;
        return MAL_SUCCEED;
}
str CMDisSorted(bit *res, int *bid) {
	BAT *b;
	@:getBATdescriptor(res,bid,b,isSorted)@
        *res = BATordered(b)?1:0;
        return MAL_SUCCEED;
}
@-
We must take care of the special case of a nil column (TYPE_void,seqbase=nil) 
such nil columns never set hkey (and BUNins will never invalidate it if set) yet
a nil column of a BAT with <= 1 entries does not contain doubles => return TRUE.
@c

str CMDgetkey(bit *ret, int *bid) {
	BAT *b;
	@:getBATdescriptor(ret,bid,b,getkey)@
	if (BATcount(b) <= 1) {
		*ret = TRUE;
	} else {
		if (!b->hkey) {
			BATpropcheck(b, BATPROPS_ALL);
		}
		*ret = b->hkey?TRUE:FALSE;
	}
	return MAL_SUCCEED;
}

str CMDsetPersistent(int *res, int *bid) {
	BAT *b;
	@:getBATdescriptor(res,bid,b,setPersistence)@
	BATmode(b, PERSISTENT);
	*res = TRUE;
        return MAL_SUCCEED;
}
str CMDisPersistent(int *res, int *bid) {
	BAT *b;
	@:getBATdescriptor(res,bid,b,setPersistence)@
	*res= (b->batPersistence == PERSISTENT)? TRUE:FALSE;
        return MAL_SUCCEED;
}
str CMDsetTransient(int *res, int *bid) {
	BAT *b;
	@:getBATdescriptor(res,bid,b,setTransient)@
	BATmode(b, TRANSIENT);
	*res= TRUE;
        return MAL_SUCCEED;
}
str CMDisTransient(bit *res, int *bid) {
	BAT *b;
	@:getBATdescriptor(res,bid,b,setTransient)@
	*res= b->batPersistence == TRANSIENT;
        return MAL_SUCCEED;
}

@-
@= accessMode
str CMDset@1(int *res, int *bid) {
	BAT *b;
	@:getBATdescriptor(res,bid,b,set@1)@
	BATsetaccess(b, @2);
	BBPfix(b->batCacheid);
	*res = b->batCacheid;
        return MAL_SUCCEED;
}
str CMDhas@1(bit *res, int *bid) {
	BAT *b;
	@:getBATdescriptor(res,bid,b,set@1)@
	*res = BATgetaccess(b)=='@3';
        return MAL_SUCCEED;
}
@-
@c
	@:accessMode(WriteMode,0,w)@
	@:accessMode(ReadMode,1,r)@
	@:accessMode(AppendMode,2,a)@

str CMDsetAccess(int *res, int *bid, str *param) {
		BAT *b;
		int m;
	@:getBATdescriptor(res,bid,b,setAccess)@
	switch(*param[0]){
	case 'r': m= 1; break;
	case 'a': m= 2; break;
	case 'w': m= 0; break;
	default: 
		*res = 0;
		return throwMessage("bat.setAccess", " illegal access mode");
	}
	BATsetaccess(b, m);
	BBPfix(b->batCacheid);
	*res = b->batCacheid;
        return MAL_SUCCEED;
}

str CMDgetAccess(char *res, int *bid) {
	BAT *b;
	@:getBATdescriptor(res,bid,b,getAccess)@
	switch(BATgetaccess(b)){
	case 1: *res= 'r'; break;
	case 2: *res= 'a'; break;
	case 0: *res= 'w'; break;
	}
        return MAL_SUCCEED;
}
str getBATrefcnt(int *res, int *bid) {
	BAT *b;
	@:getBATdescriptor(res,bid,b,setset)@
	*res = BBP_refs(b->batCacheid);
        return MAL_SUCCEED;
}

char* pre(str s1,str s2){
	static char buf[64];
	snprintf(buf,64,"%s%s",s1,s2);
	return buf;
}
static char* local_itoa(int i){
	static char buf[32];
	snprintf(buf,32,"%d",i);
	return buf;
}
static char* local_utoa(unsigned long i){
        static char buf[32];
        snprintf(buf, 32, "%lu", i);
        return buf;
}

#define COLLISION 6
extern hash_t HASHlist (Hash* h, size_t i);

void HASHinfo(BAT *bn, Hash *h, str s){
        hash_t  i;
        hash_t  j;
        size_t  cnt[COLLISION + 2];
        size_t  largebuckets = 0;
        size_t  largetot = 0;
        char    buf[32];
 
	BUNins(bn, pre(s,"type"), ATOMname(h->type));
	BUNins(bn, pre(s,"mask"), local_itoa(h->mask));
	BUNins(bn, pre(s,"lim"), local_itoa(h->lim));
 
	for (i = 0; i <= COLLISION + 1; i++) {
		cnt[i] = 0;
	}
	for (i = 0; i <= h->mask; i++) {
		if (h->hash[i] == 0) {
			cnt[0]++;
		} else if (h->hash[i] > h->lim) {
			GDKerror("HASHinfo: hash consistency problem %d\n", i);
		} else if ((j = HASHlist(h, h->hash[i])) <= COLLISION +1) {
			cnt[j]++;
		} else {
			largebuckets++;
			largetot += j;
		}
	}
 
	for (i = 0; i <= COLLISION+1; i++)
	if( cnt[i]) {
		BUNins(bn, pre(s,local_utoa(i)), local_utoa(cnt[i]));
	}

        snprintf(buf, 32, "%lu on %lu", (unsigned long) largetot, (unsigned long) largebuckets);
	BUNins(bn, pre(s,"collision"), buf);
}

static void infoHeap(BAT *bn, Heap *hp, str nme){
	char buf[1024], *p = buf;

	while(*nme) *p++ = *nme++;
	strcpy(p, "free");
        BUNins(bn, buf, local_utoa(hp->free ));
	strcpy(p, "size");
        BUNins(bn, buf, local_utoa(hp->size));
	strcpy(p, "maxsize");
        BUNins(bn, buf, local_utoa(hp->maxsize));
	strcpy(p, "storage");
        BUNins(bn, buf, (hp->base==NULL)?"absent":(hp->storage==STORE_MMAP)?
		(hp->filename?"memory mapped":"anonymous vm"):
		(hp->storage==STORE_PRIV)?"private map":"malloced");
	strcpy(p, "filename");
        BUNins(bn, buf, hp->filename?hp->filename:"no file");
	strcpy(p, "offset");
        BUNins(bn, buf, local_utoa(hp->offset));
}


static char *oidtostr( oid i ){
        int len = 32;
        static char bf[32];
        char *p = bf;

        (void)OIDtoStr(&p, &len, &i);
        return bf;
}
str CMDinfo(int *retval, int *bid){
	BAT *bn,*b;
	char mode[1024], *access;
 
	if (!(bn = BATnew(TYPE_str,TYPE_str, 128)))
		return throwMessage("bat.info", "GDKerror");
	*retval = bn->batCacheid;
 
	b= BBPdescriptor(*bid);
	if( b== 0) return throwMessage("CMDinfo","no such bat.\n");

	if (b->batPersistence == PERSISTENT) {
		strcpy(mode, "persistent");
	} else if (b->batPersistence == SESSION) {
		strcpy(mode, "session");
	} else if (b->batPersistence == TRANSIENT) {
		strcpy(mode, "transient");
	} else {
		strcpy(mode, "unknown");
	} 

	switch(b->batRestricted) {
	case BAT_READ:         access="read-only";      break;
	case BAT_WRITE:        access="updatable";      break;
	case BAT_APPEND:       access="append-only";      break;
	default:               access="unknown";
	}
 
        BUNins(bn, "version", local_itoa(b->GDKversion));
        BUNins(bn, "batId", b->batId );
        BUNins(bn, "batCacheid", local_itoa(b->batCacheid));
        BUNins(bn, "batParentid", local_itoa(b->batParentid));
        BUNins(bn, "batSharecnt", local_itoa(b->batSharecnt));
        BUNins(bn, "head", ATOMname(b->htype));
        BUNins(bn, "tail", ATOMname(b->ttype));
        BUNins(bn, "batPersistence", mode);
        BUNins(bn, "batRestricted", access);
        BUNins(bn, "batRefcnt", local_itoa(BBP_refs(b->batCacheid)));
        BUNins(bn, "batDirty", BATdirty(b)?"dirty":"clean");
        BUNins(bn, "batSet", local_itoa(b->batSet));
        BUNins(bn, "void_tid", local_itoa(b->void_tid));
        BUNins(bn, "void_cnt", local_itoa(b->void_cnt));
 
        BUNins(bn, "hsorted", local_itoa(BAThordered(b)));
        BUNins(bn, "hident",  b->hident);
	BUNins(bn, "hdense", local_itoa(BAThdense(b)));
	BUNins(bn, "hseqbase", oidtostr(b->hseqbase));
        BUNins(bn, "hkey", local_itoa(b->hkey));
        BUNins(bn, "hloc", local_itoa(b->hloc));
        BUNins(bn, "hvarsized", local_itoa(b->hvarsized));
        BUNins(bn, "halign", local_utoa(b->halign));
        BUNins(bn, "halignflushed", local_utoa(b->halignflushed));
 
        BUNins(bn, "tident", b->tident);
	BUNins(bn, "tdense", local_itoa(BATtdense(b)));
	BUNins(bn, "tseqbase", oidtostr(b->tseqbase));
        BUNins(bn, "tsorted", local_itoa(BATtordered(b)));
        BUNins(bn, "tkey", local_itoa(b->tkey));
        BUNins(bn, "tloc", local_itoa(b->tloc));
        BUNins(bn, "tvarsized", local_itoa(b->tvarsized));
        BUNins(bn, "talign", local_utoa(b->talign));
        BUNins(bn, "talignflushed", local_utoa(b->talignflushed));
 
        BUNins(bn, "batInserted", local_utoa(BUNindex(b, b->batInserted)));
        BUNins(bn, "batDeleted", local_utoa(BUNindex(b, b->batDeleted)));
        BUNins(bn, "batHole", local_utoa(BUNindex(b, b->batHole)));
        BUNins(bn, "top", local_utoa(BUNindex(b, (Bunbase(b) + b->batBuns->free))));
	BUNins(bn, "batStamp", local_itoa(b->batStamp));
	BUNins(bn, "curStamp", local_itoa(BBPcurstamp()));
        BUNins(bn, "batCopiedtodisk", local_itoa(b->batCopiedtodisk));
        BUNins(bn, "batDirtydesc", b->batDirtydesc?"dirty":"clean");
 
        BUNins(bn, "batDirtybuns", b->batDirtybuns?"dirty":"clean");
	infoHeap(bn, b->batBuns, "batBuns.");

        BUNins(bn, "hheapdirty", b->hheapdirty?"dirty":"clean");
	infoHeap(bn, &b->hheap, "hheap.");

        BUNins(bn, "theapdirty", b->theapdirty?"dirty":"clean");
	infoHeap(bn, &b->theap, "theap.");

        BUNins(bn, "hacctype", ACCname(b->hacctype));
        BUNins(bn, "haccdirty", b->haccdirty?"dirty":"clean");
        BUNins(bn, "haccCopiedtodisk", local_itoa(b->haccCopiedtodisk));
	infoHeap(bn, &b->haccelerator, "haccelerator.");

        BUNins(bn, "tacctype", ACCname(b->tacctype));
        BUNins(bn, "taccdirty", b->taccdirty?"dirty":"clean");
        BUNins(bn, "taccCopiedtodisk", local_itoa(b->taccCopiedtodisk));
	infoHeap(bn, &b->taccelerator, "taccelerator.");
 
        /* dump index information */
        if (b->hhash_heap) {
                HASHinfo(bn, &b->hhash, "hhash->");
        }
        if (b->thash_heap) {
                HASHinfo(bn, &b->thash, "thash->");
        }
        BUNins(bn, "head_index", b->hidx_heap?"present":"absent");
        BUNins(bn, "tail_index", b->tidx_heap?"present":"absent");
 
	return MAL_SUCCEED;
}

#define ROUND_UP(x,y) ((y)*(((x)+(y)-1)/(y)))

str CMDbatsize(int *tot, int *bid){
	BAT *b;
	size_t blksize = MT_pagesize();
	size_t size = ROUND_UP(sizeof(BATstore),blksize);

	@:getBATdescriptor(tot,bid,b,batsize)@
	if (!VIEWparent(b)) {
		size_t cnt = BATcapacity(b);
		size += ROUND_UP(b->batBuns->size, blksize);
		if (b->hheap.base) size += ROUND_UP(b->hheap.size, blksize);
		if (b->theap.base) size += ROUND_UP(b->theap.size, blksize);
		if (b->haccelerator.base) size += ROUND_UP(b->haccelerator.size, blksize);
		if (b->taccelerator.base) size += ROUND_UP(b->taccelerator.size, blksize);
		if (b->hhash_heap) size += ROUND_UP(sizeof(hash_t) * cnt, blksize);
		if (b->thash_heap) size += ROUND_UP(sizeof(hash_t) * cnt, blksize);
		if (b->hidx_heap) size += ROUND_UP(sizeof(BUN) * cnt, blksize);
		if (b->tidx_heap) size += ROUND_UP(sizeof(BUN) * cnt, blksize); 
	}
	*tot = size;
	return MAL_SUCCEED;
}

str CMDbatsize_str(int *tot, str batname){
        bat bid = BBPindex(batname);
        if (bid == 0) {
                return throwMessage("CMDbatsizes","no such bat.\n");
        }
        return CMDbatsize(tot, &bid);
}


@+ Synced BATs
@c
str CMDisSynced(bit *ret, int *bid1, int *bid2){
	BAT *b1, *b2;
	@:getBATdescriptor(ret,bid1,b1,isSynced)@
	@:getBATdescriptor(ret,bid2,b2,isSynced)@
	*ret = ALIGNsynced(b1,b2)?1:0;
	return MAL_SUCCEED;
}

@+ BBP Management, IO
@c
str CMDsetRole(int *r, int *bid, str *hname, str *tname){
	BAT *b;
	@:getBATdescriptor(r,bid,b,setRole)@
	if(*hname== 0) return throwMessage("bat.setRole", "head name missing");
	if(*tname== 0) return throwMessage("bat.setRole", "tail name missing");
	BATroles(b, *hname, *tname);
	*r= b->batCacheid;
	BBPfix(b->batCacheid);
	return MAL_SUCCEED;
}
str CMDsetColumn(int *r, int *bid, str *tname){
	BAT *b;
	@:getBATdescriptor(r,bid,b,setColumn)@
	if(*tname==0) return throwMessage("bat.setColumn", "column name missing");
	BBPfix(b->batCacheid);
	BATroles(b, b->hident,*tname);
	*r= b->batCacheid;
	return MAL_SUCCEED;
}
str CMDsetColumns(int *r, int *bid, str *hname, str *tname){
        BAT *b;
        @:getBATdescriptor(r,bid,b,setColumns)@
        BATroles(b, *hname, *tname);
        *r= b->batCacheid;
        BBPfix(b->batCacheid);
        return MAL_SUCCEED;
}


str CMDsetName(int *retval, int *bid, str *s){
	BAT *b;
	int ret;
	@:getBATdescriptor(retval,bid,b,setName)@
	if(*s== 0) return throwMessage("bat.setName", "name missing");
	ret = BATname(b,*s);
	*retval = *bid;;
        if (ret == 1)
                return throwException(MALEXCEPTION,"bat.setName",
			"identifier expected: %s",*s);
        else if (ret == BBPRENAME_ILLEGAL) 
                return throwException(MALEXCEPTION,"bat.setName",
			"illegal temporary name: '%s'", *s);
        else if (ret == BBPRENAME_LONG) 
                return throwException(MALEXCEPTION,"bat.setName",
			"name too long: '%s'", *s);
        else /* if (ret == BBPRENAME_ALREADY) 
                return throwException(MALEXCEPTION,"bat.setName",
			"rename already"); */
	return MAL_SUCCEED;
}

str CMDbbpname(str *retval, int *bid){
	BAT *b;
	@:getBATdescriptor(retval,bid,b,bbpname)@
	*retval = GDKstrdup(BBPname(b->batCacheid));
	return MAL_SUCCEED;
}

str CMDunload(bit *res, str *input) {
        bat bid;
	if( *input==0) return throwMessage("bat.unload", " file name missing");
        bid = ABS(BBPindex(*input));
	*res = FALSE;
        if (bid > 0) {
		BAT *b;
		BBPfix(bid);
		b = BBP_cache(bid);
		if (b && b->batPersistence == SESSION) BATmode(b, TRANSIENT);
		*res = BBPunfix(bid);
	}
        return MAL_SUCCEED;
}
str CMDisCached(int *res, int *bid) {
	BAT *b;
	@:getBATdescriptor(res,bid,b,isCached)@
	*res = 0;
	return throwMessage("bat.isCached", "not yet implemented");
}
str CMDload(int *res, str *input) {
	bat bid= BBPindex(*input);
	*res = bid;
        if( bid) return MAL_SUCCEED;
	return throwMessage("bat.unload", " file name missing");
}

str CMDhot(int *res, str *input) {
	(void)res; /* fool compiler */
	BBPhot(BBPindex(*input));
	return MAL_SUCCEED;
}

str CMDcold(int *res, str *input) {
	(void)res; /* fool compiler */
	BBPcold(BBPindex(*input));
	return MAL_SUCCEED;
}
str CMDcoldBAT(int *res, int *bid) {
	BAT *b;
	(void)res; (void)bid; /* fool compiler */
	@:getBATdescriptor(res,bid,b,isCached)@
	BBPcold(b->batCacheid);
	return MAL_SUCCEED;
}
str CMDheat(int *res, str *input) {
	int bid = BBPindex(*input);
	if (bid) {
		*res = BBP_lastused(bid) & 0x7fffffff;
	}
 	return throwMessage("bat","heat not yet implemented\n");
 }
str CMDhotBAT(int *res, int *bid) {
	(void)res; /* fool compiler */
	BAT *b;
	@:getBATdescriptor(res,bid,b,isCached)@
	BBPhot(b->batCacheid);
	return MAL_SUCCEED;
}

str CMDsave(bit *res, str *input) {
	bat bid = BBPindex(*input);
	BAT *b;
	*res = FALSE;
	if (bid ) {
		BBPfix(bid);
		b = BBP_cache(bid);
		if (b && BATdirty(b)) { 
			if (BBPsave(b) == 0) *res = TRUE;
		}
		BBPunfix(bid);
	}
        return MAL_SUCCEED;
}
str CMDsave2(bit *res, int *bid) {
	BAT *b;
	@:getBATdescriptor2(res,bid,b,save)@
	if (b && BATdirty(b)) { 
		if (BBPsave(b) == 0) *res = TRUE;
	}
	BBPunfix(*bid);
        return MAL_SUCCEED;
}


@= change_heap
{	int mode = (@2).storage;
	if (mode == STORE_MMAP && (@2).filename == NULL) 
		mode = STORE_MEM;  
	if ((@2).base == NULL || *@1 == int_nil || *@1 == mode) {
		*@1 = -1;
	}
}
@c
str CMDmmap(int *res, int *bid, int *bns, int *hhp, int *thp,
			int *hacc, int *tacc)
{	BAT *b;
	@:getBATdescriptor(res,bid,b,mmap)@
	@:change_heap(bns,(*b->batBuns))@
	@:change_heap(hhp,b->hheap)@
	@:change_heap(thp,b->theap)@
	@:change_heap(hacc,b->haccelerator)@
	@:change_heap(tacc,b->taccelerator)@
	if (BATmmap(b, *bns, *hhp, *thp, *hacc, *tacc) == 0) {
		*res= TRUE;
		return MAL_SUCCEED;
	}
	*res= FALSE;
	return throwMessage("bat.mmap", " failed");
}
str CMDmmap2(int *res, int *bid, int *bns){
	return CMDmmap(res,bid,bns,bns,bns,bns,bns);
}

str CMDmadvise(int *res, int *bid, int *bns, int *hhp, int *thp, 
		 	        int *hacc, int *tacc)
{	BAT *b;
	@:getBATdescriptor(res,bid,b,madvice)@
	*res= BATmadvise(b, (*bns==int_nil)?-1:*bns, 
		(*hhp==int_nil)?-1:*hhp, (*thp==int_nil)?-1:*thp, 
		(*hacc==int_nil)?-1:*hacc, 
		(*tacc==int_nil)?-1:*tacc);
	if( *res) return throwMessage("bat.madvise", " failed");
	return MAL_SUCCEED;
}
str CMDmadvise2(int *res,  int *bid, int *mode){
	return CMDmadvise(res,bid,mode,mode,mode,mode,mode);
}

@+ Bulk export/loading
To simplify conversion between versions and to interface with other 
applications, we use a simple import/export operation.

The conversion routine assumes space in the buffer for storing the result.
@{
@c
@-
A BAT can be saved in Monet format using the export command.
It is of particular use in preparing an ascii version for migration.
The exported file is saved in the context of the directory
where the server was started unless an absolute file name was
presented.
@c
str CMDexport(int *ret, int *bid, str *fnme) {
	BAT *b;
	stream  *s = open_wastream(*fnme);
	@:getBATdescriptor(ret,bid,b,export)@
	if (s== NULL || stream_errnr(s) ) {
		*ret = FALSE;
		return throwException(MALEXCEPTION,"bat.export",
			"could not open %s",*fnme);
	}
	BATprintf(s,b);
	stream_close(s);
	stream_destroy(s);
	*ret = TRUE;
	return MAL_SUCCEED;
}

@
The import command reads a single BAT from an ascii file. It assumes
a layout compatible with that produced by print or export.
@c
str CMDimport(int *ret, int *bid, str *fnme) {
	BAT *b;
	int	(*hconvert)(str, int*, ptr*), (*tconvert)(str, int*, ptr*);
	size_t	bufsize = 2048; /* NIELS: tmp change used to be 1024 */
	char	*base, *cur, *end;
	char	*buf = (char *) GDKmalloc(bufsize);
	ptr	*h = 0, *t = 0;
	int	lh = 0,	lt = 0;
	FILE	*fp = fopen(*fnme, "r");

	@:getBATdescriptor(ret,bid,b,import)@
	hconvert = BATatoms[BAThtype(b)].atomFromStr;
	tconvert = BATatoms[BATttype(b)].atomFromStr;
@-
Open the file. Memory map it to minimize buffering problems.
@c
        if (fp == NULL)
	return throwException(MALEXCEPTION,"bat.import",
		"could not open file %s",fnme);
	else {
		int fn,fs;
	    	struct stat st;
                if ((fn=fileno(fp)) <= 0) {
                        return throwMessage("CMDimport","fileno fails\n");
                }
                if ((fs=fstat(fn, &st)) != 0) {
                        return throwMessage("CMDimports","fstat fails\n");
                }

		(void)fclose(fp); 
		if (st.st_size <= 0)
                        return throwMessage("CMDimports",
				"file empty or fstat broken?\n");
            	base = cur = (char*)MT_mmap(*fnme, MMAP_SEQUENTIAL, 0, st.st_size, NULL);
		end = cur + st.st_size;
                if (cur == (char*) -1) {
                        return throwMessage("CMDimport", "MT_mmap failed\n");
                }

	}
@-
Parse a line. Copy it into a buffer. Concat broken lines with a slash. 
@c
	while(cur < end) {
		str dst = buf, src = cur, p = strchr(cur, '\n');
		size_t l = p - cur;

		if (!p) {
			p = end;
		} else while(src[l-1] == '\\') {
			@:memcpy@
			dst += l-1; src += l+1;
			if ((p = strchr(src, '\n')) == 0) {
				p = end; break;
			}
			l = p - src;
		} 
		@:memcpy@
@= memcpy
		if (buf+bufsize < dst+l) {
		        int len = dst - buf;
			size_t inc = (size_t) ((dst+l) - buf);
			buf = (char*) GDKrealloc((void*) buf, bufsize = MAX(inc,bufsize)*2);
			dst = buf + len;
		}
		memcpy(dst, src, l-1);
@c
		dst[l] = 0;
		cur = p+1;
@-
Parse the line, and insert a BUN.
@c
		for(p = buf; *p && GDKisspace(*p); p++);
		if (*p == '#') continue;
@= parsevalue
	       	for (;*p && ((int) *p) != @2; p++);
		if (*p) for (p++; *p && GDKisspace(*p); p++);
       		if (*p == 0){
			*ret= FALSE;
		       	return throwException(MALEXCEPTION,"bat.import",
				"error in %s",buf);
       		}
       		p += @1(p, @3, @4);			
@c
		@:parsevalue(hconvert, '[', &lh, (ptr *) &h)@
		@:parsevalue(tconvert, 44, &lt, (ptr *)&t)@
		BUNins(b, h, t);
		
@-
Unmap already parsed memory, to keep the memory usage low. 
@c
#ifndef WIN32
#define MAXBUF 40*MT_pagesize()
		if ( (unsigned)(cur - base) > MAXBUF) {
			MT_munmap(base, MAXBUF);
			base += MAXBUF;
		} 
	}
#endif
@-
Cleanup and exit. Return the filled BAT.
@c
	if (h) GDKfree(h);
	if (t) GDKfree(t);
	GDKfree(buf);
	MT_munmap(base, end-base);
	BBPfix(b->batCacheid);
	*ret = TRUE;
	return MAL_SUCCEED;
}

@+ Accelerator Control
@c
str CMDaccbuild(int *ret, int *bid, int* acc, ptr *param){
	(void) bid; (void) acc; (void) acc; (void) param; /* fool compiler */
/*
	BAT *b;
	@:getBATdescriptor(ret,bid,b,accbuild)@
	ACCbuild(*acc, b, &b->haccelerator, *param); 
*/
	*ret= TRUE;
	return throwMessage("Accelerator","Obsolete functionality");
}
str CMDaccbuild_std(int *ret, int *bid, int* acc){
	(void)ret;(void)bid; (void)acc; /* fool compiler */
/*
	ptr n= NULL;
	CMDaccbuild(ret,bid, acc, &n);	*/
	return throwMessage("Accelerator","Obsolete functionality");
}

str CMDaccdestroy(int *ret, int *bid, int *acc) {
	(void)ret;(void)bid; (void)acc; /* fool compiler */
/*
	BAT *b;
	@:getBATdescriptor(ret,bid,b,accdestroy)@
	ACCdestroy(*acc, b, &b->haccelerator);
	*ret = TRUE;
*/
	return throwMessage("Accelerator","Obsolete functionality");
}

str CMDaccpresent(int *ret, int *bid) {
	(void)ret;(void)bid; /* fool compiler */
/*
	BAT *b;
	@:getBATdescriptor(ret,bid,b,accpresent)@
	*ret = 0;
	if (b->hacctype) {
	    int (*check)(Heap *, BAT*) = BATaccelerators[b->hacctype].accRepair;
	    if (check == NULL || (*check)(&b->haccelerator,b) == GDK_SUCCEED) {
		*ret = b->hacctype;
 	    }
	}
*/
	return throwMessage("Accelerator","Obsolete functionality");
}

str CMDhasHash(bit *ret, int *bid) {
	BAT *b;
	(void)ret; /* fool compiler */
	@:getBATdescriptor(ret,bid,b,hasHash)@
	*ret = b->hacctype == 1;
	return MAL_SUCCEED;
}
str CMDsetHash(bit *ret, int *bid, bit *prop) {
	BAT *b;
	(void)ret; (void) prop; /* fool compiler */
	@:getBATdescriptor(ret,bid,b,setHash)@
	BAThash(b,0);
	return MAL_SUCCEED;
}
str CMDhasIndex(bit *ret, int *bid) {
	BAT *b;
	@:getBATdescriptor(ret,bid,b,hasIndex)@
	*ret = b->hacctype == 2;
	return throwMessage("bat.hasIndex", " not yet implemented");
}
str CMDsetIndex(bit *ret, int *bid, bit *prop) {
	BAT *b;
	(void) prop; /* fool compiler */
	@:getBATdescriptor(ret,bid,b,setIndex)@
	return throwMessage("bat.setIndex", " not yet implemented");
}

str CMDsetSequenceBase(int *r, int *bid, oid* o){
	BAT *b;
	@:getBATdescriptor(r,bid,b,seqbase)@
	BATseqbase(b, *o);
	return MAL_SUCCEED;
}
str CMDgetSequenceBase(oid *r, int *bid){
	BAT *b;
	@:getBATdescriptor(r,bid,b,seqbase)@
	*r = b->hseqbase;
	return MAL_SUCCEED;
}
@}
@}
