@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2008 CWI.
@' All Rights Reserved.

@f batcalc
@a M.L. Kersten
@+ BAT calculator
Many applications require extension of the basic calculator and
mathematic functions to work on BAT arguments. Although the
MAL multiplex optimizer contains a command ('optimizer.multiplex')
to generate the necessary code, it is often much more efficient to 
use one of the dedidacted batcalc functions introduced below.

The operators supported are limited to the built-in fixed length
atoms, because they permit ease of storage of the operation result.
Variable sized atoms, especially user defined, may require more
administrative activities.
Furthermore, the operands involved are assumed to be aligned
to assure the fastest possible join evaluation.

Optimal processing performance is further obtained when the operators
can work as 'accumulators', for then we do not pay the price
of space allocation for a new intermediate. It may imply a BATcopy
before the accummulator function is being called.
A new BAT is of course created when the result of a function does not fit 
the accumulator.

The implementation does not take into account possible overflows
caused by the operators. However, the operators respect the NIL
semantics and division by zero produces a NIL.

In addition to arithmetic and comparison operators, casting and
mathematical functions are directly supported.

@+ NULL semantics
The batcalc arithmetic is already constraint to BATs of equal size.
Another improvement can be obtained when we do not have to check
for NULLs in each and every basic operation +,-,/,* and comparisons.
This variant can be obtained using a compile time flag (NULLTST) for the time
being. If it turns out to be effective, we will derive a new

version of batcalc.
Experiments show that ignoring the NULLS saves about 15\%
for larger instructions.
@{
@mal
module batcalc;

@+ Basic arithmetic
The first group of functions provide abstractions over the
binary operators +,/,-,*, and %. Both on (BAT,BAT) and (BAT,CST)
operands. We also support the type enlargement and auto coercions,
because they avoid expensive BAT copying.
@= calcGrp

	command @1(a:bat[:oid,:@4], b:bat[:oid,:@5], c:bat[:oid,:@2]):bat[:oid,:@4]
	address CMDbataccum@3_@2_@4_@5
	comment "Binary BAT calculator function with accumulator BAT result";

	command @1(a:bat[:oid,:@4], cst:@4, b:bat[:oid,:@5]):bat[:oid,:@4]
	address CMDbataccum@3cst2_@2_@4_@5
	comment "(BAT,Constant) calculator function with accumulator BAT result";

	command @1(a:bat[:oid,:@4], b:bat[:oid,:@4], cst:@5) :bat[:oid,:@4]
	address CMDbataccum@3cst_@2_@4_@5
	comment "(BAT,Constant) calculator function with accumulator BAT result";

	command @1(b:bat[:oid,:@4], cst:@5) :bat[:oid,:@2] 
	address CMDbat@3cst_@2_@4_@5;

	command @1(cst:@4, b:bat[:oid,:@5]) :bat[:oid,:@2] 
	address CMDcst@3bat_@2_@4_@5;

	command @1(b:bat[:oid,:@4], c:bat[:oid,:@5]) :bat[:oid,:@2] 
	address CMDbat@3_@2_@4_@5
	comment "Binary BAT calculator function with new BAT result";

@-
We need instantiations for the accumulator code,
but should limit modulo functions to integer-based types.
The calc group contains the operator, the desired result typ, its
C qualifier and the operands
@mal
	@:calcGrp(%,oid,MOD,oid,oid)@
	@:calcGrp(%,bte,MOD,bte,bte)@
	@:calcGrp(%,sht,MOD,sht,sht)@
	@:calcGrp(%,int,MOD,int,int)@
	@:calcGrp(%,lng,MOD,lng,lng)@
	@:calcGrp(xor,oid,XOR,oid,oid)@
	@:calcGrp(xor,bte,XOR,bte,bte)@
	@:calcGrp(xor,sht,XOR,sht,sht)@
	@:calcGrp(xor,int,XOR,int,int)@
	@:calcGrp(xor,lng,XOR,lng,lng)@
	@:calcGrp(and,oid,AND,oid,oid)@
	@:calcGrp(and,bte,AND,bte,bte)@
	@:calcGrp(and,sht,AND,sht,sht)@
	@:calcGrp(and,int,AND,int,int)@
	@:calcGrp(and,lng,AND,lng,lng)@
	@:calcGrp(or,oid,OR,oid,oid)@
	@:calcGrp(or,bte,OR,bte,bte)@
	@:calcGrp(or,sht,OR,sht,sht)@
	@:calcGrp(or,int,OR,int,int)@
	@:calcGrp(or,lng,OR,lng,lng)@

	@:calcGrp(/,dbl,DIV,dbl,dbl)@
	@:calcGrp(/,flt,DIV,flt,flt)@
	@:calcGrp(/,lng,DIV,int,sht)@
	@:calcGrp(/,lng,DIV,sht,int)@
	@:calcGrp(/,lng,DIV,lng,sht)@
	@:calcGrp(/,lng,DIV,sht,lng)@
	@:calcGrp(/,lng,DIV,sht,sht)@
	@:calcGrp(/,lng,DIV,lng,int)@
	@:calcGrp(/,lng,DIV,int,lng)@
	@:calcGrp(/,lng,DIV,int,int)@
	@:calcGrp(/,int,DIV,sht,sht)@
	@:calcGrp(/,int,DIV,int,sht)@
	@:calcGrp(/,int,DIV,sht,int)@
	@:calcGrp(/,sht,DIV,sht,sht)@
	@:calcGrp(/,lng,DIV,lng,lng)@
	@:calcGrp(/,int,DIV,int,int)@

	@:calcGrp(*,dbl,MUL,dbl,dbl)@
	@:calcGrp(*,flt,MUL,flt,flt)@
	@:calcGrp(*,lng,MUL,int,sht)@
	@:calcGrp(*,lng,MUL,sht,int)@
	@:calcGrp(*,lng,MUL,lng,sht)@
	@:calcGrp(*,lng,MUL,sht,lng)@
	@:calcGrp(*,lng,MUL,sht,sht)@
	@:calcGrp(*,lng,MUL,lng,int)@
	@:calcGrp(*,lng,MUL,int,lng)@
	@:calcGrp(*,lng,MUL,int,int)@
	@:calcGrp(*,int,MUL,sht,sht)@
	@:calcGrp(*,int,MUL,int,sht)@
	@:calcGrp(*,int,MUL,sht,int)@
	@:calcGrp(*,sht,MUL,sht,sht)@
	@:calcGrp(*,lng,MUL,lng,lng)@
	@:calcGrp(*,int,MUL,int,int)@

	@:calcGrp(-,dbl,SUB,dbl,dbl)@
	@:calcGrp(-,flt,SUB,flt,flt)@
	@:calcGrp(-,lng,SUB,int,sht)@
	@:calcGrp(-,lng,SUB,sht,int)@
	@:calcGrp(-,lng,SUB,lng,sht)@
	@:calcGrp(-,lng,SUB,sht,lng)@
	@:calcGrp(-,lng,SUB,lng,lng)@
	@:calcGrp(-,lng,SUB,int,lng)@
	@:calcGrp(-,lng,SUB,int,int)@
	@:calcGrp(-,int,SUB,sht,sht)@
	@:calcGrp(-,int,SUB,int,sht)@
	@:calcGrp(-,int,SUB,sht,int)@
	@:calcGrp(-,sht,SUB,sht,sht)@
	@:calcGrp(-,lng,SUB,lng,int)@
	@:calcGrp(-,int,SUB,int,int)@

	@:calcGrp(+,dbl,ADD,dbl,dbl)@
	@:calcGrp(+,flt,ADD,flt,flt)@
	@:calcGrp(+,lng,ADD,int,sht)@
	@:calcGrp(+,lng,ADD,sht,int)@
	@:calcGrp(+,lng,ADD,lng,sht)@
	@:calcGrp(+,lng,ADD,sht,lng)@
	@:calcGrp(+,lng,ADD,lng,int)@
	@:calcGrp(+,lng,ADD,int,lng)@
	@:calcGrp(+,lng,ADD,int,int)@
	@:calcGrp(+,int,ADD,int,int)@
	@:calcGrp(+,int,ADD,sht,sht)@
	@:calcGrp(+,int,ADD,int,sht)@
	@:calcGrp(+,sht,ADD,sht,sht)@
	@:calcGrp(+,lng,ADD,lng,lng)@
	@:calcGrp(+,int,ADD,sht,int)@


@-
@= unary
	command -(b:bat[:any_1,:@1]):bat[:any_1,:@1] 
	address CMDunaryMIN
	comment "Unary minus over the tail of the bat";
	
	command --(b:bat[:any_1,:@1]):bat[:any_1,:@1] 
	address CMDunaryMINMIN
	comment "Unary minus over the tail of the bat";

	command ++(b:bat[:any_1,:@1]):bat[:any_1,:@1] 
	address CMDunaryPLUSPLUS
	comment "Unary minus over the tail of the bat";

	command isnil(b:bat[:any_1,:@1]):bat[:any_1,:bit] 
	address CMDunaryISNIL
	comment "Unary check for nil over the tail of the bat";
@-
Not used yet
	#command -(a:bat[:any_1,:@1],b:bat[:any_1,:@1])
	#		:bat[:any_1,:@1] 
	#address CMDunaryAccumMIN 
	#comment "Unary - over the tail of the bat";

	#command --(a:bat[:any_1,:@1],b:bat[:any_1,:@1])
	#		:bat[:any_1,:@1] 
	#address CMDunaryAccumMINMIN 
	#comment "Unary -- over the tail of the bat";
	#
	#command ++(a:bat[:any_1,:@1],b:bat[:any_1,:@1])
	#		:bat[:any_1,:@1] 
	#address CMDunaryAccumPLUSPLUS 
	#comment "Unary ++ over the tail of the bat";
@mal
@:unary(oid)@
@:unary(bte)@
@:unary(sht)@
@:unary(int)@
@:unary(lng)@
@:unary(flt)@
@:unary(dbl)@
	command isnil(b:bat[:any_1,:str]):bat[:any_1,:bit] 
	address CMDunaryISNIL
	comment "Unary check for nil over the tail of the bat";
	command isnil(b:bat[:any_1,:bit]):bat[:any_1,:bit] 
	address CMDunaryISNIL
	comment "Unary check for nil over the tail of the bat";
	command isnil(b:bat[:any_1,:chr]):bat[:any_1,:chr] 
	address CMDunaryISNIL
	comment "Unary check for nil over the tail of the bat";
@-
@+ Comparison routines
The command signatures are similar to those above, producing a bit result.
@= comparison
	command @1(b:bat[:any_1,:@2], c:bat[:any_1,:@2]) :bat[:any_1,:bit]
	address CMD_@3_@2;
	command @1(a:bat[:any_1,:bit], b:bat[:any_1,:@2], c:bat[:any_1,:@2])
	:bat[:any_1,:bit]
	address CMDaccum_@3_@2;

	command @1(b:bat[:any_1,:@2],cst:@2) :bat[:any_1,:bit]
	address CMD_@3_@2_cst;

	command @1(a:bat[:any_1,:bit], b:bat[:any_1,:@2],cst:@2) :bat[:any_1,:bit]
	address CMDaccum_@3_@2_cst;
	command @1(a:bat[:any_1,:bit], cst:@2, b:bat[:any_1,:@2]) :bat[:any_1,:bit]
	address CMDaccum_@3_cst_@2;


@= compareGrp
	@:comparison(<,@1,LT)@
	@:comparison(==,@1,EQ)@
	@:comparison(!=,@1,NEQ)@
	@:comparison(>,@1,GT)@
	@:comparison(<=,@1,LE)@
	@:comparison(>=,@1,GE)@
@mal
	@:compareGrp(bit)@
	@:compareGrp(bte)@
	@:compareGrp(sht)@
	@:compareGrp(int)@
	@:compareGrp(lng)@
	@:compareGrp(dbl)@
	@:compareGrp(flt)@
	@:compareGrp(oid)@

	@:comparison(and,bit,AND)@
	@:comparison(or,bit,OR)@

@+ Boolean operations
The command signature can mostly be borrowed from the arithmetic.

@mal
command not(b:bat[:any_1,:bit]):bat[:any_1,:bit] 
address CMDbitbatNOT
comment "Return a new BAT with the negated tail";

command not(a:bat[:any_1,:bit], b:bat[:any_1,:bit]):bat[:any_1,:bit] 
address CMDbitbataccumNOT
comment "Return a BAT with the negated tail";

@- Implementation
@include kprelude.mx

@h
#include "gdk.h"
#include "math.h"
#include "mal_exception.h"

#ifdef WIN32
#ifndef LIBBATCALC
#define batcalc_export extern __declspec(dllimport)
#else
#define batcalc_export extern __declspec(dllexport)
#endif
#else
#define batcalc_export extern
#endif

#define NULLTST
@-
The accumulator operators are relatively straight forward,
when the target BAT is known and we only have to deal with
fixed-sized types. 
@-
@= accum
{
	@1 *o = (@1*)Tloc(bn, BUNfirst(bn));
	@3 *p = (@3*)Tloc(b, BUNfirst(b));
	@3 *q = (@3*)Tloc(b, BUNlast(b));
	@4 *r = (@4*)Tloc(right, BUNfirst(right));

	for (; p<q; o++, p++, r++){
		/* this code is better as x?nil:y  */
#ifdef NULLTST
		if(*p == @3_nil || *r == @4_nil)
			*o = @1_nil;
		else 
#endif
			*o = (@1) (*p @2 *r);
	}
}
@= accumCst
{
	@1 *o = (@1*)Tloc(bn, BUNfirst(bn)); 
	@3 *p = (@3*)Tloc(b, BUNfirst(b));
	@3 *q = (@3*)Tloc(b, BUNlast(b));
	@4 c  = *(@4*)cst;
#ifdef NULLTST
	if( c == @4_nil){
		for (;p<q; o++, p++) {
			*o = @1_nil;
		}
	} else
	for (;p<q; o++, p++) {
		if (*p == @3_nil )
			*o = @1_nil;
		else 
			*o = *p @2 c;
	}
#else
	for (;p<q; o++, p++) {
		*o = *p @2 c;
	}
#endif
}
@= accumCstLeft
{
	@1 *o = (@1*)Tloc(bn, BUNfirst(bn)); 
	@3 c  = *(@3*)cst;
	@4 *p = (@4*)Tloc(b, BUNfirst(b));
	@4 *q = (@4*)Tloc(b, BUNlast(b));
#ifdef NULLTST
	if (c == @3_nil)
		for (; p<q; o++, p++) {
			*o = @1_nil;
		}
	else
	for (; p<q; o++, p++) {
		if (*p == @4_nil )
			*o = @1_nil;
		else 
			*o = c @2 *p;
	}
#else
	for (; p<q; o++, p++) {
		*o = c @2 *p;
	}
#endif
}
@= accumCstDIV
{
	@1 *o = (@1*)Tloc(bn, BUNfirst(bn)); 
	@3 c  = *(@3*)cst;
	@4 *p = (@4*)Tloc(b, BUNfirst(b));
	@4 *q = (@4*)Tloc(b, BUNlast(b));

	for (; p<q; o++, p++) {
		if (c == 0) { 
			res = createException(ARITH, "batcalc.@1", "Division by zero");
			break;
		} else 
#ifdef NULLTST
		if (c == @3_nil || *p == @4_nil)
			*o = @1_nil;
		else 
#endif
			*o = c @2 *p;
	}
}
@-
A general assumption in all cases is the bats are synchronized on their
head column. This is not checked and may be mis-used to deploy the
implementation for shifted window arithmetic as well.
@= chkSize
	if( BATcount(@1) != BATcount(@2) )
	throw(MAL, "batcalc.@3", "requires bats of identical size");
@= tstBat
if( bn== NULL) {*ret= 0; 
	throw(MAL, "batcalc.@1", "can not create bat");}
@-
The code block below heavily uses the MX code expansion involved,
but in essence the structure is relatively simple.
The BAT loops to cover the cases for arithmetic are
collected in bataccum<operator>. Initialization of the
two primary command structures are dealt with in the CMD* alternatives.
The similar code base is produced for dealing with a constant argument. 
@= loopImpl
{	
	@3 *o = (@3*)Tloc(bn, BUNfirst(bn));
	@4 *p = (@4*)Tloc(b, BUNfirst(b));
	@4 *q = (@4*)Tloc(b, BUNlast(b));
	@5 *r = (@5*)Tloc(right, BUNfirst(right));

	if( '@1' == '/'){ 
		for(; p<q; o++, p++, r++) {
			/* this code is better as x?nil:y  */
			if (*r == 0) {
				res = createException(ARITH, "batcalc.@1", "Division by zero");
				break;
				
			} else 
#ifdef NULLTST
			if (*p == @4_nil || *r == @5_nil)
				*o = @3_nil;
			else 
#endif
				*o = (@3)(*p / *r);
		}
	} else {
		for(; p<q; o++, p++, r++) {
			/* this code is better as x?nil:y  */
#ifdef NULLTST
			if (*p == @4_nil || *r == @5_nil)
				*o = @3_nil;
			else 
#endif
				*o = (@3) (*p @1 *r);
		}
	}
}
@= arithmeticImpl
batcalc_export str CMDbat@2_@3_@4_@5(int *ret, int *l, int *r);
str CMDbat@2_@3_@4_@5(int *ret, int *l, int *r)
{	
	BAT *bn, *b, *right;
	char *res = MAL_SUCCEED;

	@:getBATdescriptor(l,b,"batcalc.@1")@
	@:getBATdescriptor(r,right,"batcalc.@1")@
	@:chkSize(b,right,CMDbat@2)@
	@:voidresultBAT(TYPE_@3,"batcalc.@1")@

	@:loopImpl(@1,@2,@3,@4,@5)@

	BATsetcount(bn, BATcount(b));
	bn->tsorted = 0;
	BATkey(BATmirror(bn),FALSE);

	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); 

	if (b->htype != bn->htype) {
		BAT *r = VIEWcreate(b,bn);

		BBPreleaseref(bn->batCacheid);
		bn = r;
	}
	BBPkeepref(*ret = bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	BBPreleaseref(right->batCacheid);
	return res;
}

batcalc_export str CMDbataccum@2_@3_@4_@5(int *ret, int *d, int *l, int *r);
str CMDbataccum@2_@3_@4_@5(int *ret, int *d, int *l, int *r)
{	
	BAT *bn, *b, *right;
	char *res = MAL_SUCCEED;

	@:getBATdescriptor(d,bn,"batcalc.@1")@
	@:getBATdescriptor(l,b,"batcalc.@1")@
	@:getBATdescriptor(r,right,"batcalc.@1")@

	@:chkSize(bn,b,CMDbataccum@2)@
	@:chkSize(bn,right,CMDbataccum@2)@

	@:loopImpl(@1,@2,@3,@4,@5)@

	bn->tsorted = 0;
	BATkey(BATmirror(bn),FALSE);

	BBPkeepref(*ret = bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	BBPreleaseref(right->batCacheid);
	return res;
}

batcalc_export str CMDbataccum@2cst_@3_@4_@5(int *ret, int *r, int *l, void *cst);
str CMDbataccum@2cst_@3_@4_@5(int *ret, int *r, int *l, void *cst)
{	
	BAT *bn, *b;
	char *res = MAL_SUCCEED;

	@:getBATdescriptor(r,bn,"batcalc.@1")@
	@:getBATdescriptor(l,b,"batcalc.@1")@
	@:chkSize(bn,b,CMDbataccum@2)@

	if( '@1'== '/') {
		if (*(@5*)cst == 0) {
			res = createException(ARITH, "batcalc.@1", "Division by zero");
		} else {
			@:accumCst(@3,@1,@4,@5)@ 
		}
	} else {
		@:accumCst(@3,@1,@4,@5)@ 
	}
	bn->tsorted = 0;
	BATkey(BATmirror(bn),FALSE);

	BBPkeepref(*ret = bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	return res;
}

batcalc_export str CMDbataccum@2cst2_@3_@4_@5(int *ret, int *l, void *cst, int *r);
str CMDbataccum@2cst2_@3_@4_@5(int *ret, int *l, void *cst, int *r)
{	
	BAT *bn, *b;
	char *res = MAL_SUCCEED;

	@:getBATdescriptor(l,bn,"batcalc.@1")@
	@:getBATdescriptor(r,b,"batcalc.@1")@
	@:chkSize(bn,b,CMDbataccum@2)@

	if( '@1'== '/') {
		@:accumCstDIV(@3,@1,@4,@5)@ 
	} else {
		@:accumCstLeft(@3,@1,@4,@5)@ 
	}
	bn->tsorted = 0;
	BATkey(BATmirror(bn),FALSE);

	BBPkeepref(*ret = bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	return res;
}

batcalc_export str CMDbat@2cst_@3_@4_@5(int *ret, int *l, void *cst);
str CMDbat@2cst_@3_@4_@5(int *ret, int *l, void *cst)
{	
	BAT *bn, *b;
	char *res = MAL_SUCCEED;

	@:getBATdescriptor(l,b,"batcalc.@1")@
	@:voidresultBAT(TYPE_@3,"batcalc.@1")@

	if( '@1'== '/') {
		if (*(@5*)cst == 0) {
			res = createException(ARITH, "batcalc.@1", "Division by zero");
		} else {
			@:accumCst(@3,@1,@4,@5)@ 
		}
	} else {
		@:accumCst(@3,@1,@4,@5)@ 
	}
	BATsetcount(bn, BATcount(b));
	bn->tsorted = 0;
	BATkey(BATmirror(bn),FALSE);

	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); 

	if (b->htype != bn->htype) {
		BAT *r = VIEWcreate(b,bn);

		BBPreleaseref(bn->batCacheid);
		bn = r;
	}
	BBPkeepref(*ret = bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	return res;
}
batcalc_export str CMDcst@2bat_@3_@4_@5(int *ret, void *cst, int *l);
str CMDcst@2bat_@3_@4_@5(int *ret, void *cst, int *l)
{	
	BAT *bn, *b;
	char *res = MAL_SUCCEED;

	@:getBATdescriptor(l,b,"batcalc.@1")@
	@:voidresultBAT(TYPE_@3,"batcalc.@1")@

	if( '@1'== '/') {
		@:accumCstDIV(@3,@1,@4,@5)@ 
	} else {
		@:accumCstLeft(@3,@1,@4,@5)@ 
	}
	BATsetcount(bn, BATcount(b));
	bn->tsorted = 0;
	BATkey(BATmirror(bn),FALSE);

	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); 

	if (b->htype != bn->htype) {
		BAT *r = VIEWcreate(b,bn);

		BBPreleaseref(bn->batCacheid);
		bn = r;
	}
	BBPkeepref(*ret = bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	return res;
}
@c
#include "mal_config.h"
#include "batcalc.h"

@= arithGrpImpl
@:arithmeticImpl(@1,@2,flt,flt,flt)@
@:arithmeticImpl(@1,@2,dbl,dbl,dbl)@
@:arithmeticImpl(@1,@2,oid,oid,oid)@

@:arithmeticImpl(@1,@2,int,int,sht)@
@:arithmeticImpl(@1,@2,int,sht,int)@
@:arithmeticImpl(@1,@2,int,sht,sht)@
@:arithmeticImpl(@1,@2,sht,sht,sht)@

@:arithmeticImpl(@1,@2,lng,lng,lng)@
@:arithmeticImpl(@1,@2,lng,sht,lng)@
@:arithmeticImpl(@1,@2,lng,lng,sht)@
@:arithmeticImpl(@1,@2,lng,sht,sht)@
@:arithmeticImpl(@1,@2,lng,sht,int)@
@:arithmeticImpl(@1,@2,lng,int,sht)@
@:arithmeticImpl(@1,@2,lng,int,lng)@
@:arithmeticImpl(@1,@2,lng,lng,int)@

@:arithmeticImpl(@1,@2,lng,int,int)@
@:arithmeticImpl(@1,@2,int,int,int)@

@c
@:arithGrpImpl(/,DIV)@
@:arithGrpImpl(*,MUL)@
@:arithGrpImpl(-,SUB)@
@:arithGrpImpl(+,ADD)@

@-  Modulo arithmetic
The Modulo function doesn;t work on all types. Therefore we 
define here the necessary implementations separately by copying
the arithmeticImpl block and removing elements not required.
@c
@= numeric_funcs
batcalc_export str bataccum@1_@3_@4_@5(BAT *bn, BAT *b, BAT *right);
str bataccum@1_@3_@4_@5(BAT *bn, BAT *b, BAT *right)
{	
	@:accum(@3,@2,@4,@5)@
	BATsetcount(bn, BATcount(b));
	bn->tsorted = 0;
	BATkey(BATmirror(bn),FALSE);

	return MAL_SUCCEED;
}

batcalc_export str CMDbat@1_@3_@4_@5(int *ret, int *l, int *r);
str CMDbat@1_@3_@4_@5(int *ret, int *l, int *r)
{	
	BAT *bn, *b, *right;
	str msg;

	@:getBATdescriptor(l,b,"batcalc.@1")@
	@:getBATdescriptor(r,right,"batcalc.@1")@
	@:chkSize(b,right,CMDbat@1)@
	@:voidresultBAT(TYPE_@3,"batcalc.@1")@

	msg = bataccum@1_@3_@4_@5(bn,b,right);

	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); 

	if (b->htype != bn->htype) {
		BAT *r = VIEWcreate(b,bn);

		BBPreleaseref(bn->batCacheid);
		bn = r;
	}
	BBPkeepref(*ret = bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	BBPreleaseref(right->batCacheid);
	return msg;
}

batcalc_export str CMDbataccum@1_@3_@4_@5(int *ret, int *d, int *l, int *r);
str CMDbataccum@1_@3_@4_@5(int *ret, int *d, int *l, int *r)
{	
	BAT *bn, *b, *right;
	str msg;

	@:getBATdescriptor(d,bn,"batcalc.@1")@
	@:getBATdescriptor(l,b,"batcalc.@1")@
	@:getBATdescriptor(r,right,"batcalc.@1")@
	@:chkSize(bn,b,CMDbataccum@1)@
	@:chkSize(bn,right,CMDbataccum@1)@

	msg = bataccum@1_@3_@4_@5(bn,b,right);

	BBPkeepref(*ret = bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	BBPreleaseref(right->batCacheid);
	return msg;
}
batcalc_export str CMDbataccum@1cst_@3_@4_@5(int *ret, int *r, int *l, void *cst);
str CMDbataccum@1cst_@3_@4_@5(int *ret, int *r, int *l, void *cst)
{	
	BAT *bn, *b;

	@:getBATdescriptor(r,bn,"batcalc.@1")@
	@:getBATdescriptor(l,b,"batcalc.@1")@
	@:chkSize(bn,b,CMDbataccum@1)@

	switch(BATttype(b)){
	case TYPE_oid: @:accumCst(oid,@2,oid,oid)@ break;
	case TYPE_sht: @:accumCst(sht,@2,sht,sht)@ break;
	case TYPE_int: @:accumCst(int,@2,int,int)@ break;
	case TYPE_lng: @:accumCst(lng,@2,lng,lng)@ break;
	default : throw(MAL, "batcalc.@1", "unexpected type");
	}
	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); 

	BBPkeepref(*ret = bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}

batcalc_export str CMDbataccum@1cst2_@3_@4_@5(int *ret, int *r, void *cst, int *l);
str CMDbataccum@1cst2_@3_@4_@5(int *ret, int *r, void *cst, int *l)
{	
	BAT *bn, *b;

	@:getBATdescriptor(r,bn,"batcalc.@1")@
	@:getBATdescriptor(l,b,"batcalc.@1")@
	@:chkSize(bn,b,CMDbataccum@1)@

	switch(BATttype(b)){
	case TYPE_oid: @:accumCstLeft(oid,@2,oid,oid)@ break;
	case TYPE_sht: @:accumCstLeft(sht,@2,sht,sht)@ break;
	case TYPE_int: @:accumCstLeft(int,@2,int,int)@ break;
	case TYPE_lng: @:accumCstLeft(lng,@2,lng,lng)@ break;
	default : throw(MAL, "batcalc.@1", "unexpected type");
	}

	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); 

	BBPkeepref(*ret = bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}

batcalc_export str CMDbat@1cst_@3_@4_@5(int *ret, int *l, void *cst);
str CMDbat@1cst_@3_@4_@5(int *ret, int *l, void *cst)
{	
	BAT *bn, *b;
	char *res = MAL_SUCCEED;

	@:getBATdescriptor(l,b,"batcalc.@1")@
	@:voidresultBAT(b->ttype,"batcalc.@1")@

	if( '@2'== '/') {
		if (*(@5*)cst == 0) {
			res = createException(ARITH, "batcalc.@1", "Division by zero");
		} else {
			@:accumCst(@3,@2,@4,@5)@ 
		}
	} else {
		@:accumCst(@3,@2,@4,@5)@ 
	}
	BATsetcount(bn, BATcount(b));
	bn->tsorted = 0;
	BATkey(BATmirror(bn),FALSE);

	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); 

	BBPkeepref(*ret = bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	return res;
}

batcalc_export str CMDcst@1bat_@3_@4_@5(int *ret,void *cst, int *l);
str CMDcst@1bat_@3_@4_@5(int *ret,void *cst, int *l)
{	
	BAT *bn, *b;
	char *res = MAL_SUCCEED;

	@:getBATdescriptor(l,b,"batcalc.@1")@
	@:voidresultBAT(TYPE_@3,"batcalc.@1")@

	if( '@2'== '/') {
		@:accumCstDIV(@3,@2,@4,@5)@ 
	} else {
		@:accumCstLeft(@3,@2,@4,@5)@ 
	}
	BATsetcount(bn, BATcount(b));
	bn->tsorted = 0;
	BATkey(BATmirror(bn),FALSE);

	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); 

	if (b->htype != bn->htype) {
		BAT *r = VIEWcreate(b,bn);

		BBPreleaseref(bn->batCacheid);
		bn = r;
	}
	BBPkeepref(*ret = bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	return res;
}
@c
@:numeric_funcs(MOD,%,oid,oid,oid)@
@:numeric_funcs(MOD,%,bte,bte,bte)@
@:numeric_funcs(MOD,%,sht,sht,sht)@
@:numeric_funcs(MOD,%,int,int,int)@
@:numeric_funcs(MOD,%,lng,lng,lng)@
@:numeric_funcs(XOR,^,oid,oid,oid)@
@:numeric_funcs(XOR,^,bte,bte,bte)@
@:numeric_funcs(XOR,^,sht,sht,sht)@
@:numeric_funcs(XOR,^,int,int,int)@
@:numeric_funcs(XOR,^,lng,lng,lng)@
@:numeric_funcs(AND,&,oid,oid,oid)@
@:numeric_funcs(AND,&,bte,bte,bte)@
@:numeric_funcs(AND,&,sht,sht,sht)@
@:numeric_funcs(AND,&,int,int,int)@
@:numeric_funcs(AND,&,lng,lng,lng)@
@:numeric_funcs(OR,|,oid,oid,oid)@
@:numeric_funcs(OR,|,bte,bte,bte)@
@:numeric_funcs(OR,|,sht,sht,sht)@
@:numeric_funcs(OR,|,int,int,int)@
@:numeric_funcs(OR,|,lng,lng,lng)@

@- Implementation of unary operations
@= accumUnary
	{
		@1* p = (@1*)Tloc(b,BUNfirst(b));
		@1 *q = (@1*)Tloc(b,BUNlast(b));
		@1 *o = (@1*)Tloc(bn,BUNfirst(bn));

		for(; p<q; p++, o++){
			/* this code is better as x?nil:y  */
#ifdef NULLTST
			if(*p == @1_nil )
				*o = @1_nil;
			else 
#endif
				*o = @2 *p;
		}
	}
@-
Unary accummulators are only called indirectly. They cannot
always be defined without signature clashes, eg. -(batA,batC).
@= unary_impl
batcalc_export str CMDunaryAccum@1(int *ret,int *did, int *bid);
str CMDunaryAccum@1(int *ret,int *did, int *bid)
{
	BAT *b,*bn;
	
	@:getBATdescriptor(did,bn,"batcalc.@1")@
	@:getBATdescriptor(bid,b,"batcalc.@1")@

	switch(BATttype(bn)){
	case TYPE_oid: @:accumUnary(oid,@2)@ break;
	case TYPE_bte: @:accumUnary(bte,@2)@ break;
	case TYPE_sht: @:accumUnary(sht,@2)@ break;
	case TYPE_int: @:accumUnary(int,@2)@ break;
	case TYPE_lng: @:accumUnary(lng,@2)@ break;
	case TYPE_flt: @:accumUnary(flt,@2)@ break;
	case TYPE_dbl: @:accumUnary(dbl,@2)@ break;
	default: throw(MAL, "batcalc.@1", "unexpected type");
	}
	bn->tsorted = 0;
	BATkey(BATmirror(bn),FALSE);

	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); 

	BBPkeepref(*ret = bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}
batcalc_export str CMDunary@1(int *ret, int *bid);
str CMDunary@1(int *ret, int *bid)
{
	BAT *b,*bn;
	
	@:getBATdescriptor(bid,b,"batcalc.@1")@
	@:voidresultBAT(b->ttype,"batcalc.@1")@

	switch(BATttype(bn)){
	case TYPE_oid: @:accumUnary(oid,@2)@ break;
	case TYPE_bte: @:accumUnary(bte,@2)@ break;
	case TYPE_sht: @:accumUnary(sht,@2)@ break;
	case TYPE_int: @:accumUnary(int,@2)@ break;
	case TYPE_lng: @:accumUnary(lng,@2)@ break;
	case TYPE_flt: @:accumUnary(flt,@2)@ break;
	case TYPE_dbl: @:accumUnary(dbl,@2)@ break;
	default: throw(MAL, "batcalc.@1", "unexpected type");
	}
	BATsetcount(bn, BATcount(b));
	bn->tsorted = 0;
	BATkey(BATmirror(bn),FALSE);

	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); 

	if (b->htype != bn->htype) {
		BAT *r = VIEWcreate(b,bn);

		BBPreleaseref(bn->batCacheid);
		bn = r;
	}
	BBPkeepref(*ret = bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}
@c
@:unary_impl(MIN,-)@
@:unary_impl(MINMIN,--)@
@:unary_impl(PLUSPLUS,++)@

@= accumUnaryISNIL
{
	@1 *p = (@1*)Tloc(b,BUNfirst(b)); 
	@1 *q = (@1*)Tloc(b,BUNlast(b)); 
	for(; p<q; p++, o++ ){
		if (*p == @1_nil)
			*o = TRUE;
		else 
			*o = FALSE;
	}
}
@c
batcalc_export str CMDunaryISNIL(int *ret, int *bid);
str CMDunaryISNIL(int *ret, int *bid)
{
	BAT *b,*bn;
	bit *o;
	
	@:getBATdescriptor(bid,b,"batcalc.isnil")@
	@:voidresultBAT(TYPE_bit,"batcalc.isnil")@

	o = (bit*)Tloc(bn,BUNfirst(bn)); 
	switch(BATttype(b)){
	case TYPE_bit: @:accumUnaryISNIL(bit)@ break;
	case TYPE_chr: @:accumUnaryISNIL(chr)@ break;
	case TYPE_bte: @:accumUnaryISNIL(bte)@ break;
	case TYPE_oid: @:accumUnaryISNIL(oid)@ break;
	case TYPE_sht: @:accumUnaryISNIL(sht)@ break;
	case TYPE_int: @:accumUnaryISNIL(int)@ break;
	case TYPE_lng: @:accumUnaryISNIL(lng)@ break;
	case TYPE_flt: @:accumUnaryISNIL(flt)@ break;
	case TYPE_dbl: @:accumUnaryISNIL(dbl)@ break;
	case TYPE_str: {
			BATiter bi = bat_iterator(b);
			BUN p,q;

			BATloop(b, p, q) {
				str t = (str) BUNtail(bi,p);
				if (strcmp(t, str_nil) == 0)
					*o = TRUE;
				else 
					*o = FALSE;
				o++;
			}
		} break;
	default: throw(MAL, "batcalc.isnil", "unexpected type");
	}
	BATsetcount(bn, BATcount(b));
	bn->tsorted = 0;
	BATkey(BATmirror(bn),FALSE);

	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); 

	if (b->htype != bn->htype) {
		BAT *r = VIEWcreate(b,bn);

		BBPreleaseref(bn->batCacheid);
		bn = r;
	}
	BBPkeepref(*ret = bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}

@- Operator implementation
The structure of this code is copied from the arithmetic scheme.
@= baselineCode
batcalc_export str CMD_@1_@3(int *ret, int *l, int *r);
str CMD_@1_@3(int *ret, int *l, int *r)
{	
	BAT *bn, *b, *right;
	@3 *p, *q, *t;
	bit *o;

	@:getBATdescriptor(l,b,"batcalc.@1")@
	@:getBATdescriptor(r,right,"batcalc.@1", BBPreleaseref(b->batCacheid);)@
	@:chkSize(b,right,batcalc.@1)@
	@:voidresultBAT(TYPE_bit,"batcalc.@1")@

	o = (bit*)Tloc(bn,BUNfirst(bn));
	p = (@3*)Tloc(b,BUNfirst(b));
	q = (@3*)Tloc(b,BUNlast(b));
	t = (@3*)Tloc(right,BUNfirst(right));
		
	for (;p<q; p++, t++, o++) {
		if (*p == @3_nil || *t == @3_nil)
			*o = bit_nil;
		else 
			*o = (*p @2 *t);
	}
	BATsetcount(bn, BATcount(b));
	bn->tsorted = 0;
	BATkey(BATmirror(bn),FALSE);

	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); 

	if (b->htype != bn->htype) {
		BAT *r = VIEWcreate(b,bn);

		BBPreleaseref(bn->batCacheid);
		bn = r;
	}
	BBPkeepref(*ret= bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	BBPreleaseref(right->batCacheid);
	return MAL_SUCCEED;
}

batcalc_export str CMDaccum_@1_@3(int *ret, int *d, int *l, int *r);
str CMDaccum_@1_@3(int *ret, int *d, int *l, int *r)
{	
	BAT *bn, *b, *right;
	@3 *p, *q, *t;
	bit *o;

	@:getBATdescriptor(l,b,"batcalc.@1")@
	@:getBATdescriptor(r,right,"batcalc.@1", BBPreleaseref(b->batCacheid);)@
	@:getBATdescriptor(d,bn,"batcalc.@1", BBPreleaseref(b->batCacheid);BBPreleaseref(right->batCacheid);)@
	@:chkSize(bn,b,batcalc.@1)@
	@:chkSize(bn,right,batcalc.@1)@

	o = (bit*)Tloc(bn,BUNfirst(bn));
	p = (@3*)Tloc(b,BUNfirst(b));
	q = (@3*)Tloc(b,BUNlast(b));
	t = (@3*)Tloc(right,BUNfirst(right));
		
	for (;p<q; p++, t++, o++) {
		if (*p == @3_nil || *t == @3_nil)
			*o = bit_nil;
		else 
			*o = (*p @2 *t);
	}
	BATsetcount(bn, BATcount(b));
	bn->tsorted = 0;
	BATkey(BATmirror(bn),FALSE);

	BBPkeepref(*ret= bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	BBPreleaseref(right->batCacheid);
	return MAL_SUCCEED;
}
@= baselineCstCode
batcalc_export str CMD_@1_@3_cst(int *ret, int *l, @3 *cst);
str CMD_@1_@3_cst(int *ret, int *l, @3 *cst)
{	
	BAT *bn, *b;
	@3 *p, *q;
	bit *o;

	@:getBATdescriptor(l,b,"batcalc.@1")@
	@:voidresultBAT(TYPE_bit,"batcalc.@1")@

	o = (bit*)Tloc(bn,BUNfirst(bn));
	p = (@3*)Tloc(b,BUNfirst(b));
	q = (@3*)Tloc(b,BUNlast(b));
		
	for (;p<q; p++, o++) {
		if( *p == @3_nil || *cst == @3_nil)
			*o = bit_nil;
		else 
			*o = (*p @2 *cst);
	}
	BATsetcount(bn, BATcount(b));
	bn->tsorted = 0;
	BATkey(BATmirror(bn),FALSE);

	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);

	if (b->htype != bn->htype) {
		BAT *r = VIEWcreate(b,bn);

		BBPreleaseref(bn->batCacheid);
		bn = r;
	}
	BBPkeepref(*ret= bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}
batcalc_export str CMD_@4_cst_@3(int *ret, @3 *cst, int *l);
str CMD_@4_cst_@3(int *ret, @3 *cst, int *l) 
{
	return CMD_@1_@3_cst(ret,l,cst);
}

batcalc_export str CMDaccum_@1_@3_cst(int *ret, int *r, int *l, @3 *cst);
str CMDaccum_@1_@3_cst(int *ret, int *r, int *l, @3 *cst)
{	
	BAT *bn, *b;
	@3 *p, *q;
	bit *o;

	@:getBATdescriptor(r,bn,"batcalc.@1")@
	@:getBATdescriptor(l,b,"batcalc.@1", BBPreleaseref(bn->batCacheid);)@
	@:chkSize(bn,b,batcalc.@1)@

	o = (bit*)Tloc(bn,BUNfirst(bn));
	p = (@3*)Tloc(b,BUNfirst(b));
	q = (@3*)Tloc(b,BUNlast(b));
		
	for (;p<q; p++, o++) {
		if (*p == @3_nil || *cst == @3_nil)
			*o = bit_nil;
		else 
			*o = (*p @2 *cst);
	}

	bn->tsorted = 0;
	BATkey(BATmirror(bn),FALSE);

	BBPkeepref(*ret= bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}
batcalc_export str CMDaccum_@4_cst_@3(int *ret, int *r, @3 *cst, int *l);
str CMDaccum_@4_cst_@3(int *ret, int *r, @3 *cst, int *l)
{
	return CMDaccum_@1_@3_cst(ret, r, l, cst);
}

@-
@= operatorImpl
	@:baselineCode(@1,@2,bit)@
	@:baselineCode(@1,@2,bte)@
	@:baselineCode(@1,@2,sht)@
	@:baselineCode(@1,@2,int)@
	@:baselineCode(@1,@2,lng)@
	@:baselineCode(@1,@2,oid)@
	@:baselineCode(@1,@2,flt)@
	@:baselineCode(@1,@2,dbl)@
@= operatorCstImpl
	@:baselineCstCode(@1,@2,bit,@3)@
	@:baselineCstCode(@1,@2,bte,@3)@
	@:baselineCstCode(@1,@2,sht,@3)@
	@:baselineCstCode(@1,@2,int,@3)@
	@:baselineCstCode(@1,@2,lng,@3)@
	@:baselineCstCode(@1,@2,oid,@3)@
	@:baselineCstCode(@1,@2,flt,@3)@
	@:baselineCstCode(@1,@2,dbl,@3)@
@c
@:operatorImpl(GE,>=)@
@:operatorImpl(LE,<=)@
@:operatorImpl(GT,>)@
@:operatorImpl(LT,<)@
@:operatorImpl(EQ,==)@
@:operatorImpl(NEQ,!=)@
@:operatorImpl(AND,&&)@
@:operatorImpl(OR,||)@

@:operatorCstImpl(GE,>=,LT)@
@:operatorCstImpl(LT,<,GE)@
@:operatorCstImpl(GT,>,LE)@
@:operatorCstImpl(LE,>=,GT)@
@:operatorCstImpl(EQ,==,NEQ)@
@:operatorCstImpl(NEQ,!=,EQ)@
@:operatorCstImpl(AND,&&,AND)@
@:operatorCstImpl(OR,||,OR)@

batcalc_export str CMDbitbataccumNOT(int *ret, int *d, int *l);
str
CMDbitbataccumNOT(int *ret, int *d, int *l)
{
	BAT *bn, *b;
	bit *p, *q, *o;

	@:getBATdescriptor(d,bn,"batcalc.not")@
	@:getBATdescriptor(l,b,"batcalc.not",BBPreleaseref(bn->batCacheid);)@
	@:chkSize(bn,b,batcalc.not)@

	p = (bit*) Tloc(bn,BUNfirst(bn));
	q = (bit*) Tloc(bn,BUNlast(bn));
	o = (bit*) Tloc(b,BUNfirst(b));

	for (;p<q; p++, o++) {
		if (*o == bit_nil)
			*p = bit_nil;
		else 
			*p = ! *o;
	}
	bn->tsorted = 0;
	BATkey(BATmirror(bn),FALSE);

	BBPkeepref(*ret= bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}

batcalc_export str CMDbitbatNOT(int *ret, int *bid);
str
CMDbitbatNOT(int *ret, int *bid)
{
	BAT *bn, *b;
	bit *p, *q, *o;

	@:getBATdescriptor(bid,b,"batcalc.not")@
	@:voidresultBAT(TYPE_bit,"batcalc.not")@

	o = (bit*) Tloc(bn,BUNfirst(bn));
	p = (bit*) Tloc(b,BUNfirst(b));
	q = (bit*) Tloc(b,BUNlast(b));

	for (;p<q; p++, o++) {
		if (*p == bit_nil)
			*o = bit_nil;
		else 
			*o = ! *p;
	}
	BATsetcount(bn, BATcount(b));
	bn->tsorted = 0;
	BATkey(BATmirror(bn),FALSE);

	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);

	if (b->htype != bn->htype) {
		BAT *r = VIEWcreate(b,bn);

		BBPreleaseref(bn->batCacheid);
		bn = r;
	}

	BBPkeepref(*ret = bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}
@}
