@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f alarm
@a M.L. Kersten, P. Boncz

@* Timers and Timed Interrupts
This module handles various signaling/timer functionalities.
The Monet interface supports two timer commands: @emph{ alarm} and @emph{ sleep}.
Their argument is the number of seconds to wait before the timer goes off.
The @emph{ sleep} command blocks till the alarm goes off.
The @emph{ alarm} command continues directly, executes off a MIL
string when it goes off.
The parameterless routines @emph{ time} and @emph{ ctime} provide access to
the cpu clock.They return an integer and string, respectively.

@mal
module alarm;

command sleep(secs:int):void 
address ALARMsleep 
comment "sleep X secs";
command alarm(secs:int, action:str):void 
address ALARMsetalarm 
comment "execute action in X secs";
command timers() :bat[:str,:str] 
address ALARMtimers
comment "give a list of all active timers";
command usec() :lng 
address ALARMusec
comment "return cpu microseconds info";
command time() :int 
address ALARMtime 
comment "time in millisecs";
command epoch() :int 
address ALARMepoch 
comment "current time as unix epoch";
command ctime() :str 
address ALARMctime 
comment "current time as a string";
command prelude():void
address ALARMprelude 
comment "Initialize alarm module";
command epilogue():void
address ALARMepilogue 
comment "Finalize alarm module";

alarm.prelude();

@{
@* Implementation
@+ The Clock Interrupt Generator
A clock event generator, called @%timer@, has been added to the database kernel.
It accepts a message @%CLKalarm(sec, usec)@, which generates an alarm
after the time indicated.
The timer maintains a small stack of timing events sorted in priority of firing.
The top contains the next timer event to go off.
The timer is disabled when no timer events are outstanding.
@h
#include <mal.h>
#include <signal.h>
#define MAXtimer                200

typedef struct {
	str action;		/* MIL action (as a string) */
	MT_Sema sema;		/* barrier */
	time_t alarm_time;	/* time when the alarm goes off */
} monet_timer_t;

@c
#include "alarm.h"
#include <time.h>

mal_export str ALARMprelude();
mal_export str ALARMepilogue();
mal_export str ALARMusec(lng *ret);
mal_export str ALARMsleep(int *res, int *secs);
mal_export str ALARMsetalarm(int *res, int *secs, str *action);
mal_export str ALARMtimers(int *res);
mal_export str ALARMctime(str *res);
mal_export str ALARMepoch(int *res);
mal_export str ALARMtime(int *res);

static monet_timer_t timer[MAXtimer];
static int timerTop = 0;

@
@-
The timer is awakened by a clock interrupt. The interrupt granularity
is OS-dependent. The timer should be initialized as long as there
are outstanding timer events.
@c
void
CLKinitTimer(int sec, int usec)
{
	int i = sec - time(0);

	(void) usec;
	TRGDEBUG THRprintf(GDKerr, "CLKinitTimer: set timer to %d secs \n", i);

#ifdef SIGALRM
	alarm(i);
#endif
}
@-
A new alarm is pushed onto the stack using @%CLKalarm@.
The parameter is the real-time value to be approximated.
@c
#ifdef SIGALRM
MT_Sema
CLKalarm(time_t t, str action)
{
	int j;
	int k;

	TRGDEBUG THRprintf(GDKerr, "CLKalarm: push %d \n", t);

	if (timerTop == MAXtimer) {
		GDKerror("CLKalarm: timer stack overflow\n");
		return 0;
	}
	for (j = 0; j < timerTop; j++) {
		if (timer[j].alarm_time > t)
			break;
	}
	for (k = timerTop; k > j; k--) {
		timer[k] = timer[k - 1];
	}
	timer[k].alarm_time = t;
	if (action) {
		timer[k].action = GDKstrdup(action);
	} else {
		timer[k].action = 0;
		timer[k].sema = MT_create_sema(0);
	}
	if (k == timerTop++) {
		CLKinitTimer(t, 0);	/* set it sooner */
	}
	return timer[k].sema;
}
#endif
@-
Once a timer interrupt occurs, we should inspect the timer queue and
emit a notify signal.
@c
#ifdef SIGALRM
/* HACK to pacify compiler */
#if (defined(__INTEL_COMPILER) && (SIZEOF_VOID_P > SIZEOF_INT))
#undef  SIG_ERR			/*((__sighandler_t)-1 ) */
#define SIG_ERR   ((__sighandler_t)-1L)
#endif
static RETSIGTYPE
CLKsignal(int nr)
{
	/* int restype; */
	int k = timerTop;
	int t;

	(void) nr;

	if (signal(SIGALRM, CLKsignal) == SIG_ERR) {
		GDKsyserror("CLKsignal: call failed\n");
	}
	TRGDEBUG THRprintf(GDKerr, "alarm signal (timeTop=%d)\n", timerTop);

	if (timerTop == 0) {
		return;
	}
	t = time(0);
	while (k-- && t >= timer[k].alarm_time) {
		if (timer[k].action) {
			TRGDEBUG THRprintf(GDKerr, "eval(%s)\n", timer[k].action);

			/* monet_eval(timer[k].action, &restype); */
			GDKfree(timer[k].action);
		} else {
			MT_up_sema(timer[k].sema, "CLKsignal");
		}
		timerTop--;
	}
	if (timerTop > 0) {
		CLKinitTimer(timer[timerTop - 1].alarm_time, 0);
	}
}
#endif

bat *
CLKprelude(void)
{
#ifdef SIGALRM
	(void) signal(SIGALRM, CLKsignal);
#endif
	return NULL;
}

void
CLKepilogue(void)
{
	int k;

#if (defined(SIGALRM) && defined(SIG_IGN))
/* HACK to pacify compiler */
#if (defined(__INTEL_COMPILER) && (SIZEOF_VOID_P > SIZEOF_INT))
#undef  SIG_IGN			/*((__sighandler_t)1 ) */
#define SIG_IGN   ((__sighandler_t)1L)
#endif
	(void) signal(SIGALRM, SIG_IGN);
#endif
	for (k = 0; k < timerTop; k++) {
		if (timer[k].action)
			GDKfree(timer[k].action);
	}
}


int
CMDsleep(int *secs)
{

	if (*secs < 0) {
		GDKerror("CMDsleep: negative delay\n");
		return GDK_FAIL;
	} else {
		MT_sleep_ms(*secs * 1000);
	}
	return GDK_SUCCEED;
}

int
CMDalarm(int *secs, str action)
{
	if (*secs < 0) {
		GDKerror("CMDalarm: negative delay\n");
		return GDK_FAIL;
	} else {
#ifndef SIGALRM
		GDKerror("CMDalarm: not implemented\n");
		return GDK_FAIL;
#else
		(void) CLKalarm(time(0) + *secs, action);
#endif
	}
	return GDK_SUCCEED;
}

@-
Problem with CMDtimers is that they use static buffers that
may be overwritten under parallel processing.
Therefore, the code below is dangerous (!) and the re-entrant code
should be used.
@c
int
CMDtimers(BAT **retval)
{
	char buf[27];
	int k;

	*retval = BATnew(TYPE_str, TYPE_str, timerTop);
	if (*retval == NULL)
		return GDK_FAIL;
	BATroles(*retval, "alarm", "action");
	for (k = 0; k < timerTop; k++) {
		time_t t = timer[k].alarm_time;

#ifdef HAVE_CTIME_R3
		ctime_r(&t, buf, 26);
#else
#ifdef HAVE_CTIME_R
		ctime_r(&t, buf);
#else
		ctime(&t);
#endif
#endif
		if (buf)
			BUNins(*retval, buf, timer[k].action ? timer[k].action : "barrier");
	}
	return GDK_SUCCEED;
}

int
CMDctime(str *retval)
{
	time_t t = time(0);

#ifdef HAVE_CTIME_R3
	char buf[128];

	*retval = GDKstrdup((char *) ctime_r(&t, buf, 26));
#else
#ifdef HAVE_CTIME_R
	char buf[128];

	*retval = GDKstrdup((char *) ctime_r(&t, buf));
#else
	*retval = GDKstrdup((char *) ctime(&t));
#endif
#endif
	return GDK_SUCCEED;
}

int
CMDepoch(int *retval)
{
	*retval = time(0);
	return GDK_SUCCEED;
}

int
CMDusec(lng *retval)
{
	*retval = GDKusec();
	return GDK_SUCCEED;
}

int
CMDtime(int *retval)
{
	*retval = GDKms();
	return GDK_SUCCEED;
}

@- Wrapping
Wrapping the Version 4 code base
@c
#include "mal.h"
#include "mal_exception.h"

void
ALARMinitTimer(int sec, int usec)
{
	CLKinitTimer(sec, usec);
}

#ifdef SIGALRM
MT_Sema
ALARMalarm(int t, str *action)
{
	CLKalarm(t, *action);
	return MAL_SUCCEED;
}
#endif

#ifdef SIGALRM
static RETSIGTYPE
ALARMsignal(int nr)
{
	CLKsignal(nr);
}
#endif

str
ALARMprelude()
{
#ifdef SIGALRM
	(void) signal(SIGALRM, (void (*)()) CLKsignal);
#endif
	return MAL_SUCCEED;
}

str
ALARMepilogue()
{
	CLKepilogue();
	return MAL_SUCCEED;
}

str
ALARMusec(lng *ret)
{
	CMDusec(ret);
	return MAL_SUCCEED;
}

str
ALARMsleep(int *res, int *secs)
{
	(void) res;		/* fool compilers */
	CMDsleep(secs);
	return MAL_SUCCEED;
}

str
ALARMsetalarm(int *res, int *secs, str *action)
{
	(void) res;
	(void) secs;
	(void) action;		/* foolc compiler */
	return throwMessage("alarm.setalarm", "not yet implemented");
}

str
ALARMtimers(int *res)
{
	(void) res;		/* fool compiler */
	return throwMessage("alarm.timers", "not yet implemented");
}

str
ALARMctime(str *res)
{
	CMDctime(res);
	return MAL_SUCCEED;
}

str
ALARMepoch(int *res)
{
	CMDepoch(res);
	return MAL_SUCCEED;
}

str
ALARMtime(int *res)
{
	CMDtime(res);
	return MAL_SUCCEED;
}

@}
