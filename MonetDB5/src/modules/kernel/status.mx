@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f status
@a M.L. Kersten, P. Boncz, N.Nes
@v 2.0
@* System state information 
This document introduces a series of bats  and operations that provide access
to information stored within the Monet Version 5 internal data structures.
In all cases, pseudo BAT operation returns a transient BAT that
should be garbage collected after being used.

The main performance drain would be to use a pseudo BAT directly to
successively access it components. This can be avoided by first assigning
the pseudo BAT to a variable.

@mal
module status;

command cpuStatistics() :bat[:str,:int] 
address SYScpuStatistics
comment "Global cpu usage information";
command memStatistics():bat[:str,:int] 
address SYSmemStatistics
comment "Global memory usage information";
command ioStatistics():bat[:str,:int] 
address SYSioStatistics
comment "Global IO activity information";
#command memMap() :void 
#address SYSmemMap
#comment "Print a map of all memory that is in use";
@-

For each 64KB block in the first 3GB of the virtual memory @emph{mem_printmap()} 
prints a character:
@multitable @columnfractions 0.05 0.7
@item 0-9 
@tab - thread stack space of thread <num>
@item B 
@tab - in use for a large BAT heap 
   (i.e. anonymous virtual memory).
@item b 
@tab - free (last usage was B)
@item S 
@tab - in use for a malloc block
@item s 
@tab - free (last usage was S)
@item P 
@tab - in use for the BBP array 
   (i.e. anonymous virtual memory)
@item p 
@tab - free (last usage was P)
@item M 
@tab - in use as memory mapped region
@item m 
@tab - free (last usage was M)
@item C 
@tab - in use as MIL context buffer 
   (i.e. anonymous virtual memory)
@item c 
@tab - free (last usage was M)
@end multitable

On Linux, the malloc library appears to be using anonymous virtual memory, 
which goes undetected.  If you want to see all your memory in the map, 
lower the gdk_mmap threshold in MonetDB5.conf to a low value (say 64KB).
@-
@mal
command vmUsage(minsize:lng) :bat[:str,:lng] 
address SYSvm_usage
comment "Get a split-up of how much virtual 
	 memory blocks are in use.";
command memUsage(minsize:lng) :bat[:str,:lng] 
address SYSmem_usage
comment "Get a split-up of how much memory 
	 blocks are in use.";
@-
Some explanation of what mem_usage() and vm_usage() display:
@verbatim
> mem_usage.print;
#------------------------------#
# BAT:                 tmp_42  #
# (str)                (lng)   #
#------------------------------#
[ "buns/car_category",  400012 ] 100.000 string offsets
[ "buns/car_town",      400012 ] idem
[ "buns/car_class",     400012 ] idem
[ "tail/car_category",  266244 ] string tail heap
[ "tail/car_town",      266244 ] idem
[ "tail/car_class",     266244 ] idem
[ "_tot/buns",         1322996 ] the three bun heaps
[ "_tot/tail",          967762 ] the three tail heaps
[ "_tot/head",           70984 ] negligable
[ "_tot/bbp",            98866 ] BBP metadata structure
[ "_tot/mil",           102400 ] MIL interpreter stack space
[ "_tot/found",        2590144 ] buns+head+tail+bbp+mil
[ "_tot/malloc_heap",  2956048 ] in malloc heap
[ "_tot/malloc",       2956048 ] total consumed via malloc
[ "_tot/valloc",        201266 ] total consumed via virtualalloc
[ "_tot/mem",          3157314 ] total RAM+swap-file consumption

>
> vm_usage.print;
#------------------------------#
# BAT:               tmp_42    #
# (str)              (lng)     #
#------------------------------#
[ "_tot/bbp",        50331648  ] 50MB reserved (100KB claimed)
[ "_tot/mil",        16777216  ] 16MB reserved (100KB claimed)
[ "_tot/found",      67108864  ] bbp+mil
[ "_tot/vm",         71244560  ] total address space consumption
>
@end verbatim
@+ MAL runtime status 
@mal
command gdkEnv( ):bat[:str,:str] 
address SYSgdkEnv
comment "Pseudo bat to map thread to name";
command gdkThread( ):bat[:int,:str] 
address SYSgdkThread
comment "Pseudo bat to map thread to name";

command mem_cursize() :lng 
address SYSgetmem_cursize
comment "the amount of physical swapspace in KB that is currently in use";

command mem_maxsize() :lng 
address SYSgetmem_maxsize
comment "the maximum usable amount of physical swapspace in KB (target only)";

command mem_maxsize(v:lng) :void 
address set_mem_maxsize
comment "set the maximum usable amount of physical swapspace in KB";

command vm_cursize() :lng 
address SYSgetvm_cursize
comment "the amount of logical VM space in KB that is currently in use";

command vm_maxsize() :lng 
address SYSgetvm_maxsize
comment "the maximum usable amount of logical VM space in KB (target only)";

command vm_maxsize(v:lng) :void 
address SYSsetvm_maxsize
comment "set the maximum usable amount of physical swapspace in KB";
@{
@* Implementation Code
@h
#ifndef _SYS_H_
#define _SYS_H_
#endif
@-

@= Pseudo
        if (BBPindex("view_@1_@2") <= 0)
                BATname(b, "@2");
        BATroles(b,"@1","@2");
        BATmode(b,TRANSIENT);
        BATfakeCommit(b);
        *ret = b->batCacheid;
@c
#include "gdk.h"
#include <stdarg.h>
#include <time.h>
#include "mal_exception.h"

#ifdef HAVE_SYS_TIMES_H
#include <sys/times.h>
#include <stream.h>
#endif
#ifndef NATIVE_WIN32
# ifndef HZ
#  define HZ CLK_TCK
# endif
#endif

extern lng GDKcur_cursize();
mal_export str SYSgetmem_cursize(lng *num);
str
SYSgetmem_cursize(lng *num)
{
	*num = GDKmem_cursize();
	return MAL_SUCCEED;
}

mal_export str SYSgetmem_maxsize(lng *num);
str
SYSgetmem_maxsize(lng *num)
{
	*num = GDK_mem_maxsize;
	return MAL_SUCCEED;
}

mal_export str set_mem_maxsize(lng *num);
str
set_mem_maxsize(lng *num)
{
	GDK_mem_maxsize = (size_t) *num;
	return MAL_SUCCEED;
}

mal_export str SYSgetvm_cursize(lng *num);
str
SYSgetvm_cursize(lng *num)
{
	*num = GDKvm_cursize();
	return MAL_SUCCEED;
}

mal_export str SYSgetvm_maxsize(lng *num);
str
SYSgetvm_maxsize(lng *num)
{
	*num = GDK_vm_maxsize;
	return MAL_SUCCEED;
}

mal_export str SYSsetvm_maxsize(lng *num);
str
SYSsetvm_maxsize(lng *num)
{
	GDK_vm_maxsize = (size_t) *num;
	return MAL_SUCCEED;
}

/*
str memMap() {
        MT_alloc_print();
        return MAL_SUCCEED;
}
*/
@
@c
static int clk = 0;
#ifdef HAVE_TIMES
static struct tms state;
#endif

mal_export str SYScpuStatistics(int *ret);
str
SYScpuStatistics(int *ret)
{
	int i;
#ifdef HAVE_TIMES
	struct tms newst;
#endif
	BAT *b;


	b = BATnew(TYPE_str, TYPE_int, 32);
	if (b == 0)
		return throwMessage("catalog.gdkCpu", "failed to create BAT");
	if (clk == 0) {
		clk = time(0);
#ifdef HAVE_TIMES
		times(&state);
#endif
	}

#ifdef HAVE_TIMES
	times(&newst);
#endif
	/* store counters, ignore errors */
	i = time(0) - clk;
	b = BUNins(b, "elapsed", &i);
#ifdef HAVE_TIMES
	i = newst.tms_utime * 1000 / HZ;
	b = BUNins(b, "user", &i);
	i = (newst.tms_utime - state.tms_utime) * 1000 / HZ;
	b = BUNins(b, "elapuser", &i);
	i = newst.tms_stime * 1000 / HZ;
	b = BUNins(b, "system", &i);
	i = (newst.tms_stime - state.tms_stime) * 1000 / HZ;
	b = BUNins(b, "elapsystem", &i);

	state = newst;
#endif
	@:Pseudo(gdk,cpu)@
	return MAL_SUCCEED;
}

@-
Same observations as to SYScpuStatistics()
@c
#ifdef HAVE_SBRK
static void *memincr = NULL;
#endif
mal_export str SYSmemStatistics(int *ret);
str
SYSmemStatistics(int *ret)
{
	struct mallinfo m;
	BAT *b;
	int i;

	m = MT_mallinfo();

	b = BATnew(TYPE_str, TYPE_int, 32);
	if (b == 0)
		return throwMessage("catalog.memStatistics", "failed to create BAT");

	/* store counters, ignore errors */
#ifdef HAVE_SBRK
	if (memincr == NULL) {
		memincr = (char *) sbrk(0);
	}
	i = ((char *) sbrk(0) - (char *) memincr);

	memincr = (char *) sbrk(0);
	b = BUNins(b, "memincr", &i);
#endif
	i = m.arena;
	b = BUNins(b, "arena", &i);
	i = m.ordblks;
	b = BUNins(b, "ordblks", &i);
	i = m.smblks;
	b = BUNins(b, "smblks", &i);
	i = m.hblkhd;
	b = BUNins(b, "hblkhd", &i);
	i = m.hblks;
	b = BUNins(b, "hblks", &i);
	i = m.usmblks;
	b = BUNins(b, "usmblks", &i);
	i = m.fsmblks;
	b = BUNins(b, "fsmblks", &i);
	i = m.uordblks;
	b = BUNins(b, "uordblks", &i);
	i = m.fordblks;
	b = BUNins(b, "fordblks", &i);
	@:Pseudo(gdk,mem)@
	return MAL_SUCCEED;
}

@= heap
if (@2) {
	sz = HEAP@1size(@3);
	if (sz > *minsize) {
		sprintf(buf, "@4/%s", s); 
		BUNins(bn, buf, &sz);
	} @4 += sz; tot += sz;
}
@c

mal_export str SYSmem_usage(int *ret, lng *minsize);
str
SYSmem_usage(int *ret, lng *minsize)
{
	lng buns = 0, hhsh = 0, thsh = 0;
	lng head = 0, tail = 0;
	lng tot = 0, n = 0, sz;
	BAT *bn = BATnew(TYPE_str, TYPE_lng, 2 * BBPsize);
	char buf[1024];
	bat i;

	BBPlock("SYSmem_usage");
	for (i = 1; i < BBPsize; i++) {
		BAT *b = BBP_cache(i);
		str s = BBP_logical(i);

		if (s == NULL) {
			continue;
		}
		sz = 0;
		if (BBP[i].cache)
			sz += sizeof(BATstore);
		if (BBP[i].nme[0])
			n += strLen(BBP[i].nme[0]);
		if (BBP[i].nme[1])
			n += strLen(BBP[i].nme[1]);
		if (BBP[i].path)
			n += strLen(BBP[i].path);
		if (b)
			sz += sizeof(BAT);	/* mirror */

		if (sz > *minsize) {
			sprintf(buf, "desc/%s", s);
			BUNins(bn, buf, &sz);
		}
		tot += (lng) sz;

		if (b == NULL || VIEWparent(b)) {
			continue;
		}
		@:heap(mem, b->batBuns, b->batBuns, buns)@
		@:heap(mem, b->hhash, b->hhash->heap, hhsh)@
		@:heap(mem, b->thash, b->thash->heap, thsh)@
		@:heap(mem, b->hheap, b->hheap, head)@
		@:heap(mem, b->theap, b->theap, tail)@
	}
	/* totals per category */
	if (buns)
		BUNins(bn, "_tot/buns", &buns);
	if (head)
		BUNins(bn, "_tot/head", &head);
	if (tail)
		BUNins(bn, "_tot/tail", &tail);
	if (hhsh)
		BUNins(bn, "_tot/hhsh", &hhsh);
	if (thsh)
		BUNins(bn, "_tot/thsh", &thsh);

	/* special area 1: BBP rec */
	sz = BBPlimit * sizeof(BBPrec) + n;
	if (sz)
		BUNins(bn, "_tot/bbp", &sz);
	tot += sz;

/* special area 2: monet context records 
	DEPRICATED
	sz = monet_cntxtmax*sizeof(CntxtRec);
	if (sz) BUNins(bn, "_tot/mil", &sz);
*/
	tot += sz;
	if (tot)
		BUNins(bn, "_tot/found", &tot);
	sz = GDKmem_heapsize();
	if (sz)
		BUNins(bn, "_tot/sbrk", &sz);
/*	compilation errors !
	if (GDK_mem_cursize) BUNins(bn, "_tot/valloc", &GDK_mem_cursize);

*/
	sz = GDKmem_heapinuse();
	if (sz)
		BUNins(bn, "_tot/malloc", &sz);
	sz = sz + GDKmem_cursize() - tot;
	if (sz)
		BUNins(bn, "_tot/malloc_unknown", &sz);
	sz = GDKmem_cursize();
	if (sz)
		BUNins(bn, "_tot/all", &sz);
	BBPunlock("SYSmem_usage");

	*ret = bn->batCacheid;
	return MAL_SUCCEED;
}

/*
str SYSmemMap() {
        MT_alloc_print();
        return MAL_SUCCEED;
}
*/


mal_export str SYSvm_usage(int *ret, lng *minsize);
str
SYSvm_usage(int *ret, lng *minsize)
{
	lng buns = 0, hhsh = 0, thsh = 0;
	lng head = 0, tail = 0, tot = 0, sz;
	BAT *bn = BATnew(TYPE_str, TYPE_lng, 2 * BBPsize);
	char buf[1024];
	bat i;

	BBPlock("SYSvm_usage");
	for (i = 1; i < BBPsize; i++) {
		BAT *b = BBP_cache(i);
		str s = BBP_logical(i);

		if (s == NULL || b == NULL || VIEWparent(b)) {
			continue;
		}
		@:heap(vm, b->batBuns, b->batBuns, buns)@
		@:heap(vm, b->hhash, b->hhash->heap, hhsh)@
		@:heap(vm, b->thash, b->thash->heap, thsh)@
		@:heap(vm, b->hheap, b->hheap, head)@
		@:heap(vm, b->theap, b->theap, tail)@
	}
	/* totals per category */
	if (buns)
		BUNins(bn, "_tot/buns", &buns);
	if (head)
		BUNins(bn, "_tot/head", &head);
	if (tail)
		BUNins(bn, "_tot/tail", &tail);
	if (hhsh)
		BUNins(bn, "_tot/hhsh", &hhsh);
	if (thsh)
		BUNins(bn, "_tot/thsh", &thsh);

	/* special area 1: BBP rec */
	sz = BBPmaxsize * sizeof(BBPrec);
	if (sz)
		BUNins(bn, "_tot/bbp", &sz);
	tot += sz;

	/* special area 2: monet context records  DEPRICATE
	   sz = monet_cntxtlim*sizeof(CntxtRec);
	   if (sz) BUNins(bn, "_tot/mil", &sz);
	   tot += sz;
	   if (tot) BUNins(bn, "_tot/found", &tot);
	 */

	/* look at sbkr() to determine how much we missed */
	sz = GDKvm_cursize();
	if (sz)
		BUNins(bn, "_tot/all", &sz);
	sz -= tot;
	tot = GDKvm_heapsize();
	if (sz)
		BUNins(bn, "_tot/sbrk", &tot);
	BBPunlock("SYSvm_usage");

	*ret = bn->batCacheid;
	return MAL_SUCCEED;
}

@}
@-
Additional information on the process utilization is given by
the io command. The following information is obtained.
 
@T
\begin{tabular}{| l| l|}\hline
maxrss     &the maximum resident set size utilized (in kilobytes).\\
minflt     &the number of page faults serviced without any I/O\\
	 &activity; here I/O activity is avoided by "reclaiming" a\\
 
	 &activity; here I/O activity is avoided by "reclaiming" a\\
	 &page frame from the list of pages awaiting reallocation.\\
majflt     &the number of page faults serviced that required I/O\\
	 &activity.\\
nswap      &the number of times a process was "swapped" out of main\\
	 &memory\\
inblock    &the number of times the file system had to perform input.\\
oublock    &the number of times the file system had to perform output.\\
nvcsw      &the number of times a context switch resulted due to a\\
	 &process voluntarily giving up the processor before its\\
	 &time slice was completed (usually to await availability of\\
	 &a resource).\\
nivcsw     &the number of times a context switch resulted due to a\\
	 &higher priority process becoming runnable or because the\\
	 &current process exceeded its time slice.\\
\end{tabular}
@
The resource statistics are collected in a BAT. It can then
be queried. A default listing is produced by the command @%usagecmd@.
(which should be moved to Monet)

@{
The BAT grows. It should be compacted.
@c
#ifdef HAVE_SYS_RESOURCE_H
# include <sys/resource.h>
#endif

mal_export str SYSioStatistics(int *ret);
str
SYSioStatistics(int *ret)
{
	BAT *b;

#ifdef HAVE_SYS_RESOURCE_H
	int i;
	struct rusage ru;

	getrusage(RUSAGE_SELF, &ru);
#endif
	b = BATnew(TYPE_str, TYPE_int, 32);
	if (b == 0)
		return throwMessage("catalog.ioStatistics", "failed to create BAT");

	/* store counters, ignore errors */
#ifdef HAVE_SYS_RESOURCE_H
	i = ru.ru_maxrss;
	BUNins(b, "maxrss", &i);
	i = ru.ru_minflt;
	BUNins(b, "minflt", &i);
	i = ru.ru_majflt;
	BUNins(b, "majflt", &i);
	i = ru.ru_nswap;
	BUNins(b, "nswap", &i);
	i = ru.ru_inblock;
	BUNins(b, "inblock", &i);
	i = ru.ru_oublock;
	BUNins(b, "oublock", &i);
	i = ru.ru_nvcsw;
	BUNins(b, "nvcsw", &i);
	i = ru.ru_nivcsw;
	BUNins(b, "ninvcsw", &i);
#endif

	@:Pseudo(gdk,io)@
	return MAL_SUCCEED;
}

mal_export str SYSgdkEnv(int *ret);
str
SYSgdkEnv(int *ret)
{
	BAT *b = BATcopy(GDKenv);

	@:Pseudo(gdk,env)@
	return MAL_SUCCEED;
}

mal_export str SYSgdkThread(int *ret);
str
SYSgdkThread(int *ret)
{
	BAT *b;
	int i;

	b = BATnew(TYPE_int, TYPE_str, THREADS);
	if (b == 0)
		return throwMessage("catalog.gdkThread", "failed to create BAT");

	for (i = 0; i < THREADS; i++)
		if (GDKthreads[i].pid) {
			BUNins(b, &GDKthreads[i].tid, GDKthreads[i].name);
		}
	@:Pseudo(gdk,thread)@
	return MAL_SUCCEED;
}

@}
