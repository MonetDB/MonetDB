@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f mapi
@a N.J. Nes P. Boncz, S. Mullender
@v 1.1
@+ MonetDB's Internet Interface
This module contains a simple interface for setting up
internet connections and to initialize a client session.
Without loading this interface, Monet runs in administrator
mode. The information about activitated listeners can be
obtained with the 'inspect' module.

Clients may initialize a private listener to implement
specific services. For example, in an OLTP environment
it may make sense to have a listener for each transaction
type, which simply parses a sequence of transaction parameters.

The information about open listeners is maintain in global tables.
They behave as views on the actual state.
No protection is currently possible against malicious users changing them.

Authorization of access to the server is handled as part
of the client record initialization phase. Currently this part
is still lacking the necessary functionality.

The client can use between blocked and unblocked interaction.
The former is preferred, since it will give the best performance.
This property is indicated in the start-up sequence by passing
the authentiaction string  "<username>:<password>:blocked".
An unblocked stream is obtained using "<username>:<password>",
which is also backward compatible for older applications.
@mal
module mapi;

command listen():int
address MAPIlisten_default
comment "Start a Mapi server with the default settings.";
command listen(port:int):int
address MAPIlisten_port
comment "Start a Mapi server with the default settings.";
command listen(port:int, maxusers:int):int
address MAPIlisten
comment "Start a Mapi server.";

command listen(port:int, maxusers:int, cmd:str):int
address MAPIlisten3
comment "Start the Mapi listener on <port> for 
	<maxusers>. For a new client connection 
	MAL procedure <cmd>(Stream s_in, Stream s_out)
	is called.If no <cmd> is specified a new 
	client thread is forked.";

command listen_ssl(port:int, maxusers:int,
	keyfile:str,certfile:str, cmd:str):int
address MAPIlistenSSL
comment "Start the Mapi listener on <port> for 
	<maxusers> using SSL. <keyfile> and 
	<certfile> give the path names for files 
	with the server key and certificates in 
	PEM format. For a new client connection 
	MAL procedure <cmd>(Stream s_in, Stream s_out) 
	is called.If no <cmd> is specified a new 
	client thread is forked.";

command stop(id:int):bit
address MAPIstop
comment "Terminate a specific client identified
         by index in the client table.";
command stop(name:str):bit
address MAPIstopClient
comment "Terminate all sessions of by a client";

command suspend(sessionkey:lng,timeout:lng):void
address MAPIsuspend
comment "Suspend a client interactiont using a
         user-supplied session key.  The session
         is broken when the timer (in seconds)
         for the reconnect expires.";

command resume(sessionkey:lng):void
address MAPIresume
comment "Resume the interaction with a specific client thread";

command trace(nme:str, flag:bit):void
address MAPItrace2
comment "Trace (on/off) receipt of all messages from a specific user";
command trace(flag:bit):void
address MAPItrace
comment "Trace (on/off) receipt of messages for all users";

@{
command prelude()
address mapi_prelude;
command epilogue()
address mapi_epilogue;

@h
#ifndef MAPI_H
#define MAPI_H

/*#define DEBUG_MAPI */

#include "mal_client.h"
#include "mal_session.h"
#include "mal_exception.h"

#define NEW_ARRAY( type, size )	(type*)GDKmalloc((size)*sizeof(type))
#define STREQ(a, b) 		(strcmp(a, b)==0)

#define MAPIPORT		50000
#define MAPISSLPORT		40000
#define MAPIMAXUSERS 		5

#endif /* MAPI_H */
@c
#include "mapi.h"

#include  <sys/types.h> 
#ifdef HAVE_SYS_SOCKET_H
# include <sys/socket.h>
#endif
#ifdef HAVE_WINSOCK_H
# include <winsock.h>
#endif

#define SOCKPTR struct sockaddr *
#if HAVE_SOCKLEN_T
#define SOCKLEN socklen_t
#else
#define SOCKLEN int
#endif

#ifdef NATIVE_WIN32
#define s_close(s)	closesocket(s)
#else
#define s_close(s)	close(s)
#endif

#ifdef HAVE_OPENSSL
#include <openssl/ssl.h>
#include <openssl/err.h>
#endif

@= builtin_operand
{       int _k = interpret(stk, arg(lt, @1), res);
        if (_k < 0) {
                return _k;
        }
        @3 = VALconvert(@2, res);
        if (((ptr) @3 == ILLEGALVALUE)  || (@2 == TYPE_bat && !@3)) {
                return handle_paramerror(res,@1,res->vtype,@2);
        }
}
@c

static char *threadcommand;

str MAPIlistenThread(int *Sock ) {
	int	sock= *Sock;
        int     msgsock= -1;
	int 	retval;
	char	*cmd= threadcommand;
	struct 	timeval tv;
	fd_set 	fds;

	GDKfree(Sock);
	do {

#ifdef DEBUG_MAPI
                printf("wait for next connection sock= %d\n",sock);
                fflush(stdout);
#endif

    		FD_ZERO(&fds);
    		FD_SET(sock, &fds);
    		/* Wait up to 0.0005 seconds. */
    		tv.tv_sec = 1;
    		tv.tv_usec = 500;

    		retval = select(sock+1, &fds, &fds, &fds, &tv);
    		/*retval = select(sock+1, &fds, &fds, &fds, NULL);*/
		if (retval == 0) {
			/* nothing interesting has happened */
			continue;
		}
		if (retval < 0) {
			if (MT_geterrno() != EINTR) 
				return throwMessage("mapi.listen","select failed\n");
			continue;
		}
    		if ((msgsock = accept(sock, (SOCKPTR) 0, (SOCKLEN *) 0)) < 0) {
			if (MT_geterrno() != EINTR)
				return throwMessage("mapi.listen","accept failed\n");
			continue;
		}
#ifdef DEBUG_MAPI
		printf("mapi:accepted \n");fflush(stdout);
#endif
@- 
The command should be sent to the server to activate it.
The alternative V4 feature, i.e. read/write from stream,
is the default in V5.
@c
		if (cmd==NULL) {
			int i=0;
			char *cmd = (char*) GDKmalloc(BLOCK), *user = cmd,*s;
			int blocked=0;
			stream *fdin = socket_rastream(msgsock, "Mserver mapi read");
			stream *fdout= NULL;

			assert(cmd);
			memset(cmd,0,BLOCK);
			if (fdin == 0 || stream_errnr(fdin) ){
				GDKsyserror("MAPIlisten:fdin problems\n");
				continue;
			}
			/* get user:[key:]passwd:lang[:blocked] cmd */
			stream_read(fdin, user, 1, 1);
			for(i=0; !stream_errnr(fdin) && i<BLOCK && *user != '\n'; i++){
				user++;
				stream_read(fdin, user, 1, 1);
			}
			if (stream_errnr(fdin)) {
				GDKsyserror("MAPIlisten: fdin problems\n");
				stream_close(fdin);
				stream_destroy(fdin);
				continue;
			}
			*user=0;
#ifdef DEBUG_MAPI
            printf("mapi:Client accepted %s\n", cmd);fflush(stdout);
#endif
            s= strrchr(cmd,':');
            blocked= s && strncmp(s,":blocked",8)==0;
            if( blocked){
#ifdef DEBUG_MAPI
            	printf("mapi:use blocked mode\n");fflush(stdout);
#endif
                *s=0;
                fdin= block_stream(stream_rstream(fdin));
                fdout= block_stream(socket_wstream(msgsock, "Mserver mapi write"));
            } else {
                fdout= socket_wastream(msgsock,"Mserver mapi write");
			}

			if (fdout == 0){
				GDKsyserror("MAPIlisten:fdout problems\n");
				continue;
			}
#ifdef DEBUG_MAPI
			THRprintf(GDKerr,"MAPIlisten:client accepted %s\n", cmd);
#endif
			scheduleClient(cmd,bstream_create(fdin,blocked?128*BLOCK:0),fdout);
			/* sent commend to client */
		} else {
@-
In V4 it is possible to execute a command using the command parameter.
@c
#ifdef DEBUG_MAPI
			THRprintf(GDKerr,"MAPIlisten:process command %s\n",cmd);
#endif

		}
	} while (1);
	return MAL_SUCCEED;
}

str MAPIlisten3(int *ret, int *Port, int *Maxusers, str *Cmd)
{
	int 	*Sock = GDKmalloc(sizeof(int));
	struct sockaddr_in server;
	int 	sock,pid;
	SOCKLEN 	length = 0;
	int    	on = 1;
	int	i = 0;
	char	msg[512], host[512];

	int port;
	int maxusers;
	char *cmd;
	(void) ret;

	cmd = Cmd? GDKstrdup(*Cmd): 0;
	port = (*Port?*Port:MAPIPORT);
	maxusers = (*Maxusers?*Maxusers:MAPIMAXUSERS);

	sock = socket(AF_INET, SOCK_STREAM, 0);
	if (sock < 0)
		return throwMessage("mapi.listen","creation of stream socket failed\n");
@-
Set server port and allow internet connections from any workstation.
Bind the socket to the server port.
The port id should be obtained from the Monet configuration file.
@c
	server.sin_family = AF_INET;
	server.sin_addr.s_addr = INADDR_ANY;
	server.sin_port = htons((unsigned short)((port)&0xFFFF));
   	for (i=0;i<8;i++)
	    server.sin_zero[i]=0;
 
	setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (char*) &on, sizeof on);

	length = (SOCKLEN) sizeof(server);
	if (bind(sock, (SOCKPTR)&server, length) < 0) {
                return throwException(MALEXCEPTION,"mapi.listen",
                        "binding to socket (%d) failed", *Port);
	}
@-
Get the new information for the server socket and start listening.
@c
	if (getsockname(sock, (SOCKPTR)&server, &length) < 0) 
		return throwMessage("mapi.listen","error getting socket name\n");
	listen(sock, maxusers); 


	threadcommand= cmd;
	*Sock = sock;
        if( MT_create_thread((MT_Id *)&pid,
                (void (*)(void *))MAPIlistenThread, Sock) <0){
                return throwMessage("mapi.listen", "starting thread failed");
        }
	gethostname(host,(int)512);
        snprintf(msg,(int)512,"#Ready to accept connections on %s:%d\n",host,port);
        stream_printf(GDKout,"%s",msg);
        return MAL_SUCCEED;
}

#ifdef HAVE_OPENSSL
static char *
ssl_error(const char *name, int err, int ret)
{
	char *errstr, *s;
	char buf[120];
	unsigned long e;

	switch (err) {
	case SSL_ERROR_ZERO_RETURN:
		errstr = "TLS/SSL connection has been closed";
		break;
	case SSL_ERROR_WANT_READ:
		errstr = "The operation did not complete (read)";
		break;
	case SSL_ERROR_WANT_WRITE:
		errstr = "The operation did not complete (write)";
		break;
	case SSL_ERROR_WANT_X509_LOOKUP:
		errstr = "The operation did not complete (X509 lookup)";
		break;
	case SSL_ERROR_WANT_CONNECT:
		errstr = "The operation did not complete (connect)";
		break;
	case SSL_ERROR_SYSCALL:
		e = ERR_get_error();
		if (e == 0) {
			if (ret == 0) {
				errstr = "EOF occurred in violation of protocol";
			} else if (ret == -1) {
				/* the underlying BIO reported an I/O error */
				errstr = "I/O error";
			} else {  /* possible? */
				errstr = "Some I/O error occurred";
			}
		} else {
			errstr = ERR_error_string(e, buf);
		}
		break;
	case SSL_ERROR_SSL:
		e = ERR_get_error();
		if (e != 0) 
			errstr = ERR_error_string(e, buf);
		else { /* possible? */
			errstr = "A failure in the SSL library occurred";
		}
		break;
	default:
		errstr = "Invalid error code";
	}
	s = GDKmalloc(strlen(errstr) + strlen(name) + 4);
	sprintf(s, "%s: %s\n", name, errstr); /* we allocated enough, so it fits */
	return s;
}

static MT_Lock *mutex_buf;

static void
locking_function(int mode, int n, const char *file, int line)
{
	(void) file;
	(void) line;
	if (mode & CRYPTO_LOCK)
		mal_set_lock(mutex_buf[n], "locking_function");
	else
		mal_unset_lock(mutex_buf[n], "locking_function");
}

static unsigned long
id_function(void)
{
	return (unsigned long) MT_getpid();
}
#endif	/* HAVE_OPENSSL */

bat *mapi_prelude(void)
{
#ifdef HAVE_OPENSSL
	int i, nlocks;

	nlocks = CRYPTO_num_locks();
	mutex_buf = GDKmalloc(nlocks * sizeof(*mutex_buf));
	if (mutex_buf == NULL) {
		GDKsyserror("mapi_prelude: failed to allocate %d mutexes\n", nlocks);
		return NULL;
	}
	for (i = 0; i < nlocks; i++)
		mutex_buf[i] = MT_create_lock();
	CRYPTO_set_locking_callback(locking_function);
	CRYPTO_set_id_callback(id_function);
#endif
	return NULL;
}

void mapi_epilogue(void)
{
#ifdef HAVE_OPENSSL
	if (mutex_buf) {
		int i, nlocks;

		nlocks = CRYPTO_num_locks();
		CRYPTO_set_id_callback(NULL);
		CRYPTO_set_locking_callback(NULL);
		for (i = 0; i < nlocks; i++)
			MT_destroy_lock(mutex_buf[i]);
		GDKfree(mutex_buf);
		mutex_buf = NULL;
	}
#endif	/* HAVE_OPENSSL */
}

str MAPIlistenSSL(int *res, int *Port, int *Maxusers, str *Keyfile, str *Certfile, str *Cmd)
{
#ifdef HAVE_OPENSSL
	struct sockaddr_in server;
	int 	sock = -1;
	SOCKLEN 	length = 0;
	int    	on = 1;
	int 	msgsock;
	int	i = 0;

	int port;
	int maxusers;
	char *keyfile;
	char *certfile;
	char *cmd;
	SSL_CTX *ctx = NULL;
	SSL *ssl = NULL;

	port = *Port;
	maxusers = *Maxusers;
	keyfile = GDKstrdup(Keyfile);
	certfile = GDKstrdup(Certfile);
	cmd = GDKstrdup(Cmd);

	if (!port)
		port = MAPISSLPORT;
	if (!maxusers)
 		maxusers = MAPIMAXUSERS;

	ctx = SSL_CTX_new(SSLv23_method());
	if (ctx == NULL) {
		GDKsyserror("MAPIlistenSSL: creation of SSL context failed\n");
		goto fail;
	}
	if (SSL_CTX_set_cipher_list(ctx, "ALL:!LOW") == 0) {
		GDKsyserror("MAPIlistenSSL: SSL_CTX_set_cipher_list failed\n");
		goto fail;
	}
	if (keyfile && *keyfile && certfile && *certfile) {
		if (SSL_CTX_use_PrivateKey_file(ctx, keyfile, SSL_FILETYPE_PEM) < 1) {
			GDKsyserror("MAPIlistenSSL: SSL_CTX_use_PrivateKey_file %s failed\n", keyfile);
			goto fail;
		}
		if (SSL_CTX_use_certificate_chain_file(ctx, certfile) < 1) {
			GDKsyserror("MAPIlistenSSL: SSL_CTX_use_certificate_chain_file %s failed\n", certfile);
			goto fail;
		}
	}
	if (keyfile)
		GDKfree(keyfile);
	if (certfile)
		GDKfree(certfile);

	SSL_CTX_set_verify(ctx, SSL_VERIFY_NONE, NULL);

	sock = socket(AF_INET, SOCK_STREAM, 0);
	if (sock < 0) {
		GDKsyserror("MAPIlistenSSL:creation of stream socket failed\n");
		goto fail;
	}
@-
Set server port and allow internet connections from any workstation.
Bind the socket to the server port.
The port id should be obtained from the Homes file.
@c
	server.sin_family = AF_INET;
	server.sin_addr.s_addr = INADDR_ANY;
	server.sin_port = htons((unsigned short)((port)&0xFFFF));
   	for (i=0;i<8;i++)
	    server.sin_zero[i]=0;
 
	setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (char*) &on, sizeof on);

	length = (SOCKLEN) sizeof(server);
	if (bind(sock, (SOCKPTR)&server, length) < 0) {
		GDKsyserror("MAPIlistenSSL:binding to stream socket (%d) failed\n", port);
		goto fail;
	}
@-
Get the new information for the server socket and start listening.
@c
	if (getsockname(sock, (SOCKPTR)&server, &length) < 0) {
		GDKsyserror("MAPIlistenSSL:getting socket name\n");
		goto fail;
	}
	listen(sock, maxusers); 

	PARDEBUG {
		THRprintf(GDKerr, "MAPIlistenSSL:Internet started at %d\n", port);
	}
	do {
		int retval;
    		struct timeval tv;
    		fd_set fds;

    		FD_ZERO(&fds);
    		FD_SET(sock, &fds);
    		/* Wait up to 0.5 seconds. */
    		tv.tv_sec = 0;
    		tv.tv_usec = 500;

    		retval = select(sock+1, &fds, &fds, &fds, &tv);
		if (retval == 0) {
			/* nothing interesting has happened */
			continue;
		}
		if (retval < 0) {
			GDKsyserror("MAPIlistenSSL:select failed\n");
			goto fail;
		}
    		if ((msgsock = accept(sock, (SOCKPTR) 0, (SOCKLEN *) 0)) < 0) {
			if (MT_geterrno() != EINTR) {
				GDKsyserror("MAPIlistenSSL:accept failed\n");
				goto fail;
	    		}
			continue;
		}
		if ((ssl = SSL_new(ctx)) == 0) {
			GDKsyserror("MAPIlistenSSL: SSL_new failed\n");
			goto fail;
		}

		if (!SSL_set_fd(ssl, msgsock)) {
			GDKsyserror("MAPIlistenSSL: SSL_set_fd failed\n");
			goto fail;
		}

		for (;;) {
			int ret, err;
			char *errstr;

			ret = SSL_accept(ssl);
			err = SSL_get_error(ssl, ret);
			switch (err) {
			case SSL_ERROR_WANT_READ:
			case SSL_ERROR_WANT_WRITE:
				/* try again */
				continue;
			case SSL_ERROR_NONE:
				/* successful connect */
				break;
			case SSL_ERROR_WANT_CONNECT:
			case SSL_ERROR_WANT_ACCEPT:
			case SSL_ERROR_WANT_X509_LOOKUP:
			default:
				/* some error occurred */
				errstr = ssl_error("MAPIlistenSSL", err, ret);
				GDKsyserror(errstr);
				GDKfree(errstr);
				SSL_free(ssl);
				close(msgsock);
				goto end_loop;
			}
			break;
		}

		if (cmd==NULL) {
			int i=0;
			char *name = (char*) GDKmalloc(BLOCK), *user = name,*s;
			char *mp;
			int blocked=0;
			stream *fdin = ssl_rastream(ssl, "Mserver mapi read");
			stream *fdout= NULL;
			Client c;

			assert(name);
			memset(name,0,BLOCK);
			if (fdin == 0 || stream_errnr(fdin) ){
				GDKsyserror("MAPIlistenSSL:fdin problems\n");
				if (fdin)
					stream_destroy(fdin);
				continue;
			}
			/* get user name */
			stream_read(fdin, user, 1, 1);
			for(i=0; i<BLOCK && *user != '\n' && !stream_errnr(fdin); i++){
				user++;
				stream_read(fdin, user, 1, 1);
			}
			if (stream_errnr(fdin)) {
				GDKsyserror("MAPIlistenSSL: fdin problems\n");
				stream_close(fdin);
				stream_destroy(fdin);
				continue;
			}
			*user = 0;
                        /* printf("mapi:Client accepted %s\n", name);fflush(stdout);*/
                        s = strrchr(name,':');
                        blocked = s && strncmp(s,":blocked",8)==0;
                        if (blocked) {
                                /* printf("mapi:use blocked mode\n");fflush(stdout);*/
                                *s=0;
                                fdin = block_stream(stream_rstream(fdin));
                                fdout = block_stream(ssl_wstream(SSL_dup(ssl),
								 "Mserver mapi write"));
                        } else {
                                fdout = ssl_wastream(SSL_dup(ssl),
						     "Mserver mapi write");
			}

			if (fdout == 0){
				GDKsyserror("MAPIlistenSSL:fdout problems\n");
				continue;
			}
			*user = 0;
			mp = GDKgetenv("monet_prompt");
			c = initClient(name, mp, FALSE);
			if (c == 0) {
				stream_printf(fdout, "MAPIlistenSSL:Failed to init client for user %s\n", name );
				GDKfree(name);

				/* Make sure that the write- (out-) stream is closed first,
				 * as the related read- (in-) stream closes the shared
				 * socket; see also src/common/stream.mx:ssl_close .
				 */
				stream_close(fdout);
				stream_destroy(fdout);
				stream_close(fdin);
				stream_destroy(fdin);
				continue;
			}
			GDKfree(name);
			c->login = time(0);
			c->listing = 0;
			c->fdin = fdin;
			c->fdout = fdout;
			c->mode = BLOCKMODE;
			CNTXTcopy(stk,c);
			TBL_initclient(c, father);
			(void)monetFork();
			scheduleClient(c);
			PARDEBUG THRprintf(GDKerr, 
				"MAPIlistenSSL:client accepted %d\n", 
					msgsock);
		} else {
/* Version 4
			ValRecord res;
			char buf[BUFSIZ];
			stream *sin, *sout;

			sin = ssl_rastream(ssl, "mapi-r");
			sout = ssl_wastream(SSL_dup(ssl), "mapi-w");
			snprintf(buf, BUFSIZ, "%s(Stream(\"" PTRFMT "\"), Stream(\"" PTRFMT "\"));\n", cmd, PTRFMTCAST sin, PTRFMTCAST sout );
			THRprintf(GDKerr, "MAPIlistenSSL: %s", buf);
			res.vtype = TYPE_void; 
			interpret_str( stk, buf, &res);
*/
		}
	  end_loop:;
	} while (1);
	SSL_CTX_free(ctx);
	close(sock);
	if (cmd)
		GDKfree(cmd);
	return MAL_SUCCEED;
  fail:;
	if (sock >= 0)
		close(sock);
	if (ctx)
		SSL_CTX_free(ctx);
	if (cmd)
		GDKfree(cmd);
	return MAL_SUCCEED;
#else
	(void) res; (void) Port; (void) Maxusers; (void) Keyfile; (void) Certfile; (void)Cmd;
	GDKerror("No SSL support\n");
	return MAL_SUCCEED;
#endif	/* HAVE_OPENSSL */
}

int stream_read_until(str *res, stream *S , str stop)
{
	stream *s = *(stream**)S;
	int slen = strlen(stop);
	int len = 0;
	char buf[BUFSIZ + 1], *start = buf;

	while (stream_read(s, start, 1, 1) > 0){
		if (start - buf >= slen - 1 &&
		    strncmp(start - slen + 1, stop, slen) == 0) {
/*
				start = start-slen+1;
*/
				start++;
				break;
		}
		start++;
	}

	if (stream_errnr(s))
		return GDK_FAIL;

	len = start-buf;
	if (len > 0){
		*res = NEW_ARRAY(char, len+1);

		buf[len] = '\0';
		memcpy(*res, buf, len+1);
	} else {
		*res = GDKstrdup("");
	}
	return GDK_SUCCEED;
}
@}
@- Wrappers
The Monet Version 5 wrappers are collected here
@c
str MAPIlisten_default(int *ret){
        int port = MAPIPORT;
        int maxusers = MAPIMAXUSERS;
        return MAPIlisten3(ret, &port, &maxusers,0);
}
str MAPIlisten(int *ret, int *port, int *maxusers){
        return MAPIlisten3(ret, port, maxusers, 0);
}
str MAPIlisten_port(int *ret, int *pid){
        int port = *pid;
        int maxusers = MAPIMAXUSERS;
        return MAPIlisten3(ret, &port, &maxusers,0);
}
@-
An internet connection may be terminated from the server console.
And killing the administrator this way is prohibited.
@c
str MAPIstop(int *ret, int *id) {
        (void) ret; /* fool compiler */
        return stopClientIndex(getClient(), *id);
}

str MAPIstopClient(int *ret, str *nme) {
        (void) ret; /* fool compiler */
        return stopClient(getClient(), *nme);
}
str MAPIsuspendClient(int *ret, int *skey, int *timeout) {
        (void) ret; /* fool compiler */
        return suspendClient(getClient(), *skey, *timeout);
}
str MAPIresumeClient(int *ret, int *skey) {
        (void) ret; /* fool compiler */
        return resumeClient(getClient(), *skey);
}
@-
It is advisable to trace the interactions of clients on the server
side. At least as far as it concerns requests received.
The kernel supports this 'spying' behavior with a file descriptor
field in the client record.
@c
str MAPItrace2(int *ret, str *nme,int *flg){
        (void) ret; /* fool compiler */
        (void) traceClient(*nme,*flg);
        return MAL_SUCCEED;
}

str MAPItrace(int *res, int *flg){
        (void) res; /* fool compiler */
        (void) traceAllClients(*flg);
        return MAL_SUCCEED;
}
str MAPIsuspend(int *res, int *skey, int *timeout){
        (void) res; (void)timeout; (void)skey; /* fool compiler */
        return MAL_SUCCEED;
}
str MAPIresume(int *res, int *skey){
        (void) res; (void)skey; /* fool compiler */
        return MAL_SUCCEED;
}
