@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f algebra
@a Peter Boncz, Martin Kersten, Niels Nes
@v 2.0
@* BAT Algebra
This modules contains the most common algebraic BAT manipulation
commands. We call them @#algebra@, because all operations take
values as parameters, and produce new result values, but 
@%do not modify their parameters@.
@
Unlike the previous Monet versions, we reduce the number
of functions returning a BAT reference. This was previously needed
to simplify recursive bat-expression and manage reference counts.
In the current version we return only a BAT identifier when a new
bat is being created.
@-
All parameters to the modules are passed by reference.
In particular, this means that
string values are passed to the module layer as (str *)
and we have to de-reference them before entering the gdk library.
This calls for knowlegde on the underlying BAT typs`s
@{
@= derefStr
{int _tpe= ATOMstorage(@1->@2type);
 if( _tpe == TYPE_str || _tpe > TYPE_str )
 { if(@3== 0 || *(str*)@3==0) @3= str_nil;
   else @3 = *(str *)@3;
}}

@
@}
We split between selections that return one value, and selections
that return a BAT.
@+ Value Selections
@mal
module algebra;

command exist(b:bat[:any_1,:any_2], h:any_1):bit 
address ALGexist
comment "Returns whether 'h' occurs as a head value in b.";

command exist(b:bat[:any_1,:any_2], h:any_1, t:any_2):bit 
address ALGexistBUN
comment "Returns true when 'h,t' occurs as a bun in b.";

command find(b:bat[:any_1,:any_2], h:any_1):any_2 
address ALGfind
comment "Returns the tail value 't' for which some [h,t] BUN 
        exists in b.  If no such BUN exists, an error occurs." ;

command find(b:bat[:oid,:any_2], h:void):any_2 address ALGfind;

command position(b:bat[:any_1,:any_2], v:any_1):int
address ALGposition
comment "Returns BAT position [0.. b.count] of 'v' in the head 
        column of b. It Return an error if 'v' does not exist.";

command position(b:bat[:any_1,:any_2], val:any_1, tval:any_2) :int 
address ALGpositionBUN
comment "Returns the position of the value pair It returns an 
        error if 'val' does not exist.";

command fetch(b:bat[:any_2,:any_1], x:oid) :any_1 
address ALGfetchoid;
command fetch(b:bat[:any_2,:any_1], x:lng) :any_1 
address ALGfetch;
command fetch(b:bat[:any_2,:any_1], x:int) :any_1 
address ALGfetchint
comment "Returns the tail value of the BUN at x-th position 
        with 0 <= x < b.count";

@+ BAT Selections
The operations are grouped by positional and range selections.
A simple sampling operation is also provided.
@- Positional selection
@mal
command fetch(b:bat[:any_1,:any_2], s:bat[:int,:any_3]) :bat[:any_1,:any_2] 
address ALGfetchbat;
command fetch(b:bat[:any_1,:any_2], s:bat[:lng,:any_3] ) :bat[:any_1,:any_2] 
address ALGfetchbat;
command fetch(b:bat[:any_1,:any_2], s:bat[:oid,:any_3]) :bat[:any_1,:any_2] 
address ALGfetchbat
comment "Returns a positional selection of b by the oid 
        head values of s";

@- Range selection
The range selections are targeted at the tail of the BAT.
@mal
command select(b:bat[:any_1,:any_2], low:any_2, high:any_2) 
            :bat[:any_1,:any_2] 
address ALGselect
comment "Select all BUNs that have tail values: {v| low <= v <= high}.
        NIL boundary values have a special meaning.
        + low  == nil means: no lower bound
        + high == nil means: no upper bound.
        NOTE 1: you should cast the nil to the appropriate type, 
                e.g. int(nil) in order to cirumvent type clashes.
        NOTE 2: as the 'nil' element has no clear place in the 
                ordered domain of values, tuples with 'nil' values 
                are NEVER returned by the range select.";

command select(b:bat[:any_1,:any_2], low:any_2, 
	high:any_2, li:bit, hi:bit) :bat[:any_1,:any_2] 
address ALGselectInclusive
comment "Select all BUNs that have tail values: {v| low <{=} v <{=} high}.
	Boundary inclusion is indicated separately.
	NIL boundary values have a special meaning.
	+ low  == nil means: no lower bound
	+ high == nil means: no upper bound.";

command select(b:bat[:any_1,:any_2],value:any_2) :bat[:any_1,:any_2] 
address ALGselect1
comment "Select all BUNs of a BAT with a certain 
	tail value. Selection on NIL is also 
	possible (it should be properly casted, 
	e.g.:int(nil)).";

@-
The second group uses the head to perform the range selection.
@mal
command selectH(b:bat[:any_1,:any_2], low:any_1, high:any_1) 
            :bat[:any_1,:any_2] 
address ALGselectHead;

command selectH(b:bat[:any_1,:any_2], low:any_1, 
	high:any_1, li:bit, hi:bit) :bat[:any_1,:any_2] 
address ALGselectInclusiveHead;

command selectH(b:bat[:any_1,:any_2],value:any_1) :bat[:any_1,:any_2] 
address ALGselect1Head;

@-
The second group uses the head to perform the range selection
@mal

command fragment ( b:bat[:any_1,:any_2], hlow:any_1, hhigh:any_1,
		tlow:any_2, thigh:any_2 ) :bat[:any_1,:any_2] 
address ALGfragment
comment "Select both on head and tail range.";

command slice(b:bat[:any_1,:any_2], x:int, y:int) :bat[:any_1,:any_2] 
address ALGslice
comment "Return the slice with the BUNs at position x till y.";

command topN( b:bat[:any_1,:any_2], top:lng ) :bat[:any_1,:any_2]
address ALGtopN
comment "Trim all but the top N tuples.";

command groupby(b:bat[:any_1,:int]) :bat[:any_1,:void] 
address ALGgroupby
comment "Produces a new BAT with groups identified by the head column. The result contains tail times the head value, ie the tail contains the result group sizes.";

command uselect(b:bat[:any_1,:any_2], low:any_2, high:any_2, 
        li:bit, hi:bit) :bat[:any_1,:any_2] 
address ALGuselectInclusive
comment "See select() but limited to head values";

command uselect(b:bat[:any_1,:any_2], low:any_2, high:any_2):bat[:any_1,:void] 
address ALGuselect;
command uselect(b:bat[:any_1,:any_2], value:any_2) :bat[:any_1,:void] 
address ALGuselect1
comment "Value select, but returning only the 
	head values. SEE ALSO:select(bat,val)";
@- Pattern matching
@mal
command like(b:bat[:any_1,:str], substr:str) :bat[:any_1,:str] 
address ALGlike
comment "Selects all elements that have 'substr' as in the tail.";
@- Sampling
@mal
command sample ( b:bat[:any_1,:any_2], num:int ) :bat[:any_1,:any_2] 
address ALGsample
comment "Produce a random selection of size 'num' from the input BAT.";
@+ BAT copying
@mal
command copy( b:bat[:any_1,:any_2]) :bat[:any_1,:any_2] 
address ALGcopy
comment "Returns physical copy of a BAT.";
@- Sorted copy
@mal
command sortHead( b:bat[:any_1,:any_2]) :bat[:any_1,:any_2] 
address ALGhsort
comment "Returns a BAT copy sorted on the head column.";
command sort( b:bat[:any_1,:any_2]) :bat[:any_1,:any_2] 
address ALGtsort
comment "Returns a BAT copy sorted on the tail column.";

command sortHT( b:bat[:any_1,:any_2]) :bat[:any_1,:any_2] 
address ALGhtsort
comment "Returns a lexicographically sorted copy on head,tail.";
command sortTH( b:bat[:any_1,:any_2]) :bat[:any_1,:any_2] 
address ALGthsort
comment "Returns a lexicographically sorted copy on tail,head.";

command revert( b:bat[:any_1,:any_2]) :bat[:any_1,:any_2]
address ALGrevert
comment "Returns a BAT copy with buns in reverse order";

@+ Set operations
Sets in Monet can be viewed in two ways:
(1) by looking at both columns of a BAT together (Set-, or s-operators).
(2) by looking at the head column only (Key- or k-operators).
(3) by looking at the tail column only (Tail key- or t-operators).
For this reason, all standard set operations come in three flavors:
k-@emph{operand} series, which look only at the head column, 
t-@emph{operand} series, which look only at the tail column, and
s-@emph{operand} series, that look at the whole BUN.

@noindent Operands provided are:
@itemize
@item [s,k,t]unique(bat[:any_1,:any_2]) :bat[:any_1,:any_2]
produces a copy of the bat, with double elimination
@item [s,k,t]union(bat[:any_1,:any_2],bat[:any_1,:any_2]) :bat[:any_1,:any_2]
bat union.
@item [s,k,t]difference(bat[:any_1,:any_2],bat[:any_1,:any_2]) :bat[:any_1,:any_2]
bat difference.
@item [s,k,t]intersection(bat[:any_1,:any_2],bat[:any_1,:any_2]) :bat[:any_1,:any_2]
bat intersection.
@end itemize
Implementations typically take two forms: if the input relation(s) is/are
ordered, a merge-algorithm is used. Otherwise, hash-indices are produced
on demand for the hash-based algorithms.@*
The [k,s]intersect(l,r) operations result in all BUNs of @emph{l} that
are also in @emph{r}. They do not do double-elimination over the @emph{l} BUNs.@*
The [k,s]difference(l,r) operations result in all BUNs of @emph{l} that are
not in @emph{r}. They do not do double-elimination over the @emph{l} BUNs.@*
The [k,s]union(l,r) operations result in all BUNs of l that are 
not in @emph{r}, plus all BUNs of @emph{r}. They do not do double-elimination
over the @emph{l} nor @emph{r} BUNs.@*
Operations with double-elimination can be formed by performing
[k,s]unique(l) on their operands.
The kintersect(l,r) is used also as implementation for the
@emph{semijoin()}.

The t-@emph{operand} series are cast into a k-@emph{operand}
expression enclosing it with a BATmirror.
@- Bun-unique elements
@mal
command unique (b:bat[:any_1,:any_2] ) :bat[:any_1,:any_2] 
address ALGsunique;
command sunique (b:bat[:any_1,:any_2] ) :bat[:any_1,:any_2] 
address ALGsunique
comment "Select unique tuples from the input BAT. Double elimination is 
        done over BUNs as a whole (head and tail).  Result is a BAT 
	with real set() semantics.";
@- Head-unique elements
@mal
command kunique ( b:bat[:any_1,:any_2] ) :bat[:any_1,:any_2] 
address ALGkunique
comment "Select unique tuples from the input BAT.  Double elimination is 
        done only looking at the head column. The result is a BAT with
		property hkeyed() == true.";

command tunique (b:bat[:any_1,:any_2] ) :bat[:any_1,:any_2] 
address ALGtunique
comment "Select unique tuples from the input BAT. Double elimination is 
        done over the BUNs tail. The result is a BAT with property
		tkeyd()== true";

@- Bun-intersecting elements
@mal
command intersect ( left:bat[:any_1,:any_2], right:bat[:any_1,:any_2]) 
		:bat[:any_1,:any_2] 
address ALGsintersect;
command sintersect ( left:bat[:any_1,:any_2], right:bat[:any_1,:any_2]) 
		:bat[:any_1,:any_2] 
address ALGsintersect
comment "Returns the intersection taken over *both* columns of two BATs. 
        Results in all BUNs of 'left' that are also in 'right'. Does *not* 
        do double-elimination over the 'left' BUNs, If you want this, use:
	 'sintersect(sunique(left),sunique(right))' 
	or: 'sunique(sintersect(left,right))'.";

@- Head-intersecting elements (a.k.a. semijoin)
@mal
command semijoin( left:bat[:any_1,:any_2], right:bat[:any_1,:any] ) 
		:bat[:any_1,:any_2] 
address ALGsemijoin
comment "Returns the intersection taken over only the *head* columns of 
        two BATs.  Results in all BUNs of 'left' that are also in 'right'. 
        Does *not* do double-elimination over the 'left' BUNs. 
		If you want this, use: 'kintersect(kunique(left),kunique(right))' 
	or: 'kunique(kintersect(left,right))'.";

command semijoin( left:bat[:void,:any_2], right:bat[:oid,:any] ) 
		:bat[:oid,:any_2] 
address ALGsemijoin
comment "Patch to enable semijoin over void/oid columns";
command semijoin( left:bat[:oid,:any_2], right:bat[:void,:any] ) 
		:bat[:oid,:any_2] 
address ALGsemijoin
comment "Patch to enable semijoin over void/oid columns";

command kintersect( left:bat[:any_1,:any_2], right:bat[:any_1,:any] ) 
		:bat[:any_1,:any_2] 
address ALGsemijoin
comment "Returns the intersection taken over only the *head* columns of two BATs. 
	Results in all BUNs of 'left' that are also in 'right'. 
        Does *not* do double- elimination over the 'left' BUNs.
		If you want this, use: 'kintersect(kunique(left),kunique(right))' 
	or: 'kunique(kintersect(left,right))'.";
@- Bun-differing elements
@mal
command difference( left:bat[:any_1,:any_2], right:bat[:any_1,:any_2] ) 
		:bat[:any_1,:any_2] 
address ALGsdiff;
command sdifference( left:bat[:any_1,:any_2], right:bat[:any_1,:any_2] ) 
		:bat[:any_1,:any_2] 
address ALGsdiff
comment "Returns the difference taken over *both* columns of two BATs. 
        Results in all BUNs of 'left' that are *not* in 'right'. 
        Does *not* do double-elimination over the 'left' BUNs. 
        If you want this, use:
	     'sdifference(left.sunique,right.sunique)' 
	or: 'sdifference(left,right).sunique'.";
@- Head-differing elements
@mal
command kdifference ( left:bat[:any_1,:any_2], right:bat[:any_1,:any] ) 
		:bat[:any_1,:any_2] 
address ALGkdiff
comment "Returns the difference taken over only the *head* columns of two BATs. 
        Results in all BUNs of 'left' that are *not* in 'right'. 
        It does *not* do double-elimination over the 'left' BUNs. 
        If you want this, use:
	 'kdifference(left.kunique,right.kunique)' 
	or: 'kdifference(left,right).kunique'.";

command kdifference ( left:bat[:void,:any_2], right:bat[:oid,:any] ) 
		:bat[:oid,:any_2] 
address ALGkdiff ;
@- Unions on bun
@mal
command union ( left:bat[:any_1,:any_2], right:bat[:any_1,:any_2]) 
		:bat[:any_1,:any_2] 
address ALGsunion;
command sunion ( left:bat[:any_1,:any_2], right:bat[:any_1,:any_2]) 
		:bat[:any_1,:any_2] 
address ALGsunion
comment "Returns the union of two BATs; looking at both columns of both BATs.
        Results in all BUNs of 'left' that are  not in 'right', plus all 
        BUNs of 'right'.  *no* double-elimination is done. 
        If you want this, do:
	 'sunion(left.sunique,right.sunique)' 
	or: 'sunion(left,right).sunique'.";
@- Union on head
@mal
command kunion ( left:bat[:oid,:any_2], right:bat[:void,:any_2])
		:bat[:oid,:any_2] 
address ALGkunion;
command kunion ( left:bat[:void,:any_2], right:bat[:oid,:any_2])
		:bat[:oid,:any_2] 
address ALGkunion;
command kunion ( left:bat[:any_1,:any_2], right:bat[:any_1,:any_2])
		:bat[:any_1,:any_2] 
address ALGkunion
comment "Returns the union of two BATs; looking at head-columns only. 
        Results in all BUNs of 'left' that are  not in 'right', plus 
	all BUNs of 'right'.  *no* double-elimination is done. 
        If you want this, do:
	'kunion(left.kunique,right.kunique)' 
	or: 'sunion(left,right).kunique'.";
@+ Join operations
The core of every relational engine.
The join collection provided by the GDK kernel.
Note that joins over void columns are handled as if they are oids.
@mal
command crossproduct(left:bat[:any_1,:any_2], right:bat[:any_3,:any_4])
	:bat[:any_1,:any_4]
address ALGcross
comment "Returns the cross product";

command antijoin(left:bat[:any_1,:any_2], right:bat[:any_2,:any_4])
	:bat[:any_1,:any_4]
address ALGantijoin
comment "Returns the antijoin";

command join( left:bat[:any_1,:any_2], right:bat[:any_2,:any_3])
		:bat[:any_1,:any_3] 
address ALGjoin
comment "Returns all BUNs, consisting of a head-value from 'left' and 
        a tail-value from 'right' for which there are BUNs in 'left' 
        and 'right' with equal tail- resp. head-value (i.e. the join
	columns are projected out).";

command join( left:bat[:void,:any_1], right:bat[:any_1,:void])
		:bat[:void,:oid] 
address ALGjoin;
command join( left:bat[:any_1,:void], right:bat[:oid,:any_3])
		:bat[:any_1,:any_3] 
address ALGjoin;
command join( left:bat[:any_1,:oid], right:bat[:void,:any_3])
		:bat[:any_1,:any_3] 
address ALGjoin;

command join( left:bat[:any_1,:any_2], right:bat[:any_2,:any_3],
		estimate:lng) :bat[:any_1,:any_3] 
address ALGjoinestimate;
command join( left:bat[:any_1,:void], right:bat[:oid,:any_3],
		estimate:lng) :bat[:any_1,:any_3] 
address ALGjoinestimate;
command join( left:bat[:any_1,:oid], right:bat[:void,:any_3],
		estimate:lng) :bat[:any_1,:any_3] 
address ALGjoinestimate;

command fetchjoin ( left:bat[:any_1,:any_2], right:bat[:any_2,:any_3] )
		:bat[:any_1,:any_3] 
address ALGfetchjoin
comment "Hook directly into the fetch implementation of the join.";

command mergejoin (left:bat[:any_1,:any_2], right:bat[:any_2,:any_3])
		:bat[:any_1,:any_3] 
address ALGmergejoin
comment "Hook directly into the merge implementation of the join.";

command hashjoin ( left:bat[:any_1,:any_2], right:bat[:any_2,:any_3])
		:bat[:any_1,:any_3] 
address ALGhashjoin
comment "Hook directly into the hash implementation of the join.";

command indexjoin ( left:bat[:any_1,:any_2], right:bat[:any_2,:any_3])
		:bat[:any_1,:any_3] 
address ALGindexjoin
comment "Hook directly into the index implementation of the join.";

@- Outer Join
@mal
command outerjoin( outer:bat[:any_1,:any_2], inner:bat[:any_2,:any_3]) 
		:bat[:any_1,:any_3] 
address ALGouterjoin
comment "Returns all the result of a join, plus the BUNS formed NIL in 
        the tail and the head-values of 'outer' whose tail-value does 
        not match an head-value in 'inner'.";
command outerjoin( outer:bat[:any_1,:oid], inner:bat[:void,:any_3]) 
		:bat[:any_1,:any_3] 
address ALGouterjoin
comment "Returns all the result of a join, plus the BUNS formed NIL in 
        the tail and the head-values of 'outer' whose tail-value does 
        not match an head-value in 'inner'.";
command outerjoin( outer:bat[:any_1,:void], inner:bat[:oid,:any_3]) 
		:bat[:any_1,:any_3] 
address ALGouterjoin
comment "Returns all the result of a join, plus the BUNS formed NIL in 
        the tail and the head-values of 'outer' whose tail-value does 
        not match an head-value in 'inner'.";

command outerjoin( outer:bat[:any_1,:any_2], inner:bat[:any_2,:any_3],
		estimate:lng) :bat[:any_1,:any_3] 
address ALGouterjoinestimate;

@- Theta Join
@mal
command thetajoin( left:bat[:any_1,:any_2], right:bat[:any_2,:any_3],
		opname:int) :bat[:any_1,:any_3] 
address ALGthetajoin
comment "Theta join on for 'mode' in { LE, LT, EQ, GT, GE }.  JOIN_EQ is 
        just the same as join(). All other options do merge algorithms. 
        Either using the fact that they are ordered() already (left on tail, 
	right on head), or by using/creating binary search trees on the 
        join columns. ";

command thetajoin( left:bat[:any_1,:any_2], right:bat[:any_2,:any_3],
		opname:int,estimate:lng) :bat[:any_1,:any_3] 
address ALGthetajoinEstimate;
@- Band Join (approximate match)
@mal
command bandjoin( outer:bat[:any_1,:any_2], inner:bat[:any_2,:any_3],
		   minus:any_2 , plus:any_2 ) :bat[:any_1,:any_3] 
address ALGbandjoin
comment "This is a join() for which the predicate is that two BUNs match 
        if the left-tail value is within the range [right-head - minus, 
        right-head + plus]. Works only for the builtin numerical types, 
        and their derivates.";
@+ OID Introducing Commands
For relational processing, some operators are necessary to produce newly
initiated OID columns, for representing n-ary (intermediary) relations.

@mal
#command markT( b:bat[:any_1,:any], base:void ) :bat[:any_1,:void] 
#address ALGtmark
#comment "Produces a BAT with fresh unique OIDs in the tail starting at 0@0.";

command markT( b:bat[:any_1,:any_2], base:oid ) :bat[:any_1,:void] 
address ALGtmark
comment "Produces a BAT with fresh unique dense sequense of OIDs in 
        the tail that starts at base (i.e. [base,..base+b.count()-1] ).";
command markT( b:bat[:void,:any_2], base:oid ) :bat[:oid,:void] 
address ALGtmark;


command markT( b:bat[:any_1,:any_2] ) :bat[:any_1,:void] 
address ALGtmark_default
comment "Produces a BAT with fresh unique OIDs in the tail starting at 0@0.";

command markT( b:bat[:void,:any_1] ) :bat[:oid,:void] 
address ALGtmark_default
comment "Produces a BAT with fresh unique OIDs in the tail starting at 0@0.";


command markH( b:bat[:any_1,:any_2] ) :bat[:void,:any_1] 
address ALGmarkHead_default
comment "Produces a BAT with fresh OIDs in the head starting at 0@0.";

command markH( b:bat[:void,:any_2] ) :bat[:void,:oid] 
address ALGmarkHead_default1
comment "Produces a BAT with fresh OIDs in the head starting at 0@0.";

command markH( b:bat[:any_1,:any_2], base:oid ) :bat[:void,:any_1] 
address ALGmarkHead
comment "Produces a new BAT with fresh unique dense sequense of OIDs in 
        the head that starts at base (i.e. [base,..base+b.count()-1] ).";

command number( b:bat[:any_1,:any] ) :bat[:any_1,:int]  
address ALGnumber
comment "Produces a new BAT with identical head column, and consecutively 
        increasing integers (start at 0) in the tail column.";

command merge(b:bat[:oid,:oid]):bat[:lng,:oid]
address ALGmerge
comment "Merge head and tail into a single value";

command split(b:bat[:lng,:oid]):bat[:oid,:oid]
address ALGsplit
comment "Split head into two values";

@+ BAT fragmentation commands
Various operations for splitting BATs into useful fragments.

@- Hash Split
The commands below is temporarilly postponed, because
we don;t handle nested bats
@mal
command hashsplit( b:bat[:any_1,:any_2], buckects:int ) 
		:bat[:int,:bat] 
address ALGhashsplit
comment "Split a BAT on tail column according (hash-value MOD buckets). 
        Returns a recursive BAT, containing the fragments in the tail, 
        their bucket number in the head.";

command uhashsplit ( b:bat[:any_1,:any_2], buckets:int ) :bat[:int,:bat] 
address ALGuhashsplit
comment "Same as hashsplit, but only collect the head values in the fragments";
@- Range Split
@mil
command rangesplit ( b:bat[:any_1,:any_2], ranges:int ) 
		:bat[:any_2,bat[:any_1,:any_2]] 
address ALGrangesplit
comment "Split a BAT on tail column in 'ranges' equally sized consecutive 
        ranges. Returns a recursive BAT, containing the fragments in the tail, 
        the higher-bound of the range in the head. The higher bound of the last 
	range is 'nil'.";

command urangesplit( b:bat[:any_1,:any_2], ranges:int ) 
        :bat[:any_2,bat[:any_1,:void]] 
address ALGurangesplit
comment "Same as rangesplit, but only collect the head values in the fragments" ;

@+ Common BAT Aggregates
These operations examine a BAT, and compute some simple aggregate result
over it.
@- BAT size
@mal
module aggr;

command count( b:bat[:any_1,:any] ) :int 
address ALGcount_bat
comment "Return the current size (in number of elements) in a BAT.";
command count ( b:bat[:any_1,:any], ignore_nils:bit ) :int 
address ALGcount_nil
comment "Return the number of elements currently in a BAT ignores 
        BUNs with nil-tail iff ignore_nils==TRUE.";

command count_no_nil ( b:bat[:any_1,:any_2]) :int
address ALGcount_no_nil
comment "Return the number of elements currently 
	in a BAT ignoring BUNs with nil-tail";
@- Histogram on Tail
@mal
command histogram ( b:bat[:any_1,:any_2]) :bat[:any_2,:int] 
address ALGhistogram
comment "Produce a BAT containing the histogram over the tail values.";

@- Default Min and Max
Implementations a generic Min and Max routines get declared first. The
@emph{ min()} and @emph{ max()} routines below catch any tail-type.
The type-specific routines defined later are faster, and will
override these any implementations.
@mal
command cardinality( b:bat[:any_1,:any_2] ) :lng 
address ALGcard
comment "Return the cardinality of the BAT tail values.";
@- 
Implementations a generic Min and Max routines get declared first. The
@emph{ min()} and @emph{ max()} routines below catch any tail-type.
The type-specific routines defined later are faster, and will
override these any implementations.

@- 
@mal
command min(b:bat[:any_1,:any_2]):any_2 
address ALGminany
comment "Return the lowest tail value or nil.";

command max(b:bat[:any_1,:any_2]):any_2 
address ALGmaxany
comment "Return the highest tail value or nil.";
@+ Type-Specific Sum, Prod, Max and Min
For X in @{ sht,int,flt,dbl,lng @},  we generate the
aggregate functions using a macro.
@-
@= sum_definition
command sum (b:bat[:any_1,:@1] ) :@2 
address ALGsum_@1_@2
comment "Gives the sum of all tail values";
command product(b:bat[:any_1,:@1] ) :@2 
address ALGprod_@1_@2
comment "Gives the product of all tail values";
@mal
@:sum_definition(sht,sht)@
@:sum_definition(sht,int)@
@:sum_definition(sht,lng)@
@:sum_definition(int,int)@
@:sum_definition(int,lng)@
@:sum_definition(lng,lng)@
@:sum_definition(flt,flt)@
@:sum_definition(flt,dbl)@
@:sum_definition(dbl,dbl)@

@= avg_definition
command avg (b:bat[:any_1,:@1] ) :dbl 
address CMDavg_@1
comment "Gives the avg of all tail values";
@mal
@:avg_definition(sht)@
@:avg_definition(int)@
@:avg_definition(lng)@
@:avg_definition(flt)@
@:avg_definition(dbl)@
@-
@= aggregate_definition
command @1 ( b:bat[:any_1,:@2] ) :@2 
address ALG@1_@2 comment @3;
@= aggregate
@:aggregate_definition(@1,sht,@2)@
@:aggregate_definition(@1,int,@2)@
@:aggregate_definition(@1,flt,@2)@
@:aggregate_definition(@1,dbl,@2)@
@:aggregate_definition(@1,lng,@2)@

@mal
@:aggregate(max,"Give the highest tail value.")@
@:aggregate(min,"Give the lowest tail value. ")@

@+ Exented selection predicates
For SQL convenience we provide a serie of interval selectors.
@mal
module algebra;
# Extend select to the cases where we can ignore nils altogether
function between(b:bat[:any_1,:any_2], l:any_2, h:any_2) 
		:bat[:any_1,:any_2];
	k:= algebra.select(b,l,h);
	return k;
end between;
# between Close Open interval
function betweenCO(b:bat[:any_1,:any_2], l:any_2, h:any_2)
		:bat[:any_1,:any_2];
	t:= algebra.select(b,l,h, true,false);
	return t;
end betweenCO;
function betweenOC(b:bat[:any_1,:any_2], l:any_2, h:any_2)
		:bat[:any_1,:any_2];
	t:= algebra.select(b,l,h,false,true);
	return t;
end betweenOC;
function betweenOO(b:bat[:any_1,:any_2], l:any_2, h:any_2)
	:bat[:any_1,:any_2];
	t:= algebra.select(b,l,h,false,false);
	return t;
end betweenOO;
@+ Modeling With Properties
The Monet kernel performs run-time optimizations. To choose between
alternative algorithms in a sensible way, it maintains knowledge about
each BAT, sometimes as a BAT property, sometimes as two
column properties for each column (head and tail)
of a BAT. An example of the former is size(bat):int
(which gives the number of BUNs in a BAT), an example
of the latter is ordered(column) :bit, indicating
whether the column contains its valued stored in ascending order.
The convention is to use a BAT as operand also for the column
properties; which then is supposed to be valid for the head
column (ordered(BAT)). Tail columns can be described by
using the mirror BAT with the minus operator (ordered(-BAT)).

@table @code
@item[ordered(BAT) :bit]
	TRUE if the head column is stored in ascending order, else FALSE.
@item[keyed(BAT) :bit]
	TRUE if no duplicates are present in the head column, else FALSE.
@item[idx(BAT) :bit]
	TRUE if a binary index tree search accelerator is present on
	the head column of the BAT, else FALSE.
@item[hashtab(BAT) :bit] 
        presence of hash table on the head column of
        a BAT. TRUE if a bucket-chained hash table search accelerator is
        present on the head column of the BAT, else FALSE.
@item[subcol(BAT, BAT) :bit]
	TRUE if the bag of all values in the head column of the left BAT is
	a bag-subset of the bag of all values in the head column of the
	right BAT, else FALSE.
@item[sync(BAT) :oid]
	Sync-OID on the head column of a BAT. A sync-OID denotes some unique
	sequence of values. If two columns have the same sync-OID, then they
	are guaranteed to contain the same values, in the same sequence.

@item[size(BAT) :int]
	The (estimated) length of a column.
@item[unique(BAT) :int]
	The (estimated) number of distinct values in one column.
@item[subset(BAT, BAT) :bit]
	TRUE if the left BAT is a subset of the BUNs of the right BAT,
	else FALSE.
@item[setunique(BAT) :bit]
	TRUE if the BAT contains no duplicate BUNs, else FALSE.
@end table

@- Property Propagation Rules
At database creation time, the properties of the BATs in the database
can be derived directly from the database schema.

When queries are executed, they will produce @emph{intermediate results},
which in terms are operands for further execution. Hence it is necessary
to @emph{propagate properties} from the operands of an algebraic operator,
to its result.

This process can be captured by having a series of @emph{propagation rules}
for each algebraic operand. Since each algebraic operands may apply
different strategies, according to different status in its operand properties,
each algebraic operator may have different propagation rules with these
different situations as conditions.
@{
@h
#ifndef ALGEBRA_H
#define ALGEBRA_H

#include <gdk.h>
#include "mal_exception.h"

#ifdef _MSC_VER
#ifndef LIBALGEBRA
#define algebra_export extern __declspec(dllimport)
#else
#define algebra_export extern __declspec(dllexport)
#endif
#else
#define algebra_export extern
#endif
algebra_export ptr BATmax(BAT *b, ptr aggr);
algebra_export ptr BATmin(BAT *b, ptr aggr);
algebra_export int doCMDfetch(ptr ret, BAT *b, size_t i);

#endif

@c
#include "algebra.h"

@= BATaggr
ptr BAT@1(BAT *b, ptr aggr) {
        int t;
        size_t s;
        ptr v, x;

        BATcheck(b, "BAT@1");
        s = BATcount(b);
        t = b->ttype;
        if (BATtvoid(b)) {
            @:aggr@1(chr,loc,simple,chr,void)@
        } else {
            switch(ATOMstorage(t)) {
            case TYPE_chr: @:aggr@1(chr,loc,simple,chr,atom)@ break;
            case TYPE_sht: @:aggr@1(sht,loc,simple,sht,atom)@ break;
            case TYPE_int: @:aggr@1(int,loc,simple,int,atom)@ break;
            case TYPE_flt: @:aggr@1(flt,loc,simple,flt,atom)@ break;
            case TYPE_dbl: @:aggr@1(dbl,loc,simple,dbl,atom)@ break;
            case TYPE_lng: @:aggr@1(lng,loc,simple,lng,atom)@ break;
            default:if (b->tvarsized) {
                           @:aggr@1(chr,var,atom,t,atom)@ break;
                     } else {
                           @:aggr@1(chr,loc,atom,t,atom)@ break;
            }        }
        }
        return x;
}

@c
@:BATaggr(min)@
@:BATaggr(max)@

@* Command Implementations in C
This module contains just a wrapper implementations; since all described
operations are part of the GDK kernel.

@+ BAT sum operation
The sum aggregate only works for int and float fields.
The routines below assumes that the caller knows what type
is large enough to prevent overflow.

@= sum_implementation
int
CMDsum_@1_@2(@2* res, BAT *b)
{
	BUN p,q;
	int xx;
	@2 result=@3;

	BATcheck(b,"BATsum_@1_@2");
	BATloopFast(b, p, q, xx) {
		@1 *value = (@1*) BUNtloc(b, p);
		if (*value == @1_nil) {
			result = @2_nil;
			break;
		} else {
			result += *value;
		}
	}
	*res = result;
	return GDK_SUCCEED;
}

@+ BAT prod[uct] operation
The prod[uct] aggregate only works for int and float fields.
The routines below assumes that the caller knows what type
is large enough to prevent overflow.

@= prod_implementation
int
CMDprod_@1_@2(@2* res, BAT *b)
{
	BUN p,q;
	int xx;
	@2 result=@3;

	BATcheck(b,"BATprodInt");
	BATloopFast(b, p, q, xx) {
		@1 *value = (@1*) BUNtloc(b, p);
		if (*value == @1_nil) {
			result = @2_nil;
			break;
		} else {
			result *= *value;
		}
	}
	*res = result;
	return GDK_SUCCEED;
}

@+ BAT avg operation
The avg aggregate only works for int and float fields.

@= avg_implementation
int
CMDavg_@1(dbl* res, BAT *b)
{
	int cnt = BATcount(b);
	dbl result=0.0;

	CMDsum_@1_dbl(&result, b);
	*res = result/cnt;
	return GDK_SUCCEED;
}

@+ Minimum and Maximum
The routines @`BATmin@5(b) and @`BATmax@5(b) compute the minimum and
maximum value of the tail column of a BAT.
Aggregate values are calculated just before they are requested by
the user. They are not maintained continuously, because we expect
them to be used sparsely.

@= aggregate_implementation
int
CMDmin_@1(@1* result, BAT *b)
{
	return BATmin(b, result)?GDK_SUCCEED:GDK_FAIL;
}
int
CMDmax_@1(@1* result, BAT *b)
{
	return BATmax(b, result)?GDK_SUCCEED:GDK_FAIL;
}
@= atomaggr
	if (s > 0 && !(BATtordered(b)&1)) {
		char* nil = BATatoms[t].atomNull;
		BUN p,q;
		int xx;
		BATloopFast(b, p, q, xx) {
			x = (ptr) BUNt@2(b, p);
			if (@3_CMP(x, nil, @4) == 0) {
				v = nil;
				break;
			}
			if (@3_@5(x, v, @4)) {
				v = x;
			}
		}
	}
	if (aggr) {
       memcpy(aggr, x=v, ATOMsize(t));
	} else {
       /* alloc new space and copy the atom into it */
       s = ATOMlen(t, v);
       memcpy(x = (ptr) GDKmalloc(s), v, s);
   }
@= voidaggr
	if (aggr) {
		*(oid *) aggr = *(oid *) (x=v);
	} else {
		/* alloc new space and copy the atom into it */
		memcpy(x = (ptr) GDKmalloc(sizeof(oid)), v, s);
	}
@= aggrmin
	v = (s == 0)?ATOMnilptr(t):BUNtail(b, BUNfirst(b));
	@:@5aggr(@1,@2,@3,@4,LT)@
@= aggrmax
	v = (s == 0)?ATOMnilptr(t):BUNtail(b, BUNlast(b)-BUNsize(b));
	@:@5aggr(@1,@2,@3,@4,GT)@

@c

@:sum_implementation(sht,sht,0)@
@:sum_implementation(sht,int,0)@
@:sum_implementation(sht,lng,0)@
@:sum_implementation(sht,dbl,0)@
@:sum_implementation(int,int,0)@
@:sum_implementation(int,lng,0)@
@:sum_implementation(int,dbl,0)@
@:sum_implementation(lng,lng,0)@
@:sum_implementation(lng,dbl,0)@
@:sum_implementation(flt,flt,0.0)@
@:sum_implementation(flt,dbl,0.0)@
@:sum_implementation(dbl,dbl,0.0)@

@:prod_implementation(sht,sht,1)@
@:prod_implementation(sht,int,1)@
@:prod_implementation(sht,lng,1)@
@:prod_implementation(int,int,1)@
@:prod_implementation(int,lng,1)@
@:prod_implementation(lng,lng,1)@
@:prod_implementation(flt,flt,1.0)@
@:prod_implementation(flt,dbl,1.0)@
@:prod_implementation(dbl,dbl,1.0)@

@:avg_implementation(sht)@
@:avg_implementation(int)@
@:avg_implementation(lng)@
@:avg_implementation(flt)@
@:avg_implementation(dbl)@

@:aggregate_implementation(sht)@
@:aggregate_implementation(int)@
@:aggregate_implementation(flt)@
@:aggregate_implementation(dbl)@
@:aggregate_implementation(lng)@

int
CMDminany(ptr result, BAT *b)
{
	if (!ATOMlinear(b->ttype))
		return GDKerror("CMDminANY: atom '%s' cannot be ordered linearly\n", ATOMname(b->ttype));
	if (ATOMvarsized(b->ttype))
		return (*(ptr *) result = BATmin(b, NULL)) ? GDK_SUCCEED : GDK_FAIL;
	if (BATmin(b, result)) {
		if (b->ttype == TYPE_bat)
			*(BAT **) result = BATdescriptor(*(bat *) result);
		return GDK_SUCCEED;
	}
	return GDK_FAIL;
}

int
CMDmaxany(ptr result, BAT *b)
{
	if (!ATOMlinear(b->ttype))
		return GDKerror("CMDmaxANY: atom '%s' cannot be ordered linearly\n", ATOMname(b->ttype));
	if (ATOMvarsized(b->ttype))
		return (*(ptr *) result = BATmax(b, NULL)) ? GDK_SUCCEED : GDK_FAIL;
	if (BATmax(b, result)) {
		if (b->ttype == TYPE_bat)
			*(BAT **) result = BATdescriptor(*(bat *) result);
		return GDK_SUCCEED;
	}
	return GDK_FAIL;
}

@* Command Implementations in C
This module contains just a wrapper implementations; since all described
operations are part of the GDK kernel.

@c
int
CMDselect1(BAT **result, BAT *b, ptr value)
{
	return (*result = BATselect(b, value, 0)) ? GDK_SUCCEED : GDK_FAIL;
}

int
CMDuselect1(BAT **result, BAT *b, ptr value)
{
	return (*result = BATuselect(b, value, 0)) ? GDK_SUCCEED : GDK_FAIL;
}

int
CMDselect(BAT **result, BAT *b, ptr low, ptr high)
{
	return (*result = BATselect(b, low, high)) ? GDK_SUCCEED : GDK_FAIL;
}

int
CMDuselect(BAT **result, BAT *b, ptr low, ptr high)
{
	return (*result = BATuselect(b, low, high)) ? GDK_SUCCEED : GDK_FAIL;
}

int
CMDselect_(BAT **result, BAT *b, ptr low, ptr high, bit *l_in, bit *h_in)
{
	int tt = b->ttype;
	ptr nil = ATOMnilptr(tt);

	if (*l_in == bit_nil && ATOMcmp(tt, low, nil)) {
		GDKerror("CMDselect: flag 'l_in' must not be NIL, unless boundary 'low' is NIL\n");
		return GDK_FAIL;
	}
	if (*h_in == bit_nil && ATOMcmp(tt, high, nil)) {
		GDKerror("CMDselect: flag 'h_in' must not be NIL, unless boundary 'high' is NIL\n");
		return GDK_FAIL;
	}
	return (*result = BATselect_(b, low, high, *l_in, *h_in)) ? GDK_SUCCEED : GDK_FAIL;
}

int
CMDuselect_(BAT **result, BAT *b, ptr low, ptr high, bit *l_in, bit *h_in)
{
	int tt = b->ttype;
	ptr nil = ATOMnilptr(tt);

	if (*l_in == bit_nil && ATOMcmp(tt, low, nil)) {
		GDKerror("CMDuselect: flag 'l_in' must not be NIL, unless boundary 'low' is NIL\n");
		return GDK_FAIL;
	}
	if (*h_in == bit_nil && ATOMcmp(tt, high, nil)) {
		GDKerror("CMDuselect: flag 'h_in' must not be NIL, unless boundary 'high' is NIL\n");
		return GDK_FAIL;
	}
	return (*result = BATuselect_(b, low, high, *l_in, *h_in)) ? GDK_SUCCEED : GDK_FAIL;
}

int
CMDfragment(BAT **result, BAT *b, ptr hlow, ptr hhigh, ptr tlow, ptr thigh)
{
	return (*result = BATrestrict(b, hlow, hhigh, tlow, thigh)) ? GDK_SUCCEED : GDK_FAIL;
}

int
CMDthetajoin(BAT **result, BAT *left, BAT *right, int *mode, lng *estimate)
{
	return (*result = BATthetajoin(left, right, *mode, (*estimate == lng_nil) ? oid_nil : (size_t) * estimate)) ? GDK_SUCCEED : GDK_FAIL;
}

int
CMDbandjoin(BAT **result, BAT *left, BAT *right, ptr minus, ptr plus)
{
	return (*result = BATbandjoin(left, right, minus, plus)) ? GDK_SUCCEED : GDK_FAIL;
}

@-
Let cut this text down with some Mx macro's
@= unary
int
CMD@1(BAT **result, BAT *b)
{
	return (*result = @2(b))?GDK_SUCCEED:GDK_FAIL;
}
@= unaryint
int
CMD@1(int *result, BAT *b)
{
	*result = @2(b);
	return GDK_SUCCEED;
}
@= binary
int
CMD@1(BAT **result, BAT *left, BAT* right)
{
	return (*result = @2(left, right))?GDK_SUCCEED:GDK_FAIL;
}
@= binaryestimate
int
CMD@1(BAT **result, BAT *left, BAT* right, lng *estimate)
{
	return (*result = @2(left, right, *estimate==lng_nil?(size_t)oid_nil:(size_t)*estimate))?GDK_SUCCEED:GDK_FAIL;
}
@= binaryint
int
CMD@1(BAT **result, BAT* b, int *param)
{
	return (*result = @2(b, *param))?GDK_SUCCEED:GDK_FAIL;
}
@c
@:unaryint(count,BATcount)@
@:unary(histogram,BAThistogram)@
@:unary(sort,BATsort)@
@:unary(tsort,BATsort_rev)@
@:unary(number,BATnumber)@
@:unary(copy,BATcopy)@
@:unary(kunique,BATkunique)@
@:unary(sunique,BATsunique)@
@:binary(semijoin,BATsemijoin)@
@:binary(cross,BATcross)@
@:binary(antijoin,BATantijoin)@
@:binaryestimate(join,BATjoin)@
@:binaryestimate(outerjoin,BATouterjoin)@
@:binary(sunion,BATsunion)@
@:binary(kunion,BATkunion)@
@:binary(sintersect,BATsintersect)@
@:binary(kintersect,BATkintersect)@
@:binary(sdiff,BATsdiff)@
@:binary(kdiff,BATkdiff)@
@:binaryint(sample,BATsample)@

int
CMDcount_nil(int *result, BAT *b, bit *ignore_nils)
{
	if (*ignore_nils)
		*result = (int) BATcount_no_nil(b);
	else
		*result = (int) BATcount(b);
	return GDK_SUCCEED;
}

int
CMDgroup(BAT **result, BAT *b, int *start, int *incr, int *grpsize)
{
	return (*result = BATgroup(b, *start, *incr, *grpsize)) ? GDK_SUCCEED : GDK_FAIL;
}

int
CMDgen_group(BAT **result, BAT *b )
{
	BUN u, v;
	int xx;
	int htpe = (b->htype == TYPE_void)?TYPE_oid:b->htype;
	BAT *r = BATnew(htpe, TYPE_void, BATcount(b)*2);

	if (b->hvarsized) {
		BATloopFast(b, u, v, xx) {
		    int i, sz = *(int*)BUNtloc(b, u);
		    for(i = 0; i < sz; i++) {
			if (BUNfastins(r, BUNhvar(b, u), NULL) == NULL) {
				BBPreclaim(r);
				return GDK_FAIL;
			}
		    }
		}
	} else {
		BATloopFast(b, u, v, xx) {
		    int i, sz = *(int*)BUNtloc(b, u);
		    for(i = 0; i < sz; i++) {
			if (BUNfastins(r, BUNhloc(b, u), NULL) == NULL) {
				BBPreclaim(r);
				return GDK_FAIL;
			}
		    }
		}
	}
	*result = r;
	return GDK_SUCCEED;
}


int
CMDproject(BAT **res, BAT *b, ptr p, int t)
{
	return (*res = BATconst(b, t, p)) ? GDK_SUCCEED : GDK_FAIL;
}

int
CMDmark(BAT **res, BAT *b, oid *base)
{
	return (*res = BATmark(b, *base)) ? GDK_SUCCEED : GDK_FAIL;
}

int
CMDmark_default(BAT **res, BAT *b)
{
	oid base = OIDnew(BATcount(b));

	return CMDmark(res, b, &base);
}

int
CMDhashsplit(BAT **res, BAT *b, int *nfrag)
{
	return (*res = BAThashsplit(b, *nfrag, FALSE)) ? GDK_SUCCEED : GDK_FAIL;
}

int
CMDuhashsplit(BAT **res, BAT *b, int *nfrag)
{
	return (*res = BAThashsplit(b, *nfrag, TRUE)) ? GDK_SUCCEED : GDK_FAIL;
}

int
CMDrangesplit(BAT **res, BAT *b, int *nfrag)
{
	return (*res = BATrangesplit(b, *nfrag, FALSE)) ? GDK_SUCCEED : GDK_FAIL;
}

int
CMDurangesplit(BAT **res, BAT *b, int *nfrag)
{
	return (*res = BATrangesplit(b, *nfrag, TRUE)) ? GDK_SUCCEED : GDK_FAIL;
}

int
CMDhistogram_rev(BAT **bn, BAT *b)
{
	return CMDhistogram(bn, BATmirror(b));
}


@- Substring Select
The string pattern matching routine has been added. It should be
dynamically linked.
A simple string matcher is included. It should be refined later on
@c
INLINE int
like(char *x, char *y, int ylen)
{
	char *r;

	if (x == (char *) NULL) {
		return 0;
	}
	for (r = x + strlen(x) - ylen; x <= r; x++) {
		int ok = 1;
		char *s = x;
		char *q;

		for (q = y; *q; q++, s++)
			if (*q != tolower(*s)) {
				ok = 0;
				break;
			}
		if (ok)
			return 1;
	}
	return 0;
}

int
CMDlike(BAT **ret, BAT *b, str s)
{
	BAT *c = BATnew(BAThtype(b), TYPE_str, BATcount(b) / 10);
	str t = GDKstrdup(s);
	BUN u, v;
	int xx, yy = 0;

	if (c == NULL)
		return GDK_FAIL;
	for (s = t; *s; s++, yy++)
		*s = tolower(*s);

	if (b->hvarsized) {
		BATloopFast(b, u, v, xx)
		    if (like(BUNtvar(b, u), t, yy))
			if (BUNfastins(c, BUNhvar(b, u), BUNtvar(b, u)) == NULL) {
				BBPreclaim(c);
				return GDK_FAIL;
			}
	} else {
		BATloopFast(b, u, v, xx)
		    if (like(BUNtvar(b, u), t, yy))
			if (BUNfastins(c, BUNhloc(b, u), BUNtvar(b, u)) == NULL) {
				BBPreclaim(c);
				return GDK_FAIL;
			}
	}
	c->hsorted = BAThordered(b);
	c->tsorted = BATtordered(b);
	*ret = c;
	return GDK_SUCCEED;
}

@- BAT slice
@c
int
CMDslice(BAT **retval, BAT *b, int *start, int *end)
{
	/* the internal BATslice requires exclusive end */
	if (*start < 0) {
		GDKerror("CMDslice: start position of slice should >= 0\n");
		return GDK_FAIL;
	}

	return (*retval = BATslice(b, (size_t) * start, (size_t) * end + 1)) ? GDK_SUCCEED : GDK_FAIL;
}

@- BUN Get/Fetch
@c
int
CMDposition(int *retval, BAT *b, ptr val)
{
	ptr p = (b->htype == TYPE_bat) ? (ptr) &((BAT *) val)->batCacheid : val;
	ptr v = BUNfnd(b, p);

	if (v == 0) {
		GDKerror("CMDposition: item not found\n");
		return GDK_FAIL;
	}
	*retval = BUNindex(b, v) - BUNindex(b, BUNfirst(b));
	return GDK_SUCCEED;
}

int
CMDpositionBUN(int *retval, BAT *b, ptr val, ptr tval)
{
	ptr p = (b->htype == TYPE_bat) ? (ptr) &((BAT *) val)->batCacheid : val;
	ptr o = (b->ttype == TYPE_bat) ? (ptr) &((BAT *) tval)->batCacheid : tval;
	ptr v = BUNlocate(b, p, o);

	if (v == 0) {
		GDKerror("CMDposition: item not found\n");
		return GDK_FAIL;
	}
	*retval = BUNindex(b, v) - BUNindex(b, BUNfirst(b));
	return GDK_SUCCEED;
}

int
CMDfetchbat(BAT **ret, BAT *b, BAT *s)
{
	return (*ret = BATfetch(b, s)) ? GDK_SUCCEED : GDK_FAIL;
}

int
doCMDfetch(ptr ret, BAT *b, size_t i)
{
	if (i >= BATcount(b)) {
		GDKerror("CMDfetch: idx out of range\n");
		return GDK_FAIL;
	}
	i += BUNindex(b, BUNfirst(b));
	@:putTail(BUNptr(b,i))@
@= putTail
	if (b->theap) {
		ptr _src = BUNtvar(b,@1);/*b->theap->base + *(var_t*) BUNtloc(b,@1);*/
		int _len = ATOMlen(b->ttype, _src);
		ptr _dst = GDKmalloc(_len);
		memcpy(_dst, _src, _len);
		*(ptr*) ret = _dst;
	} else {
		int _s = ATOMsize(ATOMtype(b->ttype));
		if (ATOMvarsized(b->ttype)) {
			memcpy(*(ptr*) ret=GDKmalloc(_s), BUNtvar(b, @1), _s);
		} else if (b->ttype == TYPE_bat) {
			bat bid = *(bat*) BUNtloc(b, @1);
			*(BAT**) ret = BATdescriptor(bid);
		} else if (_s == 4) {
			*(int*) ret = *(int*) BUNtail(b, @1);
		} else if (_s == 1) {
			*(chr*) ret = *(chr*) BUNtail(b, @1);
		} else if (_s == 2) {
			*(sht*) ret = *(sht*) BUNtail(b, @1);
		} else if (_s == 8) {
			*(lng*) ret = *(lng*) BUNtail(b, @1);
		} else {
			memcpy(ret, BUNtloc(b, @1), _s);
		}
	}
@c
	return GDK_SUCCEED;
}

int
CMDfetch(ptr ret, BAT *b, int *pos)
{
	return doCMDfetch(ret, b, (size_t) * pos);
}

int
CMDfetchoid(ptr ret, BAT *b, oid *pos)
{
	if (b->hseqbase == oid_nil) {
		GDKerror("CMDfetchoid: void lookup on uninitialized column.\n");
		return GDK_FAIL;
	}
	return doCMDfetch(ret, b, (size_t) (*pos - b->hseqbase));
}

int
CMDexist(bit *ret, BAT *b, ptr val)
{
	ptr p = (b->htype == TYPE_bat) ? (ptr) &((BAT *) val)->batCacheid : val;
	BUN q = BUNfnd(b, p);

	*ret = q ? 1 : 0;
	return GDK_SUCCEED;
}

int
CMDexistBUN(bit *ret, BAT *b, ptr val, ptr tval)
{
	ptr p = (b->htype == TYPE_bat) ? (ptr) &((BAT *) val)->batCacheid : val;
	ptr o = (b->ttype == TYPE_bat) ? (ptr) &((BAT *) tval)->batCacheid : tval;
	BUN q = BUNlocate(b, p, o);

	*ret = q ? 1 : 0;
	return GDK_SUCCEED;
}

int
CMDfind(ptr ret, BAT *b, ptr val)
{
	ptr p = (b->htype == TYPE_bat) ? (ptr) &((BAT *) val)->batCacheid : val;
	BUN q = BUNfnd(b, p);

	if (q == NULL) {
		GDKerror("CMDfind: value not found.\n");
		return GDK_FAIL;
	}
	@:putTail(q)@
	return GDK_SUCCEED;
}

@= find_bounds
int
CMDr@1_summary(BAT **ret, BAT* b, int *quantiles)
{
	ssize_t cnt = BATcount(b), n = MIN(cnt,*quantiles);
	dbl threshold =0, delta = ((dbl) cnt) / (dbl) (MAX(1,n)-1);
	BAT *bn = *ret = BATnew(b->ttype, TYPE_oid, n);
	int (*cmp)(ptr,ptr) = BATatoms[b->ttype].atomCmp;

	if (bn == NULL)
		return GDK_FAIL;
	bn->hsorted = (1 @3 0 ? GDK_SORTED : FALSE);
	bn->tsorted = GDK_SORTED;

	if (cnt > 0) {
		ssize_t yy = 0, bunwidth = 0 @5 BUNsize(b);
		BUN p, bnds[2];
		ptr v;

		bnds[0 @3 1] = BUNfirst(b);
		bnds[1 @3 0] = BUNlast(b) - BUNsize(b);

		for (p=bnds[0], v=BUNtail(b, p); bnds[1] @3 p; p += bunwidth) {
			ptr cur = BUNtail(b,p);
			if (cmp(cur, v) @3 0)
				v = cur;
			if (++yy > threshold) {
				bunfastins(bn, v, BUNhead(b,p));
				threshold += delta;
			}
		}
		bunfastins(bn, v, BUNhead(b,p));
	}
	if ((BAThordered(bn)&1) == 0)
		bn = BATrevert(bn);
	if (bn) {
		bn->hsorted = GDK_SORTED;
		return GDK_SUCCEED;
	}
bunins_failed:
	BBPreclaim(bn);
	return GDK_FAIL;
}

int
CMDr@1_@2(oid* ret, BAT *b, ptr v)
{
	if ((BAThordered(b)&1) == 0) {
		GDKerror("CMDr@1_@2: %s should be sorted on head\n", BATgetId(b));
		return GDK_FAIL;
	} else if (BATcount(b) > 0) {
		BUN p = NULL;
		ssize_t idx;

		switch(ATOMstorage(b->htype)) {
		case TYPE_chr:
			p = SORTfnd@4_chr(BATmirror(b),v);
			break;
		case TYPE_sht:
			p = SORTfnd@4_sht(BATmirror(b),v);
			break;
		case TYPE_int:
			p = SORTfnd@4_int(BATmirror(b),v);
			break;
		case TYPE_lng:
			p = SORTfnd@4_lng(BATmirror(b),v);
			break;
		case TYPE_flt:
			p = SORTfnd@4_flt(BATmirror(b),v);
			break;
		case TYPE_dbl:
			p = SORTfnd@4_dbl(BATmirror(b),v);
			break;
		default:
			if (b->hvarsized ) {
				p = SORTfnd@4_var(BATmirror(b),v);
			} else {
				p = SORTfnd@4_loc(BATmirror(b),v);
			}
		}
		if (p == NULL) {
			p = BUNlast(b);
		} else if (1 @3 0) {
			p -= BUNsize(b);
		}
		if (p < BUNfirst(b)) {
			idx = *(ssize_t*) BUNtail(b,p) - 1;
		} else if (p >= BUNlast(b)) {
			idx = (*(ssize_t*) BUNtail(b,BUNlast(b)-BUNsize(b))) + 1;
		} else {
			idx = (*(ssize_t*) BUNtail(b,p)) @5 1;
		}
		*ret = (idx < 0)?0:idx;
	} else {
		*ret = oid_nil;
	}
	return GDK_SUCCEED;
}

int
CMDfind_@2(oid *ret, BAT *b, ptr v)
{
	ssize_t idx = (ssize_t) oid_nil;

	if ((BAThordered(b)&1) == 0) {
		GDKerror("CMDfind_@2: %s should be sorted on head\n", BATgetId(b));
		return GDK_FAIL;
	} else if (BATcount(b) > 0) {
		BUN p = NULL;

		switch(ATOMstorage(b->htype)) {
		case TYPE_chr:
			p = SORTfnd@4_chr(BATmirror(b),v);
			break;
		case TYPE_sht:
			p = SORTfnd@4_sht(BATmirror(b),v);
			break;
		case TYPE_int:
			p = SORTfnd@4_int(BATmirror(b),v);
			break;
		case TYPE_lng:
			p = SORTfnd@4_lng(BATmirror(b),v);
			break;
		case TYPE_flt:
			p = SORTfnd@4_flt(BATmirror(b),v);
			break;
		case TYPE_dbl:
			p = SORTfnd@4_dbl(BATmirror(b),v);
			break;
		default:
			if (b->hvarsized ) {
				p = SORTfnd@4_var(BATmirror(b),v);
			} else {
				p = SORTfnd@4_loc(BATmirror(b),v);
			}
		}
		if (p) {
			idx = *(ssize_t*) BUNtail(b,p);
			@6;
		}
	}
	*ret = (oid) idx;
	return GDK_SUCCEED;
}
@c
@:find_bounds(min,higher,<,last,-)@
@:find_bounds(max,lower,>,first,+,if (idx && (p >= BUNlast(b) || ATOMcmp(b->htype, v, BUNhead(b, p)))) idx--) @

int
CMDmerge(BAT **ret, BAT *b)
{
	int n = BATcount(b);
	BAT *bn = *ret = BATnew(TYPE_lng, TYPE_void, n);
	BUN p, q;
	int xx;
	lng *r = (lng *) BUNhead(bn, BUNfirst(bn));

	BATloopFast(b, p, q, xx) {
		oid hp = *(oid *) BUNhead(b, p);
		oid tp = *(oid *) BUNtail(b, p);

		*r++ = (((lng) hp) << 32) + tp;
	}
	bn->batBuns->free = (BUN) r - bn->batBuns->base;
	BATsetcount(bn, bn->batBuns->free/BUNsize(bn));
	if (!bn->batDirty)
		bn->batDirty = TRUE;

	bn->hsorted = ( BAThordered(b)&1 && (BATtordered(b)&1 || BAThkey(b))) 
		? GDK_SORTED : FALSE ;
	BATkey(bn, BAThkey(b) || BATtkey(b)) ;

	return GDK_SUCCEED;
}

int
CMDsplit(BAT **ret, BAT *b)
{
	int n = BATcount(b);
	BAT *bn = *ret = BATnew(TYPE_oid, TYPE_oid, n);
	int i;
	lng *r = (lng *) BUNhead(b, BUNfirst(b));

	for (i = 0; i < n; i++, r++) {
		oid hp = (int) (*r >> 32);
		oid tp = (int) *r;

		bunfastins(bn, &hp, &tp);
	}

	bn->hsorted = BAThordered(b)&1 ? GDK_SORTED : FALSE ;
	bn->tsorted = FALSE ;
	return GDK_SUCCEED;
bunins_failed:
	BBPreclaim(bn);
	return GDK_FAIL;
}

@- Wrapper
The remainder of this file contains the wrapper around the V4 code base
The BAT identifiers passed through this module may indicate
that the 'reverse' view applies. This should be taken into
account while resolving them.
@+ BAT sum and product aggregation 
The sum aggregate only works for int and float fields.
The routines below assumes that the caller knows what type
is large enough to prevent overflow.

@= ALGsum_implementation
mal_export str ALGsum_@1_@2(@2* res, int *bid) ;
str ALGsum_@1_@2(@2* res, int *bid) {
	BAT *b;
    if( (b= BATdescriptor(*bid)) == NULL ){
         return throwMessage("algebra.sum", "Cannot access descriptor");
    }

	CMDsum_@1_@2(res,b);
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

@= ALGprod_implementation
mal_export str ALGprod_@1_@2(@2* res, int *bid) ;
str ALGprod_@1_@2(@2* res, int *bid) {
	BAT *b;
    if( (b= BATdescriptor(*bid)) == NULL ){
         return throwMessage("algebra.prod", "Cannot access descriptor");
    }
	CMDprod_@1_@2(res,b);
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}
@c

@:ALGsum_implementation(sht,sht,0)@
@:ALGsum_implementation(sht,int,0)@
@:ALGsum_implementation(sht,lng,0)@
@:ALGsum_implementation(int,int,0)@
@:ALGsum_implementation(int,lng,0)@
@:ALGsum_implementation(lng,lng,0)@
@:ALGsum_implementation(flt,flt,0.0)@
@:ALGsum_implementation(flt,dbl,0.0)@
@:ALGsum_implementation(dbl,dbl,0.0)@

@:ALGprod_implementation(sht,sht,1)@
@:ALGprod_implementation(sht,int,1)@
@:ALGprod_implementation(sht,lng,1)@
@:ALGprod_implementation(int,int,1)@
@:ALGprod_implementation(int,lng,1)@
@:ALGprod_implementation(lng,lng,1)@
@:ALGprod_implementation(flt,flt,1.0)@
@:ALGprod_implementation(flt,dbl,1.0)@
@:ALGprod_implementation(dbl,dbl,1.0)@

@-
@= ALGaggregate_implementation
mal_export str ALGmin_@1(@1* res, int *bid) ;
str ALGmin_@1(@1* res, int *bid) {
	BAT *b;
    if( (b= BATdescriptor(*bid)) == NULL ){
         return throwMessage("algebra.min", "Cannot access descriptor");
    }
	if( CMDmin_@1(res,b)) {
		BBPunfix(b->batCacheid);
		return MAL_SUCCEED;
	}
	BBPunfix(b->batCacheid);
	return throwMessage("algebra.min", "GDKerror");
}
mal_export str ALGmax_@1(@1* res, int *bid) ;
str ALGmax_@1(@1* res, int *bid) {
	BAT *b;
    if( (b= BATdescriptor(*bid)) == NULL ){
         return throwMessage("algebra.min", "Cannot access descriptor");
    }
	if( CMDmax_@1(res,b)) {
		BBPunfix(b->batCacheid);
		return MAL_SUCCEED;
	}
	BBPunfix(b->batCacheid);
	return throwMessage("algebra.max", "GDKerror");
}
@c
@:ALGaggregate_implementation(sht)@
@:ALGaggregate_implementation(int)@
@:ALGaggregate_implementation(flt)@
@:ALGaggregate_implementation(dbl)@
@:ALGaggregate_implementation(lng)@

mal_export str ALGminany(ptr result, int *bid);
str
ALGminany(ptr result, int *bid)
{
	BAT *b;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("algebra.min", "Cannot access descriptor");
	}
	if (CMDminany(result, b) == GDK_SUCCEED) {
		BBPunfix(b->batCacheid);
		return MAL_SUCCEED;
	}
	BBPunfix(b->batCacheid);
	return throwMessage("algebra.min", "GDKerror");
}

mal_export str ALGmaxany(ptr result, int *bid);
str
ALGmaxany(ptr result, int *bid)
{
	BAT *b;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("algebra.min", "Cannot access descriptor");
	}
	if (CMDmaxany(result, b) == GDK_SUCCEED) {
		BBPunfix(b->batCacheid);
		return MAL_SUCCEED;
	}
	BBPunfix(b->batCacheid);
	return throwMessage("algebra.max", "GDKerror");
}


mal_export str ALGtopN(int *res, int *bid, lng *top);
str
ALGtopN(int *res, int *bid, lng *top)
{
	BAT *b;

	b = BATdescriptor(*bid);
	if (b == NULL) {
		return throwMessage("algebra.top", "Cannot access descriptor");
	}
	(void) BATtopN(b, (size_t) *top);
	BBPincref(*res = b->batCacheid, TRUE);
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}
mal_export str ALGgroupby(int *res, int *bid);
str
ALGgroupby(int *res, int *bid)
{
	BAT *b,*bn;

	b = BATdescriptor(*bid);
	if (b == NULL) {
		return throwMessage("algebra.groupby", "Cannot access descriptor");
	}
	if( CMDgen_group(&bn,b) == GDK_FAIL){
		BBPunfix(b->batCacheid);
		return throwMessage("algebra.groupby","unknown error");
	}
	if( bn){
		BBPincref(*res = bn->batCacheid, TRUE);
		BBPunfix(bn->batCacheid);
	}
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

mal_export str ALGcard(lng *result, int *bid);
str
ALGcard(lng *result, int *bid)
{
	BAT *b, *bn;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("algebra.card", "Cannot access descriptor");
	}
	bn = (BAT *) BATkunique(BATmirror(b));
	if (bn == NULL) {
		return throwMessage("algebra.card", "GDKerror");
	}
	*result = BATcount(bn);
	BBPunfix(bn->batCacheid);
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

mal_export str ALGBATminimum(ptr *result, int *bid);
str
ALGBATminimum(ptr *result, int *bid)
{
	BAT *b;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("algebra.min", "Cannot access descriptor");
	}
	BATmin(b, result);
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

mal_export str ALGBATmaximum(ptr *result, int *bid);
str
ALGBATmaximum(ptr *result, int *bid)
{
	BAT *b;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("algebra.max", "Cannot access descriptor");
	}
	BATmax(b, result);
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

mal_export str ALGselect1(int *result, int *bid, ptr value);
str
ALGselect1(int *result, int *bid, ptr value)
{
	BAT *b, *bn = NULL;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("algebra.select", "Cannot access descriptor");
	}
	@:derefStr(b,t,value)@
	CMDselect1(&bn, b, value);
	BBPunfix(b->batCacheid);
	if (bn) {
		bn = BATsetaccess(bn, 1);
		BBPincref(*result = bn->batCacheid, TRUE);
		BBPunfix(*result);
		return MAL_SUCCEED;
	}
	return throwMessage("algebra.select", "GDKerror");
}

mal_export str ALGselect1Head(int *result, int *bid, ptr value);
str
ALGselect1Head(int *result, int *bid, ptr value)
{
	BAT *b, *bn = NULL;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("algebra.select", "Cannot access descriptor");
	}
	b = BATmirror(b);
	@:derefStr(b,t,value)@
	CMDselect1(&bn, b, value);
	bn = BATmirror(bn);
	BBPunfix(b->batCacheid);
	if (bn) {
		bn = BATsetaccess(bn, 1);
		BBPincref(*result = bn->batCacheid, TRUE);
		BBPunfix(*result);
		return MAL_SUCCEED;
	}
	return throwMessage("algebra.select", "GDKerror");
}

mal_export str ALGuselect1(int *result, int *bid, ptr value);
str
ALGuselect1(int *result, int *bid, ptr value)
{
	BAT *b, *bn = NULL;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("algebra.uselect", "Cannot access descriptor");
	}
	@:derefStr(b,t,value)@
	CMDuselect1(&bn, b, value);
	BBPunfix(b->batCacheid);
	if (bn) {
		bn = BATsetaccess(bn, 1);
		BBPincref(*result = bn->batCacheid, TRUE);
		BBPunfix(*result);
		return MAL_SUCCEED;
	}
	return throwMessage("algebra.uselect", "GDKerror");
}

mal_export str ALGselect(int *result, int *bid, ptr low, ptr high);
str
ALGselect(int *result, int *bid, ptr low, ptr high)
{
	BAT *b, *bn = NULL;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("algebra.select", "Cannot access descriptor");
	}
	@:derefStr(b,t,low)@
	@:derefStr(b,t,high)@
	CMDselect(&bn, b, low, high);
	BBPunfix(b->batCacheid);
	if (bn) {
		bn = BATsetaccess(bn, 1);
		BBPincref(*result = bn->batCacheid, TRUE);
		BBPunfix(*result);
		return MAL_SUCCEED;
	}
	return throwMessage("algebra.select", "GDKerror");
}

mal_export str ALGselectHead(int *result, int *bid, ptr low, ptr high);
str
ALGselectHead(int *result, int *bid, ptr low, ptr high)
{
	BAT *b, *bn = NULL;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("algebra.select", "Cannot access descriptor");
	}
	b = BATmirror(b);
	@:derefStr(b,t,low)@
	@:derefStr(b,t,high)@
	CMDselect(&bn, b, low, high);
	bn = BATmirror(bn);
	BBPunfix(b->batCacheid);
	if (bn) {
		bn = BATsetaccess(bn, 1);
		BBPincref(*result = bn->batCacheid, TRUE);
		BBPunfix(*result);
		return MAL_SUCCEED;
	}
	return throwMessage("algebra.select", "GDKerror");
}

mal_export str ALGuselect(int *result, int *bid, ptr low, ptr high);
str
ALGuselect(int *result, int *bid, ptr low, ptr high)
{
	BAT *b, *bn = NULL;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("algebra.uselect", "Cannot access descriptor");
	}
	@:derefStr(b,t,low);@
	@:derefStr(b,t,high);@
	CMDuselect(&bn, b, low, high);
	if (bn) {
		bn = BATsetaccess(bn, 1);
		BBPincref(*result = bn->batCacheid, TRUE);
		BBPunfix(*result);
		BBPunfix(b->batCacheid);
		return MAL_SUCCEED;
	}
	BBPunfix(b->batCacheid);
	return throwMessage("algebra.uselect", "GDKerror");
}

mal_export str ALGselectInclusive(int *result, int *bid, ptr low, ptr high, bit *lin, bit *rin);
str
ALGselectInclusive(int *result, int *bid, ptr low, ptr high, bit *lin, bit *rin)
{
	BAT *b, *bn = NULL;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("algebra.select", "Cannot access descriptor");
	}
	@:derefStr(b,t,low)@
	@:derefStr(b,t,high)@
	CMDselect_(&bn, b, low, high, lin, rin);
	BBPunfix(b->batCacheid);
	if (bn) {
		bn = BATsetaccess(bn, 1);
		BBPincref(*result = bn->batCacheid, TRUE);
		BBPunfix(*result);
		return MAL_SUCCEED;
	}
	return throwMessage("algebra.select", "GDKerror");
}

mal_export str ALGselectInclusiveHead(int *result, int *bid, ptr low, ptr high, bit *lin, bit *rin);
str
ALGselectInclusiveHead(int *result, int *bid, ptr low, ptr high, bit *lin, bit *rin)
{
	BAT *b, *bn = NULL;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("algebra.select", "Cannot access descriptor");
	}
	b = BATmirror(b);
	@:derefStr(b,t,low)@
	@:derefStr(b,t,high)@
	CMDselect_(&bn, b, low, high, lin, rin);
	bn = BATmirror(bn);
	BBPunfix(b->batCacheid);
	if (bn) {
		bn = BATsetaccess(bn, 1);
		BBPincref(*result = bn->batCacheid, TRUE);
		BBPunfix(*result);
		return MAL_SUCCEED;
	}
	return throwMessage("algebra.select", "GDKerror");
}

mal_export str ALGuselectInclusive(int *result, int *bid, ptr low, ptr high, bit *lin, bit *rin);
str
ALGuselectInclusive(int *result, int *bid, ptr low, ptr high, bit *lin, bit *rin)
{
	BAT *b, *bn = NULL;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("algebra.select", "Cannot access descriptor");
	}
	@:derefStr(b,t,low);@
	@:derefStr(b,t,high);@
	CMDuselect_(&bn, b, low, high, lin, rin);
	BBPunfix(b->batCacheid);
	if (bn) {
		bn = BATsetaccess(bn, 1);
		BBPincref(*result = bn->batCacheid, TRUE);
		BBPunfix(*result);
		return MAL_SUCCEED;
	}
	return throwMessage("algebra.uselect", "GDKerror");
}

mal_export str ALGfragment(int *result, int *bid, ptr hlow, ptr hhigh, ptr tlow, ptr thigh);
str
ALGfragment(int *result, int *bid, ptr hlow, ptr hhigh, ptr tlow, ptr thigh)
{
	BAT *b, *bn = NULL;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("algebra.fragment", "Cannot access descriptor");
	}
	@:derefStr(b,h,hlow);@
	@:derefStr(b,h,hhigh);@
	@:derefStr(b,t,tlow);@
	@:derefStr(b,t,thigh);@
	CMDfragment(&bn, b, hlow, hhigh, tlow, thigh);
	BBPunfix(b->batCacheid);
	if (bn) {
		bn = BATsetaccess(bn, 1);
		BBPincref(*result = bn->batCacheid, TRUE);
		BBPunfix(*result);
		return MAL_SUCCEED;
	}
	return throwMessage("algebra.fragment", "GDKerror");
}

static int
operatorCode(str opname)
{
	if (idcmp(opname, "EQ") == 0)
		return 0;
	if (idcmp(opname, "LT") == 0)
		return -1;
	if (idcmp(opname, "LE") == 0)
		return -2;
	if (idcmp(opname, "GT") == 0)
		return 1;
	if (idcmp(opname, "GE") == 0)
		return 2;
	GDKerror("Illegal operator code, EQ assumed\n");
	return 0;
}

mal_export str ALGthetajoinEstimate(int *result, int *lid, int *rid, int *opc, lng *estimate);
str
ALGthetajoinEstimate(int *result, int *lid, int *rid, int *opc, lng *estimate)
{
	BAT *left, *right, *bn = NULL;

	if ((left = BATdescriptor(*lid)) == NULL) {
		return throwMessage("algebra.thetajoin", "Cannot access descriptor");
	}
	if ((right = BATdescriptor(*rid)) == NULL) {
		BBPunfix(left->batCacheid);
		return throwMessage("algebra.thetajoin", "Cannot access descriptor");
	}
	if( *opc == -3 ){
		/* The NE case is not supported in the kernel */
		BBPunfix(left->batCacheid);
		BBPunfix(right->batCacheid);
		return throwMessage("algebra.thetajoin", "theta <> not yet supported");
	} 
	CMDthetajoin(&bn, left, right, opc, estimate);
	BBPunfix(left->batCacheid);
	BBPunfix(right->batCacheid);
	if (bn) {
		bn = BATsetaccess(bn, 1);
		BBPincref(*result = bn->batCacheid, TRUE);
		BBPunfix(*result);
		return MAL_SUCCEED;
	}
	return throwMessage("algebra.thetajoin", "GDKerror");
}

mal_export str ALGthetajoin(int *result, int *lid, int *rid, int *opc);
str
ALGthetajoin(int *result, int *lid, int *rid, int *opc)
{
	return ALGthetajoinEstimate(result, lid, rid, opc, &lng_nil);
}

mal_export str ALGbandjoin(int *result, int *lid, int *rid, ptr *minus, ptr *plus);
str
ALGbandjoin(int *result, int *lid, int *rid, ptr *minus, ptr *plus)
{
	BAT *left, *right, *bn = NULL;

	if ((left = BATdescriptor(*lid)) == NULL) {
		return throwMessage("algebra.bandjoin", "Cannot access descriptor");
	}
	if ((right = BATdescriptor(*rid)) == NULL) {
		BBPunfix(left->batCacheid);
		return throwMessage("algebra.bandjoin", "Cannot access descriptor");
	}
	CMDbandjoin(&bn, left, right, minus, plus);
	BBPunfix(left->batCacheid);
	BBPunfix(right->batCacheid);
	if (bn) {
		bn = BATsetaccess(bn, 1);
		BBPincref(*result = bn->batCacheid, TRUE);
		BBPunfix(*result);
		return MAL_SUCCEED;
	}
	return throwMessage("algebra.bandjoin", "GDKerror");
}

@-
Let cut this text down with some Mx macro's
@= ALGunary
mal_export str ALG@1(int *result, int *bid);
str ALG@1(int *result, int *bid) {
	BAT *b,*bn;
    if( (b= BATdescriptor(*bid)) == NULL ){
        return throwMessage("algebra.@1", "Cannot access descriptor");
    }
	CMD@1(&bn,b);
	BBPunfix(b->batCacheid);
	if( bn ) {
		bn= BATsetaccess(bn,1);
		BBPincref(*result = bn->batCacheid,TRUE);
		BBPunfix(*result);
		return MAL_SUCCEED;
	}
	return throwMessage("algebra.@1", "GDKerror");
}
@= ALGunaryint
mal_export str ALG@1(int *result, int *bid);
str ALG@1(int *result, int *bid) {
	BAT *b,*bn= NULL;
    if( (b= BATdescriptor(*bid)) == NULL ){
        return throwMessage("algebra.@1", "Cannot access descriptor");
    }
	CMD@1(&bn,b);
	BBPunfix(b->batCacheid);
	if( bn ) {
		bn= BATsetaccess(bn,1);
		BBPincref(*result = bn->batCacheid,TRUE);
		BBPunfix(*result);
		return MAL_SUCCEED;
	}
	return MAL_SUCCEED;
}
@= ALGbinary
mal_export str ALG@1(int *result, int *lid, int *rid) ;
str ALG@1(int *result, int *lid, int *rid) {
	BAT *left, *right,*bn= NULL;
    if( (left= BATdescriptor(*lid)) == NULL ){
        return throwMessage("algebra.@1", "Cannot access descriptor");
    }
    if( (right= BATdescriptor(*rid)) == NULL ){
		BBPunfix(left->batCacheid);
        return throwMessage("algebra.@1", "Cannot access descriptor");
    }
	CMD@1(&bn,left, right);
	BBPunfix(left->batCacheid);
	BBPunfix(right->batCacheid);
	if( bn ) {
		bn= BATsetaccess(bn,1);
		BBPincref(*result = bn->batCacheid,TRUE);
		BBPunfix(*result);
		return MAL_SUCCEED;
	}
	return throwMessage("algebra.@1", "GDKerror");
}
@= ALGbinaryint
mal_export str ALG@1(int *result, int* bid, int *param) ;
str ALG@1(int *result, int* bid, int *param) {
	BAT *b, *bn= NULL;
    if( (b= BATdescriptor(*bid)) == NULL ){
        return throwMessage("algebra.@1", "Cannot access descriptor");
    }
	CMD@1(&bn,b, param);
	BBPunfix(b->batCacheid);
	if( bn ) {
		bn= BATsetaccess(bn,1);
		BBPincref(*result = bn->batCacheid,TRUE);
		BBPunfix(*result);
		return MAL_SUCCEED;
	}
	return throwMessage("algebra.@1", "GDKerror");
}
@= ALGbinaryestimate
mal_export str ALG@1estimate(int *result, int *lid, int *rid, lng *estimate);
str ALG@1estimate(int *result, int *lid, int *rid, lng *estimate) {
	BAT *left, *right,*bn=NULL;
    if( (left= BATdescriptor(*lid)) == NULL ){
        return throwMessage("algebra.@1", "Cannot access descriptor");
    }
    if( (right= BATdescriptor(*rid)) == NULL ){
		BBPunfix(left->batCacheid);
        return throwMessage("algebra.@1", "Cannot access descriptor");
    }
	CMD@1(&bn,left, right, estimate);
	BBPunfix(left->batCacheid);
	BBPunfix(right->batCacheid);
	if( bn ) {
		bn= BATsetaccess(bn,1);
		BBPincref(*result = bn->batCacheid,TRUE);
		BBPunfix(*result);
		return MAL_SUCCEED;
	}
	return throwMessage("algebra.@1", "GDKerror");
}
mal_export str ALG@1(int *result, int* bid, int *param);
str ALG@1(int *result, int* bid, int *param) {
	return ALG@1estimate(result,bid,param,&lng_nil);
}
@c
@:ALGunary(histogram)@
@:ALGunary(number)@
@:ALGunary(merge)@
@:ALGunary(split)@
@:ALGunary(copy)@
@:ALGunary(kunique)@
@:ALGunary(sunique)@
@:ALGbinary(cross)@
@:ALGbinary(antijoin)@
@:ALGbinaryestimate(join)@
@:ALGbinaryestimate(outerjoin)@
@:ALGbinary(semijoin)@
@:ALGbinary(sunion)@
@:ALGbinary(kunion)@
@:ALGbinary(sintersect)@
@:ALGbinary(kintersect)@
@:ALGbinary(sdiff)@
@:ALGbinary(kdiff)@
@:ALGbinaryint(sample)@

/* add item missing in the kernel */
mal_export str ALGtunique(int *result, int *bid);
str
ALGtunique(int *result, int *bid)
{
	BAT *b, *bn;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("algebra.tunique", "Cannot access descriptor");
	}
	CMDkunique(&bn, BATmirror(b));
	BBPunfix(b->batCacheid);
	if (bn) {
		bn = BATsetaccess(BATmirror(bn), 1);
		BBPincref(*result = bn->batCacheid, TRUE);
		BBPunfix(*result);
		return MAL_SUCCEED;
	}
	return throwMessage("algebra.tunique", "GDKerror");
}

mal_export str ALGtsort(int *result, int *bid);
str
ALGtsort(int *result, int *bid)
{
	BAT *b, *bn;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("algebra.tsort", "Cannot access descriptor");
	}
	CMDsort(&bn, BATmirror(b));
	BBPunfix(b->batCacheid);
	if (bn) {
		bn = BATsetaccess(BATmirror(bn), 1);
		BBPincref(*result = bn->batCacheid, TRUE);
		BBPunfix(*result);
		return MAL_SUCCEED;
	}
	return throwMessage("algebra.tunique", "GDKerror");
}

mal_export str ALGhsort(int *result, int *bid);
str
ALGhsort(int *result, int *bid)
{
	BAT *b, *bn;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("algebra.hsort", "Cannot access descriptor");
	}
	CMDsort(&bn, b);
	BBPunfix(b->batCacheid);
	if (bn) {
		bn = BATsetaccess(bn, 1);
		BBPincref(*result = bn->batCacheid, TRUE);
		BBPunfix(*result);
		return MAL_SUCCEED;
	}
	return throwMessage("algebra.tunique", "GDKerror");
}

mal_export str ALGhtsort(int *result, int *lid);
str
ALGhtsort(int *result, int *lid)
{
	BAT *b, *bc, *bk, *bn = NULL;
	size_t cnt;
	ptr p, q;

	if ((b = BATdescriptor(*lid)) == NULL) {
		return throwMessage("algebra.htsort", "Cannot access descriptor");
	}
	cnt = BATcount(b);
	bn = BATnew(b->htype, b->ttype, cnt);
	if (bn == 0)
		return throwMessage("algebra.htsort", "GDKerror");
	bk = BATsort(BATkunique(b));
	BATloop(bk, p, q) {
		b = (((b)->batCacheid < 0) ? (b) : BATmirror(b));
		bc = BATselect(b, p, p);
		bc = BATsort(bc);
		bc = (((bc)->batCacheid < 0) ? (bc) : BATmirror(bc));
		BATins(bn, bc);
	}
	BBPunfix(b->batCacheid);
	if (bn) {
		bn = BATsetaccess(bn, 1);
		BBPincref(*result = bn->batCacheid, TRUE);
		BBPunfix(*result);
		return MAL_SUCCEED;
	}
	return throwMessage("algebra.htsort", "GDKerror");
}

mal_export str ALGthsort(int *result, int *lid);
str
ALGthsort(int *result, int *lid)
{
	BAT *b, *bc, *bk, *bn = NULL;
	size_t cnt;
	ptr p, q;

	if ((b = BATdescriptor(*lid)) == NULL) {
		return throwMessage("algebra.thsort", "Cannot access descriptor");
	}
	cnt = BATcount(b);
	bn = BATnew(b->htype, b->ttype, cnt);
	if (bn == 0)
		return throwMessage("algebra.thsort", "GDKerror");
	b = (((b)->batCacheid < 0) ? (b) : BATmirror(b));
	bk = BATsort(BATkunique(b));
	BATloop(bk, p, q) {
		bc = BATselect(b, p, p);
		bc = BATsort(bc);
		BATins(bn, bc);
	}
	BBPunfix(b->batCacheid);
	if (bn) {
		bn = BATsetaccess(bn, 1);
		BBPincref(*result = bn->batCacheid, TRUE);
		BBPunfix(*result);
		return MAL_SUCCEED;
	}
	return throwMessage("algebra.htsort", "GDKerror");
}

mal_export str ALGrevert(int *result, int *bid);
str
ALGrevert(int *result, int *bid)
{
	BAT *b, *bn;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("algebra.tsort", "Cannot access descriptor");
	}
	bn= BATcopy(b);
	BATrevert(bn);
	BBPincref(*result= bn->batCacheid,TRUE);
	BBPunfix(bn->batCacheid);
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

mal_export str ALGcount_bat(int *result, int *bid);
str
ALGcount_bat(int *result, int *bid)
{
	BAT *b;
	size_t cnt;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("aggr.count", "Cannot access descriptor");
	}
	cnt = (int)  BATcount(b);
	*result = cnt;
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

mal_export str ALGcount_nil(int *result, int *bid, bit *ignore_nils);
str
ALGcount_nil(int *result, int *bid, bit *ignore_nils)
{
	BAT *b;
	size_t cnt;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("aggr.count", "Cannot access descriptor");
	}
	if (*ignore_nils)
		cnt = BATcount_no_nil(b);
	else
		cnt = BATcount(b);
	*result = (int) cnt;
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

mal_export str ALGcount_no_nil(int *result, int *bid);
str
ALGcount_no_nil(int *result, int *bid)
{
	bit ignore_nils = 1;

	return ALGcount_nil(result, bid, &ignore_nils);
}

mal_export str ALGtmark(int *result, int *bid, oid *base);
str
ALGtmark(int *result, int *bid, oid *base)
{
	BAT *b, *bn = NULL;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("algebra.tmark", "Cannot access descriptor");
	}
	if (CMDmark(&bn, b, base) == GDK_SUCCEED) {
		BBPunfix(b->batCacheid);
		bn = BATsetaccess(bn, 1);
		BBPincref(*result = bn->batCacheid, TRUE);
		BBPunfix(*result);
		return MAL_SUCCEED;
	}
	BBPunfix(b->batCacheid);
	return throwMessage("algebra.mark", "marking group failed");
}

mal_export str ALGtmark_default(int *result, int *bid);
str
ALGtmark_default(int *result, int *bid)
{
	oid o = oid_nil;

	return ALGtmark(result, bid, &o);
}

mal_export str ALGmarkHead(int *result, int *bid, oid *base);
str
ALGmarkHead(int *result, int *bid, oid *base)
{
	BAT *b, *bn = NULL;
	ptr p, q;
	oid o = oid_nil, on = 0;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("algebra.markH", "Cannot access descriptor");
	}
	if (b->htype == TYPE_void) {
		bn = BATnew(TYPE_void, TYPE_oid, BATcount(b));
		BATloop(b, p, q) {
			BUNins(bn, &o, &on);
			on++;
		}
	} else {
		bn = BATnew(TYPE_void, b->htype, BATcount(b));
		BATseqbase(bn, *base);
		BATloop(b, p, q) {
			BUNins(bn, &o, BUNhead(b, p));
		}
	}

	BBPincref(*result = bn->batCacheid, TRUE);
	BBPunfix(b->batCacheid);
	BBPunfix(bn->batCacheid);
	return MAL_SUCCEED;
}

mal_export str ALGmarkHead_default(int *result, int *bid);
str
ALGmarkHead_default(int *result, int *bid)
{
	oid o = 0;

	return ALGmarkHead(result, bid, &o);
}

mal_export str ALGmarkHead_default1(int *result, int *bid);
str
ALGmarkHead_default1(int *result, int *bid)
{
	oid o = 0;

	return ALGmarkHead(result, bid, &o);
}

mal_export str ALGhashsplit(int *result, int *bid, int *nfrag);
str
ALGhashsplit(int *result, int *bid, int *nfrag)
{
	BAT *b, *bn = NULL;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("algebra.hashsplit", "Cannot access descriptor");
	}
	CMDhashsplit(&bn, b, nfrag);
	if (bn) {
		BBPunfix(b->batCacheid);
		bn = BATsetaccess(bn, 1);
		BBPincref(*result = bn->batCacheid, TRUE);
		BBPunfix(*result);
		return MAL_SUCCEED;
	}
	BBPunfix(b->batCacheid);
	return throwMessage("algebra.hashsplit", "GDKerror");
}

mal_export str ALGuhashsplit(int *result, int *bid, int *nfrag);
str
ALGuhashsplit(int *result, int *bid, int *nfrag)
{
	BAT *b, *bn = NULL;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("algebra.uhashsplit", "Cannot access descriptor");
	}
	CMDuhashsplit(&bn, b, nfrag);
	if (bn) {
		BBPunfix(b->batCacheid);
		bn = BATsetaccess(bn, 1);
		BBPincref(*result = bn->batCacheid, TRUE);
		BBPunfix(*result);
		return MAL_SUCCEED;
	}
	BBPunfix(b->batCacheid);
	return throwMessage("algebra.uhashsplit", "GDKerror");
}

mal_export str ALGrangesplit(int *result, int *bid, int *nfrag);
str
ALGrangesplit(int *result, int *bid, int *nfrag)
{
	BAT *b, *bn = NULL;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("algebra.rangesplit", "Cannot access descriptor");
	}
	CMDrangesplit(&bn, b, nfrag);
	BBPunfix(b->batCacheid);
	if (bn) {
		bn = BATsetaccess(bn, 1);
		BBPincref(*result = bn->batCacheid, TRUE);
		BBPunfix(*result);
		return MAL_SUCCEED;
	}
	return throwMessage("algebra.rangesplit", "GDKerror");
}

mal_export str ALGurangesplit(int *result, int *bid, int *nfrag);
str
ALGurangesplit(int *result, int *bid, int *nfrag)
{
	BAT *b, *bn = NULL;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("algebra.urangesplit", "Cannot access descriptor");
	}
	CMDurangesplit(&bn, b, nfrag);
	BBPunfix(b->batCacheid);
	if (bn) {
		bn = BATsetaccess(bn, 1);
		BBPincref(*result = bn->batCacheid, TRUE);
		BBPunfix(*result);
		return MAL_SUCCEED;
	}
	return throwMessage("algebra.urangesplit", "GDKerror");
}

mal_export str ALGhistogram_rev(int *result, int *bid);
str
ALGhistogram_rev(int *result, int *bid)
{
	BAT *b, *bn = NULL;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("algebra.histogram", "Cannot access descriptor");
	}
	CMDhistogram(&bn, b);
	BBPunfix(b->batCacheid);
	if (bn) {
		bn = BATsetaccess(bn, 1);
		BBPincref(*result = bn->batCacheid, TRUE);
		BBPunfix(*result);
		return MAL_SUCCEED;
	}
	BBPunfix(b->batCacheid);
	return throwMessage("algebra.histogram", "GDKerror");
}

mal_export str ALGlike(int *ret, int *bid, str *k);
str
ALGlike(int *ret, int *bid, str *k)
{
	BAT *b, *bn = NULL;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("algebra.like", "Cannot access descriptor");
	}
	CMDlike(&bn, b, *k);
	BBPunfix(b->batCacheid);
	if (bn) {
		BBPunfix(b->batCacheid);
		bn = BATsetaccess(bn, 1);
		BBPincref(*ret = bn->batCacheid, TRUE);
		BBPunfix(*ret);
		return MAL_SUCCEED;
	}
	return throwMessage("algebra.like", "GDKerror");
}

mal_export str ALGslice(int *ret, bat *bid, int *start, int *end);
str
ALGslice(int *ret, bat *bid, int *start, int *end)
{
	BAT *b, *bn = NULL;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("algebra.slice", "Cannot access descriptor");
	}
	CMDslice(&bn, b, start, end);
	BBPunfix(b->batCacheid);
	if (bn != NULL) {
		bn = BATsetaccess(bn, 1);
		BBPincref(*ret = bn->batCacheid, TRUE);
		BBPunfix(*ret);
		return MAL_SUCCEED;
	}
	return throwMessage("algebra.slice", "GDKerror");
}

@- BUN Get/Fetch
@c
mal_export str ALGposition(int *retval, int *bid, ptr val);
str
ALGposition(int *retval, int *bid, ptr val)
{
	BAT *b;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("algebra.position", "Cannot access descriptor");
	}
	@:derefStr(b,h,val)@
	CMDposition(retval, b, val);
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

mal_export str ALGpositionBUN(int *retval, int *bid, ptr val, ptr tval);
str
ALGpositionBUN(int *retval, int *bid, ptr val, ptr tval)
{
	BAT *b;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("algebra.position", "Cannot access descriptor");
	}
	@:derefStr(b,h,val)@
	@:derefStr(b,t,tval)@
	CMDpositionBUN(retval, b, val, tval);
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

mal_export str doALGfetch(ptr ret, BAT *b, lng *pos);
str
doALGfetch(ptr ret, BAT *b, lng *pos)
{
	lng i = *pos;

	if ((i < 0) || (i >= BATcount(b)))
		return throwMessage("algebra.fetch", " idx out of range");
	i += BUNindex(b, BUNfirst(b));
	@:putTail(BUNptr(b,i))@
@= putTail
        if (b->theap) {
            ptr _src = BUNtvar(b,@1); /*b->theap->base + *(var_t*) BUNtloc(b,@1);*/
            int _len = ATOMlen(b->ttype, _src);
            ptr _dst = GDKmalloc(_len);
            memcpy(_dst, _src, _len);
            *(ptr*) ret = _dst;
        } else {
            int _s = ATOMsize(ATOMtype(b->ttype));
            if (ATOMvarsized(b->ttype)) {
                memcpy(*(ptr*) ret=GDKmalloc(_s), BUNtloc(b, @1), _s);
            } else if (b->ttype == TYPE_bat) {
                bat bid = *(bat*) BUNtloc(b, @1);
                *(bat*) ret = bid;
                BBPincref(bid,TRUE);
            } else if (_s == 4) {
                *(int*) ret = *(int*) BUNtail(b, @1);
            } else if (_s == 1) {
                *(chr*) ret = *(chr*) BUNtail(b, @1);
            } else if (_s == 2) {
                *(sht*) ret = *(sht*) BUNtail(b, @1);
            } else if (_s == 8) {
                *(lng*) ret = *(lng*) BUNtail(b, @1);
            } else {
                memcpy(ret, BUNtloc(b, @1), _s);
            }
        }
@c
	return MAL_SUCCEED;
}

mal_export str ALGfetch(ptr ret, int *bid, lng *pos);
str
ALGfetch(ptr ret, int *bid, lng *pos)
{
	BAT *b;
	str msg;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("algebra.fetch", "Cannot access descriptor");
	}
	msg = doALGfetch(ret, b, pos);
	BBPunfix(b->batCacheid);
	return msg;
}

mal_export str ALGfetchoid(int *ret, int *bid, oid *pos);
str
ALGfetchoid(int *ret, int *bid, oid *pos)
{
	lng o = *pos;

	ALGfetch(ret, bid, &o);
	return MAL_SUCCEED;
}

mal_export str ALGfetchint(int *ret, int *bid, int *pos);
str
ALGfetchint(int *ret, int *bid, int *pos)
{
	lng o = *pos;

	return ALGfetch(ret, bid, &o);
}

mal_export str ALGfetchbat(int *ret, int *bid, int *sid);
str
ALGfetchbat(int *ret, int *bid, int *sid)
{
	BAT *b, *s, *bn = NULL;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("algebra.fetch", "Cannot access descriptor");
	}
	if ((s = BATdescriptor(*sid)) == NULL) {
		BBPunfix(b->batCacheid);
		return throwMessage("algebra.fetch", "Cannot access descriptor");
	}

	bn = BATfetch(b, s);
	BBPunfix(b->batCacheid);
	BBPunfix(s->batCacheid);
	if (bn) {
		bn = BATsetaccess(bn, 1);
		BBPincref(*ret = bn->batCacheid, TRUE);
		BBPunfix(*ret);
		return MAL_SUCCEED;
	}
	return throwMessage("algebra.fetchbat", "GDKerror");

}

mal_export str ALGexist(bit *ret, int *bid, ptr val);
str
ALGexist(bit *ret, int *bid, ptr val)
{
	BAT *b;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("algebra.exist", "Cannot access descriptor");
	}
	@:derefStr(b,h,val)@
	CMDexist(ret, b, val);
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

mal_export str ALGexistBUN(bit *ret, int *bid, ptr val, ptr tval);
str
ALGexistBUN(bit *ret, int *bid, ptr val, ptr tval)
{
	BAT *b;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("algebra.exist", "Cannot access descriptor");
	}
	@:derefStr(b,h,val)@
	@:derefStr(b,t,tval)@
	CMDexistBUN(ret, b, val, tval);
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

mal_export str ALGfind(ptr ret, int *bid, ptr val);
str
ALGfind(ptr ret, int *bid, ptr val)
{
	BAT *b;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("algebra.find", "Cannot access descriptor");
	}
	@:derefStr(b,h,val)@
	if (CMDfind(ret, b, val) == GDK_FAIL) {
		BBPunfix(b->batCacheid);
		return throwMessage("algebra.find", "can not find element");
	}
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

mal_export str ALGfetchjoin(int *result, int *lid, int *rid);
str
ALGfetchjoin(int *result, int *lid, int *rid)
{
	BAT *left, *right, *bn = 0;
	int rfetch, lfetch;

	if ((left = BATdescriptor(*lid)) == NULL) {
		return throwMessage("algebra.fetchjoin", "Cannot access descriptor");
	}
	if ((right = BATdescriptor(*rid)) == NULL) {
		BBPunfix(left->batCacheid);
		return throwMessage("algebra.fetchjoin", "Cannot access descriptor");
	}

	rfetch = (BAThdense(right) && ATOMstorage(left->ttype) <= TYPE_int);
	lfetch = (BATtdense(left) && ATOMstorage(right->htype) <= TYPE_int);
	if (lfetch && !(rfetch && BATcount(left) < BATcount(right))) {
		bn = BATfetchjoin(left, right, oid_nil);
	} else if (rfetch)
		bn = BATmirror(BATfetchjoin(BATmirror(right), BATmirror(left), oid_nil));

	BBPunfix(left->batCacheid);
	BBPunfix(right->batCacheid);
	if (bn) {
		bn = BATsetaccess(bn, 1);
		BBPincref(*result = bn->batCacheid, TRUE);
		BBPunfix(*result);
		return MAL_SUCCEED;
	}
	return throwMessage("algebra.fetchjoin", "can not perform a fetchjoin");
}

mal_export str ALGhashjoin(int *result, int *lid, int *rid);
str
ALGhashjoin(int *result, int *lid, int *rid)
{
	BAT *left, *right, *bn;
	int lsize, rsize;

	if ((left = BATdescriptor(*lid)) == NULL) {
		return throwMessage("algebra.hashjoin", "Cannot access descriptor");
	}
	if ((right = BATdescriptor(*rid)) == NULL) {
		BBPunfix(left->batCacheid);
		return throwMessage("algebra.hashjoin", "Cannot access descriptor");
	}

	lsize = left->batBuns->size + (left->hheap ? left->hheap->size : 0) + (left->theap ? left->theap->size : 0);
	rsize = right->batBuns->size + (right->hheap ? right->hheap->size : 0) + (right->theap ? right->theap->size : 0);

	if (rsize < lsize)
		bn = BATmirror(BAThashjoin(BATmirror(right), BATmirror(left), oid_nil));
	else
		bn = BAThashjoin(left, right, oid_nil);

	BBPunfix(left->batCacheid);
	BBPunfix(right->batCacheid);
	if (bn) {
		bn = BATsetaccess(bn, 1);
		BBPincref(*result = bn->batCacheid, TRUE);
		BBPunfix(*result);
		return MAL_SUCCEED;
	}
	return throwMessage("algebra.hashjoin", "can not perform a hashjoin");
}

mal_export str ALGmergejoin(int *result, int *lid, int *rid);
str
ALGmergejoin(int *result, int *lid, int *rid)
{
	BAT *left, *right, *bn;

	if ((left = BATdescriptor(*lid)) == NULL) {
		return throwMessage("algebra.mergejoin", "Cannot access descriptor");
	}
	if ((right = BATdescriptor(*rid)) == NULL) {
		BBPunfix(left->batCacheid);
		return throwMessage("algebra.mergejoin", "Cannot access descriptor");
	}
	if (!((BATtordered(left) & 1) || (BAThordered(right) & 1)))
		return throwMessage("algebra.mergejoin", "neither left nor right bat is ordered.\n");

	if ((left->ttype == TYPE_void) || (right->htype == TYPE_void))
		return throwMessage("algebra.mergejoin", "Cannot perform mergejoin on void fields.\n");
	bn = BATmergejoin(left, right, oid_nil);
	BBPunfix(left->batCacheid);
	BBPunfix(right->batCacheid);
	if (bn) {
		bn = BATsetaccess(bn, 1);
		BBPincref(*result = bn->batCacheid, TRUE);
		BBPunfix(*result);
		return MAL_SUCCEED;
	}
	return throwMessage("algebra.mergejoin", "can not perform a mergejoin");
}

mal_export str ALGindexjoin(int *result, int *lid, int *rid);
str
ALGindexjoin(int *result, int *lid, int *rid)
{
	BAT *left, *right, *bn;

	if ((left = BATdescriptor(*lid)) == NULL) {
		return throwMessage("algebra.indexjoin", "Cannot access descriptor");
	}
	if ((right = BATdescriptor(*rid)) == NULL) {
		BBPunfix(left->batCacheid);
		return throwMessage("algebra.indexjoin", "Cannot access descriptor");
	}

	bn = BATthetajoin(left, right, JOIN_EQ, oid_nil);
	BBPunfix(left->batCacheid);
	BBPunfix(right->batCacheid);
	if (bn) {
		bn = BATsetaccess(bn, 1);
		BBPincref(*result = bn->batCacheid, TRUE);
		BBPunfix(*result);
		return MAL_SUCCEED;
	}
	return throwMessage("algebra.indexjoin", "can not perform a indexjoin");
}

@}
