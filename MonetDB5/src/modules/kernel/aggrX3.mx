@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2003 CWI.
@' All Rights Reserved.
@'
@' Contributor(s):
@'              Martin Kersten <Martin.Kersten@cwi.nl>
@'              Peter Boncz <Peter.Boncz@cwi.nl>
@'              Niels Nes <Niels.Nes@cwi.nl>
@'              Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f aggrX3
@a S. Manegold 
@t Improved & Extended Aggregates Module
@v 1.0

This module contains some efficient aggregate functions that compute their 
result in one scan, rather than in the iterative manner of the generic 
MIL aggr_ implementations.

The implementation code is derived from the original 'aggr' module. 
Major changes are
\begin{itemize}
\item
complete type-specific code expansion to avoid any type-checking in the inner-most loops;
\item
where feasable, replaced (expansive) hash-lookup by significantly cheaper positional
void-lookups (if the head-column of the group-extend BAT ("e") is "void") or at least by 
(also positional) array lookups (in case the group-ids span a reasonably small range);
\item
in addition to the 2-parameter {}(BAT[oid,any::1] b, BAT[oid,any] e)
functions, there are now also 3-parameter {}(BAT[void,any::1] b,
BAT[void,oid] g, BAT[oid,any] e) functions, that require b & g to be
head-aligned, and to the fetchjoin(reverse(g),b) on-the-fly;
\end{itemize}

The routines should not be stored in their own module, but
added to the 'group' module. This can be achieved by setting
the module.
@mal
module aggrX3;
#module group;

@= sum_avg_signatures
command sum(b:BAT[oid,@1],e:BAT[oid,any]) : BAT[oid,@1] = CMDaggrX3_sum_@1_@1
	comment "grouped tail sum on @1";
command prod(b:BAT[oid,@1],e:BAT[oid,any]) : BAT[oid,@1] = CMDaggrX3_prod_@1_@1
	comment "grouped tail product on @1";
command sum(b:BAT[oid,@1], g:BAT[oid,oid], e:BAT[oid,any]) : BAT[oid,@1] = CMDaggrX3_sum3_@1_@1
	comment "grouped tail sum on @1";
command avg(b:BAT[oid,@1], e:BAT[oid,any]) : BAT[oid,@1] = CMDaggrX3_avg_@1
	comment "grouped tail average on @1";
command avg(b:BAT[oid,@1], g:BAT[oid,oid], e:BAT[oid,any]) : BAT[oid,@1] = CMDaggrX3_avg3_@1
	comment "grouped tail average on @1";
@= sum_avg_signatures2
command sum(b:BAT[oid,@1],e:BAT[oid,any]) : BAT[oid,@1] = CMDaggrX3_sum_@1_@1
	comment "grouped tail sum on @1";
command sum(b:BAT[oid,@1], g:BAT[oid,oid], e:BAT[oid,any]) : BAT[oid,@1] = CMDaggrX3_sum3_@1_@1
	comment "grouped tail sum on @1";
command sum(b:BAT[oid,@1],e:BAT[oid,any]) : BAT[oid,@2] = CMDaggrX3_sum_@1_@2
	comment "grouped tail sum on @1";
command sum(b:BAT[oid,@1], g:BAT[oid,oid], e:BAT[oid,any]) : BAT[oid,@2] = CMDaggrX3_sum3_@1_@2
	comment "grouped tail sum on @1";
@mal
@:sum_avg_signatures(uchr)@
@:sum_avg_signatures(sht)@
@:sum_avg_signatures(int)@
@:sum_avg_signatures(dbl)@
@:sum_avg_signatures(lng)@
@:sum_avg_signatures2(flt,dbl)@
@:sum_avg_signatures2(sht,int)@
@:sum_avg_signatures2(int,lng)@
@:sum_avg_signatures(flt)@

command min(b:BAT[oid,any::1], e:BAT[oid,any]) : BAT[oid,any::1] = CMDaggrX3_min
	comment "grouped tail minimum";
command max(b:BAT[oid,any::1], e:BAT[oid,any]) : BAT[oid,any::1] = CMDaggrX3_max
	comment "grouped tail maximum";
command min(b:BAT[oid,any::1], g:BAT[oid,oid], e:BAT[oid,any]) : BAT[oid,any::1] = CMDaggrX3_min3
	comment "grouped tail minimum";
command max(b:BAT[oid,any::1], g:BAT[oid,oid], e:BAT[oid,any]) : BAT[oid,any::1] = CMDaggrX3_max3
	comment "grouped tail maximum";

command count(b:BAT[oid,any], e:BAT[oid,any]) : BAT[oid,int] = CMDaggrX3_count
	comment "grouped count";
command count(b:BAT[oid,any], g:BAT[oid,oid], e:BAT[oid,any], nonils:bit) : BAT[oid,int] = CMDaggrX3_count3
	comment "grouped count";

command size(b:BAT[oid,bit], e:BAT[oid,any]) : BAT[oid,int] = CMDaggrX3_size
	comment "grouped count of true values";
@-
OLD STUFF, recast in MAL proc 

    proc size(BAT[any,bit] b) : int {
	var h := b.histogram;
	if (h.exist(true)) 
	    return h.find(true);
	return 0;
    }

    proc avg(BAT[any, any::1] b) : any::1 {
	var cnt := count(b);
        if (cnt = 0) 
	    return cast(0,ttype(b));
	return /(sum(b),cast(cnt,ttype(b)));
    }

    proc card(BAT[any,any] b) : int {
	return b.tunique.count;
    }

    proc {card}(BAT[oid,any] b, BAT[oid,any] e) : BAT[oid,int] {
	return {count}(b.sunique,e);
    }
@{
@+ Test Script
@mil

proc toset(bat[any,any] b) : str {
        var res := "{ ";
        b@batloop() {
                res :+= str($t) + " ";
        }
        return res + "}";
}

proc aggrtst(int num, int fanout, str aggr) {
	var p := 3;
	while((p :+= 1) <= $0) {
	        var b, e, v := bat(void, int, num);
	        var tpe := $(p);
	        var i := 0;
	        while(i < num) {
	                v.insert(nil, 42);
	                i :+= 1;
	        }
	        e := [oid](v.seqbase(0@0).reverse).reverse;
	        if (fanout = 1) {
	                b := bat(void,(*tpe)()).seqbase(0@0);
	        } else {
	                b := bat(oid,(*tpe)());
	        }
	        var n := 0; 
	        e@batloop() {
	                i := 0; 
	                while(i < fanout) {
	                        if  (($h = 0@0) and (i = 0)) {
	                                b.insert($h, (*tpe)(nil));
	                        } else {
	                                b.insert($h, (*tpe)(n));
                        	} 
                        	n :+= 1; i :+= 1;
                	}
                }
        	print({toset}(b).col_name("test-set"),
        	      (*aggr)(b).col_name(sprintf("%s(b)",aggr)),
        	      (*aggr)(b,v).col_name(sprintf("%s(b,v)",aggr)),
        	      (*aggr)(b,e).col_name(sprintf("%s(b,e)",aggr)));
        }
}

aggrtst(16,160,"{sum}","uchr","sht","int","lng","flt","dbl");
aggrtst(16,160,"{avg}","uchr","sht","int","lng","flt","dbl");
aggrtst(16,160,"{min}","uchr","sht","int","lng","flt","dbl","decimal");
aggrtst(16,160,"{max}","uchr","sht","int","lng","flt","dbl","decimal");
aggrtst(16,160,"{card}","uchr","sht","int","lng","flt","dbl","decimal");
aggrtst(16,160,"{count}","uchr","sht","int","lng","flt","dbl","decimal");

@{
@+ Implementation
These implementations need just one scan and a simple hash-maintained data
structure to compute a group of common aggregates. 
@c
#include "mal.h"
#include "mal_function.h"
#include <gdk_scanselect.h> /* for type-specific HT_bunfastins_nocheck_noinc(), until they're moved to gdk.mx */
#include "../atoms/uchr.h"

@-
The macro CHKrange is just for array-lookups, analogously to BUNfntVOID &
HASHfnd_oid for void- and hash-lookups, respectively
@c
#define CHKrange(r, bn, h)	r = (BUN)(((*(oid*)h >= min) && (*(oid*)h <= max))?h:NULL)

@- Result initialization
@= getBATdescriptor
        if( BBPcheck(*@2,"@4")==0) 
		return throwMessage("aggrX3.@4","cannot access bat @2 in bbp");
        @3= (BAT*) BBPgetdesc(*@2);
        if( @3 == NULL) { *@1 = 0; 
		return throwMessage("aggrX3.@4","cannot access descriptor @2");
	}
	if(*@2 < 0) @3 = BATmirror(@3);

@c
/* 
with group OIDs spanning a range of less SMALL_AGGR_MAX (the actual number
of groups might be even less, in case there are "holes" in the group OID
range), we use a simple array as temporary sum/cnt table on order to benefit
from positional lookups; with size of sum <= 8 bytes and size of cnt == 4
bytes, we stay below 16 KBytes, i.e., within (almost) any L1 cache
*/
#define SMALL_AGGR_MAX 1024

@= large_aggr_sum
	(void) BATprepareHash(bn);
	BATloopFast(b, p, q, xx) {
		oid *h = (oid*) BUNhead(b,p);
		@1 *t = (@1*) BUN@2(b,p);

		BUNfndOID(r, bn, h);
		if (r) {
			@3 *dst = (@3*) BUN@2(bn, r);
			if (*dst != @3_nil) {
				if (*t == @1_nil) {	
					*dst = @3_nil;
				} else {
					*dst += *t;
				}
			} 
		}
	} 
@c
@= small_aggr_sum
	sums = (@3*) GDKmalloc(range*sizeof(@3));
	for (i = 0; i < range; i++) sums[i] = zero;
	BATloopFast(b, p, q, xx) {
		oid h = (*(oid*) BUNhead(b,p)) - min;
		@1 *t = (@1*) BUN@2(b,p);

		if (h < range) {
			@3 *dst = sums + h;
			if (*dst != @3_nil) {
				if (*t == @1_nil) {	
					*dst = @3_nil;
				} else {
					*dst += *t;
				}
			} 
		}
	} 
	BATloopFast(bn, p, q, xx) {
		oid h = (*(oid*) BUNhead(bn,p)) - min;
		*(@3*)BUN@2(bn, p) = sums[h];
	}
        GDKfree(sums);
@c
@= large_aggr_avg
	cnt  = (size_t*) GDKmalloc(BATcount(e)*sizeof(size_t));
	memset(cnt, 0, BATcount(e)*sizeof(size_t));
	(void) BATprepareHash(bn);
	BATloopFast(b, p, q, xx) {
		oid *h = (oid*) BUNhead(b,p);
		@1 *t = (@1*) BUN@2(b,p);

		BUNfndOID(r,bn,h);
		if (r) {
			dbl *dst = (dbl*) BUN@2(bn, r);
			if (*dst != dbl_nil) {
				if (*t == @1_nil) {	
					*dst = dbl_nil;
				} else {
					*dst += *t;
				}
				cnt[BUNindex(bn,r)-off]++;
			} 
		}
	} 
	/* postprocess by dividing sums by counts */
	BATloopFast(bn, p, q, xx) {
		dbl *dst = (dbl*) BUN@2(bn, p);
		if (cnt[yy] == 0) {
			*dst = dbl_nil;
		} else if (*dst != dbl_nil) {
			*dst = (dbl) (*dst / cnt[yy]);
		} yy++;
	} 
	GDKfree(cnt);
@-
@= large_aggr_prod
        (void) BATprepareHash(bn);
        BATloopFast(b, p, q, xx) {
                oid *h = (oid*) BUNhead(b,p);
                @1 *t = (@1*) BUN@2(b,p);

                BUNfndOID(r, bn, h);
                if (r) {
                        @3 *dst = (@3*) BUN@2(bn, r);
                        if (*dst != @3_nil) {
                                if (*t == @1_nil) {
                                        *dst = @3_nil;
                                } else {
                                        *dst *= *t;
                                }
                        }
                }
        }
@-
@= small_aggr_prod
        prods = (@3*) GDKmalloc(range*sizeof(@3));
        for (i = 0; i < range; i++) prods[i] = one;
        BATloopFast(b, p, q, xx) {
                oid h = (*(oid*) BUNhead(b,p)) - min;
                @1 *t = (@1*) BUN@2(b,p);

                if (h < range) {
                        @3 *dst = prods + h;
                        if (*dst != @3_nil) {
                                if (*t == @1_nil) {
                                        *dst = @3_nil;
                                } else {
                                        *dst *= *t;
                                }
                        }
                }
        }
        BATloopFast(bn, p, q, xx) {
                oid h = (*(oid*) BUNhead(bn,p)) - min;
                *(@3*)BUN@2(bn, p) = prods[h];
        }
        GDKfree(prods);
@c

@= small_aggr_avg
	sums = (dbl*) GDKmalloc(range*sizeof(dbl));
	cnt  = (size_t*) GDKmalloc(range*sizeof(size_t));
	for (i = 0; i < range; i++) sums[i] = zero;
	memset(cnt, 0, range*sizeof(size_t));
	BATloopFast(b, p, q, xx) {
		oid h = (*(oid*) BUNhead(b,p)) - min;
		@1 *t = (@1*) BUN@2(b,p);

		if (h < range) {
			dbl *dst = sums + h;
			if (*dst != dbl_nil) {
				if (*t == @1_nil) {	
					*dst = dbl_nil;
				} else {
					*dst += *t;
				}
				cnt[h]++;
			} 
		}
	} 
	/* postprocess by dividing sums by counts */
	BATloopFast(bn, p, q, xx) {
		oid h = (*(oid*) BUNhead(bn,p)) - min;
		dbl *dst = (dbl*) BUN@2(bn, p);
		if (cnt[h] == 0 || sums[h] == dbl_nil) {
			*dst = dbl_nil;
		} else {
			*dst = (dbl) (sums[h]/cnt[h]);
		}
	}
        GDKfree(sums);
	GDKfree(cnt);
/*	init_result
	@1:	tail-type:	uchr/chr/sht/int/lng/flt/dbl / any / void
*/
@= init_result
{	REGISTER BUN _p = BUNlast(bn);
	REGISTER int _bunsize = BUNsize(bn);
	bn->tsorted = bn->hsorted = 0;
	ALIGNsetH(bn, e);
	/* set all sums/avgs/counts to zero */
	/* where necessary, calculate min/max oid with minimal effort */
	if (e->htype == TYPE_void) {
		oid nil = oid_nil;
		ALGODEBUG THRprintf(GDKout, "init_result(@1): e->htype == TYPE_void, e->hseqbase=%lu\n", (unsigned long) e->hseqbase);
		BATloopFast(e, p, q, xx) {
			void@1_bunfastins_nocheck_noinc(bn, _p, &nil, &zero);
			_p += _bunsize;
		}
		BATseqbase(bn,e->hseqbase);
	} else if (BAThordered(e)&1) {
		min = *(oid*)BUNhloc(e, BUNfirst(e));
		BATloopFast(e, p, q, xx) {
			oid@1_bunfastins_nocheck_noinc(bn, _p, BUNhloc(e,p), &zero);
			_p += _bunsize;
		}
		max = *(oid*)BUNhloc(e, BUNlast(e)-BUNsize(e));
		ALGODEBUG THRprintf(GDKout, "init_result(@1): BAThordered(e)&1, min=%d, max=%d\n", (unsigned long) min, (unsigned long) max);
	} else {
		oid i;
		min = max = *(oid*)BUNhloc(e, BUNfirst(e));
		BATloopFast(e, p, q, xx) {
			oid@1_bunfastins_nocheck_noinc(bn, _p, BUNhloc(e,p), &zero);
			_p += _bunsize;
			i = *(oid*)BUNhloc(e, p);
			if (i < min) min = i;
			else
			if (i > max) max = i;
		}
		ALGODEBUG THRprintf(GDKout, "init_result(@1): min=%lu, max=%lu\n", (unsigned long) min, (unsigned long) max);
	}
	bn->batBuns->free = _p - bn->batBuns->base;
	if (!bn->batDirty) bn->batDirty = TRUE;
}
@- Sum & Average
@c
/*	aggrX3_sum
		e-void-head	e-oid-head	e-oid-head
		void-lookup	hash-lookup	array-lookup

	@1:	0		0		1		use sums-array?
	@2:	0		1		0		do BATprepareHash?
	@3:	BUNfndVOID	HASHfnd_oid	CHKrange	lookup
	@4:	var		loc		loc		e/bn-head-access

	@5:	"BUNhloc(b,p)"  for  (oid) b-head-type,		b-head access
		"&bhsb; bhsb++" for (void) b-head-type		

	@6:		uchr/sht / int / lng / flt / dbl		b/bn-tail-type
	@7:	"loc" for fixsized b/bn-tail-type, 		b/bn-tail-access
		"var" for varsized b/bn-tail-type		(only loc used currently)

	@8:	BUNt@7(bn,r)	BUNt@7(bn,r)	&sums[(*(oid*)h)-min]	
								*dst: sum in-place or in sums-array ?
	@9:	result type
*/
@= aggrX3_sum
	ALGODEBUG THRprintf(GDKout, "aggrX3_sum(@1,@2,@3,@4,@5,@6,@7,@8,@9);\n");
	if (@1) {
	 	/* create tmp. sums array */
		size_t i;
		sums = (@9*) GDKmalloc(range*sizeof(@9));
		for (i = 0; i < range; i++) sums[i] = zero;
	}
	if (@2) { (void) BATprepareHash(bn); }
	/* scan b, and add values to sums in-place or in sums-array */
	bhsb = b->hseqbase;
	BATloopFast(b, p, q, xx) {
		@6 *t = (@6*) BUNt@7(b,p);
		oid *h = (oid*) @5;

		@3(r, bn, (oid*)h);
		if (r) {
			@9 *dst = (@9*) @8;
			if (*dst != @9_nil) {
				if (*t == @6_nil) {	
					*dst = @9_nil;
				} else {
					*dst += *t;
				}
			} 
		}
	} 
	if (@1) {
        	/* copy sums array to final result */
       		BATloopFast(bn, p, q, xx) {
			oid h = (*(oid*) BUNh@4(bn,p)) - min;
			*(@9*)BUNt@7(bn, p) = sums[h];
		}
	        GDKfree(sums);
	}
@
@c
/*	aggrX3_prod
		e-void-head	e-oid-head	e-oid-head
		void-lookup	hash-lookup	array-lookup

	@1:	0		0		1		use prods-array?
	@2:	0		1		0		do BATprepareHash?
	@3:	BUNfndVOID	HASHfnd_oid	CHKrange	lookup
	@4:	var		loc		loc		e/bn-head-access

	@5:	"BUNhloc(b,p)"  for  (oid) b-head-type,		b-head access
		"&bhsb; bhsb++" for (void) b-head-type		

	@6:		uchr/ sht / int / lng / flt / dbl	b/bn-tail-type
	@7:	"loc" for fixsized b/bn-tail-type, 		b/bn-tail-access
		"var" for varsized b/bn-tail-type		(only loc used currently)

	@8:	BUNt@7(bn,r)	BUNt@7(bn,r)	&prods[(*(oid*)h)-min]	
								*dst: prod in-place or in prods-array ?
	@9: 	result type
*/
@= aggrX3_prod
	ALGODEBUG THRprintf(GDKout, "aggrX3_prod(@1,@2,@3,@4,@5,@6,@7,@8,@9);\n");
	if (@1) {
	 	/* create tmp. prods array */
		size_t i;
		prods = (@9*) GDKmalloc(range*sizeof(@9));
		for (i = 0; i < range; i++) prods[i] = zero;
	}
	if (@2) { (void) BATprepareHash(bn); }
	/* scan b, and mul values to prods in-place or in prods-array */
	bhsb = b->hseqbase;
	BATloopFast(b, p, q, xx) {
		@6 *t = (@6*) BUN@7(b,p);
		oid *h = (oid*) @5;

		@3(r, bn, (oid*)h);
		if (r) {
			@9 *dst = (@9*) @8;
			if (*dst != @9_nil) {
				if (*t == @6_nil) {	
					*dst = @9_nil;
				} else {
					*dst *= *t;
				}
			} 
		}
	} 
	if (@1) {
        	/* copy prods array to final result */
       		BATloopFast(bn, p, q, xx) {
			oid h = (*(oid*) BUNh@4(bn,p)) - min;
			*(@9*)BUN@7(bn, p) = prods[h];
		}
	        GDKfree(prods);
	}
@
@c
/*	aggrX3_avg
		e-void-head	e-oid-head	e-oid-head
		void-lookup	hash-lookup	array-lookup

	@1:	0		0		1		use sums-array?
	@2:	0		1		0		do BATprepareHash?
	@3:	BUNfndVOID	HASHfnd_oid	CHKrange	lookup
	@4:	var		loc		loc		e/bn-head-access

	@5:	"BUNhloc(b,p)"  for  (oid) b-head-type,		b-head access
		"&bhsb; bhsb++" for (void) b-head-type		

	@6:		sht / int / lng / flt / dbl		b/bn-tail-type
	@7:	"loc" for fixsized b/bn-tail-type, 		b/bn-tail-access
		"var" for varsized b/bn-tail-type		(only loc used currently)

	@8:	BUNt@7(bn,r)	BUNt@7(bn,r)	&sums[(*(oid*)h)-min]	
								*dst: sum in-place or in sums-array ?
	
	@9:	     BUNindex(bn,r)-off		(*(oid*)h)-min	index in cnt array
*/
@= aggrX3_avg
	ALGODEBUG THRprintf(GDKout, "aggrX3_avg(@1,@2,@3,@4,@5,@6,@7,@8,@9);\n");
	if (@1) {
		/* create tmp. sums array */
		size_t i;
		sums = (dbl*) GDKmalloc(range*sizeof(dbl));
		for (i = 0; i < range; i++) sums[i] = zero;
	}
	if (@2) { (void) BATprepareHash(bn); }
	cnt = (size_t*) GDKmalloc(slots*sizeof(int));
	memset(cnt, 0, slots*sizeof(cnt[0]));
	/* scan b, adding sums, and incrementing counts */
        bhsb = b->hseqbase;
	BATloopFast(b, p, q, xx) {
		@6 *t = (@6*) BUNt@7(b,p);
		oid *h = (oid*) @5;

		@3(r, bn, (oid*)h);
		if (r) {
			dbl *dst = (dbl*) @8;
			if (*dst != dbl_nil) {
				if (*t == @6_nil) {	
					*dst = dbl_nil;
				} else {
					*dst += *t;
				}
				cnt[@9]++;
			} 
		}
	} 
	/* postprocess by dividing sums by counts */
	if (@1) {
		/* sums in sums-array */
		BATloopFast(bn, p, q, xx) {
			oid h = (*(oid*) BUNh@4(bn,p)) - min;
			dbl *dst = (dbl*) BUNt@7(bn, p);
			if (cnt[h] == 0 || sums[h] == dbl_nil) {
				*dst = dbl_nil;
			} else {
				*dst = (dbl) (sums[h]/cnt[h]);
			}
		}
       		GDKfree(sums);
	} else {
		/* sums in-place */
		size_t yy = 0;
		BATloopFast(bn, p, q, xx) {
			dbl *dst = (dbl*) BUNt@7(bn, p);
			if (cnt[yy] == 0) {
				*dst = dbl_nil;
			} else if (*dst != dbl_nil) {
				*dst =(dbl)(*dst/ cnt[yy]);
			} yy++;
		} 
	
	}
        GDKfree(cnt);
@c

/*	arithsum
	@6:	uchr/sht / int / lng / flt / dbl		b/bn-tail-type
	@7:	"loc" for fixsized b/bn-tail-type, 	b/bn-tail-access
		"var" for varsized b/bn-tail-type	(only loc used currently)
	@9:	result type
*/
@-
@= arithsumprod
str CMDaggrX3_sum_@1_@3(int *retid, int *bid, int *eid){
	BAT *b, *e;
	BAT *bn;
	@3 zero= (@3)0, *sums;
	BUN p, q, r;
	size_t range;
	int xx;
	oid i,min, max;

	@:getBATdescriptor(retid,bid,b,sum)@
	@:getBATdescriptor(retid,eid,e,sum)@

	bn = BATnew(e->htype, TYPE_@3, BATcount(e));	
	ALGODEBUG THRprintf(GDKout, "CMDaggrX3_sum_@1_@3[@2](b=%s,e=%s);\n",b->batId,e->batId);
	/* init: set all sums to zero */
	bn->tsorted = bn->hsorted = 0;
        ALIGNsetH(bn, e);
        if (BAThordered(e)&1) {
                min = *(oid*)BUNhead(e, BUNfirst(e));
                BATloopFast(e, p, q, xx) {
                        BUNfastins(bn, BUNhead(e,p), &zero);
                }
                max = *(oid*)BUNhead(e, BUNlast(e)-BUNsize(e));
        } else {
                min = max = *(oid*)BUNhead(e, BUNfirst(e));
                BATloopFast(e, p, q, xx) {
                        BUNfastins(bn, BUNhead(e,p), &zero);
                        i = *(oid*)BUNhead(e, p);
                        if (i < min) min = i;
                        else
                        if (i > max) max = i;
                }
        }

	range = max - min + 1;


        /* scan b, and add values to sums in-place */
        if (range > SMALL_AGGR_MAX) {
                ALGODEBUG THRprintf(GDKout, "CMDaggr_sum_@1_@3: range(=%lu) > SMALL_AGGR_MAX(=%d)  => large_aggr_sum\n",(unsigned long) range,SMALL_AGGR_MAX);
                @:large_aggr_sum(@1,@2,@3)@
        } else {
                ALGODEBUG THRprintf(GDKout, "CMDaggr_sum_@1_@3: range(=%lu) <= SMALL_AGGR_MAX(=%d)  => small_aggr_sum\n",(unsigned long) range,SMALL_AGGR_MAX);
                @:small_aggr_sum(@1,@2,@3)@
        }
			
	*retid = bn->batCacheid;
	return MAL_SUCCEED;
}
str CMDaggrX3_prod_@1_@3(BAT **ret, BAT *b, BAT *e){
	BAT *bn = BATnew(e->htype, TYPE_@3, BATcount(e));	
	@3 zero = (@3) 1, *prods;
	BUN p, q, r;
	int xx;
	size_t range;
	oid min, max;
	oid bhsb;

/* TEST */
	ALGODEBUG THRprintf(GDKout, "CMDaggrX3_prod_@1_@3[@2](b=%s,e=%s);\n",b->batId,e->batId);
	/* init: set all prods to zero and calculate min/max oid */
	@:init_result(@3)@
	range = max - min + 1;

	/* scan b, and calculate prods */
	if (e->htype == TYPE_void) {
		/* void lookup */
		if (b->htype == TYPE_void) {
			@:aggrX3_prod(0,0,BUNfndVOID,var,&bhsb; bhsb++,@1,@2,BUN@2(bn,r),@3)@
		} else {
			@:aggrX3_prod(0,0,BUNfndVOID,var,BUNhloc(b,p),@1,@2,BUN@2(bn,r),@3)@
		}
	/* e->htype == TYPE_oid */
	} else if (range > SMALL_AGGR_MAX) {
		/* hash lookup */
		if (b->htype == TYPE_void) {
			@:aggrX3_prod(0,1,HASHfnd_oid,loc,&bhsb; bhsb++,@1,@2,BUN@2(bn,r),@3)@
		} else {
			@:aggrX3_prod(0,1,HASHfnd_int,loc,BUNhloc(b,p),@1,@2,BUN@2(bn,r),@3)@
		}
	} else {
		/* array lookup */
		if (b->htype == TYPE_void) {
			@:aggrX3_prod(1,0,CHKrange,loc,&bhsb; bhsb++,@1,@2,&prods[(*(oid*)h)-min],@3)@
		} else {
			@:aggrX3_prod(1,0,CHKrange,loc,BUNhloc(b,p),@1,@2,&prods[(*(oid*)h)-min],@3)@
		}
	}
			
	*ret = bn;
	return MAL_SUCCEED;
}
@c

/*	arithsumprod
	@6:	uchr / sht / int / lng / flt / dbl	b/bn-tail-type
	@7:	"loc" for fixsized b/bn-tail-type, 	b/bn-tail-access
		"var" for varsized b/bn-tail-type	(only loc used currently)
	@9: 	result type
*/
@-
@c
@:arithsumprod(uchr,tloc,uchr)@
@:arithsumprod(uchr,tloc,sht)@
@:arithsumprod(uchr,tloc,int)@
@:arithsumprod(uchr,tloc,lng)@
@:arithsumprod(sht,tloc,sht)@
@:arithsumprod(sht,tloc,int)@
@:arithsumprod(sht,tloc,lng)@
@:arithsumprod(int,tloc,int)@
@:arithsumprod(int,tloc,lng)@
@:arithsumprod(lng,tloc,lng)@
@:arithsumprod(flt,tloc,flt)@
@:arithsumprod(flt,tloc,dbl)@
@:arithsumprod(dbl,tloc,dbl)@
/*    arithavg
      @6:     uchr/sht / int / lng / flt / dbl             b/bn-tail-type
      @7:     "loc" for fixsized b/bn-tail-type,      b/bn-tail-access
              "var" for varsized b/bn-tail-type       (only loc used currently)
*/
@= arithavg
str CMDaggrX3_avg_@1(int *retid, int *bid, int *eid){
	BAT *b, *e;
	BAT *bn;
	int xx, yy = 0;
	size_t off;
	size_t *cnt;
	size_t range, slots; 
	oid min,max;
	dbl zero = (dbl) 0, *sums;
	BUN p, q, r;
	oid bhsb;


	@:getBATdescriptor(retid,bid,b,sum)@
	@:getBATdescriptor(retid,eid,e,sum)@
	bn = BATnew(e->htype, TYPE_dbl, BATcount(e));	
	off = BUNindex(bn,BUNfirst(bn));

	ALGODEBUG THRprintf(GDKout, "CMDaggrX3_avg_@1[@2](b=%s,e=%s);\n",b->batId,e->batId);
	/* init: set all sums & counts to zero and calculate min/max oid */
	@:init_result(dbl)@
	range = max - min + 1;

	/* scan b, calculate sums & counts, derive averages */
	if (e->htype == TYPE_void) {
		/* void lookup */
		slots = BATcount(e);
		if (b->htype == TYPE_void) {
			@:aggrX3_avg(0,0,BUNfndVOID,var,&bhsb; bhsb++,@1,@2,BUNt@2(bn,r),BUNindex(bn,r)-off)@
		} else {
			@:aggrX3_avg(0,0,BUNfndVOID,var,BUNhloc(b,p),@1,@2,BUNt@2(bn,r),BUNindex(bn,r)-off)@
		}
	/* e->htype == TYPE_oid */
	} else if (range > SMALL_AGGR_MAX) {
		/* hash lookup */
		slots = BATcount(e);
		if (b->htype == TYPE_void) {
			@:aggrX3_avg(0,1,HASHfnd_oid,loc,&bhsb; bhsb++,@1,@2,BUNt@2(bn,r),BUNindex(bn,r)-off)@
		} else {
			@:aggrX3_avg(0,1,HASHfnd_int,loc,BUNhloc(b,p),@1,@2,BUNt@2(bn,r),BUNindex(bn,r)-off)@
		}
	} else {
		/* array lookup */
		slots = range;
		if (b->htype == TYPE_void) {
			@:aggrX3_avg(1,0,CHKrange,loc,&bhsb; bhsb++,@1,@2,&sums[(*(oid*)h)-min],(*(oid*)h)-min)@
		} else {
			@:aggrX3_avg(1,0,CHKrange,loc,BUNhloc(b,p),@1,@2,&sums[(*(oid*)h)-min],(*(oid*)h)-min)@
		}
	}
	*retid = bn->batCacheid;
	return MAL_SUCCEED;
}
@c
@:arithavg(uchr,loc)@
@:arithavg(sht,loc)@
@:arithavg(int,loc)@
@:arithavg(lng,loc)@
@:arithavg(flt,loc)@
@:arithavg(dbl,loc)@

/*	arithprod3
	@6:	sht / int / lng / flt / dbl		b/bn-tail-type

#	not used any more
#	@7:	"loc" for fixsized b/bn-tail-type, 	b/bn-tail-access
#		"var" for varsized b/bn-tail-type	(only loc used currently)

	@9:	result type
*/
@= arithprod3
BAT* aggrX3_prod3_@1_@2_EarrayBvoidGvoid (BAT *bn, BAT * b, BAT *g, BAT *e, size_t range, oid min, oid max){
	@2 zero = (@2) 1, *prods;
	BUN p, q, r;
	int xx;
	oid bhsb;
	size_t base, end, w;
	ssize_t offset;

        ALGODEBUG THRprintf(GDKout, "aggrX3_prod3_@1_@2_EarrayBvoidGvoid(bn=%s,b=%s,g=%s,e=%s,range=%lu,min=%lu,max=%lu);\n",
	                             bn->batId,b->batId,g->batId,e->batId,(unsigned long)range,(unsigned long)min,(unsigned long)max);
	@:aggrX3_prod3(1,0,CHKrange,loc,&bhsb; bhsb++,@1,&prods[(*(oid*)h)-min],,@2)@
	
	return bn;
}

str CMDaggrX3_prod3_@1_@2(BAT **ret, BAT *b, BAT *g, BAT *e){
	BAT *bn = BATnew(e->htype, TYPE_@2, BATcount(e));	
	@2 zero = (@2) 1, *prods;
	BUN p, q, r;
	int xx;
	size_t range;
	oid min, max;
	oid bhsb;
	size_t base, end, w;
	ssize_t offset;

        ALGODEBUG THRprintf(GDKout, "CMDaggrX3_prod3_@1_@2(b=%s,g=%s,e=%s);\n",b->batId,g->batId,e->batId);
/*	ERRORcheck((BATcount(b)!=BATcount(g)), "CMDaggrX3_prod3_@1: BATs b & g must be of equal size.\n");	*/
	ERRORcheck((g->htype == TYPE_void) && (g->hseqbase == oid_nil), "CMDaggrX3_prod3_@1: head of BAT g must not be nil.\n");

	if((g->hseqbase == oid_nil) || (!BAThdense(g)) || (!(BAThordered(b)&1)) || (!g->hkey)) {
		return CMDaggrX3_prod_@1_@2(ret, BATjoin(BATmirror(g),b), e);
	}

	/* init: set all prods to zero and calculate min/max oid */
	@:init_result(@2)@
	range = max - min + 1;

	/* scan b & g, and calculate prods */
	if (e->htype == TYPE_void) {
		/* void lookup */
		if (b->htype == TYPE_void) {
			if ((g->htype == TYPE_void)&&(BATcount(b)==BATcount(g))&&(b->hseqbase==g->hseqbase)) {
				@:aggrX3_prod3(0,0,BUNfndVOID,var,&bhsb; bhsb++,@1,BUNtloc(bn,r),,@2)@
			} else {
				@:aggrX3_prod3(0,0,BUNfndVOID,var,&bhsb; bhsb++,@1,BUNtloc(bn,r),if (w >= base && w < end),@2)@
			}
		} else {
			@:aggrX3_prod3(0,0,BUNfndVOID,var,BUNhloc(b,p),@1,BUNtloc(bn,r),if (w >= base && w < end),@2)@
		}
	/* e->htype == TYPE_oid */
	} else if (range > SMALL_AGGR_MAX) {
		/* hash lookup */
		if (b->htype == TYPE_void) {
			if ((g->htype == TYPE_void)&&(BATcount(b)==BATcount(g))&&(b->hseqbase==g->hseqbase)) {
				@:aggrX3_prod3(0,1,HASHfnd_oid,loc,&bhsb; bhsb++,@1,BUNtloc(bn,r),,@2)@
			} else {
				@:aggrX3_prod3(0,1,HASHfnd_int,loc,&bhsb; bhsb++,@1,BUNtloc(bn,r),if (w >= base && w < end),@2)@
			}
		} else {
			@:aggrX3_prod3(0,1,HASHfnd_int,loc,BUNhloc(b,p),@1,BUNtloc(bn,r),if (w >= base && w < end),@2)@
		}
	} else {
		/* array lookup */
		if (b->htype == TYPE_void) {
			if ((g->htype == TYPE_void)&&(BATcount(b)==BATcount(g))&&(b->hseqbase==g->hseqbase)) {
				bn = aggrX3_prod3_@1_@2_EarrayBvoidGvoid (bn, b, g, e, range, min, max);
			} else {
				@:aggrX3_prod3(1,0,CHKrange,loc,&bhsb; bhsb++,@1,&prods[(*(oid*)h)-min],if (w >= base && w < end),@2)@
			}
		} else {
			@:aggrX3_prod3(1,0,CHKrange,loc,BUNhloc(b,p),@1,&prods[(*(oid*)h)-min],if (w >= base && w < end),@2)@
		}
	}
			
	*ret = bn;
	return MAL_SUCCEED;
}

@- "Extremes" (Min & Max)
@c
/*	aggrX3_minmax
		e-void-head	e-oid-head	e-oid-head
		void-lookup	hash-lookup	array-lookup

	@1:	</>		</>		</>		compare operator: <(min) or >(max)
	@2:	0		1		0		do BATprepareHash?
	@3:	BUNfndVOID	HASHfnd_oid	CHKrange	lookup
	@4:	var		loc		loc		e/bn-head-access

	@5:	"BUNhloc(b,p)"  for  (oid) b-head-type,		b-head access
		"&bhsb; bhsb++" for (void) b-head-type		

	@6:		uchr/chr / sht / int / lng / any		b/bn-tail-storage-type
	@7:	"loc" for fixsized b/bn-tail-type, 		b/bn-tail-access
		"var" for varsized b/bn-tail-type

	@8:	     BUNindex(bn,r)-off		(*(oid*)h)-min	index in extremes array
*/
@= aggrX3_minmax
	ALGODEBUG THRprintf(GDKout, "aggrX3_minmax(@1,@2,@3,@4,@5,@6,@7,@8);\n");
	if (@2) { (void) BATprepareHash(e); }
	/* init: create extremes and set all to the zero pointer */
	extremes = (ptr*) GDKmalloc(slots*sizeof(ptr));
	memset(extremes, 0, slots*sizeof(ptr));
	/* scan b and replace totals by the extreme value (just pointers to vals in b) */
        bhsb = b->hseqbase;
	BATloopFast(b, p, q, xx) {
		ptr t = BUNt@7(b,p);
		oid *h = (oid*) @5;

		@3(r, bn, (oid*)h);
		if (r) {
			ptr *val = &extremes[@8];
			if (*val != nil) {
				if ((*cmp)(t,nil) == 0) {	
					*val = nil;
				} else if (*val == NULL || (*cmp)(t,*val) @1 0) {
					*val = t;
				}
			} 
		}
	} 
	/* insert the extreme values into the result */
	BATloopFast(bn, r, q, xx) {
		oid *h = (oid*)BUNh@4(bn,r);
		ptr val = extremes[@8];
		/* trick: using a void head-type, only the tail are (over)written */
		void@6_bunfastins_nocheck_noinc(bn, r, h, val?val:nil);
	} 
        GDKfree(extremes);
@c

/*	extreme_typed
	@1:	min/max
	@2:	 < / >
	@3:	b/bn-tail-storage-type			chr/sht/int/lng/any
	@7:	"loc" for fixsized b/bn-tail-type, 	b/bn-tail-access
		"var" for varsized b/bn-tail-type
*/
@= extreme_typed
str aggrX3_@1_@3_@4(int *retid, int *bid, int *eid){
	BAT *b, *e;
	BAT *bn;
	int (*cmp)(ptr,ptr);
	ptr nil, zero ;
	int xx, yy = 0;
	size_t off;
	ptr *extremes;
	BUN p, q, r;
	size_t slots, range;
	oid min, max;
	oid bhsb;

	@:getBATdescriptor(retid,bid,b,@1)@
	@:getBATdescriptor(retid,eid,e,@1)@

	bn = BATnew(e->htype, BATttype(b), BATcount(e));	
	bn = BATnew(e->htype, BATttype(b), BATcount(e));	
	bn = BATnew(e->htype, BATttype(b), BATcount(e));	
	cmp= BATatoms[bn->ttype].atomCmp;
	nil = ATOMnilptr(bn->ttype); zero = nil;
	off = BUNindex(e,BUNfirst(e));

	ALGODEBUG THRprintf(GDKout, "aggrX3_@1_@3_@4[@2](b=%s,e=%s);\n",b->batId,e->batId);
	/* init: prepare the result bat; 
	 * trick: by using "tail-type" void, we only write the head column, here */
	@:init_result(void)@
	range = max - min + 1;

	/* scan b and replace totals by the extreme value (just pointers to vals in b) */
	slots = BATcount(e);
	if (e->htype == TYPE_void) {
		/* void lookup */
		if (b->htype == TYPE_void) {
			@:aggrX3_minmax(@2,0,BUNfndVOID,var,&bhsb; bhsb++,@3,@4,BUNindex(bn,r)-off)@
		} else {
			@:aggrX3_minmax(@2,0,BUNfndVOID,var,BUNhloc(b,p),@3,@4,BUNindex(bn,r)-off)@
		}
	/* e->htype == TYPE_oid */
	} else if (range > SMALL_AGGR_MAX) {
		/* hash lookup */
		if (b->htype == TYPE_void) {
			@:aggrX3_minmax(@2,1,HASHfnd_oid,loc,&bhsb; bhsb++,@3,@4,BUNindex(bn,r)-off)@
		} else {
			@:aggrX3_minmax(@2,1,HASHfnd_int,loc,BUNhloc(b,p),@3,@4,BUNindex(bn,r)-off)@
		}
	} else {
		/* array lookup */
		slots = range;
		if (b->htype == TYPE_void) {
			@:aggrX3_minmax(@2,0,CHKrange,loc,&bhsb; bhsb++,@3,@4,(*(oid*)h)-min)@
		} else {
			@:aggrX3_minmax(@2,0,CHKrange,loc,BUNhloc(b,p),@3,@4,(*(oid*)h)-min)@
		}
	}
			
	*retid = bn->batCacheid;
	return MAL_SUCCEED;
}
@c
/*	extreme
	@1:	min/max
	@2:	 < / >
*/
@= extreme
@:extreme_typed(@1,@2,chr,loc)@
@:extreme_typed(@1,@2,uchr,loc)@
@:extreme_typed(@1,@2,sht,loc)@
@:extreme_typed(@1,@2,int,loc)@
@:extreme_typed(@1,@2,lng,loc)@
@:extreme_typed(@1,@2,any,loc)@
@:extreme_typed(@1,@2,any,var)@

str CMDaggrX3_@1(int *ret, int *bid, int *eid){
	BAT *b, *e;
	str rtrn; int tt;

	@:getBATdescriptor(ret,bid,b,@1)@
	@:getBATdescriptor(ret,eid,e,@1)@
	tt = ATOMstorage(b->ttype);

	ALGODEBUG THRprintf(GDKout, "CMDaggrX3_@1[@2](b=%s,e=%s);\n",b->batId,e->batId);
	if (tt == TYPE_chr) {
		rtrn = aggrX3_@1_chr_loc(ret, bid, eid);
	} else if (tt == TYPE_sht) {
		rtrn = aggrX3_@1_sht_loc(ret, bid, eid);
	} else if (b->ttype != TYPE_bat && (tt == TYPE_int || tt == TYPE_flt)) {
	        /* ensure use of ATOMput for TYPE_bat */
		rtrn = aggrX3_@1_int_loc(ret, bid, eid);
	} else if (tt == TYPE_dbl || tt == TYPE_lng) {
		rtrn = aggrX3_@1_lng_loc(ret, bid, eid);
	} else if (b->tvarsized) {
		rtrn = aggrX3_@1_any_var(ret, bid, eid);
	} else {
		rtrn = aggrX3_@1_any_loc(ret, bid, eid);
	}
	return rtrn;
}
@c
@:extreme(min,<)@
@:extreme(max,>)@

@- Count
@c
/*	aggrX3_count
		e-void-head	e-oid-head	e-oid-head
		void-lookup	hash-lookup	array-lookup

	@1:	0		0		1		use cnt-array?
	@2:	0		1		0		do BATprepareHash?
	@3:	BUNfndVOID	HASHfnd_oid	CHKrange	lookup
	@4:	var		loc		loc		e/bn-head-access

	@5:	"BUNhloc(b,p)"  for  (oid) b-head-type,		b-head access
		"&bhsb; bhsb++" for (void) b-head-type		

	@6:	BUNtloc(bn,r)	BUNtloc(bn,r)	&cnt[(*(oid*)h)-min]	
								*dst: count in-place or in cnt-array ?
*/
@= aggrX3_count
	ALGODEBUG THRprintf(GDKout, "aggrX3_count(@1,@2,@3,@4,@5,@6);\n");
	if (@1) {
	 	/* create tmp. cnt array */
		cnt = (size_t*) GDKmalloc(range*sizeof(int));
		memset(cnt, 0, range*sizeof(int));
	}
	if (@2) { (void) BATprepareHash(bn); }
	/* scan b, and increment counts in-place or in cnt-array */
        bhsb = b->hseqbase;
        btt = b->ttype;
        if (*ignore_nils) {
                switch(ATOMstorage(btt)) {
                 case TYPE_chr: @:aggrX3_count_loop(@1,@2,@3,@4,@5,@6,if (!simple_EQ(BUNtloc(b,p),bt_nil,chr)))@
                 case TYPE_sht: @:aggrX3_count_loop(@1,@2,@3,@4,@5,@6,if (!simple_EQ(BUNtloc(b,p),bt_nil,sht)))@
                 case TYPE_int: @:aggrX3_count_loop(@1,@2,@3,@4,@5,@6,if (!simple_EQ(BUNtloc(b,p),bt_nil,int)))@
                 case TYPE_lng: @:aggrX3_count_loop(@1,@2,@3,@4,@5,@6,if (!simple_EQ(BUNtloc(b,p),bt_nil,lng)))@
                 case TYPE_flt: @:aggrX3_count_loop(@1,@2,@3,@4,@5,@6,if (!simple_EQ(BUNtloc(b,p),bt_nil,flt)))@
                 case TYPE_dbl: @:aggrX3_count_loop(@1,@2,@3,@4,@5,@6,if (!simple_EQ(BUNtloc(b,p),bt_nil,dbl)))@
                 default: if (b->tvarsized) {
                                @:aggrX3_count_loop(@1,@2,@3,@4,@5,@6,if (!atom_EQ(BUNtvar(b,p),bt_nil,btt)))@
                          } else {
                                @:aggrX3_count_loop(@1,@2,@3,@4,@5,@6,if (!atom_EQ(BUNtloc(b,p),bt_nil,btt)))@
                          }
                }
        } else {
                switch(ATOMstorage(btt)) {
                 case TYPE_chr: @:aggrX3_count_loop(@1,@2,@3,@4,@5,@6,)@
                 case TYPE_sht: @:aggrX3_count_loop(@1,@2,@3,@4,@5,@6,)@
                 case TYPE_int: @:aggrX3_count_loop(@1,@2,@3,@4,@5,@6,)@
                 case TYPE_lng: @:aggrX3_count_loop(@1,@2,@3,@4,@5,@6,)@
                 case TYPE_flt: @:aggrX3_count_loop(@1,@2,@3,@4,@5,@6,)@
                 case TYPE_dbl: @:aggrX3_count_loop(@1,@2,@3,@4,@5,@6,)@
                 default: if (b->tvarsized) {
                                @:aggrX3_count_loop(@1,@2,@3,@4,@5,@6,)@
                          } else {
                                @:aggrX3_count_loop(@1,@2,@3,@4,@5,@6,)@
                          }
                }
        }
        if (@1) {
                /* copy cnt array to final result */
                BATloopFast(bn, p, q, xx) {
                        oid h = (*(oid*) BUNh@4(bn,p)) - min;
                        *(int*)BUNtloc(bn, p) = cnt[h];
                }
                GDKfree(cnt);
        }

@c
/*	aggrX3_count_loop
       @7:     if (!atom_EQ(BUNt{loc,var}(b,p),bt_nil,btt))            b-tail nil check
               if (!simple_EQ(BUNtloc(b,p),bt_nil,{chr,sht,int,flt,lng,dbl}))

*/
@= aggrX3_count_loop

        ALGODEBUG THRprintf(GDKout, "aggrX3_count_loop(@1,@2,@3,@4,@5,@6,@7);\n");
	BATloopFast(b, p, q, xx) {
		oid *h = (oid*) @5;

		@3(r, bn, (oid*)h);
		if (r) {
			@7 {
				int *dst = (int*) @6;
				(*dst)++;
			}
		}
	} 
	break;
@c
	int rtrn, tt;

str CMDaggrX3_count(int *retid, int *bid, int *eid, bit *ignore_nils){
	BAT *b, *e;
	BAT *bn;
	int zero = 0, *cnt;
	BUN p, q, r;
	int xx;
	size_t range;
	oid min, max;
	oid bhsb;
	int btt;
	ptr bt_nil;

	@:getBATdescriptor(retid,bid,b,@1)@
	@:getBATdescriptor(retid,eid,e,@1)@

	bn = BATnew(e->htype, TYPE_int, BATcount(e));	
	bt_nil = ATOMnilptr(b->ttype);

	ALGODEBUG THRprintf(GDKout, "CMDaggrX3_(b=%s,e=%s);\n",b->batId,e->batId);
	/* init: set all counts to zero and calculate min/max oid */
	@:init_result(int)@
	range = max - min + 1;

	/* scan b, and calculate counts */
	if (e->htype == TYPE_void) {
		/* void lookup */
		if (b->htype == TYPE_void) {
			@:aggrX3_count(0,0,BUNfndVOID,var,&bhsb; bhsb++,BUNtloc(bn,r))@
		} else {
			@:aggrX3_count(0,0,BUNfndVOID,var,BUNhloc(b,p),BUNtloc(bn,r))@
		}
	/* e->htype == TYPE_oid */
	} else if (range > SMALL_AGGR_MAX) {
		/* hash lookup */
		if (b->htype == TYPE_void) {
			@:aggrX3_count(0,1,HASHfnd_oid,loc,&bhsb; bhsb++,BUNtloc(bn,r))@
		} else {
			@:aggrX3_count(0,1,HASHfnd_int,loc,BUNhloc(b,p),BUNtloc(bn,r))@
		}
	} else {
		/* array lookup */
		if (b->htype == TYPE_void) {
			@:aggrX3_count(1,0,CHKrange,loc,&bhsb; bhsb++,&cnt[(*(oid*)h)-min])@
		} else {
			@:aggrX3_count(1,0,CHKrange,loc,BUNhloc(b,p),&cnt[(*(oid*)h)-min])@
		}
	}
			
	*retid = bn->batCacheid;
	return MAL_SUCCEED;
}

@- Size
@c
str CMDaggrX3_size(int *retid, int *bid, int *eid){
	BAT *b, *e;
	BAT *bn;
	int zero = 0;
	BUN p, q, r;
	int xx;

	@:getBATdescriptor(retid,bid,b,@1)@
	@:getBATdescriptor(retid,eid,e,@1)@
	bn = BATnew(e->htype, TYPE_int, BATcount(e));	

	/* init: set all sums to zero */
	bn->tsorted = bn->hsorted = 0;
	ALIGNsetH(bn, e);
	BATloopFast(e, p, q, xx) {
		BUNfastins(bn, BUNhead(e,p), &zero);
	}
	/* scan b, and add increment totals for true values */
	(void) BATprepareHash(bn);
	BATloopFast(b, p, q, xx) {
		if (*(bit*) BUNtloc(b,p) == TRUE) {
			oid *h = (oid*) BUNhead(b,p);

			BUNfndOID(r, bn, h);
			if (r) {
				int *dst = (int*) BUNtloc(bn, r);
				(*dst)++;
			}
		}
	} 
	*retid = bn->batCacheid;
	return MAL_SUCCEED;
}

@- Sum & Average & Prod	
@c
/*	aggrX3_sum3
		e-void-head	e-oid-head	e-oid-head
		void-lookup	hash-lookup	array-lookup

	@1:	0		0		1		use sums-array?
	@2:	0		1		0		do BATprepareHash?
	@3:	BUNfndVOID	HASHfnd_oid	CHKrange	lookup
	@4:	var		loc		loc		e/bn-head-access

	@5:	"BUNhloc(b,p)"  for  (oid) b-head-type,		b-head access
		"&bhsb; bhsb++" for (void) b-head-type		

	@6:		uchr/sht / int / lng / flt / dbl		b/bn-tail-type
#     not used any more as the result-type needs an argument

#	@7:	"loc" for fixsized b/bn-tail-type, 		b/bn-tail-access
#		"var" for varsized b/bn-tail-type		(only loc used currently)

       @8:     <empty> / if (w >= base && w < end)             check head (oid) ranges
                                                               are not void-headed and
 aligned

	@8:	BUNt@7(bn,r)	BUNt@7(bn,r)	&sums[(*(int*)h)-min]	
								*dst: sum in-place or in sums-array ?
	@9:	result type
*/
@= aggrX3_sum3
        ALGODEBUG THRprintf(GDKout, "aggrX3_sum3(@1,@2,@3,@4,@5,@6,@7,@8,@9);\n");
	if (@1) {
	 	/* create tmp. sums array */
		size_t i;
		sums = (@9*) GDKmalloc(range*sizeof(@9));
		for (i = 0; i < range; i++) sums[i] = zero;
	}
	if (@2) { (void) BATprepareHash(bn); }
	/* scan b & g, and add values to sums in-place or in sums-array */
	base = BUNindex(g, BUNfirst(g));
	offset = (ssize_t) (base - g->hseqbase);
	end = base + BATcount(g);
	bhsb = b->hseqbase;
	BATloopFast(b, p, q, xx) {
		@6 *t = (@6*) BUNtloc(b,p);
		oid v = *(oid*) @5;

		
		w = offset + v;
		@8 {
			oid *h = (oid*) BUNtloc(g, BUNptr(g, w));

			@3(r, bn, (oid*)h);
			if (r) {
				@9 *dst = (@9*) @7;
				if (*dst != @9_nil) {
					if (*t == @6_nil) {	
						*dst = @9_nil;
					} else {
						*dst += *t;
					}
				} 
			}
		}
	} 
	if (@1) {
        	/* copy sums array to final result */
       		BATloopFast(bn, p, q, xx) {
			oid h = (*(oid*) BUNh@4(bn,p)) - min;
			*(@9*)BUNtloc(bn, p) = sums[h];
		}
	        GDKfree(sums);
	}
@
@c
/*	aggrX3_prod3
		e-void-head	e-oid-head	e-oid-head
		void-lookup	hash-lookup	array-lookup

	@1:	0		0		1		use prods-array?
	@2:	0		1		0		do BATprepareHash?
	@3:	BUNfndVOID	HASHfnd_oid	CHKrange	lookup
	@4:	var		loc		loc		e/bn-head-access

	@5:	"BUNhloc(b,p)"  for  (oid) b-head-type,		b-head access
		"&bhsb; bhsb++" for (void) b-head-type		

	@6:	uchr / sht / int / lng / flt / dbl		b/bn-tail-type
	
#	not used any more as the result-type needs an argument
#	@7:	"loc" for fixsized b/bn-tail-type, 		b/bn-tail-access
#		"var" for varsized b/bn-tail-type		(only loc used currently)

	@7:	BUNt@7(bn,r)	BUNt@7(bn,r)	&prods[(*(oid*)h)-min]	
								*dst: prod in-place or in prods-array ?
	@8:	<empty> / if (w >= base && w < end)		check head (oid) ranges in case b & g
								are not void-headed and aligned
	@9: 	result type
*/
@= aggrX3_prod3
        ALGODEBUG THRprintf(GDKout, "aggrX3_prod3(@1,@2,@3,@4,@5,@6,@7,@8,@9);\n");
	if (@1) {
	 	/* create tmp. prods array */
		size_t i;
		prods = (@9*) GDKmalloc(range*sizeof(@9));
		for (i = 0; i < range; i++) prods[i] = zero;
	}
	if (@2) { (void) BATprepareHash(bn); }
	/* scan b & g, and add values to prods in-place or in prods-array */
	base = BUNindex(g, BUNfirst(g));
	offset = (ssize_t) (base - g->hseqbase);
	end = base + BATcount(g);
	bhsb = b->hseqbase;
	BATloopFast(b, p, q, xx) {
		@6 *t = (@6*) BUNtloc(b,p);
		oid v = *(oid*) @5;

		w = offset + v;
		@8 {
			oid *h = (oid*) BUNtloc(g, BUNptr(g, w));

			@3(r, bn, (oid*)h);
			if (r) {
				@9 *dst = (@9*) @7;
				if (*dst != @9_nil) {
					if (*t == @6_nil) {	
						*dst = @9_nil;
					} else {
						*dst *= *t;
					}
				} 
			}
		}
	} 
	if (@1) {
        	/* copy prods array to final result */
       		BATloopFast(bn, p, q, xx) {
			oid h = (*(oid*) BUNh@4(bn,p)) - min;
			*(@9*)BUNtloc(bn, p) = prods[h];
		}
	        GDKfree(prods);
	}
@
@c
/*	aggrX3_avg3
		e-void-head	e-oid-head	e-oid-head
		void-lookup	hash-lookup	array-lookup

	@1:	0		0		1		use sums-array?
	@2:	0		1		0		do BATprepareHash?
	@3:	BUNfndVOID	HASHfnd_oid	CHKrange	lookup
	@4:	var		loc		loc		e/bn-head-access

	@5:	"BUNhloc(b,p)"  for  (oid) b-head-type,		b-head access
		"&bhsb; bhsb++" for (void) b-head-type		

	@6:		sht / int / lng / flt / dbl		b/bn-tail-type
	@7:	"loc" for fixsized b/bn-tail-type, 		b/bn-tail-access
		"var" for varsized b/bn-tail-type		(only loc used currently)

	@8:	BUNt@7(bn,r)	BUNt@7(bn,r)	&sums[(*(oid*)h)-min]	
								*dst: sum in-place or in sums-array ?
	
	@9:	     BUNindex(bn,r)-off		(*(oid*)h)-min	index in cnt array
*/
@= aggrX3_avg3
        ALGODEBUG THRprintf(GDKout, "aggrX3_avg3(@1,@2,@3,@4,@5,@6,@7,@8,@9);\n");
	if (@1) {
		/* create tmp. sums array */
		size_t i;
		sums = (dbl*) GDKmalloc(range*sizeof(dbl));
		for (i = 0; i < range; i++) sums[i] = zero;
	}
	if (@2) { (void) BATprepareHash(bn); }
	cnt = (int*) GDKmalloc(slots*sizeof(int));
	memset(cnt, 0, slots*sizeof(int));
	/* scan b & g, adding sums, and incrementing counts */
	base = BUNindex(g, BUNfirst(g));
	offset = (ssize_t) (base - g->hseqbase);
	end = base + BATcount(g);
	bhsb = b->hseqbase;
	BATloopFast(b, p, q, xx) {
		@6 *t = (@6*) BUNt@7(b,p);
		oid v = *(oid*) @5;
		
		w = offset + v;
		if (w >= base && w < end) {
			oid *h = (oid*) BUNtloc(g, BUNptr(g, w));

			@3(r, bn, (oid*)h);
			if (r) {
				dbl *dst = (dbl*) @8;
				if (*dst != dbl_nil) {
					if (*t == @6_nil) {	
						*dst = dbl_nil;
					} else {
						*dst += *t;
					}
					cnt[@9]++;
				} 
			}
		}
	} 
	/* postprocess by dividing sums by counts */
	if (@1) {
		/* sums in sums-array */
		BATloopFast(bn, p, q, xx) {
			oid h = (*(oid*) BUNh@4(bn,p)) - min;
			dbl *dst = (dbl*) BUNt@7(bn, p);
			if (cnt[h] == 0 || sums[h] == dbl_nil) {
				*dst = dbl_nil;
			} else {
				*dst = sums[h]/cnt[h];
			}
		}
       		GDKfree(sums);
	} else {
		/* sums in-place */
		size_t yy = 0;
		BATloopFast(bn, p, q, xx) {
			dbl *dst = (dbl*) BUNt@7(bn, p);
			if (cnt[yy] == 0) {
				*dst = dbl_nil;
			} else if (*dst != dbl_nil) {
				*dst /= cnt[yy];
			} yy++;
		} 
	
	}
        GDKfree(cnt);
@c

/*	arithsum3
	@6:	sht / int / lng / flt / dbl		b/bn-tail-type
#     not used any more
#	@7:	"loc" for fixsized b/bn-tail-type, 	b/bn-tail-access
#		"var" for varsized b/bn-tail-type	(only loc used currently)
       @9:     result type
*/
@= arithsum3

BAT* aggrX3_sum3_@1_@2_EarrayBvoidGvoid (BAT *bn, BAT *b, BAT *g, BAT *e, oid range, oid min, int max){
	@2 zero = (@2) 0, *sums;
	BUN p, q, r;
	int xx;
	oid bhsb;
	size_t base, end, w;
	ssize_t offset;

        ALGODEBUG THRprintf(GDKout, "aggrX3_sum3_@1_@2_EarrayBvoidGvoid[@2](bn=%s,b=%s,g=%s,e=%s,range=%d,min=%lu,max=%lu);\n",
	                             bn->batId,b->batId,g->batId,e->batId, (unsigned long) range,(unsigned long) min,(unsigned long) max);
	@:aggrX3_sum3(1,0,CHKrange,loc,&bhsb; bhsb++,@1,&sums[(*(oid*)h)-min],,@2)@
	
	return bn;
}

str CMDaggrX3_sum3_@1_@2(int *retid,int *bid, int *gid, int *eid){
	BAT *b,*g, *e;
	BAT *bn;
	@2 zero = (@2) 0, *sums;
	BUN p, q, r;
	int xx;
	size_t range;
	oid min, max;
	oid bhsb;
	size_t base, end, w;
	ssize_t offset;

	@:getBATdescriptor(retid,bid,b,sum)@
	@:getBATdescriptor(retid,gid,g,sum)@
	@:getBATdescriptor(retid,eid,e,sum)@
	bn = BATnew(e->htype, BATttype(g), BATcount(e));	

        ALGODEBUG THRprintf(GDKout, "CMDaggrX3_sum3_@1_@2(b=%s,g=%s,e=%s);\n",b->batId,g->batId,e->batId);
/*	ERRORcheck((BATcount(b)!=BATcount(g)), "CMDaggrX3_sum3_@1: BATs b & g must be of equal size.\n");	*/
	ERRORcheck((g->htype == TYPE_void) && (g->hseqbase == oid_nil), "CMDaggrX3_sum3_@1: head of BAT g must not be nil.\n");

	if((g->hseqbase == oid_nil) || (!BAThdense(g)) || (!(BAThordered(b)&1)) || (!g->hkey)) {

		int k= BATjoin(BATmirror(g),b)->batCacheid;
		return CMDaggrX3_sum_@1_@2(retid, &k, eid);
	}

	/* init: set all sums to zero and calculate min/max oid */
	@:init_result(@2)@
	range = max - min + 1;

	/* scan b & g, and calculate sums */
	if (e->htype == TYPE_void) {
		/* void lookup */
		if (b->htype == TYPE_void) {
			if ((g->htype == TYPE_void)&&(BATcount(b)==BATcount(g))&&(b->hseqbase==g->hseqbase)) {
				@:aggrX3_sum3(0,0,BUNfndVOID,var,&bhsb; bhsb++,@1,BUNtloc(bn,r),,@2)@
			} else {
				@:aggrX3_sum3(0,0,BUNfndVOID,var,&bhsb; bhsb++,@1,BUNtloc(bn,r),if (w >= base && w < end),@2)@
			}
		} else {
			@:aggrX3_sum3(0,0,BUNfndVOID,var,BUNhloc(b,p),@1,BUNtloc(bn,r),if (w >= base && w < end),@2)@
		}
	/* e->htype == TYPE_oid */
	} else if (range > SMALL_AGGR_MAX) {
		/* hash lookup */
		if (b->htype == TYPE_void) {
			if ((g->htype == TYPE_void)&&(BATcount(b)==BATcount(g))&&(b->hseqbase==g->hseqbase)) {
				@:aggrX3_sum3(0,1,HASHfnd_oid,loc,&bhsb; bhsb++,@1,BUNtloc(bn,r),,@2)@
			} else {
				@:aggrX3_sum3(0,1,HASHfnd_int,loc,&bhsb; bhsb++,@1,BUNtloc(bn,r),if (w >= base && w < end),@2)@
			}
		} else {
			@:aggrX3_sum3(0,1,HASHfnd_int,loc,BUNhloc(b,p),@1,BUNtloc(bn,r),if (w >= base && w < end),@2)@
		}
	} else {
		/* array lookup */
		if (b->htype == TYPE_void) {
			if ((g->htype == TYPE_void)&&(BATcount(b)==BATcount(g))&&(b->hseqbase==g->hseqbase)) {
				bn = aggrX3_sum3_@1_@2_EarrayBvoidGvoid (bn, b, g, e, range, min, max);
			} else {
				@:aggrX3_sum3(1,0,CHKrange,loc,&bhsb; bhsb++,@1,&sums[(*(oid*)h)-min],if (w >= base && w < end),@2)@
			}
		} else {
			@:aggrX3_sum3(1,0,CHKrange,loc,BUNhloc(b,p),@1,&sums[(*(oid*)h)-min],if (w >= base && w < end),@2)@
		}
	}
			
	*retid = bn->batCacheid;
	return MAL_SUCCEED;
}
@c

/*	arithsumprod3
	@6:	sht / int / lng / flt / dbl		b/bn-tail-type

#	not used any more
#	@7:	"loc" for fixsized b/bn-tail-type, 	b/bn-tail-access
#		"var" for varsized b/bn-tail-type	(only loc used currently)

	@9:	result type
*/
@-
@= arithsumprod3
@:arithsum3(@1,@2)@
@:arithprod3(@1,@2)@
@c

@:arithsumprod3(uchr,uchr)@
@:arithsumprod3(uchr,sht)@
@:arithsumprod3(uchr,int)@
@:arithsumprod3(uchr,lng)@
@:arithsumprod3(sht,sht)@
@:arithsumprod3(sht,int)@
@:arithsumprod3(sht,lng)@
@:arithsumprod3(int,int)@
@:arithsumprod3(int,lng)@
@:arithsumprod3(lng,lng)@
@:arithsumprod3(flt,flt)@
@:arithsumprod3(flt,dbl)@
@:arithsumprod3(dbl,dbl)@
/*    arithavg3
      @6:     sht / int / lng / flt / dbl             b/bn-tail-type
      @7:     "loc" for fixsized b/bn-tail-type,      b/bn-tail-access
              "var" for varsized b/bn-tail-type       (only loc used currently)
      @9:     result type
*/
@= arithavg3
str CMDaggrX3_avg3_@1(int *retid,int *bid, int *gid, int *eid){
	BAT *b,*g,*e;
	BAT *bn;
	int xx, yy = 0;
	size_t off;
	size_t *cnt;
	size_t range;
	oid min, max; 
	dbl zero = (dbl) 0, *sums;
	size_t slots;
	BUN p, q, r;
	oid bhsb;
  	size_t base, end, w;
	ssize_t	offset;
  	
	@:getBATdescriptor(retid,bid,b,avg)@
	@:getBATdescriptor(retid,gid,g,avg)@
	@:getBATdescriptor(retid,eid,e,avg)@

	bn = BATnew(e->htype, BATttype(b), BATcount(e));	
	off = BUNindex(bn,BUNfirst(bn));
        ALGODEBUG THRprintf(GDKout, "CMDaggrX3_avg3_@1[@2](b=%s,g=%s,e=%s);\n",b->batId,g->batId,e->batId);
/*	ERRORcheck((BATcount(b)!=BATcount(g)), "CMDaggrX3_avg3_@1: BATs b & g must be of equal size.\n");	*/
	ERRORcheck((g->htype == TYPE_void) && (g->hseqbase == oid_nil), "CMDaggrX3_avg3_@1: head of BAT g must not be nil.\n");

	if((g->hseqbase == oid_nil) || (!BAThdense(g)) || (!(BAThordered(b)&1)) || (!g->hkey)) {
		int k =  BATjoin(BATmirror(g),b)->batCacheid;
		return CMDaggrX3_avg_@1(retid, &k, eid);
	}

	/* init: set all sums & counts to zero and calculate min/max oid */
	@:init_result(dbl)@
	range = max - min + 1;

	/* scan b & g, calculate sums & counts, derive averages */
	if (e->htype == TYPE_void) {
		/* void lookup */
		slots = BATcount(e);
		if (b->htype == TYPE_void) {
			@:aggrX3_avg3(0,0,BUNfndVOID,var,&bhsb; bhsb++,@1,@2,BUNt@2(bn,r),BUNindex(bn,r)-off)@
		} else {
			@:aggrX3_avg3(0,0,BUNfndVOID,var,BUNhloc(b,p),@1,@2,BUNt@2(bn,r),BUNindex(bn,r)-off)@
		}
	/* e->htype == TYPE_oid */
	} else if (range > SMALL_AGGR_MAX) {
		/* hash lookup */
		slots = BATcount(e);
		if (b->htype == TYPE_void) {
			@:aggrX3_avg3(0,1,HASHfnd_oid,loc,&bhsb; bhsb++,@1,@2,BUNt@2(bn,r),BUNindex(bn,r)-off)@
		} else {
			@:aggrX3_avg3(0,1,HASHfnd_int,loc,BUNhloc(b,p),@1,@2,BUNt@2(bn,r),BUNindex(bn,r)-off)@
		}
	} else {
		/* array lookup */
		slots = range;
		if (b->htype == TYPE_void) {
			@:aggrX3_avg3(1,0,CHKrange,loc,&bhsb; bhsb++,@1,@2,&sums[(*(oid*)h)-min],(*(oid*)h)-min)@
		} else {
			@:aggrX3_avg3(1,0,CHKrange,loc,BUNhloc(b,p),@1,@2,&sums[(*(oid*)h)-min],(*(oid*)h)-min)@
		}
	}

	*retid = bn->batCacheid;
	return MAL_SUCCEED;
}
@c
@:arithavg3(uchr,loc)@
@:arithavg3(sht,loc)@
@:arithavg3(int,loc)@
@:arithavg3(lng,loc)@
@:arithavg3(flt,loc)@
@:arithavg3(dbl,loc)@

@- "Extremes" (Min & Max)
@c
/*	aggrX3_minmax3
		e-void-head	e-oid-head	e-oid-head
		void-lookup	hash-lookup	array-lookup

	@1:	</>		</>		</>		compare operator: <(min) or >(max)
	@2:	0		1		0		do BATprepareHash?
	@3:	BUNfndVOID	HASHfnd_oid	CHKrange	lookup
	@4:	var		loc		loc		e/bn-head-access

	@5:	"BUNhloc(b,p)" for  (oid) b-head-type,		b-head access
		"&bhsb; bhsb++" for (void) b-head-type		

	@6:		chr / sht / int / lng / any		b/bn-tail-storage-type
	@7:	"loc" for fixsized b/bn-tail-type, 		b/bn-tail-access
		"var" for varsized b/bn-tail-type

	@8:	     BUNindex(bn,r)-off		(*(oid*)h)-min	index in extremes array
*/
@= aggrX3_minmax3
	ALGODEBUG THRprintf(GDKout, "aggrX3_minmax(@1,@2,@3,@4,@5,@6,@7,@8);\n");
	if (@2) { (void) BATprepareHash(e); }
	/* init: create extremes and set all to the zero pointer */
	extremes = (ptr*) GDKmalloc(slots*sizeof(ptr));
	memset(extremes, 0, slots*sizeof(ptr));
	/* scan b & g and replace totals by the extreme value (just pointers to vals in b) */
	base = BUNindex(g, BUNfirst(g));
	offset = (ssize_t) (base - g->hseqbase);
	end = base + BATcount(g);
	bhsb = b->hseqbase;
	BATloopFast(b, p, q, xx) {
		ptr t = BUNt@7(b,p);
		oid v = *(oid*) @5;
		
		w = offset + v;
		if (w >= base && w < end) {
			oid *h = (oid*) BUNtloc(g, BUNptr(g, w));

			@3(r, bn, (oid*)h);
			if (r) {
				ptr *val = &extremes[@8];
				if (*val != nil) {
					if ((*cmp)(t,nil) == 0) {	
						*val = nil;
					} else if (*val == NULL || (*cmp)(t,*val) @1 0) {
						*val = t;
					}
				} 
			}
		}
	} 
	/* insert the extreme values into the result */
	BATloopFast(bn, r, q, xx) {
		oid *h = (oid*)BUNh@4(bn,r);
		ptr val = extremes[@8];
		/* trick: using a void head-type, only the tail are (over)written */
		void@6_bunfastins_nocheck_noinc(bn, r, h, val?val:nil);
	} 
        GDKfree(extremes);
@c
/*	extreme_typed
	@1:	min/max
	@2:	 < / >
	@3:	b/bn-tail-storage-type			chr/sht/int/lng/any
	@7:	"loc" for fixsized b/bn-tail-type, 	b/bn-tail-access
		"var" for varsized b/bn-tail-type
*/
@= extreme3_typed
str aggrX3_@13_@3_@4(int *ret, BAT *b, BAT *g, BAT *e){
	BAT *bn = BATnew(e->htype, BATttype(b), BATcount(e));	
	int (*cmp)(ptr,ptr) = BATatoms[bn->ttype].atomCmp;
	ptr nil = ATOMnilptr(bn->ttype), zero = nil;
	int xx, yy = 0;
	size_t off = BUNindex(bn,BUNfirst(bn));
	ptr *extremes;
	BUN p, q, r;
	size_t slots, range;
	oid min, max;
	oid bhsb;
  	size_t base, end, w;
	ssize_t offset;

	ALGODEBUG THRprintf(GDKout, "aggrX3_@1_@3_@4[@2](b=%s,g=%s,e=%s);\n",b->batId,g->batId,e->batId);
/*	ERRORcheck((BATcount(b)!=BATcount(g)), "aggrX3_@13_@3_@4: BATs b & g must be of equal size.\n");	*/
	ERRORcheck((g->htype == TYPE_void) && (g->hseqbase == oid_nil), "aggrX3_@13_@3_@4: head of BAT g must not be nil.\n");

	if((g->hseqbase == oid_nil) || (!BAThdense(g)) || (!(BAThordered(b)&1)) || (!g->hkey)) {
		BAT *k=  BATjoin(BATmirror(g),b);
		return aggrX3_@1_@3_@4(ret,  &k->batCacheid, &e->batCacheid);
	}

      	/* init: prepare the result bat; 
	 * trick: by using "tail-type" void, we only write the head column, here */
	@:init_result(void)@
	range = max - min + 1;

	/* scan b & g and replace totals by the extreme value (just pointers to vals in b) */
	slots = BATcount(e);
	if (e->htype == TYPE_void) {
		/* void lookup */
		if (b->htype == TYPE_void) {
			@:aggrX3_minmax3(@2,0,BUNfndVOID,var,&bhsb; bhsb++,@3,@4,BUNindex(bn,r)-off)@
		} else {
			@:aggrX3_minmax3(@2,0,BUNfndVOID,var,BUNhloc(b,p),@3,@4,BUNindex(bn,r)-off)@
		}
	/* e->htype == TYPE_oid */
	} else if (range > SMALL_AGGR_MAX) {
		/* hash lookup */
		if (b->htype == TYPE_void) {
			@:aggrX3_minmax3(@2,1,HASHfnd_oid,loc,&bhsb; bhsb++,@3,@4,BUNindex(bn,r)-off)@
		} else {
			@:aggrX3_minmax3(@2,1,HASHfnd_int,loc,BUNhloc(b,p),@3,@4,BUNindex(bn,r)-off)@
		}
	} else {
		/* array lookup */
		slots = range;
		if (b->htype == TYPE_void) {
			@:aggrX3_minmax3(@2,0,CHKrange,loc,&bhsb; bhsb++,@3,@4,(*(oid*)h)-min)@
		} else {
			@:aggrX3_minmax3(@2,0,CHKrange,loc,BUNhloc(b,p),@3,@4,(*(oid*)h)-min)@
		}
	}
			
	*ret = bn->batCacheid;
	return MAL_SUCCEED;
}
@c
/*	extreme
	@1:	min/max
	@2:	 < / >
*/
@= extreme3
@:extreme3_typed(@1,@2,chr,loc)@
@:extreme3_typed(@1,@2,uchr,loc)@
@:extreme3_typed(@1,@2,sht,loc)@
@:extreme3_typed(@1,@2,int,loc)@
@:extreme3_typed(@1,@2,lng,loc)@
@:extreme3_typed(@1,@2,any,loc)@
@:extreme3_typed(@1,@2,any,var)@

str CMDaggrX3_@13(int *ret,int *bid, int *gid, int *eid){
	BAT *b,*g,*e;
	str rtrn; int tt;

	@:getBATdescriptor(ret,bid,b,sum)@
	@:getBATdescriptor(ret,gid,g,sum)@
	@:getBATdescriptor(ret,eid,e,sum)@
	tt = ATOMstorage(b->ttype);

	ALGODEBUG THRprintf(GDKout, "CMDaggrX3_@1[@2](b=%s,g=%s,e=%s);\n",b->batId,g->batId,e->batId);
/*	ERRORcheck((BATcount(b)!=BATcount(g)), "aggrX3_@13: BATs b & g must be of equal size.\n");	*/
	ERRORcheck((g->htype == TYPE_void) && (g->hseqbase == oid_nil), "aggrX3_@13: head of BAT g must not be nil.\n");

	if((g->hseqbase == oid_nil) || (!BAThdense(g)) || (!(BAThordered(b)&1)) || (!g->hkey)) {
		int k =  BATjoin(BATmirror(g),b)->batCacheid;
		return CMDaggrX3_@1(ret, &k, eid);
	}

	if (tt == TYPE_uchr) {
		rtrn= aggrX3_@13_uchr_loc(ret, b, g, e);
	} else if (tt == TYPE_chr) {
		rtrn = aggrX3_@13_chr_loc(ret, b, g, e);
	} else if (tt == TYPE_sht) {
		rtrn = aggrX3_@13_sht_loc(ret, b, g, e);
	} else if (b->ttype != TYPE_bat && (tt == TYPE_int || tt == TYPE_flt)) {
	        /* ensure use of ATOMput for TYPE_bat */
		rtrn = aggrX3_@13_int_loc(ret, b, g, e);
	} else if (tt == TYPE_dbl || tt == TYPE_lng) {
		rtrn = aggrX3_@13_lng_loc(ret, b, g, e);
	} else if (b->tvarsized) {
		rtrn = aggrX3_@13_any_var(ret, b, g, e);
	} else {
		rtrn = aggrX3_@13_any_loc(ret, b, g, e);
	}
	return rtrn;
}
@c
@:extreme3(min,<)@
@:extreme3(max,>)@

@- Count
@c
/*	aggrX3_count3
		e-void-head	e-oid-head	e-oid-head
		void-lookup	hash-lookup	array-lookup

	@1:	0		0		1		use cnt-array?
	@2:	0		1		0		do BATprepareHash?
	@3:	BUNfndVOID	HASHfnd_oid	CHKrange	lookup
	@4:	var		loc		loc		e/bn-head-access

	@5:	"BUNhloc(b,p)" for  (oid) b-head-type,		b-head access
		"&bhsb; bhsb++" for (void) b-head-type		

	@6:	BUNtloc(bn,r)	BUNtloc(bn,r)	&cnt[(*(oid*)h)-min]	
								*dst: count in-place or in cnt-array ?
*/
@= aggrX3_count3
        ALGODEBUG THRprintf(GDKout, "aggrX3_count3(@1,@2,@3,@4,@5,@6);\n");
	if (@1) {
	 	/* create tmp. cnt array */
		cnt = (int*) GDKmalloc(range*sizeof(int));
		memset(cnt, 0, range*sizeof(int));
	}
	if (@2) { (void) BATprepareHash(bn); }
	/* scan b & g, and increment counts in-place or in cnt-array */
	base = BUNindex(g, BUNfirst(g));
	offset = (ssize_t) (base - g->hseqbase);
	end = base + BATcount(g);
	bhsb = b->hseqbase;
	btt = b->ttype;


       if (*ignore_nils) {
               switch(ATOMstorage(btt)) {
                case TYPE_chr: @:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,if (!simple_EQ(BUNtloc(b,p),bt_nil,chr)))@
                case TYPE_sht: @:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,if (!simple_EQ(BUNtloc(b,p),bt_nil,sht)))@
                case TYPE_int: @:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,if (!simple_EQ(BUNtloc(b,p),bt_nil,int)))@
                case TYPE_lng: @:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,if (!simple_EQ(BUNtloc(b,p),bt_nil,lng)))@
                case TYPE_flt: @:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,if (!simple_EQ(BUNtloc(b,p),bt_nil,flt)))@
                case TYPE_dbl: @:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,if (!simple_EQ(BUNtloc(b,p),bt_nil,dbl)))@
                default: if (b->tvarsized) {
                               @:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,if (!atom_EQ(BUNtvar(b,p),bt_nil,btt)))@
                         } else {
                               @:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,if (!atom_EQ(BUNtloc(b,p),bt_nil,btt)))@
                         }
               }
       } else {
               switch(ATOMstorage(btt)) {
                case TYPE_chr: @:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,)@
                case TYPE_sht: @:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,)@
                case TYPE_int: @:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,)@
                case TYPE_lng: @:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,)@
                case TYPE_flt: @:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,)@
                case TYPE_dbl: @:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,)@
                default: if (b->tvarsized) {
                               @:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,)@
                         } else {
                               @:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,)@
                         }
               }
	}
	if (@1) {
        	/* copy cnt array to final result */
       		BATloopFast(bn, p, q, xx) {
			oid h = (*(oid*) BUNh@4(bn,p)) - min;
			*(int*)BUNtloc(bn, p) = cnt[h];
		}
	        GDKfree(cnt);
	}
@c
/*	aggrX3_count3_loop
       @7:     if (!atom_EQ(BUNt{loc,var}(b,p),bt_nil,btt))            b-tail nil check
               if (!simple_EQ(BUNtloc(b,p),bt_nil,{chr,sht,int,flt,lng,dbl}))
1
*/
@= aggrX3_count3_loop
	BATloopFast(b, p, q, xx) {
		oid v = *(oid*) @5;
		
		w = offset + v;
		if (w >= base && w < end) {
			oid *h = (oid*) BUNtloc(g, BUNptr(g, w));

			@3(r, bn, (oid*)h);
			if (r) {
				@7 {
					int *dst = (int*) @6;
					(*dst)++;
				}
			}
		}
	} 
	break;
@c
str CMDaggrX3_count3(int *retid,int *bid, int *gid, int *eid, bit *ignore_nils){
	BAT *b,*g,*e;
	BAT *bn;
	int zero = 0, *cnt;
	BUN p, q, r;
	int xx; 
	size_t range;
	oid min, max;
	oid bhsb;
  	size_t base, end, w;
	ssize_t offset;
  	int btt;
	ptr bt_nil;

	@:getBATdescriptor(retid,bid,b,count)@
	@:getBATdescriptor(retid,gid,g,count)@
	@:getBATdescriptor(retid,eid,e,count)@

	bn = BATnew(e->htype, TYPE_int, BATcount(e));	
	bt_nil = ATOMnilptr(b->ttype);

        ALGODEBUG THRprintf(GDKout, "CMDaggrX3_count3(b=%s,g=%s,e=%s);\n",b->batId,g->batId,e->batId);
/*	ERRORcheck((BATcount(b)!=BATcount(g)), "CMDaggrX3_count3: BATs b & g must be of equal size.\n");	*/
	ERRORcheck((g->htype == TYPE_void) && (g->hseqbase == oid_nil), "CMDaggrX3_count3: head of BAT g must not be nil.\n");

	if((g->hseqbase == oid_nil) || (!BAThdense(g)) || (!(BAThordered(b)&1)) || (!g->hkey)) {
		int k = BATjoin(BATmirror(g),b)->batCacheid;
		return CMDaggrX3_count(retid, &k, eid, ignore_nils);
	}

	/* init: set all counts to zero and calculate min/max oid */
	@:init_result(int)@
	range = max - min + 1;

	/* scan b & g, and calculate counts */
	if (e->htype == TYPE_void) {
		/* void lookup */
		if (b->htype == TYPE_void) {
			@:aggrX3_count3(0,0,BUNfndVOID,var,&bhsb; bhsb++,BUNtloc(bn,r))@
		} else {
			@:aggrX3_count3(0,0,BUNfndVOID,var,BUNhloc(b,p),BUNtloc(bn,r))@
		}
	/* e->htype == TYPE_oid */
	} else if (range > SMALL_AGGR_MAX) {
		/* hash lookup */
		if (b->htype == TYPE_void) {
			@:aggrX3_count3(0,1,HASHfnd_oid,loc,&bhsb; bhsb++,BUNtloc(bn,r))@
		} else {
			@:aggrX3_count3(0,1,HASHfnd_int,loc,BUNhloc(b,p),BUNtloc(bn,r))@
		}
	} else {
		/* array lookup */
		if (b->htype == TYPE_void) {
			@:aggrX3_count3(1,0,CHKrange,loc,&bhsb; bhsb++,&cnt[(*(oid*)h)-min])@
		} else {
			@:aggrX3_count3(1,0,CHKrange,loc,BUNhloc(b,p),&cnt[(*(oid*)h)-min])@
		}
	}
			
	*retid = bn->batCacheid;
	return MAL_SUCCEED;
}

@}
@}
