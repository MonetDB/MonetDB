@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f lock
@v 1.0
@a Peter Boncz
@* Lightweight Lock Module
This module provides simple SMP lock and thread functionality
as already present in the MonetDB system.

@+ Locks
@mal
atom lock:ptr;

command create() :lock 
address LCKcreate
comment "Create an unset lock";
command set(l:lock) 
address LCKset
comment "Try to set a lock; if set, 
	block till it is freed";
command try(l:lock) :int 
address LCKtry
comment "Try a lock, if free set it, 
	if not return EBUSY";
command unset(l:lock) 
address LCKunset
comment "Unset a lock";
command destroy(l:lock) 
address LCKdestroy
comment "Destroy a lock";
command tostr(l:lock) 
address lockToStr
comment "Overloaded atom function";

@{
@* Implementation
@c
#include <gdk.h>
typedef ptr lock;
typedef ptr monet_lock;

int
create_lock(monet_lock *l)
{
	*l = MT_create_lock();
	return GDK_SUCCEED;
}

int
set_lock(monet_lock *l)
{
	MT_set_lock((MT_Lock) *l, "set_lock");
	return GDK_SUCCEED;
}

int
try_lock(int *res, monet_lock *l)
{
	*res = MT_try_lock((MT_Lock) *l) ? EBUSY : 0;
	return GDK_SUCCEED;
}

int
unset_lock(monet_lock *l)
{
	MT_unset_lock((MT_Lock) *l, "unset_lock");
	return GDK_SUCCEED;
}

int
destroy_lock(monet_lock *l)
{
	MT_destroy_lock((MT_Lock) *l);
	return GDK_SUCCEED;
}


@}
@-
The old code base is wrapped to ease update propagation.
@c
#include "mal.h"
int
lockToStr(char **dst, int *len, ptr *src)
{
	(void) len;		/* fool compiler */
	(void) src;		/* fool compiler */
	if (src == ptr_nil) {
		strcpy(*dst, "nil");
		return 3;
	}
	/* sprintf(*dst,"%o", (ptr)*src); */
	sprintf(*dst, "redo lockToStr");
	return strlen(*dst);
}

str
LCKcreate(monet_lock *l)
{
	create_lock(l);
	return MAL_SUCCEED;
}

str
LCKset(int *res, monet_lock *l)
{
	set_lock(l);
	*res = 1;
	return MAL_SUCCEED;
}

str
LCKtry(int *res, monet_lock *l)
{
	try_lock(res, l);
	return MAL_SUCCEED;
}

str
LCKunset(int *res, monet_lock *l)
{
	unset_lock(l);
	*res = 1;
	return MAL_SUCCEED;
}

str
LCKdestroy(int *res, monet_lock *l)
{
	destroy_lock(l);
	*res = 1;
	return MAL_SUCCEED;
}

@}
