@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2007 CWI.
@' All Rights Reserved.

@f batmath
@a M.L. Kersten
@+ BAT math calculator

@{
@= tstBat
if( bn== NULL) {*ret= 0;
	throw(MAL, "batcalc.@1", "can not create bat");}

@+ Scientific routines
The mmath functions are also overloaded to provide for
the fast execution of expanded code blocks.
The common set of math functions is supported.
@= scienceFcn
	command @1(x:bat[:oid,:dbl])  :bat[:oid,:dbl] 
	address CMDscience_bat_@1;
@= scienceFcnBinary
	command @1(x:bat[:oid,:dbl],y:@2):bat[:oid,:dbl] 
	address CMDscience_bat_cst_@1;
@-
@mal
module batmath;
	@:scienceFcn(asin)@
	@:scienceFcn(acos)@
	@:scienceFcn(atan)@
	@:scienceFcn(cos)@
	@:scienceFcn(sin)@
	@:scienceFcn(tan)@
	@:scienceFcn(cosh)@
	@:scienceFcn(sinh)@
	@:scienceFcn(tanh)@
	@:scienceFcn(exp)@
	@:scienceFcn(log)@
	@:scienceFcn(log10)@
	@:scienceFcn(sqrt)@
	@:scienceFcn(ceil)@
	@:scienceFcn(fabs)@
	@:scienceFcn(floor)@
@-
	round is not binary...
	@:scienceFcnBinary(round,int)@
@mal
	@:scienceFcnBinary(fmod,dbl)@
	@:scienceFcnBinary(atan2,dbl)@
	@:scienceFcnBinary(pow,dbl)@

@- Implementation
@include kprelude.mx

@h
#ifdef _BATMATH_H
#define _BATMATH_H
#define NULLTST

#endif  /* _BATMATH_H */
@- Implementations of scientific functions
@c
#include "mal_config.h"
#include "gdk.h"
#include "math.h"
#include "mal_exception.h"
#include "batmath.h"

#ifdef WIN32
#ifndef LIBBATMATH
#define batmath_export extern __declspec(dllimport)
#else
#define batmath_export extern __declspec(dllexport)
#endif
#else
#define batmath_export extern
#endif

@-
@= scienceFcnImpl
batmath_export str CMDscience_bat_@1(int *ret, int *bid);
str CMDscience_bat_@1(int *ret, int *bid)
{
	BAT *b,*bn;
	@2 *o, *p, *q;

	@:getBATdescriptor(bid,b,"batcalc.@1")@
	@:voidresultBAT(TYPE_dbl,"batcalc.@1")@

	o = (@2*) Tloc(bn, BUNfirst(bn));
	p = (@2*) Tloc(b, BUNfirst(b));
	q = (@2*) Tloc(b, BUNlast(b));

	for(;p<q; o++, p++){
		*o = *p == dbl_nil? dbl_nil: @1(*p);
	}
	BATsetcount(bn, BATcount(b));
	bn->tsorted = 0;
	BATkey(BATmirror(bn),0);           
	
	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); 

	if (b->htype != bn->htype) {
		BAT *r = VIEWcreate(b,bn);

		BBPreleaseref(bn->batCacheid);
		bn = r;
	}
	BBPkeepref(*ret = bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}
@= scienceBinaryImpl
batmath_export str CMDscience_bat_cst_@1(int *ret, int *bid, @2 *d);
str CMDscience_bat_cst_@1(int *ret, int *bid, @2 *d)
{
	BAT *b,*bn;
	@2 *o, *p, *q;

	@:getBATdescriptor(bid,b,"batcalc.@1")@
	@:voidresultBAT(TYPE_dbl,"batcalc.@1")@

	o = (@2*) Tloc(bn, BUNfirst(bn));
	p = (@2*) Tloc(b, BUNfirst(b));
	q = (@2*) Tloc(b, BUNlast(b));

	for(;p<q; o++, p++){
		*o = *p == dbl_nil? dbl_nil: @1(*p,*d);
	}
	BATsetcount(bn, BATcount(b));
	bn->tsorted = 0;
	BATkey(BATmirror(bn),0);           

	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); 

	if (b->htype != bn->htype) {
		BAT *r = VIEWcreate(b,bn);

		BBPreleaseref(bn->batCacheid);
		bn = r;
	}
	BBPkeepref(*ret = bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}
@c
@:scienceFcnImpl(asin,dbl)@
@:scienceFcnImpl(acos,dbl)@
@:scienceFcnImpl(atan,dbl)@
@:scienceFcnImpl(cos,dbl)@
@:scienceFcnImpl(sin,dbl)@
@:scienceFcnImpl(tan,dbl)@
@:scienceFcnImpl(cosh,dbl)@
@:scienceFcnImpl(sinh,dbl)@
@:scienceFcnImpl(tanh,dbl)@
@:scienceFcnImpl(exp,dbl)@
@:scienceFcnImpl(log,dbl)@
@:scienceFcnImpl(log10,dbl)@
@:scienceFcnImpl(sqrt,dbl)@
@:scienceFcnImpl(ceil,dbl)@
@:scienceFcnImpl(fabs,dbl)@
@:scienceFcnImpl(floor,dbl)@
@-
	round is not binary...
	@:scienceBinaryImpl(round,int)@
@c
@:scienceBinaryImpl(fmod,dbl)@
@:scienceBinaryImpl(atan2,dbl)@
@:scienceBinaryImpl(pow,dbl)@

@}
