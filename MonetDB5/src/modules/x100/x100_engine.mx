@f x100_engine
@a Peter Boncz, Niels Nes
@v 0.1 
@* X100 Execution Primitives
@T
This is a MIL-like vectorized vertically decomposed primitives. There are currently three basic commands:
\begin{itemize}
\item {\bf aggr(N,res,grp,param}: increment a field in an aggregate result array: res[grp[i]] = AGGR\_INC(res[grp[i]], p[i]).
The first parameter N is the vector length (in this case the size of grp and param). 
\item {\bf map(N, res, p1, p2..)} Apply a function over all parameters (which may be vectors or single values), 
filling the result vector: res[i] = ANY\_FCN(p1[i], p2[i],..). All non-aggregate functions have a map implementation,
for each permutation of signatures where parameters can be either constants or vectors (including the variant with all constants).
\item {\bf select(N,res,..params..)}: Like a map, but the result is a vector of those positions where the boolean 
function evaluated to true: res[i] = i; i += BOOL\_FCN(p1[i], p2[i],..). The return value is the number of values selected.
An all-constant-parameter version of select implementations is not relevant, of course.
\end{itemize}
All functions may get an additional extra parameter, which is a selection vector. In this case, the operation is only
executed on those vector indices pointed to by uidx selection vector. 

@+ Engine
@T
This is it: all what used to be MIL. The "engine" macro, using either the "impl" or "decl" parameter, 
is used to instantiate all implementations, as well as the function lookup table (see below).

Some types and operators are still disabled to keep compilation fast.

@= engine
	@:cardinal(@1,uchr,ulng)@
	@:cardinal(@1,uint,ulng)@
	@:cardinal(@1,uidx,ulng)@
	@:floating(@1,flt,dbl)@
	@:floating(@1,dbl,dbl)@
	@:@1_grp(uchr)@
@
	@:cardinal(@1,usht,ulng)@
	@:cardinal(@1,ulng,ulng)@
	@:cardinal(@1,schr,slng)@
	@:cardinal(@1,ssht,slng)@
	@:cardinal(@1,sint,slng)@
	@:cardinal(@1,slng,slng)@

@= cast_ops
	@:@1_castop(@2,uchr)@
	@:@1_castop(@2,uint)@
	@:@1_castop(@2,uidx)@
	@:@1_castop(@2,flt)@
	@:@1_castop(@2,dbl)@
@
	@:@1_castop(@2,usht)@
	@:@1_castop(@2,ulng)@
	@:@1_castop(@2,schr)@
	@:@1_castop(@2,ssht)@
	@:@1_castop(@2,sint)@
	@:@1_castop(@2,slng)@

@= type_ops
	@:@1_fetchop(@2)@
	@:cast_ops(@1,@2)@
	@:@1_boolop_binary(<=,le,@2,@2)@
	@:@1_boolop_binary(>,gt,@2,@2)@
@
	@:@1_boolop_binary(<,lt,@2,@2)@
	@:@1_boolop_binary(>=,ge,@2,@2)@
	@:@1_boolop_binary(=,eq,@2,@2)@
	@:@1_boolop_binary(!=,ne,@2,@2)@

@= arith_ops
	@:@1_op_binary(*,mul,@2,@2,@2)@
	@:@1_op_binary(/,div,@2,@2,@2)@
	@:@1_op_binary(+,add,@2,@2,@2)@
	@:@1_op_binary(-,sub,@2,@2,@2)@
	@:@1_aggrop(sum,sum,@2,@3)@
@
	@:@1_op_unary(-,neg,@2,@2)@
	@:@1_op_unary(dec,dec,@2,@2)@
	@:@1_op_unary(abs,ABS,@2,@2)@
	@:@1_op_unary(inc,inc,@2,@2)@
	@:@1_aggrop(min,min,@2,@2)@
	@:@1_aggrop(max,max,@2,@2)@

@= floating
	@:type_ops(@1,@2)@
	@:arith_ops(@1,@2,@3)@
@
	@:@1_op_binary(pow,pow,dbl,dbl,dbl)@
	@:@1_op_unary(sin,sin,dbl,dbl)@
	@:@1_op_unary(asin,asin,dbl,dbl)@
	@:@1_op_unary(cos,cos,dbl,dbl)@
	@:@1_op_unary(acos,acos,dbl,dbl)@
	@:@1_op_unary(tan,tan,dbl,dbl)@
	@:@1_op_unary(atan,atan,dbl,dbl)@
	@:@1_op_unary(exp,exp,dbl,dbl)@
	@:@1_op_unary(log,log,dbl,dbl)@
	@:@1_op_unary(log10,log10,dbl,dbl)@

@= cardinal
	@:type_ops(@1,@2)@
	@:arith_ops(@1,@2,@3)@
@
	@:@1_op_binary(<<,bitshl,@2,@2,@2)@
	@:@1_op_binary(>>,bitshr,@2,@2,@2)@
	@:@1_op_binary(&,bitand,@2,@2,@2)@
	@:@1_op_binary(|,bitor,@2,@2,@2)@

@+ Basic Functors
These are defined as macros, since we do not want function calls (brrr!@#..) in our inner loop.

@= def
#undef @1
#define @1@2 @3
@h
#include <gdk.h>
#include <mtime.h>

@:def(uchr,, unsigned char)@
@:def(schr,, signed char)@
@:def(usht,, unsigned short)@
@:def(ssht,, signed short)@
@:def(uint,, unsigned int)@
@:def(sint,, signed int)@
@:def(ulng,, unsigned long long)@
@:def(slng,, signed long long)@

@:def(uidx,, size_t)@
@c
#include <math.h>
#include "x100_engine.h"
#include "x100.h"

#define RESTRICT
#ifdef RESTRICT
#define __r  __restrict__
#else
#define __r
#endif


@:def(eq, (x, y), ((x) == (y)))@
@:def(ne, (x, y), ((x) != (y)))@
@:def(gt, (x, y), ((x) > (y)))@
@:def(lt, (x, y), ((x) < (y)))@
@:def(ge, (x, y), ((x) >= (y)))@
@:def(le, (x, y), ((x) <= (y)))@
@:def(and, (x, y), ((x) && (y)))@
@:def(or, (x, y), ((x) || (y)))@

@:def(directgrp, (x, y, z), ((x) + (((uidx) (y)) << (z))))@
@:def(not, (x), !(x))@

@:def(mul, (x, y), ((x) * (y)))@
@:def(div, (x, y), ((x) / (y)))@
@:def(sub, (x, y), ((x) - (y)))@
@:def(add, (x, y), ((x) + (y)))@
@:def(neg, (x), (-(x)))@
@:def(inc, (x), (x + 1))@
@:def(dec, (x), (x - 1))@
@:def(bitshl, (x, y), (x) << (y))@
@:def(bitshr, (x, y), (x) >> (y))@
@:def(bitand, (x, y), (x) & (y))@
@:def(bitor, (x, y), (x) | (y))@
@:def(bitxor, (x, y), (x) ^ (y))@
@:def(bitnot, (x), ~(x))@
@:def(sum, (x, y), ((x) + (y)))@
@:def(min, (x, y), ((x) < (y) ? (x) : (y)))@
@:def(max, (x, y), ((x) > (y) ? (x) : (y)))@
@c
size_t
aggr_count_uidx_col(size_t n, uidx * __r res, uidx * __r grp, uidx * __r sel)
{
	@:impl(res[grp[i]]++)@
	return 0;
}
static size_t
aggr4_count_uidx_col_multicursor(size_t n, uidx * __r res0, uidx * __r res1, uidx * __r res2, uidx * __r res3, uidx * __r grp, uidx * __r sel)
{
	@:impl4(res0[grp[i]]++, res1[grp[i]]++, res2[grp[i]]++, res3[grp[i]]++)@
	return 0;
}

size_t
aggr4_count_uidx_col(size_t n, uidx * __r res0, uidx * __r grp, uidx * __r memchunk, uidx * __r sel)
{
	uidx m = *memchunk;
	uidx *res1 = res0 + m;
	uidx *res2 = res1 + m;
	uidx *res3 = res2 + m;

	if (n > 0)
		return aggr4_count_uidx_col_multicursor(n, res0, res1, res2, res3, grp, sel);
	/* calculate final result as aggregate over 4 partials */
	for (n = 0; n < m; n++) {
		res0[n] += res1[n] + res2[n] + res3[n];
	}
	return 0;
}

size_t
select__uint_col(size_t n, uidx * __r res, uint * __r col1, uidx * __r sel)
{
	size_t ret = 0;

	@:impl(if (col1[i]) res[ret++] = i) @
	return ret;
}

@= indextile
size_t map_indextile_uidx_val_uidx_val_@1_val(size_t n, @1 *res, uidx *Pos, uidx *Mult, @1 *Domain) {
        uidx pos = *Pos, domain = *Domain, mult = *Mult, off = 0;
        if (mult == 1) {
                uidx i = pos % domain;

                while (off+domain-i < n) {
			uidx d = (domain + off) - i; 
			@1 m = i;
                        while(off+4 < d) { /* hand-unroll loop with double increments */
				res[off] = m; res[off+1] = m+1; res[off+2] = m+2; res[off+3] = m+3;
				off += 4; m += 4;
			}
                        while(off < d) res[off++] = m++;
                        i = 0;
                }
                while(off < n) res[off++] = i++;
        } else {
                uidx l = pos / mult, i = pos - mult*l;
                @1 k = l % domain;
                while (off+mult-i < n) {
                        while(i++ < mult) res[off++] = k;
                        if (++k == domain) k = 0;
                        i = 0;
                }
                while (off < n) res[off++] = k;
        }
        return off;
}
@c
@:indextile(uidx)@
@:indextile(dbl)@

@:engine(impl)@

FcnMap x100_fcnmap[] = {
	{"uidx", "aggr_count_uidx_col", (ExprFcn) aggr_count_uidx_col,},
	{"uidx", "aggr4_count_uidx_col", (ExprFcn) aggr4_count_uidx_col,},
	{"uidx", "select__uint_col,uidx", (ExprFcn) select__uint_col,},
	{"uidx", "map_indextile_uidx_val_uidx_val_uidx_val", (ExprFcn) map_indextile_uidx_val_uidx_val_uidx_val,},
	{"dbl", "map_indextile_uidx_val_uidx_val_dbl_val", (ExprFcn) map_indextile_uidx_val_uidx_val_dbl_val,},
	@:engine(decl)@
NULL, NULL,};


@+ Macro Implementations

The main loop is explicitly unrolled 8 times, as compiler like this best still.
Normally, the body is the same, but we allow to use 2, 4, or 8 different bodies (e.g. multi-cursor) also.
@= impl
	@:impl2(@1,@1)@
@= impl2
	@:impl4(@1,@2,@1,@2)@
@= impl4
	@:impl8(@1,@2,@3,@4,@1,@2,@3,@4)@
@= impl8
	uidx i=0, j=0; /* >99% of the execution time should be in these 6 lines */
	if (sel) {
		#pragma noprefetch
		for(j=0; j+8 < n; j+= 8){
			i = sel[j+0]; @1; 
			i = sel[j+1]; @2; 
			i = sel[j+2]; @3; 
			i = sel[j+3]; @4; 
			i = sel[j+4]; @1; 
			i = sel[j+5]; @2; 
			i = sel[j+6]; @3; 
			i = sel[j+7]; @4; 
		}
		for(; j<n; j++) { i = sel[j]; @1; }
	} else {
		#pragma noprefetch
		while(i+8 < n){
			@1; i++;
			@2; i++;
			@3; i++;
			@4; i++;
			@1; i++;
			@2; i++;
			@3; i++;
			@4; i++;
		}
		for(; i<n; i++) { @1; }
	}
@= impl1
	uidx i, j; /* >99% of the execution time should be in these 6 lines */
	if (sel) {
		#pragma noprefetch
		for(j=0; j<n; j++) { i = sel[j]; @1; }
	} else {
		#pragma noprefetch
		for(i=0; i<n; i++) { @1; }
	}
@
	@:impl(@1)@
@= impl_op_unary
	size_t map_@2_@3_col(size_t n, @4*__r res, @3*__r col1, uidx*__r sel) {
		@:impl1(res[i] = @2(col1[i]))@
		return n;
	}
	size_t map_@2_@3_val(size_t n, @4*__r res, @3*__r val1) {
  		*res = @2(*val1);
		return 1;
	}
@= decl_op_unary
	{ "@4", "map_@1_@3_col", (ExprFcn) map_@2_@3_col, },
	{ "@4", "map_@1_@3_val", (ExprFcn) map_@2_@3_val, },
@= impl_castop
	#ifndef to@1
	#define to@1(x) ((@1) (x))
	#endif
	@:impl_op_unary(@1,to@1,@2,@1)@
@= decl_castop
	@:decl_op_unary(@1,to@1,@2,@1)@
@= impl_op_binary
	size_t map_@2_@3_col_@4_col(size_t n, @5*__r res, @3*__r col1, @4*__r col2, uidx*__r sel) {
		@:impl1(res[i] = @2(col1[i],col2[i]))@
		return n;
	}
	size_t map_@2_@3_val_@4_col(size_t n, @5*__r res, @3*__r val1, @4*__r col2, uidx*__r sel) {
		@:impl1(res[i] = @2(*val1,col2[i]))@
		return n;
	}
	size_t map_@2_@3_col_@4_val(size_t n, @5*__r res, @3*__r col1, @4*__r val2, uidx*__r sel) {
		@:impl1(res[i] = @2(col1[i],*val2))@
		return n;
	}
	size_t map_@2_@3_val_@4_val(size_t n, @5*__r res, @3*__r val1, @4*__r val2) {
		*res = @2(*val1,*val2);
		return 1;
	}
@= decl_op_binary
	{ "@5", "map_@1_@3_col_@4_col", (ExprFcn) map_@2_@3_col_@4_col, },
	{ "@5", "map_@1_@3_col_@4_val", (ExprFcn) map_@2_@3_col_@4_val, },
	{ "@5", "map_@1_@3_val_@4_col", (ExprFcn) map_@2_@3_val_@4_col, },
	{ "@5", "map_@1_@3_val_@4_val", (ExprFcn) map_@2_@3_val_@4_val, },
@= impl_boolop_binary
	@:impl_op_binary(@1,@2,@3,@4,uidx)@
	size_t select_@2_@3_col_@4_col(size_t n, uidx*__r res, @3*__r col1, @4*__r col2, uidx*__r sel) {
		size_t ret = 0;
		@:impl(if (@2(col1[i], col2[i])) res[ret++] = i)@
		return ret; 
	}
	size_t select_@2_@3_col_@4_val(size_t n, uidx*__r res, @3*__r col1, @4*__r val2, uidx*__r sel) {
		size_t ret = 0;
		@4 v = *val2;
		@:impl(if (@2(col1[i], v)) res[ret++] = i)@
		return ret; 
	}
	size_t select_@2_@3_val_@4_col(size_t n, uidx*__r res, @3*__r val1, @4*__r col2, uidx*__r sel) {
		size_t ret = 0;
		@3 v = *val1;
		@:impl(if (@2(v, col2[i])) res[ret++] = i)@
		return ret; 
	}
@= decl_boolop_binary
	@:decl_op_binary(@1,@2,@3,@4,uidx)@
	{ "uidx", "select_@1_@3_col_@4_col", (ExprFcn) select_@2_@3_col_@4_col, },
	{ "uidx", "select_@1_@3_val_@4_col", (ExprFcn) select_@2_@3_val_@4_col, },
	{ "uidx", "select_@1_@3_col_@4_val", (ExprFcn) select_@2_@3_col_@4_val, },
@= impl_grp
	size_t map_directgrp_uidx_col_@1_col_uint_val(size_t n, uidx*__r res, uidx*__r col1, @1*__r col2, uint*__r  val3, uidx*__r  sel) {
		int sh = *val3;
		@:impl1(res[i] = directgrp(col1[i], col2[i], sh))@
		return n; 
	}
@= decl_grp
	{ "uidx", "map_directgrp_uidx_col_@1_col_uint_val", (ExprFcn) map_directgrp_uidx_col_@1_col_uint_val, }, 
@= impl_aggrop
	size_t aggr_@1_@3_col_uidx_col(size_t n, @4*__r res, @3*__r  col1, uidx*__r  grp, uidx*__r  sel) {
		@:impl1(res[grp[i]] = @1(res[grp[i]],col1[i]))@
		return 0;
	}
	static size_t aggr4_@1_@3_col_uidx_col_multicursor(size_t n, @4*__r res0, @4*__r  res1, @4*__r  res2, @4*__r  res3, @3*__r  col1, uidx*__r  grp, uidx*__r  sel) {
		@:impl4(res0[grp[i]] = @1(res0[grp[i]],col1[i]), res1[grp[i]] = @1(res1[grp[i]],col1[i]), res2[grp[i]] = @1(res2[grp[i]],col1[i]), res3[grp[i]] = @1(res3[grp[i]],col1[i]))@
		return 0;
	}
	size_t aggr4_@1_@3_col_uidx_col(size_t n, @4*__r res0, @3*__r col1, uidx*__r grp, uidx*__r memchunk, uidx*__r sel) {
		uidx m = *memchunk;
		@4* res1 = res0 + m;
		@4* res2 = res1 + m;
		@4* res3 = res2 + m;
		if (n > 0) return aggr4_@1_@3_col_uidx_col_multicursor(n, res0, res1, res2, res3, col1, grp, sel);
		/* calculate final result as aggregate over 4 partials */
		for(n=0; n<m; n++) {
			res0[n] = @2(@2(@2(res0[n],res1[n]),res2[n]),res3[n]);
		} 
		return 0;
	}
@= decl_aggrop
	{ "@4", "aggr_@1_@3_col_uidx_col", (ExprFcn) aggr_@1_@3_col_uidx_col, },
	{ "@4", "aggr4_@1_@3_col_uidx_col", (ExprFcn) aggr4_@1_@3_col_uidx_col, },
@= impl_fetchop
	size_t map_fetch_dbl_col_@1_col(size_t n, @1*__r res, dbl*__r col1, @1*__r val2, uidx*__r sel) {
		@:impl1(res[i] = val2[(uidx) col1[i]])@
		return 0;
	}
	size_t map_fetch_uidx_col_@1_col(size_t n, @1*__r res, uidx*__r col1, @1*__r val2, uidx*__r sel) {
		@:impl1(res[i] = val2[col1[i]])@
		return 0;
	}
@= decl_fetchop
	{ "@1", "map_fetch_uidx_col_@1_col", (ExprFcn) map_fetch_uidx_col_@1_col, },
	{ "@1", "map_fetch_dbl_col_@1_col", (ExprFcn) map_fetch_dbl_col_@1_col, },


@- Experimental Code (turned off)
@
; printf("%lu %d\n", (long) val2, col1[i]))
@= group_op
	gid = grp[i]; 			
	if (gid != cgid){	
		res[cgid] += cur;  	
		cur = 0;		
	}
	cgid = gid;
	cur += col1[i];

@= impl_mergesumop
	size_t aggr_@1_@3_col_uidx_col(size_t n, @4*__r  res, @3*__r  col1, uidx*__r  grp, uidx*__r  sel) {
	uidx i = 0, j = 0; /* >99% of the execution time should be in these 6 lines */
	if (n==0) return n;
	if (sel) {
		uidx gid, cgid = grp[sel[0]];
		@3 cur = col1[sel[0]];
		j = 1;
		#pragma noprefetch
		while(j+8 < n){
			i = sel[j]; @:group_op@
			i = sel[j+1]; @:group_op@
			i = sel[j+2]; @:group_op@
			i = sel[j+3]; @:group_op@
			i = sel[j+4]; @:group_op@
			i = sel[j+5]; @:group_op@
			i = sel[j+6]; @:group_op@
			i = sel[j+7]; @:group_op@
			j += 8;
		}
		for(; j<n; j++) { i = sel[j]; @:group_op@ }
		res[cgid] += cur;  	
	} else {
		uidx gid, cgid = grp[0];
		@3 cur = col1[0];
		i = 1;
		#pragma noprefetch
		for(; i+8 < n;){
			@:group_op@ i++;
			@:group_op@ i++;
			@:group_op@ i++;
			@:group_op@ i++;
			@:group_op@ i++;
			@:group_op@ i++;
			@:group_op@ i++;
			@:group_op@ i++;
		}
		for(; i<n; i++) { @:group_op@ }
		res[cgid] += cur;  	
	}
	return 0;
	}
@= decl_mergesumop
	{ "@4", "aggr_@1_@3_col_uidx_col", (ExprFcn) aggr_@1_@3_col_uidx_col, },

@= impl_sum14op
	size_t aggr_@1_@3_col_uidx_col(size_t n, @4*__r  res, @3*__r  col1, uidx*__r  grp, uidx*__r  sel) {
	uidx i = 0, j = 0; /* >99% of the execution time should be in these 6 lines */
	if (n==0) return n;
	if (sel) {
		@4 cur = 0;
		#pragma noprefetch
		for(j=0; j+14 < n; j+= 14){
			i = sel[j]; cur += col1[i];
			i = sel[j+1]; cur += col1[i];
			i = sel[j+2]; cur += col1[i];
			i = sel[j+3]; cur += col1[i];
			i = sel[j+4]; cur += col1[i];
			i = sel[j+5]; cur += col1[i];
			i = sel[j+6]; cur += col1[i];
			i = sel[j+7]; cur += col1[i];
			i = sel[j+8]; cur += col1[i];
			i = sel[j+9]; cur += col1[i];
			i = sel[j+10]; cur += col1[i];
			i = sel[j+11]; cur += col1[i];
			i = sel[j+12]; cur += col1[i];
			i = sel[j+13]; cur += col1[i];
			res[grp[i]] = cur;
			cur = 0;
		}
	} else {
		#pragma noprefetch
		for(i=0; i+14 < n; i += 14){
			@4 cur = 0;
			for(j=0;j<7;j++){
				cur += col1[i+j] + col1[i+j+7];
			}
			res[grp[i]] = cur;
		}
	}
	return 0;
	}
@= decl_sum14op
	{ "@4", "aggr_@1_@3_col_uidx_col", (ExprFcn) aggr_@1_@3_col_uidx_col, },
