@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f mtime
@a Peter Boncz, Martin van Dinther
@v 1.0

@* Temporal Module
@T
The goal of this module is to provide adequate functionality for storing
and manipulated time-related data. The minimum requirement is that data
can easily be imported from all common commercial RDBMS products.

This module supersedes the 'temporal' module that has a number of 
conceptual problems and hard-to-solve bugs that stem from these problems.

The starting point of this module are SQL 92 and the ODBC time-related data types.
Also, some functionalities have been imported from the time classes of the Java
standard library.
@T
This module introduces four basic types and operations on them:
\begin{description}
\item[date] a date in the gregorian calendar, e.g. 1999-JAN-31

\item[daytime] a time of day to the detail of milliseconds, e.g. 23:59:59:000

\item[timestamp] a combination of date and time, indicating an exact point in 
time (GMT). GMT is the time at the greenwich meridian without a daylight savings 
time (DST) regime. Absence of DST means that hours are consecutive (no jumps) which 
makes it easy to perform time difference calculations.
\item[timezone] the local time is often different from GMT (even at greenwich in
summer, as the UK also has DST). Therefore, whenever a timestamp is composed
from a local daytime and date, a timezone should be specified in order to
translate the local daytime to GMT (and vice versa if a timestamp is to
be decomposed in a local date and daytime).

There is an additional atom {\bf rule} that is used to define when daylight
savings time in a timezone starts and ends. We provide predefined timezone
objects for a number of timezones below (see the LOAD section of the module).
Also, there is one timezone called the {\bf local timezone}, which can be set
to one global value in a running Monet server, that is used if the timezone 
parameter is omitted from a command that needs it (if not set, the default value 
of the local timezone is plain GMT).
\end{description}

@+ Limitations
@T
The valid ranges of the various data types are as follows:
\begin{description}
\item[min and max year]
The maximum and minimum dates and timestamps that can be stored are in the years 5,867,411 and 
-5,867,411, respectively. Interestingly, the year 0 is not a valid year. The year before 1 is 
called -1. 
\item[valid dates]
Fall in a valid year, and have a month and day that is valid in that year. The first day in the year
is january 1, the last december 31. Months with 31 days are january, march, may, juli, august,
october, and december, while april, june, september and november have 30 days. February has 28
days, expect in a leapyear, when it has 29. A leapyear is a year that is an exact multiple of
4. Years that are a multiple of 100 but not of 1000 are an execption; they are no leapyears.
\item[valid daytime]
The smallest daytime is 00:00:00:000 and the largest 23:59:59:999 (the hours in a daytime
range between [0,23], minutes and seconds between [0,59] and milliseconds between [0:999]).
Daytime identifies a valid time-of-day, not an amount of time (for denoting amounts of time, or
time differences, we use here concepts like "number of days" or "number of milliseconds" denoted 
by some value of a standard integer type).
\item[valid timestamp]
is formed by a combination of a valid date and valid daytime.
\item[difference in days]
For difference calculations between dates (in numbers of days) we use signed integers (the {\tt int} 
Monet type), hence the valid range for difference calculations is between -2147483648 and 
2147483647 days (which corresponds to roughly -5,867,411 and 5,867,411 years). 
\item[difference in msecs]
For difference between timestamps (in numbers of milliseconds) we use 64-bit longs (the {\tt lng} Monet type).
These are large integers of maximally 19 digits, which therefore impose a limit of about 106,000,000,000 years 
on the maximum time difference used in computations. 
\end{description}

There are also conceptual limitations that are inherent to the time system itself:
\begin{description}
\item[gregorian calendar]
The basics of the Gregorian calendar stem from the time of Julius Ceasar,
when the concept of a solar year as consisting of 365.25 days (365 days plus once 
in 4 years one extra day) was introduced. However, this Julian Calendar, made a year 11  
minutes long, which subsequently accumulated over the ages, causing a shift in 
seasons. In medieval times this was noticed, and in 1582 Pope Gregory XIII issued a 
decree, skipped 11 days. This measure was not adopted in the whole of Europe inmediately, 
however.  For this reason, there were many regions in Europe that upheld different dates. 

It was only on {\bf september 14, 1752} that some concensus was reached and more countries 
joined the Gregorian Calendar, which also was last modified at that time. The modifications 
were twofold:first, 12 more days were skipped. Second, it was determined that the
year starts on january 1 (in England, for instance, it had been starting on march 25).

Other parts of the world have adopted the Gregorian Calendar even later.

This module implements the Gregorian Calendar in all its regularity. This means
that values before the year 1752 probably do not correspond with the dates that
people really used in times before that (what they did use, however, was very vague
anyway, as explained above). In solar terms, however, this calendar is reasonably 
accurate (see the "correction seconds" note below).

\item[timezones]
The basic timezone regime was established on {\bf november 1, 1884} in the {\em International 
Meridian Conference} held in Greenwich (UK). Before that, a different time held in almost 
any city. The conference established 24 different time zones defined by regular longitude intervals
that all differed by one hour.  Not for long it was that national and political interest started 
to erode this nicely regular system.  Timezones now often follow country borders, and some regions 
(like the Guinea areas in Latin America) have times that differ with a 15 minute grain from GMT 
rather than an hour or even half-an-hour grain.

An extra complication became the introduction of daylight saving time (DST), which 
causes a time jump in spring, when the clock is skips one hour and in autumn, when the 
clock is set back one hour (so in a one hour span, the same times occur twice). 
The DST regime is a purely political decision made on a country-by-country basis. Countries
in the same timezone can have differnt DST regimes. Even worse, some countries have DST in 
some years, and not in other years. 

To avoid confusion, this module stores absolute points of time in GMT only (GMT does not
have a DST regime). When storing local times in the database, or retrieving local times
from absolute timestamps, a correct timezone object should be used for the conversion.

Applications that do not make correct use of timezones, will produce irregular results 
on e.g. time difference calculations.

\item[correction seconds]
Once every such hundred years, a correction second is added on new year's night.
As I do not know the rule, and this rule would seriously complicate this module
(as then the duration of a day, which is now the fixed number of 24*60*60*1000 
milliseconds, becomes parametrized by the date), it is not implemented. Hence 
these seconds are lost, so time difference calculations in milliseconds (rather than 
in days) have a small error if the time difference spans many hundreds of years.
\end{description}

TODO:we cannot handle well changes in the tzone rules (e.g., DST only exists since 
40 years, and some countries make frequent changes to the DST policy). To accommodate
this we should make tzone\_local a function with a year parameter. The tool should 
maintain and access the tzone database stored in two bats [str,tzone],[str,year]. 
Lookup of the correct tzone would be dynamic in this structure. The tzone\_setlocal 
would just set the string name of the tzone.

@+ Time/date comparison 

@= compareGrp
command =(v:@1,w:@1):bit 
address MTIME@1_EQ
comment "Equality of two @1s";
command !=(v:@1,w:@1):bit 
address MTIME@1_NEQ
comment "Equality of two @1s";
command <(v:@1,w:@1):bit 
address MTIME@1_LT
comment "Equality of two @1s";
command <=(v:@1,w:@1):bit 
address MTIME@1_LE
comment "Equality of two @1s";
command >(v:@1,w:@1):bit 
address MTIME@1_GT
comment "Equality of two @1s";
command >=(v:@1,w:@1):bit 
address MTIME@1_GE
comment "Equality of two @1s";

command isnil(v:@1):bit 
address MTIME@1_isnil
        comment "Nil test for @1 value";
@mal

@+ Date atom
@T
Monet atoms can have multiple {\em parse formats}. One of these formats is
chosen as the {\em print format}.

To facilitate date descriptions, many formats are supported when parsing
date atoms from a string, as described by the below grammar. 
{\small
\begin{verbatim}
print format: INT_YEAR '-' INT_MONTH '-' INT_DAY
parse format: 
	INT_YEAR SEP1 INT_MONTH SEP1 INT_DAY
  or: INT_YEAR SEP2 STR_MONTH SEP2 INT_DAY
  or: STR_MONTH ' '+ INT_DAY ',' ' '* INT_YEAR

with:   
	INT_YEAR = between -5867411 and 5867411
        INT_DAY = integer between 1 and 31
	INT_MONTH = integer between 1 and 12
	STR_MONTH = 'JANUARI' or 'FEBRUARI' or 
		   'MARCH' or 'APRIL' or 'MAY'  or 
		   'JUNE' or 'JULI' or 'AUGUST' or 
		   'SEPTEMBER' or 'OCTOBER' 
                   or 'NOVEMBER' or 'DECEMBER' 
                   (lowercase characters, and/or 
                   only the first three characters 
                   are also allowed)
            SEP1 = '-' or '/' or '\' or (' ')+
            SEP2 = SEP1 or ''
\end{verbatim}
}
Printing a date uses the 1999-01-31 format, as this is both language neutral 
and the lexicografical string ordering of this representation respects the 
actual date ordering.

Other print formats can be achieved by writing a customized MIL procedure 
that extract year, month and day from a date as integers and formats those 
in a string.
@mal
atom date :int;
command fromstr() :date 
address date_fromstr;
command tostr() :str 
address date_tostr;
@:compareGrp(date)@
@+ Daytime atom
@T
A valid time of day to the detail of milliseconds, like 23:59:59:000
{\small
\begin{verbatim}
print format: HOUR ':' MIN ':' SEC '.' MSEC
parse format: HOUR ':' MIN ':' SEC SEP MSEC
          or: HOUR ':' MIN ':' SEC 
          or: HOUR ':' MIN 

with: HOUR = integer between 0 and 23 
       MIN = integer between 0 and 59 
       SEC = integer between 0 and 59 (default 0)
      MSEC = integer between 0 and 999 (default 0)
       SEP = '.' or ':'
\end{verbatim}
}
@mal
atom daytime :int;
command fromstr():daytime 
address daytime_fromstr;
command tostr():str 
address daytime_tostr;
@:compareGrp(daytime)@

@+ Timestamp
@T
An absolute point of time, as formed by the combination of a date a daytime in GMT
e.g. 1999-01-31@23:59:59:000. GMT is the universal time at the greenwhich meridian, 
without any daylight savings time (DST). As such GMT times are 'absolute' (continuous,
without hour jumps as in DST), so accurate time difference computations can be performed.
{\small
\begin{verbatim}
print format: DATE ' ' DAYTIME 
parse format: DATE ' ' DAYTIME  ['GMT' ZONE ]

with:    DATE = a valid parse format of the 
	 	date atom (as decribed earlier)
      DAYTIME = a valid parse format of the 
		daytime atom (as decribed earlier)
         ZONE = ('+'|'-') HOUR ':' MIN [ 'DST' ]
\end{verbatim}
}
Though internally timestamps are stored in GMT, the printing and parsing of 
timestamps is relative to the local timezone. That is, timestamps are 
printed without GMT part, meaning that the time is relative to the local 
timezone.   Also, if a timestamp is parsed from a string that does not have
an explicit GMT specifier, it is taken to be a timestamp in the local 
timezone. The default local timzone is just GMT+00, but iit can be set 
arbitrarily.
@mal
atom timestamp :lng;# not stored as a lng !
command fromstr():timestamp 
address timestamp_fromstr;
command tostr():str 
address timestamp_tostr;
#.NULL	 address timestamp_null;
command unix_epoch():timestamp
address MTIMEunix_epoch
comment "The Unix epoch time (00:00:00 UTC on January 1, 1970)";
command epoch():timestamp
address MTIMEepoch
comment "unix-time (epoch) support: seconds since the Unix epoch";
command epoch(t:timestamp):lng 
address MTIMEepoch2lng
comment "unix-time (epoch) support: seconds since epoch";

@:compareGrp(timestamp)@

@T
When creating a timestamp from a date and daytime, a timezone should be specified
(if timezone is omitted, the local timezone is assumed). If a timezone is specified, 
it is used to convert the date and time in that timezone to GMT, which is the internal 
timestamp representation. One problem here is that the first hour after DST
has ended (some sunday night in autumn, generally), the time is set back one hour, so
the same times occur twice. Hence two translations to a timestamp are possible for
such date and time combinations. In those case, we act as if it was the first 
occurence (still within DST). 

@+ Tzone
@T
A timezone determines a {\em time offset} from GMT with format 
[-] HOUR ':' MINUTES, with HOUR between [0:23] and MINUTES between [0:59].

Possibly, {\em Daylight Savings Time} (DST) is in force in a timezone, which means that
between a start and an end date, the clock is set back {\bf one hour}. The start and 
end date of DST are determined by a {\em rule}. These rules (similar to the
Java Timezone class) are made up of 4 parameters:a month {\bf M}, a day number in the 
month {\bf D}, a day-of-week (monday,..,sunday) denoted {\bf W}, and a daytime {\bf T}
(only to the minute detail).

Depending of the values of these parameters, five kinds of rules can be made
(similar to the Java TimeZone class):
\begin{itemize}
\item first {\bf D}th weekday {\bf W} from start of month {\bf M}.\\
iff {\bf D} in [1,..,5], {\bf W} in [1,..,7] 

\item last {\bf D}th weekday {\bf W} from end of month {\bf M}.\\
iff {\bf D} in [-5,..,-1], {\bf W} in [1,..,7] 

\item first weekday {\bf W} in month {\bf M} after exact {\bf D}th day of month.\\
iff {\bf D} in [1,..,31], {\bf W} in [-7,..,-1] 

\item last weekday {\bf W} in month {\bf M} before exact {\bf D}th day of month.\\
iff {\bf D} in [-31,..,-1], {\bf W} in [-7,..,-1] 

\item exact {\bf D}th day of month {\bf M}.\\
iff {\bf D} in [1,..,31], {\bf W}=0;

\end{itemize}
The parameters {\bf M} is a month number between 1 and 12, and {\bf T} is a time 
to the minute detail just like the time offset of the timezone.

Other values of the rule parameters on creating a timezone will produce a 
nil-timezone.

@mal
atom tzone :lng;
command fromstr():tzone 
address tzone_fromstr;
command tostr():str   
address tzone_tostr;
command str():str   
address MTIMEtzone_tostr;
#.NULL	 address tzone_null;
command timestamp(secs:int):timestamp
address MTIMEtimestamp
comment "Utility function to create a timestamp from a number of seconds since the Unix epoch";


atom rule :int;
command fromstr():rule 
address rule_fromstr;
command tostr():str 
address rule_tostr;
command define(m:int,d:int,w:int,h:int,min:int):rule 
address MTIMEruleDef0
comment "Introduce a synomym timezone rule.";
command define(m:int,d:str,w:int,h:int,min:int):rule 
address MTIMEruleDef1
comment "Introduce a synomym timezone rule.";
command define(m:int,d:str,w:int,min:int):rule 
address MTIMEruleDef2
comment "Introduce a synomym timezone rule.";


module mtime;
command date_sub_sec_interval(t:date,s:int):date 
address MTIMEdate_sub_sec_interval_wrap
comment "Subtract seconds from a date";
command date_add_sec_interval(t:date,s:int):date 
address MTIMEdate_add_sec_interval_wrap
comment "Add seconds to a date";
command date_add_month_interval(t:date,s:int):date 
address MTIMEdate_add_month_interval_wrap
comment "Add months to a date";

#command int(d:date):int = MTIMEdate_2int;
#command int(d:daytime):int = MTIMEdaytime_2int;
#command lng(d:timestamp):int = MTIMEtimestamp_2lng;
#command lng(d:tzone):lng = MTIMEtzone_2lng;
#command int(d:rule):int = MTIMErule_2int;

command date(:date):date
address MTIMEdate2date
comment "generate the nil date";
command date(:void):date
address MTIMEnil2date
comment "generate the nil date";

command tzone_local(t:tzone):void 
address MTIMEtzone_set_local 
comment "set the local tzone; which is used for printing timestamps";
command tzone_local() :tzone 
address MTIMEtzone_get_local 
comment "get the local tzone; which is used for printing timestamps";

@+ Time/date construction
Construct temporal values from simple(r) parameters.
Out-of range result values are represented by the nil.
@mal
command date(s:str):date 
address MTIMEdate_fromstr
comment "convert the string to a type date value";

command date(yr:int, mo:int, day:int):date 
address MTIMEdate_create 
comment "creates a date from (year,month,day).";

command daytime(s:str):daytime
address MTIMEdaytime_fromstr
comment "convert the string to a daytime value.";

command daytime(h:int,m:int,s:int,mi:int)
		:daytime 
address MTIMEdaytime_create 
comment "creates a time from (hours,minutes,
	seconds,milliseconds) parameters.";
command timestamp(d:date,dt:daytime,t:tzone) :timestamp 
address MTIMEtimestamp_create 
comment "creates a timestamp from (date, daytime,tzone) parameters.";
command timestamp(d:date,dt:daytime) :timestamp 
address MTIMEtimestamp_create_default 
comment "creates a timestamp from (d,dt) parameters (in the local timezone).";

command rule(s:str):rule
address MTIMErule_fromstr
comment "create a rule from a  string.";
command rule (mo:int,d:int,wkday:int,mi:int) :rule 
address MTIMErule_create 
comment "create a DST start/end date rule.";

command tzone(s:str):tzone 
address MTIMEtzone_fromstr
comment "Convert the string to a tzone.";
command tzone(s:int):tzone 
address MTIMEtzone_create
comment "Convert the int to a tzone.";
command tzone(s:lng):tzone 
address MTIMEtzone_create
comment "Convert the int to a tzone.";
command tzone(mi:int,s:rule,erule:rule):tzone 
address MTIMEtzone_create_dst 
comment "create a tzone as an hour difference 
	from GMT and a DST.";

@- Time/date decomposition
@T
There are routines that decompose a date and routines that decompose a daytime.
For decomposing a timestamp, there are routines that decompose it in a date 
and daytime. The bulk variants are also provided to simplify code
generation for SQL and to improve speed.
@mal
# date
command year(d:date) :int 
address MTIMEdate_extract_year 
comment "extracts year from date (nonzero 
	value between -5867411 and +5867411).";
command year(d:bat[:any$1,:date]):bat[:any$1,:int]
address MTIMEdate_extract_year_bulk;

command month(d:date) :int 
address MTIMEdate_extract_month 
comment "extracts month from date";
command month(d:bat[:any$1,:date]):bat[:any$1,:int]
address MTIMEdate_extract_month_bulk;

command day(d:date) :int 
address MTIMEdate_extract_day 
comment "extracts day from date ";
command day(d:bat[:any$1,:date]):bat[:any$1,:int]
address MTIMEdate_extract_day_bulk;

# daytime
command hours(h:daytime) :int 
address MTIMEdaytime_extract_hours 
comment "extracts hour from daytime";
command hours(d:bat[:any$1,:date]):bat[:any$1,:int]
address MTIMEdaytime_extract_hours_bulk;

command minutes(d:daytime) :int 
address MTIMEdaytime_extract_minutes 
comment "extracts minutes from daytime";
command minutes(d:bat[:any$1,:date]):bat[:any$1,:int]
address MTIMEdaytime_extract_minutes_bulk;

command seconds(d:daytime) :int 
address MTIMEdaytime_extract_seconds 
comment "extracts seconds from daytime";
command seconds(d:bat[:any$1,:date]):bat[:any$1,:int]
address MTIMEdaytime_extract_seconds_bulk;

command milliseconds(d:daytime) :int 
address MTIMEdaytime_extract_milliseconds 
comment "extracts milliseconds from daytime";
command milliseconds(d:bat[:any$1,:date]):bat[:any$1,:int]
address MTIMEdaytime_extract_milliseconds_bulk;

# timestamp
command daytime(t:timestamp) :daytime 
address MTIMEtimestamp_extract_daytime_default 
comment "extracts daytime from timestamp 
	in the local timezone.";
command daytime(t:timestamp, v:tzone) :daytime 
address MTIMEtimestamp_extract_daytime 
comment "extracts daytime from timestamp 
	in a specific tzone.";

command date(t:timestamp) :date 
address MTIMEtimestamp_extract_date_default 
comment "extracts date from timestamp 
	in the local timezone.";
command date(t:timestamp,v:tzone) :date 
address MTIMEtimestamp_extract_date 
comment "extracts date from timestamp in a 
	specific timezone.";

# tzone
command timezone(name:str):tzone 
address MTIMEtimezone
comment "Test and set the timezone.";

command start_dst(t:tzone) :rule 
address MTIMEtzone_extract_start 
comment "extract rule that determines 
	start of DST from tzone.";
command end_dst(t:tzone) :rule 
address MTIMEtzone_extract_end 
comment "extract rule that determines 
	end of DST from tzone.";
command minutes(t:tzone) :int 
address MTIMEtzone_extract_minutes 
comment "extract number of minutes that 
	time zone is offset wrt GMT.";

# rule
command month(t:rule) :int 
address MTIMErule_extract_month 
comment "extract month from rule.";
command day(t:rule) :int 
address MTIMErule_extract_day 
comment "extract day from rule.";
command weekday(t:rule) :int 
address MTIMErule_extract_weekday 
comment "extract weekday from rule.";
command minutes(t:rule) :int 
address MTIMErule_extract_minutes 
comment "extract minutes from rule.";

@+ Time/date arithmetic
@T
We choose to represent intervals of time as numbers of days (as int, a 32-bits integer)
and numbers of milliseconds (as lng, a 64-bits integer). Using standard integer types
facilitates computation with these amounts of time (you can use all normal integer 
arithmetic operators).

Arithmetic overflow returns the nil atom (no error messages). For all commands in 
this modules it holds that if one of the parameters is nil, the result is also nil 
(nil has the don't know semantics in MIL). 
@mal
command addyears(value:date, years:int) :date 
address MTIMEdate_addyears 
comment "returns the date after a number 
	of years (possibly negative).";
command addmonths(value:date, months:int) :date 
address MTIMEdate_addmonths 
comment "returns the date after a number of 
	months (possibly negative).";
command adddays(value:date, days:int) :date 
address MTIMEdate_adddays 
comment "returns the date after a number 
	of days (possibly negative).";
command diff(val1:date, val2:date) :int 
address MTIMEdate_diff 
comment "returns the number of days 
	between 'val1' and 'val2'.";

command dayofyear(d:date) :int 
address MTIMEdate_extract_dayofyear 
comment "Returns N where d is the Nth day 
	of the year (january 1 returns 1)";
command weekofyear(d:date) :int 
address MTIMEdate_extract_weekofyear 
comment "Returns the week number in the year.";
command dayofweek(d:date) :int 
address MTIMEdate_extract_dayofweek 
comment "Returns the current day of the week 
	where 1=sunday, .., 7=saturday";

command add(v:timestamp, msecs:lng) :timestamp 
address MTIMEtimestamp_add 
comment "returns the timestamp that comes 'msecs' 
	(possibly negative) after 'value'.";
command diff(val1:timestamp, val2:timestamp) :lng 
address MTIMEtimestamp_diff 
comment "returns the number of milliseconds 
	between 'val1' and 'val2'.";

command dst(t:timestamp,v:tzone) :bit 
address MTIMEtimestamp_inside_dst 
comment "return whether DST holds in the 
	timezone at a certain point of time.";

command compute(r:rule, year:int) :date 
address MTIMEcompute_rule_foryear 
comment "compute the date from a rule in a given year";

@- Day and month names
One day we should introduce the concept of locale, and hook here.
@mal
command monthnum(month:str) :int 
address MTIMEmonth_from_str 
comment "Returns month number [1-12] from a string
	 or nil if does not match any.";
command monthname(month:int) :str 
address MTIMEmonth_to_str 
comment "Returns month name from a number 
	between [1-12], str(nil) otherwise.";
command daynum(day:str) :int 
address MTIMEday_from_str 
comment "Returns number of day [1-7] from a 
	string or nil if does not match any.";
command dayname(day:int) :str 
address MTIMEday_to_str 
comment "Returns day name from a number 
	between [1-7], str(nil) otherwise.";

command time_synonyms(allow:bit) 
address MTIMEsynonyms 
comment "Allow synonyms for the parse format of 
	date/timestamp.";

command olddate (format:str) :date 
address MTIMEolddate 
comment "create a date from the old instant 
	format.";
command oldduration(format:str) :int 
address MTIMEoldduration 
comment "parse the old duration format and 
	return an (estimated) number of days.";

@+ Utilities
The Monet V4 procs are converted into functions.
@mal

command msecs(d:int,h:int,m:int,s:int,ms:int):lng
address MTIMEmsecs
comment "convert date components to milliseconds";

command daytime(h:int):daytime 
address MTIMEdaytime1
comment "default time with zeroed components";
command daytime(h:int,m:int):daytime 
address MTIMEdaytime2
comment "default time with zeroed components";
command daytime(h:int,m:int,s:int):daytime 
address MTIMEdaytime3
comment "default time with zeroed components";

#SQL utility functions
command current_timestamp():timestamp
address MTIMEcurrent_timestamp;
command current_date():date
address MTIMEcurrent_date;
command current_time():daytime
address MTIMEcurrent_time;

@{
@+ Prelude section
Upon intialization of the time module, we have to
initialize some variables, e.g. nils and the box with predefined
constants.
These actions are captured in a single function activated directly after
parsing of the signatures. 
@mal
command prelude()
address MTIMEprelude;

mtime.prelude();

@+ Test Script

The below tests try to be exhaustive in trying all time functionality.
@mil
module(monettime,alarm);

# test the various ways to create rules
var rule_jan := rule("1st MON from start of JAN@01:15");
var rule_mar := rule("first WEDNE on or after march 10@01:15");
var rule_apr := rule("last THU on or before aPr 1@01:15");
var rule_may := rule("MAY 26@01:15");
var rule_jun := rule("2nd TUE from end of june@01:15");
var rule_jul := rule(7,1,1,75);
var rule_aug := rule(8,-1,1,75);
var rule_sep := rule(9,-10,3,75);
var rule_oct := rule(10,31,0,75);
var rule_nov := rule(11,-10,-4,75);
# nil rules
var rule_dec := rule(12,-31,0,75);
var rule_feb := rule("first fRiDaY on or after february 30@01:15");
 
var rule_bat := new(str,rule,10);
rule_bat.insert("jan",rule_jan).insert("feb",rule_feb).insert("mar",rule_mar).insert("apr",rule_apr);
rule_bat.insert("may",rule_may).insert("jun",rule_jun).insert("jul",rule_jul).insert("aug",rule_aug);
rule_bat.insert("sep",rule_sep).insert("oct",rule_oct).insert("nov",rule_nov).insert("dec",rule_dec);

# test the operations on rules
print(rule_bat.col_name("rule"),
      [month](rule_bat).col_name("month"),
      [weekday](rule_bat).col_name("weekday"),
      [day](rule_bat).col_name("day"),
      [minutes](rule_bat).col_name("minutes"));

print(rule_bat.col_name("rule"),
      [compute](rule_bat, 2001).col_name("2001"),
      [dayname]([dayofweek]([compute](rule_bat, 2001))).col_name("2001"),
      [compute](rule_bat, 1999).col_name("1999"),
      [dayname]([dayofweek]([compute](rule_bat, 1999))).col_name("1999"),
      [compute](rule_bat, 1992).col_name("1992"),
      [dayname]([dayofweek]([compute](rule_bat, 1992))).col_name("1992"));

print(rule_bat.col_name("rule"),
      [compute](rule_bat, 1572).col_name("1572"),
      [dayname]([dayofweek]([compute](rule_bat, 1572))).col_name("1572"),
      [compute](rule_bat, 1).col_name("1"),
      [dayname]([dayofweek]([compute](rule_bat, 1))).col_name("1"),
      [compute](rule_bat, -2000).col_name("-2000"),
      [dayname]([dayofweek]([compute](rule_bat, -2000))).col_name("-2000"));

@- tzone
@mil
# test the various ways to create tzones, using some of the above created rules
var tzone_00 := tzone("GMT");
var tzone_01 := tzone("GMT+01:00");
var tzone_02 := tzone("GMT+0100");
var tzone_03 := tzone(60, rule_oct, rule_mar);
var tzone_04 := tzone(0, rule_jan, rule_aug);
var tzone_05 := tzone(-97, rule_oct, rule_apr);
var tzone_06 := tzone(-97, rule_may, rule_sep);
var tzone_07 := tzone(23*60, rule_apr, rule_nov);
var tzone_08 := tzone((-23*59) - 59);
var tzone_09 := tzone(0);
var tzone_10 := tzone(-60);
var tzone_11 := tzone((23*60)+59);
var tzone_12 := tzone(60);
# nil tzones
var tzone_13 := tzone(60, rule_feb, rule_dec);
var tzone_15 := tzone(24*60, rule_apr, rule_nov);


var tzone_bat := new(oid,tzone);
tzone_bat.insert(00@0, tzone_00).insert(01@0, tzone_01).insert(02@0, tzone_02);
tzone_bat.insert(03@0, tzone_03).insert(04@0, tzone_04).insert(05@0, tzone_05);
tzone_bat.insert(06@0, tzone_06).insert(07@0, tzone_07).insert(08@0, tzone_08);
tzone_bat.insert(09@0, tzone_09).insert(10@0, tzone_10).insert(11@0, tzone_11);
tzone_bat.insert(12@0, tzone_12).insert(13@0, tzone_13).insert(15@0, tzone_15);

# test the operations on tzones
print(tzone_bat.col_name("tzone"));
print([minutes](tzone_bat).col_name("minutes"),
      [start_dst](tzone_bat).col_name("start_dst"),
      [end_dst](tzone_bat).col_name("end_dst"));

@- date
@mil
# test the various ways to create dates
var date_00 := date(2000,01,01);
var date_01 := date("5000-JAN-01");
var date_02 := date("1968-FEBR-29");
var date_03 := date("1-MARCH-01");
var date_04 := date("-5867411-JAN-1");
var date_05 := date("-768/octobe/01");
var date_06 := date("5000\\novembe\\01");
var date_07 := date("-1999/jun/01");
var date_08 := date("2000-jul-14");
var date_09 := date("1999-sept-01");
var date_10 := date("1998-decemBeR-01");
var date_11 := date("1953 may                01");
var date_12 := date("5867411-DEC-31");
# nil dates
var date_13 := date(1996,13,1);
var date_14 := date("999999999999999999999-01-01");
var date_15 := date("1999-JANUARI-01");
var date_16 := date("1999-FEBR-29");
var date_17 := date("-1-DECEMBER-0");
var date_18 := date("5000\novembe\31");
var date_19 := date("nil");
var date_20 := date("1999-sept-31");

var date_bat := new(oid,date);
date_bat.insert(00@0, date_00).insert(01@0, date_01).insert(02@0, date_02);
date_bat.insert(03@0, date_03).insert(04@0, date_04).insert(05@0, date_05);
date_bat.insert(06@0, date_06).insert(07@0, date_07).insert(08@0, date_08);
date_bat.insert(09@0, date_09).insert(10@0, date_10).insert(11@0, date_11);
date_bat.insert(12@0, date_12).insert(13@0, date_13).insert(14@0, date_14);
date_bat.insert(15@0, date_15).insert(16@0, date_16).insert(17@0, date_17);
date_bat.insert(18@0, date_18).insert(19@0, date_19).insert(20@0, date_20);

# test the operations on dates
print(date_bat.col_name("date"),
      [year](date_bat).col_name("year"),
      [day](date_bat).col_name("day"),
      [monthname]([month](date_bat)).col_name("monthname"),
      [monthnum]([monthname]([month](date_bat))).col_name("monthnum"));

var date_addyears := [addyears](date_bat, -100);
var date_addmonths := [addmonths](date_bat, 1);

print(date_bat.col_name("date"),
      date_addyears.col_name("min100y"),
      [diff](date_addyears, date_bat).col_name("diff"));

print(date_bat.col_name("date"),
      date_addmonths.col_name("plus1m"),
      [diff](date_addmonths, date_bat).col_name("diff"));

# test dayofweek and weeknumber using more than two years as consecutive days
var date_seq := new(int, date);
var i := -375;
while ((i :+= 1) < 375) {
	date_seq.insert(i,adddays(date_00,i));
}
print(date_seq.col_name("date"),
      [weekofyear](date_seq).col_name("weekofyear"),
      [dayname]([dayofweek](date_seq)).col_name("dayofweek"),
      [daynum]([dayname]([dayofweek](date_seq))).col_name("num"),
      [dayofyear](date_seq).col_name("dayofyear"));

@- daytime
@mil
# test the various ways top create daytimes
var daytime_00 := daytime(23,59,59,999);
var daytime_01 := daytime("23:59");
var daytime_02 := daytime("00:00");
var daytime_03 := daytime("23:59:59");
var daytime_04 := daytime("00:00:00.000");
var daytime_05 := daytime("00:00:00");
var daytime_06 := daytime("00:00:00:001");
var daytime_07 := daytime("03:49:02.999");
var daytime_08 := daytime("20:48:42:999");
var daytime_09 := daytime("17:53:38:999");
var daytime_10 := daytime("13:15:34:999");
var daytime_11 := daytime("07:34:27.999");
var daytime_12 := daytime("23:59:59:999");
var daytime_13 := daytime("01:00:03.999");
var daytime_14 := daytime("23:59:59.999");
# nil daytimes
var daytime_15 := daytime(24,59,59,999);
var daytime_16 := daytime(23,60,59,999);
var daytime_17 := daytime(23,59,60,999);
var daytime_18 := daytime(23,59,60,1000);
var daytime_19 := daytime("nil");

var daytime_bat := new(oid,daytime);
daytime_bat.insert(00@0, daytime_00).insert(01@0, daytime_01).insert(02@0, daytime_02);
daytime_bat.insert(03@0, daytime_03).insert(04@0, daytime_04).insert(05@0, daytime_05);
daytime_bat.insert(06@0, daytime_06).insert(07@0, daytime_07).insert(08@0, daytime_08);
daytime_bat.insert(09@0, daytime_09).insert(10@0, daytime_10).insert(11@0, daytime_11);
daytime_bat.insert(12@0, daytime_12).insert(13@0, daytime_13).insert(14@0, daytime_14);
daytime_bat.insert(15@0, daytime_15).insert(16@0, daytime_16).insert(17@0, daytime_17);
daytime_bat.insert(18@0, daytime_18).insert(19@0, daytime_19);

print(daytime_bat.col_name("daytime"),
      [hours](daytime_bat).col_name("hours"),
      [minutes](daytime_bat).col_name("minutes"),
      [seconds](daytime_bat).col_name("seconds"),
      [milliseconds](daytime_bat).col_name("milliseconds"));

@- timestamp
@* Implementation

@+ Atoms

@- date
Internally, we store date as the (possibly negative) number of
days since the start of the calendar. Oddly, since I (later) learned
that the year 0 did no exist, this defines the start of the calendar to
be Jan 1 of the year -1 (in other words, a -- positive -- year component
of a date is equal to the number of years that have passed since the start
of the calendar).
@h
#ifndef _MONETTIME_H_
#define _MONETTIME_H_

#include <gdk.h>
#include <mal.h>

#if TIME_WITH_SYS_TIME
# include <sys/time.h>
# include <time.h>
#else
# if HAVE_SYS_TIME_H
#  include <sys/time.h>
# else
#  include <time.h>
# endif
#endif

typedef int date;
#define date_nil ((date) int_nil)
@c
#include "mtime.h"

@- daytime
Daytime values are also stored as the number of milliseconds that passed since
the start of the day (i.e. midnight).
@h
typedef int daytime;

#define daytime_nil ((daytime) int_nil)

@- timestamp
Timestamp is implemented as a record that contains a date and a time (GMT).
@h
typedef struct {
#ifndef WORDS_BIGENDIAN
	daytime msecs;
	date days;
#else
	date days;
	daytime msecs;
#endif
} timestamp;

@- rule
rules are used to define the start and end of DST. It uses the 25 lower bits of an int.
@h
typedef union {
	struct {
		unsigned int month:4,	/* values: [1..12] */
		 minutes:11,	/* values: [0:1439] */
		 day:6,		/* values: [-31..-1,1..31] */
		 weekday:4,	/* values: [-7..-1,1..7] */
		 empty:7;	/* rule uses just 32-7=25 bits */
	} s;
	int asint;		/* the same, seen as single value */
} rule;

@c
#define get_rule(r)	((r).s.weekday | ((r).s.day<<6) | ((r).s.minutes<<10) | ((r).s.month<<21))
#define set_rule(r,i) { (r).s.weekday = (i)&15;\
			(r).s.day = ((i)&(63<<6))>>6;\
			(r).s.minutes = ((i)&(2047<<10))>>10;\
			(r).s.month = ((i)&(15<<21))>>21; }

/* phony zero values, used to get negative numbers from unsigned sub-integers in rule */
#define WEEKDAY_ZERO	8
#define DAY_ZERO	32
#define OFFSET_ZERO	4096

@- tzone
A tzone consists of an offset and two DST rules, all crammed into one lng.
@h
typedef struct {
	/* we had this as bitfields in one unsigned long long, but native sun CC does not eat that.  */
	unsigned int dst:1, off1:6, dst_start:25;
	unsigned int off2:7, dst_end:25;
} tzone;

@c
/* as the offset field got split in two, we need macros to get and set them */
#define get_offset(z)	(((int) (((z)->off1 << 7) + (z)->off2)) - OFFSET_ZERO)
#define set_offset(z,i)	{ (z)->off1 = (((i)+4096)&8064) >> 7; (z)->off2 = ((i)+OFFSET_ZERO)&127; }

@h
mal_export tzone tzone_local;


mal_export void fromdate(int n, int *d, int *m, int *y);
mal_export void fromtime(int n, int *hour, int *min, int *sec, int *msec);
mal_export int daytime_tz_fromstr(str buf, int *len, daytime **ret);
mal_export str MTIMEcurrent_timestamp(timestamp *t);
mal_export str MTIMEcurrent_date(date *d);
mal_export str MTIMEcurrent_time(daytime *t);
mal_export int timestamp_tostr(str *buf, int *len, timestamp *val);
mal_export int timestamp_diff(lng *ret, timestamp *v1, timestamp *v2);
mal_export str MTIMEnil2date(date *ret, int *src);
mal_export str MTIMEdate2date(date *ret, date *src);
mal_export str MTIMErule_fromstr(rule *ret, str *s);
mal_export str MTIMEprelude();
mal_export str time_epilogue(void);
mal_export str MTIMEsynonyms(bit *allow);
mal_export str MTIMEoldduration(int *ndays, str *s);
mal_export str MTIMEolddate(date *d, str *buf);
mal_export str MTIMEtimezone(tzone *z, str *name);
mal_export str MTIMEtzone_set_local(int res, tzone *z);
mal_export str MTIMEtzone_get_local(tzone *z);
mal_export str MTIMEmonth_from_str(int *ret, str *month);
mal_export str MTIMEmonth_to_str(str *ret, int *month);
mal_export str MTIMEday_from_str(int *ret, str *day);
mal_export str MTIMEday_to_str(str *ret, int *day);
mal_export str MTIMEdate_tostr(str *ret, date *d);
mal_export str MTIMEdate_fromstr(date *ret, str *s);
mal_export str MTIMEdate_create(date *ret, int *year, int *month, int *day);
mal_export str MTIMEdaytime_tostr(str *ret, daytime *d);
mal_export str MTIMEdaytime_create(daytime *ret, int *hour, int *min, int *sec, int *msec);
mal_export str MTIMEtimestamp_fromstr(timestamp *ret, str *d);
mal_export str MTIMEtimestamp_create(timestamp *ret, date *d, daytime *t, tzone *z);
mal_export str MTIMEtimestamp_create_default(timestamp *ret, date *d, daytime *t);
mal_export str MTIMEdate_extract_year(int *ret, date *v);
mal_export str MTIMEdate_extract_month(int *ret, date *v);
mal_export str MTIMEdate_extract_day(int *ret, date *v);
mal_export str MTIMEdate_extract_dayofyear(int *ret, date *v);
mal_export str MTIMEdate_extract_weekofyear(int *ret, date *v);
mal_export str MTIMEdate_extract_dayofweek(int *ret, date *v);
mal_export str MTIMEdaytime_extract_hours(int *ret, daytime *v);
mal_export str MTIMEdaytime_extract_minutes(int *ret, daytime *v);
mal_export str MTIMEdaytime_extract_seconds(int *ret, daytime *v);
mal_export str MTIMEdaytime_extract_milliseconds(int *ret, daytime *v);
mal_export str MTIMEtimestamp_extract_daytime(daytime *ret, timestamp *t, tzone *z);
mal_export str MTIMEtimestamp_extract_daytime_default(daytime *ret, timestamp *t);
mal_export str MTIMEtimestamp_extract_date(date *ret, timestamp *t, tzone *z);
mal_export str MTIMEtimestamp_extract_date_default(date *ret, timestamp *t);
mal_export str MTIMEdate_addyears(date *ret, date *v, int *delta);
mal_export str MTIMEdate_adddays(date *ret, date *v, int *delta);
mal_export str MTIMEdate_addmonths(date *ret, date *v, int *delta);
mal_export str MTIMEdate_diff(int *ret, date *v1, date *v2);
mal_export str MTIMEtimestamp_add(timestamp *ret, timestamp *v, lng *msecs);
mal_export str MTIMEtimestamp_diff(lng *ret, timestamp *v1, timestamp *v2);
mal_export str MTIMEtimestamp_inside_dst(bit *ret, timestamp *p, tzone *z);
mal_export str MTIMEtimestamp_isnil(bit *retval, timestamp *val);
mal_export str MTIMEtimestamp_EQ(bit *retval, timestamp *val1, timestamp *val2);
mal_export str MTIMEtimestamp_NEQ(bit *retval, timestamp *val1, timestamp *val2);
mal_export str MTIMEtimestamp_LT(bit *retval, timestamp *val1, timestamp *val2);
mal_export str MTIMEtimestamp_LE(bit *retval, timestamp *val1, timestamp *val2);
mal_export str MTIMEtimestamp_GT(bit *retval, timestamp *val1, timestamp *val2);
mal_export str MTIMEtimestamp_GE(bit *retval, timestamp *val1, timestamp *val2);
mal_export str MTIMErule_tostr(str *s, rule *r);
mal_export str MTIMErule_fromstr(rule *ret, str *s);
mal_export str MTIMErule_create(rule *ret, int *month, int *day, int *weekday, int *minutes);
mal_export str MTIMEtzone_create_dst(tzone *ret, int *minutes, rule *start, rule *end);
mal_export str MTIMEtzone_create(tzone *ret, int *minutes);
mal_export str MTIMErule_extract_month(int *ret, rule *r);
mal_export str MTIMErule_extract_day(int *ret, rule *r);
mal_export str MTIMErule_extract_weekday(int *ret, rule *r);
mal_export str MTIMErule_extract_minutes(int *ret, rule *r);
mal_export str MTIMEtzone_extract_start(rule *ret, tzone *t);
mal_export str MTIMEtzone_extract_end(rule *ret, tzone *t);
mal_export str MTIMEtzone_extract_minutes(int *ret, tzone *t);
mal_export str MTIMEdate_sub_sec_interval_wrap(date *ret, date *t, int *sec);
mal_export str MTIMEdate_add_sec_interval_wrap(date *ret, date *t, int *sec);
mal_export str MTIMEdate_add_month_interval_wrap(date *ret, date *t, int *months);
mal_export str MTIMEcompute_rule_foryear(date *ret, rule *val, int *year);
mal_export str MTIMEtzone_tostr(str *s, tzone *ret);
mal_export str MTIMEtzone_fromstr(tzone *ret, str *s);
mal_export str MTIMEdaytime_fromstr(daytime *ret, str *s);
mal_export str MTIMEmsecs(lng *ret, int *d, int *h, int *m, int *s, int *ms);
mal_export str MTIMEdaytime1(daytime *ret, int *h);
mal_export str MTIMEdaytime2(daytime *ret, int *h, int *m);
mal_export str MTIMEdaytime3(daytime *ret, int *h, int *m, int *s);
mal_export str MTIMEunix_epoch(timestamp *ret);
mal_export str MTIMEepoch(timestamp *ret);
mal_export str MTIMEepoch2lng(lng *ret, timestamp *t);
mal_export str MTIMEtimestamp(timestamp *ret, int *sec);
mal_export str MTIMEruleDef0(rule *ret, int *m, int *d, int *w, int *h, int *mint);
mal_export str MTIMEruleDef1(rule *ret, int *m, str *dnme, int *w, int *h, int *mint);
mal_export str MTIMEruleDef2(rule *ret, int *m, str *dnme, int *w, int *mint);
mal_export str MTIMEcurrent_timestamp(timestamp *t);
mal_export str MTIMEcurrent_date(date *d);
mal_export str MTIMEcurrent_time(daytime *t);
mal_export int date_fromstr(str buf, int *len, date **d);
mal_export int date_tostr(str *buf, int *len, date *val);
mal_export int daytime_fromstr(str buf, int *len, daytime **ret);
mal_export int daytime_tostr(str *buf, int *len, daytime *val);
mal_export int timestamp_fromstr(str buf, int *len, timestamp **ret);
mal_export int timestamp_tostr(str *buf, int *len, timestamp *val);
mal_export int tzone_fromstr(str buf, int *len, tzone **d);
mal_export int tzone_tostr(str *buf, int *len, tzone *z);
mal_export int rule_fromstr(str buf, int *len, rule **d);
mal_export int tzone_fromstr(str buf, int *len, tzone **d);

#endif /* _MONETTIME_H_ */
@+ Defines
@c
tzone tzone_local;

str MONTHS[13] = { NULL, "january", "february", "march", "april", "may", "june",
	"july", "august", "september", "october", "november", "december"
};
str DAYS[8] = { NULL, "sunday", "monday", "tuesday", "wednesday", "thursday",
	"friday", "saturday"
};
str COUNT1[7] = { NULL, "first", "second", "third", "fourth", "fifth", "last" };
str COUNT2[7] = { NULL, "1st", "2nd", "3rd", "4th", "5th", "last" };
int NODAYS[13] = { 0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };

date DATE_MAX, DATE_MIN;	/* often used dates; computed once */

#define YEAR_MAX	5867411
#define YEAR_MIN	-YEAR_MAX
#define MONTHDAYS(m,y)	(((m)!=2)?NODAYS[m]:leapyear(y)?29:28)
#define YEARDAYS(y)	(leapyear(y)?366:365)
#define LEAPYEARS(y)	(leapyears(y)+((y)>=0))
#define DATE(d,m,y)	((m)>0&&(m)<=12&&(d)>0&&(y)!=0&&(y)>=YEAR_MIN&&(y)<=YEAR_MAX&&(d)<=MONTHDAYS(m,y))
#define TIME(h,m,s,x)	((h)>=0&&(h)<24&&(m)>=0&&(m)<60&&(s)>=0&&(s)<60&&(x)>=0 &&(x)<1000)
#define LOWER(c)	(((c) >= 'A' && (c) <= 'Z') ? (c)+'a'-'A' : (c))

@+ auxiliary functions
@c

#define tz_isnil(z)   (get_offset(&(z)) == get_offset(tz_nilptr))
#define ts_isnil(t)   ((t).days == ts_nilptr->days && (t).msecs == ts_nilptr->msecs)

static union {
	timestamp ts;
	lng nilval;
} ts_nil;
static union {
	tzone tz;
	lng nilval;
} tz_nil;
static timestamp *ts_nilptr = NULL;
static tzone *tz_nilptr = NULL;

static void date_prelude(void);

bat *
monettime_prelude(void)
{
	ts_nil.nilval = lng_nil;
	tz_nil.nilval = lng_nil;

	ts_nilptr = &ts_nil.ts;
	tz_nilptr = &tz_nil.tz;

	date_prelude();
	return NULL;
}

void
monettime_epilogue(void)
{
}

timestamp *
timestamp_null(void)
{
	return (ts_nilptr);
}

tzone *
tzone_null(void)
{
	return (tz_nilptr);
}

static int synonyms = TRUE;

int
monettime_synonyms(bit *allow)
{
	if (*allow != bit_nil)
		synonyms = *allow;
	return GDK_SUCCEED;
}

static INLINE int
leapyear(int year)
{
	return year % 4 == 0 && (year % 100 != 0 || year % 400 == 0);
}

static INLINE int
leapyears(int year)
{
	/* count the 4-fold years that passed since jan-1-0 */
	int y4 = year / 4;

	/* count the 100-fold years */
	int y100 = year / 100;

	/* count the 400-fold years */
	int y400 = year / 400;

	return y4 + y400 - y100;	/* may be negative */
}

static INLINE date
todate(int day, int month, int year)
{
	date n = date_nil;

	if (DATE(day, month, year)) {
		if (year < 0)
			year++;	/* HACK: hide year 0 */
		for (n = (date) (day - 1); --month > 0; n += MONTHDAYS(month, year))
			;
		/* current year does not count as leapyear */
		n += 365 * year + LEAPYEARS(year >= 0 ? year - 1 : year);
	}
	return n;
}

void
fromdate(int n, int *d, int *m, int *y)
{
	int month, year = n / 365;
	int day = (n - year * 365) - LEAPYEARS(year >= 0 ? year - 1 : year);

	if (n < 0) {
		year--;
		while (day >= 0) {
			year++;
			day -= YEARDAYS(year);
		}
		day = YEARDAYS(year) + day;
	} else {
		while (day < 0) {
			year--;
			day += YEARDAYS(year);
		}
	}
	day++;
	for (month = 1; month <= 12; month++) {
		int days = MONTHDAYS(month, year);

		if (day <= days)
			break;
		day -= days;
	}
	if (n != int_nil) {
		*d = day;
		*m = month;
		*y = (year <= 0) ? year - 1 : year;	/* HACK: hide year 0 */
	} else {
		*d = *m = *y = int_nil;
	}
}

static INLINE daytime
totime(int hour, int min, int sec, int msec)
{
	if (TIME(hour, min, sec, msec)) {
		return (daytime) (((((hour * 60) + min) * 60) + sec) * 1000 + msec);
	}
	return daytime_nil;
}

void
fromtime(int n, int *hour, int *min, int *sec, int *msec)
{
	if (n != int_nil) {
		*hour = n / 3600000;
		n -= (*hour) * 3600000;
		*min = n / 60000;
		n -= (*min) * 60000;
		*sec = n / 1000;
		n -= (*sec) * 1000;
		*msec = n;
	} else {
		*hour = *min = *sec = *msec = int_nil;
	}
}

/* matches regardless of case and extra spaces */
static INLINE int
fleximatch(str s, str pat, int min)
{
	int hit, spacy = 0;

	if (min == 0) {
		min = (int) strlen(pat);	/* default mininum required hits */
	}
	for (hit = 0; *pat; s++, hit++) {
		if (LOWER(*s) != *pat) {
			if (GDKisspace(*s) && spacy) {
				min++;
				continue;	/* extra spaces */
			}
			break;
		}
		spacy = GDKisspace(*pat);
		pat++;
	}
	return (hit >= min) ? hit : 0;
}

static INLINE int
parse_substr(int *ret, str s, int min, str list[], int size)
{
	int j = 0, i = 0;

	*ret = int_nil;
	while (++i <= size) {
		if ((j = fleximatch(s, list[i], min)) > 0) {
			*ret = i;
			break;
		}
	}
	return j;
}

static INLINE int
date_dayofweek(date v)
{
	v %= 7;
	return (v <= 0) ? v + 7 : v;
}

#define SKIP_DAYS(d,w,i) d += i; w = (w + i)%7; if (w <= 0) w += 7;

static INLINE date
compute_rule(rule *val, int y)
{
	int m = val->s.month, cnt = ABS(val->s.day - DAY_ZERO);
	date d = todate(1, m, y);
	int dayofweek = date_dayofweek(d);
	int w = ABS(val->s.weekday - WEEKDAY_ZERO);

	if (val->s.weekday == WEEKDAY_ZERO) {
		/* cnt-th of month */
		d += cnt - 1;
	} else if (val->s.day > DAY_ZERO) {
		if (val->s.weekday < WEEKDAY_ZERO) {
			/* first weekday on or after cnt-th of month */
			SKIP_DAYS(d, dayofweek, cnt - 1);
			cnt = 1;
		}		/* ELSE cnt-th weekday of month */
		while (dayofweek != w || --cnt > 0) {
			if (++dayofweek == 8)
				dayofweek = 1;
			d++;
		}
	} else {
		if (val->s.weekday > WEEKDAY_ZERO) {
			/* cnt-last weekday from end of month */
			SKIP_DAYS(d, dayofweek, MONTHDAYS(m, y) - 1);
		} else {
			/* first weekday on or before cnt-th of month */
			SKIP_DAYS(d, dayofweek, cnt - 1);
			cnt = 1;
		}
		while (dayofweek != w || --cnt > 0) {
			if (--dayofweek == 0)
				dayofweek = 7;
			d--;
		}
	}
	return d;
}

static int dummy;

#define BEFORE(d1,m1,d2,m2) (d1 < d2 || (d1 == d2 && m1 <= m2))

int timestamp_add(timestamp *ret, timestamp *v, lng *msecs);
static INLINE int
timestamp_inside(timestamp *ret, timestamp *t, tzone *z, lng offset)
{
	/* starts with GMT time t, and returns whether it is in the DST for z */
	lng add = (offset != (lng) 0) ? offset : (get_offset(z)) * (lng) 60000;
	int start_days, start_msecs, end_days, end_msecs, year;
	rule start, end;

	timestamp_add(ret, t, &add);

	if (ts_isnil(*ret) || z->dst == 0) {
		return 0;
	}
	set_rule(start, z->dst_start);
	set_rule(end, z->dst_end);

	start_msecs = start.s.minutes * 60000;
	end_msecs = end.s.minutes * 60000;

	fromdate((int) ret->days, &dummy, &dummy, &year);
	start_days = compute_rule(&start, year);
	end_days = compute_rule(&end, year);

	return BEFORE(start_days, start_msecs, end_days, end_msecs) ? (BEFORE(start_days, start_msecs, ret->days, ret->msecs)
								       && BEFORE(ret->days, ret->msecs, end_days, end_msecs)) : (BEFORE(start_days, start_msecs, ret->days, ret->msecs)
																 || BEFORE(ret->days, ret->msecs, end_days, end_msecs));
}


@+ ADT implementations
@- date
@c
int
date_fromstr(str buf, int *len, date **d)
{
	int day = 0, month = int_nil, year = 0, yearneg = (buf[0] == '-'), yearlast = 0, pos = 0, sep;
	if (*len < (int) sizeof(date)) {
		if (*d)
			GDKfree(*d);
		*d = (date *) GDKmalloc(*len = sizeof(date));
	}
	**d = date_nil;
	if (yearneg == 0 && !GDKisdigit(buf[0])) {
		if (synonyms == 0)
			return 0;
		yearlast = 1;
		sep = ' ';
	} else {
		for (pos = yearneg; GDKisdigit(buf[pos]); pos++) {
			year = (buf[pos] - '0') + year * 10;
			if (year > YEAR_MAX)
				break;
		}
		sep = buf[pos++];
		if (synonyms == 0 && sep != '-') {
			return 0;
		}
		sep = LOWER(sep);
		if (sep >= 'a' && sep <= 'z') {
			sep = 0;
		} else if (sep == ' ') {
			while (buf[pos] == ' ')
				pos++;
		} else if (sep != '-' && sep != '/' && sep != '\\') {
			return 0;	/* syntax error */
		}
	}
	if (GDKisdigit(buf[pos])) {
		month = buf[pos++] - '0';
		if (GDKisdigit(buf[pos])) {
			month = (buf[pos++] - '0') + month * 10;
		}
	} else if (synonyms == 0) {
		return 0;
	} else {
		pos += parse_substr(&month, buf + pos, 3, MONTHS, 12);
	}
	if (month == int_nil || (sep && buf[pos++] != sep)) {
		return 0;	/* syntax error */
	}
	if (sep == ' ') {
		while (buf[pos] == ' ')
			pos++;
	}
	if (!GDKisdigit(buf[pos])) {
		return 0;	/* syntax error */
	}
	while (GDKisdigit(buf[pos])) {
		day = (buf[pos++] - '0') + day * 10;
		if (day > 31)
			break;
	}
	if (yearlast && buf[pos] == ',') {
		while (buf[++pos] == ' ')
			;
		if (buf[pos] == '-') {
			yearneg = 1;
			pos++;
		}
		while (GDKisdigit(buf[pos])) {
			year = (buf[pos++] - '0') + year * 10;
			if (year > YEAR_MAX)
				break;
		}
	}
	/* handle semantic error here (returns nil in that case) */
	**d = todate(day, month, yearneg ? -year : year);
	return pos;
}

int
date_tostr(str *buf, int *len, date *val)
{
	int day, month, year;

	fromdate((int) *val, &day, &month, &year);
	/* longest possible string: "-5867411-01-01" i.e. 14 chars
	   without NUL (see definition of YEAR_MIN/YEAR_MAX above) */
	if (*len < 15) {
		if (*buf)
			GDKfree(*buf);
		*buf = (str) GDKmalloc(*len = 15);
	}
	if (*val == date_nil || !DATE(day, month, year)) {
		strcpy(*buf, "nil");
		return 3;
	}
	sprintf(*buf, "%d-%02d-%02d", year, month, day);
	return (int) strlen(*buf);
}

@- daytime
@c
int
daytime_fromstr(str buf, int *len, daytime **ret)
{
	int hour, min, sec = 0, msec = 0, pos = 0;

	if (*len < (int) sizeof(daytime)) {
		if (*ret)
			GDKfree(*ret);
		*ret = (daytime *) GDKmalloc(*len = sizeof(daytime));
	}
	**ret = daytime_nil;
	if (!GDKisdigit(buf[pos])) {
		return 0;	/* syntax error */
	}
	for (hour = 0; GDKisdigit(buf[pos]); pos++) {
		if (hour <= 24)
			hour = (buf[pos] - '0') + hour * 10;
	}
	if ((buf[pos++] != ':') || !GDKisdigit(buf[pos])) {
		return 0;	/* syntax error */
	}
	for (min = 0; GDKisdigit(buf[pos]); pos++) {
		if (min <= 60)
			min = (buf[pos] - '0') + min * 10;
	}
	if ((buf[pos] == ':') && GDKisdigit(buf[pos + 1])) {
		for (pos++, sec = 0; GDKisdigit(buf[pos]); pos++) {
			if (sec <= 60)
				sec = (buf[pos] - '0') + sec * 10;
		}
		if ((buf[pos] == '.' || (synonyms && buf[pos] == ':')) && GDKisdigit(buf[pos + 1])) {
			int fac = 100;

			for (pos++, msec = 0; GDKisdigit(buf[pos]); pos++) {
				msec += (buf[pos] - '0') * fac;
				fac /= 10;
			}
		}
	}
	/* handle semantic error here (returns nil in that case) */
	**ret = totime(hour, min, sec, msec);
	return pos;
}

int
daytime_tz_fromstr(str buf, int *len, daytime **ret)
{
	str s = buf;
	int pos = daytime_fromstr(s, len, ret);
	lng val, offset = 0;
	daytime mtime = 24 * 60 * 60 * 1000;

	if (!*ret || **ret == daytime_nil)
		return pos;

	s = buf + pos;
	pos = 0;
	while (GDKisspace(*s))
		s++;
	/* incase of gmt we need to add the time zone */
	if (fleximatch(s, "gmt", 0) == 3) {
		s += 3;
	}
	if ((s[0] == '-' || s[0] == '+') && GDKisdigit(s[1]) && GDKisdigit(s[2]) && GDKisdigit(s[pos = 4]) && ((s[3] == ':' && GDKisdigit(s[5])) || GDKisdigit(s[pos = 3]))) {
		offset = (((s[1] - '0') * (lng) 10 + (s[2] - '0')) * (lng) 60 + (s[pos] - '0') * (lng) 10 + (s[pos + 1] - '0')) * (lng) 60000;
		pos++;
		if (s[0] != '-')
			offset = -offset;
		s += pos;
	} else {
		/* if no tzone is specified; work with the local */
		offset = get_offset(&tzone_local) * (lng) -60000;
	}
	val = **ret + offset;
	if (val < 0)
		val = mtime + val;
	if (val >= mtime)
		val = val - mtime;
	**ret = (daytime) val;
	return (int) (s - buf);
}

int
daytime_tostr(str *buf, int *len, daytime *val)
{
	int hour, min, sec, msec;

	fromtime((int) *val, &hour, &min, &sec, &msec);
	if (*len < 12) {
		if (*buf)
			GDKfree(*buf);
		*buf = (str) GDKmalloc(*len = 13);
	}
	if (*val == daytime_nil || !TIME(hour, min, sec, msec)) {
		strcpy(*buf, "nil");
		return 3;
	}
	sprintf(*buf, "%02d:%02d:%02d.%03d", hour, min, sec, msec);
	return 12;
}

@- timestamp
@c
int
timestamp_fromstr(str buf, int *len, timestamp **ret)
{
	str s = buf;
	int pos;
	date *d;
	daytime *t;

	if (*len < (int) sizeof(timestamp)) {
		if (*ret)
			GDKfree(*ret);
		*ret = (timestamp *) GDKmalloc(*len = sizeof(timestamp));
	}
	d = &(*ret)->days;
	t = &(*ret)->msecs;
	s += date_fromstr(buf, len, &d);
	if (s > buf && (*(s) == '@' || *s == ' ' || *s == '-')) {
		while (*(++s) == ' ')
			;
		pos = daytime_fromstr(s, len, &t);
		s = pos ? s + pos : buf;
	} else {
		(*ret)->msecs = daytime_nil;
	}
	if (s <= buf || (*ret)->days == date_nil || (*ret)->msecs == daytime_nil) {
		**ret = *ts_nilptr;
	} else {
		lng offset = 0;

		while (GDKisspace(*s))
			s++;
		/* incase of gmt we need to add the time zone */
		if (fleximatch(s, "gmt", 0) == 3) {
			s += 3;
		}
		if ((s[0] == '-' || s[0] == '+') && GDKisdigit(s[1]) && GDKisdigit(s[2]) && GDKisdigit(s[pos = 4]) && ((s[3] == ':' && GDKisdigit(s[5])) || GDKisdigit(s[pos = 3]))) {
			offset = (((s[1] - '0') * (lng) 10 + (s[2] - '0')) * (lng) 60 + (s[pos] - '0') * (lng) 10 + (s[pos + 1] - '0')) * (lng) 60000;
			pos++;
			if (s[0] != '-')
				offset = -offset;
			s += pos;
		} else {
			/* if no tzone is specified; work with the local */
			timestamp tmp = **ret;

			offset = get_offset(&tzone_local) * (lng) -60000;
			if (timestamp_inside(&tmp, &tmp, &tzone_local, (lng) -3600000)) {
				**ret = tmp;
			}
		}
		timestamp_add(*ret, *ret, &offset);
	}
	return (int) (s - buf);
}

int
timestamp_tostr(str *buf, int *len, timestamp *val)
{
	int len1, len2, big = 128, off = get_offset(&tzone_local);
	char buf1[128], buf2[128], *s, *s1 = buf1, *s2 = buf2;
	timestamp tmp = *val;

	if (!ts_isnil(tmp) && timestamp_inside(&tmp, val, &tzone_local, (lng) 0)) {
		lng add = (lng) 3600000;

		timestamp_add(&tmp, &tmp, &add);
		off += 60;
	}
	len1 = date_tostr(&s1, &big, &tmp.days);
	len2 = daytime_tostr(&s2, &big, &tmp.msecs);

	if (*len < 2 + len1 + len2) {
		if (*buf)
			GDKfree(*buf);
		*buf = (str) GDKmalloc(*len = len1 + len2 + 2);
	}
	s = *buf;
	if (ts_isnil(tmp)) {
		strcpy(s, "nil");
		return 3;
	}
	strcpy(s, buf1);
	s += len1;
	*s++ = ' ';
	strcpy(s, buf2);
	s += len2;
/* omit GMT distance in order not to cinfuse the confused user
	strcpy(s, "GMT"); s += 3;
	if (off) {
		*s++ = (off>=0)?'+':'-';
		sprintf(s, "%02d%02d", ABS(off)/60, ABS(off)%60);
		s += 4;
	}
 */
	return (int) (s - *buf);
}

str
count1(int i)
{
	static char buf[16];

	if (i <= 0) {
		return "(illegal number)";
	} else if (i < 6) {
		return COUNT1[i];
	}
	sprintf(buf, "%dth", i);
	return buf;
}

@- rule
@c
int
rule_tostr(str *buf, int *len, rule *r)
{
	int hours = r->s.minutes / 60;
	int minutes = r->s.minutes % 60;

	if (*len < 64) {
		if (*buf)
			GDKfree(*buf);
		*buf = (str) GDKmalloc(*len = 64);
	}
	if (r->asint == int_nil) {
		strcpy(*buf, "nil");
	} else if (r->s.weekday == WEEKDAY_ZERO) {
		sprintf(*buf, "%s %d\@%02d:%02d", MONTHS[r->s.month], r->s.day - DAY_ZERO, hours, minutes);
	} else if (r->s.weekday > WEEKDAY_ZERO && r->s.day > DAY_ZERO) {
		sprintf(*buf, "%s %s from start of %s\@%02d:%02d", count1(r->s.day - DAY_ZERO), DAYS[r->s.weekday - WEEKDAY_ZERO], MONTHS[r->s.month], hours, minutes);
	} else if (r->s.weekday > WEEKDAY_ZERO && r->s.day < DAY_ZERO) {
		sprintf(*buf, "%s %s from end of %s\@%02d:%02d", count1(DAY_ZERO - r->s.day), DAYS[r->s.weekday - WEEKDAY_ZERO], MONTHS[r->s.month], hours, minutes);
	} else if (r->s.day > DAY_ZERO) {
		sprintf(*buf, "first %s on or after %s %d\@%02d:%02d", DAYS[WEEKDAY_ZERO - r->s.weekday], MONTHS[r->s.month], r->s.day - DAY_ZERO, hours, minutes);
	} else {
		sprintf(*buf, "last %s on or before %s %d\@%02d:%02d", DAYS[WEEKDAY_ZERO - r->s.weekday], MONTHS[r->s.month], DAY_ZERO - r->s.day, hours, minutes);
	}
	return (int) strlen(*buf);
}

int
rule_fromstr(str buf, int *len, rule **d)
{
	int day = 0, month = 0, weekday = 0, hours = 0, minutes = 0;
	int neg_day = 0, neg_weekday = 0, pos;
	str cur = buf;

	if (*len < (int) sizeof(rule)) {
		if (*d)
			GDKfree(*d);
		*d = (rule *) GDKmalloc(*len = sizeof(rule));
	}
	(*d)->asint = int_nil;

	/* start parsing something like "first", "second", .. etc */
	pos = parse_substr(&day, cur, 0, COUNT1, 6);
	if (pos == 0) {
		pos = parse_substr(&day, cur, 0, COUNT2, 6);
	}
	if (pos && cur[pos++] == ' ') {
		/* now we must see a weekday */
		cur += pos;
		cur += parse_substr(&weekday, cur, 3, DAYS, 7);
		if (weekday == int_nil) {
			return 0;	/* syntax error */
		}
		pos = fleximatch(cur, " from start of ", 0);
		if (pos == 0) {
			pos = fleximatch(cur, " from end of ", 0);
			if (pos)
				neg_day = 1;
		}
		if (pos && day < 6) {
			/* RULE 1+2: X-th weekday from start/end of month */
			pos = parse_substr(&month, cur += pos, 3, MONTHS, 12);
		} else if (day == 1) {
			/* RULE 3: first weekday on or after-th of month */
			pos = fleximatch(cur, " on or after ", 0);
			neg_weekday = 1;
			day = int_nil;	/* re-read below */
		} else if (day == 6) {
			/* RULE 4: last weekday on or before X-th of month */
			pos = fleximatch(cur, " on or before ", 0);
			neg_weekday = neg_day = 1;
			day = int_nil;	/* re-read below */
		}
		if (pos == 0) {
			return 0;	/* syntax error */
		}
		cur += pos;
	}
	if (day == int_nil) {
		/* RULE 5:  X-th of month */
		cur += parse_substr(&month, cur, 3, MONTHS, 12);
		if (month == int_nil || *cur++ != ' ' || !GDKisdigit(*cur)) {
			return 0;	/* syntax error */
		}
		day = 0;
		while (GDKisdigit(*cur) && day < 31) {
			day = (*(cur++) - '0') + day * 10;
		}
	}

	/* parse hours:minutes */
	if (*cur++ != '\@' || !GDKisdigit(*cur)) {
		return 0;	/* syntax error */
	}
	while (GDKisdigit(*cur) && hours < 24) {
		hours = (*(cur++) - '0') + hours * 10;
	}
	if (*cur++ != ':' || !GDKisdigit(*cur)) {
		return 0;	/* syntax error */
	}
	while (GDKisdigit(*cur) && minutes < 60) {
		minutes = (*(cur++) - '0') + minutes * 10;
	}

	/* assign if semantically ok */
	if (day >= 1 && day <= NODAYS[month] && hours >= 0 && hours < 60 && minutes >= 0 && minutes < 60) {
		(*d)->s.month = month;
		(*d)->s.weekday = WEEKDAY_ZERO + (neg_weekday ? -weekday : weekday);
		(*d)->s.day = DAY_ZERO + (neg_day ? -day : day);
		(*d)->s.minutes = hours * 60 + minutes;
	}
	return (int) (cur - buf);
}

@- tzone
@c
int
tzone_fromstr(str buf, int *len, tzone **d)
{
	int hours = 0, minutes = 0, neg_offset = 0, pos = 0;
	rule r1, *rp1 = &r1, r2, *rp2 = &r2;
	str cur = buf;

	rp1->asint = rp2->asint = 0;
	if (*len < (int) sizeof(tzone)) {
		if (*d)
			GDKfree(*d);
		*d = (tzone *) GDKmalloc(*len = sizeof(tzone));
	}
	**d = *tz_nilptr;

	/* syntax checks */
	if (fleximatch(cur, "gmt", 0) == 0) {
		return 0;	/* syntax error */
	}
	cur += 3;
	if (*cur == '-' || *cur == '+') {
		str bak = cur + 1;

		neg_offset = (*cur++ == '-');
		if (!GDKisdigit(*cur)) {
			return 0;	/* syntax error */
		}
		while (GDKisdigit(*cur) && hours < 9999) {
			hours = (*(cur++) - '0') + hours * 10;
		}
		if (*cur == ':' && GDKisdigit(cur[1])) {
			cur++;
			do {
				minutes = (*(cur++) - '0') + minutes * 10;
			} while (GDKisdigit(*cur) && minutes < 60);
		} else if (*cur != ':' && (cur - bak) == 4) {
			minutes = hours % 100;
			hours = hours / 100;
		} else {
			return 0;	/* syntax error */
		}
	}
	if (fleximatch(cur, "-dst[", 0)) {
		pos = rule_fromstr(cur += 5, len, &rp1);
		if (pos == 0 || cur[pos++] != ',') {
			return 0;	/* syntax error */
		}
		pos = rule_fromstr(cur += pos, len, &rp2);
		if (pos == 0 || cur[pos++] != ']') {
			return 0;	/* syntax error */
		}
		cur += pos;
	}
	/* semantic check */
	if (hours < 24 && minutes < 60 && rp1->asint != int_nil && rp2->asint != int_nil) {
		minutes += hours * 60;
		set_offset(*d, neg_offset ? -minutes : minutes);
		if (pos) {
			(*d)->dst = TRUE;
			(*d)->dst_start = get_rule(r1);
			(*d)->dst_end = get_rule(r2);
		} else {
			(*d)->dst = FALSE;
		}
	}
	return (int) (cur - buf);
}

int
tzone_tostr(str *buf, int *len, tzone *z)
{
	str s;

	if (*len < 160) {
		if (*buf)
			GDKfree(*buf);
		*buf = (str) GDKmalloc(*len = 160);
	}
	s = *buf;
	if (tz_isnil(*z)) {
		strcpy(s, "nil");
		s += 3;
	} else {
		rule dst_start, dst_end;
		int mins = get_offset(z);

		set_rule(dst_start, z->dst_start);
		set_rule(dst_end, z->dst_end);

		strcpy(*buf, "GMT");
		s += 3;
		if (mins > 0) {
			sprintf(s, "+%02d:%02d", mins / 60, mins % 60);
			s += 6;
		} else if (mins < 0) {
			sprintf(s, "-%02d:%02d", (-mins) / 60, (-mins) % 60);
			s += 6;
		}
		if (z->dst) {
			strcpy(s, "-DST[");
			s += 5;
			s += rule_tostr(&s, len, &dst_start);
			*s++ = ',';
			s += rule_tostr(&s, len, &dst_end);
			*s++ = ']';
			*s = 0;
		}
	}
	return (int) (s - *buf);
}

@+ operator implementations
@c
static void
date_prelude(void)
{
	MONTHS[0] = str_nil;
	DAYS[0] = str_nil;
	NODAYS[0] = int_nil;
	DATE_MAX = todate(31, 12, YEAR_MAX);
	DATE_MIN = todate(1, 1, YEAR_MIN);
	tzone_local.dst = 0;
	set_offset(&tzone_local, 0);
}

int
oldduration(int *ndays, str s)
{
	int year = 0, month = 0, day = 0;
	int hour = 0 /*, min=0 */ ;
	char *snew = s;
	int v = 0;

	while (*snew != '\0') {
		if (GDKisdigit(*snew)) {
			v = 0;
			while (GDKisdigit(*snew)) {
				v = v * 10 + (*snew) - '0';
				snew++;
			}
		} else if (isupper((int) (*snew)) || islower((int) (*snew))) {
			switch (*snew++) {
			case 'y':
			case 'Y':
				year = v;
				v = 0;
				break;
			case 'm':
			case 'M':
				if (month || day || hour)	/*min = v */
					;
				else
					month = v;
				v = 0;
				break;
			case 'd':
			case 'D':
				day = v;
				v = 0;
				break;
			case 'h':
			case 'H':
				hour = v;
				v = 0;
				break;
			case 's':
			case 'S':
				v = 0;
				break;
			default:	/* GDKerror("duration_fromstr: wrong duration '%s'!\n",s); */
				*ndays = int_nil;
				return GDK_SUCCEED;
			}
		} else {
			snew++;
		}
	}
	*ndays = year * 365 + month * 30 + day;
	return GDK_SUCCEED;
}

int
olddate(date *d, str buf)
{
	int day = 0, month, year, yearneg = (buf[0] == '-'), pos = yearneg;

	*d = date_nil;
	if (!GDKisdigit(buf[pos])) {
		return GDK_FAIL;	/* syntax error */
	}
	for (year = 0; GDKisdigit(buf[pos]); pos++) {
		year = (buf[pos] - '0') + year * 10;
		if (year > YEAR_MAX)
			break;
	}
	pos += parse_substr(&month, buf + pos, 3, MONTHS, 12);
	if (month == int_nil) {
		return GDK_FAIL;	/* syntax error */
	}
	if (!GDKisdigit(buf[pos])) {
		return GDK_FAIL;	/* syntax error */
	}
	while (GDKisdigit(buf[pos])) {
		day = (buf[pos] - '0') + day * 10;
		pos++;
		if (day > 31)
			break;
	}
	/* handle semantic error here (returns nil in that case) */
	*d = todate(day, month, yearneg ? -year : year);
	return GDK_SUCCEED;
}

int
tzone_set_local(tzone *z)
{
	tzone_local = *z;
	return GDK_SUCCEED;
}

int
tzone_get_local(tzone *z)
{
	*z = tzone_local;
	return GDK_SUCCEED;
}

/* Returns month number [1-12] from a string (or nil if does not match any). */
int
month_from_str(int *ret, str month)
{
	parse_substr(ret, month, 3, MONTHS, 12);
	return GDK_SUCCEED;
}

/* Returns month name from a number between [1-7], str(nil) otherwise. */
int
month_to_str(str *ret, int *month)
{
	*ret = GDKstrdup(MONTHS[(*month < 1 || *month > 12) ? 0 : *month]);
	return GDK_SUCCEED;
}

/* Returns number of day [1-7] from a string (or nil if does not match any). */
int
day_from_str(int *ret, str day)
{
	parse_substr(ret, day, 3, DAYS, 7);
	return GDK_SUCCEED;
}

/* Returns day name from a number between [1-7], str(nil) otherwise. */
int
day_to_str(str *ret, int *day)
{
	*ret = GDKstrdup(DAYS[(*day < 1 || *day > 7) ? 0 : *day]);
	return GDK_SUCCEED;
}

/* creates a date from (day,month,year) parameters */
int
date_create(date *ret, int *year, int *month, int *day)
{
	*ret = todate(*day, *month, *year);
	return GDK_SUCCEED;
}

/* creates a daytime from (hours,minutes,seconds,milliseconds) parameters */
int
daytime_create(daytime *ret, int *hour, int *min, int *sec, int *msec)
{
	*ret = totime(*hour, *min, *sec, *msec);
	return GDK_SUCCEED;
}

/* creates a timestamp from (date,daytime) parameters */
int
timestamp_create(timestamp *ret, date *d, daytime *t, tzone *z)
{
	if (*d == date_nil || *t == daytime_nil || tz_isnil(*z)) {
		*ret = *ts_nilptr;
	} else {
		lng add = get_offset(z) * (lng) -60000;

		ret->days = *d;
		ret->msecs = *t;
		if (z->dst) {
			timestamp tmp;

			if (timestamp_inside(&tmp, ret, z, (lng) -3600000)) {
				*ret = tmp;
			}
		}
		timestamp_add(ret, ret, &add);
	}
	return GDK_SUCCEED;
}

int
timestamp_create_default(timestamp *ret, date *d, daytime *t)
{
	return timestamp_create(ret, d, t, &tzone_local);
}

/* extracts year from date (value between -5867411 and +5867411). */
int
date_extract_year(int *ret, date *v)
{
	if (*v == date_nil) {
		*ret = int_nil;
	} else {
		fromdate((int) *v, &dummy, &dummy, ret);
	}
	return GDK_SUCCEED;
}

/* extracts month from date (value between 1 and 12) */
int
date_extract_month(int *ret, date *v)
{
	if (*v == date_nil) {
		*ret = int_nil;
	} else {
		fromdate((int) *v, &dummy, ret, &dummy);
	}
	return GDK_SUCCEED;
}

/* extracts day from date (value between 1 and 31)*/
int
date_extract_day(int *ret, date *v)
{
	if (*v == date_nil) {
		*ret = int_nil;
	} else {
		fromdate((int) *v, ret, &dummy, &dummy);
	}
	return GDK_SUCCEED;
}

/* Returns N where d is the Nth day of the year (january 1 returns 1). */
int
date_extract_dayofyear(int *ret, date *v)
{
	if (*v == date_nil) {
		*ret = int_nil;
	} else {
		int year;

		fromdate((int) *v, &dummy, &dummy, &year);
		*ret = (int) (1 + *v - todate(1, 1, year));
	}
	return GDK_SUCCEED;
}

/* Returns the week number */
int
date_extract_weekofyear(int *ret, date *v)
{
	if (*v == date_nil) {
		*ret = int_nil;
	} else {
		int year, dayofweek;
		date year_jan_1;

		fromdate((int) *v, &dummy, &dummy, &year);
		dayofweek = date_dayofweek(year_jan_1 = todate(1, 1, year));

		if (dayofweek <= 4) {
			/* week of jan 1 belongs to this year */
			*ret = (int) (1 + (*v - year_jan_1 + dayofweek - 1) / 7);
		} else if (*v - year_jan_1 > 7 - dayofweek) {
			/* week of jan 1 belongs to last year; but this is a later week */
			*ret = (int) ((*v - year_jan_1 + dayofweek - 1) / 7);
		} else {
			/* recurse to get last weekno of previous year (it is 52 or 53) */
			date lastyear_dec_31 = todate(31, 12, (year == 1) ? -1 : year - 1);

			return date_extract_weekofyear(ret, &lastyear_dec_31);
		}
	}
	return GDK_SUCCEED;
}

/* Returns the current day  of the week where 1=monday, .., 7=sunday */
int
date_extract_dayofweek(int *ret, date *v)
{
	if (*v == date_nil) {
		*ret = int_nil;
	} else {
		*ret = date_dayofweek(*v);
	}
	return GDK_SUCCEED;
}

/* extracts hour from daytime (value between 0 and 23) */
int
daytime_extract_hours(int *ret, daytime *v)
{
	if (*v == daytime_nil) {
		*ret = int_nil;
	} else {
		fromtime((int) *v, ret, &dummy, &dummy, &dummy);
	}
	return GDK_SUCCEED;
}

/* extracts minutes from daytime (value between 0 and 59) */
int
daytime_extract_minutes(int *ret, daytime *v)
{
	if (*v == daytime_nil) {
		*ret = int_nil;
	} else {
		fromtime((int) *v, &dummy, ret, &dummy, &dummy);
	}
	return GDK_SUCCEED;
}

/* extracts seconds from daytime (value between 0 and 59) */
int
daytime_extract_seconds(int *ret, daytime *v)
{
	if (*v == daytime_nil) {
		*ret = int_nil;
	} else {
		fromtime((int) *v, &dummy, &dummy, ret, &dummy);
	}
	return GDK_SUCCEED;
}

/* extracts milliseconds from daytime (value between 0 and 999) */
int
daytime_extract_milliseconds(int *ret, daytime *v)
{
	if (*v == daytime_nil) {
		*ret = int_nil;
	} else {
		fromtime((int) *v, &dummy, &dummy, &dummy, ret);
	}
	return GDK_SUCCEED;
}

int
daytime_add(daytime *ret, daytime *v, lng *msec)
{
	if (*v == daytime_nil) {
		*ret = int_nil;
	} else {
		*ret = (daytime) (*v + *msec / 1000);
	}
	return GDK_SUCCEED;
}

/* extracts daytime from timestamp */
int
timestamp_extract_daytime(daytime *ret, timestamp *t, tzone *z)
{
	if (ts_isnil(*t) || tz_isnil(*z)) {
		*ret = daytime_nil;
	} else {
		timestamp tmp;

		if (timestamp_inside(&tmp, t, z, (lng) 0)) {
			lng add = (lng) 3600000;

			timestamp_add(&tmp, &tmp, &add);
		}
		if (ts_isnil(tmp)) {
			*ret = daytime_nil;
		} else {
			*ret = tmp.msecs;
		}
	}
	return GDK_SUCCEED;
}

int
timestamp_extract_daytime_default(daytime *ret, timestamp *t)
{
	return timestamp_extract_daytime(ret, t, &tzone_local);
}

/* extracts date from timestamp */
int
timestamp_extract_date(date *ret, timestamp *t, tzone *z)
{
	if (ts_isnil(*t) || tz_isnil(*z)) {
		*ret = date_nil;
	} else {
		timestamp tmp;

		if (timestamp_inside(&tmp, t, z, (lng) 0)) {
			lng add = (lng) 3600000;

			timestamp_add(&tmp, &tmp, &add);
		}
		if (ts_isnil(tmp)) {
			*ret = date_nil;
		} else {
			*ret = tmp.days;
		}
	}
	return GDK_SUCCEED;
}

int
timestamp_extract_date_default(date *ret, timestamp *t)
{
	return timestamp_extract_date(ret, t, &tzone_local);
}

int date_adddays(date *ret, date *v, int *delta);

/* returns the date that comes a number of years after 'v' (or before iff *delta < 0). */
int
date_addyears(date *ret, date *v, int *delta)
{
	if (*v == date_nil || *delta == int_nil) {
		*ret = date_nil;
	} else {
		int d, m, y, x, z = *delta;

		fromdate((int) *v, &d, &m, &y);
		if (m >= 3) {
			y++;
		}
		*ret = *v;
		while (z > 0) {
			x = YEARDAYS(y);
			date_adddays(ret, ret, &x);
			z--;
			y++;
		}
		while (z < 0) {
			z++;
			y--;
			x = -YEARDAYS(y);
			date_adddays(ret, ret, &x);
		}
	}
	return GDK_SUCCEED;
}

/* returns the date that comes a number of months after 'v' (or before iff *delta < 0). */
int
date_addmonths(date *ret, date *v, int *delta)
{
	if (*v == date_nil || *delta == int_nil) {
		*ret = date_nil;
	} else {
		int d, m, y, x, z = *delta;

		fromdate((int) *v, &d, &m, &y);
		*ret = *v;
		while (z > 0) {
			z--;
			x = MONTHDAYS(m, y);
			if (++m == 13)
				m = 1;
			date_adddays(ret, ret, &x);
		}
		while (z < 0) {
			z++;
			if (--m == 0)
				m = 12;
			x = -MONTHDAYS(m, y);
			date_adddays(ret, ret, &x);
		}
	}
	return GDK_SUCCEED;
}

/* returns the date that comes a number of day after 'v' (or before iff *delta < 0). */
int
date_adddays(date *ret, date *v, int *delta)
{
	lng min = DATE_MIN, max = DATE_MAX;
	lng cur = (lng) *v, inc = *delta;

	if (cur == int_nil || inc == int_nil || (inc > 0 && (max - cur) < inc) || (inc < 0 && (min - cur) > inc)) {
		*ret = date_nil;
	} else {
		*ret = *v + *delta;
	}
	return GDK_SUCCEED;
}




/* returns the number of days between 'val1' and 'val2'. */
int
date_diff(int *ret, date *v1, date *v2)
{
	if (*v1 == date_nil || *v2 == date_nil) {
		*ret = int_nil;
	} else {
		*ret = (int) (*v1 - *v2);
	}
	return GDK_SUCCEED;
}

/* returns the timestamp that comes 'milliseconds' after 'value'. */
int
timestamp_add(timestamp *ret, timestamp *v, lng *msecs)
{
	if (!ts_isnil(*v) && *msecs != lng_nil) {
		int days = (int) (*msecs / (24 * 60 * 60 * 1000));

		ret->msecs = (int) (v->msecs + (*msecs - ((lng) days) * (24 * 60 * 60 * 1000)));
		ret->days = v->days;
		if (ret->msecs >= (24 * 60 * 60 * 1000)) {
			days++;
			ret->msecs -= (24 * 60 * 60 * 1000);
		} else if (ret->msecs < 0) {
			days--;
			ret->msecs += (24 * 60 * 60 * 1000);
		}
		if (days) {
			date_adddays(&ret->days, &ret->days, &days);
			if (ret->days == int_nil) {
				*ret = *ts_nilptr;
			}
		}
	} else {
		*ret = *ts_nilptr;
	}
	return GDK_SUCCEED;
}


/* returns the number of milliseconds between 'val1' and 'val2'. */
int
timestamp_diff(lng *ret, timestamp *v1, timestamp *v2)
{
	if (ts_isnil(*v1) || ts_isnil(*v2)) {
		*ret = lng_nil;
	} else {
		*ret = ((lng) (v1->days - v2->days)) * ((lng) 24 * 60 * 60 * 1000) + ((lng) (v1->msecs - v2->msecs));
	}
	return GDK_SUCCEED;
}


/* return whether DST holds in the tzone at a certain point of time. */
int
timestamp_inside_dst(bit *ret, timestamp *p, tzone *z)
{
	*ret = FALSE;

	if (tz_isnil(*z)) {
		*ret = bit_nil;
	} else if (z->dst) {
		timestamp tmp;

		if (timestamp_inside(&tmp, p, z, (lng) 0)) {
			*ret = TRUE;
		}
	}
	return GDK_SUCCEED;
}

/* create a DST start/end date rule. */
int
rule_create(rule *ret, int *month, int *day, int *weekday, int *minutes)
{
	ret->asint = int_nil;
	if (*month >= 1 && *month <= 12 && ABS(*weekday) <= 7 && *minutes >= 0 && *minutes < 24 * 60 && ABS(*day) >= 1 && ABS(*day) <= NODAYS[*month] && (*weekday || *day > 0)) {
		ret->s.month = *month;
		ret->s.day = DAY_ZERO + *day;
		ret->s.weekday = WEEKDAY_ZERO + *weekday;
		ret->s.minutes = *minutes;
	}
	return GDK_SUCCEED;
}

/* create a tzone as a simple hour difference from GMT. */
int
tzone_create_dst(tzone *ret, int *minutes, rule *start, rule *end)
{
	*ret = *tz_nilptr;
	if (*minutes != int_nil && ABS(*minutes) < 24 * 60 && start->asint != int_nil && end->asint != int_nil) {
		set_offset(ret, *minutes);
		ret->dst = TRUE;
		ret->dst_start = get_rule(*start);
		ret->dst_end = get_rule(*end);
	}
	return GDK_SUCCEED;
}

/* create a tzone as an hour difference from GMT and a DST. */
int
tzone_create(tzone *ret, int *minutes)
{
	*ret = *tz_nilptr;
	if (*minutes != int_nil && ABS(*minutes) < 24 * 60) {
		set_offset(ret, *minutes);
		ret->dst = FALSE;
	}
	return GDK_SUCCEED;
}

/* extract month from rule. */
int
rule_extract_month(int *ret, rule *r)
{
	*ret = (r->asint == int_nil) ? int_nil : r->s.month;
	return GDK_SUCCEED;
}

/* extract day from rule. */
int
rule_extract_day(int *ret, rule *r)
{
	*ret = (r->asint == int_nil) ? int_nil : r->s.day - DAY_ZERO;
	return GDK_SUCCEED;
}

/* extract weekday from rule. */
int
rule_extract_weekday(int *ret, rule *r)
{
	*ret = (r->asint == int_nil) ? int_nil : r->s.weekday - WEEKDAY_ZERO;
	return GDK_SUCCEED;
}

/* extract minutes from rule. */
int
rule_extract_minutes(int *ret, rule *r)
{
	*ret = (r->asint == int_nil) ? int_nil : r->s.minutes;
	return GDK_SUCCEED;
}

/* extract rule that determines start of DST from tzone. */
int
tzone_extract_start(rule *ret, tzone *t)
{
	if (tz_isnil(*t) || !t->dst) {
		ret->asint = int_nil;
	} else {
		set_rule(*ret, t->dst_start);
	}
	return GDK_SUCCEED;
}

/* extract rule that determines end of DST from tzone. */
int
tzone_extract_end(rule *ret, tzone *t)
{
	if (tz_isnil(*t) || !t->dst) {
		ret->asint = int_nil;
	} else {
		set_rule(*ret, t->dst_end);
	}
	return GDK_SUCCEED;
}

/* extract number of minutes that tzone is offset wrt GMT. */
int
tzone_extract_minutes(int *ret, tzone *t)
{
	*ret = (tz_isnil(*t)) ? int_nil : get_offset(t);
	return GDK_SUCCEED;
}

int
date_sub_sec_interval_wrap(date *ret, date *t, int *sec)
{
	if (*sec > 0) {
		int delta = -1 * *sec / 86400;

		return date_adddays(ret, t, &delta);
	}

	return GDK_SUCCEED;
}

int
date_add_sec_interval_wrap(date *ret, date *t, int *sec)
{
	if (*sec > 0) {
		int delta = *sec / 86400;

		return date_adddays(ret, t, &delta);
	}

	return GDK_SUCCEED;
}

int
date_sub_month_interval_wrap(date *ret, date *t, int *months)
{
	return date_addmonths(ret, t, months);
}

/* compute the date from a rule in a certain year. */
int
compute_rule_foryear(date *ret, rule *val, int *year)
{
	if (*(int *) val == int_nil || *year < YEAR_MIN || *year > YEAR_MAX) {
		*ret = date_nil;
	} else {
		*ret = compute_rule(val, *year);
	}
	return GDK_SUCCEED;
}

@= isnil
int @1_isnil(bit *retval, @1 *val)
{
	*retval = *val == @1_nil;
	return GDK_SUCCEED;
}
@c
@:isnil(date)@
@:isnil(daytime)@

@= compare
int @1_comp_@2(bit *retval, @1 *val1, @1 *val2)
{
	if (*val1 == @1_nil || *val2 == @1_nil)
		*retval = bit_nil;
	else
		*retval = *val1 @3 *val2;
	return GDK_SUCCEED;
}
@c
@:compare(date,EQ,==)@
@:compare(date,NE,!=)@
@:compare(date,LT,<)@
@:compare(date,GT,>)@
@:compare(date,LE,<=)@
@:compare(date,GE,>=)@
@:compare(daytime,EQ,==)@
@:compare(daytime,NE,!=)@
@:compare(daytime,LT,<)@
@:compare(daytime,GT,>)@
@:compare(daytime,LE,<=)@
@:compare(daytime,GE,>=)@

int
timestamp_isnil(bit *retval, timestamp *val)
{
	*retval = ts_isnil(*val);
	return GDK_SUCCEED;
}

int
timestamp_comp_EQ(bit *retval, timestamp *val1, timestamp *val2)
{
	if (ts_isnil(*val1) || ts_isnil(*val2))
		*retval = bit_nil;
	else
		*retval = val1->days == val2->days && val1->msecs == val2->msecs;
	return GDK_SUCCEED;
}

int
timestamp_comp_NE(bit *retval, timestamp *val1, timestamp *val2)
{
	if (ts_isnil(*val1) || ts_isnil(*val2))
		*retval = bit_nil;
	else
		*retval = val1->days != val2->days || val1->msecs != val2->msecs;
	return GDK_SUCCEED;
}

int
timestamp_comp_LT(bit *retval, timestamp *val1, timestamp *val2)
{
	if (ts_isnil(*val1) || ts_isnil(*val2))
		*retval = bit_nil;
	else
		*retval = val1->days < val2->days || (val1->days == val2->days && val1->msecs < val2->msecs);
	return GDK_SUCCEED;
}

int
timestamp_comp_LE(bit *retval, timestamp *val1, timestamp *val2)
{
	if (ts_isnil(*val1) || ts_isnil(*val2))
		*retval = bit_nil;
	else
		*retval = val1->days < val2->days || (val1->days == val2->days && val1->msecs <= val2->msecs);
	return GDK_SUCCEED;
}

int
timestamp_comp_GT(bit *retval, timestamp *val1, timestamp *val2)
{
	if (ts_isnil(*val1) || ts_isnil(*val2))
		*retval = bit_nil;
	else
		*retval = val1->days > val2->days || (val1->days == val2->days && val1->msecs > val2->msecs);
	return GDK_SUCCEED;
}

int
timestamp_comp_GE(bit *retval, timestamp *val1, timestamp *val2)
{
	if (ts_isnil(*val1) || ts_isnil(*val2))
		*retval = bit_nil;
	else
		*retval = val1->days > val2->days || (val1->days == val2->days && val1->msecs >= val2->msecs);
	return GDK_SUCCEED;
}

@- Wrapper
The Monet V5 API interface is defined here
@= TIMEZONES
        ticks= @2;
        tzone_create((tzone*) &vr.val.ival, &ticks);
        tz= BUNins(tz,@1,&vr.val.ival);
@= TIMEZONES2
        ticks =@2;
        tzone_create_dst((tzone*) &vr.val.ival, &ticks,&@3,&@4);
        tz= BUNins(tz,@1,&vr.val.ival);
@-
Include BAT macros
@c
#include "mal.h"
#include "mal_exception.h"
#include <mal_box.h>
@-
@= coerce
mal_export str MTIME@1_2@2(@2 *ret,@1 *src);
str MTIME@1_2@2(@2 *ret,@1 *src){
	*ret= *src;
	return MAL_SUCCEED;
}
@c
@:coerce(date,lng)@
@:coerce(daytime,lng)@

str
MTIMEnil2date(date *ret, int *src)
{
	(void) src;
	*ret = date_nil;
	return MAL_SUCCEED;
}

str
MTIMEdate2date(date *ret, date *src)
{
	(void) src;
	*ret = *src;
	return MAL_SUCCEED;
}

@-
The comparison implementations are relatively straightforward.
@= compareImpl
mal_export str MTIME@3_@1(int *ret, @3 *v, @3 *w);
str MTIME@3_@1(int *ret, @3 *v, @3 *w){
        if( *v== @3_nil || *w== @3_nil)
                *ret= bit_nil;
        else    *ret = *v @2 *w;
	return MAL_SUCCEED;
}
@= compareAll
mal_export str MTIME@1_isnil(int *ret, @1 *v);
str MTIME@1_isnil(int *ret, @1 *v){
	*ret= *v == @1_nil;
	return MAL_SUCCEED;
}
        @:compareImpl(EQ,==,@1)@
        @:compareImpl(NEQ,!=,@1)@
        @:compareImpl(LT,<,@1)@
        @:compareImpl(LE,<=,@1)@
        @:compareImpl(GT,>,@1)@
        @:compareImpl(GE,>=,@1)@
@c
@:compareAll(date)@
@:compareAll(daytime)@


static BAT *timezones = NULL;

str
MTIMEprelude()
{
	Box box;
	ValRecord vr;
	int ticks;
	rule RULE_MAR, RULE_OCT;
	str s1 = "first sunday from end of march@02:00";
	str s2 = "first sunday from end of october@02:00";

	monettime_prelude();

	/* here we should initialize the time box as well */
	box = openBox("time");
	if (box == 0)
		return throwMessage("time.prelude", "failed to open box");
	/* if the box was already filled we can skip initialization */
	if (box->sym->vtop == 0) {
		BAT *tz = BATnew(TYPE_str, ATOMindex("tzone"), 30);

		if (tz == NULL)
			return throwMessage("time.prelude", "failed to create box");
		BBPrename(tz->batCacheid, "timezones");
		timezones = tz;
		newVariable(box->sym, GDKstrdup("timezones"), newBatType(TYPE_str, ATOMindex("tzone")));
		if (bindBAT(box, "timezones", "timezones")) {
			return throwMessage("time.prelude", "could not bind timezones");
		}
		vr.vtype = ATOMindex("tzone");
		@:TIMEZONES("Wake Island", 12 * 60)@
		@:TIMEZONES("Melbourne/Australia", 11 * 60)@
		@:TIMEZONES("Brisbane/Australia", 10 * 60)@
		@:TIMEZONES("Japan", 9 * 60)@
		@:TIMEZONES("Singapore", 8 * 60)@
		@:TIMEZONES("Thailand", 7 * 60)@
		@:TIMEZONES("Pakistan", 5 * 60)@
		@:TIMEZONES("United Arab Emirates", 4 * 60)@
		@:TIMEZONES("GMT", 0 * 0)@
		@:TIMEZONES("Azore Islands", -1 * 60)@
		@:TIMEZONES("Hawaii/USA", -10 * 60)@
		@:TIMEZONES("American Samoa", -11 * 60)@
		MTIMErule_fromstr(&RULE_MAR, &s1);
		MTIMErule_fromstr(&RULE_OCT, &s2);
		@:TIMEZONES2("Kazakhstan", 6 * 60, RULE_MAR, RULE_OCT)@
		@:TIMEZONES2("Moscow/Russia", 3 * 60, RULE_MAR, RULE_OCT)@
		@:TIMEZONES2("East/Europe", 2 * 60, RULE_MAR, RULE_OCT)@
		@:TIMEZONES2("West/Europe", 1 * 60, RULE_MAR, RULE_OCT)@
		@:TIMEZONES2("UK", 0 * 0, RULE_MAR, RULE_OCT)@
		@:TIMEZONES2("Eastern/Brazil", -2 * 60, RULE_OCT, RULE_MAR)@
		@:TIMEZONES2("Western/Brazil", -3 * 60, RULE_OCT, RULE_MAR)@
		@:TIMEZONES2("Andes/Brazil", -4 * 60, RULE_OCT, RULE_MAR)@
		@:TIMEZONES2("East/USA", -5 * 60, RULE_MAR, RULE_OCT)@
		@:TIMEZONES2("Central/USA", -6 * 60, RULE_MAR, RULE_OCT)@
		@:TIMEZONES2("Mountain/USA", -7 * 60, RULE_MAR, RULE_OCT)@
		@:TIMEZONES2("Alaska/USA", -9 * 60, RULE_MAR, RULE_OCT)@
	}
	return MAL_SUCCEED;
}

str
time_epilogue(void)
{
	GDKfree(ts_nilptr);
	GDKfree(tz_nilptr);
	return MAL_SUCCEED;
}

str
MTIMEsynonyms(bit *allow)
{
	monettime_synonyms(allow);
	return MAL_SUCCEED;
}

str
MTIMEoldduration(int *ndays, str *s)
{
	oldduration(ndays, *s);
	return MAL_SUCCEED;
}

str
MTIMEolddate(date *d, str *buf)
{
	olddate(d, *buf);
	return MAL_SUCCEED;
}

str
MTIMEtimezone(tzone *z, str *name)
{
	str s = *name;

	(void) z;		/* fool compiler */
	if (BUNfnd(timezones, s) == 0)
		s = "GMT";
	if (BUNfnd(timezones, s))
		printf("MTIMEtimezone NYI\n");
	;
	return MAL_SUCCEED;
}

str
MTIMEtzone_set_local(int res, tzone *z)
{
	(void) res;		/* fool compilers */
	tzone_set_local(z);
	return MAL_SUCCEED;
}

str
MTIMEtzone_get_local(tzone *z)
{
	tzone_get_local(z);
	return MAL_SUCCEED;
}

str
MTIMEmonth_from_str(int *ret, str *month)
{
	month_from_str(ret, *month);
	return MAL_SUCCEED;
}

str
MTIMEmonth_to_str(str *ret, int *month)
{
	month_to_str(ret, month);
	return MAL_SUCCEED;
}

str
MTIMEday_from_str(int *ret, str *day)
{
	day_from_str(ret, *day);
	return MAL_SUCCEED;
}

str
MTIMEday_to_str(str *ret, int *day)
{
	day_to_str(ret, day);
	return MAL_SUCCEED;
}

str
MTIMEdate_tostr(str *ret, date *d)
{
	int big = 128;
	char buf[128], *s1 = buf;

	*s1 = 0;
	date_tostr(&s1, &big, d);
	*ret = GDKstrdup(buf);
	return MAL_SUCCEED;
}

str
MTIMEdate_fromstr(date *ret, str *s)
{
	int len = 0;
	date *d = 0;

	date_fromstr(*s, &len, &d);
	*ret = *d;
	return MAL_SUCCEED;
}

str
MTIMEdate_create(date *ret, int *year, int *month, int *day)
{
	date_create(ret, year, month, day);
	return MAL_SUCCEED;
}

str
MTIMEdaytime_tostr(str *ret, daytime *d)
{
	char buf[128], *s = buf;
	int len = 128;

	*s = 0;
	daytime_tostr(&s, &len, d);
	*ret = GDKstrdup(buf);
	return MAL_SUCCEED;
}

str
MTIMEdaytime_create(daytime *ret, int *hour, int *min, int *sec, int *msec)
{
	daytime_create(ret, hour, min, sec, msec);
	return MAL_SUCCEED;
}

str
MTIMEtimestamp_tostr(str *s, timestamp *d)
{
	char buf[128], *s1 = buf;
	int len = 128;

	*s1 = 0;
	timestamp_tostr(&s1, &len, d);
	*s = GDKstrdup(buf);
	return MAL_SUCCEED;
}

str
MTIMEtimestamp_fromstr(timestamp *ret, str *d)
{
	int len = strlen(*d);

	timestamp_fromstr(*d, &len, &ret);
	return MAL_SUCCEED;
}

str
MTIMEtimestamp_create(timestamp *ret, date *d, daytime *t, tzone *z)
{
	timestamp_create(ret, d, t, z);
	return MAL_SUCCEED;
}

str
MTIMEtimestamp_create_default(timestamp *ret, date *d, daytime *t)
{
	return MTIMEtimestamp_create(ret, d, t, &tzone_local);
}

str
MTIMEdate_extract_year(int *ret, date *v)
{
	date_extract_year(ret, v);
	return MAL_SUCCEED;
}

str
MTIMEdate_extract_month(int *ret, date *v)
{
	date_extract_month(ret, v);
	return MAL_SUCCEED;
}

str
MTIMEdate_extract_day(int *ret, date *v)
{
	date_extract_day(ret, v);
	return MAL_SUCCEED;
}

str
MTIMEdate_extract_dayofyear(int *ret, date *v)
{
	date_extract_dayofyear(ret, v);
	return MAL_SUCCEED;
}

str
MTIMEdate_extract_weekofyear(int *ret, date *v)
{
	date_extract_weekofyear(ret, v);
	return MAL_SUCCEED;
}

str
MTIMEdate_extract_dayofweek(int *ret, date *v)
{
	date_extract_dayofweek(ret, v);
	return MAL_SUCCEED;
}

str
MTIMEdaytime_extract_hours(int *ret, daytime *v)
{
	daytime_extract_hours(ret, v);
	return MAL_SUCCEED;
}

str
MTIMEdaytime_extract_minutes(int *ret, daytime *v)
{
	daytime_extract_minutes(ret, v);
	return MAL_SUCCEED;
}

str
MTIMEdaytime_extract_seconds(int *ret, daytime *v)
{
	daytime_extract_seconds(ret, v);
	return MAL_SUCCEED;
}

str
MTIMEdaytime_extract_milliseconds(int *ret, daytime *v)
{
	daytime_extract_milliseconds(ret, v);
	return MAL_SUCCEED;
}

str
MTIMEtimestamp_extract_daytime(daytime *ret, timestamp *t, tzone *z)
{
	timestamp_extract_daytime(ret, t, z);
	return MAL_SUCCEED;
}

str
MTIMEtimestamp_extract_daytime_default(daytime *ret, timestamp *t)
{
	return MTIMEtimestamp_extract_daytime(ret, t, &tzone_local);
}

str
MTIMEtimestamp_extract_date(date *ret, timestamp *t, tzone *z)
{
	timestamp_extract_date(ret, t, z);
	return MAL_SUCCEED;
}

str
MTIMEtimestamp_extract_date_default(date *ret, timestamp *t)
{
	return MTIMEtimestamp_extract_date(ret, t, &tzone_local);
}

str
MTIMEdate_addyears(date *ret, date *v, int *delta)
{
	date_addyears(ret, v, delta);
	return MAL_SUCCEED;
}

str
MTIMEdate_adddays(date *ret, date *v, int *delta)
{
	date_adddays(ret, v, delta);
	return MAL_SUCCEED;
}

str
MTIMEdate_addmonths(date *ret, date *v, int *delta)
{
	date_addmonths(ret, v, delta);
	return MAL_SUCCEED;
}

str
MTIMEdate_diff(int *ret, date *v1, date *v2)
{
	date_diff(ret, v1, v2);
	return MAL_SUCCEED;
}

str
MTIMEtimestamp_add(timestamp *ret, timestamp *v, lng *msecs)
{
	timestamp_add(ret, v, msecs);
	return MAL_SUCCEED;
}

str
MTIMEtimestamp_diff(lng *ret, timestamp *v1, timestamp *v2)
{
	timestamp_diff(ret, v1, v2);
	return MAL_SUCCEED;
}

str
MTIMEtimestamp_inside_dst(bit *ret, timestamp *p, tzone *z)
{
	timestamp_inside_dst(ret, p, z);
	return MAL_SUCCEED;
}

str
MTIMEtimestamp_isnil(bit *retval, timestamp *val)
{
	*retval = ts_isnil(*val);
	return MAL_SUCCEED;
}

str
MTIMEtimestamp_EQ(bit *retval, timestamp *val1, timestamp *val2)
{
	if (ts_isnil(*val1) || ts_isnil(*val2))
		*retval = bit_nil;
	else
		*retval = val1->days == val2->days && val1->msecs == val2->msecs;
	return MAL_SUCCEED;
}

str
MTIMEtimestamp_NEQ(bit *retval, timestamp *val1, timestamp *val2)
{
	if (ts_isnil(*val1) || ts_isnil(*val2))
		*retval = bit_nil;
	else
		*retval = val1->days != val2->days || val1->msecs != val2->msecs;
	return MAL_SUCCEED;
}

str
MTIMEtimestamp_LT(bit *retval, timestamp *val1, timestamp *val2)
{
	if (ts_isnil(*val1) || ts_isnil(*val2))
		*retval = bit_nil;
	else
		*retval = val1->days < val2->days || (val1->days == val2->days && val1->msecs < val2->msecs);
	return MAL_SUCCEED;
}

str
MTIMEtimestamp_LE(bit *retval, timestamp *val1, timestamp *val2)
{
	if (ts_isnil(*val1) || ts_isnil(*val2))
		*retval = bit_nil;
	else
		*retval = val1->days < val2->days || (val1->days == val2->days && val1->msecs <= val2->msecs);
	return MAL_SUCCEED;
}

str
MTIMEtimestamp_GT(bit *retval, timestamp *val1, timestamp *val2)
{
	if (ts_isnil(*val1) || ts_isnil(*val2))
		*retval = bit_nil;
	else
		*retval = val1->days > val2->days || (val1->days == val2->days && val1->msecs > val2->msecs);
	return MAL_SUCCEED;
}

str
MTIMEtimestamp_GE(bit *retval, timestamp *val1, timestamp *val2)
{
	if (ts_isnil(*val1) || ts_isnil(*val2))
		*retval = bit_nil;
	else
		*retval = val1->days > val2->days || (val1->days == val2->days && val1->msecs >= val2->msecs);
	return MAL_SUCCEED;
}

str
MTIMErule_tostr(str *s, rule *r)
{
	char buf[128], *s1 = buf;
	int len = 128;

	*s1 = 0;
	rule_tostr(&s1, &len, r);
	*s = GDKstrdup(buf);
	return MAL_SUCCEED;
}

str
MTIMErule_fromstr(rule *ret, str *s)
{
	int len = 0;
	rule *d = 0;

	rule_fromstr(*s, &len, &d);
	*ret = *d;
	GDKfree(d);
	return MAL_SUCCEED;
}

str
MTIMErule_create(rule *ret, int *month, int *day, int *weekday, int *minutes)
{
	rule_create(ret, month, day, weekday, minutes);
	return MAL_SUCCEED;
}

str
MTIMEtzone_create_dst(tzone *ret, int *minutes, rule *start, rule *end)
{
	tzone_create_dst(ret, minutes, start, end);
	return MAL_SUCCEED;
}

str
MTIMEtzone_create(tzone *ret, int *minutes)
{
	tzone_create(ret, minutes);
	return MAL_SUCCEED;
}

str
MTIMErule_extract_month(int *ret, rule *r)
{
	rule_extract_month(ret, r);
	return MAL_SUCCEED;
}

str
MTIMErule_extract_day(int *ret, rule *r)
{
	rule_extract_day(ret, r);
	return MAL_SUCCEED;
}

str
MTIMErule_extract_weekday(int *ret, rule *r)
{
	rule_extract_weekday(ret, r);
	return MAL_SUCCEED;
}

str
MTIMErule_extract_minutes(int *ret, rule *r)
{
	rule_extract_minutes(ret, r);
	return MAL_SUCCEED;
}

str
MTIMEtzone_extract_start(rule *ret, tzone *t)
{
	tzone_extract_start(ret, t);
	return MAL_SUCCEED;
}

str
MTIMEtzone_extract_end(rule *ret, tzone *t)
{
	tzone_extract_end(ret, t);
	return MAL_SUCCEED;
}

str
MTIMEtzone_extract_minutes(int *ret, tzone *t)
{
	tzone_extract_minutes(ret, t);
	return MAL_SUCCEED;
}

str
MTIMEdate_sub_sec_interval_wrap(date *ret, date *t, int *sec)
{
	date_sub_sec_interval_wrap(ret, t, sec);
	return MAL_SUCCEED;
}

str
MTIMEdate_add_sec_interval_wrap(date *ret, date *t, int *sec)
{
	date_add_sec_interval_wrap(ret, t, sec);
	return MAL_SUCCEED;
}

str
MTIMEdate_add_month_interval_wrap(date *ret, date *t, int *months)
{
	return MTIMEdate_addmonths(ret, t, months);
}

str
MTIMEcompute_rule_foryear(date *ret, rule *val, int *year)
{
	compute_rule_foryear(ret, val, year);
	return MAL_SUCCEED;
}

str
MTIMEtzone_tostr(str *s, tzone *ret)
{
	char buf[128], *s1 = buf;
	int len = 128;

	*s1 = 0;
	tzone_tostr(&s1, &len, ret);
	*s = GDKstrdup(buf);
	return MAL_SUCCEED;
}

str
MTIMEtzone_fromstr(tzone *ret, str *s)
{
	int len = 0;
	tzone *d = 0;

	tzone_fromstr(*s, &len, &d);
	*ret = *d;
	return MAL_SUCCEED;
}

str
MTIMEdaytime_fromstr(daytime *ret, str *s)
{
	int len = 0;
	daytime *d = 0;

	daytime_fromstr(*s, &len, &d);
	*ret = *d;
	return MAL_SUCCEED;
}

@-
The utilities from Monet V4
@c
str
MTIMEmsecs(lng *ret, int *d, int *h, int *m, int *s, int *ms)
{
	*ret = ((lng) *ms) + 1000 * (*s + 60 * (*m + 60 * (*h + 24 * *d)));
	return MAL_SUCCEED;
}

str
MTIMEdaytime1(daytime *ret, int *h)
{
	int m = 0, s = 0, ms = 0;

	daytime_create(ret, h, &m, &s, &ms);
	return MAL_SUCCEED;
}

str
MTIMEdaytime2(daytime *ret, int *h, int *m)
{
	int s = 0, ms = 0;

	daytime_create(ret, h, m, &s, &ms);
	return MAL_SUCCEED;
}

str
MTIMEdaytime3(daytime *ret, int *h, int *m, int *s)
{
	int ms = 0;

	daytime_create(ret, h, m, s, &ms);
	return MAL_SUCCEED;
}

str
MTIMEunix_epoch(timestamp *ret)
{
	date d0 = todate(1, 1, 1970);
	int zero = 0;
	str s = "GMT";
	daytime d1;
	tzone d2;

	daytime_create(&d1, &zero, &zero, &zero, &zero);
	MTIMEtzone_fromstr(&d2, &s);
	timestamp_create(ret, &d0, &d1, &d2);
	return MAL_SUCCEED;
}

str
MTIMEepoch(timestamp *ret)
{
	timestamp ts;
	lng t = ((lng) time(0)) * 1000;
	str e;

	/* convert number of seconds into a timestamp */
	(e = MTIMEunix_epoch(&ts)) == MAL_SUCCEED && (e = MTIMEtimestamp_add(ret, &ts, &t)) == MAL_SUCCEED;
	return (e);
}

str
MTIMEepoch2lng(lng *ret, timestamp *t)
{
	timestamp e;
	lng v;

	MTIMEunix_epoch(&e);
	timestamp_diff(&v, &e, t);
	*ret = v / 1000;
	return MAL_SUCCEED;
}

str
MTIMEtimestamp(timestamp *ret, int *sec)
{
	timestamp e;
	lng l = *sec * 1000;

	MTIMEunix_epoch(&e);
	timestamp_add(ret, &e, &l);
	return MAL_SUCCEED;
}

str
MTIMEruleDef0(rule *ret, int *m, int *d, int *w, int *h, int *mint)
{
	int d0 = 60 * *h;
	int d1 = d0 + *mint;

	rule_create(ret, m, d, w, &d1);
	return MAL_SUCCEED;
}

str
MTIMEruleDef1(rule *ret, int *m, str *dnme, int *w, int *h, int *mint)
{
	int d;
	int d0 = 60 * *h;
	int d1 = d0 + *mint;

	day_from_str(&d, *dnme);
	rule_create(ret, m, &d, w, &d1);
	return MAL_SUCCEED;
}

str
MTIMEruleDef2(rule *ret, int *m, str *dnme, int *w, int *mint)
{
	int d;

	day_from_str(&d, *dnme);
	rule_create(ret, m, &d, w, mint);
	return MAL_SUCCEED;
}

str
MTIMEcurrent_timestamp(timestamp *t)
{
	MTIMEepoch(t);
	return MAL_SUCCEED;
}

str
MTIMEcurrent_date(date *d)
{
	timestamp stamp;

	MTIMEcurrent_timestamp(&stamp);
	MTIMEtimestamp_extract_date_default(d, &stamp);
	return MAL_SUCCEED;
}

str
MTIMEcurrent_time(daytime *t)
{
	timestamp stamp;

	MTIMEcurrent_timestamp(&stamp);
	MTIMEtimestamp_extract_daytime_default(t, &stamp);
	return MAL_SUCCEED;
}

@-
The BAT equivalents for these functions provide
speed.
@= Extract
mal_export str MTIME@1_extract_@2_bulk(int *ret, int *bid);
str MTIME@1_extract_@2_bulk(int *ret, int *bid)
{       BAT *b,*bn;
	int s1,xx;
	@3 v;
	date d;
	ptr p1;
	BUN p,q;

	if( (b= BATdescriptor(*bid)) == NULL ){
		 return throwMessage("bbp.get@1", "Cannot access descriptor");
	}


	bn= BATnew(BAThtype(b),TYPE_@3, BATcount(b));

	s1= BUNsize(bn);
	p1= BUNfirst(bn);

	BATloopFast(b,p,q,xx){
		ptr h= BUNhead(b,p);
		d= *(date*) BUNtail(b,p);
		MTIME@1_extract_@2(&v,&d);
		bunfastins_nocheck(bn,p1,h,&v,s1);
		p1= (ptr)( ((char*)p1) + s1);
	}
bunins_failed:
	BBPfix(*ret = bn->batCacheid);
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}


@-
@c
@:Extract(date,year,int)@
@:Extract(date,month,int)@
@:Extract(date,day,int)@
@:Extract(daytime,hours,int)@
@:Extract(daytime,minutes,int)@
@:Extract(daytime,seconds,int)@
@:Extract(daytime,milliseconds,int)@

@}
