@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f streams
@a Niels Nes
@* A simple interface to streams
All file IO is funneled through the stream library, which
guarantees cross-platform capabilities.
Several protocols are provided, e.g. it can be used to 
open 'non compressed, gzipped, bz2zipped' data files. 
It encapsulates the corresponding library managed in
.../stream.

@mal
atom stream:ptr;

command openReadBytes( filename:str ) :stream
address stream_open_rstreamwrap
comment "open a file stream for reading";
command openWriteBytes( filename:str ) :stream
address stream_open_wstreamwrap
comment "open a file stream for writing";

command openRead( filename:str ) :stream
address stream_open_rastreamwrap
comment "open ascii file stream for reading";
command openWrite( filename:str ) :stream
address stream_open_wastreamwrap
comment "open ascii file stream for writing";

command openRead(s:stream):stream
address stream_stream_rstreamwrap
comment "convert an ascii stream to binary";
command openWrite(s:stream):stream
address stream_stream_wstreamwrap
comment "convert an ascii stream to binary";

command socketReadBytes(skt:int,name:str):stream
address stream_socket_rstreamwrap
comment "open a socket stream for reading";
command socketWriteBytes(skt:int,name:str):stream
address stream_socket_wstreamwrap
comment "open a socket stream for writing";
command socketRead(skt:int,name:str):stream
address stream_socket_rastreamwrap
comment "open ascii socket stream for reading";
command socketWrite(skt:int,name:str):stream
address stream_socket_wastreamwrap
comment "open ascii socket stream for writing";

command blocked( s:stream ) :stream
address open_block_streamwrap
comment "open a block based stream";

command writeStr( s:stream, data:str ):void
address stream_write_stringwrap
comment "write data on the stream";
command writeInt( s:stream, data:int ):void
address stream_writeIntwrap
comment "write data on the stream";
command readStr( s:stream):str
address stream_read_stringwrap
comment "read string data from the stream";
command readInt( s:stream):int
address stream_readIntwrap
comment "read integer data from the stream";

command flush( s:stream )
address stream_flush_streamwrap
comment "flush the stream";

command close( s:stream )
address stream_close_streamwrap
comment "close and destroy the stream s";

atom bstream:ptr;
command create(s:stream, bufsize:int):bstream
address bstream_create_wrapwrap
comment "create a buffered stream";

command destroy(s:bstream)
address bstream_destroy_wrapwrap
comment "destroy bstream";

command read(s:bstream,size:int):int
address bstream_read_wrapwrap
comment "read at least size bytes into the buffer of s";

@-
@{
The implementation follows and should be self-documenting
@h
#ifndef _STREAMS_H_
#define _STREAMS_H_

#include <gdk.h>
#include <blob.h>

typedef ptr Stream;
typedef ptr Bstream;

#endif /*_STREAMS_H_*/
@c
#include <mal.h>
#include "streams.h"
#include <stdio.h>

/*
int io_stdin (Stream *ret) { *(stream**)ret = GDKin;  return GDK_SUCCEED; }
int io_stdout(Stream *ret) { *(stream**)ret = GDKout; return GDK_SUCCEED; }
int io_stderr(Stream *ret) { *(stream**)ret = GDKerr; return GDK_SUCCEED; }
*/

mal_export int stream_write_string(Stream *S, str data);
mal_export int stream_writeInt_wrap(Stream *S, int *data);
mal_export int stream_readInt_wrap(int *data, Stream *S);
mal_export int stream_read_string(str *res, Stream *S);
mal_export int stream_flush_stream(Stream *S);
mal_export int stream_close_stream(Stream *S);
mal_export int open_block_stream(Stream *S, Stream *is);
mal_export int bstream_create_wrap(Bstream *BS, Stream *S, int *bufsize);
mal_export int bstream_destroy_wrap(Bstream *BS);
mal_export int bstream_read_wrap(int *res, Bstream *BS, int *size);
mal_export str stream_write_stringwrap(int *ret, Stream *S, str *data);
mal_export str stream_writeIntwrap(int *ret, Stream *S, int *data);
mal_export str stream_readIntwrap(int *ret, Stream *S);
mal_export str stream_read_stringwrap(str *res, Stream *s);
mal_export str stream_flush_streamwrap(int *ret, Stream *s);
mal_export str stream_close_streamwrap(int *ret, Stream *s);
mal_export str open_block_streamwrap(Stream *S, Stream *is);
mal_export str bstream_create_wrapwrap(Bstream *Bs, Stream *S, int *bufsize);
mal_export str bstream_destroy_wrapwrap(int *ret, Bstream *BS);
mal_export str bstream_read_wrapwrap(int *res, Bstream *BS, int *size);
mal_export str stream_readIntwrap(int *ret, Stream *S);
mal_export str stream_read_stringwrap(str *res, Stream *s);

@= open_stream
mal_export int stream_open_@1(Stream *S, str filename);
int
stream_open_@1(Stream *S, str filename)
{
	stream *s;

	if ((s = open_@1( filename )) == NULL || stream_errnr(s)) {
		if (s)
			stream_destroy(s);
		GDKerror("stream_open: could not open file %s\n", filename);
		return GDK_FAIL;
	} else {
		*(stream**)S = s;
		return GDK_SUCCEED;
	}
}
@c
@:open_stream(rstream)@
@:open_stream(wstream)@
@:open_stream(rastream)@
@:open_stream(wastream)@

@= stream_stream
mal_export int stream_stream_@1(Stream *Sout, Stream *Sin);
int
stream_stream_@1(Stream *Sout, Stream *Sin)
{
	*(stream**)Sout = stream_@1(*(stream**)Sin);
	return GDK_SUCCEED;
}
@c
@:stream_stream(rstream)@
@:stream_stream(wstream)@

@= open_socket
mal_export int stream_socket_@1(Stream *S, int *socket, str name);
int
stream_socket_@1(Stream *S, int *socket, str name)
{
	stream *s;

	if ((s = socket_@1( *socket, name )) == NULL || stream_errnr(s)) {
		if (s)
			stream_destroy(s);
		GDKerror("Could not open socket %s\n", name );
		return GDK_FAIL;
	} else {
		*(stream**)S = s;
		return GDK_SUCCEED;
	}
}
@c
@:open_socket(rstream)@
@:open_socket(wstream)@
@:open_socket(rastream)@
@:open_socket(wastream)@

@c
int
stream_write_string(Stream *S, str data)
{
	stream *s = *(stream **) S;

	return stream_write(s, data, 1, strlen(data)) < 0 ? GDK_FAIL : GDK_SUCCEED;
}

int
stream_writeInt_wrap(Stream *S, int *data)
{
	stream *s = *(stream **) S;

	return stream_writeInt(s, *data) ? GDK_SUCCEED : GDK_FAIL;
}

int
stream_readInt_wrap(int *data, Stream *S)
{
	stream *s = *(stream **) S;

	return stream_readInt(s, data) ? GDK_SUCCEED : GDK_FAIL;
}

#define CHUNK (64*1024)
int
stream_read_string(str *res, Stream *S)
{
	stream *s = *(stream **) S;
	ssize_t len = 0;
	size_t size = CHUNK +1;
	char *buf = GDKmalloc(size), *start = buf;

	while ((len = stream_read(s, start, 1, CHUNK)) > 0) {
		size += len;
		buf = GDKrealloc(buf, size);
		start = buf + size - CHUNK -1;

		*start = '\0';
	}
	if (len < 0)
		return GDK_FAIL;
	start += len;
	*start = '\0';
	*res = buf;
	return GDK_SUCCEED;
}

int
stream_flush_stream(Stream *S)
{
	stream *s = *(stream **) S;

	if (stream_flush(s))
		return GDK_FAIL;
	return GDK_SUCCEED;
}

int
stream_close_stream(Stream *S)
{
	close_stream(*(stream **) S);
	return GDK_SUCCEED;
}

int
open_block_stream(Stream *S, Stream *is)
{
	if ((*(stream **) S = block_stream(*(stream **) is)) == NULL) {
		return GDK_FAIL;
	} else {
		return GDK_SUCCEED;
	}
}

int
bstream_create_wrap(Bstream *BS, Stream *S, int *bufsize)
{
	if ((*(bstream **) BS = bstream_create(*(stream **) S, (size_t) * bufsize)) == NULL) {
		return GDK_FAIL;
	} else {
		return GDK_SUCCEED;
	}
}

int
bstream_destroy_wrap(Bstream *BS)
{
	bstream_destroy(*(bstream **) BS);
	return GDK_SUCCEED;
}

int
bstream_read_wrap(int *res, Bstream *BS, int *size)
{
	*res = (int) bstream_read(*(bstream **) BS, (size_t) * size);
	return GDK_SUCCEED;
}

@- Wrapper
The remainder is the version 5 wrapper
@= open_streamwrap
mal_export str stream_open_@1wrap( Stream *S, str *filename );
str stream_open_@1wrap( Stream *S, str *filename ){
    
    if( stream_open_@1(S, *filename)== GDK_SUCCEED)
            return MAL_SUCCEED;
    return throwMessage("stream","Could not open file\n");
}
@}
@c
#include "mal_exception.h"

@:open_streamwrap(rstream)@
@:open_streamwrap(wstream)@
@:open_streamwrap(rastream)@
@:open_streamwrap(wastream)@

@-
@= stream_streamwrap
mal_export str stream_stream_@1wrap(Stream *sout, Stream *sin);
str stream_stream_@1wrap(Stream *sout, Stream *sin){
    *(stream**)sout = stream_@1(*(stream**)sin);
    return MAL_SUCCEED;
}
@c
@:stream_streamwrap(rstream)@
@:stream_streamwrap(wstream)@
@-
@= open_socketwrap
mal_export str stream_socket_@1wrap( Stream *S, int *socket, str *name );
str stream_socket_@1wrap( Stream *S, int *socket, str *name ){
    if( stream_socket_@1(S,socket,*name) == GDK_SUCCEED)
        return MAL_SUCCEED;
    return throwMessage("stream","Could not open socket\n");
}
@c
@:open_socketwrap(rstream)@
@:open_socketwrap(wstream)@
@:open_socketwrap(rastream)@
@:open_socketwrap(wastream)@

str
stream_write_stringwrap(int *ret, Stream *S, str *data)
{
	(void) ret;
	if (stream_write_string(S, *data) == GDK_SUCCEED)
		return MAL_SUCCEED;
	return throwMessage("streams.writeStr", "failed");
}

str
stream_writeIntwrap(int *ret, Stream *S, int *data)
{
	(void) ret;
	if (stream_writeInt_wrap(S, data) == GDK_SUCCEED)
		return MAL_SUCCEED;
	return throwMessage("streams.writeInt", "failed");
}

str
stream_readIntwrap(int *ret, Stream *S)
{
	if (stream_readInt_wrap(ret, S) == GDK_SUCCEED)
		return MAL_SUCCEED;
	return throwMessage("streams.readInt", "failed");
}

str
stream_read_stringwrap(str *res, Stream *s)
{
	if (stream_read_string(res, s) == GDK_SUCCEED)
		return MAL_SUCCEED;
	return throwMessage("streams.readStr", "failed");
}

str
stream_flush_streamwrap(int *ret, Stream *s)
{
	(void) ret;
	if (stream_flush_stream(s) == GDK_SUCCEED)
		return MAL_SUCCEED;
	return throwMessage("streams.flush", "failed");
}

str
stream_close_streamwrap(int *ret, Stream *s)
{
	(void) ret;
	if (stream_close_stream(s) == GDK_SUCCEED)
		return MAL_SUCCEED;
	return throwMessage("streams.close", "failed");
}

str
open_block_streamwrap(Stream *S, Stream *is)
{
	if (open_block_stream(S, is) == GDK_SUCCEED)
		return MAL_SUCCEED;
	return throwMessage("bstreams.open", "failed");
}

str
bstream_create_wrapwrap(Bstream *Bs, Stream *S, int *bufsize)
{
	if (bstream_create_wrap(Bs, S, bufsize) == GDK_SUCCEED)
		return MAL_SUCCEED;
	return throwMessage("bstreams.create", "failed");
}

str
bstream_destroy_wrapwrap(int *ret, Bstream *BS)
{
	(void) ret;
	bstream_destroy_wrap(BS);
	return MAL_SUCCEED;
}

str
bstream_read_wrapwrap(int *res, Bstream *BS, int *size)
{
	bstream_read_wrap(res, BS, size);
	return MAL_SUCCEED;
}
