@f url
@t The URL module
@a M. Kersten
@v 1.2
@* The URL module
The URL module contains a collection of commands to manipulate 
Uniform Resource Locators - a resource on the World Wide Web-
represented as a string in Monet. The URL can represent
anything from a file, a directory or a complete movie.
This module is geared towards manipulation of their name only.
A complementary module can be used to gain access.[IOgate]

The core of the extension involves several operators to extract
portions of the URLs for further manipulation.
In particular, the domain, the server, and the protocol, and the file
extension can be extracted without copying the complete URL from the heap 
into a string variable first.

The commands provided are based on the corresponding Java class.

A future version should use a special atom, because this may save
considerable space. Alternatively, break the URL strings into components
and represent them with a bunch of BATs. 
An intermediate step would be to refine the atom STR, then it would be
possible to redefine hashing.

@mal
atom module url:str;

command url(s:str):url = URLnew
	comment "Create an URL from a string literal";
command getAnchor(u:url) : str        = URLgetAnchor 
	comment "Extract the anchor (reference) from the URL";
command getBasename(u:url) : str        = URLgetBasename 
	comment "Extract the base file name of the URL";
command getContent(u:url)   : str        = URLgetContent 
	comment "Get the URL resource in a local file";
command getContext(u:url)   : str        = URLgetContext 
	comment "Get the path context of a URL ";
command getDirectory(u:url) : bat[int,str]  = URLgetDirectory 
	comment "Extract the directory names from the URL";
command getDomain(u:url) : str        = URLgetDomain 
	comment "Extract the Internet domain from the URL";
command getExtension(u:url) : str        = URLgetExtension 
	comment "Extract the file extension of the URL";
command getFile(u:url) : str        = URLgetFile 
	comment "Extract the last file name of the URL";
command getHost(u:url)   : str        = URLgetHost 
	comment "Extract the server identity from the URL";
command getPort(u:url) : str        = URLgetPort 
	comment "Extract the port id from the URL";
command getProtocol(u:url) : str        = URLgetProtocol 
	comment "Extract the protocol from the URL";
command getQuery(u:url) : str        = URLgetQuery 
	comment "Extract the query string from the URL";
command getQueryArg(u:url) : bat[str,str]  = URLgetQueryArg 
	comment "Extract the argument mappings from the URL";
command getUser(u:url) : str        = URLgetUser 
	comment "Extract the user identity from the URL";
command getRobotURL(u:url) : str        = URLgetRobotURL 
	comment "Extract the location of the robot control file";
command isaURL(u:url)   : bit        = URLisaURL 
	comment "Check conformity of the URL syntax";
command newurl(prot:str,host:str,port:int,fnme:str)   : url        = URLnew4 
	comment "Construct a URL from protocol, host,port,and file";
command newurl(prot:str,host:str,fnme:str)   : url        = URLnew3 
	comment "Construct a URL from protocol, host,and file";

# the remaining instructions replace the string equivalent versions
command fromstr() = URLfromString
	comment "Convert a string to an url. ";
command tostr() = URLtoString
	comment "Convert url to string equivalent";
@* Example Script
@mil
setoid(oid(20000000));
module(url);
u:= url("http://www.cwi.nl/~mk/Acoi/index.html");
u.getHost.print;
u.getPort.print;
u.getDomain.print;
u.getFile.print;
u.getAnchor.print;
u.getBasename.print;
u.getProtocol.print;
u.getUser.print;
u.getDirectory.print;

v:= newurl("http","www.cwi.nl","~monet");
v.print;
v.getRobotURL.print;
w:= url("http://www.nedstat.nl/cgi-bin/viewstat?name=Planetarium");
w.getQuery.print;
w.getQueryArg.print;

t:= new(int, url);
t.insert(1, url("http://www.cwi.nl"));
t.insert(2, url("http://www.cwi.nl/~monet"));
t.insert(3, url("http://www.cwi.nl/~mk/Acoi/doc/features.html"));
t.insert(4, url("http://www.educ.uva.nl/schoolweb/rocloka.htm"));
t.insert(5, url("http://www.nedstat.nl/cgi-bin/viewstat?name=Planetarium"));
t.insert(6, url("http://www.edgeonline.com/"));
t.insert(7, url("http://robotics.stanford.edu/icons/ "));

t.print;
t.[getHost].print;
t.[getPort].print;
t.[getDomain].print;
t.[getFile].print;
t.[getAnchor].print;
t.[getBasename].print;
t.[getProtocol].print;
t.[getUser].print;

quit;
@{
@* URL command implementation 
The URLs are stored as strings without further optimization.
A more compact representation is feasible, but not considered yet to
invest energy.
@= Pseudo
        /* BATrename(b,"@1_@2");*/
        BATroles(b,"@1","@2");
        BATmode(b,TRANSIENT);
@-
The key action is to break an url into its constituents.
Parsing is done for each individual request, because this way we
secure concurrent use from different threads.
@c
/*
 * The contents of this file are subject to the Monet Public
 * License Version 1.1 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy of
 * the License at 
 * http://www.monetsolutions.com/Download/Licensing/MonetPL-1.1.html
 * 
 * Software distributed under the License is distributed on an "AS
 * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 * 
 * The Original Code is the Monet Database System.
 * 
 * The Initial Developer of the Original Code is CWI.
 * Portions created by CWI are Copyright (C) 1997-2002 CWI.  
 * All Rights Reserved.
 * 
 * Contributor(s): Martin Kersten <Martin.Kersten@cwi.nl>
 *		   Peter Boncz <Peter.Boncz@cwi.nl>
 *		   Niels Nes <Niels.Nes@cwi.nl>
 *		   Stefan Manegold  <Stefan.Manegold@cwi.nl>
 */

#include <gdk.h>
#include "monet.h"

typedef str url;

void getword(char *word, char *line, char stop);
char x2c(char *what);
void unescape_url(char *url);
void plustospace(char *str);

int URLfromString(str src, int *len, str *url){
	/* actually parse the message for valid url */
	if( *url != 0) GDKfree(url);
	*len= strlen(src);
	*url= GDKstrdup(src);
	return *len;
}
int URLtoString(str *s, int *len, str src){
	int l;
	if( GDK_STRNIL(src) ){
		**s = 0;
		return GDK_SUCCEED;
	}
	l= src==0? 3: strlen(src)+3;
	/* if( !*s) *s= (str)GDKmalloc(*len = l); */

	if( l>= *len){
		GDKfree(*s);
		*s= GDKmalloc(l);
	}
	snprintf(*s,l,"\"%s\"",src);
	*len = l-1;
	return *len;
}

str URLgetAnchor( str *retval, str *Str1 ){
	char *s,*d;

	if( *Str1 == 0) return throwMessage("url.getAnchor", "no string");
	s= strchr(*Str1,'#');
	if( s ==0 ){
		d= GDKmalloc(strlen(str_nil)+1);
		if(d) strcpy(d,str_nil);
	} else {
		d= GDKmalloc(strlen(s)+1);
		if(d) strcpy(d,s);
	}
	*retval =d;
	return MAL_SUCCEED;
}
str URLgetBasename(str *retval, str *t){
        char *d =0, *s;
	if( *t == 0) return throwMessage("url.getBasename", "no string");
	s= strrchr(*t,'/');
	if( s) s++; else s= str_nil;
	d= GDKmalloc(strlen(s)+1);
	if(d) strcpy(d,s);
	s= strchr(d,'.');
	if( s) *s = 0;
	*retval = d;
	return MAL_SUCCEED;
}

str URLgetContent( str *retval, str *Str1){
	*retval = 0;
	return throwMessage("url.getContent", "not yet implemented");
}

str URLgetContext(str *retval, str *Str1){
	char *s,*d;

	if( *Str1 == 0) return throwMessage("url.getContext", "no string");
	s= strchr(*Str1,'/');
	if( s ==0 ){
		d= GDKmalloc(strlen(str_nil)+1);
		if(d) strcpy(d,str_nil);
	} else {
		int i = s- *Str1 +1;
		d= GDKmalloc(i+1);
		if(d) strncpy(d,s,i);
	}
	*retval =d;
	return MAL_SUCCEED;
}
str URLgetDirectory(int *ret, str *tv){
        static char buf[1024];
        char *d,*s;
	int i=0, k=0;
	BAT *b;
	str t= *tv;

	if( t == 0) return throwMessage("url.getDirectory", "no string");

        while( *t && *t != ':') t++;
        t++; if( *t != '/') goto getDir_done;
        t++; if( *t != '/') goto getDir_done;
        t++;  
        while( *t && *t != '/') t++;
	b= BATnew(TYPE_int,TYPE_str,40);
	if( b == 0) return throwMessage("url.getDirectory", "GDKerror");

        s= buf; 
        for(t++  ; *t  ; t++){
		if( *t == '/') {
			*s = 0;
			BUNins(b, &k, buf);
			k++;
			s= buf;
			*s =0; i=0;
			continue;
		}
		*s++ = *t;
		if( i++ == 1023) {
			GDKwarning("URLgetDirectory:server name too long\n");
			break;
		}
        }
getDir_done:
        @:Pseudo(dir,name)@
	*ret= b->batCacheid;
	return MAL_SUCCEED;
}

str URLgetDomain( str *retval, str *tv){
        static char buf[1024];
        char *b,*d,*s=buf;
	int i=0;
	str t = *tv;

	*retval = 0;
	s = str_nil;
	if( t == 0) return throwMessage("url.getDomain", "no string");
        while( *t && *t != ':') t++;
        t++; if( *t != '/') goto getDomain_done;
        t++; if( *t != '/') goto getDomain_done;
        t++;  
        b= buf; d = 0;
        for( ; *t && *t !='/'; t++){
                if( *t == '.') d=b;
		if( *t == ':') break;
		*b++ = *t;
		if( i++ == 1023) {
			GDKwarning("URLgetDomain:server name too long\n");
			break;
		}
        }
        *b =0;
	if( d ) s= d+1;
getDomain_done:
	d= GDKmalloc(strlen(s)+1);
	if(d) strcpy(d,s);
	*retval = d;
	return MAL_SUCCEED;
}

str URLgetExtension( str *retval, str *tv){
        char *d =0, *s;
	str t= *tv;
	if( t == 0) return throwMessage("url.getExtension", "no string");
	s= strrchr(t,'/');
	if( s) {
		s++; 
		s= strchr(s+1,'.');
		if( s ) s++; else s= str_nil;
	} else s= str_nil;
	d= GDKmalloc(strlen(s)+1);
	if(d) strcpy(d,s);
	*retval = d;
	return MAL_SUCCEED;
}

str URLgetFile(str *retval, str *tv){
        char *d =0, *s;
	str t= *tv;
	if( t == 0) return throwMessage("url.getFile", "no string");
	s= strrchr(t,'/');
	if( s) s++; else s= str_nil;
	d= GDKmalloc(strlen(s)+1);
	if(d) strcpy(d,s);
	*retval = d;
	return MAL_SUCCEED;
}

@+ Url_getHost
Extract the server identity from the URL
SIGNATURE: getHost(str) : str; 
@c
str URLgetHost(str *retval, str *tv){
        static char buf[1024];
        char *b, *d,*s;
	int i=0;
	str t= *tv;
	s= str_nil;
	if( t == 0) return throwMessage("url.getHost", "no string");
        while( *t && *t != ':') t++;
        t++; if( *t != '/') goto getHost_done;
        t++; if( *t != '/') goto getHost_done;
        t++;  
        b= buf; s= buf;
        for( ; *t && *t !='/'; t++){
                *b++ = *t;
		if( i++ == 1023) {
			GDKwarning("URLgetHosterver:server name too long\n");
			break;
		}
        }
        *b =0;
getHost_done:
	d= GDKmalloc(strlen(s)+1);
	if(d) strcpy(d,s);
	*retval = d;
	return MAL_SUCCEED;
}

@+ URLgetPort
 Extract the port id from the URL SIGNATURE: getPort(str) : str; 
@c
str URLgetPort(str *retval, str *tv){
        char buf[1024];
        char *b,*d =0, *s=buf;
	int i=0;
	str t= *tv;
	if( t == 0) return throwMessage("url.getPort", "no string");
        s= str_nil;
        while( *t && *t != ':') t++;
        t++; if( *t != '/') goto getPort_done;
        t++; if( *t != '/') goto getPort_done;
        t++;  
        b= buf;
        for( ; *t && *t !='/'; t++){
                if( *t== ':') d=b;
                *b++ = *t;
		if( i++ == 1023) {
			GDKwarning("URLgetPort:server name too long\n");
			break;
		}
        }
        *b =0;
	if( d ) s= d+1; else  s = str_nil; 
getPort_done:
	d= GDKmalloc(strlen(s)+1);
	if(d) strcpy(d,s);
	*retval = d;
	return MAL_SUCCEED;
}

str URLgetProtocol(str *retval, str *tv){
        static char buf[1024];
        char *b,*d =0, *s=buf;
	int i=0;
	str t= *tv;

	if( t == 0) return throwMessage("url.getProtocol", "no string");
	b= buf;
        for( ; *t && *t !=':'; t++){
                *b++ = *t;
		if( i++ == 1023) {
			GDKwarning("URLgetProtocol:server name too long\n");
			break;
		}
        }
        *b =0;
	d= GDKmalloc(strlen(buf)+1);
	if(d) strcpy(d,buf);
	*retval = d;
	return MAL_SUCCEED;
}

str URLgetQuery(str *retval,  str *tv){
	char *s,*d;
	str Str1= *tv;

	if( Str1 == 0) return throwMessage("url.getQuery", "no string");
	s= strchr(Str1,'?');
	if( s ==0 ){
		d= GDKmalloc(strlen(str_nil)+1);
		if(d) strcpy(d,str_nil);
	} else {
		s++;
		d= GDKmalloc(strlen(s)+1);
		if(d) strcpy(d,s);
	}
	*retval =d;
	return MAL_SUCCEED;
}
str URLgetQueryArg(int *ret, str *tv){
	char query[1024];
        char val[1024];
        char name[1024];
	BAT *b;
	str t= *tv;

	if( t == 0) return throwMessage("url.getQueryArg", "no string");
	t= strchr(t,'?');
	if( t == 0) return throwMessage("url.getQueryArg", "no query arguments");
	t++;

	b= BATnew(TYPE_str,TYPE_str,40);
	if( b == 0) return throwMessage("url.getQueryArg", "GDKerror");
	if(strlen(t) >1023) 
		return throwMessage("url.getQueryArg", "string too long");
	strcpy(query,t);

	for(; query[0] != '\0';) {
		getword(val,query,'&');
		plustospace(val);
		unescape_url(val);
		getword(name,val,'=');
		BUNins(b, name, val);
	}
        @:Pseudo(dir,name)@
	*ret= b->batCacheid;
	return MAL_SUCCEED;
}

str URLgetRobotURL(str *retval, str *tv){
        static char buf[1024];
        char *b, *d,*s = buf;
	int i=0;
	str t = *tv;
	if( t == 0) return throwMessage("url.getRobotURL", "no string");
        b= buf; 
        while( *t && *t != ':') *b++ = *t++;
        *b++ = *t++; if( *t != '/') goto getRobot_done;
        *b++ = *t++; if( *t != '/') goto getRobot_done;
        *b++ = *t++;  
        for( ; *t && *t !='/'; t++){
                *b++ = *t;
		if( i++ == 980) {
			GDKwarning("URLgetRobot:server name too long\n");
			break;
		}
        }
	strcpy(b,"/robots.txt");
getRobot_done:
	d= GDKmalloc(strlen(s)+1);
	if(d) strcpy(d,s);
	*retval = d;
	return MAL_SUCCEED;
}


str URLgetUser(str *retval, str *tv){
        static char buf[1024];
        char *b,*d =0, *s;
	int i=0;
	str t= *tv;

	if( t == 0) return throwMessage("url.getUser", "no string");
	s= str_nil;
        while( *t && *t != ':') t++;
        t++; if( *t != '/') goto getUser_done;
        t++; if( *t != '/') goto getUser_done;
        t++;  
        for( ; *t && *t !='/'; t++);
	t++;
	if( *t == '~') {
	t++;
        b= buf;
	s= buf;
        for( ; *t && *t !='/'; t++){
                *b++ = *t;
		if( i++ == 1023) {
			GDKwarning("URLgetUser:server name too long\n");
			break;
		}
        }
        *b =0;
	}
getUser_done:
	d= GDKmalloc(strlen(s)+1);
	if(d) strcpy(d,s);
	*retval = d;
	return MAL_SUCCEED;
}
str URLisaURL( bit *retval, str *tv){
	str Str1= *tv;
	if( tv == 0) return throwMessage("url.isaURL", "no string");
	return throwMessage("url.isaURL", "not yet implemented");
}

str URLnew( str *url, str *Str1 ){
	*url= GDKstrdup(*Str1);
	return MAL_SUCCEED;
}
str URLnew3(str *url, str *protocol, str *server, str *file){
	str Protocol;
	str Server;
	str File;
	int l,i;

	l= GDK_STRLEN(*file)+ GDK_STRLEN(*server)+GDK_STRLEN(*protocol)+10;
	*url= (str) GDKmalloc(l);
	snprintf(*url,l,"%s://",*protocol);
	i= strlen(*url);
	snprintf(*url+i,l-i,"%s",*server);
	i= strlen(*url);
	snprintf(*url+i,l-i,"/%s",*file);
	return MAL_SUCCEED;
}

str URLnew4(str *url, str *protocol, str *server, int *port, str *file){
	str Protocol;
	str Server;
	str File;
	int l,i;

	if( GDK_STRNIL(file)) File="";
	if( GDK_STRNIL(server)) Server="";
	if( GDK_STRNIL(protocol)) Protocol="";
	l= strlen(File)+ strlen(Server)+strlen(Protocol)+20;
	*url= (str) GDKmalloc(l);
	snprintf(*url,l,"%s://",*Protocol);
	i= strlen(*url);
	snprintf(*url+i,l-i,"%s",*Server);
	i= strlen(*url);
	snprintf(*url+i,l-i,":%d",*port);
	i= strlen(*url);
	snprintf(*url+i,l-i,"/%s",*File);
	return MAL_SUCCEED;
}
@+ Utilities
@c

#define LF 10
#define CR 13

void getword(char *word, char *line, char stop) {
    int x = 0,y;

    for(x=0;((line[x]) && (line[x] != stop));x++)
        word[x] = line[x];

    word[x] = '\0';
    if(line[x]) ++x;
    y=0;

    while(line[y++] = line[x++]);
}

char *makeword(char *line, char stop) {
    int x = 0,y;
    char *word = (char *) malloc(sizeof(char) * (strlen(line) + 1));

    for(x=0;((line[x]) && (line[x] != stop));x++)
        word[x] = line[x];

    word[x] = '\0';
    if(line[x]) ++x;
    y=0;

    while(line[y++] = line[x++]);
    return word;
}

char x2c(char *what) {
    char digit;

    digit = (what[0] >= 'A' ? ((what[0] & 0xdf) - 'A')+10 : (what[0] - '0'));
    digit *= 16;
    digit += (what[1] >= 'A' ? ((what[1] & 0xdf) - 'A')+10 : (what[1] - '0'));
    return(digit);
}

char *escape_url(char *url) {
   int x,y;
   char *res;

   if(!url) return NULL;

   res=(char*)malloc(200);
   for(x=0,y=0;url[x];++x,++y) {
       sprintf(&res[y],"%%%2x",url[x]);
       y+=2; 
   }
   res[y]='\0';
   return res;
}
 
void unescape_url(char *url) {
    int x,y;

    for(x=0,y=0;url[y];++x,++y) {
        if((url[x] = url[y]) == '%') {
            url[x] = x2c(&url[y+1]);
            y+=2;
        }
    }
    url[x] = '\0';
}

void plustospace(char *str) {
    int x;

    for(x=0;str[x];x++) if(str[x] == '+') str[x] = ' ';
}
@}

