@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f enum
@a Peter Boncz, Martin Kersten
@v 2.0
@* Encoding/Decoding
When large sets of data are stored and memory is short, one 
seeks for memory occupation optimizations.
One way to do this when the cardinality is low, is to substitute
the datatype to a smaller ordinal datatype. For instance, when 
less than 256 different string values occur in an attribute, one 
could store them as a byte. 
Further space optimizations into values smaller than a byte are
impossible in MonetDB, since all values need to have a unique memory address.
@{
Though it may by a problem to waste memory, one should also realize that 
main-memory databases suffer increasingly when the data representation gets 
more complex. This is obviously true for complex compression schemes, but 
even loading a single byte value is considerably slower on custom CPUs
than loading an entire 32-bit integer. On 64-bits architectures, this 
will even be the case for long 64-bit integers. 
@}

The prototypical use of the enum facility runs as follows.
The user starts with collecting the values of interest in 
a (persistent) BAT.  
Then the operation enum.encode(B)(Bn,E)
creates an encoding table E large enough to hold the encoded value
and maps the original BAT into its smaller representation Bn.
Once an encoding table E is known, any BAT can be encoded using
enum.encode(B,E)
The original table B can be recovered using enum.decode(Bn,E), which
actually performs join(Bn,E) and performs a check on missing encoding values.

This module supports encodings using 'chr' (1-byte encoding),
and 'sht' (2-byte encoding).

[TODO implementation has to match the documentation]
@mal
atom enum:int;
module enum;

pattern create(e:any$2, src:bat[:any,:any$1]) :bat[:any$1,:any$2]	
address ENUMcreate
comment "Associate a value set with an enumerated type.";

pattern loadEncoding(map:any$1):bat[:any,:any$1] 
address ENUMload
comment "Load/activate an enumeration type.";

pattern destroy(map:any):void 
address ENUMdestroy
comment "Destroy an enumeration type";

pattern encode(e:any$1,v:any$2):any$1 
address ENUMencode
comment "Encode a value using a small map";

pattern encode(e:any$2,b:bat[:any$1,:any]) :bat[:any$1,:any$2] 	
address ENUMencode_multi
comment "Encode a BAT of tail values into a new BAT of encoded values.
        This action is actually a join operation.";

pattern lower(e:any$1, v:any):any$1 
address ENUMlower
comment "Encode to the lowest value in the encoded 
	domain that is equal to or larger than v";

pattern upper(e:any$1, v:any):any$1 
address ENUMupper
comment "Encode to the highest value in the encoded domain that is 
	equal to or less than v";

pattern decode(e:any):any 	
address ENUMdecode
comment "Decode a value";

pattern decode(b:bat[:any$2,:any$1]) :bat[:any$2,:any] 	
address ENUMdecode_multi
comment "Decode a BAT of tail values
	into a new BAT of decoded values";

pattern getTable(e:any) :bat[:any,:any] 
address ENUMtable
comment "Return the enumeration BAT";

command isEnum(tpe:bat[:any,:any]) :bit 
address isEnum
comment "Returns true iff the bat is used as an enumerated type";

pattern setHistogram(tpe:any$1, b:bat[:any,:any]):void 			
address ENUMsethisto
comment "registers the fact that ENUMtable(tpe) 
	is a histogram on b's head column";

pattern isHistogram(tpe:any,b:bat[:any,:any]) :bit 			
address ENUMishisto
comment "is ENUMtable(tpe) a histogram on b's head column";
@-
@{
@include prelude.mx
@+ Implementation
Note that we have to build the table with pre-instantiated
function references, because there is no easy way from the GDK layer
to access the enum administration.
@= enumCheck
{	str tname= getTypeName(@1);
	b= (BAT*) BBPgetdesc(BBPindex(tname));
	if( b==0)
	return throwException(MALEXCEPTION,"enum.@2","illegal enum type.");
}
@-
old
     for(xx=0; xx<MAX_ENUM; xx++)
	if (ENUMtpe[xx] == @1) break;
     if ((xx>MAX_ENUM) || ((b=BBPdescriptor(ENUMmap[xx])) == NULL)) {
	return throwException(MALEXCEPTION,"enum.@2","illegal enum type.");
     }
     (void)b;	/* keep compilers happy */
}
@c
#include "gdk.h"
#include "mal_client.h"
#include "io.h"
#include "mal.h"

typedef int (*fcn)();

#define MAX_ENUM 80

bat ENUMmap[MAX_ENUM] = { 0 };
oid ENUMhisto[MAX_ENUM] = { 0 };
int ENUMtpe[MAX_ENUM] = { -1 };

@:block(chr,char)@
@:block(sht,short)@
@:imp(0)@	@:imp(1)@	@:imp(2)@	@:imp(3)@ 	@:imp(4)@
@:imp(5)@	@:imp(6)@	@:imp(7)@	@:imp(8)@ 	@:imp(9)@
@:imp(10)@	@:imp(11)@	@:imp(12)@	@:imp(13)@ 	@:imp(14)@
@:imp(15)@	@:imp(16)@	@:imp(17)@	@:imp(18)@ 	@:imp(19)@
@:imp(20)@	@:imp(21)@	@:imp(22)@	@:imp(23)@ 	@:imp(24)@
@:imp(25)@	@:imp(26)@	@:imp(27)@	@:imp(28)@ 	@:imp(29)@
@:imp(30)@	@:imp(31)@	@:imp(32)@	@:imp(33)@ 	@:imp(34)@
@:imp(35)@	@:imp(36)@	@:imp(37)@	@:imp(38)@ 	@:imp(39)@
@:imp(40)@	@:imp(41)@	@:imp(42)@	@:imp(43)@ 	@:imp(44)@
@:imp(45)@	@:imp(46)@	@:imp(47)@	@:imp(48)@ 	@:imp(49)@
@:imp(50)@	@:imp(51)@	@:imp(52)@	@:imp(53)@ 	@:imp(54)@
@:imp(55)@	@:imp(56)@	@:imp(57)@	@:imp(58)@ 	@:imp(59)@
@:imp(60)@	@:imp(61)@	@:imp(62)@	@:imp(63)@ 	@:imp(64)@
@:imp(65)@	@:imp(66)@	@:imp(67)@	@:imp(68)@ 	@:imp(69)@
@:imp(70)@	@:imp(71)@	@:imp(72)@	@:imp(73)@ 	@:imp(74)@
@:imp(75)@	@:imp(76)@	@:imp(77)@	@:imp(78)@ 	@:imp(79)@

fcn ENUMconv[MAX_ENUM*4+1] = { 
@:def(0)@	@:def(1)@	@:def(2)@	@:def(3)@ 	@:def(4)@
@:def(5)@	@:def(6)@	@:def(7)@	@:def(8)@ 	@:def(9)@
@:def(10)@	@:def(11)@	@:def(12)@	@:def(13)@ 	@:def(14)@
@:def(15)@	@:def(16)@	@:def(17)@	@:def(18)@ 	@:def(19)@
@:def(20)@	@:def(21)@	@:def(22)@	@:def(23)@ 	@:def(24)@
@:def(25)@	@:def(26)@	@:def(27)@	@:def(28)@ 	@:def(29)@
@:def(30)@	@:def(31)@	@:def(32)@	@:def(33)@ 	@:def(34)@
@:def(35)@	@:def(36)@	@:def(37)@	@:def(38)@ 	@:def(39)@
@:def(40)@	@:def(41)@	@:def(42)@	@:def(43)@ 	@:def(44)@
@:def(45)@	@:def(46)@	@:def(47)@	@:def(48)@ 	@:def(49)@
@:def(50)@	@:def(51)@	@:def(52)@	@:def(53)@ 	@:def(54)@
@:def(55)@	@:def(56)@	@:def(57)@	@:def(58)@ 	@:def(59)@
@:def(60)@	@:def(61)@	@:def(62)@	@:def(63)@ 	@:def(64)@
@:def(65)@	@:def(66)@	@:def(67)@	@:def(68)@ 	@:def(69)@
@:def(70)@	@:def(71)@	@:def(72)@	@:def(73)@ 	@:def(74)@
@:def(75)@	@:def(76)@	@:def(77)@	@:def(78)@ 	@:def(79)@
0 };

@= def
	enum@1chrTostr, enum@1chrFromstr, enum@1shtTostr, enum@1shtFromstr,
@= block
int enum@1Tostr(int mapid, str* dst, int* len, @1* src){
	int l; ptr v; 
	BAT *b = BATdescriptor(ENUMmap[mapid]);

	if (*src == @1_nil) {
		v = ATOMnilptr(b->htype);
	} else {
		BUN p = BUNptr(b, 1 + *(unsigned @2*) src); 
		v = BUNhead(b,p);
	}
	if (b->htype != TYPE_str) {
		fcn tostr = BATatoms[b->htype].atomToStr;
		l= (*tostr)(dst, len, v);
		BBPunfix(b->batCacheid);
		return l;
	}
	l = strLen(v);
	if (*len < l) {
		if (*dst) GDKfree(*dst);
		*dst = (char*) GDKmalloc(*len = l);
	}
	memcpy(*dst, v, l);
	BBPunfix(b->batCacheid);
	return (l-1);  /* return string length excluding eos */
}
int enum@1Fromstr(int mapid, str src, int* l1, @1** dst){
	unsigned int len= *l1;
	int r, l = 0;
	BUN p; ptr v;
	BAT *b = BATdescriptor(ENUMmap[mapid]);

	if (b->htype != TYPE_str) {
		fcn fromstr = BATatoms[b->htype].atomFromStr;
 		v = (ptr) GDKmalloc(l=32);
		r = (*fromstr)(src, &l, &v);
	} else {
		r = strlen(src); 
		v = src;
	}
	if (len < sizeof(@1)) {
		*dst = (@1*) GDKmalloc(len = sizeof(@1));
	}
	if ((p = SORTfnd(b, v)) != NULL) {
		**(unsigned @2**) dst = BUNindex(b,p)-1;
	} else {
		**dst = @1_nil;
	}
	if (l) GDKfree(v);
	BBPunfix(b->batCacheid);
	return r;
}
@-
@c
@= imp
	@:template(@1,chr,char)@ @:template(@1,sht,short)@
@= template
static int enum@1@2Tostr(char** dst, int* len, @2* src){
	return enum@2Tostr(@1,dst,len,src);
}
static int enum@1@2Fromstr(@2** src, int* len, str dst){
	return enum@2Fromstr(@1, dst,len, src);
}
@c
int ENUMatom(int i, BAT *h){
	str name= h->batId;
	if (BATcount(h) > 255) {
		ATOMproperty(name, "storage", (GDKfcn) TYPE_sht); 
		ATOMproperty(name, "tostr", ENUMconv[i*4+2]);
		ATOMproperty(name, "fromstr", ENUMconv[i*4+3]);
	} else {
		ATOMproperty(name, "storage", (GDKfcn) TYPE_chr); 
		ATOMproperty(name, "tostr", ENUMconv[i*4]);
		ATOMproperty(name, "fromstr", ENUMconv[i*4+1]);
	}
	ENUMtpe[i] = ATOMindex(name);
	ENUMmap[i] = h->batCacheid;
	BBPincref(h->batCacheid,TRUE);
	return ENUMtpe[i];
}
str ENUMreload(int *retval, int bid) {
	int i;
	BAT *h;

    if( (h= BATdescriptor(bid)) == NULL ){
         return throwMessage("enum.load", "Cannot access descriptor");
    }

	mal_set_lock(mal_contextLock, "ENUMload");
	for(i=0; i<MAX_ENUM; i++) {
		if (ENUMmap[i] == 0) {
			char *name = h->batId;
			if (BATcount(h) > 255) {
				ATOMproperty(name, "storage", (GDKfcn) TYPE_sht); 
				ATOMproperty(name, "tostr", ENUMconv[i*4+2]);
				ATOMproperty(name, "fromstr", ENUMconv[i*4+3]);
			} else {
				ATOMproperty(name, "storage", (GDKfcn) TYPE_chr); 
				ATOMproperty(name, "tostr", ENUMconv[i*4]);
				ATOMproperty(name, "fromstr", ENUMconv[i*4+1]);
			}
			ENUMtpe[i] = ATOMindex(name);
			ENUMmap[i] = h->batCacheid;
			BBPincref(h->batCacheid,TRUE);
			*retval = h->batCacheid;
			mal_unset_lock(mal_contextLock, "ENUMload");
			BBPunfix(h->batCacheid);
			return MAL_SUCCEED;
		}
	}
	mal_unset_lock(mal_contextLock, "ENUMload");
	BBPunfix(h->batCacheid);
	return throwMessage("enum.load"," too many active enum types.");
}

str ENUMcreate(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	BAT *h,*b;
	ptr nil;
	int *retval,hid,bid; str ret;
	int tpe;
	str name;

	retval = (int*) getArgReference(stk,pci,0);
	tpe= getArgType(mb,pci,1);
	bid= *(int*) getArgReference(stk,pci,2);
	name= getTypeName(tpe);
    if( (b= BATdescriptor(bid)) == NULL ){
         return throwMessage("enum.create", "Cannot access descriptor");
    }
	h = BAThistogram(b);
	nil = ATOMnilptr(b->htype);
	BUNdelHead(h, nil);
	BATorder(h);
	BATrename(h, name);
/*
	BATmode(h, PERSISTENT);
	BBPsave(h);
*/
	hid= h->batCacheid;
	ret= ENUMreload(retval, hid);
	GDKfree(name);
	BBPunfix(b->batCacheid);
	return ret;
}
str ENUMload(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	int tpe, *retval;
	str ret;
	str name;

	tpe= getArgType(mb,pci,1);
	name= getTypeName(tpe);
	retval= (int*) getArgReference(stk,pci,0);
	*retval= BBPindex(name);
	if( *retval ==0)
		return throwMessage("enum.load"," encoding BAT does not exist.");
	ret= ENUMreload(retval,*retval);
	GDKfree(name);
	return ret;
}

str ENUMdestroy(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	BAT *b;
	int xx = 0;
	int tpe;

	(void) stk; /* fool compiler */
	tpe= getArgType(mb,pci,1);
	@:enumCheck(tpe, ENUMdestroy)@
	mal_set_lock(mal_contextLock, "ENUMdestroy");
	ATOMdelete(tpe);
	BBPunfix(ENUMmap[xx]);
	ENUMhisto[xx] = 0;
	ENUMmap[xx] = 0;
	ENUMtpe[xx] = 0;
	mal_unset_lock(mal_contextLock, "ENUMdestroy");
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}
@-
The result of an encode/lower/upper step is stored in the 
receiving variable.
@= encoding
	if( ATOMstorage(tpe)== TYPE_chr){
		if (p == NULL) *(chr*) dst = chr_nil; 
		else *(unsigned char*) dst = BUNindex(b,p) - 1;
	} else {
		if (p == NULL) *(sht*) dst = sht_nil; 
		else *(unsigned short*) dst = BUNindex(b,p) - 1;
	}
@c
str ENUMencode(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	BAT *b;
	ptr p,src,dst;
	int tpe;

	tpe= getArgType(mb,pci,1);
	@:enumCheck(tpe,ENUMencode)@
	src= *(ptr*) getArgReference(stk,pci,2);
	dst= (ptr) getArgReference(stk,pci,0);
	p = BUNfnd(b, src);
	@:encoding@
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}
str ENUMlower(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	int tpe;
	BUN p,src,dst;
	BAT *b;
	
	tpe= getArgType(mb,pci,1);
	src= *(ptr*) getArgReference(stk,pci,2);
	dst= (ptr) getArgReference(stk,pci,0);
	@:enumCheck(tpe,ENUMlower)@
	if (!ATOMlinear(b->htype)){
		BBPunfix(b->batCacheid);
	 	return throwMessage("enum.lower"," incompatible source type.");
	}
	if (BAThordered(b)&1) {
		p = SORTfndlast(BATmirror(b), src);
		if (p && p > BUNfirst(b))  p -= BUNsize(b);
		else p = NULL;
	} else {
		BATidx(b, NULL);
		p = (BUN) IDXfndlast(b, src);
		if (p && p > (BUN) b->hidx.first) p = ((BUN*) p)[-1];
		else p = NULL;
	}
	@:encoding@
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
} 

str ENUMupper(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	int tpe;
	BUN p,src,dst;
	BAT *b;
	
	tpe= getArgType(mb,pci,1);
	src= *(ptr*) getArgReference(stk,pci,2);
	dst= (ptr) getArgReference(stk,pci,0);
	@:enumCheck(tpe,ENUMlower)@
	if (!ATOMlinear(b->htype)){
		if(b) BBPunfix(b->batCacheid);
	 	return throwException(MALEXCEPTION,"enum.upper",
			"incompatible source type.");
	}
	if (BAThordered(b)&1) {
		p = SORTfndfirst(BATmirror(b), src);
	} else {
		BATidx(b,NULL);
		p = (BUN) IDXfndfirst(b, src);
		if (p) p = *(BUN*) p;
	}
	@:encoding@
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
} 

str ENUMdecode(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	int tpe;
	BUN p,src, *dst;
	BAT *b;
	
	tpe= getArgType(mb,pci,1);
	src= *(ptr*) getArgReference(stk,pci,1);
	dst= (ptr) getArgReference(stk,pci,0);
	@:enumCheck(tpe,ENUMlower)@

	if( b->htype != getArgType(mb,pci,0)){
		if(b) BBPunfix(b->batCacheid);
		return throwMessage("enum.decode","incompatible source type");
	}
	if( ATOMstorage(tpe) == TYPE_chr){
		if (*(chr*) src == chr_nil) p = ATOMnilptr(b->htype);
		else p = BUNhead(b, BUNptr(b, 1 + *(unsigned char*)src));
	} else{
		if (*(sht*) src == sht_nil) p = ATOMnilptr(b->htype);
		else p = BUNhead(b, BUNptr(b, 1 + *(unsigned short*)src));
	}
	
	if (b->hvarsized) {
		int l = ATOMlen(b->htype, p); 
		* (ptr*)dst =  (ptr*) GDKmalloc(l);
		memcpy(*(ptr*)dst, p, l);
	} else {
		memcpy(dst, p, ATOMsize(b->htype));
	}
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}


#define HASHfnd_loc(r,b,p) r = BUNfnd(b,p)
#define HASHfnd_var(r,b,p) r = BUNfnd(b,p)

@= encode
{ 	BAT *bn = BATnew(src->htype, tpe, BATcount(src)); 
	BUN p,q,r; int xx;
	unsigned @2 idx;
	
	if (BAThordered(b)&1) {
	    BATloopFast(src, p, q, xx) {
		BUN r = (BUN) SORTfnd@4(b, BUNt@3(src,p));
		if (r == NULL) {
			idx = @1_nil; 
		} else {
			idx = BUNindex(b,r) - 1;
		}
		BUNfastins(bn, BUNhead(src,p), &idx); 
	    } 
	} else {
	    BATloopFast(src, p, q, xx) {
		HASHfnd@4(r, b, BUNt@3(src,p));
		if (r == NULL) {
			idx = @1_nil; 
		} else {
			idx = BUNindex(b,r) - 1;
		}
		BUNfastins(bn, BUNhead(src,p), &idx); 
	    } 
	} 
	*retval = bn->batCacheid;
	bn->tsorted = 0;
	ALIGNsetH(bn, src);
} break;
@c
str ENUMencode_multi(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	BAT *b,*src;
	int bid,*retval;
	int tpe;

	tpe= getArgType(mb,pci,1);
	@:enumCheck(tpe,ENUMencode_multi)@
	bid= *(int*) getArgReference(stk,pci,2);
	retval= (int*) getArgReference(stk,pci,0);
    if( (src= BATdescriptor(bid)) == NULL ){
         return throwMessage("enum.encode", "Cannot access descriptor");
    }

	if (src->ttype != b->htype) {
		BBPunfix(b->batCacheid);
		BBPunfix(src->batCacheid);
	 	return throwMessage("enum.encode"," incompatible types");
	}
	if (ATOMstorage(tpe) == TYPE_chr) { 
	    switch(ATOMstorage(src->ttype)) {
	    case TYPE_void: 
			BBPunfix(b->batCacheid);
			BBPunfix(src->batCacheid);
			return throwMessage("enum.encode"," illegal tail type");
	    case TYPE_chr:	@:encode(chr,char,loc,_chr)@
	    case TYPE_sht:	@:encode(chr,char,loc,_sht)@
	    case TYPE_int:	@:encode(chr,char,loc,_int)@
	    case TYPE_flt:	@:encode(chr,char,loc,_flt)@
	    case TYPE_lng:	@:encode(chr,char,loc,_lng)@
	    case TYPE_dbl:	@:encode(chr,char,loc,_dbl)@
	    default:if(src->tvarsized) {
				@:encode(chr,char,var,_var)#
		    } else {
				@:encode(chr,char,loc,_loc)#
	    }	    }
	} else {
	    switch(ATOMstorage(src->ttype)) {
	    case TYPE_void: 
			BBPunfix(b->batCacheid);
			BBPunfix(src->batCacheid);
			return throwMessage("enum.encode"," illegal tail type");
	    case TYPE_chr:	@:encode(sht,short,loc,_chr)@
	    case TYPE_sht:	@:encode(sht,short,loc,_sht)@
	    case TYPE_int:	@:encode(sht,short,loc,_int)@
	    case TYPE_flt:	@:encode(sht,short,loc,_flt)@
	    case TYPE_lng:	@:encode(sht,short,loc,_lng)@
	    case TYPE_dbl:	@:encode(sht,short,loc,_dbl)@
	    default:if(src->tvarsized) {
				@:encode(sht,short,var,_var)#
		    } else {
				@:encode(sht,short,loc,_loc)#
	    }	    }
	}
	BBPincref(b->batCacheid,TRUE);
	BBPunfix(b->batCacheid);
	BBPunfix(src->batCacheid);
	return MAL_SUCCEED;
} 

@= decode
{	BAT *bn = BATnew(src->htype, b->htype, BATcount(src)); 
	BUN p,q; int xx;
	ptr w,nil = ATOMnilptr(b->htype);
	
	BATloopFast(src, p, q, xx) {
		unsigned @2 *idx = (unsigned @2*) BUNtloc(src,p);
		if (*(@1*) idx == chr_nil) {
			w = nil;
		} else {
			w = BUNhead(b, BUNptr(b, 1 + *idx));
		}
		BUNfastins(bn, BUNhead(src,p), w); 
		
	} 
	*retval = bn->batCacheid;
}
@c
str ENUMdecode_multi(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	BAT *b,*src;
	int *bid,*retval;
	int tpe;

	(void) mb; /* fool compiler */
	bid= (int*) getArgReference(stk,pci,1);
	retval= (int*) getArgReference(stk,pci,0);
    if( (src= BATdescriptor(*bid)) == NULL ){
         return throwMessage("enum.decode", "Cannot access descriptor");
    }
	tpe= src->ttype;
	@:enumCheck(tpe,ENUMencode_multi)@
	if(b) BBPunfix(b->batCacheid);
	if (ATOMstorage(tpe) == TYPE_chr) { 
	    @:decode(chr,char)@
	} else if (ATOMstorage(tpe) == TYPE_sht) { 
	    @:decode(sht,short)@
	} else
	    return throwMessage("enum.decode"," illegal tail type.");
	BBPunfix(src->batCacheid);
	return MAL_SUCCEED;
}

int ENUMchktpe(int tpe) {
	int i;
	for(i=0; i<MAX_ENUM; i++)
		if (ENUMtpe[i] == tpe) return TRUE;
	return FALSE;
}

int ENUMisTable(BAT *b, int tpe){
	if( b->ttype== tpe)
		return ENUMchktpe(tpe);
	return FALSE;
}
str ENUMtable(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	BAT *b;
	int *retval;
	int tpe;
	str tname;

	tpe= *(int*) getArgReference(stk,pci,1);
	(void) tpe; /* fool user */
	retval= (int*) getArgReference(stk,pci,0);

	tname= getTypeName(getArgType(mb,pci,1));
        b= (BAT*) BBPgetdesc(BBPindex(tname));
        if( b == NULL)
		return throwMessage("enum.getTable","cannot access type table");
	*retval = b->batCacheid;
	return MAL_SUCCEED;
}

str isEnum(bit *ret, int *bid){
	BAT *b;
	int i;
	*ret= FALSE;
    if( (b= BATdescriptor(*bid)) == NULL ){
         return throwMessage("enum.isEnum", "Cannot access descriptor");
    }
	for(i=0; i<MAX_ENUM; i++)
		if (ENUMmap[i] == b->batCacheid) { *ret= TRUE;break;}
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

str ENUMsethisto( MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	BAT *b,*column;
	int xx = 0;
	int tpe,bid;
	str tname;

	tpe= *(int*) getArgReference(stk,pci,1);
	(void) tpe; /* fool compiler */
	bid= *(int*) getArgReference(stk,pci,2);

	tname= getTypeName(xx=getArgType(mb,pci,1));
	b= (BAT*) BBPgetdesc(BBPindex(tname));
	if( b == NULL)
		return throwMessage("enum.setHisto","cannot access type table");
    if( (column= BATdescriptor(bid)) == NULL ){
         return throwMessage("enum.setHisto", "Cannot access descriptor");
    }
	if (column->halign == 0) {
		column->halign = OIDnew(1);
		column->batDirtydesc = TRUE;
	}
	ENUMhisto[xx] = column->halign;
	BBPunfix(b->batCacheid);
	BBPunfix(column->batCacheid);
	return MAL_SUCCEED;
}

str ENUMishisto(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	BAT *b,*column;
	int xx;
	bit *retval;
	int tpe,*bid;
	str tname;

	tpe= *(int*) getArgReference(stk,pci,1);
	(void) tpe; /* fool compiler */
	bid= (int*) getArgReference(stk,pci,2);
	retval= (bit*) getArgReference(stk,pci,0);

	tname= getTypeName(xx= getArgType(mb,pci,1));
	b= (BAT*) BBPgetdesc(BBPindex(tname));
	if( b == NULL)
		return throwMessage("enum.setHisto","cannot access type table");
    if( (column= BATdescriptor(*bid)) == NULL ){
         return throwMessage("enum.isHisto", "Cannot access descriptor");
    }
    if( (column= BATdescriptor(*bid)) == NULL ){
         return throwMessage("enum.isEnum", "Cannot access descriptor");
    }
	*retval = (ENUMhisto[xx] == column->halign);
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

str ENUMepilogue() {
	int xx;
	for(xx=0; xx<MAX_ENUM; xx++)  {
		if (ENUMmap[xx])  {
			BBPunfix(ENUMmap[xx]);
		}
	}
	return MAL_SUCCEED;
}

@-
@}
