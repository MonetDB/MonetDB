@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f pbm
@v 0.1
@a M.L.Kersten
@+ Partitioned BAT Manager
In real-life database applications the BATs tend to grow beyond
the memory size. Although in most situation this does not
provide severe limitations, it helps to be able to work with
Partitioned BATs (PBAT).

For example, the updates could be collected in
separate BATs, while all querying may still focus on the table at large.
The partition optimizers will step in to either assemble the pieces before
a function is called, or to replace the instruction with a program fragment
to produce the result incrementally.

The code snippet below illustrates a sequence over time
to build the partitioned BAT. BATs are incrementally
added to a named PBAT @code{Sales}.
@verbatim
    b1:= bat.new(:oid,:int);
    bat.setPersistent(b1);
    pbm.deposit("Sales2005","06",b1);
    b2:= bat.new(:oid,:int);
    bat.setPersistent(b2);
    pbm.deposit("Sales2005","07",b2);
    b3:= bat.new(:oid,:int);
    bat.setPersistent(b3);
    pbm.deposit("Sales2005","08",b3);
    n:= pbm.getNames(); # get content of partitition catalogue.
    io.print(n);
@end verbatim

The components of a PBAT can be selectively retrieved by name or 
using an iterator.
@verbatim
    a:= pbm.take("Sales2005","06");
barrier c:= pbm.newIterator("Sales2005");
    io.print(c);
    redo c:= pbm.getNextComponent("Sales2005");
exit c;
@end verbatim
Alternatively, a static PBAT definition can be retrieved for manipulation
by the MAT optimizer.
@verbatim
#	d:= mat.take("Sales2005");    replaced by mat.optimizer into
    _21:= pbm.take("Sales2005","06");
    _22:= pbm.take("Sales2005","07");
    _23:= pbm.take("Sales2005","08");
    d:= mat.new(_21,_22,_23);
@end verbatim

A related, but separate issues, are the BAT distribution and replication
managers.
BEWARE, it is not yet protected against concurrent access yet.

Also support partitions by enumerations
@mal
module pbm;

command open():void
address PBMopen
comment "Locate and open the partition box";

command close():void
address PBMclose
comment "Save and close the partition box ";

command destroy():void
address PBMdestroy
comment "Destroy the partition box";

command take(grp:str,elm:str):bat[:any_1,:any_2]
address PBMtake
comment "Retrieve a single component of a PBAT";
command take(grp:str,idx:int):bat[:any_1,:any_2]
address PBMtakeIndexed
comment "Retrieve a single component of a PBAT by index";

command getNames():bat[:str,:str]
address PBMgetNames
comment "Retrieve the component names of all PBATs";
command getNextName()(:int,:str,:str)
address PBMgetNextName
comment "Locate next element in the partition box";


command getComponents(grp:str):bat[:str,:str]
address PBMgetComponents
comment "Retrieve the component names of a PBAT";

command deposit(nme:str,elm:str,idx:int) :void
address PBMdeposit
comment "Add an existing BAT to a PBAT in the partition box";
command deposit(nme:str,elm:str,b:str) :void
address PBMdepositByName
comment "Add a BAT to a PBAT in the partition box";
command deposit(nme:str,elm:str,b:bat[:any_1,:any_2]) :void
address PBMdeposit
comment "Add a BAT to a PBAT in the partition box";
command deposit(nme:str,b:bat[:oid,:any_2]) :void
address PBMdepositIndexed
comment "Add a BAT to a PBAT in the partition box";

command releaseAll(nme:str):void
address PBMreleaseAll
comment "Release a PBAT definitions";

command discard() :void
address PBMdiscardAll
comment "Release all PBAT variable from the box";
command discard(name:str) :void
address PBMdiscard
comment "Release a PBAT variable from the box";
command discard(nme:str, b:bat[:oid,:any_1]) :void
address PBMdiscardComponent
comment "Release a single BAT from a PBAT";

command newIterator()(:int,:str,:str)
address PBMnewIteratorBase
comment "Create an iterator over the partition box";

command generator(s:str):bat[:oid,:any_2]
address PBMdummy
comment "Place holder for generator optimizer";

command newIterator(grp:str):bat[:oid,:any_2]
address PBMnewIterator
comment "Create an iterator over the BAT partitions.";

command newIterator(grp:str,first:oid,last:oid)
		:bat[:oid,:any_2]
address PBMnewIteratorRng
comment "Create an iterator over the BAT partitions.";

command getNextElement(grp:str) :bat[:oid,:any_1]
address PBMgetNextElement
comment "Localize the next partition for processing.";

command getNextElement(grp:str,first:oid,last:oid) :bat[:oid,:any_2]
address PBMgetNextElementRng
comment "Localize the next partition for processing.";

command getLast(grp:str):bat[:oid,:any_2]
address PBMgetLast
comment "Obtain the last partition for update";

command getRange(b:bat[:oid,:any_1])(first:oid,last:oid)
address PBMgetRange
comment "Obtain the oid range for a partition";

command compress(grp:str):void
address PBMcompress
comment "Compress the group to remove oid holes";


command setWriteMode(nme:str):bat[:oid,:any_2]
address PBMdummy
comment "Perform mode change for all components of the partitioned BAT";
command setReadMode(b:bat[:oid,:any_2]):bat[:oid,:any_2]
address PBMdummy
comment "Perform mode change for all components of the partitioned BAT";

command dump()
address PBMdump;

@{
command prelude()
address PBMprelude;

command epilogue()
address PBMepilogue;

pbm.prelude();
@-

@+ BAT Partition Manager Implementation
The implementation is organized around a shared box, which should
be saved between session. It is up to other layers to ensure that BATs
being deleted are also removed from the partition box to avoid
mis-represented information.

The internal data structure is used as a cache for improved access.
@h
#ifndef _MAL_PBM
#define _MAL_PBM

#include <mal.h>
#include <mal_client.h>
#include <mal_interpreter.h>

#ifdef WIN32
#ifndef LIBPBM
#define pbm_export extern __declspec(dllimport)
#else
#define pbm_export extern __declspec(dllexport)
#endif
#else
#define pbm_export extern
#endif

typedef struct {
	str grp;		/* group name */
	str elm;		/* element name */
	bat bid;		/* element bat identifier */
	int type;		/* to ease filling the types */
@-
For the common case of :bat[:void,:any_1] we keep the boundaries
around for fast matching.
@h
	ValRecord hmin;		/* lowest head value stored */
	ValRecord hmax;		/* largest head value */

	int next;		/* next one in the PBAT list */
	int prev;		/* previous one in the PBAT list */
} PBATrecord, *PBAT;

pbm_export PBAT partitions ;
pbm_export int ptop, plimit;


pbm_export void PBMresize(int size);
pbm_export str PBMdump(void);
pbm_export str PBMprelude(int *ret);
pbm_export str PBMepilogue(int *ret);
pbm_export str PBMopen(int *ret);
pbm_export str PBMclose(int *ret);
pbm_export str PBMdestroy(int *ret);
pbm_export str PBMtakePBAT(int *ret, str *grp);
pbm_export str PBMtake(int *ret, str *grp, str *elm);
pbm_export str PBMtakeIndexed(int *ret, str *grp, int *bid);
pbm_export str PBMgetComponents(int *ret, str *grp);
pbm_export str PBMgetAllComponents(int *ret);
pbm_export int PBMfindGrp(int bid);
pbm_export int PBMfindPBAT(str grp);
pbm_export int PBMfindPBATcomponent(str grp, str elm);
pbm_export str PBMdeposit(int *ret, str *grp, str *elm, int *bid);
pbm_export str PBMdepositIndexed(int *ret, str *grp, int *idx);
pbm_export str PBMdepositByName(int *ret, str *grp, str *elm, str *nme);
pbm_export str PBMgetRange(oid *first, oid *last, int *bid);
pbm_export str PBMgetLast(int *ret, str *grp);
pbm_export str PBMdiscard(int *ret, str *grp);
pbm_export str PBMdiscardAll(int *ret);
pbm_export str PBMreleaseAll(int *ret, int *bid);
pbm_export str PBMdiscardComponent(int *ret, str *grp, int *bid);
pbm_export str PBMnewIteratorBase(int *ret, str *grp, str *elm);
pbm_export str PBMnewIterator(int *res, str *grp);
pbm_export str PBMnewIteratorRng(int *res, str *grp, oid *first, oid *last);
pbm_export str PBMgetNextElement(int *res, str *grp );
pbm_export str PBMgetNextElementRng(int *res, str *grp, oid *first, oid *last);
pbm_export str PBMcompress(int *ret, str *grp);
pbm_export str PBMgetNextName(int *ret, str *nme, str *elm);
pbm_export str PBMgetNames(int *ret);
pbm_export str PBMdummy(int *ret, str *grp);
#endif
@c
#include "mal_config.h"
#include "pbm.h"

PBAT partitions = NULL;
int ptop=0, plimit=0;

#define INCREMENT 1024
void
PBMresize(int size)
{
	PBAT p;

	if( size <= plimit) return;
	p = GDKmalloc(size * sizeof(PBATrecord));
	memset((char*)p, 0, size * sizeof(PBATrecord));
	if (partitions) {
		if (ptop > size)
			GDKfatal("assertion error in PBMresize");
		memcpy(p, partitions, sizeof(PBATrecord) * ptop);
		GDKfree(partitions);
	}
	partitions = p;
	partitions[0].grp = NULL;
	partitions[0].elm = NULL;
	partitions[0].bid = -1;
	partitions[0].prev = -1;
	partitions[0].next = -1;
	plimit = size;
}

static void
PBMfreePartition(int i){
	BAT *b;
	if( partitions[i].grp){
		b= (BAT*) BBPgetdesc(partitions[i].bid);
		if( b== 0)
			GDKerror("inconsistent pbm, lost a BAT");
		else{
			b->batPersistence = TRANSIENT;
			BBPdecref(b->batCacheid,TRUE);
			BBPunfix(b->batCacheid);
		}
	}
	if( partitions[i].grp) GDKfree(partitions[i].grp);
	if( partitions[i].elm) GDKfree(partitions[i].elm);
	partitions[i].grp = NULL;
	partitions[i].elm = NULL;
	partitions[i].bid = -1;
	partitions[i].prev = -1;
	partitions[i].next = -1;
}
static void
PBMfree()
{
	int i;
	if (partitions) {
		for(i=0; i<plimit; i++){
			if( partitions[i].grp) GDKfree(partitions[i].grp);
			if( partitions[i].elm) GDKfree(partitions[i].elm);
		}
		GDKfree(partitions);
		partitions = NULL;	
	}
}

str
PBMdump()
{
	stream *fd = GDKout;
	int i;

	stream_printf(fd, "ptop=%d plimit=%d\n", ptop, plimit);
	for (i = 0; i < ptop; i++){
		stream_printf(fd, "[%d] grp=%s elm=%s bid=%d type=%d prv=%d nxt=%d\n", i, 
			partitions[i].grp, partitions[i].elm, partitions[i].bid, 
			partitions[i].type, partitions[i].prev, partitions[i].next);
			/* bounds for later */
	}
	return MAL_SUCCEED;
}

@- Box administration
The box currently does not carry any client protection.
This should later be added or being provided by the BAT access.
@c
str
PBMprelude(int *ret)
{
	Box box;

	(void) ret;
	box = openBox("partitions");
	(void) box;
/*
	if (box == 0)
		throw(MAL, "pbm.prelude", "failed to open box");
*/
	PBMresize(INCREMENT);
	return MAL_SUCCEED;
}

str
PBMepilogue(int *ret)
{
	*ret = closeBox("partitions", 0);
	PBMfree();
	if (*ret != 0)
		throw(MAL, "pbm.prelude", "failed to open box");
	return MAL_SUCCEED;
}


str
PBMopen(int *ret)
{
	(void)* ret;
	if (openBox("pbm") != 0)
		return MAL_SUCCEED;
	throw(MAL, "pbm.open", "failed to open pbm box");
}

str
PBMclose(int *ret)
{
	stream *f;
	str boxfile, boxfilebak;
	Box box;
	BAT *b;
	int i;
	(void)* ret;

	box = openBox("pbm");
	f = prepareSaveBox(box, &boxfile, &boxfilebak);
	if (f != NULL) {
		/* save the info */
		for (i = 0; i < ptop; i++)
			if (partitions[i].bid != -1) {
				b = (BAT *) BBPgetdesc(partitions[i].bid);
				if (b && b->batPersistence & PERSISTENT)
					stream_printf(f, "pbm.deposit(\"%s\",\"%s\",\"%s\");\n", 
						partitions[i].grp,
						partitions[i].elm,
						BBPname(partitions[i].bid));
			}
		stream_close(f);
		GDKfree(boxfile);
		GDKfree(boxfilebak);
	}
	return MAL_SUCCEED;
}

str
PBMdestroy(int *ret)
{
	(void)* ret;
	destroyBox("partitions");
	return MAL_SUCCEED;
}
@-
Taking out a BAT should be protective, i.e. check for their existence.
Taking out a PBAT leads to a forced union before returning.
The intend is to use an optimizer to avoid this if possible.
@c
str
PBMtakeComplete(int *ret, str *grp)
{
	BAT *b,*bn;
	int i;
	i = PBMfindPBAT(*grp);
	if( i<0)
		throw(MAL, "pbm.take","PBAT not found");
	b= BBPdescriptor(partitions[i].bid);
	if( b== NULL)
		throw(MAL, "pbm.take", "PBAT partition not accessible");
	bn= BATcopy(b, b->htype, b->ttype, TRUE);
	BBPunfix(b->batCacheid);

	for(i= partitions[i].next; i>= 0; i= partitions[i].next){
		b= BBPdescriptor(partitions[i].bid);
		if( b== NULL){
			BBPdecref(bn->batCacheid, TRUE);
			BBPunfix(bn->batCacheid);
			throw(MAL, "pbm.take", "PBAT partition not accessible");
		}
		BATins(bn,b,FALSE);
		BBPunfix(b->batCacheid);
	}
	*ret = bn->batCacheid;
	BBPkeepref(*ret);
	return MAL_SUCCEED;
}
str
PBMtake(int *ret, str *grp, str *elm)
{
	BAT *b;
	int i;
	for( i=0; i< plimit; i++)
	if( partitions[i].grp &&
		 strcmp(partitions[i].grp, *grp)== 0 &&
		strcmp(partitions[i].elm, *elm)== 0) 
		break;
	if( i== plimit )
		throw(MAL, "pbm.take", "PBAT partition not found");
	b= BBPdescriptor(partitions[i].bid);
	if( b== NULL)
		throw(MAL, "pbm.take", "PBAT partition not accessible");
	*ret = partitions[i].bid;
	BBPkeepref(*ret);
	return MAL_SUCCEED;
}
str
PBMtakeIndexed(int *ret, str *grp, int *idx)
{
	BAT *b;
	int i;
	i= PBMfindPBAT(*grp);
	if( i< 0)
		throw(MAL, "pbm.take","PBAT not found");
	for( ; i>=0 && *idx>0; i= partitions[i].next)
		*idx= *idx-1;
	if( i< 0)
		throw(MAL, "pbm.take","PBAT component not found");
	b= BBPdescriptor(partitions[i].bid);
	if( b== NULL)
		throw(MAL, "pbm.take", "PBAT partition not accessible");
	*ret = partitions[i].bid;
	BBPkeepref(*ret);
	return MAL_SUCCEED;
}
str
PBMgetComponents(int *ret, str *grp)
{
	BAT *b;
	int i;
	b= BATnew(TYPE_str,TYPE_str, oid_nil);
	if( b==NULL)
		throw(MAL, "pbm.getComponents", "Could not create BAT");
	for( i= PBMfindPBAT(*grp); i>=0;  i= partitions[i].next)
		BUNins(b,grp, partitions[i].elm, FALSE);
	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	*ret = b->batCacheid;
	BBPkeepref(*ret);
	return MAL_SUCCEED;
}
str
PBMgetNames(int *ret)
{
	BAT *b;
	int i;
	b= BATnew(TYPE_str,TYPE_str, oid_nil);
	if( b==NULL)
		throw(MAL, "pbm.getNames", "Could not create BAT");
	for( i= 0; i<ptop;  i++)
	if( partitions[i].grp )
		BUNins(b,partitions[i].grp, partitions[i].elm, FALSE);
	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	*ret = b->batCacheid;
	BBPkeepref(*ret);
	return MAL_SUCCEED;
}

@-
Administration of new partitions.
@c
int
PBMfindGrp(int bid)
{
	int i;

	for (i = 0; i < ptop; i++)
		if (partitions[i].bid == bid) {
			while (partitions[i].prev >= 0)
				i = partitions[i].prev;
			return i;
		}
	return -1;
}

@-
Find the header of a group
@c
int
PBMfindPBAT(str grp)
{
	int i;

	for (i = 0; i < ptop; i++)
		if(	partitions[i].grp && 
			strcmp(partitions[i].grp,grp)==0 &&
			partitions[i].prev == -1 )
			return i;
	return -1;
}
int
PBMfindPBATcomponent(str grp, str elm)
{
	int i;

	for (i = 0; i < ptop; i++)
		if( strcmp(partitions[i].grp,grp)==0 &&
			strcmp(partitions[i].elm,elm)== 0)
			return i;
	return -1;
}

str
PBMdeposit(int *ret, str *grp, str *elm, int *bid)
{
	int idx, i,j;
	BAT *b;

	if( elm){
		i= PBMfindPBATcomponent(*grp,*elm);
		if( i >=0 )
			throw(MAL, "pbm.deposit", "PBAT component already known");
	}
	b = BATdescriptor(*bid);
	if (b == NULL)
		throw(MAL, "pbm.deposit", "Can not access descriptor");
	idx = PBMfindPBAT(*grp);
	if (ptop == plimit)
		PBMresize(plimit + INCREMENT);
	for (i = 0; i <= ptop; i++)
		if (partitions[i].bid == -1)
			break;
	partitions[i].grp = GDKstrdup(*grp);
	partitions[i].elm = elm?GDKstrdup(*elm):0;
	partitions[i].bid = *bid;
	partitions[i].type = newBatType(b->htype, b->ttype);
	partitions[i].hmin.val.oval = b->hseqbase;
	partitions[i].hmax.val.oval = b->hseqbase + BATcount(b);
	partitions[i].prev = -1;
	partitions[i].next = -1;
	if (i >= ptop) {
		ptop = i + 1;
		partitions[ptop].bid = -1;
		partitions[ptop].next = -1;
		partitions[ptop].prev = -1;
	}
	if( idx >=0){
		for(j=idx; partitions[j].next>=0; j= partitions[j].next) ;
		partitions[j].next = i;
		partitions[i].prev = j;
	}
	BBPunfix(*bid);
	(void) ret;
	return MAL_SUCCEED;
}

str
PBMdepositIndexed(int *ret, str *grp, int *idx)
{
	return PBMdeposit(ret,grp,0,idx);
}
str
PBMdepositByName(int *ret, str *grp, str *elm, str *nme)
{
	int idx;
	BAT *b;

	idx= PBMfindPBATcomponent(*grp,*elm);
	if( idx >=0 )
		throw(MAL, "pbm.deposit", "PBAT already known");
	idx= BBPindex(*nme);
	b = BATdescriptor(idx);
	if (b == NULL)
		throw(MAL, "pbm.deposit", "Can not access descriptor");

	PBMdeposit(ret,grp,elm,&idx);
	BBPunfix(idx);
	(void) ret;
	return MAL_SUCCEED;
}

str
PBMgetRange(oid *first, oid *last, int *bid)
{
	int i;

	for (i = 0; i < ptop; i++)
		if (partitions[i].bid == *bid) {
			*first = partitions[i].hmin.val.oval;
			*last = partitions[i].hmax.val.oval;
			return MAL_SUCCEED;
		}
	throw(MAL, "pbm.getRange", "PBAT not known");
}

str
PBMgetLast(int *ret, str *grp)
{
	int i;

	i= PBMfindPBAT(*grp);
	if( i < 0)
		throw(MAL, "pbm.getLast", "PBAT not known");
	for (; partitions[i].next>=0 ; i= partitions[i].next)
		;
	*ret = partitions[i].bid;
	return MAL_SUCCEED;
}

str
PBMdiscard(int *ret, str *grp)
{
	int i;

	for (i = 0; i<ptop; i++)
	if(	partitions[i].grp &&
		strcmp(partitions[i].grp, *grp)== 0 )
			PBMfreePartition(i);
	(void) ret;
	return MAL_SUCCEED;
}

str
PBMdiscardAll(int *ret)
{
	int i;
	for(i=0; i<ptop; i++)
	if( partitions[i].grp)
			PBMfreePartition(i);
	GDKfree(partitions);
	partitions = 0;
	plimit = -1;
	PBMresize(INCREMENT);
	(void) ret;
	return MAL_SUCCEED;
}

@-
releasing the PBAT does not remove its components.
@c
str
PBMreleaseAll(int *ret, int *bid)
{
	(void) ret;
	(void) bid;
	throw(MAL, "pbm.release", "not yet implemented");
}

str
PBMdiscardComponent(int *ret, str *grp, int *bid)
{
	(void) ret;
	(void) bid;
	(void) grp;
	throw(MAL, "pbm.release", "not yet implemented");
}
@-
We start with the large chunk iterator.
The definition of the control statements require the same
control variables, which means that the BATview is accessible
to determine how far to advance when the next chunk is retrieved.
The number of elements in the chunk is limited by the granule
size.
@c
str
PBMnewIteratorBase(int *ret, str *grp, str *elm)
{
	*ret = 0;
	if (*ret == ptop)
		*ret = -1;
	else {
		*grp= GDKstrdup(partitions[0].grp);
		*elm= GDKstrdup(partitions[0].elm);
	}
	return MAL_SUCCEED;
}

str
PBMnewIterator(int *res, str *grp)
{
	int idx;

	idx= PBMfindPBAT(*grp);
	if(idx<0)
		throw(MAL, "pbm.newIterator","Could not find PBAT");
	*res = partitions[idx].bid;
	BBPincref(*res, TRUE);
	return MAL_SUCCEED;
}

str
PBMnewIteratorRng(int *res, str *grp, oid *first, oid *last)
{
	int i;

	i= PBMfindPBAT(*grp);
	if( i<0)
		throw(MAL, "pbm.newIterator","Could not find PBAT");
	for (; i>=0 ; i= partitions[i].next)
	if (!(partitions[i].hmax.val.oval < *first || 
		  partitions[i].hmin.val.oval > *last)) {
			*res = partitions[i].bid;
			BBPincref(*res, TRUE);
		}
	return MAL_SUCCEED;
}

str
PBMgetNextElement(int *res, str *grp)
{
	int i;
	for(i=0; i<ptop; i++)
	if( partitions[i].bid == *res &&
		partitions[i].grp &&
		strcmp(partitions[i].grp,*grp)== 0){
		*res= partitions[i].bid;
		BBPincref(*res, TRUE);
		return MAL_SUCCEED;
	}
	*res = -1;
	return MAL_SUCCEED;
}

str
PBMgetNextElementRng(int *res, str *grp, oid *first, oid *last)
{
	int i;
	for(i= PBMfindPBAT(*grp); i>=0 ; i = partitions[i].next)
		if( !(partitions[i].hmax.val.oval < *first || 
			  partitions[i].hmin.val.oval > *last)) {
			*res = partitions[i].bid;
			BBPincref(*res, TRUE);
			return MAL_SUCCEED;
		}
	*res = -1;
	return MAL_SUCCEED;
}

str
PBMcompress(int *ret, str *grp)
{
	BAT *b;
	int i;
	oid o = 0;

	(void) ret;
	i = PBMfindPBAT(*grp);
	if (i < 0)
		throw(MAL, "pbm.commpress", "PBAT not found");
	b = BATdescriptor(partitions[i].bid);
	if (b == 0)
		throw(MAL, "pbm.commpress", "BAT group not found");
	for (; i >= 0; i = partitions[i].next) {
		partitions[i].hmin.val.oval = o;
		b = BATdescriptor(partitions[i].bid);
		if (b == 0)
			throw(MAL, "pbm.compress", "Internal error in BAT group");
		b->hseqbase = partitions[i].hmin.val.oval;
		o = partitions[i].hmax.val.oval += BATcount(b) - 1;
		BBPunfix(b->batCacheid);
	}
	return MAL_SUCCEED;
}

str
PBMdummy(int *ret, str *grp){
	(void)ret; (void) grp;
	return MAL_SUCCEED;
}

str
PBMgetNextName(int *ret, str *nme, str *elm)
{
	do {
		*ret = *ret + 1;
		if (*ret >= ptop) {
		  *ret = -1;
		  return MAL_SUCCEED;
		}
		*nme= GDKstrdup(partitions[*ret].grp);
		*elm= GDKstrdup(partitions[*ret].elm);
	} while (partitions[*ret].bid == -1);
	return MAL_SUCCEED;
}

@}
