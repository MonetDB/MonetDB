@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f rsbox
@a Fabian Groffen
@v 1.0
@* ResultSet support box
This module acts as a simple box of ResultSet objects.
A ResultSet is a thin wrapper around a number of BATs that allows
serialising the values in the BATs to the MonetDB/Five MCL result
format.  This box allows the user to create, retrieve and destroy
ResultSets easily.

Normally, objects are stored into a box using {\sc deposit}
and taken out with {\sc take}.  This box however, only knows
{\sc create} and {\sc take}.  ResultSets cannot
be stored, because the only way to create them is by using the
{\sc create} function, which automatically deposits the newly
created ResultSet in the box.  The {\sc release} function allows
to remove a ResultSet from the box.

The existing functionality of mal_box allows to store and retrieve
items somehow.  In the future we might want to switch to those
supplied tools.  For now we stick with (documented and) simple
elements such as structs and an array.  As a result, we are NOT
thread safe.
[TODO: make it a thing associated to a user, with no global box stuff]

@+ The ResultSet atom
A ResultSet is a container for a set of BATs that form together
a result of a user query.  The purpose of the ResultSet is to
hand a uniform interface to both application and foreign client
by defining how to build a ResultSet from BATs and on the other
hand serialising the given BATs in a predefined format.

The ResultSet is {\em not} meant to be generic, instead it is
suitable only for MonetDB/Five MCL server/client communication.
The exact specification of this protocol can be found in
[ref:cvs:~fabian/repository:proefschrift/paper3] [(TODO)]

A ResultSet requires all its associated BATs to be of equal
length and :bat[:void,:any$1] typed, for this allows efficient
serialisation.

A new empty ResultSet can be obtained by calling the create()
function of the rsbox.  During creation time, the number of
columns the ResultSet is going to have must be specified.
The state of such newly created ResultSet will be
`uncomplete', which means that BATs can be attached to the
columns of that ResultSet, as well as properties of the columns
can be set.
The ResultSet can be composed horizontally, which means that
column properties can be set before the actual BAT is attached.
This behaviour helps efficient factorisation.
The function populateColumn() allows the user to attach a BAT
to a ResultSet column, if and only if the BAT has the proper
length, otherwise an exception will be thrown.
If all columns are populated the ResultSet can be serialised
using the writeNextPart(), writeHeader() and writeBlock()
functions.

Properties for columns can be set using the setProperty()
function.  This function sets the given property value for
the given property name on the given column, where the
column index starts at 1.  If the column index is out of
bounds, the property name is not valid, or the value is
not allowed an exception will be thrown.
The setProperty() function overwrites previous values,
if set and returns whether it has replaced a value or not.

Calling one of the writeNextPart(), writeHeader() or writeBlock()
functions, causes the ResultSet to be closed for changes.
This effectively means that any call to populateColumn() or
setProperty() will result in an exception.  If a ResultSet
cannot properly be closed because not all columns have a BAT
attached, an appropriate exception is thrown.
When the header is written by the writeHeader() function, all
property values that are not set, but should have a value, are
auto-generated.  In most cases this will be convenient for
quickly serialising some BATs.  Where necessary the otherwise
auto-generated columns should be set explicitly.

The wrapper function writeNextPart() is a convenience function
that combines writeHeader and writeBlock such that only the first
call includes the header and all consecutive calls only include
results.  The return value of hasNextPart() is an int indicating
whether there is a next part to write using the function
writeNextPart().  The size of the blocks can be set using the
setBlockSize() function.

To reuse a ResultSet, it should first be opened again.  The
function dePopulate() releases all BATs attached to the columns
of the ResultSet and allows calls to populateColumn() and
setProperty() again.

Finally, to properly release a ResultSet and all its associated
resources, the function release(:resultset) should be
called.  This function frees all associated BAT columns and
properties.

@mal
atom resultset:int;

command populateColumn(rs:resultset,col:int,b:bat[:void,:any$1]):resultset
address RSpopulateColumn
comment "Add a BAT as column with a name to this ResultSet";
command dePopulate(rs:resultset):resultset
address RSdePopulate
comment "Removes all the attached BATs and allows populating again";
command addUnion(rs:resultset):resultset
address RSunion
comment "Allow populating a new set of column which is unioned to the
previous";

command setProperty(rs:resultset,col:int,nme:str,val:str):resultset
address RSsetPropertyStr
comment "Sets the given property to the given value on the given column";
command setProperty(rs:resultset,col:int,nme:str,val:int):resultset
address RSsetPropertyInt
comment "Sets the given property to the given value on the given column";

command writeHeader(rs:resultset):int
address RSwriteHeader
comment "Writes the header of this ResultSet to the given stream";
command writeBlock(rs:resultset,upper:lng,lower:lng):int
address RSwriteBlock
comment "Writes the results from upper to lower to the stream";
command getLength(rs:resultset):int
address RSgetLength
comment "Returns the size of this ResultSet as number of rows";
command setBlockSize(rs:resultset,size:int):resultset
address RSsetBlockSize
comment "Sets the block size used by writeNextPart";
command hasNextPart(rs:resultset):bit
address RShasNextPart
comment "Returns whether there is another part to write by writeNextPart";
command writeNextPart(rs:resultset):int
address RSwriteNextPart
comment "Writes the next part to the stream.  If it is the first part,
the header will be written to the stream first.  The size of the blocks
is determined by the value supplied via the setBlockSize function.";

# ResultSets themselves should never be serialised to disk.  The
# fromStr and toStr functions merely exist to adhere to the interface
command fromstr()
address RSfromString
comment "Discards the string and does nothing (returns nil)";
command tostr()
address RStoString
comment "Returns a string indicating this is a ResultSet";

module rsbox
comment "The resultset box implementation provides a store for
query results";

command create(columns:int, type:chr):resultset
address RSBcreate
comment "Create a new ResultSet with the given number of columns
& type and deposit it in the box";

command take(id:int):resultset
address RSBtake
comment "Take a resultset with the given id out of the box";
command deposit(name:str,set:resultset):void
address RSBdeposit
comment "Store a new resultset into the box (only there to comply
to the interface, throws an exception, use create instead";

command releaseAll():void
address RSBreleaseAll
comment "Release all resultsets for this client in the box";
command release(rs:resultset):void
address RSBdelete
comment "Release this ResultSet and all its associated resources from
the box";
command release(id:int):void
address RSBrelease
comment "Release the resultset with the given id";

command discard(id:int):void
address RSBrelease
comment "see rsbox.release(id:int)";

command newIterator()(:lng,:resultset)
address RSBiterator
comment "Initialize the iterator over the resultset box";
command hasMoreElements()(:lng,:resultset)
address RSBhasMoreElements
comment "Locate next resultset in the box";

@-
The content of the box consists of result sets.
Their handle is represented by an atom to ease
type analysis of the resultset box operations.
@mal
@{
@-
@+ Implementation
@h
#ifndef _RSBOX_H
#define _RSBOX_H 1

#include "mal.h"
#include "mal_client.h"
#include "mal_interpreter.h"

typedef struct column_t {
	BAT *bat;		/* BAT that backs this (part of the) column */
	BUN bun;		/* a walker variable */
	str name;		/* the name/id of this column */
	str table;		/* name of the table this column belongs to */
	str schema;		/* name of the schema this column belongs to */
	str type;		/* name of the type of this column */
	int digits;		/* digits of this data type */
	int scale;		/* scale of this data type */
	int width;		/* the maximum field width of this column */
} column;

typedef struct columnset_t {
	column **columns;	/* an array of associated columns */
	size_t length;		/* the number of rows in this block */
	char complete;		/* whether this ResultSet block can be serialised */
	struct columnset_t *nextSet;	/* the next ResultSet block (if not NULL) */
} columnset;

typedef struct resultset_t {
	unsigned int blocksize;	/* the number of rows per block */
	size_t id;		/* external reference ID of this ResultSet */
	char type;		/* type of result */
	int columnCount;	/* the number of columns in this ResultSet */
	size_t length;		/* the number of rows in this ResultSet */
	size_t pos;		/* the current row position */
	columnset columnSet;	/* the first column set of this ResultSet */
} resultset;

/* protocol stuff */
/* level 1: protocol synchronisation */
#define RS_LINE_PROMPT				"\001\001"
#define RS_LINE_PROMPT_MORE			"\001\002"
#define RS_LINE_START_OF_HEADER		'&'	/* followed by header type also in level 2 */
/* level 2: MCL meta-data */
#define RS_LINE_CONTROL_HEADER		'$'
#define RS_LINE_SWITCHROLE			'^'	/* switch from client to server and vice-versa */
/* level 3: client messages */
#define RS_LINE_HEADER				'%'
#define RS_LINE_TUPLE				'['
#define RS_LINE_ERROR				'!'	/* also in level 4 */
/* level 4: user messages */
#define RS_LINE_MESSAGE				'#'

/* header types: results */
#define RS_TYPE_R_DEFAULT	't'	/* alias for RS_TYPE_R_MONET5 */
#define RS_TYPE_R_MONET5	't'	/* MonetDB/Five MAPI protocol */
#define RS_TYPE_R_RAW		'r'	/* bulk data, length known */
#define RS_TYPE_R_BAT		'B'	/* BAT dump format (for replication) */
#define RS_TYPE_R_STREAM	's'	/* stream of data, length unknown */
/* prepare response */
#define RS_TYPE_P_PREPARE	'p'	/* prepare message response */
/* updates */
#define RS_TYPE_U_DEFAULT	'u'	/* alias for RS_TYPE_U_AFFROW */
#define RS_TYPE_U_AFFROW	'u'	/* 1 affected row count */
#define RS_TYPE_U_BATCH		'b'	/* list of affected row counts */
#define RS_TYPE_U_SUCCESS	'v'	/* operation successful */
/* error */
#define RS_TYPE_E_ERROR		'!'	/* sole error message */

#endif
@c
#include "rsbox.h"
#include <stream.h>
#include "mal.h"
#include "mal_exception.h"

mal_export str RSBdeposit(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mal_export str RSBcreate(int *retval, int *columns, char *type);
mal_export str RSBtake(int *retval, int *id);
mal_export str RSBdelete(void *retval, int *handle);
mal_export str RSBrelease(void *retval, int *id);
mal_export str RSBreleaseAll();
mal_export str RSBhasMoreElements(lng *ret1, int *ret2);
mal_export str RSBiterator(lng *ret1, int *ret2);
mal_export str RSpopulateColumn(int *retval, int *handle, int *colno, int *bat);

mal_export str RSsetPropertyStr(int *retval, int *handle, int *colno, str *nme,
str *val);
mal_export str RSsetPropertyInt(int *retval, int *handle, int *colno, str *nme,
int *val);
mal_export str RSunion(int *retval, int *handle);
mal_export str RSdePopulate(int *retval, int *handle);
mal_export str RSwriteHeader(int *retval, int *handle);
mal_export str RSwriteBlock(int *retval, int *handle, lng *upper, lng *lower);
mal_export str RSgetLength(int *retval, int *handle);
mal_export str RSsetBlockSize(int *retval, int *handle, int size);
mal_export str RShasNextPart(int *retval, int *handle);
mal_export str RSwriteNextPart(int *retval, int *handle);
mal_export str RSfromString(str *src, int *len, resultset * retval);
mal_export int RStoString(str *retval, int *len, ptr handle);

/* convenience macros */
#define throwRS(X, Y) throw("ResultSetException", X, Y);
#define throwRSf(X, Y, A) throwf("ResultSetException", X, Y, A);
#define resolveHandle(X, Y) \
	if ((tmp = RSBgetResultSet(X, Y)) != MAL_SUCCEED) return(tmp);

/** How many elements we can handle at a time */
#define RSB_MAX_ELEMS	20
/** Array which contains all the resultsets contained in this Set */
static resultset *elements[RSB_MAX_ELEMS];

/** A global ResultSet ID counter */
static size_t RS_nextID = 1;	/* start at 1 */

static void RSinitColumn(columnset * rs, int *colindex);
static str RSBgetResultSet(resultset ** retval, int *handle);
static str RSBfreeColumn(column * col);
static str RSfreeColumnSet(resultset * rs, columnset * cs);
static str RStailWidth(int *retval, BAT *b);
static str RSsetComplete(resultset * rs);

/**
 * Returns the resultset from an element for a given array slot.
 * An exception is thrown if the array slot is empty or out of
 * bounds.
 */
static str
RSBgetResultSet(resultset ** retval, int *handle)
{
	if (handle == NULL)
		throwIllArg("rsbox.getResultSet", "Handle should not be NULL");
	if (*handle < 0 || *handle > RSB_MAX_ELEMS)
		throwOutOfBnds("rsbox.getResultSet", "Handle index out of bounds");
	if (*handle == 0)
		throwIllArg("rsbox.getResultSet", "Invalid handle: not initialised");
	if (elements[*handle - 1] == NULL)
		throwIllArg("rsbox.getResultSet", "Handle points to an empty slot");

	*retval = elements[*handle - 1];
	return (MAL_SUCCEED);
}

@- Operator implementation
@-
@c
/**
 * Deposit does not work for a ResultSet box.  Use create instead.
 *
 * @throws exception
 */
str
RSBdeposit(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	(void) mb;
	(void) stk;
	(void) pci;		/* make compiler happy */
	throwRS("rsbox.deposit", "Operation not supported: use rsbox.create");
}

/**
 * Create a new ResultSet with the given string as id.  The
 * ResultSet is immediately deposited in the box, and its
 * handle is returned.
 * Depending on the given type, the columns argument is
 * either ignored or used.
 *
 * @param name the name of the ResultSet
 * @param columns the number of columns this ResultSet has
 * @param type the ResultSet type.
 */
str
RSBcreate(int *retval, int *columns, char *type)
{
	int i, j, free = -1;
	char tpe;

	if (*columns <= 0)
		throwIllArg("rsbox.create", "Number of columns should be a positive non-zero value");
	tpe = *type;
	if (tpe == RS_TYPE_E_ERROR)
		throwIllArg("rsbox.create", "use TODOError.create to send error messages");
	if (tpe != RS_TYPE_R_DEFAULT && tpe != RS_TYPE_R_MONET5 && tpe != RS_TYPE_R_RAW && tpe != RS_TYPE_U_AFFROW && tpe != RS_TYPE_U_BATCH && tpe != RS_TYPE_U_SUCCESS)
		throwIllArgf("rsbox.create", "ResultSet type unknown: %c", tpe);

	/* find the first free slot */
	for (i = 0; i < RSB_MAX_ELEMS; i++) {
		if (elements[i] == NULL) {
			/* this is a free slot */
			if (free == -1) {
				/* somehow hide it from other threads (not safe!) */
				elements[i] = GDKmalloc(sizeof(resultset));
				/* initialise the values to null */
				memset(elements[i], 0, sizeof(resultset));
				/* set the id */
				elements[i]->id = RS_nextID++;

				elements[i]->columnCount = *columns;
				elements[i]->type = tpe;
				elements[i]->columnSet.columns = GDKmalloc(sizeof(column *) * *columns);
				memset(elements[i]->columnSet.columns, 0, sizeof(column *) * *columns);
				for (j = 0; j < *columns; j++)
					RSinitColumn(&(elements[i]->columnSet), &j);
				elements[i]->columnSet.length = -1;
				free = i;
			}
		}
	}
	if (free == -1)
		throwRS("rsbox.create", "No free slots available");

	/* and return the index as handle */
	*retval = free + 1;
	return (MAL_SUCCEED);
}

/**
 * Returns for the given id, the corresponding ResultSet handle.
 * Throws an exception if no such ResultSet is found.
 * The actual int returned is the container element array position.
 */
str
RSBtake(int *retval, int *id)
{
	int i;

	for (i = 0; i < RSB_MAX_ELEMS; i++) {
		if (elements[i] != NULL && elements[i]->id == *id) {
			*retval = i + 1;
			return (MAL_SUCCEED);
		}
	}

	throwRSf("rsbox.take", "No such element with id '%d'", *id);
}

/**
 * Helper function to properly free a column struct.
 *
 * @param column the column to free
 */
static str
RSBfreeColumn(column * col)
{
	if (col == NULL)
		throwIllArg("resultset.freeColumn", "Column should NOT be NULL");

	if (col->bat)
		BBPunfix(col->bat->batCacheid);

	if (col->name)
		GDKfree(col->name);
	if (col->table)
		GDKfree(col->table);
	if (col->schema)
		GDKfree(col->schema);
	if (col->type)
		GDKfree(col->type);
	GDKfree(col);

	return (MAL_SUCCEED);
}

/**
 * Helper function to properly free columnset structs.  This function
 * uses recursion to properly free all members of the list.
 *
 * @param rs the resultset the to be freed columnset belongs to
 * @param cs the columnset to be freed
 */
static str
RSfreeColumnSet(resultset * rs, columnset * cs)
{
	int i;
	str tmp;

	if (cs == NULL)
		return (MAL_SUCCEED);

	if (cs->nextSet != NULL)
		if ((tmp = RSfreeColumnSet(rs, cs->nextSet)) != MAL_SUCCEED)
			return (tmp);

	for (i = 0; i < rs->columnCount; i++) {
		if ((tmp = RSBfreeColumn(cs->columns[i])) != MAL_SUCCEED)
			return (tmp);
	}

	return (MAL_SUCCEED);
}

/**
 * Releases the given ResultSet and all its associated rescources.
 *
 * @param handle a resultset handle
 */
str
RSBdelete(void *retval, int *handle)
{
	resultset *rs = NULL;
	str tmp;
	int i;

	(void) retval;		/* make compiler happy */

	rethrow("rsbox.delete", tmp, RSBgetResultSet(&rs, handle));

	/* hide this resultset */
	elements[*handle - 1] = NULL;

	/* first free all columns */
	RSfreeColumnSet(rs, rs->columnSet.nextSet);
	for (i = 0; i < rs->columnCount; i++)
		RSBfreeColumn(rs->columnSet.columns[i]);
	/* finally free the struct itself */
	GDKfree(rs);

	*handle = 0;
	return (MAL_SUCCEED);
}

/**
 * Releases the given ResultSet and all its associated rescources.
 *
 * @param id a resultset id
 */
str
RSBrelease(void *retval, int *id)
{
	str tmp;
	int handle;

	(void) retval;		/* make compiler happy */

	rethrow("rsbox.release", tmp, RSBtake(&handle, id));

	return (RSBdelete(NULL, &handle));
}

/**
 * Releases all the ResultSets that are associated to the user.
 */
str
RSBreleaseAll()
{
	str tmp;
	int i, handle;

	for (i = 0; i < RSB_MAX_ELEMS; i++) {
		if (elements[i] != NULL) {
			handle = i + 1;
			rethrow("rsbox.releaseAll", tmp, RSBdelete(NULL, &handle));
		}
	}

	return (MAL_SUCCEED);
}

/**
 * Increases the cursor by one and returns the next resultset handle,
 * if available.
 *
 * @return ret1 iterator cursor
 * @return ret2 resultset handle
 */
str
RSBhasMoreElements(lng *ret1, int *ret2)
{
	int pos, handle;

	if (*ret1 + 1 < RSB_MAX_ELEMS) {
		pos = ((int) *ret1) + 1;
		for (; pos < RSB_MAX_ELEMS; pos++) {
			if (elements[pos] != NULL) {
				handle = pos + 1;
				*ret1 = (lng) pos;
				*ret2 = handle;
				return (MAL_SUCCEED);
			}
		}
	}

	/* tell there are no more elements */
	*ret1 = -1;
	*ret2 = 0;
	return (MAL_SUCCEED);
}

/**
 * Iterator thinghy that returns the starting point of an
 * iteration over all ResultSets stored in the box that are
 * owned by the caller.
 *
 * @return ret1 iterator cursor
 * @return ret2 resultset handle
 */
str
RSBiterator(lng *ret1, int *ret2)
{
	str tmp;

	*ret1 = -1;

	rethrow("rsbox.iterator", tmp, RSBhasMoreElements(ret1, ret2));
	return (MAL_SUCCEED);
}

@-
@+ Implementation of the resultset
@c

/**
 * Small helper function that calculates the max width of the
 * tail value of the given BAT.
 *
 * @param b the BAT to scan the tail from
 * @return the max width of the tail
 */
static str
RStailWidth(int *retval, BAT *b)
{
	BUN p, q;
	int max = 0;

	if (b == NULL)
		throwIllArg("resultset.tailWidth", "BAT should not be NULL");

	switch (b->ttype) {
	case TYPE_bit:
		max = 5;	/* false */
		break;
	case TYPE_chr:
		max = 1;
		break;
	case TYPE_oid:
		max = 11;	/* wild guess */
		break;
	case TYPE_sht:{
		lng maxval = 0;

		BATloop(b, p, q) {
			sht *l = (sht *) BUNtail(b, p);

			maxval += *l;
		}
		while (maxval /= 10)
			max++;
	}
		break;
	case TYPE_int:{
		lng maxval = 0;

		BATloop(b, p, q) {
			int *l = (int *) BUNtail(b, p);

			maxval += *l;
		}
		while (maxval /= 10)
			max++;
	}
		break;
	case TYPE_lng:{
		lng maxval = 0;

		BATloop(b, p, q) {
			lng *l = (lng *) BUNtail(b, p);

			maxval += *l;
		}
		while (maxval /= 10)
			max++;
	}
		break;
	case TYPE_flt:
		max = 12;	/* SQL99 max stdout */
		break;
	case TYPE_dbl:
		max = 24;	/* SQL99 max stdout */
		break;
	case TYPE_str:
	BATloop(b, p, q) {
		char *s = BUNtail(b, p);
		int l = strlen(s);

		if (l > max)
			max = l;
	}
		break;
	case TYPE_ptr:		/* C pointer! */
	case TYPE_bat:		/* BAT id: index in BBPcache */
	default:
		max = 0;
	}

	*retval = max;
	return (MAL_SUCCEED);
}


/**
 * Initialises a column struct by setting the default values
 * for all its members.  Remember that this function is designed
 * for internal use, and therefore takes a real reference to
 * a resultset struct instead of a handle.  The arguments are
 * not checked.  If the column to be initialised is not NULL
 * it is free'd first.
 */
static void
RSinitColumn(columnset * cs, int *colindex)
{
	/* free if not empty */
	if (cs->columns[*colindex])
		RSBfreeColumn(cs->columns[*colindex]);

	/* malloc some space */
	cs->columns[*colindex] = GDKmalloc(sizeof(column));

	/* initialise all relevant values */
	memset(cs->columns[*colindex], 0, sizeof(column));
	cs->columns[*colindex]->width = -1;
	cs->columns[*colindex]->digits = -1;
	cs->columns[*colindex]->scale = -1;
}

/**
 * Adds a column to the ResultSet and returns its position in
 * the sequence of columns.  The BAT and name string are taken
 * and freed upon deletion of the ResultSet.
 *
 * @param handle a resultset handle
 * @param colno the column number to attach the BAT to
 * @param bat a :void,:any BAT
 * @return the modified ResultSet
 */
str
RSpopulateColumn(int *retval, int *handle, int *colno, int *bat)
{
	BAT *b;
	resultset *rs = NULL;
	columnset *cs;
	columnset *lastcs = NULL;
	str tmp;

	rethrow("resultset.populateColumn", tmp, RSBgetResultSet(&rs, handle));
	if ((b = BATdescriptor(*bat)) == NULL)
		throwIllArg("resultset.populateColumn", "Cannot access BAT descriptor");

	if (b->ttype < 0 || b->ttype >= GDKatomcnt || b->ttype == TYPE_bat || b->ttype == TYPE_ptr)
		throwIllArg("resultset.populateColumn", "Illegal BAT tail type");
	if (colno == NULL || *colno == int_nil)
		throwIllArg("resultset.populateColumn", "Column index should not be NULL or nil");
	if (*colno <= 0 || *colno > rs->columnCount)
		throwOutOfBndsf("resultset.populateColumn", "Column index out of bounds (%d)", *colno);
	/* find the last ResultSet block */
	cs = &(rs->columnSet);
	while (cs->nextSet != NULL) {
		lastcs = cs;
		cs = cs->nextSet;
	}
	if (cs->complete)
		throwRS("resultset.populateColumn", "Unable to modify a complete ResultSet");

	/* tell the BBP to leave this BAT alone: it's ours! */
	BBPfix(b->batCacheid);

	if (cs->length != -1) {
		/* check length of BAT and match it with the known length */
		if (cs->length != BATcount(b))
			throwRSf("resultset.populateColumn", "BATcount does not match those of previous columns (%d)", cs->length);
	} else {
		/* this is the first column that is added, take its length as
		 * base for all other columns that get added */
		cs->length = BATcount(b);
		rs->length += cs->length;
	}
	/* add the BAT */
	if (cs->columns[*colno - 1]->bat !=NULL)
		BBPunfix(cs->columns[*colno - 1]->bat->batCacheid);

	if (lastcs != NULL && b->ttype != lastcs->columns[*colno - 1]->bat->ttype)
		throwRS("resultset.populateColumn", "The tail type of the to be added column does not match the previous union part");
	cs->columns[*colno - 1]->bat = b;

	*retval = *handle;
	return (MAL_SUCCEED);
}

/**
 * Sets a string property/value pair for the xth column.  If the
 * property is not supported, an exception is thrown.  The return
 * value indicates whether a previous value was overwritten.
 * Accepted string properties are:
 *	name		name of the column
 *	table		name of the table this column belongs to
 *	schema		name of the schema this column belongs to
 *	type		name of the type of this column
 *
 * @param handle a resultset struct
 * @param col the sequence number of the column starting from 1
 * @param nme a the name of the property
 * @param val the string value of the property
 * @return true if there was a previous value, false otherwise
 */
str
RSsetPropertyStr(int *retval, int *handle, int *colno, str *nme, str *val)
{
	column *col;
	int ret = 0;
	resultset *rs = NULL;
	columnset *cs;
	str tmp;

	rethrow("resultset.setPropertyStr", tmp, RSBgetResultSet(&rs, handle));
	cs = &(rs->columnSet);
	while (cs->nextSet != NULL)
		cs = cs->nextSet;
	if (cs->complete)
		throwRS("resultset.setProperty", "Unable to modify a complete ResultSet");
	if (colno == NULL || *colno == int_nil)
		throwIllArg("resultset.setProperty", "Column index should not be NULL or nil");
	if (*colno <= 0 || *colno > rs->columnCount)
		throwOutOfBndsf("resultset.setProperty", "Column index out of bounds (%d)", *colno);
	if (nme == NULL || *nme == NULL || strNil(*nme))
		throwIllArg("resultset.setProperty", "Property name should not be NULL or nil");
	if (val == NULL || *val == NULL)
		throwIllArg("resultset.setProperty", "Property value should not be NULL");

	col = cs->columns[(*colno) - 1];
@= MX-setPropertyStrNoNil
	if (strcmp("@1", *nme) == 0) {
		if (strNil(*val))
			throwRS("resultset.setProperty", "@1 property value cannot be nil");

		if (col->@1 != NULL) {
			ret = 1;
			GDKfree(col->@1);
		}
		col->@1 = GDKstrdup(*val);
	}
@c
	@:MX-setPropertyStrNoNil(name)@
	else
	@:MX-setPropertyStrNoNil(type)@
	else
@= MX-setPropertyStr
	if (strcmp("@1", *nme) == 0) {
		if (strNil(*val)) *val = "";

		if (col->@1 != NULL) {
			ret = 1;
			GDKfree(col->@1);
		}
		col->@1 = GDKstrdup(*val);
	}
@c
	@:MX-setPropertyStr(table)@
	else
	@:MX-setPropertyStr(schema)@
	else
	throwRSf("resultset.setProperty", "Invalid property '%s'", *nme);

	*retval = ret;
	return (MAL_SUCCEED);
}

/**
 * Sets an integer property/value pair for the xth column.  If the
 * property is not supported, an exception is thrown.  The return
 * value indicates whether a previous value was overwritten.
 * Accepted integer properties are:
 *	digits		digits of this data type
 *	scale		scale of this data type
 *	width		the maximum width of this column
 *
 * @param handle a resultset struct
 * @param col the sequence number of the column starting from 1
 * @param nme a the name of the property
 * @param val the int value of the property
 * @return true if there was a previous value, false otherwise
 */
str
RSsetPropertyInt(int *retval, int *handle, int *colno, str *nme, int *val)
{
	column *col = 0;
	int ret = 0;
	resultset *rs = NULL;
	columnset *cs;
	str tmp;

	rethrow("resultset.setPropertyInt", tmp, RSBgetResultSet(&rs, handle));
	cs = &(rs->columnSet);
	while (cs->nextSet != NULL)
		cs = cs->nextSet;
	if (cs->complete)
		throwRS("resultset.setProperty", "Unable to modify a complete ResultSet");
	if (colno == NULL || *colno == int_nil)
		throwIllArg("resultset.setProperty", "Column index should not be NULL or nil");
	if (*colno <= 0 || *colno > rs->columnCount)
		throwOutOfBndsf("resultset.setProperty", "Column index out of bounds (%d)", *colno);
	if (nme == NULL || *nme == NULL || strNil(*nme))
		throwIllArg("resultset.setProperty", "Property name should not be NULL or nil");
	if (val == NULL || *val == int_nil)
		throwIllArg("resultset.setProperty", "Property value should not be nil");
	if (*val < 0)
		throwIllArgf("resultset.setProperty", "Property value cannot be a negative value (%d)", *val);

	col = cs->columns[(*colno) - 1];
@= MX-setPropertyInt
	if (strcmp("@1", *nme) == 0) {
		if (col->@1 != -1) {
			ret = 1;
		}
		col->@1 = *val;
	}
@c
	@:MX-setPropertyInt(digits)@
	else
	@:MX-setPropertyInt(scale)@
	else
	@:MX-setPropertyInt(width)@
	else
	throwRSf("resultset.setProperty", "Invalid property '%s'", *nme);

	*retval = ret;
	return (MAL_SUCCEED);
}

/**
 * Marks the given ResultSet as being complete.  A ResultSet which
 * is complete, does not allow new columns to be added or properties
 * to be set.  Instead, it does allow serialisation of the ResultSet.
 * To enable proper serialisation of meta-data, all properties that
 * are not set at this time are filled with auto generated values.
 * Note that a ResultSet without column is considered to be an error.
 *
 * @param rs a resultset
 */
static str
RSsetComplete(resultset * rs)
{
	int i;
	columnset *cs;
	column *col;

	cs = &(rs->columnSet);
	while (cs->nextSet != NULL)
		cs = cs->nextSet;

	for (i = 0; i < rs->columnCount; i++) {
		col = cs->columns[i];

		if (col->bat == NULL)
			throwRS("resultset.setComplete", "ResultSet contains at least one column that has not been populated yet");
	}

	cs->complete = (char) 1;

	return (MAL_SUCCEED);
}

/**
 * Unions a new (empty) column set to the last one of the
 * given ResultSet.  Before the set is added, the previous
 * one is first completed.
 *
 * @param rs a resultset
 * @return the same resultset handle
 */
str
RSunion(int *retval, int *handle)
{
	int j;
	resultset *rs = NULL;
	columnset *cs;
	str tmp;

	rethrow("resultset.union", tmp, RSBgetResultSet(&rs, handle));
	cs = &(rs->columnSet);
	while (cs->nextSet != NULL)
		cs = cs->nextSet;

	/* make sure the last column set is complete */
	rethrow("resultset.union", tmp, RSsetComplete(rs));

	/* add a new column set and initialise the values */
	cs = cs->nextSet = GDKmalloc(sizeof(columnset));
	memset(cs, 0, sizeof(columnset));
	cs->columns = GDKmalloc(sizeof(column *) * rs->columnCount);
	memset(cs->columns, 0, sizeof(column *) * rs->columnCount);
	for (j = 0; j < rs->columnCount; j++)
		RSinitColumn(cs, &j);
	cs->length = -1;

	*retval = *handle;
	return (MAL_SUCCEED);
}

/**
 * Removes all the associated BATs and unsets the complete state.
 * Using this function allows a ResultSet to be reused by populating
 * it again.
 *
 * @param handle a resultset handle
 * @return the resultset handle
 */
str
RSdePopulate(int *retval, int *handle)
{
	int i;
	resultset *rs = NULL;
	columnset *cs;
	str tmp;

	rethrow("resultset.dePopulate", tmp, RSBgetResultSet(&rs, handle));
	cs = &(rs->columnSet);

	RSfreeColumnSet(rs, cs->nextSet);

	for (i = 0; i < rs->columnCount; i++) {
		if (cs->columns[i]->bat !=NULL)
			BBPunfix(cs->columns[i]->bat->batCacheid);
		cs->columns[i]->bat = NULL;
	}
	cs->length = -1;
	cs->complete = (char) 0;
	cs->nextSet = NULL;
	rs->length = 0;
	rs->id = RS_nextID++;

	*retval = *handle;
	return (MAL_SUCCEED);
}

/**
 * Writes the header for the ResultSet to the given stream.  Note
 * that the ResultSet should be complete in order for this function
 * to work.
 * This function defines the layout of the protocol.
 *
 * @param handle a resultset handle
 * @param s a stream to write to
 * @returns the number of bytes written
 */
str
RSwriteHeader(int *retval, int *handle)
{
	int bytes = 0, bt, i;
	stream *s = GDKout;
	resultset *rs = NULL;
	column *col;
	str tmp;
	str mask;

	rethrow("resultset.writeHeader", tmp, RSBgetResultSet(&rs, handle));
	if (!rs->columnSet.complete)
		rethrow("resultset.writeHeader", tmp, RSsetComplete(rs));

	/* write start of header */
	if ((bt = stream_printf(s, "%c%c\n", RS_LINE_START_OF_HEADER, rs->type)) <= 0) {
		*retval = 0;
		throwIO("resultset.writeHeader", "Error while writing to the stream");
	}
	bytes += 3;
	/* write single value headers */
@= MX-writeHeaderLineSingleValue
	if ((bt = stream_printf(s, "%c%s\t" @1 "\n", RS_LINE_CONTROL_HEADER, @3, @2)) <= 0)
		throwIO("resultset.writeHeader", "Error while writing to the stream");
	bytes += bt;
@c
	/* serialise the header to the stream */
	@:MX-writeHeaderLineSingleValue("%d",rs->id,"id")@
	@:MX-writeHeaderLineSingleValue("%d",rs->columnCount,"columncount")@
	@:MX-writeHeaderLineSingleValue("%d",rs->length,"tuplecount")@
	/* create columntype charmask */
	mask = tmp = GDKmalloc(sizeof(char) * (rs->columnCount + 1));
	for (i = 0; i < rs->columnCount; i++) {
		col = rs->columnSet.columns[i];

		switch (col->bat->ttype) {
		case TYPE_bit:
			*tmp++ = 'b';
			break;
		case TYPE_chr:
			*tmp++ = 'c';
			break;
		case TYPE_str:
			*tmp++ = 'S';
			break;
		case TYPE_oid:
			*tmp++ = 'o';
			break;
		case TYPE_sht:
			*tmp++ = 's';
			break;
		case TYPE_int:
			*tmp++ = 'i';
			break;
		case TYPE_lng:
			*tmp++ = 'l';
			break;
		case TYPE_flt:
			*tmp++ = 'f';
			break;
		case TYPE_dbl:
			*tmp++ = 'd';
			break;
		case TYPE_ptr:	/* C pointer! */
		case TYPE_bat:	/* BAT id: index in BBPcache */
		default:
			*tmp++ = 'S';
		}
	}
	*tmp = '\0';
	@:MX-writeHeaderLineSingleValue("%s", mask, "ctype")@
	GDKfree(mask);

	/* walk through the columns, and set those properties that are not
	 * yet set, but are a necessity */

	if ((bt = stream_printf(s, "%c%s\t", RS_LINE_HEADER, "column")) > 0) {
		bytes += bt;
		for (i = 0; i < rs->columnCount; i++) {
			col = rs->columnSet.columns[i];

			/* name defaults to column_x */
			if (col->name == NULL) {
				if ((bt = stream_printf(s, "column_%d", i + 1)) < 0)
					throwIO("resultset.writeHeader", "Error while writing to the stream");
			} else {
				if ((bt = stream_printf(s, "%s", col->name)) < 0)
					throwIO("resultset.writeHeader", "Error while writing to the stream");
			}
			bytes += bt;

			/* write column or row separator */
			if (stream_write(s, i < (rs->columnCount - 1) ? "\t" : "\n", 1, 1) != 1) {
				*retval = 0;
				throwIO("resultset.writeHeader", "Error while writing to the stream");
			}
			bytes += 1;
		}
	} else {
		*retval = 0;
		throwIO("resultset.writeHeader", "Error while writing to the stream");
	}
@= MX-writeHeaderLine
	/* serialise the header to the stream */
	if ((bt = stream_printf(s, "%c%s\t", RS_LINE_HEADER, @3)) > 0) {
		bytes += bt;
		for (i = 0; i < rs->columnCount; i++) {
			col = rs->columnSet.columns[i];

			if (@4) {
				if ((bt = stream_printf(s, @1, @2)) < 0)
					throwIO("resultset.writeHeader", "Error while writing to the stream");
				bytes += bt;
			}

			/* write column or row separator */
			if (stream_write(s, i < (rs->columnCount - 1) ? "\t" : "\n", 1, 1) != 1) {
				*retval = 0;
				throwIO("resultset.writeHeader", "Error while writing to the stream");
			}
			bytes += 1;
		}
	} else {
		*retval = 0;
		throwIO("resultset.writeHeader", "Error while writing to the stream");
	}
@c
	/* yeah baby!  dirty as hell! */
	@:MX-writeHeaderLine("%s", col->table, "table", col->table != NULL)@
	@:MX-writeHeaderLine("%s", col->schema, "schema", col->schema != NULL)@
	/* serialise the header to the stream */
	if ((bt = stream_printf(s, "%c%s\t", RS_LINE_HEADER, "type")) > 0) {
		bytes += bt;
		for (i = 0; i < rs->columnCount; i++) {
			col = rs->columnSet.columns[i];

			/* type defaults to the BAT tail type if not set */
			if (col->type == NULL) {
				switch (col->bat->ttype) {
				case TYPE_bit:
					bt = stream_printf(s, "%s", "boolean");
					break;
				case TYPE_chr:
					bt = stream_printf(s, "%s", "char");
					break;
				case TYPE_oid:
					bt = stream_printf(s, "%s", "oid");
					break;
				case TYPE_sht:
					bt = stream_printf(s, "%s", "smallint");
					break;
				case TYPE_int:
					bt = stream_printf(s, "%s", "int");
					break;
				case TYPE_lng:
					bt = stream_printf(s, "%s", "bigint");
					break;
				case TYPE_flt:
					bt = stream_printf(s, "%s", "real");
					break;
				case TYPE_dbl:
					bt = stream_printf(s, "%s", "double");
					break;
				case TYPE_str:
					bt = stream_printf(s, "%s", "varchar");
					break;
				case TYPE_ptr:	/* C pointer! */
				case TYPE_bat:	/* BAT id: index in BBPcache */
				default:
					bt = stream_printf(s, "%s", "varchar");
				}
			} else {
				if ((bt = stream_printf(s, "%s", col->type)) < 0)
					throwIO("resultset.writeHeader", "Error while writing to the stream");
			}
			bytes += bt;

			/* write column or row separator */
			if (stream_write(s, i < (rs->columnCount - 1) ? "\t" : "\n", 1, 1) != 1) {
				*retval = 0;
				throwIO("resultset.writeHeader", "Error while writing to the stream");
			}
			bytes += 1;
		}
	} else {
		*retval = 0;
		throwIO("resultset.writeHeader", "Error while writing to the stream");
	}
	@:MX-writeHeaderLine("%d", col->digits, "digits", col->digits > -1)@
	@:MX-writeHeaderLine("%d", col->scale, "scale", col->scale > -1)@
	/* serialise the header to the stream */
	if ((bt = stream_printf(s, "%c%s\t", RS_LINE_HEADER, "width")) > 0) {
		bytes += bt;
		for (i = 0; i < rs->columnCount; i++) {
			col = rs->columnSet.columns[i];

			/* calculate width if not set */
			if (col->width == -1) {
				int width = 0;
				if ((tmp = RStailWidth(&width, col->bat)) != MAL_SUCCEED)
					 return (tmp);

				if ((bt = stream_printf(s, "%d", width)) < 0)
					throwIO("resultset.writeHeader", "Error while writing to the stream");
			} else {
				if ((bt = stream_printf(s, "%d", col->width)) < 0)
					throwIO("resultset.writeHeader", "Error while writing to the stream");
			}
			bytes += bt;

			/* write column or row separator */
			if (stream_write(s, i < (rs->columnCount - 1) ? "\t" : "\n", 1, 1) != 1) {
				*retval = 0;
				throwIO("resultset.writeHeader", "Error while writing to the stream");
			}
			bytes += 1;
		}
	} else {
		*retval = 0;
		throwIO("resultset.writeHeader", "Error while writing to the stream");
	}

	*retval = bytes;
	return (MAL_SUCCEED);
}

/**
 * Writes a block of results for the ResultSet to the given stream.
 * The block of results starts from upper (inclusive) to lower
 * (exclusive), and will count (upper - lower) rows.  Note
 * that the ResultSet should be complete in order for this function
 * to work.
 * This function defines the layout of the protocol.
 *
 * @param handle a resultset handle
 * @param s a stream to write to
 * @param upper till which row of the result (exclusive)
 * @param lower from which row of the result (inclusive)
 * @returns the number of bytes written
 */
str
RSwriteBlock(int *retval, int *handle, lng *upper, lng *lower)
{
	int bytes = 0, bt, i;
	column *col;
	resultset *rs = NULL;
	columnset *cs;
	str tmp;
	stream *s = GDKout;
	lng low = *lower, up = *upper;
	ptr p;

	rethrow("resultset.writeBlock", tmp, RSBgetResultSet(&rs, handle));
	if (low < 0)
		throwOutOfBndsf("resultset.writeBlock", "Lower index out of bounds (%d < 0)", low);
	if (up > (lng) rs->length)
		throwOutOfBndsf("resultset.writeBlock", "Upper index out of bounds (%d > ResultSet length)", up);
	if (low >= up)
		throwIllArg("resultset.writeBlock", "Lower index should be smaller than upper index");

	cs = &(rs->columnSet);
	do {
		if (cs->complete == 0)
			rethrow("resultset.writeBlock", tmp, RSsetComplete(rs));

		/* correct lower value if necessary */
		if (low >= (lng) cs->length) {
			low -= cs->length;
			up -= cs->length;
		} else {
			break;
		}
	} while ((cs = cs->nextSet) != NULL);

	if (cs == NULL)
		throwRS("resultset.writeBlock", "Panic! lower value seems to be higher than the actual size!");

	/* initialise all column BUN pointers */
	for (i = 0; i < rs->columnCount; i++) {
		col = cs->columns[i];
		col->bun = (BUN) ((char *) BUNfirst(col->bat) + BUNsize(col->bat) * low);
	}
	/* write the desired block of results */
	for (; low < up; low++) {
		/* if we run out of our BAT... */
		if (low >= (lng) cs->length) {
			/* ... we have to do a move again ... */
			low -= cs->length;
			up -= cs->length;
			/* ... and put the next column set in place */
			cs = cs->nextSet;

			if (cs == NULL)
				throwRS("resultset.writeBlock", "Panic! lower value seems to be higher than the actual size!");
			/* initialise all column BUN pointers */
			for (i = 0; i < rs->columnCount; i++) {
				col = cs->columns[i];
				col->bun = (BUN) ((char *) BUNfirst(col->bat) + BUNsize(col->bat) * low);
			}
		}

		if ((bt = stream_printf(s, "%c", RS_LINE_TUPLE)) <= 0) {
			bytes = 0;
			break;
		}
		bytes += bt;
		for (i = 0; i < rs->columnCount; i++) {
			col = cs->columns[i];
			/* write value */
			p = (ptr) BUNtail(col->bat, col->bun);

			if (!p)
				throwRS("resultset.writeBlock", "Illegal tail value pointer: NULL");

@= MX-writeNull
			if (@1) {
				stream_write(s, "NULL", 1, 4);
				bytes += 4;
				break;
			}
@c
			switch (col->bat->ttype) {
				case TYPE_bit:
					@:MX-writeNull(*(unsigned char *) p == bit_nil)@
					bt = stream_printf(s, "%d", (*(unsigned char *) p ? 1 : 0));
					break;
				case TYPE_chr:
					@:MX-writeNull(*(char *) p == chr_nil)@
					bt = stream_printf(s, "%c", *(char *) p);
					break;
				case TYPE_str:
					@:MX-writeNull(strNil(p))@
					bt = stream_printf(s, "%d:%s", strlen(p), p);
					break;
				case TYPE_oid:
					@:MX-writeNull(*(size_t *) p == oid_nil)@
					bt = stream_printf(s, "%d", *(size_t *) p);
					break;
				case TYPE_sht:
					@:MX-writeNull(*(sht *) p == sht_nil)@
					bt = stream_printf(s, "%hd", *(sht *) p);
					break;
				case TYPE_int:
					@:MX-writeNull(*(int *) p == int_nil)@
					bt = stream_printf(s, "%d", *(int *) p);
					break;
				case TYPE_lng:
					@:MX-writeNull(*(lng *) p == lng_nil)@
					bt = stream_printf(s, LLFMT, *(lng *) p);
					break;
				case TYPE_flt:
					@:MX-writeNull(*(flt *) p == flt_nil)@
					bt = stream_printf(s, "%e", *(flt *) p);
					break;
				case TYPE_dbl:
					@:MX-writeNull(*(dbl *) p == dbl_nil)@
					bt = stream_printf(s, "%e", *(dbl *) p);
					break;
				case TYPE_ptr:	/* C pointer! */
				case TYPE_bat:	/* BAT id: index in BBPcache */
				default:
					{
						str buf = NULL;
						int len = 0, size = 0;
						len = (*BATatoms[col->bat->ttype].atomToStr) (&buf, &size, p);

						bt = stream_printf(s, "%d:%s", len, buf);
						GDKfree(buf);
					}
			}

			/* advance to the next value in the BAT */
			col->bun = BUNnext(col->bat, col->bun);

			/* write column or row separator */
			if (stream_write(s, i < (rs->columnCount - 1) ? "\t" : "\n", 1, 1) != 1) {
				bytes = 0;
				break;
			}
			bytes += 1;
		}
	}

	/* stream_errnr(s) ? */

	*retval = bytes;
	if (bytes) {
		return (MAL_SUCCEED);
	} else {
		throwIO("resultset.writeBlock", "Error while writing to the stream");
	}
}

/**
 * Retrieves the length of the ResultSet measured in number of rows.
 *
 * @param handle a resultset handle
 * @returns the number of rows in the ResultSet
 */
str
RSgetLength(int *retval, int *handle)
{
	resultset *rs = NULL;
	str tmp;

	rethrow("resultset.getLength", tmp, RSBgetResultSet(&rs, handle));
	if (!rs->columnSet.complete)
		throwRS("resultset.getLength", "Unable to get length of a non-complete ResultSet");

	*retval = rs->length;
	return (MAL_SUCCEED);
}

/**
 * Sets the block size as used by writeNextPart.
 *
 * @param handle a resultset handle
 * @param size the size
 * @return the handle
 */
str
RSsetBlockSize(int *retval, int *handle, int size)
{
	resultset *rs = NULL;
	str tmp;

	rethrow("resultset.setBlockSize", tmp, RSBgetResultSet(&rs, handle));
	/* is this useful?  I don't see any problems now
	   if (!rs->columnSet.complete)
	   return(throwMessage("resultset.setBlockSize", "Unable to serialise a non-complete ResultSet"));
	 */

	rs->blocksize = size;
	*retval = *handle;
	return (MAL_SUCCEED);
}

/**
 * Returns the number of blocks that can be retrieved using
 * writeNextPart.  The number is based on the current internal
 * position counter and a step size as defined by a setBlockSize
 * call.  If the block size is 0 (default) an infinite block is
 * assumed.
 *
 * @param handle a resultset handle
 * @return the number of times writeNextPart can be called
 */
str
RShasNextPart(int *retval, int *handle)
{
	resultset *rs = NULL;
	str tmp;

	rethrow("resultset.hasNextPart", tmp, RSBgetResultSet(&rs, handle));
	if (!rs->columnSet.complete)
		rethrow("resultset.hasNextPart", tmp, RSsetComplete(rs));

	if (rs->blocksize > 0) {
		*retval = rs->pos < rs->length ? ((rs->length - rs->pos) / rs->blocksize) + 1 : 0;
	} else {
		*retval = rs->pos < rs->length;
	}
	return (MAL_SUCCEED);
}

/**
 * Writes the next part to the stream.  If it is the first part,
 * the header will be written to the stream first.  The size of the
 * blocks is determined by the value supplied via the setBlockSize
 * function.  If the block size is 0 (default) an infinite block is
 * assumed.
 *
 * @param handle a resultset handle
 * @param s a stream to write to
 * @return the number of bytes written
 */
str
RSwriteNextPart(int *retval, int *handle)
{
	int hbytes = 0, bbytes = 0;
	lng upper, lower;
	resultset *rs = NULL;
	str tmp;

	rethrow("resultset.writeNextPart", tmp, RSBgetResultSet(&rs, handle));
	if (!rs->columnSet.complete)
		rethrow("resultset.writeNextPart", tmp, RSsetComplete(rs));

	if (rs->pos < rs->length) {
		if (rs->blocksize == 0) {
			/* serialise the whole result */
			lower = (lng) rs->pos;
			upper = (lng) rs->length;
		} else {
			/* serialise only a block */
			lower = (lng) rs->pos;
			upper = (lng) (rs->pos + rs->blocksize);
			if (upper > (lng) rs->length)
				upper = (lng) rs->length;
		}
	} else {
		throwRS("resultset.writeNextPart", "No next part, all rows already serialised");
	}

	if (rs->pos == 0) {
		/* write header */
		rethrow("resultset.writeNextPart", tmp, RSwriteHeader(&hbytes, handle));
	}

	/* write block of results */
	rethrow("resultset.writeNextPart", tmp, RSwriteBlock(&bbytes, handle, &upper, &lower));

	*retval = hbytes + bbytes;
	return (MAL_SUCCEED);
}

/**
 * Interface requirement.  The input string is discarded and null
 * is returned.
 *
 * @param val input string
 * @return always null
 */
str
RSfromString(str *src, int *len, resultset * retval)
{
	(void) src;		/* make compiler happy */
	(void) retval;
	(void) len;
	return (MAL_SUCCEED);
}

/**
 * Interface requirement.  Returns a string indicating the given
 * ResultSet is a ResultSet.
 *
 * @param handle input ResultSet handle
 * @return "ResultSet"
 */
int
RStoString(str *retval, int *len, ptr handle)
{
	resultset *rs = NULL;

	if (RSBgetResultSet(&rs, handle) != MAL_SUCCEED) {
		if (*retval == NULL)
			*retval = GDKmalloc(sizeof(str) * 4);
		strcpy(*retval, "NULL");
		return (*len = 4);
	}

	/* you can do all kinds of fancy things like telling how much
	 * columns it has, what size it has, and stuff like that...
	 * but that's not worth the work for now
	 */
	if (*retval == NULL) {
		*retval = GDKmalloc(sizeof(str) * (*len = 13 + 10));
	}
	return (*len = snprintf(*retval, *len, "ResultSet '" SZFMT "'", rs->id));
}

@}
@}
