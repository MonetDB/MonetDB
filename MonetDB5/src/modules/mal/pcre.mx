@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f pcre
@a N. Nes
@+ PCRE library interface
The  PCRE library is a set of functions that implement regular expres-
sion pattern matching using the same syntax  and  semantics  as  Perl,
with  just  a  few  differences.  The  current  implementation of PCRE
(release 4.x) corresponds approximately with Perl 5.8, including  sup-
port  for  UTF-8  encoded  strings.   However,  this support has to be
explicitly enabled; it is not the default.

@mal
atom pcre:ptr;
command tostr()   address pcre_tostr;
command fromstr() address pcre_fromstr;
command nequal()  address pcre_nequal;
command hash()    address pcre_hash;
command null()    address pcre_null;
command put()     address pcre_put;
command del()     address pcre_del;
command length()  address pcre_length;
command heap()    address pcre_heap;

command compile(pat:str ) :pcre 
address PCREcompile_wrap
comment "compile a pattern";

command match(pat:pcre, s:str) :bit 
address PCREexec_wrap
comment "match a pattern";

command select(pat:str, strs:bat[:any_1,:str]) :bat[:any_1,:str] 
address PCREselect
comment "Select tuples based on the pattern";

command uselect(pat:str, strs:bat[:any_1,:str]) :bat[:any_1,:void] 
address PCREuselect
comment "Select tuples based on the pattern, only returning the head";

command match(s:str, pat:str):bit
address PCREmatch
comment "POSIX pattern matching against a string";

command patindex(s:str, pat:str):int
address PCREpatindex
comment "Location of the first POSIX pattern matching against a string"

command replace(origin:str,pat:str,repl:str,flags:str):str
address PCREreplace_wrap
comment "Replace _all_ matches of \"pattern\" in \"origin_str\" with
	   \"replacement\".\n\
	 Parameter \"flags\" accept these flags: 'i', 'm', 's', and 'x'.\n
	   'e': if present, an empty string is considered to be a valid match
	   'i': if present, the match operates in case-insensitive mode. Otherwise, in\n
			case-sensitive mode.\n\
	 'm': if present, the match operates in multi-line mode.\n
	   's': if present, the match operates in \"dot-all\"
	   The specifications of the flags can be found in \"man pcreapi\"\n
	   The flag letters may be repeated.\n
	   No other letters than 'e', 'i', 'm', 's' and 'x' are allowed in \"flags\".\n
	   Returns the replaced string, or if no matches found, the original string.";

command replace(orig:bat[:any_1,:str],pat:str,repl:str,flag:str):bat[:any_1,:str]
address PCREreplace_bat_wrap;

command pcre_quote(s:str):str 
address PCREquote
comment "Return a PCRE pattern string that matches the argument exactly."

command sql2pcre(pat:str,esc:str):str
address PCREsql2pcre
comment "Convert a SQL like pattern with the given escape character into a PCRE pattern.";

command like(s:str, pat:str, esc:str):bit 
address PCRElike3;

command like(s:str, pat:str):bit 
address PCRElike2;

command like(s:bat[:any_1,:str], pat:str, esc:str):bat[:any_1,:void] 
address PCRElike_uselect_pcre;

pattern prelude():void 
address pcre_init
comment "Initialize pcre";

pcre.prelude();
@{
@-
\begin{center}
ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre
\end{center}

@+ Implementation
@include prelude.mx
@c
#include "mal.h"
#include "mal_exception.h"


#ifdef WIN32
#ifndef HAVE_LIBPCRE
#define pcre_export extern __declspec(dllimport)
#else
#define pcre_export extern __declspec(dllexport)
#endif
#else
#define pcre_export extern
#endif

#ifndef HAVE_LIBPCRE
#define pcre str
#else
#include <pcre.h>
#endif

pcre_export str PCREquote(str *r, str *v);
pcre_export str PCREselect(int *res, str *pattern, int *bid);
pcre_export str PCREuselect(int *res, str *pattern, int *bid);
pcre_export str PCREmatch(bit *ret, str *val, str *pat);
pcre_export str PCREpatindex(int *ret, str *val, str *pat);
pcre_export str PCREfromstr(str instr, int *l, pcre ** val);

pcre_export str PCREreplace_wrap(str *res, str *or, str *pat, str *repl, str *flags);
pcre_export str PCREreplace_bat_wrap(int *res, int *or, str *pat, str *repl, str *flags);

pcre_export str PCREcompile_wrap(pcre ** res, str *pattern);
pcre_export str PCREexec_wrap(bit *res, pcre * pattern, str *s);
pcre_export int pcre_tostr(str *tostr, int *l, pcre * p);
pcre_export int pcre_fromstr(str instr, int *l, pcre ** val);
pcre_export int pcre_nequal(pcre * l, pcre * r);
pcre_export hash_t pcre_hash(pcre * b);
pcre_export pcre * pcre_null(void);
pcre_export void pcre_del(Heap *h, var_t *index);
pcre_export int pcre_length(pcre * p);
pcre_export void pcre_heap(Heap *heap, size_t capacity);
pcre_export var_t pcre_put(Heap *h, var_t *bun, pcre * val);
pcre_export str PCRElike3(bit *ret, str *s, str *pat, str *esc);
pcre_export str PCRElike2(bit *ret, str *s, str *pat);
pcre_export str PCRElike_uselect_pcre(int *ret, int *b, str *pat, str *esc);
pcre_export str pcre_init(void);

#ifndef HAVE_LIBPCRE

int
pcre_compile_wrap(pcre ** res, str pattern)
{
	(void) res;
	(void) pattern;

	return GDK_FAIL;
}

int
pcre_exec_wrap(bit *res, pcre * pattern, str s)
{
	(void) res;
	(void) pattern;
	(void) s;

	return GDK_FAIL;
}

int
pcre_select(BAT **res, str pattern, BAT *strs)
{
	(void) res, (void) pattern;
	(void) strs;

	return GDK_FAIL;
}

int
pcre_uselect(BAT **res, str pattern, BAT *strs)
{
	(void) res, (void) pattern;
	(void) strs;

	return GDK_FAIL;
}

int
pcre_replace(str *res, str origin_str, str pattern, str replacement, str flags)
{
	(void) res;
	(void) origin_str;
	(void) pattern;
	(void) replacement;
	(void) flags;
	GDKerror("pcre_replace() not available as required version of libpcre was not found by configure.\n");
	return GDK_FAIL;
}

int
pcre_replace_bat(BAT **res, BAT *origin_strs, str pattern, str replacement, str flags)
{
	(void) res;
	(void) origin_strs;
	(void) pattern;
	(void) replacement;
	(void) flags;
	GDKerror("pcre_replace_bat() not available as required version of libpcre was not found by configure.\n");
	return GDK_FAIL;
}

str 
pcre_init(void)
{
	return NULL;
}

void
pcre_exit(void)
{
}

int
pcre_match(bit *ret, str val, str pat)
{
	(void) ret;
	(void) val;
	(void) pat;
	GDKerror("pcre_match() not available as required version of libpcre was not found by configure.\n");
	return GDK_FAIL;
}

int
pcre_patindex(int *ret, str val, str pat)
{
	(void) ret;
	(void) val;
	(void) pat;
	GDKerror("pcre_patindexmatch() not available as required version of libpcre was not found by configure.\n");
	return GDK_FAIL;
}
#else

#define m2p(p) (pcre*)(((sht*)p)+1)
#define p2m(p) (pcre*)(((sht*)p)-1)

void *
my_pcre_malloc(size_t s)
{
	char *r = GDKmalloc(s + sizeof(sht));
	sht *sz = (sht *) r;

	*sz = s + sizeof(sht);
	return (void *) (sz + 1);
}

void
my_pcre_free(void *blk)
{
	sht *sz = (sht *) blk;

	sz -= 1;
	GDKfree((void *) sz);
}

int
pcre_compile_wrap(pcre ** res, str pattern)
{
	pcre *r;
	const char err[BUFSIZ], *err_p = err;
	int errpos = 0;

	if ((r = pcre_compile(pattern, PCRE_UTF8, &err_p, &errpos, NULL)) == NULL) {
		return GDK_FAIL;
	}
	*(pcre **) res = p2m(r);
	return GDK_SUCCEED;
}

int
pcre_exec_wrap(bit *res, pcre * pattern, str s)
{
	if (pcre_exec(m2p(pattern), NULL, s, strlen(s), 0, 0, NULL, 0) >= 0) {
		*res = TRUE;
	} else {
		*res = FALSE;
	}
	return GDK_SUCCEED;
}

int
pcre_select(BAT **res, str pattern, BAT *strs)
{
	const char err[BUFSIZ], *err_p = err;
	int errpos = 0;
	BAT *r;
	BUN p, q;
	pcre *re = NULL;

	if (strs->htype == TYPE_void)
		r = BATnew(TYPE_oid, TYPE_str, BATcount(strs));
	else
		r = BATnew(strs->htype, TYPE_str, BATcount(strs));
	if ((re = pcre_compile(pattern, PCRE_UTF8, &err_p, &errpos, NULL)) == NULL) {
		GDKerror("pcre_select: pcre compile of pattern (%s) failed at %d with\n'%s'.\n",
			pattern, errpos, err_p);
		return GDK_FAIL;
	}
	BATloop(strs, p, q) {
		str s = BUNtail(strs, p);

		if (pcre_exec(re, NULL, s, strlen(s), 0, 0, NULL, 0) >= 0) {
			BUNins(r, BUNhead(strs, p), s, FALSE);
		}
	}
	if (!(r->batDirty&2)) r = BATsetaccess(r, BAT_READ);
	my_pcre_free(re);
	*res = r;
	return GDK_SUCCEED;
}

int
pcre_uselect(BAT **res, str pattern, BAT *strs)
{
	const char err[BUFSIZ], *err_p = err;
	int errpos = 0;
	BAT *r;
	BUN p, q;
	pcre *re = NULL;

	if (strs->htype == TYPE_void)
		r = BATnew(TYPE_oid, TYPE_void, BATcount(strs));
	else
		r = BATnew(strs->htype, TYPE_void, BATcount(strs));
	if ((re = pcre_compile(pattern, PCRE_UTF8, &err_p, &errpos, NULL)) == NULL) {
		GDKerror("pcre_uselect: pcre compile of pattern (%s) failed at %d with\n'%s'.\n",
			pattern, errpos, err_p);
		return GDK_FAIL;
	}
	BATloop(strs, p, q) {
		str s = BUNtail(strs, p);

		if (pcre_exec(re, NULL, s, strlen(s), 0, 0, NULL, 0) >= 0) {
			BUNins(r, BUNhead(strs, p), NULL, FALSE);
		}
	}
	my_pcre_free(re);
	if (!(r->batDirty&2)) r = BATsetaccess(r, BAT_READ);
	*res = r;
	return GDK_SUCCEED;
}

#define MAX_NR_CAPTURES  1024 /* Maximal number of captured substrings in one original string */

int
pcre_replace(str *res, str origin_str, str pattern, str replacement, str flags)
{
	const char err[BUFSIZ], *err_p = err, *err_p2 = err;
	pcre *pcre_code = NULL;
	pcre_extra *extra;
	str tmpres;
	int i, j, k, len, errpos = 0, offset = 0;
	int compile_options = PCRE_UTF8, exec_options = PCRE_NOTEMPTY;
	int *ovector, ovecsize;
	int len_origin_str = strlen(origin_str);
	int len_replacement = strlen(replacement);
	int capture_offsets[MAX_NR_CAPTURES * 2], ncaptures = 0, len_del = 0;
	
	for (i = 0; i < (int)strlen(flags); i++) {
		if (flags[i] == 'e') {
			exec_options -= PCRE_NOTEMPTY;
			stream_printf(GDKout, "exec_options %d, PCRE_NOTEMPTY %d\n",
					exec_options, PCRE_NOTEMPTY);
		} else if (flags[i] == 'i') {
			compile_options |= PCRE_CASELESS;
		} else if (flags[i] == 'm') {
			compile_options |= PCRE_MULTILINE;
		} else if (flags[i] == 's') {
			compile_options |= PCRE_DOTALL;
		} else if (flags[i] == 'x') {
			compile_options |= PCRE_EXTENDED;
		} else {
			GDKerror("pcre_replace: \"flags\" contains invalid character '%c'\n", flags[i]);
			return GDK_FAIL;
		}
	}

	if ((pcre_code = pcre_compile(pattern, compile_options, &err_p, &errpos, NULL)) == NULL) {
		GDKerror("pcre_replace: pcre compile of pattern (%s) failed at %d with\n'%s'.\n", pattern, errpos, err_p);
		return GDK_FAIL;
	}

	/* Since the compiled pattern is going to be used several times, it is
	 * worth spending more time analyzing it in order to speed up the time
	 * taken for matching.
	 */
	extra = pcre_study(pcre_code, 0, &err_p2);
	pcre_fullinfo(pcre_code, extra, PCRE_INFO_CAPTURECOUNT, &i);
	ovecsize = (i + 1) * 3;
	if ((ovector = (int *) GDKmalloc(sizeof(int) * ovecsize)) == NULL) {
		GDKerror("pcre_replace: not enough memory\n");
		my_pcre_free(pcre_code);
		return GDK_FAIL;
	}
	
	i = 0;
	do {
		j = pcre_exec(pcre_code, extra, origin_str, len_origin_str, 
						offset, exec_options, ovector, ovecsize);
		if (j > 0){
			capture_offsets[i] = ovector[0];
			capture_offsets[i+1] = ovector[1];
			ncaptures++;
			i += 2;
			len_del += (ovector[1] - ovector[0]);
			offset = ovector[1];
		}
	} while((j > 0) && (offset < len_origin_str) && (ncaptures < MAX_NR_CAPTURES));
	
	if (ncaptures > 0){
		tmpres = GDKmalloc(len_origin_str - len_del + (len_replacement * ncaptures) + 1);
		if (!tmpres) {
			GDKerror("pcre_replace: not enough memory\n");
			my_pcre_free(pcre_code);
			GDKfree(ovector);
			return GDK_FAIL;
		}

		j = k = 0;

		/* possibly copy the substring before the first captured substring */
		strncpy(tmpres, origin_str, capture_offsets[j]); 
		k = capture_offsets[j];
		j++;

		for (i = 0; i < ncaptures - 1; i++) {
			strncpy(tmpres+k, replacement, len_replacement);
			k += len_replacement;
			/* copy the substring between two captured substrings */
			len = capture_offsets[j+1] - capture_offsets[j];
			strncpy(tmpres+k, origin_str+capture_offsets[j], len);
			k += len;
			j += 2;
		}

		/* replace the last captured substring */
		strncpy(tmpres+k, replacement, len_replacement);
		k += len_replacement;
		/* possibly copy the substring after the last captured substring */
		len = len_origin_str - capture_offsets[j];
		strncpy(tmpres+k, origin_str+capture_offsets[j], len);
		k += len;
		tmpres[k] = '\0';
	} else { /* no captured substrings, return the original string*/
		tmpres = GDKstrdup(origin_str);
	}

	my_pcre_free(pcre_code);
	GDKfree(ovector);
	*res = tmpres;
	return GDK_SUCCEED;
}

int
pcre_replace_bat(BAT **res, BAT *origin_strs, str pattern, str replacement, str flags)
{
	const char err[BUFSIZ], *err_p = err, *err_p2 = err;
	int i, j, k, len, errpos = 0, offset = 0;
	int compile_options = PCRE_UTF8, exec_options = PCRE_NOTEMPTY;
	pcre *pcre_code = NULL;
	pcre_extra *extra;
	BAT *tmpbat;
	BUN p, q;
	int *ovector, ovecsize;
	int len_origin_str, len_replacement = strlen(replacement);
	int capture_offsets[MAX_NR_CAPTURES * 2], ncaptures = 0, len_del = 0;
	str origin_str, replaced_str;

	for (i = 0; i < (int)strlen(flags); i++) {
		if (flags[i] == 'e') {
			exec_options |= (~PCRE_NOTEMPTY);
		} else if (flags[i] == 'i') {
			compile_options |= PCRE_CASELESS;
		} else if (flags[i] == 'm') {
			compile_options |= PCRE_MULTILINE;
		} else if (flags[i] == 's') {
			compile_options |= PCRE_DOTALL;
		} else if (flags[i] == 'x') {
			compile_options |= PCRE_EXTENDED;
		} else {
			GDKerror("pcre_replace_bat: \"flags\" contains invalid character '%c'\n", flags[i]);
			return GDK_FAIL;
		}
	}

	if ((pcre_code = pcre_compile(pattern, compile_options, &err_p, &errpos, NULL)) == NULL) {
		GDKerror("pcre_replace_bat: pcre compile of pattern (%s) failed at %d with\n'%s'.\n", pattern, errpos, err_p);
		return GDK_FAIL;
	}

	/* Since the compiled pattern is ging to be used several times, it is worth spending 
	 * more time analyzing it in order to speed up the time taken for matching.
	 */
	extra = pcre_study(pcre_code, 0, &err_p2);
	pcre_fullinfo(pcre_code, extra, PCRE_INFO_CAPTURECOUNT, &i);
	ovecsize = (i + 1) * 3;
	if ((ovector = (int *) GDKzalloc(sizeof(int) * ovecsize)) == NULL) {
		GDKerror("pcre_replace_bat: not enough memory\n");
		my_pcre_free(pcre_code);
		return GDK_FAIL;
	}
	
	tmpbat = BATnew(origin_strs->htype, TYPE_str, BATcount(origin_strs));
	BATloop(origin_strs, p, q) {
		origin_str = BUNtail(origin_strs, p);
		len_origin_str = strlen(origin_str);
		i = ncaptures = len_del = offset = 0;
		do {
			j = pcre_exec(pcre_code, extra, origin_str, len_origin_str, offset,
					exec_options, ovector, ovecsize);
			if (j > 0){
				capture_offsets[i] = ovector[0];
				capture_offsets[i+1] = ovector[1];
				ncaptures++;
				i += 2;
				len_del += (ovector[1] - ovector[0]);
				offset = ovector[1];
			}
		} while((j > 0) && (offset < len_origin_str) && (ncaptures < MAX_NR_CAPTURES));
	
		if (ncaptures > 0){
			replaced_str = GDKmalloc(len_origin_str - len_del + (len_replacement * ncaptures) + 1);
			if (!replaced_str) {
				GDKerror("pcre_replace_bat: not enough memory\n");
				my_pcre_free(pcre_code);
				GDKfree(ovector);
				return GDK_FAIL;
			}

			j = k = 0;

			/* copy eventually the substring before the first captured
			 * substring */
			strncpy(replaced_str, origin_str, capture_offsets[j]); 
			k = capture_offsets[j];
			j++;

			for (i = 0; i < ncaptures - 1; i++) {
				strncpy(replaced_str+k, replacement, len_replacement);
				k += len_replacement;
				/* copy the substring between two captured substrings */
				len = capture_offsets[j+1] - capture_offsets[j];
				strncpy(replaced_str+k, origin_str+capture_offsets[j], len);
				k += len;
				j += 2;
			}

			/* replace the last captured substring */
			strncpy(replaced_str+k, replacement, len_replacement);
			k += len_replacement;
			/* copy eventually the substring after the last captured substring */
			len = len_origin_str - capture_offsets[j];
			strncpy(replaced_str+k, origin_str+capture_offsets[j], len);
			k += len;
			replaced_str[k] = '\0';
			BUNins(tmpbat, BUNhead(origin_strs, p), replaced_str, FALSE);
			GDKfree(replaced_str);
		} else { /* no captured substrings, copy the original string into new bat */
			BUNins(tmpbat, BUNhead(origin_strs, p), origin_str, FALSE);
		}
	}

	my_pcre_free(pcre_code);
	GDKfree(ovector);
	if (origin_strs->htype == TYPE_void) {
		*res = BATseqbase(tmpbat, origin_strs->hseqbase);
	} else {
		*res = tmpbat;
	}
	return GDK_SUCCEED;
}

str 
pcre_init(void)
{
	pcre_malloc = my_pcre_malloc;
	pcre_free = my_pcre_free;
	return NULL;
}

void
pcre_exit(void)
{
}

int
pcre_match(bit *ret, str val, str pat)
{
	const char err[BUFSIZ], *err_p = err;
	int errpos = 0;
	pcre *re;

	if ((re = pcre_compile(pat, PCRE_UTF8, &err_p, &errpos, NULL)) == NULL){
		GDKerror("pcre.match", "Compilation of regular expression (%s) failed at %d with '%s'", pat, errpos, err_p);
		return GDK_FAIL;
	}
	*ret = pcre_exec(re, NULL, val, strlen(val), 0, 0, NULL, 0) >= 0;
	return GDK_SUCCEED;
}

int
pcre_patindex(int *ret, str val, str pat)
{
	const char err[BUFSIZ], *err_p = err;
	int errpos = 0;
	pcre *re;
	
	if ((re = pcre_compile(pat, PCRE_UTF8, &err_p, &errpos, NULL)) == NULL) {
		GDKerror("pcre.match", "Compilation of regular expression (%s) failed at %d with '%s'", pat, errpos, err_p);
		return GDK_FAIL;
	}
	*ret = pcre_exec(re, NULL, val, strlen(val), 0, 0, NULL, 0);
	return GDK_SUCCEED;
}
#endif

int
pcre_quote(str *res, str s)
{
	str p;

	*res = p = GDKmalloc(strlen(s) * 2 + 1); /* certainly long enough */
	if (p == NULL)
		return GDK_FAIL;
	/* quote all non-alphanumeric ASCII characters (i.e. leave
	   non-ASCII and alphanumeric alone) */
	while (*s) {
		if (!((*s & 0x80) != 0 ||
		      ('a' <= *s && *s <= 'z') ||
		      ('A' <= *s && *s <= 'Z') ||
		      ('0' <= *s && *s <= '9')))
			*p++ = '\\';
		*p++ = *s++;
	}
	*p = 0;
	return GDK_SUCCEED;
}

int
pcre_tostr(str *tostr, int *l, pcre * p)
{
	(void) tostr;
	(void) l;
	(void) p;
	return GDK_FAIL;
}

int
pcre_fromstr(str instr, int *l, pcre ** val)
{
	(void) l;
	return pcre_compile_wrap(val, instr);
}

int
pcre_nequal(pcre * l, pcre * r)
{
	if (l != r)
		return 0;
	else
		return 1;
}

hash_t
pcre_hash(pcre * b)
{
	return *(sht *) b;
}

pcre *
pcre_null(void)
{
	static sht nullval, *r;

	nullval = ~(sht) 0;
	r = &nullval;
	return ((pcre *) (r));
}

void
pcre_del(Heap *h, var_t *index)
{
	HEAP_free(h, *index);
}

#define pcresize(val) ((sht*)val)[0]

var_t
pcre_put(Heap *h, var_t *bun, pcre * val)
{
	char *base;

	*bun = HEAP_malloc(h, pcresize(val));
	base = h->base;
	if (*bun)
		memcpy(&base[*bun], (char *) val, pcresize(val));
	return *bun;
}

int
pcre_length(pcre * p)
{
	return (pcresize(p));
}

void
pcre_heap(Heap *heap, size_t capacity)
{
	HEAP_initialize(heap, capacity, 0, (int) sizeof(var_t));
}

/* change SQL LIKE pattern into PCRE pattern */
int
sql2pcre(str *r, str pat, str esc_str) 
{
	/* change the SQL wilcards into PCRE wildcards */
	int len = (int) strlen(pat);
	int escaped = 0;
	int hasWildcard = 0;
	char *ppat = GDKmalloc(len*2+3 /* 3 = "^'the translated regexp'$0" */);
	int esc = esc_str[0]; /* should change to utf8_convert() */
	int specials = 0;

	*r = ppat;
	/*
	# the escape character can be a char which is special in a PCRE
	# if the user used the "+" char as escape and has "++" in
	# its pattern, then replacing this with "+" is not correct
	# but should be "\+"
	*/
	if (*esc_str && strchr( ".+*()[]", esc) != NULL) 
		specials = 1; 

	*ppat ++ = '^';
	while (*pat) {
		int c = *pat++;

		if (c == esc) {
			if (escaped) {
				if (specials) { /* change ++ into \\+ */
					*ppat++ = esc;
				} else { /* do not escape simple escape symbols */
					ppat[-1] = esc;
				}
				escaped = 0;
			} else {
				*ppat++ = '\\';
				escaped = 1;
			}
			/* not optimal but functional */
			hasWildcard = 1; 
		} else if (strchr( ".+*()[]\\", c) != NULL) {
			*ppat++ = '\\';
			*ppat++ = c;
			/* not optimal but functional */
			hasWildcard = 1; 
			escaped = 0;
		} else if (c == '%' && !escaped) {
			*ppat++ = '.';
			*ppat++ = '*';
			hasWildcard = 1;
		} else if (c == '_' && !escaped) {
			*ppat++ = '.';
			hasWildcard = 1;
		} else {
			*ppat++ = c;
			escaped = 0;
		}
	}
	/* no wildcard or escape character at end of string */
	if (!hasWildcard || escaped) {
		GDKfree(*r);
		*r = GDKstrdup(str_nil);
		if (escaped)
			return GDK_FAIL; 
	} else {
		*ppat++ = '$';
		*ppat = 0;
	}
	return GDK_SUCCEED; 
}
@+ Wrapping
@c
#include "mal.h"
str
PCREfromstr(str instr, int *l, pcre ** val)
{
	(void) instr;
	(void) l;
	(void) val;
	return NULL;
}

str
PCREreplace_wrap(str *res, str *or, str *pat, str *repl, str *flags){
	pcre_replace(res,*or,*pat,*repl,*flags);
	return MAL_SUCCEED;
}

str
PCREreplace_bat_wrap(int *res, int *bid, str *pat, str *repl, str *flags){
	BAT *b,*bn = NULL;
	if ((b = BATdescriptor(*bid)) == NULL)
		return throwMessage("pcre.replace", "Cannot access descriptor");

	pcre_replace_bat(&bn,b,*pat,*repl,*flags);
	*res= bn->batCacheid;
	BBPkeepref(*res);
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

str
PCREcompile_wrap(pcre ** res, str *pattern)
{
	pcre_compile_wrap(res, *pattern);
	return MAL_SUCCEED;
}

str
PCREexec_wrap(bit *res, pcre * pattern, str *s)
{
#ifndef HAVE_LIBPCRE
	(void) res;
	(void) pattern;
	(void) s;
	return throwMessage("pcre.select", "Library missing");
#else
	pcre_exec_wrap(res, pattern, *s);
#endif
	return MAL_SUCCEED;
}

str
PCREselect(int *res, str *pattern, int *bid)
{
#ifndef HAVE_LIBPCRE
	(void) res;
	(void) pattern;
	(void) bid;
	return throwMessage("pcre.select", "Library missing");
#else
	BAT *bn, *strs;
	const char err[BUFSIZ], *err_p = err;
	int errpos = 0;
	BUN p, q;
	pcre *re = NULL;

	if ((strs = BATdescriptor(*bid)) == NULL) {
		return throwMessage("pcre.select", "Cannot access descriptor");
	}

	if (strs->htype == TYPE_void)
		bn = BATnew(TYPE_oid, TYPE_str, BATcount(strs));
	else
		bn = BATnew(strs->htype, TYPE_str, BATcount(strs));
	re = pcre_compile(*pattern, PCRE_UTF8, &err_p, &errpos, NULL);
	if (re == NULL)
		return throwMessage("pcre.select", "Pcre compile of pattern failed\n");

	BATloop(strs, p, q) {
		str s = BUNtail(strs, p);

		if (pcre_exec(re, NULL, s, strlen(s), 0, 0, NULL, 0) >= 0) {
			BUNins(bn, BUNhead(strs, p), s, FALSE);
		}
	}
	my_pcre_free(re);
	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
	*res = bn->batCacheid;
	BBPkeepref(bn->batCacheid);
	BBPunfix(strs->batCacheid);
#endif
	return MAL_SUCCEED;
}

str
PCREuselect(int *res, str *pattern, int *bid)
{
#ifndef HAVE_LIBPCRE
	(void) res;
	(void) pattern;
	(void) bid;
	return throwMessage("pcre.select", "Library missing");
#else
	BAT *bn, *strs;
	const char err[BUFSIZ], *err_p = err;
	int errpos = 0;
	BUN p, q;
	pcre *re = NULL;
	oid o = oid_nil;

	if ((strs = BATdescriptor(*bid)) == NULL) {
		return throwMessage("pcre.select", "Cannot access descriptor");
	}
	if (strs->htype == TYPE_void)
		bn = BATnew(TYPE_oid, TYPE_void, BATcount(strs));
	else
		bn = BATnew(strs->htype, TYPE_void, BATcount(strs));
	re = pcre_compile(*pattern, PCRE_UTF8, &err_p, &errpos, NULL);
	if (re == NULL) {
		BBPunfix(strs->batCacheid);
		throwMessage("pcre.select", "Pcre compile of pattern failed");
		return GDK_FAIL;
	}

	BATloop(strs, p, q) {
		str s = BUNtail(strs, p);

		if (pcre_exec(re, NULL, s, strlen(s), 0, 0, NULL, 0) >= 0) {
			ptr h = BUNhead(strs, p);
			bunfastins(bn, h, &o);
		}
	}
bunins_failed:
	my_pcre_free(re);
	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
	*res = bn->batCacheid;
	BBPkeepref(bn->batCacheid);
	BBPunfix(strs->batCacheid);
	return MAL_SUCCEED;
#endif
}

str
PCREmatch(bit *ret, str *val, str *pat)
{
	if (pcre_match(ret, *val, *pat) == GDK_FAIL) {
		return throwMessage("pcre.match", "Match failed");
	}
	return MAL_SUCCEED;
}

str
PCREpatindex(int *ret, str *val, str *pat)
{
	if (pcre_patindex(ret, *val, *pat) == GDK_FAIL) {
		return throwMessage("pcre.patindex", "PATINDEX failed");
	}
	return MAL_SUCCEED;
}

str
PCREquote(str *ret, str *val)
{
	if (pcre_quote(ret, *val) == GDK_FAIL) {
		return throwMessage("pcre.quote", "Quote failed");
	}
	return MAL_SUCCEED;
}


str
PCREsql2pcre(str *ret, str *pat, str *esc)
{
	if (sql2pcre(ret, *pat, *esc) == GDK_FAIL)
		return throwMessage("pcre.sql2pcre", "Pattern convert failed");
	return MAL_SUCCEED;
} 

str
PCRElike3(bit *ret, str *s, str *pat, str *esc)
{
	char *ppat = NULL;
	str r = PCREsql2pcre(&ppat, pat, esc);

	if (!r) {
		if (strcmp(ppat,str_nil) == 0) {
			*ret = FALSE;
			if (strcmp(*s, *pat) == 0)
				*ret = TRUE;
		} else {
			r = PCREmatch(ret, s, &ppat);
		}
	}
	if (ppat)
		GDKfree(ppat);
	return r;
}

str
PCRElike2(bit *ret, str *s, str *pat)
{
	char *esc = "\\";

	return PCRElike3(ret, s, pat, &esc);
}

str
PCRElike_uselect_pcre(int *ret, int *b, str *pat, str *esc)
{
	char *ppat = NULL;
	str r = PCREsql2pcre(&ppat, pat, esc);

	if (!r) {
		if (strcmp(ppat,str_nil) == 0) {
			BAT *bp = BATdescriptor(*b);
			BAT *res = BATuselect(bp, *pat, *pat);
			
			*ret = res->batCacheid;
			BBPkeepref(res->batCacheid);
			BBPreleaseref(bp->batCacheid);
			r = MAL_SUCCEED;
		} else {
			r = PCREuselect(ret, &ppat, b);
		}
	}
	if (ppat)
		GDKfree(ppat);
	return r;
}  
@}
