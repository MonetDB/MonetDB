@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f pcre
@a N. Nes
@t PCRE - Perl-compatible regular expressions
@v 0.1
@T
       The  PCRE library is a set of functions that implement regular expres-
       sion pattern matching using the same syntax  and  semantics  as  Perl,
       with  just  a  few  differences.  The  current  implementation of PCRE
       (release 4.x) corresponds approximately with Perl 5.8, including  sup-
       port  for  UTF-8  encoded  strings.   However,  this support has to be
       explicitly enabled; it is not the default.

\begin{center}
       ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre
\end{center}
@include prelude.mx

@+ Module Definition
@mal
atom pcre:ptr;
command tostr()   address pcre_tostr;
command fromstr() address pcre_fromstr;
command nequal()  address pcre_nequal;
command hash()    address pcre_hash;
command null()    address pcre_null;
command put()     address pcre_put;
command del()     address pcre_del;
command length()  address pcre_length;
command heap()    address pcre_heap;

command compile(pat:str ) :pcre 
address PCREcompile_wrap
comment "compile a pattern";

command match(pat:pcre, s:str) :bit 
address PCREexec_wrap
comment "match a pattern";

command select(pat:str, strs:bat[:any_1,:str]) :bat[:any_1,:str] 
address PCREselect
comment "Select tuples based on the pattern";

command uselect(pat:str, strs:bat[:any_1,:str]) :bat[:any_1,:void] 
address PCREuselect
comment "Select tuples based on the pattern, only returning the head";

command match(s:str, pat:str):bit
address PCREmatch
comment "POSIX pattern matching against a string";

command replace(origin:str,pat:str,repl:str,flags:str):str
address PCREreplace_wrap
comment "Replace _all_ matches of \"pattern\" in \"origin_str\" with
       \"replacement\".\n\
     Parameter \"flags\" accept these flags: 'i', 'm', 's', and 'x'.\n
       'e': if present, an empty string is considered to be a valid match
       'i': if present, the match operates in case-insensitive mode. Otherwise, in\n
            case-sensitive mode.\n\
     'm': if present, the match operates in multi-line mode.\n
       's': if present, the match operates in \"dot-all\"
       The specifications of the flags can be found in \"man pcreapi\"\n
       The flag letters may be repeated.\n
       No other letters than 'e', 'i', 'm', 's' and 'x' are allowed in \"flags\".\n
       Returns the replaced string, or if no matches found, the original string.";

command replace(orig:bat[:any_1,:str],pat:str,repl:str,flag:str):bat[:any_1,:str]
address PCREreplace_bat_wrap;
@+ Implementation

@c
#include "mal.h"
#include "mal_exception.h"


#ifndef HAVE_LIBPCRE

#define pcre str
mal_export str PCREreplace_wrap(str *res, str *or, str *pat, str *repl, str *flags);
mal_export str PCREreplace_bat_wrap(int *res, int *or, str *pat, str *repl, str *flags);
mal_export str PCREcompile_wrap(pcre ** res, str *pattern);
mal_export str PCREexec_wrap(bit *res, pcre * pattern, str *s);
mal_export str PCREselect(int *res, str *pattern, int *bid);
mal_export str PCREmatch(bit *ret, str *val, str *pat);
mal_export str PCREfromstr(str instr, int *l, pcre ** val);
mal_export str PCREcompile_wrap(pcre ** res, str *pattern);
mal_export str PCREexec_wrap(bit *res, pcre * pattern, str *s);
mal_export str PCREselect(int *res, str *pattern, int *bid);
mal_export str PCREmatch(bit *ret, str *val, str *pat);
mal_export int pcre_tostr(str *tostr, int *l, pcre * p);
mal_export int pcre_fromstr(str instr, int *l, pcre ** val);
mal_export int pcre_nequal(pcre * l, pcre * r);
mal_export hash_t pcre_hash(pcre * b);
mal_export pcre * pcre_null(void);
mal_export void pcre_del(Heap *h, var_t *index);
mal_export int pcre_length(pcre * p);
mal_export void pcre_heap(Heap *heap, size_t capacity);
mal_export str PCREuselect(int *res, str *pattern, int *bid);
mal_export var_t pcre_put(Heap *h, var_t *bun, pcre * val);

int
pcre_compile_wrap(pcre ** res, str pattern)
{
	(void) res;
	(void) pattern;
	return GDK_FAIL;
}

int
pcre_exec_wrap(bit *res, pcre * pattern, str s)
{
	(void) res;
	(void) pattern;
	(void) s;
	return GDK_FAIL;
}

int
pcre_select(BAT **res, str pattern, BAT *strs)
{
	(void) res, (void) pattern;
	(void) strs;
	return GDK_FAIL;
}

int
pcre_uselect(BAT **res, str pattern, BAT *strs)
{
	(void) res, (void) pattern;
	(void) strs;
	return GDK_FAIL;
}


int
pcre_replace(str *res, str origin_str, str pattern, str replacement, str flags)
{
	(void) res;
	(void) origin_str;
	(void) pattern;
	(void) replacement;
	(void) flags;
	GDKerror("pcre_replace() not available as required version of libpcre was not found by configure.\n");
	return GDK_FAIL;
}

int
pcre_replace_bat(BAT **res, BAT *origin_strs, str pattern, str replacement, str flags)
{
	(void) res;
	(void) origin_strs;
	(void) pattern;
	(void) replacement;
	(void) flags;
	GDKerror("pcre_replace_bat() not available as required version of libpcre was not found by configure.\n");
	return GDK_FAIL;
}

bat *
pcre_init(void)
{
	return NULL;
}

void
pcre_exit(void)
{
}

str
pcre_match(bit *ret, str *val, str *pat)
{
	(void) ret;
	(void) val;
	(void) pat;
	return throwMessage("pcre_select", "library missing\n");
}
#else

#include <regex.h>
#include <pcre.h>

mal_export str PCREreplace_wrap(str *res, str *or, str *pat, str *repl, str *flags);
mal_export str PCREreplace_bat_wrap(int *res, int *or, str *pat, str *repl, str *flags);
mal_export str PCREcompile_wrap(pcre ** res, str *pattern);
mal_export str PCREexec_wrap(bit *res, pcre * pattern, str *s);
mal_export str PCREselect(int *res, str *pattern, int *bid);
mal_export str PCREmatch(bit *ret, str *val, str *pat);
mal_export str PCREfromstr(str instr, int *l, pcre ** val);
mal_export str PCREcompile_wrap(pcre ** res, str *pattern);
mal_export str PCREexec_wrap(bit *res, pcre * pattern, str *s);
mal_export str PCREselect(int *res, str *pattern, int *bid);
mal_export str PCREmatch(bit *ret, str *val, str *pat);
mal_export int pcre_tostr(str *tostr, int *l, pcre * p);
mal_export int pcre_fromstr(str instr, int *l, pcre ** val);
mal_export int pcre_nequal(pcre * l, pcre * r);
mal_export hash_t pcre_hash(pcre * b);
mal_export pcre * pcre_null(void);
mal_export void pcre_del(Heap *h, var_t *index);
mal_export int pcre_length(pcre * p);
mal_export void pcre_heap(Heap *heap, size_t capacity);

#define m2p(p) (pcre*)(((sht*)p)+1)
#define p2m(p) (pcre*)(((sht*)p)-1)

void *
my_pcre_malloc(size_t s)
{
	char *r = GDKmalloc(s + sizeof(sht));
	sht *sz = (sht *) r;

	*sz = s + sizeof(sht);
	return (void *) (sz + 1);
}

void
my_pcre_free(void *blk)
{
	sht *sz = (sht *) blk;

	sz -= 1;
	GDKfree((void *) sz);
}

int
pcre_compile_wrap(pcre ** res, str pattern)
{
	pcre *r;
	const char err[BUFSIZ], *err_p = err;
	int errpos = 0;

	if ((r = pcre_compile(pattern, PCRE_UTF8, &err_p, &errpos, NULL)) == NULL) {
		return GDK_FAIL;
	}
	*(pcre **) res = p2m(r);
	return GDK_SUCCEED;
}

int
pcre_exec_wrap(bit *res, pcre * pattern, str s)
{
	if (pcre_exec(m2p(pattern), NULL, s, strlen(s), 0, 0, NULL, 0) >= 0) {
		*res = TRUE;
	} else {
		*res = FALSE;
	}
	return GDK_SUCCEED;
}

#define MAX_NR_CAPTURES  1024 /* Maximal number of captured substrings in one original string */

int
pcre_replace(str *res, str origin_str, str pattern, str replacement, str flags)
{
	const char err[BUFSIZ], *err_p = err, *err_p2 = err;
	pcre *pcre_code = NULL;
	pcre_extra *extra;
	str tmpres;
	int i, j, k, len, errpos = 0, offset = 0;
	int compile_options = PCRE_UTF8, exec_options = PCRE_NOTEMPTY;
	int *ovector, ovecsize;
	int len_origin_str = strlen(origin_str);
	int len_replacement = strlen(replacement);
	int capture_offsets[MAX_NR_CAPTURES * 2], ncaptures = 0, len_del = 0;
	
	for (i = 0; i < (int)strlen(flags); i++) {
		if (flags[i] == 'e') {
			exec_options -= PCRE_NOTEMPTY;
			stream_printf(GDKout, "exec_options %d, PCRE_NOTEMPTY %d\n",
					exec_options, PCRE_NOTEMPTY);
		} else if (flags[i] == 'i') {
			compile_options |= PCRE_CASELESS;
		} else if (flags[i] == 'm') {
			compile_options |= PCRE_MULTILINE;
		} else if (flags[i] == 's') {
			compile_options |= PCRE_DOTALL;
		} else if (flags[i] == 'x') {
			compile_options |= PCRE_EXTENDED;
		} else {
			GDKerror("pcre_replace: \"flags\" contains invalid character '%c'\n", flags[i]);
			return GDK_FAIL;
		}
	}

	if ((pcre_code = pcre_compile(pattern, compile_options, &err_p, &errpos, NULL)) == NULL) {
		GDKerror("pcre_replace: pcre compile of pattern (%s) failed at %d with\n'%s'.\n", pattern, errpos, err_p);
		return GDK_FAIL;
	}

	/* Since the compiled pattern is going to be used several times, it is
	 * worth spending more time analyzing it in order to speed up the time
	 * taken for matching.
	 */
	extra = pcre_study(pcre_code, 0, &err_p2);
	pcre_fullinfo(pcre_code, extra, PCRE_INFO_CAPTURECOUNT, &i);
	ovecsize = (i + 1) * 3;
	if ((ovector = (int *) GDKmalloc(sizeof(int) * ovecsize)) == NULL) {
		GDKerror("pcre_replace: not enough memory\n");
		my_pcre_free(pcre_code);
		return GDK_FAIL;
	}
	
	i = 0;
	do {
		j = pcre_exec(pcre_code, extra, origin_str, len_origin_str, 
						offset, exec_options, ovector, ovecsize);
		if (j > 0){
			capture_offsets[i] = ovector[0];
			capture_offsets[i+1] = ovector[1];
			ncaptures++;
			i += 2;
			len_del += (ovector[1] - ovector[0]);
			offset = ovector[1];
		}
	} while((j > 0) && (offset < len_origin_str) && (ncaptures < MAX_NR_CAPTURES));
	
	if (ncaptures > 0){
		tmpres = GDKmalloc(len_origin_str - len_del + (len_replacement * ncaptures) + 1);
		if (!tmpres) {
			GDKerror("pcre_replace: not enough memory\n");
			my_pcre_free(pcre_code);
			GDKfree(ovector);
			return GDK_FAIL;
		}

		j = k = 0;

		/* possibly copy the substring before the first captured substring */
		strncpy(tmpres, origin_str, capture_offsets[j]); 
		k = capture_offsets[j];
		j++;

		for (i = 0; i < ncaptures - 1; i++) {
			strncpy(tmpres+k, replacement, len_replacement);
			k += len_replacement;
			/* copy the substring between two captured substrings */
			len = capture_offsets[j+1] - capture_offsets[j];
			strncpy(tmpres+k, origin_str+capture_offsets[j], len);
			k += len;
			j += 2;
		}

		/* replace the last captured substring */
		strncpy(tmpres+k, replacement, len_replacement);
		k += len_replacement;
		/* possibly copy the substring after the last captured substring */
		len = len_origin_str - capture_offsets[j];
		strncpy(tmpres+k, origin_str+capture_offsets[j], len);
		k += len;
		tmpres[k] = '\0';
	} else { /* no captured substrings, return the original string*/
		tmpres = GDKstrdup(origin_str);
	}

	my_pcre_free(pcre_code);
	GDKfree(ovector);
	*res = tmpres;
	return GDK_SUCCEED;
}

int
pcre_replace_bat(BAT **res, BAT *origin_strs, str pattern, str replacement, str flags)
{
	const char err[BUFSIZ], *err_p = err, *err_p2 = err;
	int i, j, k, len, errpos = 0, offset = 0;
	int compile_options = PCRE_UTF8, exec_options = PCRE_NOTEMPTY;
	pcre *pcre_code = NULL;
	pcre_extra *extra;
	BAT *tmpbat;
	BUN p, q;
	int *ovector, ovecsize;
	int len_origin_str, len_replacement = strlen(replacement);
	int capture_offsets[MAX_NR_CAPTURES * 2], ncaptures = 0, len_del = 0;
	str origin_str, replaced_str;

	for (i = 0; i < (int)strlen(flags); i++) {
		if (flags[i] == 'e') {
			exec_options |= (~PCRE_NOTEMPTY);
		} else if (flags[i] == 'i') {
			compile_options |= PCRE_CASELESS;
		} else if (flags[i] == 'm') {
			compile_options |= PCRE_MULTILINE;
		} else if (flags[i] == 's') {
			compile_options |= PCRE_DOTALL;
		} else if (flags[i] == 'x') {
			compile_options |= PCRE_EXTENDED;
		} else {
			GDKerror("pcre_replace_bat: \"flags\" contains invalid character '%c'\n", flags[i]);
			return GDK_FAIL;
		}
	}

	if ((pcre_code = pcre_compile(pattern, compile_options, &err_p, &errpos, NULL)) == NULL) {
		GDKerror("pcre_replace_bat: pcre compile of pattern (%s) failed at %d with\n'%s'.\n", pattern, errpos, err_p);
		return GDK_FAIL;
	}

	/* Since the compiled pattern is ging to be used several times, it is worth spending 
	 * more time analyzing it in order to speed up the time taken for matching.
	 */
	extra = pcre_study(pcre_code, 0, &err_p2);
	pcre_fullinfo(pcre_code, extra, PCRE_INFO_CAPTURECOUNT, &i);
	ovecsize = (i + 1) * 3;
	if ((ovector = (int *) GDKzalloc(sizeof(int) * ovecsize)) == NULL) {
		GDKerror("pcre_replace_bat: not enough memory\n");
		my_pcre_free(pcre_code);
		return GDK_FAIL;
	}
	
	tmpbat = BATnew(origin_strs->htype, TYPE_str, BATcount(origin_strs));
	BATloop(origin_strs, p, q) {
		origin_str = BUNtail(origin_strs, p);
		len_origin_str = strlen(origin_str);
		i = ncaptures = len_del = offset = 0;
		do {
			j = pcre_exec(pcre_code, extra, origin_str, len_origin_str, offset,
					exec_options, ovector, ovecsize);
			if (j > 0){
				capture_offsets[i] = ovector[0];
				capture_offsets[i+1] = ovector[1];
				ncaptures++;
				i += 2;
				len_del += (ovector[1] - ovector[0]);
				offset = ovector[1];
			}
		} while((j > 0) && (offset < len_origin_str) && (ncaptures < MAX_NR_CAPTURES));
	
		if (ncaptures > 0){
			replaced_str = GDKmalloc(len_origin_str - len_del + (len_replacement * ncaptures) + 1);
			if (!replaced_str) {
				GDKerror("pcre_replace_bat: not enough memory\n");
				my_pcre_free(pcre_code);
				GDKfree(ovector);
				return GDK_FAIL;
			}

			j = k = 0;

			/* copy eventually the substring before the first captured
			 * substring */
			strncpy(replaced_str, origin_str, capture_offsets[j]); 
			k = capture_offsets[j];
			j++;

			for (i = 0; i < ncaptures - 1; i++) {
				strncpy(replaced_str+k, replacement, len_replacement);
				k += len_replacement;
				/* copy the substring between two captured substrings */
				len = capture_offsets[j+1] - capture_offsets[j];
				strncpy(replaced_str+k, origin_str+capture_offsets[j], len);
				k += len;
				j += 2;
			}

			/* replace the last captured substring */
			strncpy(replaced_str+k, replacement, len_replacement);
			k += len_replacement;
			/* copy eventually the substring after the last captured substring */
			len = len_origin_str - capture_offsets[j];
			strncpy(replaced_str+k, origin_str+capture_offsets[j], len);
			k += len;
			replaced_str[k] = '\0';
			BUNins(tmpbat, BUNhead(origin_strs, p), replaced_str);
			GDKfree(replaced_str);
		} else { /* no captured substrings, copy the original string into new bat */
			BUNins(tmpbat, BUNhead(origin_strs, p), origin_str);
		}
	}

	my_pcre_free(pcre_code);
	GDKfree(ovector);
	if (origin_strs->htype == TYPE_void) {
		*res = BATseqbase(tmpbat, origin_strs->hseqbase);
	} else {
		*res = tmpbat;
	}
	return GDK_SUCCEED;
}

bat *
pcre_init(void)
{
	pcre_malloc = &my_pcre_malloc;
	pcre_free = &my_pcre_free;
	return NULL;
}

void
pcre_exit(void)
{
}

str
pcre_match(bit *ret, str *val, str *pat)
{
	regex_t prg;
	int error = regcomp(&prg, *pat, REG_EXTENDED | REG_NOSUB);

	if (error < 0)
		return throwMessage("pcre.match", "Compilation of regular expression failed");
	error = regexec(&prg, *val, 0, 0, 0);
	*ret = (error == 0);
	return MAL_SUCCEED;
}
#endif

int
pcre_tostr(str *tostr, int *l, pcre * p)
{
	(void) tostr;
	(void) l;
	(void) p;
	return GDK_FAIL;
}

int
pcre_fromstr(str instr, int *l, pcre ** val)
{
	(void) l;
	return pcre_compile_wrap(val, instr);
}

int
pcre_nequal(pcre * l, pcre * r)
{
	if (l != r)
		return 0;
	else
		return 1;
}

hash_t
pcre_hash(pcre * b)
{
	return *(sht *) b;
}

pcre *
pcre_null(void)
{
	static sht nullval, *r;

	nullval = ~(sht) 0;
	r = &nullval;
	return ((pcre *) (r));
}

void
pcre_del(Heap *h, var_t *index)
{
	HEAP_free(h, *index);
}

#define pcresize(val) ((sht*)val)[0]

var_t
pcre_put(Heap *h, var_t *bun, pcre * val)
{
	char *base;

	*bun = HEAP_malloc(h, pcresize(val));
	base = h->base;
	if (*bun)
		memcpy(&base[*bun], (char *) val, pcresize(val));
	return *bun;
}

int
pcre_length(pcre * p)
{
	return (pcresize(p));
}

void
pcre_heap(Heap *heap, size_t capacity)
{
	HEAP_initialize(heap, capacity, 0, (int) sizeof(var_t));
}

@+ Wrapping
@c
#include "mal.h"
str
PCREfromstr(str instr, int *l, pcre ** val)
{
	(void) instr;
	(void) l;
	(void) val;
	return NULL;
}

str
PCREreplace_wrap(str *res, str *or, str *pat, str *repl, str *flags){
	pcre_replace(res,*or,*pat,*repl,*flags);
	return MAL_SUCCEED;
}

str
PCREreplace_bat_wrap(int *res, int *bid, str *pat, str *repl, str *flags){
	BAT *b,*bn = NULL;
	if ((b = BATdescriptor(*bid)) == NULL)
		return throwMessage("pcre.replace", "Cannot access descriptor");

	pcre_replace_bat(&bn,b,*pat,*repl,*flags);
	*res= bn->batCacheid;
	BBPincref(*res,TRUE);
	BBPunfix(*res);
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

str
PCREcompile_wrap(pcre ** res, str *pattern)
{
	pcre_compile_wrap(res, *pattern);
	return MAL_SUCCEED;
}

str
PCREexec_wrap(bit *res, pcre * pattern, str *s)
{
#ifndef HAVE_LIBPCRE
	(void) res;
	(void) pattern;
	(void) s;
	return throwMessage("pcre_select", "library missing\n");
#else
	pcre_exec_wrap(res, pattern, *s);
#endif
	return MAL_SUCCEED;
}

str
PCREselect(int *res, str *pattern, int *bid)
{
#ifndef HAVE_LIBPCRE
	(void) res;
	(void) pattern;
	(void) bid;
	return throwMessage("pcre_select", "library missing\n");
#else
	BAT *bn, *strs;
	const char err[BUFSIZ], *err_p = err;
	int errpos = 0;
	BUN p, q;
	pcre *re = NULL;

	if ((strs = BATdescriptor(*bid)) == NULL) {
		return throwMessage("pcre.select", "Cannot access descriptor");
	}

	if (strs->htype == TYPE_void)
		bn = BATnew(TYPE_oid, TYPE_str, BATcount(strs));
	else
		bn = BATnew(strs->htype, TYPE_str, BATcount(strs));
	re = pcre_compile(*pattern, PCRE_UTF8, &err_p, &errpos, NULL);
	if (re == NULL)
		return throwMessage("pcre_select", "pcre compile of pattern failed\n");

	BATloop(strs, p, q) {
		str s = BUNtail(strs, p);

		if (pcre_exec(re, NULL, s, strlen(s), 0, 0, NULL, 0) >= 0) {
			BUNins(bn, BUNhead(strs, p), s);
		}
	}
	my_pcre_free(re);
	BBPincref(*res = bn->batCacheid, TRUE);
	BBPunfix(bn->batCacheid);
	BBPunfix(strs->batCacheid);
#endif
	return MAL_SUCCEED;
}

str
PCREuselect(int *res, str *pattern, int *bid)
{
#ifndef HAVE_LIBPCRE
	(void) res;
	(void) pattern;
	(void) bid;
	return throwMessage("pcre_select", "library missing\n");
#else
	BAT *bn, *strs;
	const char err[BUFSIZ], *err_p = err;
	int errpos = 0;
	BUN p, q;
	pcre *re = NULL;

	if ((strs = BATdescriptor(*bid)) == NULL) {
		return throwMessage("pcre.select", "Cannot access descriptor");
	}
	if (strs->htype == TYPE_void)
		bn = BATnew(TYPE_oid, TYPE_void, BATcount(strs));
	else
		bn = BATnew(strs->htype, TYPE_void, BATcount(strs));
	re = pcre_compile(*pattern, PCRE_UTF8, &err_p, &errpos, NULL);
	if (re == NULL) {
		BBPunfix(strs->batCacheid);
		throwMessage("pcre_select", "pcre compile of pattern failed\n");
		return GDK_FAIL;
	}

	BATloop(strs, p, q) {
		str s = BUNtail(strs, p);

		if (pcre_exec(re, NULL, s, strlen(s), 0, 0, NULL, 0) >= 0) {
			BUNins(bn, BUNhead(strs, p), NULL);
		}
	}
	my_pcre_free(re);
	BBPincref(*res = bn->batCacheid, TRUE);
	BBPunfix(bn->batCacheid);
	BBPunfix(strs->batCacheid);
	return MAL_SUCCEED;
#endif
}

str
PCREmatch(bit *ret, str *val, str *pat)
{
	return pcre_match(ret, val, pat);
}
