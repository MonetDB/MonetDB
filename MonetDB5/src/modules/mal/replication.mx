@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008-2010 MonetDB B.V.
@' All Rights Reserved.

@f replication
@a Martin Kersten
@v 1.0
@+ Database replication
The replication module supports distribution of updates over SQL
databases at multiple sites using a simple master-slave protocol using a
MAL-based update log.  Note that the current replication approach does
not support replication of schema changes, such as addition of tables or
columns.  Setup the full catalog before transitioning a database to a
replication master and make a backup.

Turning an existing database into a master and creation of a single
slave works as follows.

step 1) Turn the database into a replication master by setting its
"master" property to true using monetdb(1).  This property is translated
by merovingian(1) into the database variable "replication_master" and is
set upon database (re)start.  Note that this setting can not be added to a
running database.

step 2) Create a dump of the master database using the msqldump(1) tool.  

step 3) To initiate a slave, simply load the master snapshot.

step 4) Turn the database into a slave by setting its "slave" property
to the uri of the master using monetdb(1).  This property is translated
by merovingian(1) into the database variable "replication_slave" and is
set upon database (re)start.  Note that this setting can not be added to a
running database.

The slave starts synchronizing with the master automatically upon each
restart.  The synchronization can be manually controlled with the SQL
functions "CALL 'startSynchronization();'" and "CALL 'stopSynchronization();'".
FIXME: this doesn't work at all, as the functions don't exist

The replication scheme allows a slave to be cloned e.g. by copying the
dbfarm of the slave to another database without problems.  Important
here is that the new slave is also initialised as slave of the correct
master, by setting the "slave" property using monetdb(1).

It is possible to make a slave database also a master.  In such
situation the database carries both a master and slave property.
Creating such scheme allows to employ hierarchical replication, or to
have additional tables available in the replication stream.  Note that
at this point replication from multiple masters to e.g. combine a full
set from a set of partitioned masters is not yet possible.

Beware, turning off the "master" property leads to removal of all
left-over log files.  This renders the master database unusable for
replication.  To restore replication in such case, both master and
slaves have to be reinitialised using the afore described steps.
FIXME: implement this, logs are currently NOT removed

@- Behind the scene
When the replication_master environment is set, an optimizer
becomes active to look after updates on SQL tables and to prepare
for producing the log files. The snippet below illustrates the
additions and modifications to a query plan.

@verbatim
function query():void
  tag:= master.open();
  ...
  sql.append("schema","table","col",b:[:oid,:int]);
  master.append("schema","table","col",b,tag);
  ...
  t := mtime.current_timestamp();
  master.close();
end query;
@end verbatim

At runtime this leads to buffers being filled with the statements
required for the slaves to catch up. 
Each query block is stored in its own buffer and sent at
the end of the query block. This separates the concurrent 
actions on the database at the master and leads to a serial
execution of the replication operations within the slave.

The log records are stored in a file "dbfarm/db/master/log_%d" with the 
following structure:
@verbatim
function slave.tag1(tag:int,stamp:timestamp);
  slave.open(tag,stamp);
  tag1_b := bat.new(:oid,:int);
  ...
  bat.insert(tag1_b,3:oid,232:int); #example update
  ...
  sql.append("schema","table","col",tag1_b,tag);
  slave.close(tag,stamp);
  sql.commit();
end tag1;
slave.tag_1(1,"2009-09-03 15:49:45.000":timestamp);
slave.drop("tag1");
@end verbatim

Grouping the operations within temporary functions
makes it easy to skip its execution when we detect
that it has been executed before. The slave.open()
simply checks the replica log administration table
and issues an assertion if necessary.

The operations are executed in the serial order as on the master,
which should lead to the same optimistic transactional behavior.
All queries are considered running in auto-commit mode, because
the SQL frontend does not provide the hook (yet) for better transaction
boundary control.

@- Log file management
The log records are grouped into chunks, each represented by a file. 
Those files are the units for re-submission and the scheme
is set up to be idempotent. 
The log files will ultimately pollute your database and have to
be (re)moved. This is considered a responsibility for the DBA,
for it involves making a checkpoint or securely storing the logs
into an archive. The master keeps a table of chunks sent completely.

MonetDB can inform the master about each slave being added.
Or the server can request the names of all slaves from Sabaoth.
This way we can garbage collect log files without DBA interference.

A slave starts replicating off the
master starting from the tag maintained by the master for each slave.
The master can be optionally forced to start at a particular tag.
@{
@mal
module master;

command open():int
address MASTERopen
comment "Create a replication record";

command close(tag:int):void
address MASTERclose
comment "Close the replication record";

pattern append(s:str, t:str, c:str, :any_1, tag:int):void
address MASTERappendValue
comment "Dump the scalar on the MAL log");

pattern append(s:str, t:str, c:str, b:bat[:oid,:any_1], tag:int):void
address MASTERappend
comment "Dump the BAT on the MAL log");

pattern delete(s:str, t:str, b:bat[:oid,:any_1], tag:int):void
address MASTERdelete
comment "Dump the BAT with deletions on the MAL log");

pattern replay():void
address MASTERreplay
comment "Slave calls the master to restart sending the missing transactions";
pattern replay(tag:int):void
address MASTERreplayTag
comment "Slave calls the master to restart sending the missing transactions
from a certain point";

command stop(uri:str):void
address MASTERstop
comment "Slave suspends synchronisation with master";

command synchronize():void
address MASTERsynchronizeDefault
comment "Login to master with environment credentials to initiate submission of the log records";
command synchronize(uri:str):void
address MASTERsynchronizeURI
comment "Login to master with admin credentials to initiate submission of the log records";
command synchronize(uri:str, usr:str, pw:str, tag:int):void
address MASTERsynchronize
comment "Login to master with admin credentials to initiate submission of the log records";

module slave;

pattern init( uri:str)
address SLAVEinit
comment "The master announces the start of a roll forward of pending updates";

command open(tag:int,d:timestamp)
address SLAVEopen
comment "Marks the start of a replication record. It checks the replicas
table for existence of the tag. If so, it aborts the attempt to reapply.";

command close(uri:str, tag:int, d:timestamp)
address SLAVEclose
comment "End of replication record. Add the tag to the replicas table
using the SQL transaction semantics. To be extended with the reason for
failures.";

command drop(tag:str)
address SLAVEdrop
comment "Remove the replica function from the module";
@-
@+ Implementation code 
@h
#ifndef _REPLICATOR_H
#define _REPLICATOR_H

#include "mal.h"
#include "mal_instruction.h"
#include "mal_interpreter.h"
#include "mal_namespace.h"
#include <mapilib/Mapi.h>
#include "mtime.h"

/* #define _DEBUG_REPLICATOR_ */

#ifdef WIN32
#ifndef LIBREPLICATION
#define replication_export extern __declspec(dllimport)
#else
#define replication_export extern __declspec(dllexport)
#endif
#else
#define replication_export extern
#endif

replication_export int MASTERroleEnabled(void);
replication_export str MASTERopen(int *ret);
replication_export str MASTERstop(int *ret);
replication_export str MASTERclose(int *ret, int *tag);
replication_export str MASTERstart(int *ret);
replication_export str MASTERstartTag(int *ret, int *tag);
replication_export str MASTERreplayTag(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
replication_export str MASTERreplay(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
replication_export str MASTERappendValue(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
replication_export str MASTERappend(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
replication_export str MASTERdelete(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
replication_export str MASTERsynchronizeDefault(int  *ret);
replication_export str MASTERsynchronizeURI(int  *ret, str *conn);
replication_export str MASTERsynchronize(int  *ret, str *uri, str *usr, str *pw, int *tag);
replication_export str MASTERgetName(str *ret);

replication_export str SLAVEinit(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
replication_export str SLAVEopen(int *ret, int *tag, timestamp *t);
replication_export str SLAVEclose(int *ret, str *str, int *tag, timestamp *t);
replication_export str SLAVEdrop(int *ret, str *tag);
#endif /* _REPLICATOR_H */
@c
#include "mal_config.h"
#include "replication.h"
#include "mal_client.h"
#include <mal_sabaoth.h>
#include <mapilib/Mapi.h>

@-
The start of the query is marked with a replica tag.
It also designates the local buffer to collect the update
requests before they are shipped to the log.
The tag is returned for marking all related updates.
The final code should contain a loop to determine the last replication tag.
@c
#define MASTER "master"
#define REPLICA "/log_%d"
#define REPLICABLOCK 1000
#define REPLICADELAY 5000

static struct MASTERRECORD {
	char *buf;
	int limit;
	int top;
	int tag;
} *master;
static int mtop = 0;
static int mlimit = 0;
static MT_Lock repLck;
static int replicationTag = 0;
static stream *repFile;

int
MASTERroleEnabled(void)
{
	return replicationTag > 0;
}

static int MASTERgetBuffer(int tag)
{
	int i;

	for (i = 0; i < mtop; i++)
		if (master[i].tag == tag)
			return i;
	for (i = 0; i < mlimit; i++)
		if (master[i].tag == 0)
			break;
	if (i == 0) {
		master = GDKzalloc(sizeof(struct MASTERRECORD) * (mlimit + 32));
		mlimit = 32;
	} else
	if (i == mlimit) {
		master = GDKrealloc(master, sizeof(struct MASTERRECORD) * (mlimit + 32));
		mlimit += 32;
	}
	mtop = i >= mtop ? i + 1 : mtop;
	if (master[i].buf == 0) {
		master[i].buf = (char*)GDKzalloc(2 * 1024);
		master[i].limit = 2 * 1024;
		master[i].top = 0;
	}
	master[i].tag = tag;
	return i;
}
@-
For the time being, we assume that all chunks are kept in the
master directory. A better scheme is to find the last chunk
by reading the directory itself.
@c
str MASTERopen(int *ret)
{
	char buf[BUFSIZ];
	FILE *fp = 0;
	int i, l, len;

	if (replicationTag == 0)
		MT_lock_init(&repLck, "replication");
	mal_set_lock(repLck, "replication");
	if (repFile == NULL) {
		mkdir(MASTER, 0755); /* ensure existance of the replica pool */
		if (replicationTag == 0) {
			/* find the last one already in the pool, using the REPLICABLOCK */
			do {
				if (fp) {
					replicationTag += REPLICABLOCK;
					fclose(fp);
				}
				snprintf(buf, BUFSIZ, MASTER REPLICA, replicationTag);
				fp = fopen(buf, "r");
			} while (fp);
		}
		snprintf(buf, BUFSIZ, MASTER REPLICA, replicationTag);
		repFile = open_wastream(buf);
		if (repFile == NULL || stream_errnr(repFile)) {
			mal_unset_lock(repLck, RUNTIME_STREAM_FAILED);
			throw(MAL, "master.start", RUNTIME_STREAM_FAILED);
		}
	}
	/* get a replica buffer */
	replicationTag++;
	i = MASTERgetBuffer(replicationTag);
	/* prepare the MAL redo record */
	len = master[i].limit - master[i].top - 1;
	while ((l = snprintf(master[i].buf + master[i].top, len,
			     "function slave.tag_%d(tag:int,stamp:timestamp);\n"
			     "sql.transaction();\n"
			     "slave.open(tag,stamp);\n",
			     replicationTag)) == len) {
		master[i].buf = (char*)GDKrealloc(master[i].buf, master[i].limit + 1024);
		if (master[i].buf == NULL)
			throw(MAL, "replication.open", MAL_MALLOC_FAIL);
		master[i].limit += 1024;
		len = master[i].limit - master[i].top - 1;
	}
	master[i].top += l;
	master[i].buf[master[i].top] = 0;
	mal_unset_lock(repLck, RUNTIME_STREAM_FAILED);

	*ret = replicationTag;
	return MAL_SUCCEED;
}

str MASTERclose(int *ret, int *tag)
{
	timestamp stamp = *timestamp_nil;
	str val = NULL;
	int i, l, len;
	char buf[BUFSIZ];

	(void)ret;
	i = MASTERgetBuffer(*tag);
	mal_set_lock(repLck, "replication");
	MTIMEepoch(&stamp);
	ATOMformat(TYPE_timestamp, (ptr) & stamp, &val);
	snprintf(buf, BUFSIZ, "tag_%d", *tag);

	len = master[i].limit - master[i].top - 1;
	while ((l = snprintf(master[i].buf + master[i].top, len,
			     "slave.close(tag,stamp);\n"
			     "sql.commit();\n"
			     "end tag_%d;\n"
			     "slave.tag_%d(%d,\"%s\":timestamp);\n"
			     "slave.drop(\"%s\");\n",
			     *tag, *tag, *tag, val, buf)) == len) {
		master[i].buf = (char*)GDKrealloc(master[i].buf, master[i].limit + 1024);
		if (master[i].buf == NULL)
			throw(MAL, "replication.close", MAL_MALLOC_FAIL);
	}
	master[i].top += l;
	master[i].buf[master[i].top] = 0;
	GDKfree(val);
	stream_printf(repFile, "%s", master[i].buf);
	stream_flush(repFile);
	master[i].buf[0] = 0;
	master[i].top = 0;
	master[i].top = 0;
	if (stream_errnr(repFile)) {
		mal_unset_lock(repLck, "replication");
		throw(MAL, "replication.close", RUNTIME_STREAM_FAILED);
	}
	if (replicationTag % REPLICABLOCK == 0) {
		close_stream(repFile);
		repFile = NULL;
	}
	mal_unset_lock(repLck, "replication");
	return MAL_SUCCEED;
}

static str
MASTERdump(BAT *b, str buf, int type, int tag)
{
	BATiter bi;
	BUN p, q;
	char *headv = 0, *tailv = 0;
	str head = getTypeName(getHeadType(type));
	str tail = getTypeName(getTailType(type));
	int i, l, len;

	i = MASTERgetBuffer(tag);
	bi = bat_iterator(b);
	BATloop(b, p, q)
	{
		ATOMformat(getHeadType(type), BUNhead(bi, p), &headv);
		ATOMformat(getTailType(type), BUNtail(bi, p), &tailv);
		len = master[i].limit - master[i].top - 1;
		if (getTailType(type) <= TYPE_str &&
		    getHeadType(type) <= TYPE_str) {
			while ((l = snprintf(master[i].buf + master[i].top, len, "bat.insert(%s, %s:%s, %s:%s);\n",
					     buf, headv, head, tailv, tail)) >= len) {
				master[i].buf = (char*)GDKrealloc(master[i].buf, master[i].limit + 1024);
				if (master[i].buf == NULL)
					throw(MAL, "replication.dump", MAL_MALLOC_FAIL);
				master[i].limit += 1024;
				len = master[i].limit - master[i].top - 1;
			}
		} else
		if (getTailType(type) > TYPE_str &&
		    getHeadType(type) > TYPE_str) {
			while ((l = snprintf(master[i].buf + master[i].top, len, "bat.insert(%s, \"%s\":%s, \"%s\":%s);\n",
					     buf, headv, head, tailv, tail)) >= len) {
				master[i].buf = (char*)GDKrealloc(master[i].buf, master[i].limit + 1024);
				if (master[i].buf == NULL)
					throw(MAL, "replication.dump", MAL_MALLOC_FAIL);
				master[i].limit += 1024;
				len = master[i].limit - master[i].top - 1;
			}
		} else
		if (getTailType(type) > TYPE_str) {
			while ((l = snprintf(master[i].buf + master[i].top, len, "bat.insert(%s, %s:%s, \"%s\":%s);\n",
					     buf, headv, head, tailv, tail)) == len) {
				master[i].buf = (char*)GDKrealloc(master[i].buf, master[i].limit + 1024);
				if (master[i].buf == NULL)
					throw(MAL, "replication.dump", MAL_MALLOC_FAIL);
				master[i].limit += 1024;
				len = master[i].limit - master[i].top - 1;
			}
		} else{
			while ((l = snprintf(master[i].buf + master[i].top, len, "bat.insert(%s, \"%s\":%s, %s:%s);\n",
					     buf, headv, head, tailv, tail)) == len) {
				master[i].buf = (char*)GDKrealloc(master[i].buf, master[i].limit + 1024);
				if (master[i].buf == NULL)
					throw(MAL, "replication.dump", MAL_MALLOC_FAIL);
				master[i].limit += 1024;
				len = master[i].limit - master[i].top - 1;
			}
		}
		master[i].top += l;
		master[i].buf[master[i].top] = 0;
	}
	GDKfree(tail);
	GDKfree(head);
	return MAL_SUCCEED;
}

str
MASTERappendValue(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int tag = *(int*)getArgReference(stk, pci, 5);
	InstrPtr q;
	str val = NULL;
	int i, len;

	(void)cntxt;
	if (repFile == NULL)
		throw(MAL, "replication.append", RUNTIME_FILE_NOT_FOUND);

	i = MASTERgetBuffer(tag);
	q = copyInstruction(pci);
	q->argc--;
	setModuleId(q, putName("sql", 3));

	val = instruction2str(mb, stk, q, LIST_MAL_CALL);
	freeInstruction(q);

	len = master[i].limit - master[i].top - 1;
	while (snprintf(master[i].buf + master[i].top, len, "%s\n", val) >= len) {
		master[i].buf = (char*)GDKrealloc(master[i].buf, master[i].limit + 1024);
		if (master[i].buf == NULL)
			throw(MAL, "replication.append", MAL_MALLOC_FAIL);
		master[i].limit += 1024;
		len = master[i].limit - master[i].top - 1;
	}
	master[i].top += (int)(strlen(val) + 1);
	master[i].buf[master[i].top] = 0;
	GDKfree(val);
	return MAL_SUCCEED;
}

str
MASTERappend(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str *schema = (str*)getArgReference(stk, pci, 1);
	str *table = (str*)getArgReference(stk, pci, 2);
	str *col = (str*)getArgReference(stk, pci, 3);
	int *bid = (int*)getArgReference(stk, pci, 4);
	int tag = *(int*)getArgReference(stk, pci, 5);
	BAT *b;
	char buf[BUFSIZ];
	int type = getArgType(mb, pci, 4);
	str head = getTypeName(getHeadType(type));
	str tail = getTypeName(getTailType(type));
	int i, l, len;
	str msg;

	(void)cntxt;
	if (repFile == NULL)
		throw(MAL, "replication.append", RUNTIME_FILE_NOT_FOUND);
	b = BATdescriptor(*bid);
	if (b == NULL)
		throw(MAL, "replication.append", RUNTIME_OBJECT_MISSING);

	i = MASTERgetBuffer(tag);
	/* create the temporary bat */
	len = master[i].limit - master[i].top - 1;
	while ((l = snprintf(master[i].buf + master[i].top, len, "tag_%d_%s:=bat.new(:%s,:%s);\n",
			     tag, getArgName(mb, pci, 4), head, tail)) >= len) {
		master[i].buf = (char*)GDKrealloc(master[i].buf, master[i].limit + 1024);
		if (master[i].buf == NULL)
			throw(MAL, "replication.append", MAL_MALLOC_FAIL);
		master[i].limit += 1024;
		len = master[i].limit - master[i].top - 1;
	}
	master[i].top += l;
	master[i].buf[master[i].top] = 0;

	/* fill it */
	snprintf(buf, BUFSIZ, "tag_%d_%s", tag, getArgName(mb, pci, 4));
	msg = MASTERdump(b, buf, type, tag);
	if (msg != MAL_SUCCEED)
		return msg;

	/* execute the original append */
	len = master[i].limit - master[i].top - 1;
	while ((l = snprintf(master[i].buf + master[i].top, len, "sql.append(\"%s\",\"%s\",\"%s\",%s);\ntag_%d_%s := nil;\n",
			     *schema, *table, *col, buf, tag, getArgName(mb, pci, 4))) >= len) {
		master[i].buf = (char*)GDKrealloc(master[i].buf, master[i].limit + 1024);
		if (master[i].buf == NULL)
			throw(MAL, "replication.append", MAL_MALLOC_FAIL);
		master[i].limit += 1024;
		len = master[i].limit - master[i].top - 1;
	}
	master[i].top += l;
	master[i].buf[master[i].top] = 0;
	GDKfree(head);
	GDKfree(tail);
	return MAL_SUCCEED;
}

str
MASTERdelete(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str *schema = (str*)getArgReference(stk, pci, 1);
	str *table = (str*)getArgReference(stk, pci, 2);
	int *bid = (int*)getArgReference(stk, pci, 3);
	int tag = *(int*)getArgReference(stk, pci, 4);
	BAT *b;
	char buf[BUFSIZ];
	int type = getArgType(mb, pci, 3);
	str head = getTypeName(getHeadType(type));
	str tail = getTypeName(getTailType(type));
	str msg;
	int i, l, len;

	(void)cntxt;
	if (repFile == NULL)
		throw(MAL, "replication.delete", RUNTIME_FILE_NOT_FOUND);
	b = BATdescriptor(*bid);
	if (b == NULL)
		throw(MAL, "replication.delete", RUNTIME_OBJECT_MISSING);

	i = MASTERgetBuffer(tag);
	/* create the temporary bat */
	len = master[i].limit - master[i].top - 1;
	while ((l = snprintf(master[i].buf + master[i].top, len, "tag_%d_%s:=bat.new(:%s,:%s);\n",
			     tag, getArgName(mb, pci, 3), head, tail)) == len) {
		master[i].buf = (char*)GDKrealloc(master[i].buf, master[i].limit + 1024);
		if (master[i].buf == NULL)
			throw(MAL, "replication.delete", MAL_MALLOC_FAIL);
		master[i].limit += 1024;
		len = master[i].limit - master[i].top - 1;
	}
	master[i].top += l;
	master[i].buf[master[i].top] = 0;

	/* fill it */
	snprintf(buf, BUFSIZ, "tag_%d_%s", tag, getArgName(mb, pci, 3));
	msg = MASTERdump(b, buf, type, tag);
	if (msg != MAL_SUCCEED)
		return msg;

	/* execute the original append */
	len = master[i].limit - master[i].top - 1;
	while ((l = snprintf(master[i].buf + master[i].top, len, "sql.delete(\"%s\",\"%s\",%s);\ntag_%d_%s := nil;\n",
			     *schema, *table, buf, tag, getArgName(mb, pci, 4))) == len) {
		master[i].buf = (char*)GDKrealloc(master[i].buf, master[i].limit + 1024);
		if (master[i].buf == NULL)
			throw(MAL, "replication.delete", MAL_MALLOC_FAIL);
		master[i].limit += 1024;
		len = master[i].limit - master[i].top - 1;
	}
	master[i].top += l;
	master[i].buf[master[i].top] = 0;
	GDKfree(head);
	GDKfree(tail);
	return MAL_SUCCEED;
}

@-
Replaying the MAL logs is straightforward. The slave upon calling the
master switches to the role of client, receiving the redo transactions
upon arrival.

The master keeps a [persistent] structure with the status of all completed 
log files being sent to slaves.

The replay should be performed in an independent thread to enable
the slave to continue processing. Furthermore we assume that
all log files still exist (but may be zapped)

To ensure  we only sent completed log records the replication lock
is acquired. Currently for each file, but it is only needed for the
one still being extended.
@c
static struct MASTERrecord {
	str uri;
	int idx;        /* for its forced termination */
	time_t last_connect;
	time_t last_disconnect;
	int tag;        /* next one to sent */
	Mapi m;
} masterstatus[MAL_MAXCLIENTS];

#define _DEBUG_REPLICATOR_
static void
MASTERsend(Client cntxt, int tag)
{
	char buf[BUFSIZ + 1] = "\ninclude sql;\nsql.init();\n";
	stream *s;
	bstream *bs;

	/* wait for the request to start pumping */
	if ((size_t)stream_write(cntxt->fdout, cntxt->prompt, 1, strlen(buf)) != strlen(cntxt->prompt))
		stream_printf(GDKerr, "!failed to initialize slave session\n");

	if (replicationTag == 0)
		MT_lock_init(&repLck, "replication");
	do {
		snprintf(buf, BUFSIZ, MASTER REPLICA, (tag / REPLICABLOCK) * REPLICABLOCK);
		slash_2_dir_sep(buf);
		s = open_rastream(buf);
		if (stream_errnr(s) == OPEN_ERROR) {
			stream_destroy(s);
			/* wait for new file */
#ifdef _DEBUG_REPLICATOR_
			printf("#replay waiting\n");
#endif
			MT_sleep_ms(REPLICADELAY);
			continue;
		}

		mal_set_lock(repLck, "replication");
		/* read the complete file [now trimmed to 64KB]*/
		bs = bstream_create(s, 128 * BLOCK);
		if (bstream_next(bs) < 0) {
			bstream_destroy(bs);
			break;
		}
#ifdef _DEBUG_REPLICATOR_
		printf("#replay thread started %s\n", bs->buf);
#endif
		if ((size_t)stream_write(cntxt->fdout, bs->buf, 1, bs->len) != bs->len) {
			stream_printf(GDKerr, "!failed to sent log file\n");
			stream_flush(cntxt->fdout);
			break;
		}
		stream_flush(cntxt->fdout);
		mal_unset_lock(repLck, "replication");
		close_stream(s);
#ifdef _DEBUG_REPLICATOR_
		printf("#next file\n");
#endif
@-
Upon succesful transmission we update the log file tag for the slave.
@c
		tag += REPLICABLOCK;
	} while (cntxt->mode > FINISHING); /* stop when out of log files or closed by force */

#ifdef _DEBUG_REPLICATOR_
	printf("#replay thread finished \n");
#endif
	MCcloseClient(cntxt);
}

str
MASTERreplayTag(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	(void)mb;
	MASTERsend(cntxt, *(int*)getArgReference(stk, pci, 1));
	return MAL_SUCCEED;
}

str
MASTERreplay(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int tag = 0;
	(void)stk;
	(void)mb;
	(void)pci;
	MASTERsend(cntxt, tag);
	return MAL_SUCCEED;
}
@-
Contact the master and issue the master.start() command remotely.
Switch to a local client to consume the MAL stream it will sent.
@c
#if 0
static void
MASTERecho(void *arg)
{
	Mapi mapi = (Mapi)arg;
	bstream *bs = bstream_create(mapi_get_from(mapi), 128 * BUFSIZ);

#ifdef _DEBUG_REPLICATOR_
	stream_printf(GDKout, "MASTERecho\n");
#endif

	while (bstream_next(bs) > 0)
		stream_printf(GDKout, "#got:%s\n", bs->buf);

	mapi_disconnect(mapi);

#ifdef _DEBUG_REPLICATOR_
	stream_printf(GDKout, "MASTERecho done\n");
#endif
}
#endif
static void
MASTERreceiver(Mapi mapi)
{
	Client c;
	MT_Id tid;

#ifdef _DEBUG_REPLICATOR_
	stream_printf(GDKout, "#call master to replay\n");
#endif

	/* just reads from the mapi stream until EOF, echos to GDKstdout as
	 * comment, not very useful in a real setting.
	if (MT_create_thread(&tid, MASTERecho, (void *)mapi) < 0) {
		showException(MAL, "master.receiver", "cannot fork new client");
		return;
	}
	*/

	/* alternative (of what?) */
	c = MCinitClient(0, 0, 0);
	if (c == NULL) {
		stream_printf(GDKerr, "!MASTERreceiver: out of client slots\n");
		showException(MAL, "master.receiver", "out of client slots");
		return;
	}

	if (c->nspace == 0) {
		c->nspace = newModule(NULL, putName("user", 4));
		c->nspace->outer = mal_clients[0].nspace->outer;
	}
	(void)setScenario(c, "mal");

#ifdef _DEBUG_REPLICATOR_
	c->listing = LIST_MAL_ALL;
#endif

	MSinitClientPrg(c, "user", "main");
	c->fdin = bstream_create(mapi_get_from(mapi), 0);
	if (MT_create_thread(&tid, MSserveClient, (void *)c) < 0) {
		showException(MAL, "master.receiver", "cannot fork new client");
		return;
	}
	
	/* FIXME: we never mapi_disconnect(mapi) here */

#ifdef _DEBUG_REPLICATOR_
	stream_printf(GDKout, "#slave started receiving\n");
#endif
}

str MASTERsynchronize(int *ret, str *uri, str *usr, str *pw, int *tag)
{
	Mapi mapi;
	MapiHdl hdl;
	char buf[BUFSIZ + 1];

	(void)ret;

#ifdef _DEBUG_REPLICATOR_
	stream_printf(GDKout, "#replay the log from  %s %s %s %d\n",
			*uri, *usr, *pw, *tag);
#endif

	mapi = mapi_mapiuri(*uri, *usr, *pw, "mal");
	if (mapi_error(mapi))
		throw(MAL, "master.replay", "unable to connect to '%s': %s",
				*uri, mapi_error_str(mapi));

	if (mapi_reconnect(mapi) != MOK)
		throw(IO, "master.replay", "failed to connect to '%s': %s",
				*uri, mapi_error_str(mapi));

	snprintf(buf, BUFSIZ, "master.replay();");
	hdl = mapi_query(mapi, buf);
	if (mapi_result_error(hdl))
		throw(IO, "master.replay", "failed to start replay: %s",
				mapi_result_error(hdl));

	MASTERreceiver(mapi);
	return MAL_SUCCEED;
}

str MASTERsynchronizeURI(int *ret, str *uri)
{
	int tag = 0;
	str usr = "monetdb";
	str pw = "monetdb";
	(void)ret;
	return MASTERsynchronize(ret, uri, &usr, &pw, &tag);
}

str MASTERsynchronizeDefault(int *ret)
{
	str uri;
	uri = GDKgetenv("replication_slave");
	if (uri == NULL)
		throw(MAL, "master.synchronize", "Slave property not set");
	return MASTERsynchronizeURI(ret, &uri);
}

@-
The master thread is stopped at the slave side by closing
its client record. 
@c
str MASTERstop(int *ret)
{
	(void)ret;
	return MAL_SUCCEED;
}

@-
We should assure that only operations we haven't seen are
being executed. This is based on the tag assigned to each
replication block. 
The slave is initialized with the uri of the master
to locate its index in the client record.
@c
str SLAVEinit(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	struct MASTERrecord *mr;
	str *uri = (str*)getArgReference(stk, pci, 1);
	(void)mb;
	/* find the corresponding master record */
	for (mr = masterstatus; mr->uri && mr < masterstatus + MAL_MAXCLIENTS - 1; mr++)
		if (strcmp(mr->uri, *uri) == 0) {
			mr->idx = cntxt->idx;
#ifdef _DEBUG_REPLICATOR_
			stream_printf(GDKout, "#replay init %s\n", mr->uri);
#endif
			break;
		}
	return MAL_SUCCEED;
}

str SLAVEopen(int *ret, int *tag, timestamp *t)
{
	(void)ret;
	(void)t;
	(void)tag;
	throw(MAL, "slave.open", "Operation ignored, defined in SQL context");
}

str SLAVEclose(int *ret, str *uri, int *tag, timestamp *t)
{
	(void)ret;
	(void)uri;
	(void)tag;
	(void)t;
	throw(MAL, "slave.close", "Operation ignored, defined in SQL context");
}

str
SLAVEdelete(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	/*
	str *schema = (str*)getArgReference(stk, pci, 1);
	str *table = (str*)getArgReference(stk, pci, 2);
	int *bid = (int*)getArgReference(stk, pci, 3);
	int tag = *(int*)getArgReference(stk, pci, 4);
	*/

	(void)cntxt;
	(void)mb;
	(void)stk;
	(void)pci;
	/*
	(void)schema;
	(void)table;
	(void)bid;
	(void)tag;
	*/
	return MAL_SUCCEED;
}

str
SLAVEdrop(int *ret, str *tag)
{
	Symbol prg;
	Module mod;
	prg = findSymbol(NULL, getName("slave", 5), *tag);
	mod = findModule(NULL, getName("slave", 5));
	if (prg == NULL || mod == NULL)
		throw(MAL, "slave.drop", "Symbol not found");
	deleteSymbol(mod, prg);
	(void)ret;
	return MAL_SUCCEED;
}

@}
