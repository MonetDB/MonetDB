@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f box
@a Martin Kersten
@v 0.1
@* Box definitions
This module shows the behavior of a simple box of objects.
Objects are stored into the box using @emph{ deposit} and taken
out with @emph{ take}. Once you are done, elements can be
removed by name or reference using @emph{ discard}.

A box should be opened before being used. It is typically used
to set-up the list of current users and to perform authorization.
@mal
module box;

pattern open(nme:str):any_1
address BOXopen
comment "Locate the box and open it ";
pattern close(bname:str):void	
address BOXclose
comment "Close the box ";
pattern destroy(bname:str):void	
address BOXdestroy
comment "Destroy the box ";
pattern take(bnme:str, vnme:str):any_1
address BOXtake
comment "Locates the typed value in the box";
pattern deposit(bname:str,name:str,v:any_1):void 			
address BOXdeposit
comment "Enter a new value into the box";
pattern releaseAll(bname:str) :void 			
address BOXreleaseAll
comment "Release all objects for this client";
pattern release(bname:str,nme:str,val:any_1):void 			
address BOXrelease
comment "Release the BAT from the client pool";
pattern toString(bname:str,name:str) :str 			
address BOXtoString
comment "Get the string representation of 
	the i-th element in the box";
pattern discard(bname:str,name:str) :void 			
address BOXdiscard
comment "Release the BAT from the client pool";
pattern iterator(nme:str):lng 
address BOXiterator
comment "Locates the next element in the box";
command getBoxNames():bat[:int,:str]
address BOXgetBoxNames
comment "Retrieve the names of all boxes";
@-
@{
@+ Dummy code 
@h
#ifndef __BOX_H
#define __BOX_H
mal_export str BOXopen(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mal_export str BOXclose(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mal_export str BOXdestroy(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mal_export str BOXdeposit(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mal_export str BOXtake(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mal_export str BOXrelease(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mal_export str BOXreleaseAll(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mal_export str BOXdiscard(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mal_export str BOXtoString(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mal_export str BOXgetBoxNames(int *bid);
mal_export str BOXiterator(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
#endif /* __BOX_H */
@c
#include "mal_exception.h"
#include "mal_box.h"
#include "mal_interpreter.h"
#include "box.h"


str
BOXopen(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str name;

	(void) mb;		/*fool compiler */
	name = (str) getArgValue(stk, pci, 1);
	if (openBox(name) != 0)
		return MAL_SUCCEED;
	return throwMessage("box.open", "failed to open box");
}

str
BOXclose(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str name;

	(void) mb;		/*fool compiler */
	name = (str) getArgValue(stk, pci, 1);
	if (closeBox(name, FALSE) == 0)
		return MAL_SUCCEED;
	return throwMessage("box.close", "failed to close box");
}

str
BOXdestroy(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	Box box;
	str name;

	(void) mb;
	(void) stk;		/*fool compiler */
	@:OpenBox(destroy)@
	destroyBox(name);
	return MAL_SUCCEED;
}

@-
Access to a box calls for resolving the first parameter
to a named box.
@= OpenBox
	name = (str) getArgValue(stk,pci,1);
	box= findBox(name);
	if( box ==0) 
	return throwMessage("box.@1","box is not open");
@-
@c
str
BOXdeposit(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str name;
	ValPtr v;
	Box box;

	(void) mb;
	@:OpenBox(deposit)@
	name = (str) getArgValue(stk, pci, 2);
	v = &stk->stk[getArg(pci, 3)];
	if (depositBox(box, name, v))
		return throwException(MALEXCEPTION, "box.deposit", "failed to deposit '%s' into box", name);
	return MAL_SUCCEED;
}

str
BOXtake(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str name;
	Box box;
	ValPtr v;

	@:OpenBox(take)@
	name = (str) getArgValue(stk, pci, 2);
	v = &stk->stk[getArg(pci, 0)];
	if (takeBox(box, name, v, (int) getArgType(mb, pci, 0)))
		return throwException(MALEXCEPTION, "box.take", "failed to take '%s' from box", name);
	(void) mb;
	return MAL_SUCCEED;
}

str
BOXrelease(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str name;
	Box box;

	(void) mb;		/*fool compiler */
	@:OpenBox(release)@
	name = (str) getArgValue(stk, pci, 2);
	releaseBox(box, name);
	return MAL_SUCCEED;
}

str
BOXreleaseAll(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str name;
	Box box;

	(void) mb;		/*fool compiler */
	@:OpenBox(releaseAll)@
	releaseAllBox(box);
	return MAL_SUCCEED;
}

str
BOXdiscard(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str name;
	Box box;

	(void) mb;		/*fool compiler */
	@:OpenBox(discard)@
	name = (str) getArgValue(stk, pci, 2);
	if (discardBox(box, name))
		return throwException(MALEXCEPTION, "box.discard", "failed to discard '%s' from box '%s'", name, box->name);
	return MAL_SUCCEED;
}

str
BOXtoString(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str name;
	Box box;

	(void) mb;
	(void) stk;		/*fool compiler */
	@:OpenBox(toString)@
	return MAL_SUCCEED;
}

str
BOXgetBoxNames(int *bid)
{
	return getBoxNames(bid);
}

str
BOXiterator(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str name;
	Box box;
	lng *cursor;
	ValPtr v;

	(void) mb;		/*fool compiler */
	@:OpenBox(iterator)@
	cursor = (lng *) getArgValue(stk, pci, 0);
	v = &stk->stk[getArg(pci, 2)];
	nextBoxElement(box, cursor, v);
	return MAL_SUCCEED;
}

@}
