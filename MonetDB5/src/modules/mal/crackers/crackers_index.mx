@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2008 CWI.
@' All Rights Reserved.

@f crackers_index
@a Martin Kersten, Stratos Idreos, Stefan Manegold
@d March 2006 - July 2007
@* Cracker index


@+ Interface
 

@- Type expansion

@= TypeSwitch
@:@1(chr,simple,)@
@:@1(sht,simple,)@
@:@1(int,simple,)@
@:@1(lng,simple,)@
@:@1(flt,simple,)@
@:@1(dbl,simple,)@
@:@1(date,atom,TYPE_)@
@


@- Header file

@h
#ifndef _CRACKERS_INDEX_H_
#define _CRACKERS_INDEX_H_

#ifdef LIBCRACKERS
/* Type definitions shared within the crackers module/library */

/* used to keep track of the bats that use a given map set within a query
   With this information we can improve the alignment procedure of incremental sideways cracking
   by avoiding alignment operations not necessary for the current query 
   All bats required for the current query are kept in these nodes as a list in the CrackerIndexNode of the cracker bat
  of the head of the used map set */

struct referencesNodeFM{
	int 		batId;
	int 		tailBatId;
	struct referencesNodeFM *next;
};

struct referencesNode{
	int 		batId;
	lng 		cursor;
	struct referencesNode *next;
};

typedef struct referencesNode refNode; 

struct Node{
	/* Tree related */
        struct Node  	*left;
        struct Node  	*right;
        int	      	height;
	bit	      	head;

	/* Information stored at this node */
        oid	      	position;		/* The position in the BAT of the index where the bounds are stored */
	bit 	      	inclusive;	  
	bit	      	deleted;		/* If true then this node is deleted and can be reused */
        struct Node  	*previous;
	bit 	      	isPreviousSmaller;	
	oid	      	hols; 		  	/* # of hols before this piece */

	/* Joins */	
	int 	      	slice;		  	/* A view between the position of this index entry and the next one
						   Keeping views around allows us to reuse hash tables built for a view for joins */	

	/* Info needed for incremental maps */
	int 		pieceBAT;		/* The BAT id of the  map for this piece */
	bit		localBound;		/* TRUE if this bound exists only in this piece. FALSE if it exists in the cracker BAT too */
	bit 		first;			/* TRUE if this is the first bound in this piece. FALSE if it is the last. 
							Valid only if localBound=FALSE */
	oid 		indexLocal;		/* Local crack positions */

	 /* Used in the storage management procedure*/ 
	struct Node     *nextPiece;		/*  It identifies the next piece, i.e., the next first node in the map*/
	lng 		creationTimestamp;
	lng 		accesses;
	lng		dropped;
	lng 		tuples;

	/* Used on the cracker BAT side in the case of incremental maps */
	struct referencesNode *references;	/* maps that use this piece */
	int 		tape;			/* Tape holding previous cracks, (value,inclusive) */
};

typedef struct {
			/* Core cracking */
	int 		bid;   		/* The base BAT */
	int 		cbid;   	/* The cracker column/BAT i.e., the copy on which we actually crack */

	int 		cid;   		/* The cracker index for BAT */
	struct Node 	*Tree; 		/* The AVL-tree part of the cracker index */

			/* Updates */
	int 		iid;   		/* The pending insertions column */
	int 		did;   		/* The pending deletions column */

	bit		reCreate;	/* Indicates whether we need to recreate the index if we chose to forget it */

	sht		mergeInsertions;/* Indicates wether there are insertions to merge -->  -1 no insertions,
												0 complete merge,
												1 gradually,
												2 ripple */
	sht		mergeDeletions; /* Indicates wether there are insertions to merge -->  -1 no insertions,
												0 complete merge,
												1 gradually,
												2 ripple */
	bit 		deleteNodes;    /* If set true, merging operations will delete nodes 
					   form the cracker index if this makes things easier */

			/* Sideways cracking */
	int 		pbid; 		/* The cracker map. Together with the bid, they uniquely identify 
				           a cracker map when pid is -1 then chid stores the cracker 
                                           tape for all the cracker maps where bid is head 
				           hiid is a [bit,bit] BAT that stores inclusive information 
					   for each bound stored in chid */

	oid 		nextCrack;	/* Points to the next cracking operation that should be applied 
                                           in this map to sync it */
	int 		chid;
	int 		hiid;

	struct referencesNode *references;
	lng 		creationTimestamp;
	lng 		accesses;
	lng		dropped;
	lng 		tuples;

} CrackerIndexNode;

/* Signatures shared within the crackers module/library */
@:IndexSharedFunctions_decl_0@
@:TypeSwitch(IndexSharedFunctions_decl_1)@

#endif

/* Exported signatures */
@:IndexExport_decl@

#endif /* _CRACKERS_INDEX_H */
@


@- Exported signatures

@= IndexExport_decl
crackers_export str CRKprintCrackerIndexBATpart(int *k, int *bid);
crackers_export str CRKprintAVLTree_int(int *k, int *bid);
crackers_export str CRKprintCrackerBAT(int *k, int *bid);
crackers_export str CRKgetCrackerBAT(int *vid, int *bid);
@


@- Signatures shared within the crackers module/library

@= IndexSharedFunctions_decl_0
int existsCrackerIndex(int bid);
@

@= IndexSharedFunctions_decl_1
/* CreateNewIndex */
int newCrackerIndex_@1(int bid, int cbid);
void reCreateMap_@1(int position);

/* InsertIndexElements */
void addCrackerIndex_@1(int m, @1 *value, bit inclusive, oid index, BAT * b);
struct Node *  addCrackerIndexIncrementalSideways_@1(int m, @1 value, bit inclusive, oid indexLocal, oid index, BAT * b, bit localBound, bit first, int pieceBAT);
@


@{
@+ Implementation


@- C file

@c
#include "mal_config.h"
#include "crackers.h"

/* Functions shared within the crackers module/library */
@:IndexSharedFunctions_impl_0@
@:TypeSwitch(IndexSharedFunctions_impl_1)@

/* Exported functions */
@:IndexExport_impl@
@


@- Exported functions

@= IndexExport_impl
str
CRKprintCrackerIndexBATpart(int *k, int *bid){
	int i = existsCrackerIndex(*bid);

	(void)k;

	if (i == -1)
		fprintf(stderr, " the crack index does not exist \n");
	BATprint(BATdescriptor(CrackerIndex[i].cid));

	return MAL_SUCCEED;
}

str
CRKprintAVLTree_int(int *k, int *bid){
	BAT *c;
	int position;
	BUN idxFirst;

	(void) k;

	position = existsCrackerIndex(*bid);
        if (position == -1)
                fprintf(stderr, " the crack index does not exist \n");

	if ((c = BATdescriptor(CrackerIndex[position].cid)) == NULL)
                throw(MAL, "crackers.CRKprintAVLTree_int", "Cannot access cracker index");

        idxFirst = BUNfirst(c);
	printAVLTree(CrackerIndex[position].Tree, c, idxFirst);

	BBPunfix(c->batCacheid);

	return MAL_SUCCEED;
}

str
CRKprintCrackerBAT(int *k, int *bid){
	int i = existsCrackerIndex(*bid);

	(void)k;

	if (i == -1)
		fprintf(stderr, " the crack index does not exist \n");
	BATprint(BATdescriptor(CrackerIndex[i].cbid));

	return MAL_SUCCEED;
}

str
CRKgetCrackerBAT(int *vid, int *bid){
        int i = existsCrackerIndex(*bid);
        if (i == -1)
                fprintf(stderr, " the cracker index does not exist \n");
        if (CrackerIndex[i].cbid > 0){
		*vid = CrackerIndex[i].cbid;
		BBPincref(*vid,TRUE);
	}
	else
		*vid = 0;

        return MAL_SUCCEED;
}
@


@- Functions shared within the crackers module/library

@= IndexSharedFunctions_impl_0
int
existsCrackerIndex(int bid){
	int i;
	
	for (i = 0; i < maxCrackMap; i++)
		if (CrackerIndex[i].bid == bid)
			return i;
	return -1;
}
@

@= IndexSharedFunctions_impl_1
/* CreateNewIndex */
int
newCrackerIndex_@1(int bid, int cbid){
	int i, j, freemap = -1, units = 100;
        BAT *b;

        for (i = 0; i < maxCrackMap; i++){
                if (CrackerIndex[i].bid == -1){
                        freemap = i;
                        break;
                }
        }

        if (freemap == -1){
                if (i == maxCrackMap) {
                        CrackerIndexNode *x;

                        if (maxCrackMap > 0)
                                units = (int) (1.2 * maxCrackMap);
                        x = (CrackerIndexNode *) GDKmalloc(sizeof(CrackerIndexNode) * units);
                        memset(x, 0, sizeof(CrackerIndexNode) * units);
                        if (CrackerIndex) {
                                fprintf(stderr, "reallocate index \n");
                                memcpy(x, CrackerIndex, sizeof(CrackerIndexNode) * i);
                                GDKfree(CrackerIndex);
                        }
                        CrackerIndex = x;

                        /* mark the new slots as empty */
                        for(j=maxCrackMap; j<units;j++){
                                CrackerIndex[j].bid = -1;
                        }
                        maxCrackMap = units;
                }
        }

	CrackerIndex[i].chid = -1;
	CrackerIndex[i].hiid = -1;
	CrackerIndex[i].pbid = -1;
	CrackerIndex[i].bid = bid;
	CrackerIndex[i].cbid = cbid;
	b = BATnew(TYPE_oid, TYPE_@1, IndexEntries);	/* TODO: size */
	BBPkeepref(b->batCacheid);
	CrackerIndex[i].cid = b->batCacheid;
	CrackerIndex[i].iid = -1;
	CrackerIndex[i].did = -1;
	CrackerIndex[i].mergeInsertions = -1;
	CrackerIndex[i].reCreate = 0;
	CrackerIndex[i].Tree = NULL;
	CrackerIndex[i].references = NULL;
	CrackerIndex[i].deleteNodes = FALSE;
	CrackerIndex[i].mergeDeletions = -1;
	return i;
}

void
reCreateMap_@1(int position){
	BAT *b;

	b = BATnew(TYPE_oid, TYPE_@1, IndexEntries);	/* TODO: size */
	BBPkeepref(b->batCacheid);
	CrackerIndex[position].cid = b->batCacheid;
	CrackerIndex[position].reCreate = 0;
	
	return;
}


/* InsertIndexElements */
void
addCrackerIndex_@1(int m, @1 *value, bit inclusive, oid index, BAT * b){
	BUN base;
	oid *ph;
	@1  *pt;
	struct Node *newNode=NULL, *prev=NULL;
	oid count;

	ph = (oid*)Hloc(b, BUNlast(b));
	pt = (@1 *)Tloc(b, BUNlast(b));

	count = BATcount(b);
        if (count == (oid)0){
                @:insertIndexElement(@1, (oid*)Hloc(b, BUNfirst(b)), (@1*)Tloc(b, BUNfirst(b)), index, *value)@
		CrackerIndex[m].Tree = (struct Node *)GDKmalloc(sizeof(struct Node));
                CrackerIndex[m].Tree->position = (oid)0;
                CrackerIndex[m].Tree->inclusive = inclusive;
                CrackerIndex[m].Tree->height = 0;
                CrackerIndex[m].Tree->left = NULL;
                CrackerIndex[m].Tree->right = NULL;		
                CrackerIndex[m].Tree->head = TRUE;	
                CrackerIndex[m].Tree->deleted = FALSE;	
                CrackerIndex[m].Tree->previous = NULL;	
                CrackerIndex[m].Tree->hols = (oid)0;	
                CrackerIndex[m].Tree->slice = -1;	

                return;
        }

	base = BUNfirst(b);
	InsertTree_@1(m, count, *value, inclusive, index, CrackerIndex[m].Tree, b, base, &newNode);
        if ( newNode != NULL ) {
		/* use a new BUN only if we cannot reuse a previously deleted one */
		@:insertIndexElement(@1, ph, pt, index, *value)@
		/* remove hash table since cracking has destroyed tuple positioning */
		prev = findPreviousPieceWalkingBack(newNode);
		if (prev != NULL){
			if (prev->slice != -1){
				BBPdecref(prev->slice,TRUE);
				prev->slice = -1; 
			}
		}
	}
}

struct Node *
addCrackerIndexIncrementalSideways_@1(int m, @1 value, bit inclusive, oid indexLocal, oid index, BAT * b, bit localBound, bit first, int pieceBAT){
	BUN base;
	oid *ph;
	@1  *pt;
	struct Node *newNode=NULL, *prev=NULL;
	lng count;

	ph = (oid*)Hloc(b, BUNlast(b));
	pt = (@1 *)Tloc(b, BUNlast(b));

	count = BATcount(b);
        if (count == 0){
                @:insertIndexElement(@1, (oid*)Hloc(b, BUNfirst(b)), (@1*)Tloc(b, BUNfirst(b)), index, value)@
		CrackerIndex[m].Tree = (struct Node *)GDKmalloc(sizeof(struct Node));
                CrackerIndex[m].Tree->position = 0;
                CrackerIndex[m].Tree->inclusive = inclusive;
                CrackerIndex[m].Tree->height = 0;
                CrackerIndex[m].Tree->left = NULL;
                CrackerIndex[m].Tree->right = NULL;		
                CrackerIndex[m].Tree->head = TRUE;	
                CrackerIndex[m].Tree->deleted = FALSE;	
                CrackerIndex[m].Tree->previous = NULL;	
                CrackerIndex[m].Tree->hols = 0;	
                CrackerIndex[m].Tree->slice = -1;	
                CrackerIndex[m].Tree->localBound = localBound;	
                CrackerIndex[m].Tree->first = first;	
                CrackerIndex[m].Tree->pieceBAT = pieceBAT;	
                CrackerIndex[m].Tree->tape = -1;	
                CrackerIndex[m].Tree->indexLocal = indexLocal;	
                CrackerIndex[m].Tree->references = NULL;	
                CrackerIndex[m].Tree->nextPiece = NULL;	

                return CrackerIndex[m].Tree;
        }

	base = BUNfirst(b);
	InsertTreeIncrementalSideways_@1(m, count, value, inclusive, index, indexLocal, CrackerIndex[m].Tree, b, base, &newNode,localBound, first, pieceBAT);
        if ( newNode != NULL ) {
		/* use a new BUN only if we cannot reuse a previously deleted one */
		@:insertIndexElement(@1, ph, pt, index, value)@
		/* remove hash table since cracking has destroyed tuple posititioning */
		prev = findPreviousPieceWalkingBack(newNode);
		if (prev != NULL){
			if (prev->slice != -1){
				BBPdecref(prev->slice,TRUE);
				prev->slice = -1; 
			}
		}
	}
	return newNode;
}
@


@- Local support functions and macros

@= insertIndexElement
	*@2 = @4;	
	*@3 = @5;	
	count++;
	BATsetcount(b,count);
@

@}
