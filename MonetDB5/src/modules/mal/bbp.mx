@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f bbp
@v 2.0
@a M.L.Kersten, P. Boncz
@* BAT Buffer Pool
The BBP module implements a box interface over the BAT buffer pool.
Furthermore, it provides some functionality for bats in the context
of the Mal interpreter. The kernel does not know anything about
the runtime context.

The two predominant approaches to use bbp is to access the BBP
with either @emph{ bind} or {\sc take}. The former merely maps the BAT name
to the object in the bat buffer pool. In Monet 4 this binding
was implicit in the name resolution scheme.
No guarantees are given on stability and isolation.

A more controlled scheme is to @emph{ deposit}, {\sc take}, {\sc release}
and @emph{ discard} elements.
Any BAT B created can be brought under this scheme with the name N.
The association N->B is only maintained in the box administration
and not reflected in the BAT descriptor.
In particular, taking a  BATobject out of the box leads to a private 
copy to isolate the user from concurrent updates on the underlying store.
Upon releasing it, the updates are merged with the master copy [todo].

The BBP module does not impose any authorization, replication, localization,
or fragmentation policy. 
The default location of the BAT storage is .../dbfarm/bat, which maps
to a directory on the local file system. 

@+ The Box Interface
The bbp module implements the box 
abstraction over the Bat buffer pool. It should 
(future) provide an adequate transaction 
and version support.  It provides a collection 
of views to inspect the buffer pool status.;
@mal
module bbp;

command open():void		
address CMDbbpopen
comment "Locate the bbp box and open it.";
command close():void		
address CMDbbpclose
comment "Close the bbp box.";
command destroy():void		
address CMDbbpdestroy
comment "Destroy the box";
pattern take(name:str) :bat[:any_1,:any_2] 
address CMDbbptake
comment "Load a particular bat from disk and make a private copy";
pattern deposit(name:str,v:bat[:any_1,:any_2]) :void 			
address CMDbbpdeposit
comment "Enter a new bat into the bbp box.";
pattern releaseAll():void 	
address CMDbbpReleasA
comment "Commit updates for this client";
pattern release(name:str,val:bat[:any_1,:any_2]) :void 			
address CMDbbprelease
comment "Commit updates and release this BAT.";
pattern release(b:bat[:any_1,:any_2]):void
address CMDbbpreleaseBAT
comment "Remove the BAT from further consideration";
pattern destroy(b:bat[:any_1,:any_2]):void
address CMDbbpdestroyBAT1
comment "BAT removal at session end";
pattern destroy(b:bat[:any_1,:any_2],immediate:bit)
address CMDbbpdestroyBAT
comment "Schedule a BAT for removal at session end or immediately";
pattern toString(name:str):str 	
address CMDbbptoStr
comment "Get the string representation of an element in the box";
pattern discard(name:str):void 
address CMDbbpdiscard
comment "Remove the BAT from the box";

pattern garbage(b:bat[:any_1,:any_2]):void
address CMDbbpgarbage
comment "Designate a BAT as garbage";

pattern iterator(nme:str):lng 	
address CMDbbpiterator
comment "Locates the next element in the box";

pattern prelude():void 
address CMDbbpprelude
comment "Initialize the bbp box";

pattern bind(name:str,loc:str) :bat[:any_1,:any_2]
address CMDbbpbindDefinition
comment "Relate a logical name to a physical BAT in the buffer pool.";
pattern bind(name:str):bat[:any_1,:any_2]
address CMDbbpbind
comment "Locate the BAT using its logical name,
	but without making a local copy. 
	No guarantees are given for consistent reads.";
command bind(idx:int):bat[:any_1,:any_2] 
address CMDbbpbindindex
comment "Locate the BAT using its BBP index";
pattern getObjects():bat[:int,:str] 
address CMDbbpGetObjects
	comment "View of the box content.";
@+ BAT declarations
A pattern block may be required to make the proper translation to
the BAT library. In particular when the type information is needed
to steer the process. This means the code can not belong to the
kernel module, because MAL context knowledge is forbidden there.

@mal
pattern new(ht:any_1, tt:any_2, b:bat[:any_3,:any_4]) :bat[:any_1,:any_2] 	
address CMDBATclone
comment "Creates a new empty transient BAT by cloning another";
pattern new(ht:any_1, tt:any_2) :bat[:any_1,:any_2] 	
address CMDBATnew
comment "Creates a new empty transient BAT,
	with head- and tail-types as indicated.";
pattern new(ht:any_1, tt:any_2, size:int) :bat[:any_1,:any_2] 	
address CMDBATnewint
comment "Creates a new BAT with sufficient space.";
pattern new(ht:any_1, tt:any_2, size:lng) :bat[:any_1,:any_2] 	
address CMDBATnew
comment "Creates a new BAT and allocate space.";
pattern new(ht:void, tt:any_2, size:int) :bat[:void,:any_2] 	
address CMDBATnew;
pattern new(ht:void, tt:any_2, size:lng) :bat[:void,:any_2] 	
address CMDBATnew;

pattern new(b:bat[:any_1,:any_2] ) :bat[:any_1,:any_2] 	
address CMDBATnewDerived;
pattern new(b:bat[:any_1,:any_2], size:lng) :bat[:any_1,:any_2] 	
address CMDBATnewDerived;

command new(nme:str):bat[:any_1,:any_2]
address CMDBATderivedByName
comment "Localize a bat by name and produce a variant";
@- Singleton Set management
Singleton sets are ideally not represented by BATs, but they
nevertheless emerge as the result of an operation.
They can be packed/unpacked easily.
@mal
pattern unpack(b:bat[:any_1,:any_2])(h:any_1,t:any_2)
address CMDbatunpack
comment "Extract the first tuple from a bat";
pattern pack(h:any_1,t:any_2):bat[:any_1,:any_2]
address CMDbatpack
comment "Pack a pair into a BAT";

@+ Algebraic operators
Those that rely on knowledge of the runtime environment
@mal
command project(b:bat[:any_1,:any_2]) :bat[:any_1,:void]	
address CMDBBPprojectNil
comment "Extract the head of a BAT.";

pattern project( b:bat[:any_1,:any_3], val:any_2) :bat[:any_1,:any_2] 	
address CMDBBPproject
comment "Fill the tail column with a constant.";
pattern project(b:bat[:any_1,:any_3], val:bat[:any_1,:any_2]) :bat[:any_1,:any_2]
address CMDBBPproject
comment "Fill the tail column with a constant.";
                                                                                
@+ BAT buffer pool
The following list of operations permits inspection of the
buffer pool
@mal
command getHeadType() :bat[:int,:str]		
address CMDbbpHeadType
comment "Map a BAT into its head type";
command getTailType() :bat[:int,:str]		
address CMDbbpTailType
comment "Map a BAT into its tail type";
command getNames() :bat[:int,:str] 	
address CMDbbpNames
comment "Map BAT into its bbp name";
command getRNames() :bat[:int,:str] 	
address CMDbbpRNames
comment "Map a BAT into its bbp physical name";

command getName( b:bat[:any_1,:any_2]):str
address CMDbbpName
comment "Map a BAT into its internal name";
command getCount() :bat[:int,:lng] 	
address CMDbbpCount
comment "Map a BAT into its cardinality";
command getRefCount() :bat[:int,:int] 	
address CMDbbpRefCount
comment "Map a BAT into its (hard) reference count";
command getLRefCount() :bat[:int,:int] 	
address CMDbbpLRefCount
comment "Map a BAT into its logical reference count";
command getLocation() :bat[:int,:str] 	
address CMDbbpLocation
comment "Map a BAT into its disk location";
command getHeat() :bat[:int,:int] 	
address CMDbbpHeat
comment "Map a BAT into its heat";
command getDirty() :bat[:int,:str] 	
address CMDbbpDirty
comment "Map a BAT into its dirty/ diffs/clean status";
command getStatus() :bat[:int,:str] 	
address CMDbbpStatus
comment "Map a BAT into disk/load status";
command getKind():bat[:int,:str] 
address CMDbbpKind
comment "Map a BAT into its persistency status";
command getRefCount(b:bat[:any_1,:any_2]) :int
address CMDgetBATrefcnt
comment "Utility for debugging MAL interpreter";
command getLRefCount(b:bat[:any_1,:any_2]) :int
address CMDgetBATlrefcnt
comment "Utility for debugging MAL interpreter";
@-
@{
@include prelude.mx
@+ Implementation section
In most cases we pass a BAT identifier, which should be unified
with a BAT descriptor. Upon failure we can simply abort the function.

@c
#include "mal_box.h"
#include "mal_client.h"
#include "mal_interpreter.h"
#include "bat.h"
#include "algebra.h"

mal_export str CMDbbpprelude(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mal_export str CMDbbpopen(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mal_export str CMDbbpclose(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mal_export str CMDbbpdestroy(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mal_export str CMDbbpdeposit(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mal_export str CMDbbpbindDefinition(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mal_export str CMDbbpbind(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mal_export str CMDbbpbindindex(int *ret, int *bid);
mal_export str CMDbbptake(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mal_export str CMDbbprelease(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mal_export str CMDbbpreleaseBAT(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mal_export str CMDbbpgarbage(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mal_export str CMDbbpdestroyBAT(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mal_export str CMDbbpdestroyBAT1(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mal_export str CMDbbpReleasA(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mal_export str CMDbbpdiscard(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mal_export str CMDbbptoStr(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mal_export str CMDbbpiterator(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mal_export str CMDBATclone(MalBlkPtr m, MalStkPtr s, InstrPtr p);
mal_export str CMDBATnew(MalBlkPtr m, MalStkPtr s, InstrPtr p);
mal_export str CMDBATnewDerived(MalBlkPtr m, MalStkPtr s, InstrPtr p);
mal_export str CMDBATderivedByName(int *ret, str *nme);
mal_export str CMDBATnewint(MalBlkPtr m, MalStkPtr s, InstrPtr p);
mal_export str CMDBBPproject(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mal_export str CMDBBPprojectNil(int *ret, int *bid);
mal_export str CMDbbpGetObjects(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mal_export str CMDbbpNames(int *ret);
mal_export str CMDbbpName(str *ret, int *bid);
mal_export str CMDbbpRNames(int *ret);
mal_export str CMDbbpCount(int *ret);
mal_export str CMDbbpLocation(int *ret);
mal_export str CMDbbpHeat(int *ret);
mal_export str CMDbbpDirty(int *ret);
mal_export str CMDbbpStatus(int *ret);
mal_export str CMDbbpKind(int *ret);
mal_export str CMDbbpRefCount(int *ret);
mal_export str CMDbbpLRefCount(int *ret);
mal_export str CMDgetBATrefcnt(int *res, int *bid);
mal_export str CMDgetBATlrefcnt(int *res, int *bid);
mal_export str CMDbatunpack(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mal_export str CMDbatpack(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);

@-
Access to a box calls for resolving the first parameter
to a named box. The bbp box is automatically opened.
@c
#define OpenBox(X) \
	box= findBox("bbp");\
	if(box == 0 )\
		box= openBox("bbp");\
	if( box ==0) \
		return throwMessage("bbp." X,"box is not open");


str
CMDbbpprelude(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	(void) mb;
	(void) stk;
	(void) pci;		/* fool compiler */
	if (openBox("bbp"))
		return MAL_SUCCEED;
	return throwMessage("bbp.prelude", "failed to open box");
}

@- Operator implementation
@c
str
CMDbbpopen(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	(void) mb;
	(void) stk;
	(void) pci;		/* fool compiler */
	if (openBox("bbp") != 0)
		return MAL_SUCCEED;
	return throwMessage("bbp.open", "failed to open box");
}

str
CMDbbpclose(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	(void) mb;
	(void) stk;
	(void) pci;		/* fool compiler */
	if (closeBox("bbp", TRUE) == 0)
		return MAL_SUCCEED;
	return throwMessage("bbp.close", "failed to close 'bbp' box");
}

str
CMDbbpdestroy(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	Box box;

	(void) mb;
	(void) stk;
	(void) pci;		/* fool compiler */
	OpenBox("destroy");
	if (getClient() != mal_clients)
		return throwMessage("bbp.destroy", "not allowed to destroy 'bbp' box");
	destroyBox("bbp");
	return MAL_SUCCEED;
}

@-
Beware that once you deposit a BAT into a box, it should
increment the reference count to assure it is not
garbage collected. Moreover, it should be done so only once.
@c
str
CMDbbpdeposit(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str name;
	ValPtr v;
	Box box;
	int flg;

	(void) mb;		/* fool compiler */

	OpenBox("deposit");
	name = (str) getArgValue(stk, pci, 1);
	if (isIdentifier(name) < 0 )
		return throwMessage("bbp.deposit", "identifier expected");
	v = &stk->stk[getArg(pci, 2)];
	flg = findVariable(box->sym, name) >= 0;
	if (depositBox(box, name, v))
		return throwMessage("bbp.deposit", "failed to deposit into box");
	if (!flg)
		BBPincref(v->val.bval, TRUE);
	return MAL_SUCCEED;
}

str
CMDbbpbindDefinition(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str name, loc;
	Box box;

	(void) mb;		/* fool compiler */
	OpenBox("bind");
	name = (str) getArgValue(stk, pci, 1);
	loc = (str) getArgValue(stk, pci, 2);
	if (isIdentifier(name) < 0)
		return throwMessage("bbp.bind", "identifier expected");
	if (bindBAT(box, name, loc))
		return throwMessage("bbp.bind", "failed to bind name ");
	return MAL_SUCCEED;
}

str
CMDbbpbind(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str name;
	Box box;
	ValPtr lhs, rhs;
	int i = -1;
	BAT *b;

	(void) mb;		/* fool compiler */
	lhs = &stk->stk[getArg(pci, 0)];
	name = (str) getArgValue(stk, pci, 1);
	if (isIdentifier(name) < 0)
		return throwMessage("bbp.bind", "identifier expected");
	box = findBox("bbp");
	if (box && (i = findVariable(box->sym, name)) >= 0) {
		rhs = &box->val->stk[i];
		VALcopy(lhs, rhs);
		if (lhs->vtype == TYPE_bat) {
			BAT *b;

			b = (BAT *) BBPgetdesc(lhs->val.bval);
			if (b == NULL)
				return throwMessage("bbp.bind", "can not access descriptor");
			BBPincref(b->batCacheid, TRUE);
		}
		return MAL_SUCCEED;
	}
	i = BBPindex(name);
	if (i == 0)
		return throwMessage("bbp.bind", "failed to locate object in box");
	/* make sure you load the descriptors and heaps */
	b = (BAT *) BATdescriptor(i);
	if (b == 0)
		/* Simple ignore the binding if you can;t find the bat */
		return throwMessage("bbp.bind", "failed to find object in box");

	BBPincref(b->batCacheid, TRUE);
	BBPunfix(i);
	lhs->vtype = TYPE_bat;
	lhs->val.bval = i;
	return MAL_SUCCEED;
}

str
CMDbbpbindindex(int *ret, int *bid)
{
	BAT *b;

	b = (BAT *) BBPdescriptor(*bid);
	if (b == 0)
		return throwMessage("bbp.bind", "can not access descriptor");
	BBPincref(*ret = *bid, TRUE);
	return MAL_SUCCEED;
}

@-
Moving BATs in/out of the box also involves
checking the type already known for possible misfits.
Therefore, we need access to the runtime context.
If the bat is not known in the box, we go to the bbp pool
and make an attempt to load it directly.
@c
str
CMDbbptake(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str name;
	Box box;
	ValPtr v;

	(void) mb;		/* fool compiler */
	OpenBox("take");
	name = (str) getArgValue(stk, pci, 1);
	if (isIdentifier(name)< 0)
		return throwMessage("bbp.take", "identifier expected");
	v = &stk->stk[getArg(pci, 0)];
	if (takeBox(box, name, v, (int) getArgType(mb, pci, 0))) {
		int bid = BBPindex(name);

		if (bid > 0 && (v->vtype == TYPE_any || v->vtype == TYPE_bat)) {
			/* adjust the types as well */
			v->vtype = TYPE_bat;
			v->val.ival = bid;
			BBPincref(bid, TRUE);
		} else
			return throwMessage("bbp.take", "failed to take object from box");
	}
	/* make a private copy for this client session */
	/* use the cheapest copy method */
	/* printf("bbp.take not yet fully implemented\n"); */
	return MAL_SUCCEED;
}

str
CMDbbprelease(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str name;
	Box box;

	(void) mb;		/* fool compiler */
	OpenBox("release");
	name = (str) getArgValue(stk, pci, 1);
	releaseBox(box, name);
	/* merge the updates of this BAT with the master copy */
	/* printf("bbp.release not yet fully implemented\n"); */
	return MAL_SUCCEED;
}

@-
A BAT can be released to make room for others.
We decrease the reference count with one, but should not
immediately release it, because there may be aliases.
@c
str
CMDbbpreleaseBAT(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int *bid;
	Box box;

	OpenBox("release");
	bid = (int *) getArgValue(stk, pci, 1);
	BBPdecref(*bid, TRUE);
	releaseBAT(mb, stk, *bid);
	*bid = 0;
	return MAL_SUCCEED;
}

@-
A BAT designated as garbage can be removed, provided we
do not keep additional references in the stack frame
Be careful here not to remove persistent BATs.
@c
str
CMDbbpgarbage(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int *bid;
	Box box;
	BAT *b;

	(void) mb;
	OpenBox("release");
	bid = (int *) getArgValue(stk, pci, 1);
	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("bbp.garbage", "Cannot access descriptor");
	}

	if (BBP_lrefs(*bid) == 0) {
		BBPunfix(b->batCacheid);
		return throwMessage("bbp.garbage", "Bat already gone");
	}
	if (BBP_lrefs(*bid) == 2 && b->batPersistence == PERSISTENT) {
		/* release BAT from pool altogether */
		BBPunfix(b->batCacheid);
		BBPdecref(*bid, TRUE);
		*bid = 0;
		return MAL_SUCCEED;
	}
	BBPunfix(b->batCacheid);
	if (*bid)
		/* while( BBP_lrefs(*bid) > 1 ) */
		BBPdecref(*bid, TRUE);
	*bid = 0;
	return MAL_SUCCEED;
}

@-
A BAT can be removed forever immediately or at the end of
a session. The references within the current frame
should also be zapped.
@c
str
CMDbbpdestroyBAT(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	bit ret = 0;
	int *bid;
	bit *immediate;
	str msg;

	bid = (int *) getArgValue(stk, pci, 1);
	immediate = (bit *) getArgValue(stk, pci, 2);
	if( *immediate) 
		msg = BKCdestroyImmediate(&ret, bid);
	else 
		msg = BKCdestroy(&ret, bid);
	if (msg == MAL_SUCCEED) {
		msg = CMDbbpreleaseBAT(mb, stk, pci);
	}
	return msg;
}

str
CMDbbpdestroyBAT1(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	bit ret = 0;
	int *bid;
	str msg;

	bid = (int *) getArgValue(stk, pci, 1);
	msg = BKCdestroyImmediate(&ret, bid);
	if (msg == MAL_SUCCEED) {
		msg = CMDbbpreleaseBAT(mb, stk, pci);
	}
	return msg;
}

str
CMDbbpReleasA(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	Box box;

	(void) mb;
	(void) stk;
	(void) pci;		/* fool compiler */
	OpenBox("releaseAll");
	releaseAllBox(box);
	/* merge the updates with the master copies */
	/* printf("bbp.releaseAll not yet fully implemented\n"); */
	return MAL_SUCCEED;
}

str
CMDbbpdiscard(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str name;
	Box box;

	(void) mb;		/* fool compiler */
	OpenBox("discard");
	name = (str) getArgValue(stk, pci, 1);
	if (discardBox(box, name))
		return throwMessage("bbp.discard", "failed to discard object ");
	/*printf("bbp.discard not yet fully implemented\n"); */
	return MAL_SUCCEED;
}

str
CMDbbptoStr(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	Box box;
	int i;
	ValPtr v;
	str nme;

	(void) mb;		/* fool compiler */
	OpenBox("toString");
	nme = (str) getArgValue(stk, pci, 1);
	i = findVariable(box->sym, nme);
	if (i < 0)
		return throwMessage("bbp.toString", "failed to take value from box");
	v = &box->val->stk[i];
	garbageElement(&stk->stk[getArg(pci, 0)]);
	if (VALconvert(TYPE_str, v) == ILLEGALVALUE)
		return throwMessage("bbp.toString", "illegal value conversion");
	VALcopy(&stk->stk[getArg(pci, 0)], v);
	return MAL_SUCCEED;
}

str
CMDbbpiterator(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	Box box;
	lng *cursor;
	ValPtr v;

	(void) mb;		/* fool compiler */
	OpenBox("iterator");
	cursor = (lng *) getArgValue(stk, pci, 0);
	v = &stk->stk[getArg(pci, 1)];
	if (nextBoxElement(box, cursor, v))
		return throwMessage("bbp.iterator", "failed");
	return MAL_SUCCEED;
}

@+ BAT enhancements
The code to enhance thekernel
@c
str
CMDBATclone(MalBlkPtr m, MalStkPtr s, InstrPtr p)
{
	BAT *b;
	int bid = 0, cap, ht, tt;
	int *res;

	(void) m;

	bid = *(int *) getArgReference(s, p, 3);
	if ((b = BATdescriptor(bid)) == NULL) {
		return throwMessage("bbp.new", "Cannot access descriptor");
	}
	res = (int *) getArgReference(s, p, 0);
	ht = getArgType(m, p, 1);
	tt = getArgType(m, p, 2);
	cap = BATcount(b) + 64;
	BBPunfix(b->batCacheid);
	return (str) BKCnewBATint(res, &ht, &tt, &cap);
}

str
CMDBATnew(MalBlkPtr m, MalStkPtr s, InstrPtr p)
{
	int ht, tt;
	int cap = 0;
	int *res;

	ht = getArgType(m, p, 1);
	tt = getArgType(m, p, 2);
	if (p->argc > 3)
		cap = *(int *) getArgReference(s, p, 3);
	res = (int *) getArgReference(s, p, 0);

	if (ht == TYPE_any || tt == TYPE_any)
		return throwMessage("bbp.new", "Explicit type required\n");
	if (isaBatType(ht))
		ht = TYPE_bat;
	if (isaBatType(tt))
		tt = TYPE_bat;
	return (str) BKCnewBATint(res, &ht, &tt, &cap);
}

str
CMDBATnewDerived(MalBlkPtr m, MalStkPtr s, InstrPtr p)
{
	int bid, ht, tt;
	int cap = 0;
	int *res;
	BAT *b;
	str msg;
	oid o;

	(void) m;

	bid = *(int *) getArgReference(s, p, 1);
	if ((b = BATdescriptor(bid)) == NULL) {
		return throwMessage("bbp.new", "Cannot access descriptor");
	}

	if (bid > 0) {
		ht = b->htype;
		tt = b->ttype;
	} else {
		tt = b->htype;
		ht = b->ttype;
	}

	if (p->argc > 2)
		cap = *(int *) getArgReference(s, p, 2);
	else
		cap = BATcount(b);
	BBPunfix(b->batCacheid);
	o = b->hseqbase;

	res = (int *) getArgReference(s, p, 0);
	msg = (str) BKCnewBATint(res, &ht, &tt, &cap);
	if (msg == MAL_SUCCEED && ht == TYPE_void) {
		b = BATdescriptor(*res);
		BATseqbase(b, o);
		BBPunfix(b->batCacheid);
	}

	return msg;
}

str
CMDBATderivedByName(int *ret, str *nme)
{
	BAT *bn;
	int bid;

	bid = BBPindex(*nme);
	if (bid <= 0 || (bn = BATdescriptor(bid)) == 0)
		return throwMessage("bbp.new", "Referenced BAT not found");
	BBPincref(*ret = bn->batCacheid, TRUE);
	BBPunfix(bid);
	return MAL_SUCCEED;
}

str
CMDBATnewint(MalBlkPtr m, MalStkPtr s, InstrPtr p)
{
	int ht, tt;
	int cap = 0;
	int *res;

	ht = getArgType(m, p, 1);
	tt = getArgType(m, p, 2);
	cap = *(int *) getArgReference(s, p, 3);
	res = (int *) getArgReference(s, p, 0);

	return (str) BKCnewBATint(res, &ht, &tt, &cap);
}

str
CMDBBPproject(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int *result, *bid, tt;
	ptr *p;
	BAT *b, *bn;

	result = (int *) getArgReference(stk, pci, 0);
	bid = (int *) getArgReference(stk, pci, 1);
	p = (ptr *) getArgReference(stk, pci, 2);
	tt = getArgType(mb, pci, 2);
	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("bbp.project", "Cannot access descriptor");
	}

	if (tt >= TYPE_str) {
		if (p == 0 || *(str *) p == 0)
			p = (ptr *) str_nil;
		else
			p = *(ptr **) p;
	}
	bn = BATconst(b, tt, p);
	BBPunfix(b->batCacheid);
	if (bn) {
		BBPincref(*result = bn->batCacheid, TRUE);
		return MAL_SUCCEED;
	}
	return throwMessage("mal.project", "GDKerror");
}

str
CMDBBPprojectNil(int *ret, int *bid)
{
	BAT *b, *bn;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("bbp.project", "Cannot access descriptor");
	}

	bn = BATconst(b, TYPE_void, &int_nil);
	BBPunfix(b->batCacheid);
	if (bn) {
		BBPincref(*ret = bn->batCacheid, TRUE);
		return MAL_SUCCEED;
	}
	return throwMessage("mal.project", "GDKerror");
}

@+ BBP status
The BAT buffer pool datastructures describe the memory resident information
on the whereabouts of the BATs. The three predominant tables are made accessible
for inspection. 

The most interesting system bat for end-users is the BID-> NAME mapping,
because it provides access to the system guaranteed persistent BAT identifier.
It may be the case that the user already introduced a BAT with this name,
it is simply removed first
@= Pseudo2
	if (BBPindex("@1_@2") > 0) 
		BATdelete(BBPdescriptor(BBPindex("@1_@2")));
	BATroles(b,"@1","@2");
	BATmode(b,TRANSIENT);
	BATfakeCommit(b);
	BBPincref(*ret = b->batCacheid, TRUE);
	BBPunfix(*ret);
@c
str
CMDbbpGetObjects(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	BAT *b;
	int i;
	ValPtr v;
	Box box;
	int *ret;

	(void) mb;		/* fool compiler */
	OpenBox("getObjects");
	b = BATnew(TYPE_int, TYPE_str, BBPsize);
	if (b == 0)
		return throwMessage("bbp.getObjects", "GDKerror");
	for (i = 0; i < box->sym->vtop; i++) {
		v = &box->val->stk[i];
		BUNins(b, &v->val.bval, getVarName(box->sym, i));
	}

	ret = (int *) getArgReference(stk, pci, 0);
	@:Pseudo2(bbp,objects)@
	return MAL_SUCCEED;
}

str
CMDbbpNames(int *ret)
{
	BAT *b;
	int i;

	b = BATnew(TYPE_int, TYPE_str, BBPsize);
	if (b == 0)
		return throwMessage("catalog.bbpNames", "failed to create BAT");

	BBPlock("CMDbbpNames");
	for (i = 1; i < BBPsize; i++)
		if (i != b->batCacheid) {
			if (BBP_logical(i)) {
				BUNins(b, &i, BBP_logical(i));
				if (BBP_logical(-i)) {
					int j = -i;

					BUNins(b, &j, BBP_logical(j));
				}
			}
		}
	BBPunlock("CMDbbpNames");
	@:Pseudo2(bbp,name)@
	return MAL_SUCCEED;
}

str
CMDbbpName(str *ret, int *bid)
{
	*ret = (str) GDKstrdup(BBP_logical(*bid));
	return MAL_SUCCEED;
}

str
CMDbbpRNames(int *ret)
{
	BAT *b;
	int i;

	b = BATnew(TYPE_int, TYPE_str, BBPsize);
	if (b == 0)
		return throwMessage("bbp.getRNames", "failed to create BAT");

	BBPlock("CMDbbpRNames");
	for (i = 1; i < BBPsize; i++)
		if (i != b->batCacheid && BBP_logical(i)) {
			if (BBP_logical(-i)) {
				BUNins(b, &i, BBP_logical(-i));
			} else
				BUNins(b, &i, BBP_logical(i));
		}
	BBPunlock("CMDbbpRNames");
	@:Pseudo2(bbp,revname)@
	return MAL_SUCCEED;
}

str
CMDbbpCount(int *ret)
{
	BAT *b, *bn;
	int i;
	lng l;

	b = BATnew(TYPE_int, TYPE_lng, BBPsize);
	if (b == 0)
		return throwMessage("catalog.bbpCount", "failed to create BAT");

	for (i = 1; i < BBPsize; i++)
		if (i != b->batCacheid) {
			if (BBP_logical(i)) {
				bn = BATdescriptor(i);
				if (bn) {
					l = BATcount(bn);
					BUNins(b, &i, &l);
					BBPunfix(bn->batCacheid);
				}
			}
		}
	@:Pseudo2(bbp,count)@
	return MAL_SUCCEED;
}

@-
The BAT status is redundantly stored in CMDbat_info.
@c
str
CMDbbpLocation(int *ret)
{
	BAT *b;
	int i;

	b = BATnew(TYPE_int, TYPE_str, BBPsize);
	if (b == 0)
		return throwMessage("catalog.bbpLocation", "failed to create BAT");

	BBPlock("CMDbbpLocation");
	for (i = 1; i < BBPsize; i++)
		if (i != b->batCacheid) {
			if (BBP_logical(i))
				BUNins(b, &i, BBP_physical(i));
		}
	BBPunlock("CMDbbpLocation");
	@:Pseudo2(bbp,location)@
	return MAL_SUCCEED;
}


#define monet_modulesilent (GDKdebug&4096)


str
CMDbbpHeat(int *ret)
{
	BAT *b;
	int i;

	b = BATnew(TYPE_int, TYPE_int, BBPsize);
	if (b == 0)
		return throwMessage("catalog.bbpHeat", "failed to create BAT");

	BBPlock("CMDbbpHeat");
	for (i = 1; i < BBPsize; i++)
		if (i != b->batCacheid) {
			if (BBP_cache(i) && !monet_modulesilent) {
				int heat = BBP_lastused(i);

				BUNins(b, &i, &heat);
			} else if (BBP_logical(i)) {
				int zero = 0;

				BUNins(b, &i, &zero);
			}
		}
	BBPunlock("CMDbbpHeat");
	@:Pseudo2(bbp,heat)@
	return MAL_SUCCEED;
}

@-
The BAT dirty status:dirty => (mem != disk); diffs = not-committed
@c
str
CMDbbpDirty(int *ret)
{
	BAT *b;
	int i;

	b = BATnew(TYPE_int, TYPE_str, BBPsize);
	if (b == 0)
		return throwMessage("catalog.bbpDirty", "failed to create BAT");

	BBPlock("CMDbbpDirty");
	for (i = 1; i < BBPsize; i++)
		if (i != b->batCacheid)
			if (BBP_logical(i)) {
				BAT *bn = BBP_cache(i);

				BUNins(b, &i, bn ? BATdirty(bn) ? "dirty" : DELTAdirty(bn) ? "diffs" : "clean" : (BBP_status(i) & BBPSWAPPED) ? "diffs" : "clean");
			}
	BBPunlock("CMDbbpDirty");
	@:Pseudo2(bbp,status)@
	return MAL_SUCCEED;
}

@-
The BAT status is redundantly stored in CMDbat_info.
@c
str
CMDbbpStatus(int *ret)
{
	BAT *b;
	int i;

	b = BATnew(TYPE_int, TYPE_str, BBPsize);
	if (b == 0)
		return throwMessage("catalog.bbpStatus", "failed to create BAT");

	BBPlock("CMDbbpStatus");
	for (i = 1; i < BBPsize; i++)
		if (i != b->batCacheid)
			if (BBP_logical(i)) {
				char *loc = BBP_cache(i) ? "load" : "disk";

				BUNins(b, &i, loc);
			}
	BBPunlock("CMDbbpStatus");
	@:Pseudo2(bbp,status)@
	return MAL_SUCCEED;
}

str
CMDbbpKind(int *ret)
{
	BAT *b;
	int i;

	b = BATnew(TYPE_int, TYPE_str, BBPsize);
	if (b == 0)
		return throwMessage("catalog.bbpKind", "failed to create BAT");

	BBPlock("CMDbbpKind");
	for (i = 1; i < BBPsize; i++)
		if (i != b->batCacheid)
			if (BBP_logical(i)) {
				char *mode = NULL;

				if ((BBP_status(i) & BBPDELETED) || !(BBP_status(i) & BBPPERSISTENT))
					mode = "transient";
				else
					mode = "persistent";
				if (mode)
					BUNins(b, &i, mode);
			}
	BBPunlock("CMDbbpKind");
	@:Pseudo2(bbp,kind)@
	return MAL_SUCCEED;
}

str
CMDbbpRefCount(int *ret)
{
	BAT *b;
	int i;

	b = BATnew(TYPE_int, TYPE_int, BBPsize);
	if (b == 0)
		return throwMessage("catalog.bbpRefCount", "failed to create BAT");

	BBPlock("CMDbbpRefCount");
	for (i = 1; i < BBPsize; i++)
		if (i != b->batCacheid && BBP_logical(i)) {
			int refs = BBP_refs(i);

			BUNins(b, &i, &refs);
		}
	BBPunlock("CMDbbpRefCount");
	@:Pseudo2(bbp,refcnt)@
	return MAL_SUCCEED;
}

str
CMDbbpLRefCount(int *ret)
{
	BAT *b;
	int i;

	b = BATnew(TYPE_int, TYPE_int, BBPsize);
	if (b == 0)
		return throwMessage("catalog.bbpLRefCount", "failed to create BAT");

	BBPlock("CMDbbpLRefCount");
	for (i = 1; i < BBPsize; i++)
		if (i != b->batCacheid && BBP_logical(i)) {
			int refs = BBP_lrefs(i);

			BUNins(b, &i, &refs);
		}
	BBPunlock("CMDbbpLRefCount");
	@:Pseudo2(bbp,lrefcnt)@
	return MAL_SUCCEED;
}

str
CMDgetBATrefcnt(int *res, int *bid)
{
	BAT *b;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("bbp.getRefCount", "Cannot access descriptor");
	}
	*res = BBP_refs(b->batCacheid);
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

str
CMDgetBATlrefcnt(int *res, int *bid)
{
	BAT *b;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("bbp.getLRefCount", "Cannot access descriptor");
	}
	*res = BBP_lrefs(b->batCacheid);
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}


@-
@= headtailProperty
mal_export str CMDbbp@2( int *ret);
str CMDbbp@2( int *ret){
	BAT     *b,*bn;
	int     i;

	b= BATnew(TYPE_int,TYPE_str,BBPsize);
	if (b == 0) 
		return throwMessage("catalog.bbp@2", "failed to create BAT");

	for(i=1; i < BBPsize; i++) if (i != b->batCacheid) 
	if (BBP_logical(i)) {
		bn= BATdescriptor(i);
		if(bn) BUNins(b, &i, BATatoms[BAT@1(bn)].name);
		BBPunfix(bn->batCacheid);
	}
	@:Pseudo2(bbp,@2)@
	return MAL_SUCCEED;
}

@c
@:headtailProperty(htype,HeadType)@
@:headtailProperty(ttype,TailType)@

str
CMDbatunpack(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	BAT *b;
	int bid;
	ptr p;
	ValPtr head, tail;

	bid = *(int *) getArgValue(stk, pci, 2);

	if ((b = BATdescriptor(bid)) == NULL) {
		return throwMessage("bbp.unpack", "Cannot access descriptor");
	}

	head = &stk->stk[pci->argv[0]];
	tail = &stk->stk[pci->argv[1]];
	p = BUNfirst(b);
	if (p) {
		VALinit(head, getArgType(mb, pci, 0), BUNhead(b, p));
		VALinit(tail, getArgType(mb, pci, 1), BUNtail(b, p));
	}

	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

str
CMDbatpack(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	BAT *b;
	int *ret;
	int ht, tt;
	size_t cap = 0;

	ht = getArgType(mb, pci, 1);
	tt = getArgType(mb, pci, 2);
	ret = (int *) getArgReference(stk, pci, 0);

	if (ht == TYPE_any || tt == TYPE_any)
		return throwMessage("bbp.new", "Explicit type required\n");
	if (isaBatType(ht))
		ht = TYPE_bat;
	if (isaBatType(tt))
		tt = TYPE_bat;
	b = BATnew(ht, tt, cap);
	BBPincref(*ret = b->batCacheid, TRUE);
	BUNins(b, (ptr) getArgValue(stk, pci, 1), getArgValue(stk, pci, 2));
	BBPunfix(*ret);
	return MAL_SUCCEED;
}
