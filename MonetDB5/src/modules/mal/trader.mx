@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2010 MonetDB B.V.
All Rights Reserved.
@

@a M. Ivanova, M. Kersten
@f trader
@- This module contains primitives for bidding of (sub)-query execution 
among mservers.

trader.makeBid() is used to ask another server to make a bid for a mal function (sub-query) execution.

Currently the bid estimate is made using only the recycle cache.
ToDo: use the info about server load
FactFinder
@{
@-
@mal
module trader;

pattern makeBid(fnname:str, bidtype:sht):lng
address TRADERmakeBid
comment "Make a bid for execution of function octopus.<fnname>";

@h
#ifndef _TRADER_
#define _TRADER_

#include "mal.h"
#include "mal_interpreter.h"
#include "mal_client.h"

#ifdef WIN32
#ifndef LIBTRADER
#define trader_export extern __declspec(dllimport)
#else
#define trader_export extern __declspec(dllexport)
#endif
#else
#define trader_export extern
#endif

trader_export str TRADERmakeBid(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);

#define BID_TRANS	1
#define BID_COVER	2
#endif

@-
Bidding described ...
@c
#include "mal_config.h"
#include <mal.h>
#include <mal_exception.h>
#include <mal_instruction.h>
#include <mal_module.h>
#include <mal_recycle.h>
#include "trader.h"


static lng estimateSavings0(MalBlkPtr mb,  sht bidtype)
{
	(void) mb;
	(void) bidtype;
	return (lng)100;
}


lng estimateSavings(MalBlkPtr mb, sht bidtype)
{
	MalStkPtr stk = NULL;
	int i, j, k, marked = 0;
	ValPtr lhs, rhs;
	InstrPtr p, q;
	lng savedInstr = 0, savedKB = 0;
	static str octopusRef = 0, bindRef = 0;

	if (octopusRef == 0)
		octopusRef = putName("octopus",7);
	if (bindRef == 0)
        bindRef = putName("bind",4);

	if( recycleBlk == 0 || reusePolicy == 0)
		return 0;

	/* Create a phony exec. stack */
	newStack(stk,mb->vsize);
	memset((char *) stk, 0, stackSize(mb->vtop));
	stk->stktop = mb->vtop; 
	stk->stksize = mb->vsize;
	stk->blk = mb;

	/* Init symbol table of the phony stack */	
	for(i= 1; i< mb->vtop; i++) {
		lhs = &stk->stk[i];
		if( isVarConstant(mb,i) > 0 ){
/*			assert(!isVarCleanup(mb,i)); */
			if( !isVarDisabled(mb,i)){
				rhs = &getVarConstant(mb,i);
				*lhs = *rhs;
				if (rhs->vtype == TYPE_str && rhs->val.sval != 0)
					lhs->val.sval = GDKstrdup(rhs->val.sval);
			}
		} else{
			lhs->vtype = getVarGDKType(mb,i);
			lhs->val.pval = 0;
			lhs->len = 0;
		}
	}

	for (k = 0; k < mb->stop; k++){
		p = getInstrPtr(mb,k);
		if ( !RECYCLEinterest(p) ) 
			continue;
		marked++;
		if ( bidtype == BID_TRANS )  /* check only octopus.bind */
			if ( getModuleId(p) != octopusRef ||
				 getFunctionId(p) != bindRef )
				continue; 

		/* Match p against the recycle pool */
		for (i = 0; i < recycleBlk->stop; i++){
			q = getInstrPtr(recycleBlk,i);

			if ((getFunctionId(p) != getFunctionId(q)) ||
		   	 (getModuleId(p) != getModuleId(q)))
				continue;

			switch(reusePolicy){
	
			case REUSE_COVER:
				/* 1: check for subsumption : TODO*/
			
			case REUSE_EXACT:
				/* 2: exact covering */
				if (p->argc != q->argc-1) continue;
		
				if ( bidtype == BID_TRANS ) j = p->retc + 1;
				else j = p->retc;
				for ( ; j < p->argc; j++)
					if (VALcmp(&stk->stk[getArg(p,j)], &getVarConstant(recycleBlk,getArg(q,j))))
						goto nomatch;

				/* found an exact match - get the results on the stack */
				for( j=0; j<p->retc; j++){
					VALcopy(&stk->stk[getArg(p,j)],
						&getVarConstant(recycleBlk,getArg(q,j)) );
				}

				if ( bidtype == BID_TRANS )
					savedKB += recycleBlk->profiler[i].wbytes;
				else savedInstr++;
				goto nextinstr;

				nomatch: 
					continue;
			}

		}	/* end loop over RP */

		/* processing of subsumed instruction: TODO */

		nextinstr:
			continue;
	}

	freeStack(stk);
	if ( bidtype == BID_TRANS )
		return savedKB;
	return (marked? (lng)100*savedInstr/marked: 0) ;
}


str TRADERmakeBid(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	lng *c = (lng *) getArgReference(stk,pci,0);
	str fnname = *(str *) getArgReference(stk,pci,1);
	sht bidtype = *(sht *) getArgReference(stk,pci,2);
	Symbol sym;

	(void) mb;
    sym = findSymbol(cntxt->nspace, putName("octopus",7), fnname);
    if ( sym == NULL)
        throw(MAL,"trader.makeBid", RUNTIME_SIGNATURE_MISSING "%s", fnname);
        
    *c = estimateSavings0(sym->def, bidtype);

	return MAL_SUCCEED;
}   

@}
