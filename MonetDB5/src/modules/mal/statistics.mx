@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.
@f statistics
@a M.L. Kersten
@+ Statistics box.
Most optimizers need easy access to key information 
for proper plan generation. Amongst others, this
volatile information consists of the tuple count, size,
min- and max-value, the null-density, and 
a histogram of the value distribution.

The statistics are management by a Box, which gives 
a controlled environment to manage a collection of BATs
and system variables.

BATs have to be deposit into the  statistics box 
separately, because the costs attached maintaining them are high.
The consistency of the statistics box is partly
the responsibility of the upper layers. There is
no automatic triggering when the BATs referenced
are heavily modified or are being destroyed. 
They disappear from the statistics box the first time 
an invalid access is attempted or during system reboot.

A forced update can be called upon when the front-end
expects the situation to be changed drastically.
@mal
module statistics;

pattern open():void
address STATopen
comment "Locate and open the statistics box";
pattern close():void
address STATclose
comment "Close the statistics box ";
pattern destroy():void
address STATdestroy
comment "Destroy the statistics box";
pattern take(name:any):any
address STATtake
comment "Take a variable out of the statistics box";
command deposit(name:str) :void
address STATdepositStr
comment "Enter a new BAT into the statistics box";
command deposit(name:bat[:any,:any]) :void
address STATdeposit
comment "Enter a new BAT into the statistics box";
@-
The Box can optimize its behaviour by e.g. keeping 
often used histograms locked into memory or propagate
updates quickly. This is only applicable for objects
taken from the box and until it is released.
@mal
pattern releaseAll():void
address STATreleaseAll
comment "Release all variables in the box";
pattern release(name:str) :void
address STATreleaseStr
comment "Release a single BAT from the  box";
command release(name:bat[:any,:any]):void
address STATrelease
comment "Release a single BAT from the  box";
pattern toString(name:any):str
address STATtoString
comment "Get the string representation of an element in the box";
pattern discard(name:str) :void
address STATdiscard
comment "Release a BAT by name from the box";
command discard(name:bat[:any,:any]) :void
address STATdiscard2
comment "Release a BAT variable from the box";
pattern newIterator()(:lng,:str)
address STATnewIterator
comment "Locate next element in the box";
pattern hasMoreElements()(:lng,:str)
address STAThasMoreElements
comment "Locate next element in the box";

@-
The staleness of the information can be controlled in several
ways. The easiest, and most expensive, is to assure that
the statistics are updated when you start the server.
Alternative, you can set a expiration interval, which will
update the information only when it is considered expired.
This test will be triggered either at server restart or
your explicit call to update the statistics tables.

The statistics table is commited each time you change it.

@mal
command update()
address STATupdate
comment "Check for stale information";

command forceUpdate()
address STATforceUpdateAll
comment "Bring all information up to date";

command forceUpdate(bnme:str)
address STATforceUpdate
comment "Bring the statistics up to date for one BAT";

command prelude()
address STATprelude
comment "Initialize the statistics package";

@-
Although it is mostly used internally, the key operators
for inspection are provided, such that it is possible to bake
a query plan that changes course after checking the statistics
table.

The statistics table is mostly used internally, but
once in a while you need a dump for closed inspection.
in your MAL program for inspection. Just
use the BBP bind operation to locate them in the buffer pool.

@mal
command dump()
address STATdump
comment "Display the statistics table";

command getObjects():bat[:int,:str]
address STATgetObjects
comment "Return a table with BAT names managed";

command getHotset():bat[:int,:str]
address STATgetHotset
comment "Return a table with BAT names that have been touched
since the start of the session";

command getCount(nme:str):lng
address STATgetCount
comment "Return latest stored count information";

command getSize(nme:str):lng
address STATgetSize
comment "Return latest stored count information";

command getMin(nme:str):lng
address STATgetMin
comment "Return latest stored minimum information";

command getMax(nme:str):lng
address STATgetMax
comment "Return latest stored maximum information";

command getHistogram(nme:str):bat[:any,:any]
address STATgetHistogram
comment "Return the latest histogram");

statistics.prelude();
@- Implementation
The implementation is based on the assumption that in
most cases front-ends deal with BAT names as opposed to
the internal index.

Furthermore, the code is split in two sections. The first
contains the primitves as they will also be used in
linked-in code. The second part provides a MAL interface.
It is assumed that any direct call obeys the semantics of
this interface.
@include prelude.mx
@h
#ifndef _STATISTICS_DEF
#define _STATISTICS_DEF

/* #define DEBUG_STATISTICS */

#include "mal.h"
#include "mal_client.h"
#include "mal_interpreter.h"

#endif /* _STATISTICS_DEF */
@-
@c
#include "statistics.h"
#include "algebra.h"
mal_export str STATforceUpdateAll(int *ret);
mal_export void STATinit();
mal_export str STATdrop(str nme);
mal_export str STATforceUpdateAll(int *ret);
mal_export str STATenroll(int *ret, str *nme);
mal_export str STATenrollHistogram(int *ret, str *nme);
mal_export str STATdiscard2(int *ret, int *bid);
mal_export str STATupdateAll(int *ret, int forced);
mal_export str STATupdate(int *ret);
mal_export str STATforceUpdate(int *ret, str *nme);
mal_export str STATdump(int *ret);
mal_export str STATprelude(int *ret);
mal_export str STATopen(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mal_export str STATclose(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mal_export str STATdestroy(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mal_export str STATdepositStr(int *ret, str *nme);
mal_export str STATdeposit(int *ret, int *bid);
mal_export str STATtake(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mal_export str STATrelease(int *ret, int *bid);
mal_export str STATreleaseStr(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mal_export str STATreleaseAll(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mal_export str STATdiscard(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mal_export str STATdiscard2(int *ret, int *bid);
mal_export str STATtoString(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mal_export str STATnewIterator(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mal_export str STAThasMoreElements(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mal_export str STATgetHotset(int *bid);
mal_export str STATgetObjects(int *bid);
mal_export str STATgetHistogram(int *ret, str *nme);


BAT *STAT_id_inuse;		/* BATs information taken from the box */
BAT *STAT_id_nme;		/* mapping from BBP index */
BAT *STAT_id_expire;
BAT *STAT_id_stamp;		/* BAT last time stamp */
BAT *STAT_id_count;
BAT *STAT_id_size;
BAT *STAT_id_min_lng;
BAT *STAT_id_max_lng;
BAT *STAT_id_histogram;


static BAT *
STAT_create(str hnme, str tnme, int ht, int tt)
{
	BAT *b;
	char buf[128];

	snprintf(buf, 128, "stat_%s_%s", hnme, tnme);
	b = BATdescriptor(BBPindex(buf));
	if (b)
		return b;

	b = BATnew(ht, tt, 256);
	if (b == NULL)
		GDKfatal("STAT_create: could not allocate.");

	BATkey(b, TRUE);
	BBPrename(b->batCacheid, buf);
	BATmode(b, PERSISTENT);
	BATcommit(b);
#ifdef DEBUG_STATISTICS
	printf("created %s\n", buf);
#endif
	return b;
}

void
STATinit()
{
	mal_set_lock(mal_contextLock, "statistics");
	STAT_id_inuse = STAT_create("id", "inuse", TYPE_int, TYPE_int);
	STAT_id_nme = STAT_create("id", "nme", TYPE_int, TYPE_str);
	STAT_id_expire = STAT_create("id", "expire", TYPE_int, TYPE_int);
	STAT_id_stamp = STAT_create("id", "stamp", TYPE_int, TYPE_int);
	STAT_id_count = STAT_create("id", "count", TYPE_int, TYPE_lng);
	STAT_id_size = STAT_create("id", "size", TYPE_int, TYPE_lng);
	STAT_id_min_lng = STAT_create("id", "min_lng", TYPE_int, TYPE_lng);
	STAT_id_max_lng = STAT_create("id", "max_lng", TYPE_int, TYPE_lng);
	STAT_id_histogram = STAT_create("id", "histogram", TYPE_int, TYPE_str);
	mal_unset_lock(mal_contextLock, "statistics");
}

@-
Actually STATcommit is not a real transaction, it may fail during
execution. The remainder of the code is set up to compensate for
the situation.
@c
static void
STATcommit()
{
	mal_set_lock(mal_contextLock, "statistics");
	BATcommit(STAT_id_nme);
	BATsave(STAT_id_nme);
	BATcommit(STAT_id_expire);
	BATsave(STAT_id_expire);
	BATcommit(STAT_id_stamp);
	BATsave(STAT_id_stamp);
	BATcommit(STAT_id_count);
	BATsave(STAT_id_count);
	BATcommit(STAT_id_size);
	BATsave(STAT_id_size);
	BATcommit(STAT_id_min_lng);
	BATsave(STAT_id_min_lng);
	BATcommit(STAT_id_max_lng);
	BATsave(STAT_id_max_lng);
	BATcommit(STAT_id_histogram);
	BATsave(STAT_id_histogram);
	BATcommit(STAT_id_inuse);
	BATsave(STAT_id_inuse);
	mal_unset_lock(mal_contextLock, "statistics");
}

str
STATdrop(str nme)
{
	ptr p;
	int idx;

	p = BUNfnd(BATmirror(STAT_id_nme), nme);
	if (p == 0)
		return throwMessage("statistics.drop", "BAT not enrolled");
	idx = *(int *) p;
	BUNdelHead(STAT_id_nme, &idx);
	BUNdelHead(STAT_id_expire, &idx);
	BUNdelHead(STAT_id_stamp, &idx);
	BUNdelHead(STAT_id_count, &idx);
	BUNdelHead(STAT_id_size, &idx);
	BUNdelHead(STAT_id_min_lng, &idx);
	BUNdelHead(STAT_id_max_lng, &idx);
	BUNdelHead(STAT_id_histogram, &idx);
	BUNdelHead(STAT_id_inuse, &idx);
	STATcommit();
	return MAL_SUCCEED;
}

str
STATenroll(int *ret, str *nme)
{
	return STATforceUpdate(ret, nme);
}

str
STATenrollHistogram(int *ret, str *nme)
{
	(void) ret;
	(void) nme;
	return MAL_SUCCEED;
}

@-
An update on all BATs in use can be requested.
The amount of work is somewhat limited by ensuring
that the underlying store has been changed 
@c
str
STATupdateAll(int *ret, int forced)
{
	BAT *b;
	BUN p, q;
	str name;
	int i;

	if (STAT_id_nme)
		BATloop(STAT_id_nme, p, q) {
		name = (str) BUNtail(STAT_id_nme, p);
#ifdef DEBUG_STATISTICS
		stream_printf(GDKout, "update statistics of %d\n", name);
#endif
		i = BBPindex(name);
		if (i == 0)
			continue;
		if (forced == FALSE && BUNfnd(STAT_id_inuse, &i) == 0)
			continue;
		b = BATdescriptor(i);
		if (b == 0) {
			/* BAT disappeared */
			STATdiscard2(ret, &i);
			continue;
		}
		/* check the modification time with histogram */
		/* if BBPolder(i,j) ) */  {
			STATforceUpdate(ret, &name);
		}
		}

	return MAL_SUCCEED;
}

str
STATupdate(int *ret)
{
	return STATupdateAll(ret, FALSE);
}

str
STATforceUpdateAll(int *ret)
{
	return STATupdateAll(ret, TRUE);
}

@-
Here the real work is done. This should be refined to
accomodate different base types .
@c
str
STATforceUpdate(int *ret, str *nme)
{
	BAT *b, *h;
	char buf[PATHLENGTH];
	ptr p;
	lng cnt;
	int idx;

	(void) ret;
	b = BATdescriptor(idx = BBPindex(*nme));
	if (b == 0)
		return throwMessage("statistics.forceUpdate", "Could not find BAT\n");
	p = BUNfnd(STAT_id_nme, &idx);
	if (p)
		BUNdelete(STAT_id_nme, p);
	BUNins(STAT_id_nme, &idx, *nme);
	cnt = BATcount(b);
	p = BUNfnd(STAT_id_count, &idx);
	if (p)
		BUNdelete(STAT_id_count, p);
	BUNins(STAT_id_count, &idx, &cnt);

	cnt = BATmemsize(b, 0);
	p = BUNfnd(STAT_id_size, &idx);
	if (p)
		BUNdelete(STAT_id_size, p);
	BUNins(STAT_id_size, &idx, &cnt);

	p = BUNfnd(STAT_id_min_lng, &idx);
	if (p)
		BUNdelete(STAT_id_min_lng, p);
	p = BUNfnd(STAT_id_max_lng, &idx);
	if (p)
		BUNdelete(STAT_id_max_lng, p);

	if (b->ttype == TYPE_int) {
		BATmin(b, &cnt);
		BUNins(STAT_id_min_lng, &idx, &cnt);
		BATmax(b, &cnt);
		BUNins(STAT_id_max_lng, &idx, &cnt);
	} else {
		BUNins(STAT_id_min_lng, &idx, &lng_nil);
		BUNins(STAT_id_max_lng, &idx, &lng_nil);
	}
	h = BAThistogram(b);
	if (h == 0)
		return MAL_SUCCEED;
	snprintf(buf, PATHLENGTH, "H%s", BATgetId(b));
	BBPrename(h->batCacheid, buf);
	BATmode(h, PERSISTENT);
	BBPincref(h->batCacheid, TRUE);
	BATcommit(h);

	p = BUNfnd(STAT_id_histogram, &idx);
	if (p)
		BUNdelete(STAT_id_histogram, p);
	BUNins(STAT_id_histogram, &idx, BATgetId(h));

	p = BUNfnd(STAT_id_inuse, &idx);
	if (p)
		BUNdelete(STAT_id_inuse, p);
	BUNins(STAT_id_inuse, &idx, &idx);
	STATcommit();
	return MAL_SUCCEED;
}

str
STATdump(int *ret)
{
	BAT *piv[MAXPARAMS];

	(void) ret;
	piv[0] = STAT_id_nme;
	/* STAT_id_expire, */
	/* STAT_id_stamp, */
	piv[1] = STAT_id_count;
	piv[2] = STAT_id_size;
	piv[3] = STAT_id_min_lng;
	piv[4] = STAT_id_max_lng;
	piv[5] = STAT_id_histogram;

	BATmultiprintf(GDKout, 6 + 1, piv, 0, 1, 1);
	return MAL_SUCCEED;
}

@- Module initializaton
The content of this box my only be changed by the Administrator.
@c
#include "mal_client.h"
#include "mal_interpreter.h"

#define authorize(X)\
				/* if( !isAuthorized("Admin"))\
				   return throwMessage("const." X ,"unauthorized access to 'const' box"); */

int
isAuthorized(str nme)
{
	Client c;

	if (nme == 0)
		return 1;
	c = getClient();
	return idcmp(c->user, nme) == 0;
}

@- Operator implementation
@c
#define OpenBox(X) \
	authorize(X); \
	box= findBox("statistics"); \
	if( box ==0) \
	return throwMessage("statistics."X,"box is not open");

str
STATprelude(int *ret)
{
	Box box;

	box = openBox("statistics");
	if (box == 0)
		return throwMessage("statistics.prelude", "failed to open box");
	STATinit();
	STATupdate(ret);
	return MAL_SUCCEED;
}

str
STATopen(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	(void) mb;
	(void) stk;
	(void) pci;		/* fool compiler */
	authorize("open");
	if (openBox("statistics") != 0)
		return MAL_SUCCEED;
	return throwMessage("statistics.open", "failed to open statistics box");
}

str
STATclose(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	(void) mb;
	(void) stk;
	(void) pci;		/* fool compiler */
	authorize("close");
	if (closeBox("statistics", TRUE) == 0)
		return MAL_SUCCEED;
	return throwMessage("statistics.close", "failed to close box");
}

str
STATdestroy(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	Box box;

	(void) mb;
	(void) stk;
	(void) pci;		/* fool compiler */
	OpenBox("destroy");
	destroyBox("statistics");
	return MAL_SUCCEED;
}

@-
Access to a box calls for resolving the first parameter
to a named box.
@c
str
STATdepositStr(int *ret, str *nme)
{
	BAT *b;
	Box box;
	ValRecord val;
	int idx;
	str bnme;

	b = BATdescriptor(idx = BBPindex(*nme));
	if (b == NULL)
		return throwMessage("statistics.deposit", "BAT unknown");
	OpenBox("deposit");
	val.val.bval = idx;
	val.vtype = TYPE_bat;
	if (depositBox(box, *nme, &val))
		return throwException(MALEXCEPTION, "statistics.deposit", "failed to deposit '%s' into box", *nme);
	bnme = BATgetId(b);
	return STATenroll(ret, &bnme);
}

str
STATdeposit(int *ret, int *bid)
{
	BAT *b;
	Box box;
	str msg;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("statistics.deposit", "Cannot access descriptor");
	}

	OpenBox("deposit");
	msg = BATgetId(b);
	msg = STATenroll(ret, &msg);
	BBPunfix(b->batCacheid);
	return msg;
}

str
STATtake(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str name;
	Box box;
	ValPtr v;

	OpenBox("take");
	name = (str) getArgName(mb, pci, 1);
	v = &stk->stk[getArg(pci, 0)];
	if (takeBox(box, name, v, (int) getArgType(mb, pci, 0)))
		return throwException(MALEXCEPTION, "statistics.take", "failed to take '%s' from box", name);
	return MAL_SUCCEED;
}

str
STATrelease(int *ret, int *bid)
{
	BAT *b;
	Box box;

	(void) ret;
	OpenBox("release");
	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("statistics.release", "Cannot access descriptor");
	}
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

str
STATreleaseStr(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str name;
	Box box;

	(void) stk;		/* fool compiler */

	OpenBox("release");
	name = (str) getArgName(mb, pci, 1);
	if (releaseBox(box, name))
		return throwException(MALEXCEPTION, "statistics.release", "failed to release '%s' from box", name);
	return MAL_SUCCEED;
}

@-
We should keep track of all BATs taken from the Box, for this
can be used to upgrade the information quickly.
For example, the update functio only looks at those in use to detect
stale information. All others are only updated with a forceful update.
The release policy is not yet implemented.
@c
str
STATreleaseAll(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	Box box;

	(void) mb;
	(void) stk;
	(void) pci;		/* fool compiler */
	OpenBox("release");
	releaseAllBox(box);
	return MAL_SUCCEED;
}

str
STATdiscard(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str name;
	Box box;

	(void) mb;		/* fool compiler */
	OpenBox("discard");
	name = (str) getArgValue(stk, pci, 1);
	return STATdrop(name);
}

str
STATdiscard2(int *ret, int *bid)
{
	BAT *b;
	Box box;
	str msg;

	(void) ret;
	OpenBox("discard");
	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("statistics.discard", "Cannot access descriptor");
	}

	msg = STATdrop(BATgetId(b));
	BBPunfix(b->batCacheid);
	return msg;
}

str
STATtoString(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	Box box;
	int i, len = 0;
	ValPtr v;
	str nme, s = 0;

	(void) mb;		/* fool compiler */
	OpenBox("toString");
	nme = (str) getArgValue(stk, pci, 1);
	i = findVariable(box->sym, nme);
	if (i < 0)
		return throwException(MALEXCEPTION, "statistics.toString", "failed to take '%s' from box", nme);

	v = &box->val->stk[i];
	if (v->vtype == TYPE_str)
		s = v->val.sval;
	else
		(*BATatoms[v->vtype].atomToStr) (&s, &len, v);
	if (s == NULL)
		return throwMessage("statistics.toString", "illegal value");
	VALset(&stk->stk[getArg(pci, 0)], TYPE_str, s);
	return MAL_SUCCEED;
}

str
STATnewIterator(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	Box box;
	lng *cursor;
	ValPtr v;

	(void) mb;		/* fool compiler */
	OpenBox("iterator");
	cursor = (lng *) getArgValue(stk, pci, 0);
	v = &stk->stk[getArg(pci, 1)];
	nextBoxElement(box, cursor, v);
	return MAL_SUCCEED;
}

str
STAThasMoreElements(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	Box box;
	lng *cursor;
	ValPtr v;

	(void) mb;		/* fool compiler */
	OpenBox("iterator");
	cursor = (lng *) getArgValue(stk, pci, 0);
	v = &stk->stk[getArg(pci, 1)];
	nextBoxElement(box, cursor, v);
	return MAL_SUCCEED;
}

str
STATgetHotset(int *bid)
{
	BAT *b;

	b = BATjoin(STAT_id_inuse, STAT_id_nme, BATcount(STAT_id_nme));
	BBPincref(*bid = b->batCacheid, TRUE);
	return MAL_SUCCEED;
}

str
STATgetObjects(int *bid)
{
	*bid = STAT_id_nme->batCacheid;
	BBPincref(*bid, TRUE);
	return MAL_SUCCEED;
}

@-
@= stat
mal_export str STATget@1(lng *ret, str *nme);
str
STATget@1(lng *ret, str *nme){
	ptr p;
	p= BUNfnd(BATmirror(STAT_id_nme),*nme);
	if( p == NULL)
		return throwMessage("statistics.get@1","BAT not known");
	p= BUNfnd(STAT_id_@2, (int *) p);
	if( p == NULL)
		return throwMessage("statistics.get@1","@1 not known");
	*ret = *(lng*)BUNtail(STAT_id_@2,p);
	return MAL_SUCCEED;
}
@c
@:stat(Count,count)@
@:stat(Size,size)@
@:stat(Min,min_lng)@
@:stat(Max,max_lng)@


str
STATgetHistogram(int *ret, str *nme)
{
	ptr p;
	int i;
	BAT *h;

	p = BUNfnd(BATmirror(STAT_id_nme), *nme);
	if (p == NULL)
		return throwMessage("statistics.getHistogram", "BAT not known");
	p = BUNfnd(STAT_id_histogram, (int *) p);
	if (p == NULL)
		return throwMessage("statistics.getHistogram", "Histogram not known");
	i = BBPindex((str) BUNtail(STAT_id_histogram, p));
	if (i == 0)
		return throwMessage("statistics.getHistogram", "Histogram disappeared");
	h = BATdescriptor(i);
	BBPincref(*ret = h->batCacheid, TRUE);
	return MAL_SUCCEED;
}
