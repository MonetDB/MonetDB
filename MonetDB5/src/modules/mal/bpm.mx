@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f pbm
@v 0.1
@a M.L.Kersten
@* Partitioned BAT Manager
In real-life database applications the BATs tend to grow beyond
the memory size. Although in most situation this does not
provide severe limitations, it helps to be able to work with
Partitioned BATs (PBAT).

For example, the updates could be collected in
separate BATs, while all querying may still focus on the table at large.
The partition optimizers will step in to either assemble the pieces before
a function is called, or to replace the instruction with a program fragment
to produce the result incrementally.

The code snippet below illustrates a sequence over time
to build the partitioned BAT. BATs are incrementally
added to a named PBAT @code{Sales}.
@example
    b1:= bat.new(:void,:int);
    bat.setPersistent(b1);
    pbm.deposit("Sales2005","06",b1);
    b2:= bat.new(:void,:int);
    bat.setPersistent(b2);
    pbm.deposit("Sales2005","07",b2);
    b3:= bat.new(:void,:int);
    bat.setPersistent(b3);
    pbm.deposit("Sales2005","08",b3);
	n:= pbm.getNames(); # get content of partitition catalogue.
	io.print(n);
@end example

The components of a PBAT can be selectively retrieved by name or 
using an iterator.
@example
	a:= pbm.take("Sales2005","06");
barrier c:= pbm.newIterator("Sales2005");
	io.print(c);
	redo c:= pbm.hasMoreElements("Sales2005");
exit c;
@end example
Alternatively, a static PBAT definition can be retrieved for manipulation
by the MAT optimizer.
@example
#	d:= mat.take("Sales2005");    replaced by mat.optimizer into
	_21:= pbm.take("Sales2005","06");
	_22:= pbm.take("Sales2005","07");
	_23:= pbm.take("Sales2005","08");
	d:= mat.new(_21,_22,_23);
@end example

A related, but separate issues, are the BAT distribution and replication
managers.
BEWARE, it is not yet protected against concurrent access yet.
@mal
module pbm;

command open():void
address PBMopen
comment "Locate and open the partition box";

command close():void
address PBMclose
comment "Save and close the partition box ";

command destroy():void
address PBMdestroy
comment "Destroy the partition box";

command take(grp:str,elm:str):bat[:any_1,:any_2]
address PBMtake
comment "Retrieve a single component of a PBAT";
command take(grp:str,idx:int):bat[:any_1,:any_2]
address PBMtakeIndexed
comment "Retrieve a single component of a PBAT by index";

command getNames():bat[:str,:str]
address PBMgetAllComponents
comment "Retrieve the component names of all PBATs";

command getComponents(grp:str):bat[:str,:str]
address PBMgetComponents
comment "Retrieve the component names of a PBAT";

command deposit(nme:str,elm:str,idx:int) :void
address PBMdeposit
comment "Add an existing BAT to a PBAT in the partition box";
command deposit(nme:str,elm:str) :void
address PBMdepositByName
comment "Add a BAT to a PBAT in the partition box";
command deposit(nme:str,elm:str,b:bat[:any_1,:any_2]) :void
address PBMdeposit
comment "Add a BAT to a PBAT in the partition box";

command releaseAll(nme:str):void
address PBMreleaseAll
comment "Release a PBAT definitions";

command discard() :void
address PBMdiscardAll
comment "Release all PBAT variable from the box";
command discard(name:str) :void
address PBMdiscard
comment "Release a PBAT variable from the box";
command discard(nme:str, b:bat[:void,:any_1]) :void
address PBMdiscardComponent
comment "Release a single BAT from a PBAT";

command newIterator()(:int,:str,:str)
address PBMnewIteratorBase
comment "Create an iterator over the partition box";
command hasMoreElements()(:int,:str,:str)
address PBMhasMoreElementsBase
comment "Locate next element in the partition box";

@-
In most situations we would like to iterator over
the components of a single PBAT. 
Wherever possible skipping elements that don't qualify
the bounds given for the head.
@mal
command newIterator(grp:str):bat[:any_1,:any_2]
address PBMnewIterator
comment "Create an iterator over the BAT partitions.";

command newIterator(grp:str,first:oid,last:oid)
		:bat[:any_1,:any_2]
address PBMnewIteratorRng
comment "Create an iterator over the BAT partitions.";

command hasMoreElements(grp:str) :bat[:any_2,:any_1]
address PBMhasMoreElements
comment "Localize the next partition for processing.";

command hasMoreElements(grp:str,first:oid,last:oid) :bat[:any_1,:any_2]
address PBMhasMoreElementsRng
comment "Localize the next partition for processing.";

command getLast(grp:str):bat[:any_1,:any_2]
address PBMgetLast
comment "Obtain the last partition for update";

command getRange(b:bat[:void,:any_1])(first:oid,last:oid)
address PBMgetRange
comment "Obtain the oid range for a partition";

command compress(grp:str):void
address PBMcompress
comment "Compress the group to remove oid holes";

command dump()
address PBMdump;

command prelude()
address PBMprelude;

command epilogue()
address PBMepilogue;

pbm.prelude();
@-
@{

@+ BAT Partition Manager Implementation
The implementation is organized around a shared box, which should
be saved between session. It is up to other layers to ensure that BATs
being deleted are also removed from the partition box to avoid
mis-represented information.

The internal data structure is used as a cache for improved access.
@h
#ifndef _MAL_PBM
#define _MAL_PBM
#include "mal.h"
#include "mal_client.h"
#include "mal_interpreter.h"

typedef struct {
	str grp;		/* group name */
	str elm;		/* element name */
	bat bid;		/* element bat identifier */
@-
For the common case of :bat[:void,:any_1] we keep the boundaries
around for fast matching.
@h
	oid first;		/* lowest oid stored */
	oid last;		/* largest oid stored or nil */

	int next;		/* next one in the PBAT list */
	int prev;		/* previous one in the PBAT list */
} PBATrecord, *PBAT;

mal_export PBAT partitions ;
mal_export int ptop, plimit;

#endif
@c
#include "pbm.h"

mal_export int PBMfindGrp(int bid);
mal_export void PBMresize(int size);
mal_export str PBMdump();
mal_export str PBMprelude(int *ret);
mal_export str PBMepilogue(int *ret);
mal_export str PBMopen();
mal_export str PBMclose();
mal_export str PBMdestroy();
mal_export str PBMtakePBAT(int *ret, str *grp);
mal_export str PBMtake(int *ret, str *grp, str *elm);
mal_export str PBMtakeIndexed(int *ret, str *grp, int *bid);
mal_export str PBMgetComponents(int *ret, str *grp);
mal_export str PBMgetAllComponents(int *ret);
mal_export int PBMfindGrp(int bid);
mal_export int PBMfindPBAT(str grp);
mal_export int PBMfindPBATcomponent(str grp, str elm);
mal_export str PBMdeposit(int *ret, str *grp, str *elm, int *bid);
mal_export str PBMdepositByIndex(int *ret, str *grp, str *elm,int *idx);
mal_export str PBMdepositByName(int *ret, str *grp, str *elm);
mal_export str PBMgetRange(oid *first, oid *last, int *bid);
mal_export str PBMgetLast(int *ret, str *grp);
mal_export str PBMdiscard(int *ret, str *grp);
mal_export str PBMdiscardAll(int *ret);
mal_export str PBMreleaseAll(int *ret, int *bid);
mal_export str PBMdiscardComponent(int *ret, str *grp, int *bid);
mal_export str PBMnewIteratorBase(int *ret, str *grp, str *elm);
mal_export str PBMhasMoreElementsBase(int *ret, str *nme, str *elm);
mal_export str PBMnewIterator(int *res, str *grp);
mal_export str PBMnewIteratorRng(int *res, str *grp, oid *first, oid *last);
mal_export str PBMhasMoreElements(int *res, str *grp );
mal_export str PBMhasMoreElementsRng(int *res, str *grp, oid *first, oid *last);
mal_export str PBMcompress(int *ret, str *grp);

PBAT partitions = NULL;
int ptop, plimit;

#define INCREMENT 1024
void
PBMresize(int size)
{
	PBAT p;

	if( size <= plimit) return;
	p = GDKmalloc(size * sizeof(PBATrecord));
	if (partitions) {
		if (ptop > size)
			GDKfatal("assertion error in PBMresize");
		memcpy(p, partitions, sizeof(PBATrecord) * ptop);
		GDKfree(partitions);
	}
	partitions = p;
	partitions[0].grp = NULL;
	partitions[0].elm = NULL;
	partitions[0].bid = -1;
	partitions[0].prev = -1;
	partitions[0].next = -1;
	plimit = size;
}

static void
PBMfreePartition(int i){
	BAT *b;
	if( partitions[i].grp){
		b= (BAT*) BBPgetdesc(partitions[i].bid);
		if( b== 0)
			GDKerror("inconsistent pbm, lost a BAT");
		else{
			b->batPersistence = TRANSIENT;
			BBPdecref(b->batCacheid,TRUE);
			BBPunfix(b->batCacheid);
		}
	}
	if( partitions[i].grp) GDKfree(partitions[i].grp);
	if( partitions[i].elm) GDKfree(partitions[i].elm);
	partitions[i].grp = NULL;
	partitions[i].elm = NULL;
	partitions[i].bid = -1;
	partitions[i].prev = -1;
	partitions[i].next = -1;
}
static void
PBMfree()
{
	int i;
	if (partitions) {
		for(i=0; i<plimit; i++){
			if( partitions[i].grp) GDKfree(partitions[i].grp);
			if( partitions[i].elm) GDKfree(partitions[i].elm);
		}
		GDKfree(partitions);
		partitions = NULL;	
	}
}

str
PBMdump()
{
	stream *fd = GDKout;
	int i;

	stream_printf(fd, "ptop=%d plimit=%d\n", ptop, plimit);
	for (i = 0; i < ptop; i++)
		stream_printf(fd, "[%d] grp=%s elm=%s bid=%d "
			"f=%d, l=%d prv=%d nxt=%d\n", i, 
			partitions[i].grp, partitions[i].elm, 
			partitions[i].bid, 
			partitions[i].first, partitions[i].last, 
			partitions[i].prev, partitions[i].next);
	return MAL_SUCCEED;
}

@- Box administration
The box currently does not carry any client protection.
This should later be added or being provided by the BAT access.
@c
str
PBMprelude(int *ret)
{
	Box box;

	(void) ret;
	box = openBox("partitions");
	if (box == 0)
		return throwMessage("pbm.prelude", "failed to open box");
	PBMresize(INCREMENT);
	return MAL_SUCCEED;
}

str
PBMepilogue(int *ret)
{
	*ret = closeBox("partitions", 0);
	PBMfree();
	if (*ret != 0)
		return throwMessage("pbm.prelude", "failed to open box");
	return MAL_SUCCEED;
}


str
PBMopen()
{
	if (openBox("pbm") != 0)
		return MAL_SUCCEED;
	return throwMessage("pbm.open", "failed to open pbm box");
}

str
PBMclose()
{
	stream *f;
	str boxfile, boxfilebak;
	Box box;
	BAT *b;
	int i;

	box = openBox("pbm");
	f = prepareSaveBox(box, &boxfile, &boxfilebak);
	if (f != NULL) {
		/* save the info */
		for (i = 0; i < ptop; i++)
			if (partitions[i].bid != -1) {
				b = (BAT *) BBPgetdesc(partitions[i].bid);
				if (b && b->batPersistence & PERSISTENT)
					stream_printf(f, "pbm.deposit(\"%s\",\"%s\",%d);\n", 
						partitions[i].grp,
						partitions[i].elm,
						partitions[i].bid);
			}
		stream_close(f);
		GDKfree(boxfile);
		GDKfree(boxfilebak);
	}
	return MAL_SUCCEED;
}

str
PBMdestroy()
{
	destroyBox("partitions");
	return MAL_SUCCEED;
}
@-
Taking out a BAT should be protective, i.e. check for their existence.
Taking out a PBAT leads to a forced union before returning.
The intend is to use an optimizer to avoid this if possible.
@c
str
PBMtakeComplete(int *ret, str *grp)
{
	BAT *b,*bn;
	int i;
	i = PBMfindPBAT(*grp);
	if( i<0)
		return throwMessage("pbm.take","PBAT not found");
	b= BBPdescriptor(partitions[i].bid);
	if( b== NULL)
		return throwMessage("pbm.take", "PBAT partition not accessible");
	bn= BATcopy(b);
	BBPunfix(b->batCacheid);

	for(i= partitions[i].next; i>= 0; i= partitions[i].next){
		b= BBPdescriptor(partitions[i].bid);
		if( b== NULL){
			BBPdecref(bn->batCacheid, TRUE);
			BBPunfix(bn->batCacheid);
			return throwMessage("pbm.take", "PBAT partition not accessible");
		}
		BATins(bn,b);
		BBPunfix(b->batCacheid);
	}
	*ret = bn->batCacheid;
	BBPkeepref(*ret);
	return MAL_SUCCEED;
}
str
PBMtake(int *ret, str *grp, str *elm)
{
	BAT *b;
	int i;
	for( i=0; i< plimit; i++)
	if( partitions[i].grp &&
		 strcmp(partitions[i].grp, *grp)== 0 &&
		strcmp(partitions[i].elm, *elm)== 0) 
		break;
	if( i== plimit )
		return throwMessage("pbm.take", "PBAT partition not found");
	b= BBPdescriptor(partitions[i].bid);
	if( b== NULL)
		return throwMessage("pbm.take", "PBAT partition not accessible");
	*ret = partitions[i].bid;
	BBPkeepref(*ret);
	return MAL_SUCCEED;
}
str
PBMtakeIndexed(int *ret, str *grp, int *idx)
{
	BAT *b;
	int i;
	i= PBMfindPBAT(*grp);
	if( i< 0)
		return throwMessage("pbm.take","PBAT not found");
	for( ; i>=0 && *idx>0; i= partitions[i].next)
		*idx= *idx-1;
	if( i< 0)
		return throwMessage("pbm.take","PBAT component not found");
	b= BBPdescriptor(partitions[i].bid);
	if( b== NULL)
		return throwMessage("pbm.take", "PBAT partition not accessible");
	*ret = partitions[i].bid;
	BBPkeepref(*ret);
	return MAL_SUCCEED;
}
str
PBMgetComponents(int *ret, str *grp)
{
	BAT *b;
	int i;
	b= BATnew(TYPE_str,TYPE_str, oid_nil);
	if( b==NULL)
		return throwMessage("pbm.take", "Could not create BAT");
	for( i= PBMfindPBAT(*grp); i>=0;  i= partitions[i].next)
		BUNins(b,grp, partitions[i].elm);
	*ret = b->batCacheid;
	BBPkeepref(*ret);
	return MAL_SUCCEED;
}
str
PBMgetAllComponents(int *ret)
{
	BAT *b;
	int i;
	b= BATnew(TYPE_str,TYPE_str, oid_nil);
	if( b==NULL)
		return throwMessage("pbm.take", "Could not create BAT");
	for( i= 0; i<ptop;  i++)
	if( partitions[i].grp )
		BUNins(b,partitions[i].grp, partitions[i].elm);
	*ret = b->batCacheid;
	BBPkeepref(*ret);
	return MAL_SUCCEED;
}

@-
Administration of new partitions.
@c
int
PBMfindGrp(int bid)
{
	int i;

	for (i = 0; i < ptop; i++)
		if (partitions[i].bid == bid) {
			while (partitions[i].prev >= 0)
				i = partitions[i].prev;
			return i;
		}
	return -1;
}

@-
Find the header of a group
@c
int
PBMfindPBAT(str grp)
{
	int i;

	for (i = 0; i < ptop; i++)
		if(	partitions[i].grp && 
			strcmp(partitions[i].grp,grp)==0 &&
			partitions[i].prev == -1 )
			return i;
	return -1;
}
int
PBMfindPBATcomponent(str grp, str elm)
{
	int i;

	for (i = 0; i < ptop; i++)
		if( strcmp(partitions[i].grp,grp)==0 &&
			strcmp(partitions[i].elm,elm)== 0)
			return i;
	return -1;
}

str
PBMdeposit(int *ret, str *grp, str *elm, int *bid)
{
	int idx, i,j;
	BAT *b;

	i= PBMfindPBATcomponent(*grp,*elm);
	if( i >=0 )
		return throwMessage("pbm.deposit", "PBAT component already known");
	b = BATdescriptor(*bid);
	if (b == NULL)
		return throwMessage("pbm.deposit", "Can not access descriptor");
	idx = PBMfindPBAT(*grp);
	if (ptop == plimit)
		PBMresize(plimit + INCREMENT);
	for (i = 0; i <= ptop; i++)
		if (partitions[i].bid == -1)
			break;
	partitions[i].grp = GDKstrdup(*grp);
	partitions[i].elm = GDKstrdup(*elm);
	partitions[i].bid = *bid;
	partitions[i].first = b->hseqbase;
	partitions[i].last = b->hseqbase + BATcount(b);
	partitions[i].prev = -1;
	partitions[i].next = -1;
	if (i >= ptop) {
		ptop = i + 1;
		partitions[ptop].bid = -1;
		partitions[ptop].next = -1;
		partitions[ptop].prev = -1;
	}
	if( idx >=0){
		for(j=idx; partitions[j].next>=0; j= partitions[j].next) ;
		partitions[j].next = i;
		partitions[i].prev = j;
	}
	BBPunfix(*bid);
	(void) ret;
	return MAL_SUCCEED;
}

str
PBMdepositByName(int *ret, str *grp, str *elm)
{
	int idx;
	BAT *b;

	idx= PBMfindPBATcomponent(*grp,*elm);
	if( idx >=0 )
		return throwMessage("pbm.deposit", "PBAT already known");
	b = BATdescriptor(partitions[idx].bid);
	if (b == NULL)
		return throwMessage("pbm.deposit", "Can not access descriptor");

	PBMdeposit(ret,grp,elm,&partitions[idx].bid);
	BBPunfix(partitions[idx].bid);
	(void) ret;
	return MAL_SUCCEED;
}

str
PBMgetRange(oid *first, oid *last, int *bid)
{
	int i;

	for (i = 0; i < ptop; i++)
		if (partitions[i].bid == *bid) {
			*first = partitions[i].first;
			*last = partitions[i].last;
			return MAL_SUCCEED;
		}
	return throwMessage("pbm.getRange", "PBAT not known");
}

str
PBMgetLast(int *ret, str *grp)
{
	int i;

	i= PBMfindPBAT(*grp);
	if( i < 0)
		return throwMessage("pbm.getLast", "PBAT not known");
	for (; partitions[i].next>=0 ; i= partitions[i].next)
		;
	*ret = partitions[i].bid;
	return MAL_SUCCEED;
}

str
PBMdiscard(int *ret, str *grp)
{
	int i;

	for (i = 0; i<ptop; i++)
	if(	partitions[i].grp &&
		strcmp(partitions[i].grp, *grp)== 0 )
			PBMfreePartition(i);
	(void) ret;
	return MAL_SUCCEED;
}

str
PBMdiscardAll(int *ret)
{
	int i;
	for(i=0; i<ptop; i++)
	if( partitions[i].grp)
			PBMfreePartition(i);
	GDKfree(partitions);
	partitions = 0;
	plimit = -1;
	PBMresize(INCREMENT);
	(void) ret;
	return MAL_SUCCEED;
}

@-
releasing the PBAT does not remove its components.
@c
str
PBMreleaseAll(int *ret, int *bid)
{
	(void) ret;
	(void) bid;
	return throwMessage("pbm.release", "not yet implemented");
}

str
PBMdiscardComponent(int *ret, str *grp, int *bid)
{
	(void) ret;
	(void) bid;
	(void) grp;
	return throwMessage("pbm.release", "not yet implemented");
}
@-
We start with the large chunk iterator.
The definition of the control statements require the same
control variables, which means that the BATview is accessible
to determine how far to advance when the next chunk is retrieved.
The number of elements in the chunk is limited by the granule
size.
@c
str
PBMnewIteratorBase(int *ret, str *grp, str *elm)
{
	*ret = 0;
	if (*ret == ptop)
		*ret = -1;
	else {
		*grp= GDKstrdup(partitions[0].grp);
		*elm= GDKstrdup(partitions[0].elm);
	}
	return MAL_SUCCEED;
}

str
PBMhasMoreElementsBase(int *ret, str *nme, str *elm)
{
	do {
		*ret = *ret + 1;
		if (*ret >= ptop) {
			*ret = -1;
			return MAL_SUCCEED;
		}
		*nme= GDKstrdup(partitions[*ret].grp);
		*elm= GDKstrdup(partitions[*ret].elm);
	} while (partitions[*ret].bid == -1);
	return MAL_SUCCEED;
}

str
PBMnewIterator(int *res, str *grp)
{
	int idx;

	idx= PBMfindPBAT(*grp);
	if(idx<0)
		return throwMessage("pbm.newIterator","Could not find PBAT");
	*res = partitions[idx].bid;
	BBPincref(*res, TRUE);
	return MAL_SUCCEED;
}

str
PBMnewIteratorRng(int *res, str *grp, oid *first, oid *last)
{
	int i;

	i= PBMfindPBAT(*grp);
	if( i<0)
		return throwMessage("pbm.newIterator","Could not find PBAT");
	for (; i>=0 ; i= partitions[i].next)
	if (!(partitions[i].last < *first || partitions[i].first > *last)) {
			*res = partitions[i].bid;
			BBPincref(*res, TRUE);
		}
	return MAL_SUCCEED;
}

str
PBMhasMoreElements(int *res, str *grp)
{
	int i;
	for(i=0; i<ptop; i++)
	if( partitions[i].bid == *res &&
		partitions[i].grp &&
		strcmp(partitions[i].grp,*grp)== 0){
		*res= partitions[i].bid;
		BBPincref(*res, TRUE);
		return MAL_SUCCEED;
	}
	*res = -1;
	return MAL_SUCCEED;
}

str
PBMhasMoreElementsRng(int *res, str *grp, oid *first, oid *last)
{
	int i;
	for(i= PBMfindPBAT(*grp); i>=0 ; i = partitions[i].next)
		if( !(partitions[i].last < *first || partitions[i].first > *last)) {
			*res = partitions[i].bid;
			BBPincref(*res, TRUE);
			return MAL_SUCCEED;
		}
	*res = -1;
	return MAL_SUCCEED;
}

str
PBMcompress(int *ret, str *grp)
{
	BAT *b;
	int i;
	oid o = 0;

	(void) ret;
	i = PBMfindPBAT(*grp);
	if (i < 0)
		return throwMessage("pbm.commpress", "PBAT not found");
	b = BATdescriptor(partitions[i].bid);
	if (b == 0)
		return throwMessage("pbm.commpress", "BAT group not found");
	for (; i >= 0; i = partitions[i].next) {
		partitions[i].first = o;
		b = BATdescriptor(partitions[i].bid);
		if (b == 0)
			return throwMessage("pbm.compress", "Internal error in BAT group");
		b->hseqbase = partitions[i].first;
		o = partitions[i].last += BATcount(b) - 1;
		BBPunfix(b->batCacheid);
	}
	return MAL_SUCCEED;
}
@}
