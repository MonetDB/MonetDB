@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f const
@a Martin Kersten
@v 0.1
@* Constant support box
This module shows the behavior of a simple box of global variables.
They are stored into the box using {\sc deposit} and taken
out with {\sc take}. Once you are done, elements can be
removed by name or reference using {\sc discard}.

A box should be opened before being used. It is typically used
to set-up the list of current users and to perform authorization.

The default constant box is initialized with session variables,
such as 'user','dbname', 'dbfarm', and 'dbdir'.
These actions are encapsulated in the prelude routine called.

The constant box is protected with a simple authorization scheme,
prohibiting all updates unless issued by the system administrator.

@mal
module const
comment "The const module provides a box 
abstraction store for global constants.
Between sessions the value of the constants 
is saved on disk in the form of a simple 
mal program, which is scanned and made 
available by opening the box.  A future 
implementation should provide transaction 
support over the box, which would permit 
multiple clients to exchange (scalar) 
information easily.";

pattern open():void
address CSTopen
comment "Locate and open the constant box";
pattern close():void
address CSTclose
comment "Close the constant box ";
pattern destroy():void
address CSTdestroy
comment "Destroy the box";
pattern take(name:str):any 
address CSTtake
comment "Take a variable out of the box";
pattern deposit(name:str,val:any) :void 		
address CSTdeposit
comment "Enter a new variable into the box";

pattern releaseAll():void 
address CSTreleaseAll
comment "Release all variables in the box";
pattern release(name:str) :void 		
address CSTrelease
comment "Release a new constant value";
pattern release(name:any):void 
address CSTrelease
comment "Release a new constant value";
pattern toString(name:any):str 
address CSTtoString
comment "Get the string representation of an element in the box";
pattern discard(name:any) :void 		
address CSTdiscard
comment "Release the const from the box";
pattern newIterator()(:lng,:str)
address CSTnewIterator
comment "Locate next element in the box";
pattern hasMoreElements()(:lng,:str)
address CSThasMoreElements
comment "Locate next element in the box";

@{
pattern prelude():void 
address CSTprelude
comment "Initialize the const box";

const.prelude();
@-
@+ Implementation
@h
#ifndef _ITERATOR_H
#define _ITERATOR_H
#include "mal.h"
#include "mal_client.h"
#include "mal_interpreter.h"

mal_export str CSTprelude(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mal_export str CSTopen(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mal_export str CSTclose(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mal_export str CSTdestroy(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mal_export str CSTdeposit(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mal_export str CSTtake(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mal_export str CSTrelease(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mal_export str CSTreleaseAll(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mal_export str CSTdiscard(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mal_export str CSTtoString(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mal_export str CSTnewIterator(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mal_export str CSThasMoreElements(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
#endif /* _ITERATOR_H */
@- Module initializaton
The content of this box my only be changed by the Administrator.
@= authorize
	if( !isAuthorized("user") && !isAuthorized("Admin"))
		return throwMessage("const.@1","unauthorized access to 'const' box");
@-
@= insertBox
	msg = @2;
	insertToBox(box,@1,msg);
	GDKfree(msg);
@c
#include "const.h"


int
isAuthorized(str nme)
{
	Client c;

	if (nme == 0)
		return 1;
	c = getClient();
	return idcmp(c->user, nme) == 0;
}

str
CSTprelude(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	Box box;

	(void) mb;
	(void) stk;
	(void) pci;		/* fool compiler */
	@:authorize(prelude)@
	box = openBox("const");
	if (box == 0)
		return throwMessage("const.prelude", "failed to open box");
	/* if the box was already filled we can skip initialization */
	if (box->sym->vtop == 0) {
		insertToBox(box, "user", getClient()->user);
		insertToBox(box, "dbname", GDKgetenv("gdk_dbname"));
		insertToBox(box, "dbfarm", GDKgetenv("gdk_dbfarm"));
		insertToBox(box, "version", GDKgetenv("gdk_version"));
		insertToBox(box, "config", GDKgetenv("gdk_config"));
		/* old bat.mx and algebra.mx constants */
	}
	return MAL_SUCCEED;
}

@- Operator implementation
@c
str
CSTopen(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	(void) mb;
	(void) stk;
	(void) pci;		/* fool compiler */
	@:authorize(open)@
	if (openBox("const") != 0)
		return MAL_SUCCEED;
	return throwMessage("const.open", "failed to open box");
}

str
CSTclose(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	(void) mb;
	(void) stk;
	(void) pci;		/* fool compiler */
	@:authorize(close)@
	if (closeBox("const", TRUE) == 0)
		return MAL_SUCCEED;
	return throwMessage("const.close", "failed to close box");
}

str
CSTdestroy(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	Box box;

	(void) mb;
	(void) stk;
	(void) pci;		/* fool compiler */
	@:OpenBox(destroy)@
	destroyBox("const");
	return MAL_SUCCEED;
}

@-
Access to a box calls for resolving the first parameter
to a named box.
@= OpenBox
	@:authorize(@1)@
	box= findBox("const");
	if( box ==0) 
	return throwMessage("const.@1","box is not open");
@-
@c
str
CSTdeposit(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str name;
	ValPtr v;
	Box box;

	@:OpenBox(deposit)@
	name = (str) getArgValue(stk, pci, 1);
	v = &stk->stk[getArg(pci, 2)];
	if (depositBox(box, name, v))
		return throwMessage("const.deposit", "failed to deposit into box");
	(void) mb;
	return MAL_SUCCEED;
}

str
CSTtake(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str name;
	Box box;
	ValPtr v;

	@:OpenBox(take)@
	name = (str) getArgValue(stk, pci, 1);
	v = &stk->stk[getArg(pci, 0)];
	if (takeBox(box, name, v, (int) getArgType(mb, pci, 0)))
		return throwMessage("const.take", "failed to take object from box");
	(void) mb;
	return MAL_SUCCEED;
}

str
CSTrelease(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str name;
	Box box;

	(void) mb;		/* fool compiler */

	@:OpenBox(release)@
	name = (str) getArgValue(stk, pci, 1);
	if (releaseBox(box, name))
		return throwMessage("const.release", "failed to release object from box");
	return MAL_SUCCEED;
}

str
CSTreleaseAll(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	Box box;

	(void) mb;
	(void) stk;
	(void) pci;		/* fool compiler */
	@:OpenBox(release)@
	releaseAllBox(box);
	return MAL_SUCCEED;
}

str
CSTdiscard(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str name;
	Box box;

	(void) mb;		/* fool compiler */
	@:OpenBox(discard)@
	name = (str) getArgValue(stk, pci, 1);
	if (discardBox(box, name) == 0)
		return throwMessage("const.discard", "failed to discard object from box");
	return MAL_SUCCEED;
}

str
CSTtoString(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	Box box;
	int i, len = 0;
	ValPtr v;
	str nme, s = 0;

	(void) mb;		/* fool compiler */
	@:OpenBox(toString)@
	nme = (str) getArgValue(stk, pci, 1);
	i = findVariable(box->sym, nme);
	if (i < 0)
		return throwMessage("const.toString", "failed to take object from box");

	v = &box->val->stk[i];
	if (v->vtype == TYPE_str)
		s = v->val.sval;
	else
		(*BATatoms[v->vtype].atomToStr) (&s, &len, v);
	if (s == NULL)
		return throwMessage("const.toString", "illegal value");
	VALset(&stk->stk[getArg(pci, 0)], TYPE_str, s);
	return MAL_SUCCEED;
}

str
CSTnewIterator(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	Box box;
	lng *cursor;
	ValPtr v;

	(void) mb;		/* fool compiler */
	@:OpenBox(iterator)@
	cursor = (lng *) getArgValue(stk, pci, 0);
	v = &stk->stk[getArg(pci, 1)];
	nextBoxElement(box, cursor, v);
	return MAL_SUCCEED;
}

str
CSThasMoreElements(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	Box box;
	lng *cursor;
	ValPtr v;

	(void) mb;		/* fool compiler */
	@:OpenBox(iterator)@
	cursor = (lng *) getArgValue(stk, pci, 0);
	v = &stk->stk[getArg(pci, 1)];
	nextBoxElement(box, cursor, v);
	return MAL_SUCCEED;
}

@}
