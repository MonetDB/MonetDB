@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008-2009 MonetDB B.V.
@' All Rights Reserved.

@f remote
@a Fabian Groffen
@+ Remote querying functionality
Communication with other mservers at the MAL level is a delicate task.
However, it is indispensable for any distributed functionality.  This
module provides an abstract way to store and retrieve objects on a
remote site.  Additionally, functions on a remote site can be executed
using objects available in the remote session context.  This yields in
four primitive functions that form the basis for distribution methods:
get, put, register and exec.

The get method simply retrieves a copy of a remote object.  Objects can
be simple values, strings or BATs.  The same holds for the put method,
but the other way around.  A local object can be stored on a remote
site.  Upon a successful store, the put method returns the remote
identifier for the stored object.  With this identifier the object can
be addressed, e.g. using the get method to retrieve the object that was
stored using put.

The get and put methods are symmetric.  Performing a get on an
identifier that was returned by put, results in an object with the same
value as the one that was put.  The result of such an operation is
equivalent to making an (expensive) copy of the original object.

The register function takes a local MAL function and makes it known
at a remote site. It ensures that it does not overload an already
known operation remotely, which could create a semantic conflict.
Deregister a function is forbidden, because it would allow for taking
over the remote site completely.
C-implemented functions, such as io.print() cannot be remotely 
stored. It would require even more complicated (byte?) code 
shipping and remote compilation to make it work.  
Currently, the remote procedure may only returns a single value.

The choice to let exec only execute functions was made to avoid problems
to decide what should be returned to the caller.  With a function it is
clear and simple to return that what the function signature prescribes.
Any side effect (e.g.  io.print calls) may cause havoc in the system,
but are currently ignored.

This leads to the final contract of this module.  The methods should be
used correctly, by obeying their contract.  Failing to do so will result
in errors and possibly undefined behaviour.

The remote module also contains functionality to create and maintain
connections.  Here a close binding with Merovingian and Sabaoth is
inevitable to make remote aware of possible connections in the vincinity
of the server.  This translates into the getList() function, that returns a
list of databases. For each we can ask its type getKind(),
which is either "local", "remote" or "user".  
The "local" type is used for databases known by Sabaoth, which are hence local.
The second translates into the discovered neighbours by Merovingian (as
returned by `monetdb discover`), which are remote as such.  Lastly, a
user can add her own connection using the create() function, which
also appears in the output of list().  Connections added using create()
are currently not persistent over server restarts, but can be removed
using destroy(). They are marked "user".

Connections are activated using a call to connect().  Each client has
its own stack of connection handles.  By default, a connection is
persistent, that is, it is being reused over multiple connect calls.  In
some cases this might not be desirable.  For this situation, connect()
can be instructed to explicitly create a new connection.  The return
value of connect() is a string handle that identifies the connection,
which must be passed to calls that perform operations over the
connection.  A call to disconnect() closes the connection handle for
non-persistent connections.  Persistent connections are closed when the
client is destroyed by the server, such as when the client's session
ends.

The first argument to the primary functions is the name of the connection
the operation has to be performed on.  A connection has to be created
before it can be used, otherwise a MALexception is being raised.
During creation of such connection, details like credentials, hostname
and database can be given.  Currently, connections are stored in memory
and not made persistent.  This could be changed in the future to allow
connections created to be remembered over server restarts.

@mal
module remote;

# module loading and unloading funcs

command prelude():void
address RMTprelude
comment "Initialise the remote module.";

command epilogue():void
address RMTepilogue
comment "Release the resources held by the remote module.";

# global connection management functions

command create(dbname:str, host:str, port:int):str
address RMTcreate
comment "Create a user-defined connection to a server.";

command destroy(dbname:str):void
address RMTdestroy
comment "Destroy a previously user-defined connection to a server.";

command getList()(list:bat[:void,:str], kind:bat[:void,:str])
address RMTgetList
comment "List available databases with their property for use with connect().";

# session local connection instantiation functions

command connect(dbname:str, user:str, passwd:str):str
address RMTconnectDef
comment "Returns a persistent connection for dbname using user name and password, or creates a new connection if no previous connection exists.";

command connect(dbname:str, user:str, passwd:str, persistent:bit):str
address RMTconnect
comment "Returns a newly created connection for dbname, user name and password, if persistent is false or no previous connection exists.  Otherwise the previously existing connection is returned.";

command disconnect(dbname:str):void
address RMTdisconnectDef
comment "Disconnects a non-persistent connection.  Calling this function for a persistent connection is a no-op.";

command disconnect(dbname:str, force:bit):void
address RMTdisconnect
comment "Disconnects the connection for dbname.";


# core transfer functions

pattern get(conn:str, ident:str):any
address RMTget
comment "Retrieves a copy of remote object ident.";

pattern put(conn:str, object:any):str
address RMTput
comment "Copies object to the remote site and returns its identifier.";

pattern register(conn:str, mod:str, fcn:str):void
address RMTregister
comment "Register <mod>.<fcn> at the remote site.";

pattern exec(conn:str, mod:str, func:str):str
address RMTexec
comment "Remotely executes <mod>.<func> and returns the handle to its result";
pattern exec(conn:str, mod:str, func:str, :str...):str
address RMTexec
comment "Remotely executes <mod>.<func> using the argument list
of remote objects and returns the handle to its result";

@h

#ifndef _REMOTE_DEF
#define _REMOTE_DEF


/* #define _DEBUG_REMOTE_	   trace the interaction */
/* #define _DEBUG_MAPI_		   trace mapi interaction */

#ifdef WIN32
#ifndef LIBREMOTE

#define remote_export extern __declspec(dllimport)
#else
#define remote_export extern __declspec(dllexport)
#endif
#else
#define remote_export extern
#endif
@c
#include "mal_config.h"
#include <mal.h>
#include <mal_exception.h>
#include <mal_interpreter.h>
#include <mal_function.h> /* for printFunction */
#include <mal_sabaoth.h> /* for local "connections" */
#include <mapilib/Mapi.h>
#include "remote.h"	/* for the implementation of the functions */

#ifndef WIN32
#include <sys/socket.h> /* socket */
#include <sys/un.h> /* sockaddr_un */
#endif
#include <unistd.h> /* gethostname */

@-
Technically, these methods need to be serialised per connection, 
hence a scheduler that interleaves e.g.  multiple get calls, 
simply violates this constraint.  If parallelism to the same site 
is desired, a user could create a second connection.
This is not always easy to generate at the proper place, e.g.
overloading the dataflow optimizer to patch connections structures
is not acceptable.

Instead, we maintain a simple lock with each connection, which
can be used to issue a safe, but blocking get/put/exec/register request.
@- Implementation
@h
typedef struct _connection {
	MT_Lock            lock;      /* lock to avoid interference */
	str                name;      /* the handle for this connection */
	Mapi               mconn;     /* the Mapi handle for the connection */
	bit                persist;   /* is it a persistent connection */
	size_t             nextid;    /* id counter */
	struct _connection *next;     /* the next connection in the list */
} *connection;

typedef struct _userconn {
	char             *dbname;     /* name of the connection */
	char             *host;       /* host to connect to */
	int              port;        /* target port */
	struct _userconn *next;       /* the next connection in the list */
} *userconn;

@h
remote_export str RMTprelude(int *ret);
remote_export str RMTepilogue(int *ret);
@c
static userconn userconns = NULL;

static INLINE str RMTquery(MapiHdl *ret, str func, Mapi conn, str query);

@h
remote_export str RMTcreate(str *ret, str *dbname, str *host, int *port);
@c
/**
 * Stores a new connection in the global state.  The connection is not
 * validated.
 */
remote_export str RMTcreate(str *ret, str *dbname, str *host, int *port) {
	userconn c;

	*ret = 0;

	if (dbname == NULL || *dbname == NULL || strcmp(*dbname, (str)str_nil) == 0)
		throw(ILLARG, "remote.create", "database name is NULL or nil");
	if (host == NULL || *host == NULL || strcmp(*host, (str)str_nil) == 0)
		throw(ILLARG, "remote.create", "hostname is NULL or nil");
	if (port == NULL || *port <= 0)
		throw(ILLARG, "remote.create", "port is NULL or <= 0");

	mal_set_lock(mal_remoteLock, "remote.create"); /* global userconns */
	/* find a free slot, start with special case of connections not
	 * being set */
	if (userconns == NULL) {
		userconns = GDKzalloc(sizeof(struct _userconn));
		c = userconns;
	} else {
		/* ok, it's set, so find the last element in the list */
		userconn t = c = userconns;
		do {
			/* at the same time also check if this connection name
			 * already exists */
			if (strcmp(c->dbname, *dbname) == 0) {
				mal_unset_lock(mal_remoteLock, "remote.create"); /* global userconns */
				throw(MAL, "remote.create", "connection with name "
						"'%s' already exists", *dbname);
			}
			t = c;
			c = c->next;
		} while (c != NULL);
		c = t->next = GDKzalloc(sizeof(struct _userconn));
	}

	/* fill in the new entry */
	c->dbname = GDKstrdup(*dbname);
	c->host = GDKstrdup(*host);
	c->port = *port;
	c->next = NULL;

	mal_unset_lock(mal_remoteLock, "remote.create"); /* global userconns */
	*ret = GDKstrdup(*dbname);
	return(MAL_SUCCEED);
}

@h
remote_export str RMTdestroy(int *ret, str *dbname);
@c
/**
 * Removes a connection in the global state.  If the connection is in
 * use by a client, it will remain available for that client.
 */
str RMTdestroy(int *ret, str *dbname) {
	userconn c, t;

	if (dbname == NULL || *dbname == NULL || strcmp(*dbname, (str)str_nil) == 0)
		throw(ILLARG, "remote.destroy", "connection name is NULL or nil");

	/* just make sure the return isn't garbage */
	*ret = 0;

	mal_set_lock(mal_remoteLock, "remote.destroy"); /* global connections */
	c = userconns;
	t = NULL;
	/* walk through the list */
	while (c != NULL) {
		if (strcmp(c->dbname, *dbname) == 0) {
			/* ok, delete it... */
			if (t == NULL) { /* the top */
				t = c->next;
				GDKfree(c->dbname);
				GDKfree(c->host);
				GDKfree(c);
				userconns = t;
			} else {
				/* connect the grand child to the grand parent */
				t->next = c->next;
				/* and kill the parent in the middle */
				GDKfree(c->dbname);
				GDKfree(c->host);
				GDKfree(c);
			}

			mal_unset_lock(mal_remoteLock, "remote.destroy");
			return(MAL_SUCCEED);
		}
		c = c->next;
	}

	mal_unset_lock(mal_remoteLock, "remote.destroy");
	throw(MAL, "remote.destroy", "no such connection with name '%s'", *dbname);
}

@h
remote_export str RMTgetList(int *ret, int *ret2);
@c
#define SOCKPTR struct sockaddr *
/**
 * Returns a BAT with available connections.  In the head the dbname is
 * stored, in the tail "user", "local" or "remote".  The entries are
 * grouped in that order.
 */
remote_export str RMTgetList(int *ret, int *ret2){
	BAT *b, *b2;
	str type;
	userconn c;
	sabdb *sab, *osab;
	str tmp;
	char path[8096];
	char mero_running;
	int fd;

	b = BATnew(TYPE_void,getHeadType(TYPE_str), 20);
	if ( b == NULL)
		throw(MAL,"remote.getList","could not create BAT");
	b2 = BATnew(TYPE_void,getHeadType(TYPE_str), 20);
	if ( b2 == NULL){
		BBPunfix(b->batCacheid);
		throw(MAL,"remote.getList","could not create BAT");
	}

	/* part 1: "user" -- this is trivial */
	type = "user";
	mal_set_lock(mal_remoteLock, "remote.list");
	c = userconns;
	/* walk through the list */
	while (c != NULL) {
		BUNappend(b, (ptr)c->dbname,FALSE);
		BUNappend(b, (ptr)type,FALSE);
		c = c->next;
	}
	mal_unset_lock(mal_remoteLock, "remote.list");

	/* part 2: "local" -- bit more tricky, contact Sabaoth */
	type = "local";
	rethrow("remote.list", tmp, SABAOTHgetStatus(&osab, NULL));
	sab = osab;
	while (sab != NULL) {
		BUNappend(b, (ptr)sab->dbname,FALSE);
		BUNappend(b, (ptr)type,FALSE);
		sab = sab->next;
	}
	SABAOTHfreeStatus(&osab);

	/* part 3: "remote" -- ask merovingian over a UNIX socket, oops
	 *                     portability issues! */
	type = "remote";
#ifndef WIN32
	mero_running = 1;
	snprintf(path, 8096, "%s/.merovingian_lock", GDKgetenv("gdk_dbfarm"));
	fd = MT_lockf(path, F_TLOCK, 4, 1);
	if (fd >= 0 || fd <= -2) {
		if (fd >= 0) {
			/* oops, not running */
			close(fd);
		}
		mero_running = 0;
	}

	/* if Merovingian isn't running, there's not much we can do */
	if (mero_running == 1) do {
		char buf[256];
		int sock = -1;
		struct sockaddr_un server;
		char *p, *q;
		int len;
		int pos;

		snprintf(path, 8095, "%s/.merovingian_control", GDKgetenv("gdk_dbfarm"));
		path[8095] = '\0';

		if ((sock = socket(AF_UNIX, SOCK_STREAM, 0)) < 0)
			break;

		memset(&server, 0, sizeof(struct sockaddr_un));
		server.sun_family = AF_UNIX;
		strncpy(server.sun_path, path, sizeof(server.sun_path) - 1);
		if (connect(sock, (SOCKPTR) &server, sizeof(struct sockaddr_un)))
			break;

		/* Send the pass phrase to unlock the information available in
		 * merovingian.  Anelosimus eximius is a social species of spiders,
		 * which help each other, just like merovingians do among each
		 * other. */
		len = snprintf(buf, sizeof(buf), "anelosimus eximius\n");
		send(sock, buf, len, 0);
		pos = 0;
		len = 0;
		buf[len] = '\0';
		do {
			if ((p = strchr(buf, '\n')) == NULL) {
				if (len == sizeof(buf) - 1) {
					/* no newline in this block, too large, discard */
					pos = 0;
				} else {
					pos = len;
				}
				len = recv(sock, buf + pos, sizeof(buf) - 1 - pos, 0);
				/* if there is no more... */
				if (len <= 0)
					break;
				len += pos;
				buf[len] = '\0';
				continue;
			}
			*p++ = '\0';

			if ((q = strchr(buf, '\t')) == NULL) {
				/* doesn't look correct */
				len -= p - buf;
				memmove(buf, p, len + 1 /* include \0 */);
				continue;
			}
			*q++ = '\0';

			/* store what we found */
			BUNappend(b, (ptr)buf,FALSE);
			BUNappend(b, (ptr)type,FALSE);

			/* move it away */
			len -= p - buf;
			memmove(buf, p, len + 1 /* include \0 */);
		} while (1);

		close(sock);
	} while (0);
#endif

	BBPkeepref(*ret = b->batCacheid);
	BBPkeepref(*ret2 = b2->batCacheid);
	return(MAL_SUCCEED);
}


#define connections    (connection)MCgetClient()->conn

/**
 * Helper function to return a userconn struct containing the needed
 * bits to open up a connection.  This function is very similar to
 * RMTgetList, but differs on enough crucial points to warrant its own
 * copy.
 */
static INLINE userconn RMTgetConnDefinition(str dbname) {
	userconn c;
	sabdb *sab, *osab;
	str tmp;
	char path[8096];
	userconn ret = NULL;
	char mero_running;
	int fd;

	/* part 1: "user" -- this is trivial */
	mal_set_lock(mal_remoteLock, "remote.list");
	c = userconns;
	/* walk through the list */
	while (c != NULL) {
		if (strcmp(c->dbname, dbname) == 0) {
			ret = GDKzalloc(sizeof(struct _userconn));
			ret->dbname = GDKstrdup(c->dbname);
			ret->host = GDKstrdup(c->host);
			ret->port = c->port;
			break;
		}
	}
	mal_unset_lock(mal_remoteLock, "remote.list");
	if (ret != NULL)
		return(ret);

	/* part 2: "local" -- bit more tricky, contact Sabaoth, but for
	 *                    connection details, we better use Merovingian
	 *                    which needs to be available in that case... */
	mero_running = 0;
#ifndef WIN32
	mero_running = 1;
	snprintf(path, 8096, "%s/.merovingian_lock", GDKgetenv("gdk_dbfarm"));
	fd = MT_lockf(path, F_TLOCK, 4, 1);
	if (fd >= 0 || fd <= -2) {
		if (fd >= 0) {
			/* oops, not running */
			close(fd);
		}
		mero_running = 0;
	}
#endif

	if ((tmp = SABAOTHgetStatus(&osab, NULL)) != NULL) {
		/* if Sabaoth fails, Merovingian most probably won't have much
		 * luck either, so just return */
		GDKfree(tmp);
		return(NULL);
	}
	sab = osab;
	while (sab != NULL) {
		if (strcmp(sab->dbname, dbname) == 0 &&
				sab->conns != NULL && sab->conns->val != NULL)
		{
			ret = GDKzalloc(sizeof(struct _userconn));
			ret->dbname = GDKstrdup(sab->dbname);
			if (mero_running == 1) { /* use Merovingian */
				gethostname(path, 8096);
				ret->host = GDKstrdup(path);
				ret->port = 0;
				tmp = GDKgetenv("mero_port");
				if (tmp != NULL)
					ret->port = atoi(GDKgetenv("mero_port"));
				if (ret->port == 0)
					ret->port = 50000;  /* hardcoded default from merovingian.mx */
				break;
			} else { /* just use the server's own connection */
				tmp = sab->conns->val;
				if (strncmp(tmp, "mapi:monetdb://", sizeof("mapi:monetdb://") - 1) == 0) {
					str port, t;
					tmp += sizeof("mapi:monetdb://") - 1;
					/* drop anything off after the hostname */
					if ((port = strchr(tmp, ':')) != NULL) {
						*port = '\0';
						port++;
						if ((t = strchr(port, '/')) != NULL)
							*t = '\0';
						ret->host = GDKstrdup(tmp);
						ret->port = atoi(port);
						break;
					}
				}
			}
			GDKfree(ret);
			ret = NULL;
		}
		sab = sab->next;
	}
	SABAOTHfreeStatus(&osab);
	if (ret != NULL)
		return(ret);

	/* part 3: "remote" -- ask merovingian over a UNIX socket, oops
	 *                     portability issues! */
#ifndef WIN32
	/* if Merovingian isn't running, there's not much we can do */
	if (mero_running == 1) do {
		char buf[256];
		int sock = -1;
		struct sockaddr_un server;
		char *p, *q;
		int len;
		int pos;

		snprintf(path, 8095, "%s/.merovingian_control", GDKgetenv("gdk_dbfarm"));
		path[8095] = '\0';

		if ((sock = socket(AF_UNIX, SOCK_STREAM, 0)) < 0)
			break;

		memset(&server, 0, sizeof(struct sockaddr_un));
		server.sun_family = AF_UNIX;
		strncpy(server.sun_path, path, sizeof(server.sun_path) - 1);
		if (connect(sock, (SOCKPTR) &server, sizeof(struct sockaddr_un)))
			break;

		/* Send the pass phrase to unlock the information available in
		 * merovingian.  Anelosimus eximius is a social species of spiders,
		 * which help each other, just like merovingians do among each
		 * other. */
		len = snprintf(buf, sizeof(buf), "anelosimus eximius\n");
		send(sock, buf, len, 0);
		pos = 0;
		len = 0;
		buf[len] = '\0';
		do {
			if ((p = strchr(buf, '\n')) == NULL) {
				if (len == sizeof(buf) - 1) {
					/* no newline in this block, too large, discard */
					pos = 0;
				} else {
					pos = len;
				}
				len = recv(sock, buf + pos, sizeof(buf) - 1 - pos, 0);
				/* if there is no more... */
				if (len <= 0)
					break;
				len += pos;
				buf[len] = '\0';
				continue;
			}
			*p++ = '\0';

			if ((q = strchr(buf, '\t')) == NULL) {
				/* doesn't look correct */
				len -= p - buf;
				memmove(buf, p, len + 1 /* include \0 */);
				continue;
			}
			*q++ = '\0';

			/* does it match? */
			if (strcmp(buf, dbname) == 0) {
				ret = GDKzalloc(sizeof(struct _userconn));
				ret->dbname = GDKstrdup(sab->dbname);
				tmp = p;
				if (strncmp(tmp, "mapi:monetdb://", sizeof("mapi:monetdb://") - 1) == 0) {
					str port, t;
					tmp += sizeof("mapi:monetdb://") - 1;
					/* drop anything off after the hostname */
					if ((port = strchr(tmp, ':')) != NULL) {
						*port = '\0';
						port++;
						if ((t = strchr(port, '/')) != NULL)
							*t = '\0';
						ret->host = GDKstrdup(tmp);
						ret->port = atoi(port);
						break;
					}
				}
			}

			/* move it away */
			len -= p - buf;
			memmove(buf, p, len + 1 /* include \0 */);
		} while (1);

		close(sock);
	} while (0);
	if (ret != NULL)
		return(ret);
#endif

	return(NULL);
}

@h
remote_export str RMTconnectDef(str *ret, str *dbname, str *user, str *passwd);
@c
/**
 * Default wrapper, calling RMTconnect with persistent = FALSE.
 */
remote_export str RMTconnectDef(str *ret, str *dbname, str *user, str *passwd) {
	bit f = TRUE;
	return(RMTconnect(ret, dbname, user, passwd, &f));
}

@h
remote_export str RMTconnect(
		str *ret,
		str *dbname,
		str *user,
		str *passwd,
		bit *persistent);
@c
#define serveget "\
    function user.remote_internal_servegetbat(type:str, o:bat[:any_1,:any_2]):void;\n\
        t := inspect.getType(o);\n\
        barrier ifpart := type == t;\n\
			len := aggr.count(o);\n\
			io.print(len);\n\
            io.print(o);\n\
        exit ifpart;\n\
		barrier ifpart := calc.isnil(type);\n\
			io.printf(\"!MALException:user.serveget:nil type doesn't match anything\n\");\n\
		exit ifpart;\n\
		barrier ifpart := type != t;\n\
			io.printf(\"!MALException:user.serveget:object type (%s) \", t);\n\
			io.printf(\"does not match required type (%s)\n\", type);\n\
		exit ifpart;\n\
    end user.remote_internal_servegetbat;\n\
    function user.remote_internal_serveget(type:str, o:any):void;\n\
        t := inspect.getType(o);\n\
        barrier ifpart := type == t;\n\
            io.print(o);\n\
        exit ifpart;\n\
		barrier ifpart := calc.isnil(type);\n\
			io.printf(\"!MALException:user.serveget:nil type doesn't match anything\n\");\n\
		exit ifpart;\n\
		barrier ifpart := type != t;\n\
			io.printf(\"!MALException:user.serveget:object type (%s) \", t);\n\
			io.printf(\"does not match required type (%s)\n\", type);\n\
		exit ifpart;\n\
    end user.remote_internal_serveget;\n\
"
/**
 * Returns a connection to the given dbname.  If persistent is FALSE, it
 * always returns a newly created connection.  Otherwise, it returns an
 * existing connection if available, or a newly connected one otherwise.
 * A returned existing connection is checked for its connectivity.
 */
str RMTconnect(
		str *ret,
		str *dbname,
		str *user,
		str *passwd,
		bit *persistent)
{
	connection c;
	userconn cdef = NULL;
	MapiHdl mhdl;
	char conn[BUFSIZ];
	char *s;
	str tmp;
	int id;

	/* just make sure the return isn't garbage */
	*ret = 0;

	if (dbname == NULL || *dbname == NULL || strcmp(*user, (str)str_nil) == 0)
		throw(ILLARG, "remote.connect", "database name is NULL or nil");
	if (user == NULL || *user == NULL || strcmp(*user, (str)str_nil) == 0)
		throw(ILLARG, "remote.connect", "username is NULL or nil");
	if (passwd == NULL || *passwd == NULL || strcmp(*passwd, (str)str_nil) == 0)
		throw(ILLARG, "remote.connect", "password is NULL or nil");
	if (persistent == NULL)
		throw(ILLARG, "remote.connect", "persistent is NULL");


	/* generate a connection name */
	id = 0;
	if (*persistent == FALSE)
		id = 1; /* reserve 0 for the persistent one */
	snprintf(conn, BUFSIZ, "%s_%s_%d", *dbname, *user, id);

	/* find a free slot, start with special case of connections not
	 * being set */
	if (connections == NULL) {
		MCgetClient()->conn = GDKzalloc(sizeof(struct _connection));
		c = connections;
	} else {
		/* ok, it's set, so find the last element in the list */
		connection t = c = connections;
		do {
			/* at the same time also check if this connection name
			 * already exists */
			if (strcmp(c->name, conn) == 0) {
				if (*persistent == TRUE) {
					if (mapi_ping(c->mconn) != MOK && mapi_reconnect(c->mconn) != MOK) {
						throw(IO, "remote.connect", "an error occurred during "
								"reconnect of '%s': %s",
								conn, mapi_error_str(c->mconn));
						/* TODO: throw away connection? */
					}
					*ret = strdup(conn);
					return(MAL_SUCCEED);
				}

				/* try the next id, duplicate non-persistent connects
				 * must be allowed */
				id++;
				snprintf(conn, BUFSIZ, "%s_%s_%d", *dbname, *user, id);
			}
			t = c;
			c = c->next;
		} while (c != NULL);
		cdef = RMTgetConnDefinition(*dbname);
		if (cdef == NULL)
			throw(MAL, "remote.connect", "no such connection with name: '%s'",
					dbname);
		c = t->next = GDKzalloc(sizeof(struct _connection));
	}
	/* make sure we protect the just added connection (small race) */
	mal_set_lock(c->lock, "remote.connect");

	/* this can probably screw up the uniqueness, but we need it since
	 * we will construct MAL identifiers using it */
	for (s = conn; *s != '\0'; s++) {
		if (!isalpha((int)*s) && !isdigit((int)*s)) {
			*s = '_';
		}
	}

	c->name = GDKstrdup(conn);
	c->persist = *persistent;
	c->nextid = 0;
	c->next = NULL;
	c->mconn = mapi_mapi(cdef->host, cdef->port, *user, *passwd, "mal",
			(strcmp(*dbname, (str)str_nil) == 0 ? NULL : *dbname));

	GDKfree(cdef->dbname);
	GDKfree(cdef->host);
	GDKfree(cdef);

	if (mapi_reconnect(c->mconn) != MOK){
		mal_unset_lock(c->lock, "remote.connect"); 
		throw(IO, "remote.connect", "an error occurred during "
				"connect of connection '%s': %s",
				conn, mapi_error_str(c->mconn));
	}
	/* TODO: throw away connection? */

#ifdef _DEBUG_MAPI_
	mapi_trace(c->mconn,TRUE);
#endif

	/* initialise remote helper function */
	if ((tmp = RMTquery(&mhdl, "remote.connect",
					c->mconn, serveget)) != MAL_SUCCEED)
	{
		mal_unset_lock(c->lock, "remote.connect"); 
		return tmp;
	}
	mapi_close_handle(mhdl);
	mal_unset_lock(c->lock, "remote.connect"); 

	*ret = GDKstrdup(conn);
	return(MAL_SUCCEED);
}

@h
remote_export str RMTdisconnectDef(int *ret, str *conn);
@c
/**
 * Simple wrapper that calls RMTdisconnect with force = FALSE.
 */
remote_export str RMTdisconnectDef(int *ret, str *conn) {
	bit f = FALSE;
	return(RMTdisconnect(ret, conn, &f));
}

@h
remote_export str RMTdisconnect(int *ret, str *conn, bit *force);
@c
/**
 * Disconnects a connection.  The connection needs not to exist in the
 * system, it only needs to exist for the client (i.e. it was once
 * created).
 */
str RMTdisconnect(int *ret, str *conn, bit *force) {
	connection c, t;

	if (conn == NULL || *conn == NULL || strcmp(*conn, (str)str_nil) == 0)
		throw(ILLARG, "remote.disconnect", "connection name is NULL or nil");
	if (force == NULL)
		throw(ILLARG, "remote.disconnect", "force is NULL");


	/* just make sure the return isn't garbage */
	*ret = 0;

	c = connections;
	t = NULL;
	/* walk through the list */
	while (c != NULL) {
		if (strcmp(c->name, *conn) == 0) {
			/* don't close persistent connections, unless forced */
			if (*force == FALSE && c->persist == FALSE) {
				mal_unset_lock(mal_remoteLock, "remote.disconnect");
				return(MAL_SUCCEED);
			}

			/* ok, delete it... */
			if (t == NULL) { /* the top */
				t = c->next;
				mal_set_lock(c->lock, "remote.disconnect"); /* shared connection */
				mapi_destroy(c->mconn);
				mal_unset_lock(c->lock, "remote.disconnect");
				GDKfree(c->name);
				GDKfree(c);
				MCgetClient()->conn = t;
			} else {
				/* connect the grand child to the grand parent */
				t->next = c->next;
				/* and kill the parent in the middle */
				mal_set_lock(c->lock, "remote.disconnect"); /* shared connection */
				mapi_destroy(c->mconn);
				mal_unset_lock(c->lock, "remote.disconnect");
				GDKfree(c->name);
				GDKfree(c);
			}

			mal_unset_lock(mal_remoteLock, "remote.disconnect");
			return(MAL_SUCCEED);
		}
		c = c->next;
	}

	mal_unset_lock(mal_remoteLock, "remote.disconnect");
	throw(MAL, "remote.disconnect", "no such connection with name '%s'", *conn);
}


/**
 * Helper function to return a connection matching a given string, or an
 * error if it does not exist.  Before the connection is returned, it is
 * made sure that it is usable.  If the connection cannot be made
 * useable, an error is returned.  Since this function is internal, it
 * doesn't check the argument conn, as it should have been checked
 * already.
 */
static INLINE str
RMTfindconn(connection *ret, str conn) {
	connection c;

	/* just make sure the return isn't garbage */
	*ret = NULL;
	mal_set_lock(mal_remoteLock, "remote.<findconn>"); /* global connections */
	c = connections;
	while (c != NULL) {
		if (strcmp(c->name, conn) == 0) {
			/* ok found, ensure it is connected */
			mal_set_lock(c->lock, "remote.<findconn>"); /* shared connection */
			if (mapi_ping(c->mconn) != MOK && mapi_reconnect(c->mconn) != MOK) {
				mal_unset_lock(c->lock, "remote.<findconn>");
				mal_unset_lock(mal_remoteLock, "remote.<findconn>"); 
				throw(IO, "remote.<findconn>", "an error occurred during "
						"connect of '%s': %s",
						conn, mapi_error_str(c->mconn));
				/* TODO: throw away connection? */
			}
			*ret = c;
			mal_unset_lock(c->lock, "remote.<findconn>");
			mal_unset_lock(mal_remoteLock, "remote.<findconn>"); 
			return(MAL_SUCCEED);
		}
		c = c->next;
	}
	mal_unset_lock(mal_remoteLock, "remote.<findconn>"); 
	/* don't print conn, it contains the password */
	throw(MAL, "remote.<findconn>", "no such connection '%s'", conn);
}

@h
remote_export str RMTfindConnection(connection *ret, str conn);
@c
/**
 * Small wrapper around RMTfindconn just for the Octopus optimiser.
 * Martin likes to break open protection schemes just to get things to
 * work.  I doubt whether it is a good approach, but at least this way I
 * protect my own code.
 */
remote_export str RMTfindConnection(connection *ret, str conn)
{
	if (conn == NULL || strcmp(conn, (str)str_nil) == 0)
		throw(ILLARG, "remote.<findconnection>",
				"connection name is NULL or nil");

	return(RMTfindconn(ret, conn));
}

/**
 * Little helper function that returns a GDKmalloced string containing a
 * valid identifier that is supposed to be unique in the connection's
 * remote context.  Since this function is internal, it doesn't check
 * the argument conn, as it should have been checked already.
 */
static INLINE str
RMTgetNextId(str *ret, connection conn) {
	char buf[BUFSIZ];

	snprintf(buf, BUFSIZ, "rmt_%s_" SZFMT, conn->name, conn->nextid++);

	*ret = GDKstrdup(buf);
	return(MAL_SUCCEED);
}

/**
 * Helper function to execute a query over the given connection,
 * returning the result handle.  If communication fails in one way or
 * another, an error is returned.  Since this function is internal, it
 * doesn't check the input arguments func, conn and query, as they
 * should have been checked already.
 */
static INLINE str
RMTquery(MapiHdl *ret, str func, Mapi conn, str query) {
	MapiHdl mhdl;

	*ret = NULL;
	mhdl = mapi_query(conn, query);
	if (mhdl) {
		if (mapi_result_error(mhdl) != NULL) {
			str err = createException(
					getExceptionType(mapi_result_error(mhdl)),
					func,
					"%s", getExceptionMessage(mapi_result_error(mhdl)));
			mapi_close_handle(mhdl);
			return(err);
		}
	} else {
		if (mapi_error(conn) != MOK) {
			throw(IO, func, "an error occurred on connection: %s",
					mapi_error_str(conn));
		} else {
			throw(MAL, func, "remote function invocation didn't return a result");
		}
	}

	*ret = mhdl;
	return(MAL_SUCCEED);
}

str RMTprelude(int *ret) {
	(void)ret;

	return(MAL_SUCCEED);
}

str RMTepilogue(int *ret) {
	connection c, t;

	(void)ret;

	mal_set_lock(mal_remoteLock,"remote.epilogue"); /* nobody allowed here */
	/* free connections list */
	c = connections;
	while (c != NULL) {
		t = c;
		c = c->next;
		mal_set_lock(c->lock,"remote.epilogue");
		mapi_destroy(t->mconn);
		mal_unset_lock(c->lock,"remote.epilogue");
		GDKfree(t);
	}
	/* not sure, but better be safe than sorry */
	MCgetClient()->conn = NULL;
	mal_unset_lock(mal_remoteLock,"remote.epilogue"); 

	return(MAL_SUCCEED);
}

@h
remote_export str RMTget(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
@c
/**
 * get fetches the object referenced by ident over connection conn.
 */
str RMTget(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci) {
	str conn, ident, tmp;
	connection c;
	char qbuf[BUFSIZ+1];
	MapiHdl mhdl;
	int rtype;
	ValPtr v;

	(void)cntxt;
	(void)mb;

	conn = (str)getArgValue(stk, pci, 1);
	if (conn == NULL || strcmp(conn, (str)str_nil) == 0)
		throw(ILLARG, "remote.get", "connection name is NULL or nil");
	ident = (str)getArgValue(stk, pci, 2);
	if (isIdentifier(ident) < 0)
		throw(ILLARG, "remote.get", "identifier expected, got '%s'", ident);

	/* lookup conn, set mconn if valid */
	rethrow("remote.get", tmp, RMTfindconn(&c, conn));

	rtype = getArgType(mb, pci, 0);
	v = getArgReference(stk, pci, 0);

	if (rtype == TYPE_any || isAnyExpression(rtype)) {
		throw(MAL, "remote.get", "cannot deal with any (%s) type",
				getTypeName(rtype));
	}

	if (isaBatType(rtype)) {
		int h, t, s;
		ptr l, r;
		lng len;
		str val, var;
		BAT *b;

		snprintf(qbuf, BUFSIZ, "user.remote_internal_servegetbat(\"%s\", %s);",
				getTypeName(rtype), ident);
#ifdef _DEBUG_REMOTE
		stream_printf(ctxt->fdout,"#remote.get:%s\n",qbuf);
#endif
		/* this call should be a single transaction over the channel*/
		mal_set_lock(c->lock,"remote.get"); 

		if( (tmp = RMTquery(&mhdl, "remote.get", c->mconn, qbuf))!= MAL_SUCCEED ){
			mal_unset_lock(c->lock,"remote.get"); 
			throw(MAL,"remote.get",tmp);
		}
		mapi_fetch_row(mhdl); /* should succeed */
		val = mapi_fetch_field(mhdl, 0);
		if (val == NULL) {
			mapi_close_handle(mhdl);
			mal_unset_lock(c->lock,"remote.get"); 
			throw(MAL, "remote.get", "missing first column in tuple");
		}
		len = atol(val);

#if SIZEOF_SIZE_T == 4
		if ((lng)(len & 0x80000000FFFFFFFF) != len){
			mal_unset_lock(c->lock,"remote.get"); 
			throw(MAL, "remote.get", "remote BAT is too big for this "
					"32-bits (configured) system");
		}
#endif
		/* FIXME: len < 0 ???? */

		assert(0 <= len && len <= (lng) BUN_MAX);
		h = getHeadType(rtype);
		t = getTailType(rtype);
		b = BATnew(h, t, (BUN)len);

		while (len-- > 0) {
			if (mapi_fetch_row(mhdl) == 0) {
				mapi_close_handle(mhdl);
				mal_unset_lock(c->lock,"remote.get"); 
				throw(MAL, "remote.get", "expected %d more rows in result", len + 1);
			}
			val = mapi_fetch_field(mhdl, 0); /* should both be there */
			var = mapi_fetch_field(mhdl, 1);
			if (ATOMvarsized(h)) {
				l = (ptr)(val == NULL ? str_nil : val);
			} else {
				s = 0;
				l = NULL;
				if (val == NULL)
					val = "nil";
				ATOMfromstr(h, &l, &s, val);
			}
			if (ATOMvarsized(t)) {
				r = (ptr)(var == NULL ? str_nil : var);
			} else {
				s = 0;
				r = NULL;
				if (var == NULL)
					var = "nil";
				ATOMfromstr(t, &r, &s, var);
			}

			BUNins(b, l, r, FALSE);

			if (!ATOMvarsized(h)) GDKfree(l);
			if (!ATOMvarsized(t)) GDKfree(r);
		}

		v->val.ival = b->batCacheid;
		BBPkeepref(b->batCacheid);
	} else {
		ptr p = NULL;
		str val;
		int len = 0;

		snprintf(qbuf, BUFSIZ, "user.remote_internal_serveget(\"%s\", %s);",
				getTypeName(rtype), ident);
		if ( (tmp=RMTquery(&mhdl, "remote.get", c->mconn, qbuf)) != MAL_SUCCEED ){
				mal_unset_lock(c->lock,"remote.get"); 
				return tmp;
		}
		mapi_fetch_row(mhdl); /* should succeed */
		val = mapi_fetch_field(mhdl, 0);

		if (ATOMvarsized(rtype)) {
			VALset(v, rtype, GDKstrdup(val == NULL ? str_nil : val));
		} else {
			ATOMfromstr(rtype, &p, &len, val == NULL ? "nil" : val);
			if (p != NULL) {
				VALset(v, rtype, p);
				if (ATOMextern(rtype) == 0)
					GDKfree(p);
			} else {
				char tval[BUFSIZ+1];
				snprintf(tval, BUFSIZ, "%s", val);
				tval[BUFSIZ] = '\0';
				mapi_close_handle(mhdl);
				mal_unset_lock(c->lock,"remote.get"); 
				throw(MAL, "remote.get", "unable to parse value '%s'", tval);
			}
		}
	}

	mapi_close_handle(mhdl);
	mal_unset_lock(c->lock,"remote.get"); 

	return(MAL_SUCCEED);
}

@h
remote_export str RMTput(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
@c
/**
 * stores the given object on the remote host.  The identifier of the
 * object on the remote host is returned for later use.
 */
str RMTput(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci) {
	str conn, tmp;
	str ident;
	connection c;
	ValPtr v;
	int type;
	ptr value;
	MapiHdl mhdl = NULL;

	(void)cntxt;

	conn = (str)getArgValue(stk, pci, 1);
	if (conn == NULL || strcmp(conn, (str)str_nil) == 0)
		throw(ILLARG, "remote.put", "connection name is NULL or nil");

	/* lookup conn */
	rethrow("remote.put", tmp, RMTfindconn(&c, conn));

	/* put the thing */
	type = getArgType(mb, pci, 2);
	value = getArgReference(stk, pci, 2);

	/* this call should be a single transaction over the channel*/
	mal_set_lock(c->lock, "remote.put"); 

	/* get a free identifier for the remote host */
	RMTgetNextId(&tmp, c);
	/* allocate on the stack as not to leak when we error lateron */
	ident = alloca(sizeof(char) * (strlen(tmp) + 1));
	memcpy(ident, tmp, strlen(tmp) + 1);
	GDKfree(tmp); /* FIXME, this is inefficient... */

	/* depending on the input object generate actions to store the
	 * object remotely*/
	if (type == TYPE_any || isAnyExpression(type)) {
		mal_unset_lock(c->lock, "remote.put"); 
		throw(MAL, "remote.put", "cannot deal with '%s' type",
				getTypeName(type));
	} else if (isaBatType(type)) {
		BATiter bi;
		/* naive approach using bat.new() and bat.insert() calls */
		char head[10], tail[10];
		char qbuf[BUFSIZ+1]; /* FIXME: this should be dynamic */
		int bid;
		BAT *b;
		BUN p, q;
		str headv, tailv;

		if (getHeadIndex(type) > 0) {
			sprintf(head, "any%c%d", TMPMARKER, getHeadIndex(type));
		} else if (getHeadType(type) == TYPE_any) {
			sprintf(head, "any");
		} else {
			sprintf(head, "%s", ATOMname(getHeadType(type)));
		}
		if (getTailIndex(type) > 0) {
			sprintf(tail, "any%c%d", TMPMARKER, getTailIndex(type));
		} else if (getTailType(type) == TYPE_any) {
			sprintf(tail, "any");
		} else {
			sprintf(tail, "%s", ATOMname(getTailType(type)));
		}

		bid = *(int *)value;
		if ((b = BATdescriptor(bid)) == NULL){
			mal_unset_lock(c->lock, "remote.put"); 
			throw(MAL, "remote.put", "cannot access BAT descriptor");
		}

		qbuf[BUFSIZ] = '\0';
		snprintf(qbuf, BUFSIZ, "%s := bat.new(:%s, :%s, " BUNFMT ");",
				ident, head, tail, BATcount(b));
#ifdef _DEBUG_REMOTE
		stream_printf(ctxt->fdout,"#remote.put:%s\n",qbuf);
#endif
		if ((tmp = RMTquery(&mhdl, "remote.put", c->mconn, qbuf)) != MAL_SUCCEED) {
			mal_unset_lock(c->lock, "remote.put");
			return tmp;
		}
		mapi_close_handle(mhdl);

		headv = tailv = NULL;
		bi = bat_iterator(b);
		BATloop(b, p, q) {
			ATOMformat(getHeadType(type), BUNhead(bi, p), &headv);
			ATOMformat(getTailType(type), BUNtail(bi, p), &tailv);
			snprintf(qbuf, BUFSIZ, "bat.insert(%s, %s:%s, %s:%s);",
					ident, headv, head, tailv, tail);
#ifdef _DEBUG_REMOTE
		stream_printf(ctxt->fdout,"#remote.put:%s\n",qbuf);
#endif
			if ((tmp = RMTquery(&mhdl, "remote.put", c->mconn, qbuf)) != MAL_SUCCEED) {
				mal_unset_lock(c->lock, "remote.put"); 
				return tmp;
			}
			/* we leak headv and tailv here if an exception is thrown */
			mapi_close_handle(mhdl);
		}
		GDKfree(headv);
		GDKfree(tailv);
		BBPunfix(b->batCacheid);
	} else {
		str val = NULL;
		char qbuf[BUFSIZ+1]; /* FIXME: this should be dynamic */
		if (ATOMvarsized(type)) {
			ATOMformat(type, *(str *)value, &val);
		} else {
			ATOMformat(type, value, &val);
		}
		snprintf(qbuf, BUFSIZ, "%s := %s:%s;\n", ident, val, ATOMname(type));
		qbuf[BUFSIZ] = '\0';
		GDKfree(val);
#ifdef _DEBUG_REMOTE
		stream_printf(ctxt->fdout,"#remote.put:%s\n",qbuf);
#endif
		if ((tmp = RMTquery(&mhdl, "remote.put", c->mconn, qbuf)) != MAL_SUCCEED) {
			mal_unset_lock(c->lock,"remote.put"); 
			return tmp;
		}
		mapi_close_handle(mhdl);
	}
	mal_unset_lock(c->lock, "remote.put"); 

	/* return the identifier */
	v = getArgReference(stk,pci,0);
	v->vtype = TYPE_str;
	v->val.sval = GDKstrdup(ident);
	return(MAL_SUCCEED);
}

@h
remote_export str RMTregisterInternal(Client cntxt, str conn, str mod, str fcn);
@c
/**
 * stores the given <mod>.<fcn> on the remote host.  
 * An error is returned if the function is already known at the remote site.
 * The implementation is based on serialisation of the block into a string
 * followed by remote parsing.
 */
str RMTregisterInternal(Client cntxt, str conn, str mod, str fcn)
{
	str tmp, qry, msg;
	connection c;
	char buf[BUFSIZ];
	MapiHdl mhdl = NULL;
	Symbol sym;

	if (conn == NULL || strcmp(conn, (str)str_nil) == 0)
		throw(ILLARG, "remote.register", "Connection name is NULL or nil");

	/* find local definition */
	sym= findSymbol(getName(mod,strlen(mod)),getName(fcn,strlen(fcn)));
	if ( sym == NULL)
		throw(MAL,"remote.register","Function not found");

	/* lookup conn */
	rethrow("remote.put", tmp, RMTfindconn(&c, conn));

	/* this call should be a single transaction over the channel*/
	mal_set_lock(c->lock,"remote.register"); 

	/* check remote definition */
	snprintf(buf,BUFSIZ,"inspect.getSignature(\"%s\",\"%s\");",mod,fcn);
	msg = RMTquery(&mhdl,"remote.register",c->mconn, buf);
	if ( msg == MAL_SUCCEED){
		mal_unset_lock(c->lock,"remote.register"); 
		throw(MAL,"remote.register","Function already defined remotely");
	}
	if ( mhdl)
		mapi_close_handle(mhdl);

	qry= function2str(sym->def, LIST_MAL_STMT);
#ifdef _DEBUG_REMOTE
	stream_printf(cntxt->fdout,"remote.register:%s\n",qry);
#else
	(void) cntxt;
#endif
	msg = RMTquery(&mhdl,"remote.register",c->mconn,qry);
	if (mhdl)
		mapi_close_handle(mhdl);

	mal_unset_lock(c->lock,"remote.register"); 
	return msg;
}

@h
remote_export str RMTregister(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
@c
str RMTregister(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci) {
	str conn = (str)getArgValue(stk, pci, 1);
	str mod = (str)getArgValue(stk, pci, 2);
	str fcn = (str)getArgValue(stk, pci, 3);
	(void)mb;
	return RMTregisterInternal(cntxt, conn, mod, fcn);
}

@h
remote_export str RMTexec(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
@c
/**
 * exec executes the function with its given arguments on the remote
 * host, returning the function's return value.  exec is purposely kept
 * very spartan.  All arguments need to handles to previously put()
 * values.  It calls the function with the given arguments at the remote
 * site, and returns the handle which stores the return value of the
 * remotely executed function.  This return value can be retrieved using
 * a get call. It does not (yet) handle multiple return arguments.
 */
str RMTexec(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci) {
	str conn, mod, func, ident, tmp;
	int i, len;
	connection c= NULL;
	char qbuf[BUFSIZ+1];	/* FIXME: make this dynamic */
	MapiHdl mhdl;

	(void)cntxt;
	(void)mb;

	conn = (str)getArgValue(stk, pci, 1);
	if (conn == NULL || strcmp(conn, (str)str_nil) == 0)
		throw(ILLARG, "remote.exec", "connection name is NULL or nil");
	mod = (str)getArgValue(stk, pci, 2);
	if (mod == NULL || strcmp(mod, (str)str_nil) == 0)
		throw(ILLARG, "remote.exec", "module name is NULL or nil");
	func = (str)getArgValue(stk, pci, 3);
	if (func == NULL || strcmp(func, (str)str_nil) == 0)
		throw(ILLARG, "remote.exec", "function name is NULL or nil");

	/* lookup conn */
	rethrow("remote.exec", tmp, RMTfindconn(&c, conn));

	/* this call should be a single transaction over the channel*/
	mal_set_lock(c->lock,"remote.exec"); 

	/* get a free identifier on the remote host for each return argument expected */
	RMTgetNextId(&tmp, c);
	i = (int)strlen(tmp) + 1;
	ident = alloca(sizeof(char) * i);
	memcpy(ident, tmp, i);
	GDKfree(tmp);

	/* build the function invocation string in qbuf */
	len = 0;
	len += snprintf(&qbuf[len], BUFSIZ - len, "%s := %s.%s(", ident, mod, func);

	/* handle the arguments to the function */
	assert(pci->argc >= 3); /* ret, conn, func, ... */

	/* put the arguments one by one, and dynamically build the
	 * invocation string */
	for (i = 4; i < pci->argc; i++) {
		/* all arguments are of type rmtobj, at least we blindly trust
		 * the parser that it makes sure, we can cast to a string
		 * pointer as long as rmtobj is nothing more than that */
		len += snprintf(&qbuf[len], BUFSIZ - len, "%s%s",
				(i > 4 ? ", " : ""),
				*((str *)getArgReference(stk, pci, i)));
	}

	/* finish end execute the invocation string */
	len += snprintf(&qbuf[len], BUFSIZ - len, ");");
#ifdef _DEBUG_REMOTE
		stream_printf(ctxt->fdout,"#remote.exec:%s\n",qbuf);
#endif
	if( (tmp = RMTquery(&mhdl, "remote.exec", c->mconn, qbuf)) != MAL_SUCCEED ){
		mal_unset_lock(c->lock,"remote.exec"); 
		return tmp;
	}
	mapi_close_handle(mhdl);  /* we don't care at all about what it outputs */

	/* return the rident */
	VALset(getArgReference(stk,pci,0),
			stk->stk[getArg(pci, 0)].vtype, GDKstrdup(ident));
	mal_unset_lock(c->lock,"remote.exec"); 
	return(MAL_SUCCEED);
}
@h /* _REMOTE_DEF */
#endif
@}
