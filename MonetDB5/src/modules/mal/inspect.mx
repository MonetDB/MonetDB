@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2007 CWI.
@' All Rights Reserved.

@f inspect
@a Martin Kersten
@v 1
@+ Inspection 
This module introduces a series of commands that provide access
to information stored within the interpreter data structures.
In all cases, the pseudo BAT operation is returned that
should be garbage collected after being used.

The main performance drain would be to use a pseudo BAT directly to
successively access it components. This can be avoided by first assigning
the pseudo BAT to a variable.

Inspection is organized for two purposes, for interactive use
and as a bases for reflective code. The latter needs BATs
to work with. The former merely dumps the result in a table
for the front-ends to consume.
@mal
module inspect;

command getDefinition(mod:str,fcn:str) :bat[:str,:str] 
address INSPECTgetDefinition
comment "Returns a string representation of a specific function.";
command getSignature(mod:str,fcn:str) :bat[:str,:str] 
address INSPECTgetSignature
comment "Returns the function signature(s).";
command getAddress(mod:str,fcn:str) :bat[:str,:str] 
address INSPECTgetAddress
comment "Returns the function signature(s).";
command getComment(mod:str,fcn:str) :bat[:str,:str]
address INSPECTgetComment
comment "Returns the function help information.";
command getSource(mod:str,fcn:str):str
address INSPECTgetSource
comment "Return the original input for a function.";

command getKind():bat[:oid,:str]
address INSPECTgetkind
comment "Obtain the instruction kind.";
command getModule():bat[:oid,:str]
address INSPECTgetAllModules
comment "Obtain the function name.";
command getFunction():bat[:oid,:str]
address INSPECTgetAllFunctions
comment "Obtain the function name.";
command getSignatures():bat[:oid,:str]
address INSPECTgetAllSignatures
comment "Obtain the function signatures.";
command getAddresses():bat[:oid,:str]
address INSPECTgetAllAddresses
comment "Obtain the function address.";


pattern getSize():lng
address INSPECTgetSize
comment "Return the storage size for the current function (in bytes).";
command getSize(mod:str):bat[:str,:lng]
address INSPECTgetModuleSize
comment "Return the storage size for a module (in bytes).";
command getSize(mod:str,fcn:str):lng
address INSPECTgetFunctionSize
comment "Return the storage size for a function (in bytes).";

pattern getType(v:bat[:any_1,:any_2]) (ht:str, tt:str)
address INSPECTtypeName
comment "Return the internal type of a variable (expression).";
pattern getType(v:any_1) :str 
address INSPECTtypeName
comment "Return the type of a variable (expression).";

command getTypeName(v:int):str 
address INSPECTtypename
comment "Get the type name associated with a type id.";
pattern getTypeIndex(v:any_1):int 
address INSPECTtypeIndex
comment "Return the type index of a variable.";


command getAtomNames():bat[:int,:str] 
address INSPECTatom_names
comment "Collect a BAT with the atom names.";
command getAtomSuper():bat[:int,:str] 
address INSPECTatom_sup_names
comment "Collect a BAT with the atom names.";
command getAtomSizes():bat[:int,:int] 
address INSPECTatom_sizes
comment "Collect a BAT with the atom sizes.";

command getEnvironment():bat[:str,:str]
address INSPECTgetEnvironment
comment "Collect the environment variables.";
@-
@{
@+ Implementation
@include prelude.mx
@h
#ifdef _INSPECT_H
#endif /* _INSPECT_H */
@c
#include "mal_config.h"
#include "gdk.h"
#include <stdarg.h>
#include <time.h>
#include "mal_resolve.h"
#include "mal_client.h"
#include "mal_exception.h"
#include "mal_debugger.h"
#include "mal_interpreter.h"
#include "mal_namespace.h"

#ifdef WIN32
#ifndef LIBINSPECT
#define inspect_export extern __declspec(dllimport)
#else
#define inspect_export extern __declspec(dllexport)
#endif
#else
#define inspect_export extern
#endif

inspect_export str INSPECTgetModuleIds(int *ret);
inspect_export str INSPECTsymbolFind(int *ret, int kind);
inspect_export str INSPECTfactoryNames(int *ret);
inspect_export str INSPECTgetFunctionIds(int *ret);
inspect_export str INSPECTpatternNames(int *ret);
inspect_export str INSPECTcommandNames(int *ret);
inspect_export str INSPECTgetFunction(int *ret);
inspect_export str INSPECTgetModule(int *ret);
inspect_export str INSPECTgetkind(int *ret);
inspect_export str INSPECTgetaddress(int *ret);
inspect_export str INSPECTgetAllSignatures(int *ret);
inspect_export str INSPECTgetAllModules(int *ret);
inspect_export str INSPECTgetAllFunctions(int *ret);
inspect_export str INSPECTgetAllAddresses(int *ret);
inspect_export str INSPECTgetDefinition(int *ret, str *nme, str *fcn);
inspect_export str INSPECTgetSignature(int *ret, str *mod, str *fcn);
inspect_export str INSPECTgetAddress(int *ret, str *mod, str *fcn);
inspect_export str INSPECTgetComment(int *ret, str *mod, str *fcn);
inspect_export str INSPECTgetSource(str *ret, str *mod, str *fcn);
inspect_export str INSPECTgetModuleSize(int *ret, str *mod);
inspect_export str INSPECTgetFunctionSize(lng *ret, str *mod, str *fcn);
inspect_export str INSPECTgetSize(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
inspect_export str INSPECTgetEnvironment(int *ret);
inspect_export str INSPECTsymbolType(int *ret, str *mod, str *fcn);
inspect_export str INSPECTatom_names(int *ret);
inspect_export str INSPECTatom_sup_names(int *ret);
inspect_export str INSPECTatom_sizes(int *ret);
inspect_export str INSPECTshowFunction(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
inspect_export str INSPECTshowFunction3(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
inspect_export str INSPECTtypename(str *ret, int *tpe);
inspect_export str INSPECTtype(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
inspect_export str INSPECTtypeName(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
inspect_export str INSPECTtypeIndex(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);

@+ Symbol table 
Mal symbol table and environment analysis.
@c

str
INSPECTgetModuleIds(int *ret)
{
	Client c;
	Module s;
	int i = 0;
	BAT *b = BATnew(TYPE_void, TYPE_str, 256);

	if (b == 0)
		throw(MAL, "inspect.getModuleIds", "failed to create BAT");
	c = MCgetClient();

	for (s = c->nspace; s; s = s->outer, i++)
		BUNins(b, (ptr) &int_nil, s->name, FALSE);

	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(view,scope,names)@

	return MAL_SUCCEED;
}

str
INSPECTsymbolFind(int *ret, int kind)
{
	Client c;
	Module s;
	Symbol t;
	int i;
	BAT *b = BATnew(TYPE_str, TYPE_str, 256);

	if (b == 0)
		throw(MAL, "inspect.symbolFind", "failed to create BAT");
	c = MCgetClient();
	s = c->nspace;
	while (s) {
		for (i = 0; s && i < MAXSCOPE; i++)
			if (s->subscope[i]) {
				for (t = s->subscope[i]; t; t = t->peer) {
					InstrPtr sig = getSignature(t);

					if (kind && kind != sig->token)
						continue;
					BUNins(b, getModuleId(sig), getFunctionId(sig), FALSE);
				}
			}
		s = s->outer;
	}
	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(view,symbol,name)@

	return MAL_SUCCEED;
}

str
INSPECTfactoryNames(int *ret)
{
	return INSPECTsymbolFind(ret, FACTORYsymbol);
}

str
INSPECTgetFunctionIds(int *ret)
{
	return INSPECTsymbolFind(ret, FUNCTIONsymbol);
}

str
INSPECTpatternNames(int *ret)
{
	return INSPECTsymbolFind(ret, PATTERNsymbol);
}

str
INSPECTcommandNames(int *ret)
{
	return INSPECTsymbolFind(ret, COMMANDsymbol);
}

@-
Collect symbol table information in a series of BATs for analysis
and display. Note, the elements are aligned using a counter,
which makes it susceptable for intermediate updates
@c

str
INSPECTgetAllFunctions(int *ret)
{
	Client c;
	Module s;
	Symbol t;
	int i;
	oid k = 0;
	BAT *b = BATnew(TYPE_oid, TYPE_str, 256);

	if (b == 0)
		throw(MAL, "inspect.getgetFunctionId", "failed to create BAT");
	BATseqbase(b, k);
	c = MCgetClient();
	s = c->nspace;
	while (s) {
		for (i = 0; s && i < MAXSCOPE; i++)
			if (s->subscope[i]) {
				for (t = s->subscope[i]; t; t = t->peer) {
					InstrPtr sig = getSignature(t);

					BUNins(b, &k, getFunctionId(sig), FALSE);
					k++;
				}
			}
		s = s->outer;
	}
	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(view,symbol,function)@

	return MAL_SUCCEED;
}

str
INSPECTgetAllModules(int *ret)
{
	Client c;
	Module s;
	Symbol t;
	int i;
	oid k = 0;
	BAT *b = BATnew(TYPE_oid, TYPE_str, 256);

	if (b == 0)
		throw(MAL, "inspect.getmodule", "failed to create BAT");
	BATseqbase(b, k);
	c = MCgetClient();
	s = c->nspace;
	while (s) {
		for (i = 0; s && i < MAXSCOPE; i++)
			if (s->subscope[i]) {
				for (t = s->subscope[i]; t; t = t->peer) {
					InstrPtr sig = getSignature(t);

					BUNins(b, &k, getModuleId(sig), FALSE);
					k++;
				}
			}
		s = s->outer;
	}
	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(view,symbol,module)@

	return MAL_SUCCEED;
}

str
INSPECTgetkind(int *ret)
{
	Client c;
	Module s;
	Symbol t;
	int i;
	oid k = 0;
	BAT *b = BATnew(TYPE_oid, TYPE_str, 256);

	if (b == 0)
		throw(MAL, "inspect.get@1", "failed to create BAT");
	BATseqbase(b, k);
	c = MCgetClient();
	s = c->nspace;
	while (s) {
		for (i = 0; s && i < MAXSCOPE; i++)
			if (s->subscope[i]) {
				for (t = s->subscope[i]; t; t = t->peer) {
					InstrPtr sig = getSignature(t);
					str kind = operatorName(sig->token);

					BUNins(b, &k, kind, FALSE);
					k++;
				}
			}
		s = s->outer;
	}
	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(view,symbol,kind)@

	return MAL_SUCCEED;
}

str
INSPECTgetaddress(int *ret)
{
	Client c;
	Module s;
	Symbol t;
	int i;
	oid k = 0;
	BAT *b = BATnew(TYPE_oid, TYPE_str, 256);

	if (b == 0)
		throw(MAL, "inspect.get@1", "failed to create BAT");
	BATseqbase(b, k);
	c = MCgetClient();
	s = c->nspace;
	while (s) {
		for (i = 0; s && i < MAXSCOPE; i++)
			if (s->subscope[i]) {
				for (t = s->subscope[i]; t; t = t->peer) {
					str kind = t->def->binding;

					if (kind == 0)
						kind = "";
					BUNins(b, &k, &kind, FALSE);
					k++;
				}
			}
		s = s->outer;
	}
	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(view,symbol, address)@

	return MAL_SUCCEED;
}


str
INSPECTgetAllSignatures(int *ret)
{
	Client c;
	Module s;
	Symbol t;
	int i;
	oid k = 0;
	BAT *b = BATnew(TYPE_oid, TYPE_str, 256);
	char sig[4096],*a;

	if (b == 0)
		throw(MAL, "inspect.get@1", "failed to create BAT");
	BATseqbase(b, k);
	c = MCgetClient();
	s = c->nspace;
	while (s) {
		for (i = 0; s && i < MAXSCOPE; i++)
			if (s->subscope[i]) {
				for (t = s->subscope[i]; t; t = t->peer) {
					fcnDefinition(t->def, getSignature(t), sig, 0);
					a= strstr(sig,"address");
					if(a) *a = 0;
					BUNins(b, &k, strchr(sig, '('), FALSE);
					k++;
				}
			}
		s = s->outer;
	}
	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(view, symbol,address)@

	return MAL_SUCCEED;
}
str
INSPECTgetAllAddresses(int *ret)
{
	Client c;
	Module s;
	Symbol t;
	int i;
	oid k = 0;
	BAT *b = BATnew(TYPE_oid, TYPE_str, 256);
	char sig[4096],*a;

	if (b == 0)
		throw(MAL, "inspect.get@1", "failed to create BAT");
	BATseqbase(b, k);
	c = MCgetClient();
	s = c->nspace;
	while (s) {
		for (i = 0; s && i < MAXSCOPE; i++)
			if (s->subscope[i]) {
				for (t = s->subscope[i]; t; t = t->peer) {
					fcnDefinition(t->def, getSignature(t), sig, 0);
					a= strstr(sig,"address");
					if( a)
						for( a=a+7; isspace((int) *a); a++)
							;
					BUNins(b, &k, (a? a: "nil"), FALSE);
					k++;
				}
			}
		s = s->outer;
	}
	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(view, symbol,address)@

	return MAL_SUCCEED;
}

str
INSPECTgetDefinition(int *ret, str *mod, str *fcn)
{
	Symbol s;
	char buf[BUFSIZ];
	BAT *b;

	s = findSymbol(getName(*mod,strlen(*mod)), putName(*fcn, strlen(*fcn)));
	if (s == 0)
		throw(MAL, "inspect.getDefinition", 
				"failed to find <module>.<function>");

	b = BATnew(TYPE_str, TYPE_str, 256);
	if (b == 0)
		throw(MAL, "inspect.getDefinition", "failed to create BAT");

	snprintf(buf,BUFSIZ,"%s.%s",*mod,*fcn);
	while (s) {
		int i;
		str ps;

		for (i = 0; i < s->def->stop; i++) {
			ps = instruction2str(s->def, getInstrPtr(s->def, i), 0);
			BUNins(b, buf, ps + 1, FALSE);
			GDKfree(ps);
		}
		s = s->peer;
	}
	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(view,fcn,stmt)@

	return MAL_SUCCEED;
}

str
INSPECTgetSignature(int *ret, str *mod, str *fcn)
{
	Symbol s;
	char buf[BUFSIZ];
	str ps, tail;
	BAT *b;

	s = findSymbol(getName(*mod,strlen(*mod)), putName(*fcn, strlen(*fcn)));
	if (s == 0)
		throw(MAL, "inspect.getSignature", 
				"failed to find <module>.<function>");
	b = BATnew(TYPE_str, TYPE_str, 12);
	if (b == 0)
		throw(MAL, "inspect.getSignature", "failed to create BAT");

	snprintf(buf,BUFSIZ,"%s.%s",*mod,*fcn);
	while (s != NULL) {
		if (idcmp(s->name, *fcn) == 0) {
			char *c, *w;

			ps = instruction2str(s->def, getSignature(s), 0);
			c = strchr(ps, '(');
			if (c == 0)
				continue;
			tail= strstr(c,"address");
			if( tail)
				*tail = 0;
			if (tail && (w=strchr(tail, ';')) )
				*w = 0;
			BUNins(b, buf, c, FALSE);
			GDKfree(ps);
		}
		s = s->peer;
	}

	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(view,input,result)@
	return MAL_SUCCEED;
}
str
INSPECTgetAddress(int *ret, str *mod, str *fcn)
{
	Symbol s;
	char buf[BUFSIZ];
	str ps, tail;
	BAT *b;

	s = findSymbol( getName(*mod,strlen(*mod)), putName(*fcn, strlen(*fcn)));
	if (s == 0)
		throw(MAL, "inspect.getAddress", "failed to find <module>.<function>");
	b = BATnew(TYPE_str, TYPE_str, 12);
	if (b == 0)
		throw(MAL, "inspect.getAddress", "failed to create BAT");

	snprintf(buf,BUFSIZ,"%s.%s",*mod,*fcn);
	while (s != NULL) {
		if (idcmp(s->name, *fcn) == 0) {
			char *c,*w;

			ps = instruction2str(s->def, getSignature(s), 0);
			c = strchr(ps, '(');
			if (c == 0)
				continue;
			tail= strstr(c,"address");
			if( tail){
				*tail = 0;
				for( tail=tail+7; isspace((int) *tail); tail++)  ;
			}
			if (tail && (w=strchr(tail, ';')) )
				*w = 0;
			BUNins(b, buf, (tail? tail: "nil"), FALSE);
			GDKfree(ps);
		}
		s = s->peer;
	}

	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(view,input,result)@
	return MAL_SUCCEED;
}
str
INSPECTgetComment(int *ret, str *mod, str *fcn)
{
	Symbol s;
	char buf[BUFSIZ];
	BAT *b;

	s = findSymbol( getName(*mod,strlen(*mod)), putName(*fcn, strlen(*fcn)));
	if (s == 0)
		throw(MAL, "inspect.getComment", "failed to find <module>.<function>");
	b = BATnew(TYPE_str, TYPE_str, 12);
	if (b == 0)
		throw(MAL, "inspect.getSignature", "failed to create BAT");

	snprintf(buf,BUFSIZ,"%s.%s",*mod,*fcn);
	while (s != NULL) {
		if (idcmp(s->name, *fcn) == 0) {
			BUNins(b, buf, s->def->help, FALSE);
		}
		s = s->peer;
	}

	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(view,input,result)@
	return MAL_SUCCEED;
}
str
INSPECTgetSource(str *ret, str *mod, str *fcn)
{
	Symbol s;
	char *buf;
	size_t len,lim;

	s = findSymbol( getName(*mod,strlen(*mod)), putName(*fcn, strlen(*fcn)));
	if (s == 0)
		throw(MAL, "inspect.getSource", 
			"Failed to find <module>.<function>");

	buf= (char*) GDKmalloc(BUFSIZ);
	snprintf(buf,BUFSIZ,"%s.%s",*mod,*fcn);
	buf[0]=0;
	len= 0;
	lim= BUFSIZ;

	while (s) {
		int i;
		str ps;

		for (i = 0; i < s->def->stop; i++) {
			ps = instruction2str(s->def, getInstrPtr(s->def, i), 0);
			if( strlen(ps) >= lim-len){
				/* expand the buffer */
				char *bn;
				bn= GDKmalloc(lim+BUFSIZ);
				strcpy(bn,buf);
				GDKfree(buf);
				buf=bn;
				lim+= BUFSIZ;
			}
			strcat(buf+len,ps+1);
			len+= strlen(ps)-1;
			buf[len++]='\n';
			buf[len]=0;
			GDKfree(ps);
		}
		s = s->peer;
	}
	*ret= buf;
	return MAL_SUCCEED;
}

str
INSPECTsymbolType(int *ret, str *mod, str *fcn)
{
	Symbol s;
	BAT *b;

	s = findSymbol( getName(*mod,strlen(*mod)), putName(*fcn, strlen(*fcn)));
	if (s == 0)
		throw(MAL, "inspect.getSignature", 
			"failed to find <module>.<function>");
	b = BATnew(TYPE_str, TYPE_str, 256);
	if (b == 0)
		throw(MAL, "inspect.getType", "failed to create BAT");
	while (s != NULL) {
		if (idcmp(s->name, *fcn) == 0) {
			str t = getTypeName(getDestType(s->def, getSignature(s)));

			BUNins(b, s->name, t, FALSE);
			GDKfree(t);
		}
		s = s->peer;
	}
	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(view,fcn,type)@
	return MAL_SUCCEED;
}

str
INSPECTatom_names(int *ret)
{
	int i;
	BAT *b = BATnew(TYPE_int, TYPE_str, 256);

	if (b == 0)
		throw(MAL, "inspect.getAtomNames", "failed to create BAT");

	for (i = 0; i < GDKatomcnt; i++)
		BUNins(b, &i, ATOMname(i), FALSE);

	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(view,atom,name)@

	return MAL_SUCCEED;
}
str
INSPECTgetEnvironment(int *ret)
{
	BAT *b;

	b= GDKenv;
	if (b == 0)
		throw(MAL, "inspect.getEnvironment", "failed to create BAT");

	BBPfix(*ret = b->batCacheid);
	return MAL_SUCCEED;
}

str
INSPECTatom_sup_names(int *ret)
{
	int i, k;
	BAT *b = BATnew(TYPE_int, TYPE_str, 256);

	if (b == 0)
		throw(MAL, "inspect.getAtomSuper", "failed to create BAT");

	for (i = 0; i < GDKatomcnt; i++) {
		for (k = BATatoms[i].storage; k > TYPE_str; k = BATatoms[k].storage)
			;
		BUNins(b, &i, ATOMname(k), FALSE);
	}

	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(view,atom,sup_name)@

	return MAL_SUCCEED;
}

str
INSPECTatom_sizes(int *ret)
{
	int i;
	size_t s;
	BAT *b = BATnew(TYPE_int, TYPE_int, 256);

	if (b == 0)
		throw(MAL, "inspect.getAtomSizes", "failed to create BAT");

	for (i = 0; i < GDKatomcnt; i++) {
		s = ATOMsize(i);
		BUNins(b, &i, &s, FALSE);
	}

	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(view,atom,size)@

	return MAL_SUCCEED;
}

/* calculate to trimmed storage space */
lng
INSPECTcalcSize(MalBlkPtr mb){
	lng size,args=0,i;
	InstrPtr p;

	for(i=0;i<mb->stop; i++){
		p= getInstrPtr(mb,i);
		args += (p->argc-1)* sizeof(*p->argv);
	}
	size = (sizeof(InstrRecord) +sizeof(InstrPtr)) * mb->stop;
	size += (sizeof(VarRecord)+ sizeof(InstrPtr)) * mb->vtop;
	size += args;
	return size;
}

str
INSPECTgetSize(MalBlkPtr mb, MalStkPtr stk, InstrPtr p){
	lng *ret = (lng*) getArgReference(stk,p,0);
	*ret= INSPECTcalcSize(mb);
	return MAL_SUCCEED;
}
str
INSPECTgetModuleSize(int *ret, str *mod)
{
	Symbol s;
	Module m;
	int i;
	lng total=0;
	BAT *b = BATnew(TYPE_str, TYPE_lng, 256);

	if (b == 0)
		throw(MAL, "inspect.getSize", "failed to create BAT");

	m = findModule(MCgetClient()->nspace, putName(*mod, strlen(*mod)));
	if (m == 0)
		throw(MAL, "inspect.getSize", 
				"failed to find <module>.<function>");

	for( i=0; i<MAXSCOPE; i++){
		s= m->subscope[i];
		while (s != NULL) {
			lng size;
			total+= (size = INSPECTcalcSize(s->def));
			BUNins(b, s->name, &size, FALSE);
			s = s->peer;
		}
	}
	BUNins(b, *mod, &total, FALSE);

	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(view,input,result)@
	return MAL_SUCCEED;
}
str
INSPECTgetFunctionSize(lng *ret, str *mod, str *fcn)
{
	Symbol s;

	s = findSymbol( getName(*mod,strlen(*mod)), putName(*fcn, strlen(*fcn)));
	if (s == 0)
		throw(MAL, "inspect.getSize", 
			"failed to find <module>.<function>");
	*ret= INSPECTcalcSize(s->def);
	return MAL_SUCCEED;
}
@+ Display routines
@c
str
INSPECTshowFunction(MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	Client c = MCgetClient();

	(void) p;
	(void) stk;
	printFunction(c->fdout, mb, LIST_INPUT);
	return MAL_SUCCEED;
}

str
INSPECTshowFunction3(MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	str modnme = getArgName(mb, p, 1);
	str fcnnme = getArgName(mb, p, 2);
	Symbol s = NULL;
	Client c = MCgetClient();


	s = findSymbol(getName(modnme,strlen(modnme)), putName(fcnnme, strlen(fcnnme)));

	if (s == NULL){
		char buf[BUFSIZ];
		snprintf(buf,BUFSIZ,"Could not find %s.%s\n", modnme, fcnnme);
		throw(MAL, "inspect.showSource",buf);
	} else
		printFunction(c->fdout, s->def, LIST_INPUT);
	(void) stk;		/* fool compiler */
	return MAL_SUCCEED;
}

str
INSPECTtypename(str *ret, int *tpe)
{
	*ret = getTypeName(*tpe);
	return MAL_SUCCEED;
}
str
INSPECTtypeIndex(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int *ret;
	ret = (int *) getArgReference(stk, pci, 0);
	*ret = getTailType(getArgType(mb, pci, 1));
	return MAL_SUCCEED;
}

str
INSPECTtypeName(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str *hn, *tn =0;

	hn = (str *) getArgReference(stk, pci, 0);
	if( pci->retc== 2){
		tn = (str *) getArgReference(stk, pci, 1);
		*hn = getTypeName(getHeadType(getArgType(mb, pci, 2)));
		*tn = getTypeName(getTailType(getArgType(mb, pci, 2)));
	} else
		*hn = getTypeName(getArgType(mb, pci, 1));
	return MAL_SUCCEED;
}


@}
