@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f crackers
@a Martin Kersten
@d October 2004
@* Cracker index

A cracker is a logically partitioned bat.  Its partitions are 
administered in a cracker index, a volatile data structure.
The partitions are mostly derived from ordered, tail values.
However, a derived fragmentation based on the (v)oid heads
is also used.

A table is explicitly cracked further, each time we issue a select.
It will scan the cracker index and will split all partitions
accordingly and retain their location. In this process we
re-shuffle BUNs around to produce dense range lists.
The cracker index can be used in subsequent scans to speed up the search.

This module contains the experimental code to play with cracked tables.
It supports int-based bats for the time being only.
The current implementation uses an unprotected cracker
index. This limits the interface at slightly more overhead
of searching the cracker index upon each call.

[todo] Cracking a BAT should be bounded by either the
number of pieces already obtained or the granularity
of a piece.

[todo] Coalescing pieces to create larger ones. Especially
relevant if you switch partitioning head and tail.

Initial performance indicates around 70 ms processing
overhead on a 1M bat during the first crack operation.
(Athlon 1400, 1Gb)
@mal
module crackers;

command new(b:bat[:int,:int]) 
address CRKnew
comment "Create the index tables for a cracked table.";
command new(b:bat[:int,:int], granule:int) 
address CRKnewGranule
comment "Create the index tables for a cracked
	table. Set the minimum granularity";

@-
For debugging we provide a simple routine to dump
the cracker index. Future versions should provide
a BAT-like access to this internal information.
@mal
command info(b:bat[:int,:int])
address CRKinfo
comment "Print the cracker index administration";

@-
The cracker comes in two variants. One to split the
table using an inclusive range over its tail, and a second to 
bi-partite two bats using a join over its tail
[TODO mirroring information should be kept around]
@mal
command crack(b:bat[:int,:int],low:int,hgh:int) :int
address CRKcrackRange
comment "Break the partitions into smaller pieces
	using a range over the tail";

command crack(b:bat[:int,:int],c:bat[:int,:int]) :int
address CRKcrackJoin
comment "Break the partitions into smaller pieces
	using a join over the tail";
@-
A cracker partition is indicated by the index in the cidx
table. It can be used to initialize a BATview to represent
the partition during processing.
@mal
command newIterator(b:bat[:int,:int])
	(a:lng,x:bat[:int,:int])
address CRKnewIterator
comment "Retrieve the first piece of a cracked
	BAT as a BAT view and also return the
	identity of the next piece.";

command hasMoreElements(b:bat[:int,:int])
	(a:lng,x:bat[:int,:int])
address CRKhasMoreElements
comment "Retrieve the next piece of a cracked
	BAT by adjusting the BAT view descriptor.
	It returns the next valid piece id.
	A value zero means 'end-of-sequence'";

command getPiece(b:bat[:int,:int], piece:int) :bat[:int,:int]
address CRKgetPiece0
comment "Retrieve a piece of a cracked BAT into a new BAT view.";

command getPiece(b:bat[:int,:int], crk:bat[:int,:int], piece:int)
address CRKgetPiece1
comment "Retrieve a piece of a cracked BAT into a known BAT view.";

command selectPieces( b:bat[:int,:int], low:int, hgh:int) :bat[:void,:int]
address CRKselectPieces
comment "Retrieve identities of all pieces that qualify the selection criterion.";
@-
The relational select is overloaded. It collects the pieces
into a single BAT. Preferably using a BATview, otherwise
the pieces are combined to form a new BAT.
@mal
command select(b:bat[:int,:int],l:int,h:int,li:bit,hi:bit):bat[:int,:int]
address CRKselect
comment "Retrieve the subset using a cracker
	index producing preferably a BATview.";
command drop(b:bat[:int,:int])
address CRKdropPiece
comment	"Garbage collect the piece representation";
command dropView(b:bat[:int,:int])
address CRKdropView
comment	"Garbage collect the piece representation.
	Should be a side-effect of dropping the bat!";
@{
@include prelude.mx
@* Implementation
The implementation is geared at early experimentation
without all the details to make the code robust and
ultra fast.

@-
The relationships between a table and its cracker index
is locally maintained. 
@h
#ifndef _CRACKERS_H_
#define _CRACKERS_H_

/* #define DEBUG_CRACKERS  */

#define LEAF 'L'
#define PHI  'P'		/* broken using a select */
#define DIAMOND  'D'		/* broken using a join */
#define OMEGA  'O'		/* broken using a group */

typedef struct {
	char kind;		/* kind of piece */
	int rng_max;		/* the value ranges */
	int rng_min;
	int idx_first;		/* the slice boundaries */
	int idx_last;
	int parent;		/* lineage */
	int left, middle, right;	/* tree branch directions */
} Piece;

typedef struct {
	int bid;		/* the original bat */
	int freepiece, maxpiece;
	Piece *pieces;
} CrackMap;

#endif /* _CRACKERS_H */
@-
During initialization of the crackers structure we already
shuffle the data around to have a first assessment of
the value ranges supported.

Note, this implementation does not protect the crackMap
administration. This is necessary in a concurrent version.
The granularity can be used to limit the number of pieces.
@c
#include "mal.h"
#include "mal_exception.h"
#include "crackers.h"

#define MAXPIECE 1024*100

static CrackMap *crackMap;
static int maxCrackMap = 0;
static int minGranule = 2;

int
findCrackMap(int bid)
{
	int i, freemap = -1, units = 1024;

	for (i = 0; i < maxCrackMap; i++)
		if (crackMap[i].bid == bid)
			return i;
		else if (crackMap[i].bid == -1)
			freemap = i;

	if (freemap != -1) {
		crackMap[freemap].bid = bid;
		return freemap;
	}

	if (i == maxCrackMap) {
		CrackMap *x;

		if (maxCrackMap > 0)
			units = (int) (1.2 * maxCrackMap);
		x = (CrackMap *) GDKmalloc(sizeof(CrackMap) * units);
		memset(x, 0, sizeof(CrackMap) * units);
		if (crackMap) {
			fprintf(stderr, "reallocate Crackmap\n");
			memcpy(x, crackMap, sizeof(CrackMap) * i);
			GDKfree(crackMap);
		}
		crackMap = x;
		maxCrackMap = units;
	}
	/* init the crackmap */
	crackMap[i].bid = bid;
	crackMap[i].pieces = GDKmalloc(sizeof(Piece) * MAXPIECE);
	memset((void *) crackMap[i].pieces, 0, sizeof(Piece) * MAXPIECE);
	crackMap[i].freepiece = 0;
	crackMap[i].maxpiece = MAXPIECE;
	return i;
}

void
freeCrackMap(int m)
{
	assert(m >= 0);
	/* re-initialize crackmap */
	crackMap[m].bid = -1;
	memset((void *) crackMap[m].pieces, 0, sizeof(Piece) * crackMap[m].maxpiece);
	crackMap[m].freepiece = 0;
}

void
printCrackMapElement(Piece * list, int i, int bid)
{
	stream_printf(GDKout, "[ %3d %3d, ", i, bid);
	stream_printf(GDKout, "%c, ", list[i].kind);
	stream_printf(GDKout, "%d ", list[i].parent);
	stream_printf(GDKout, "%d, ", list[i].rng_min);
	stream_printf(GDKout, "%d, ", list[i].rng_max);
	stream_printf(GDKout, "%d, ", list[i].idx_first);
	stream_printf(GDKout, "%d, ", list[i].idx_last);
	stream_printf(GDKout, "%d, ", list[i].left);
	stream_printf(GDKout, "%d, ", list[i].middle);
	stream_printf(GDKout, "%d ]\n ", list[i].right);
}

void
printCrackMap(int bid)
{
	int i, m;

	m = findCrackMap(bid);
	if (crackMap[m].freepiece)
		stream_printf(GDKout, "# idx bid kind parent rng_min rng_max idx_first idx_last left middle right# name\n");
	for (i = 0; i < crackMap[m].freepiece; i++)
		printCrackMapElement(crackMap[m].pieces, i, bid);
}

str
initCrackMap(CrackMap * map, int *bid)
{
	BAT *b;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("crackers.initCrackMap", "Cannot access descriptor");
	}
@-
The target BAT should not be modified by the applications,
otherwise the partitioning scheme becomes void
already. [todo]
@c

	map->pieces[0].rng_min = INT_MIN;
	map->pieces[0].rng_max = INT_MAX;
	map->pieces[0].idx_first = BUNindex(b, BUNfirst(b));
	map->pieces[0].idx_last = BUNindex(b, BUNlast(b)) - 1;
	map->pieces[0].kind = LEAF;
	map->pieces[0].parent = -1;
	map->pieces[0].left = -1;
	map->pieces[0].middle = -1;
	map->pieces[0].right = -1;
	map->freepiece = 1;
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

str
CRKnew(int *cret, int *bid)
{
	int m;

	(void) cret;
	m = findCrackMap(*bid);
	initCrackMap(crackMap + m, bid);
#ifdef DEBUG_CRACKERS
	stream_printf(GDKout, "crackMap created\n");
#endif
	return MAL_SUCCEED;
}

str
CRKnewGranule(int *cret, int *bid, int *gran)
{
	(void) minGranule;	/* fool compile on its use */
	minGranule = *gran;
	return CRKnew(cret, bid);
}

str
CRKinfo(int *k, int *bid)
{
	(void) k;
	printCrackMap(*bid);
	return MAL_SUCCEED;
}

@-
@= exchange
#ifdef DEBUG_CRACKERS_DETAIL
	printf("exchange %d %d\n",BUNindex(b,@1),BUNindex(b,@2));
#endif
{ /* be aware of reversed bats, which disallow memcpy
	memcpy(buf, @1, BUNsize(b));
	memcpy(@1, @2, BUNsize(b));
	memcpy(@2, buf, BUNsize(b));
*/
	int hdummy,tdummy;
	(void) buf;
	hdummy= *(int*) BUNhead(b,@1);
	tdummy= *(int*) BUNtail(b,@1);
	*(int*) BUNhead(b,@1) = *(int*) BUNhead(b,@2);
	*(int*) BUNtail(b,@1) = *(int*) BUNtail(b,@2);
	*(int*) BUNhead(b,@2)= hdummy;
	*(int*) BUNtail(b,@2)= tdummy;
}
@= exchange2
#ifdef DEBUG_CRACKERS_DETAIL
	printf("exchange %d %d %d\n",BUNindex(b,@1),
		BUNindex(b,@2),BUNindex(b,@3));
#endif
	memcpy(buf, @1, BUNsize(b));
	memcpy(@1, @3, BUNsize(b));
	memcpy(@3, @2, BUNsize(b));
	memcpy(@2, buf, BUNsize(b));

@- Cracking
The key operation for the cracker infrastructure is to process a scan
efficiently and re-shuffle the tuples in the BAT such that a simple
BATview can be used to denote the subrange of interest to upper layers.
Assume the range (low,hgh), both inclusive, is needed then all tuples
not qualifying this range should be moved out of the way by effectively
splitting the BAT into three segments.

Two strategies can be considered; a naive exchange shuffle and
pre-scan shuffle.
The naive exchange shuffle works as follows. We simple walk through the table
left to right and move all elements >=low to the right. 
A slightly improved version is to find groups of tuples to move around
as larger chunks.

The pre-scan shuffle reads the table twice. In the first phase we
calculate (for each partition) the number of elements in the range
(low,hgh). In the second phase we move the data into the designated place.
The advantage over the naive shuffle is potential less data writes.

First experiment is a simple partitioning on the tail value.
@= newPiece
	if(crackMap[@1].maxpiece == crackMap[@1].freepiece ){
		printf("too many pieces");
		exit(0);
	}
	@2 = crackMap[@1].pieces+ crackMap[@1].freepiece;
	@2->left= @2->middle= @2->right = -1;
	crackMap[@1].freepiece++;
@c
str
CRKcrackRange(int *partid, int *bid, int *low, int *hgh)
{
	BAT *b;
	Piece *piece, *npiece;
	int xx;
	ptr p;
	char buf[128];		/* scratch space */
	ptr vmax = 0, vmin = 0, vm;
	int lim, m, i, l, h, pid = -1;


	if (*(int *) low > *(int *) hgh)
		return throwMessage("crackers.crack", "illegal range");
	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("crackers.crackRange", "Cannot access descriptor");
	}
	m = findCrackMap(*bid);
@-
Inspect the value range table to only further crack qualifying fragments.
@c

	lim = crackMap[m].freepiece;
#ifdef DEBUG_CRACKERS
	printf("search range %d %d [lim=%d]\n", *(int *) low, *(int *) hgh, lim);
#endif
	for (i = 0; i < lim; i++) {
		if (crackMap[m].pieces[i].kind != LEAF)
			continue;
		if (*(int *) low <= crackMap[m].pieces[i].rng_min && *(int *) hgh >= crackMap[m].pieces[i].rng_max) {
			continue;
		}
		if (crackMap[m].pieces[i].rng_max < *(int *) low)
			continue;
		if (crackMap[m].pieces[i].rng_min > *(int *) hgh)
			continue;

		piece = crackMap[m].pieces + i;
		/* set bounds */
		xx = BUNsize(b);
		vmin = (ptr) ((char *) BUNptr(b, piece->idx_first) - xx);
		vmax = (ptr) ((char *) BUNptr(b, piece->idx_last) + xx);

		vm = BUNtail(b, (ptr) ((char *) vmin + xx));
		for (p = (ptr) ((char *) vmin + xx); p < vmax; p = (ptr) ((char *) p + xx), vm = (ptr) ((char *) vm + xx)) {
			if (*(int *) vm < *(int *) low) {
				/* exchange with first low */
				vmin = (ptr) ((char *) vmin + xx);
				if (vmin != p) {
					@:exchange(vmin, p)@
				}
			} else if (*(int *) vm > *(int *) hgh) {
				/* exchange with qualifying tail elm */
				vmax = (ptr) ((char *) vmax - xx);
				while (*(int *) BUNtail(b, vmax) > *(int *) hgh && vmax > p)
					vmax = (ptr) ((char *) vmax - xx);
				if (vmax != p) {
					@:exchange(vmax, p)@
					vm = (ptr) ((char *) vm - xx);
					p = (ptr) ((char *) p - xx);
@-
The chosen element could also be less then 'low' and an 
exchange operation could be saved. It turned out that
this optimization was not effective when a BUNtail
test was performed. A similar remark holds for having
an additional variable to keep track of the tail value.
@c

				}
			}
		}
@-
For each fragment discovered we have to break it into several pieces
and update the administration BATs. 
@c
		l = BUNindex(b, vmin) + 1;
		h = BUNindex(b, vmax) - 1;

		if (piece->idx_first == l) {
			if (h < piece->idx_last) {
#ifdef DEBUG_CRACKERS
				printf("left split [%d] %d-%d \n", i, l, h);
#endif
				piece->kind = PHI;
				piece->left = pid = crackMap[m].freepiece;
				@:newPiece(m, npiece)@
				npiece->rng_min = piece->rng_min;
				npiece->rng_max = *(int *) hgh;
				npiece->idx_first = piece->idx_first;
				npiece->idx_last = h;
				npiece->kind = LEAF;
				npiece->parent = i;

				piece->middle = -1;

				piece->right = crackMap[m].freepiece;
				@:newPiece(m, npiece)@
				npiece->rng_min = *(int *) hgh + 1;
				npiece->rng_max = piece->rng_max;
				npiece->idx_first = h + 1;
				npiece->idx_last = piece->idx_last;
				npiece->kind = LEAF;
				npiece->parent = i;
			}
		} else if (piece->idx_last == h) {
			if (l > piece->idx_first) {
#ifdef DEBUG_CRACKERS
				printf("right split [%d] %d-%d \n", i, l, h);
#endif
				/* falls at high end */
				piece->kind = PHI;
				piece->left = crackMap[m].freepiece;
				@:newPiece(m, npiece)@
				npiece->rng_min = piece->rng_min;
				npiece->rng_max = *(int *) low - 1;
				npiece->idx_first = piece->idx_first;
				npiece->idx_last = l - 1;
				npiece->kind = LEAF;
				npiece->parent = i;

				piece->middle = -1;

				piece->right = pid = crackMap[m].freepiece;
				@:newPiece(m, npiece)@
				npiece->rng_min = *(int *) low;
				npiece->rng_max = piece->rng_max;
				npiece->idx_first = l;
				npiece->idx_last = piece->idx_last;
				npiece->kind = LEAF;
				npiece->parent = i;
			}
		} else {
#ifdef DEBUG_CRACKERS
			printf("middle split [%d] %d-%d \n", i, l, h);
#endif
			piece->kind = PHI;
			piece->left = crackMap[m].freepiece;
			@:newPiece(m, npiece)@
			npiece->rng_min = piece->rng_min;
			npiece->rng_max = *(int *) low - 1;
			npiece->idx_first = piece->idx_first;
			npiece->idx_last = l - 1;
			npiece->kind = LEAF;
			npiece->parent = i;

			piece->middle = pid = crackMap[m].freepiece;
			@:newPiece(m, npiece)@
			npiece->rng_min = *(int *) low;
			npiece->rng_max = *(int *) hgh;
			npiece->idx_first = l;
			npiece->idx_last = h;
			npiece->kind = LEAF;
			npiece->parent = i;

			piece->right = crackMap[m].freepiece;
			@:newPiece(m, npiece)@
			npiece->rng_min = *(int *) hgh + 1;
			npiece->rng_max = piece->rng_max;
			npiece->idx_first = h + 1;
			npiece->idx_last = piece->idx_last;
			npiece->kind = LEAF;
			npiece->parent = i;
		}
	}
@-
If this was the first cracking operation it makes sense to administer
the ranges of the outer partitions as well.
@c
#ifdef DEBUG_CRACKERS
	printf("pid returned %d\n", pid);
#endif
	BBPunfix(b->batCacheid);
	*partid = pid;
	return MAL_SUCCEED;
}

str
CRKcrackJoin(int *partid, int *bid, int *cid)
{
	(void) bid;
	(void) cid;
	GDKerror("CRKcrackJoin:not yet implemented\n");
	*partid = 0;
	return MAL_SUCCEED;
}

@- 
The pieces of a cracked BAT are obtained through bat view.
The nextPiece simply changes the dimensions of the BATview
returned previously to represent a cracker piece.
@c
int
CRKsetBounds(BAT *b, BAT *view, int mid, int pid)
{
	int l, h;

	(void) view;		/* fool compiler */

	l = crackMap[mid].pieces[pid].idx_first;
	h = crackMap[mid].pieces[pid].idx_last;
#ifdef DEBUG_CRACKERS
	printf("set view to new dimension[%d,%d]: %d-%d\n", mid, pid, l, h);
#endif
	VIEWbounds(view, l, h);
	if (pid > 0 && (size_t) pid == BATcount(b))
		return 0;
	return pid + 1;
}

str
CRKnewIterator(lng *newpid, int *vid, int *bid)
{
	BAT *b, *view;
	int m, i;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("crackers.newIterator", "Cannot access descriptor");
	}
	m = findCrackMap(*bid);

	b->batRestricted = BAT_READ;
	view = VIEWcreate_(b, TRUE);

	*newpid = -1;
	for (i = 0; i < crackMap[m].freepiece; i++)
		if (crackMap[m].pieces[i].kind == LEAF) {
			*newpid = CRKsetBounds(b, view, m, i);
			break;
		}
	BBPunfix(b->batCacheid);
	BBPincref(*vid = view->batCacheid, TRUE);
	return MAL_SUCCEED;
}

str
CRKhasMoreElements(lng *pid, int *vbid, int *bid)
{
	BAT *b, *vid;
	int m, i;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("crackers.hasMoreElements", "Cannot access descriptor");
	}
	if ((vid = BATdescriptor(*vbid)) == NULL) {
		BBPunfix(b->batCacheid);
		return throwMessage("crackers.hasMoreElements", "Cannot access descriptor");
	}
	m = findCrackMap(*bid);

	/* test validity of pid  [todo] */
	if (*pid > crackMap[m].freepiece) {
		*pid = -1;
		BBPunfix(b->batCacheid);
		BBPunfix(vid->batCacheid);
		return MAL_SUCCEED;
	}
	if (*pid <= 0) {
		return throwMessage("crackers.hasMoreElements", "illegal piece");
	}

	for (i = (int) *pid; i < crackMap[m].freepiece; i++)
		if (crackMap[m].pieces[i].kind == LEAF) {
			*pid = CRKsetBounds(b, vid, m, i);
			BBPunfix(b->batCacheid);
			BBPunfix(vid->batCacheid);
			return MAL_SUCCEED;
		}
	*pid = -1;
	BBPunfix(b->batCacheid);
	BBPunfix(vid->batCacheid);
	return MAL_SUCCEED;
}

@-
Selectively retrieve the pieces from the jigsaw.
@c
str
CRKgetPiece0(int *vbid, int *bid, int *piece)
{
	BAT *b, *vid;
	int m;
	lng result = 0;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("crackers.getPiece", "Cannot access descriptor");
	}
	CRKnewIterator(&result, vbid, bid);
	m = (int) result;
	if ((vid = BATdescriptor(m)) == NULL) {
		BBPunfix(b->batCacheid);
		return throwMessage("crackers.getPiece", "Cannot access descriptor");
	}
	m = findCrackMap(*vbid);
	CRKsetBounds(b, vid, m, *piece);
	BBPunfix(b->batCacheid);
	BBPunfix(vid->batCacheid);
	return MAL_SUCCEED;
}

str
CRKgetPiece1(int *newpid, int *bid, int *vbid, int *piece)
{
	int m;
	BAT *b, *vid;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("crackers.getPiece", "Cannot access descriptor");
	}
	if ((vid = BATdescriptor(*vbid)) == NULL) {
		BBPunfix(b->batCacheid);
		return throwMessage("crackers.getPiece", "Cannot access descriptor");
	}
	m = findCrackMap(*bid);
	/* test validity of piece */
	CRKsetBounds(b, vid, m, *piece);
	BBPunfix(b->batCacheid);
	BBPunfix(vid->batCacheid);
	*newpid = 0;
	return MAL_SUCCEED;
}

@-
The combined pieces can be retrieved as an ordinary
overloaded select.  The cracker administration is
organized as an interval tree. The left and right
branch are always set. The middle may be empty.
@c
int
intervalFind(int m, int p, int *val)
{
	int x = -1;

/* printf("search %d in %d[%d,%d]\n",
	*val,p,crackMap[m].pieces[p].rng_min ,crackMap[m].pieces[p].rng_max); */
	if (crackMap[m].pieces[p].left > 0) {
		x = intervalFind(m, crackMap[m].pieces[p].left, val);
	}
	if (x == -1 && crackMap[m].pieces[p].middle > 0) {
		x = intervalFind(m, crackMap[m].pieces[p].middle, val);
	}
	if (x == -1 && crackMap[m].pieces[p].right > 0) {
		x = intervalFind(m, crackMap[m].pieces[p].right, val);
	}
	if (x == -1 && *val >= crackMap[m].pieces[p].rng_min && *val <= crackMap[m].pieces[p].rng_max)
		return p;
	return x;
}

void
intervalSelect(int m, int p, int *low, int *high, int *first, int *last)
{
	if (crackMap[m].pieces[p].rng_min > *low)
		*first = p;
	else
		*first = intervalFind(m, p, low);
/* printf("left found %d\n",*first);*/
	if (crackMap[m].pieces[p].rng_max < *high)
		*last = p;
	else
		*last = intervalFind(m, p, high);
/* printf("right found %d\n",*last);*/
}

@-
The algorithm collects the elements by repeatedly
inspecting the cracker table to extend the scope.
It keeps a count of number of leftover pieces.
If it can not glue the pieces together it should
create a BAT and insert all the left over elements;

The cracking strategy ensures that you don;t have to pick
the left/right pieces. Any piece that qualifies the search
would be sufficient. This works because we know that
the reshuffling of a range always takes place within the
space of its origin.
@c
str
CRKselectNew(int *vid, int *bid, int *low, int *high, bit *li, bit *hi)
{
	BAT *b, *view;
	int m;
	int left, right;

	(void) li;
	(void) hi;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("crackers.selectPiece", "Cannot access descriptor");
	}
	m = findCrackMap(*bid);

	b->batRestricted = BAT_READ;
	view = VIEWcreate_(b, TRUE);
	*vid = view->batCacheid;
	intervalSelect(m, 0, low, high, &left, &right);
	/* printf("get range from %d %d\n",left,right); */
	if (left >= 0 && right >= 0)
		VIEWbounds(view, crackMap[m].pieces[left].idx_first, crackMap[m].pieces[right].idx_last);
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

str
CRKselect(int *vid, int *bid, int *low, int *high, bit *li, bit *hi)
{
	BAT *b, *view;
	int m, i;
	int leftover, glued;
	int idxlow = -1, idxhgh = -1;

	(void) li;
	(void) hi;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("crackers.selectPiece", "Cannot access descriptor");
	}
	m = findCrackMap(*bid);

	b->batRestricted = BAT_READ;
	view = VIEWcreate_(b, TRUE);
	*vid = view->batCacheid;

@-
Select an interval with a desirable value to start the gluing process
@c
	for (i = 0; i < crackMap[m].freepiece; i++)
		if (crackMap[m].pieces[i].kind == LEAF &&	/* NOT NEEDED */
		    ((crackMap[m].pieces[i].rng_min <= *(int *) low && *(int *) low <= crackMap[m].pieces[i].rng_max) || (crackMap[m].pieces[i].rng_min <= *(int *) high && *(int *) high <= crackMap[m].pieces[i].rng_max)
		    )) {
			CRKsetBounds(b, view, m, i);
			idxlow = crackMap[m].pieces[i].idx_first;
			idxhgh = crackMap[m].pieces[i].idx_last;
#ifdef DEBUG_CRACKERS
			printf("start glue: [%d][%d]%d %d\n", m, i, crackMap[m].pieces[i].idx_first, crackMap[m].pieces[i].idx_last);
#endif
			break;
		}
	/* start glue cycle */
	if (idxlow >= 0)
		do {
			glued = 0;
			leftover = 0;
			for (i = 0; i < crackMap[m].freepiece; i++)
				if (crackMap[m].pieces[i].kind == LEAF &&	/* NOT NEEDED */
				    crackMap[m].pieces[i].rng_min >= *(int *) low && crackMap[m].pieces[i].rng_max <= *(int *) high) {
/* no little speedup, discarded
			if( crackMap[m].pieces[i].idx_first < idxlow &&
			    crackMap[m].pieces[i].idx_last > idxhgh){
				VIEWbounds(view,
					idxlow= crackMap[m].pieces[i].idx_first,
					idxhgh=crackMap[m].pieces[i].idx_last);
				glued++;
			} else
*/
					if (crackMap[m].pieces[i].idx_last == idxlow - 1) {
#ifdef DEBUG_CRACKERS
						printf("lglue: [%d][%d]%d %d\n", m, i, crackMap[m].pieces[i].idx_first, idxhgh);
#endif
						VIEWbounds(view, idxlow = crackMap[m].pieces[i].idx_first, idxhgh);
						glued++;
					} else if (crackMap[m].pieces[i].idx_first == idxhgh + 1) {
#ifdef DEBUG_CRACKERS
						printf("rglue: [%d][%d]%d %d\n", m, i, idxlow, crackMap[m].pieces[i].idx_last);
#endif
						VIEWbounds(view, idxlow, idxhgh = crackMap[m].pieces[i].idx_last);
						glued++;
					} else if (crackMap[m].pieces[i].idx_first > idxhgh || crackMap[m].pieces[i].idx_last < idxlow)
						leftover++;

				}
#ifdef DEBUG_CRACKERS
			printf("glued %d leftover %d\n", glued, leftover);
#endif
		} while (leftover);
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

@-
A common operation is to find all the pieces that
overlap with a range. It can be used for subsequent
iteration and flow-based processing.
@c
str
CRKselectPieces(int *result, int *bid, int *low, int *hgh)
{
	BAT *b;
	int m, i;
	oid o = oid_nil;

	m = findCrackMap(*bid);
	if (m < 0)
		return throwMessage("crackers.select", "Map non-existent");
	b = BATnew(TYPE_void, TYPE_int, 0);
	if (b == 0)
		return throwMessage("crackers.select", "failed to create BAT");
	for (i = 0; i < crackMap[m].freepiece; i++)
		if (crackMap[m].pieces[i].kind == LEAF) {
			if (crackMap[m].pieces[i].rng_max < *low)
				continue;
			if (crackMap[m].pieces[i].rng_min > *hgh)
				continue;
			BUNins(b, &o, &i);
		}
	BBPincref(*result = b->batCacheid, TRUE);
	return MAL_SUCCEED;
}

@-
The GDK kernel contains an error about garbage collection
of BATview objects. They have to be freed explicitly
too.
@c
str
CRKdropPiece(int *newpid, int *bid)
{
	BAT *b;
	int m;

	(void) newpid;
	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("crackers.dropPiece", "Cannot access descriptor");
	}
	m = findCrackMap(*bid);
	freeCrackMap(m);
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

str
CRKdropView(int *newpid, int *bid)
{
	BAT *b;

	(void) newpid;
	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("crackers.dropPiece", "Cannot access descriptor");
	}
	/* VIEWdestroy(b); */
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

@-
Test cases for this experiment are stored under the sequence tst5000
@}
