@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f partitions
@v 0.0
@a M.L.Kersten
@* BAT partition manager
In real-life database applications the BATs tend to grow beyond
the memory size. Although in most situation this does not
provide severe limitations, it helps to be able to see a BAT
as a logical union of BATs. 

For example, the updates of each month could be collected in
separate BATs, while all querying may still focus on the table at large.

A related, but separate issue, is the location of the BAT.

The partition module provides a shared repository of managing
such BAT groups. All elements in a group are assumed 
of type :bat[:void,:any] and the partition represents
a dense oid range. Moreover, all partitions in a group are 
considered pairwise disjoint.

The name of any of its components is also an alias for the group
as a whole.

BEWARE, it is not protected against concurrent access yet.
@mal
module partitions;

command open():void
address BPTopen
comment "Locate and open the partition box";
command close():void
address BPTclose
comment "Save and close the partition box ";
command destroy():void
address BPTdestroy
comment "Destroy the partition box";

command take(idx:int):bat[:void,:any]
address BPTtake
comment "Take a partition from the box";

command deposit(b:bat[:void,:any]) :void
address BPTdeposit
comment "Enter a new BAT into the partition box";
command deposit(b:bat[:void,:any$1],p:bat[:void,:any$1]) :void
address BPTdeposit2
comment "Enter a new partition to a group into the partition box";
command deposit(b:str,p:str,cap:int) :void
address BPTdepositPartition
comment "Enter a new BAT into the partition box";

pattern releaseAll():void
address BPTreleaseAll
comment "Release all partitions in the box";
pattern release(b:bat[:void,:any]) :void
address BPTrelease
comment "Release a single BAT with its partitions from the  box";

pattern toString(idx:int):str
address BPTtoString
comment "Get the string representation of an element in the box";

command discard(name:bat[:void,:any]) :void
address BPTdiscard
comment "Release a BAT variable from the box";

command newIterator()(:int)
address BPTnewIteratorBase
comment "Create an iterator over the partition box";
command hasMoreElements()(:int)
address BPThasMoreElementsBase
comment "Locate next element in the partition box";

command newIterator(b:bat[:void,:any$1]) (:int,:bat[:void,:any$1])
address BPTnewIterator
comment "Create an iterator over the BAT partitions.";

command newIterator(b:bat[:void,:any$1],first:oid,last:oid)
		(:int,:bat[:void,:any$1])
address BPTnewIteratorRng
comment "Create an iterator over the BAT partitions.";

command hasMoreElements(b:bat[:void,:any$1]) (:int, :bat[:void,:any$1])
address BPThasMoreElements
comment "Localize the next partition for processing.";

command hasMoreElements(b:bat[:void,:any$1],first:oid,last:oid) (:int, :bat[:void,:any$1])
address BPThasMoreElementsRng
comment "Localize the next partition for processing.";

command getLastPartition(b:bat[:void,:any$1]):bat[:void,:any$1]
address BPTgetLastPartition
comment "Obtain the last partition for update";

command getRange(b:bat[:void,:any$1])(first:oid,last:oid)
address BPTgetRange
comment "Obtain the oid range for a partition";

@-
The insert/delete/replace operations on the BATs are overloaded for
the partitioned version. Insertions are added to the last partition.
Deletion takes place in all versions and will actually shrink
the oid range. 
Rebalancing the partitions content is considered a separate action.

The partition capacity can be set to limit the number
of insertions. As soon as the capacity is exhausted,
a new bat is allocated.

@mal
command setCapacity(b:bat[:void,:any$1], s:int):void
address BPTsetCapacity
comment "Limit the content of all remaining BATs";

command insert(b:bat[:void,:any$1],h:void,t:any$1):bat[:void,:any$1]
address BPTinsert
comment "Add a tuple to the last partition";
command insert(b:bat[:void,:any$1],t:any$1):bat[:void,:any$1]
address BPTinsert_void_bun
comment "Add a tuple to the last partition";

command insert(b:bat[:void,:any$1],p:bat[:void,:any$1]):bat[:void,:any$1]
address BPTinsertBAT
comment "Add a BAT as a partition to the end of the list.";

command delete(b:bat[:void,:any$1],h:oid):bat[:void,:any$1]
address BPTdelete_oid
comment "Delete a tuple from the BAT group";

command delete(b:bat[:void,:any$1],p:bat[:void,:any$1]):bat[:void,:any$1]
address BPTdeleteBAT
comment "Delete a BAT from the partition";

command compress(b:bat[:void,:any$1]):bat[:void,:any$1]
address BPTcompress
comment "Compress the group to remove oid holes";

command dump()
address BPTdump;

command prelude()
address BPTprelude;

partitions.prelude();
@-
@{

@+ BAT Partition Iterator Implementation
The implementation is organized around a shared box, which should
be saved between session. It is up to other layers to ensure that BATs
being deleted are also removed from the partition box to avoid
mis-represented information.

The datastructures for the partition table are dynamic arrays
indexed by an integer, which is also returned to the environment
as a handle.
@h
#ifndef _MAL_BPT
#define _MAL_BPT
#include "mal.h"
#include "mal_client.h"
#include "mal_interpreter.h"


#endif
@c
#include "partitions.h"
#include "bat.h"

mal_export int BPTfindGrp(int bid);
mal_export void BPTresize(int size);
mal_export str BPTdump();
mal_export str BPTprelude(int *ret);
mal_export str BPTopen();
mal_export str BPTclose();
mal_export str BPTdestroy();
mal_export str BPTtake(int *ret, int *idx);
mal_export int BPTfindGrp(int bid);
mal_export int BPTfindPartition(int bid, int pid);
mal_export str BPTdeposit(int *ret, int *bid);
mal_export str BPTdeposit2(int *ret, int *bid, int *pid);
mal_export str BPTdepositPartition(int *ret, str *bnme, str *pnme, int *cap);
mal_export str BPTgetRange(oid *first, oid *last, int *bid);
mal_export str BPTgetLastPartition(int *ret, int *bid);
mal_export str BPTdiscard(int *ret, int *bid);
mal_export str BPTdiscardAll(int *ret);
mal_export str BPTtoString(int *ret, int *bid);
mal_export str BPTreleaseAll(int *ret, int *bid);
mal_export str BPTrelease(int *ret, int *bid);
mal_export str BPTnewIteratorBase(int *ret);
mal_export str BPThasMoreElementsBase(int *ret);
mal_export str BPTnewIterator(int *res, int *pid, int *bid);
mal_export str BPTnewIteratorRng(int *res, int *pid, int *bid, oid *first, oid *
last);
mal_export str BPThasMoreElements(int *res, int *pid, int *bid);
mal_export str BPThasMoreElementsRng(int *res, int *pid, int *bid, oid *first, oid *last);
mal_export str BPTsetCapacity(int *ret, int *bid, int *val);
mal_export str BPTinsert_void_bun(int *ret, int *bid, ptr val);
mal_export str BPTinsert(int *ret, int *bid, ptr h, ptr t);
mal_export str BPTinsertBAT(int *ret, int *bid, int *bnid);
mal_export str BPTdelete_oid(int *ret, int *bid, oid *h);
mal_export str BPTcompress(int *ret, int *bid);
mal_export str BPTdeleteBAT(int *ret, int *bid, int *bnid);

typedef struct {
	bat bid;		/* group bat identifier */
	int pid;		/* group element identifier */
	oid first;		/* lowest oid stored */
	oid last;		/* largest oid stored or nil */
	int next;		/* next one in the list */
	int prev;		/* previous one in the list */
	int cap;		/* maximum capacity */
} Partition;

static Partition *partitions;
static int ptop, plimit;

#define INCREMENT 1024
void
BPTresize(int size)
{
	Partition *p;

	p = GDKmalloc(size * sizeof(Partition));
	if (partitions) {
		if (ptop > size)
			GDKfatal("assertion error in BPTresize");
		memcpy(p, partitions, sizeof(Partition) * ptop);
		GDKfree(partitions);
	}
	partitions = p;
	partitions[0].bid = -1;
	partitions[0].pid = -1;
	partitions[0].prev = -1;
	partitions[0].next = -1;
	plimit = size;
}

str
BPTdump()
{
	stream *fd = GDKout;
	int i;

	stream_printf(fd, "ptop=%d plimit=%d\n", ptop, plimit);
	for (i = 0; i < ptop; i++)
		stream_printf(fd, "[%d] bid=%d pid=%d f=%d, l=%d prv=%d nxt=%d cap=%d\n", i, partitions[i].bid, partitions[i].pid, partitions[i].first, partitions[i].last, partitions[i].prev, partitions[i].next, partitions[i].cap);
	return MAL_SUCCEED;
}

@- Box administration
The box currently does not carry any client protection.
This should later be added or being provided by the BAT
access.
@c
str
BPTprelude(int *ret)
{
	Box box;

	(void) ret;
	box = openBox("partitions");
	if (box == 0)
		return throwMessage("partitions.prelude", "failed to open box");
	BPTresize(INCREMENT);
	return MAL_SUCCEED;
}

str
BPTopen()
{
	if (openBox("partitions") != 0)
		return MAL_SUCCEED;
	return throwMessage("partitions.open", "failed to open partitions box");
}

str
BPTclose()
{
	stream *f;
	str boxfile, boxfilebak;
	Box box;
	int i;

	box = openBox("partitions");
	f = prepareSaveBox(box, &boxfile, &boxfilebak);
	if (f != NULL) {
		/* save the info */
		for (i = 0; i < ptop; i++)
			if (partitions[i].bid != -1) {
				BAT *b = (BAT *) BBPgetdesc(partitions[i].pid);

				if (b && b->batPersistence & PERSISTENT)
					stream_printf(f, "%s.deposit(\"%s\",\"%s\",%d);\n", box->name, BBPname(partitions[i].bid), BBPname(partitions[i].pid), partitions[i].cap);
			}
		stream_close(f);
		(void) rename(boxfilebak, boxfile);
		GDKfree(boxfile);
		GDKfree(boxfilebak);
	}
	return MAL_SUCCEED;
}

str
BPTdestroy()
{
	destroyBox("partitions");
	return MAL_SUCCEED;
}

str
BPTtake(int *ret, int *idx)
{
	if (*idx < 0 || *idx >= ptop)
		return throwMessage("partitions.take", "Index out of range");
	*ret = partitions[*idx].pid;
	BBPincref(*ret, TRUE);
	return MAL_SUCCEED;
}

@-
Administration of new partitions.
@c
int
BPTfindGrp(int bid)
{
	int i;

	for (i = 0; i < ptop; i++)
		if (partitions[i].bid == bid) {
			while (partitions[i].prev >= 0)
				i = partitions[i].prev;
			return i;
		}
	return -1;
}

int
BPTfindPartition(int bid, int pid)
{
	int i;

	for (i = 0; i < ptop; i++)
		if (partitions[i].bid == bid && partitions[i].pid == pid)
			return i;
	return -1;
}

str
BPTdeposit(int *ret, int *bid)
{
	int idx, i;
	BAT *b;

	b = BATdescriptor(*bid);
	if (b == NULL)
		return throwMessage("partitions.deposit", "Can not access descriptor");
	idx = BPTfindGrp(*bid);
	if (idx != -1)
		return throwMessage("partitions.deposit", "Duplicate group definition");
	if (ptop == plimit)
		BPTresize(plimit + INCREMENT);
	for (i = 0; i <= ptop; i++)
		if (partitions[i].bid == -1)
			break;
	partitions[i].bid = *bid;
	partitions[i].pid = *bid;
	partitions[i].first = b->hseqbase;
	partitions[i].last = b->hseqbase + BATcount(b);
	partitions[i].prev = -1;
	partitions[i].next = -1;
	partitions[i].cap = -1;
	if (i >= ptop) {
		ptop = i + 1;
		partitions[ptop].bid = -1;
		partitions[ptop].next = -1;
		partitions[ptop].prev = -1;
	}
	BBPunfix(*bid);
	(void) ret;
	return MAL_SUCCEED;
}

str
BPTdeposit2(int *ret, int *bid, int *pid)
{
	int idx, i;
	BAT *b;

	b = BATdescriptor(*pid);
	if (b == NULL)
		return throwMessage("partitions.deposit", "Can not access descriptor");

	idx = BPTfindGrp(*bid);
	if (idx == -1) {
		BBPunfix(b->batCacheid);
		return throwMessage("partitions.deposit", "BAT group unknown");
	}

	while (partitions[idx].next >= 0)
		idx = partitions[idx].next;
	if (b->hseqbase < partitions[idx].last && partitions[idx].last != -1) {
		BBPunfix(b->batCacheid);
		return throwMessage("partitions.deposit", "Partition already known");
	}

	if (ptop == plimit)
		BPTresize(plimit + INCREMENT);
	for (i = 0; i <= ptop; i++)
		if (partitions[i].bid == -1)
			break;
	partitions[i].bid = *bid;
	partitions[i].pid = *pid;
	partitions[i].first = b->hseqbase;
	partitions[i].last = b->hseqbase + BATcount(b);
	partitions[i].cap = -1;
	partitions[i].prev = idx;
	partitions[idx].next = i;
	if (i >= ptop) {
		ptop = i + 1;
		partitions[ptop].bid = -1;
		partitions[ptop].next = -1;
		partitions[ptop].prev = -1;
	}
	BBPunfix(*pid);
	(void) ret;
	return MAL_SUCCEED;
}

str
BPTdepositPartition(int *ret, str *bnme, str *pnme, int *cap)
{
	BAT *b, *bn;
	str msg;
	int idx;

	idx = BBPindex(*bnme);
	if (idx == 0)
		return throwMessage("partitions.deposit", "Can not access descriptor");
	b = BATdescriptor(idx);
	if (b == NULL)
		return throwMessage("partitions.deposit", "Can not access descriptor");

	idx = BBPindex(*pnme);
	if (idx == 0)
		return throwMessage("partitions.deposit", "Can not access descriptor");
	bn = BATdescriptor(idx);
	if (bn == NULL) {
		BBPunfix(b->batCacheid);
		return throwMessage("partitions.deposit", "Can not access descriptor");
	}
	msg = BPTdeposit2(ret, &b->batCacheid, &bn->batCacheid);
	if (msg) {
		BBPunfix(b->batCacheid);
		BBPunfix(bn->batCacheid);
		return msg;
	}
	idx = BPTfindPartition(b->batCacheid, bn->batCacheid);
	partitions[idx].first = bn->hseqbase;
	partitions[idx].last = bn->hseqbase + BATcount(bn) - 1;
	partitions[idx].cap = *cap;
	BBPunfix(b->batCacheid);
	BBPunfix(bn->batCacheid);
	return MAL_SUCCEED;
}

str
BPTgetRange(oid *first, oid *last, int *bid)
{
	int i;

	for (i = 0; i < ptop; i++)
		if (partitions[i].pid == *bid) {
			*first = partitions[i].first;
			*last = partitions[i].last;
			return MAL_SUCCEED;
		}
	return throwMessage("partitions.getRange", "Partition not known");
}

str
BPTgetLastPartition(int *ret, int *bid)
{
	int i;

	for (i = 0; i < ptop; i++)
		if (partitions[i].bid == *bid && partitions[i].next == -1) {
			*ret = partitions[i].pid;
			return MAL_SUCCEED;
		}
	return throwMessage("partitions.getLastPartition", "Partition not known");
}

str
BPTdiscard(int *ret, int *bid)
{
	int i;

	for (i = 0; i < ptop; i++)
		if (partitions[i].bid == *bid || partitions[i].pid == *bid) {
			partitions[i].bid = -1;
			partitions[i].pid = -1;
		}
	(void) ret;
	return MAL_SUCCEED;
}

str
BPTdiscardAll(int *ret)
{
	GDKfree(partitions);
	partitions = 0;
	BPTresize(INCREMENT);
	(void) ret;
	return MAL_SUCCEED;
}

str
BPTtoString(int *ret, int *bid)
{
	(void) ret;
	(void) bid;
	return throwMessage("partitions.toString", "not yet implemented");
}

str
BPTreleaseAll(int *ret, int *bid)
{
	(void) ret;
	(void) bid;
	return throwMessage("partitions.release", "not yet implemented");
}

str
BPTrelease(int *ret, int *bid)
{
	(void) ret;
	(void) bid;
	return throwMessage("partitions.release", "not yet implemented");
}

@-
We start with the large chunk iterator.
The definition of the control statements require the same
control variables, which means that the BATview is accessible
to determine how far to advance when the next chunk is retrieved.
The number of elements in the chunk is limited by the granule
size.
@c
str
BPTnewIteratorBase(int *ret)
{
	*ret = 0;
	if (*ret == ptop)
		*ret = -1;
	return MAL_SUCCEED;
}

str
BPThasMoreElementsBase(int *ret)
{
	do {
		*ret = *ret + 1;
		if (*ret >= ptop) {
			*ret = -1;
			return MAL_SUCCEED;
		}
	} while (partitions[*ret].bid == -1);
	return MAL_SUCCEED;
}

str
BPTnewIterator(int *res, int *pid, int *bid)
{
	int i;

	for (i = 0; i < ptop; i++)
		if (partitions[i].bid == *bid) {
			*res = i;
			*pid = partitions[i].pid;
			BBPincref(*pid, TRUE);
			return MAL_SUCCEED;
		}
	return throwMessage("partitions.newIterator", "Group not found");
}

str
BPTnewIteratorRng(int *res, int *pid, int *bid, oid *first, oid *last)
{
	int i;

	for (i = 0; i < ptop; i++)
		if (partitions[i].bid == *bid && !(partitions[i].last < *first || partitions[i].first > *last)) {
			*res = i;
			*pid = partitions[i].pid;
			BBPincref(*pid, TRUE);
			return MAL_SUCCEED;
		}
	return throwMessage("partitions.newIterator", "Group not found");
}

str
BPThasMoreElements(int *res, int *pid, int *bid)
{
	if (partitions[*res].next != 0 && partitions[*res].bid == *bid) {
		*res = partitions[*res].next;
		*pid = partitions[*res].pid;
		BBPincref(*pid, TRUE);
		return MAL_SUCCEED;
	}
	*res = -1;
	return MAL_SUCCEED;
}

str
BPThasMoreElementsRng(int *res, int *pid, int *bid, oid *first, oid *last)
{
	int i;

	for (i = *res + 1; i < ptop; i++)
		if (partitions[i].bid == *bid && !(partitions[i].last < *first || partitions[i].first > *last)) {
			*res = i;
			*pid = partitions[i].pid;
			BBPincref(*pid, TRUE);
			return MAL_SUCCEED;
		}
	*res = -1;
	return MAL_SUCCEED;
}

@-
Data management of the partitioned BATs.
@c
static int
BPTgetlastindex(int bid)
{
	int i;

	for (i = 0; i < ptop; i++)
		if ((partitions[i].bid == bid || partitions[i].pid == bid) && partitions[i].next == -1)
			return i;
	return -1;
}
static int
BPTgetfirstindex(int bid)
{
	int i;

	for (i = 0; i < ptop; i++)
		if ((partitions[i].bid == bid || partitions[i].pid == bid) && partitions[i].prev == -1)
			return i;
	return -1;
}
static int
getpartitionsize(int idx)
{
	return (int) partitions[idx].last - (int) partitions[idx].first + 1;
}
static int
addPartition(int idx)
{
	int i;
	BAT *b, *bn;

	b = BATdescriptor(partitions[idx].pid);
	if (b == 0)
		return -1;
	bn = BATnew(b->htype, b->ttype, BATcount(b));
	if (bn == 0)
		return -1;

	partitions[idx].last = partitions[idx].first + BATcount(b);
	for (i = 0; i <= ptop; i++)
		if (partitions[i].bid == -1)
			break;
	partitions[i].bid = partitions[idx].bid;
	partitions[i].pid = bn->batCacheid;
	partitions[i].last = partitions[i].first = partitions[idx].last;
	partitions[i].cap = partitions[idx].cap;
	partitions[i].next = -1;

	if (i >= ptop) {
		ptop = i + 1;
		partitions[ptop].bid = -1;
		partitions[ptop].next = -1;
		partitions[ptop].prev = -1;
	}

	partitions[idx].next = i;

	BATseqbase(bn, partitions[i].first);
	BBPincref(bn->batCacheid, TRUE);
	BBPunfix(b->batCacheid);
	BBPunfix(bn->batCacheid);
	return i;
}

str
BPTsetCapacity(int *ret, int *bid, int *val)
{
	int i;

	(void) ret;
	i = BPTgetlastindex(*bid);
	if (i >= 0) {
		partitions[i].cap = *val;
		return MAL_SUCCEED;
	}
	return throwMessage("partitions.setCapacity", "BAT group not found");
}

str
BPTinsert_void_bun(int *ret, int *bid, ptr val)
{
	int i;

	i = BPTgetlastindex(*bid);
	if (i >= 0) {
		if (partitions[i].cap != -1 && partitions[i].cap < getpartitionsize(i))
			i = addPartition(i);
		partitions[i].last++;
		if (i >= 0)
			return BKCinsert_void_bun(ret, &partitions[i].pid, val);
	}
	return throwMessage("partitions.insert", "BAT group not found");
}

str
BPTinsert(int *ret, int *bid, ptr h, ptr t)
{
	int i;

	i = BPTgetlastindex(*bid);
	if (i >= 0) {
		if (partitions[i].cap != -1 && partitions[i].cap <= getpartitionsize(i))
			i = addPartition(i);
		if (i >= 0)
			return BKCinsert_bun(ret, &partitions[i].pid, h, t);
	}
	return throwMessage("partitions.insert", "BAT group not found");
}

str
BPTinsertBAT(int *ret, int *bid, int *bnid)
{
	(void) ret;
	(void) bid;
	(void) bnid;
	return throwMessage("partitions.insert", "BAT insert not yet implemented");
}

@-
A deletion over a BAT group may create holes between the groups comprising,
which is solved by upgrading the hbase of the descriptors.
@c
str
BPTdelete_oid(int *ret, int *bid, oid *h)
{
	int i;

	i = BPTgetlastindex(*bid);
	if (i < 0)
		return throwMessage("partitions.delete", "BAT group not found");

	for (; i >= 0; i = partitions[i].prev) {
		if (*h >= partitions[i].first)
			return BKCdelete(ret, &partitions[i].pid, h);
		if (partitions[i].prev < 0)
			return MAL_SUCCEED;
	}
	return throwMessage("partitions.delete", "Element not found in BAT group");
}

str
BPTcompress(int *ret, int *bid)
{
	BAT *b;
	int i;
	oid o = 0;

	(void) ret;
	i = BPTgetfirstindex(*bid);
	if (i < 0)
		return throwMessage("partitions.commpress", "BAT group not found");
	b = BATdescriptor(i);
	if (b == 0)
		return throwMessage("partitions.commpress", "BAT group not found");
	for (; i >= 0; i = partitions[i].next) {
		partitions[i].first = o;
		b = BATdescriptor(partitions[i].pid);
		if (b == 0)
			return throwMessage("partitions.compress", "Internal error in BAT group");
		b->hseqbase = partitions[i].first;
		o = partitions[i].last += BATcount(b) - 1;
		BBPunfix(b->batCacheid);
	}
	return MAL_SUCCEED;
}

str
BPTdeleteBAT(int *ret, int *bid, int *bnid)
{
	int i;
	BAT *b;

	(void) ret;
	i = BPTgetlastindex(*bid);
	for (; i >= 0; i = partitions[i].prev) {
		if (partitions[i].pid == *bnid) {
			/* remove a complete BAT */
			if (partitions[i].next >= 0)
				partitions[partitions[i].next].prev = partitions[i].prev;
			if (partitions[i].prev >= 0)
				partitions[partitions[i].prev].next = partitions[i].next;
			return MAL_SUCCEED;
		}
		b = BATdescriptor(partitions[i].pid);
		if (partitions[i].first <= b->hseqbase && b->hseqbase <= partitions[i].last)
			BKCdelete_bat(ret, &partitions[i].pid, bnid);
		BBPunfix(b->batCacheid);
	}
	return throwMessage("partitions.delete", "BAT delete not yet implemented");
}

@}
