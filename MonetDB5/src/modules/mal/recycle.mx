@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008-2010 MonetDB B.V.
@' All Rights Reserved.

@a M. Ivanova, M. Kersten
@f recycle
@- The Recycler
Just the interface to the recycler.
@{
@-
The Recycler is a variation of the interpreter
which inspects the variable table for alternative results.
@mal
module recycle;

pattern start():void
address RECYCLEstart
comment "Initialize recycler for the current block";

pattern stop():void
address RECYCLEstop
comment "Cleans recycler bookkeeping";

pattern dump():void
address RECYCLEdumpWrap
comment "Dump summary of recycle table for potential re-use benefits";

pattern dump(n:str):void
address RECYCLEdumpWrap
comment "Dump summary of recycle table into a file";

pattern dumpQPat():void
address RECYCLEdumpQPatWrap
comment "Dump statistics of query patterns";

pattern setRetainPolicy(p:int...):void
address RECYCLEsetRetain
comment "Set recycler retainment policy:
0- RETAIN_NONE: baseline, keeps stat, no retain, no reuse
1- RETAIN_ALL: infinite case, retain all
2- RETAIN_CAT: time-based semantics, retain if beneficial
3- RETAIN_ADAPT: adaptive temporal";

command getRetainPolicy():int
address RECYCLEgetRetain;

pattern setReusePolicy(p:int...):void
address RECYCLEsetReuse
comment "Set recycler reuse policy";

command getReusePolicy():int
address RECYCLEgetReuse;

pattern setCachePolicy(p:int...):void
address RECYCLEsetCache
comment "Set recycler cache policy:
0- RCACHE_ALL: baseline, do nothing
1- RCACHE_LRU: throw LRU by setting the limit
2- RCACHE_CREDIT: credit-based LRU scheme
3- RCACHE_CAT: use semantics of query patterns
optional arguments are [ instruction-, [memory -]] limit";

pattern setCachePolicy(p:int,cl:int,mem:int,alpha:flt):void
address RECYCLEsetCache
comment "Set recycler cache policy with alpha parameter"

command getCachePolicy():int
address RECYCLEgetCache;

pattern reset(bid:bat):void
address RECYCLEresetCMD
comment "Reset off all recycled variables";

pattern reset(sname:str...):void
address RECYCLEresetCMD
comment "Reset off all recycled variables";

pattern shutdown():void
address RECYCLEshutdownWrap
comment "Clear the recycle cache";

command monitor(f:int):void
address RECYCLEmonitor
comment "start/stop the monitoring (printing) of the recycler info (storage size used and number of statements retained)";

command log(nm:str):void
address RECYCLElog
comment "Set the name of recycle log file";

pattern prelude():void
address RECYCLEprelude
comment "Called at the start of a recycle controlled function";

pattern epilogue():void
address RECYCLEepilogue
comment "Called at the start of a recycle controlled function";
@h
#ifndef _RECYCLE_
#define _RECYCLE_

#include "mal.h"
#include "mal_instruction.h"
#include "bat5.h"

#ifdef WIN32
#ifndef LIBRECYCLE
#define recycle_export extern __declspec(dllimport)
#else
#define recycle_export extern __declspec(dllexport)
#endif
#else
#define recycle_export extern
#endif

recycle_export str RECYCLEdumpWrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
recycle_export str RECYCLEstart(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
recycle_export str RECYCLEstop(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
recycle_export str RECYCLEsetRetain(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
recycle_export str RECYCLEsetReuse(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
recycle_export str RECYCLEresetCMD(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
recycle_export str RECYCLEsetCache(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
recycle_export str RECYCLEgetRetain(int *p);
recycle_export str RECYCLEgetReuse(int *p);
recycle_export str RECYCLEgetCache(int *p);
recycle_export str RECYCLEshutdownWrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
recycle_export str RECYCLEmonitor(int *d, int *p);
recycle_export str RECYCLElog(int *d, str *nm);
recycle_export str RECYCLEprelude(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
recycle_export str RECYCLEepilogue(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
recycle_export str RECYCLEdumpQPatWrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);

#endif
@-
@c
#include "mal_config.h"
#include "mal_interpreter.h"
#include "mal_function.h"
#include "mal_recycle.h"
#include "recycle.h"
#include "algebra.h"

str recycleLog = NULL; 

@-
The recycler is started when the first function is called for its support.
Upon exit of the last function, the content of the recycle cache is destroyed.
@c
str
RECYCLEstart(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	(void) pci;
	(void) stk;
	(void) mb;
	(void) cntxt;

	return MAL_SUCCEED;
}


str
RECYCLEstop(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	(void) cntxt;
	(void) mb;
	(void) stk;
	(void) pci;

	return MAL_SUCCEED;
}


str
RECYCLEresetCMD(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	RECYCLEreset(cntxt, mb,stk,pci);
	return MAL_SUCCEED;
}

void
RECYCLEdump(stream *s)
{
	int i, incache;
	str msg;
	lng sz, persmem=0;
	ValPtr v;
    Client c;
    lng statements=0, recycled=0, recycleMiss=0, recycleRem=0;
    lng ccCalls=0, ccInstr=0, crdInstr=0;
    
	stream_printf(s,"#Recycler  catalog\n");
        stream_printf(s,"#retain= %d time =%d alpha= %4.3f\n",
                retainPolicy, recycleTime, recycleAlpha);
        stream_printf(s,"#reuse= %d\n", reusePolicy);
        stream_printf(s,"#rcache= %d limit= %d memlimit="LLFMT"\n", rcachePolicy, recycleCacheLimit, recycleMemory);
        stream_printf(s,"#hard stmt = %d hard var = %d hard mem="LLFMT"\n",
                 HARDLIMIT_STMT, HARDLIMIT_VAR, HARDLIMIT_MEM);

	if (!recycleBlk) return;

	for(i=0; i< recycleBlk->stop; i++){
#ifdef _DEBUG_CACHE_
                if ( getInstrPtr(recycleBlk,i)->token == NOOPsymbol ) continue;
#endif
		v = &getVarConstant(recycleBlk,getArg(recycleBlk->stmt[i],0));
		if ((v->vtype == TYPE_bat) &&
			 (BBP_status( *(int*)VALget(v)) & BBPPERSISTENT)) {
			msg = BKCbatsize(&sz, (int*)VALget(v));
			if ( msg == MAL_SUCCEED )
				persmem += sz;
		}
	}
	persmem = (lng) persmem/RU;

    for(c = mal_clients; c < mal_clients+MAL_MAXCLIENTS; c++)
        if (c->mode != FREECLIENT) {
            recycled += c->rcc->recycled;
            statements += c->rcc->statements;
            recycleMiss += c->rcc->recycleMiss;
            recycleRem += c->rcc->recycleRem;
            ccCalls += c->rcc->ccCalls;
            ccInstr += c->rcc->ccInstr;
            crdInstr += c->rcc->crdInstr;
        };

	incache = recycleBlk->stop;
	stream_printf(s,"#recycled = "LLFMT" incache= %d executed = "LLFMT" memory(KB)= "LLFMT" PersBat memory="LLFMT"\n",
		 recycled, incache,statements, recyclerUsedMemory, persmem);
#ifdef _DEBUG_CACHE_
	stream_printf(s,"#RPremoved = %d RPactive= %d RPmisses = %d\n",
                 recycleRem, incache-recycleRem, recycleMiss);
#endif
	stream_printf(s,"#Cache search time= "LLFMT"(usec) cleanCache: "LLFMT" calls evicted "LLFMT" instructions \t Discarded by CRD "LLFMT"\n",recycleSearchTime, ccCalls,ccInstr, crdInstr);

	/* and dump the statistics per instruction*/
        stream_printf(s,"# CL\t   lru\t\tcnt\t ticks\t rd\t wr\t Instr\n");
	for(i=0; i< recycleBlk->stop; i++){
		if (getInstrPtr(recycleBlk,i)->token == NOOPsymbol)
			stream_printf(s,"#NOOP ");
		else stream_printf(s,"#     ");
		stream_printf(s,"%4d\t"LLFMT"\t%d\t"LLFMT"\t"LLFMT"\t"LLFMT"\t%s\n", i,
			recycleBlk->profiler[i].clk,
			recycleBlk->profiler[i].counter,
			recycleBlk->profiler[i].ticks,
			recycleBlk->profiler[i].rbytes,
			recycleBlk->profiler[i].wbytes,
			instruction2str(recycleBlk,0,getInstrPtr(recycleBlk,i),TRUE));
	}
	
}


str
RECYCLEdumpWrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	stream *s = cntxt->fdout;
	str fname;

	(void) mb;
	if (pci->argc >1){
		fname = * (str*) getArgReference(stk, pci,1);
		s = open_wastream(fname);
		if (s == NULL )
			throw(MAL,"recycle.dump", RUNTIME_FILE_NOT_FOUND "%s", fname);
		if (stream_errnr(s)) {
			stream_close(s);
			throw(MAL,"recycle.dump", RUNTIME_FILE_NOT_FOUND "%s", fname);
		}
	}
	RECYCLEdump(s);
	if( s != cntxt->fdout)
		close_stream(s);
	return MAL_SUCCEED;
}

void
RECYCLEdumpQPat(stream *s)
{
	int i;
	QryStatPtr qs;
	struct tm * t;

	if (!recycleQPat) {
		stream_printf(s,"#No query patterns\n");
		return;
	}

	stream_printf(s,"#Query patterns %d\n",	recycleQPat->cnt);
	stream_printf(s,"#Client\tLogin\t\tName\tcalls\tglobRec\tlocRec\n");
	for(i=0; i< recycleQPat->cnt; i++){
		qs = recycleQPat->ptrn[i];
		t = localtime(&qs->clogin);
		stream_printf(s,"#%d\t%2d:%2d:%2d\t%s\t%d\t%d\t%d\n",
			qs->cidx, t->tm_hour, t->tm_min, t->tm_sec,qs->name, qs->calls, qs->greuse, qs->lreuse);
	}
}

str
RECYCLEdumpQPatWrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	stream *s = cntxt->fdout;
	str fname;

	(void) mb;
	if (pci->argc >1){
		fname = * (str*) getArgReference(stk, pci,1);
		s = open_wastream(fname);
		if (s == NULL )
			throw(MAL,"recycle.dumpQ", RUNTIME_FILE_NOT_FOUND" %s", fname);
		if (stream_errnr(s)){
			stream_close(s);
			throw(MAL,"recycle.dumpQ", RUNTIME_FILE_NOT_FOUND" %s", fname);
		}
	}
	RECYCLEdumpQPat(s);
	if( s != cntxt->fdout)
		close_stream(s);
	return MAL_SUCCEED;
}

@-
Called to collect statistics at the end of each query.
@c
static str
RECYCLErunningStat(Client cntxt, MalBlkPtr mb)
{	
	static int q=0;
	stream *s;
	InstrPtr p;
	int potrec=0, instr=0, i;
	lng recmem=0;

	if (recycleLog == NULL) 
		s = cntxt->fdout;
	else {
		s = append_wastream(recycleLog);
		if (s == NULL || stream_errnr(s)) {
			if (s)
				stream_destroy(s);
			throw(MAL,"recycle", RUNTIME_FILE_NOT_FOUND ":%s", recycleLog);
		}
	}

	for(i=0; i< mb->stop; i++){
		p = mb->stmt[i];
		if ( RECYCLEinterest(p) ){
			potrec++;
			if (!isBindInstr(p)) instr++;
		}
	}

	for(i=0; i< recycleBlk->stop; i++)
#ifdef _DEBUG_CACHE_
		if ( getInstrPtr(recycleBlk,i)->token != NOOPsymbol ) 
#endif
		if ( recycleBlk->profiler[i].counter >1) 
			recmem += recycleBlk->profiler[i].wbytes;

	stream_printf(s,"%d\t %d\t %d\t %d\t %8.2f\t",++q, mb->stop, potrec,
		cntxt->rcc->recycled0,(GDKusec()-cntxt->rcc->time0)/1000.0);
	stream_printf(s,"%d\t %d\t %d\t",cntxt->rcc->recycled,cntxt->rcc->statements,recycleBlk?recycleBlk->stop:0);
#ifdef _DEBUG_CACHE_
	stream_printf(s,"%d\t %d\t ",cntxt->rcc->recycleRem,cntxt->rcc->recycleMiss);
#endif
	stream_printf(s, LLFMT "\t" LLFMT "\t %d\n", recyclerUsedMemory, recmem, instr);
	if( s !=cntxt->fdout)
		close_stream(s);
	return MAL_SUCCEED;
}


str
RECYCLEsetRetain(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	(void) cntxt;
	(void) mb;
	retainPolicy = * (int*) getArgReference(stk, p,1);
	if( p->argc > 2)
	if (retainPolicy == RETAIN_ADAPT)
		recycleTime = * (int*) getArgReference(stk, p,2);
	
	return MAL_SUCCEED;
}

str
RECYCLEsetReuse(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	(void) cntxt;
	(void) mb;
	reusePolicy = * (int*) getArgReference(stk, p,1);
	return MAL_SUCCEED;
}

str
RECYCLEsetCache(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	(void) cntxt;
	(void) mb;
	rcachePolicy = * (int*) getArgReference(stk, p, 1);
	if( rcachePolicy && p->argc > 2)
		recycleCacheLimit = * (int*) getArgReference(stk, p, 2);
	if( rcachePolicy && p->argc > 3)
		recycleMemory= * (int*) getArgReference(stk, p, 3);
	if( rcachePolicy && p->argc > 4)
		recycleAlpha = * (flt*) getArgReference(stk, p, 4);
	return MAL_SUCCEED;
}

str 
RECYCLEgetRetain(int *p)
{
	*p = retainPolicy;
	return MAL_SUCCEED;
}

str 
RECYCLEgetReuse(int *p)
{
	*p = reusePolicy;
	return MAL_SUCCEED;
}

str 
RECYCLEgetCache(int *p)
{
	*p = rcachePolicy;
	return MAL_SUCCEED;
}

@-
At the end of the session we have to cleanup the recycle cache.
@c
str
RECYCLEshutdownWrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p){

	(void) mb;
	(void) stk;
	(void) p;
	RECYCLEshutdown(cntxt);
	return MAL_SUCCEED;
}
str 
RECYCLEmonitor(int *ret, int *p)
{
	(void) ret;
	monitorRecycler = *p;
	return MAL_SUCCEED;
}

str 
RECYCLElog(int *ret, str *nm)
{
	stream *s;
	(void) ret;
	recycleLog = GDKstrdup(*nm);
	s = open_wastream(recycleLog);
        if (s){
#ifdef _DEBUG_CACHE_
		stream_printf(s,"# Q\t InstrQ\t PotRecQ RecQ\t TimeQ(ms)\tRecTot\tInstrTot\tRPTot\tRPRem\tRPMiss\tMem(KB)\tReusedMem\tInstrNoGBC\n");
#else
	       	stream_printf(s,"# Q\t InstrQ\t PotRecQ RecQ\t TimeQ(ms)\tRecTot\tInstrTot\tRPTot\tMem(KB)\tReusedMem\tInstrNoGBC\n");
#endif
                close_stream(s);
	}

	return MAL_SUCCEED;
}

str 
RECYCLEprelude(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	(void) stk;
	(void) p;
	cntxt->rcc->recent = -1;
	cntxt->rcc->recycled0 = 0; 
	cntxt->rcc->time0 = GDKusec();
  	if (recycleQPat == NULL)
   		RECYCLEinitQPat(20);
	cntxt->rcc->curQ = RECYCLEnewQryStat(cntxt,mb);
	minAggr = ALGminany;
	maxAggr = ALGmaxany;
	return MAL_SUCCEED;
}
str 
RECYCLEepilogue(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p){
	(void) mb;
	(void) stk;
	(void) p;
	cntxt->rcc->curQ = -1;  
	cntxt->rcc->recycled += cntxt->rcc->recycled0; 
	if (monitorRecycler == 2 ) 
		return RECYCLErunningStat(cntxt,mb);
	return MAL_SUCCEED;
}
@}
