@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f optimizer
@a Martin Kersten
@v 0.1
@* Optimizer support 
This module contains the framework for inclusion query transformers, i.e.
C-programs geared at optimizing a piece of MAL.
The query transformer appears at the language level as an ordinary function,
but it is effective only at a specific execution phase.

Each optimizer function has access to the runtime scope of the
routine in which it is called. This can be used to maintain status
information between successive calls. 

The routines below are linked with the kernel by default

@mal

module optimizer;

pattern prelude()
address optimizer_prelude
comment "Initialize the optimizer";

pattern optimize(mod:str, fcn:str)
address QOToptimize
comment "Optimize a specific operation";

pattern commonExpressionRemoval():str 
address QOTCXoptimizer;
pattern commonExpressionRemoval(mod:any, fcn:any):str 
address QOTCXoptimizerCALL
comment "Common subexpression optimizer";

pattern aliasRemoval():str 
address QOTARoptimizer;
pattern aliasRemoval(mod:str, fcn:str):str 
address QOTARoptimizerCALL
comment "Alias removal optimizer";

pattern deadCodeRemoval():str 
address QOTDCoptimizer;
pattern deadCodeRemoval(mod:str, fcn:str):str 
address QOTDCoptimizerCALL
comment "Dead code optimizer";

pattern expressionAccumulation():str 
address QOTORoptimizer;
pattern expressionAccumulation(mod:str, fcn:str):str 
address QOTORoptimizerCALL
comment "Replace calculations with accumulator model";

pattern strengthReduction():str 
address QOTSRoptimizer;
pattern strengthReduction(mod:str, fcn:str):str 
address QOTSRoptimizerCALL
comment "Move constant expressions out of the loop";

pattern emptySet():str 
address QOTESoptimizer;
pattern emptySet(mod:str, fcn:str):str 
address QOTESoptimizerCALL
comment "Move constant expressions out of the blocks";

pattern peephole():str 
address QOTPHoptimizer;
pattern peephole(mod:str, fcn:str):str 
address QOTPHoptimizerCALL
comment "Perform local rewrites";

pattern singleton():str 
address QOTSToptimizer;
pattern singleton(mod:str, fcn:str):str 
address QOTSToptimizerCALL
comment "Perform singleton optimization";

pattern garbageCollector():str 
address QOTGCoptimizer;
pattern garbageCollector(mod:str, fcn:str):str 
address QOTGCoptimizerCALL
comment "Garbage collector optimizer";

pattern factorize():str 
address QOTFToptimizer;
pattern factorize(mod:str, fcn:str):str 
address QOTFToptimizerCALL
comment "Turn function into a factory";

pattern partitionedQuery():str 
address QOTBPToptimizer;
pattern partitionedQuery(mod:str, fcn:str):str 
address QOTBPToptimizerCALL
comment "Experiment with partitioned databases";

pattern costEstimation():str 
address QOTRMoptimizer;
pattern costEstimation(mod:str, fcn:str):str 
address QOTRMoptimizerCALL
comment "Estimate the cost of a relational expression";

pattern reduce():str 
address QOTMRoptimizer;
pattern reduce(mod:str, fcn:str):str 
address QOTMRoptimizerCALL
comment "Estimate the cost of a relational expression";

pattern setDebug():void 
address QOTdebugOptimizers;
pattern clrDebug():void 
address QOTclrdebugOptimizers;

pattern showFlowGraph(M:str,F:str,s:str):void 
address QOTshowFlowGraph
comment "Dump the data flow of the function 
	M.F in a format recognizable by the 
	command 'dot' on the file s";

pattern showPlan(M:str,F:str,s:str):void 
address QOTshowPlan;
pattern showPlan()
address QOTshowPlan
comment "Illustrate the plan derived so far";
@-
The macro processors are also be called during optimizer time
@mal
pattern macroExpansion():void 
address QOTMEoptimizer
comment "Inliner of any function";
pattern macroExpansion(mod:str):void 
address QOTMEoptimizerModule
comment "Inliner of functions in a specific module";
pattern macroExpansion(mod:str, fcn:str):void
address QOTMEoptimizerSymbol
comment "Inliner of a specific function";

pattern macroContraction():void
address QOTMCoptimizer
comment "Inliner of any function";
pattern macroContraction(mod:str):void
address QOTMCoptimizerModule
comment "Inliner of functions in a specific module";
pattern macroContraction(mod:str, fcn:str):void
address QOTMCoptimizerSymbol
comment "Inliner of a specific function";

pattern multiplex(CMD:str, a:any...):any
address OPTmultiplex
comment "Compiler for multiplexed instructions.";

@-
The remainder of this file contains dynamic optimization
routines, i.e. those not covered by the current backend.
The most important one is the multi-path join, which should
be optimized to reduce a potential exploding size/
@mal
pattern algebra.joinPath(b:bat[:any$1,:any$2], 
        aliasRemoval:bat[:any$2,:any$3]...):bat[:any$1,:any$3]
address QOTjoinPath
comment "Evaluate a join path.";

optimizer.prelude();
@{
@+ Dummy code 
@h
#ifndef _OPTIMIZER_H
#define _OPTIMIZER_H
/* #define OPTIMIZER_DEBUG*/

#include "mal_optimizer.h"

#endif /* _OPTIMIZER_H */
@c
#include "optimizer.h"
#include "mal_interpreter.h"
#include "mal_commonExpressions.h"
#include "mal_garbageCollector.h"
#include "mal_factorize.h"
#include "mal_multiplex.h"
#include "mal_partitionedQuery.h"
#include "mal_strengthReduction.h"
#include "mal_scenario.h"
#include "mal_namespace.h"
#include "mal_peephole.h"
#include "mal_singleton.h"
#include "mal_multiplex.h"
#include "mal_emptyset.h"
#include "mal_costmodel.h"
#include "mal_macro.h"
#include "mal_reduce.h"

mal_export str QOTMEoptimizerSymbol(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mal_export str QOTMEoptimizerModule(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mal_export str QOTMEoptimizer(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mal_export str QOTMCoptimizerSymbol(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mal_export str QOTMCoptimizerModule(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mal_export str QOTMCoptimizer(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);

mal_export str optimizer_prelude(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mal_export str QOTdebugOptimizers(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mal_export str QOTclrdebugOptimizers(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mal_export str QOToptimize(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mal_export str QOTshowFlowGraph(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mal_export str QOTshowPlan(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mal_export size_t QOTjoinEstimate(BAT *l, BAT *r);
mal_export str QOTjoinPath(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mal_export str OPTmultiplex(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);

@
Upon loading the module it should inspect the scenario table
for any unresolved references to the MALoptimizer and set the 
callback function.
@c
str
optimizer_prelude(MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	(void) stk;
	(void) mb;
	(void) p;
	updateScenario("MALoptimizer", (MALfcn) MALoptimizer);
	return MAL_SUCCEED;
}


static int debugOpt = 0;
str
QOTdebugOptimizers(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	debugOptimizers(mb, stk, pci);
	debugOpt = 1;
	return MAL_SUCCEED;
}

str
QOTclrdebugOptimizers(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	(void) mb;
	(void) stk;
	(void) pci;
	debugOpt = 0;
	return MAL_SUCCEED;
}

@-
MAL functions can be optimized explicitly using the routines below.
Beware, the function names should be known as literalstrings, because
you may not know the runtime situation.
@= QOTC
mal_export str QOT@1optimizerCALL(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
str QOT@1optimizerCALL(MalBlkPtr mb, MalStkPtr stk, InstrPtr p){
	str	modnme;
	str	fcnnme;
	Module  scope=NULL;
	Symbol s= NULL;
	Client c= getClient();
	lng clk= GDKusec();
	char cmd= 0;

	if( stk != 0){
		modnme= (str)getArgValue(stk,p,1);
		fcnnme= (str)getArgValue(stk,p,2);
	} else {
		modnme= getArgDefault(mb,p,1);
		fcnnme= getArgDefault(mb,p,2);
	}
	scope = findModule(c->nspace,putName(modnme,strlen(modnme)) );
	if( scope)
		s= findSymbolInModule(scope,putName(fcnnme,strlen(fcnnme)));

	if( s == NULL) {
		char buf[1024];
		snprintf(buf,1024, "Could not find %s.%s\n",modnme,fcnnme);
		return throwMessage(@2".optimizer",buf);
	}
	
	if(debugOpt) { cmd= c->itrace; c->itrace='n';}
	@1optimizer(s->def,0,0);
	optimizerCheck(s->def,@2 " optimizer",1,GDKusec()-clk);
	if(debugOpt) { c->itrace= cmd;}
	/* if(c->listing) printFunction(GDKout,s->def,c->listing);*/

	removeInstruction(mb, p);
	return MAL_SUCCEED;
}
mal_export str QOT@1optimizer(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
str QOT@1optimizer(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	setLifespan(mb);
	@1optimizer(mb, stk, pci);
	return MAL_SUCCEED;
}
@c
@:QOTC(CX, "commonExpressionRemoval")@
@:QOTC(AR, "aliasRemoval")@
@:QOTC(DC, "deadCodeRemoval")@
@:QOTC(HR, "heuristics")@
@:QOTC(GC, "garbageCollector")@
@:QOTC(BPT, "partitionedQuery")@
@:QOTC(OR, "expressionAccumulation")@
@:QOTC(FT, "factorize")@
@:QOTC(SR, "strengthReduction")@
@:QOTC(ES, "emptySet")@
@:QOTC(ST, "singleton")@
@:QOTC(PH, "peephole")@
@:QOTC(RM, "costEstimation")@
@:QOTC(MR, "reduce")@

str
QOToptimize(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str modnme;
	str fcnnme;
	Symbol s;

	(void) stk;
	if (stk != 0) {
		modnme = (str) getArgValue(stk, pci, 1);
		fcnnme = (str) getArgValue(stk, pci, 2);
	} else {
		modnme = getArgDefault(mb, pci, 1);
		fcnnme = getArgDefault(mb, pci, 2);
	}
	s = findMALSymbol(modnme, fcnnme);
	if (s == NULL)
		return throwMessage("optimizer.optimize", "operation not found\n");
	removeInstruction(mb, pci);
	return optimizeMALBlock(s->def);
}

str
QOTshowFlowGraph(MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	str fname;
	str modnme;
	str fcnnme;
	Module scope = NULL;
	Symbol s = NULL;
	Client c = getClient();

	if (stk != 0) {
		modnme = (str) getArgValue(stk, p, 1);
		fcnnme = (str) getArgValue(stk, p, 2);
		fname = (str) getArgValue(stk, p, 3);
	} else {
		modnme = getArgDefault(mb, p, 1);
		fcnnme = getArgDefault(mb, p, 2);
		fname = getArgDefault(mb, p, 3);
	}

	scope = findModule(c->nspace, putName(modnme, strlen(modnme)));

	if (scope)
		s = findSymbolInModule(scope, putName(fcnnme, strlen(fcnnme)));

	if (s == NULL) {
		char buf[1024];
		snprintf(buf,1024, "Could not find %s.%s\n", modnme, fcnnme);
		return throwMessage("optimizer.showFlowGraph", buf);
	}
	showFlowGraph(s->def, stk, fname);
	return MAL_SUCCEED;
}

str
QOTshowPlan(MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	str modnme;
	str fcnnme;
	Module scope = NULL;
	Symbol s = NULL;
	Client c = getClient();

	if (stk != 0) {
		modnme = (str) getArgValue(stk, p, 1);
		fcnnme = (str) getArgValue(stk, p, 2);
	} else {
		modnme = getArgDefault(mb, p, 1);
		fcnnme = getArgDefault(mb, p, 2);
	}

	stream_printf(c->fdout,"#showPlan()\n");
	removeInstruction(mb, p);
	if( modnme ) {
		scope = findModule(c->nspace, putName(modnme, strlen(modnme)));

		if (scope)
			s = findSymbolInModule(scope, putName(fcnnme, strlen(fcnnme)));

		if (s == NULL) {
			char buf[1024];
			snprintf(buf,1024, "Could not find %s.%s\n", modnme, fcnnme);
			return throwMessage("optimizer.showPlan", buf);
		}
		mb= s->def;
	}
	printFunction(c->fdout, mb, LIST_INPUT);
	return MAL_SUCCEED;
}

@-
The join path optimizer takes a join sequence and
attempts to minimize the intermediate result.
The choice depends on a good estimate of intermediate
results.
For the time being, we use a simplistic model, based
on the assumption that most joins are foreign key joins anyway.
@c
size_t
QOTjoinEstimate(BAT *l, BAT *r)
{
	size_t lc, rc;

	lc = BATcount(l);
	rc = BATcount(r);
	return MIN(lc, rc);
}

str
QOTjoinPath(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	BAT *joins[MAXARG], *b = 0;
	size_t estimate, e;
	int top, i, j, ret = 0, *bid;

	(void) mb;
	(void) ret;
	top = 0;
	for (i = pci->retc; i < pci->argc; i++) {
		bid = (int *) getArgReference(stk, pci, i);
#ifdef OPTIMIZER_DEBUG
		printf("bid %d\n", *bid);
#endif
		if ((b = BATdescriptor(*bid)) == NULL) {
			return throwMessage("algebra.joinPath", "Cannot access descriptor");
		}

		joins[top++] = b;
	}
	/* solve the join by pairing the smallest first */
	while (top > 2) {
		j = 0;
		estimate = BATcount(joins[0]);
		for (i = 1; i < top - 1; i++) {
			e = QOTjoinEstimate(joins[i], joins[i + 1]);
			if (e < estimate) {
				estimate = e;
				j = i;
			}
		}
#ifdef OPTIMIZER_DEBUG
		printf("join %d and %d\n", joins[j]->batCacheid, joins[j + 1]->batCacheid);
#endif
		b = BATjoin(joins[j], joins[j + 1], estimate);
		BBPunfix(joins[j]->batCacheid);
		BBPunfix(joins[j + 1]->batCacheid);
		joins[j] = b;
		for (i = j + 1; i < top; i++)
			joins[i] = joins[i + 1];
		top--;
	}
#ifdef OPTIMIZER_DEBUG
	printf("join %d and %d\n", joins[0]->batCacheid, joins[1]->batCacheid);
#endif
	estimate = BATcount(joins[0]);
	b = BATjoin(joins[0], joins[1], estimate);
	BBPunfix(joins[0]->batCacheid);
	BBPunfix(joins[1]->batCacheid);

	BBPfix(b->batCacheid);
	*(int *) getArgReference(stk, pci, 0) = b->batCacheid;
	return NULL;
}

@}
@= macroOptimizer
mal_export str QOT@1optimizerSymbol( MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
str QOT@1optimizerSymbol( MalBlkPtr mb, MalStkPtr stk, InstrPtr p){
    Module s;
    Symbol t;
    int j;
    str nme, fcn,msg=MAL_SUCCEED;

    (void)stk;
    nme= getVarConstant(mb, getArg(p,1)).val.sval;
    fcn= getVarConstant(mb, getArg(p,2)).val.sval;
#ifdef DEBUG_MAL_MACRO
    printf("@1optimizer: %s.%s\n",nme,fcn);
#endif
    removeInstruction(mb,p);


    s= findModule(mal_scope, putName(nme,strlen(nme)));
    if (s == 0) s= mal_scope;
    for(; s; s=s->outer)
    if(strcmp(s->name,nme)== 0 && s->subscope){
        j = getSubScope(fcn); 
        for(t= s->subscope[j];t!=NULL;t=t->peer) 
        if( t->def->errors == 0) {
            if( getSignature(t)->token == FUNCTIONsymbol &&
                idcmp(fcn, functionName(getSignature(t)) )==0
                )
                /* call macro expansion */
                msg= @2processor(mb,t);
                if( msg) return msg;
        }
    }
    chkFlow(mb);
	chkDeclarations(mb,TRUE);
    return msg;
}
mal_export str QOT@1optimizerModule( MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
str QOT@1optimizerModule( MalBlkPtr mb, MalStkPtr stk, InstrPtr p){
    Module s;
    Symbol t;
    int j;
    str fcn,msg=MAL_SUCCEED;

    (void) stk; 
    removeInstruction(mb,p);
    fcn= getVarConstant(mb, getArg(p,1)).val.sval;
    s= findModule(mal_scope, putName(fcn,strlen(fcn)));
#ifdef DEBUG_MAL_MACRO
    printf("@1optimizer: %s\n",fcn);
#endif
    if( s== 0)
        return throwException(MALEXCEPTION,"optimizer.@1optimizer",
            "module '%s' not found\n",fcn);
    if( s->subscope){
        j = getSubScope(fcn); 
        for(t= s->subscope[j];t!=NULL;t=t->peer)
        if( t->def->errors == 0) {
            if( getSignature(t)->token == FUNCTIONsymbol )
                /* call macro expansion */
                @2processor(mb,t); 
                if( msg) break;
        }
    }
    chkFlow(mb);
	chkDeclarations(mb,TRUE);
    return msg;
}
mal_export str QOT@1optimizer( MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
str QOT@1optimizer( MalBlkPtr mb, MalStkPtr stk, InstrPtr p){
    Module s;
    Symbol t;
    int j;
    str msg= MAL_SUCCEED;

    removeInstruction(mb,p);
#ifdef DEBUG_MAL_MACRO
    printf("@1optimizer\n");
#endif
    for(s= mal_scope; s; s=s->outer)
    if( s->subscope){
        for(j=0;j<MAXSCOPE;j++)
        if(s->subscope[j]){
            for(t= s->subscope[j];t!=NULL;t=t->peer) 
            if( t->def->errors == 0) {
                if( getSignature(t)->token == FUNCTIONsymbol )
                    /* call macro expansion */
                    @2processor(mb,t);
                    if( msg) break;
            }
        }
    }
    (void) stk; 
    chkFlow(mb);
	chkDeclarations(mb,TRUE);
    return msg;
}
@c
@:macroOptimizer(ME, MACRO)@
@:macroOptimizer(MC, ORCAM)@

str
OPTmultiplex(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{

	InstrPtr *old, p;
	int i, limit;
	lng clk = GDKusec();

	(void) stk;
	(void) pci;
	old = mb->stmt;

	limit = mb->stop;
	newMalBlkStmt(mb, mb->stop);
	for (i = 0; i < limit; i++) {
		p = old[i];
		if (moduleId(p) == putName("optimizer", 9) && functionId(p) == putName("multiplex", 9)) {
			OPTexpandMultiplex(mb, stk, p);
			freeInstruction(p);
		} else
			pushInstruction(mb, p);
	}
	GDKfree(old);
	optimizerCheck(mb, "optimizer.multiplex", 1, GDKusec() - clk);
	return MAL_SUCCEED;
}
