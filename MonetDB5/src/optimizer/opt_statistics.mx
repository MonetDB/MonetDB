@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2008 CWI.
@' All Rights Reserved.

@f opt_statistics
@a Martin Kersten
@v 0.1
@+ Optimizer Statistics
The optimizers statistics are collected in a small catalog.
It provides a basis for off-line analysis of their contribution
and a source of information of dynamic optimization decisions.

The command is stored in the inspection module, because it
otherwise interferes with the general optimizer phase.
@mal
command inspect.getStatistics(nme:str):bat[:any_1,:any_2]
address QOTgetStatistics
comment "Get optimizer property statistics 
such as #calls, #total actions, #total time";
 
@{
@+ Dummy code 
@h
#ifndef _Q_STATISTICS_H
#define _Q_STATISTICS_H
/* #define _Q_STATISTICS_DEBUG*/

#include "mal_interpreter.h"
#include "mal_scenario.h"
#include "mal_namespace.h"
#include "opt_support.h"
#include "opt_prelude.h"

opt_export str QOTgetStatistics(int *ret, str *nme);
opt_export void QOTupdateStatistics(str nme, int prop, lng val);
opt_export void QOTstatisticsExit(void);
#endif /* _Q_STATISTICS_H */
@c
#include "mal_config.h"
#include "opt_statistics.h"
@
Upon loading the module it should inspect the scenario table
for any unresolved references to the MALoptimizer and set the 
callback function.
A few global tables are maintained with optimizer statistics.
They provide the basis for dynamic optimization and offline analysis
@c
#define QOTnames	0
#define QOTcalls	1
#define QOTactions	2
#define QOTtimings	3

static BAT *qotStat[4] = { NULL };

static BAT *
QOT_create(str hnme, str tnme, int ht, int tt)
{
	BAT *b;
	char buf[128];

	snprintf(buf, 128, "stat_%s_%s", hnme, tnme);
	b = BATdescriptor(BBPindex(buf));
	if (b)
		return b;

#ifdef _Q_STATISTICS_DEBUG
	stream_printf(GDKout,"create optimizer statistics %s %s\n",hnme,tnme);
#endif
	b = BATnew(ht, tt, 256);
	if (b == NULL)
		GDKfatal("QOT_create: could not allocate.");

	BATkey(b, TRUE);
	BBPrename(b->batCacheid, buf);
	BATmode(b, PERSISTENT);
	return b;
}
static void QOTstatisticsInit(){
	oid o=0;

	if (qotStat[QOTnames]) return;
	qotStat[QOTnames]= QOT_create("opt","names",TYPE_void,TYPE_str);
	BATseqbase(qotStat[QOTnames],o);
	qotStat[QOTcalls]= QOT_create("opt","calls",TYPE_void,TYPE_int);
	BATseqbase(qotStat[QOTcalls],o);
	qotStat[QOTactions]= QOT_create("opt","actions",TYPE_void,TYPE_int);
	BATseqbase(qotStat[QOTactions],o);
	qotStat[QOTtimings]= QOT_create("opt","timings",TYPE_void,TYPE_lng);
	BATseqbase(qotStat[QOTtimings],o);

	/* save them at least once */
	QOTstatisticsExit();
}

void
QOTupdateStatistics(str nme, int actions, lng val)
{
	BATiter bi;
	BUN p;
	oid idx;
	int ival=0, *ip= &ival;
	lng lval=0, *lp= &lval;

	QOTstatisticsInit();
#ifdef _Q_STATISTICS_DEBUG
	stream_printf(GDKout,"update optimizer statistics\n");
#endif
	p = BUNfnd(BATmirror(qotStat[QOTnames]),(ptr)nme);
	if (p == BUN_NONE) {
#ifdef _Q_STATISTICS_DEBUG
		stream_printf(GDKout,"initialized? %d\n",qotStat[QOTnames]==0);
		stream_printf(GDKout,"insert optimizer statistics %s\n",nme);
#endif
		BUNappend(qotStat[QOTnames], nme, FALSE);
		BUNappend(qotStat[QOTcalls],  &ival, FALSE);
		BUNappend(qotStat[QOTactions], &ival, FALSE);
		BUNappend(qotStat[QOTtimings], &lval, FALSE);
		p = BUNfnd(BATmirror(qotStat[QOTnames]),(ptr)nme);
		if (p == BUN_NONE){
#ifdef _Q_STATISTICS_DEBUG
			stream_printf(GDKout,"not found\n");
#endif
			return;
		}
	} 
	bi = bat_iterator(qotStat[QOTnames]);
	idx = *(oid*) BUNhead(bi,p);

	p = BUNfnd(qotStat[QOTcalls],&idx);
	if (p == BUN_NONE)
		stream_printf(GDKout,"#Could not access 'calls'\n");
	bi = bat_iterator(qotStat[QOTcalls]);
	ip = (int*) BUNtail(bi,p);
	*ip = *ip+1;

	p = BUNfnd(qotStat[QOTactions],&idx);
	if (p == BUN_NONE)
		stream_printf(GDKout,"#Could not access 'actions'\n");
	bi = bat_iterator(qotStat[QOTactions]);
	ip = (int*) BUNtail(bi,p);
	*ip = *ip+ actions;

	p = BUNfnd(qotStat[QOTtimings],&idx);
	if (p == BUN_NONE)
		stream_printf(GDKout,"#Could not access 'timings'\n");
	bi = bat_iterator(qotStat[QOTtimings]);
	lp = (lng*) BUNtail(bi,p);
	*lp = *lp+ val;
}

void
QOTstatisticsExit()
{
	BAT *names = BATnew(TYPE_void,TYPE_str, 4);

	if( qotStat[QOTnames] == NULL) return;
	BUNappend(names, BBPname(qotStat[QOTnames]->batCacheid), FALSE);
	BUNappend(names, BBPname(qotStat[QOTcalls]->batCacheid), FALSE);
	BUNappend(names, BBPname(qotStat[QOTactions]->batCacheid), FALSE);
	BUNappend(names, BBPname(qotStat[QOTtimings]->batCacheid), FALSE);

	TMsubcommit(names);
	BBPreclaim(names);
}

static int 
QOTindex(str nme)
{
	if( nme == 0) return -1;
	if(strcmp(nme,"names") == 0) return QOTnames;
	if(strcmp(nme,"calls") == 0) return QOTcalls;
	if(strcmp(nme,"actions") == 0) return QOTactions;
	if(strcmp(nme,"timings") == 0) return QOTtimings;
	return -1;
}

str
QOTgetStatistics(int *ret, str *nme)
{
	int idx;
	QOTstatisticsInit();
	idx= QOTindex(*nme);
	if( idx <  0)
		throw(MAL,"optimizer.getStatistics","Illegal property");
	if( qotStat[idx] ==  0)
		throw(MAL,"optimizer.getStatistics","Statistics table not valid");
	BBPincref(*ret= qotStat[idx]->batCacheid, TRUE);
	return MAL_SUCCEED;
}

@}
