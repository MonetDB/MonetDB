@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f mal_partitionedQuery
@a M. Kersten
@-
@node Partitioned Database Optimizer, Strength Reduction, Code Factorization, Optimizer toolkit
@+ Partitioned query processing
Limitations on the addressing space in older PCs and the need
for distributed storage makes that BATs ideally should be 
looked upon as a union of smaller BATs. However, this view calls
for excessively more MAL programming effort, especially when it comes to
avoiding work using semantic knowledge.

The operation @code{optimizer.partitionedQuery} deals with 
a large fragment of the problem space. It assumes that the partitioned BATs
are all of type @code{:bat[:void,:any_1]}. 
Each partition is responsible for a dense range.
This means we can use the minimum and maximum @code{oid} as a
range constraint in optimizations decisions.

The optimizer is designed incrementally. The focus is
on supporting the SQL front-end. In particularly, the
operators considered is a limited subset of MAL. Occurrence
of an operator outside this set terminates the optimizer
activities.

The partition optimizer relies on a module that keeps
track of the partitions associated with BATs and which
also provide filtering capabilities to avoid work.

The general strategy is to select a portion of the workflow
related to a designated variable and encapsulate it with
an iterator over the BAT partitions. In doing so, we replace
operators with their incremental counter part.

Selection of which variables to expand is left to upper layers,
e.g. the language specific optimizer. Alternatively, a scheduler
may decide to rework the plan based on more accurate knowledge
of the task at hand.

A snippet of the partitioning optimizer is shown below. It assumes
that the BATs @code{a1,a2,a3} are type equivalent. The partition
module groups them together under the name @code{a1}.
A subsequent call of the partition optimizer will replace
the print command with a sequence of print commands.
@verbatim
# add it to the BAT partition table
partitions.deposit(a1);
partitions.deposit(a1,a2);
partitions.deposit(a1,a3);

function qry(a:bat[:void,:any_1]);
        io.print(a);
end qry;
optimizer.partitionedQuery("user","qry");
@end verbatim
The query is transformed into the following version.
@verbatim
function user.qry(a:bat[:void,:any_1]):void;
barrier (_5,_6):= partitions.newIterator(a);
    io.print(_6);
    redo (_5,_6):= partitions.hasMoreElements(a);
exit (_5,_6);
end qry;
@end verbatim
@{
@h
#ifndef _MAL_PARTITIONED_
#define _MAL_PARTITIONED_
#include "mal_optimizer.h"

#define DEBUG_MAL_PARTITIONED	/* show partial result */
opt_export str BPToptimizer(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);

#endif
@c
#include "mal_partitionedQuery.h"
#include "mal_optimizer.h"
#include "mal_interpreter.h"	/* for showErrors() */
#include "mal_namespace.h"

extern int BPTfindGrp(int bid);

extern str BPTreplacement(MalBlkPtr mb, int *first, int *last, int varid);
extern str BPTneedsExpansion(MalBlkPtr mb, int varid);
extern int BPTvalidFlowNetwork(MalBlkPtr mb, int *first, int *last, int varid);

@-
Calling the optimizer from the MAL context is currently
focussed on replacing the BAT arguments only.
@c
str
BPToptimizer(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int i;
	InstrPtr p;

	(void) stk;
	(void) pci;

	p = getInstrPtr(mb, 0);
	for (i = p->retc; i < p->argc; i++) {
		BPTneedsExpansion(mb, p->argv[i]);
	}
	return MAL_SUCCEED;
}

@-
Not all BATs call for iterator expansion. Unfortunately
we can not check this always at compile time, because
we need the actual BAT identifier.  Therefor the user should
supply the variable instead.
We
@c
str
BPTneedsExpansion(MalBlkPtr mb, int varid)
{
	int tpe;
	int first, last;
	str msg = 0;

	tpe = getVarType(mb, varid);
	if (isaBatType(tpe) && getHeadType(tpe) == TYPE_void) {
		first = 1;
		last = mb->stop - 2;
		printf("start first=%d last=%d \n", first, last);
		for (; first < mb->stop && last < mb->stop;) {
			if (BPTvalidFlowNetwork(mb, &first, &last, varid)) {
				printf("replace first=%d last=%d \n", first, last);
				msg = BPTreplacement(mb, &first, &last, varid);
				if (msg)
					return msg;
			} else {
				first = last;
				last = mb->stop - 1;
			}
			printf("first=%d last=%d \n", first, last);
		}
	}
	return MAL_SUCCEED;
}

@}
@-
The translation of a MAL block into a multi-iterator only works if
the network flow is simple, i.e there exists a 'single' sink, 
or all the information is compressed
into variables that are passed back to the caller as a single value,
or is sent non-interupted to the output channels.
The bottom-line is to avoid expansion.
An assignment to the target is not allowed [to be checked separately]
@{
The validFlowNetwork searches the next basic block to
be considered as safe to expand. It first skips to the
next instruction that uses the variable mentioned.
@c
int
BPTvalidFlowNetwork(MalBlkPtr mb, int *first, int *last, int varid)
{
	int i, k = 0, iocount = 0;
	InstrPtr p;

	for (i = *first; i <= *last; i++) {
		p = getInstrPtr(mb, i);
		for (k = 0; k < p->retc; k++)
			if (getArg(p, k) == varid) {
				*first = i + 1;
				return 0;
			}
		for (k = p->retc; k < p->argc; k++)
			if (getArg(p, k) == varid)
				break;
		if (k < p->argc)
			break;
		if (i == *last) {
			*last = mb->stop;
			return 0;
		}
	}
	*first = i;
	for (; i <= *last; i++) {
		p = getInstrPtr(mb, i);
		if (functionId(p) && strncmp(functionId(p), "print", 5) == 0)
			iocount++;
		else if (p->barrier)
			iocount++;
		else if (p->token == ENDsymbol)
			iocount++;
		if (iocount > 1) {
			*last = i - 1;
			return TRUE;
		}
	}
	return iocount > 0;
}

@}
@-
The first implementation takes a query block and replaces the first
bat variable with its partitioned equivalent.
The external references should be adjusted to permit working
your way through the complete graph incrementally.
They denote an inclusive range.
A copy of the program block is made by default. This could be
optimized away later.
@{
@c
str
BPTreplacement(MalBlkPtr mb, int *first, int *last, int varid)
{
	InstrPtr *old, p;
	int i, limit, actions = 0;
	int idx = -1, bid = -1;
	int pcf, pcl;
	lng clk = GDKusec();

	setLifespan(mb);
	old = mb->stmt;

	limit = mb->stop;
	newMalBlkStmt(mb, limit + 10);
#ifdef DEBUG_MAL_PARTITIONED
	stream_printf(GDKout, "variable replacement '%s'", getVarName(mb, varid));
	stream_printf(GDKout, " instructions %d-%d ", *first, *last);
	stream_printf(GDKout, " lifespan %d-%d\n", mb->var[varid]->beginLifespan, mb->var[varid]->endLifespan);
#endif
	/* copy prelude into place */
	for (i = 0; i < *first; i++)
		pushInstruction(mb, old[i]);

	actions++;
	/* barrier (idx,bid):= partitions.newIterator(var); */
	p = newInstruction(ASSIGNsymbol);
	setModuleId(p, putName("partitions", 10));
	setFunctionId(p, putName("newIterator", 11));
	p->barrier = BARRIERsymbol;
	idx = newTmpVariable(mb, TYPE_int);
	pushReturn(mb, p, idx);
	bid = newTmpVariable(mb, getVarType(mb, varid));
	pushReturn(mb, p, bid);
	pushArgument(mb, p, varid);
	pushInstruction(mb, p);

	pcf = mb->stop;
	for (i = *first; i <= *last; i++)
		pushInstruction(mb, old[i]);
	pcl = mb->stop;
@-
Before we finalize, we should also check all operations for being applicable 
to partitions as well. Where necessary they should be replaced by an
accumulated version.
@c
	/* finalize the loop */
	/* redo (idx,bid):= partitions.hasMoreElements(var); */
	p = newInstruction(REDOsymbol);
	setModuleId(p, putName("partitions", 10));
	setFunctionId(p, putName("hasMoreElements", 15));
	pushReturn(mb, p, idx);
	pushReturn(mb, p, bid);
	pushArgument(mb, p, varid);
	pushInstruction(mb, p);
	/* exit (idx,bid) */
	p = newInstruction(EXITsymbol);
	pushReturn(mb, p, idx);
	pushReturn(mb, p, bid);
	pushInstruction(mb, p);

	*first = mb->stop;
	/* copy the rest of the program back into place */
	for (; i < limit; i++)
		pushInstruction(mb, old[i]);
	GDKfree(old);
	*last = mb->stop - 1;

	/* now replace variable with the alias bid */
	if (bid != -1)
		ARreplaceAlias(mb, pcf, pcl, varid, bid);
	optimizerCheck(mb, "BPTreplacement", actions, GDKusec() - clk);
	return MAL_SUCCEED;
}

@}
