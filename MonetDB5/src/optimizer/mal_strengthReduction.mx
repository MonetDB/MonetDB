@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f mal_strengthReduction
@a M. Kersten
@-
@node Strength Reduction, Costmodels, Partitioned Database Optimizer, Optimizer toolkit
@+ Strength Reduction
An effective optimization technique in compiler construction is to
move invariant statements out of the loops. The equivalent strategy can be
applied to the guarded blocks in MAL programs.
Any variable introduced in a block and assigned a value using a
side-effect free operation is a candidate to be moved.
Furthermore, it may not be used outside the block and the expression
may not depend on variables assigned a value within the same block.

@verbatim
    j:= "hello world";
barrier go:=true;
    i:= 23;
    j:= "not moved";
    k:= j; 
    io.print(i);
exit go;
optimizer.strengthReduction();
@end verbatim
which is translated into the following code:
@verbatim
    j := "hello world";
    i := 23;
barrier go := true;
    j := "not moved";
	k := j;
    io.print(i);
exit go;
@end verbatim
Application of the strength reduction should be done with care,
because execution of a statement outside the guarded block
consumes processing resources which may have been prohibited by
the block condition.

For example, it doesn't make sense to move creation of objects
outside the barrier.
@{
@h
#ifndef _MAL_STRENGTHREDUCTION_
#define _MAL_STRENGTHREDUCTION_
#include "mal_optimizer.h"

/* #define DEBUG_MAL_STRENGTHREDUCTION     show partial result */

opt_export str SRoptimizer(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);

#endif
@c
#include "mal_strengthReduction.h"
#include "mal_interpreter.h"	/* for showErrors() */

@+ Strength reduction implementation
Strength reduction of the code is defensive. 
This first shot assumes a single loop, so we do not have to
maintain a complex administration. We simply split the code
into two sections. Those that should do Before and  Within the loop.
@c
int
SRoverwritten(InstrPtr p, int varid)
{
	int i;

	for (i = p->retc; i < p->argc; i++)
		if (getArg(p, i) == varid)
			return 1;
	return 0;
}
int isNewSource(InstrPtr p) {
	str mp= moduleId(p);
	if( mp == getName("calc",4)) return 1;
	if( mp == getName("batcalc",7)) return 1;
	if( mp == getName("str",3)) return 1;
	if( mp == getName("batstr",6)) return 1;
	if( mp == getName("array",5)) return 1;
	if( mp == getName("url",3)) return 1;
	if( mp == getName("daytime",7)) return 1;
	if( mp == getName("day",3)) return 1;
	if( mp == getName("date",4)) return 1;
	if( mp == getName("time",4)) return 1;
	if( mp == getName("tzone",5)) return 1;
	if( mp == getName("color",4)) return 1;
	if( mp == getName("batcolor",8)) return 1;
	if( mp == getName("blob",4)) return 1;
	return 0;
}
str
SRoptimizer(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int i, j = 0, k, se /*,moves */ ;
	InstrPtr p;
	int bk, ik, b, blk, blkstart, actions = 0;
	InstrPtr *before, *within;
	lng clk = GDKusec();

	(void) pci;
	(void) stk;		/* to fool compilers */

	before = (InstrPtr *) alloca((mb->ssize + 1) * sizeof(InstrPtr));
	within = (InstrPtr *) alloca((mb->ssize + 1) * sizeof(InstrPtr));
	/*for(moves=1; moves>0; ) { */
	bk = 0;
	ik = 0;
	blk = 0;
	blkstart = 0;
	for (i = 0; i < mb->stop; i++)
		before[i] = within[i] = 0;
	before[bk++] = getInstrPtr(mb, 0);	/* to become a factory */

	setLifespan(mb);
	for (i = 1; i < mb->stop - 1; i++) {
		p = getInstrPtr(mb, i);
		if (blockStart(p)) {
			if (blkstart == 0)
				blkstart = i;
			within[ik++] = p;
			blk++;
			continue;
		}
		if (blockExit(p)) {
			blk--;
			if (blk == 0)
				blkstart = 0;
			/* move the saved instruction into place */
#ifdef DEBUG_MAL_STRENGTHREDUCTION
			stream_printf(GDKout, "combine both %d %d\n", bk, ik);
#endif
			/* moves += ik; */
			for (k = 0; k < ik; k++)
				before[bk++] = within[k];
			ik = 0;
			before[bk++] = p;
			continue;
		}
		if ((se = p->barrier != 0))
			goto noreduction;
@-
Only variables introduced in the block can be moved out.
Moreover, they should be result of a calculation, e.g.
type modules and the batcalc, batstr, batcolor
@c
		if( !isNewSource(p) ) goto noreduction;

		for (k = 0; k < p->retc; k++)
			if (getVar(mb, getArg(p, k))->beginLifespan != i ){
				se = i;
#ifdef DEBUG_MAL_STRENGTHREDUCTION
				stream_printf(GDKout, "variable may not be moved out %d\n", getArg(p, k));
#endif
				goto noreduction;
			}
@-
Search the end of the block
@c
		b = blk;
		if (blk)
			for (j = i + 1; j < mb->stop - 1; j++) {
				InstrPtr q = getInstrPtr(mb, j);

				if (blockStart(q))
					b++;
				if (blockExit(q))
					b--;
				if (b < blk)
					break;	/* exit the block */
			}
@-
Make sure the variables are not used outside the block
@c
		for (k = 0; k < p->retc; k++)
			if (!isConstant(mb, getArg(p, k)) && 
				getVar(mb, getArg(p, k))->endLifespan >= j) {
				se = j;
#ifdef DEBUG_MAL_STRENGTHREDUCTION
				stream_printf(GDKout, "variable may not be used out %d\n", getArg(p, k));
#endif
				goto noreduction;
			}
@-
Search the beginning of the block and make sure that
none of the target variables is assigned a new value.
@c
		b = blk;
		if (blk)
			for (j = i - 1; j > 0; j--) {
				InstrPtr q = getInstrPtr(mb, j);

				for (k = 0; k < q->retc; k++)
					if (SRoverwritten(p, getArg(q, k))) {
						se = j;
#ifdef DEBUG_MAL_STRENGTHREDUCTION
						stream_printf(GDKout, "variable may not be overwritten %d\n", getArg(p, k));
#endif
						goto noreduction;
					}
				if (blockStart(q))
					b--;
				if (blockExit(q))
					b++;
				if (b < blk)
					break;	/* exit the block */
			}

  noreduction:
#ifdef DEBUG_MAL_STRENGTHREDUCTION
		stream_printf(GDKout, "move %d to stack %s\n", i, (se ? "within" : "before"));
		printInstruction(GDKout, mb, p, LIST_MAL_ALL);
#endif
		if (se == 0 && !hasSideEffects(p, TRUE) && isNewSource(p))
			before[bk++] = p;
		else
			within[ik++] = p;
	}
	actions += ik;
	for (k = 0; k < ik; k++)
		before[bk++] = within[k];
	before[bk++] = getInstrPtr(mb, i);
	GDKfree(mb->stmt);
	mb->stmt = (InstrPtr *) GDKmalloc((mb->ssize) * sizeof(InstrPtr));

	mb->stop = 0;

	for (i = 0; i < bk; i++)
		pushInstruction(mb, before[i]);
	/*} */
	if (pci)
		removeInstruction(mb, pci);
	optimizerCheck(mb, "strengthReduction", actions, GDKusec() - clk);
	/* remove the SRoptimizer request */
	return NULL;
}

@}
