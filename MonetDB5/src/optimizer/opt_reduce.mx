@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2007 CWI.
@' All Rights Reserved.

@f opt_reduce
@a M. Kersten
@- Stack Reduction
The compilers producing MAL may generate an abundance of temporary variables
to hold the result of expressions. This leads to a polution of the
runtime stack space, because space should be allocated and garbage
collection tests should be performed.

Likewise, constant duplicates are scattered around the stack.
They are located and merged.

The routine @sc{optimizer.reduce()} reduces the number of scratch
variables to a minimum. All scratch variables of the same underlying
type share the storage space. 
The result of this optimizer can be seen using the MonetDB debugger,
which marks unused variables explicitly.
Experience with the SQL front-end shows, that this optimization
step easily reduces the stack consumption by over 20\%.

This optimizer needs further testing. 
Furthermore, the other optimizers should be careful in setting
the isused property, or this property can again be easily derived.
@{
@mal
pattern optimizer.reduce():str
address OPTreduce;
pattern optimizer.reduce(mod:str, fcn:str):str
address OPTreduce
comment "Reduce the stack space claims";

@h
#ifndef _MAL_REDUCE_
#define _MAL_REDUCE_
#include "opt_prelude.h"
#include "opt_support.h"

/* #define DEBUG_OPT_REDUCE     show partial result */

@c
#include "mal_config.h"
#include "opt_reduce.h"
#include "mal_interpreter.h"

static 
void MRconstant(MalBlkPtr mb){
	int i,j;
	int *cst,*alias,top=0;
	InstrPtr p;

	cst= (int*) alloca(mb->vtop *sizeof(int));
	alias= (int*) alloca(mb->vtop *sizeof(int));

	for(i = 0; i< mb->vtop; i++)
	if( isConstant(mb,i) ){
		alias[i]= i;
		for(j=0; j<top; j++)
		if( getVarType(mb,i) == getVarType(mb,cst[j]) &&
			ATOMcmp(getVarType(mb,i),
			VALget(&getVar(mb,i)->value),
			VALget(&getVar(mb,cst[j])->value)) == 0){
				alias[i]= cst[j];
				break;
			}
		cst[top++]= i;
	}
	for( i=0; i< mb->stop; i++){
		p= getInstrPtr(mb,i);
		for(j=p->retc; j < p->argc; j++)
		if( isConstant(mb, getArg(p,j)) )
			getArg(p,j) = alias[getArg(p,j)];
	}
}
static int
OPTreduceImplementation(MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	int *vars, *used;
	int cnt = 0, i, j;
	InstrPtr q;
	int actions = 0;
	(void)stk;
	(void) p;

	vars = (int *) alloca(mb->vtop * sizeof(int));
	used= (int *) alloca(mb->vtop * sizeof(int));
	memset((char*) vars, 0, mb->vtop * sizeof(int));
	memset((char*) used, 0, mb->vtop * sizeof(int));

	/* reduce constant list */
	MRconstant(mb);
	/* build the use table */
	for(i=0; i<mb->stop; i++){
		q= getInstrPtr(mb,i);

		for(j=0; j<q->argc; j++)
			used[getArg(q,j)]= 1;
	}
	/* build the alias table */
	for (i = 0; i < mb->vtop; i++) {
		if ( used[i]==0 ){
			clearVariable(mb, i);
			continue;
		}
		if (i>cnt) {
			/* remap temporary variables */
			if (isTmpVar(mb,i))
				getVarTmp(mb,i) = cnt;
			mb->var[cnt] = mb->var[i];
			mb->var[i] = NULL;
			resetVarName(mb,cnt);
		}
		vars[i] = cnt;
		cnt++;
	}
	actions = mb->vtop - cnt;
#ifdef DEBUG_OPT_REDUCE
	stream_printf(GDKout, "Reduction %d -> %d\n", mb->vtop, cnt);
	for(i=0; i<mb->vtop;i++)
		stream_printf(GDKout,"map %d->%d\n",i, vars[i]);
#endif

	/* remap all variable references to their new position. */
	if (actions) {
		for (i = 1; i < mb->stop; i++) {
			q = getInstrPtr(mb, i);
			for (j = 0; j < q->argc; j++)
				getArg(q, j) = vars[getArg(q, j)];
		}
	}
#ifdef DEBUG_OPT_REDUCE
	stream_printf(GDKout, "After reduction \n");
	printFunction(GDKout,mb,0);
#endif
	mb->vtop = cnt;
	return actions;
}
@include optimizerWrapper.mx
@h
@:exportOptimizer(reduce)@
#endif
@c
@:wrapOptimizer(reduce,OPT_CHECK_ALL)@
@}
