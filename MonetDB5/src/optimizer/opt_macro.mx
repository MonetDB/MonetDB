@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2007 CWI.
@' All Rights Reserved.

@f opt_macro
@a M. L. Kersten
@- Macro and Orcam Processing
The optimizers form the basis for replacing code fragments.
Two optimizers are focused on code expansion and contraction.
The former involves replacing individual instructions by a block of
MAL code, i.e. a @sc{macro} call.
The latter depicts the inverse operation, a group of instructions
is replaced by a single MAL assignment statement, i.e. a @sc{orcam}
call.

The macro facility is limited to type-correct MAL functions,
which means that replacement is not essential from a semantic
point of view. They could have been called, or the block need
not be compressed. It is equivalent to inline code expansion.

The @sc{macro} and @sc{orcam} transformations provide 
a basis to develop front-end specific code generation templates.
The prototypical test case is the following template:
@example
function user.joinPath( a:bat[:any_1,:any_2],
                b:bat[:any_2,:any_3],
                c:bat[:any_3,:any_4]):bat[:any_1,:any_4]
address fastjoinpath;
    z:= join(a,b);
    zz:= join(z,c);
    return zz;
end user.joinPath;
@end example

The call @sc{optimizer.macro("user", "joinPath")} hunts
for occurrences of the instruction call in the block in
which it is called
and replaces it with the body, i.e. it in-lines the code.
Conversely,  the @sc{optimizer.orcam("user", "joinPath")}
attempts to localize a block of two join operations and,
when found, it is replaced by the direct call to @sc{joinPath}.
In turn, type resolution then directs execution to a built-in
function @sc{fastjoinpath}.

The current implementation is limited to finding a consecutive
sequence, ending in a return-statement. The latter is needed to
properly embed the result in the enclosed environment.
It may be extended in the future to consider the flow of control as well.

@{
After both operations the flow of control structure has to be
checked and for contraction we also have to resolve the new
code, e.g. to bind the new instruction with an implementation.
(Or become part of a macro expansion)

The implementation is based on matching MAL instructions.
This means they address the same function, but also that their 
variables are isomorphic.
The generalization of malMatch is malFcnMatch, which checks
equivalence of a function body as an occurrence in another one.
@}

The optimizer can be targeted to a function @sc{user.foo()}
using the call @sc{optimizer.macro("user","foo","user","joinPath");
@- Known issues
The functions subject to expansion or contraction should be
checked on 'proper' behavior.

The current implementation is extremely limited. 
The @sc{macro} optimizer does not recognize use of intermediate results 
outside the block being contracted. This should be checked and
it should block the replacement, unless the intermediates are part of
the return list.
Likewise, we assume here that the block has a single return
statement, which is also the last one to be executed.

The @sc{macro} optimizer can only expand functions. Factories already
carry a significant complex flow of control that is hard
to simulate in the nested flow structure of an arbitrary function.

The @sc{orcam} optimizer can not deal with calls controlled by a barrier.
It would often require a rewrite of several other statements as well.

@mal
pattern optimizer.macro(targetmod:str,targetfcn:str):void
address OPTmacro
comment "Inline the code of the target function.";
pattern optimizer.macro(mod:str,fcn:str,targetmod:str,targetfcn:str):void
address OPTmacro
comment "Inline a target function used in a specific function.";

pattern optimizer.orcam(targetmod:str,targetfcn:str):void
address OPTorcam
comment "Inverse macro processor for current function";
pattern optimizer.orcam(mod:str,fcn:str,targetmod:str,targetfcn:str):void
address OPTorcam
comment "Inverse macro, find pattern and replace with a function call.";

@-
@{
#pattern optimizer.macro(targetmod:str):void
#address OPTmacro
#comment "Inline functions known a specific module.";
#pattern optimizer.orcam(targetmod:str):void
#address OPTorcam
#comment "Inverse macro processor for a module";
@+ Implementation section
@h
#ifndef _MAL_MACRO_H_
#define _MAL_MACRO_H_

/* #define DEBUG_OPT_MACRO*/

opt_export str MACROprocessor(MalBlkPtr mb, Symbol t);
opt_export int inlineMALblock(MalBlkPtr mb, int pc, MalBlkPtr mc);
@-
@c
#include "mal_config.h"
#include "opt_prelude.h"
#include "opt_macro.h"
#include "mal_interpreter.h"

@-
The optimizer hooks are introduced first.
They are refered to from the optimizer module.
@c
static int
malMatch(InstrPtr p1, InstrPtr p2)
{
	int i, j;

	if (getFunctionId(p1) == 0 && getFunctionId(p2) != 0)
		return 0;
	if (getModuleId(p1) == 0 && getModuleId(p2) != 0)
		return 0;
	if (getModuleId(p1) != getModuleId(p2))
		return 0;
	if (getFunctionId(p2) == 0)
		return 0;
	if (getFunctionId(p1) != getFunctionId(p2))
		return 0;
	if (p1->retc != p2->retc)
		return 0;
	if (p1->argc != p2->argc)
		return 0;
	if (p1->barrier != p2->barrier)
		return 0;
	for (i = 0; i < p1->argc; i++)
		for (j = i + 1; j < p1->argc; j++)
			if ((getArg(p1, i) == getArg(p1, j) && getArg(p2, i) != getArg(p2, j)) || (getArg(p1, i) != getArg(p1, j) && getArg(p2, i) == getArg(p2, j)))
				return 0;
	return 1;
}

@-
Matching a block calls for building two variable lists used.
The isomorphism can be determined after-wards using a single scan.
The candidate block is matched with mb starting at a given pc.
The candidate block is expected to defined as a function, including
a signature and end-statement. They are ignored in the comparison

Beware, the variables in the block being removed, could be
used furtheron in the program. [tricky to detect, todo]
@c
static int
malFcnMatch(MalBlkPtr mc, MalBlkPtr mb, int pc)
{
	int i, j, k, lim;
	int *cvar, *mvar;
	int ctop = 0, mtop = 0;
	InstrPtr p, q;

	if (mb->stop - pc < mc->stop - 2)
		return 0;

	cvar = (int *) alloca(mc->vtop * mc->maxarg);

	mvar = (int *) alloca(mb->vtop * mc->maxarg);
	/* also trim the return statement */
	lim = pc + mc->stop - 3;
	k = 1;
	for (i = pc; i < lim; i++, k++) {
		p = getInstrPtr(mb, i);
		q = getInstrPtr(mc, k);
		if (malMatch(p, q) == 0)
			return 0;
		for (j = 0; j < p->argc; j++)
			cvar[ctop++] = getArg(p, j);

		for (j = 0; j < p->argc; j++)
			mvar[mtop++] = getArg(q, j);
	}
	assert(mtop == ctop);	/*shouldn;t happen */
#ifdef DEBUG_OPT_MACRO
	for (i = 0; i < ctop; i++)
		printf("match %d %d\n", cvar[i], mvar[i]);
#endif
	for (i = 0; i < ctop; i++)
		for (j = i + 1; j < ctop; j++)
			if ((cvar[i] == cvar[j] && mvar[i] != mvar[j]) ||(mvar[i] == mvar[j] && cvar[i] != cvar[j]))
				return 0;
	return 1;
}

@- Macro expansions
The macro expansion routine walks through the MAL code block in search
for the function to be expanded.  
The macro expansion process is restarted at the first new instruction.
A global is used to protect at (direct) recursive expansions
@c
#define MAXEXPANSION 256

int
inlineMALblock(MalBlkPtr mb, int pc, MalBlkPtr mc)
{
	int i, k, l, n;
	InstrPtr *ns, p,q;
	int *nv;

#ifdef DEBUG_OPT_MACRO
	printf("inlineMALblock\n");
	printFunction(GDKout,mb,LIST_MAL_ALL);
	printFunction(GDKout,mc,LIST_MAL_ALL);
#endif
	p = getInstrPtr(mb, pc);
	q = getInstrPtr(mc, 0);
	ns = GDKzalloc((l = (mb->ssize + mc->ssize + p->retc - 3)) * sizeof(InstrPtr));
	nv = alloca(mc->vtop * sizeof(int));

	/* add all variables of the new block to the target environment */
	for (n = 0; n < mc->vtop; n++) {
		if (isExceptionVariable(mc->var[n]->name)) {
			nv[n] = newVariable(mb,GDKstrdup(mc->var[n]->name),TYPE_str);
			/* keep the properties */
			if( isVarUDFtype(mc,n))
				setVarUDFtype(mb,nv[n]);
			if( isVarUsed(mc,n))
				setVarUsed(mb,nv[n]);
		} else
		if( isVarTypedef(mc,n) )
			nv[n] = newTypeVariable(mb,getVarType(mc,n));
		else
		if ( isVarConstant(mc,n)){
			nv[n] = cpyConstant(mb,getVar(mc,n));
		} else {
			nv[n] = newTmpVariable(mb, getVarType(mc, n));
			if( isVarUDFtype(mc,n))
				setVarUDFtype(mb,nv[n]);
			if( isVarUsed(mc,n))
				setVarUsed(mb,nv[n]);
		}
	}

	/* use an alias mapping to keep track of the actual arguments */
	for (n = p->retc; n < p->argc; n++)
		nv[getArg(q,n)] = getArg(p, n);

	k = 0;
	/* find the return statement of the inline function */
	for (i = 1; i < mc->stop - 1; i++) {
		q = mc->stmt[i];
		if( q->barrier== RETURNsymbol || q->barrier== YIELDsymbol){
			/* add the mapping of the return variables */
			for(n=0; n<p->retc; n++)
				nv[getArg(q,n)] = getArg(p,n);
		}
	}

	/* copy the stable part */
	for (i = 0; i < pc; i++)
		ns[k++] = mb->stmt[i];

	/* make result variable(s) known, ie assign a nil value */
	for (n = 0; n < p->retc; n++) {
		q = ns[k++] = newInstruction(NULL, ASSIGNsymbol);
		q->argc = q->retc = 0;
		q = pushArgument(mb, q, getArg(p, n)); q->retc++;
		q = pushNil(mb, q, getArgType(mb, p, n));
	}

	for (i = 1; i < mc->stop - 1; i++) {
		q = mc->stmt[i];
		if( q->token == ENDsymbol)
			break;

		/* copy the instruction and fix variable references */
		ns[k] = copyInstruction(q);
		for (n = 0; n < q->argc; n++) 
			getArg(ns[k], n) = nv[getArg(q, n)];

		if (q->barrier == RETURNsymbol || q->barrier == YIELDsymbol) {
			for(n=0; n<q->retc; n++)
				clrVarFixed(mb,getArg(ns[k],n)); /* for typing */
			setModuleId(ns[k],NULL);
			setFunctionId(ns[k],NULL);
			ns[k]->barrier = 0;
			ns[k]->token = ASSIGNsymbol;
		}
		k++;
	} 

	/* copy the remainder of the stable part */
	for (i = pc + 1; i < mb->stop; i++){
		ns[k++] = mb->stmt[i];
	}
	/* remove any free instruction */
	for(; i<mb->ssize; i++)
	if( mb->stmt[i]){
		freeInstruction(mb->stmt[i]);
		mb->stmt[i]= 0;
	}
	GDKfree(mb->stmt);
	mb->stmt = ns;

	mb->ssize = l;
	mb->stop = k;
	return pc;
}

@-
The macro processor should be carefull in replacing the
instruction. In particular, any RETURN or YIELD statement
should be replaced by a jump. For the time being,
we only allow for a single return statement at the end
of the block.
The semantic test is encapsulated in a routines.
@c

static str
MACROvalidate(MalBlkPtr mb)
{
	int retseen = 0;
	int i;
	InstrPtr p = 0;

	if (getArgType(mb, getInstrPtr(mb, 0), 0) == TYPE_void)
		return MAL_SUCCEED;

	for (i = 1; retseen == 0 && i < mb->stop; i++) {
		p = getInstrPtr(mb, i);
		retseen = p->token == RETURNsymbol || p->token == YIELDsymbol || p->barrier == RETURNsymbol || p->barrier == YIELDsymbol;
	}
	if (retseen && i != mb->stop - 1)
		throw(MAL, "optimizer.MACROvalidate", "RETURN statement is not the last one");
	return MAL_SUCCEED;
}

str
MACROprocessor(MalBlkPtr mb, Symbol t)
{
	InstrPtr q;
	int i, cnt = 0, last = -1;
	str msg = MAL_SUCCEED;

#ifdef DEBUG_OPT_MACRO
	printf("calling the MACRO processor\n");
#endif
	if (t == NULL)
		return msg;
	msg = MACROvalidate(t->def);
	if (msg)
		return msg;
	for (i = 0; i < mb->stop; i++) {
		q = getInstrPtr(mb, i);
		if (getFunctionId(q) && idcmp(getFunctionId(q), t->name) == 0 && 
			getSignature(t)->token == FUNCTIONsymbol) {
#ifdef DEBUG_OPT_MACRO
			printf("Hit, replace macro call %s\n", t->name);
#endif
			if (i == last)
				throw(MAL, "optimizer.MACROoptimizer", "duplicate macro expansion");

			last = i;
			i = inlineMALblock(mb, i, t->def);
			cnt++;
			if (cnt > MAXEXPANSION)
				throw(MAL, "optimizer.MACROoptimizer", "too many macro expansions");
		}
	}
	return msg;
}

@- Macro inversions
Macro inversions map a consecutive sequences of MAL instructions
into a single call. Subsequence resolution will bind it with the proper
function. The pattern being replaced should be a self-standing
assignment. [could be improved]

The function being replaced should assign the result to
the signature variables. Otherwise it will be difficult
to assess which result to retain.
@c
static int
replaceMALblock(MalBlkPtr mb, int pc, MalBlkPtr mc)
{
	int i, j, k, lim;
	InstrPtr p, q, rq;
	int *cvar, *mvar;
	int ctop = 0, mtop = 0;

	/* collect variable map */
	cvar = (int *) alloca(mc->vtop * mc->maxarg);

	mvar = (int *) alloca(mb->vtop * mc->maxarg);
	lim = pc + mc->stop - 2;
	k = 1;
	for (i = pc; i < lim; i++, k++) {
		p = getInstrPtr(mb, i);
		q = getInstrPtr(mc, k);
		for (j = 0; j < p->argc; j++)
			cvar[ctop++] = getArg(q, j);
		assert(ctop < mc->vtop *mc->maxarg);

		for (j = 0; j < p->argc; j++)
			mvar[mtop++] = getArg(p, j);
	}
	assert(mtop == ctop);	/*shouldn;t happen */
#ifdef DEBUG_OPT_MACRO
	for (i = 0; i < ctop; i++)
		printf("match %d %d\n", cvar[i], mvar[i]);
#endif

	p = getInstrPtr(mb, pc);
	q = copyInstruction(getInstrPtr(mc, 0));	/* the signature */
	q->token = ASSIGNsymbol;
	mb->stmt[pc] = q;

	for (i = q->retc; i < q->argc; i++)
		for (j = 0; j < ctop; j++)
			if (q->argv[i] == cvar[j]) {
				q->argv[i] = mvar[j];
				break;
			}
	/* take the return expression  and match the variables*/
	rq = getInstrPtr(mc, mc->stop - 2);
	for (i = 0; i < rq->retc; i++)
		for (j = 0; j < ctop; j++)
			if (rq->argv[i+rq->retc] == cvar[j]) {
				q->argv[i] = mvar[j];
				break;
			}
	freeInstruction(p);

	/* strip signature, return, and end statements */
	k = mc->stop - 3;
	j = pc + k;
	for (i = pc + 1; i < pc + k; i++)
		freeInstruction(mb->stmt[i]);

	for (i = pc + 1; i < mb->stop - k; i++)
		mb->stmt[i] = mb->stmt[j++];

	k = i;
	for (; i < mb->stop; i++)
		mb->stmt[i] = 0;

	mb->stop = k;
	return pc;
}

static str
ORCAMprocessor(MalBlkPtr mb, Symbol t)
{
	MalBlkPtr mc = t->def;
	int i;
	str msg = MAL_SUCCEED;

	if (t == NULL || mc->stop < 3)
		return msg;
#ifdef DEBUG_OPT_MACRO
	printf("calling the ORCAM processor for %s\n", t->name);
#endif
	/* strip signature, return, and end statements */
	for (i = 1; i < mb->stop - mc->stop + 3; i++)
		if (malFcnMatch(mc, mb, i)) {
#ifdef DEBUG_OPT_MACRO
			printf("found match for %s at %d \n", t->name, i);
#endif
			msg = MACROvalidate(mc);
			if (msg == MAL_SUCCEED)
				replaceMALblock(mb, i, mc);
			else
				break;
		}
	chkProgram(MCgetClient()->nspace, mb);
	return msg;
}

@-
The optimizer call infrastructure is identical to the liners
function with the exception that here we inline all possible
functions, regardless their
@c
@= implementation
static int
OPT@1Implementation(MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	MalBlkPtr target= mb;
	Module s;
	Symbol t;
	str mod,fcn;
	int j;

	(void) p;
	(void) stk;

	if( p->argc == 3){
		mod= getArgDefault(mb,p,1);
		fcn= getArgDefault(mb,p,2);
	} else {
		mod= getArgDefault(mb,p,1);
		fcn= getArgDefault(mb,p,2);
		t= findSymbol(putName(mod, strlen(mod)), fcn);
		if( t == 0)
			return 0;
		target= t->def;
		mod= getArgDefault(mb,p,3);
		fcn= getArgDefault(mb,p,4);
	}
	s = findModule(MCgetClient()->nspace, putName(mod, strlen(mod)));
	if (s == 0)
		return 0;
	if (s->subscope) {
		j = getSubScope(fcn);
		for (t = s->subscope[j]; t != NULL; t = t->peer)
			if (t->def->errors == 0) {
				if (getSignature(t)->token == FUNCTIONsymbol)
					@2processor(target, t);
			}
	}
	return 1;
}
@c
@:implementation(macro,MACRO)@
@:implementation(orcam,ORCAM)@
@- Optimizer code wrapper
The optimizer wrapper code is the interface to the MAL optimizer calls.
It prepares the environment for the optimizers to do their work and removes
the call itself to avoid endless recursions.

Before an optimizer is finished, it should leave a clean state behind.
Moreover, the information of the optimization step is saved for
debugging and analysis.

The wrapper expects the optimizers to return the number of
actions taken, i.e. number of succesful changes to the code.

This code is slightly different from other optimizer
wrappers, because the mod.fcn argument is optional.
@= exportOptimizer
opt_export str OPT@1(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);

@= wrapOptimizer
str OPT@1(MalBlkPtr mb, MalStkPtr stk, InstrPtr p){
	Symbol t;
	str msg,mod,fcn;
	lng clk= GDKusec();
	int actions = 0;

	optimizerInit();
	if( p->argc == 3){
		mod= getArgDefault(mb,p,1);
		fcn= getArgDefault(mb,p,2);
	} else {
		mod= getArgDefault(mb,p,3);
		fcn= getArgDefault(mb,p,4);
	}
	t= findSymbol(putName(mod, strlen(mod)), fcn);
	if( t == 0)
		return 0;

	msg = MACROvalidate(t->def);
	if( msg) 
		return msg;
	if( mb->errors == 0)
		actions= OPT@1Implementation(mb,stk,p);
	if( p )
		removeInstruction(mb, p);
    optimizerCheck(mb, "optimizer.@1", actions, GDKusec() - clk, OPT_CHECK_ALL);
	return MAL_SUCCEED;
}
@h
@:exportOptimizer(macro)@
@c
@:wrapOptimizer(macro)@
@h
@:exportOptimizer(orcam)@
#endif /* _MAL_MACRO_H_ */
@c
@:wrapOptimizer(orcam,OPT_CHECK_ALL)@

@}
