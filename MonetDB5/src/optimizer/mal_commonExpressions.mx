@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f mal_commonExpressions
@a M. Kersten
@{
@h
#ifndef _MAL_STRENGTHREDUCTION_
#define _MAL_STRENGTHREDUCTION_
#include "mal_optimizer.h"

/* #define DEBUG_MAL_OPTIMIZER     show partial result */

opt_export str CXoptimizer(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);

#endif
@c
#include "mal_commonExpressions.h"
#include "mal_interpreter.h"	/* for showErrors() */
@}
@-
@node Common Sub-Expression Removal,Empty Set Reduction, Heuristic Rewrite Rules,   Optimizer toolkit
@+ Common Subexpression Elimination
Common subexpression elimination merely involves a single scan through the 
program block to detect re-curring statements.
The key problem to be addressed is to make sure that the parameters involved
in the repeatative instruction are invariant. 

The analysis of @code{optimizer.commonExpressionRemoval()}
is rather crude. All functions with possible side-effects on
their arguments should have been marked as 'unsafe'.
Their use within a MAL block breaks the dataflow graph for all 
objects involved (BATs, everything kept in boxes).
@-
The common subexpression optimizer locates backwards the identical 
instructions. 
It stops as soon as it has found an identical one. Before we can replace the 
expression with the variable(s) of the previous one, we should assure that
we haven;t passed a safety barrier.

@verbatim
    b:= bat.new(:int,:int);
    c:= bat.new(:int,:int);
    d:= algebra.select(b,0,100);
    e:= algebra.select(b,0,100);
    k1:= 24;
    k2:= 27;
    l:= k1+k2;
    l2:= k1+k2;
    l3:= l2+k1;
    optimizer.commonExpressionRemoval();
@end verbatim
is translated into the code block where the first two instructions 
are not common, because they have side effects.
@verbatim
    b := bat.new(:int,:int);
    c := bat.new(:int,:int);
    d := algebra.select(b,0,100);
    e := d;
    k1 := 24;
    k2 := 27;
    l := calc.+(k1,k2);
    l3 := calc.+(l,k1);
@end verbatim
The current implementation is rather expensive nested-loop algorithm,
which does not perform well for large MAL blocks.
Furthermore, after each hit we apply alias removal.
This potentially generates more common expressions.
The search can be improved significantly when a dataflow graph
is maintained for all variables. For, equality of instruction implies that
all variables have been used before in a similar context.

@{
Note, we skip the first instruction because it signifies the signature.
The last instruction signifies the end.
@c
str
CXoptimizer(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int i, j, k;
	InstrPtr p, q;
	int actions = 0;
	lng clk = GDKusec();

	(void) stk;
	setLifespan(mb);
	for (i = 1; i < mb->stop - 1; i++) {
		p = getInstrPtr(mb, i);
		if (p->retc != p->argc)
			for (j = i - 1; j >= 1; j--) {
				if (safetyBarrier(mb, p, q = getInstrPtr(mb, j)))
					goto nxtCommonSubExpression;
#ifdef DEBUG_MAL_OPTIMIZER
				printf("%d, %d  %d %d ", i, j, hasSameSignature(p, q), hasSameArguments(mb, p, q));
				printf(" :%d %d %d \n", !isUpdated(mb, i), !hasCommonResults(p, q), !hasSideEffects(p, TRUE));

#endif
				if (hasSameSignature(p, q) && 
					hasSameArguments(mb, p, q) && 
					!isUpdated(mb, i) && 
					!hasCommonResults(p, q) && 
					!hasSideEffects(p, TRUE) &&
					allArgumentsVisible(mb,j,i)
					) {
#ifdef DEBUG_MAL_OPTIMIZER
					if (getClient()->debugOptimizer) {
						stream_printf(GDKout, "Found a common expression " "%d <-> %d\n", j, i);
						printInstruction(GDKout, mb, q, LIST_MAL_ALL);
						printInstruction(GDKout, mb, p, LIST_MAL_ALL);
					}
#endif
					clrFunction(p);
					p->token = ASSIGNsymbol;
					p->argc = p->retc + q->retc;
					for (k = 0; k < q->retc; k++)
						p->argv[p->retc + k] = q->argv[k];
#ifdef DEBUG_MAL_OPTIMIZER
					if (getClient()->debugOptimizer) {
						stream_printf(GDKout, "common expression");
						printInstruction(GDKout, mb, p, LIST_MAL_ALL);
					}
#endif
					i = ARoptimizerStep(mb, i);
					actions++;
					goto nxtCommonSubExpression;
				}
			}
	      nxtCommonSubExpression:;
	}
	/* remove the CXoptimizer request */
	if (pci)
		removeInstruction(mb, pci);
	optimizerCheck(mb, "commonExpressions", actions, GDKusec() - clk);
	return MAL_SUCCEED;
}

@}
