@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008-2010 MonetDB B.V.
@' All Rights Reserved.

@f opt_datacyclotron
@- The data cyclotron 

@mal
module datacyclotron;

pattern optimizer.datacyclotron():str
address OPTdatacyclotron;
pattern optimizer.datacyclotron(mod:str, fcn:str):str
address OPTdatacyclotron
comment "Datacyclotron code injection";

command copy(schema:str, tab:str, col:str, kind:int):bat[:any_1,:any_2]
address DCcopy
comment "Inform the DataCyclotron about the intended access";

command bind(schema:str, tab:str, col:str, kind:int):bat[:any_1,:any_2]
address DCbind
comment "Inform the DataCyclotron about the intended access";
command pin(b:bat[:any_1,:any_2]):bat[:any_1,:any_2]
address DCpin
comment "Inform the DataCyclotron about a pin request";
command unpin(b:bat[:any_1,:any_2])
address DCunpin
comment "Inform the DataCyclotron about a pin request";
@-
The number of overloaded instructions is kept to a minimum.
@h
#ifndef _OPT_DATACYCLOTRON_
#define _OPT_DATACYCLOTRON_
#include "opt_prelude.h"
#include "opt_support.h"
#include "mal_recycle.h"

/* #define DEBUG_DATACYCLOTRON_OPT */
/* #define BIND_DATACYCLOTRON_OPT */
@-
@c
#include "mal_config.h"
#include "opt_datacyclotron.h"
#include "mal_instruction.h"

static int
OPTdatacyclotronImplementation(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	int i, actions=0;
	InstrPtr *old;
	char *used= (char*) GDKzalloc(mb->vtop *sizeof(char));
	int limit;
#ifdef BIND_DATAFLOW_OPT
	InstrPtr q;
	int j;
#endif

	if ( used == NULL)
		return 0;
	(void) cntxt;
	(void) stk;
	if ( used == NULL)
		return 0;
	limit= mb->stop;
	old = mb->stmt;
	if ( newMalBlkStmt(mb, mb->ssize) < 0){
		GDKfree(used);
		return 0;
	}
	pushInstruction(mb,old[0]);

	for (i = 1; i<limit; i++) {
		p = old[i];
		if (getModuleId(p)== sqlRef && 
			(getFunctionId(p) == bindRef || 
			 getFunctionId(p) == putName("bind_idxbat",11) ||
			 getFunctionId(p) == binddbatRef) ) {
				setModuleId(p,putName("datacyclotron",13));
#ifdef BIND_DATAFLOW_OPT
				setFunctionId(p, putName("bind",4));
#else
				setFunctionId(p, putName("copy",4));
#endif
				used[getArg(p,0)] = 1;
				actions++;
			}
#ifdef BIND_DATAFLOW_OPT
		for (j = p->retc; j<p->argc; j++)
		if ( used[getArg(p,j)] == 1 ){
			used[getArg(p,j)] = 2;
			q= newStmt(mb,"datacyclotron","pin");
			pushArgument(mb,q,getArg(p,j));
			getArg(p,j)= getArg(q,0);
		}
		if (functionExit(p))
		for (j = 0; j< mb->vtop; j++)
		if ( used[j] == 2){
			q= newStmt(mb,"datacyclotron","unpin");
			pushArgument(mb,q,j);
		}
#endif
		pushInstruction(mb,p);
	}
	GDKfree(old);
	return actions;
}

@include optimizerWrapper.mx
@h
@:exportOptimizer(datacyclotron)@
@c
#include "opt_statistics.h"
@:wrapOptimizer(datacyclotron,OPT_CHECK_ALL)@
@- The DataCyclotron Wrapper
@h
opt_export str DCrequest(int *ret, str *sch, str *tab, str *col, int *kind);
@c
str
DCbind(int *ret, str *sch, str *tab, str *col, int *kind){
	(void) ret;
	(void) sch;
	(void) tab;
	(void) col;
	(void) kind;
	throw(MAL,"datacyclotron.bind",PROGRAM_NYI);
}

@h
opt_export str DCpin(int *ret, int *bid);
@c
str
DCpin(int *ret, int *bid){
	(void) ret;
	(void) bid;
	throw(MAL,"datacyclotron.pin",PROGRAM_NYI);
}

@h
opt_export str DCunpin(int *ret, int *bid);
@c
str
DCunpin(int *ret, int *bid){
	(void) ret;
	(void) bid;
	throw(MAL,"datacyclotron.unpin",PROGRAM_NYI);
}

@h
opt_export str DCcopy(int *ret, str *sch, str *tab, str *col, int *kind);
@c
str
DCcopy(int *ret, str *sch, str *tab, str *col, int *kind){
	(void) ret;
	(void) sch;
	(void) tab;
	(void) col;
	(void) kind;
	throw(MAL,"datacyclotron.copy",PROGRAM_NYI);
}

@h
#endif
