@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008-2010 MonetDB B.V.
@' All Rights Reserved.

@f opt_constants
@- Constant Duplicate Removal
The compilers may generate an abundance of constants on
the stack. This simple optimizer re-organizes performs a complete
job to use constants only once.
This makes it easier to search for statement duplicates 
and alias their variables.

@{
@mal
pattern optimizer.constants():str
address OPTconstants;
pattern optimizer.constants(mod:str, fcn:str):str
address OPTconstants
comment "Duplicate constant removal optimizer";
@-
@h
#ifndef _OPT_CONSTANTS_
#define _OPT_CONSTANTS_
#include "opt_prelude.h"
#include "opt_support.h"
#include "mal_exception.h"

/* #define DEBUG_OPT_CONSTANTS        show partial result */

@-
We have to keep an alias table to reorganize the program
after the variable stack has changed.
@c
#include "mal_config.h"
#include "opt_constants.h"

static int
OPTconstantsImplementation(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	int i,k=1, n=0, fnd=0, actions=0;
	int *alias, *index;
	VarPtr x,y, *cst;

#ifdef DEBUG_OPT_CONSTANTS 
	stream_printf(cntxt->fdout,"matching constant elements \n");
#endif
	alias= (int*) GDKmalloc(sizeof(int) * mb->vtop);
	cst= (VarPtr*) GDKmalloc(sizeof(VarPtr) * mb->vtop);
	index= (int*) GDKmalloc(sizeof(int) * mb->vtop);

	if ( alias == NULL || cst == NULL || index == NULL){
		if( alias) GDKfree(alias);
		if( cst) GDKfree(cst);
		if( index) GDKfree(index);
		return 0;
	}

	(void) stk;
	(void) cntxt;

	for (i=0; i< getInstrPtr(mb,0)->argc; i++)
		alias[i]=i;
	for (; i< mb->vtop; i++)
		if ( isVarConstant(mb,i) ){
			x= getVar(mb,i); fnd = 0;
			for( k= n-1; k>=0; k--){
				y= cst[k];
				if ( x->type == y->type &&
					ATOMcmp(x->type, VALget(&x->value), VALget(&y->value)) == 0){
#ifdef DEBUG_OPT_CONSTANTS 
	stream_printf(cntxt->fdout,"matching elements %s %d %d ", getVarName(mb,i), i,k);
	ATOMprint(x->value.vtype,VALget(&x->value),cntxt->fdout);
	stream_printf(cntxt->fdout,"\n");
#endif
					/* re-use a constant */
					alias[i]= index[k];
					fnd=1;
					break;
				}
			}
			if ( fnd == 0){
#ifdef DEBUG_OPT_CONSTANTS 
				stream_printf(cntxt->fdout,"swith elements %d %d\n", i,n);
#else
				(void) cntxt;
#endif
				cst[n]= x;
				index[n]= i;
				alias[i]= index[n];
				n++;
			} 
		} else
			alias[i]=i;

	for (i = 0; i < mb->stop; i++){
		p= getInstrPtr(mb,i);
		for (k=0; k < p->argc; k++)
			getArg(p,k) = alias[getArg(p,k)];
	}
	GDKfree(alias);
	GDKfree(cst);
	GDKfree(index);
	return actions;
}
@include optimizerWrapper.mx
@h
@:exportOptimizer(constants)@
#endif
@c
#include "opt_statistics.h"
@:wrapOptimizer(constants,OPT_CHECK_ALL)@
@}
