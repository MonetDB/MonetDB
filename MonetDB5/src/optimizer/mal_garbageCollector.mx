@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f mal_garbageCollector
@a M. Kersten
@-
@node Garbage Collector, Code Factorization, Multiplex Compiler, Optimizer toolkit
@+ Garbage Collection
Garbage collection of temporary variables, such as strings and BATs,
takes place upon returning from a function call. Especially for BATs
this may keep sizable resources locked longer than strictly necessary.
Although the programmer can influence their lifespan by assignment
of the @code{nil}, thereby triggering the garbage collector,
it is more appropriate to rely on an optimizer to inject these statements. 
For, it keeps the program smaller and a better
target for code-optimizations.

The operation @code{optimizer.garbageCollector()} removes all 
BATs that are at their end of life to make room for new ones.
It is typically called as one of the last optimizer steps.
A snippet of a the effect of the garbage collector:
@verbatim
    t1 := bat.new(:void,:int);
    t2 := array.grid(132000,8,1,0);
    t3 := array.grid(1,100,10560,0);
    t4 := array.grid(1,100,10560,0,8);
    t5 := batcalc.+(t2,t4);
    t6 := batcalc.oid(t5);
    t7 := algebra.join(t6,t1);
    optimizer.setGarbageCollector();
@end verbatim
is translated into the following code block:
@verbatim
    t1 := bat.new(:void,:int);
    t2 := array.grid(132000,8,1,0);
    t3 := array.grid(1,100,10560,0);
    t4 := array.grid(1,100,10560,0,8);
    t5 := batcalc.+(t2,t4);
    bat.setGarbage(t2);
    bat.setGarbage(t4);
    t6 := batcalc.oid(t5);
    bat.setGarbage(t5);
    t7 := algebra.join(t6,t1);
    bat.setGarbage(t6);
    bat.setGarbage(t1);
@end verbatim

The current algorithm is straight forward. After each instruction
we check whether its BAT arguments are needed in the future.
If not, we inject a garbage collection statement to release them,
provided there are no other reasons to retain it.
This should be done carefully, because the instruction may be part of a loop.
If the variable is defined inside the loop, we can safely remove it. 

@{
A variable can only be released in the scope in which
it is introduced. This means we need an overview of
the scope nesting and maintain a list of variables
still to be garbage collected.

We don;t have to worry about pre-mature return from the
function, because this will trigger garbage collection
anyway.

This optimizer should not be called when the scheduler
intends to keep intermediates around for re-use.
@h
#ifndef _MAL_GARBAGE_
#define _MAL_GARBAGE_
#include "mal_optimizer.h"

/* #define DEBUG_MAL_GARBAGE     show partial result */

opt_export str GCoptimizer(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);

#endif
@c
#include "mal_factorize.h"
#include "mal_interpreter.h"	/* for showErrors() */
#include "mal_namespace.h"

@= releaseBAT
	q= newInstruction(ASSIGNsymbol);
	setModuleId(q,putName("bat",3));
	setFunctionId(q,putName("setGarbage",10));
	pushArgument(mb,q,getArg(p,j));
	pushInstruction(mb,q);
	typeChecker(s,mb,q,TRUE);
@c
str
GCoptimizer(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int i, j, k, limit, done;
	InstrPtr p, q, *stmt;
	VarPtr v;
	Client cntxt = getClient();
	Module s = cntxt->nspace;
	int top = 0, blk = 1, actions = 0;
	lng clk = GDKusec();

	(void) pci;
	(void) stk;		/* to fool compilers */

	if( mb->errors) {
		if (pci)
			removeInstruction(mb, pci);
		return MAL_SUCCEED;
	}
	stmt = (InstrPtr *) GDKmalloc(mb->ssize * sizeof(InstrPtr));
	memcpy(stmt, mb->stmt, mb->ssize * sizeof(InstrPtr));

	limit = mb->stop;

	/* move to stable start */
	mb->stop = 0;
	for (i = 0; i < limit; i++) {
		p = stmt[i];

		pushInstruction(mb, p);
		for (j = p->retc; j < p->argc; j++) {
			v = getVar(mb, getArg(p, j));
			/* avoid duplicate releases */
			done = 0;
			for (k = j - 1; k >= p->retc; k--)
				if (getArg(p, j) == getArg(p, k))
					done++;

			if (done == 0 && v->endLifespan == i && isaBatType(getArgType(mb, p, j))) {
/* 			printf("remove the variable %s at %d\n", getArgName(mb,p,j),i);*/
				if (getVarScope(mb, getArg(p, j)) == blk) {
					@:releaseBAT()@
					actions++;
				}
			}
		}
		if (blockStart(p)) {
			blk++;
			if (top < MAXDEPTH - 2) {
			} else {
				mb->errors++;
				return throwMessage("optimizer.garbageCollector", "Too deeply nested MAL program\n");
			}
		}
		if (blockExit(p))
			if (top > 0) {
				top--;
			}

	}
#ifdef DEBUG_MAL_GARBAGE
	{
		if (cntxt->debugOptimizer) {
			stream_printf(GDKout, "Garbage collected BAT variables \n");
			printFunction(GDKout, mb, LIST_MAL_ALL);
			stream_printf(GDKout, "End of GCoptimizer\n");
		}
	}
#endif
	GDKfree(stmt);

	if (pci)
		removeInstruction(mb, pci);
	optimizerCheck(mb, "garbageCollector", actions, GDKusec() - clk);
	return NULL;
}

@}
