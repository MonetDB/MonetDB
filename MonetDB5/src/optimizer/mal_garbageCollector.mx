@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f mal_garbageCollector
@a M. Kersten
@-
@node Garbage Collector, Code Factorization, Multiplex Compiler, Optimizer toolkit
@+ Garbage Collection
Garbage collection of temporary variables, such as strings and BATs,
takes place upon returning from a function call. Especially for BATs
this may keep sizable resources locked longer than strictly necessary.
Although the programmer can influence their lifespan by assignment
of the @code{nil}, thereby triggering the garbage collector,
it is more appropriate to rely on an optimizer to inject these statements. 
For, it keeps the program smaller and a better
target for code-optimizations.

The operation @code{optimizer.garbageCollector()} removes all 
BATs that are at their end of life to make room for new ones.
It is typically called as one of the last optimizer steps.
A snippet of a the effect of the garbage collector:
@verbatim
    t1 := bat.new(:void,:int);
    t2 := array.grid(132000,8,1,0);
    t3 := array.grid(1,100,10560,0);
    t4 := array.grid(1,100,10560,0,8);
    t5 := batcalc.+(t2,t4);
    t6 := batcalc.oid(t5);
    t7 := algebra.join(t6,t1);
    optimizer.garbageCollector();
@end verbatim
is translated into the following code block:
@verbatim
    t1 := bat.new(:void,:int);
    t2 := array.grid(132000,8,1,0);
    t3 := array.grid(1,100,10560,0);
    t4 := array.grid(1,100,10560,0,8);
    t5 := batcalc.+(t2,t4);
    bat.setGarbage(t2);
    bat.setGarbage(t4);
    t6 := batcalc.oid(t5);
    bat.setGarbage(t5);
    t7 := algebra.join(t6,t1);
    bat.setGarbage(t6);
    bat.setGarbage(t1);
@end verbatim

The current algorithm is straight forward. After each instruction
we check whether its BAT arguments are needed in the future.
If not, we inject a garbage collection statement to release them,
provided there are no other reasons to retain it.
This should be done carefully, because the instruction may be part of a loop.
If the variable is defined inside the loop, we can safely remove it. 

@{
A variable can only be released in the scope in which
it is introduced. This means we need an overview of
the scope nesting and maintain a list of variables
still to be garbage collected.

We don;t have to worry about pre-mature return from the
function, because this will trigger garbage collection
anyway.

This optimizer should not be called when the scheduler
intends to keep intermediates around for re-use.
@mal
pattern optimizer.garbageCollector():str
address QOTGCoptimizer;
pattern optimizer.garbageCollector(mod:str, fcn:str):str
address QOTGCoptimizer
comment "Garbage collector optimizer";
@h
#ifndef _MAL_GARBAGE_
#define _MAL_GARBAGE_
#include "mal_optimizer.h"

/* #define DEBUG_MAL_GARBAGE     show partial result */

opt_export str GCoptimizer(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);

#endif
@c
#include "mal_factorize.h"
#include "mal_interpreter.h"	/* for showErrors() */
#include "mal_namespace.h"
#include "mal_prelude.h"

@= releaseBAT
	q= newInstruction(NULL,ASSIGNsymbol);
	setModuleId(q,batRef);
	setFunctionId(q,putName("setGarbage",10));
	pushArgument(mb,q,getArg(p,j));
	getArg(q,0) = newTmpVariable(mb,TYPE_any);
	pushInstruction(mb,q);
	typeChecker(s,mb,q,TRUE);
@c
str
GCoptimizer(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int i, j, k, limit, done;
	InstrPtr p, q, *stmt;
	VarPtr v;
	Client cntxt = MCgetClient();
	Module s = cntxt->nspace;
	int top = 0, blk = 1, actions = 0;
	lng clk = GDKusec();

	(void) pci;
	(void) stk;		/* to fool compilers */

	if( mb->errors) {
		if (pci)
			removeInstruction(mb, pci);
		return MAL_SUCCEED;
	}
	setLifespan(mb);

	stmt = (InstrPtr *) GDKmalloc(mb->ssize * sizeof(InstrPtr));
	memcpy(stmt, mb->stmt, mb->ssize * sizeof(InstrPtr));
	memset((char*) mb->stmt,0, mb->ssize * sizeof(InstrPtr));

	limit = mb->stop;

	/* move to stable start */
	mb->stop = 0;
	for (i = 0; i < limit; i++) {
		p = stmt[i];

		pushInstruction(mb, p);
		for (j = p->retc; j < p->argc; j++) {
			v = getVar(mb, getArg(p, j));
			/* avoid duplicate releases */
			done = 0;
			for (k = j - 1; k >= p->retc; k--)
				if (getArg(p, j) == getArg(p, k))
					done++;

			if (done == 0 && v->endLifespan == i && isaBatType(getArgType(mb, p, j))) {
/* 			printf("remove the variable %s at %d\n", getArgName(mb,p,j),i);*/
				if (getVarScope(mb, getArg(p, j)) == blk) {
					@:releaseBAT()@
					actions++;
				}
			}
		}
		if (blockStart(p)) {
			blk++;
			if (top < MAXDEPTH - 2) {
			} else {
				mb->errors++;
				return throwMessage("optimizer.garbageCollector", "Too deeply nested MAL program\n");
			}
		}
		if (blockExit(p))
			if (top > 0) {
				top--;
			}

	}
#ifdef DEBUG_MAL_GARBAGE
	{
		if (cntxt->debugOptimizer) {
			stream_printf(GDKout, "Garbage collected BAT variables \n");
			printFunction(GDKout, mb, LIST_MAL_ALL);
			stream_printf(GDKout, "End of GCoptimizer\n");
		}
	}
#endif
	GDKfree(stmt);

	if (pci)
		removeInstruction(mb, pci);
	optimizerCheck(mb, "garbageCollector", actions, GDKusec() - clk);
	return MAL_SUCCEED;
}

@- Optimizer code wrapper
@c
mal_export str QOTGCoptimizer(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
str QOTGCoptimizer(MalBlkPtr mb, MalStkPtr stk, InstrPtr p){
	str	modnme;
	str	fcnnme;
	Module  scope=NULL;
	Symbol s= NULL;
	Client c= MCgetClient();
	lng clk= GDKusec();

	/* handle the empty argument list */
	if( p->argc== 1){
		/* setLifespan(mb); they should do it themselves*/
		optimizerInit();
		GCoptimizer(mb, stk, p);
		return MAL_SUCCEED;
	}
	if( stk != 0){
		modnme= (str)getArgValue(stk,p,1);
		fcnnme= (str)getArgValue(stk,p,2);
	} else {
		modnme= getArgDefault(mb,p,1);
		fcnnme= getArgDefault(mb,p,2);
	}
	scope = findModule(c->nspace,putName(modnme,strlen(modnme)) );
	if( scope)
		s= findSymbolInModule(scope,putName(fcnnme,strlen(fcnnme)));

	if( s == NULL) {
		char buf[1024];
		snprintf(buf,1024, "Could not find %s.%s\n",modnme,fcnnme);
		return throwMessage("optimizer.garbageCollector",buf);
	}
	
	if( s->def->errors == 0){
		optimizerInit();
		GCoptimizer(s->def,0,0);
		optimizerCheck(s->def,"garbageCollector",1,GDKusec()-clk);
	}
	removeInstruction(mb, p);
	return MAL_SUCCEED;
}
@}
