@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2008 CWI.
@' All Rights Reserved.

@f opt_peephole
@a M. Kersten
@- Peephole optimization
Recursive descend query compilers easily miss opportunities
for better code generation, because limited context is retained
or lookahead available. The peephole optimizer is
built around such recurring patterns and compensates
for the compilers 'mistakes'.
The collection of peephole patterns should grow over time and
front-end specific variations are foreseen.
@{
@mal
pattern optimizer.peephole():str
address OPTpeephole;
pattern optimizer.peephole(mod:str, fcn:str):str
address OPTpeephole
comment "Perform local rewrites";
@h
#ifndef _MAL_PEEPHOLE_
#define _MAL_PEEPHOLE_
#include "opt_support.h"
#include "mal_interpreter.h"	/* for showErrors() */
#include "opt_prelude.h"

/* #define DEBUG_OPT_PEEPHOLE     show partial result */

#define match(X,M,F) ( (X) && getFunctionId(X) && strcmp(getFunctionId(X),F)==0 && \
	getModuleId(X) && strcmp(getModuleId(X),M)==0)
@c
#include "mal_config.h"
#include "opt_peephole.h"
#include "opt_aliases.h"
@}
@- 
The SQL frontend heavily relies on a pivot table, which
is a generated oid sequence. Unfortunately, this
is not seen and the pattern '$i := calc.oid(0@@0); $j:= algebra.markT($k,$i);'
occurs often. This can be replaced with '$j:= algebra.markT($k)';

Another example of a 2-way instruction sequence produced is then
'$j:= algebra.markT($k); $l:= bat.reverse($j);',
which can be replaced by '$l:= algebra.markH($k);'.

The reverse-reverse operation also falls into this category.
Reversal pairs may result from the processing scheme of a front-end compiler
or from a side-effect from other optimization steps. Such reversal pairs should
be removed as quickly as possible, so as to reduce the complexity of finding
alternative optimization opportunities.
As in all cases we should ensure that the intermediates dropped are not
used for other purposes as well.

@verbatim
	r:bat[:int,:int]:= bat.new(:int,:int);
	o:= calc.oid(0@0);
	z:= algebra.markT(r,o);
	rr:= bat.reverse(z);
	s := bat.reverse(r);
	t := bat.reverse(s);
	io.print(t);
	optimizer.peephole();
@end verbatim
which is translated by the peephole optimizer into:
@verbatim
	r:bat[:int,:int] := bat.new(:int,:int);
	rr := algebra.markH(r);
	io.print(r);
@end verbatim
@{
The type of a variable may have to be reset when you change
the program structure.
@c
static int
OPTpeepholeImplementation(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	InstrPtr p, q, r, *old;
	int i, limit, slimit, doit, actions = 0;
	Lifespan span= newLifespan(mb);

#ifdef DEBUG_OPT_PEEPHOLE
	stream_printf(GDKout, "Peephole optimizer started\n");
#endif
	(void) stk;
	(void) pci;
	actions = 0;
	doit = 0;
	setLifespan(mb,span);
	limit = mb->stop;
	slimit = mb->ssize;
	old = mb->stmt;

	newMalBlkStmt(mb, mb->ssize);
	for (i = 0; i < limit; i++) {
		p = old[i];
		q = i < limit - 1 ? old[i + 1] : 0;
		if (q && match(p, batRef, reverseRef) && 
					match(q, batRef, reverseRef) && 
					getArg(p, 0) == getArg(q, 1) && 
					getEndLifespan(span,getArg(p,0)) == i + 1) {
#ifdef DEBUG_OPT_PEEPHOLE
			printf("PEEPHOLE reverse-reverse\n");
			printInstruction(GDKout, mb, p, LIST_MAL_ALL);
			printInstruction(GDKout, mb, q, LIST_MAL_ALL);
#endif
			r = newInstruction(mb,ASSIGNsymbol);
			getArg(r, 0) = getArg(q, 0);
			r= pushArgument(mb, r, getArg(p, 1));
			freeInstruction(p);
			freeInstruction(q);
			pushInstruction(mb, r);
			i++;
			actions++;
			doit++;
		} else if (match(p, "optimizer", "peephole"))
			freeInstruction(p);
		else
			pushInstruction(mb, p);
	}
	for( ; i<slimit; i++)
	if( old[i])
		freeInstruction(old[i]);
	GDKfree(old);
	if (doit) {
		chkProgram(MCgetClient()->nspace, mb);
#ifdef DEBUG_OPT_PEEPHOLE
		stream_printf(GDKout, "PEEPHOLE %d\n", doit);
		printFunction(GDKout, mb, LIST_MAL_ALL);
#endif
	}
	GDKfree(span);
	return actions;
}

@include optimizerWrapper.mx
@h
@:exportOptimizer(peephole)@
#endif
@c
#include "opt_statistics.h"
@:wrapOptimizer(peephole,OPT_CHECK_ALL)@
@}

