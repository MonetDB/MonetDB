@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f mal_emptyset
@a M. Kersten
@-
@node Empty Set Reduction, Singleton Sets, Common Sub-Expressions, Optimizer Toolkit
@- Emptyset Reduction
One of the key decisions during MAL optimization is to estimate
the size of the BATs produced and consumed. Two cases are of interest
for symbolic processing. Namely when a BAT is known to contain no
tuples and those that have precisely one element.
Such information may come from application domain knowledge or as a
side effect from symbolic evaluation. It is associated with the
program under inspection as properties.

The empty set property is used by the reduction algorithm
presented here. Any empty set is propagated through the program
to arrive at a smaller and therefore faster evaluation.

For example, consider the following MAL test 
@example
@verbatim
    V1 := bat.new(:void,:int);
    V7 := bat.new(:void,:int);
    V10{empty} := bat.new(:int,:void);
    V11 := bat.reverse(V10);
    V12 := algebra.kdifference(V7,V11);
    V16 := algebra.markH(V12);
    V17 := algebra.join(V16,V7);
    bat.append(V1,V17);
	optimizer.emptySet();
@end verbatim
@end example
Calling the optimizer optimize.emptySet("user","test") replaces this program
by the following code snippet.
@example
     V1 := bat.new(:void,:int);
     V7 := bat.new(:void,:int);
     V16 := algebra.markH(V7);
     V17 := algebra.join(V16,V7);
     bat.append(V1,V17);
@end example
During empty set propagation, new candidates may appear. For example,
taking the intersection with an empty set creates a target variable
that is empty too. It becomes an immediate target for optimization.
The current implementation is conservative. A limited set of
instructions is considered. Any addition to the MonetDB instruction
set would call for assessment on their effect.
@{
The implementation differs slightly from other optimizers in that
we need the variables that are designated as being empty
@mal
pattern optimizer.emptySet():str
address QOTESoptimizer;
pattern optimizer.emptySet(mod:str, fcn:str):str
address QOTESoptimizer
comment "Move constant expressions out of the blocks";
@h
#ifndef _MAL_EMPTYSET_
#define _MAL_EMPTYSET_
#include "mal_prelude.h"
#include "mal_optimizer.h"

#define DEBUG_MAL_EMPTYSET	/* show partial result */

opt_export str ESoptimizer(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
opt_export str ESevaluate(MalBlkPtr mb, int cnt, int *vars);
#endif
@c
#include "mal_emptyset.h"
#include "mal_interpreter.h"	/* for showErrors() */
#include "mal_builder.h"
#include "mal_namespace.h"

str
ESoptimizer(MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	int *sets;
	int i, k = 0;
	PropertySet ps;

	sets = (int *) alloca(mb->vtop * sizeof(int));
	(void) mb;
	(void) stk;
	(void) p;
#ifdef DEBUG_MAL_EMPTYSET
	printf("ESoptimizer called, collect empty sets and process them\n");
#endif
	for (i = 0; i < mb->vtop; i++) {
		ps = getVarProperties(mb, i);
		if (fndProperty(ps, "empty")) {
			sets[k++] = i;
		}
	}
	ESevaluate(mb, k, sets);
	return MAL_SUCCEED;
}

str
ESevaluate(MalBlkPtr mb, int cnt, int *vars)
{
	lng clk = GDKusec();
	char *empty;
	int i, j, limit, doAR = 0;
	InstrPtr p, *old;

	if( mb->errors) 
		return MAL_SUCCEED;
#ifdef DEBUG_MAL_EMPTYSET
	stream_printf(GDKout, "START emptyset optimizer %d:", cnt);
	for (i = 0; i < cnt; i++)
		stream_printf(GDKout, ",%d ", vars[i]);
	stream_printf(GDKout, "\n");
#endif

	empty = alloca(mb->vtop);
	for (i = 0; i < mb->vtop; i++)
		empty[i] = 0;
	for (i = 0; i < cnt; i++)
		empty[vars[i]] = 1;

	old = alloca(mb->ssize * sizeof(InstrPtr));
	memcpy((char*) old, mb->stmt, mb->ssize * sizeof(InstrPtr));

	setLifespan(mb);
	limit= mb->stop;
	/* memset((char*)mb->stmt,0,mb->ssize * sizeof(InstrPtr));
	mb->stop =0; */
	for (i = 0; i < limit; i++) {
		p = old[i];
		for (j = 0; j < p->retc; j++)
			if (empty[getArg(p, j)] && getLastUpdate(mb, getArg(p, j)) > i) {
#ifdef DEBUG_MAL_EMPTYSET
				stream_printf(GDKout, "reject emptyset %d\n", getArg(p, j));
#endif
				empty[getArg(p, j)] = 0;
			}
	}
	for (i = 0; i < limit; i++) {
		p = old[i];
		for (j = p->retc; j < p->argc; j++)
			if (empty[getArg(p, j)]) {
				/* decode operations */
				if (getName("bat", 3) == getModuleId(p)) {
					if (getName("insert", 6) == getFunctionId(p) || 
						getName("delete", 6) == getFunctionId(p) || 
						getName("append", 6) == getFunctionId(p)) {
						if (j == 2) {
							/* you don;t add anything */
							p->token = IGNOREsymbol;
							doAR++;
							break;
						}
					} else 
					if ( getName("reverse", 7) == getFunctionId(p) ){
						p->token = IGNOREsymbol;
						empty[getArg(p, 0)] = 1;
						doAR++;
						break;
					}
				} else if (getName("algebra", 7) == getModuleId(p)) {
					if (getName("markH", 5) == getFunctionId(p) || 
						getName("markT", 5) == getFunctionId(p)) {
						p->token = IGNOREsymbol;
						doAR++;
						empty[getArg(p, 0)] = 1;
						break;
					} else if (getName("exist", 4) == getFunctionId(p)) {
						/* always false */
						setModuleId(p, NULL);
						setFunctionId(p, NULL);
						p->argc = 1;
						p->token = ASSIGNsymbol;
						pushBit(mb, p, FALSE);
						doAR++;
						break;
					} else if (getName("select", 6) == getFunctionId(p) || 
								getName("uselect", 7) == getFunctionId(p) || 
								getName("like", 4) == getFunctionId(p) || 
								getName("sortH", 5) == getFunctionId(p) || 
								getName("sortT", 5) == getFunctionId(p) ||
								getName("sortHT", 6) == getFunctionId(p) || 
								getName("sortTH", 6) == getFunctionId(p) || 
								getName("unique", 6) == getFunctionId(p) || 
								getName("sunique", 7) == getFunctionId(p) || 
								getName("kunique", 7) == getFunctionId(p) ||
								getName("tunique", 7) == getFunctionId(p) || 
								getName("intersect", 9) == getFunctionId(p) || 
								getName("sintersect", 10) == getFunctionId(p) || 
								getName("kintersect", 10) == getFunctionId(p) ||
								getName("fragment", 8) == getFunctionId(p)) {

								/* result is empty */
								p->token = IGNOREsymbol;
								if (getLastUpdate(mb, getArg(p, 0)) == i)
									empty[getArg(p, 0)] = 1;
					} else if (getName("difference", 10) == getFunctionId(p) || 
								getName("kdifference", 11) == getFunctionId(p)
						) {
						if (getLastUpdate(mb, getArg(p, 0)) == i) {
							/* always empty */
							setModuleId(p, NULL);
							setFunctionId(p, NULL);
							p->argc = 2;
							p->token = ASSIGNsymbol;
							if (j == 1)
								empty[getArg(p, 0)] = 1;
							doAR++;
						}
						break;
					} else if (getName("sunion", 6) == getFunctionId(p) || 
								getName("kunion", 6) == getFunctionId(p) || 
								getName("union", 5) == getFunctionId(p)) {
						/* always identity */
						setModuleId(p, NULL);
						setFunctionId(p, NULL);
						p->argc = 2;
						p->token = ASSIGNsymbol;
						if (j == 1)
							p->argv[1] = p->argv[2];
						if (empty[p->argv[1]])
							empty[p->argv[0]] = 1;
						doAR++;
						break;
					} else if ( getName("join", 4) == getFunctionId(p) || 
								getName("semijoin", 8) == getFunctionId(p) ||
								getName("fetchjoin", 9) == getFunctionId(p) ||
								getName("mergejoin", 9) == getFunctionId(p) || 
								getName("indexjoin", 9) == getFunctionId(p) || 
								getName("hashjoin", 8) == getFunctionId(p) || 
								getName("cartesianproduct", 16) == getFunctionId(p)
								) {
						/* always identity */
						setModuleId(p, NULL);
						setFunctionId(p, NULL);
						p->argc = 2;
						p->token = IGNOREsymbol;
						empty[p->argv[0]] = 1;
						doAR++;
						break;
					} else if (getName("count", 5) == getFunctionId(p)) {
						/* count propagation */
						setModuleId(p, NULL);
						setFunctionId(p, NULL);
						p->argc = 1;
						p->token = ASSIGNsymbol;
						pushLng(mb,p,0);
						doAR++;
						break;
					}
					/* CONTINUE WITH THETA JOIN */
				}
			}
	}
	if (doAR && mb->errors == 0) {
#ifdef DEBUG_MAL_EMPTYSET
		printf("MID STAGE doAR=%d\n", doAR);
		printFunction(GDKout, mb, LIST_MAL_ALL);
#endif
		ARoptimizer(mb, 0, 0);
		DCoptimizer(mb, 0, 0);
	}

	optimizerCheck(mb, "mal.emptyset", 1, GDKusec() - clk);
#ifdef DEBUG_MAL_EMPTYSET
	printf("FINAL STAGE errors=%d\n", mb->errors);
	printFunction(GDKout, mb, LIST_MAL_ALL);
#endif
	return MAL_SUCCEED;
}

@- Optimizer code wrapper
@c
mal_export str QOTESoptimizer(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
str QOTESoptimizer(MalBlkPtr mb, MalStkPtr stk, InstrPtr p){
	str	modnme;
	str	fcnnme;
	Module  scope=NULL;
	Symbol s= NULL;
	Client c= MCgetClient();
	lng clk= GDKusec();

	/* handle the empty argument list */
	if( p->argc== 1){
		/* setLifespan(mb); they should do it themselves*/
		optimizerInit();
		ESoptimizer(mb, stk, p);
		return MAL_SUCCEED;
	}
	if( stk != 0){
		modnme= (str)getArgValue(stk,p,1);
		fcnnme= (str)getArgValue(stk,p,2);
	} else {
		modnme= getArgDefault(mb,p,1);
		fcnnme= getArgDefault(mb,p,2);
	}
	scope = findModule(c->nspace,putName(modnme,strlen(modnme)) );
	if( scope)
		s= findSymbolInModule(scope,putName(fcnnme,strlen(fcnnme)));

	if( s == NULL) {
		char buf[1024];
		snprintf(buf,1024, "Could not find %s.%s\n",modnme,fcnnme);
		return throwMessage("optimizer.emptySet",buf);
	}
	
	if( s->def->errors == 0){
		optimizerInit();
		ESoptimizer(s->def,0,0);
		optimizerCheck(s->def,"emptySet",1,GDKusec()-clk);
	}
	removeInstruction(mb, p);
	return MAL_SUCCEED;
}
@}
