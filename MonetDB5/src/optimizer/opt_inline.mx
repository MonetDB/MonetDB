@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2008 CWI.
@' All Rights Reserved.

@f opt_inline
@a M. Kersten
@subsection Function Inliners
The routine @sc{optimizer.inline()} searches MAL function definitions
whose property @{inline@}  is set. In addition, all MAL function calls
whose primary target variable carry the @{inline@} property are inlined
as well.
The code is expanded inline using the macro processor.

The inline optimizer processes all instructions, thereby
causing recursive inlined functions to appear as well.
@{
@mal
pattern optimizer.inline():str
address OPTinline;
pattern optimizer.inline(mod:str, fcn:str):str
address OPTinline
comment "Expand inline functions";

@h
#ifndef _OPT_INLINE_
#define _OPT_INLINE_
#include "opt_prelude.h"
#include "opt_support.h"
#include "mal_interpreter.h"
#include "opt_macro.h"

/* #define DEBUG_OPT_INLINE     show partial result */

@c
#include "mal_config.h"
#include "opt_inline.h"

extern int OPTinlineMultiplex(MalBlkPtr mb, InstrPtr p);

int
OPTinlineImplementation(MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	int i;
	InstrPtr q,sig;
	int actions = 0;
	(void) p;

	for (i = 1; i < mb->stop; i++) {
		q = getInstrPtr(mb, i);
		if( q->blk ){
			sig = getInstrPtr(q->blk,0);
@-
Time for inlining functions that are used in multiplex operations.
They are produced by SQL compiler.
@c
#ifdef DEBUG_OPT_INLINE
			stream_printf(GDKout,"check inline function\n");
			printInstruction(GDKout,mb,q,LIST_MAL_ALL);
			printInstruction(GDKout,q->blk,sig,LIST_MAL_ALL);
#endif
			if( getModuleId(q) == malRef &&
				getFunctionId(q)== multiplexRef &&
				OPTinlineMultiplex(mb,q)){
#ifdef DEBUG_OPT_INLINE
					stream_printf(GDKout,"multiplex inline function\n");
					printInstruction(GDKout,mb,q,LIST_MAL_ALL);
#endif
			    varSetProp(mb, getArg(q,0), inlineProp, op_eq, NULL);
			} else
@-
Check if the function definition is tagged as being inlined.
@c
			if (sig->token == FUNCTIONsymbol &&
			    varGetProp(q->blk, getArg(sig, 0), inlineProp) != NULL) {
				(void) inlineMALblock(mb,i,q->blk);
				i--;
				actions++;
#ifdef DEBUG_OPT_INLINE
				stream_printf(GDKout,"inline function at %d\n",i);
				printFunction(GDKout, mb, LIST_MAL_ALL);
#endif
			} else 
@-
Check if the local call is tagged as being inlined.
@c
			if (varGetProp(mb, getArg(q,0), inlineProp) != NULL) {
				inlineMALblock(mb,i,q->blk);
				i--;
				actions++;
#ifdef DEBUG_OPT_INLINE
				stream_printf(GDKout,"inlined called at %d\n",i);
				printFunction(GDKout, mb, LIST_MAL_ALL);
#endif
			} 
		}
	}
	(void)stk;
	return actions;
}


int OPTinlineMultiplex(MalBlkPtr mb, InstrPtr p){
	Symbol s;
	str mod,fcn;
	mod = VALget(&getVar(mb, getArg(p, 1))->value);
	fcn = VALget(&getVar(mb, getArg(p, 2))->value);
	if( (s= findSymbol(mod,fcn)) ==0 )
		return FALSE;
@-
Before we decide to propagate the inline request
to the multiplex operation, we check some basic properties
of the target function. Moreover, we apply the inline optimizer
to the target function as well.
This code should be protected against overflow due to recursive calls.
In general, this is a hard problem. For now, we just expand.
@c
	(void) OPTinlineImplementation(s->def, NULL, p);
	return varGetProp(s->def , getArg(getInstrPtr(s->def,0), 0),
				inlineProp) != NULL;
}
@include optimizerWrapper.mx
@h
@:exportOptimizer(inline)@
#endif
@c
#include "opt_statistics.h"
@:wrapOptimizer(inline,OPT_CHECK_ALL)@
@}
