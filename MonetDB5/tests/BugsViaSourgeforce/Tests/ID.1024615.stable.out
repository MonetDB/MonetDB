stdout of test 'ID.1024615` in directory 'tests/BugsViaSourgeforce` itself:


# 16:24:49 >  
# 16:24:49 >  Mtimeout -timeout 60 Mserver "--config=/ufs/niels/data/Linux-i686/etc/MonetDB.conf" --debug=10 --set "monet_mod_path=/ufs/niels/data/Linux-i686/lib/MonetDB" --set "gdk_dbfarm=/ufs/niels/data/Linux-i686/var/MonetDB/dbfarm" --set "sql_logdir=/ufs/niels/data/Linux-i686/var/MonetDB/log" --set mapi_port=46419 --set sql_port=54865 --set monet_prompt= --trace --dbname=mTests_tests_BugsViaSourgeforce  < ID.1024615.milS
# 16:24:49 >  

# Monet Database Server V4.3.19
# Copyright (c) 1993-2004, CWI. All rights reserved.
# Compiled for x86_64-redhat-linux-gnu/64bit; dynamically linked.
# config:/home/mk/monet5/Linux/etc/MonetDB5.conf
# dbfarm:/home/mk/monet5/Linux/var/MonetDB5/dbfarm
# dbname:mTests_tests_BugsViaSourgeforce
# Visit http://monetdb.cwi.nl for further information.
## Monet Mil to Mal compiler
#include mil;
#include mil_scenario;
## Copyright (c) 2001-2004, CWI. All rights reserved.
#
## Predefined code segment
##The compiler can not guarantee an accurate compilation,
##because MIL unlike MAL is a dynamically typed language.
##A few guidelines to maximize usefullness.
##- make the type of variables explicit, in particular 'nil'
##- upon advice of M2m to remap identifiers, change it in your program directly
##var b1 := bat(oid,str);
#	b1 := new(:oid,:str);
##b1.reverse().sort().reverse().print();
#	aa_a := reverse(b1,);
#	ba_a := sort(aa_a,);
#	ca_a := reverse(ba_a,);
#	da_a := print(ca_a,);
##b1.access(BAT_WRITE);
#	BAT_WRITE:= mil.take("BAT_WRITE");
#	ea_a := access(b1,BAT_WRITE);
##b1.reverse().sort().reverse().print();
#	fa_a := reverse(b1,);
#	ga_a := sort(fa_a,);
#	ha_a := reverse(ga_a,);
#	ia_a := print(ha_a,);
##var b2 := bat(void,str);
#	b2 := new(:void,:str);
##b2.seqbase(oid(10));
#	ja_a := oid(10);
#	ka_a := bat.setSequenceBase(b2,ja_a);
##b2.reverse().sort().reverse().print();
#	la_a := reverse(b2,);
#	ma_a := sort(la_a,);
#	na_a := reverse(ma_a,);
#	oa_a := print(na_a,);
##b2.access(BAT_WRITE);
#	pa_a := access(b2,BAT_WRITE);
##b2.reverse().sort().reverse().print();
#	qa_a := reverse(b2,);
#	ra_a := sort(qa_a,);
#	sa_a := reverse(ra_a,);
#	ta_a := print(sa_a,);
##var b3 := mirror(b2);
#	b3 := mirror(b2);
##b3.print();
#	ua_a := print(b3,);
##var b4 := b3.reverse().join(b2);
#	va_a := reverse(b3,);
#	b4 := join(va_a,b2);
##b4.print();
#	wa_a := print(b4,);
##b4.reverse().sort().reverse().print();
#	xa_a := reverse(b4,);
#	ya_a := sort(xa_a,);
#	ab_a := reverse(ya_a,);
#	bb_a := print(ab_a,);
##var b2 := bat(void,str);
#	b2 := new(:void,:str);
##b2.seqbase(oid(10));
#	cb_a := oid(10);
#	db_a := bat.setSequenceBase(b2,cb_a);
##var b3 := mirror(b2);
#	b3 := mirror(b2);
##var b4 := b3.reverse().join(b2);
#	eb_a := reverse(b3,);
#	b4 := join(eb_a,b2);
##b4.reverse().sort().reverse().print();
#	fb_a := reverse(b4,);
#	gb_a := sort(fb_a,);
#	hb_a := reverse(gb_a,);
#	ib_a := print(hb_a,);
##Identifer 'seqbase' mapped to 'bat.setSequenceBase'
#
function user.main():int;	# 0  (main:int)
# Copyright (c) 2001-2004, CWI. All rights reserved. 	# 1  (_32:str)
#Predefined code segment 	# 2  (_34:str)
#The compiler can not guarantee an accurate compilation, 	# 3  (_36:str)
#because MIL unlike MAL is a dynamically typed language. 	# 4  (_38:str)
#A few guidelines to maximize usefullness. 	# 5  (_40:str)
#- make the type of variables explicit, in particular 'nil' 	# 6  (_42:str)
#- upon advice of M2m to remap identifiers, change it in your program directly 	# 7  (_44:str)
#use the "mil_schema" for additional support routines 	# 8  (_46:str)
    mil.line("var b1 := bat(oid,str);");	# 9 MILline (_47:void)<-(_48:str)
    b1 := bbp.new(nil:oid,nil:str);	# 10 CMDBATnew (b1:bat[:oid,:str])<-(_50:oid)(_51:str)
    mil.line("b1.reverse().sort().reverse().print();");	# 11 MILline (_52:void)<-(_53:str)
    aa_a := bat.reverse(b1);	# 12 BKCreverse (aa_a:bat[:str,:oid])<-(b1:bat[:oid,:str])
    ba_a := algebra.sortH(aa_a);	# 13 ALGhsort (ba_a:bat[:str,:oid])<-(aa_a:bat[:str,:oid])
    ca_a := bat.reverse(ba_a);	# 14 BKCreverse (ca_a:bat[:oid,:str])<-(ba_a:bat[:str,:oid])
    da_a := io.print(ca_a);	# 15 IOprint_val (da_a:int)<-(ca_a:bat[:oid,:str])
    mil.line("b1.access(BAT_WRITE);");	# 16 MILline (_58:void)<-(_59:str)
    BAT_WRITE := mil.take("BAT_WRITE");	# 17 MILtake (BAT_WRITE:int)<-(_60:str)
    ea_a := bat.access(b1,BAT_WRITE);	# 18 BKCaccess (ea_a:bat[:oid,:str])<-(b1:bat[:oid,:str])(BAT_WRITE:int)
    mil.line("b1.reverse().sort().reverse().print();");	# 19 MILline (_62:void)<-(_53:str)
    fa_a := bat.reverse(b1);	# 20 BKCreverse (fa_a:bat[:str,:oid])<-(b1:bat[:oid,:str])
    ga_a := algebra.sortH(fa_a);	# 21 ALGhsort (ga_a:bat[:str,:oid])<-(fa_a:bat[:str,:oid])
    ha_a := bat.reverse(ga_a);	# 22 BKCreverse (ha_a:bat[:oid,:str])<-(ga_a:bat[:str,:oid])
    ia_a := io.print(ha_a);	# 23 IOprint_val (ia_a:int)<-(ha_a:bat[:oid,:str])
    mil.line("var b2 := bat(void,str);");	# 24 MILline (_67:void)<-(_68:str)
    b2 := bbp.new(nil:void,nil:str);	# 25 CMDBATnew (b2:bat[:void,:str])<-(_70:void)(_71:str)
    mil.line("b2.seqbase(oid(10));");	# 26 MILline (_72:void)<-(_73:str)
    ja_a := calc.oid(10);	# 27 CALCint2oid (ja_a:oid)<-(_75:int)
    ka_a := bat.setSequenceBase(b2,ja_a);	# 28 BKCsetSequenceBase (ka_a:bat[:void,:str])<-(b2:bat[:void,:str])(ja_a:oid)
    mil.line("b2.reverse().sort().reverse().print();");	# 29 MILline (_77:void)<-(_78:str)
    la_a := bat.reverse(b2);	# 30 BKCreverse (la_a:bat[:str,:void])<-(b2:bat[:void,:str])
    ma_a := algebra.sortH(la_a);	# 31 ALGhsort (ma_a:bat[:str,:void])<-(la_a:bat[:str,:void])
    na_a := bat.reverse(ma_a);	# 32 BKCreverse (na_a:bat[:void,:str])<-(ma_a:bat[:str,:void])
    oa_a := io.print(na_a);	# 33 IOprint_val (oa_a:int)<-(na_a:bat[:void,:str])
    mil.line("b2.access(BAT_WRITE);");	# 34 MILline (_83:void)<-(_84:str)
    pa_a := bat.access(b2,BAT_WRITE);	# 35 BKCaccess (pa_a:bat[:void,:str])<-(b2:bat[:void,:str])(BAT_WRITE:int)
    mil.line("b2.reverse().sort().reverse().print();");	# 36 MILline (_86:void)<-(_78:str)
    qa_a := bat.reverse(b2);	# 37 BKCreverse (qa_a:bat[:str,:void])<-(b2:bat[:void,:str])
    ra_a := algebra.sortH(qa_a);	# 38 ALGhsort (ra_a:bat[:str,:void])<-(qa_a:bat[:str,:void])
    sa_a := bat.reverse(ra_a);	# 39 BKCreverse (sa_a:bat[:void,:str])<-(ra_a:bat[:str,:void])
    ta_a := io.print(sa_a);	# 40 IOprint_val (ta_a:int)<-(sa_a:bat[:void,:str])
    mil.line("var b3 := mirror(b2);");	# 41 MILline (_91:void)<-(_92:str)
    b3 := bat.mirror(b2);	# 42 BKCmirror (b3:bat[:void,:void])<-(b2:bat[:void,:str])
    mil.line("b3.print();");	# 43 MILline (_94:void)<-(_95:str)
    ua_a := io.print(b3);	# 44 IOprint_val (ua_a:int)<-(b3:bat[:void,:void])
    mil.line("var b4 := b3.reverse().join(b2);");	# 45 MILline (_97:void)<-(_98:str)
    va_a := bat.reverse(b3);	# 46 BKCreverse (va_a:bat[:void,:void])<-(b3:bat[:void,:void])
    b4 := algebra.join(va_a,b2);	# 47 ALGjoin (b4:bat[:void,:str])<-(va_a:bat[:void,:void])(b2:bat[:void,:str])
    mil.line("b4.print();");	# 48 MILline (_101:void)<-(_102:str)
    wa_a := io.print(b4);	# 49 IOprint_val (wa_a:int)<-(b4:bat[:void,:str])
    mil.line("# next line produced an incorrect error \n");	# 50 MILline (_104:void)<-(_105:str)
    mil.line("# ERROR: CMDsort: returned BAT has unexpected head.\n");	# 51 MILline (_106:void)<-(_107:str)
    xa_a := bat.reverse(b4);	# 52 BKCreverse (xa_a:bat[:str,:void])<-(b4:bat[:void,:str])
    ya_a := algebra.sortH(xa_a);	# 53 ALGhsort (ya_a:bat[:str,:void])<-(xa_a:bat[:str,:void])
    ab_a := bat.reverse(ya_a);	# 54 BKCreverse (ab_a:bat[:void,:str])<-(ya_a:bat[:str,:void])
    bb_a := io.print(ab_a);	# 55 IOprint_val (bb_a:int)<-(ab_a:bat[:void,:str])
    mil.line("#mini mil example\n");	# 56 MILline (_112:void)<-(_113:str)
    mil.line("var b2 := bat(void,str);");	# 57 MILline (_114:void)<-(_115:str)
    b2 := bbp.new(nil:void,nil:str);	# 58 CMDBATnew (b2:bat[:void,:str])<-(_116:void)(_117:str)
    mil.line("b2.seqbase(oid(10));");	# 59 MILline (_118:void)<-(_119:str)
    cb_a := calc.oid(10);	# 60 CALCint2oid (cb_a:oid)<-(_121:int)
    db_a := bat.setSequenceBase(b2,cb_a);	# 61 BKCsetSequenceBase (db_a:bat[:void,:str])<-(b2:bat[:void,:str])(cb_a:oid)
    mil.line("var b3 := mirror(b2);");	# 62 MILline (_123:void)<-(_92:str)
    b3 := bat.mirror(b2);	# 63 BKCmirror (b3:bat[:void,:void])<-(b2:bat[:void,:str])
    mil.line("var b4 := b3.reverse().join(b2);");	# 64 MILline (_124:void)<-(_98:str)
    eb_a := bat.reverse(b3);	# 65 BKCreverse (eb_a:bat[:void,:void])<-(b3:bat[:void,:void])
    b4 := algebra.join(eb_a,b2);	# 66 ALGjoin (b4:bat[:void,:str])<-(eb_a:bat[:void,:void])(b2:bat[:void,:str])
    mil.line("# next line produced an incorrect error \n");	# 67 MILline (_126:void)<-(_105:str)
    mil.line("# ERROR: CMDsort: returned BAT has unexpected head.\n");	# 68 MILline (_127:void)<-(_107:str)
    fb_a := bat.reverse(b4);	# 69 BKCreverse (fb_a:bat[:str,:void])<-(b4:bat[:void,:str])
    gb_a := algebra.sortH(fb_a);	# 70 ALGhsort (gb_a:bat[:str,:void])<-(fb_a:bat[:str,:void])
    hb_a := bat.reverse(gb_a);	# 71 BKCreverse (hb_a:bat[:void,:str])<-(gb_a:bat[:str,:void])
    ib_a := io.print(hb_a);	# 72 IOprint_val (ib_a:int)<-(hb_a:bat[:void,:str])
#Identifer 'seqbase' mapped to 'bat.setSequenceBase' 	# 73  ($132:str)
end main;	# 74  
#var b1 := bat(oid,str);
#b1.reverse().sort().reverse().print();
#-----------------#
# t	tmp_28	  # name
# oid	str	  # type
#-----------------#
#-----------------#
# t	tmp_28	  # name
# oid	str	  # type
#-----------------#
#-----------------#
# t	tmp_30	  # name
# void	str	  # type
#-----------------#
#-----------------#
# t	tmp_30	  # name
# void	str	  # type
#-----------------#
#-----------------#
# h	tmp_31	  # name
# void	oid	  # type
#-----------------#
#-----------------#
# h	tmp_30	  # name
# oid	str	  # type
#-----------------#
#-----------------#
# h	tmp_31	  # name
# oid	str	  # type
#-----------------#
#-----------------#
# h	tmp_31	  # name
# oid	str	  # type
#-----------------#

# 22:47:53 >  
# 22:47:53 >  Done.
# 22:47:53 >  

