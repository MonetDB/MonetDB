stdout of test 'evenheight` in directory 'tests/by_Peter` itself:

#> Mtest:	milM evenheight milM
#> Mtest:	Mtimeout -timeout 210 Mserver -modulesilent -yaccsilent -d8 -db tests_by_Peter evenheight.milM
# Monet Database Server V4.1
# Copyright (c) 1993-1999, CWI & SION. All rights reserved.
# compiled for IRIX646.5/32bit on Fri Jan 14 01:04:33 MET 2000.
#script:evenheight.milM


# Monet Database Server V4.3.5
# Copyright (c) 1993-2002, CWI. All rights reserved.
# compiled for i686-pc-linux-gnu/32bit; dynamically linked.
# The main procedure is evenheight(bat_param,nranges) 
# it produces a new bat with an even-height remapping of tail-values.

# this computes the weighed midpoint of a range 'low'..'high'
# the weights are taken from the sorted histogram 'hst' 
#
proc compute_mid(bat hst, any  low, any  high) : void {
    var members := hst.reverse().select(low,high);
    var weighed := new(int, members.ttype(), members.count());
    var mid := nil.cast(hst.htype());
    var cum := 0;

    members@batloop() {
        cum := cum + $h;
        weighed.insert(cum, $t);
    }
    weighed@batloop() {
        mid := $t;
        if ($h >= (cum / 2)) break;
    }
    return mid;
}

# we construct an equal-height partitioning range for the tail columns
# of a bat. This partitioning range is represented by a new 'range-bat'.
# Each BUN in the range-bat represents 1 range. Its tail contains the maximum 
# range value (tails are sorted); its head contains the representative value.
#
# The below proc constructs such a range-bat iteratively using
# a histogram. This algorithms dynamically adapts the ideal 
# group-size 'ideal' to obtain a nicely balanced result.
#
proc range_bat(bat b, int n) : bat {
    var      histo := b.histogram().sort(); # sort it!
    var     ranges := new(b.ttype(), b.ttype(), (n*4)/3);
    var    cursize := 0;
    var items_left := b.count();
    var mid_h, last_h, first_h;

    histo@batloop() {
        var idealsize := items_left/n;
        if (cursize = 0) {
            first_h := $h; # the lowest element of the range
        }
        cursize := cursize + $t;
        if (cursize >= idealsize) {
            # ok, we must create a new group
            if ((cursize - idealsize) <= (idealsize - (cursize- $t))) {
                items_left := items_left - cursize;
	             mid_h := histo.compute_mid(first_h, $h);
                    last_h := $h;
                   cursize := 0;
            } else {
                # group would be too large with the current
                # element in it. Keep the current for the next grp.
                #
                items_left := items_left - (cursize - $t);
	             mid_h := histo.compute_mid(first_h, last_h);
                   first_h := $h;
                   cursize := $t;
            }
            # insert the new group description
            ranges.insert(mid_h, last_h);
            n := n - 1;
        }
        last_h := $h;
    }
    return ranges;
}

# use the range-bat to convert one value to its representative value.
proc convert_val(any v, any rng) : any {
        rng@batloop() {
		if ($t >= v) return $h;
	}
        return nil.cast(v.type());
}

# OVERALL USEABLE PROC
proc evenheight(bat b, int n) : bat {
        var rng := range_bat(b, n);
        print(rng); # print the range (for debugging purposes)
        return [convert_val](b, const rng);
}

# TESTING

var TheSize := 1000;

var def_tpe := new(int,int);
var i := 0;
while (i<TheSize) { def_tpe.insert(i,rand()); i:+=1; }

var a := [str](def_tpe.mark(100000@0)).reverse().mirror();
var b := a.range_bat(10);
var c := [int](b.reverse().mirror());
var d := [int](b.reverse());
print([-](c,d),b.reverse());
#-----------------------------------------#
# BAT:		  tmp_31| tmp_30	  #
# (str)		  (int)	| (str)		  #
#-----------------------------------------#
[ "100099@0",	  50,	  "100049@0"	  ]
[ "100199@0",	  50,	  "100149@0"	  ]
[ "100299@0",	  50,	  "100249@0"	  ]
[ "100399@0",	  50,	  "100349@0"	  ]
[ "100499@0",	  50,	  "100449@0"	  ]
[ "100599@0",	  50,	  "100549@0"	  ]
[ "100699@0",	  50,	  "100649@0"	  ]
[ "100799@0",	  50,	  "100749@0"	  ]
[ "100899@0",	  50,	  "100849@0"	  ]
[ "100999@0",	  50,	  "100949@0"	  ]

var aa := a.evenheight(9);
#---------------------------------#
# BAT:		  tmp_33	  #
# (str)		  (str)		  #
#---------------------------------#
[ "100054@0",	  "100110@0"	  ]
[ "100165@0",	  "100221@0"	  ]
[ "100276@0",	  "100332@0"	  ]
[ "100387@0",	  "100443@0"	  ]
[ "100498@0",	  "100554@0"	  ]
[ "100609@0",	  "100665@0"	  ]
[ "100720@0",	  "100776@0"	  ]
[ "100831@0",	  "100887@0"	  ]
[ "100943@0",	  "100999@0"	  ]

var z1 := new(int,int);
var z2 := new(int,int);
i := 0;
while (i<TheSize) { z1.insert(i,rand()); z2.insert(i,i); i:+=1; }

printf("#~BeginVariableOutput~#\n"); var z1z:=z1.evenheight(8); printf("#~EndVariableOutput~#\n");
#~BeginVariableOutput~#
#---------------------------------#
# BAT:		  tmp_34	  #
# (int)		  (int)		  #
#---------------------------------#
[ 107939561,	  242639747	  ]
[ 365862802,	  505185185	  ]
[ 625843881,	  805251743	  ]
[ 942581876,	  1073781763	  ]
[ 1196774315,	  1346941484	  ]
[ 1482841197,	  1607774548	  ]
[ 1750829613,	  1887665154	  ]
[ 2003980519,	  2145854098	  ]
#~EndVariableOutput~#

var z2z:=z2.evenheight(8);
#-----------------#
# BAT:	  tmp_37  #
# (int)	  (int)	  #
#-----------------#
[ 61,	  124	  ]
[ 186,	  249	  ]
[ 311,	  374	  ]
[ 436,	  499	  ]
[ 561,	  624	  ]
[ 686,	  749	  ]
[ 811,	  874	  ]
[ 936,	  999	  ]

quit();

# 17:07:36 >  
# 17:07:36 >  Done.
# 17:07:36 >  

