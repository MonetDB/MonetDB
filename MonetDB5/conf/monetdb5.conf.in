# The contents of this file are subject to the MonetDB Public License
# Version 1.1 (the "License"); you may not use this file except in
# compliance with the License. You may obtain a copy of the License at
# http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
#
# Software distributed under the License is distributed on an "AS IS"
# basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
# License for the specific language governing rights and limitations
# under the License.
#
# The Original Code is the MonetDB Database System.
#
# The Initial Developer of the Original Code is CWI.
# Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
# Copyright August 2008-2010 MonetDB B.V.
# All Rights Reserved.


# Configuration file for MonetDB Version 5 server

# The configuration file is an integral part of a database store
# and aimed to initialize the server and service components.
# This startup file is read by the GDK kernel to set system wide parameters.

# It may be inspected by application/scripts for specific settings,
# but such client side configurations are better packed in their
# own structure.

# Absolute path where MonetDB is installed
prefix=@prefix@
exec_prefix=@exec_prefix@

# GDK Section
#============
# All databases are stored as a directory under the directory
# given below.  Use this value to change the overall location
# of your data.
gdk_dbfarm=@localstatedir@@DIRSEP@MonetDB5@DIRSEP@dbfarm

# MonetDB can only handle one database at a time.  When you start an
# mserver5 manually without specifying the database name yourself, the
# following database name is used.
gdk_dbname=demo

# The options below deal with various aspects of memory usage behaviour.
# If you don't know what these values mean, you should leave them alone.

# gdk_mem_bigsize will be initialized in GDKinit
# memory chunks of size >= gdk_mem_bigsize (in bytes) will be mmaped anonymously
#gdk_mem_bigsize=262144
# for 32 bit systems try to claim 3G of (virtual) memory;
#gdk_vmtrim=yes
# set to "no" to disable the vmtrim thread.

# valgrind issues:
# for 32 bit systems it tries claim 3G of (virtual) memory
# set the alloca map to "no" to run mserver with valgrind;
# also, you need to tell valgrind to use 8-byte alignment, hence:
# "valgrind --alignment=8 mserver --set gdk_alloc_map=no ..."
gdk_alloc_map=no

# the kernel can be used in embedded situations (don't set this yourself)
gdk_embedded=no

# You can enable debug for specific parts.  By default debug is
# switched off.
gdk_debug=0
# possible values: (can be a combination of)
#       1 = thread-specific debug output
#       2 = CHECKMASK    = property enforcing on new BATs
#       4 = MEMMASK      = memory allocation
#       8 = PROPMASK     = property checking on all values: tells about
#                          wrongly set properties
#      16 = IOMASK       = major IO activity
#      32 = BATMASK      = BAT handling
#      64 = PARSEMASK    = parser debugging
#     128 = PARMASK      = Thread management
#     256 = TRGMASK      = Event management 
#     512 = TMMASK       = Transaction management
#    1024 = TEMMASK      = Locks and Triggers
#    2048 = DLMASK       = Dynamic loading
#    4096 = PERFMASK     = BBP Performance (?)
#    8192 = DELTAMASK    = Delta debugging (?)
#   16384 = LOADMASK     = Module loading
#   32768 = YACCMASK     = Yacc specific error messages
#   65536 = obsolete     = tcpip (??)
#  131072 = obsolete     = monet_multiplex: setaggr debugging (??)
#  262144 = obsolete     = \
#  524288 = obsolete     =   ddbench (???)
# 1048576 = obsolete     = /
# 2097152 = ALGOMASK     = show join/select algorithm chosen
# 4194304 = ESTIMASK     = show result size estimations (for join,select)
# 8388608 = XPROPMASK    = extended property checking: tells also about
#                          not set properties
#16777216 = JOINPROPMASK = disable property checking with join & outerjoin
#                          (e.g., for performance measurements)
#33554432 = DEADBEEFMASK = disable "cleaning" of freed memory in GDKfree()
#                          (e.g., for performance measurements)
#67108864 = ALLOCMASK    = exhaustive GDK malloc & free tracing for debugging
#                          (GDK developers, only)
#134217728 = OPTMASK     = trace the actions, decisions and effects of MAL optimizers
# 
# Mserver 5 recognizes a series of command line names instead:
# --threads ( 1 | PARMASK)
# --memory (MEMMASK )
# --properties (CHECKMASK | PROPMASK | BATMASK )
# --io (IOMASK | PERFMASK )
# --transactions ( TMMASK | DELTAMASK | TEMMASK)
# --modules (DLMASK | LOADMASK)
# --algorithms (ALGOMASK | ESTIMASK)
# --xproperties (XPROPMASK )
# --performance (JOINPROPMASK | DEADBEEFMASK)
# --optimizers (OPTMASK)


# Monet Section
#==============
# monet_admin=adm			#administrator user name
# Prompt when using MAL interface
# monet_prompt=>
# Where do the MonetDB modules reside? The second path is for windows dlls.
monet_mod_path=@libdir@@DIRSEP@MonetDB5@PATHSEP@@libdir@@DIRSEP@MonetDB5@DIRSEP@lib@PATHSEP@@libdir@@DIRSEP@MonetDB5@DIRSEP@bin
# Start mserver in daemon mode, or start with MAL interactive interface?
monet_daemon=no
# Display version and copyright information upon startup?
monet_welcome=yes
# Where is the file that stores the secret key to unlock the password
# vault?  The file is read up to the first null-byte ('\0'), so you can
# padd the file with trailing null-bytes to obfuscate the key length.
# You can easily generate some key by running pwgen and adding a few of
# the passwords generated.  Make sure not to make the key too small.
# If you leave this unset, some default key is used.
# Note: changing this key for an existing database makes that database
# unusable as noone is any longer able to login.
# If you use Merovingian, a per-database vault key is used and this
# setting ignored.
#monet_vault_key=@sysconfdir@@DIRSEP@monetdb.secret


# Merovingian section
#====================================
# Merovingian logs messages and errors by default to the stdout and
# stderr channels on the console.  By setting one or both of the
# variables below, one can specify messages and/or errors to be logged
# to a file instead.  It is legitimate to have both mero_msglog and
# mero_errlog pointing to the same file, as in the default below.
# Unsetting below defaults will make merovingian log to the screen.
mero_msglog=@localstatedir@@DIRSEP@log@DIRSEP@MonetDB@DIRSEP@merovingian.log
mero_errlog=@localstatedir@@DIRSEP@log@DIRSEP@MonetDB@DIRSEP@merovingian.log
#
# Merovingian forks itself to detach into the background.  It stores its
# pid in the following file, which can be used to stop Merovingian
# again.
mero_pidfile=@localstatedir@@DIRSEP@run@DIRSEP@MonetDB@DIRSEP@merovingian.pid
#
# In normal use, Merovingian replaces an mserver, and hence listens for
# connections on the same port as an mserver would do.  For certain
# configs, however, it may be more suitable to use an alternate port,
# which can be specified here.
#mero_port=50000
#
# mservers that were started by Merovingian are shut down when the
# Merovingian is shut down.  This behaviour is desirable if the
# Merovingian is ran as daemon process that represents MonetDB, such as
# in an init.d script.  Setting the time-out value below to a positive
# non-zero value will shut down each mserver that was started with a
# given time-out in seconds.  If the time-out expires, the mserver is
# killed using the SIGKILL signal.  A time-out value of 0 means that no
# mserver is shut down, meaning they will live on after the Merovingian
# has shut down.  The default is to shut down all started mservers with
# a time-out of 60 seconds.
#mero_exittimeout=0
#
# Merovingian has two ways in which it can "attach" a connecting client
# to the target database.  The first method uses a redirect to the
# responsible mserver process, the second method proxies the client to
# the mserver over Merovingian.  While the first is more efficient, it
# requires the connecting client to be able to connect to the mserver.
# In many settings this may be undesirable or even impossible, since
# a wide range of open ports are necessary for this.  In such case the
# proxy behaviour of Merovingian is a good solution, which also allows a
# Merovingian on the border of a network to serve requests to nodes in
# the local (unreachable) network.  Hence, proxy mode is the default.
# Uncomment the value below to use the first method of using redirects.
#mero_doproxy=no
#
# Neighbour discovery allows Merovingian to discover other running
# Merovingian processes in the local network.  Merovingian publishes
# locally available databases to others periodically.  The interval used
# here depends on the time-to-live of the databases before they need to
# get refreshed.  The default is 10 minutes, which should keep traffic
# in your network fairly low.  If you add and/or remove databases often,
# you may want to decrease this value.
#mero_discoveryttl=600
#
# Neighbour discovery is done using UDP broadcasts on the port set by
# mero_discoveryport.  It's value defaults to the value of mero_port,
# which usually is 50000.  Setting this value to 0 disables the
# neighbour discovery service entirely.
#mero_discoveryport=50000
#
# Each Merovingian can be controlled by monetdb(1).  By default,
# Merovingian binds to a local UNIX domain socket which allows a local
# monetdb(1) to connect based on the UNIX file system permissions.
# Merovingian can also listen on a TCP socket to serve requests from a
# monetdb(1) elsewhere.  If mero_controlport is set, Merovingian listens
# to that port for remote control commands.  This is an all or nothing
# scenario, hence any remote monetdb(1) can create, destroy, etc.  As a
# little protective measure, the file
# @localstatedir@@DIRSEP@MonetDB5@DIRSEP@dbfarm@DIRSEP@.merovingian_pass
# contains the passphrase that a remote monetdb(1) needs to issue to be
# able to perform any command.  For this file the same rules hold as for
# the monet_vault_key file.  If this file is missing, Merovingian will
# attempt to create it with a random password.  If the file cannot be
# opened for some reason, Merovingian will not start.
mero_controlport=50001


# MAL section
# Monet Virtual Machine
#====================================
mal_init=@libdir@@DIRSEP@MonetDB5/mal_init.mal
mal_listing = 2 
#    1 = List the original input
#    2 = List the MAL instruction
#    4 = List the MAL type information
#    8 = List the MAL UDF type
#    16 = List the MAL properties
#    32 = List the hidden details
#    64 = List the bat tuple count

# Monet Application Interface Section
#====================================
mapi_port=50000       # default port to address an mserver
mapi_autosense=false  # if set to 'true': automatically find a free port
                      # starting the search at mapi_port and going up
mapi_open=false       # should be set to 'true' to allow for 
                      # remote access to a server

# SQL Interface Section
#====================================
# The SQL debug level (should be disabled for normal use)
# sql_debug=0

# The default SQL optimizer pipeline can be set per server.  See the
# optpipe setting in monetdb(1) when using merovingian.  During SQL
# initialization, the optimizer pipeline is checked against the
# dependency information maintained in the optimizer library to ensure
# there are no conflicts and at least the pre-requisite optimizers are
# used.  The setting of sql_optimizer can be either the list of
# optimizers to run, or one or more variables containing the optimizer
# pipeline to run.  The latter is provided for readability purposes
# only.
#
# The minimal pipeline necessary by the server to operate correctly:
# sql_optimizer=inline,remap,deadcode,multiplex

# Set and define the default pipeline
sql_optimizer=default_pipe
default_pipe=inline,remap,evaluate,costModel,coercions,emptySet,aliases,mergetable,deadcode,constants,commonTerms,joinPath,deadcode,reduce,garbageCollector,dataflow,history,multiplex

# experimental pipelines stressing various components

# Replication
replication_pipe=inline,remap,evaluate,costModel,coercions,emptySet,aliases,mergetable,deadcode,constants,commonTerms,joinPath,deadcode,reduce,garbageCollector,dataflow,history,replication,multiplex

# Accumulator
accumulator_pipe=inline,remap,evaluate,costModel,coercions,emptySet,aliases,mergetable,deadcode,constants,commonTerms,joinPath,deadcode,reduce,accumulators,garbageCollector,dataflow,history,multiplex

# The Recycle pipeline for Skyserver
recycler_pipe=inline,remap,evaluate,costModel,coercions,emptySet,aliases,deadcode,constants,commonTerms,joinPath,deadcode,recycle,reduce,garbageCollector,dataflow,history,multiplex

# The Cracking pipeline(s)
cracker_pipe=inline,remap,evaluate,costModel,coercions,emptySet,aliases,selcrack,deadcode,constants,commonTerms,joinPath,deadcode,reduce,garbageCollector,dataflow,history,multiplex

# The datacell pipeline
datacell_pipe=inline,remap,evaluate,costModel,coercions,emptySet,aliases,deadcode,constants,commonTerms,joinPath,datacell,deadcode,reduce,garbageCollector,dataflow,history,multiplex

# The Octopus pipeline for distributed processing (Merovingian enabled
# platforms only)
octopus_pipe=inline,remap,evaluate,costModel,coercions,emptySet,mitosis,aliases,mergetable,deadcode,constants,commonTerms,joinPath,octopus,deadcode,reduce,garbageCollector,dataflow,history,multiplex

# The Mitosis-mergetable-reorder pipeline, aimed at better variable
# access locality
mitosis_pipe=inline,remap,evaluate,costModel,coercions,emptySet,mitosis,aliases,mergetable,deadcode,constants,commonTerms,joinPath,reorder,deadcode,reduce,garbageCollector,dataflow,history,multiplex
