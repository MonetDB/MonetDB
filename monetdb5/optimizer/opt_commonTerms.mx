@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.monetdb.org/Legal/MonetDBLicense

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2011 MonetDB B.V.
All Rights Reserved.
@

@f opt_commonTerms
@a M. Kersten
@{
@mal
pattern optimizer.commonTerms():str
address OPTcommonTerms;
pattern optimizer.commonTerms(mod:any_1, fcn:any_2):str
address OPTcommonTerms
comment "Common sub-expression optimizer"
@h
#ifndef _OPT_COMMONTERMS_
#define _OPT_COMMONTERMS_
#include "opt_prelude.h"
#include "opt_support.h"


@:exportOptimizer(commonTerms)@

#define OPTDEBUGcommonTerms  if ( optDebug & (1 <<DEBUG_OPT_COMMONTERMS) )

#endif
@c
#include "monetdb_config.h"
#include "opt_commonTerms.h"
#include "mal_exception.h"
@}
@- Common Subexpression Elimination
Common subexpression elimination merely involves a scan through the 
program block to detect re-curring statements.
The key problem to be addressed is to make sure that the parameters involved
in the repeatative instruction are invariant. 

The analysis of @sc{optimizer.commonTerms()}
is rather crude. All functions with possible side-effects on
their arguments should have been marked as 'unsafe'.
Their use within a MAL block breaks the dataflow graph for all 
objects involved (BATs, everything kept in boxes).
@-
The common subexpression optimizer locates backwards the identical 
instructions. 
It stops as soon as it has found an identical one. Before we can replace the 
expression with the variable(s) of the previous one, we should assure that
we haven;t passed a non-empty barrier block.

@verbatim
    b:= bat.new(:int,:int);
    c:= bat.new(:int,:int);
    d:= algebra.select(b,0,100);
    e:= algebra.select(b,0,100);
    k1:= 24;
    k2:= 27;
    l:= k1+k2;
    l2:= k1+k2;
    l3:= l2+k1;
    optimizer.commonTerms();
@end verbatim
is translated into the code block where the first two instructions 
are not common, because they have side effects.
@verbatim
    b := bat.new(:int,:int);
    c := bat.new(:int,:int);
    d := algebra.select(b,0,100);
    e := d;
    l := calc.+(24,27);
    l3 := calc.+(l,24);
@end verbatim
@{
The current implementation is rather expensive nested-loop algorithm,
which does not perform well for large MAL blocks.
The search is improved significantly by prefiltering on the
function name and not searching beyond the last assignment to
its arguments. Variables can be assigned a variable
multiple times, which complicates the code a little.

The common term removal creates opportunities for alias removal,
which in turn could lead to common terms to be detected.

Note, we skip the first instruction because it always signifies the signature.
The last instruction signifies the end.

Pathological case require alias removal also to find dependents.
@verbatim
a:= e();
b:= e();
c:= f(a);
d:= f(b);
@end verbatim

Caveat. A lot of time was lost due to constants that are indistinguisable 
at the surface level. It may miss common expressions if their constants
are introduced too far apart in the MAL program.
@c
static int
OPTcommonTermsImplementation(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int i, j, k, barrier= 0, last;
	InstrPtr p, q;
	int actions = 0;
	int limit, slimit;
	int *alias;
	InstrPtr *old;
	int *lastassigned;

	(void) cntxt;
	(void) stk;
	(void) pci;
	lastassigned = (int*) GDKzalloc(sizeof(int) * mb->vtop);
	if ( lastassigned == NULL)
		return 0;
	alias = (int*) GDKmalloc(sizeof(int) * mb->vtop);
	if ( alias == NULL){
		GDKfree(lastassigned);
		return 0;
	}
	for ( k=0;k<mb->vtop; k++)
		alias[k]=k;

	old = mb->stmt;
	limit = mb->stop;
	slimit = mb->ssize;
	if ( newMalBlkStmt(mb, mb->ssize) < 0){
		GDKfree(alias);
		GDKfree(lastassigned);
		return 0; 
	}

	for ( i = 0; i < limit; i++) {
		p = old[i];

		for ( k = 0; k < p->argc; k++)
			getArg(p,k) = alias[getArg(p,k)];

		if ( hasSideEffects(p, TRUE)  || isUpdateInstruction(p))
			for ( k = p->retc; k < p->argc; k++)
				lastassigned[getArg(p,k)] = i;
@-
We have to also look for first 'assignments' of constant arguments.
Constants should be ignored when it comes to building a barrier for
searching common terms.

We look back in the code base to determine a candidate for
replacement. We don't have to look further back then the last
relevant assignment.
@c
		last=  0;
		for (j = p->retc; j<p->argc; j++)
			if (lastassigned[getArg(p,j)]> last)
				last= lastassigned[getArg(p,j)];

		for ( k = p->retc; k < p->argc; k++)
			if ( isVarConstant(mb,getArg(p,k)) && lastassigned[getArg(p,k)] == 0 )
				lastassigned[getArg(p,k)]= last ? last : i;

		for ( k = 0; k < p->retc; k++)
			lastassigned[getArg(p,k)]=i;

		pushInstruction(mb,p);
@-
Any non-empty barrier block signals the end of this optimizer,
the impact of the block can affect the common code.
@c
		barrier |= (p->barrier== BARRIERsymbol || p->barrier== CATCHsymbol) && old[i+1]->barrier!=EXITsymbol;
@-
Also block further optimization when you have seen an assert().
This works particularly for SQL, because it is not easy to track
the BAT identifier aliases to look for updates. The sql.assert
at least tells us that an update is planned.
Like all optimizer decisions, it is safe to stop.
@c
		barrier |= getFunctionId(p) == assertRef;
		if (p->token == ENDsymbol){
			/* wrap up the remainder */
			for(i++; i<limit; i++)
				if( old[i])
					pushInstruction(mb,old[i]);
			break;
		}
		if (p->token == NOOPsymbol || p->token == ASSIGNsymbol || barrier || p->retc == p->argc) {
#ifdef DEBUG_OPT_COMMONTERMS_MORE
				mnstr_printf(cntxt->fdout, "COMMON SKIPPED[%d] %d %d\n",i, barrier, p->retc == p->argc);
#endif
			continue;
		}

#ifdef DEBUG_OPT_COMMONTERMS_MORE
		mnstr_printf(cntxt->fdout,"#CANDIDATE[%d] last= %d ",i,last);
		printInstruction(cntxt->fdout, mb, 0, p, LIST_MAL_ALL);
#endif
		for (j = i - 1; j >= last; j--) 
			if ( (q=getInstrPtr(mb,j))->fcn == p->fcn && !hasSideEffects(q, TRUE) && !isUpdateInstruction(p)){
#ifdef DEBUG_OPT_COMMONTERMS_MORE
			mnstr_printf(cntxt->fdout,"#CANDIDATE %d, %d  %d %d lookback %d ", i, j, 
				hasSameSignature(mb, p, q), 
				hasSameArguments(mb, p, q), last);
				printInstruction(cntxt->fdout, mb, 0, q, LIST_MAL_ALL);
				mnstr_printf(cntxt->fdout," :%d %d %d=%d %d %d %d %d %d\n", 
					q->token != ASSIGNsymbol ,
					lastassigned[getArg(q,0)],i,
					!hasCommonResults(p, q), 
					!hasSideEffects(q, TRUE),
					!isUpdateInstruction(q),
					isLinearFlow(q),
					isLinearFlow(p));
#endif
				if (safetyBarrier(p, q) ){
#ifdef DEBUG_OPT_COMMONTERMS_MORE
					mnstr_printf(cntxt->fdout,"#safetybarrier reached\n");
#endif
					break;
				}
@-
Simple assignments are not replaced either. They should be
handled by the alias removal part. All arguments should
be assigned their value before instruction p.
@c
				if (hasSameSignature(mb, p, q) && 
					hasSameArguments(mb, p, q) && 
					!hasCommonResults(p, q) && 
					isLinearFlow(p) &&
					isLinearFlow(q)  
				   ) {
#ifdef DEBUG_OPT_COMMONTERMS_MORE
						mnstr_printf(cntxt->fdout, "Found a common expression " "%d <-> %d\n", j, i);
						printInstruction(cntxt->fdout, mb, 0, q, LIST_MAL_ALL);
#endif
					clrFunction(p);
					p->argc = p->retc;
					for (k = 0; k < q->retc; k++){
						lastassigned[getArg(p,k)] = lastassigned[getArg(q,k)];
						alias[getArg(p,k)] = getArg(q,k);
						p= pushArgument(mb,p, getArg(q,k));
					}
#ifdef DEBUG_OPT_COMMONTERMS_MORE
						mnstr_printf(cntxt->fdout, "COMMON MODIFIED EXPRESSION %d -> %d last %d\n",getArg(p,k) , alias[getArg(p,k)], lastassigned[getArg(p,k)]);
						printInstruction(cntxt->fdout, mb, 0, p, LIST_MAL_ALL);
#endif
					actions++;
					break; /* end of search */
				}
			}
#ifdef DEBUG_OPT_COMMONTERMS_MORE
			else if ( hasSideEffects(q, TRUE) || isUpdateInstruction(p)){
				mnstr_printf(cntxt->fdout, "COMMON SKIPPED %d %d\n", hasSideEffects(q, TRUE) , isUpdateInstruction(p));
				printInstruction(cntxt->fdout, mb, 0, q, LIST_MAL_ALL);
			}
#endif
	}
	for(; i<slimit; i++)
		if( old[i])
			freeInstruction(old[i]);
	GDKfree(old);
	GDKfree(alias);
	GDKfree(lastassigned);
	DEBUGoptimizers
		mnstr_printf(cntxt->fdout,"#opt_commonTerms: %d statements catched\n",actions);
#ifdef DEBUG_OPT_COMMONTERMS_MORE
		mnstr_printf(cntxt->fdout,"#opt_commonTerms: %d statements catched\n",actions);
#endif
	return actions;
}

@include optimizerWrapper.mx
@c
#include "opt_statistics.h"
@:wrapOptimizer(commonTerms,OPT_CHECK_ALL)@
@}
