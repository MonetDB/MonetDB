@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.monetdb.org/Legal/MonetDBLicense

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2011 MonetDB B.V.
All Rights Reserved.
@

@f opt_commonTerms

@c
/*
 * @a M. Kersten
 */
@mal
pattern optimizer.commonTerms():str
address OPTcommonTerms;
pattern optimizer.commonTerms(mod:any_1, fcn:any_2):str
address OPTcommonTerms
comment "Common sub-expression optimizer"
@h
#ifndef _OPT_COMMONTERMS_
#define _OPT_COMMONTERMS_
#include "opt_prelude.h"
#include "opt_support.h"


@:exportOptimizer(commonTerms)@

/* #define DEBUG_OPT_COMMONTERMS_MORE */
#define OPTDEBUGcommonTerms  if ( optDebug & (1 <<DEBUG_OPT_COMMONTERMS) )

#endif
@c
#include "monetdb_config.h"
#include "opt_commonTerms.h"
#include "mal_exception.h"
/*
 * @- Common Subexpression Elimination
 * Common subexpression elimination merely involves a scan through the
 * program block to detect re-curring statements.
 * The key problem to be addressed is to make sure that the parameters involved
 * in the repeatative instruction are invariant.
 *
 * The analysis of @sc{optimizer.commonTerms()}
 * is rather crude. All functions with possible side-effects on
 * their arguments should have been marked as 'unsafe'.
 * Their use within a MAL block breaks the dataflow graph for all
 * objects involved (BATs, everything kept in boxes).
 * @-
 * The common subexpression optimizer locates backwards the identical
 * instructions.
 * It stops as soon as it has found an identical one. Before we can replace the
 * expression with the variable(s) of the previous one, we should assure that
 * we haven;t passed a non-empty barrier block.
 *
 * @verbatim
 *     b:= bat.new(:int,:int);
 *     c:= bat.new(:int,:int);
 *     d:= algebra.select(b,0,100);
 *     e:= algebra.select(b,0,100);
 *     k1:= 24;
 *     k2:= 27;
 *     l:= k1+k2;
 *     l2:= k1+k2;
 *     l3:= l2+k1;
 *     optimizer.commonTerms();
 * @end verbatim
 * is translated into the code block where the first two instructions
 * are not common, because they have side effects.
 * @verbatim
 *     b := bat.new(:int,:int);
 *     c := bat.new(:int,:int);
 *     d := algebra.select(b,0,100);
 *     e := d;
 *     l := calc.+(24,27);
 *     l3 := calc.+(l,24);
 * @end verbatim
 * The common term removal creates opportunities for alias removal,
 * which in turn could lead to common terms to be detected.
 *
 * Pathological case require alias removal also to find dependents.
 * @verbatim
 * a:= e();
 * b:= e();
 * c:= f(a);
 * d:= f(b);
 * @end verbatim
 *
 * A method is to keep a link to all instructions based on one (the first)
 * of the arguments. This gives a good starting point for attempting a match.
 * This walk backward analysis should be terminated when we hit a barrier.
 *
 * Caveat. A lot of time was lost due to constants that are indistinguisable
 * at the surface level. It may miss common expressions if their constants
 * are introduced too far apart in the MAL program.
 * It requires the constant optimizer to be ran first.
 */
static int
OPTcommonTermsImplementation(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int i, j, k, prop, candidate, barrier= 0;
	InstrPtr p, q;
	int actions = 0;
	int limit, slimit;
	int *alias;
	InstrPtr *old;
	int *list;	
	/* link all final constant expressions in a list */
	/* it will help to find duplicate sql.bind calls */
	int cstlist=0;
	int *vars;

	(void) cntxt;
	(void) stk;
	(void) pci;
	alias = (int*) GDKzalloc(sizeof(int) * mb->vtop);
	list = (int*) GDKzalloc(sizeof(int) * mb->stop);
	vars = (int*) GDKzalloc(sizeof(int) * mb->vtop);
	if ( alias == NULL || list == NULL || vars == NULL){
		if(alias) GDKfree(alias);
		if(list) GDKfree(list);
		if(vars) GDKfree(vars);
		return 0;
	}

	old = mb->stmt;
	limit = mb->stop;
	slimit = mb->ssize;
	if ( newMalBlkStmt(mb, mb->ssize) < 0){
		GDKfree(alias);
		GDKfree(list);
		GDKfree(vars);
		return 0; 
	}

	for ( i = 0; i < limit; i++) {
		p = old[i];

		for ( k = 0; k < p->argc; k++)
		if ( alias[getArg(p,k)] )
			getArg(p,k) = alias[getArg(p,k)];

		/* Link the statement to the previous use, based on the last argument.*/
		if ( p->retc < p->argc ) {
			candidate = vars[getArg(p,p->argc-1)];
			if ( isVarConstant(mb, getArg(p,p->argc-1)) ){
				/* all instructions with constant tail are linked */
				list[i] = cstlist;
				cstlist = i;
			} else
				list[i]= vars[ getArg(p,p->argc-1) ];
			vars[getArg(p,p->argc-1)] = i;
		} else candidate = 0;

		pushInstruction(mb,p);
		if (p->token == ENDsymbol){
			/* wrap up the remainder */
			for(i++; i<limit; i++)
				if( old[i])
					pushInstruction(mb,old[i]);
			break;
		}
		/*
		 * @-
		 * Any non-empty barrier block signals the end of this optimizer,
		 * the impact of the block can affect the common code.
		 */
		barrier |= (p->barrier== BARRIERsymbol || p->barrier== CATCHsymbol) && old[i+1]->barrier!=EXITsymbol;
		/*
		 * @-
		 * Also block further optimization when you have seen an assert().
		 * This works particularly for SQL, because it is not easy to track
		 * the BAT identifier aliases to look for updates. The sql.assert
		 * at least tells us that an update is planned.
		 * Like all optimizer decisions, it is safe to stop.
		 */
		barrier |= getFunctionId(p) == assertRef;
		if (p->token == NOOPsymbol || p->token == ASSIGNsymbol || barrier /* || p->retc == p->argc */) {
#ifdef DEBUG_OPT_COMMONTERMS_MORE
				mnstr_printf(cntxt->fdout, "COMMON SKIPPED[%d] %d %d\n",i, barrier, p->retc == p->argc);
#endif
			continue;
		}

		/* from here we have a candidate to look for a match */
#ifdef DEBUG_OPT_COMMONTERMS_MORE
		mnstr_printf(cntxt->fdout,"#CANDIDATE[%d] ",i);
		printInstruction(cntxt->fdout, mb, 0, p, LIST_MAL_ALL);
#endif
		prop = hasSideEffects(p,TRUE) || isUpdateInstruction(p);
		j =	isVarConstant(mb, getArg(p,p->argc-1))? cstlist: candidate;
				
		if ( !prop)
		for (; j ; j = list[j]) 
			if ( (q=getInstrPtr(mb,j))->fcn == p->fcn  && !isUnsafeFunction(q)){
#ifdef DEBUG_OPT_COMMONTERMS_MORE
			mnstr_printf(cntxt->fdout,"#CANDIDATE %d, %d  %d %d ", i, j, 
				hasSameSignature(mb, p, q, p->retc), 
				hasSameArguments(mb, p, q));
				printInstruction(cntxt->fdout, mb, 0, q, LIST_MAL_ALL);
				mnstr_printf(cntxt->fdout," :%d %d %d=%d %d %d %d %d %d\n", 
					q->token != ASSIGNsymbol ,
					list[getArg(q,q->argc-1)],i,
					!hasCommonResults(p, q), 
					!hasSideEffects(q, TRUE),
					!isUpdateInstruction(q),
					isLinearFlow(q),
					isLinearFlow(p));
#endif
				/*
				 * @-
				 * Simple assignments are not replaced either. They should be
				 * handled by the alias removal part. All arguments should
				 * be assigned their value before instruction p.
				 */
				if ( hasSameArguments(mb, p, q) && 
					hasSameSignature(mb, p, q, p->retc) && 
					!hasCommonResults(p, q) && 
					isLinearFlow(q) 
				   ) {
						if (safetyBarrier(p, q) ){
#ifdef DEBUG_OPT_COMMONTERMS_MORE
						mnstr_printf(cntxt->fdout,"#safetybarrier reached\n");
#endif
						break;
					}
#ifdef DEBUG_OPT_COMMONTERMS_MORE
						mnstr_printf(cntxt->fdout, "Found a common expression " "%d <-> %d\n", j, i);
						printInstruction(cntxt->fdout, mb, 0, q, LIST_MAL_ALL);
#endif
					clrFunction(p);
					p->argc = p->retc;
					for (k = 0; k < q->retc; k++){
						alias[getArg(p,k)] = getArg(q,k);
						p= pushArgument(mb,p, getArg(q,k));
					}
#ifdef DEBUG_OPT_COMMONTERMS_MORE
					mnstr_printf(cntxt->fdout, "COMMON MODIFIED EXPRESSION %d -> %d\n",i,j);
					printInstruction(cntxt->fdout, mb, 0, p, LIST_MAL_ALL);
#endif
					actions++;
					break; /* end of search */
				}
			}
#ifdef DEBUG_OPT_COMMONTERMS_MORE
			else if ( hasSideEffects(q, TRUE) || isUpdateInstruction(p)){
				mnstr_printf(cntxt->fdout, "COMMON SKIPPED %d %d\n", hasSideEffects(q, TRUE) , isUpdateInstruction(p));
				printInstruction(cntxt->fdout, mb, 0, q, LIST_MAL_ALL);
			}
#endif
	}
	for(; i<slimit; i++)
		if( old[i])
			freeInstruction(old[i]);
	GDKfree(list);
	GDKfree(vars);
	GDKfree(old);
	GDKfree(alias);
	DEBUGoptimizers
		mnstr_printf(cntxt->fdout,"#opt_commonTerms: %d statements catched\n",actions);
#ifdef DEBUG_OPT_COMMONTERMS_MORE
		mnstr_printf(cntxt->fdout,"#opt_commonTerms: %d statements catched\n",actions);
#endif
	return actions;
}

@include optimizerWrapper.mx
@c
#include "opt_statistics.h"
@:wrapOptimizer(commonTerms,OPT_CHECK_ALL)@
