/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0.  If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 *
 * Copyright 1997 - July 2008 CWI, August 2008 - 2020 MonetDB B.V.
 */

#include "monetdb_config.h"
#include "opt_pushproject.h"
#include "mal_interpreter.h"	/* for showErrors() */


str
OPTpushprojectImplementation(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
        int i, limit, slimit, actions =0;
        InstrPtr p=0, q=0, *old= mb->stmt;
        int *projects=0;
        char buf[256];
        lng usec = GDKusec();
        str msg= MAL_SUCCEED;

        (void) cntxt;
        (void) pci;
        (void) stk;             /* to fool compilers */

        if ( mb->inlineProp )
                return MAL_SUCCEED;

        projects = GDKzalloc(2 * mb->vtop * sizeof(int));
        if (projects == NULL)
                return MAL_SUCCEED;

        limit = mb->stop;
        slimit = mb->ssize;
        if (newMalBlkStmt(mb, mb->ssize) < 0) {
                msg= createException(MAL,"optimizer.deadcode", SQLSTATE(HY013) MAL_MALLOC_FAIL);
                goto wrapup;
        }

        // Consolidate the actual need for variables
        for (i = 0; i < limit; i++) {
                p = old[i];
                if( p == 0)
                        continue; //left behind by others?

                if ( getModuleId(p) == algebraRef && getFunctionId(p) == projectionRef && p->argc ==3){
			projects[getArg(p,0)] = i;
		}
                if ( getModuleId(p) == algebraRef && getFunctionId(p) == projectionpathRef && projects[getArg(p, p->argc-1)] ){
			// Inject the projection arguments
			q = old[projects[getArg(p, p->argc-1)]];
			getArg(p, p->argc-1) = getArg(q,1);
			p= pushArgument(mb, p, getArg(q,2));
			setFunctionId(p, projectionpathRef);
			actions++;
		} else
		/* Raises error during startup  in Mtest
                if ( getModuleId(p) == algebraRef && getFunctionId(p) == projectionRef && projects[getArg(p, p->argc-1)] ){
			// Inject the projection arguments
			q = old[projects[getArg(p, p->argc-1)]];
			getArg(p, p->retc) = getArg(q,1);
			setFunctionId(p, projectionpathRef);
			p= setArgument(mb, p, p->retc+1, getArg(q,2));
			actions++;
		}
		*/
                pushInstruction(mb, p);
        }
	for(; i<slimit; i++)
	if( old[i])
		freeInstruction(old[i]);
	/* Defense line against incorrect plans */
	if( actions > 0){
		msg = chkTypes(cntxt->usermodule, mb, FALSE);
		if (!msg)
			msg = chkFlow(mb);
		if (!msg)
			msg = chkDeclarations(mb);
	}
    /* keep all actions taken as a post block comment */
        usec = GDKusec()- usec;
    snprintf(buf,256,"%-20s actions=%2d time=" LLFMT " usec","pushproject",actions, usec);
    newComment(mb,buf);
    if( actions > 0)
	addtoMalBlkHistory(mb);

wrapup:
        if(old) GDKfree(old);
        if(projects) GDKfree(projects);
        return msg;
}
