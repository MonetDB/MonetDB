@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.monetdb.org/Legal/MonetDBLicense

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2011 MonetDB B.V.
All Rights Reserved.
@

@c
/*
 * @f opt_partitions
 * @a M. Kersten
 * @- BAT Partitions
 * Limitations on the addressing space in older PCs and the need
 * for distributed storage makes that BATs ideally should be
 * looked upon as a union of smaller BATs which are processed
 * within the (memory) resource limitations given.
 *
 * The @sc{partition()} optimizer with the supportive
 * bat partition library @code{bpm}
 * addresses the issue with an adaptive database segmentation algorithm.
 * It is designed incrementally with a focus
 * on supporting the SQL front-end. In particularly, the
 * operators considered is a limited subset of MAL. Occurrence
 * of an operator outside this set terminates the optimizer
 * activities.
 *
 * The operation @sc{optimizer.partitions()} hunts for bindings
 * of SQL column BATs and prepare code for using partitioned
 * versions instead.
 *
 * We use two implementations. The first one attempts to find
 * segments of linear dependent data and builds an iterator
 * around it. This approach is tricky, because you have to
 * take care of special cases. In particular, the semantics
 * of the operators on the sequence construction posed quite
 * some problems.
 *
 * The naive() approach simply looks at individual operations
 * and surround them with an iterator. An alias table is
 * kept around for re-use and detect already partitioned operands.
 * The drawback is that potentially a partitioned BAT is
 * read multiple times [it depends on the re-use of variables,
 * which can be calculated] and write+read of intermediates.
 * Experiments should demonstrate the optimal one.
 */
@mal
pattern optimizer.partitions():str
address OPTpartitions;
pattern optimizer.partitions(mod:str, fcn:str):str
address OPTpartitions
comment "Experiment with partitioned databases";
@h
#ifndef _OPT_PARTITIONED_
#define _OPT_PARTITIONED_
#include "opt_prelude.h"
#include "opt_support.h"

#define OPTDEBUGpartitions  if ( optDebug & (1 <<DEBUG_OPT_PARTITIONS) )
@c
#include "monetdb_config.h"
#include "opt_partitions.h"
#include "mal_interpreter.h"	/* for showErrors() */

/*
 * @-
 * Calling the optimizer from the MAL context currently
 * assumes that all sql.bind operations references partitioned BATs.
 * We mark the segments derived from a single partitioned bat group.
 * This continues until we find a blocking operator
 * that requires the results of multiple threads.
 * Then we have to close the iterator block and gather the results.
 */
static int localVar(MalBlkPtr mb, char *prefix, int idx, int tpe){
	char name[256];
	snprintf(name,256,"%s%d",prefix,idx);

	idx=findVariable(mb,name);
	if( idx >= 0) return idx;
	return newVariable(mb,GDKstrdup(name),tpe);
}

/*
 * @- Naive partitioning
 * The simplistic approach starts here
 * An operation should be replace by an iterator if
 * any of its arguments is partitioned. This is detected
 * by an alias function, which is set to the alternative.
 */
static int 
OPTuseIterator(MalBlkPtr mb, InstrPtr p, int *alias){
	int i;
	for(i=p->retc; i<p->argc; i++)
	if( isaBatType(getArgType(mb,p, i)) || alias[getArg(p,i)] > 0)
		return 1;
	return 0;
}

static void
OPTbarrierList(MalBlkPtr mb, InstrPtr p, int *alias){
	int j;
	InstrPtr q;
	/* dump the iterators */
	for(j=p->retc; j<p->argc; j++)
	if( isaBatType(getArgType(mb,p,j))  && alias[getArg(p,j)]>0){
		q = newStmt(mb, bpmRef, "newIterator");
		q->barrier= BARRIERsymbol;
		q->argv[0]= getArg(p,j);
		OPTDEBUGpartitions
			printf("barrier %d ->%d\n",getArg(p,j), alias[getArg(p,j)]);
		(void) pushArgument(mb, q, 
			(alias[getArg(p,j)]?alias[getArg(p,j)]:getArg(p,j)) );
	}
}
static int
OPTbarrierListCnt(MalBlkPtr mb, InstrPtr p, int *alias){
	int j,cnt=0;
	/* count dump the iterators */
	for(j=p->retc; j<p->argc; j++)
	if( isaBatType(getArgType(mb,p,j))  && alias[getArg(p,j)]>0)
		cnt++;
	return cnt;
}
static void
OPTredoList(MalBlkPtr mb, InstrPtr p, int *alias){
	int j;
	InstrPtr q;
	/* finalize iterator structure */
	for(j=p->argc-1; j>= p->retc; j--)
	if( isaBatType(getArgType(mb,p,j))  && alias[getArg(p,j)]>0){
		q = newStmt(mb, bpmRef, "hasMoreElements");
		q->barrier= REDOsymbol;
		q->argv[0]= getArg(p,j);
		(void) pushArgument(mb, q, 
			(alias[getArg(p,j)]?alias[getArg(p,j)]:getArg(p,j)) );
	}

	for(j=p->argc-1; j>=p->retc; j--)
	if( isaBatType(getArgType(mb,p,j))  && alias[getArg(p,j)]>0){
		q = newInstruction(mb,EXITsymbol);
		q->barrier= EXITsymbol;
		q->argv[0]= getArg(p,j);
		pushInstruction(mb,q);
	}
}

static void
OPTbakeIterator(MalBlkPtr mb, InstrPtr p, int *alias, int *garbage){
	int tpe;
	InstrPtr q, anchor;

	anchor= q = newStmt(mb,"bpm","new");
	tpe= getArgType(mb,p,0);
	anchor= pushArgument(mb,anchor,newTypeVariable(mb,getHeadType(tpe)));
	anchor= pushArgument(mb,anchor,newTypeVariable(mb,getTailType(tpe)));
	alias[getArg(p,0)]= getArg(q,0);
	garbage[getArg(q,0)]= 1;

	/* declare the target at the outer level */
	q= newAssignment(mb);
	getArg(q,0)= getArg(p,0);
	pushNil(mb,q, getArgType(mb,p,0));

	/* dump the iterators */
	OPTbarrierList(mb,p,alias);

	/* run the partitioned operation */
	pushInstruction(mb,p);

	/* save the temporary partitions */
	q = newStmt(mb,"bpm","addPartition");
	q= pushArgument(mb,q,getArg(anchor,0));
	(void) pushArgument(mb,q,getArg(p,0));

	OPTredoList(mb,p,alias);
}
/*
 * @-
 * Be aware the the SQL produces sql.bind(-,-,-,0) and sql.bind(-,-,-,3)
 * which lead to the same BAT id. This causes sharing in a ring, with
 * possib;e side effects upon garbage collection.
 */
static int bindTest(MalBlkPtr mb, InstrPtr p){
	ValPtr v;
	v= &getVarConstant(mb,getArg(p,4));
	return v->val.ival>0;
}
/*
 * @-
 * Garbage collection of partitioned BATs is tricky when the
 * sql.bind() operations are nested inside BARRIER-EXIT blocks.
 * For the time being we ignore plans that rely on this.
 * The test below is rather coarse grained.
 */
static int
OPTisSimple(MalBlkPtr mb){
	int i,nested=0;
	InstrPtr p;

	for(i=0; i<mb->stop; i++){
		p= getInstrPtr(mb,i);
		nested +=  p->barrier== BARRIERsymbol || p->barrier== CATCHsymbol;
		if( getModuleId(p)== sqlRef && getFunctionId(p)== bindRef && nested)
			return FALSE;
	}
	return TRUE;
}

static int
OPTnaiveIterations(MalBlkPtr mb){
	int i,j,k,limit,vlimit= mb->vsize + mb->ssize*4; /* expanded*/
	InstrPtr *old,p=0,q;
	int *alias;
	int *garbage;
	/* char name[1024];*/

	if( !OPTisSimple(mb))
		return 0;
	alias= (int*) GDKzalloc(sizeof(int)*vlimit);
	if (alias == NULL)
		return 0;
	garbage= (int*) GDKzalloc(sizeof(int)*vlimit);
	if (garbage== NULL){
		GDKfree(alias);
		return 0;
	}

	limit= mb->stop;
	old = mb->stmt;
	if ( newMalBlkStmt(mb,limit) < 0 ){
		GDKfree(alias);
		return 0;
	}
	pushInstruction(mb,old[0]); /* signature */
	for(i=1;i< limit; i++){
		p= old[i];
		/*
		 * @-
		 * Assume all bind operations are over partitioned bats.
		 */
		if( getFunctionId(p)== bindRef && getModuleId(p)== sqlRef &&
			bindTest(mb,p) ){
			pushInstruction(mb,p);
			/* hdl:= bpm.take(name) */
			q = newStmt(mb,"bpm","unfold");
			q->argv[0]=
				localVar(mb,"bpm",getArg(p,0), getVarType(mb, getArg(p,0)));
			setVarUDFtype(mb,q->argv[0]);
			alias[getArg(p,0)]= getArg(q,0);
			OPTDEBUGpartitions
				printf("1 alias[%d]=%d\n",getArg(p,0),getArg(q,0));
/*
			snprintf(name,1024,"%s_%s_%s",
			getVarConstant(mb, getArg(p,1)).val.sval,
			getVarConstant(mb, getArg(p,2)).val.sval,
			getVarConstant(mb, getArg(p,3)).val.sval );
			q= pushStr(mb, q,name);
*/
			q= pushArgument(mb,q,getArg(p,0));
			garbage[getArg(q,0)]=1;
			/* printf("unfold  %d %d\n",getArg(q,0),getArg(q,1));*/
			continue;
		}
		/*
		 * @-
		 * The instruction should be broken into an interator
		 * if any of its arguments is already partitioned.
		 * The exceptions are 1) there exists a fast direct
		 * implementation in the bpm for it, 2) it has
		 * side-effects, 3) it involves a blocking instruction
		 * @-
		 * Caveats.
		 * The batcalc module uses a merge-like operation
		 * to scan through multiple BATs. A naive iterator expansion approach would
		 * lead to a cartesian product. This means the opt_accumulator
		 * can not be used in this context or a complex backwards
		 * analysis is needed. At this stage we consider them blocking,
		 * later a correct partitioned solution can be made.
		 *
		 * The bakeIterator currently supports a single result variable.
		 */
		if( OPTuseIterator(mb, p, alias) == 0 )
			goto jump2;
		if( getModuleId(p) == constraintsRef ){
			getModuleId(p)= bpmRef;
			pushInstruction(mb,p);
			if( alias[getArg(p,1)])
				getArg(p,1)= alias[getArg(p,1)];
			continue;
		}

		if( !hasSideEffects(p,TRUE) && !isUpdateInstruction(p) && p->retc == 1 &&
			isLinearFlow(p) &&
			!isBlocking(p) &&
			getModuleId(p) != batcalcRef &&
			OPTbarrierListCnt(mb, p, alias) > 0
		){
			OPTbakeIterator(mb, p, alias, garbage);
			continue;
		}
	/*
	 * @-
	 * At this stage we first undo the partitioning.
	 */
	jump2:
		for(j= p->retc; j<p->argc; j++)
		if( (alias[getArg(p,j)] && alias[getArg(p,j)]!= getArg(p,j)) ){
			q = newStmt(mb,"bpm","fold");
			q->argv[0]= getArg(p,j);
			q= pushArgument(mb,q,alias[getArg(p,j)]);
			garbage[getArg(q,1)]=0;
			alias[getArg(p,j)]= 0;
			OPTDEBUGpartitions
				printf("alias[%d]=0\n",getArg(p,j));
		}
		if( p->token == ENDsymbol)
			break;
		pushInstruction(mb,p);
	}
	/*
	 * @-
	 * Whenever an exception is raised, we should still process
	 * the garbage collection statements for the partitioned bats.
	 */
	q= newAssignment(mb);
	j=findVariable(mb,"SQLexception");
	if( j <0)
		j= newVariable(mb,GDKstrdup("SQLexception"),TYPE_str);
	getArg(q,0)= j;
	q->barrier= CATCHsymbol;
	for(k=0; k< vlimit; k++)
	if( garbage[k]){
		q=newStmt(mb,bpmRef,"garbage");
		setVarType(mb,getArg(q,0),TYPE_void);
		(void) pushArgument(mb,q,k);
	}
	q= newAssignment(mb);
	getArg(q,0)= j;
	q->barrier= RAISEsymbol;
	q= newAssignment(mb);
	getArg(q,0)= j;
	q->barrier= EXITsymbol;

	/* if there is no exception */
	for(k=0; k< vlimit; k++)
	if( garbage[k]){
		q=newStmt(mb,bpmRef,"garbage");
		setVarType(mb,getArg(q,0),TYPE_void);
		(void) pushArgument(mb,q,k);
	}
	for(;i< limit; i++)
		pushInstruction(mb,old[i]);
	GDKfree(alias);
	GDKfree(garbage);
	return 1;
}

static int
OPTpartitionsImplementation(Client cntxt,MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	(void) cntxt;
	(void) stk;
	(void) pci;
	return OPTnaiveIterations(mb);
}

/*
 * @-
 * The translation of a MAL block into a multi-iterator only works if
 * the network flow is simple, i.e there exists a 'single' sink,
 * or all the information is compressed
 * into variables that are passed back to the caller as a single value,
 * or is sent non-interupted to the output channels.
 * The bottom-line is to avoid expansion.
 * An assignment to the target is not allowed [to be checked separately]
 */
@include optimizerWrapper.mx
@h
@:exportOptimizer(partitions)@
#endif
@c
#include "opt_statistics.h"
@:wrapOptimizer(partitions,OPT_CHECK_ALL)@
