@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.monetdb.org/Legal/MonetDBLicense

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2011 MonetDB B.V.
All Rights Reserved.
@

@c
/*
 * @f opt_aliases
 * @- Alias Removal
 * The routine @sc{optimizer.aliasRemoval()}
 * walks through the program looking for simple
 * assignment statements, e.g. V:=W. It replaces all subsequent
 * occurrences of V by W, provided V is assigned a value once and
 * W does not change in the remainder of the code.
 * Special care should be taken for iterator blocks as illustrated in
 * the case below:
 * @verbatim
 * 	i:=0;
 * 	b:= "done";
 * barrier go:= true;
 * 	c:=i+1;
 * 	d:="step";
 * 	v:=d;
 * 	io.print(v);
 * 	i:=c;
 * redo go:= i<2;
 * exit go;
 * 	io.print(b);
 * 	optimizer.aliasRemoval();
 * @end verbatim
 * The constant strings are propagated to the @sc{print()} routine, while
 * the initial assigment @sc{i:=0} should be retained. The code block becomes:
 * @verbatim
 * 	i:=0;
 * barrier go:= true;
 * 	c:=i+1;
 * 	io.print("step");
 * 	i:=c;
 * redo go:= i<2;
 * exit go;
 * 	io.print("done");
 * @end verbatim
 * A special case is backward propagation of constants.
 * The following snippet is the result of the JITO emptyset.
 * It can be further reduced to avoid useless assignments.
 * @verbatim
 *     _53 := sql.bind("sys","_tables","type",0);
 *     (_54,_56,_58,_60) := bat.partition(_53);
 *     _53 := nil;
 *     _67 := _54;
 *     _54 := nil;
 *     _75 := _67;
 *     _67 := nil;
 *     _83 := _75;
 *     _75 := nil;
 * @end verbatim
 */
@mal
pattern optimizer.aliases():str
address OPTaliases;
pattern optimizer.aliases(mod:str, fcn:str):str
address OPTaliases
comment "Alias removal optimizer";
@h
/*
 * @-
 * The key decision is to find the next statement that
 * changes the candidate.
 * Beware that parameters could be changed as part of a call.
 * They are marked as unsafe.
 */
#ifndef _OPT_ALIASES_
#define _OPT_ALIASES_
#include "opt_prelude.h"
#include "opt_support.h"
#include "mal_exception.h"

opt_export int OPTisAlias(InstrPtr p);
opt_export void OPTaliasRemap(InstrPtr p, int *alias);

#define OPTDEBUGaliases  if ( optDebug & (1 <<DEBUG_OPT_ALIASES) )

@c
/*
 * @-
 * When you propagate an alias through the program, the properties
 * maintained should also be updated. In particular, the lifespan
 * of the alias changes as part of the move.
 *
 * Alias removal is targeted at simple assignments only,
 * because MAL does not allow for nested expressions.
 * Instructions changing the flow of control should also be ignored.
 * In all other cases the target variables are potential candidates
 * for alias removal.
 * @-
 * The new aliasremoval code performs a single scan through the
 * code. We are currently only interested in simple V:=W
 * expressions.
 */
#include "monetdb_config.h"
#include "opt_aliases.h"
int
OPTisAlias(InstrPtr p){
	if( p->token == ASSIGNsymbol &&
		p->barrier == 0 && 
		p->argc == 2)
		return TRUE;
	return FALSE;
}

void
OPTaliasRemap(InstrPtr p, int *alias){
	int i;
	for(i=0; i<p->argc; i++)
		getArg(p,i) = alias[getArg(p,i)];
}

static int
OPTaliasesImplementation(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	int i,k=1, limit, actions=0;
	int *alias;
	Lifespan span;

	(void) stk;
	(void) cntxt;
	span= setLifespan(mb);
	if( span == NULL)
		return 0;

	alias= (int*) GDKmalloc(sizeof(int)* mb->vtop);
	if (alias == NULL)
		return 0;
	for(i=0; i<mb->vtop; i++) alias[i]=i;

	limit = mb->stop;
	for (i = 1; i < limit; i++){
		p= getInstrPtr(mb,i);
		mb->stmt[k++] = p;
		if (OPTisAlias(p)){
			if( getLastUpdate(span,getArg(p,0)) == i  &&
				getBeginLifespan(span,getArg(p,0)) == i  &&
				getLastUpdate(span,getArg(p,1)) <= i ){
				alias[getArg(p,0)]= alias[getArg(p,1)];
				freeInstruction(p);
				actions++;
				k--;
			} else 
				OPTaliasRemap(p,alias);
		} else 
			OPTaliasRemap(p,alias);
	}
	for(i=k; i<limit; i++)
		mb->stmt[i]= NULL;
	mb->stop= k;
	/*
	 * @-
	 * The second phase is constant alias replacement should be implemented.
	 */
	GDKfree(span);
	GDKfree(alias);
	DEBUGoptimizers
		mnstr_printf(cntxt->fdout,"#opt_aliases: %d removed\n",actions);
	return actions;
}
@include optimizerWrapper.mx
@h
@:exportOptimizer(aliases)@
#endif
@c
#include "opt_statistics.h"
@:wrapOptimizer(aliases,OPT_CHECK_ALL)@
