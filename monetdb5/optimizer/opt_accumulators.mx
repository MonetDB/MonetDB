@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.monetdb.org/Legal/MonetDBLicense

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2011 MonetDB B.V.
All Rights Reserved.
@

@f opt_accumulators
@- Accumulator Evaluations
Bulk arithmetic calculations are pretty expensive,
because new @sc{bat}s are created for each expression. 
This memory hunger can be reduced
by detecting opportunities for accummulator processing, i.e.
where a (temporary) variable is overwritten.
For example, consider the program snippet
@example
	t3:= batcalc.*(64,t2);
	t4:= batcalc,+(t1,t3);
	optimizer.accumulators();
@end example
If variable t2 is a temporary variable and not used any further in
the program block, we can re-use its storage space.
@example
	t3:= batcalc.*(t2,64,true,false);
	t4:= batcalc.+(t1,t3);
@end example
The implementation is straight forward. It only deals with the
arithmetic operations available in @sc{batcalc} right now.
This set may be gradually extended.
The key decision is to determine whether we may overwrite
any of the arguments. This is hard to detect at compile
time, e.g. the argument may be the result of a binding operation
or represent a view over a persistent BAT.

[NOTE the accumulator optimizer is known to produce
problems due to concurrent access to the BATs.
However, the last instruction for a BAT is now scheduled only
when all other uses have finished.

The accumulator can be installed just before garbage collector,
because the other modules do not recognize batcalc operations with
more arguments.]
@{
@mal
pattern optimizer.accumulators():str
address OPTaccumulators;
pattern optimizer.accumulators(mod:str, fcn:str):str
address OPTaccumulators
comment "Replace calculations with accumulator model";
@h
#ifndef _OPT_ACCUMULATORS_
#define _OPT_ACCUMULATORS_
#include "opt_prelude.h"
#include "opt_support.h"
#include "mal_interpreter.h"

@:exportOptimizer(accumulators)@

#define OPTDEBUGaccumulators  if ( optDebug & ((lng)1 <<DEBUG_OPT_ACCUMULATORS) )

#endif
@c
#include "monetdb_config.h"
#include "opt_accumulators.h"
#include "mal_builder.h"

static int
OPTaccumulatorsImplementation(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int i, limit,slimit;
	InstrPtr p,q;
	Module scope = cntxt->nspace;
	int actions = 0;
	InstrPtr *old;
	Lifespan span;

	(void) pci;
	(void) stk;		/* to fool compilers */
	span = setLifespan(mb);
	if( span == NULL)
		return 0;
	old= mb->stmt;
	limit= mb->stop;
	slimit= mb->ssize;
	if ( newMalBlkStmt(mb,mb->stop) < 0)
		return 0;
	for (i = 0; i < limit; i++) {
		p = old[i];

		if( getModuleId(p) != batcalcRef ) {
			pushInstruction(mb,p);
			continue;
		}
		OPTDEBUGaccumulators
			printInstruction(cntxt->fdout, mb, 0, p, LIST_MAL_ALL);
		if (p->retc==1 && p->argc == 2) {
			/* unary operation, avoid clash with binary */
			pushInstruction(mb,p);
			continue;
		}
		if( getLastUpdate(span,getArg(p,0)) != i ) {
			/* only consider the last update to this variable */
			pushInstruction(mb,p);
			continue;
		}

		if (p->retc==1  && p->argc == 3 && isaBatType(getArgType(mb,p,0))) {
			int b1 =getEndLifespan(span,getArg(p,1))<=i && getArgType(mb,p,1) == getArgType(mb,p,0);
			int b2 =getEndLifespan(span,getArg(p,2))<=i && getArgType(mb,p,2) == getArgType(mb,p,0) ;
			if ( b1 == 0 && b2 == 0){
				pushInstruction(mb,p);
				continue;
			}
			/* binary/unary operation, check arguments for being candidates */
			q= copyInstruction(p);
			p= pushBit(mb,p, b1);
			p= pushBit(mb,p, b2);

			typeChecker(scope, mb, p, TRUE);
			if (mb->errors || p->typechk == TYPE_UNKNOWN) {
				OPTDEBUGaccumulators{
					mnstr_printf(cntxt->fdout,"# Failed typecheck");
					printInstruction(cntxt->fdout, mb, 0, p, LIST_MAL_ALL);
				}
				/* reset instruction error buffer */
				cntxt->errbuf[0]=0;
				mb->errors = 0;
				freeInstruction(p);
				p=q; /* restore */
			} else  {
				OPTDEBUGaccumulators{
					mnstr_printf(cntxt->fdout, "#Found accumulation candidate ");
					mnstr_printf(cntxt->fdout, "%d: %d(%d)\n", i, getArg(p,0),getArg(p,2));
					printInstruction(cntxt->fdout, mb, 0, p, LIST_MAL_ALL);
				}
				freeInstruction(q);
				actions++;  
			}
			OPTDEBUGaccumulators
				printInstruction(cntxt->fdout, mb, 0, p, LIST_MAL_ALL);
		}
		pushInstruction(mb,p);
	} 
	for (i = limit; i<slimit; i++) 
		if(old[i])
			freeInstruction(old[i]);
	GDKfree(old);
	GDKfree(span);
	DEBUGoptimizers
		mnstr_printf(cntxt->fdout,"#opt_accumulators:%d accumulations\n",actions);
	return actions;
}

@include optimizerWrapper.mx
@c
#include "opt_statistics.h"
@:wrapOptimizer(accumulators,OPT_CHECK_ALL)@
@}
