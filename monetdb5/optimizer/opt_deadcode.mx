@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.monetdb.org/Legal/MonetDBLicense

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2011 MonetDB B.V.
All Rights Reserved.
@

@f opt_deadcode

@c
/*
 * @- Dead Code Removal
 * Dead code fragments are recognized by assignments to variables
 * whose value is not consumed any more.
 * It can be detected  by marking all variables used as
 * arguments as being relevant.
 * In parallel, we built a list of instructions that should appear
 * in the final result.
 * The new code block is than built in one scan, discarding the
 * superflous instructions.
 *
 * Instructions that produce side effects to the environment,
 * e.g., printing and BAT updates, should be taken into account.
 * Such (possibly recursive) functions should be marked with a property
 * (@sc{unsafe}). For now we recognize a few important ones
 * Likewise, instructions marked as control flow instructions should be retained.
 *
 * An illustrative example is the following MAL snippet:
 * @verbatim
 * 	V7 := bat.new(:oid,:int);
 * 	V10 := bat.new(:int,:oid);
 * 	V16 := algebra.markH(V7);
 * 	V17 := algebra.join(V16,V7);
 * 	V19 := bat.new(:oid,:int);
 * 	V22 := bat.new(:oid,:int);
 * 	V23 := algebra.join(V16,V22);
 * 	io.print("done");
 * 	optimizer.deadCodeRemoval();
 * @end verbatim
 * The dead code removal trims this program to the following short block:
 * @verbatim
 * 	io.print("done");
 * @end verbatim
 *
 * A refinement of the dead code comes from using arguments
 * that ceased to exist due to actions taken by an optimizer.
 * For example, in the snippet below the @sc{pushranges} optimizer
 * may conclude that variable V31 becomes empty and simply
 * injects a 'dead' variable by dropping the assignment statement.
 * This makes other code dead as well.
 * @example
 * 	V30 := algebra.select( V7, 10,100);
 * 	V31 := algebra.select(V30,-1,5);
 * 	V32 := aggr.sum(V31);
 * 	io.print(V32);
 * @end example
 * [implementation pending]
 */
@mal
pattern optimizer.deadcode():str
address OPTdeadcode;
pattern optimizer.deadcode(mod:str, fcn:str):str
address OPTdeadcode
comment "Dead code optimizer";
@h
#ifndef _OPT_DEADCODE_
#define _OPT_DEADCODE_
#include "opt_prelude.h"
#include "opt_support.h"
#include "mal_interpreter.h"
#include "mal_instruction.h"
#include "mal_function.h"

@:exportOptimizer(deadcode)@

#define OPTDEBUGdeadcode  if ( optDebug & (1 <<DEBUG_OPT_DEADCODE) )

#endif
@c
#include "monetdb_config.h"
#include "opt_deadcode.h"

static int 
OPTdeadcodeImplementation(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int i, k, se,limit, slimit;
	InstrPtr p=0, *old= mb->stmt;
	int actions = 0;

	(void) pci;
	(void) stk;		/* to fool compilers */

	if (varGetProp(mb, getArg(mb->stmt[0], 0), inlineProp) != NULL)
		return 0;

	clrDeclarations(mb);
	chkDeclarations(mb);
	limit= mb->stop;
	slimit = mb->ssize;
	if ( newMalBlkStmt(mb, mb->ssize) < 0)
		return 0;

	pushInstruction(mb, old[0]);
	for (i = 1; i < limit; i++) {
		p= old[i];

		se = p->token == ENDsymbol;
		if( se){
			pushInstruction(mb,p);
			for(i++; i<limit; i++)
				if(old[i])
					pushInstruction(mb,old[i]);
			break;
		}
		if( p->token != NOOPsymbol)
		for (k = 0; k < p->retc; k++)
			if( isVarUsed(mb,getArg(p,k)) ){
				se++;
				break;
			} 

		if( getModuleId(p)== sqlRef && getFunctionId(p)== assertRef &&
			isVarConstant(mb,getArg(p,1)) && getVarConstant(mb,getArg(p,1)).val.ival==0){
			freeInstruction(p);
			actions++;
		} else
		if (se || hasSideEffects(p, FALSE) || isUpdateInstruction(p) || !isLinearFlow(p) || 
				isProcedure(mb,p)  || 
				(p->retc == 1 && varGetProp( mb, getArg(p,0), unsafeProp ) != NULL) ||
				p->barrier /* ==side-effect */)
			pushInstruction(mb,p);
		else {
			freeInstruction(p);
			actions++;
		}
	}
	for(; i<slimit; i++)
		if( old[i])
			freeInstruction(old[i]);
	DEBUGoptimizers
		mnstr_printf(GDKstdout,"#opt_deadcode: %d statements removed\n", actions);
	GDKfree(old);
	/* we may have uncovered new use-less operations */
	if (actions) 
		actions += OPTdeadcodeImplementation(cntxt,mb, stk, pci);
	return actions;
}
@include optimizerWrapper.mx
@c
#include "opt_statistics.h"
@:wrapOptimizer(deadcode,OPT_CHECK_ALL)@
