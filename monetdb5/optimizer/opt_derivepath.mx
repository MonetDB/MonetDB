@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.monetdb.org/Legal/MonetDBLicense

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2011 MonetDB B.V.
All Rights Reserved.
@

@f opt_derivepath

@c
/*
 * @- Group derive paths
 * The routine @sc{optimizer.derivepaths()}
 * walks through the program looking for grouping operations
 * and cascades them into a single multiple group paths.
 * To illustrate, consider
 * @verbatim
 * 	(ext1,grp1) := group.new(b);
 * 	(ext2,grp2) := group.derive(ext1,grp1, c);
 * 	(ext3,grp3) := group.done(ext2,grp2, d);
 * @end verbatim
 * The result becomes.
 * @verbatim
 * 	(ext3,grp3) := group.derivepath(b,c,d);
 * @end verbatim
 *
 * The implementation of this operator can freely re-order the BATs
 * for reduced intermediate results or as a basis for parallel scanning
 * all BATs involved to derive their group id.
 *
 * The collection can be extended to immediately aim for group counting
 * or summation, avoiding the materialisation of the group id table.
 */
@mal
pattern optimizer.derivePath():str
address OPTderivePath;
pattern optimizer.derivePath(mod:str, fcn:str):str
address OPTderivePath
comment "Join path constructor";

pattern group.derivePath(l:bat[:oid,:any]...)(grp:bat[:oid,:any],ext:bat[:oid,:any])
address ALGderivePath
comment "Derive a group index.";

pattern group.deriveCount(l:bat[:oid,:any]...):bat[:oid,:wrd]
address ALGderiveCount
comment "Derive a group count.";

pattern group.deriveSum(s:bat[:oid,:int],l:bat[:oid,:any]...):bat[:oid,:int]
address ALGderiveSum
comment "Derive a group sum.";
pattern group.deriveSum(s:bat[:oid,:lng],l:bat[:oid,:any]...):bat[:oid,:lng]
address ALGderiveSum
comment "Derive a group sum.";
pattern group.deriveSum(s:bat[:oid,:flt],l:bat[:oid,:any]...):bat[:oid,:flt]
address ALGderiveSum
comment "Derive a group sum.";
pattern group.deriveSum(s:bat[:oid,:dbl],l:bat[:oid,:any]...):bat[:oid,:dbl]
address ALGderiveSum
comment "Derive a group sum.";
@h
#ifndef _OPT_DERIVEPATH_
#define _OPT_DERIVEPATH_
#include "opt_prelude.h"
#include "opt_support.h"
#include "mal_interpreter.h"

opt_export str ALGderivePath(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
opt_export str ALGderiveCount(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
opt_export str ALGderiveSum(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);

#define OPTDEBUGderivePath  if ( optDebug & ((lng)1 <<DEBUG_OPT_DERIVEPATH) )

@c
#include "monetdb_config.h"
#include "opt_derivepath.h"
#include "group.h"

static int
OPTderivePathImplementation(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	int i, actions=0;
	int *pc;
	InstrPtr q;
	InstrPtr *old;
	int limit,slimit;
    Lifespan span;



	(void) cntxt;
	(void) stk;
    span= setLifespan(mb);
    if( span == NULL)
        return 0;
	if (varGetProp(mb, getArg(mb->stmt[0], 0), inlineProp) != NULL)
		return 0;

	/* beware, new variables and instructions are introduced */
	pc= (int*) GDKzalloc(sizeof(int)* mb->vtop * 2); /* to find last assignment */
	if ( pc == NULL)
		return 0;

	old= mb->stmt;
	limit= mb->stop;
	slimit= mb->ssize;
	if ( newMalBlkStmt(mb,mb->ssize) <0)
		return 0;

	for (i = 0; i<limit; i++){
		p= old[i];
		if (getModuleId(p) == groupRef && p->argc == 3 && getFunctionId(p) == newRef ){
				setFunctionId(p,derivePathRef);
				pc[getArg(p,0)] = i;
				pc[getArg(p,1)] = i;
				actions++;
				OPTDEBUGderivePath {
					mnstr_printf(GDKstdout,"#new derivePath instruction\n");
					printInstruction(GDKstdout,mb, 0, p, LIST_MAL_ALL);
				}
		}
		if (getModuleId(p) == groupRef && p->argc == 5 && (getFunctionId(p) == deriveRef || getFunctionId(p) == doneRef)){
			/*
			 * @-
			 * Try to expand its argument list with what we have found so far.
			 * This creates a series of derive paths, many of which will be removed during deadcode elimination.
			 */
			if (pc[getArg(p,2)] && pc[getArg(p,2)]== pc[getArg(p,3)]){
				q= copyInstruction(getInstrPtr(mb,pc[getArg(p,2)]));
				q= pushArgument(mb,q, getArg(p,4));
				getArg(q,0) = getArg(p,0);
				getArg(q,1) = getArg(p,1);
				pc[getArg(q,0)] = i;
				pc[getArg(q,1)] = i;
				freeInstruction(p);
				p= q;
				OPTDEBUGderivePath{
					mnstr_printf(GDKstdout,"#new derivePath instruction extension\n");
					printInstruction(GDKstdout,mb, 0, p, LIST_MAL_ALL);
				}
			}
		} 
		pushInstruction(mb,p);
	}
	for(; i<slimit; i++)
	if(old[i])
		freeInstruction(old[i]);
	GDKfree(old);
	GDKfree(pc);
	DEBUGoptimizers
		mnstr_printf(GDKstdout,"#opt_derivepath: %d statements glued\n",actions);
	return actions;
}
@include optimizerWrapper.mx
@h
@:exportOptimizer(derivePath,OPT_CHECK_ALL)@
#endif
opt_export str ALGderivePath(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
@c
#include "opt_statistics.h"
@:wrapOptimizer(derivePath,OPT_CHECK_ALL)@
/*
 * @-
 * The derive path optimizer takes a derivation sequence and attempts to minimize the intermediate result.
 * The choice depends on a good estimate of intermediate results using properties.
 * For the time being, we use a simplistic model, based on the assumption that most joins are foreign key joins anyway.
 */
typedef struct{
	int *arg;
	BAT *b;
} Elm;
str
ALGderivePath(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int *grp = (int*) getArgReference(stk,pci,0);
	int *ext = (int*) getArgReference(stk,pci,1);
	Elm *path = (Elm *) GDKzalloc(pci->argc * sizeof(Elm));
	int i, newgrp, newext;
	str msg = MAL_SUCCEED;

	if ( path == NULL)
		throw(MAL,"group.derivePath",MAL_MALLOC_FAIL);
	/* collect the properties (histograms) for all columns */
	for ( i = 2; i < pci->argc; i++){
		path[i].arg = (int*) getArgReference(stk,pci,i);
	}
	/* determine an optimal order for derivation by reshuffling */

	msg = GRPgroup(grp, ext, path[2].arg);
	for ( i=3; msg == MAL_SUCCEED && i < pci->argc; i++){
		msg = GRPderive(&newgrp, &newext, grp, ext, path[i].arg);
		if ( msg == MAL_SUCCEED){
			BBPreleaseref(*grp);
			BBPreleaseref(*ext);
			*grp = newgrp;
			*ext = newext;
		}
	}
	/* remove the histograms */
	for ( i = 2; i < pci->argc; i++){
	}
	GDKfree(path);
	(void) cntxt;
	(void) mb;
	return msg;
}

str
ALGderiveCount(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	(void) cntxt;
	(void) mb;
	(void) stk;
	(void) pci;
	throw(MAL,"group.deriveCount",PROGRAM_NYI);
}

str
ALGderiveSum(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	(void) cntxt;
	(void) mb;
	(void) stk;
	(void) pci;
	throw(MAL,"group.deriveSum",PROGRAM_NYI);
}

