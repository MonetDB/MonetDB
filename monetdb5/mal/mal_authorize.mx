@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.monetdb.org/Legal/MonetDBLicense

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2011 MonetDB B.V.
All Rights Reserved.
@

@f mal_authorize
@a M. Kersten, F. Groffen
@v 0.3
@+ Authorisation adminstration management
Authorisation of users is a key concept in protecting the server from
malicious and unauthorised users.  This file contains a number of
functions that administrate a set of BATs backing the authorisation
tables.

The implementation is based on three persistent BATs, which keep the
usernames, passwords and allowed scenarios for users of the server.

@h
#ifndef _MAL_AUTHORIZE_H
#define _MAL_AUTHORIZE_H

/* #define _DEBUG_AUTH_*/
#include "mal.h"
#include "mal_exception.h"
#include "mal_instruction.h"
#include "mal_client.h"

mal_export str AUTHcheckCredentials(oid *ret, Client *c, str *user, str *passwd, str *challenge, str *algo, str *scenario);
mal_export str AUTHaddUser(oid *ret, Client *c, str *user, str *pass, bat *scenarios);
mal_export str AUTHremoveUser(Client *c, str *username);
mal_export str AUTHchangeUsername(Client *c, str *olduser, str *newuser);
mal_export str AUTHchangePassword(Client *c, str *oldpass, str *passwd);
mal_export str AUTHsetPassword(Client *c, str *username, str *passwd);
mal_export str AUTHaddScenario(Client *c, str *username, str *scenario);
mal_export str AUTHremoveScenario(Client *c, str *username, str *scenario);
mal_export str AUTHresolveUser(str *ret, oid *uid);
mal_export str AUTHgetUsername(str *ret, Client *c);
mal_export str AUTHgetUsers(BAT **ret, Client *c, bat *scenarios);
mal_export str AUTHgetPasswordHash(str *ret, Client *c, str *username);

mal_export str AUTHrequireAdmin(Client *c);
mal_export str AUTHrequireAdminOrUser(Client *c, str *username);
mal_export str AUTHinitTables(void);

mal_export str AUTHMD5Sum(str *ret, str *string, int *len);
mal_export str AUTHSHA1Sum(str *ret, str *string, int *len);
mal_export str AUTHRIPEMD160Sum(str *ret, str *string, int *len);
mal_export str AUTHSHA2Sum(str *ret, str *string, int *len, int *number);
mal_export str AUTHBackendSum(str *ret, str *string, int *len);

@-
Authorisation is based on a password.  The passwords are stored hashed
in a BAT.  Access to this BAT is ok from the MAL level, and in
particular SQL needs it to dump (and later restore) users.
The database administrator can unlock the BAT that stores the password
(the vault) by supplying the master password which is the key for the
cypher algorithm used to store the data.  The BAT will never
contain the plain hashes, as they will be decyphered on the fly when
needed.  A locked vault means noone can log into the system, hence, the
vault needs to be unlocked as part of the server startup ritual.
@h
mal_export str AUTHunlockVault(str *password);

@-
To avoid the password hashes from being sent over the wire in their
original format (and allowing repeatability attacks), MAPI starts with
sending a challenge with salt.  This salt should be appended to the
password hash before it is hashed again in order to make the password
unreadable for eavesdroppers.  The hash algorithm used is specified by
the client, and can be chosen from a comma separated list offered by the
server through the challenge (protocol >=6).  As of protocol version 9
the crypt algorithm has been removed.
@h
mal_export str AUTHgetHashAlgorithms(str *ret);

#endif /* _MAL_AUTHORIZE_H */
@-
@c
@{
#include "monetdb_config.h"
#include "mal_authorize.h"
#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif
#include <openssl/md5.h>
#include <openssl/sha.h>
#include <openssl/ripemd.h>


static str AUTHdecypherValue(str *ret, str *value);
static str AUTHcypherValue(str *ret, str *value);
static str AUTHhashPassword(str *ret, str *algo, str *passwd, str *challenge);
static str AUTHverifyPassword(int *ret, str *passwd);

static BAT *user = NULL;
static BAT *pass = NULL;
static BAT *scen = NULL;

/**
 * Requires the current client to be the admin user thread.  If not the case,
 * this function returns an InvalidCredentialsException.
 */
str
AUTHrequireAdmin(Client *c) {
	oid id;
	Client cntxt = *c;

	if (cntxt == NULL)
			return(MAL_SUCCEED);
	id = cntxt->user;

	if (id != 0) {
		char u[BUFSIZ] = "";
		str user = u;
		str tmp;
		
		rethrow("requireAdmin", tmp, AUTHresolveUser(&user, &id));
		throw(INVCRED, "requireAdmin", INVCRED_ACCESS_DENIED " '%s'", user);
	}

	return(MAL_SUCCEED);
}

/**
 * Requires the current client to be the admin user, or the user with
 * the given username.  If not the case, this function returns an
 * InvalidCredentialsException.
 */
str
AUTHrequireAdminOrUser(Client *c, str *username) {
	oid id = (*c)->user;
	char u[BUFSIZ] = "";
	str user = u;
	str tmp = MAL_SUCCEED;

	/* root?  then all is well */
	if (id == 0)
		return(MAL_SUCCEED);

	rethrow("requireAdminOrUser", tmp, AUTHresolveUser(&user, &id));
	if (username == NULL || *username == NULL || strcmp(*username, user) != 0) {
		throw(INVCRED, "requireAdminOrUser", INVCRED_ACCESS_DENIED " '%s'", user);
	}

	return(MAL_SUCCEED);
}

void
AUTHcommit()
{
	bat blist[4];

	blist[0] = 0;

	assert(user);
	blist[1] = ABS(user->batCacheid);
	assert(pass);
	blist[2] = ABS(pass->batCacheid);
	assert(pass);
	blist[3] = ABS(scen->batCacheid);
	TMsubcommit_list(blist, 4);
}

@-
Localize the authorization tables in the database.  The authorization
tables are a set of aligned BATs that store username, password (hashed)
and scenario permissions.
If the BATs do not exist, they are created, and the monetdb/monetdb
administrator account is added.  Initialising the authorization tables
can only be done after the GDK kernel has been initialized.
@c
str
AUTHinitTables() {
	bat bid;
	BAT *b;
	int isNew = 1;
	str msg = MAL_SUCCEED;

	/* skip loading if already loaded */
	if (user != NULL && pass != NULL && scen != NULL)
		return(MAL_SUCCEED);

	/* if one is not NULL here, something is seriously screwed up */
	assert (user == NULL);
	assert (pass == NULL);
	assert (scen == NULL);

	/* load/create users BAT */
	bid = BBPindex("M5system_auth_user");
	if (!bid) {
		b = BATnew(TYPE_oid, TYPE_str, 256);
		if (b == NULL)
			throw(MAL, "initTables.user", MAL_MALLOC_FAIL " user table");

		BATkey(BATmirror(b), TRUE);
		BBPrename(BBPcacheid(b), "M5system_auth_user");
		BATmode(b, PERSISTENT);
	} else {
		b = BATdescriptor(bid);
		isNew = 0;
	}	
	assert(b);
	user = b;

	/* load old password BAT, upgrade to hash, <monetdb-5.11 */
	bid = BBPindex("M5system_auth_passwd");
	if (bid) {
		BAT *n;
		bat s[3];

		b = BATdescriptor(bid);
		if (b == NULL)
			throw(MAL, "initTables.passwd", INTERNAL_BAT_ACCESS);
		fprintf(stderr,
				"#warning: converting old password store to new format\n");
		fflush(stderr);

		/* create new bat */
		n = BATnew(TYPE_oid, TYPE_str, 256);
		if (n == NULL)
			throw(MAL, "initTables.passwd", MAL_MALLOC_FAIL " password table");

		BBPrename(BBPcacheid(n), "M5system_auth_passwd_v2");
		BATmode(n, PERSISTENT);

		/* convert data */
		if (BATcount(b) > 0) {
			BATiter bi = bat_iterator(b);
			BUN p, q;
			str tmp;
			str pwd;
			str sha1pwd;
			int len;

			BATloop(b, p, q) {
				tmp = (str)BUNtail(bi, p);
				rethrow("initTables", tmp, AUTHdecypherValue(&pwd, &tmp));
				len = (int) strlen(pwd);
				msg= AUTHBackendSum(&sha1pwd, &pwd, &len);
				GDKfree(pwd);
				if (msg)
					return msg;
				pwd = NULL;
				msg = AUTHcypherValue(&pwd, &sha1pwd);
				if (msg){
					if (pwd)
						GDKfree(pwd);
					return msg;
				}
				BUNins(n, BUNhead(bi, p), pwd, FALSE);
				GDKfree(sha1pwd);
				GDKfree(pwd);
			}
		}

		/* destroy old bat */
		BATmode(b, TRANSIENT);
		BBPreleaseref(b->batCacheid);

		/* commit the new situation */
		s[0] = 0;
		s[1] = ABS(n->batCacheid);
		s[2] = ABS(b->batCacheid);
		TMsubcommit_list(s, 3);
	}

	/* load/create password BAT */
	bid = BBPindex("M5system_auth_passwd_v2");
	if (!bid) {
		b = BATnew(TYPE_oid, TYPE_str, 256);
		if (b == NULL)
			throw(MAL, "initTables.passwd", MAL_MALLOC_FAIL " password table");

		BBPrename(BBPcacheid(b), "M5system_auth_passwd_v2");
		BATmode(b, PERSISTENT);
	} else {
		b = BATdescriptor(bid);
		isNew = 0;
	}
	assert(b);
	pass = b;

	/* load/create scenario BAT */
	bid = BBPindex("M5system_auth_scen");
	if (!bid) {
		b = BATnew(TYPE_oid, TYPE_str, 256);
		if (b == NULL)
			throw(MAL, "initTables.scen", MAL_MALLOC_FAIL " scenario table");

		BATkey(b, TRUE);
		BBPrename(BBPcacheid(b), "M5system_auth_scen");
		BATmode(b, PERSISTENT);
	} else {
		b = BATdescriptor(bid);
		isNew = 0;
	}
	assert(b);
	scen = b;

	if (isNew == 1) {
		/* insert the monetdb/monetdb administrator account on a
		 * complete fresh and new auth tables system */
		str user = "monetdb";
		str pw; /* will become the right hash for "monetdb" */
		int len = (int) strlen(user);
		bat b = 0;
		str tmp;
		oid uid;
		Client c = &mal_clients[0];

		rethrow("initTables", tmp, AUTHBackendSum(&pw, &user /* because user == pass */, &len));
		msg= AUTHaddUser(&uid, &c, &user, &pw, &b);
		GDKfree(pw);
		if (msg)
			return msg;
		if (uid != 0)
			throw(MAL, "initTables", INTERNAL_AUTHORIZATION " while they were just created!");
		AUTHcommit();
	}

	return(MAL_SUCCEED);
}

/**
 * Checks the credentials supplied and throws an exception if invalid.
 * The user id of the authenticated user is returned upon success.
 */
str
AUTHcheckCredentials(
		oid *uid,
		Client *c,
		str *username,
		str *passwd,
		str *challenge,
		str *algo,
		str *scenario)
{
	str tmp, msg= MAL_SUCCEED;
	str pwd = NULL;
	str hash = NULL;
	BAT *b;
	BUN p, q;
	oid *id;
	BATiter useri, passi;

	rethrow("checkCredentials", tmp, AUTHrequireAdminOrUser(c, username));
	assert(user);
	assert(pass);
	assert(scen);

	if (*username == NULL || strNil(*username))
		throw(INVCRED, "checkCredentials", "invalid credentials for unknown user");

	p = BUNfnd(BATmirror(user), *username);
	if (p == BUN_NONE) {
		/* DO NOT reveal that the user doesn't exist here! */
		throw(INVCRED, "checkCredentials", INVCRED_INVALID_USER " '%s'", *username);
	}
	useri = bat_iterator(user);
	id = (oid*)(BUNhead(useri, p));

	/* a NULL password is impossible (since we should be dealing with
	 * hashes here) so we can bail out immediately
	 */
	if (*passwd == NULL || strNil(*passwd)) {
		/* DO NOT reveal that the password is NULL here! */
		throw(INVCRED, "checkCredentials", INVCRED_INVALID_USER " '%s'", *username);
	}

	/* find the corresponding password to the user */
	q = BUNfnd(pass, id);
	assert (q != BUN_NONE);
	passi = bat_iterator(pass);
	tmp = (str)BUNtail(passi, q);
	assert (tmp != NULL);
	/* decypher the password (we lose the original tmp here) */
	rethrow("checkCredentials", tmp, AUTHdecypherValue(&pwd, &tmp));
	/* generate the hash as the client should have done */
	msg = AUTHhashPassword(&hash, algo, &pwd, challenge);
	if (msg ){
		GDKfree(pwd);
		return msg;
	}
	GDKfree(pwd);
	/* and now we have it, compare it to what was given to us */
	if (strcmp(*passwd, hash) != 0) {
		/* of course we DO NOT print the password here */
		GDKfree(hash);
		throw(INVCRED, "checkCredentials", INVCRED_INVALID_USER " '%s'", *username);
	}
	GDKfree(hash);

	/* now see if the scenario is permitted (if restrictions for that
	 * apply)
	 */
	b = BATselect(scen, id, id);
	if (b && BATcount(b) > 0) {
		BATiter bi = bat_iterator(b);

		if (*scenario == NULL || strNil(*scenario)) {
			BBPunfix(b->batCacheid);
			/* of course we DO NOT tell the exact reason here again */
			throw(INVCRED, "checkCredentials", INVCRED_INVALID_USER " '%s'",*username);
		}

		/* ok, there are some tuples that we have to consider */
		BATloop(b, p, q) {
			tmp = (str)BUNtail(bi, p);
			assert (tmp != NULL);
			if (strcmp(*scenario, tmp) == 0) {
				/* YAY!  fun!  party!  We are granted access! */
				*uid = *id;
				BBPunfix(b->batCacheid);
				return(MAL_SUCCEED);
			}
		}

		BBPunfix(b->batCacheid);
		/* uh oh... that we made it till here means it's wrong */
		throw(INVCRED, "checkCredentials", INVCRED_INVALID_USER " '%s'",  *username);
	} else {
		/* no scenario restriction applies, so everything is good */
		if (b) 
			BBPunfix(b->batCacheid);
		*uid = *id;
		return(MAL_SUCCEED);
	}
}

/**
 * Adds the given user with password to the administration.  The scens
 * BAT contains all scenarios allowed for the user.  If NULL or empty,
 * no restrictions for a scenario applies.  The return value of this
 * function is the user id of the added user.
 */
str
AUTHaddUser(oid *uid, Client *c, str *username, str *passwd, bat *scenarios) {
	BUN p, q;
	BAT *b;
	oid *id;
	str tmp;
	str hash;
	BATiter useri;

	rethrow("addUser", tmp, AUTHrequireAdmin(c));
	assert(user);
	assert(pass);
	assert(scen);
	
	/* some pre-condition checks */
	if (*username == NULL || strNil(*username))
		throw(ILLARG, "addUser", "username should not be nil");
	if (*passwd == NULL || strNil(*passwd))
		throw(ILLARG, "addUser", "password should not be nil");
	rethrow("addUser", tmp, AUTHverifyPassword(NULL, passwd));

	/* ensure that the username is not already there */
	p = BUNfnd(BATmirror(user), *username);
	if (p != BUN_NONE)
		throw(MAL, "addUser", "user '%s' already exists", *username);
	
	/* we assume the BATs are still aligned */
	rethrow("addUser", tmp, AUTHcypherValue(&hash, passwd));
	/* needs force, as SQL makes a view over user */
	BUNappend(user, *username, TRUE);
	BUNappend(pass, hash, FALSE);
	GDKfree(hash);
	/* retrieve the oid of the just inserted user */
	p = BUNfnd(BATmirror(user), *username);
	assert (p != BUN_NONE);
	useri = bat_iterator(user);
	id = (oid*)(BUNhead(useri, p));

	if (*scenarios != 0) {
		b = BATdescriptor(*scenarios);
		if (b == NULL) {
			BATundo(user);
			BATundo(pass);
			throw(ILLARG, "addUser", INTERNAL_BAT_ACCESS);
		}
		if (b->htype != TYPE_str) {
			BATundo(user);
			BATundo(pass);
			BBPreleaseref(b->batCacheid);
			throw(ILLARG, "addUser", INTERNAL_BAT_HEAD);
		}

		/* associate scenarios given in the BAT with the user */
		if (BATcount(b) > 0){
			BATiter bi = bat_iterator(b);
			BATloop(b, p, q) {
				/* needs force, as sql makes a view over it */
				BUNins(scen, id, BUNhead(bi, p), TRUE);
			}
		}
		BBPreleaseref(b->batCacheid);
	}

	/* make the stuff persistent */
	AUTHcommit();

	*uid = *id;
	return(MAL_SUCCEED);
}

/**
 * Removes the given user from the administration.  All scenarios (if
 * any) and the password are removed as well.
 */
str
AUTHremoveUser(Client *c, str *username) {
	BUN p;
	BAT *b;
	oid id;
	str tmp;
	BATiter useri;

	rethrow("removeUser", tmp, AUTHrequireAdmin(c));
	assert(user);
	assert(pass);
	assert(scen);

	/* pre-condition check */
	if (*username == NULL || strNil(*username))
		throw(ILLARG, "removeUser", "username should not be nil");

	/* ensure that the username exists */
	p = BUNfnd(BATmirror(user), *username);
	if (p == BUN_NONE)
		throw(MAL, "removeUser", "no such user: '%s'", *username);
	useri = bat_iterator(user);
	id = *(oid*)(BUNhead(useri, p));

	/* find the name of the administrator and see if it equals username */
	if (id == (*c)->user)
		throw(MAL, "removeUser", "cannot remove yourself");

	/* now, we got the oid, start removing the related tuples */
	b = BATmirror(BATselect(BATmirror(user), &id, &id));
	assert(BATcount(b) != 0);
	BATdel(user, b, TRUE);
	b = BATmirror(BATselect(BATmirror(pass), &id, &id));
	assert(BATcount(b) != 0);
	BATdel(pass, b, FALSE);
	b = BATmirror(BATselect(BATmirror(scen), &id, &id));
	BATdel(scen, b, TRUE);

	/* make the stuff persistent */
	AUTHcommit();

	return(MAL_SUCCEED);
}

/**
 * Changes the username of the user indicated by olduser into newuser.
 * If the username is already in use, an exception is thrown and nothing
 * is modified.
 */
str
AUTHchangeUsername(Client *c, str *olduser, str *newuser) 
{
	BUN p, q;
	str tmp;
	BATiter useri;
	oid id;

	rethrow("addUser", tmp, AUTHrequireAdminOrUser(c, olduser));

	/* precondition checks */
	if (*olduser == NULL || strNil(*olduser))
		throw(ILLARG, "changeUsername", "old username should not be nil");
	if (*newuser == NULL || strNil(*newuser))
		throw(ILLARG, "changeUsername", "new username should not be nil");

	/* see if the olduser is valid */
	p = BUNfnd(BATmirror(user), *olduser);
	if (p == BUN_NONE)
		throw(MAL, "changeUsername", "user '%s' does not exist", *olduser);
	/* ... and if the newuser is not there yet */
	q = BUNfnd(BATmirror(user), *newuser);
	if (q != BUN_NONE)
		throw(MAL, "changeUsername", "user '%s' already exists", *newuser);

	/* ok, just do it! (with force, because sql makes view over it) */
	useri = bat_iterator(user);
	id = *(oid*)BUNhead(useri, p);
	BUNinplace(user, p, &id, *newuser, TRUE);
	AUTHcommit();

	return(MAL_SUCCEED);
}

/**
 * Changes the password of the current user to the given password.  The
 * old password must match the one stored before the new password is
 * set.
 */
str
AUTHchangePassword(Client *c, str *oldpass, str *passwd) {
	BUN p;
	str tmp= NULL;
	str hash= NULL;
	oid id;
	BATiter passi;
	str msg= MAL_SUCCEED;

	/* precondition checks */
	if (*oldpass == NULL || strNil(*oldpass))
		throw(ILLARG, "changePassword", "old password should not be nil");
	if (*passwd == NULL || strNil(*passwd))
		throw(ILLARG, "changePassword", "password should not be nil");
	rethrow("changePassword", tmp, AUTHverifyPassword(NULL, passwd));

	/* check the old password */
	id = (*c)->user;
	p = BUNfnd(pass, &id);
	assert(p != BUN_NONE);
	passi = bat_iterator(pass);
	tmp = BUNtail(passi, p);
	assert (tmp != NULL);
	/* decypher the password */
	msg= AUTHdecypherValue(&hash, &tmp);
	if ( msg){
		GDKfree(hash);
		return msg;
	}
	if (strcmp(hash, *oldpass) != 0){
		GDKfree(hash);
		throw(INVCRED, "changePassword", "Access denied");
	}

	GDKfree(hash);
	/* cypher the password */
	msg= AUTHcypherValue(&hash, passwd);
	if ( msg){
		GDKfree(hash);
		return msg;
	}

	/* ok, just overwrite the password field for this user */
	BUNinplace(pass, p, &id, hash, FALSE);
	GDKfree(hash);
	AUTHcommit();

	return(MAL_SUCCEED);
}

/**
 * Changes the password of the given user to the given password.  This
 * function can be used by the administrator to reset the password for a
 * user.  Note that for the administrator to change its own password, it
 * cannot use this function for obvious reasons.
 */
str
AUTHsetPassword(Client *c, str *username, str *passwd) {
	BUN p;
	str tmp;
	str hash;
	oid id;
	BATiter useri;

	rethrow("setPassword", tmp, AUTHrequireAdmin(c));

	/* precondition checks */
	if (*username == NULL || strNil(*username))
		throw(ILLARG, "setPassword", "username should not be nil");
	if (*passwd == NULL || strNil(*passwd))
		throw(ILLARG, "setPassword", "password should not be nil");
	rethrow("setPassword", tmp, AUTHverifyPassword(NULL, passwd));

	id = (*c)->user;
	/* find the name of the administrator and see if it equals username */
	p = BUNfnd(user, &id);
	assert (p != BUN_NONE);
	useri = bat_iterator(user);
	tmp = BUNtail(useri, p);
	assert (tmp != NULL);
	if (strcmp(tmp, *username) == 0)
		throw(INVCRED, "setPassword", "The administrator cannot set its own password, use changePassword instead");

	/* see if the user is valid */
	p = BUNfnd(BATmirror(user), *username);
	if (p == BUN_NONE)
		throw(MAL, "setPassword", "no such user '%s'", *username);
	id = *(oid*)BUNhead(useri, p);

	/* cypher the password */
	rethrow("setPassword", tmp, AUTHcypherValue(&hash, passwd));
	/* ok, just overwrite the password field for this user */
	p = BUNfnd(pass, &id);
	assert (p != BUN_NONE);
	BUNinplace(pass, p, &id, hash, FALSE);
	GDKfree(hash);
	AUTHcommit();

	return(MAL_SUCCEED);
}

/**
 * Adds the given scenario to the list of allowed scenarios for the
 * given user.  Note that this can result in unexpected behaviour when
 * there where previously no scenarios defined for the user (which means
 * all scenarios are permitted).
 */
str
AUTHaddScenario(Client *c, str *username, str *scenario) {
	BUN p;
	str tmp;
	oid *id;
	BAT *b;
	BATiter useri;

	rethrow("addScenario", tmp, AUTHrequireAdmin(c));

	/* precondition checks */
	if (*username == NULL || strNil(*username))
		throw(ILLARG, "addScenario", "username should not be nil");
	if (*scenario == NULL || strNil(*scenario))
		throw(ILLARG, "addScenario", "scenario should not be nil");

	/* see if the user is valid */
	p = BUNfnd(BATmirror(user), *username);
	if (p == BUN_NONE)
		throw(MAL, "addScenario", "user '%s' does not exist", *username);
	useri = bat_iterator(user);
	id = (oid*)BUNhead(useri, p);

	/* see if this scenario is not already there */
	b = BATselect(BATmirror(scen), id, id);
	b = BATselect(BATmirror(b), *scenario, *scenario);
	if (BATcount(b) == 1)
		throw(MAL, "addScenario", "scenario '%s' already exists for user '%s'", *scenario, *username);
	if (BATcount(b) > 1)
		throw(MAL, "addScenario", "inconsistent authorisation administration, scenario '%s' multiple times defined", *scenario);

	/* add the scenario for this user, use force as sql makes view over it */
	BUNins(scen, BUNhead(useri, p), *scenario, TRUE);
	AUTHcommit();

	return(MAL_SUCCEED);
}

/**
 * Removes the given scenario from the list of allowed scenarios for the
 * given user.  Note that removing the last allowed scenario results in
 * the opposite effect: it will allow any scenario to be used.
 */
str
AUTHremoveScenario(Client *c, str *username, str *scenario) {
	BUN p;
	BAT *b;
	oid *id;
	str tmp;
	BATiter useri;

	rethrow("removeScenario", tmp, AUTHrequireAdmin(c));

	/* precondition checks */
	if (*username == NULL || strNil(*username))
		throw(ILLARG, "removeScenario", "username should not be nil");
	if (*scenario == NULL || strNil(*scenario))
		throw(ILLARG, "removeScenario", "scenario should not be nil");

	/* see if the user is valid */
	p = BUNfnd(BATmirror(user), *username);
	if (p == BUN_NONE)
		throw(MAL, "removeScenario", "user '%s' does not exist", *username);
	useri = bat_iterator(user);
	id = (oid*)BUNhead(useri, p);

	/* see if the scenario is valid for this user */
	b = BATselect(BATmirror(scen), id, id);
	if (BATcount(b) != 1)
		throw(MAL, "removeScenario", "scenario '%s' not found for user '%s'", *scenario, *username);
	b = BATselect(BATmirror(b), *scenario, *scenario);
	if (BATcount(b) == 0)
		throw(MAL, "removeScenario", "scenario '%s' not found for user '%s'", *scenario, *username);
	if (BATcount(b) > 1)
		throw(MAL, "removeScenario", "inconsistent authorisation administration, scenario '%s' multiple times defined", *scenario);

	/* ok, remove it */
	if (scen)
		BATdel(scen, (b), TRUE);
	AUTHcommit();

	return(MAL_SUCCEED);
}

/**
 * Resolves the given user id and returns the associated username.  If
 * the id is invalid, an exception is thrown.  The given pointer to the
 * username char buffer should be NULL if this function is supposed to
 * allocate memory for it.  If the pointer is pointing to an already
 * allocated buffer, it is supposed to be of size BUFSIZ.
 */
str
AUTHresolveUser(str *username, oid *uid) 
{
	BUN p;
	BATiter useri;

	if (uid == NULL || *uid == oid_nil)
		throw(ILLARG, "resolveUser", "userid should not be nil");
	
	p = BUNfnd(user, uid);
	if (p == BUN_NONE)
		throw(MAL, "resolveUser", "No such user with id: " OIDFMT, *uid);

	assert (username != NULL);

	useri = bat_iterator(user);
	if (*username == NULL) {
		*username = GDKstrdup((str)(BUNtail(useri, p)));
	} else {
		snprintf(*username, BUFSIZ, "%s", (str)(BUNtail(useri, p)));
	}

	return(MAL_SUCCEED);
}

/**
 * Returns the username of the given client.
 */
str
AUTHgetUsername(str *username, Client *c) {
	BUN p;
	oid id;
	BATiter useri;

	id = (*c)->user;
	p = BUNfnd(user, &id);

	/* If you ask for a username using a client struct, and that user
	 * doesn't exist, you seriously screwed up somehow.  If this
	 * happens, it may be a security breach/attempt, and hence
	 * terminating the entire system seems like the right thing to do to
	 * me. */
	if (p == BUN_NONE)
		GDKfatal("Internal error: user id that doesn't exist: " OIDFMT, id);

	useri = bat_iterator(user);
	*username = BUNtail(useri, p);
	return(MAL_SUCCEED);
}

/**
 * Returns a BAT with user names in the tail, and user ids in the head.
 * Only those users are returned that have access to all of the given
 * scenarios.
 */
str
AUTHgetUsers(BAT **ret, Client *c, bat *scenarios) {
	BAT *b, *r;
	str tmp;

	rethrow("getUsers", tmp, AUTHrequireAdmin(c));

	if (*scenarios != 0) {
		b = BATdescriptor(*scenarios);
		if (b == NULL)
			throw(ILLARG, "getUsers", "invalid BAT!");
		if (b->htype != TYPE_str)
			throw(ILLARG, "getUsers", "BAT should have str head");

		if (BATcount(b) == 0) {
			/* we can simply copy the whole users table, as there is no
			 * selection */
			r = BATcopy(user, user->htype, user->ttype, FALSE);
		} else {
			BAT *t1, *t2, *t3;
			
			/* we have to do some work in order to return the requested
			 * rows; only those that have the given scenario(s) (all of
			 * them) */

			/* all users with no scenarios are always in the return
			 * list, we find them by "inversing" the list of users
			 * *with* a scenario */
			t1 = BATkdiff(user, t2=BATkunique(scen));
			BBPunfix(t2->batCacheid);
			
			/* find users with one or more scenarios in the given BAT */
			t2 = BATjoin(scen, b, BATcount(scen));
			t3 = BATkunique(t2);
			BBPunfix(t2->batCacheid);
			t2 = VIEWcombine(t3);
			BBPunfix(t3->batCacheid);
			t3 = BATjoin(t2, user, BATcount(user));
			BBPunfix(t2->batCacheid);

			/* the final result is the union of both (we can discard the
			 * tail, as they *should* be equal when the heads are equal
			 * too... */
			r = BATkunion(t1, t3);
			BBPunfix(t1->batCacheid);
			BBPunfix(t3->batCacheid);
		}
		BBPunfix(*scenarios);
	} else {
		r = BATcopy(user, user->htype, user->ttype, FALSE);
	}
	*ret = r;
	return(NULL);
}

/**
 * Returns the password hash as used by the backend for the given
 * username.  Throws an exception if called by a non-superuser.
 */
str
AUTHgetPasswordHash(str *ret, Client *c, str *username) {
	BUN p;
	oid id;
	BATiter i;
	str tmp;
	str passwd = NULL;

	rethrow("getPasswordHash", tmp, AUTHrequireAdmin(c));

	if (*username == NULL || strNil(*username))
		throw(ILLARG, "getPasswordHash", "username should not be nil");

	p = BUNfnd(BATmirror(user), *username);
	if (p == BUN_NONE)
		throw(MAL, "getPasswordHash", "user '%s' does not exist", *username);
	i = bat_iterator(user);
	id = *(oid*)BUNhead(i, p);
	p = BUNfnd(pass, &id);
	assert(p != BUN_NONE);
	i = bat_iterator(pass);
	tmp = BUNtail(i, p);
	assert (tmp != NULL);
	/* decypher the password */
	rethrow("changePassword", tmp, AUTHdecypherValue(&passwd, &tmp));

	*ret = GDKstrdup(passwd);
	return(NULL);
}


/*=== the vault ===*/

/* yep, the vault key is just stored in memory */
static str vaultKey = NULL;

/**
 * Unlocks the vault with the given password.  Since the password is
 * just the decypher key, it is not possible to directly check whether
 * the given password is correct.  If incorrect, however, all decypher
 * operations will probably fail or return an incorrect decyphered
 * value.
 */
str
AUTHunlockVault(str *password) {
	if (password == NULL || strNil(*password))
		throw(ILLARG, "unlockVault", "password should not be nil");

	/* even though I think this function should be called only once, it
	 * is not of real extra efforts to avoid a mem-leak if it is used
	 * multiple times */
	if (vaultKey != NULL)
		GDKfree(vaultKey);

	vaultKey = GDKstrdup(*password);
	return(MAL_SUCCEED);
}

/**
 * Decyphers a given value, using the vaultKey.  The returned value
 * might be incorrect if the vaultKey is incorrect or unset.  If the
 * cypher algorithm fails or detects an invalid password, it might throw
 * an exception.  The ret string is GDKmalloced, and should be GDKfreed
 * by the caller.
 */
static str
AUTHdecypherValue(str *ret, str *value) {
	/* Cyphering and decyphering can be done using many algorithms.
	 * Future requirements might want a stronger cypher than the XOR
	 * cypher chosen here.  It is left up to the implementor how to do
	 * that once those algoritms become available.  It could be
	 * #ifdef-ed or on if-basis depending on whether the cypher
	 * algorithm is a compile, or runtime option.  When necessary, this
	 * function could be extended with an extra argument that indicates
	 * the cypher algorithm.
	 */
	
	/* this is the XOR decypher implementation */
	str r = GDKmalloc(sizeof(char) * (strlen(*value) + 1));
	str w = r;
	str s = *value;
	char t = '\0';
	int escaped = 0;
	/* we default to some garbage key, just to make password unreadable
	 * (a space would only uppercase the password) */
	int keylen = 0;

	if (vaultKey == NULL)
		throw(MAL, "decypherValue", "The vault is still locked!");

	keylen = (int) strlen(vaultKey);

	/* XOR all characters.  If we encounter a 'one' char after the XOR
	 * operation, it is an escape, so replace it with the next char. */
	for (; (t = *s) != '\0'; s++) {
		if (t == '\1' && escaped == 0) {
			escaped = 1;
			continue;
		} else if (escaped != 0) {
			t -= 1;
			escaped = 0;
		}
		*w = t ^ vaultKey[(w - r) % keylen];
		w++;
	}
	*w = '\0';

	*ret = r;
	return(MAL_SUCCEED);
}

/**
 * Cyphers the given string using the vaultKey.  If the cypher algorithm
 * fails or detects an invalid password, it might throw an exception.
 * The ret string is GDKmalloced, and should be GDKfreed by the caller.
 */
static str
AUTHcypherValue(str *ret, str *value) {
	/* this is the XOR cypher implementation */
	str r = GDKmalloc(sizeof(char) * (strlen(*value) * 2 + 1));
	str w = r;
	str s = *value;
	/* we default to some garbage key, just to make password unreadable
	 * (a space would only uppercase the password) */
	int keylen = 0;

	if (vaultKey == NULL)
		throw(MAL, "cypherValue", "The vault is still locked!");

	keylen = (int) strlen(vaultKey);

	/* XOR all characters.  If we encounter a 'zero' char after the XOR
	 * operation, escape it with an 'one' char. */
	for (; *s != '\0'; s++) {
		*w = *s ^ vaultKey[(s - *value) % keylen];
		if (*w == '\0') {
			*w++ = '\1';
			*w = '\1';
		} else if (*w == '\1') {
			*w++ = '\1';
			*w = '\2';
		}
		w++;
	}
	*w = '\0';

	*ret = r;
	return(MAL_SUCCEED);
}

/**
 * Returns a comma separated list of supported hash algorithms.  The
 * returned string is GDKmalloced and should be GDKfreed.
 */
str
AUTHgetHashAlgorithms(str *ret) {
	/* Currently, four "hashes" are available, RIPEMD160, SHA-2, SHA-1
	 * and MD5.  Previous versions supported UNIX crypt and plain text
	 * login, but those were removed when SHA-1 became mandatory for
	 * hashing the plain password in wire protocol version 9.
	 * Better/stronger/faster algorithms can be added in the future upon
	 * desire.
	 */
	*ret = GDKstrdup("RIPEMD160,SHA256,SHA1,MD5");
	return(MAL_SUCCEED);
}

#ifdef HAVE_MD5
/**
 * Returns a GDKmalloced string representing the hex representation of
 * the MD5 hash of the given string.
 */
str
AUTHMD5Sum(str *ret, str *string, int *len) {
	unsigned char md[16]; /* should be MD5_DIGEST_LENGTH */

	MD5((unsigned char*)*string, *len, md);
	*ret = GDKmalloc(sizeof(char) * (16 * 2 + 1));
	sprintf(*ret, "%02x%02x%02x%02x%02x%02x%02x%02x"
			"%02x%02x%02x%02x%02x%02x%02x%02x",
			md[0], md[1], md[2], md[3],
			md[4], md[5], md[6], md[7],
			md[8], md[9], md[10], md[11],
			md[12], md[13], md[14], md[15]
		   );

	return(MAL_SUCCEED);
}
#endif

#ifdef HAVE_SHA1
/**
 * Returns a GDKmalloced string representing the hex representation of
 * the SHA-1 hash of the given string.
 */
str
AUTHSHA1Sum(str *ret, str *string, int *len) {
	unsigned char md[20]; /* should be SHA_DIGEST_LENGTH */

	SHA1((unsigned char*)*string, *len, md);
	*ret = GDKmalloc(sizeof(char) * (20 * 2 + 1));
	sprintf(*ret, "%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"
			"%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x",
			md[0], md[1], md[2], md[3], md[4],
			md[5], md[6], md[7], md[8], md[9],
			md[10], md[11], md[12], md[13], md[14],
			md[15], md[16], md[17], md[18], md[19]
		   );

	return(MAL_SUCCEED);
}
#endif

#if defined(HAVE_SHA224) || defined(HAVE_SHA256) || defined(HAVE_SHA384) || defined(HAVE_SHA512)
/**
 * Returns a GDKmalloced string representing the hex representation of
 * the SHA-2 hash with number of bits of the given string.
 */
str
AUTHSHA2Sum(str *ret, str *string, int *len, int *number) {
	unsigned char md[64]; /* should be SHA512_DIGEST_LENGTH */

	switch (*number) {
#ifdef HAVE_SHA224
		case 224:
			SHA224((unsigned char*)*string, *len, md);
			*ret = GDKmalloc(sizeof(char) * (28 * 2 + 1));
			sprintf(*ret,
					"%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"
					"%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"
					"%02x%02x%02x%02x%02x%02x%02x%02x",
					md[0], md[1], md[2], md[3], md[4],
					md[5], md[6], md[7], md[8], md[9],
					md[10], md[11], md[12], md[13], md[14],
					md[15], md[16], md[17], md[18], md[19],
					md[20], md[21], md[22], md[23], md[24],
					md[25], md[26], md[27]
				   );
		break;
#endif
#ifdef HAVE_SHA256
		case 256:
			SHA256((unsigned char*)*string, *len, md);
			*ret = GDKmalloc(sizeof(char) * (32 * 2 + 1));
			sprintf(*ret,
					"%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"
					"%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"
					"%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"
					"%02x%02x",
					md[0], md[1], md[2], md[3], md[4],
					md[5], md[6], md[7], md[8], md[9],
					md[10], md[11], md[12], md[13], md[14],
					md[15], md[16], md[17], md[18], md[19],
					md[20], md[21], md[22], md[23], md[24],
					md[25], md[26], md[27], md[28], md[29],
					md[30], md[31]
				   );
		break;
#endif
#ifdef HAVE_SHA384
		case 384:
			SHA384((unsigned char*)*string, *len, md);
			*ret = GDKmalloc(sizeof(char) * (48 * 2 + 1));
			sprintf(*ret,
					"%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"
					"%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"
					"%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"
					"%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"
					"%02x%02x%02x%02x%02x%02x%02x%02x",
					md[0], md[1], md[2], md[3], md[4],
					md[5], md[6], md[7], md[8], md[9],
					md[10], md[11], md[12], md[13], md[14],
					md[15], md[16], md[17], md[18], md[19],
					md[20], md[21], md[22], md[23], md[24],
					md[25], md[26], md[27], md[28], md[29],
					md[30], md[31], md[32], md[33], md[34],
					md[35], md[36], md[37], md[38], md[39],
					md[40], md[41], md[42], md[43], md[44],
					md[45], md[46], md[47]
				   );
		break;
#endif
#ifdef HAVE_SHA512
		case 512:
			SHA512((unsigned char*)*string, *len, md);
			*ret = GDKmalloc(sizeof(char) * (64 * 2 + 1));
			sprintf(*ret,
					"%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"
					"%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"
					"%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"
					"%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"
					"%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"
					"%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"
					"%02x%02x%02x%02x",
					md[0], md[1], md[2], md[3], md[4],
					md[5], md[6], md[7], md[8], md[9],
					md[10], md[11], md[12], md[13], md[14],
					md[15], md[16], md[17], md[18], md[19],
					md[20], md[21], md[22], md[23], md[24],
					md[25], md[26], md[27], md[28], md[29],
					md[30], md[31], md[32], md[33], md[34],
					md[35], md[36], md[37], md[38], md[39],
					md[40], md[41], md[42], md[43], md[44],
					md[45], md[46], md[47], md[48], md[49],
					md[50], md[51], md[52], md[53], md[54],
					md[55], md[56], md[57], md[58], md[59],
					md[60], md[61], md[62], md[63]
				   );
		break;
#endif
		default:
			throw(MAL, "AUTHSHA2Sum", "%d is not a valid bit length, "
					"choose one of 224, 256, 384 or 512", *number);
	}


	return(MAL_SUCCEED);
}
#endif

#ifdef HAVE_RIPEMD160
/**
 * Returns a GDKmalloced string representing the hex representation of
 * the RIPEMD-160 hash of the given string.
 */
str
AUTHRIPEMD160Sum(str *ret, str *string, int *len) {
	unsigned char md[20]; /* should be RIPEMD160_DIGEST_LENGTH */

	RIPEMD160((unsigned char*)*string, *len, md);
	*ret = GDKmalloc(sizeof(char) * (20 * 2 + 1));
	sprintf(*ret, "%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"
			"%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x",
			md[0], md[1], md[2], md[3], md[4],
			md[5], md[6], md[7], md[8], md[9],
			md[10], md[11], md[12], md[13], md[14],
			md[15], md[16], md[17], md[18], md[19]
		   );

	return(MAL_SUCCEED);
}
#endif

/**
 * Returns a GDKmalloced string representing the hex representation of
 * the by the backend used hash of the given string.
 */
str
AUTHBackendSum(str *ret, str *string, int *len) {
	int bits;
#ifdef HAVE_RIPEMD160
	if (strcmp(MONETDB5_PASSWDHASH, "RIPEMD160") == 0) {
		AUTHRIPEMD160Sum(ret, string, len);
	} else
#endif
#ifdef HAVE_SHA512
	if (strcmp(MONETDB5_PASSWDHASH, "SHA512") == 0) {
		bits = 512;
		AUTHSHA2Sum(ret, string, len, &bits);
	} else
#endif
#ifdef HAVE_SHA384
	if (strcmp(MONETDB5_PASSWDHASH, "SHA384") == 0) {
		bits = 384;
		AUTHSHA2Sum(ret, string, len, &bits);
	} else
#endif
#ifdef HAVE_SHA256
	if (strcmp(MONETDB5_PASSWDHASH, "SHA256") == 0) {
		bits = 256;
		AUTHSHA2Sum(ret, string, len, &bits);
	} else
#endif
#ifdef HAVE_SHA224
	if (strcmp(MONETDB5_PASSWDHASH, "SHA224") == 0) {
		bits = 224;
		AUTHSHA2Sum(ret, string, len, &bits);
	} else
#endif
#ifdef HAVE_SHA1
	if (strcmp(MONETDB5_PASSWDHASH, "SHA1") == 0) {
		AUTHSHA1Sum(ret, string, len);
	} else
#endif
#ifdef HAVE_MD5
	if (strcmp(MONETDB5_PASSWDHASH, "MD5") == 0) {
		AUTHMD5Sum(ret, string, len);
	} else
#endif
	{
		throw(MAL, "BackendSum", "Unknown backend hash algorithm: %s",
				MONETDB5_PASSWDHASH);
	}
	return(MAL_SUCCEED);
}

/**
 * Returns the hash for the given password, challenge and algorithm.
 * The hash calculated using the given algorithm over the password
 * concatenated with the challenge.  The returned string is allocated
 * using GDKmalloc, and hence should be freed with GDKfree by the
 * caller.
 */
static str
AUTHhashPassword(str *ret, str *algo, str *password, str *challenge) {
	str tmp;
	int len = (int) (strlen(*password) + strlen(*challenge));
	str key = alloca(sizeof(char) * (len + 1));
	snprintf(key, len + 1, "%s%s", *password, *challenge);

#ifdef HAVE_RIPEMD160
	if (strcmp(*algo, "RIPEMD160") == 0) {
		rethrow("hashPassword", tmp, AUTHRIPEMD160Sum(ret, &key, &len));
	} else
#endif
#ifdef HAVE_SHA512
	if (strcmp(*algo, "SHA512") == 0) {
		int bits = 512;
		rethrow("hashPassword", tmp, AUTHSHA2Sum(ret, &key, &len, &bits));
	} else
#endif
#ifdef HAVE_SHA384
	if (strcmp(*algo, "SHA384") == 0) {
		int bits = 384;
		rethrow("hashPassword", tmp, AUTHSHA2Sum(ret, &key, &len, &bits));
	} else
#endif
#ifdef HAVE_SHA256
	if (strcmp(*algo, "SHA256") == 0) {
		int bits = 256;
		rethrow("hashPassword", tmp, AUTHSHA2Sum(ret, &key, &len, &bits));
	} else
#endif
#ifdef HAVE_SHA224
	if (strcmp(*algo, "SHA224") == 0) {
		int bits = 224;
		rethrow("hashPassword", tmp, AUTHSHA2Sum(ret, &key, &len, &bits));
	} else
#endif
#ifdef HAVE_SHA1
	if (strcmp(*algo, "SHA1") == 0) {
		rethrow("hashPassword", tmp, AUTHSHA1Sum(ret, &key, &len));
	} else
#endif
#ifdef HAVE_MS5
	if (strcmp(*algo, "MD5") == 0) {
		rethrow("hashPassword", tmp, AUTHMD5Sum(ret, &key, &len));
	} else
#endif
	{
		throw(MAL, "hashPassword", "unsupported hash type: '%s'", *algo);
	}

	return(MAL_SUCCEED);
}

/**
 * Checks if the given string is a (hex represented) hash for the
 * current backend.  This check allows to at least forbid storing
 * trivial plain text passwords by a simple check.
 */
static str
AUTHverifyPassword(int *ret, str *passwd) {
	char *p = *passwd;
	size_t len = strlen(p);

	(void)ret;

#ifdef HAVE_RIPEMD160
	if (strcmp(MONETDB5_PASSWDHASH, "RIPEMD160") == 0) {
		if (len != 20 * 2)
			throw(MAL, "verifyPassword",
					"password is not 40 chars long, is it a hex "
					"representation of a RIPEMD160 password hash?");
	} else
#endif
#ifdef HAVE_SHA512
	if (strcmp(MONETDB5_PASSWDHASH, "SHA512") == 0) {
		if (len != 64 * 2)
			throw(MAL, "verifyPassword",
					"password is not 128 chars long, is it a hex "
					"representation of a SHA-2 512-bits password hash?");
	} else
#endif
#ifdef HAVE_SHA384
	if (strcmp(MONETDB5_PASSWDHASH, "SHA384") == 0) {
		if (len != 48 * 2)
			throw(MAL, "verifyPassword",
					"password is not 96 chars long, is it a hex "
					"representation of a SHA-2 384-bits password hash?");
	} else
#endif
#ifdef HAVE_SHA256
	if (strcmp(MONETDB5_PASSWDHASH, "SHA256") == 0) {
		if (len != 32 * 2)
			throw(MAL, "verifyPassword",
					"password is not 64 chars long, is it a hex "
					"representation of a SHA-2 256-bits password hash?");
	} else
#endif
#ifdef HAVE_SHA224
	if (strcmp(MONETDB5_PASSWDHASH, "SHA224") == 0) {
		if (len != 28 * 2)
			throw(MAL, "verifyPassword",
					"password is not 56 chars long, is it a hex "
					"representation of a SHA-2 224-bits password hash?");
	} else
#endif
#ifdef HAVE_SHA1
	if (strcmp(MONETDB5_PASSWDHASH, "SHA1") == 0) {
		if (len != 20 * 2)
			throw(MAL, "verifyPassword",
					"password is not 40 chars long, is it a hex "
					"representation of a SHA-1 password hash?");
	} else
#endif
#ifdef HAVE_MD5
	if (strcmp(MONETDB5_PASSWDHASH, "MD5") == 0) {
		if (len != 16 * 2)
			throw(MAL, "verifyPassword",
					"password is not 32 chars long, is it a hex "
					"representation of an MD5 password hash?");
	} else
#endif
	{
		throw(MAL, "verifyPassword", "Unknown backend hash algorithm: %s",
				MONETDB5_PASSWDHASH);
	}

	while (*p != '\0') {
		if (!((*p >= 'a' && *p <= 'z') || (*p >= '0' && *p <= '9')))
			throw(MAL, "verifyPassword",
					"password does contain invalid characters, is it a"
					"lowercase hex representation of a hash?");
		p++;
	}

	return(MAL_SUCCEED);
}
@}
