@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.monetdb.org/Legal/MonetDBLicense

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2011 MonetDB B.V.
All Rights Reserved.
@

@c
/*
 * @a M. L. Kersten
 * @v 5.0
 * @-
 * Clients gain access to the Monet server through a internet connection
 * or through its server console.
 * Access through the internet requires a client program at the
 * source, which addresses the default port of a running server.
 * The functionality of the server console is limited.
 * It is a textual interface for expert use.
 *
 * @ifset M5manual
 * At the server side, each client is represented by a session record with the
 * current status, such as name, file descriptors, namespace, and local stack.
 * Each client session has a dedicated thread of control, which limits
 * the number of concurrent users to the thread management facilities of the
 * underlying operating system. A large client base should be supported using
 * a single server-side client thread, geared at providing
 * a particular service.
 *
 * The number of clients permitted concurrent access is
 * a compile time option. The console is the first and is always present.
 * It reads from standard input and writes to standard output.
 * @end ifset
 *
 * Client sessions remain in existence until the corresponding
 * communication channels break or its retention timer expires
 * The administrator and owner of a sesssion
 * can manipulate the timeout with a system call.
 *
 * @ifset sqlmanual
 * There are many user-friendly tools to interact with a SQL database server.
 * A few based on the JDBC library of MonetDB are included for reference only.
 * @end ifset
 * Client records are linked into a hierarchy, where the top record
 * denotes the context of the Monet administrator. The next layer
 * is formed by a database administrator and the third layer contains
 * user sessions.
 * This hierachy is used to share and constrain resources, such
 * as global variables or references to catalogue information.
 * During parallel execution additional layers may be constructed.
 * [This feature needs more implementation support]
 *
 * The routines defined below provide management of the client
 * administration. Routines dealing with serviceing requests
 * are located in mal_startup.
 */
@h
#ifndef _MAL_CLIENT_H_
#define _MAL_CLIENT_H_
#define bitset int

/*#define MAL_CLIENT_DEBUG */

#include "mal_resolve.h"
#include "mal_profiler.h"
#include "mal.h"

#define MAL_MAXCLIENTS  64
#define CONSOLE     0
#define isAdministrator(X) (X==mal_clients)

#define FREECLIENT  0
#define FINISHING   1   
#define CLAIMED     2
#define AWAITING    4

#define TIMEOUT     (5*60)  /* seconds */
#define PROCESSTIMEOUT  2   /* seconds */

#ifdef HAVE_SYS_RESOURCE_H
# include <sys/resource.h>
#endif

#ifdef HAVE_SYS_TIMES_H
# include <sys/times.h>
#endif
#include <setjmp.h>

/*
 * @-
 * The prompt structure is designed to simplify recognition
 * of the language framework for interaction. For direct console
 * access it is a short printable ascii string. For access through
 * an API we assume the prompt is an ascii string surrounded by a \001
 * character. This simplifies recognition.
 * The information between the prompt brackets can be used to
 * pass the mode to the front-end. Moreover, the prompt can be
 * dropped if a single stream of information is expected from the
 * server(See mal_profiler.mx).
 * @-
 * The user can request server-side compilation as part of the
 * initialization string. See the documentation on Scenarios.
 */
typedef struct CLIENT_INPUT {
	bstream             *fdin;
	int                 yycur;		
	int                 listing;
	char                *prompt;
	struct CLIENT_INPUT *next;    
} ClientInput;

typedef struct CLIENT {
	int idx;        /* entry in mal_clients */
	oid user;       /* user id in the auth administration */
	/*
	 * @-
	 * The actions for a client is separated into several stages: parsing,
	 * strategic optimization, tactial optimization, and execution.
	 * The routines to handle them are obtained once the scenario is choosen.
	 * Each stage carries a state descriptor, but they share the IO state
	 * description. A backup structure is provided
	 * to temporarily switch to another scenario. Propagation of the state
	 * information should be dealt with separately.[TODO]
	 */
	str     scenario;  /* scenario management references */
	str     oldscenario;
	void    *state[7], *oldstate[7];
	MALfcn  phase[7], oldphase[7];
	sht	stage;	   /* keep track of the phase being ran */
	char    itrace;    /* trace execution using interactive mdb */
						/* if set to 'S' it will put the process to sleep */
	short   debugOptimizer,debugScheduler;
	/*
	 * @-
	 * For program debugging we need information on the timer and memory
	 * usage patterns.
	 */
	sht	flags;	 /* resource tracing flags */
	lng     timer;   /* trace time in usec */
	lng	bigfoot; /* maximum virtual memory use */
	lng	vmfoot;  /* virtual memory use */
	lng memory;	/* memory claimed for keeping BATs */
	BUN	cnt;	/* bat count */

#define timerFlag	1
#define memoryFlag	2
#define ioFlag		4
#define flowFlag	8
#define bigfootFlag	16
#define cntFlag		32
#define threadFlag	64
#define bbpFlag		128
	/*
	 * @-
	 * @-
	 * Session structures are currently not saved over network failures.
	 * Future releases may support a re-connect facility.  [TODO]
	 */
	time_t      login;  
	time_t      lastcmd;	/* set when input is received */
	unsigned int  delay;	/* not yet used */
	int 	    qtimeout;	/* query abort after x seconds */
	int	    stimeout;	/* session abort after x seconds */
	/*
	 * @-
	 * Communication channels for the interconnect are stored here.
	 * It is perfectly legal to have a client without input stream.
	 * It will simple terminate after consuming the input buffer.
	 */
	str       srcFile;  /* NULL for stdin, or file name */
	bstream  *fdin;
	int       yycur;    /* the scanners current position */
	/*
	 * @-
	 * Keeping track of instructions executed is a valueable tool for
	 * script processing and debugging.
	 * Its default value is defined in the MonetDB configuration file.
	 * It can be changed at runtime for individual clients using
	 * the operation @sc{clients.listing}(@emph{mask}).
	 * A listing bit controls the level of detail to be generated during
	 * program execution tracing. The lowest level (1) simply dumps the input,
	 * (2) also demonstrates the MAL internal structur (4) adds the
	 * type information
	 */
	bitset  listing;        
	str prompt;         /* acknowledge prompt */
	size_t promptlength;
	ClientInput *bak;   /* used for recursive script and string execution */

	stream   *fdout;    /* streams from and to user. */
	/*
	 * @-
	 * In interactive mode, reading one line at a time, we should be
	 * aware of parsing compound structures, such as functions and
	 * barrier blocks. The level of nesting is maintained in blkmode,
	 * which is reset to zero upon encountering an end instruction,
	 * or the closing bracket has been detected. Once the complete
	 * structure has been parsed the program can be checked and executed.
	 * Nesting is indicated using a '+' before the prompt.
	 */
	int blkmode;        /* control block parsing */
	/*
	 * @-
	 * The MAL debugger uses the client record to keep track of
	 * any pervasive debugger command. For detailed information
	 * on the debugger features.
	 */
	bitset debug;
	void  *mdb;            /* context upon suspend */
	str    history;	       /* where to keep console history */
	short  mode;           /* FREECLIENT..BLOCKED */
	/*
	 * @-
	 * Client records are organized into a two-level dependency
	 * tree, where children may be created to deal with parallel processing
	 * activities. Each client runs in its own process thread. Its identity
	 * is retained here for access by others (=father).
	 */
	MT_Sema 	s;	    /* sema to (de)activate thread */ 
	Thread      	mythread;
	MT_Id		mypid;
	str     	errbuf;     /* location of GDK exceptions */
	struct CLIENT   *father;    
	/*
	 * @-
	 * Each client has a private entry point into the namespace and
	 * object space (the global variables).
	 * Moreover, the parser needs some administration variables
	 * to keep track of critical elements.
	 */
	Module      nspace;     /* private scope resolution list */
	Symbol      curprg;     /* focus of parser */
	Symbol      backup;     /* save parsing context */
	MalStkPtr   glb;        /* global variable stack */
	/*
	 * @-
	 * Some statistics on client behavior becomes relevant
	 * for server maintenance. The scenario loop is used as
	 * a frame of reference. We measure the elapsed time after
	 * a request has been received and we have to wait for
	 * the next one.
	 */
	int		actions;
	lng		totaltime;	/* sum of elapsed processing times */
	struct RECSTAT *rcc;	/* recycling stat */
#ifdef HAVE_TIMES
	struct tms	workload;
#endif
	jmp_buf	exception_buf;
	int exception_buf_initialized;
} *Client, ClientRec;

mal_export ClientRec mal_clients[MAL_MAXCLIENTS+1];
mal_export int MCdefault;

mal_export Client  MCgetClient(int id);
mal_export Client  MCfindClient(oid user, str scen, bstream *fin, stream *fout);
mal_export Client  MCinitClient(oid user, bstream *fin, stream *fout);
mal_export int     MCinitClientThread(Client c);
mal_export void    MCcloseClient    (Client c);
mal_export Client  MCforkClient     (Client c);
mal_export int	   MCcountClients(void);
mal_export int     MCreadClient  (Client c);
mal_export str	   MCsuspendClient(int id, unsigned int timeout);
mal_export str	   MCawakeClient(int id);
mal_export int     MCwait(Client c);
mal_export void    MCcleanupClients(void);
mal_export void    MCexitPending(void);
mal_export void    MCtraceAllClients(int flag);
mal_export void    MCtraceClient(oid which, int flag);
mal_export int     MCpushClientInput(Client c, bstream *new_input, int listing, char *prompt);
mal_export void    MCpopClientInput(Client c);

#endif /* _MAL_CLIENT_H_ */
@c
/*
 * @-
 *
 * A client record is initialized upon acceptance of a connection.
 * The client runs in his own thread of control until it finds a
 * soft-termination request mode (FINISHING) or its IO file
 * descriptors are closed. The latter generates an IO error, which
 * leads to a safe termination.
 *
 * The system administrator client runs in the primary thread of
 * control to simplify debugging with external debuggers.
 *
 * A new Client structure can only be requested if the 'adm'
 * user is available, because it guarantees a way to deliver
 * ny error message.
 * Searching a free client record is encapsulated in
 * a critical section to hand them out one-at-a-time.
 * Marking them as being claimed avoids any interference from parallel
 * actions to obtain client records.
 */
#include "monetdb_config.h"
#include "mal_client.h"
#include "mal_readline.h"
#include "mal_import.h"
#include "mal_parser.h"
#include "mal_namespace.h"
#include <mapi.h> /* for PROMPT1 */


/* This should be in src/mal/mal.h, as the function is implemented in 
 * src/mal/mal.c; however, it cannot, as "Client" isn't known there ... |-( 
 * For now, we move the prototype here, as it it only used here.
 * Maybe, we should concider also moving the implementation here...

int streamClient(Client c, str prompt);
int bstreamClient(Client c, str prompt);
 */

static void     freeClient  (Client c);

ClientRec   mal_clients[MAL_MAXCLIENTS+1];
/*int MCdefault= threadFlag | bigfootFlag;*/
int MCdefault= 0;

int MCpushClientInput(Client c, bstream *new_input, int listing, char *prompt)
{
	ClientInput *x = (ClientInput*)GDKmalloc(sizeof(ClientInput));
	if ( x == 0 )
		return -1;
	x->fdin = c->fdin;
	x->yycur = c->yycur;
	x->listing = c->listing;
	x->prompt = c->prompt;
	x->next = c->bak;
	c->bak = x;
	c->fdin = new_input;
	c->listing = listing;
	c->prompt = prompt? GDKstrdup(prompt):GDKstrdup("");
	c->promptlength = strlen(c->prompt);
	c->yycur = 0;
	return 0;
}

void MCpopClientInput(Client c)
{
	ClientInput *x = c->bak;
	if (c->fdin) {
		/* missing protection against closing stdin stream */
		(void) bstream_destroy(c->fdin);
	}
	GDKfree(c->prompt);
	c->fdin = x->fdin;
	c->yycur = x->yycur;
	c->listing = x->listing;
	c->prompt = x->prompt;
	c->promptlength = strlen(c->prompt);
	c->bak = x->next;
	GDKfree(x);
}

static Client MCnewClient(void)
{
	Client  c;
	mal_set_lock(mal_contextLock, "newClient");
	if (mal_clients[CONSOLE].user &&
	    mal_clients[CONSOLE].mode == FINISHING) {
		showException(MAL,"newClient", "system shutdown in progress");
		mal_unset_lock(mal_contextLock, "newClient");
		return NULL;
	}
	for (c = mal_clients; c < mal_clients+MAL_MAXCLIENTS; c++) {
		if (c->mode == FREECLIENT) {
			c->mode= CLAIMED;
			break;
		}
	}
	mal_unset_lock(mal_contextLock, "newClient");

	if (c == mal_clients+MAL_MAXCLIENTS) 
		return NULL;
	c->idx= (int)(c - mal_clients);
#ifdef MAL_CLIENT_DEBUG
	printf("New client created %d\n", (int)(c-mal_clients));
#endif
	return c;
}
/*
 * @-
 * You can always retrieve a client record using the thread identifier,
 * because we maintain a 1-1 mapping between client and thread of control.
 * Therefore, we don't need locks either.
 * If the number of clients becomes too large, we have to change the
 * allocation and lookup scheme.
 *
 * Finding a client record is tricky when we are spawning threads
 * as co-workers. It is currently passed as an argument.
 */

Client MCgetClient(int id)
{
	if (id < 0 || id > MAL_MAXCLIENTS)
		return NULL;
	return(mal_clients + id);
}

Client
MCfindClient(oid user, str scen, bstream *fin, stream *fout)
{
	Client c = NULL;
	Scenario s = findScenario(scen);

	if (!s) {
		showException(MAL, "findClient",
				"findScenario returned NULL for '%s'", scen);
		mnstr_printf(fout, "!could not find scenario '%s'\n", scen);
		mnstr_flush(fout);
		return NULL;
	}

	mal_set_lock(mal_contextLock, "newClient");
	if (mal_clients[CONSOLE].user && mal_clients[CONSOLE].mode == FINISHING) {
		showException(MAL, "newClient", "system shutdown in progress");
		mal_unset_lock(mal_contextLock, "newClient");
		mnstr_printf(fout, "!system shutdown in progress, please try again later\n");
		mnstr_flush(fout);
		return NULL;
	}
	for (c = mal_clients; c < mal_clients + MAL_MAXCLIENTS; c++) {
		if (c->mode == AWAITING && c->scenario == s->name) {
			/* remove garbage from previous session */
			if (c->nspace) {
				freeModule(c->nspace);
				c->nspace = 0;
			}
			c->mode = CLAIMED;
			break;
		}
	}
	mal_unset_lock(mal_contextLock, "newClient");

	if (c == mal_clients + MAL_MAXCLIENTS)
		return NULL;
#ifdef MAL_CLIENT_DEBUG
	printf("Client found %d\n", c->idx);
#endif
	c->user = user;
	c->fdin = fin ? fin : bstream_create(GDKin, 0);
	c->yycur = 0;
	c->bak = NULL;

	c->listing = 0;
	c->flags = MCdefault;
	c->fdout = fout ? fout : GDKstdout;
	c->mdb = 0;
	c->login = time(0);
	memset((char *) c->rcc, 0, sizeof(RecStat));
	c->rcc->curQ = -1;
	/* (re)activate thread */
	MT_sema_up(&c->s, "MCfindClient");
	return c;
}

static void
MCexitClient(Client c)
{
#ifdef MAL_CLIENT_DEBUG
	printf("# Exit client %d\n", c->idx);
#endif
	MPresetProfiler(c->fdout);
	if (c->father == NULL) { /* normal client */
		if( c->fdout && c->fdout != GDKstdout){
			(void) mnstr_close(c->fdout);
			(void) mnstr_destroy(c->fdout);
		}
		assert(c->bak==NULL);
		if(c->fdin){
			/* missing protection against closing stdin stream */
			(void) bstream_destroy(c->fdin);
		}
		c->fdout = NULL;
		c->fdin= NULL;
	} 
}

int
MCwait(Client c) 
{
	if (c != mal_clients && c->mode == FINISHING) {
		mal_set_lock(mal_contextLock, "wait");
		c->mode = AWAITING;
		/* close streams */
		mal_unset_lock(mal_contextLock, "wait");
		MCexitClient(c);
		/* wait for work */
#ifdef MAL_DEBUG_CLIENT
		mnstr_printf(c->fdout,"Put client into pool %d\n",c->idx);
#endif
		MT_sema_down(&c->s, "MSserveClient");
#ifdef MAL_DEBUG_CLIENT
		mnstr_printf(c->fdout,"Awake client in pool %d\n",c->idx);
#endif
		c->mythread->data[1] = c->fdin;
		c->mythread->data[0] = c->fdout;
		return (c->mode == CLAIMED);
	}
	return 1;
}

Client MCinitClient(oid user, bstream *fin, stream *fout) 
{
	Client c = NULL; 
	str prompt;

	if ((c = MCnewClient()) == NULL)
		return NULL;

	c->user = user; 
	c->scenario = NULL;
	c->oldscenario = NULL;
	c->srcFile = NULL;
	c->blkmode = 0;

	c->fdin = fin ? fin : bstream_create(GDKin,0);
	c->yycur = 0;
	c->bak = NULL;

	c->listing = 0;
	c->fdout = fout ? fout : GDKstdout;
	c->mdb = 0;
	c->history = 0;
	c->curprg = c->backup = 0;
	c->glb = 0;

	c->father = NULL;
	c->login = c->lastcmd= time(0);
	c->delay= TIMEOUT;
	c->qtimeout= 0;
	c->stimeout= 0;
	c->stage = 0;
	c->itrace = 0;
	c->debugOptimizer = c->debugScheduler= 0;
	c->flags= MCdefault;
	c->timer = 0;
	c->bigfoot = 0;
	c->vmfoot = 0;
	c->memory = 0;
	c->errbuf = 0;

	prompt = !fin? GDKgetenv("monet_prompt"): PROMPT1;
	c->prompt= GDKstrdup(prompt);
	c->promptlength= strlen(prompt);

	c->actions =0;
	c->totaltime= 0;
	c->rcc = (RecPtr) GDKzalloc(sizeof(RecStat));
	c->rcc->curQ = -1;
	c->exception_buf_initialized = 0;
	MT_sema_init(&c->s, 0, "MCinitClient");
	return c;
}

/*
 * @-
 * The administrator should be initialized to enable
 * interpretation of the command line arguments, before
 * it starts serviceing statements
 */
int MCinitClientThread(Client c)
{
	Thread t;
	char cname[11 + 1];

	snprintf(cname, 11, OIDFMT, c->user);
	cname[11] = '\0';
	c->mypid = MT_getpid();
	t = THRnew(c->mypid,cname);
	if ( t==0) {
		showException(MAL, "initClientThread", "Failed to initialize client");
		MPresetProfiler(c->fdout);
		return -1;
	}
	/*
	 * @-
	 * The GDK thread administration should be set to reflect use of
	 * the proper IO descriptors.
	 */
	t->data[1] = c->fdin;
	t->data[0] = c->fdout;
	c->mythread = t;
	c->errbuf = GDKerrbuf;
	if (c->errbuf == NULL) {
		GDKsetbuf( GDKzalloc(GDKMAXERRLEN));
		c->errbuf = GDKerrbuf;
	} else
		c->errbuf[0]=0;
	return 0;
} 
/*
 * @- Client decendants
 * Forking is a relatively cheap way to create a new client.
 * The new client record shares the IO descriptors.
 * To avoid interference, we limit children to only produce
 * output by closing the input-side.
 *
 * If the father itself is a temporary client, let
 * the new child depend on the grandfather.
 */
Client MCforkClient(Client father){
	Client son = NULL;
	if( father == NULL) return NULL;
	if (father->father != NULL) father = father->father;
	if ((son = MCinitClient(father->user, father->fdin, father->fdout))) {
		son->fdin= NULL;
		son->fdout= father->fdout;
		son->bak= NULL;
		son->yycur=0;
		son->father = father;
		son->scenario = father->scenario;
		if( son->prompt)
			GDKfree(son->prompt);
		son->prompt = GDKstrdup(father->prompt);
		son->promptlength= strlen(father->prompt);
		/* reuse the scopes wherever possible */
		if(son->nspace==0)
			son->nspace = newModule(NULL, putName("child",5));
		son->nspace->outer = father->nspace->outer;
	}
	return son;
}

/*
 * @-
 *
 * When a client needs to be terminated then the file descriptors for
 * its input/output are simply closed.
 * This leads to a graceful degradation, but may take some time
 * when the client is busy.
 * A more forcefull method is to kill the client thread, but this
 * may leave locks and semaphores in an undesirable state.
 *
 * The routine freeClient ends a single client session,
 * but through side effects of sharing IO descriptors,
 * also its children. Conversely, a child can not close a parent.
 */
void freeClient(Client c)
{
	Thread t= c->mythread;
	c->mode = FINISHING;

#ifdef MAL_CLIENT_DEBUG
	printf("# Free client %d\n", c->idx);
#endif
	MCexitClient(c);

	/* scope list and curprg can not be removed, 
	   because the client may reside in a
	   quit() command. Therefore the scopelist is re-used.
	if( c->curprg ) {
		freeSymbol(c->curprg); 
		c->curprg=0;
	}
	if( c->nspace) {
		freeModule(c->nspace);
		c->nspace=0;
	}
	   */
	c->scenario = NULL;
	if(c->prompt) 
		GDKfree(c->prompt); 
	c->prompt = NULL;
	c->promptlength=-1;
	if(c->errbuf){
		GDKsetbuf(0);
		GDKfree(c->errbuf);
		c->errbuf=0;
	}
	c->father = 0;
	c->login = c->lastcmd = 0;
	c->delay =  0;
	c->qtimeout =  0;
	c->stimeout =  0;
	if(c->rcc){ 
		GDKfree(c->rcc);
		c->rcc = NULL;
	}
	/*
	 * @-
	 * The threads may not be removed, but should become dormant
	 */
	c->user = oid_nil;
	c->mythread = 0;
	c->mypid = 0;
	c->mode = FREECLIENT;
	if (t) 
		THRdel(t);	/* you may perform suicide */
}

/*
 * @-
 * If a client disappears from the scene (eof on stream), we should
 * terminate all its children. This is in principle a forcefull action,
 * because the children may be ignoring the primary IO streams.
 * (Instead they may be blocked in an infinite loop)
 *
 * Special care should be taken by closing the 'adm' thread.
 * It is permitted to leave only when it is the sole user of the system.
 *
 * Furthermore, once we enter closeClient, the process in which it is
 * raised has already lost its file descriptors.
 */
void MCcloseClient(Client c) {

#ifdef MAL_DEBUG_CLIENT
		printf("closeClient %d " OIDFMT "\n",(int) (c-mal_clients),c->user);
#endif
	/* free resources of a single thread */
	if( !isAdministrator(c)) {
		freeClient(c);
		return;
	} 

	/* adm is set to disallow new clients entering */
	mal_clients[CONSOLE].mode= FINISHING;
	mal_exit();
}

/*
 * @-
 * At the end of the server session all remaining structured are
 * explicitly released to simplify detection of memory leakage problems.
 */
void MCcleanupClients(void){
	Client c;
	for(c = mal_clients; c < mal_clients+MAL_MAXCLIENTS; c++) {
		/* if( c->nspace){ freeModuleList(c->nspace); c->nspace=0;}*/
		if( c->prompt) { 
			GDKfree(c->prompt); 
			c->prompt = NULL;
		}
		c->user = oid_nil;
		assert(c->bak==NULL);
		MCexitClient(c);
	}
}
void 
MCexitPending(void)
{
	Client c;

	mal_set_lock(mal_contextLock, "MCexitPending");
	for (c = mal_clients+1; c < mal_clients+MAL_MAXCLIENTS; c++) {
		if (c->mode == AWAITING) {
			c->mode = FINISHING;
			/* (re)activate thread */
			MT_sema_up(&c->s, "MCfindClient");
		}
	}
	mal_unset_lock(mal_contextLock, "MCexitPending");
}

str
MCsuspendClient(int id, unsigned int timeout){
	if( id<0 || id>MAL_MAXCLIENTS)
		throw(INVCRED,"mal.clients", INVCRED_WRONG_ID);
	mal_clients[id].itrace='S';
	mal_clients[id].delay=timeout;
	return MAL_SUCCEED;
}

str
MCawakeClient(int id){
	if( id<0 || id>MAL_MAXCLIENTS)
		throw(INVCRED,"mal.clients", INVCRED_WRONG_ID);
	mal_clients[id].itrace=0;
	return MAL_SUCCEED;
}
/*
 * @-
 * In embedded mode there can be at most one console client and one
 * Mapi connection. Moreover, the Mapi connection should disable the administrator
 * console.
 */
int MCcountClients(void){
	int cnt=0;
	Client c;
	for(c = mal_clients; c < mal_clients+MAL_MAXCLIENTS; c++) 
		if (c->mode != FREECLIENT) cnt++;
	return cnt;
}
#if 0
int MCrunEmbedded(Client c){
	(void) c;
	/* to be defined */
	return 0;
}
#endif

/*
 * @+ Client input
 * Input to be processed is collected in a Client specific buffer.
 * It is filled by reading information from a stream, a terminal,
 * or by scheduling strings constructed internally.
 * The latter involves removing any escape character needed to
 * manipulate the string within the kernel.
 * The buffer space is automatically expanded to accommodate new
 * information and the read pointers are adjusted.
 * @-
 * The input is read from a (blocked) stream and stored in the client record
 * input buffer. The storage area grows automatically upon need.
 * The origin of the input stream depends on the connectivity mode.
 *
 * Most interactions should be regulated through the Mclient
 * front-end. This will also take care of buffering a request before
 * submission. This avoids a significant number of network interactions.
 *
 * @-
 * Each operation received from a front-end consists of at least one line.
 * To simplify misaligned communication with front-ends, we use different
 * prompts structures. [think, can we avoid acks]
 *
 * @-
 * The default action is to read information from an ascii-stream
 * one line at a time. This is the preferred mode for reading
 * from terminal.
 * @-
 * The next statement block is to be read. Send a prompt to warn
 * the front-end to issue the request.
 */
@= sendPrompt
	if (!isa_block_stream(c->fdout) && c->promptlength>0)
		mnstr_write(c->fdout,c->prompt,c->promptlength,1); 
	mnstr_flush(c->fdout);
@
@c

int MCreadClient(Client c){
	bstream *in = c->fdin;

#ifdef MAL_CLIENT_DEBUG
	printf("# streamClient %d %d\n",c->idx,isa_block_stream(in->s));
#endif

	while (in->pos < in->len && 
			(isspace((int)(in->buf[in->pos])) ||
			 in->buf[in->pos] == ';' || !in->buf[in->pos]))
		in->pos++;

	if (in->pos >= in->len || in->mode) {
		ssize_t rd, sum = 0;

		if (in->eof || !isa_block_stream(in->s)) {
			@:sendPrompt@
			in->eof = 0;
		}
		while ((rd = bstream_next(in)) > 0 && !in->eof) {
			sum += rd;
			if (!in->mode) /* read one line at a time in line mode */
				break;
		}
		if (in->mode) { /* find last new line */
			char *p = in->buf+in->len-1;

			while(p > in->buf && *p != '\n') {
				*(p+1) = *p;
				p--;
			}
			if (p > in->buf)
				*(p+1) = 0;
			if (p != in->buf + in->len -1)
				in->len++;
		}
		if (sum == 0 && in->eof && isa_block_stream(in->s)) {
			/* we hadn't seen the EOF before, so just try again
			   (this time with prompt) */
#ifdef MAL_CLIENT_DEBUG
			printf("# retry stream reading %d %d\n",c->idx, in->eof);
#endif
			return MCreadClient(c);
		}
#ifdef MAL_CLIENT_DEBUG
		printf("# simple stream received %d sum " SZFMT "\n",c->idx,sum);
#endif
	}
	if (in->pos >= in->len) {
		/* end of stream reached */
#ifdef MAL_CLIENT_DEBUG
		printf("# end of stream received %d %d\n",c->idx,c->bak==0);
#endif
		if (c->bak) {
			MCpopClientInput(c);
			if( c->fdin == NULL)
				return 0;
			return MCreadClient(c);
		}
		return 0;
	}
	if( *CURRENT(c) == '?'){
		showHelp(c->nspace, CURRENT(c)+1, c->fdout);
		in->pos= in->len;
		return MCreadClient(c);
	} 
#ifdef MAL_CLIENT_DEBUG
	printf("# finished stream read %d %d\n", (int)in->pos,  (int)in->len);
	printf("#%s\n", in->buf);
#endif
	return 1;
}
