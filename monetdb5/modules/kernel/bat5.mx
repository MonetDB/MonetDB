@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.monetdb.org/Legal/MonetDBLicense

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2011 MonetDB B.V.
All Rights Reserved.
@

@f bat5
@v 2.0
@a Peter Boncz, M.L. Kersten
@+ Binary Association Tables
This module contains the commands and patterns to manage Binary
Association Tables (BATs). The relational operations you can execute
on BATs have the form of a neat algebra, described in algebra.mx

But a database system needs more that just this algebra, since often it
is crucial to do table-updates (this would not be permitted in a strict
algebra).

All commands needed for BAT updates, property management, basic I/O, 
persistence, and storage options can be found in this module.

All parameters to the modules are passed by reference.
In particular, this means that string values are passed to the module
layer as (str *)
and we have to de-reference them before entering the gdk library.
(Actual a design error in gdk to differentiate passing int/str)
This calls for knowledge on the underlying BAT types`s
@-
@{
@= derefStr
{ if( @1->@2type >= TYPE_str  && ATOMstorage(@1->@2type) >= TYPE_str)
 { if(@3== 0 || *(str*)@3==0) @3 = (str)str_nil;
   else @3 = *(str *)@3; 
}}
@-
The code speaks for itself

#command access( b:bat[:any_1,:any_2], mode:int) :bat[:any_1,:any_2]
#address BKCaccess;

#command setSequenceBase( b:bat[:oid,:any_1], base:oid):void
#address BKCsetSequenceBase
#comment "Set the sequence base for the void column of a BAT.";
@mal
module bat;
command attach(tt:int, heapfile:str) :bat[:void,:any_1]
address BKCattach
comment "Returns a new BAT with dense head and tail of the given type and uses
        the given file to initialize the tail. The file will be owned by the
        server."

command densebat(size:wrd) :bat[:void,:void]
address BKCdensebat
comment "Creates a new [void,void] BAT of size 'size'."

command reverse(b:bat[:any_1,:any_2]) :bat[:any_2,:any_1] 
address BKCreverse
comment "Returns the reverse view of a BAT (head is tail and tail is head).
        BEWARE  no copying is involved; input and output refer to the 
        same object!";

command mirror(b:bat[:any_1,:any_2]) :bat[:any_1,:any_1] 
address BKCmirror
comment "Returns the head-mirror image of a BAT (two head columns).";

command order(b:bat[:any_1,:any_2]) :bat[:any_1,:any_2] 
address BKCorder
comment "Sorts the BAT itself on the head, in place. ";
command orderReverse(b:bat[:any_1,:any_2]) :bat[:any_1,:any_2] 
address BKCorder_rev
comment "Reverse sorts the BAT itself on the head, in place. ";

command revert(b:bat[:any_1,:any_2]) :bat[:any_1,:any_2] 
address BKCrevert
comment "Puts all BUNs in a BAT in reverse order.  (Belongs to the 
        BAT sequence module)";

@+ BAT properties
Properties of BATs not necessarily require loading the BAT completely.
The BAT identifier can be used to access the descriptors.
These properties can be inspected with the 
@emph{info(BAT[:any_1,:any_2]) :bat[str,str] } command:
@verbatim
> car_age.info.print;
#---------------------------------#
# BAT:               tmp_31       #
# (str)              (str)        #
#---------------------------------#
[ "batId",           "car_age"    ] # logical bat name
[ "batCacheid",      "26"         ] # BBP index
[ "batParentid",     "0"          ] # set if a BAT is a view
[ "head",            "void"       ] # physical head-type
[ "tail",            "int"        ] # physical tail-type
[ "batPersistence",  "persistent" ] # transient/session/persistent
[ "batRestricted",   "updatable"  ] # read-only/append-only/updatable
[ "batDirty",        "clean"      ] # clean/dirty
[ "batRefcnt",       "1"          ] # physical refcount
[ "batLRefcnt",      "1"          ] # logical refcount (total)
[ "batPlevel",       "1"          ] # logical refcount (persistent part)
[ "batSet",          "0"          ] # [head,tail] combinations are unique
[ "batCopiedtodisk", "1"          ] # has been saved or not
@end verbatim

Per column, a number of properties are kept. We only show the head-properties; the tail properties
have the first character of their named replaced by 't' (@emph{sorted}, @emph{tdense}, etc.):

@verbatim
[ "hsorted",         "1"          ] # column is known to be sorted
[ "hdense",          "1"          ] # column is known to be densely ascended
[ "hseqbase",        "0@0"        ] # if densely ascending first value
@end verbatim

As described in the @[<a href="www/gdk.html#mod_1_3_0">GDK Technical Reference</a>@,
BATs store their data in one to six heaps. For each column type that is @emph{variable-sized} - 
like @emph{str} - another
heap might be present (@emph{hheap} and @emph{theap}). 

@verbatim
[ "head.free",    "400004"     ] # occupied size in bytes
[ "head.size",    "400012"     ] # allocated size in bytes
[ "head.maxsize", "400012"     ] # reserver virtual memory in bytes
[ "head.storage", "malloced"   ] # malloced/mmap/priv
@end verbatim

Properties steer the algorithms that Monet uses to execute algebra command. For instance,
the @emph{find(bat[:any_1,:any_2] b, :any_1) :any_2} that looks up a tail value by head,
uses binary search if and only if the head column is sorted (in other cases, hash-lookup
and scan are execution options).

Sometimes new (extension) code contains bugs in the property management, leaving false
properties on produced BATs. You can imagine that later on, this leads to additional
bugs, as e,g, the binary search algorithms will yield erroneous results on a non-sorted
sequence.

@mal
command info ( b:bat[:any_1,:any_2]) :bat[:str,:str] 
address BKCinfo
comment "Produce a BAT containing info about a BAT in [attribute,value] format. 
        It contains all properties of the BAT record. See the BAT documentation 
        in GDK for more information.";

command getSize ( b:bat[:any_1,:any_2]) :lng
address BKCbatsize
comment "Calculate the size of the BAT descriptor, heaps and indices in bytes.";

command getMemorySize ( b:bat[:any_1,:any_2]) :lng
address BKCbatvmsize
comment "Calculate the size of the BAT heaps and indices in bytes
rounded to the memory page size (see bbp.getPageSize()).";

command getDiskSize ( b:bat[:any_1,:any_2]) :lng
address BKCbatdisksize
comment "Approximate size of the (persistent) BAT heaps as stored on disk 
in pages of 512 bytes. Indices are not included, as they only live temporarily
in virtual memory.";

command getCapacity(b:bat[:any_1,:any_2]):lng 
address BKCgetCapacity
comment "Returns the current allocation size (in max number of elements) of a BAT.";

command getHeadType(b:bat[:any_1,:any_2] ) :str 
address BKCgetHeadType
comment "Returns the type of the head column of a BAT, as an integer type number.";

command getTailType( b:bat[:any_1,:any_2] ) :str 
address BKCgetTailType 
comment "Returns the type of the tail column of a BAT, as an integer type number.";

command getRole ( bid:bat[:any_1,:any_2] ) :str 
address BKCgetRole
comment "Returns the rolename of the head column of a BAT.";

command setKey( b:bat[:any_1,:any_2], mode:bit) :bat[:any_1,:any_2] 
address BKCsetkey
comment "Sets the 'key' property of the head column to 'mode'. In 'key' mode, 
        the kernel will silently block insertions that cause a duplicate 
        entries in the head column. KNOWN BUG:when 'key' is set to TRUE, this 
	function does not automatically eliminate duplicates. 
        Use b := b.kunique;";

command isaKey( b:bat[:any_1,:any_2]) :bit 
address BKCgetKey
comment "return whether the head column of a BAT is unique (key).";

command setSet( b:bat[:any_1,:any_2], mode:bit) :bat[:any_1,:any_2] 
address BKCsetSet
comment "Sets the 'set' property on this BAT to 'mode'. In 'set' mode, 
        the kernel will silently block insertions that cause a duplicate 
        BUN [head,tail] entries in the BAT.  KNOWN BUG:when 'set' is set 
        to TRUE, this function does not automatically eliminate duplicates. 
        Use b := b.sunique; Returns the BAT itself.";

command isaSet( b:bat[:any_1,:any_1]) :bit 
address BKCisaSet
comment "return whether the BAT mode is set to unique.";

command setAccess( b:bat[:any_1,:any_2], mode:str) :bat[:any_1,:any_2]
address BKCsetAccess
comment "Try to change the update access priviliges 
	to this BAT. Mode:
	 r[ead-only]      - allow only read access.
	 a[append-only]   - allow reads and update.
	 w[riteable]      - allow all operations.
	BATs are updatable by default. On making a BAT read-only, 
        all subsequent updates fail with an error message.Returns 
        the BAT itself.";

command setAppendMode( b:bat[:any_1,:any_2]) :bat[:any_1,:any_2]
address BKCsetAppendMode
comment "Change access privilige of BAT to append only";

command setReadMode( b:bat[:any_1,:any_2]) :bat[:any_1,:any_2]
address BKCsetReadMode
comment "Change access privilige of BAT to read only";

command setWriteMode( b:bat[:any_1,:any_2]) :bat[:any_1,:any_2]
address BKCsetWriteMode
comment "Change access privilige of BAT to read and write";

command getAccess( b:bat[:any_1,:any_2]):str 
address BKCgetAccess
comment "return the access mode attached to this BAT as a character.";

command hasAppendMode( b:bat[:any_1,:any_2]):bit 
address BKChasAppendMode
comment "return true if to this BAT is append only.";

command hasWriteMode( b:bat[:any_1,:any_2]):bit 
address BKChasWriteMode
comment "return true if to this BAT is read and write.";

command hasReadMode( b:bat[:any_1,:any_2]):bit 
address BKChasReadMode
comment "return true if to this BAT is read only.";


command getSequenceBase( b:bat[:oid,:any_1]):oid 
address BKCgetSequenceBase
comment "Get the sequence base for the void column of a BAT.";

command setSorted(b:bat[:any_1,:any_2]) :bit 
address BKCsetSorted
comment "Assure BAT is ordered on the head.";

command isSorted(b:bat[:any_1,:any_2]) :bit 
address BKCisSorted
comment "Returns whether a BAT is ordered on head or not.";
command isSortedReverse(b:bat[:any_1,:any_2]) :bit 
address BKCisSortedReverse
comment "Returns whether a BAT is ordered on head or not.";

command getStorageSize(b:bat[:any_1,:any_2]) :lng 
address BKCgetStorageSize
comment "Determine the total space (in bytes) reserved for a BAT.";

command getSpaceUsed(b:bat[:any_1,:any_2]) :lng 
address BKCgetSpaceUsed
comment "Determine the total space (in bytes) occupied by a BAT.";

@- BAT updates
Update commands come in many disguises.  Note that we don;t return
the BAT id, but merely a success/failure code.
@mal
command insert(b:bat[:any_1,:any_2], src:bat[:any_1,:any_2]):bat[:any_1,:any_2]
address BKCinsert_bat
comment "Insert all BUNs of the second BAT into the first.";

command insert(b:bat[:any_1,:any_2], src:bat[:any_1,:any_2], force:bit):bat[:any_1,:any_2]
address BKCinsert_bat_force
comment "Insert all BUNs of the second BAT into the first.";

command insert(b:bat[:any_1,:any_2], h:any_1, t:any_2) :bat[:any_1,:any_2]
address BKCinsert_bun
comment "Insert one BUN[h,t] in a BAT.";

command insert(b:bat[:any_1,:any_2], h:any_1, t:any_2, force:bit) :bat[:any_1,:any_2]
address BKCinsert_bun_force
comment "Insert one BUN[h,t] in a BAT.";

@+
@mal
command replace(b:bat[:any_1, :any_2], src:bat[:any_1,:any_2]) :bat[:any_1,:any_2]
address BKCreplace_bat
comment "Perform replace for all BUNs of the second BAT into the first.";

command replace(b:bat[:any_1, :any_2], src:bat[:any_1,:any_2], force:bit) :bat[:any_1,:any_2]
address BKCreplace_bat_force
comment "Perform replace for all BUNs of the second BAT into the first.";

command replace(b:bat[:any_1, :any_2], h:any_1, t:any_2) :bat[:any_1,:any_2]
address BKCreplace_bun
comment "Replace the tail value of one BUN that has some head value.";

command replace(b:bat[:any_1, :any_2], h:any_1, t:any_2, force:bit) :bat[:any_1,:any_2]
address BKCreplace_bun_force
comment "Replace the tail value of one BUN that has some head value.";
@-
The SQL append/inplace commands
@mal
command append( i:bat[:any_1,:any_2], u:bat[:any_1,:any_2] ) :bat[:any_1,:any_2]
address BKCappend_wrap
comment "append the content of u to i";

command append( i:bat[:any_1,:any_2], u:bat[:any_1,:any_2], force:bit ) :bat[:any_1,:any_2]
address BKCappend_force_wrap
comment "append the content of u to i";

command append(i:bat[:oid,:any_1], u:any_1):bat[:oid,:any_1]
address BKCappend_val_wrap
comment "append the value u to i";

command append(i:bat[:void,:any_1], u:any_1):bat[:void,:any_1]
address BKCappend_val_wrap
comment "append the value u to i";

command append(i:bat[:any_1,:void], u:any_1):bat[:any_1,:void]
address BKCappend_reverse_val_wrap
comment "append the value u to i";

command append(i:bat[:any_1,:any_2], u:any_2, force:bit):bat[:any_1,:any_2]
address BKCappend_val_force_wrap
comment "append the value u to i";

command inplace( o:bat[:any_1,:any_2], id:any_1, t:any_2) :bat[:any_1,:any_2]
address BKCbun_inplace
comment "inplace replace values on the given locations";

command inplace( o:bat[:any_1,:any_2], d:bat[:any_1,:any_2]) :bat[:any_1,:any_2]
address BKCbat_inplace
comment "inplace replace values on the given locations";

command inplace( o:bat[:any_1,:any_2], id:any_1, t:any_2, force:bit) :bat[:any_1,:any_2]
address BKCbun_inplace_force
comment "inplace replace values on the given locations";

command inplace( o:bat[:any_1,:any_2], d:bat[:any_1,:any_2], force:bit) :bat[:any_1,:any_2]
address BKCbat_inplace_force
comment "inplace replace values on the given locations";

@mal
command delete(b:bat[:any_1, :any_2], h:any_1, t:any_2) :bat[:any_1,:any_2]
address BKCdelete_bun
comment "Delete one specific BUN.";

command delete(b:bat[:any_1, :any_2], h:any_1) :bat[:any_1,:any_2]
address BKCdelete
comment "Delete all BUNs with a certain tail value.";

command delete(b:bat[:any_1, :any_2]) :bat[:any_1,:any_2]
address BKCdelete_all
comment "Delete all BUNs in a BAT.";

@mal
command deleteHead(b:bat[:any_1, :any_2], src:bat[:any_1,:any]) :void
address BKCdelete_bat
comment "Delete from the first BAT all BUNs with a corresponding head  
        in the second.";

command delete(b:bat[:any_1, :any_2], src:bat[:any_1,:any_2]) :bat[:any_1,:any_2]
address BKCdelete_bat_bun
comment "Delete from the first BAT all BUNs with a corresponding BUN 
        in the second.";

command getAlpha(b:bat[:any_1,:any_2]) :bat[:any_1,:any_2] 
address BKCgetAlpha
comment "Obtain the list of BUNs added";
command getDelta(b:bat[:any_1,:any_2]) :bat[:any_1,:any_2] 
address BKCgetDelta
comment "Obtain the list of BUNs deleted";
@- BAT I/O, Persistency
The BAT Buffer Pool (BBP) manages all known BATs. It administers
their logical and physical names and a reference count. BATs can
either be @emph{persistent} or @emph{transient}. The BBP also manages
swapping on a BAT level:a BAT is either loaded entirely or not.
MAL variables of type @emph{bat} can either be loaded or not. When
the Monet server is started, all BATs are swapped out. If an unloaded
bat-variable is used as an operand in a command, it is automatically
loaded.  The BBP applies a simple but effective LRU based swapping
algorithm. BATs have a @emph{heat}, which drops over time, and is
increased when a BAT is used by some command.  If the size of the
allocated arena gets to be large, BATs may be swapped out.

Note, we should move old-fashioned mil operator definitions
into a separate module.

@mal
command setName ( b:bat[:any_1,:any_2] , s:str) :void
address BKCsetName
comment "Give a logical name to a BAT. ";

command getName ( b:bat[:any_1,:any_2]) :str 
address BKCgetBBPname
comment "Gives back the logical name of a BAT.";

command setRole( b:bat[:any_1,:any_2], h:str, t:str) :void
address BKCsetRole
comment "Give a logical name to the columns of a BAT.";

command setColumn( b:bat[:any_1,:any_2], t:str) :void
address BKCsetColumn
comment "Give a logical name to the tail column of a BAT.";
command setColumn( b:bat[:any_1,:any_2], h:str, t:str) :void
address BKCsetColumns
comment "Give both columns of a BAT a new name.";


command isTransient( b:bat[:any_1,:any_2]) :bit 
address BKCisTransient;
command setTransient( b:bat[:any_1,:any_2]) :void
address BKCsetTransient
comment "Make the BAT transient.  Returns 
	boolean which indicates if the
BAT administration has indeed changed.";

command isPersistent( b:bat[:any_1,:any_2]) :bit 
address BKCisPersistent;
command setPersistent( b:bat[:any_1,:any_2],f:bit) :void
address BKCpersists
comment "Backward compatibility";
command setPersistent( b:bat[:any_1,:any_2]) :void
address BKCsetPersistent
comment "Make the BAT persistent.";

command save(nme:bat[:any_1,:any_2]) :void
address BKCsave2;

command save(nme:str) :bit 
address BKCsave
comment "Save a BAT to storage, if it was loaded and dirty.  
        Returns whether IO was necessary.  Please realize that 
	calling this function violates the atomic commit protocol!!";


command load(name:str) :bat[:any_1,:any_2] 
address BKCload
comment "Load a particular BAT from disk";

command unload(name:str) :bit 
address BKCunload
comment "Swapout a BAT to disk. Transient BATs can also be swapped out.     
        Returns whether the unload indeed happened. ";

command isCached(b:bat[:any_1,:any_2]):bit 
address BKCisCached
comment "Bat is stored in main memory.";

command getHeat(b:bat[:any_1,:any_2]) :lng 
address BKCheat
comment "Return the current BBP heat (LRU stamp)";

command setCold(b:bat[:any_1,:any_1]) :void 
address BKCcoldBAT
comment "Makes a BAT very cold for the BBP. The chance of being choses 
        for swapout is big, afterwards.";
command setHot(b:bat[:any_1,:any_2]) :void 
address BKChotBAT
comment "Makes a BAT very hot for the BBP. The chance of being chosen for 
        swapout is small, afterwards.";

@- Heap Specific Commands
BATs are stored in memory in a number of Heap objects. A heap is nothing
more than a contiguous range of memory. Bats are saved to disk by just writing
away their image. This approach without pointer swizzling makes it possible
to either load an image into an alloced range of memory (STORE_MEM), or
memory-map (STORE_MMAP) an image into virtual memory.

The heap images of a BAT are stored in the @emph{$MONETHOME/dbfarm/$DB/bat/}
directory.  For each bat X, the following heaps are stored:
@table @code
@item[X.buns] 
    an array with all the fixed-size parts of all BUNs.
@item[X.hheap] 
    if the head column contains a variable sized atoms (e.g. str),
then the fixed-size part of a BUN contains an integer byte-offset into
the heap. String values themselves are stored in this the X.hheap.
@item[X.theap] 
    similar to X.hheap, but for the tail column.
@item[X.desc] 
the BAT descriptor. Stores most of the properties of a BAT.
@end table

Each of these heaps can be compressed using the Unix @emph{compress}
utility forming a X.ext.Z file. Monet will automatically decompress it
upon load. Compressed heaps cannot be memory mapped.

@
For more technical information on BATs, we refer to the
@[<a href="http://www.cwi.nl/~monet/www/scw/gdk/470_pseudo.html">GDK</a>@
documentation.
@mal
command setMemoryMap(b:bat[:any_1,:any_2], head_mode:int, tail_mode:int, hheap_mode:int, theap_mode:int) :bit 
address BKCmmap
comment "For each individual heap, you can change the allocation mode 
        to either STORE_MEM or STORE_MMAP. Passing an int(nil) means:
        no change.  Changing a dirty STORE_MEM heap into STORE_MMAP, 
	will cause a BAT save (this has to happen before the heap can 
        be mapped into virtual memory). These modes are persistent. ";

command setMemoryMap(b:bat[:any_1,:any_2], mode:int):bit 
address BKCmmap2
comment "Alias for mmap(b, mode, mode, mode, mode)";

command setMemoryAdvise(b:bat[:any_1,:any_2], head_mode:int, tail_mode:int, hheap_mode:int, theap_mode:int) :bit 
address BKCmadvise
comment "Modern Operating Systems allow users to influence the buffer 
        management policy of virtual memory. This is a crucial feature 
        for database systems, and eliminates the need to reimplement 
	the OS in a database buffer manager.  The supported flags are 
        BUF_NORMAL (the normal adaptive kernel algorithm),
	BUF_RANDOM (no page prefetching), 
	BUF_SEQUENTIAL (prefetch and swapout),
	BUF_WILLNEED (load everything with prefetch), 
	BUF_DONTNEED (swapout).
	These buffer management modes are not persistent. 
	Returns the BAT operated upon.";

command setMemoryAdvise(b:bat[:any_1,:any_2], mode:int):bit 
address BKCmadvise2
comment "alias for madvise(b, mode, mode, mode, mode)";

command setHash(b:bat[:any_1,:any_2],prop:bit):bit 
address BKCsetHash;

@- Synced BATs
The binary model of Monet has important advantages when working in
main-memory. Tables are thin and very efficiently processed. The binary
model gives rise, however, to a larger-than-normal number of join
and semijoin operations. Relations are split up in vertical parts that
are very much related to each other. Then, for instance, multiple
similar semijoins occur on different vertical parts. By equipping the
kernel with knowledge about the correspondence of these parts, we
can greatly limit the amount of work to be done.

When two BATs effectively contain the same sequence of head elements,
we call them 'synced'. This is implemented by storing a very large
OID for each column. An update to the column destroys this OID.
By comparing two OIDs the Monet kernel can very quickly decide that
two columns are exactly equal. All BAT algebra operations propagate
these 'sync' OIDs with their own propagation rules.
@mal
command isSynced (b1:bat[:any_1,:any_2], b2:bat[:any_3,:any_4]) :bit 
address BKCisSynced
comment "Tests whether two BATs are synced or not. ";

@- Constants
The following constants have not been integrated in the code base

#Constants have been added to mal/const.mx prelude
#    STORE_MEM   := 0;     # load into GDKmalloced memory
#    STORE_MMAP  := 1;     # mmap() into virtual memory
#    STORE_COMPR := 2;     # currently not implemented this way
#    BUF_NORMAL    := 0;   # No further special treatment
#    BUF_RANDOM    := 1;   # Expect random page references
#    BUF_SEQUENTIAL:= 2;   # Expect sequential page references
#    BUF_WILLNEED  := 3;   # Will need these pages
#    BUF_DONTNEED  := 4;   # Don't need these pages

@- Shrinking BATs
The SQL front-end uses a multi-BAT representation for relational tables.
This includes a list of tuples to be deleted at some convenient time.
The primitives to consolidate the information consists of shrink()
and reuse(). 
The former simply compresses the underlying BAT skipping over all
oids mentioned as to-be-deleted. The reuse() operator takes the tail
of the BAT an fills all the holes that occur due to the deletion list.
@mal
command shrink(b:bat[:oid,:any_1],del:bat[:oid,:oid]):bat[:oid,:any_1]
address BKCshrinkBAT
comment "Shrink the BAT based on a list of entries identified as to-be-deleted";

command shrinkMap(b:bat[:oid,:any_1],del:bat[:oid,:oid]):bat[:oid,:oid]
address BKCshrinkBATmap
comment "Derive the oid mapping for shrink BAT based on list of to-be-deleted";

command reuse(b:bat[:oid,:any_1],del:bat[:oid,:oid]):bat[:oid,:any_1]
address BKCreuseBAT
comment "Shuffle the values around to restore a dense representation of buns.";

command reuseMap(b:bat[:oid,:any_1],del:bat[:oid,:oid]):bat[:oid,:oid]
address BKCreuseBATmap
comment "Derive the oid mapping for reuse BAT based on list of to-be-deleted";

@+ Implementation Code
In Version 5, we are not going to support recursive BATs.
It is up to the programmer to translate a bat into a
bat-name or batCacheid

@h
#ifndef _BAT_H_
#define _BAT_H_

#include <mal.h>
#include <gdk.h>

#ifdef WIN32
#if !defined(LIBMAL) && !defined(LIBATOMS) && !defined(LIBKERNEL) && !defined(LIBMAL) && !defined(LIBOPTIMIZER) && !defined(LIBSCHEDULER) && !defined(LIBMONETDB5)
#define bat5_export extern __declspec(dllimport)
#else
#define bat5_export extern __declspec(dllexport)
#endif
#else
#define bat5_export extern
#endif

bat5_export char *BKCsetRole(int *r, int *bid, char **hname, char **tname);
bat5_export char *BKCdestroyImmediate(signed char *r, int *bid);
bat5_export char *BKCgetAlpha(int *r, int *bid);
bat5_export char *BKCgetDelta(int *r, int *bid);
bat5_export char *BKCinsert_bun(int *r, int *bid, ptr h, ptr t);
bat5_export char *BKCinsert_bun_force(int *r, int *bid, ptr h, ptr t, bit *force);
bat5_export char *BKCdelete(int *r, int *bid, ptr h);
bat5_export char *BKCdelete_bat(int *r, int *bid, int *bnid);
bat5_export char *BKCdelete_bun(int *r, int *bid, ptr h, ptr t);
bat5_export char *BKCdestroy(signed char *r, int *bid);
bat5_export char *BKCbat_append_void_bat_wrap(int *r, int *bid, int *uid);
bat5_export char * BKCbat_append_val_wrap(int *r, int *bid, ptr u);
bat5_export str BKCnewBAT(int *res, int *ht, int *tt, BUN *cap);
bat5_export str BKCattach(int *ret, int *tt, str *heapfile);
bat5_export str BKCdensebat(int *ret, wrd *size);
bat5_export str BKCreverse(int *ret, int *bid);
bat5_export str BKCmirror(int *ret, int *bid);
bat5_export str BKCrevert(int *ret, int *bid);
bat5_export str BKCorder(int *ret, int *bid);
bat5_export str BKCorder_rev(int *ret, int *bid);
bat5_export str BKCinsert_bat(int *r, int *bid, int *sid);
bat5_export str BKCinsert_bat_force(int *r, int *bid, int *sid, bit *force);
bat5_export str BKCreplace_bun(int *r, int *bid, ptr h, ptr t);
bat5_export str BKCreplace_bat(int *r, int *bid, int *sid);
bat5_export str BKCreplace_bun_force(int *r, int *bid, ptr h, ptr t, bit *force);
bat5_export str BKCreplace_bat_force(int *r, int *bid, int *sid, bit *force);
bat5_export str BKCdelete_all(int *r, int *bid);
bat5_export str BKCdelete_bat_bun(int *r, int *bid, int *sid);
bat5_export str BKCdelete_bat(int *r, int *bid, int *sid);
bat5_export str BKCdestroy_bat(bit *r, str *input);
bat5_export str BKCappend_wrap(int *r, int *bid, int *uid);
bat5_export str BKCappend_val_wrap(int *r, int *bid, ptr u);
bat5_export str BKCappend_reverse_val_wrap(int *r, int *bid, ptr u);
bat5_export str BKCappend_force_wrap(int *r, int *bid, int *uid, bit *force);
bat5_export str BKCappend_val_force_wrap(int *r, int *bid, ptr u, bit *force);
bat5_export str BKCbun_inplace(int *r, int *bid, oid *id, ptr t);
bat5_export str BKCbat_inplace(int *r, int *bid, int *rid);
bat5_export str BKCbun_inplace_force(int *r, int *bid, oid *id, ptr t, bit *force);
bat5_export str BKCbat_inplace_force(int *r, int *bid, int *rid, bit *force);
bat5_export str BKCgetCapacity(lng *res, int *bid);
bat5_export str BKCgetHeadType(str *res, int *bid);
bat5_export str BKCgetTailType(str *res, int *bid);
bat5_export str BKCgetRole(str *res, int *bid);
bat5_export str BKCsetkey(int *res, int *bid, bit *param);
bat5_export str BKCsetSet(int *res, int *bid, bit *param);
bat5_export str BKCisaSet(bit *res, int *bid);
bat5_export str BKCsetSorted(bit *res, int *bid);
bat5_export str BKCisSorted(bit *res, int *bid);
bat5_export str BKCisSortedReverse(bit *res, int *bid);
bat5_export str BKCgetKey(bit *ret, int *bid);
bat5_export str BKCpersists(int *r, int *bid, bit *flg);
bat5_export str BKCsetPersistent(int *r, int *bid);
bat5_export str BKCisPersistent(bit *res, int *bid);
bat5_export str BKCsetTransient(int *r, int *bid);
bat5_export str BKCisTransient(bit *res, int *bid);
bat5_export str BKCaccess(int *res, int *bid, int *m);
bat5_export str BKCsetAccess(int *res, int *bid, str *param);
bat5_export str BKCgetAccess(str *res, int *bid);
bat5_export str BKCinfo(int *retval, int *bid);
bat5_export str BKCbatsize(lng *tot, int *bid);
bat5_export str BKCbatvmsize(lng *tot, int *bid);
bat5_export str BKCbatdisksize(lng *tot, int *bid);
bat5_export str BKCgetStorageSize(lng *tot, int *bid);
bat5_export str BKCgetSpaceUsed(lng *tot, int *bid);
bat5_export str BKCgetStorageSize_str(lng *tot, str batname);
bat5_export str BKCisSynced(bit *ret, int *bid1, int *bid2);
bat5_export str BKCsetColumn(int *r, int *bid, str *tname);
bat5_export str BKCsetColumns(int *r, int *bid, str *hname, str *tname);
bat5_export str BKCsetName(int *r, int *bid, str *s);
bat5_export str BKCgetBBPname(str *ret, int *bid);
bat5_export str BKCunload(bit *res, str *input);
bat5_export str BKCisCached(bit *res, int *bid);
bat5_export str BKCload(int *res, str *input);
bat5_export str BKChot(int *res, str *input);
bat5_export str BKCcold(int *res, str *input);
bat5_export str BKCcoldBAT(int *res, int *bid);
bat5_export str BKCheat(int *res, str *input);
bat5_export str BKChotBAT(int *res, int *bid);
bat5_export str BKCsave(bit *res, str *input);
bat5_export str BKCsave2(int *r, int *bid);
bat5_export str BKCmmap(bit *res, int *bid, int *hbns, int *tbns, int *hhp, int *thp);
bat5_export str BKCmmap2(bit *res, int *bid, int *bns);
bat5_export str BKCmadvise(bit *res, int *bid, int *hbns, int *tbns, int *hhp, int *thp);
bat5_export str BKCmadvise2(bit *res, int *bid, int *mode);
bat5_export str BKCaccbuild(int *ret, int *bid, str *acc, ptr *param);
bat5_export str BKCaccbuild_std(int *ret, int *bid, int *acc);
bat5_export str BKCsetHash(bit *ret, int *bid, bit *prop);
bat5_export str BKCsetSequenceBase(int *r, int *bid, oid *o);
bat5_export str BKCsetSequenceBaseNil(int *r, int *bid, oid *o);
bat5_export str BKCgetSequenceBase(oid *r, int *bid);
bat5_export str BKCshrinkBAT(int *ret, int *bid, int *did);
bat5_export str BKCreuseBAT(int *ret, int *bid, int *did);
bat5_export str BKCshrinkBATmap(int *ret, int *bid, int *did);
bat5_export str BKCreuseBATmap(int *ret, int *bid, int *did);

#endif /*_BAT_H_*/

@c
#include "monetdb_config.h"
#include "bat5.h"
#include "mal_exception.h"
@-
@= batconvert
	(BAT@2type(@1) == TYPE_bat)?(ptr)&((BAT*)@2)->batCacheid:(ptr)@2

@+ Information Functions
@c

static int
CMDnew(BAT **ret, int *ht, int *tt, BUN *cap)
{
	*ret = BATnew(*ht, *tt, *cap);
	if (*ret)
		(*ret)->batDirty |= 2;
	return (*ret) ? GDK_SUCCEED : GDK_FAIL;
}

int
CMDattach(BAT **ret, int *tt, str heapfile)
{
	*ret = BATattach(*tt, heapfile);
	return *ret ? GDK_SUCCEED : GDK_FAIL;
}

int
CMDdensebat(BAT **ret, wrd *size)
{
	BAT *b;

	if (*size < 0)
		*size = 0;
	if (*size > (wrd) BUN_MAX)
		*size = (wrd) BUN_MAX;
	*ret = b = BATnew(TYPE_void, TYPE_void, (BUN) *size);
	if (b == NULL)
		return GDK_FAIL;
	b->batDirty = 1;
	b->hseqbase = 0;
	b->tseqbase = 0;
	BATkey(b, TRUE);
	BATkey(BBP_cache(-b->batCacheid), TRUE);
	BATsetcount(b, (BUN) *size);
	return GDK_SUCCEED;
}

int
CMDreverse(BAT **ret, BAT *b)
{
	*ret = BATmirror(b);
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

int
CMDmirror(BAT **ret, BAT *b)
{
	BAT *v = *ret = VIEWcombine(b);

	if (b->batRestricted == BAT_WRITE) {
		*ret = BATcopy(v, v->htype, v->ttype, FALSE);
		BBPreclaim(v);
	}
	return (*ret) ? GDK_SUCCEED : GDK_FAIL;
}

int
CMDrevert(BAT **ret, BAT *b)
{
	if (BATrevert(*ret = b) == NULL)
		return GDK_FAIL;
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

int
CMDorder(BAT **ret, BAT *b)
{
	if (BATorder(*ret = b) == NULL)
		return GDK_FAIL;
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

int
CMDorder_rev(BAT **ret, BAT *b)
{
	if (BATorder_rev(*ret = b) == NULL)
		return GDK_FAIL;
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

int
CMDsorder(BAT **ret, BAT *b)
{
	if (BATsorder(*ret = b) == NULL)
		return GDK_FAIL;
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

int
CMDsorder_rev(BAT **ret, BAT *b)
{
	if (BATsorder_rev(*ret = b) == NULL)
		return GDK_FAIL;
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

int
CMDinsert_bun(BAT **r, BAT *b, ptr h, ptr t)
{
	if (BUNins(*r = b, @:batconvert(b,h)@, @:batconvert(b,t)@,FALSE) == NULL)
		return GDK_FAIL;
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

int
CMDinsert_bat(BAT **r, BAT *b, BAT *s)
{
	if (BATins(*r = b, s, FALSE) == NULL)
		return GDK_FAIL;
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

int
CMDreplace_bun(BAT **r, BAT *b, ptr h, ptr t)
{
	if (BUNreplace(*r = b, @:batconvert(b,h)@, @:batconvert(b,t)@, 0) == NULL)
		return GDK_FAIL;
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

int
CMDreplace_bat(BAT **r, BAT *b, BAT *s)
{
	if (BATreplace(*r = b, s, 0) == NULL)
		return GDK_FAIL;
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

int
CMDreplace_bun_force(BAT **r, BAT *b, ptr h, ptr t, bit *force)
{
	if (BUNreplace(*r = b, @:batconvert(b,h)@, @:batconvert(b,t)@, *force) == NULL)
		return GDK_FAIL;
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

int
CMDreplace_bat_force(BAT **r, BAT *b, BAT *s, bit *force)
{
	if (BATreplace(*r = b, s, *force) == NULL)
		return GDK_FAIL;
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

int
CMDdelete_bun(BAT **r, BAT *b, ptr h, ptr t)
{
	if (BUNdel(*r = b, h, t, FALSE) == NULL)
		return GDK_FAIL;
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

int
CMDdelete_head(BAT **r, BAT *b, ptr h)
{
	if (BUNdelHead(*r = b, @:batconvert(b,h)@, FALSE) == NULL)
		return GDK_FAIL;
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

int
CMDdelete_all(BAT **r, BAT *b)
{
	if (BATclear(*r = b) == NULL)
		return GDK_FAIL;
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

int
CMDdelete_bat_bun(BAT **r, BAT *b, BAT *s)
{
	if (BATdel(*r = b, s, FALSE) == NULL)
		return GDK_FAIL;
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

int
CMDdelete_bat_head(BAT **r, BAT *b, BAT *s)
{
	if (BATdelHead(*r = b, s, FALSE) == NULL)
		return GDK_FAIL;
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}


@-
The next collection of operators fill a hole in the MonetDB kernel libraries.
It provide handy operations on void-BATs.
@c
int
bun_inplace(BAT **res, BAT *b, oid *id, ptr val )
{
	int ret = void_inplace(b,*id,val,FALSE);
	*res = b;
	BBPfix(b->batCacheid);
	return ret;
}

int
bun_inplace_force(BAT **res, BAT *b, oid *id, ptr val, bit *force )
{
	int ret = void_inplace(b,*id,val,*force);
	*res = b;
	BBPfix(b->batCacheid);
	return ret;
}

int
bat_inplace(BAT **res, BAT *o, BAT *d)
{
	*res = o;
	if (void_replace_bat(o, d, FALSE) == BUN_NONE)
		return GDK_FAIL;
	BBPfix(o->batCacheid);
	return GDK_SUCCEED;
}

int
bat_inplace_force(BAT **res, BAT *o, BAT *d, bit *force)
{
	*res = o;
	if (void_replace_bat(o, d, *force) == BUN_NONE)
		return GDK_FAIL;
	BBPfix(o->batCacheid);
	return GDK_SUCCEED;
}

int
BATappend_force(BAT **res, BAT *i, BAT *u, bit *force)
{
	if (!BATappend(i, u, *force))
		return GDK_FAIL;
	*res = i;
	BBPfix(i->batCacheid);
	return GDK_SUCCEED;
}

int
BATappend_wrap(BAT **res, BAT *i, BAT *u)
{
	bit force = FALSE;
	return BATappend_force(res, i, u, &force);
}

int
BUNappend_force(BAT **res, BAT *i, ptr t, bit *force)
{
	*res = BUNappend(i, @:batconvert(i,t)@, *force);
	if (*res) {
		BBPfix((*res)->batCacheid);
		return GDK_SUCCEED;
	}
	return GDK_FAIL;
}

int
BUNappend_wrap(BAT **res, BAT *i, ptr t)
{
	bit force = FALSE;
	return BUNappend_force(res, i, t, &force);
}

static BAT *
lock_desc(bat bid)
{
	BBPfix(bid);
	return (BAT *) BBPgetdesc(bid);
}

static void
unlock_desc(bat bid)
{
	BBPunfix(bid);
}

int
CMDcapacity(lng *res, int *bid)
{
	if (BBPcheck((bat) *bid, "CMDcapacity")) {
		BAT *b = lock_desc((bat) *bid);

		if (b == NULL) {
			*res = lng_nil;
		} else {
			*res = (lng) BATcapacity(b);
		}
		unlock_desc(*bid);
	}
	return GDK_SUCCEED;
}

int
CMDhead(str *res, int *bid)
{
	if (BBPcheck((bat) *bid, "CMDhead")) {
		str ret = (str)str_nil;
		BAT *b = lock_desc((bat) *bid);

		if (b) {
			ret = *bid > 0 ? ATOMname(b->htype) : ATOMname(b->ttype);
		}
		*res = GDKstrdup(ret);
		unlock_desc(*bid);
	} else {
		*res = GDKstrdup(str_nil);
	}
	return GDK_SUCCEED;
}

int
CMDhead_bat(str *res, BAT *b)
{
	return CMDhead(res, &b->batCacheid);
}

int
CMDhtype(int *res, int *bid)
{
	int ret = int_nil;
	if (BBPcheck((bat) *bid, "CMDhtype")) {
		BAT *b = lock_desc((bat) *bid);
		if (b) {
			ret = *bid > 0 ? b->htype : b->ttype;
		}
		unlock_desc(*bid);
	} *res = ret;
	return GDK_SUCCEED;
	
}

int
CMDhtype_bat(int *res, BAT *b)
{
	*res = b->htype; 
	return GDK_SUCCEED;
}

int
CMDtail(str *res, int *bid)
{
	if (BBPcheck((bat) *bid, "CMDtail")) {
		str ret = (str)str_nil;
		BAT *b = lock_desc((bat) *bid);

		if (b) {
			ret = *bid > 0 ? ATOMname(b->ttype) : ATOMname(b->htype);
		}
		*res = GDKstrdup(ret);
		unlock_desc(*bid);
	} else {
		*res = GDKstrdup(str_nil);
	}
	return GDK_SUCCEED;
}

int
CMDtail_bat(str *res, BAT *b)
{
	return CMDtail(res, &b->batCacheid);
}

int
CMDttype(int *res, int *bid)
{
	int ret = int_nil;
	if (BBPcheck((bat) *bid, "CMDttype")) {
		BAT *b = lock_desc((bat) *bid);
		if (b) {
			ret = *bid > 0 ? b->ttype : b->htype;
		}
		unlock_desc(*bid);
	} *res = ret;
	return GDK_SUCCEED;
}

int
CMDttype_bat(int *res, BAT *b)
{
	*res = b->ttype; 
	return GDK_SUCCEED;
}



int
CMDsetkey(BAT **result, BAT *input, bit *param)
{
	BATkey(*result = input, *param ? BOUND2BTRUE : FALSE);
	BBPfix(input->batCacheid);
	return GDK_SUCCEED;
}

int
CMDsetset(BAT **result, BAT *input, bit *param)
{
	BATset(*result = input, *param ? BOUND2BTRUE : FALSE);
	BBPfix(input->batCacheid);
	return GDK_SUCCEED;
}

int
CMDordered(bit *result, BAT *input)
{
	*result = BATordered(input) ? 1 : 0;
	return GDK_SUCCEED;
}

int
CMDchk_order(BAT **result, BAT *input)
{
	BATordered(input);
	BATordered(BATmirror(input));
	BBPfix(input->batCacheid);
	*result = input;
	return GDK_SUCCEED;
}

int
CMDassert_order(BAT **result, BAT *input)
{
	PROPDEBUG {
	    /* only with -d8 actually check */
	    BATordered(BATmirror(input));
	    if (!(BATtordered(input)&1)) {
		GDKerror("assert_order(%s): tail was not ordered.\n", BBP_logical(input->batCacheid));
		return GDK_FAIL;
	    }
	}

	/* mark tail sorted */
	if (!(BATtordered(input)&1)) {
	    input->tsorted = GDK_SORTED;
	    input->batDirtydesc = TRUE;
	}
	BBPfix(input->batCacheid);
	*result = input;
	return GDK_SUCCEED;
}

int
CMDordered_rev(bit *result, BAT *input)
{
	*result = BATordered_rev(input) ? 1 : 0;
	return GDK_SUCCEED;
}

int
CMDgetkey(bit *ret, BAT *b)
{
	/* we must take care of the special case of a nil column (TYPE_void,seqbase=nil)
	 * such nil columns never set hkey (and BUNins will never invalidate it if set) yet
	 * a nil column of a BAT with <= 1 entries does not contain doubles => return TRUE.
	 */
	if (BATcount(b) <= 1) {
		*ret = TRUE;
	} else {
		if (!b->hkey) {
			BATpropcheck(b, BATPROPS_ALL);
		}
		*ret = b->hkey ? TRUE : FALSE;
	}
	return GDK_SUCCEED;
}

int
CMDpersists(BAT **r, BAT *input, bit *param)
{
	BATmode(*r = input, (*param == TRUE) ? PERSISTENT : (*param == FALSE) ? TRANSIENT : SESSION);
	BBPfix(input->batCacheid);
	return GDK_SUCCEED;
}

int
CMDdestroy(bit *res, str input )
{
	int bid = BBPindex(input);

	*res = FALSE;
	if (bid) {
		BBPfix(bid);
		if (BBPindex(input) == bid) {
			BAT *b = (BAT*)BBPgetdesc(ABS(bid));

			BATmode(b, TRANSIENT);
			*res = TRUE;
		}
		BBPunfix(bid);
	}
	return GDK_SUCCEED;
}

int
CMDsetaccess(BAT **r, BAT *input, int *param)
{
	bat oldCacheid = input->batCacheid;

	*r = BATsetaccess(input, *param);
	if ((*r)->batCacheid == oldCacheid) {
		BBPfix(oldCacheid);
	}
	return GDK_SUCCEED;
}

int
CMDgetaccess(int *r, BAT *input)
{
	*r = BATgetaccess(input);
	return GDK_SUCCEED;
}

static char *
pre(str s1, str s2)
{
	static char buf[64];

	snprintf(buf, 64, "%s%s", s1, s2);
	return buf;
}
static char *
local_itoa(ssize_t i)
{
	static char buf[32];

	snprintf(buf, 32, SSZFMT, i);
	return buf;
}
static char *
local_utoa(size_t i)
{
	static char buf[32];

	snprintf(buf, 32, SZFMT, i);
	return buf;
}

#define COLLISION 64 

static void
HASHinfo(BAT *bn, Hash *h, str s)
{
	BUN i;
	BUN j;
	BUN k;
	BUN cnt[COLLISION + 2];

	BUNins(bn, pre(s, "type"), ATOMname(h->type),FALSE);
	BUNins(bn, pre(s, "mask"), local_utoa(h->mask),FALSE);
	BUNins(bn, pre(s, "lim"), local_utoa(h->lim),FALSE);

	for (i = 0; i <= COLLISION + 1; i++) {
		cnt[i] = 0;
	}
	for (i = 0; i <= h->mask; i++) {
		if (h->hash[i] == BUN_NONE) {
			cnt[0]++;
		} else if (h->hash[i] > h->lim) {
			GDKerror("HASHinfo: hash consistency problem " BUNFMT "\n", i);
		} else {
			j = HASHlist(h, h->hash[i]);
			for (k = 0; j; k++)
				j >>= 1;
			cnt[k]++;
		}
	}

	for (i = 0; i <= COLLISION + 1; i++)
		if (cnt[i]) {
			BUNins(bn, pre(s, local_itoa((ssize_t) (i?(((ssize_t)1)<<(i-1)):0))), local_utoa((size_t) cnt[i]), FALSE);
		}
}

static void
infoHeap(BAT *bn, Heap *hp, str nme)
{
	char buf[1024], *p = buf;

	if (!hp)
		return;
	while (*nme)
		*p++ = *nme++;
	strcpy(p, "free");
	BUNins(bn, buf, local_utoa(hp->free),FALSE);
	strcpy(p, "size");
	BUNins(bn, buf, local_utoa(hp->size),FALSE);
	strcpy(p, "maxsize");
	BUNins(bn, buf, local_utoa(hp->maxsize),FALSE);
	strcpy(p, "storage");
	BUNins(bn, buf, (hp->base == NULL || hp->base == (char*)1) ? "absent" : (hp->storage == STORE_MMAP) ? (hp->filename ? "memory mapped" : "anonymous vm") : (hp->storage & STORE_PRIV) ? "private map" : "malloced",FALSE);
	strcpy(p, "newstorage");
	BUNins(bn, buf, (hp->newstorage == STORE_MEM) ? "malloced" : (hp->newstorage & STORE_PRIV) ? "private map" : "memory mapped",FALSE);
	strcpy(p, "filename");
	BUNins(bn, buf, hp->filename ? hp->filename : "no file",FALSE);
}

static char *
oidtostr(oid i)
{
	int len = 48;
	static char bf[48];
	char *p = bf;

	(void) OIDtoStr(&p, &len, &i);
	return bf;
}

int
CMDinfo(BAT **retval, BAT *b)
{
	BAT *bn;
	char mode[1024], *accessmode;

	if (!(bn = BATnew(TYPE_str, TYPE_str, 128)))
		return GDK_FAIL;
	*retval = bn;

	if (b->batPersistence == PERSISTENT) {
		strcpy(mode, "persistent");
	} else if (b->batPersistence == SESSION) {
		strcpy(mode, "session");
	} else if (b->batPersistence == TRANSIENT) {
		strcpy(mode, "transient");
	} else {
		strcpy(mode, "unknown");
	}

	switch (b->batRestricted) {
	case BAT_READ:
		accessmode = "read-only";
		break;
	case BAT_WRITE:
		accessmode = "updatable";
		break;
	case BAT_APPEND:
		accessmode = "append-only";
		break;
	default:
		accessmode = "unknown";
	}

	BUNins(bn, "batId", BATgetId(b),FALSE);
	BUNins(bn, "batCacheid", local_itoa((ssize_t)(b->batCacheid)),FALSE);
	BUNins(bn, "hparentid", local_itoa((ssize_t)(b->H->heap.parentid)),FALSE);
	BUNins(bn, "tparentid", local_itoa((ssize_t)(b->T->heap.parentid)),FALSE);
	BUNins(bn, "batSharecnt", local_itoa((ssize_t)(b->batSharecnt)),FALSE);
	BUNins(bn, "batCount", local_utoa((size_t)b->batCount),FALSE);
	BUNins(bn, "batCapacity", local_utoa((size_t)b->batCapacity),FALSE);
	BUNins(bn, "head", ATOMname(b->htype),FALSE);
	BUNins(bn, "tail", ATOMname(b->ttype),FALSE);
	BUNins(bn, "batPersistence", mode,FALSE);
	BUNins(bn, "batRestricted", accessmode,FALSE);
	BUNins(bn, "batRefcnt", local_itoa((ssize_t)(BBP_refs(b->batCacheid))),FALSE);
	BUNins(bn, "batLRefcnt", local_itoa((ssize_t)(BBP_lrefs(b->batCacheid))),FALSE);
	BUNins(bn, "batDirty", BATdirty(b) ? "dirty" : "clean",FALSE);
	BUNins(bn, "batSet", local_itoa((ssize_t)(b->batSet)),FALSE);

	BUNins(bn, "hsorted", local_itoa((ssize_t)(BAThordered(b))),FALSE);
	BUNins(bn, "hident", b->hident,FALSE);
	BUNins(bn, "hdense", local_itoa((ssize_t)(BAThdense(b))),FALSE);
	BUNins(bn, "hseqbase", oidtostr(b->hseqbase),FALSE);
	BUNins(bn, "hkey", local_itoa((ssize_t)(b->hkey)),FALSE);
	BUNins(bn, "hvarsized", local_itoa((ssize_t)(b->hvarsized)),FALSE);
	BUNins(bn, "halign", local_utoa(b->halign),FALSE);
	BUNins(bn, "hnosorted", local_utoa(b->H->nosorted),FALSE);
	BUNins(bn, "hnosorted_rev", local_utoa(b->H->nosorted_rev),FALSE);
	BUNins(bn, "hnodense", local_utoa(b->H->nodense),FALSE);
	BUNins(bn, "hnokey[0]", local_utoa(b->H->nokey[0]),FALSE);
	BUNins(bn, "hnokey[1]", local_utoa(b->H->nokey[1]),FALSE);
	BUNins(bn, "hnonil", local_utoa(b->H->nonil),FALSE);
	BUNins(bn, "hnil", local_utoa(b->H->nil),FALSE);

	BUNins(bn, "tident", b->tident,FALSE);
	BUNins(bn, "tdense", local_itoa((ssize_t)(BATtdense(b))),FALSE);
	BUNins(bn, "tseqbase", oidtostr(b->tseqbase),FALSE);
	BUNins(bn, "tsorted", local_itoa((ssize_t)(BATtordered(b))),FALSE);
	BUNins(bn, "tkey", local_itoa((ssize_t)(b->tkey)),FALSE);
	BUNins(bn, "tvarsized", local_itoa((ssize_t)(b->tvarsized)),FALSE);
	BUNins(bn, "talign", local_utoa(b->talign),FALSE);
	BUNins(bn, "tnosorted", local_utoa(b->T->nosorted),FALSE);
	BUNins(bn, "tnosorted_rev", local_utoa(b->T->nosorted_rev),FALSE);
	BUNins(bn, "tnodense", local_utoa(b->T->nodense),FALSE);
	BUNins(bn, "tnokey[0]", local_utoa(b->T->nokey[0]),FALSE);
	BUNins(bn, "tnokey[1]", local_utoa(b->T->nokey[1]),FALSE);
	BUNins(bn, "tnonil", local_utoa(b->T->nonil),FALSE);
	BUNins(bn, "tnil", local_utoa(b->T->nil),FALSE);

	BUNins(bn, "batInserted", local_utoa(b->batInserted),FALSE);
	BUNins(bn, "batDeleted", local_utoa(b->batDeleted),FALSE);
	BUNins(bn, "batFirst", local_utoa(b->batFirst),FALSE);
	BUNins(bn, "htop", local_utoa(b->H->heap.free),FALSE);
	BUNins(bn, "ttop", local_utoa(b->T->heap.free),FALSE);
	BUNins(bn, "batStamp", local_itoa((ssize_t)(b->batStamp)),FALSE);
	BUNins(bn, "lastUsed", local_itoa((ssize_t)(BBP_lastused(b->batCacheid))),FALSE);
	BUNins(bn, "curStamp", local_itoa((ssize_t)(BBPcurstamp())),FALSE);
	BUNins(bn, "batCopiedtodisk", local_itoa((ssize_t)(b->batCopiedtodisk)),FALSE);
	BUNins(bn, "batDirtydesc", b->batDirtydesc ? "dirty" : "clean",FALSE);

	BUNins(bn, "H->heap.dirty", b->H->heap.dirty ? "dirty" : "clean",FALSE);
	BUNins(bn, "T->heap.dirty", b->T->heap.dirty ? "dirty" : "clean",FALSE);
	infoHeap(bn, &b->H->heap, "head.");
	infoHeap(bn, &b->T->heap, "tail.");

	BUNins(bn, "H->vheap->dirty", (b->H->vheap && b->H->vheap->dirty) ? "dirty" : "clean",FALSE);
	infoHeap(bn, b->H->vheap, "hheap.");

	BUNins(bn, "T->vheap->dirty", (b->T->vheap && b->T->vheap->dirty) ? "dirty" : "clean",FALSE);
	infoHeap(bn, b->T->vheap, "theap.");

	/* dump index information */
	if (b->H->hash) {
		HASHinfo(bn, b->H->hash, "hhash->");
	}
	if (b->T->hash) {
		HASHinfo(bn, b->T->hash, "thash->");
	}
	return GDK_SUCCEED;
}

#define ROUND_UP(x,y) ((y)*(((x)+(y)-1)/(y)))

static int
CMDbatdisksize(lng *tot, BAT *b)
{
	size_t blksize = 512;
	size_t size = 0;

	if (!isVIEW(b)) {
		size += ROUND_UP(b->H->heap.free, blksize);
		size += ROUND_UP(b->T->heap.free, blksize);
		if (b->H->vheap)
			size += ROUND_UP(b->H->vheap->free, blksize);
		if (b->T->vheap)
			size += ROUND_UP(b->T->vheap->free, blksize);
	}
	*tot = size;
	return GDK_SUCCEED;
}

static int
CMDbatvmsize(lng *tot, BAT *b)
{
	size_t blksize = MT_pagesize();
	size_t size = 0;

	if (!isVIEW(b)) {
		BUN cnt = BATcapacity(b);

		size += ROUND_UP(b->H->heap.size, blksize);
		size += ROUND_UP(b->T->heap.size, blksize);
		if (b->H->vheap)
			size += ROUND_UP(b->H->vheap->size, blksize);
		if (b->T->vheap)
			size += ROUND_UP(b->T->vheap->size, blksize);
		if (b->H->hash)
			size += ROUND_UP(sizeof(BUN) * cnt, blksize);
		if (b->T->hash)
			size += ROUND_UP(sizeof(BUN) * cnt, blksize);
	}
	*tot = size;
	return GDK_SUCCEED;
}

static int
CMDbatsize(lng *tot, BAT *b, int force)
{
	size_t size = 0;

	if ( force || !isVIEW(b)) {
		BUN cnt = BATcapacity(b);

		size += b->H->heap.size;
		size += b->T->heap.size;
		if (b->H->vheap)
			size += b->H->vheap->size;
		if (b->T->vheap)
			size += b->T->vheap->size;
		if (b->H->hash)
			size += sizeof(BUN) * cnt;
		if (b->T->hash)
			size += sizeof(BUN) * cnt;
	}
	*tot = size;
	return GDK_SUCCEED;
}

int
CMDbatsize_str(lng *tot, str batname, int force)
{
	bat bid = BBPindex(batname);
	BAT *b = bid ? (BAT *) BBPgetdesc(bid) : NULL;

	if (b == NULL) {
		GDKerror("CMDbatsize_str: %s no such bat.\n", batname);
		return GDK_FAIL;
	}
	return CMDbatsize(tot, b, force);
}

@+ Synced BATs
@c
int
CMDsynced(bit *ret, BAT *b1, BAT *b2)
{
	*ret = ALIGNsynced(b1, b2) ? 1 : 0;
	return GDK_SUCCEED;
}

@+ BBP Management, IO
@c
int
CMDroles(BAT **r, BAT *b, str hname, str tname)
{
	BATroles(*r = b, hname, tname);
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

int
CMDcol_name(BAT **r, BAT *b, str tname)
{
	BATcol_name(*r = b, tname);
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

int
CMDrename(bit *retval, BAT *b, str s)
{
	int ret;
	int c;
	char *t = s;

	for ( ; (c = *t) != 0; t++) {
		if (c != '_' && !GDKisalnum(c)) {
			GDKerror("CMDrename: identifier expected: %s\n", s);
			return GDK_FAIL;
		}
	}

	ret = BATname(b, s);
	*retval = FALSE;
	if (ret == 1) {
		GDKerror("CMDrename: identifier expected: %s\n", s);
		return GDK_FAIL;
	} else if (ret == BBPRENAME_ILLEGAL) {
		GDKerror("CMDrename: illegal temporary name: '%s'\n", s);
		return GDK_FAIL;
	} else if (ret == BBPRENAME_LONG) {
		GDKerror("CMDrename: name too long: '%s'\n", s);
		return GDK_FAIL;
	} else if (ret != BBPRENAME_ALREADY) {
		*retval = TRUE;
	}
	return GDK_SUCCEED;
}

int
CMDname(str *retval, BAT *b)
{
	*retval = GDKstrdup(BBPname(b->batCacheid));
	return GDK_SUCCEED;
}

int
CMDunload(bit *res, str input)
{
	bat bid = ABS(BBPindex(input));

	*res = FALSE;
	if (bid > 0) {
		BAT *b;

		BBPfix(bid);
		b = BBP_cache(bid);
		if (b) {
			if (b->batPersistence == SESSION)
				BATmode(b, TRANSIENT);
			BBPcold(bid);	/* will trigger unload of also persistent bats */
		}
		*res = BBPunfix(bid) == 0;
	}
	return GDK_SUCCEED;
}

int
CMDhot(str input)
{
	BBPhot(BBPindex(input));
	return GDK_SUCCEED;
}

int
CMDcold(str input)
{
	BBPcold(BBPindex(input));
	return GDK_SUCCEED;
}

int
CMDheat(int *res, str input)
{
	int bid = BBPindex(input);

	if (bid) {
		*res = BBP_lastused(bid) & 0x7fffffff;
	}
	return GDK_SUCCEED;
}

int
CMDsave(bit *res, str input)
{
	bat bid = BBPindex(input);
	BAT *b;

	*res = FALSE;
	if (bid) {
		BBPfix(bid);
		b = BBP_cache(bid);
		if (b && BATdirty(b)) {
			if (BBPsave(b) == 0)
				*res = TRUE;
		}
		BBPunfix(bid);
	}
	return GDK_SUCCEED;
}


int
CMDmmap(BAT **r, BAT *b, int *hbns, int *tbns, int *hhp, int *thp)
{
	/* == int_nil means no change */
	if (*hbns == int_nil) 
		*hbns = b->batMaphead;
	if (*tbns == int_nil) 
		*tbns = b->batMaptail;
	if (b->H->vheap && *hhp == int_nil) 
		*hhp = b->batMaphheap;
	if (b->T->vheap && *thp == int_nil) 
		*thp = b->batMaptheap;
	if (BATmmap(*r = b, *hbns, *tbns, *hhp, *thp, 0) == 0) {
		BBPfix(b->batCacheid);
		return GDK_SUCCEED;
	}
	return GDK_FAIL;
}

int
CMDmadvise(BAT **r, BAT *b, int *hbns, int *tbns, int *hhp, int *thp)
{
	BBPfix(b->batCacheid);
	return BATmadvise(*r = b, (*hbns == int_nil) ? -1 : *hbns, (*tbns == int_nil) ? -1 : *tbns, (*hhp == int_nil) ? -1 : *hhp, (*thp == int_nil) ? -1 : *thp) ? GDK_FAIL : GDK_SUCCEED;
}

@+ Accelerator Control
@c
int
CMDaccbuild(BAT *b, str acc )
{
	if (strcmp(acc, "hash") == 0 && BAThash(b,0)) {
		return GDK_SUCCEED;
	}
	return GDK_FAIL;
}

int
CMDaccdel(BAT *b, str acc)
{
	if (strcmp(acc, "hash") == 0)
		HASHremove(b);
	return GDK_SUCCEED;
}

/* ITERATIONS ARE DEFINED ELSEWHERE */


int
CMDget_seqbase(oid *o, BAT *b)
{
	*o = b->hseqbase;
	return GDK_SUCCEED;
}

int
CMDset_seqbase(BAT **r, BAT *b, oid *o)
{
	BATseqbase(*r = b, *o);
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

@+ Page-wise BAT remappings
@T
The XML node storage scheme of MonetDB/XQuery needs some extra kernel support. 

@itemize
@item
  we introduce a fast way to create BATs with the VM pages in a different order
  (to cheaply support inserting new pages halfway). 
@item
  for other bats, there is a new rcopy(), that copies large heaps using
  copy-on-write memory maps. This is also done for string heaps, if they are
  no longer double eliminated. 
@item
  we introduce a primitive to swizzle OIDs for such remappings between RIDs (the real
  voids on disk) and PREs (the voids of the remapped copy).
@item
  we introduce 'isolate()' a primitive that executes a number of idempotent updates
  on a bat, such that all modified logical pages have received physical page
  copies (transparently by the MMU page faults it generates).
@end itemize

Also, we use copy-on-write maps for transaction isolation. Contrary to intuition, we 
write into STORE_MMAP read-only master bats (overriding the read-only protection 
with a new 'force' flag), and read only from the copy-on-write copies produced by 
the 'remap' and 'rcopy'. These copies provide efficient shadow paging. That is, before a master bat 
is replaced into (appends are no problem) then all live read copies (copy-on-write remaps) 
get a 'idempotent' replace on the affected pages (a BUN replace with a value that was 
already there), such that a shadow copy of the page is made by the OS. In this way, 
the subsequent update in the master bat is invisible in the copy-on-write copies 
(transaction isolation). 

The shadow copying could be done with BUN-replaces but can be optimized to touch just
one word per physical page. This is done by CMDisolate.

Similarly, the swizzle computations (from physical to logical id in remapped bats)
could be done with shifts, mask, addition and fetchjoins; it is done much faster
using the special-purpose CMDswizzle.  

other changes were:

@ itemize
@item
  gdk_bat.mx/gdk_batop.mx: a 'force' flag in update operations that allow to update
  read-only/append-only BATs anyway. Note that if used, another (WAL-based) recovery
  mechanism must be used to repair BATs after a system crash!! This is a user
  respsonability (in this case, of the MonetDB/XQuery frontend).
@item
  gdk_bat.mx: make a true copy of remapped/rcopied BUN heaps if the bat becomes persistent 
  or updatable. 
@item
  gdk_batop.mx: optimized fetchjoin for idempotent positional joins (into a bat[void,void]
  with equal seqbase and all tuples hitting). To keep semantics consistent, it is now
  an error if a fetchjoin is performed with a key that is out-of-range. Everything *must* match!
@item
  gdk_storage.mx: batload.  To preserve the integritry of string heaps with such forced updates, 
  the kernel zaps the internal hash table of string heaps. Note that this is only allowed if 
  double-elimination inside the string heap is disabled (in that case the hash table is not 
  required to be complete).  To prevent problems, the rcopy() does not do mmap-tricks for 
  double-eliminating heaps.
@end itemize

In swizzling as well as in positional join, specific optimizations are made for
the common case where all pages appear in order (this occurs in XML tables that have
not yet received updates or are read-only). In this case swizzling is a no-op.

For read-only tables, logical node IDs (nids) are equal to both PREs and RIDs. A 
translation from NID to PRE (or RID) then becomes positional join onto a bat[void,void] 
with seqbases 0@0, which is an idempotent join. This case now returns a view at
zero cost.

@- Remapped Copy
@T
CMDremap makes a copy of a bat, putting the logical 'pages' (REMAP_PAGE_SIZE tuples) in an 
alternative order, specified by a map. It is optimized to use copy-on-write memory 
mappings to make cheap copies, when possible.

The result is a read-only copy of the original. As it is a true copy, in principle 
we can replace (but nor insert/delete) BUNs in it, overriding the access restriction.

Making such bats persistent or appendable/writable, will force a true copy of the 
copy-on-write mmap heap to be made.
@c
static int
copy_segment(MT_mmap_hdl *hdl, BAT *bn, BAT *b, oid src, BUN dst, BUN cnt)
{
	int ret = 0;

	if (cnt) {
		size_t xx = REMAP_PAGE_SIZE * Tsize(b);
		off_t src_off = (off_t) (src * xx); /* 64bit: could overflow */
		size_t dst_off = dst * xx;
		size_t nbytes  = cnt * xx;
		size_t partial = (Tloc(b,BUNlast(b)) - Tloc(b,BUNfirst(b))) - src_off;

		if (!hdl) {
			/* copy segment from master bat */
			memcpy(Tloc(bn,BUNfirst(bn)) + dst_off, Tloc(b,BUNfirst(b)) + src_off, (partial < nbytes)?partial:nbytes);
		} else {
			if (MT_mmap_remap(hdl, src_off, nbytes) == (void *) -1) return 0;
		}
		if (partial < nbytes) {
			/* fill a partial page with nils */
			ptr nil = ATOMnilptr(bn->ttype);
			BUN cur = BUNfirst(bn) + (BUN) ((dst_off + partial) >> bn->T->shift);
			BUN end = BUNlast(bn);

			for (; cur < end; cur++) {
				Treplacevalue(bn, Tloc(bn,cur), nil);
			}
		}
	}
	ret = 1;
bunins_failed:
	return ret;
}

int
CMDremap(BAT **res, BAT *b, BAT *map, bit *force)
{
	BATiter mapi = bat_iterator(map), bni;
	BUN cnt = BATcount(map), n = BATcount(b);
	BUN max = (BUN) (1 + (((ssize_t) n) - 1) / (size_t) REMAP_PAGE_SIZE);
	int (*fix) (ptr) = BATatoms[b->ttype].atomFix;
	int mode = (MMAP_READ|MMAP_SEQUENTIAL) | ((*force)?MMAP_WRITE:MMAP_COPY);
	oid* pid = (oid*) alloca(cnt*sizeof(oid));
	BUN xx, yy = 0, zz = 0;
	char path[PATHLENGTH];
	char *chk;
	BUN p, q;
	BAT *bn;
	BATstore *bs;
	MT_mmap_hdl hdl;

   	/* try to use fast page-wise memory mapping technique on read-only mmapped [void,X] bats */ 
	char* mmappath = (b->batRestricted != BAT_WRITE &&
		    (b->T->heap.storage == STORE_MMAP))?path:NULL;

	/* sanity check on page map */
	if (BAThdense(map) == 0 || map->hseqbase ) {
		GDKerror("remap: map head column must be dense and starting from 0@0.\n");
		return GDK_FAIL;
	}
	if (b->ttype == TYPE_void) {
		/* remappings on bat[void,void] are only supported in the trivial case (all pages in order) */
		if (!BATtdense(map)) {
			GDKerror("remap: a bat[void,void] cannot me remapped.\n");
			return GDK_FAIL;
		}
		/* create another bat[void,void]. BEWARE: last page is not NIL padded!! */
		*res = bn = BATnew(TYPE_void, TYPE_void, 10);
		if (bn == NULL) return GDK_FAIL;
		BATseqbase(bn, 0);
		if (cnt) {
			oid mpid = *(oid*) BUNtail(mapi,BUNfirst(map));
			BATseqbase(BATmirror(bn), mpid << REMAP_PAGE_BITS);
		}
		BATsetcount(bn,cnt <<= REMAP_PAGE_BITS);
		return GDK_SUCCEED;
	}

	/* chk is a bit mask to ensure that no page is requested twice */
	chk = (char*) GDKzalloc(n = 1 + max/8);
	if (chk == NULL) return GDK_FAIL;

	/* check that the set of requested page-ids is a subset of all existing page-ids */
	BATloop(map, p, q) {
		oid id = *(oid*) BUNtail(mapi, p);
		size_t idx = id >> 3;  
		char mask = (char) (1 << (id & 7));  
		if (id > max) {
			GDKerror("remap: map index " OIDFMT "@0 out of range [0@0," BUNFMT "@0]\n", id, max);
			GDKfree(chk);
			return GDK_FAIL;
		} else if (chk[idx] & mask) {
			GDKerror("remap: map index " OIDFMT "@0 occurs twice.\n", id);
			GDKfree(chk);
			return GDK_FAIL;
		}
		pid[yy++] = id;
		chk[idx] |= mask;
	}
	GDKfree(chk);

	/* create result bat descriptor */
	bs = BATcreatedesc(TYPE_void, b->ttype, TRUE);
	bn = bs ? &bs->B : NULL;
	*res = bn; 
	bni = bat_iterator(bn);
	if (bn == NULL) return GDK_FAIL;
	BATinit_idents(bn);

	bn->H->type = TYPE_void;
	bn->H->varsized = 1;
	bn->H->shift = 0;
	bn->H->width = 0;
	bn->H->seq = 0;
	bn->H->nonil = 0;

	bn->T->type = b->T->type;
	bn->T->varsized = b->T->varsized;
	bn->T->shift = b->T->shift; 
	bn->T->width = b->T->width;
	bn->T->seq = b->T->seq;

	bn->tsorted = 0;
	bn->tkey = 0;
	bn->T->nonil = 0;
	bn->batRestricted = BAT_READ;
	n = cnt << REMAP_PAGE_BITS;

	/* copy the entire tail heap (if present) */
	if (ATOMvarsized(bn->ttype)) {
		if (HEAPalloc(bn->T->vheap, (size_t) (b->T->vheap->free*BATMARGIN), 1) >= 0) {
			memcpy(bn->T->vheap->base, b->T->vheap->base, bn->T->vheap->free = b->T->vheap->free);
		} else {
			goto error;
		}
	}
	/* try to get a reserved mmap region */
	if (mmappath) {
		void *base;
		size_t heapsize = tailsize(bn, n);

		if (bn->T->heap.filename)
			GDKfree(bn->T->heap.filename); 
		bn->T->heap.filename = GDKstrdup(b->T->heap.filename); 
		if (bn->T->heap.filename == NULL)
			goto error;
		GDKfilepath(mmappath, BATDIR, bn->T->heap.filename, NULL);
		base = MT_mmap_open(&hdl, mmappath, mode, 0, heapsize, cnt);
		if (base == (void*) -1) goto error;

		bn->T->heap.base = base;
		bn->T->heap.size = bn->T->heap.maxsize = heapsize; 
		bn->T->heap.storage = STORE_MMAP;
		if (!*force)
			bn->T->heap.storage |= STORE_PRIV; 
	} else if (HEAPalloc(&bn->T->heap, n, Tsize(bn)) < 0) {
		goto error;
	}

	/* set the right bat size */
	bn->batCapacity = n;
	BATsetcount(bn, n);
	bn->batFirst = bn->batDeleted = 0;
	bn->batInserted = (cnt << REMAP_PAGE_BITS);

	/* go over all pages and copy them in segments that unite consecutively mapped pages */
	for(xx=1; xx<cnt; xx++) {
		if (pid[xx]-1 != pid[xx-1]) {
			if (!copy_segment(mmappath ? &hdl : NULL, bn, b, pid[zz], zz, xx-zz))
				break;
			zz = xx;
		}
	}
	if (xx < cnt || !copy_segment(mmappath ? &hdl : NULL, bn, b, pid[zz], zz, cnt-zz)) {
		HEAPfree(&bn->T->heap);
		goto error;
	}
	if (mmappath) {
		MT_mmap_close(&hdl);
		GDKvminc(tailsize(bn, n));
	}

	/* if the tail atom has refcounting, we must fix the copies */
	if (fix) {
		BATloop(bn, p, q) {
			fix(BUNtail(bni, p));
		}
	}
	BBPcacheit(bs, 1);
	if (mmappath) {
		/* if copy-on-write was used, make bn a logical view on b */
		bn->P->lview = TRUE;
		bn->T->heap.copied = TRUE;
		if (bn->H->type != TYPE_void)
			BBPshare(bn->H->heap.parentid = b->batCacheid);
		if (bn->T->type != TYPE_void)
			BBPshare(bn->T->heap.parentid = -b->batCacheid);
	}
	return GDK_SUCCEED;
  error:
	if (mmappath)
		MT_mmap_close(&hdl);
	if (bn->T->vheap) {
		HEAPfree(bn->T->vheap);
		GDKfree(bn->T->vheap);
	}
	HEAPfree(&bn->T->heap);
	BBPclear(bn->batCacheid);
	return GDK_FAIL;
}

@- page-wise OID swizzling
@c
#ifdef HAVE_RESTRICT
#define __r     restrict
#else
#ifdef HAVE___RESTRICT__
#define __r     __restrict__
#else
#define __r
#endif
#endif

#define SWIZZLE(idx) ((map[idx >> REMAP_PAGE_BITS] << REMAP_PAGE_BITS) | (idx & (oid) REMAP_PAGE_MASK))  
#define SWIZZLE_CHECK(idx) ((map[(idx >> REMAP_PAGE_BITS) & (ok &= ((idx >= max) - 1))] << REMAP_PAGE_BITS) | (idx & (oid) REMAP_PAGE_MASK))  

static int 
swizzle(oid max, int htpe, oid tbase, BUN cnt, 
	oid *__r hdst, oid *__r tdst, oid *__r map, oid *__r head, oid *__r tail) 
{
	BUN i, n = cnt;
	int ok = -1;

	if (tbase != oid_nil) {
		if (tbase + cnt > max) {
			ok = 0;
		} else if (htpe) {
			for(i=0; i<n; i++, tbase++) {
				*hdst++ = head[i];
				*tdst++ = SWIZZLE(tbase);
			}
		} else {
			for(i=0; i<n; i++, tbase++) {
				*tdst++ = SWIZZLE(tbase);
			}
		}
	} else {
		if (htpe) {
			for(i=0; i<n; i++) {
				*hdst++ = head[i];
				*tdst++ = SWIZZLE_CHECK(tail[i]);
			}
		} else {
			for(i=0; i<n; i++) {
				*tdst++ = SWIZZLE_CHECK(tail[i]);
			}
		}
	}
	return ok;
}

int
CMDswizzle(BAT **res, BAT *b, BAT *map)
{
	BATiter mapi = bat_iterator(map), bi = bat_iterator(b), bni;
	BUN xx, yy=0, n = BATcount(b), max = BATcount(map);
	oid *pid = (oid*) BUNtail(mapi, BUNfirst(map));
	BUN p, q;
	BAT *bn;
	oid sqbs;

	if (map->hseqbase) {
		GDKerror("[swizzle]: map %s should be a void column starting at 0@0.\n", 
			BBP_logical(map->batCacheid));
		return GDK_FAIL;
	}

	/* sometimes we can just return the input bat (idempotent swizzle) */
	if (max == 0 || (BATtdense(map) && map->tseqbase == 0)) { 
		/* special semantics: empty bat (max == 0) => no remapping */
		/* or if map-tdense with base 0 => do not check for out-of-range oids (HACK) */
		if (max && map->tseqbase) {
			GDKerror("[swizzle]: map %s is a void view.\n", BBP_logical(map->batCacheid)); 
			return GDK_FAIL;
		}
		*res = VIEWcreate(b, b); /* used in the fast, read-only XML case */
		return GDK_SUCCEED;
	} 

	/* for efficiency, we ensure the map to be a simple array (copy if necessary) */
	if (map->ttype == TYPE_void) {
		pid = (oid*) GDKmalloc(max*sizeof(oid));
		if (pid == NULL) return GDK_FAIL;
		BATloop(map, p, q)
			pid[yy++] = *(oid*) BUNtail(mapi,p);
	}

	/* create the result bat and set its final size */
	*res = bn = BATnew(BAThdense(b)?TYPE_void:b->htype, TYPE_oid, n);
	bni = bat_iterator(bn);
	if (bn == NULL) return GDK_FAIL;
	BATsetcount(bn, n);
	BATseqbase(bn, b->hseqbase);

	/* do the work in a fast function */
	xx = swizzle(max << REMAP_PAGE_BITS,            /* maximum offset (for range check) */
		     bn->htype,                         /* generate a head column? */
		     BATtdense(b)?b->tseqbase:oid_nil,  /* input tail is dense? */
		     n,                                 /* number of input tuples */
		     (oid*) Hloc( bn, BUNfirst(bn)),    /* result array */
		     (oid*) Tloc( bn, BUNfirst(bn)),    /* result array */
		     pid,                               /* page-id lookup array */
		     (oid*) BUNhloc(bi,BUNfirst(b)),     /* head input array */
		     (oid*) BUNtloc(bi,BUNfirst(b))      /* tail input array */
		     ) == 0;

	if (yy) GDKfree(pid);
	if (xx) {
		GDKerror("[swizzle]: %s contains illegal offsets.\n", BBP_logical(b->batCacheid)); 
		BBPreclaim(bn);
		return GDK_FAIL;
	}

	sqbs = n == 0 ? 0 : *(oid*)BUNhead(bni,BUNfirst(bn));
	bn->hdense = BAThdense(b) || (n < 2 && sqbs != oid_nil);
	if (bn->hdense) {
		BATseqbase(bn, sqbs);
	}
	bn->hsorted = (bn->hdense || BAThordered(b)&1) ? GDK_SORTED : FALSE;
	BATkey(bn, bn->hdense || b->hkey != 0);

	sqbs = n == 0 ? 0 : *(oid*)BUNtail(bni,BUNfirst(bn));
	bn->tdense = n < 2 && sqbs != oid_nil;
	if (bn->tdense) {
		BATseqbase(BATmirror(bn), sqbs);
	}
	bn->tsorted = bn->tdense ? GDK_SORTED : FALSE;
	BATkey(BATmirror(bn), bn->tdense || b->tkey != 0);

	return GDK_SUCCEED;
}

@- fast isolation support

If *pageids == TRUE, the oids are logical page-ids (REMAP_PAGE_SIZE) and the entire page
needs to be isolated. Note the distinction between physical and logical pages. VM needs
isolation on the physical level. The difference can be significant. A locical page is defined 
as a number of tuples (e.g. 64K) thus spans up to 512KB in case of a 8-byte type such as lng 
or oid. Such a a 512KB range may span up to 128 physical OS pages (MT_pagesize can be as low 
as 4KB on current systems).

All this is taken csre of by CMDisolate.
@c
int
CMDisolate(BAT *b, BAT *dirty, bit *pageids) {
	BATiter dirtyi = bat_iterator(dirty);
	int bogus = ~((((*pageids)&64)>>5) != (((*pageids)&32)>>4)); /* yields all ones */
	BUN cnt = BATcount(b);

	if (!BAThdense(b) || b->hseqbase || Tsize(b) != ATOMsize(b->ttype)) {
		GDKerror("isolate(%s): should be a unary column.\n", BBP_logical(b->batCacheid));
		return GDK_FAIL;
	}
	if (b->T->vheap && b->T->vheap->base && b->T->vheap->storage != STORE_MEM) {
		GDKerror("isolate(%s): cannot isolate tail heaps.\n", BBP_logical(b->batCacheid));
		return GDK_FAIL;
	}
	if (b->T->heap.storage == STORE_MMAP) {
		GDKerror("isolate(%s): cannot isolate direct maps.\n", BBP_logical(b->batCacheid));
		return GDK_FAIL;
	}
	if (cnt && (b->T->heap.storage & STORE_PRIV)) {
		size_t pagebits, pagesize = MT_pagesize(), pagecnt = pagesize/ATOMsize(b->ttype);
		size_t pos, lim = 0, idx, xx, yy = pagecnt;
		unsigned int *bitmask;
		BUN p, q;
		for(pagebits=0; yy>1; pagebits++) yy >>= 1;

		/* determine the number of bitmask slots, and zalloc it */
		yy = 1+ ((cnt-1) >> (pagebits+5)); /* 5 is for 32, #bits in a unsigned int */
		bitmask = (unsigned int*) GDKmalloc(yy*sizeof(unsigned int));
		if (bitmask == NULL) {
			GDKerror("isolate(%s): memory failure.\n", BBP_logical(b->batCacheid));
			return GDK_FAIL;
		}
		for(xx=0; xx<yy; xx++) bitmask[xx] = 0;

		if (*pageids) {
			BATloop(dirty, p, q) {
				/* oid is a page number, calculate absolute oid */
				pos = (*(oid*) BUNtail(dirtyi,p)) << REMAP_PAGE_BITS;
				lim = pos + (size_t) REMAP_PAGE_SIZE;
	
				if (lim > cnt) lim = cnt; /* out of bounds!! */

				/* must touch all physical pages in this logical page */
				for(; pos<lim; pos+=pagecnt) { 
					idx = pos >> pagebits;
					bitmask[idx >> 5] |= 1 << (idx&31); 
				}
			}
		} else {
			/* oids are the BUNs that must be isolated */
			BATloop(dirty, p, q) {
				pos = *(oid*) BUNtail(dirtyi,p);

				if (pos > cnt) continue; /* out of bounds!! */

				idx = pos >> pagebits;
				bitmask[idx >> 5] |= 1 << (idx&31); 
			}
		}	

		/* write an idempotent byte into all pages that need isolation */
		for(xx=0; xx<yy; xx++) {
			unsigned int msk = bitmask[xx];
			if (msk) {
				chr *touch = ((chr*) b->T->heap.base) + xx * (pagesize << 5);
				do {
					if ((msk&127) == 0) { /* skip 7 clean pages */
						msk >>=7; touch += (pagesize<<3)-pagesize;
					} 
					if (msk&1) {
						/* do LOAD/STORE; bit-AND with all-ones to fool compiler */
						*(int*)touch = (*(int*)touch)&bogus; /* causes OS trap (copy-on-write) */
					} 
					msk >>= 1; touch += pagesize;
				} while(msk);
			} /* else: skip 32 clean pages */
		}
		GDKfree(bitmask);
	}
	return GDK_SUCCEED;
}

int
CMDmsync(BAT **r, BAT *b, oid* lo, oid *hi, bit *async)
{
	if (b->hseqbase == oid_nil || Tsize(b) > ATOMsize(ATOMtype(b->ttype))) {
		GDKerror("msync(%s, " OIDFMT ", " OIDFMT "): illegal head column.\n", BBP_logical(b->batCacheid), *lo, *hi);
		return GDK_FAIL;
	}
	if (*lo < b->hseqbase || *lo > *hi || (*hi - *lo) > BATcount(b)) {
		GDKerror("msync(%s, " OIDFMT ", " OIDFMT "): illegal lo-hi head range.\n", BBP_logical(b->batCacheid), *lo, *hi);
		return GDK_FAIL;
	}
	if (*lo < *hi && (b->T->heap.storage == STORE_MMAP)) {
		size_t lo_off = (*lo - b->hseqbase) * Tsize(b);
		size_t hi_off = (*hi - b->hseqbase) * Tsize(b);
		lo_off = (lo_off / MT_pagesize()) * MT_pagesize();
		hi_off = (((hi_off - 1) / MT_pagesize()) + 1) * MT_pagesize();
		if (MT_msync(b->T->heap.base, lo_off, hi_off - lo_off, (*async==TRUE)?MMAP_ASYNC:MMAP_SYNC)) {
			GDKerror("msync(%s, " OIDFMT ", " OIDFMT "): buns sync failed.\n", BBP_logical(b->batCacheid), *lo, *hi);
			return GDK_FAIL;
		}
	}
	if (b->T->vheap && b->T->vheap->storage == STORE_MMAP) { /* flush tail heaps fully */
		if (MT_msync(b->T->vheap->base, 0, b->T->vheap->free, (*async==TRUE)?MMAP_ASYNC:MMAP_SYNC)) { 
			GDKerror("msync(%s, " OIDFMT ", " OIDFMT "): tail sync failed.\n", BBP_logical(b->batCacheid), *lo, *hi);
			return GDK_FAIL;
		}
	}
	*r = b;
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}
@}

@- Wrapping
The remainder contains the wrapper code over the version 4
@+ InformationFunctions
In most cases we pass a BAT identifier, which should be unified
with a BAT descriptor. Upon failure we can simply abort the function.

The logical head type :oid is mapped to a TYPE_void
with sequenceBase. It represents the old fashioned :vid
@c


str
BKCnewBAT(int *res, int *ht, int *tt, BUN *cap)
{
	BAT *b;

	if( *ht == TYPE_oid){
		int tpe= TYPE_void;
		if (CMDnew(&b, &tpe, tt, cap) == GDK_SUCCEED) {
			oid o= 0;
			BATseqbase(b, o);
			*res = b->batCacheid;
			BBPkeepref(*res);
			return MAL_SUCCEED;
		}
	} else
	if (CMDnew(&b, ht, tt, cap) == GDK_SUCCEED) {
		*res = b->batCacheid;
		BBPkeepref(*res);
		return MAL_SUCCEED;
	}
	throw(MAL, "bat.new", GDK_EXCEPTION);
}

str
BKCattach(int *ret, int *tt, str *heapfile)
{
	BAT *b;

	if (CMDattach(&b, tt, *heapfile) == GDK_SUCCEED) {
		*ret = b->batCacheid;
		BBPkeepref(*ret);
		return MAL_SUCCEED;
	}
	throw(MAL, "bat.attach", GDK_EXCEPTION);
}

str
BKCdensebat(int *ret, wrd *size)
{
	BAT *b;

	if (CMDdensebat(&b, size) == GDK_SUCCEED) {
		*ret = b->batCacheid;
		BBPkeepref(*ret);
		return MAL_SUCCEED;
	}
	throw(MAL, "bat.densebat", GDK_EXCEPTION);
}

str
BKCreverse(int *ret, int *bid)
{
	BAT *b, *bn = NULL;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "bat.reverse", RUNTIME_OBJECT_MISSING);
	}

	CMDreverse(&bn, b);
	BBPreleaseref(b->batCacheid);
	if (bn) {
		*ret = bn->batCacheid;
		BBPkeepref(bn->batCacheid);
		return MAL_SUCCEED;
	}
	throw(MAL, "bat.reverse", GDK_EXCEPTION);
}

str
BKCmirror(int *ret, int *bid)
{
	BAT *b, *bn = NULL;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "bat.mirror", RUNTIME_OBJECT_MISSING);
	}
	if (CMDmirror(&bn, b) == GDK_SUCCEED) {
		*ret = bn->batCacheid;
		BBPkeepref(*ret);
		BBPreleaseref(b->batCacheid);
		return MAL_SUCCEED;
	}
	*ret = 0;
	BBPreleaseref(b->batCacheid);
	throw(MAL, "bat.mirror", GDK_EXCEPTION);
}

str
BKCrevert(int *ret, int *bid)
{
	BAT *b, *bn;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "bat.revert", RUNTIME_OBJECT_MISSING);
	}
	bn= BATrevert(b);
	if(bn==NULL ){
		BBPreleaseref(b->batCacheid);
		throw(MAL, "bat.revert", GDK_EXCEPTION);
	}
	BBPkeepref(*ret= bn->batCacheid);
	return MAL_SUCCEED;
}

str
BKCorder(int *ret, int *bid)
{
	BAT *b,*bn;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "bat.order", RUNTIME_OBJECT_MISSING);
	}
	bn= BATorder(b);
	if (bn != b)
		BBPreleaseref(b->batCacheid);
	if(bn==NULL ){
		throw(MAL, "bat.order", GDK_EXCEPTION);
	}
	BBPkeepref(*ret= bn->batCacheid);
	return MAL_SUCCEED;
}

str
BKCorder_rev(int *ret, int *bid)
{
	BAT *b,*bn;

	(void) ret;
	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "bat.order_rev", RUNTIME_OBJECT_MISSING);
	}
	bn= BATorder_rev(b);
	if (bn != b)
		BBPreleaseref(b->batCacheid);
	if(bn==NULL ){
		throw(MAL, "bat.order_rev", GDK_EXCEPTION);
	}
	BBPkeepref(*ret= bn->batCacheid);
	return MAL_SUCCEED;
}

@-
Insertions into the BAT may involve void types (=no storage required)
These cases should actually be captured during BUNins, because they
may emerge internally as well.
@= void_insertbun
if (b->@1type == TYPE_void && *(oid*) @1 != oid_nil &&
    *(oid*) @1 != (b->@1seqbase + BUNgetpos(b, BUNlast(b))))
{
printf("val " OIDFMT " seqbase " OIDFMT " pos " BUNFMT "\n", *(oid*)@1,
	b->@1seqbase,  BUNgetpos(b, BUNlast(b)) );
      throw(MAL, "bat.insert", OPERATION_FAILED " Insert non-nil values in a void column.");
}
@c

char *
BKCinsert_bun(int *r, int *bid, ptr h, ptr t)
{
	BAT *i,*b;
	int param=0;
	(void) r;

	if ((i = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "bat.insert", RUNTIME_OBJECT_MISSING);
	}
	CMDsetaccess(&b,i,&param);
	@:derefStr(b,h,h)@
	@:derefStr(b,t,t)@
	BUNins(b, h, t,FALSE);
	BBPkeepref(*r=b->batCacheid);
	BBPreleaseref(i->batCacheid);
	return MAL_SUCCEED;
}

char *
BKCinsert_bun_force(int *r, int *bid, ptr h, ptr t, bit *force)
{
	BAT *i,*b;
	int param=0;
	(void) r;

	if ((i = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "bat.insert", RUNTIME_OBJECT_MISSING);
	}
	CMDsetaccess(&b,i,&param);
	@:derefStr(b,h,h)@
	@:derefStr(b,t,t)@
	BUNins(b, h, t, *force);
	BBPkeepref(*r=b->batCacheid);
	BBPreleaseref(i->batCacheid);
	return MAL_SUCCEED;
}

str
BKCinsert_bat(int *r, int *bid, int *sid)
{
	BAT *i,*b, *s;
	int param=0;

	if ((i = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "bat.insert", RUNTIME_OBJECT_MISSING);
	}
	if ((s = BATdescriptor(*sid)) == NULL) {
		BBPreleaseref(i->batCacheid);
		throw(MAL, "bat.insert", RUNTIME_OBJECT_MISSING);
	}
	CMDsetaccess(&b,i,&param);
	if (BATins(b, s,FALSE) == NULL) {
		BBPreleaseref(b->batCacheid);
		BBPreleaseref(s->batCacheid);
		BBPreleaseref(i->batCacheid);
		throw(MAL, "bat.insert", GDK_EXCEPTION);
	}
	BBPkeepref(*r=b->batCacheid);
	BBPreleaseref(s->batCacheid);
	BBPreleaseref(i->batCacheid);
	return MAL_SUCCEED;
}

str
BKCinsert_bat_force(int *r, int *bid, int *sid, bit *force)
{
	BAT *i,*b, *s;
	int param=0;

	if ((i = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "bat.insert", RUNTIME_OBJECT_MISSING);
	}
	if ((s = BATdescriptor(*sid)) == NULL) {
		BBPreleaseref(i->batCacheid);
		throw(MAL, "bat.insert", RUNTIME_OBJECT_MISSING);
	}
	CMDsetaccess(&b,i,&param);
	if (BATins(b, s, *force) == NULL) {
		BBPreleaseref(b->batCacheid);
		BBPreleaseref(s->batCacheid);
		BBPreleaseref(i->batCacheid);
		throw(MAL, "bat.insert", GDK_EXCEPTION);
	}
	BBPkeepref(*r=b->batCacheid);
	BBPreleaseref(s->batCacheid);
	BBPreleaseref(i->batCacheid);
	return MAL_SUCCEED;
}


str
BKCreplace_bun(int *r, int *bid, ptr h, ptr t)
{
	BAT *i,*b;
	int param=0;

	if ((i = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "bat.replace", RUNTIME_OBJECT_MISSING);
	}
	CMDsetaccess(&b,i,&param);
	@:derefStr(b,h,h)@
	@:derefStr(b,t,t)@
	if (BUNreplace(b, h, t, 0) == NULL) {
		BBPreleaseref(b->batCacheid);
		BBPreleaseref(i->batCacheid);
		throw(MAL, "bat.replace", GDK_EXCEPTION);
	}
	BBPkeepref(*r=b->batCacheid);
	BBPreleaseref(i->batCacheid);
	return MAL_SUCCEED;
}

str
BKCreplace_bat(int *r, int *bid, int *sid)
{
	BAT *i, *b, *bn, *s;
	int param=0;

	if ((i = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "bat.replace", RUNTIME_OBJECT_MISSING);
	}
	if ((s = BATdescriptor(*sid)) == NULL) {
		BBPreleaseref(i->batCacheid);
		throw(MAL, "bat.replace", RUNTIME_OBJECT_MISSING);
	}
	CMDsetaccess(&b,i,&param);
	bn=BATreplace(b, s, 0);
	if (bn == NULL || bn->batCacheid != b->batCacheid){
		BBPreleaseref(i->batCacheid);
		BBPreleaseref(s->batCacheid);
		BBPreleaseref(b->batCacheid);
		if( bn)
			BBPreleaseref(bn->batCacheid);
		throw(MAL, "bat.replace", OPERATION_FAILED);
	}
	BBPkeepref(*r=bn->batCacheid);
	BBPreleaseref(i->batCacheid);
	BBPreleaseref(s->batCacheid);
	return MAL_SUCCEED;
}

str
BKCreplace_bun_force(int *r, int *bid, ptr h, ptr t, bit *force)
{
	BAT *b, *bn;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "bat.replace", RUNTIME_OBJECT_MISSING);
	}
	@:derefStr(b,h,h)@
	@:derefStr(b,t,t)@
	bn= BUNreplace(b, h, t, *force);
	if (bn == NULL){
		BBPreleaseref(b->batCacheid);
		throw(MAL, "bat.replace", OPERATION_FAILED);
	}
	if(bn->batCacheid != b->batCacheid) {
		BBPreleaseref(b->batCacheid);
		BBPreleaseref(bn->batCacheid);
		throw(MAL, "bat.replace", OPERATION_FAILED "Different BAT returned");
	}
	BBPkeepref(*r=bn->batCacheid);
	return MAL_SUCCEED;
}

str
BKCreplace_bat_force(int *r, int *bid, int *sid, bit *force)
{
	BAT *b, *bn, *s;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "bat.replace", RUNTIME_OBJECT_MISSING);
	}
	if ((s = BATdescriptor(*sid)) == NULL) {
		BBPreleaseref(b->batCacheid);
		throw(MAL, "bat.replace", RUNTIME_OBJECT_MISSING);
	}
	bn= BATreplace(b, s, *force);
	if (bn == NULL || bn->batCacheid != b->batCacheid){
		BBPreleaseref(s->batCacheid);
		BBPreleaseref(b->batCacheid);
		if (bn)
			BBPreleaseref(bn->batCacheid);
		throw(MAL, "bat.replace_bat", OPERATION_FAILED);
	}
	BBPkeepref(*r=bn->batCacheid);
	BBPreleaseref(s->batCacheid);
	return MAL_SUCCEED;
}

char *
BKCdelete_bun(int *r, int *bid, ptr h, ptr t)
{
	BAT *b, *bn;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "bat.delete", RUNTIME_OBJECT_MISSING);
	}
	@:derefStr(b,h,h)@
	@:derefStr(b,t,t)@
	bn= BUNdel(b, h, t,FALSE);
	if (bn == NULL){
		BBPreleaseref(b->batCacheid);
		throw(MAL, "bat.delete_bun", OPERATION_FAILED);
	}
	if(bn->batCacheid != b->batCacheid) {
		BBPreleaseref(b->batCacheid);
		BBPreleaseref(bn->batCacheid);
		throw(MAL, "bat.delete_bun", OPERATION_FAILED "Different BAT returned");
	}
	BBPkeepref(*r=bn->batCacheid);
	return MAL_SUCCEED;
}

char *
BKCdelete(int *r, int *bid, ptr h)
{
	BAT *b, *bn;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "bat.delete", RUNTIME_OBJECT_MISSING);
	}
	@:derefStr(b,h,h)@
	bn= BUNdelHead(b, h,FALSE);
	if (bn == NULL) {
		BBPreleaseref(b->batCacheid);
		throw(MAL, "bat.delete", OPERATION_FAILED);
	}
	if (bn->batCacheid != b->batCacheid) {
		BBPreleaseref(b->batCacheid);
		BBPreleaseref(bn->batCacheid);
		throw(MAL, "bat.delete", OPERATION_FAILED "Different BAT returned");
	}
	BBPkeepref(*r=bn->batCacheid);
	return MAL_SUCCEED;
}

str
BKCdelete_all(int *r, int *bid)
{
	BAT *b, *bn;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "bat.delete", RUNTIME_OBJECT_MISSING);
	}
	bn=BATclear(b);
	if (bn == NULL){
		BBPreleaseref(b->batCacheid);
		throw(MAL, "bat.delete_all", OPERATION_FAILED);
	}
	if(bn->batCacheid != b->batCacheid){
		BBPreleaseref(b->batCacheid);
		BBPreleaseref(bn->batCacheid);
		throw(MAL, "bat.delete_all", OPERATION_FAILED "Different BAT returned");
	}
	BBPkeepref(*r=b->batCacheid);
	return MAL_SUCCEED;
}

str
BKCdelete_bat_bun(int *r, int *bid, int *sid)
{
	BAT *b, *bn, *s;

	if( *bid == *sid)
		return BKCdelete_all(r,bid);
	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "bat.delete", RUNTIME_OBJECT_MISSING);
	}
	if ((s = BATdescriptor(*sid)) == NULL) {
		BBPreleaseref(b->batCacheid);
		throw(MAL, "bat.delete", RUNTIME_OBJECT_MISSING);
	}

	bn=BATdel(b, s,FALSE);
	if (bn == NULL || bn->batCacheid != b->batCacheid){
		BBPreleaseref(s->batCacheid);
		BBPreleaseref(b->batCacheid);
		if(bn)
			BBPreleaseref(bn->batCacheid);
		throw(MAL, "bat.delete_bat_bun", OPERATION_FAILED);
	}
	BBPkeepref(*r=bn->batCacheid);
	BBPreleaseref(s->batCacheid);
	return MAL_SUCCEED;
}

str
BKCdelete_bat(int *r, int *bid, int *sid)
{
	BAT *i,*b, *s;
	int param=0;

	if ((i = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "bat.delete", RUNTIME_OBJECT_MISSING);
	}
	if ((s = BATdescriptor(*sid)) == NULL) {
		BBPreleaseref(i->batCacheid);
		throw(MAL, "bat.delete", RUNTIME_OBJECT_MISSING);
	}
	CMDsetaccess(&b,i,&param);
	if (BATdelHead(b, s,FALSE) == NULL) {
		BBPreleaseref(b->batCacheid);
		BBPreleaseref(s->batCacheid);
		BBPreleaseref(i->batCacheid);
		throw(MAL, "bat.delete", OPERATION_FAILED);
	}
	BBPkeepref(*r=b->batCacheid);
	BBPreleaseref(s->batCacheid);
	BBPreleaseref(i->batCacheid);
	return MAL_SUCCEED;
}

str
BKCdestroy_bat(bit *r, str *input)
{
	CMDdestroy(r, *input);
	return MAL_SUCCEED;
}

char *
BKCdestroyImmediate(signed char*r, int *bid)
{
	BAT *b;
	char buf[512];

	if ((b = BATdescriptor(*bid)) == NULL) 
		return MAL_SUCCEED;
	BBPlogical(b->batCacheid, buf);
	BBPreleaseref(b->batCacheid);
	CMDdestroy(r, buf);
	return MAL_SUCCEED;
}

char *
BKCdestroy(signed char *r, int *bid)
{
	BAT *b;

	(void) r;
	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "bat.destroy", RUNTIME_OBJECT_MISSING);
	}
	*bid = 0;
	BATmode(b, TRANSIENT);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}

/* The SQL frontend uses void-head bats */
BUN
void_delete_bat(BAT *b, BAT *d, int delta)
{
	BATiter di = bat_iterator(d);
	BUN nr = 0;
	BUN r, s;
	ptr nil = ATOMnilptr(b->ttype);

	if (delta) {
		for (r = d->batInserted; r < BUNlast(d); r++) {
			oid delid = *(oid *) BUNtail(di, r);

			void_inplace(b, delid, nil, TRUE);
			nr++;
		}
	} else {
		BATaccessBegin(d,USE_TAIL,MMAP_SEQUENTIAL);
		BATloop(d, r, s) {
			oid delid = *(oid *) BUNtail(di, r);

			void_inplace(b, delid, nil, TRUE);
			nr++;
		}
		BATaccessEnd(d,USE_TAIL,MMAP_SEQUENTIAL);
	}
	return nr;
}

BUN
void_insert_delta(BAT *b, BAT *u)
{
	BATiter ui = bat_iterator(u);
	BUN nr = 0;
	BUN r;

	for (r = u->batInserted; r < BUNlast(u); r++) {
		BUNappend(b, BUNtail(ui, r),FALSE);
		nr++;
	}
	return nr;
}

BUN
void_replace_delta(BAT *b, BAT *u)
{
	BATiter ui = bat_iterator(u);
	BUN nr = 0;
	BUN r;

	for (r = u->batInserted; r < BUNlast(u); r++) {
		oid updid = *(oid *) BUNhead(ui, r);
		ptr val = BUNtail(ui, r);

		void_inplace(b, updid, val, TRUE);
		nr++;
	}
	return nr;
}

char *
BKCappend_wrap(int *r, int *bid, int *uid)
{
	BAT *b, *i, *u;
	int param=0;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "bat.append", RUNTIME_OBJECT_MISSING);
	}
	if ((u = BATdescriptor(*uid)) == NULL) {
		BBPreleaseref(b->batCacheid);
		throw(MAL, "bat.append", RUNTIME_OBJECT_MISSING);
	}
	CMDsetaccess(&i,b,&param);
	BATappend(i, u,FALSE);
	BBPkeepref(*r=i->batCacheid);
	BBPreleaseref(b->batCacheid);
	BBPreleaseref(u->batCacheid);
	return MAL_SUCCEED;
}

str
BKCappend_val_wrap(int *r, int *bid, ptr u)
{
	BAT *i,*b;
	int param=0;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "bat.append", RUNTIME_OBJECT_MISSING);
	}

	@:derefStr(b,t,u)@
	CMDsetaccess(&i,b,&param);
	BUNappend(i, u,FALSE);
	BBPkeepref(*r=i->batCacheid);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}
str
BKCappend_reverse_val_wrap(int *r, int *bid, ptr u)
{
	BAT *i,*b;
	int param=0;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "bat.append", RUNTIME_OBJECT_MISSING);
	}

	CMDsetaccess(&i,b,&param);
	@:derefStr(i,t,u)@
	BUNappend(BATmirror(i), u,FALSE);
	BBPkeepref(*r=i->batCacheid);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}

char *
BKCappend_force_wrap(int *r, int *bid, int *uid, bit *force)
{
	BAT *b,*i, *u;
	int param=0;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "bat.append", RUNTIME_OBJECT_MISSING);
	}
	if ((u = BATdescriptor(*uid)) == NULL) {
		BBPreleaseref(b->batCacheid);
		throw(MAL, "bat.append", RUNTIME_OBJECT_MISSING);
	}
	CMDsetaccess(&i,b,&param);
	BATappend(i, u, *force);
	BBPkeepref(*r=i->batCacheid);
	BBPreleaseref(u->batCacheid);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}

str
BKCappend_val_force_wrap(int *r, int *bid, ptr u, bit *force)
{
	BAT *b,*i;
	int param=0;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "bat.append", RUNTIME_OBJECT_MISSING);
	}

	CMDsetaccess(&i,b,&param);
	@:derefStr(i,t,u)@
	BUNappend(i, u, *force);
	BBPkeepref(*r=i->batCacheid);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}

str 
BKCbun_inplace(int *r, int *bid, oid *id, ptr t)
{
	BAT *o;

	(void) r;
	if ((o = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "bat.inplace", RUNTIME_OBJECT_MISSING);
	}
	void_inplace(o, *id, t,FALSE);
	BBPkeepref(*r = o->batCacheid);
	return MAL_SUCCEED;
}

str 
BKCbun_inplace_force(int *r, int *bid, oid *id, ptr t, bit *force)
{
	BAT *o;

	(void) r;
	if ((o = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "bat.inplace", RUNTIME_OBJECT_MISSING);
	}
	void_inplace(o, *id, t, *force);
	BBPkeepref(*r = o->batCacheid);
	return MAL_SUCCEED;
}

str
BKCbat_inplace(int *r, int *bid, int *rid)
{
	BAT *o, *d;

	(void) r;
	if ((o = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "bat.inplace", RUNTIME_OBJECT_MISSING);
	}
	if ((d = BATdescriptor(*rid)) == NULL) {
		BBPreleaseref(o->batCacheid);
		throw(MAL, "bat.inplace", RUNTIME_OBJECT_MISSING);
	}
	void_replace_bat(o, d,FALSE);
	BBPkeepref(*r = o->batCacheid);
	BBPreleaseref(d->batCacheid);
	return MAL_SUCCEED;
}

str
BKCbat_inplace_force(int *r, int *bid, int *rid, bit *force)
{
	BAT *o, *d;

	(void) r;
	if ((o = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "bat.inplace", RUNTIME_OBJECT_MISSING);
	}
	if ((d = BATdescriptor(*rid)) == NULL) {
		BBPreleaseref(o->batCacheid);
		throw(MAL, "bat.inplace", RUNTIME_OBJECT_MISSING);
	}
	void_replace_bat(o, d, *force);
	BBPkeepref(*r = o->batCacheid);
	BBPreleaseref(d->batCacheid);
	return MAL_SUCCEED;
}

/*end of SQL enhancement */

char *
BKCgetAlpha(int *r, int *bid)
{
	BAT *b, *c;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "bat.getInserted", RUNTIME_OBJECT_MISSING);
	}
	c = BATalpha(b);
	*r = c->batCacheid;
	BBPkeepref(c->batCacheid);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}

char *
BKCgetDelta(int *r, int *bid)
{
	BAT *b, *c;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "bat.getDeleted", RUNTIME_OBJECT_MISSING);
	}
	c = BATdelta(b);
	*r = c->batCacheid;
	BBPkeepref(c->batCacheid);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}

str
BKCgetCapacity(lng *res, int *bid)
{
	CMDcapacity(res, bid);
	return MAL_SUCCEED;
}

str
BKCgetHeadType(str *res, int *bid)
{
	CMDhead(res, bid);
	return MAL_SUCCEED;
}

str
BKCgetTailType(str *res, int *bid)
{
	CMDtail(res, bid);
	return MAL_SUCCEED;
}

str
BKCgetRole(str *res, int *bid)
{
	BAT *b;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "bat.getType", RUNTIME_OBJECT_MISSING);
	}
	*res = GDKstrdup((*bid > 0) ? b->hident : b->tident);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}

str
BKCsetkey(int *res, int *bid, bit *param)
{
	BAT *b;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "bat.setKey", RUNTIME_OBJECT_MISSING);
	}
	BATkey(b, *param ? BOUND2BTRUE :FALSE);
	*res = b->batCacheid;
	BBPkeepref(b->batCacheid);
	return MAL_SUCCEED;
}

str
BKCsetSet(int *res, int *bid, bit *param)
{
	BAT *b;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "bat.setSet", RUNTIME_OBJECT_MISSING);
	}
	BATset(b, *param ? BOUND2BTRUE :FALSE);
	*res = b->batCacheid;
	BBPkeepref(b->batCacheid);
	return MAL_SUCCEED;
}

str
BKCisaSet(bit *res, int *bid)
{
	BAT *b;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "bat.isaSet", RUNTIME_OBJECT_MISSING);
	}
	*res = b->batSet;
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}

str
BKCsetSorted(bit *res, int *bid)
{
	BAT *b;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "bat.isSorted", RUNTIME_OBJECT_MISSING);
	}
	CMDordered(res, b);
	*res = BATordered(b) ? 1 : 0;
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}

str
BKCisSorted(bit *res, int *bid)
{
	BAT *b;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "bat.isSorted", RUNTIME_OBJECT_MISSING);
	}
	*res = BATordered(b) ? 1 : 0;
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}

str
BKCisSortedReverse(bit *res, int *bid)
{
	BAT *b;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "bat.isSorted", RUNTIME_OBJECT_MISSING);
	}
	*res = BATordered_rev(b) ? 1 : 0;
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}

@-
We must take care of the special case of a nil column (TYPE_void,seqbase=nil)
such nil columns never set hkey (and BUNins will never invalidate it if set) yet
a nil column of a BAT with <= 1 entries does not contain doubles => return TRUE.
@c

str
BKCgetKey(bit *ret, int *bid)
{
	BAT *b;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "bat.setPersistence", RUNTIME_OBJECT_MISSING);
	}
	CMDgetkey(ret, b);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}

str
BKCpersists(int *r, int *bid, bit *flg)
{
	BAT *b;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "bat.setPersistence", RUNTIME_OBJECT_MISSING);
	}
	BATmode(b, (*flg == TRUE) ? PERSISTENT : (*flg ==FALSE) ? TRANSIENT : SESSION);
	BBPreleaseref(b->batCacheid);
	*r = 0;
	return MAL_SUCCEED;
}

str
BKCsetPersistent(int *r, int *bid)
{
	bit flag= TRUE;
	return BKCpersists(r,bid, &flag);
}

str
BKCisPersistent(bit *res, int *bid)
{
	BAT *b;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "bat.setPersistence", RUNTIME_OBJECT_MISSING);
	}
	*res = (b->batPersistence == PERSISTENT) ? TRUE :FALSE;
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}

str
BKCsetTransient(int *r, int *bid)
{
	BAT *b;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "bat.setTransient", RUNTIME_OBJECT_MISSING);
	}
	BATmode(b, TRANSIENT);
	*r = 0;
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}

str
BKCisTransient(bit *res, int *bid)
{
	BAT *b;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "bat.setTransient", RUNTIME_OBJECT_MISSING);
	}
	*res = b->batPersistence == TRANSIENT;
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}

@-
@= accessMode_export
bat5_export str BKCset@1(int *res, int *bid) ;
bat5_export str BKChas@1(bit *res, int *bid);
@= accessMode
str BKCset@1(int *res, int *bid) {
	BAT *b, *bn = NULL;
	int param=@2;
    if( (b= BATdescriptor(*bid)) == NULL ){
        throw(MAL, "bat.set@1", RUNTIME_OBJECT_MISSING);
    }
	CMDsetaccess(&bn,b,&param);
	BBPkeepref(*res=bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}

str BKChas@1(bit *res, int *bid) {
	BAT *b;
    if( (b= BATdescriptor(*bid)) == NULL ){
        throw(MAL, "bat.set@1", RUNTIME_OBJECT_MISSING);
    }
	*res = BATgetaccess(b)=='@3';
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}
@-
@h
@:accessMode_export(WriteMode,0,w)@
@:accessMode_export(ReadMode,1,r)@
@:accessMode_export(AppendMode,2,a)@
@c
@:accessMode(WriteMode,0,w)@
@:accessMode(ReadMode,1,r)@
@:accessMode(AppendMode,2,a)@

str
BKCaccess(int *res, int *bid, int *m)
{
	BAT *b, *bn = NULL;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "bat.setAccess", RUNTIME_OBJECT_MISSING);
	}
	CMDsetaccess(&bn, b, m);
	*res = bn->batCacheid;
	BBPkeepref(bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}

str
BKCsetAccess(int *res, int *bid, str *param)
{
	BAT *b, *bn = NULL;
	int m;
	int oldid;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "bat.setAccess", RUNTIME_OBJECT_MISSING);
	}
	switch (*param[0]) {
	case 'r':
		m = 1;
		break;
	case 'a':
		m = 2;
		break;
	case 'w':
		m = 0;
		break;
	default:
		*res = 0;
		throw(MAL, "bat.setAccess", ILLEGAL_ARGUMENT" Got %c" " expected 'r','a', or 'w'", *param[0]);
	}
	/* CMDsetaccess(&bn, b, &m);*/

	oldid= b->batCacheid;
	bn = BATsetaccess(b, m);
	if ((bn)->batCacheid == b->batCacheid) {
		BBPkeepref(bn->batCacheid);
	} else {
		BBPreleaseref(oldid);
		BBPfix(bn->batCacheid);
		BBPkeepref(bn->batCacheid);
	}
	*res = bn->batCacheid;
	return MAL_SUCCEED;
}

str
BKCgetAccess(str *res, int *bid)
{
	BAT *b;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "bat.getAccess", RUNTIME_OBJECT_MISSING);
	}
	switch (BATgetaccess(b)) {
	case 1:
		*res = GDKstrdup("read");
		break;
	case 2:
		*res = GDKstrdup("append");
		break;
	case 0:
		*res = GDKstrdup("write");
		break;
	}
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}

@- Property management
All property operators should ensure exclusive access to the BAT
descriptor.
Where necessary use the primary view to access the properties
@c
str
BKCinfo(int *retval, int *bid)
{
	BAT *bn = NULL, *b;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "bat.getInfo", RUNTIME_OBJECT_MISSING);
	}
	if (CMDinfo(&bn, b) == GDK_SUCCEED) {
		*retval = bn->batCacheid;
		BBPkeepref(bn->batCacheid);
		BBPreleaseref(*bid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(*bid);
	throw(MAL, "BKCinfo", GDK_EXCEPTION);
}

str
BKCbatdisksize(lng *tot, int *bid){
	BAT *b;
	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "bat.getDiskSize", RUNTIME_OBJECT_MISSING);
	}
	CMDbatdisksize(tot,b);
	BBPreleaseref(*bid);
	return MAL_SUCCEED;
}

str
BKCbatvmsize(lng *tot, int *bid){
	BAT *b;
	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "bat.getDiskSize", RUNTIME_OBJECT_MISSING);
	}
	CMDbatvmsize(tot,b);
	BBPreleaseref(*bid);
	return MAL_SUCCEED;
}

str
BKCbatsize(lng *tot, int *bid){
	BAT *b;
	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "bat.getDiskSize", RUNTIME_OBJECT_MISSING);
	}
	CMDbatsize(tot,b, FALSE);
	BBPreleaseref(*bid);
	return MAL_SUCCEED;
}

str
BKCgetStorageSize(lng *tot, int *bid)
{
	BAT *b;

	if ((b = BATdescriptor(*bid)) == NULL)
		throw(MAL, "bat.getStorageSize", RUNTIME_OBJECT_MISSING);
	CMDbatsize(tot,b,TRUE);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}
str
BKCgetSpaceUsed(lng *tot, int *bid)
{
	BAT *b;
	size_t size = sizeof(BATstore);

	if ((b = BATdescriptor(*bid)) == NULL)
		throw(MAL, "bat.getSpaceUsed", RUNTIME_OBJECT_MISSING);

	if (!isVIEW(b)) {
		BUN cnt = BATcount(b);

		size += headsize(b, cnt);
		size += tailsize(b, cnt);
		/* the upperbound is used for the heaps */
		if (b->H->vheap)
			size += b->H->vheap->size;
		if (b->T->vheap)
			size += b->T->vheap->size;
		if (b->H->hash)
			size += sizeof(BUN) * cnt;
		if (b->T->hash)
			size += sizeof(BUN) * cnt;
	}
	*tot = size;
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}

str
BKCgetStorageSize_str(lng *tot, str batname)
{
	int bid = BBPindex(batname);

	if (bid == 0) 
		throw(MAL, "bat.getStorageSize", RUNTIME_OBJECT_MISSING);
	return BKCgetStorageSize(tot, &bid);
}

@+ Synced BATs
@c
str
BKCisSynced(bit *ret, int *bid1, int *bid2)
{
	BAT *b1, *b2;

	if ((b1 = BATdescriptor(*bid1)) == NULL) {
		throw(MAL, "bat.isSynced", RUNTIME_OBJECT_MISSING);
	}
	if ((b2 = BATdescriptor(*bid2)) == NULL) {
		BBPreleaseref(b1->batCacheid);
		throw(MAL, "bat.isSynced", RUNTIME_OBJECT_MISSING);
	}
	CMDsynced(ret, b1, b2);
	BBPreleaseref(b1->batCacheid);
	BBPreleaseref(b2->batCacheid);
	return MAL_SUCCEED;
}

@+ Role Management
@c
char *
BKCsetRole(int *r, int *bid, char **hname, char **tname)
{
	BAT *b;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "bat.setRole", RUNTIME_OBJECT_MISSING);
	}
	if (hname == 0 || *hname == 0 || **hname == 0){
		BBPreleaseref(b->batCacheid);
		throw(MAL, "bat.setRole", ILLEGAL_ARGUMENT " Head name missing");
	}
	if (tname == 0 || *tname == 0 || **tname == 0){
		BBPreleaseref(b->batCacheid);
		throw(MAL, "bat.setRole", ILLEGAL_ARGUMENT " Tail name missing");
	}
	BATroles(b, *hname, *tname);
	BBPreleaseref(b->batCacheid);
	*r = 0;
	return MAL_SUCCEED;
}

str
BKCsetColumn(int *r, int *bid, str *tname)
{
	BAT *b;
	str dummy;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "bat.setColumn", RUNTIME_OBJECT_MISSING);
	}
	if (tname == 0 || *tname == 0 || **tname == 0){
		BBPreleaseref(b->batCacheid);
		throw(MAL, "bat.setColumn", ILLEGAL_ARGUMENT " Column name missing");
	}
	/* watch out, hident is freed first */
	dummy= GDKstrdup(b->hident);
	BATroles(b, dummy, *tname);
	GDKfree(dummy);
	BBPreleaseref(b->batCacheid);
	*r =0;
	return MAL_SUCCEED;
}

str
BKCsetColumns(int *r, int *bid, str *hname, str *tname)
{
	BAT *b;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "bat.setColumns", RUNTIME_OBJECT_MISSING);
	}
	if (hname == 0 || *hname == 0 || **hname == 0){
		BBPreleaseref(b->batCacheid);
		throw(MAL, "bat.setRole", ILLEGAL_ARGUMENT " Head name missing");
	}
	if (tname == 0 || *tname == 0 || **tname == 0){
		BBPreleaseref(b->batCacheid);
		throw(MAL, "bat.setRole", ILLEGAL_ARGUMENT " Tail name missing");
	}
	BATroles(b, *hname, *tname);
	BBPreleaseref(b->batCacheid);
	*r =0;
	return MAL_SUCCEED;
}


str
BKCsetName(int *r, int *bid, str *s)
{
	BAT *b;
	bit res, *rp = &res;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "bat.setName", RUNTIME_OBJECT_MISSING);
	}
	CMDrename(rp, b, *s);
	BBPreleaseref(b->batCacheid);
	*r = 0;
	return MAL_SUCCEED;
}

str
BKCgetBBPname(str *ret, int *bid)
{
	BAT *b;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "bat.getName", RUNTIME_OBJECT_MISSING);
	}
	*ret = GDKstrdup(BBPname(b->batCacheid));
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}

str
BKCunload(bit *res, str *input)
{
	CMDunload(res, *input);
	return MAL_SUCCEED;
}

str
BKCisCached(bit *res, int *bid)
{
	BAT *b;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "bat.isCached", RUNTIME_OBJECT_MISSING);
	}
	*res = 0;
	BBPreleaseref(b->batCacheid);
	throw(MAL, "bat.isCached", PROGRAM_NYI);
}

str
BKCload(int *res, str *input)
{
	bat bid = BBPindex(*input);

	*res = bid;
	if (bid) {
		BBPincref(bid,TRUE);
		return MAL_SUCCEED;
	}
	throw(MAL, "bat.unload", ILLEGAL_ARGUMENT " File name missing");
}

str
BKChot(int *res, str *input)
{
	(void) res;		/* fool compiler */
	BBPhot(BBPindex(*input));
	return MAL_SUCCEED;
}

str
BKCcold(int *res, str *input)
{
	(void) res;		/* fool compiler */
	BBPcold(BBPindex(*input));
	return MAL_SUCCEED;
}

str
BKCcoldBAT(int *res, int *bid)
{
	BAT *b;

	(void) res;
	(void) bid;		/* fool compiler */
	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "bat.isCached", RUNTIME_OBJECT_MISSING);
	}
	BBPcold(b->batCacheid);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}

str
BKCheat(int *res, str *input)
{
	int bid = BBPindex(*input);

	if (bid) {
		*res = BBP_lastused(bid) & 0x7fffffff;
	}
	throw(MAL, "bat", PROGRAM_NYI);
}

str
BKChotBAT(int *res, int *bid)
{
	BAT *b;

	(void) res;
	(void) bid;		/* fool compiler */
	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "bat.isCached", RUNTIME_OBJECT_MISSING);
	}
	BBPhot(b->batCacheid);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}

str
BKCsave(bit *res, str *input)
{
	CMDsave(res, *input);
	return MAL_SUCCEED;
}

str
BKCsave2(int *r, int *bid)
{
	BAT *b;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "bat.save", RUNTIME_OBJECT_MISSING);
	}

	if (b && BATdirty(b))
		BBPsave(b);
	BBPreleaseref(b->batCacheid);
	*r = 0;
	return MAL_SUCCEED;
}

@c
str
BKCmmap(bit *res, int *bid, int *hbns, int *tbns, int *hhp, int *thp)
{
	BAT *b, *bn = NULL;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "bat.mmap", RUNTIME_OBJECT_MISSING);
	}
	if (CMDmmap(&bn, b, hbns, tbns, hhp, thp) == GDK_SUCCEED) {
		*res = TRUE;
		BBPreleaseref(bn->batCacheid);
		BBPreleaseref(b->batCacheid);
		return MAL_SUCCEED;
	}
	*res =FALSE;
	BBPreleaseref(b->batCacheid);
	throw(MAL, "bat.mmap", GDK_EXCEPTION);
}

str
BKCmmap2(bit *res, int *bid, int *mode)
{
	return BKCmmap(res, bid, mode, mode, mode, mode);
}

str
BKCmadvise(bit *res, int *bid, int *hbns, int *tbns, int *hhp, int *thp)
{
	BAT *b;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "bat.madvice", RUNTIME_OBJECT_MISSING);
	}
	*res = BATmadvise(b, (*hbns == int_nil) ? -1 : *hbns, (*tbns == int_nil) ? -1 : *tbns, (*hhp == int_nil) ? -1 : *hhp, (*thp == int_nil) ? -1 : *thp);
	BBPreleaseref(b->batCacheid);
	if (*res)
		throw(MAL, "bat.madvise", GDK_EXCEPTION);
	return MAL_SUCCEED;
}

str
BKCmadvise2(bit *res, int *bid, int *mode)
{
	return BKCmadvise(res, bid, mode, mode, mode, mode);
}

@+ Accelerator Control
@c
str
BKCaccbuild(int *ret, int *bid, str *acc, ptr *param)
{
	(void) bid;
	(void) acc;
	(void) param;
	*ret = TRUE;
	throw(MAL, "Accelerator", PROGRAM_NYI);
}

str
BKCaccbuild_std(int *ret, int *bid, int *acc)
{
	(void) bid;
	(void) acc;
	*ret = TRUE;
	throw(MAL, "Accelerator", PROGRAM_NYI);
}


str
BKCsetHash(bit *ret, int *bid, bit *prop)
{
	BAT *b;

	(void) ret;
	(void) prop;		/* fool compiler */
	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "bat.setHash", RUNTIME_OBJECT_MISSING);
	}
	BAThash(b, 0);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}

str
BKCsetSequenceBase(int *r, int *bid, oid *o)
{
	BAT *b;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "bat.setSequenceBase", RUNTIME_OBJECT_MISSING);
	}
	BATseqbase(b, *o);
	*r = b->batCacheid;
	BBPkeepref(b->batCacheid);
	return MAL_SUCCEED;
}

str
BKCsetSequenceBaseNil(int *r, int *bid, oid *o)
{
	oid ov = oid_nil;

	(void) o;
	return BKCsetSequenceBase(r, bid, &ov);
}

str
BKCgetSequenceBase(oid *r, int *bid)
{
	BAT *b;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "bat.setSequenceBase", RUNTIME_OBJECT_MISSING);
	}
	*r = b->hseqbase;
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}

@-
Shrinking a void-headed BAT using a list of oids to ignore. 
@= shrinkloop
{
	@1 *p = (@1*)Tloc(b, BUNfirst(b));
	@1 *q = (@1*)Tloc(b, BUNlast(b));
	@1 *r = (@1*)Tloc(bn, BUNfirst(bn));

	cnt=0;
	for (;p<q; oidx++, p++) {
		if ( o < ol && *o == oidx ){
			o++;
		} else {
			cnt++;
			*r++ = *p;
		}
	}
}
@c
str
BKCshrinkBAT(int *ret, int *bid, int *did)
{
	BAT *b, *d, *bn, *bs;
	BUN cnt =0;
	oid oidx = 0, *o, *ol;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "bat.shrink", RUNTIME_OBJECT_MISSING);
	}
	if ( b->htype != TYPE_void) {
		BBPreleaseref(b->batCacheid);
		throw(MAL, "bat.shrink", SEMANTIC_TYPE_MISMATCH);
	}
	if ((d = BATdescriptor(*did)) == NULL) {
		BBPreleaseref(b->batCacheid);
		throw(MAL, "bat.shrink", RUNTIME_OBJECT_MISSING);
	}
	bn= BATnew(b->htype, b->ttype, BATcount(b) - BATcount(d) );
	if (bn == NULL) {
		BBPreleaseref(b->batCacheid);
		BBPreleaseref(d->batCacheid);
		throw(MAL, "bat.shrink", MAL_MALLOC_FAIL );
	}
	BATseqbase(bn, 0);
	bs = BATmirror(BATsort(BATmirror(d)));
	if (bs == NULL) {
		BBPreleaseref(b->batCacheid);
		BBPreleaseref(d->batCacheid);
		BBPreleaseref(bn->batCacheid);
		throw(MAL, "bat.shrink", MAL_MALLOC_FAIL );
	}

    	o = (oid*)Tloc(bs, BUNfirst(bs));
    	ol= (oid*)Tloc(bs, BUNlast(bs));

	BATaccessBegin(d, USE_TAIL, MMAP_SEQUENTIAL);
	BATaccessBegin(b, USE_TAIL, MMAP_SEQUENTIAL);
	switch(ATOMstorage(b->ttype) ){
	case TYPE_chr: @:shrinkloop(chr)@ break;
	case TYPE_bte: @:shrinkloop(bte)@ break;
	case TYPE_sht: @:shrinkloop(sht)@ break;
	case TYPE_int: @:shrinkloop(int)@ break;
	case TYPE_lng: @:shrinkloop(lng)@ break;
	case TYPE_flt: @:shrinkloop(flt)@ break;
	case TYPE_dbl: @:shrinkloop(dbl)@ break;
	case TYPE_oid: @:shrinkloop(oid)@ break;
	default:
		if (ATOMvarsized(bn->ttype)) {
			BUN p = BUNfirst(b);
			BUN q = BUNlast(b);
			BATiter bi = bat_iterator(b);

			cnt=0;
			for (;p<q; oidx++, p++) {
				if ( o < ol && *o == oidx ){
					o++;
				} else {
					BUNappend(bn, BUNtail(bi, p), FALSE);
					cnt++;
				}
			}
		} else {
			switch( b->T->width){
			case 1:@:shrinkloop(bte)@ break;
			case 2:@:shrinkloop(sht)@ break;
			case 4:@:shrinkloop(int)@ break;
			case 8:@:shrinkloop(lng)@ break;
			default:
				throw(MAL, "bat.shrink", "Illegal argument type");
			}
		}
	}
	BATaccessEnd(d, USE_TAIL, MMAP_SEQUENTIAL);
	BATaccessEnd(b, USE_TAIL, MMAP_SEQUENTIAL);

	BATsetcount(bn, cnt);
	bn->tsorted = 0;
	bn->tdense = 0;
	bn->tkey = b->tkey;
	bn->T->nonil = b->T->nonil;
	bn->T->nil = b->T->nil;

	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);

	BBPreleaseref(b->batCacheid);
	BBPreleaseref(d->batCacheid);
	BBPkeepref(*ret= bn->batCacheid);
	return MAL_SUCCEED;
}

str
BKCshrinkBATmap(int *ret, int *bid, int *did)
{
	BAT *b, *d, *bn, *bs;
	oid lim,oidx = 0, *o, *ol;
	oid *r;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "bat.shrinkMap", RUNTIME_OBJECT_MISSING);
	}
	if ( b->htype != TYPE_void) {
		BBPreleaseref(b->batCacheid);
		throw(MAL, "bat.shrinkMap", SEMANTIC_TYPE_MISMATCH);
	}
	if ((d = BATdescriptor(*did)) == NULL) {
		BBPreleaseref(b->batCacheid);
		throw(MAL, "bat.shrinkMap", RUNTIME_OBJECT_MISSING);
	}
	if ( d->htype != TYPE_void) {
		BBPreleaseref(d->batCacheid);
		throw(MAL, "bat.shrinkMap", SEMANTIC_TYPE_MISMATCH);
	}

	bn= BATnew(TYPE_void, TYPE_oid, BATcount(b) );
	if (bn == NULL) {
		BBPreleaseref(b->batCacheid);
		BBPreleaseref(d->batCacheid);
		throw(MAL, "bat.shrinkMap", MAL_MALLOC_FAIL );
	}
	BATseqbase(bn, b->hseqbase);
	bs = BATmirror(BATsort(BATmirror(d)));
	if (bs == NULL) {
		BBPreleaseref(b->batCacheid);
		BBPreleaseref(d->batCacheid);
		BBPreleaseref(bn->batCacheid);
		throw(MAL, "bat.shrinkMap", MAL_MALLOC_FAIL );
	}

    	o = (oid*)Tloc(bs, BUNfirst(bs));
    	ol= (oid*)Tloc(bs, BUNlast(bs));
    	r = (oid*)Tloc(bn, BUNfirst(bn));

	lim = BATcount(b);

    BATaccessBegin(d, USE_TAIL, MMAP_SEQUENTIAL);
	for (;oidx<lim; oidx++) {
		if ( o < ol && *o == oidx ){
			o++;
		} else {
			*r++ = oidx;
		}
	}
    BATaccessEnd(d, USE_TAIL, MMAP_SEQUENTIAL);

    BATsetcount(bn, BATcount(b)-BATcount(d));
    bn->tsorted = 0;
    bn->tdense = 0;

    if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);

	BBPreleaseref(b->batCacheid);
	BBPreleaseref(d->batCacheid);
	BBPkeepref(*ret= bn->batCacheid);
	return MAL_SUCCEED;
}
@-
Shrinking a void-headed BAT using a list of oids to ignore. 
@= reuseloop
{
	@1 *p = (@1*)Tloc(b, BUNfirst(b));
	@1 *q = (@1*)Tloc(b, BUNlast(b));
	@1 *r = (@1*)Tloc(bn, BUNfirst(bn));

	for (;p<q; oidx++, p++) {
		if ( *o == oidx ){
			while ( *ol == bidx && ol>o) {
				bidx--;
				ol--;q--;
			}
			*r++ = *(--q);
			o += (o < ol);
			bidx--;
		} else
			*r++ = *p; 
	}
}
@c
str
BKCreuseBAT(int *ret, int *bid, int *did)
{
	BAT *b, *d, *bn, *bs;
	oid oidx = 0, bidx, *o, *ol;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "bat.reuse", RUNTIME_OBJECT_MISSING);
	}
	if ( b->htype != TYPE_void) {
		BBPreleaseref(b->batCacheid);
		throw(MAL, "bat.reuse", SEMANTIC_TYPE_MISMATCH);
	}
	if ((d = BATdescriptor(*did)) == NULL) {
		BBPreleaseref(b->batCacheid);
		throw(MAL, "bat.reuse", RUNTIME_OBJECT_MISSING);
	}
	bn= BATnew(b->htype, b->ttype, BATcount(b) - BATcount(d) );
	if (bn == NULL) {
		BBPreleaseref(b->batCacheid);
		BBPreleaseref(d->batCacheid);
		throw(MAL, "bat.reuse", MAL_MALLOC_FAIL );
	}
	BATseqbase(bn, b->hseqbase);
	bs = BATmirror(BATsort(BATmirror(d)));
	if (bs == NULL) {
		BBPreleaseref(b->batCacheid);
		BBPreleaseref(d->batCacheid);
		BBPreleaseref(bn->batCacheid);
		throw(MAL, "bat.reuse", MAL_MALLOC_FAIL );
	}

	bidx= BUNlast(b)-1;
    	o = (oid*)Tloc(bs, BUNfirst(bs));
    	ol= (oid*)Tloc(bs, BUNlast(bs))-1;

    BATaccessBegin(d, USE_TAIL, MMAP_SEQUENTIAL);
    BATaccessBegin(b, USE_TAIL, MMAP_SEQUENTIAL);
	switch(ATOMstorage(b->ttype) ){
	case TYPE_chr: @:reuseloop(chr)@ break;
	case TYPE_bte: @:reuseloop(bte)@ break;
	case TYPE_sht: @:reuseloop(sht)@ break;
	case TYPE_int: @:reuseloop(int)@ break;
	case TYPE_lng: @:reuseloop(lng)@ break;
	case TYPE_flt: @:reuseloop(flt)@ break;
	case TYPE_dbl: @:reuseloop(dbl)@ break;
	case TYPE_oid: @:reuseloop(oid)@ break;
	case TYPE_str: /* to be done based on its index width */
	default:
		if (ATOMvarsized(bn->ttype)) {
			BUN p = BUNfirst(b);
			BUN q = BUNlast(b);
			BATiter bi = bat_iterator(b);
		
			for (;p<q; oidx++, p++) {
				if ( *o == oidx ){
					while ( *ol == bidx && ol>o) {
						bidx--;
						ol--;q--;
					}
					BUNappend(bn, BUNtail(bi, --q), FALSE);
					o += (o < ol);
					bidx--;
				} else
					BUNappend(bn, BUNtail(bi, p), FALSE);
			}
		} else {
			switch( b->T->width){
			case 1:@:reuseloop(bte)@ break;
			case 2:@:reuseloop(sht)@ break;
			case 4:@:reuseloop(int)@ break;
			case 8:@:reuseloop(lng)@ break;
			default:
				throw(MAL, "bat.shrink", "Illegal argument type");
			}
		}
	}
    BATaccessEnd(d, USE_TAIL, MMAP_SEQUENTIAL);
    BATaccessEnd(b, USE_TAIL, MMAP_SEQUENTIAL);

    BATsetcount(bn, BATcount(b) - BATcount(d));
    bn->tsorted = 0;
    bn->tdense = 0;
	bn->tkey = b->tkey;

    if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);

	BBPreleaseref(b->batCacheid);
	BBPreleaseref(d->batCacheid);
	BBPkeepref(*ret= bn->batCacheid);
	return MAL_SUCCEED;
}
str
BKCreuseBATmap(int *ret, int *bid, int *did)
{
	BAT *b, *d, *bn, *bs;
	oid bidx, oidx = 0, *o, *ol;
	oid *r;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "bat.shrinkMap", RUNTIME_OBJECT_MISSING);
	}
	if ( b->htype != TYPE_void) {
		BBPreleaseref(b->batCacheid);
		throw(MAL, "bat.shrinkMap", SEMANTIC_TYPE_MISMATCH);
	}
	if ((d = BATdescriptor(*did)) == NULL) {
		BBPreleaseref(b->batCacheid);
		throw(MAL, "bat.shrinkMap", RUNTIME_OBJECT_MISSING);
	}
	bn= BATnew(TYPE_void, TYPE_oid, BATcount(b) );
	if (bn == NULL) {
		BBPreleaseref(b->batCacheid);
		BBPreleaseref(d->batCacheid);
		throw(MAL, "bat.shrinkMap", MAL_MALLOC_FAIL );
	}
	BATseqbase(bn, b->hseqbase);
	bs = BATmirror(BATsort(BATmirror(d)));
	if (bs == NULL) {
		BBPreleaseref(b->batCacheid);
		BBPreleaseref(d->batCacheid);
		BBPreleaseref(bn->batCacheid);
		throw(MAL, "bat.shrinkMap", MAL_MALLOC_FAIL );
	}

	bidx= BUNlast(b)-1;
    o = (oid*)Tloc(d, BUNfirst(d));
    ol= (oid*)Tloc(d, BUNlast(d));
    r = (oid*)Tloc(bn, BUNfirst(bn));

    BATaccessBegin(d, USE_TAIL, MMAP_SEQUENTIAL);
	for (;oidx<bidx; oidx++) {
		if ( *o == oidx ){
			while ( ol > o && *--ol == bidx) {
				bidx--;
			}
			*r++ = bidx;
			o += (o < ol);
			bidx--;
		} else
			*r++ = oidx; 
	}
    BATaccessEnd(d, USE_TAIL, MMAP_SEQUENTIAL);

    BATsetcount(bn, BATcount(b)-BATcount(d));
    bn->tsorted = 0;
    bn->tdense = 0;

    if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);

	BBPreleaseref(b->batCacheid);
	BBPreleaseref(d->batCacheid);
	BBPkeepref(*ret= bn->batCacheid);
	return MAL_SUCCEED;
}

@}
