@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.monetdb.org/Legal/MonetDBLicense

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2011 MonetDB B.V.
All Rights Reserved.
@

@c
/*
 * @f status
 * @a M.L. Kersten, P. Boncz, N.Nes
 * @v 2.0
 * @+ System state information
 * This document introduces a series of bats  and operations that provide access
 * to information stored within the Monet Version 5 internal data structures.
 * In all cases, pseudo BAT operation returns a transient BAT that
 * should be garbage collected after being used.
 *
 * The main performance drain would be to use a pseudo BAT directly to
 * successively access it components. This can be avoided by first assigning
 * the pseudo BAT to a variable.
 */
@mal
module status;

command cpuStatistics():bat[:str,:int] 
address SYScpuStatistics
comment "Global cpu usage information";
command memStatistics():bat[:str,:wrd] 
address SYSmemStatistics
comment "Global memory usage information";
command ioStatistics():bat[:str,:int] 
address SYSioStatistics
comment "Global IO activity information";
command vmStatistics(minsize:lng):bat[:str,:lng] 
address SYSvm_usage
comment "Get a split-up of how much virtual memory blocks are in use";
command memUsage(minsize:lng):bat[:str,:lng] 
address SYSmem_usage
comment "Get a split-up of how much memory blocks are in use";
# @-
# Some explanation of what mem_usage() and vm_usage() display:
# @verbatim
# > m:= status.memUsage(1024:lng); io.print(m);
# #------------------------------#
# # BAT:                 tmp_42  #
# # (str)                (lng)   #
# #------------------------------#
# [ "buns/car_category",  400012 ] 100.000 string offsets
# [ "buns/car_town",      400012 ] idem
# [ "buns/car_class",     400012 ] idem
# [ "tail/car_category",  266244 ] string tail heap
# [ "tail/car_town",      266244 ] idem
# [ "tail/car_class",     266244 ] idem
# [ "_tot/buns",         1322996 ] the three bun heaps
# [ "_tot/tail",          967762 ] the three tail heaps
# [ "_tot/head",           70984 ] negligable
# [ "_tot/bbp",            98866 ] BBP metadata structure
# [ "_tot/mil",           102400 ] MIL interpreter stack space
# [ "_tot/found",        2590144 ] buns+head+tail+bbp+mil
# [ "_tot/malloc_heap",  2956048 ] in malloc heap
# [ "_tot/malloc",       2956048 ] total consumed via malloc
# [ "_tot/valloc",        201266 ] total consumed via virtualalloc
# [ "_tot/mem",          3157314 ] total RAM+swap-file consumption
#
# >
# > v:= status.vmStatistics(1024:lng); io.print(v);
# #------------------------------#
# # BAT:               tmp_42    #
# # (str)              (lng)     #
# #------------------------------#
# [ "_tot/bbp",        50331648  ] 50MB reserved (100KB claimed)
# [ "_tot/mil",        16777216  ] 16MB reserved (100KB claimed)
# [ "_tot/found",      67108864  ] bbp+mil
# [ "_tot/vm",         71244560  ] total address space consumption
# >
# @end verbatim
# @+ MAL runtime status
command batStatistics():bat[:str,:str] 
address SYSgdkEnv
comment "Show distribution of bats by kind";
command getThreads():bat[:int,:str] 
address SYSgdkThread
comment "Produce overview of active threads";

command mem_cursize():lng 
address SYSgetmem_cursize
comment "The amount of physical swapspace in KB that is currently in use";

command mem_maxsize():lng 
address SYSgetmem_maxsize
comment "The maximum usable amount of physical swapspace in KB (target only)";

command mem_maxsize(v:lng):void 
address SYSsetmem_maxsize
comment "Set the maximum usable amount of physical swapspace in KB";

command vm_cursize():lng 
address SYSgetvm_cursize
comment "The amount of logical VM space in KB that is currently in use";

command vm_maxsize():lng 
address SYSgetvm_maxsize
comment "The maximum usable amount of logical VM space in KB (target only)";

command vm_maxsize(v:lng):void 
address SYSsetvm_maxsize
comment "Set the maximum usable amount of physical swapspace in KB";

@h
/*
 * @+ Implementation Code
 */
#ifndef _SYS_H_
#define _SYS_H_

#ifdef WIN32
#if !defined(LIBMAL) && !defined(LIBATOMS) && !defined(LIBKERNEL) && !defined(LIBMAL) && !defined(LIBOPTIMIZER) && !defined(LIBSCHEDULER) && !defined(LIBMONETDB5)
#define status_export extern __declspec(dllimport)
#else
#define status_export extern __declspec(dllexport)
#endif
#else
#define status_export extern
#endif


#endif
/*
 * @-
 */
@include kprelude.mx
@c
#include "monetdb_config.h"
#include "gdk.h"
#include <stdarg.h>
#include <time.h>
#include "mal_exception.h"
#include "status.h"
#ifdef HAVE_UNISTD_H
# include <unistd.h>
#endif

#ifdef HAVE_SYS_TIMES_H
# include <sys/times.h>
#endif

#ifdef HAVE_SYS_RESOURCE_H
# include <sys/resource.h>
#endif

@h
status_export str SYSgetmem_cursize(lng *num);
@c
str
SYSgetmem_cursize(lng *num)
{
	*num = GDKmem_cursize();
	return MAL_SUCCEED;
}

@h
status_export str SYSgetmem_maxsize(lng *num);
@c
str
SYSgetmem_maxsize(lng *num)
{
	*num = GDK_mem_maxsize;
	return MAL_SUCCEED;
}

@h
status_export str SYSsetmem_maxsize(int *ret, lng *num);
@c
str
SYSsetmem_maxsize(int *ret, lng *num)
{
	size_t sze = 0;
	*ret = 0;
	if (*num < 0)
		throw(ILLARG, "status.mem_maxsize", "new size must not be < 0");
#if SIZEOF_SIZE_T == SIZEOF_INT
	{
		lng size_t_max = 2 * (lng)INT_MAX;
		if (*num > size_t_max)
			throw(ILLARG, "status.mem_maxsize", "new size must not be > " LLFMT, size_t_max);
	}
#endif
	if (sze < GDK_mem_bigsize)
		GDK_mem_bigsize = MAX(32768, sze);
	GDK_mem_maxsize = MAX(GDK_mem_bigsize, sze);
	return MAL_SUCCEED;
}

@h
status_export str SYSgetvm_cursize(lng *num);
@c
str
SYSgetvm_cursize(lng *num)
{
	*num = GDKvm_cursize();
	return MAL_SUCCEED;
}

@h
status_export str SYSgetvm_maxsize(lng *num);
@c
str
SYSgetvm_maxsize(lng *num)
{
	*num = GDK_vm_maxsize;
	return MAL_SUCCEED;
}

@h
status_export str SYSsetvm_maxsize(lng *num);
@c
str
SYSsetvm_maxsize(lng *num)
{
	GDK_vm_maxsize = (size_t) *num;
	return MAL_SUCCEED;
}

/*
 * @- Performance
 * To obtain a good impression of the Monet performance we need timing information.
 * The most detailed information is best obtained with the system profiler.
 *
 * However, the direct approach is to enable the user to read the timers maintained
 * internally. This is done with the CPU, IO, MEMORY, and BBP command which
 * displays the elapsed time in seconds, user- and system-cpu time in milliseconds
 * since its last invocation and the amount of space in use.  The process
 * identifier is used to differentiate among the possible processes.
 *
 * Note that in multi threaded mode the routine prints the elapsed
 * time since the beginning of each process.
 */
#ifdef HAVE_TIMES
static time_t clk = 0;
static struct tms state;
#endif

@h
status_export str SYScpuStatistics(int *ret);
@c
str
SYScpuStatistics(int *ret)
{
	int i;
	BAT *b;
#ifdef HAVE_TIMES
	struct tms newst;
# ifndef HZ
	static int HZ;

	if (HZ == 0) {
#  if defined(HAVE_SYSCONF) && defined(_SC_CLK_TCK)
		HZ = sysconf(_SC_CLK_TCK);
#  else
		HZ = CLK_TCK;
#  endif
	}
# endif
#endif

	b = BATnew(TYPE_str, TYPE_int, 32);
	if (b == 0)
		throw(MAL, "status.cpuStatistics", MAL_MALLOC_FAIL);
#ifdef HAVE_TIMES
	if (clk == 0) {
		clk = time(0);
		times(&state);
	}
	times(&newst);
	/* store counters, ignore errors */
	i = (int) (time(0) - clk);
	b = BUNins(b, "elapsed", &i, FALSE);
	i = newst.tms_utime * 1000 / HZ;
	b = BUNins(b, "user", &i, FALSE);
	i = (newst.tms_utime - state.tms_utime) * 1000 / HZ;
	b = BUNins(b, "elapuser", &i, FALSE);
	i = newst.tms_stime * 1000 / HZ;
	b = BUNins(b, "system", &i, FALSE);
	i = (newst.tms_stime - state.tms_stime) * 1000 / HZ;
	b = BUNins(b, "elapsystem", &i, FALSE);

	state = newst;
#else
	i = int_nil;
	b = BUNins(b, "elapsed", &i, FALSE);
	b = BUNins(b, "user", &i, FALSE);
	b = BUNins(b, "elapuser", &i, FALSE);
	b = BUNins(b, "system", &i, FALSE);
	b = BUNins(b, "elapsystem", &i, FALSE);
#endif
	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(gdk,cpu)@
	return MAL_SUCCEED;
}

@h
status_export str SYSmemStatistics(int *ret);
@c
static char *memincr = NULL;
str
SYSmemStatistics(int *ret)
{
	struct Mallinfo m;
	BAT *b;
	wrd i;

	m = MT_mallinfo();

	b = BATnew(TYPE_str, TYPE_wrd, 32);
	if (b == 0)
		throw(MAL, "status.memStatistics", MAL_MALLOC_FAIL);

	/* store counters, ignore errors */
	if (memincr == NULL)
		memincr = MT_heapbase;

	i = (wrd) (MT_heapcur() - memincr);

	memincr = MT_heapcur();
	b = BUNins(b, "memincr", &i, FALSE);
	i = (wrd) m.arena;
	b = BUNins(b, "arena", &i, FALSE);
	i = (wrd) m.ordblks;
	b = BUNins(b, "ordblks", &i, FALSE);
	i = (wrd) m.smblks;
	b = BUNins(b, "smblks", &i, FALSE);
	i = (wrd) m.hblkhd;
	b = BUNins(b, "hblkhd", &i, FALSE);
	i = (wrd) m.hblks;
	b = BUNins(b, "hblks", &i, FALSE);
	i = (wrd) m.usmblks;
	b = BUNins(b, "usmblks", &i, FALSE);
	i = (wrd) m.fsmblks;
	b = BUNins(b, "fsmblks", &i, FALSE);
	i = (wrd) m.uordblks;
	b = BUNins(b, "uordblks", &i, FALSE);
	i = (wrd) m.fordblks;
	b = BUNins(b, "fordblks", &i, FALSE);
	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(gdk,mem)@
	return MAL_SUCCEED;
}

@= heap
	if (@2) {
		sz = HEAP@1size(@3);
		if (sz > *minsize) {
			sprintf(buf, "@4/%s", s);
			BUNins(bn, buf, &sz, FALSE);
		}
		@4 += sz; tot += sz;
	}
@
@c

@h
status_export str SYSmem_usage(int *ret, lng *minsize);
@c
str
SYSmem_usage(int *ret, lng *minsize)
{
	lng hbuns = 0, tbuns = 0, hhsh = 0, thsh = 0, hind = 0, tind = 0, head = 0, tail = 0, tot = 0, n = 0, sz;
	BAT *bn = BATnew(TYPE_str, TYPE_lng, 2 * BBPsize);
	struct Mallinfo m;
	char buf[1024];
	bat i;

	if (bn == NULL)
		throw(MAL, "status.memUsage", MAL_MALLOC_FAIL);
	BBPlock("SYSmem_usage");
	for (i = 1; i < BBPsize; i++) {
		BAT *b = BBP_cache(i);
		str s;

		if (!BBPvalid(i))
			continue;

		s = BBPname(i);
		sz = 0;
		if (BBP[i].cache)
			sz += sizeof(BATstore);
		if (BBP[i].nme[0])
			n += strLen(BBP[i].nme[0]);
		if (BBP[i].nme[1])
			n += strLen(BBP[i].nme[1]);
		if (BBP[i].path)
			n += strLen(BBP[i].path);
		if (b)
			sz += sizeof(BAT);	/* mirror */

		if (sz > *minsize) {
			sprintf(buf, "desc/%s", s);
			BUNins(bn, buf, &sz, FALSE);
		}
		tot += (lng) sz;

		if (b == NULL || isVIEW(b)) {
			continue;
		}
		@:heap(mem,1,&b->H->heap,hbuns)@
		@:heap(mem,1,&b->T->heap,tbuns)@
		@:heap(mem,b->H->hash,b->H->hash->heap,hhsh)@
		@:heap(mem,b->T->hash,b->T->hash->heap,thsh)@
		@:heap(mem,b->H->vheap,b->H->vheap,head)@
		@:heap(mem,b->T->vheap,b->T->vheap,tail)@
	}
	/* totals per category */
	BUNins(bn, "_tot/hbuns", &hbuns, FALSE);
	BUNins(bn, "_tot/tbuns", &tbuns, FALSE);
	BUNins(bn, "_tot/head", &head, FALSE);
	BUNins(bn, "_tot/tail", &tail, FALSE);
	BUNins(bn, "_tot/hhsh", &hhsh, FALSE);
	BUNins(bn, "_tot/thsh", &thsh, FALSE);
	BUNins(bn, "_tot/hind", &hind, FALSE);
	BUNins(bn, "_tot/tind", &tind, FALSE);

	/* special area 1: BBP rec */
	sz = BBPlimit * sizeof(BBPrec) + n;
	BUNins(bn, "_tot/bbp", &sz, FALSE);
	tot += sz;

	/* this concludes all major traceable Monet memory usages */
	tot += sz;
	BUNins(bn, "_tot/found", &tot, FALSE);

	/* now look at what the global statistics report (to see if it coincides) */

	/* how much *used* bytes in heap? */
	m = MT_mallinfo();
	sz = (size_t) m.usmblks + (size_t) m.uordblks + (size_t) m.hblkhd;
	BUNins(bn, "_tot/malloc", &sz, FALSE);

	/* measure actual heap size, includes wasted fragmented space and anon mmap space used by malloc() */
	sz = GDKvm_heapsize();
	BUNins(bn, "_tot/heap", &sz, FALSE);

	tot = GDKmem_cursize();

	/* allocated swap area memory that is not plain malloc() */
	sz = MAX(0, sz - tot);
	BUNins(bn, "_tot/valloc", &sz, FALSE);

	/* swap-area memory is in either GDKvmalloc or heap */
	BUNins(bn, "_tot/swapmem", &tot, FALSE);

	BBPunlock("SYSmem_usage");
	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
	*ret = bn->batCacheid;
	BBPkeepref(bn->batCacheid);
	return MAL_SUCCEED;
}

@h
status_export str SYSvm_usage(int *ret, lng *minsize);
@c
str
SYSvm_usage(int *ret, lng *minsize)
{
	lng hbuns = 0, tbuns = 0, hhsh = 0, thsh = 0, hind = 0, tind = 0, head = 0, tail = 0, tot = 0, sz;
	BAT *bn = BATnew(TYPE_str, TYPE_lng, 2 * BBPsize);
	char buf[1024];
	bat i;

	if (bn == NULL)
		throw(MAL, "status.vmStatistics", MAL_MALLOC_FAIL);
	BBPlock("SYSvm_usage");
	for (i = 1; i < BBPsize; i++) {
		BAT *b;
		str s;

		if (!BBPvalid(i))
			continue;

		s = BBPname(i);
 		b = BBP_cache(i);
		if (b == NULL || isVIEW(b)) {
			continue;
		}
		@:heap(vm,1,&b->H->heap,hbuns)@
		@:heap(vm,1,&b->T->heap,tbuns)@
		@:heap(vm,b->H->hash,b->H->hash->heap,hhsh)@
		@:heap(vm,b->T->hash,b->T->hash->heap,thsh)@
		@:heap(vm,b->H->vheap,b->H->vheap,head)@
		@:heap(vm,b->T->vheap,b->T->vheap,tail)@
	}
	/* totals per category */
	BUNins(bn, "_tot/hbuns", &hbuns, FALSE);
	BUNins(bn, "_tot/tbuns", &tbuns, FALSE);
	BUNins(bn, "_tot/head", &head, FALSE);
	BUNins(bn, "_tot/tail", &tail, FALSE);
	BUNins(bn, "_tot/hhsh", &hhsh, FALSE);
	BUNins(bn, "_tot/thsh", &thsh, FALSE);
	BUNins(bn, "_tot/hind", &hind, FALSE);
	BUNins(bn, "_tot/tind", &tind, FALSE);

	/* special area 1: BBP rec */
	sz = BBPmaxsize * sizeof(BBPrec);
	BUNins(bn, "_tot/bbp", &sz, FALSE);
	tot += sz;


	/* this concludes all major traceable Monet virtual memory usages */
	tot += sz;
	BUNins(bn, "_tot/found", &tot, FALSE);

	/* all VM is either GDKmmap or GDKvmalloc (possibly redirected GDKmalloc), *plus* the heap */
	sz = GDKvm_cursize();
	BUNins(bn, "_tot/vm", &sz, FALSE);

	BBPunlock("SYSvm_usage");
	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
	*ret = bn->batCacheid;
	BBPkeepref(bn->batCacheid);
	return MAL_SUCCEED;
}

@h
/*
 * @-
 * Additional information on the process utilization is given by
 * the ioStatistics command. The following information is obtained.
 *
 * @T
 * \begin{tabular}{| l| l|}\hline
 * maxrss     &the maximum resident set size utilized (in kilobytes).\\
 * minflt     &the number of page faults serviced without any I/O\\
 * 	 &activity; here I/O activity is avoided by "reclaiming" a\\
 *
 * 	 &activity; here I/O activity is avoided by "reclaiming" a\\
 * 	 &page frame from the list of pages awaiting reallocation.\\
 * majflt     &the number of page faults serviced that required I/O\\
 * 	 &activity.\\
 * nswap      &the number of times a process was "swapped" out of main\\
 * 	 &memory\\
 * inblock    &the number of times the file system had to perform input.\\
 * oublock    &the number of times the file system had to perform output.\\
 * nvcsw      &the number of times a context switch resulted due to a\\
 * 	 &process voluntarily giving up the processor before its\\
 * 	 &time slice was completed (usually to await availability of\\
 * 	 &a resource).\\
 * nivcsw     &the number of times a context switch resulted due to a\\
 * 	 &higher priority process becoming runnable or because the\\
 * 	 &current process exceeded its time slice.\\
 * \end{tabular}
 *
 * The resource statistics are collected in a BAT. It can then
 * be queried. A default listing is produced by the command usagecmd.
 * (which should be moved to Monet)
 *
 * The BAT grows. It should be compacted.
 */
status_export str SYSioStatistics(int *ret);
@c
str
SYSioStatistics(int *ret)
{
#ifndef NATIVE_WIN32
	struct rusage ru;
#endif
	int i;
	BAT *b;

#ifndef NATIVE_WIN32
	getrusage(RUSAGE_SELF, &ru);
#endif
	b = BATnew(TYPE_str, TYPE_int, 32);
	if (b == 0)
		throw(MAL, "status.ioStatistics", MAL_MALLOC_FAIL);

#ifndef NATIVE_WIN32
	/* store counters, ignore errors */
	i = ru.ru_maxrss;
	BUNins(b, "maxrss", &i, FALSE);
	i = ru.ru_minflt;
	BUNins(b, "minflt", &i, FALSE);
	i = ru.ru_majflt;
	BUNins(b, "majflt", &i, FALSE);
	i = ru.ru_nswap;
	BUNins(b, "nswap", &i, FALSE);
	i = ru.ru_inblock;
	BUNins(b, "inblock", &i, FALSE);
	i = ru.ru_oublock;
	BUNins(b, "oublock", &i, FALSE);
	i = ru.ru_nvcsw;
	BUNins(b, "nvcsw", &i, FALSE);
	i = ru.ru_nivcsw;
	BUNins(b, "ninvcsw", &i, FALSE);
#else
	i = int_nil;
	BUNins(b, "maxrss", &i, FALSE);
	BUNins(b, "minflt", &i, FALSE);
	BUNins(b, "majflt", &i, FALSE);
	BUNins(b, "nswap", &i, FALSE);
	BUNins(b, "inblock", &i, FALSE);
	BUNins(b, "oublock", &i, FALSE);
	BUNins(b, "nvcsw", &i, FALSE);
	BUNins(b, "ninvcsw", &i, FALSE);
#endif

	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(gdk,io)@
	return MAL_SUCCEED;
}

@h
status_export str SYSgdkEnv(int *ret);
@c
str
SYSgdkEnv(int *ret)
{
	int pbat = 0;
	int pdisk = 0;
	int pheat = 0;
	bat i;
	int tmp = 0, per = 0;
	BAT *b;

	b = BATnew(TYPE_str, TYPE_int, 32);
	if (b == 0)
		throw(MAL, "status.batStatistics", MAL_MALLOC_FAIL);

	for (i = 1; i < BBPsize; i++) {
		if (BBPvalid(i)) {
			pbat++;
			if (BBP_cache(i)) {
				pheat += BBP_lastused(i);
				if (BBP_cache(i)->batPersistence == PERSISTENT)
					per++;
				else
					tmp++;
			} else {
				pdisk++;
			}
		}
	}
	b = BUNins(b, "bats", &pbat, FALSE);
	b = BUNins(b, "tmpbats", &tmp, FALSE);
	b = BUNins(b, "perbats", &per, FALSE);
	b = BUNins(b, "ondisk", &pdisk, FALSE);
	b = BUNins(b, "todisk", &BBPout, FALSE);
	b = BUNins(b, "fromdisk", &BBPin, FALSE);
	if (!(b->batDirty & 2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(gdk,env)@
	return MAL_SUCCEED;
}

@h
status_export str SYSgdkThread(int *ret);
@c
str
SYSgdkThread(int *ret)
{
	BAT *b;
	int i;

	b = BATnew(TYPE_int, TYPE_str, THREADS);
	if (b == 0)
		throw(MAL, "status.getThreads", MAL_MALLOC_FAIL);

	for (i = 0; i < THREADS; i++) {
		if (GDKthreads[i].pid)
			BUNins(b, &GDKthreads[i].tid, GDKthreads[i].name, FALSE);
	}
	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(gdk,thread)@
	return MAL_SUCCEED;
}
