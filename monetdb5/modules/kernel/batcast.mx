@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.monetdb.org/Legal/MonetDBLicense

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2011 MonetDB B.V.
All Rights Reserved.
@

@f batcast
@a M.L. Kersten
@+ BAT Coercion Routines
The coercion routines over BATs can not easily be speed up using
an accumulator approach, because they often require different storage space. 
Nevertheless, the implementation provided here are much faster compared
to the Version 4.* implementation.

The coercion routines are build for speed. They are not protected
against overflow.
@{
@= idempotent
	command batcalc.@1(b:bat[:any_1,:@1]):bat[:any_1,:@1] 
	address CMDconvert_@1;
@= coercion
	command batcalc.@2(b:bat[:any_1,:@1]):bat[:any_1,:@2] 
	address CMDconvert_@1_@2
	comment "Coerce an @1 tail to a bat with @2 tail.";
@mal
	@:idempotent(bit)@
	@:idempotent(chr)@
	@:idempotent(bte)@
	@:idempotent(sht)@
	@:idempotent(int)@
	@:idempotent(oid)@
	@:idempotent(wrd)@
	@:idempotent(lng)@
	@:idempotent(flt)@
	@:idempotent(dbl)@
	@:idempotent(str)@

	@:coercion(bte,oid)@
	@:coercion(bte,sht)@
	@:coercion(bte,int)@
	@:coercion(bte,wrd)@
	@:coercion(bte,lng)@
	@:coercion(bte,flt)@
	@:coercion(bte,dbl)@

	@:coercion(sht,oid)@
	@:coercion(sht,bte)@
	@:coercion(sht,int)@
	@:coercion(sht,wrd)@
	@:coercion(sht,lng)@
	@:coercion(sht,flt)@
	@:coercion(sht,dbl)@

	@:coercion(int,bte)@
	@:coercion(int,sht)@
	@:coercion(int,oid)@
	@:coercion(int,wrd)@
	@:coercion(int,lng)@
	@:coercion(int,flt)@
	@:coercion(int,dbl)@

	@:coercion(wrd,oid)@
	@:coercion(wrd,bte)@
	@:coercion(wrd,sht)@
	@:coercion(wrd,int)@
	@:coercion(wrd,lng)@
	@:coercion(wrd,flt)@
	@:coercion(wrd,dbl)@

	@:coercion(lng,oid)@
	@:coercion(lng,bte)@
	@:coercion(lng,sht)@
	@:coercion(lng,int)@
	@:coercion(lng,wrd)@
	@:coercion(lng,flt)@
	@:coercion(lng,dbl)@

	@:coercion(oid,bte)@
	@:coercion(oid,sht)@
	@:coercion(oid,int)@
	@:coercion(oid,wrd)@
	@:coercion(oid,lng)@
	@:coercion(oid,flt)@
	@:coercion(oid,dbl)@

	@:coercion(flt,bte)@
	@:coercion(flt,sht)@
	@:coercion(flt,int)@
	@:coercion(flt,wrd)@
	@:coercion(flt,lng)@
	@:coercion(flt,dbl)@

	@:coercion(dbl,bte)@
	@:coercion(dbl,sht)@
	@:coercion(dbl,int)@
	@:coercion(dbl,wrd)@
	@:coercion(dbl,lng)@
	@:coercion(dbl,flt)@

	@:coercion(bit,bte)@
	@:coercion(bit,sht)@
	@:coercion(bit,int)@
	@:coercion(bit,wrd)@
	@:coercion(bit,lng)@

	@:coercion(bte,bit)@
	@:coercion(sht,bit)@
	@:coercion(int,bit)@
	@:coercion(wrd,bit)@
	@:coercion(lng,bit)@
	@:coercion(str,bit)@

	@:coercion(str,int)@
@-
@include kprelude.mx
@- Implementation
@h
#include "gdk.h"
#include "math.h"
#include "mal_exception.h"

#ifdef WIN32
#if !defined(LIBMAL) && !defined(LIBATOMS) && !defined(LIBKERNEL) && !defined(LIBMAL) && !defined(LIBOPTIMIZER) && !defined(LIBSCHEDULER) && !defined(LIBMONETDB5)
#define batcast_export extern __declspec(dllimport)
#else
#define batcast_export extern __declspec(dllexport)
#endif
#else
#define batcast_export extern
#endif

@- Implementation of coercions

The different coercion implementations exploit the fact
that many coercions are simply space enlargers.
The others effectively may loose information, which calls
for a more expensive operation based on the conversion
routines in the GDK kernel.

@= Idempotent
batcast_export str CMDconvert_@1(int *ret, int *bid);
str CMDconvert_@1(int *ret, int *bid)
{
	BAT *b, *bn;

	@:getBATdescriptor(bid, b, "batcalc.@1")@
	bn = BATcopy(b, b->htype, b->ttype, 0);
	@:tstBAT("batcalc.@1")@
	BBPkeepref(*ret = bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}
@= wrapup
	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
	BATkey(BATmirror(bn), FALSE);
	bn->tsorted = 0;

	if (b->htype != bn->htype) {
		BAT *r = VIEWcreate(b,bn);

		BBPreleaseref(bn->batCacheid);
		bn = r;
	}
	BBPkeepref(*ret = bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
@-
@= GeneralFixed
batcast_export str CMDconvert_@1_@2(int *ret, int *bid);
str CMDconvert_@1_@2(int *ret, int *bid)
{
	BAT *b,*bn;
	@2 *o;

	@:getBATdescriptor(bid, b, "batcalc.@2")@
	@:voidresultBAT(TYPE_@2,"batcalc.@2")@
	o = (@2*)Tloc(bn,BUNfirst(bn));

	if (b->ttype == TYPE_void) {
		oid t = b->tseqbase;
		BUN i, cnt = BATcount(b);

		for(i=0; i<cnt; i++) 
			*o++ = (@2)t++;
	} else {
		@1 *p = (@1*)Tloc(b, BUNfirst(b));
		@1 *q = (@1*)Tloc(b, BUNlast(b));

		if (b->T->nonil)
			for(; p<q; o++, p++)
				*o = (@2) *p;
		else
			for(; p<q; o++, p++)
				if (*p == @1_nil) {
					*o = @2_nil;
					bn->T->nonil = 0;
				} else
					*o = (@2) *p;

	}
	BATsetcount(bn, BATcount(b));
	@:wrapup@
}
@= GeneralStr
batcast_export str CMDconvert_@1_str(int *ret, int *bid);
str CMDconvert_@1_str(int *ret, int *bid)
{
	BATiter bi;
	BAT *b,*bn;
	BUN p,q,r;

	@:getBATdescriptor(bid, b, "batcalc.@2")@
	@:voidresultBAT(TYPE_str,"batcalc.@2")@
	r= BUNfirst(bn);
	p= BUNfirst(b);
	q= BUNlast(b);
	bi = bat_iterator(b);

	for(; p<q; p++, r++) {
		str dst=0;
		int len=0;
		@1 *v = (@1*)BUNtail(bi,p);

		@1ToStr(&dst,&len, (ptr) v);
		Tputvalue(bn, Tloc(bn,r), dst, 1);
		if (dst) 
			GDKfree(dst);
	}
	BATsetcount(bn, BATcount(b));
bunins_failed:
	@:wrapup@
}

batcast_export str CMDconvert_str_@1(int *ret, int *bid);
str CMDconvert_str_@1(int *ret, int *bid)
{
	BAT *b,*bn;
	BATiter bi;
	BUN p, q, r = 0;
	ptr v = NULL; 
	int len = 0;

	@:getBATdescriptor(bid, b, "batcalc.@1")@
	@:voidresultBAT(TYPE_@1,"batcalc.@1")@
	bi = bat_iterator(b);

	BATaccessBegin(b, USE_TAIL, MMAP_SEQUENTIAL);
	BATloop(b, p, q) {
		ATOMfromstr(TYPE_@1, &v, &len, (char *) BUNtvar(bi, p));
		Tputvalue(bn, Tloc(bn,r), v, 1);
		r++;
	}
	GDKfree(v);
	BATsetcount(bn, BATcount(b));
bunins_failed:
	BATaccessEnd(b, USE_TAIL, MMAP_SEQUENTIAL);
	@:wrapup@
}
@-
The lengthly list of coercions options could have been generated.
@c
#include "monetdb_config.h"
#include "batcast.h"

	@:Idempotent(bit)@
	@:Idempotent(chr)@
	@:Idempotent(bte)@
	@:Idempotent(sht)@
	@:Idempotent(int)@
	@:Idempotent(oid)@
	@:Idempotent(wrd)@
	@:Idempotent(lng)@
	@:Idempotent(flt)@
	@:Idempotent(dbl)@
	@:Idempotent(str)@

	@:GeneralStr(bit)@
	@:GeneralStr(chr)@
	@:GeneralStr(bte)@
	@:GeneralStr(sht)@
	@:GeneralStr(int)@
	@:GeneralStr(lng)@
	@:GeneralStr(flt)@
	@:GeneralStr(dbl)@

@-
The reduction coding is still to be provided.
@= CoercionEnlarge
	@:GeneralFixed(@1,@2)@
@= CoercionReduce
	@:GeneralFixed(@1,@2)@
@-
Write out all combinations to ease subsequent
code fine tuning
@c
	@:CoercionEnlarge(bte,sht)@
	@:CoercionEnlarge(bte,oid)@
	@:CoercionEnlarge(bte,int)@
	@:CoercionEnlarge(bte,wrd)@
	@:CoercionEnlarge(bte,lng)@
	@:CoercionEnlarge(bte,flt)@
	@:CoercionEnlarge(bte,dbl)@

	@:CoercionReduce(sht,bte)@
	@:CoercionEnlarge(sht,oid)@
	@:CoercionEnlarge(sht,int)@
	@:CoercionEnlarge(sht,wrd)@
	@:CoercionEnlarge(sht,lng)@
	@:CoercionEnlarge(sht,flt)@
	@:CoercionEnlarge(sht,dbl)@

	@:CoercionReduce(int,bte)@
	@:CoercionReduce(int,sht)@
	@:CoercionEnlarge(int,oid)@
	@:CoercionEnlarge(int,wrd)@
	@:CoercionEnlarge(int,lng)@
	@:CoercionEnlarge(int,flt)@
	@:CoercionEnlarge(int,dbl)@

	@:CoercionReduce(lng,oid)@
	@:CoercionReduce(lng,bte)@
	@:CoercionReduce(lng,sht)@
	@:CoercionReduce(lng,int)@
	@:CoercionReduce(lng,wrd)@
	@:CoercionEnlarge(lng,flt)@
	@:CoercionEnlarge(lng,dbl)@

	@:CoercionReduce(oid,bte)@
	@:CoercionReduce(oid,sht)@
	@:CoercionReduce(oid,int)@
	@:CoercionEnlarge(oid,wrd)@
	@:CoercionEnlarge(oid,lng)@
	@:CoercionEnlarge(oid,flt)@
	@:CoercionEnlarge(oid,dbl)@

	@:CoercionReduce(wrd,bte)@
	@:CoercionReduce(wrd,sht)@
	@:CoercionReduce(wrd,int)@
	@:CoercionReduce(wrd,oid)@
	@:CoercionEnlarge(wrd,lng)@
	@:CoercionEnlarge(wrd,flt)@
	@:CoercionEnlarge(wrd,dbl)@

	@:CoercionReduce(flt,bte)@
	@:CoercionReduce(flt,sht)@
	@:CoercionReduce(flt,int)@
	@:CoercionReduce(flt,wrd)@
	@:CoercionReduce(flt,lng)@
	@:CoercionEnlarge(flt,dbl)@

	@:CoercionReduce(dbl,bte)@
	@:CoercionReduce(dbl,sht)@
	@:CoercionReduce(dbl,int)@
	@:CoercionReduce(dbl,wrd)@
	@:CoercionReduce(dbl,lng)@
	@:CoercionReduce(dbl,flt)@

	@:CoercionEnlarge(bit,bte)@
	@:CoercionEnlarge(bit,sht)@
	@:CoercionEnlarge(bit,int)@
	@:CoercionEnlarge(bit,wrd)@
	@:CoercionEnlarge(bit,lng)@

	@:CoercionReduce(bte,bit)@
	@:CoercionReduce(sht,bit)@
	@:CoercionReduce(int,bit)@
	@:CoercionReduce(wrd,bit)@
	@:CoercionReduce(lng,bit)@
@}
