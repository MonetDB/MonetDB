@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.monetdb.org/Legal/MonetDBLicense

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2011 MonetDB B.V.
All Rights Reserved.
@

@f aggr_bge_count
@a S. Manegold 
@v 1.0
@+ Aggregates Module

@{

@+ Implementation
These implementations need just one scan and a simple hash-maintained data
structure to compute a group of common aggregates.
@c
#include "monetdb_config.h"
#include <gdk.h>
#include <gdk_scanselect.h>	/* for type-specific HT_bunfastins_nocheck_noinc(), until they're moved to gdk.mx */
#include "aggr.h"
#include "aggr_bge_count.h"
#include "aggr_be_count.h"

@- Result initialization
/*	init_result
	@1:	tail-type:	bte/sht/int/wrd/lng/flt/dbl / any / void
*/
@include aggr_ri.mx

@- Count
@c
/*	aggrX3_count3
		e-void-head	e-oid-head	e-oid-head	e-oid-head
		void-lookup	array-lookup	scan-lookup	hash-lookup

	@1:	0		1		0		0		use cnt-array?
	@2:	0		0		0		1		do BATprepareHash?
	@3:	BUNfndVOID	CHKrange	SCANfndOID	HASHfnd_oid	lookup
	@4:	var		loc		loc		loc		e/bn-head-access

	@5:	"BUNhloc(b,p)" for  (oid) b-head-type,		b-head access
		"&bhsb; bhsb++" for (void) b-head-type

	@6:	BUNtloc(bn,r)	BUNtloc(bn,r)	&cnt[(*(oid*)h)-min]
								*dst: count in-place or in cnt-array ?
*/
@= aggrX3_count3
	ALGODEBUG THRprintf(GDKout, "#aggrX3_count3(@1,@2,@3,@4,@5,@6);\n");
	if (@1 && range > 0) {
		/* create tmp. cnt array */
		cnt = (wrd*) GDKzalloc(range*sizeof(wrd));
		if (cnt == NULL) {
			GDKerror("aggrX3_count3(@1,@2,@3,@4,@5,@6,@6): cnt = GDKzalloc("OIDFMT"*"SZFMT") failed", range, sizeof(wrd));
			BBPreclaim(bn);
			return GDK_FAIL;
		}
	}
	if (@2 && BATprepareHash(bn)) {
		GDKerror("aggrX3_count3(@1,@2,@3,@4,@5,@6,@6): BATprepareHash(bn) failed");
		if (@1 && cnt)
			GDKfree(cnt);
		BBPreclaim(bn);
		return GDK_FAIL;
	}
	/* scan b & g, and increment counts in-place or in cnt-array */
	base = BUNfirst(g);
	gh_offset = (ssize_t) base - (ssize_t) g->hseqbase;
	gt_offset = (ssize_t) g->tseqbase - (ssize_t) g->hseqbase;
	end = base + BATcount(g);
	bhsb = b->hseqbase;
	btt = b->ttype;
	if (*ignore_nils && !b->T->nonil) {
		b_use |= USE_TAIL;
		switch(ATOMstorage(btt)) {
		case TYPE_chr:
			@:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,if (!simple_EQ(BUNtloc(bi,p),bt_nil,chr)))@
		case TYPE_bte:
			@:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,if (!simple_EQ(BUNtloc(bi,p),bt_nil,bte)))@
		case TYPE_sht:
			@:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,if (!simple_EQ(BUNtloc(bi,p),bt_nil,sht)))@
		case TYPE_int:
			@:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,if (!simple_EQ(BUNtloc(bi,p),bt_nil,int)))@
		case TYPE_lng:
			@:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,if (!simple_EQ(BUNtloc(bi,p),bt_nil,lng)))@
		case TYPE_flt:
			@:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,if (!simple_EQ(BUNtloc(bi,p),bt_nil,flt)))@
		case TYPE_dbl:
			@:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,if (!simple_EQ(BUNtloc(bi,p),bt_nil,dbl)))@
		default:
			if (b->tvarsized) {
				@:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,if (!atom_EQ(BUNtvar(bi,p),bt_nil,btt)))@
			} else {
				@:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,if (!atom_EQ(BUNtloc(bi,p),bt_nil,btt)))@
			}
		}
	} else {
		switch(ATOMstorage(btt)) {
		case TYPE_chr:
			@:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,)@
		case TYPE_bte:
			@:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,)@
		case TYPE_sht:
			@:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,)@
		case TYPE_int:
			@:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,)@
		case TYPE_lng:
			@:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,)@
		case TYPE_flt:
			@:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,)@
		case TYPE_dbl:
			@:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,)@
		default:
			if (b->tvarsized) {
				@:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,)@
			} else {
				@:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,)@
			}
		}
	}
	if (@1 && cnt) {
		/* copy cnt array to final result */
		BATaccessBegin(bn,USE_HEAD|USE_TAIL,MMAP_SEQUENTIAL);
		BATloop(bn, p, q) {
			oid h = (*(oid*) BUNh@4(bni,p)) - min;
			*(wrd*)BUNtloc(bni, p) = cnt[h];
		}
		BATaccessEnd(bn,USE_HEAD|USE_TAIL,MMAP_SEQUENTIAL);
		GDKfree(cnt);
	}
@c
/*	aggrX3_count3_loop
	@7:	if (!atom_EQ(BUNt{loc,var}(b,p),bt_nil,btt))		b-tail nil check
		if (!simple_EQ(BUNtloc(b,p),bt_nil,{chr,bte,sht,int,flt,lng,dbl}))
*/
@= aggrX3_count3_loop
	if (BATtdense(g)) {
		@:aggrX3_count3_loop_body(@1,@2,@3,@4,@5,@6,@7,oid hh = (oid) (gt_offset + v); oid *h = &hh)@
	} else {
		BATaccessBegin(g,USE_TAIL,MMAP_SEQUENTIAL);
		@:aggrX3_count3_loop_body(@1,@2,@3,@4,@5,@6,@7,oid *h = (oid*) Tloc(g, w))@
		BATaccessEnd(g,USE_TAIL,MMAP_SEQUENTIAL);
	}
	break;
@c
/*	aggrX3_count3_loop_body
	@8:	oid hh = (oid) (gt_offset + v); oid *h = &hh		g tail value calculation
		oid *h = (oid*) Tloc(g, w)				g tail value lookup
*/
@= aggrX3_count3_loop_body
	ALGODEBUG THRprintf(GDKout, "#aggrX3_count3_loop_body(@1,@2,@3,@4,@5,@6,@7,@8);\n");
	if (!(@1 && cnt))
		BATaccessBegin(bn,USE_HEAD|USE_HHASH|USE_TAIL,BATtordered(g)&BAThordered(e)&1?MMAP_SEQUENTIAL:MMAP_WILLNEED);
	if (b_use)
		BATaccessBegin(b,b_use,MMAP_SEQUENTIAL);
	BATloop(b, p, q) {
		oid v = *(oid*) @5;

		w = (BUN) (gh_offset + v);
		if (w >= base && w < end) {
			@7 {
				@8;

				@3(r, bni, h);
				if (r != BUN_NONE) {
					wrd *dst = (wrd*) @6;
					(*dst)++;
				}
			}
		}
	}
	if (b_use)
		BATaccessEnd(b,b_use,MMAP_SEQUENTIAL);
	if (!(@1 && cnt))
		BATaccessEnd(bn,USE_HEAD|USE_HHASH|USE_TAIL,BATtordered(g)&BAThordered(e)&1?MMAP_SEQUENTIAL:MMAP_WILLNEED);
@h
int
CMDaggrX3_count3(BAT **ret, BAT *b, BAT *g, BAT *e, bit *ignore_nils);
@c
int
CMDaggrX3_count3(BAT **ret, BAT *b, BAT *g, BAT *e, bit *ignore_nils)
{
	BATiter bni, bi = bat_iterator(b);
	BAT *bn;
	wrd zero = 0, *cnt = NULL;
	BUN p, q, r;
	oid range;
	oid min, max;
	oid bhsb;
	BUN base, end, w;
	ssize_t gh_offset, gt_offset;
	int b_use = 0;
	int btt;
	ptr bt_nil = ATOMnilptr(b->ttype);

	ALGODEBUG THRprintf(GDKout, "#CMDaggrX3_count3(b=%s,g=%s,e=%s);\n", 
		BATgetId(b),BATgetId(g),BATgetId(e));

/*	ERRORcheck((BATcount(b)!=BATcount(g)), "CMDaggrX3_count3: BATs b & g must be of equal size.\n");	*/
	ERRORcheck((g->htype == TYPE_void) && (g->hseqbase == oid_nil) && (BATcount(g) > 0), "CMDaggrX3_count3: head of BAT g must not be nil.\n");

	if ((g->hseqbase == oid_nil) || (!BAThdense(g)) || (!(BAThordered(b) & 1)) || (!g->hkey)) {
		BAT *gb = BATjoin(BATmirror(g), b, BUN_NONE);
		int rtrn = CMDaggrX3_count(ret, gb, e, ignore_nils);
		BBPunfix(gb->batCacheid);
		return rtrn;
	}

	if (BAThdense(e) && 
	    BAThdense(b) && 
	    BAThdense(g) && 
	    BATtdense(g) &&
	    BATcount(b) == BATcount(e) &&
	    (!ignore_nils || b->T->nonil)) {
		/* simply return counts with one */
		wrd one = 1;
		bn = BATconst(b, TYPE_wrd, &one);
		*ret = bn;
		return GDK_SUCCEED;
	}
 	bn = BATnew(TYPE_void, TYPE_wrd, BATcount(e));
	if( bn == NULL) {
		GDKerror("CMDaggrX3_count3(): BATnew() failed");
		return GDK_FAIL;
	}

	/* init: set all counts to zero and calculate min/max oid */
	@:init_result(wrd)@
	bni = bat_iterator(bn);
	bn->T->nonil = 1;
	range = max - min + 1;

	if (!BAThdense(b))
		b_use |= USE_HEAD;
	/* scan b & g, and calculate counts */
	if (e->htype == TYPE_void) {
		/* void lookup */
		if (BAThdense(b)) {
			@:aggrX3_count3(0,0,BUNfndVOID,var,&bhsb;bhsb++,BUNtloc(bni,r))@
		} else {
			@:aggrX3_count3(0,0,BUNfndVOID,var,BUNhloc(bi,p),BUNtloc(bni,r))@
		}
		/* e->htype == TYPE_oid */
	} else if (range <= SMALL_AGGR_MAX) {
		/* array lookup */
		if (BAThdense(b)) {
			@:aggrX3_count3(1,0,CHKrange,loc,&bhsb;bhsb++,&cnt[(*(oid*)h)-min])@
		} else {
			@:aggrX3_count3(1,0,CHKrange,loc,BUNhloc(bi,p),&cnt[(*(oid*)h)-min])@
		}
	} else if (BATcount(e) <= SCAN_AGGR_MAX) {
		/* scan lookup */
		SCAN_aggr_init;
		if (BAThdense(b)) {
			@:aggrX3_count3(0,0,SCANfndOID,loc,&bhsb;bhsb++,BUNtloc(bni,r))@
		} else {
			@:aggrX3_count3(0,0,SCANfndOID,loc,BUNhloc(bi,p),BUNtloc(bni,r))@
		}
	} else if (BATtordered(g)&BAThordered(e)&1) {
		/* merge lookup */
		MERGE_aggr_init;
		if (BAThdense(b)) {
			@:aggrX3_count3(0,0,MERGEfndOID,loc,&bhsb;bhsb++,BUNtloc(bni,r))@
		} else {
			@:aggrX3_count3(0,0,MERGEfndOID,loc,BUNhloc(bi,p),BUNtloc(bni,r))@
		}
	} else {
		/* hash lookup */
		if (BAThdense(b)) {
			@:aggrX3_count3(0,1,HASHfnd_oid,loc,&bhsb;bhsb++,BUNtloc(bni,r))@
		} else {
			@:aggrX3_count3(0,1,HASHfnd_oid,loc,BUNhloc(bi,p),BUNtloc(bni,r))@
		}
	}

	*ret = bn;
	return GDK_SUCCEED;
}

@}
