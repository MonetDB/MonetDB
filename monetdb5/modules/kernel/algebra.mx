@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2011 MonetDB B.V.
All Rights Reserved.
@

@f algebra
@a Peter Boncz, Martin Kersten, Niels Nes
@v 2.0
@+ BAT Algebra
This modules contains the most common algebraic BAT manipulation
commands. We call them @#algebra@, because all operations take
values as parameters, and produce new result values, but
@%do not modify their parameters@.
@
Unlike the previous Monet versions, we reduce the number
of functions returning a BAT reference. This was previously needed
to simplify recursive bat-expression and manage reference counts.
In the current version we return only a BAT identifier when a new
bat is being created.
@-
All parameters to the modules are passed by reference.
In particular, this means that
string values are passed to the module layer as (str *)
and we have to de-reference them before entering the gdk library.
This calls for knowlegde on the underlying BAT typs`s
@{
@= derefStr
{int _tpe= ATOMstorage(@1->@2type);
 if( _tpe >= TYPE_str )
 { if(@3== 0 || *(str*)@3==0) @3 = (str)str_nil;
   else @3 = *(str *)@3;
}}

@
We split between selections that return one value, and selections
that return a BAT.
@+ Value Selections
@mal
module algebra;

command exist(b:bat[:any_1,:any_2], h:any_1):bit 
address ALGexist
comment "Returns whether 'h' occurs as a head value in b.";

command exist(b:bat[:any_1,:any_2], h:any_1, t:any_2):bit 
address ALGexistBUN
comment "Returns true when 'h,t' occurs as a bun in b.";

command find(b:bat[:any_1,:any_2], h:any_1):any_2 
address ALGfind
comment "Returns the tail value 't' for which some [h,t] BUN 
	exists in b.  If no such BUN exists, an error occurs." ;

command position(b:bat[:any_1,:any_2], v:any_1):wrd
address ALGposition
comment "Returns BAT position [0.. b.count] of 'v' in the head 
	column of b. It Return an error if 'v' does not exist.";

command position(b:bat[:any_1,:any_2], val:any_1, tval:any_2) :wrd 
address ALGpositionBUN
comment "Returns the position of the value pair It returns an 
	error if 'val' does not exist.";

command fetch(b:bat[:any_2,:any_1], x:oid) :any_1 
address ALGfetchoid;
command fetch(b:bat[:any_2,:any_1], x:lng) :any_1 
address ALGfetch;
command fetch(b:bat[:any_2,:any_1], x:int) :any_1 
address ALGfetchint
comment "Returns the tail value of the BUN at x-th position 
	with 0 <= x < b.count";

@+ BAT Selections
The operations are grouped by positional and range selections.
A simple sampling operation is also provided.
@- Positional selection
@mal
command fetch(b:bat[:any_1,:any_2], s:bat[:int,:any_3]) :bat[:any_1,:any_2] 
address ALGfetchbat;
command fetch(b:bat[:any_1,:any_2], s:bat[:lng,:any_3] ) :bat[:any_1,:any_2] 
address ALGfetchbat;
command fetch(b:bat[:any_1,:any_2], s:bat[:oid,:any_3]) :bat[:any_1,:any_2] 
address ALGfetchbat
comment "Returns a positional selection of b by the oid 
	head values of s";

@- Range selection
The range selections are targeted at the tail of the BAT.
@mal
command select(b:bat[:any_1,:any_2], low:any_2, high:any_2) 
		:bat[:any_1,:any_2] 
address ALGselect
comment "Select all BUNs that have tail values: {v| low <= v <= high}.
	NIL boundary values have a special meaning.
		+ low  == nil means: no lower bound
		+ high == nil means: no upper bound.
		NOTE 1: you should cast the nil to the appropriate type, 
				e.g. int(nil) in order to cirumvent type clashes.
		NOTE 2: as the 'nil' element has no clear place in the 
				ordered domain of values, tuples with 'nil' values 
				are NEVER returned by the range select.";

command thetaselect(b:bat[:any_1,:any_2], val:any_2, op:str) :bat[:any_1,:any_2]
address ALGthetaselect
comment "The theta (<=,<,=,>,>=) select()";

command select(b:bat[:any_1,:any_2], low:any_2, 
	high:any_2, li:bit, hi:bit) :bat[:any_1,:any_2] 
address ALGselectInclusive
comment "Select all BUNs that have tail values: {v| low <{=} v <{=} high}.
	Boundary inclusion is indicated separately.
	NIL boundary values have a special meaning.
	+ low  == nil means: no lower bound
	+ high == nil means: no upper bound.";

command select(b:bat[:any_1,:any_2],value:any_2) :bat[:any_1,:any_2] 
address ALGselect1
comment "Select all BUNs of a BAT with a certain 
	tail value. Selection on NIL is also 
	possible (it should be properly casted, 
	e.g.:int(nil)).";

command selectNotNil(b:bat[:any_1,:any_2]):bat[:any_1,:any_2]
address ALGselectNotNil
comment "Select all not-nil values";
@-
The second group uses the head to perform the range selection.
@mal
command selectH(b:bat[:any_1,:any_2], low:any_1, high:any_1) 
			:bat[:any_1,:any_2] 
address ALGselectHead;

command selectH(b:bat[:any_1,:any_2], low:any_1, 
	high:any_1, li:bit, hi:bit) :bat[:any_1,:any_2] 
address ALGselectInclusiveHead;

command selectH(b:bat[:any_1,:any_2],value:any_1) :bat[:any_1,:any_2] 
address ALGselect1Head;
@-
A special case for this set are the void tailed bats.
@mal
command select(b:bat[:any_2,:void], low:any_2) 
		:bat[:any_2,:void] 
address ALGselect1Head;

command select(b:bat[:any_2,:void], low:any_2, high:any_2) 
		:bat[:any_2,:void] 
address ALGselectHead;
command select(b:bat[:any_2,:void], low:any_2, high:any_2,li:bit, hi:bit) 
		:bat[:any_2,:void] 
address ALGselectInclusiveHead;

@-
The second group uses the head to perform the range selection
@mal

command fragment ( b:bat[:any_1,:any_2], hlow:any_1, hhigh:any_1,
		tlow:any_2, thigh:any_2 ) :bat[:any_1,:any_2] 
address ALGfragment
comment "Select both on head and tail range.";

command slice(b:bat[:any_1,:any_2], x:lng, y:lng) :bat[:any_1,:any_2] 
address ALGslice
comment "Return the slice with the BUNs at position x till y.";

command slice(b:bat[:any_1,:any_2], x:int, y:int) :bat[:any_1,:any_2] 
address ALGslice_int
comment "Return the slice with the BUNs at position x till y.";

command slice(b:bat[:any_1,:any_2], x:wrd, y:wrd) :bat[:any_1,:any_2] 
address ALGslice_wrd
comment "Return the slice with the BUNs at position x till y.";

command topN( b:bat[:any_1,:any_2], top:lng ) :bat[:any_1,:any_2]
address ALGtopN
comment "Trim all but the top N tuples.";

command groupby(b:bat[:any_1,:wrd]) :bat[:any_1,:oid] 
address ALGgroupby
comment "Produces a new BAT with groups identified by the head column. The result contains tail times the head value, ie the tail contains the result group sizes.";

command uselect(b:bat[:any_1,:any_2], low:any_2, high:any_2, 
		li:bit, hi:bit) :bat[:any_1,:void] 
address ALGuselectInclusive
comment "See select() but limited to head values";

command thetauselect(b:bat[:any_1,:any_2], val:any_2, op:str) :bat[:any_1,:void] 
address ALGthetauselect
comment "The theta (<=,<,=,>,>=) select() limited to head values";

command uselect(b:bat[:any_1,:any_2], low:any_2, high:any_2):bat[:any_1,:void] 
address ALGuselect;
command uselect(b:bat[:any_1,:any_2], value:any_2) :bat[:any_1,:void] 
address ALGuselect1
comment "Value select, but returning only the 
	head values. SEE ALSO:select(bat,val)";

command antiuselect(b:bat[:any_1,:any_2], value:any_2) :bat[:any_1,:void] 
address ALGantiuselect1
comment "Value select, but returning only the 
	head values. SEE ALSO:select(bat,val)";

command antiuselect(b:bat[:any_1,:any_2], low:any_2, high:any_2, 
		li:bit, hi:bit) :bat[:any_1,:void] 
address ALGantiuselectInclusive
comment "See select() but limited to head values";
@- Pattern matching
@mal
command like(b:bat[:any_1,:str], substr:str) :bat[:any_1,:str]
address ALGlike
comment "Selects all elements that have 'substr' as in the tail.";

@- Sampling
@mal
command sample ( b:bat[:oid,:any_2], num:int ) :bat[:oid,:any_2] 
address ALGsample
comment "Produce a random selection of size 'num' from the input BAT.";
@+ BAT copying
@mal
command copy( b:bat[:any_1,:any_2]) :bat[:any_1,:any_2] 
address ALGcopy
comment "Returns physical copy of a BAT.";
@- Sorted copy
@mal
command sort( b:bat[:any_1,:any_2]) :bat[:any_1,:any_2] 
address ALGhsort
comment "Returns a BAT copy sorted on the head column.";
command sortReverse( b:bat[:any_1,:any_2]) :bat[:any_1,:any_2] 
address ALGhsort_rev
comment "Returns a BAT copy reversely sorted on the tail column.";

command sortTail( b:bat[:any_1,:any_2]) :bat[:any_1,:any_2] 
address ALGtsort
comment "Returns a BAT copy sorted on the tail column.";
command sortReverseTail( b:bat[:any_1,:any_2]) :bat[:any_1,:any_2] 
address ALGtsort_rev
comment "Returns a BAT copy reversely sorted on the tail column.";

command sortHT( b:bat[:any_1,:any_2]) :bat[:any_1,:any_2] 
address ALGhtsort
comment "Returns a lexicographically sorted copy on head,tail.";
command sortTH( b:bat[:any_1,:any_2]) :bat[:any_1,:any_2] 
address ALGthsort
comment "Returns a lexicographically sorted copy on tail,head.";

command ssort( b:bat[:any_1,:any_2]) :bat[:any_1,:any_2]
address ALGssort
comment "Returns copy of a BAT with the BUNs sorted on ascending head values.
         This is a stable sort.";
command ssort_rev( b:bat[:any_1,:any_2]) :bat[:any_1,:any_2]
address ALGssort_rev
comment "Returns copy of a BAT with the BUNs sorted on descending head values.
         This is a stable sort.";

command revert( b:bat[:any_1,:any_2]) :bat[:any_1,:any_2]
address ALGrevert
comment "Returns a BAT copy with buns in reverse order";

@+ Set operations
Sets in Monet can be viewed in two ways:
@itemize
@item
by looking at both columns of a BAT together (Set-, or s-operators).
@item
by looking at the head column only (Key- or k-operators).
by looking at the tail column only (Tail key- or t-operators).
@end itemize
For this reason, all standard set operations come in three flavors:
k-@emph{operand} series, which look only at the head column, 
t-@emph{operand} series, which look only at the tail column, and
s-@emph{operand} series, that look at the whole BUN.

@noindent Operands provided are:
@itemize
@item [s,k,t]unique(bat[:any_1,:any_2]) :bat[:any_1,:any_2]
produces a copy of the bat, with double elimination
@item [s,k,t]union(bat[:any_1,:any_2],bat[:any_1,:any_2]) :bat[:any_1,:any_2]
bat union.
@item [s,k,t]difference(bat[:any_1,:any_2],bat[:any_1,:any_2]) :bat[:any_1,:any_2]
bat difference.
@item [s,k,t]intersection(bat[:any_1,:any_2],bat[:any_1,:any_2]) :bat[:any_1,:any_2]
bat intersection.
@end itemize
Implementations typically take two forms: if the input relation(s) is/are
ordered, a merge-algorithm is used. Otherwise, hash-indices are produced
on demand for the hash-based algorithms.
The [k,s]intersect(l,r) operations result in all BUNs of @emph{l} that
are also in @emph{r}. They do not do double-elimination over the @emph{l} BUNs.
The [k,s]difference(l,r) operations result in all BUNs of @emph{l} that are
not in @emph{r}. They do not do double-elimination over the @emph{l} BUNs.
The [k,s]union(l,r) operations result in all BUNs of l, plus all BUNs
of @emph{r} that are not in @emph{l}. They do not do double-elimination
over the @emph{l} nor @emph{r} BUNs.
Operations with double-elimination can be formed by performing
[k,s]unique(l) on their operands.
The kintersect(l,r) is used also as implementation for the
@emph{semijoin()}.

The t-@emph{operand} series are cast into a k-@emph{operand}
expression enclosing it with a BATmirror.
@- Bun-unique elements
@mal
command unique (b:bat[:any_1,:any_2] ) :bat[:any_1,:any_2] 
address ALGsunique;
command sunique (b:bat[:any_1,:any_2] ) :bat[:any_1,:any_2] 
address ALGsunique
comment "Select unique tuples from the input BAT. Double elimination is 
		done over BUNs as a whole (head and tail).  Result is a BAT 
	with real set() semantics.";
@- Head-unique elements
@mal
command kunique ( b:bat[:any_1,:any_2] ) :bat[:any_1,:any_2] 
address ALGkunique
comment "Select unique tuples from the input BAT.  Double elimination is 
		done only looking at the head column. The result is a BAT with
		property hkeyed() == true.";

command tunique (b:bat[:any_1,:any_2] ) :bat[:any_1,:any_2] 
address ALGtunique
comment "Select unique tuples from the input BAT. Double elimination is 
		done over the BUNs tail. The result is a BAT with property
		tkeyd()== true";

@- Bun-intersecting elements
@mal
command intersect ( left:bat[:any_1,:any_2], right:bat[:any_1,:any_2]) 
		:bat[:any_1,:any_2] 
address ALGsintersect;
command sintersect ( left:bat[:any_1,:any_2], right:bat[:any_1,:any_2]) 
		:bat[:any_1,:any_2] 
address ALGsintersect
comment "Returns the intersection taken over *both* columns of two BATs. 
		Results in all BUNs of 'left' that are also in 'right'. Does *not* 
		do double-elimination over the 'left' BUNs, If you want this, use:
	 'sintersect(sunique(left),sunique(right))' 
	or: 'sunique(sintersect(left,right))'.";

@- Head-intersecting elements (a.k.a. semijoin)
@mal
command semijoin( left:bat[:any_1,:any_2], right:bat[:any_1,:any] ) 
		:bat[:any_1,:any_2] 
address ALGsemijoin
comment "Returns the intersection taken over only the *head* columns of 
		two BATs.  Results in all BUNs of 'left' that are also in 'right'. 
		Does *not* do double-elimination over the 'left' BUNs. 
		If you want this, use: 'kintersect(kunique(left),kunique(right))' 
	or: 'kunique(kintersect(left,right))'.";

command kintersect( left:bat[:any_1,:any_2], right:bat[:any_1,:any] ) 
		:bat[:any_1,:any_2] 
address ALGsemijoin
comment "Returns the intersection taken over only the *head* columns of two BATs. 
	Results in all BUNs of 'left' that are also in 'right'. 
		Does *not* do double- elimination over the 'left' BUNs.
		If you want this, use: 'kintersect(kunique(left),kunique(right))' 
	or: 'kunique(kintersect(left,right))'.";
@- Bun-differing elements
@mal
command difference( left:bat[:any_1,:any_2], right:bat[:any_1,:any_2] ) 
		:bat[:any_1,:any_2] 
address ALGsdiff;
command sdifference( left:bat[:any_1,:any_2], right:bat[:any_1,:any_2] ) 
		:bat[:any_1,:any_2] 
address ALGsdiff
comment "Returns the difference taken over *both* columns of two BATs. 
		Results in all BUNs of 'left' that are *not* in 'right'. 
		Does *not* do double-elimination over the 'left' BUNs. 
		If you want this, use:
		 'sdifference(left.sunique,right.sunique)' 
	or: 'sdifference(left,right).sunique'.";
@- Head-differing elements
@mal
command kdifference ( left:bat[:any_1,:any_2], right:bat[:any_1,:any] ) 
		:bat[:any_1,:any_2] 
address ALGkdiff
comment "Returns the difference taken over only the *head* columns of two BATs. 
		Results in all BUNs of 'left' that are *not* in 'right'. 
		It does *not* do double-elimination over the 'left' BUNs. 
		If you want this, use:
	 'kdifference(left.kunique,right.kunique)' 
	or: 'kdifference(left,right).kunique'.";
@- Unions on bun
@mal
command union ( left:bat[:any_1,:any_2], right:bat[:any_1,:any_2]) 
		:bat[:any_1,:any_2] 
address ALGsunion;
command sunion ( left:bat[:any_1,:any_2], right:bat[:any_1,:any_2]) 
		:bat[:any_1,:any_2] 
address ALGsunion
comment "Returns the union of two BATs; looking at both columns of both BATs.
		Results in all BUNs of 'left' that are  not in 'right', plus all 
		BUNs of 'right'.  *no* double-elimination is done. 
		If you want this, do:
	 'sunion(left.sunique,right.sunique)' 
	or: 'sunion(left,right).sunique'.";
@- Union on head
@mal
command kunion ( left:bat[:any_1,:any_2], right:bat[:any_1,:any_2])
		:bat[:any_1,:any_2] 
address ALGkunion
comment "Returns the union of two BATs; looking at head-columns only. 
		Results in all BUNs of 'left' that are  not in 'right', plus 
	all BUNs of 'right'.  *no* double-elimination is done. 
		If you want this, do:
	'kunion(left.kunique,right.kunique)' 
	or: 'sunion(left,right).kunique'.";
@+ Join operations
The core of every relational engine.
The join collection provided by the GDK kernel.
Note that joins over void columns are handled as if they are oids.
@mal
command crossproduct(left:bat[:any_1,:any_2], right:bat[:any_3,:any_4])
	:bat[:any_1,:any_4]
address ALGcross
comment "Returns the cross product";

command antijoin(left:bat[:any_1,:any_2], right:bat[:any_2,:any_4])
	:bat[:any_1,:any_4]
address ALGantijoin
comment "Returns the antijoin";

command join( left:bat[:any_1,:any_2], right:bat[:any_2,:any_3])
		:bat[:any_1,:any_3] 
address ALGjoin
comment "Returns all BUNs, consisting of a head-value from 'left' and 
		a tail-value from 'right' for which there are BUNs in 'left' 
		and 'right' with equal tail- resp. head-value (i.e. the join
	columns are projected out).";

command join( left:bat[:any_1,:any_2], right:bat[:any_2,:any_3])
		:bat[:any_1,:any_3] 
address ALGjoin;
command leftjoin( left:bat[:any_1,:any_2], right:bat[:any_2,:any_3])
		:bat[:any_1,:any_3] 
address ALGleftjoin;

command leftjoin( left:bat[:any_1,:any_2], right:bat[:any_2,:any_3],
		estimate:lng) :bat[:any_1,:any_3] 
address ALGleftjoinestimate;

command join( left:bat[:any_1,:any_2], right:bat[:any_2,:any_3],
		estimate:lng) :bat[:any_1,:any_3] 
address ALGjoinestimate;

command fetchjoin ( left:bat[:any_1,:oid], right:bat[:oid,:any_3] )
		:bat[:any_1,:any_3] 
address ALGfetchjoin
comment "Hook directly into the fetch implementation of the join.";

command leftfetchjoin ( left:bat[:any_1,:oid], right:bat[:oid,:any_3] )
		:bat[:any_1,:any_3] 
address ALGleftfetchjoin
comment "Hook directly into the left fetch join implementation.";

command mergejoin (left:bat[:any_1,:any_2], right:bat[:any_2,:any_3])
		:bat[:any_1,:any_3] 
address ALGmergejoin
comment "Hook directly into the merge implementation of the join.";

command hashjoin ( left:bat[:any_1,:any_2], right:bat[:any_2,:any_3])
		:bat[:any_1,:any_3] 
address ALGhashjoin
comment "Hook directly into the hash implementation of the join.";

command indexjoin ( left:bat[:any_1,:any_2], right:bat[:any_2,:any_3])
		:bat[:any_1,:any_3] 
address ALGindexjoin
comment "Hook directly into the index implementation of the join.";

@- Outer Join
@mal
command outerjoin( outer:bat[:any_1,:any_2], inner:bat[:any_2,:any_3]) 
		:bat[:any_1,:any_3] 
address ALGouterjoin
comment "Returns all the result of a join, plus the BUNS formed NIL in 
		the tail and the head-values of 'outer' whose tail-value does 
		not match an head-value in 'inner'.";
command outerjoin( outer:bat[:any_1,:oid], inner:bat[:oid,:any_3]) 
		:bat[:any_1,:any_3] 
address ALGouterjoin
comment "Returns all the result of a join, plus the BUNS formed NIL in 
		the tail and the head-values of 'outer' whose tail-value does 
		not match an head-value in 'inner'.";
command outerjoin( outer:bat[:any_1,:oid], inner:bat[:oid,:any_3]) 
		:bat[:any_1,:any_3] 
address ALGouterjoin
comment "Returns all the result of a join, plus the BUNS formed NIL in 
		the tail and the head-values of 'outer' whose tail-value does 
		not match an head-value in 'inner'.";

command outerjoin( outer:bat[:any_1,:any_2], inner:bat[:any_2,:any_3],
		estimate:lng) :bat[:any_1,:any_3] 
address ALGouterjoinestimate;

@- Theta Join
@mal
command thetajoin( left:bat[:any_1,:any_2], right:bat[:any_2,:any_3],
		opname:int) :bat[:any_1,:any_3] 
address ALGthetajoin
comment "Theta join on for 'mode' in { LE, LT, EQ, GT, GE }.  JOIN_EQ is 
		just the same as join(). All other options do merge algorithms. 
		Either using the fact that they are ordered() already (left on tail, 
	right on head), or by using/creating binary search trees on the 
		join columns. ";

command thetajoin( left:bat[:any_1,:any_2], right:bat[:any_2,:any_3],
		opname:int,estimate:lng) :bat[:any_1,:any_3] 
address ALGthetajoinEstimate;
@- Band Join (approximate match)
@mal
command bandjoin( outer:bat[:any_1,:any_2], inner:bat[:any_2,:any_3],
		   minus:any_2 , plus:any_2 ) :bat[:any_1,:any_3] 
address ALGbandjoin_default
comment "This is a join() for which the predicate is that two BUNs match 
		if the left-tail value is within the range [right-head - minus, 
		right-head + plus]. Works only for the builtin numerical types, 
		and their derivates.";

command bandjoin( outer:bat[:any_1,:any_2], inner:bat[:any_2,:any_3],
		   minus:any_2 , plus:any_2, li:bit, hi:bit ) :bat[:any_1,:any_3] 
address ALGbandjoin
comment "This is a join() for which the predicate is that two BUNs match 
		if the left-tail value is within the range [right-head - minus, 
		right-head + plus], depending on (l_in/h_in), the bounds 
		are included. Works only for the builtin numerical types, 
		and their derivates.";

command join(l:bat[:any_1,:any_2], rl:bat[:any_3,:any_2], rh:bat[:any_3,:any_2], li:bit, hi:bit) :bat[:any_1,:any_3] 
address ALGrangejoin;

@+ Projection operations
@mal
command project(b:bat[:any_1,:any_2]) :bat[:any_1,:void]
address ALGprojectNIL
comment "Extract the head of a BAT.";

@= projectGrp
command project(v:@1,b:bat[:any_2,:any_1]) :bat[:@1,:any_1] 
address ALGprojecthead_@1
comment "Fill the head with a constant, e.g. [0~b]";
command project(b:bat[:any_2,:any_1],v:@1) :bat[:any_2,:@1] 
address ALGprojecttail_@1
comment "Fill the tail with a constant, e.g. [0~b]";
@mal
	@:projectGrp(bit)@
	@:projectGrp(chr)@
	@:projectGrp(str)@
	@:projectGrp(oid)@
	@:projectGrp(int)@
	@:projectGrp(sht)@
	@:projectGrp(lng)@
	@:projectGrp(flt)@
	@:projectGrp(dbl)@
@+ OID Introducing Commands
For relational processing, some operators are necessary to produce newly
initiated OID columns, for representing n-ary (intermediary) relations.

@mal
command markT( b:bat[:any_1,:any_2], base:oid ) :bat[:any_1,:oid] 
address ALGtmark
comment "Produces a BAT with fresh unique dense sequense of OIDs in 
		the tail that starts at base (i.e. [base,..base+b.count()-1] ).";

command markT( b:bat[:any_1,:any_2] ) :bat[:any_1,:oid] 
address ALGtmark_default
comment "Produces a BAT with fresh unique OIDs in the tail starting at 0@0.";

command markT( b:bat[:any_1,:any_2], nr_parts:int, part_nr:int ) :bat[:any_1,:oid] 
address ALGtmarkp
comment "Produces a BAT with fresh unique dense sequense of OIDs in 
	the tail that starts at base (i.e. [base,..base+b.count()-1] ).
	The base is uniquely defined by the part_nr (ie we set the highest
	bits based on the part_nr/nr_parts) ";


command markH( b:bat[:any_1,:any_2] ) :bat[:oid,:any_2] 
address ALGmarkHead_default
comment "Produces a BAT with fresh OIDs in the head starting at 0@0.";

command markH( b:bat[:any_1,:any_2], base:oid ) :bat[:oid,:any_2] 
address ALGmarkHead
comment "Produces a new BAT with fresh unique dense sequense of OIDs in 
		the head that starts at base (i.e. [base,..base+b.count()-1] ).";

command markH( b:bat[:any_1,:any_2], nr_parts:int, part_nr:int ) :bat[:any_1,:oid] 
address ALGhmarkp
comment "Produces a BAT with fresh unique dense sequense of OIDs in 
	the head that starts at base (i.e. [base,..base+b.count()-1] ).
	The base is uniquely defined by the part_nr (ie we set the highest
	bits based on the part_nr/nr_parts) ";


command mark_grp( b:bat[:any_1,:oid], g:bat[:oid,:oid]) :bat[:any_1,:oid]
address ALGmark_grp_1
comment "\"grouped mark\": Produces a new BAT with per group a locally unique dense
 ascending sequence of OIDs in the tail. The tail of the first BAT (b)
 identifies the group that each BUN of b belongs to. The second BAT (g)
 represents the group extent, i.e., the head is the unique list of group IDs
 from b's tail. The tail of g gives for each group the base value for the new
 OID sequence.";

command mark_grp(b:bat[:any_1,:oid], g:bat[:oid,:any_2], s:oid) :bat[:any_1,:oid]
address ALGmark_grp_2
comment "\"grouped mark\": Produces a new BAT with per group a locally unique dense
 ascending sequense of OIDs in the tail. The tail of the first BAT (b)
 identifies the group that each BUN of b belongs to. The second BAT (g)
 represents the group extent, i.e., the head is the unique list of group IDs
 from b's tail. The third argument (s) gives the base value for the new
 OID sequence of each group.";

command number( b:bat[:any_1,:any] ) :bat[:any_1,:int]  
address ALGnumber
comment "Produces a new BAT with identical head column, and consecutively 
		increasing integers (start at 0) in the tail column.";

command merge(b:bat[:oid,:oid]):bat[:lng,:oid]
address ALGmerge
comment "Merge head and tail into a single value";

command split(b:bat[:lng,:oid]):bat[:oid,:oid]
address ALGsplit
comment "Split head into two values";

@+ BAT fragmentation commands
Various operations for splitting BATs into useful fragments.

@- Variable management
It is sometimes needed to cast a type at runtime
@mal
command materialize(b:bat[:oid,:any_1]):bat[:oid,:any_1]
address ALGmaterialize
comment "Materialize the void column";

command reuse(b:bat[:any_1,:any_2]):bat[:any_1,:any_2]
address ALGreuse
comment "Reuse a temporary BAT if you can. Otherwise,
	allocate enough storage to accept result of an
 	operation (not involving the heap)";

@- Hash Split
The commands below is temporarilly postponed, because
we don;t handle nested bats
@mal
command hashsplit( b:bat[:any_1,:any_2], buckects:int ) 
		:bat[:int,:bat] 
address ALGhashsplit
comment "Split a BAT on tail column according (hash-value MOD buckets). 
		Returns a recursive BAT, containing the fragments in the tail, 
		their bucket number in the head.";

command uhashsplit ( b:bat[:any_1,:any_2], buckets:int ) :bat[:int,:bat] 
address ALGuhashsplit
comment "Same as hashsplit, but only collect the head values in the fragments";
@- Range Split
@mal
command rangesplit ( b:bat[:any_1,:any_2], ranges:int ) 
		:bat[:any_2,:bat] 
address ALGrangesplit
comment "Split a BAT on tail column in 'ranges' equally sized consecutive 
		ranges. Returns a recursive BAT, containing the fragments in the tail, 
		the higher-bound of the range in the head. The higher bound of the last 
	range is 'nil'.";

command urangesplit( b:bat[:any_1,:any_2], ranges:int ) 
		:bat[:any_2,:bat] 
address ALGurangesplit
comment "Same as rangesplit, but only collect the head values in the fragments" ;

@+ Common BAT Aggregates
These operations examine a BAT, and compute some simple aggregate result
over it.
@- BAT size
@mal
module aggr;

command count( b:bat[:any_1,:any] ) :wrd 
address ALGcount_bat
comment "Return the current size (in number of elements) in a BAT.";
command count ( b:bat[:any_1,:any], ignore_nils:bit ) :wrd 
address ALGcount_nil
comment "Return the number of elements currently in a BAT ignores 
		BUNs with nil-tail iff ignore_nils==TRUE.";
command count_no_nil ( b:bat[:any_1,:any_2]) :wrd
address ALGcount_no_nil
comment "Return the number of elements currently 
	in a BAT ignoring BUNs with nil-tail";
@- Histogram on Tail
@mal
command histogram ( b:bat[:any_1,:any_2]) :bat[:any_2,:int] 
address ALGhistogram
comment "Produce a BAT containing the histogram over the tail values.";

@- Default Min and Max
Implementations a generic Min and Max routines get declared first. The
@emph{min()} and @emph{max()} routines below catch any tail-type.
The type-specific routines defined later are faster, and will
override these any implementations.
@mal
command cardinality( b:bat[:any_1,:any_2] ) :lng 
address ALGcard
comment "Return the cardinality of the BAT tail values.";
@- 
Implementations a generic Min and Max routines get declared first. The
@emph{ min()} and @emph{ max()} routines below catch any tail-type.
The type-specific routines defined later are faster, and will
override these any implementations.

@- 
@mal
command min(b:bat[:any_1,:any_2]):any_2 
address ALGminany
comment "Return the lowest tail value or nil.";

command max(b:bat[:any_1,:any_2]):any_2 
address ALGmaxany
comment "Return the highest tail value or nil.";
@+ Type-Specific Sum, Prod, Max and Min
For X in @{ bte,sht,int,wrd,flt,dbl,lng @},  we generate the
aggregate functions using a macro.
@-
@mal
@:sumprod(sum,"Gives the sum of all tail values.")@
@:sumprod(prod,"Gives the product of all tail values.")@
@= sumprod_definition
command @1 (b:bat[:any_1,:@2], empty_is_nil:bit ) :@4 
address ALG@1_@2_@4
comment @3;

function @1 (b:bat[:any_1,:@2] ) :@4;
	return @1 := aggr.@1(b, true); 
end @1;
@mal
@= sumprod
@:sumprod_definition(@1,bte,@2,bte)@
@:sumprod_definition(@1,bte,@2,sht)@
@:sumprod_definition(@1,bte,@2,int)@
@:sumprod_definition(@1,bte,@2,wrd)@
@:sumprod_definition(@1,bte,@2,lng)@
@:sumprod_definition(@1,sht,@2,sht)@
@:sumprod_definition(@1,sht,@2,int)@
@:sumprod_definition(@1,sht,@2,wrd)@
@:sumprod_definition(@1,sht,@2,lng)@
@:sumprod_definition(@1,int,@2,int)@
@:sumprod_definition(@1,int,@2,wrd)@
@:sumprod_definition(@1,int,@2,lng)@
@:sumprod_definition(@1,wrd,@2,wrd)@
@:sumprod_definition(@1,wrd,@2,lng)@
@:sumprod_definition(@1,lng,@2,lng)@
@:sumprod_definition(@1,flt,@2,flt)@
@:sumprod_definition(@1,flt,@2,dbl)@
@:sumprod_definition(@1,dbl,@2,dbl)@

@:sumprod_definition(@1,bte,@2,dbl)@
@:sumprod_definition(@1,sht,@2,dbl)@
@:sumprod_definition(@1,int,@2,dbl)@
@:sumprod_definition(@1,wrd,@2,dbl)@
@:sumprod_definition(@1,lng,@2,dbl)@

@= avg_definition
command avg (b:bat[:any_1,:@1] ) :dbl 
address ALGavg_@1
comment "Gives the avg of all tail values";
@mal
@:avg_definition(bte)@
@:avg_definition(sht)@
@:avg_definition(int)@
@:avg_definition(wrd)@
@:avg_definition(lng)@
@:avg_definition(flt)@
@:avg_definition(dbl)@

@- Standard deviation
The standard deviation of a set is the square root of its variance.
The variance is the sum of squares of the deviation of each value in the set
from the mean (average) value, divided by the population of the set.

@= stdev_definition
command stdev (b:bat[:any_1,:@1] ) :dbl
address ALGstdev_@1
comment "Gives the standard deviation of all tail values";
@mal
@:stdev_definition(bte)@
@:stdev_definition(sht)@
@:stdev_definition(int)@
@:stdev_definition(wrd)@
@:stdev_definition(lng)@
@:stdev_definition(flt)@
@:stdev_definition(dbl)@

@-
@= aggregate_definition
command @1 ( b:bat[:any_1,:@2] ) :@2 
address ALG@1_@2 comment @3;
@= aggregate
@:aggregate_definition(@1,bte,@2)@
@:aggregate_definition(@1,sht,@2)@
@:aggregate_definition(@1,int,@2)@
@:aggregate_definition(@1,wrd,@2)@
@:aggregate_definition(@1,flt,@2)@
@:aggregate_definition(@1,dbl,@2)@
@:aggregate_definition(@1,lng,@2)@

@mal
@:aggregate(max,"Give the highest tail value.")@
@:aggregate(min,"Give the lowest tail value. ")@

@+ Exented selection predicates
For SQL convenience we provide a serie of interval selectors.
@mal
module algebra;
@+ Modeling With Properties
The Monet kernel performs run-time optimizations. To choose between
alternative algorithms in a sensible way, it maintains knowledge about
each BAT, sometimes as a BAT property, sometimes as two
column properties for each column (head and tail)
of a BAT. An example of the former is size(bat):int
(which gives the number of BUNs in a BAT), an example
of the latter is ordered(column) :bit, indicating
whether the column contains its valued stored in ascending order.
The convention is to use a BAT as operand also for the column
properties; which then is supposed to be valid for the head
column (ordered(BAT)). Tail columns can be described by
using the mirror BAT with the minus operator (ordered(-BAT)).

@- Column Properties
@table @code
@item [ordered(BAT) :bit]
	TRUE if the head column is stored in ascending order, else FALSE.
@item [keyed(BAT) :bit]
	TRUE if no duplicates are present in the head column, else FALSE.
@item [idx(BAT) :bit]
	TRUE if a binary index tree search accelerator is present on
	the head column of the BAT, else FALSE.
@item [hashtab(BAT) :bit] 
	presence of hash table on the head column of
	a BAT. TRUE if a bucket-chained hash table search accelerator is
	present on the head column of the BAT, else FALSE.
@item [subcol(BAT, BAT) :bit]
	TRUE if the bag of all values in the head column of the left BAT is
	a bag-subset of the bag of all values in the head column of the
	right BAT, else FALSE.
@item [sync(BAT) :oid]
	Sync-OID on the head column of a BAT. A sync-OID denotes some unique
	sequence of values. If two columns have the same sync-OID, then they
	are guaranteed to contain the same values, in the same sequence.

@item [size(BAT) :int]
	The (estimated) length of a column.
@item [unique(BAT) :int]
	The (estimated) number of distinct values in one column.
@item [subset(BAT, BAT) :bit]
	TRUE if the left BAT is a subset of the BUNs of the right BAT,
	else FALSE.
@item [setunique(BAT) :bit]
	TRUE if the BAT contains no duplicate BUNs, else FALSE.
@end table

@- Property Propagation Rules
At database creation time, the properties of the BATs in the database
can be derived directly from the database schema.

When queries are executed, they will produce @emph{intermediate results},
which in terms are operands for further execution. Hence it is necessary
to @emph{propagate properties} from the operands of an algebraic operator,
to its result.

This process can be captured by having a series of @emph{propagation rules}
for each algebraic operand. Since each algebraic operands may apply
different strategies, according to different status in its operand properties,
each algebraic operator may have different propagation rules with these
different situations as conditions.

@include kprelude.mx
@h
#ifndef ALGEBRA_H
#define ALGEBRA_H

#include <gdk.h>
#include "mal_exception.h"

#ifdef WIN32
#if !defined(LIBMAL) && !defined(LIBATOMS) && !defined(LIBKERNEL) && !defined(LIBMAL) && !defined(LIBOPTIMIZER) && !defined(LIBSCHEDULER) && !defined(LIBMONETDB5)
#define algebra_export extern __declspec(dllimport)
#else
#define algebra_export extern __declspec(dllexport)
#endif
#else
#define algebra_export extern
#endif

algebra_export ptr BATmax(BAT *b, ptr aggr);
algebra_export ptr BATmin(BAT *b, ptr aggr);

@= avg_export
algebra_export str ALGavg_@1(dbl *res, int *bid);
@h
@:avg_export(bte)@
@:avg_export(sht)@
@:avg_export(int)@
@:avg_export(wrd)@
@:avg_export(lng)@
@:avg_export(flt)@
@:avg_export(dbl)@

@= stdev_export
algebra_export str ALGstdev_@1(dbl *res, int *bid);
@h
@:stdev_export(bte)@
@:stdev_export(sht)@
@:stdev_export(int)@
@:stdev_export(wrd)@
@:stdev_export(lng)@
@:stdev_export(flt)@
@:stdev_export(dbl)@

@= ALGsum_export
algebra_export str ALGsum_@1_@2(@2* res, int *bid, bit *empty_is_nil) ;
@= ALGprod_export
algebra_export str ALGprod_@1_@2(@2* res, int *bid, bit *empty_is_nil) ;
@h
@:ALGsum_export(bte,bte,0)@
@:ALGsum_export(bte,sht,0)@
@:ALGsum_export(bte,int,0)@
@:ALGsum_export(bte,wrd,0)@
@:ALGsum_export(bte,lng,0)@
@:ALGsum_export(sht,sht,0)@
@:ALGsum_export(sht,int,0)@
@:ALGsum_export(sht,wrd,0)@
@:ALGsum_export(sht,lng,0)@
@:ALGsum_export(int,int,0)@
@:ALGsum_export(int,wrd,0)@
@:ALGsum_export(int,lng,0)@
@:ALGsum_export(wrd,wrd,0)@
@:ALGsum_export(wrd,lng,0)@
@:ALGsum_export(lng,lng,0)@
@:ALGsum_export(flt,flt,0.0)@
@:ALGsum_export(flt,dbl,0.0)@
@:ALGsum_export(dbl,dbl,0.0)@

@:ALGsum_export(bte,dbl,0.0)@
@:ALGsum_export(sht,dbl,0.0)@
@:ALGsum_export(int,dbl,0.0)@
@:ALGsum_export(wrd,dbl,0.0)@
@:ALGsum_export(lng,dbl,0.0)@

@:ALGprod_export(bte,bte,1)@
@:ALGprod_export(bte,sht,1)@
@:ALGprod_export(bte,int,1)@
@:ALGprod_export(bte,wrd,1)@
@:ALGprod_export(bte,lng,1)@
@:ALGprod_export(sht,sht,1)@
@:ALGprod_export(sht,int,1)@
@:ALGprod_export(sht,wrd,1)@
@:ALGprod_export(sht,lng,1)@
@:ALGprod_export(int,int,1)@
@:ALGprod_export(int,wrd,1)@
@:ALGprod_export(int,lng,1)@
@:ALGprod_export(wrd,wrd,1)@
@:ALGprod_export(wrd,lng,1)@
@:ALGprod_export(lng,lng,1)@
@:ALGprod_export(flt,flt,1.0)@
@:ALGprod_export(flt,dbl,1.0)@
@:ALGprod_export(dbl,dbl,1.0)@

@:ALGprod_export(bte,dbl,0.0)@
@:ALGprod_export(sht,dbl,0.0)@
@:ALGprod_export(int,dbl,0.0)@
@:ALGprod_export(wrd,dbl,0.0)@
@:ALGprod_export(lng,dbl,0.0)@

@= ALGaggregate_export
algebra_export str ALGmin_@1(@1* res, int *bid) ;
algebra_export str ALGmax_@1(@1* res, int *bid) ;
@h
@:ALGaggregate_export(bte)@
@:ALGaggregate_export(sht)@
@:ALGaggregate_export(int)@
@:ALGaggregate_export(wrd)@
@:ALGaggregate_export(lng)@
@:ALGaggregate_export(flt)@
@:ALGaggregate_export(dbl)@

algebra_export str ALGminany(ptr result, int *bid);
algebra_export str ALGmaxany(ptr result, int *bid);
algebra_export str ALGtopN(int *res, int *bid, lng *top);
algebra_export str ALGgroupby(int *res, int *bid);
algebra_export str ALGcard(lng *result, int *bid);
algebra_export str ALGBATminimum(ptr *result, int *bid);
algebra_export str ALGBATmaximum(ptr *result, int *bid);
algebra_export str ALGselect1(int *result, int *bid, ptr value);
algebra_export str ALGselect1Head(int *result, int *bid, ptr value);
algebra_export str ALGuselect1(int *result, int *bid, ptr value);
algebra_export str ALGthetauselect(int *result, int *bid, ptr value, str *op);
algebra_export str ALGantiuselect1(int *result, int *bid, ptr value);
algebra_export str ALGselect(int *result, int *bid, ptr low, ptr high);
algebra_export str ALGthetaselect(int *result, int *bid, ptr low, str *op);
algebra_export str ALGselectHead(int *result, int *bid, ptr low, ptr high);
algebra_export str ALGuselect(int *result, int *bid, ptr low, ptr high);
algebra_export str ALGselectInclusive(int *result, int *bid, ptr low, ptr high, bit *lin, bit *rin);
algebra_export str ALGselectInclusiveHead(int *result, int *bid, ptr low, ptr high, bit *lin, bit *rin);
algebra_export str ALGuselectInclusive(int *result, int *bid, ptr low, ptr high, bit *lin, bit *rin);
algebra_export str ALGantiuselectInclusive(int *result, int *bid, ptr low, ptr high, bit *lin, bit *rin);
algebra_export str ALGfragment(int *result, int *bid, ptr hlow, ptr hhigh, ptr tlow, ptr thigh);
algebra_export str ALGthetajoinEstimate(int *result, int *lid, int *rid, int *opc, lng *estimate);
algebra_export str ALGthetajoin(int *result, int *lid, int *rid, int *opc);
algebra_export str ALGbandjoin_default(int *result, int *lid, int *rid, ptr *minus, ptr *plus);
algebra_export str ALGbandjoin(int *result, int *lid, int *rid, ptr *minus, ptr *plus, bit *li, bit *hi);
algebra_export str ALGrangejoin(int *result, int *lid, int *rlid, int *rhid, bit *li, bit *hi);

@= ALGunaryExport
algebra_export str ALG@1(int *result, int *bid);
@= ALGunaryintExport
algebra_export str ALG@1(int *result, int *bid);
@= ALGbinaryExport
algebra_export str ALG@1(int *result, int *lid, int *rid) ;
@= ALGbinaryintExport
algebra_export str ALG@1(int *result, int* bid, int *param) ;
@= ALGbinaryestimateExport
algebra_export str ALG@1estimate(int *result, int *lid, int *rid, lng *estimate);
algebra_export str ALG@1(int *result, int* lid, int *rid);
@h
@:ALGunaryExport(histogram)@
@:ALGunaryExport(number)@
@:ALGunaryExport(merge)@
@:ALGunaryExport(split)@
@:ALGunaryExport(copy)@
@:ALGunaryExport(kunique)@
@:ALGunaryExport(sunique)@
@:ALGbinaryExport(cross)@
@:ALGbinaryExport(antijoin)@
@:ALGbinaryestimateExport(join)@
@:ALGbinaryestimateExport(fetchjoin)@
@:ALGbinaryestimateExport(leftjoin)@
@:ALGbinaryestimateExport(leftfetchjoin)@
@:ALGbinaryestimateExport(outerjoin)@
@:ALGbinaryExport(semijoin)@
@:ALGbinaryExport(sunion)@
@:ALGbinaryExport(kunion)@
@:ALGbinaryExport(sintersect)@
@:ALGbinaryExport(kintersect)@
@:ALGbinaryExport(sdiff)@
@:ALGbinaryExport(kdiff)@
@:ALGbinaryintExport(sample)@

algebra_export str ALGtunique(int *result, int *bid);
algebra_export str ALGtsort(int *result, int *bid);
algebra_export str ALGtsort_rev(int *result, int *bid);
algebra_export str ALGhsort(int *result, int *bid);
algebra_export str ALGhsort_rev(int *result, int *bid);
algebra_export str ALGhtsort(int *result, int *lid);
algebra_export str ALGthsort(int *result, int *lid);
algebra_export str ALGssort(int *result, int *bid);
algebra_export str ALGssort_rev(int *result, int *bid);
algebra_export str ALGrevert(int *result, int *bid);
algebra_export str ALGcount_bat(wrd *result, int *bid);
algebra_export str ALGcount_nil(wrd *result, int *bid, bit *ignore_nils);
algebra_export str ALGcount_no_nil(wrd *result, int *bid);
algebra_export str ALGtmark(int *result, int *bid, oid *base);
algebra_export str ALGtmark_default(int *result, int *bid);
algebra_export str ALGtmarkp(int *result, int *bid, int *nr_parts, int *part_nr);
algebra_export str ALGmarkHead(int *result, int *bid, oid *base);
algebra_export str ALGmarkHead_default(int *result, int *bid);
algebra_export str ALGhmarkp(int *result, int *bid, int *nr_parts, int *part_nr);
algebra_export str ALGmark_grp_1(int *result, int *bid, int *gid);
algebra_export str ALGmark_grp_2(int *result, int *bid, int *gid, oid *base);
algebra_export str ALGhashsplit(int *result, int *bid, int *nfrag);
algebra_export str ALGrangesplit(int *result, int *bid, int *nfrag);
algebra_export str ALGurangesplit(int *result, int *bid, int *nfrag);
algebra_export str ALGhistogram_rev(int *result, int *bid);
algebra_export str ALGlike(int *ret, int *bid, str *k);
algebra_export str ALGslice(int *ret, bat *bid, lng *start, lng *end);
algebra_export str ALGslice_int(int *ret, bat *bid, int *start, int *end);
algebra_export str ALGslice_wrd(int *ret, bat *bid, wrd *start, wrd *end);
algebra_export str ALGposition(wrd *retval, int *bid, ptr val);
algebra_export str ALGpositionBUN(wrd *retval, int *bid, ptr val, ptr tval);
algebra_export str doALGfetch(ptr ret, BAT *b, lng *pos);
algebra_export str ALGfetch(ptr ret, int *bid, lng *pos);
algebra_export str ALGfetchoid(int *ret, int *bid, oid *pos);
algebra_export str ALGfetchint(int *ret, int *bid, int *pos);
algebra_export str ALGfetchbat(int *ret, int *bid, int *sid);
algebra_export str ALGexist(bit *ret, int *bid, ptr val);
algebra_export str ALGexistBUN(bit *ret, int *bid, ptr val, ptr tval);
algebra_export str ALGfind(ptr ret, int *bid, ptr val);
algebra_export str ALGhashjoin(int *result, int *lid, int *rid);
algebra_export str ALGmergejoin(int *result, int *lid, int *rid);
algebra_export str ALGindexjoin(int *result, int *lid, int *rid);
algebra_export str ALGprojectNIL(int *ret, int *bid);
algebra_export str ALGselectNotNil(int *result, int *bid);
algebra_export str ALGuhashsplit(int *result, int *bid, int *nfrag);

@= project_export
algebra_export str ALGprojecthead_@1(int *ret,ptr *val, int *bid);
algebra_export str ALGprojecttail_@1(int *ret,int *bid, ptr *val);
@h
@:project_export(int)@
@:project_export(sht)@
@:project_export(lng)@
@:project_export(oid)@
@:project_export(flt)@
@:project_export(dbl)@
@:project_export(str)@
@:project_export(chr)@
@:project_export(bit)@

algebra_export str ALGidentity(int *ret, int *bid);
algebra_export str ALGmaterialize(int *ret, int *bid);
algebra_export str ALGreuse(int *ret, int *bid);
#endif
@c
#include "monetdb_config.h"
#include "algebra.h"
#include "gdk_rangejoin.h"
#include <math.h>

@* Command Implementations in C
This module contains just a wrapper implementations; since all described
operations are part of the GDK kernel.

@+ BAT sum operation
The sum aggregate only works for int and float fields.
The routines below assumes that the caller knows what type
is large enough to prevent overflow.

@= sum_implementation
int
CMDsum_@1_@2(@2* res, BAT *b, bit *empty_is_nil)
{
	BATiter bi = bat_iterator(b);
	BUN p,q;
	@2 result=@3;

	BATcheck(b,"BATsum_@1_@2");
	if (!BATcount(b) && *empty_is_nil)
		result = @2_nil;
	BATaccessBegin(b,USE_TAIL,MMAP_SEQUENTIAL);
	if (b->T->nonil) {
		BATloop(b, p, q) {
			result += *(@1*) BUNtloc(bi, p);
		}
	} else {
		BATloop(b, p, q) {
			@1 *value = (@1*) BUNtloc(bi, p);
			if (*value == @1_nil) {
				result = @2_nil;
				break;
			} else {
				result += *value;
			}
		}
	}
	BATaccessEnd(b,USE_TAIL,MMAP_SEQUENTIAL);
	*res = result;
	return GDK_SUCCEED;
}

@+ BAT prod[uct] operation
The prod[uct] aggregate only works for int and float fields.
The routines below assumes that the caller knows what type
is large enough to prevent overflow.

@= prod_implementation
int
CMDprod_@1_@2(@2* res, BAT *b, bit *empty_is_nil)
{
	BATiter bi = bat_iterator(b);
	BUN p,q;
	@2 result=@3;

	BATcheck(b,"BATprodInt");
	if (!BATcount(b) && *empty_is_nil)
		result = @2_nil;
	BATaccessBegin(b,USE_TAIL,MMAP_SEQUENTIAL);
	if (b->T->nonil) {
		BATloop(b, p, q) {
			result *= *(@1*) BUNtloc(bi, p);
		}
	} else {
		BATloop(b, p, q) {
			@1 *value = (@1*) BUNtloc(bi, p);
			if (*value == @1_nil) {
				result = @2_nil;
				break;
			} else {
				result *= *value;
			}
		}
	}
	BATaccessEnd(b,USE_TAIL,MMAP_SEQUENTIAL);
	*res = result;
	return GDK_SUCCEED;
}

@+ Minimum and Maximum
The routines @`BATmin@5(b) and @`BATmax@5(b) compute the minimum and
maximum value of the tail column of a BAT.
Aggregate values are calculated just before they are requested by
the user. They are not maintained continuously, because we expect
them to be used sparsely.

@= aggregate_implementation
int
CMDmin_@1(@1* result, BAT *b)
{
	return BATmin(b, result)?GDK_SUCCEED:GDK_FAIL;
}
int
CMDmax_@1(@1* result, BAT *b)
{
	return BATmax(b, result)?GDK_SUCCEED:GDK_FAIL;
}
@= atomaggr
	if (s > 0 && !(BATtordered(b)&1)) {
		char* nil = BATatoms[t].atomNull;
		BUN p,q;

		BATaccessBegin(b,USE_TAIL,MMAP_SEQUENTIAL);
		if (b->T->nonil) {
			BATloop(b, p, q) {
				x = (ptr) BUNt@2(bi, p);
				if (@3_@5(x, v, @4)) {
					v = x;
				}
			}
		} else {
			BATloop(b, p, q) {
				x = (ptr) BUNt@2(bi, p);
				if (@3_CMP(x, nil, @4) == 0) {
					v = nil;
					break;
				}
				if (@3_@5(x, v, @4)) {
					v = x;
				}
			}
		}
		BATaccessEnd(b,USE_TAIL,MMAP_SEQUENTIAL);
	}
	if (aggr) {
		memcpy(aggr, x=v, ATOMsize(t));
	} else {
		/* alloc new space and copy the atom into it */
		s = ATOMlen(t, v);
		x = GDKmalloc(s);
		if (x)
			memcpy(x, v, s);
	}
@= voidaggr
	if (aggr) {
		*(oid *) aggr = *(oid *) (x=v);
	} else {
		/* alloc new space and copy the atom into it */
		x = GDKmalloc(sizeof(oid));
		if (x)
			memcpy(x, v, s);
	}
@= aggrmin
	v = (s == 0)?ATOMnilptr(t):BUNtail(bi, BUNfirst(b));
	@:@5aggr(@1,@2,@3,@4,LT)@
@= aggrmax
	v = (s == 0)?ATOMnilptr(t):BUNtail(bi, BUNlast(b)-1);
	@:@5aggr(@1,@2,@3,@4,GT)@

@= BATaggr
ptr
BAT@1(BAT *b, ptr aggr)
{
	BATiter bi = bat_iterator(b);
	int t;
	BUN s;
	ptr v, x;

	BATcheck(b, "BAT@1");
	s = BATcount(b);
	t = b->ttype;
	if (BATtvoid(b)) {
		@:aggr@1(chr,loc,simple,chr,void)@
	} else {
		switch(ATOMstorage(t)) {
		case TYPE_chr:
			@:aggr@1(chr,loc,simple,chr,atom)@
			break;
		case TYPE_bte:
			@:aggr@1(bte,loc,simple,bte,atom)@
			break;
		case TYPE_sht:
			@:aggr@1(sht,loc,simple,sht,atom)@
			break;
		case TYPE_int:
			@:aggr@1(int,loc,simple,int,atom)@
			break;
		case TYPE_flt:
			@:aggr@1(flt,loc,simple,flt,atom)@
			break;
		case TYPE_dbl:
			@:aggr@1(dbl,loc,simple,dbl,atom)@
			break;
		case TYPE_lng:
			@:aggr@1(lng,loc,simple,lng,atom)@
			break;
		default:
			if (b->tvarsized) {
				@:aggr@1(chr,var,atom,t,atom)@
				break;
			} else {
				@:aggr@1(chr,loc,atom,t,atom)@
				break;
			}
		}
	}
	return x;
}
@c
@:BATaggr(min)@
@:BATaggr(max)@

@:sum_implementation(bte,bte,0)@
@:sum_implementation(bte,sht,0)@
@:sum_implementation(bte,int,0)@
@:sum_implementation(bte,wrd,0)@
@:sum_implementation(bte,lng,0)@
@:sum_implementation(sht,sht,0)@
@:sum_implementation(sht,int,0)@
@:sum_implementation(sht,wrd,0)@
@:sum_implementation(sht,lng,0)@
@:sum_implementation(int,int,0)@
@:sum_implementation(int,wrd,0)@
@:sum_implementation(int,lng,0)@
@:sum_implementation(wrd,wrd,0)@
@:sum_implementation(wrd,lng,0)@
@:sum_implementation(lng,lng,0)@
@:sum_implementation(flt,flt,0.0)@
@:sum_implementation(flt,dbl,0.0)@
@:sum_implementation(dbl,dbl,0.0)@

@:sum_implementation(bte,dbl,0.0)@
@:sum_implementation(sht,dbl,0.0)@
@:sum_implementation(int,dbl,0.0)@
@:sum_implementation(wrd,dbl,0.0)@
@:sum_implementation(lng,dbl,0.0)@

@:prod_implementation(bte,bte,1)@
@:prod_implementation(bte,sht,1)@
@:prod_implementation(bte,int,1)@
@:prod_implementation(bte,wrd,1)@
@:prod_implementation(bte,lng,1)@
@:prod_implementation(sht,sht,1)@
@:prod_implementation(sht,int,1)@
@:prod_implementation(sht,wrd,1)@
@:prod_implementation(sht,lng,1)@
@:prod_implementation(int,int,1)@
@:prod_implementation(int,wrd,1)@
@:prod_implementation(int,lng,1)@
@:prod_implementation(wrd,wrd,1)@
@:prod_implementation(wrd,lng,1)@
@:prod_implementation(lng,lng,1)@
@:prod_implementation(flt,flt,1.0)@
@:prod_implementation(flt,dbl,1.0)@
@:prod_implementation(dbl,dbl,1.0)@

@:prod_implementation(bte,dbl,0.0)@
@:prod_implementation(sht,dbl,0.0)@
@:prod_implementation(int,dbl,0.0)@
@:prod_implementation(wrd,dbl,0.0)@
@:prod_implementation(lng,dbl,0.0)@

@:aggregate_implementation(bte)@
@:aggregate_implementation(sht)@
@:aggregate_implementation(int)@
@:aggregate_implementation(wrd)@
@:aggregate_implementation(flt)@
@:aggregate_implementation(dbl)@
@:aggregate_implementation(lng)@

int
CMDminany(ptr result, BAT *b)
{
	if (!ATOMlinear(b->ttype))
		return GDKerror("CMDminANY: atom '%s' cannot be ordered linearly\n", ATOMname(b->ttype));
	if (ATOMvarsized(b->ttype)) {
		return (*(ptr *) result = BATmin(b, NULL)) ? GDK_SUCCEED : GDK_FAIL;
	}
	if (BATmin(b, result)) {
		if (b->ttype == TYPE_bat)
			*(BAT **) result = BATdescriptor(*(bat *) result);
		return GDK_SUCCEED;
	}
	return GDK_FAIL;
}

int
CMDmaxany(ptr result, BAT *b)
{
	if (!ATOMlinear(b->ttype))
		return GDKerror("CMDmaxANY: atom '%s' cannot be ordered linearly\n", ATOMname(b->ttype));
	if (ATOMvarsized(b->ttype)) {
		return (*(ptr *) result = BATmax(b, NULL)) ? GDK_SUCCEED : GDK_FAIL;
	}
	if (BATmax(b, result)) {
		if (b->ttype == TYPE_bat)
			*(BAT **) result = BATdescriptor(*(bat *) result);
		return GDK_SUCCEED;
	}
	return GDK_FAIL;
}

@* Command Implementations in C
This module contains just a wrapper implementations; since all described
operations are part of the GDK kernel.

@c
int
CMDselect1(BAT **result, BAT *b, ptr value)
{
	ptr v = (b->ttype == TYPE_bat) ? (ptr) &((BAT *) value)->batCacheid : value;

	return (*result = BATselect(b, v, 0)) ? GDK_SUCCEED : GDK_FAIL;
}

int
CMDuselect1(BAT **result, BAT *b, ptr value)
{
	ptr v = (b->ttype == TYPE_bat) ? (ptr) &((BAT *) value)->batCacheid : value;

	return (*result = BATuselect(b, v, 0)) ? GDK_SUCCEED : GDK_FAIL;
}

int
CMDantiuselect1(BAT **result, BAT *b, ptr value)
{
	ptr v = (b->ttype == TYPE_bat) ? (ptr) &((BAT *) value)->batCacheid : value;

	return (*result = BATantiuselect_(b, v, NULL, FALSE, FALSE)) ? GDK_SUCCEED : GDK_FAIL;
}

int
CMDselect(BAT **result, BAT *b, ptr low, ptr high)
{
	ptr l = (b->ttype == TYPE_bat) ? (ptr) &((BAT *) low )->batCacheid : low ;
	ptr h = (b->ttype == TYPE_bat) ? (ptr) &((BAT *) high)->batCacheid : high;

	if (b->ttype == TYPE_bat && l != h ) {
		GDKerror("CMDselect: range-selects on type BAT are not supported\n");
		return GDK_FAIL;
	}
	return (*result = BATselect(b, l, h)) ? GDK_SUCCEED : GDK_FAIL;
}

int
CMDuselect(BAT **result, BAT *b, ptr low, ptr high)
{
	ptr l = (b->ttype == TYPE_bat) ? (ptr) &((BAT *) low )->batCacheid : low ;
	ptr h = (b->ttype == TYPE_bat) ? (ptr) &((BAT *) high)->batCacheid : high;

	if (b->ttype == TYPE_bat && l != h ) {
		GDKerror("CMDuselect: range-selects on type BAT are not supported\n");
		return GDK_FAIL;
	}
	return (*result = BATuselect(b, l, h)) ? GDK_SUCCEED : GDK_FAIL;
}

int
CMDselect_(BAT **result, BAT *b, ptr low, ptr high, bit *l_in, bit *h_in)
{
	int tt = b->ttype;
	ptr nil = ATOMnilptr(tt);
	ptr l = (b->ttype == TYPE_bat) ? (ptr) &((BAT *) low )->batCacheid : low ;
	ptr h = (b->ttype == TYPE_bat) ? (ptr) &((BAT *) high)->batCacheid : high;

	if (b->ttype == TYPE_bat && l != h ) {
		GDKerror("CMDselect: range-selects on type BAT are not supported\n");
		return GDK_FAIL;
	}
	if (*l_in == bit_nil && ATOMcmp(tt, l, nil)) {
		GDKerror("CMDselect: flag 'l_in' must not be NIL, unless boundary 'low' is NIL\n");
		return GDK_FAIL;
	}
	if (*h_in == bit_nil && ATOMcmp(tt, h, nil)) {
		GDKerror("CMDselect: flag 'h_in' must not be NIL, unless boundary 'high' is NIL\n");
		return GDK_FAIL;
	}
	return (*result = BATselect_(b, l, h, *l_in, *h_in)) ? GDK_SUCCEED : GDK_FAIL;
}

int
CMDuselect_(BAT **result, BAT *b, ptr low, ptr high, bit *l_in, bit *h_in)
{
	int tt = b->ttype;
	ptr nil = ATOMnilptr(tt);
	ptr l = (b->ttype == TYPE_bat) ? (ptr) &((BAT *) low )->batCacheid : low ;
	ptr h = (b->ttype == TYPE_bat) ? (ptr) &((BAT *) high)->batCacheid : high;

	if (b->ttype == TYPE_bat && l != h ) {
		GDKerror("CMDuselect: range-selects on type BAT are not supported\n");
		return GDK_FAIL;
	}
	if (*l_in == bit_nil && ATOMcmp(tt, l, nil)) {
		GDKerror("CMDuselect: flag 'l_in' must not be NIL, unless boundary 'low' is NIL\n");
		return GDK_FAIL;
	}
	if (*h_in == bit_nil && ATOMcmp(tt, h, nil)) {
		GDKerror("CMDuselect: flag 'h_in' must not be NIL, unless boundary 'high' is NIL\n");
		return GDK_FAIL;
	}
	return (*result = BATuselect_(b, l, h, *l_in, *h_in)) ? GDK_SUCCEED : GDK_FAIL;
}

int
CMDantiuselect_(BAT **result, BAT *b, ptr low, ptr high, bit *l_in, bit *h_in)
{
	int tt = b->ttype;
	ptr nil = ATOMnilptr(tt);
	ptr l = (b->ttype == TYPE_bat) ? (ptr) &((BAT *) low )->batCacheid : low ;
	ptr h = (b->ttype == TYPE_bat) ? (ptr) &((BAT *) high)->batCacheid : high;

	if (b->ttype == TYPE_bat && l != h ) {
		GDKerror("CMDantiuselect: range-selects on type BAT are not supported\n");
		return GDK_FAIL;
	}
	if (*l_in == bit_nil && ATOMcmp(tt, l, nil)) {
		GDKerror("CMDantiuselect: flag 'l_in' must not be NIL, unless boundary 'low' is NIL\n");
		return GDK_FAIL;
	}
	if (*h_in == bit_nil && ATOMcmp(tt, h, nil)) {
		GDKerror("CMDantiuselect: flag 'h_in' must not be NIL, unless boundary 'high' is NIL\n");
		return GDK_FAIL;
	}
	return (*result = BATantiuselect_(b, l, h, *l_in, *h_in)) ? GDK_SUCCEED : GDK_FAIL;
}

int
CMDfragment(BAT **result, BAT *b, ptr hlow, ptr hhigh, ptr tlow, ptr thigh)
{
	return (*result = BATrestrict(b, hlow, hhigh, tlow, thigh)) ? GDK_SUCCEED : GDK_FAIL;
}

int
CMDthetajoin(BAT **result, BAT *left, BAT *right, int *mode, lng *estimate)
{
	return (*result = BATthetajoin(left, right, *mode, *estimate == lng_nil || *estimate < 0 ? BUN_NONE : (*estimate >= (lng) BUN_MAX ? BUN_MAX : (BUN) *estimate))) ? GDK_SUCCEED : GDK_FAIL;
}

int
CMDbandjoin_default(BAT **result, BAT *left, BAT *right, ptr minus, ptr plus)
{
	return (*result = BATbandjoin(left, right, minus, plus, TRUE, TRUE)) ? GDK_SUCCEED : GDK_FAIL;
}

int
CMDbandjoin(BAT **result, BAT *left, BAT *right, ptr minus, ptr plus, bit *li, bit *hi)
{
	return (*result = BATbandjoin(left, right, minus, plus, *li, *hi)) ? GDK_SUCCEED : GDK_FAIL;
}

int
CMDrangejoin(BAT **result, BAT *left, BAT *rl, BAT *rh, bit *li, bit *hi)
{
	return (*result = BATrangejoin(left, rl, rh, *li, *hi)) ? GDK_SUCCEED : GDK_FAIL;
}

@-
Let's cut this text down with some Mx macros
@= unary
int
CMD@1(BAT **result, BAT *b)
{
	return (*result = @2(b))?GDK_SUCCEED:GDK_FAIL;
}
@= binary
int
CMD@1(BAT **result, BAT *left, BAT* right)
{
	return (*result = @2(left, right))?GDK_SUCCEED:GDK_FAIL;
}
@= binaryestimate
int
CMD@1(BAT **result, BAT *left, BAT* right, lng *estimate)
{
	return (*result = @2(left, right, *estimate == lng_nil || *estimate < 0 ? BUN_NONE : (*estimate >= (lng) BUN_MAX ? BUN_MAX : (BUN) *estimate))) ? GDK_SUCCEED : GDK_FAIL;
}
@= binaryint
int
CMD@1(BAT **result, BAT* b, int *param)
{
	return (*result = @2(b, *param))?GDK_SUCCEED:GDK_FAIL;
}
@h
#define BATtdiff(l,r) BATmirror(BATkdiff(BATmirror(l),BATmirror(r)))
#define BATtintersect(l,r) BATmirror(BATkintersect(BATmirror(l),BATmirror(r)))
#define BATtsort(b) BATmirror(BATsort(BATmirror(b)))
#define BATtsort_rev(b) BATmirror(BATsort_rev(BATmirror(b)))
#define BAThistogram_rev(b) BAThistogram(BATmirror(b))
#define BATmark_default(b) BATmark(b,OIDnew(BATcount(b)))
#define BATtmark_default(b) BATmirror(BATmark(BATmirror(b),OIDnew(BATcount(b))))
#define BAThmark_default(b) BATmirror(BATmark(b,OIDnew(BATcount(b))))
#define BATwcopy(b) BATcopy(b, b->htype, b->ttype, 1)
#define BATrcopy(b) BATcopy(b, b->htype, b->ttype, 2)
@c
@:unary(histogram,BAThistogram)@
@:unary(histogram_rev,BAThistogram_rev)@
@:unary(sort,BATsort)@
@:unary(sort_rev,BATsort_rev)@
@:unary(tsort,BATtsort)@
@:unary(tsort_rev,BATtsort_rev)@
@:unary(ssort,BATssort)@
@:unary(ssort_rev,BATssort_rev)@
@:unary(number,BATnumber)@
@:unary(copy,BATwcopy)@
@:unary(rcopy,BATrcopy)@
@:unary(kunique,BATkunique)@
@:unary(sunique,BATsunique)@
@:unary(mark_default,BATmark_default)@
@:unary(tmark_default,BATtmark_default)@
@:unary(hmark_default,BAThmark_default)@
@:binary(semijoin,BATsemijoin)@
@:binary(cross,BATcross)@
@:binary(antijoin,BATantijoin)@
@:binaryestimate(join,BATjoin)@
@:binaryestimate(fetchjoin,BATfetchjoin)@
@:binaryestimate(leftjoin,BATleftjoin)@
@:binaryestimate(leftfetchjoin,BATleftfetchjoin)@
@:binaryestimate(outerjoin,BATouterjoin)@
@:binary(sunion,BATsunion)@
@:binary(kunion,BATkunion)@
@:binary(sintersect,BATsintersect)@
@:binary(kintersect,BATkintersect)@
@:binary(tintersect,BATtintersect)@
@:binary(sdiff,BATsdiff)@
@:binary(kdiff,BATkdiff)@
@:binary(tdiff,BATtdiff)@
@:binaryint(sample,BATsample)@

int
CMDtunique(BAT **result, BAT* b)
{
	oid id = oid_nil;
	BAT *v = BATconst(BATmirror(b), TYPE_void, &id);
	*result = BATkunique(v);
	BBPreclaim(v);
	return *result?GDK_SUCCEED:GDK_FAIL;
}

int
CMDgroup(BAT **result, BAT *b, int *start, int *incr, int *grpsize)
{
	return (*result = BATgroup(b, *start, *incr, *grpsize)) ? GDK_SUCCEED : GDK_FAIL;
}

int
CMDgen_group(BAT **result, BAT *b )
{
	BATiter bi = bat_iterator(b);
	BUN u, v;
	int htpe = (b->htype == TYPE_void)?TYPE_oid:b->htype;
	BAT *r = BATnew(htpe, TYPE_void, BATcount(b)*2);

	BATaccessBegin(b,USE_HEAD|USE_TAIL,MMAP_SEQUENTIAL);
	if (b->hvarsized) {
		BATloop(b, u, v) {
			wrd i, sz = *(wrd*)BUNtloc(bi, u);
			for(i = 0; i < sz; i++) {
				if (BUNfastins(r, BUNhvar(bi, u), NULL) == NULL) {
					BBPreclaim(r);
					return GDK_FAIL;
				}
			}
		}
	} else {
		BATloop(b, u, v) {
			wrd i, sz = *(wrd*)BUNtloc(bi, u);
			for(i = 0; i < sz; i++) {
				if (BUNfastins(r, BUNhloc(bi, u), NULL) == NULL) {
					BBPreclaim(r);
					return GDK_FAIL;
				}
			}
		}
	}
	BATaccessEnd(b,USE_HEAD|USE_TAIL,MMAP_SEQUENTIAL);
	r -> hsorted = BAThordered(b);
	r -> tsorted = BATtordered(b);
	r -> H ->nonil = b->H->nonil;
	r -> T ->nonil = 0;
	*result = r;
	return GDK_SUCCEED;
}


int
CMDproject(BAT **res, BAT *b, ptr p, int t)
{
	return (*res = BATconst(b, t, p)) ? GDK_SUCCEED : GDK_FAIL;
}

int
CMDmark(BAT **res, BAT *b, oid *base)
{
	return (*res = BATmark(b, *base)) ? GDK_SUCCEED : GDK_FAIL;
}

int
CMDtmark(BAT **res, BAT *b, oid *base)
{
	return (*res = BATmirror(BATmark(BATmirror(b), *base))) ? GDK_SUCCEED : GDK_FAIL;
}

int
CMDhmark(BAT **res, BAT *b, oid *base)
{
	return (*res = BATmirror(BATmark(b, *base))) ? GDK_SUCCEED : GDK_FAIL;
}

int CMDmark_grp_1( BAT** res, BAT *b, BAT *g )
{
	return (*res=BATmark_grp(b, g, NULL))?GDK_SUCCEED:GDK_FAIL;
}

int CMDmark_grp_2( BAT** res, BAT *b, BAT *g, oid *s)
{
	return (*res=BATmark_grp(b, g, s))?GDK_SUCCEED:GDK_FAIL;
}


int
CMDhashsplit(BAT **res, BAT *b, int *nfrag)
{
	if (*nfrag < 0
#if SIZEOF_INT >= SIZEOF_BUN
	    || *nfrag > (int) BUN_MAX
#endif
	   ) {
		GDKerror("hashsplit: parameter out of range.\n");
		return GDK_FAIL;
	}
	return (*res = BAThashsplit(b, (BUN) *nfrag, FALSE)) ? GDK_SUCCEED : GDK_FAIL;
}

int
CMDuhashsplit(BAT **res, BAT *b, int *nfrag)
{
	if (*nfrag < 0
#if SIZEOF_INT >= SIZEOF_BUN
	    || *nfrag > (int) BUN_MAX
#endif
	   ) {
		GDKerror("uhashsplit: parameter out of range.\n");
		return GDK_FAIL;
	}
	return (*res = BAThashsplit(b, (BUN) *nfrag, TRUE)) ? GDK_SUCCEED : GDK_FAIL;
}

int
CMDrangesplit(BAT **res, BAT *b, int *nfrag)
{
	if (*nfrag < 0
#if SIZEOF_INT >= SIZEOF_BUN
	    || *nfrag > (int) BUN_MAX
#endif
	   ) {
		GDKerror("rangesplit: parameter out of range.\n");
		return GDK_FAIL;
	}
	return (*res = BATrangesplit(b, (BUN) *nfrag, FALSE)) ? GDK_SUCCEED : GDK_FAIL;
}

int
CMDurangesplit(BAT **res, BAT *b, int *nfrag)
{
	if (*nfrag < 0
#if SIZEOF_INT >= SIZEOF_BUN
	    || *nfrag > (int) BUN_MAX
#endif
	   ) {
		GDKerror("urangesplit: parameter out of range.\n");
		return GDK_FAIL;
	}
	return (*res = BATrangesplit(b, (BUN) *nfrag, TRUE)) ? GDK_SUCCEED : GDK_FAIL;
}

@- Substring Select
The string pattern matching routine has been added. It should be
dynamically linked.
A simple string matcher is included. It should be refined later on
@c
static inline int
like(char *x, char *y, BUN ylen)
{
	char *r;

	if (x == (char *) NULL) {
		return 0;
	}
	for (r = x + strlen(x) - ylen; x <= r; x++) {
		int ok = 1;
		char *s = x;
		char *q;

		for (q = y; *q; q++, s++)
			if (*q != tolower(*s)) {
				ok = 0;
				break;
			}
		if (ok)
			return 1;
	}
	return 0;
}

int
CMDlike(BAT **ret, BAT *b, str s)
{
	BATiter bi = bat_iterator(b);
	BAT *c = BATnew(BAThtype(b), TYPE_str, BATcount(b) / 10);
	str t;
	BUN u, v;
	BUN yy = 0;

	if (c == NULL)
		return GDK_FAIL;
	t = GDKstrdup(s);
	for (s = t; *s; s++, yy++)
		*s = tolower(*s);

	BATaccessBegin(b,USE_HEAD|USE_TAIL,MMAP_SEQUENTIAL);
	if (b->hvarsized) {
		BATloop(b, u, v)
			if (like(BUNtvar(bi, u), t, yy))
			if (BUNfastins(c, BUNhvar(bi, u), BUNtvar(bi, u)) == NULL) {
				BBPreclaim(c);
				GDKfree(t);
				return GDK_FAIL;
			}
	} else {
		BATloop(b, u, v)
			if (like(BUNtvar(bi, u), t, yy))
			if (BUNfastins(c, BUNhloc(bi, u), BUNtvar(bi, u)) == NULL) {
				BBPreclaim(c);
				GDKfree(t);
				return GDK_FAIL;
			}
	}
	BATaccessEnd(b,USE_HEAD|USE_TAIL,MMAP_SEQUENTIAL);
	c->hsorted = BAThordered(b);
	c->tsorted = BATtordered(b);
	c->H->nonil = b->H->nonil;
	c->T->nonil = b->T->nonil;
	*ret = c;
	GDKfree(t);
	return GDK_SUCCEED;
}

@- BAT slice
@c
static int
slice(BAT **retval, BAT *b, lng start, lng end)
{
	/* the internal BATslice requires exclusive end */
	if (start < 0) {
		GDKerror("CMDslice: start position of slice should >= 0\n");
		return GDK_FAIL;
	}
	if (end == lng_nil) 
		end = BATcount(b);
	if (start > (lng) BUN_MAX || end >= (lng) BUN_MAX) {
		GDKerror("CMDslice: argument out of range\n");
		return GDK_FAIL;
	}

	return (*retval = BATslice(b, (BUN) start, (BUN) end + 1)) ? GDK_SUCCEED : GDK_FAIL;
}

static int
CMDslice(BAT **retval, BAT *b, lng *start, lng *end)
{
	return slice(retval, b, *start, *end);
}

@- BUN Get/Fetch
@c
int
CMDposition(wrd *retval, BAT *b, ptr val)
{
	ptr p = (b->htype == TYPE_bat) ? (ptr) &((BAT *) val)->batCacheid : val;
	BUN v = BUNfnd(b, p);

	if (v == BUN_NONE)
		return GDK_FAIL;
	*retval = (wrd) (v - BUNfirst(b));
	return GDK_SUCCEED;
}

int
CMDpositionBUN(wrd *retval, BAT *b, ptr val, ptr tval)
{
	ptr p = (b->htype == TYPE_bat) ? (ptr) &((BAT *) val)->batCacheid : val;
	ptr o = (b->ttype == TYPE_bat) ? (ptr) &((BAT *) tval)->batCacheid : tval;
	BUN v = BUNlocate(b, p, o);

	if (v == BUN_NONE)
		return GDK_FAIL;
	*retval = (wrd) (v - BUNfirst(b));
	return GDK_SUCCEED;
}

int
CMDfetchbat(BAT **ret, BAT *b, BAT *s)
{
	return (*ret = BATfetch(b, s)) ? GDK_SUCCEED : GDK_FAIL;
}

static int
fetch(ptr ret, BAT *b, lng i)
{
	BATiter bi = bat_iterator(b);

	if (i < 0 || i >= (lng) BATcount(b)) {
		GDKerror("CMDfetch: idx out of range\n");
		return GDK_FAIL;
	}
	i += BUNfirst(b);
	assert(i <= (lng) BUN_MAX);
	@:putTail((BUN)i)@
@= putTail
	if (b->ttype && b->T->vheap) {
		ptr _src = BUNtvar(bi,@1);
		int _len = ATOMlen(b->ttype, _src);
		ptr _dst = GDKmalloc(_len);
		memcpy(_dst, _src, _len);
		*(ptr*) ret = _dst;
	} else {
		int _s = ATOMsize(ATOMtype(b->ttype));
		if (ATOMvarsized(b->ttype)) {
			memcpy(*(ptr*) ret=GDKmalloc(_s), BUNtvar(bi, @1), _s);
		} else if (b->ttype == TYPE_void) {
			*(oid*) ret = b->tseqbase;
			if (b->tseqbase != oid_nil)
				*(oid*)ret += @1 - BUNfirst(b);
		} else if (b->ttype == TYPE_bat) {
			bat bid = *(bat*) Tloc(b, @1);
			*(BAT**) ret = BATdescriptor(bid);
		} else if (_s == 4) {
			*(int*) ret = *(int*) Tloc(b, @1);
		} else if (_s == 1) {
			*(bte*) ret = *(bte*) Tloc(b, @1);
		} else if (_s == 2) {
			*(sht*) ret = *(sht*) Tloc(b, @1);
		} else if (_s == 8) {
			*(lng*) ret = *(lng*) Tloc(b, @1);
		} else {
			memcpy(ret, Tloc(b, @1), _s);
		}
	}
@c
	return GDK_SUCCEED;
}

int
CMDfetch_int(ptr ret, BAT *b, int *pos)
{
	return fetch(ret, b, *pos);
}

int
CMDexist(bit *ret, BAT *b, ptr val)
{
	ptr p = (b->htype == TYPE_bat) ? (ptr) &((BAT *) val)->batCacheid : val;
	BUN q = BUNfnd(b, p);

	*ret = (q != BUN_NONE) ? 1 : 0;
	return GDK_SUCCEED;
}
int
CMDtexist(bit *ret, BAT *b, ptr val)
{
	return CMDexist(ret, BATmirror(b), val);
}

int
CMDexistBUN(bit *ret, BAT *b, ptr val, ptr tval)
{
	ptr p = (b->htype == TYPE_bat) ? (ptr) &((BAT *) val)->batCacheid : val;
	ptr o = (b->ttype == TYPE_bat) ? (ptr) &((BAT *) tval)->batCacheid : tval;
	BUN q = BUNlocate(b, p, o);

	*ret = (q != BUN_NONE) ? 1 : 0;
	return GDK_SUCCEED;
}

int
CMDfind(ptr ret, BAT *b, ptr val)
{
	BATiter bi = bat_iterator(b);
	ptr p = (b->htype == TYPE_bat) ? (ptr) &((BAT *) val)->batCacheid : val;
	BUN q = BUNfnd(b, p);

	if (q == BUN_NONE) {
		GDKerror("CMDfind: value not found.\n");
		return GDK_FAIL;
	}
	@:putTail(q)@
	return GDK_SUCCEED;
}

int
CMDfind_oid(ptr ret, BAT *b, oid* val)
{
	return CMDfind(ret, b, (ptr) val); 
}

@= find_bounds
int
CMDr@1_summary(BAT **ret, BAT* b, int *quantiles)
{
	BUN cnt = BATcount(b);
	BUN n = *quantiles < 0 ? 0 : MIN(cnt,(BUN) *quantiles);
	dbl threshold =0, delta = ((dbl) cnt) / (dbl) (MAX(1,n)-1);
	BAT *bn = *ret = BATnew(b->ttype, TYPE_oid, n);
	int (*cmp)(ptr,ptr) = BATatoms[b->ttype].atomCmp;

	if (bn == NULL)
		return GDK_FAIL;
	bn->hsorted = (1 @3 0 ? GDK_SORTED : FALSE);
	bn->tsorted = GDK_SORTED;
	bn->H->nonil = b->H->nonil;
	bn->T->nonil = b->T->nonil;

	BATaccessBegin(b,USE_HEAD|USE_TAIL,MMAP_SEQUENTIAL);
	if (cnt > 0) {
		BATiter bi = bat_iterator(b);
		BUN yy = 0;
		BUN p, bnds[2];
		ptr v;

		bnds[0 @3 1] = BUNfirst(b);
		bnds[1 @3 0] = BUNlast(b) - 1;

		for (p=bnds[0], v=BUNtail(bi,p); bnds[1] @3 p; p++) {
			ptr cur = BUNtail(bi,p);
			if (cmp(cur, v) @3 0)
				v = cur;
			if (++yy > threshold) {
				bunfastins(bn, v, BUNhead(bi,p));
				threshold += delta;
			}
		}
		bunfastins(bn, v, BUNhead(bi,p));
	}
	BATaccessEnd(b,USE_HEAD|USE_TAIL,MMAP_SEQUENTIAL);
	if ((BAThordered(bn)&1) == 0)
		bn = BATrevert(bn);
	if (bn) {
		bn->hsorted = GDK_SORTED;
		return GDK_SUCCEED;
	}
bunins_failed:
	BATaccessEnd(b,USE_HEAD|USE_TAIL,MMAP_SEQUENTIAL);
	BBPreclaim(bn);
	return GDK_FAIL;
}

int
CMDr@1_@2(oid* ret, BAT *b, ptr v)
{
	if ((BAThordered(b)&1) == 0) {
		GDKerror("CMDr@1_@2: %s should be sorted on head\n", BATgetId(b));
		return GDK_FAIL;
	} else if (BATcount(b) > 0) {
		BATiter bi = bat_iterator(b);
		BUN p = BUN_NONE;
		oid idx;

		switch(ATOMstorage(b->htype)) {
		case TYPE_chr:
			p = SORTfnd@4_chr(BATmirror(b),v);
			break;
		case TYPE_bte:
			p = SORTfnd@4_bte(BATmirror(b),v);
			break;
		case TYPE_sht:
			p = SORTfnd@4_sht(BATmirror(b),v);
			break;
		case TYPE_int:
			p = SORTfnd@4_int(BATmirror(b),v);
			break;
		case TYPE_lng:
			p = SORTfnd@4_lng(BATmirror(b),v);
			break;
		case TYPE_flt:
			p = SORTfnd@4_flt(BATmirror(b),v);
			break;
		case TYPE_dbl:
			p = SORTfnd@4_dbl(BATmirror(b),v);
			break;
		default:
			if (b->hvarsized ) {
				p = SORTfnd@4_var(BATmirror(b),v);
			} else {
				p = SORTfnd@4_loc(BATmirror(b),v);
			}
		}
		if (p == BUN_NONE) {
			p = BUNlast(b);
		} else if (1 @3 0) {
			p--;
		}
		if (p < BUNfirst(b)) {
			idx = *(oid*) BUNtail(bi,p) - 1;
		} else if (p >= BUNlast(b)) {
			idx = *(oid*) BUNtail(bi,BUNlast(b)-1) + 1;
		} else {
			idx = *(oid*) BUNtail(bi,p) @5 1;
		}
		*ret = idx;
	} else {
		*ret = oid_nil;
	}
	return GDK_SUCCEED;
}

int
CMDfind_@2(oid *ret, BAT *b, ptr v)
{
	oid idx = oid_nil;

	if ((BAThordered(b)&1) == 0) {
		GDKerror("CMDfind_@2: %s should be sorted on head\n", BATgetId(b));
		return GDK_FAIL;
	} else if (BATcount(b) > 0) {
		BUN p = BUN_NONE;

		switch(ATOMstorage(b->htype)) {
		case TYPE_chr:
			p = SORTfnd@4_chr(BATmirror(b),v);
			break;
		case TYPE_bte:
			p = SORTfnd@4_bte(BATmirror(b),v);
			break;
		case TYPE_sht:
			p = SORTfnd@4_sht(BATmirror(b),v);
			break;
		case TYPE_int:
			p = SORTfnd@4_int(BATmirror(b),v);
			break;
		case TYPE_lng:
			p = SORTfnd@4_lng(BATmirror(b),v);
			break;
		case TYPE_flt:
			p = SORTfnd@4_flt(BATmirror(b),v);
			break;
		case TYPE_dbl:
			p = SORTfnd@4_dbl(BATmirror(b),v);
			break;
		default:
			if (b->hvarsized ) {
				p = SORTfnd@4_var(BATmirror(b),v);
			} else {
				p = SORTfnd@4_loc(BATmirror(b),v);
			}
		}
		if (p != BUN_NONE) {
			BATiter bi = bat_iterator(b);
			idx = *(oid*) BUNtail(bi,p);
			@6;
		}
	}
	*ret = idx;
	return GDK_SUCCEED;
}
@c
@:find_bounds(min,higher,<,last,-)@
@:find_bounds(max,lower,>,first,+,if (idx && (p >= BUNlast(b) || ATOMcmp(b->htype, v, BUNhead(bi, p)))) idx--) @

int
CMDmerge(BAT **ret, BAT *b)
{
	BUN n = BATcount(b);
	BAT *bn = *ret = BATnew(TYPE_lng, TYPE_void, n);
	BATiter bni = bat_iterator(bn), bi = bat_iterator(b);
	BUN p, q;
	lng *r = (lng *) BUNhead(bni, BUNfirst(bn));

	BATaccessBegin(b,USE_HEAD|USE_TAIL,MMAP_SEQUENTIAL);
	BATloop(b, p, q) {
		oid hp = *(oid *) BUNhead(bi, p);
		oid tp = *(oid *) BUNtail(bi, p);

		*r++ = (((lng) hp) << 32) + tp;
	}
	BATaccessEnd(b,USE_HEAD|USE_TAIL,MMAP_SEQUENTIAL);
	BATsetcount(bn, p);
	if (!bn->batDirty)
		bn->batDirty = TRUE;

	bn->hsorted = ( BAThordered(b)&1 && (BATtordered(b)&1 || BAThkey(b))) 
		? GDK_SORTED : FALSE ;
	bn->tsorted = FALSE ;
	bn->tdense = FALSE ;
	BATkey(bn, BAThkey(b) || BATtkey(b)) ;
	BATkey(BATmirror(bn), FALSE) ;

	return GDK_SUCCEED;
}

int
CMDsplit(BAT **ret, BAT *b)
{
	BATiter bi = bat_iterator(b);
	BUN n = BATcount(b);
	BAT *bn = *ret = BATnew(TYPE_oid, TYPE_oid, n);
	BUN i;
	lng *r = (lng *) BUNhead(bi, BUNfirst(b));

	BATaccessBegin(b,USE_HEAD,MMAP_SEQUENTIAL);
	for (i = 0; i < n; i++, r++) {
		oid hp = (int) (*r >> 32);
		oid tp = (int) *r;

		bunfastins(bn, &hp, &tp);
	}
	BATaccessEnd(b,USE_HEAD,MMAP_SEQUENTIAL);

	bn->hsorted = BAThordered(b)&1 ? GDK_SORTED : FALSE ;
	bn->tsorted = FALSE ;
	bn->hdense = FALSE ;
	bn->tdense = FALSE ;
	bn->H->nonil = FALSE ;
	bn->T->nonil = FALSE ;
	BATkey(bn, FALSE) ;
	BATkey(BATmirror(bn), FALSE) ;

	return GDK_SUCCEED;
bunins_failed:
	BATaccessEnd(b,USE_HEAD,MMAP_SEQUENTIAL);
	BBPreclaim(bn);
	return GDK_FAIL;
}

@- Wrapper
The remainder of this file contains the wrapper around the V4 code base
The BAT identifiers passed through this module may indicate
that the 'reverse' view applies. This should be taken into
account while resolving them.
@+ BAT sum and product aggregation 
The sum aggregate only works for int and float fields.
The routines below assumes that the caller knows what type
is large enough to prevent overflow.

@= ALGsum_implementation
str ALGsum_@1_@2(@2* res, int *bid, bit *empty_is_nil) {
	BAT *b;
	if( (b= BATdescriptor(*bid)) == NULL ){
		 throw(MAL, "algebra.sum", RUNTIME_OBJECT_MISSING);
	}

	CMDsum_@1_@2(res, b, empty_is_nil);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}

@= ALGprod_implementation
str ALGprod_@1_@2(@2* res, int *bid, bit *empty_is_nil) {
	BAT *b;
	if( (b= BATdescriptor(*bid)) == NULL ){
		 throw(MAL, "algebra.prod", RUNTIME_OBJECT_MISSING);
	}
	CMDprod_@1_@2(res, b, empty_is_nil);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}
@c
@:ALGsum_implementation(bte,bte,0)@
@:ALGsum_implementation(bte,sht,0)@
@:ALGsum_implementation(bte,int,0)@
@:ALGsum_implementation(bte,wrd,0)@
@:ALGsum_implementation(bte,lng,0)@
@:ALGsum_implementation(sht,sht,0)@
@:ALGsum_implementation(sht,int,0)@
@:ALGsum_implementation(sht,wrd,0)@
@:ALGsum_implementation(sht,lng,0)@
@:ALGsum_implementation(int,int,0)@
@:ALGsum_implementation(int,wrd,0)@
@:ALGsum_implementation(int,lng,0)@
@:ALGsum_implementation(wrd,wrd,0)@
@:ALGsum_implementation(wrd,lng,0)@
@:ALGsum_implementation(lng,lng,0)@
@:ALGsum_implementation(flt,flt,0.0)@
@:ALGsum_implementation(flt,dbl,0.0)@
@:ALGsum_implementation(dbl,dbl,0.0)@

@:ALGsum_implementation(bte,dbl,0.0)@
@:ALGsum_implementation(sht,dbl,0.0)@
@:ALGsum_implementation(int,dbl,0.0)@
@:ALGsum_implementation(wrd,dbl,0.0)@
@:ALGsum_implementation(lng,dbl,0.0)@

@:ALGprod_implementation(bte,bte,1)@
@:ALGprod_implementation(bte,sht,1)@
@:ALGprod_implementation(bte,int,1)@
@:ALGprod_implementation(bte,wrd,1)@
@:ALGprod_implementation(bte,lng,1)@
@:ALGprod_implementation(sht,sht,1)@
@:ALGprod_implementation(sht,int,1)@
@:ALGprod_implementation(sht,wrd,1)@
@:ALGprod_implementation(sht,lng,1)@
@:ALGprod_implementation(int,int,1)@
@:ALGprod_implementation(int,wrd,1)@
@:ALGprod_implementation(int,lng,1)@
@:ALGprod_implementation(wrd,wrd,1)@
@:ALGprod_implementation(wrd,lng,1)@
@:ALGprod_implementation(lng,lng,1)@
@:ALGprod_implementation(flt,flt,1.0)@
@:ALGprod_implementation(flt,dbl,1.0)@
@:ALGprod_implementation(dbl,dbl,1.0)@

@:ALGprod_implementation(bte,dbl,0.0)@
@:ALGprod_implementation(sht,dbl,0.0)@
@:ALGprod_implementation(int,dbl,0.0)@
@:ALGprod_implementation(wrd,dbl,0.0)@
@:ALGprod_implementation(lng,dbl,0.0)@


@-
@= ALGaggregate_implementation
str ALGmin_@1(@1* res, int *bid) {
	BAT *b;
	if( (b= BATdescriptor(*bid)) == NULL ){
		 throw(MAL, "algebra.min", RUNTIME_OBJECT_MISSING);
	}
	if( CMDmin_@1(res,b)) {
		BBPreleaseref(b->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(b->batCacheid);
	throw(MAL, "algebra.min", GDK_EXCEPTION);
}
str ALGmax_@1(@1* res, int *bid) {
	BAT *b;
	if( (b= BATdescriptor(*bid)) == NULL ){
		 throw(MAL, "algebra.min", RUNTIME_OBJECT_MISSING);
	}
	if( CMDmax_@1(res,b)) {
		BBPreleaseref(b->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(b->batCacheid);
	throw(MAL, "algebra.max", GDK_EXCEPTION);
}
@c
@:ALGaggregate_implementation(bte)@
@:ALGaggregate_implementation(sht)@
@:ALGaggregate_implementation(int)@
@:ALGaggregate_implementation(wrd)@
@:ALGaggregate_implementation(lng)@
@:ALGaggregate_implementation(flt)@
@:ALGaggregate_implementation(dbl)@


@c
str
ALGminany(ptr result, int *bid)
{
	BAT *b;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "algebra.min", RUNTIME_OBJECT_MISSING);
	}
	if (CMDminany(result, b) == GDK_SUCCEED) {
		BBPreleaseref(b->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(b->batCacheid);
	throw(MAL, "algebra.min", GDK_EXCEPTION);
}

str
ALGmaxany(ptr result, int *bid)
{
	BAT *b;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "algebra.min", RUNTIME_OBJECT_MISSING);
	}
	if (CMDmaxany(result, b) == GDK_SUCCEED) {
		BBPreleaseref(b->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(b->batCacheid);
	throw(MAL, "algebra.max", GDK_EXCEPTION);
}


str
ALGtopN(int *res, int *bid, lng *top)
{
	BAT *b;

	b = BATdescriptor(*bid);
	if (b == NULL) {
		throw(MAL, "algebra.top", RUNTIME_OBJECT_MISSING);
	}
	/* TOP N works inplace, ie deletes ... */
	(void) BATtopN(b, (BUN) *top);
	*res = b->batCacheid;
	BBPkeepref(b->batCacheid);
	return MAL_SUCCEED;
}

str
ALGgroupby(int *res, int *bid)
{
	BAT *b,*bn;

	b = BATdescriptor(*bid);
	if (b == NULL) {
		throw(MAL, "algebra.groupby", RUNTIME_OBJECT_MISSING);
	}
	if( CMDgen_group(&bn,b) == GDK_FAIL){
		BBPreleaseref(b->batCacheid);
		throw(MAL, "algebra.groupby",GDK_EXCEPTION);
	}
	if( bn){
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
		*res = bn->batCacheid;
		BBPkeepref(bn->batCacheid);
	}
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}

str
ALGcard(lng *result, int *bid)
{
	BAT *b, *bn;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "algebra.card", RUNTIME_OBJECT_MISSING);
	}
	bn = (BAT *) BATkunique(BATmirror(b));
	if (bn == NULL) {
		throw(MAL, "algebra.card", GDK_EXCEPTION);
	}
	*result = BATcount(bn);
	BBPunfix(bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}

str
ALGBATminimum(ptr *result, int *bid)
{
	BAT *b;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "algebra.min", RUNTIME_OBJECT_MISSING);
	}
	BATmin(b, result);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}

str
ALGBATmaximum(ptr *result, int *bid)
{
	BAT *b;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "algebra.max", RUNTIME_OBJECT_MISSING);
	}
	BATmax(b, result);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}

str
ALGselect1(int *result, int *bid, ptr value)
{
	BAT *b, *bn = NULL;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "algebra.select", RUNTIME_OBJECT_MISSING);
	}
	@:derefStr(b,t,value)@
	CMDselect1(&bn, b, value);
	BBPreleaseref(b->batCacheid);
	if (bn) {
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
		*result = bn->batCacheid;
		BBPkeepref(*result);
		return MAL_SUCCEED;
	}
	throw(MAL, "algebra.select", GDK_EXCEPTION);
}

str
ALGselect1Head(int *result, int *bid, ptr value)
{
	BAT *b, *bn = NULL;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "algebra.select", RUNTIME_OBJECT_MISSING);
	}
	b = BATmirror(b);
	@:derefStr(b,t,value)@
	CMDselect1(&bn, b, value);
	bn = BATmirror(bn);
	BBPreleaseref(b->batCacheid);
	if (bn) {
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
		*result = bn->batCacheid;
		BBPkeepref(*result);
		return MAL_SUCCEED;
	}
	throw(MAL, "algebra.select", GDK_EXCEPTION);
}

str
ALGuselect1(int *result, int *bid, ptr value)
{
	BAT *b, *bn = NULL;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "algebra.uselect", RUNTIME_OBJECT_MISSING);
	}
	@:derefStr(b,t,value)@
	CMDuselect1(&bn, b, value);
	BBPreleaseref(b->batCacheid);
	if (bn) {
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
		*result = bn->batCacheid;
		BBPkeepref(*result);
		return MAL_SUCCEED;
	}
	throw(MAL, "algebra.uselect", GDK_EXCEPTION);
}

str
ALGantiuselect1(int *result, int *bid, ptr value)
{
	BAT *b, *bn = NULL;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "algebra.antiuselect", RUNTIME_OBJECT_MISSING);
	}
	@:derefStr(b,t,value)@
	CMDantiuselect1(&bn, b, value);
	BBPreleaseref(b->batCacheid);
	if (bn) {
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
		*result = bn->batCacheid;
		BBPkeepref(*result);
		return MAL_SUCCEED;
	}
	throw(MAL, "algebra.antiuselect", GDK_EXCEPTION);
}

str
ALGselect(int *result, int *bid, ptr low, ptr high)
{
	BAT *b, *bn = NULL;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "algebra.select", RUNTIME_OBJECT_MISSING);
	}
	@:derefStr(b,t,low)@
	@:derefStr(b,t,high)@
	CMDselect(&bn, b, low, high);
	BBPreleaseref(b->batCacheid);
	if (bn) {
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
		*result = bn->batCacheid;
		BBPkeepref(*result);
		return MAL_SUCCEED;
	}
	throw(MAL, "algebra.select", GDK_EXCEPTION);
}

str
ALGthetaselect(int *result, int *bid, ptr val, str *OP)
{
	ptr nilptr;
	BAT *b, *bn = NULL;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "algebra.thetaselect", RUNTIME_OBJECT_MISSING);
	}
	nilptr = ATOMnilptr(b->ttype);
	@:derefStr(b,t,val);@
	if (ATOMcmp(b->ttype, val, nilptr) == 0) {
		bn = BATnew(b->htype,b->ttype, 0);
	} else {
		char *op = *OP; 
		bit lin = TRUE, rin = TRUE;
		ptr low = nilptr, high = nilptr;
	
		if (op[0] == '=') {
			low = val; 
			high = val;
		} else if (op[0] == '<') {
			high = val;
			rin = (op[1] == '=');
		} else if (op[0] == '>') {
			low = val;
			lin = (op[1] == '=');
		} else {
			BBPreleaseref(b->batCacheid);
			throw(MAL, "algebra.thetaselect", ILLEGAL_ARGUMENT " Unknown operator");
		}
		CMDselect_(&bn, b, low, high, &lin, &rin);
	}
	if (bn) {
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
		*result = bn->batCacheid;
		BBPkeepref(*result);
		BBPreleaseref(b->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(b->batCacheid);
	throw(MAL, "algebra.thetaselect", GDK_EXCEPTION);
}

str
ALGselectNotNil(int *result, int *bid)
{
	BAT *b, *bn = NULL;
	ptr low,high;
	bit bound=FALSE;

	if ((b = BATdescriptor(*bid)) == NULL) 
		throw(MAL, "algebra.selectNotNil", RUNTIME_OBJECT_MISSING);

	if( BATcount_no_nil(b) != BATcount(b) ){
		low=high= ATOMnilptr(b->ttype);
		CMDselect_(&bn, b, low, high, &bound, &bound);
		if (bn) {
			if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
			*result = bn->batCacheid;
			BBPkeepref(*result);
			BBPreleaseref(b->batCacheid);
			return MAL_SUCCEED;
		}
		BBPreleaseref(b->batCacheid);
		throw(MAL, "algebra.select", GDK_EXCEPTION);
	}
	/* just pass on the result */
	*result = b->batCacheid;
	BBPkeepref(*result);
	return MAL_SUCCEED;
}

str
ALGselectHead(int *result, int *bid, ptr low, ptr high)
{
	BAT *b, *bn = NULL;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "algebra.select", RUNTIME_OBJECT_MISSING);
	}
	b = BATmirror(b);
	@:derefStr(b,t,low)@
	@:derefStr(b,t,high)@
	CMDselect(&bn, b, low, high);
	bn = BATmirror(bn);
	if (bn) {
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
		*result = bn->batCacheid;
		BBPkeepref(*result);
		BBPreleaseref(b->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(b->batCacheid);
	throw(MAL, "algebra.select", GDK_EXCEPTION);
}

str
ALGuselect(int *result, int *bid, ptr low, ptr high)
{
	BAT *b, *bn = NULL;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "algebra.uselect", RUNTIME_OBJECT_MISSING);
	}
	@:derefStr(b,t,low);@
	@:derefStr(b,t,high);@
	CMDuselect(&bn, b, low, high);
	if (bn) {
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
		*result = bn->batCacheid;
		BBPkeepref(*result);
		BBPreleaseref(b->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(b->batCacheid);
	throw(MAL, "algebra.uselect", GDK_EXCEPTION);
}

str
ALGthetauselect(int *result, int *bid, ptr val, str *OP)
{
	ptr nilptr;
	BAT *b, *bn = NULL;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "algebra.thetauselect", RUNTIME_OBJECT_MISSING);
	}
	nilptr = ATOMnilptr(b->ttype);
	@:derefStr(b,t,val);@
	if (ATOMcmp(b->ttype, val, nilptr) == 0) {
		bn = BATnew(b->htype,TYPE_void, 0);
	} else {
		char *op = *OP; 
		bit lin = TRUE, rin = TRUE;
		ptr low = nilptr, high = nilptr;
	
		if (op[0] == '=') {
			low = val; 
			high = val;
		} else if (op[0] == '<') {
			high = val;
			rin = (op[1] == '=');
		} else if (op[0] == '>') {
			low = val;
			lin = (op[1] == '=');
		} else {
			BBPreleaseref(b->batCacheid);
			throw(MAL, "algebra.thetauselect", ILLEGAL_ARGUMENT " Unknown operator");
		}
		CMDuselect_(&bn, b, low, high, &lin, &rin);
	}
	if (bn) {
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
		*result = bn->batCacheid;
		BBPkeepref(*result);
		BBPreleaseref(b->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(b->batCacheid);
	throw(MAL, "algebra.thetauselect", GDK_EXCEPTION);
}

str
ALGselectInclusive(int *result, int *bid, ptr low, ptr high, bit *lin, bit *rin)
{
	BAT *b, *bn = NULL;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "algebra.select", RUNTIME_OBJECT_MISSING);
	}
	@:derefStr(b,t,low)@
	@:derefStr(b,t,high)@
	CMDselect_(&bn, b, low, high, lin, rin);
	if (bn) {
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
		*result = bn->batCacheid;
		BBPkeepref(*result);
		BBPreleaseref(b->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(b->batCacheid);
	throw(MAL, "algebra.select", GDK_EXCEPTION);
}

str
ALGselectInclusiveHead(int *result, int *bid, ptr low, ptr high, bit *lin, bit *rin)
{
	BAT *b, *bn = NULL;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "algebra.select", RUNTIME_OBJECT_MISSING);
	}
	b = BATmirror(b);
	@:derefStr(b,t,low)@
	@:derefStr(b,t,high)@
	CMDselect_(&bn, b, low, high, lin, rin);
	bn = BATmirror(bn);
	if (bn) {
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
		*result = bn->batCacheid;
		BBPkeepref(*result);
		BBPreleaseref(b->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(b->batCacheid);
	throw(MAL, "algebra.select", GDK_EXCEPTION);
}

str
ALGuselectInclusive(int *result, int *bid, ptr low, ptr high, bit *lin, bit *rin)
{
	BAT *b, *bn = NULL;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "algebra.select", RUNTIME_OBJECT_MISSING);
	}
	@:derefStr(b,t,low);@
	@:derefStr(b,t,high);@
	CMDuselect_(&bn, b, low, high, lin, rin);
	if (bn) {
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
		*result = bn->batCacheid;
		BBPkeepref(*result);
		BBPreleaseref(b->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(b->batCacheid);
	throw(MAL, "algebra.uselect", GDK_EXCEPTION);
}

str
ALGantiuselectInclusive(int *result, int *bid, ptr low, ptr high, bit *lin, bit *rin)
{
	BAT *b, *bn = NULL;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "algebra.select", RUNTIME_OBJECT_MISSING);
	}
	@:derefStr(b,t,low);@
	@:derefStr(b,t,high);@
	CMDantiuselect_(&bn, b, low, high, lin, rin);
	if (bn) {
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
		*result = bn->batCacheid;
		BBPkeepref(*result);
		BBPreleaseref(b->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(b->batCacheid);
	throw(MAL, "algebra.uselect", GDK_EXCEPTION);
}

str
ALGfragment(int *result, int *bid, ptr hlow, ptr hhigh, ptr tlow, ptr thigh)
{
	BAT *b, *bn = NULL;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "algebra.fragment", RUNTIME_OBJECT_MISSING);
	}
	@:derefStr(b,h,hlow);@
	@:derefStr(b,h,hhigh);@
	@:derefStr(b,t,tlow);@
	@:derefStr(b,t,thigh);@
	CMDfragment(&bn, b, hlow, hhigh, tlow, thigh);
	if (bn) {
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
		*result = bn->batCacheid;
		BBPkeepref(*result);
		BBPreleaseref(b->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(b->batCacheid);
	throw(MAL, "algebra.fragment", GDK_EXCEPTION);
}

str
ALGthetajoinEstimate(int *result, int *lid, int *rid, int *opc, lng *estimate)
{
	BAT *left, *right, *bn = NULL;

	if ((left = BATdescriptor(*lid)) == NULL) {
		throw(MAL, "algebra.thetajoin", RUNTIME_OBJECT_MISSING);
	}
	if ((right = BATdescriptor(*rid)) == NULL) {
		BBPreleaseref(left->batCacheid);
		throw(MAL, "algebra.thetajoin", RUNTIME_OBJECT_MISSING);
	}
	if( *opc == -3 ){
		/* The NE case is not supported in the kernel */
		BBPreleaseref(left->batCacheid);
		BBPreleaseref(right->batCacheid);
		throw(MAL, "algebra.thetajoin", ILLEGAL_ARGUMENT " Theta comparison <> not yet supported");
	} 
	CMDthetajoin(&bn, left, right, opc, estimate);
	if (bn) {
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
		*result = bn->batCacheid;
		BBPkeepref(*result);
		BBPreleaseref(left->batCacheid);
		BBPreleaseref(right->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(left->batCacheid);
	BBPreleaseref(right->batCacheid);
	throw(MAL, "algebra.thetajoin", GDK_EXCEPTION);
}

str
ALGthetajoin(int *result, int *lid, int *rid, int *opc)
{
	return ALGthetajoinEstimate(result, lid, rid, opc, (ptr)&lng_nil);
}

str
ALGbandjoin(int *result, int *lid, int *rid, ptr *minus, ptr *plus, bit *li, bit *hi)
{
	BAT *left, *right, *bn = NULL;

	if ((left = BATdescriptor(*lid)) == NULL) {
		throw(MAL, "algebra.bandjoin", RUNTIME_OBJECT_MISSING);
	}
	if ((right = BATdescriptor(*rid)) == NULL) {
		BBPreleaseref(left->batCacheid);
		throw(MAL, "algebra.bandjoin", RUNTIME_OBJECT_MISSING);
	}
	CMDbandjoin(&bn, left, right, minus, plus, li, hi);
	if (bn) {
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
		*result = bn->batCacheid;
		BBPkeepref(*result);
		BBPreleaseref(left->batCacheid);
		BBPreleaseref(right->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(left->batCacheid);
	BBPreleaseref(right->batCacheid);
	throw(MAL, "algebra.bandjoin", GDK_EXCEPTION);
}

str
ALGbandjoin_default(int *result, int *lid, int *rid, ptr *minus, ptr *plus)
{
	bit li = TRUE;
	bit hi = TRUE;
	return ALGbandjoin(result, lid, rid, minus, plus, &li, &hi);
}

str 
ALGrangejoin(int *result, int *lid, int *rlid, int *rhid, bit *li, bit *hi)
{
	BAT *left, *rightl, *righth, *bn = NULL;

	if ((left = BATdescriptor(*lid)) == NULL) {
		throw(MAL, "algebra.rangejoin", RUNTIME_OBJECT_MISSING);
	}
	if ((rightl = BATdescriptor(*rlid)) == NULL) {
		BBPreleaseref(left->batCacheid);
		throw(MAL, "algebra.rangejoin", RUNTIME_OBJECT_MISSING);
	}
	if ((righth = BATdescriptor(*rhid)) == NULL) {
		BBPreleaseref(left->batCacheid);
		BBPreleaseref(rightl->batCacheid);
		throw(MAL, "algebra.rangejoin", RUNTIME_OBJECT_MISSING);
	}
	bn = BATrangejoin(left, rightl, righth, *li, *hi);
	if (bn) {
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
		*result = bn->batCacheid;
		BBPkeepref(*result);
		BBPreleaseref(left->batCacheid);
		BBPreleaseref(rightl->batCacheid);
		BBPreleaseref(righth->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(left->batCacheid);
	BBPreleaseref(rightl->batCacheid);
	BBPreleaseref(righth->batCacheid);
	throw(MAL, "algebra.rangejoin", GDK_EXCEPTION);
}

@-
Let cut this text down with some Mx macro's
@= ALGunary
str ALG@1(int *result, int *bid) {
	BAT *b,*bn;
	if( (b= BATdescriptor(*bid)) == NULL ){
		throw(MAL, "algebra.@1", RUNTIME_OBJECT_MISSING);
	}
	CMD@1(&bn,b);
	if( bn ) {
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
		*result = bn->batCacheid;
		BBPkeepref(*result);
		BBPreleaseref(b->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(b->batCacheid);
	throw(MAL, "algebra.@1", GDK_EXCEPTION);
}
@= ALGunaryint
str ALG@1(int *result, int *bid) {
	BAT *b,*bn= NULL;
	if( (b= BATdescriptor(*bid)) == NULL ){
		throw(MAL, "algebra.@1", RUNTIME_OBJECT_MISSING);
	}
	CMD@1(&bn,b);
	if( bn ) {
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
		*result = bn->batCacheid;
		BBPkeepref(*result);
		BBPreleaseref(b->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}
@= ALGbinary
str ALG@1(int *result, int *lid, int *rid) {
	BAT *left, *right,*bn= NULL;
	if( (left= BATdescriptor(*lid)) == NULL ){
		throw(MAL, "algebra.@1", RUNTIME_OBJECT_MISSING);
	}
	if( (right= BATdescriptor(*rid)) == NULL ){
		BBPreleaseref(left->batCacheid);
		throw(MAL, "algebra.@1", RUNTIME_OBJECT_MISSING);
	}
	if( CMD@1(&bn,left, right) == GDK_FAIL){
		BBPreleaseref(left->batCacheid);
		BBPreleaseref(right->batCacheid);
		if( bn) BBPunfix(bn->batCacheid);
		throw(MAL, "algebra.@1", GDK_EXCEPTION);
	}
	if( bn ) {
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
		*result = bn->batCacheid;
		BBPkeepref(*result);
		BBPreleaseref(left->batCacheid);
		BBPreleaseref(right->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(left->batCacheid);
	BBPreleaseref(right->batCacheid);
	throw(MAL, "algebra.@1", GDK_EXCEPTION);
}
@= ALGbinaryint
str ALG@1(int *result, int* bid, int *param) {
	BAT *b, *bn= NULL;
	if( (b= BATdescriptor(*bid)) == NULL ){
		throw(MAL, "algebra.@1", RUNTIME_OBJECT_MISSING);
	}
	CMD@1(&bn,b, param);
	if( bn ) {
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
		*result = bn->batCacheid;
		BBPkeepref(*result);
		BBPreleaseref(b->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(b->batCacheid);
	throw(MAL, "algebra.@1", GDK_EXCEPTION);
}
@= ALGbinaryestimate
str ALG@1estimate(int *result, int *lid, int *rid, lng *estimate) {
	BAT *left, *right,*bn=NULL;
	if( (left= BATdescriptor(*lid)) == NULL ){
		throw(MAL, "algebra.@1", RUNTIME_OBJECT_MISSING);
	}
	if( (right= BATdescriptor(*rid)) == NULL ){
		BBPreleaseref(left->batCacheid);
		throw(MAL, "algebra.@1", RUNTIME_OBJECT_MISSING);
	}
	if( CMD@1(&bn,left, right, estimate) == GDK_FAIL){
		BBPreleaseref(left->batCacheid);
		BBPreleaseref(right->batCacheid);
		if( bn) BBPunfix(bn->batCacheid);
		throw(MAL, "algebra.@1", GDK_EXCEPTION);
	}
	if( bn ) {
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
		*result = bn->batCacheid;
		BBPkeepref(*result);
		BBPreleaseref(left->batCacheid);
		BBPreleaseref(right->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(left->batCacheid);
	BBPreleaseref(right->batCacheid);
	throw(MAL, "algebra.@1", GDK_EXCEPTION);
}
str ALG@1(int *result, int* lid, int *rid) {
	lng estimate= lng_nil;
	return ALG@1estimate(result,lid,rid,&estimate);
}
@c
@:ALGunary(histogram)@
@:ALGunary(number)@
@:ALGunary(merge)@
@:ALGunary(split)@
@:ALGunary(copy)@
@:ALGunary(kunique)@
@:ALGunary(sunique)@
@:ALGbinary(cross)@
@:ALGbinary(antijoin)@
@:ALGbinaryestimate(join)@
@:ALGbinaryestimate(fetchjoin)@
@:ALGbinaryestimate(leftjoin)@
@:ALGbinaryestimate(leftfetchjoin)@
@:ALGbinaryestimate(outerjoin)@
@:ALGbinary(semijoin)@
@:ALGbinary(sunion)@
@:ALGbinary(kunion)@
@:ALGbinary(sintersect)@
@:ALGbinary(kintersect)@
@:ALGbinary(sdiff)@
@:ALGbinary(kdiff)@
@:ALGbinaryint(sample)@

/* add item missing in the kernel */
str
ALGtunique(int *result, int *bid)
{
	BAT *b, *bn;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "algebra.tunique", RUNTIME_OBJECT_MISSING);
	}
	CMDkunique(&bn, BATmirror(b));
	if (bn) {
		bn = BATmirror(bn);
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
		*result = bn->batCacheid;
		BBPkeepref(*result);
		BBPreleaseref(b->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(b->batCacheid);
	throw(MAL, "algebra.tunique", GDK_EXCEPTION);
}

str
ALGtsort(int *result, int *bid)
{
	BAT *b, *bn;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "algebra.tsort", RUNTIME_OBJECT_MISSING);
	}
	CMDsort(&bn, BATmirror(b));
	if (bn) {
		bn = BATmirror(bn);
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
		*result = bn->batCacheid;
		BBPkeepref(*result);
		BBPreleaseref(b->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(b->batCacheid);
	throw(MAL, "algebra.tsort", GDK_EXCEPTION);
}

str
ALGtsort_rev(int *result, int *bid)
{
	BAT *b, *bn;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "algebra.tsort", RUNTIME_OBJECT_MISSING);
	}
	CMDsort_rev(&bn, BATmirror(b));
	if (bn) {
		bn = BATmirror(bn);
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
		*result = bn->batCacheid;
		BBPkeepref(*result);
		BBPreleaseref(b->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(b->batCacheid);
	throw(MAL, "algebra.tsort", GDK_EXCEPTION);
}

str
ALGhsort(int *result, int *bid)
{
	BAT *b, *bn;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "algebra.hsort", RUNTIME_OBJECT_MISSING);
	}
	CMDsort(&bn, b);
	if (bn) {
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
		*result = bn->batCacheid;
		BBPkeepref(*result);
		BBPreleaseref(b->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(b->batCacheid);
	throw(MAL, "algebra.hsort", GDK_EXCEPTION);
}

str
ALGhsort_rev(int *result, int *bid)
{
	BAT *b, *bn;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "algebra.tsort", RUNTIME_OBJECT_MISSING);
	}
	CMDsort_rev(&bn, b);
	if (bn) {
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
		*result = bn->batCacheid;
		BBPkeepref(*result);
		BBPreleaseref(b->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(b->batCacheid);
	throw(MAL, "algebra.tsort", GDK_EXCEPTION);
}
str
ALGhtsort(int *result, int *lid)
{
	BAT *b, *bm = NULL, *bn = NULL;

	if ((b = BATdescriptor(*lid)) == NULL) {
		throw(MAL, "algebra.htsort", RUNTIME_OBJECT_MISSING);
	}
	CMDtsort(&bm, b);
	if (bm) {
		CMDssort(&bn, bm);
		if (bn) {
			if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
			*result = bn->batCacheid;
			BBPkeepref(*result);
			BBPunfix(bm->batCacheid);
			BBPreleaseref(b->batCacheid);
			return MAL_SUCCEED;
		}
		BBPunfix(bm->batCacheid);
		BBPreleaseref(b->batCacheid);
		throw(MAL, "algebra.htsort", GDK_EXCEPTION);
	}
	BBPreleaseref(b->batCacheid);
	throw(MAL, "algebra.htsort", GDK_EXCEPTION);
}

str
ALGthsort(int *result, int *lid)
{
	BAT *b, *bm = NULL, *bn = NULL;

	if ((b = BATdescriptor(*lid)) == NULL) {
		throw(MAL, "algebra.thsort", RUNTIME_OBJECT_MISSING);
	}
	CMDtsort(&bm, BATmirror(b));
	if (bm) {
		CMDssort(&bn, bm);
		if (bn) {
			bn = BATmirror(bn);
			if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
			*result = bn->batCacheid;
			BBPkeepref(*result);
			BBPunfix(bm->batCacheid);
			BBPreleaseref(b->batCacheid);
			return MAL_SUCCEED;
		}
		BBPunfix(bm->batCacheid);
		BBPreleaseref(b->batCacheid);
		throw(MAL, "algebra.thsort", GDK_EXCEPTION);
	}
	BBPreleaseref(b->batCacheid);
	throw(MAL, "algebra.thsort", GDK_EXCEPTION);
}

str
ALGssort(int *result, int *bid)
{
	BAT *b, *bn;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "algebra.ssort", RUNTIME_OBJECT_MISSING);
	}
	CMDssort(&bn, b);
	if (bn) {
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
		*result = bn->batCacheid;
		BBPkeepref(*result);
		BBPreleaseref(b->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(b->batCacheid);
	throw(MAL, "algebra.ssort", GDK_EXCEPTION);
}

str
ALGssort_rev(int *result, int *bid)
{
	BAT *b, *bn;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "algebra.ssort_rev", RUNTIME_OBJECT_MISSING);
	}
	CMDssort_rev(&bn, b);
	if (bn) {
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
		*result = bn->batCacheid;
		BBPkeepref(*result);
		BBPreleaseref(b->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(b->batCacheid);
	throw(MAL, "algebra.ssort_rev", GDK_EXCEPTION);
}

str
ALGrevert(int *result, int *bid)
{
	BAT *b, *bn;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "algebra.revert", RUNTIME_OBJECT_MISSING);
	}
	bn = BATcopy(b, b->htype, b->ttype, TRUE);
	BATrevert(bn);
	*result= bn->batCacheid;
	BBPkeepref(bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}

str
ALGcount_bat(wrd *result, int *bid)
{
	BAT *b;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "aggr.count", RUNTIME_OBJECT_MISSING);
	}
	*result = (wrd) BATcount(b);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}

str
ALGcount_nil(wrd *result, int *bid, bit *ignore_nils)
{
	BAT *b;
	BUN cnt;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "aggr.count", RUNTIME_OBJECT_MISSING);
	}
	if (*ignore_nils)
		cnt = BATcount_no_nil(b);
	else
		cnt = BATcount(b);
	*result = (wrd) cnt;
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}

str
ALGcount_no_nil(wrd *result, int *bid)
{
	bit ignore_nils = 1;

	return ALGcount_nil(result, bid, &ignore_nils);
}

str
ALGtmark(int *result, int *bid, oid *base)
{
	BAT *b, *bn = NULL;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "algebra.markT", RUNTIME_OBJECT_MISSING);
	}
	if (CMDmark(&bn, b, base) == GDK_SUCCEED) {
		BBPreleaseref(b->batCacheid);
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
		*result = bn->batCacheid;
		BBPkeepref(*result);
		return MAL_SUCCEED;
	}
	BBPreleaseref(b->batCacheid);
	throw(MAL, "algebra.markT", GDK_EXCEPTION);
}

str
ALGtmark_default(int *result, int *bid)
{
	oid o = 0;

	return ALGtmark(result, bid, &o);
}

str 
ALGtmarkp(int *result, int *bid, int *nr_parts, int *part_nr)
{
#if SIZEOF_OID == 4
	int bits = 31;
#else
	int bits = 63;
#endif
	oid base = 0;
	
	assert(*part_nr < *nr_parts);
	base = ((oid)1)<<bits;
	base /= *nr_parts;
	base *= *part_nr;
	return ALGtmark(result, bid, &base);
}

str
ALGmarkHead(int *result, int *bid, oid *base)
{
	BAT *b, *bn = NULL;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "algebra.markH", RUNTIME_OBJECT_MISSING);
	}
	/* M5's markH is semantically identical with M4/GDK's tmark */
	/* (Don't ask me why; wasn't my decision. Stefan.) */
	if (CMDtmark(&bn, b, base) == GDK_SUCCEED) {
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
		*result = bn->batCacheid;
		BBPkeepref(*result);
		BBPreleaseref(b->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(b->batCacheid);
	throw(MAL, "algebra.markH", GDK_EXCEPTION);
}

str
ALGmarkHead_default(int *result, int *bid)
{
	oid o = 0;

	return ALGmarkHead(result, bid, &o);
}

str 
ALGhmarkp(int *result, int *bid, int *nr_parts, int *part_nr)
{
#if SIZEOF_OID == 4
	int bits = 31;
#else
	int bits = 63;
#endif
	oid base = 0;
	
	assert(*part_nr < *nr_parts);
	base = ((oid)1)<<bits;
	base /= *nr_parts;
	base *= *part_nr;
	return ALGmarkHead(result, bid, &base);
}

str 
ALGmark_grp_1(int *result, int *bid, int *gid)
{
	BAT *g, *b, *bn = NULL;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "algebra.mark_grp", RUNTIME_OBJECT_MISSING);
	}
	if ((g = BATdescriptor(*gid)) == NULL) {
		BBPreleaseref(b->batCacheid);
		throw(MAL, "algebra.mark_grp", RUNTIME_OBJECT_MISSING);
	}
	if (CMDmark_grp_1(&bn, b, g) == GDK_SUCCEED) {
		BBPreleaseref(b->batCacheid);
		BBPreleaseref(g->batCacheid);
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
		*result = bn->batCacheid;
		BBPkeepref(*result);
		return MAL_SUCCEED;
	}
	BBPreleaseref(b->batCacheid);
	BBPreleaseref(g->batCacheid);
	throw(MAL, "algebra.mark_grp", GDK_EXCEPTION);
}

str 
ALGmark_grp_2(int *result, int *bid, int *gid, oid *base)
{
	BAT *g, *b, *bn = NULL;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "algebra.mark_grp", RUNTIME_OBJECT_MISSING);
	}
	if ((g = BATdescriptor(*gid)) == NULL) {
		BBPreleaseref(b->batCacheid);
		throw(MAL, "algebra.mark_grp", RUNTIME_OBJECT_MISSING);
	}
	if (CMDmark_grp_2(&bn, b, g, base) == GDK_SUCCEED) {
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
		*result = bn->batCacheid;
		BBPkeepref(*result);
		BBPreleaseref(b->batCacheid);
		BBPreleaseref(g->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(b->batCacheid);
	BBPreleaseref(g->batCacheid);
	throw(MAL, "algebra.mark_grp", GDK_EXCEPTION);
}

str
ALGhashsplit(int *result, int *bid, int *nfrag)
{
	BAT *b, *bn = NULL;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "algebra.hashsplit", RUNTIME_OBJECT_MISSING);
	}
	CMDhashsplit(&bn, b, nfrag);
	if (bn) {
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
		*result = bn->batCacheid;
		BBPkeepref(*result);
		BBPreleaseref(b->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(b->batCacheid);
	throw(MAL, "algebra.hashsplit", GDK_EXCEPTION);
}

str
ALGuhashsplit(int *result, int *bid, int *nfrag)
{
	BAT *b, *bn = NULL;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "algebra.uhashsplit", RUNTIME_OBJECT_MISSING);
	}
	CMDuhashsplit(&bn, b, nfrag);
	if (bn) {
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
		*result = bn->batCacheid;
		BBPkeepref(*result);
		BBPreleaseref(b->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(b->batCacheid);
	throw(MAL, "algebra.uhashsplit", GDK_EXCEPTION);
}

str
ALGrangesplit(int *result, int *bid, int *nfrag)
{
	BAT *b, *bn = NULL;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "algebra.rangesplit", RUNTIME_OBJECT_MISSING);
	}
	CMDrangesplit(&bn, b, nfrag);
	if (bn) {
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
		*result = bn->batCacheid;
		BBPkeepref(*result);
		BBPreleaseref(b->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(b->batCacheid);
	throw(MAL, "algebra.rangesplit", GDK_EXCEPTION);
}

str
ALGurangesplit(int *result, int *bid, int *nfrag)
{
	BAT *b, *bn = NULL;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "algebra.urangesplit", RUNTIME_OBJECT_MISSING);
	}
	CMDurangesplit(&bn, b, nfrag);
	if (bn) {
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
		*result = bn->batCacheid;
		BBPkeepref(*result);
		BBPreleaseref(b->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(b->batCacheid);
	throw(MAL, "algebra.urangesplit", GDK_EXCEPTION);
}

str
ALGhistogram_rev(int *result, int *bid)
{
	BAT *b, *bn = NULL;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "algebra.histogram", RUNTIME_OBJECT_MISSING);
	}
	CMDhistogram(&bn, b);
	if (bn) {
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
		*result = bn->batCacheid;
		BBPkeepref(*result);
		BBPreleaseref(b->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(b->batCacheid);
	throw(MAL, "algebra.histogram", GDK_EXCEPTION);
}

str
ALGlike(int *ret, int *bid, str *k)
{
	BAT *b, *bn = NULL;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "algebra.like", RUNTIME_OBJECT_MISSING);
	}
	CMDlike(&bn, b, *k);
	if (bn) {
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
		*ret = bn->batCacheid;
		BBPkeepref(*ret);
		BBPreleaseref(b->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(b->batCacheid);
	throw(MAL, "algebra.like", GDK_EXCEPTION);
}

str
ALGslice(int *ret, bat *bid, lng *start, lng *end)
{
	BAT *b, *bn = NULL;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "algebra.slice", RUNTIME_OBJECT_MISSING);
	}
	CMDslice(&bn, b, start, end);
	if (bn != NULL) {
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
		*ret = bn->batCacheid;
		BBPkeepref(*ret);
		BBPreleaseref(b->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(b->batCacheid);
	throw(MAL, "algebra.slice", GDK_EXCEPTION);
}

str
ALGslice_int(int *ret, bat *bid, int *start, int *end)
{
	lng s = *start;
	lng e = (*end == int_nil ? lng_nil : *end);

	return ALGslice(ret, bid, &s, &e);
}

str
ALGslice_wrd(int *ret, bat *bid, wrd *start, wrd *end)
{
	lng s = *start;
	lng e = (*end == wrd_nil ? lng_nil : *end);

	return ALGslice(ret, bid, &s, &e);
}

@- BUN Get/Fetch
@c
str
ALGposition(wrd *retval, int *bid, ptr val)
{
	BAT *b;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "algebra.position", RUNTIME_OBJECT_MISSING);
	}
	@:derefStr(b,h,val)@
	if (CMDposition(retval, b, val) == GDK_FAIL){
		BBPreleaseref(b->batCacheid);
		throw(MAL, "algebra.position", GDK_EXCEPTION "Item not found");
	}
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}

str
ALGpositionBUN(wrd *retval, int *bid, ptr val, ptr tval)
{
	BAT *b;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "algebra.position", RUNTIME_OBJECT_MISSING);
	}
	@:derefStr(b,h,val)@
	@:derefStr(b,t,tval)@
	if( (CMDpositionBUN(retval, b, val, tval) == GDK_FAIL) ){
		BBPreleaseref(b->batCacheid);
		throw(MAL, "algebra.position", GDK_EXCEPTION "Item not found");
	}
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}

str
doALGfetch(ptr ret, BAT *b, lng *pos)
{
	lng i = *pos;
	BAT *bn;
	int *res;
	BATiter bi = bat_iterator(b);

	if ((i < 0) || (i >= (lng) BATcount(b)))
		throw(MAL, "algebra.fetch", ILLEGAL_ARGUMENT " Idx out of range\n");
	i += BUNfirst(b);
	
	assert(i <= (lng) BUN_MAX);
	if( b->ttype== TYPE_bat){
		res= (int*) ret;
		ret= &bn;
		@:putTail((BUN)i)@
		if( bn)
			BBPkeepref(*res = bn->batCacheid);
		else *res = 0;
	} else {
		@:putTail((BUN)i)@
	}
	return MAL_SUCCEED;
}

str
ALGfetch(ptr ret, int *bid, lng *pos)
{
	BAT *b;
	str msg;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "algebra.fetch", RUNTIME_OBJECT_MISSING);
	}
	msg = doALGfetch(ret, b, pos);
	BBPreleaseref(b->batCacheid);
	return msg;
}

str
ALGfetchoid(int *ret, int *bid, oid *pos)
{
	lng o = *pos;

	ALGfetch(ret, bid, &o);
	return MAL_SUCCEED;
}

str
ALGfetchint(int *ret, int *bid, int *pos)
{
	lng o = *pos;

	return ALGfetch(ret, bid, &o);
}

str
ALGfetchbat(int *ret, int *bid, int *sid)
{
	BAT *b, *s, *bn = NULL;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "algebra.fetch", RUNTIME_OBJECT_MISSING);
	}
	if ((s = BATdescriptor(*sid)) == NULL) {
		BBPreleaseref(b->batCacheid);
		throw(MAL, "algebra.fetch", RUNTIME_OBJECT_MISSING);
	}

	bn = BATfetch(b, s);
	if (bn) {
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
		*ret = bn->batCacheid;
		BBPkeepref(*ret);
		BBPreleaseref(b->batCacheid);
		BBPreleaseref(s->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(b->batCacheid);
	BBPreleaseref(s->batCacheid);
	throw(MAL, "algebra.fetchbat", GDK_EXCEPTION);

}

str
ALGexist(bit *ret, int *bid, ptr val)
{
	BAT *b;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "algebra.exist", RUNTIME_OBJECT_MISSING);
	}
	@:derefStr(b,h,val)@
	CMDexist(ret, b, val);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}

str
ALGexistBUN(bit *ret, int *bid, ptr val, ptr tval)
{
	BAT *b;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "algebra.exist", RUNTIME_OBJECT_MISSING);
	}
	@:derefStr(b,h,val)@
	@:derefStr(b,t,tval)@
	CMDexistBUN(ret, b, val, tval);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}

str
ALGfind(ptr ret, int *bid, ptr val)
{
	BAT *b,*bn;
	ptr p;
	BUN q;
	int *res;
	BATiter bi;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "algebra.find", RUNTIME_OBJECT_MISSING);
	}
	@:derefStr(b,h,val)@
	p = (b->htype == TYPE_bat) ? (ptr) &((BAT *) val)->batCacheid : val;
	q = BUNfnd(b, p);

	if (q == BUN_NONE){
		BBPreleaseref(b->batCacheid);
		throw(MAL, "algebra.find", GDK_EXCEPTION "can not find element");
	}
	
	bi = bat_iterator(b);
	if( b->ttype== TYPE_bat){
		res= (int*) ret;
		ret= &bn;
		@:putTail(q)@
		if( bn)
			BBPkeepref(*res = bn->batCacheid);
		else *res = 0;
	} else {
		@:putTail(q)@
	}
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}


str
ALGhashjoin(int *result, int *lid, int *rid)
{
	BAT *left, *right, *bn;
	size_t lsize, rsize;

	if ((left = BATdescriptor(*lid)) == NULL) {
		throw(MAL, "algebra.hashjoin", RUNTIME_OBJECT_MISSING);
	}
	if ((right = BATdescriptor(*rid)) == NULL) {
		BBPreleaseref(left->batCacheid);
		throw(MAL, "algebra.hashjoin", RUNTIME_OBJECT_MISSING);
	}

	lsize = left->H->heap.size + left->T->heap.size + (left->H->vheap ? left->H->vheap->size : 0) + (left->T->vheap ? left->T->vheap->size : 0);
	rsize = right->H->heap.size + right->T->heap.size + (right->H->vheap ? right->H->vheap->size : 0) + (right->T->vheap ? right->T->vheap->size : 0);

	if (rsize < lsize)
		bn = BATmirror(BAThashjoin(BATmirror(right), BATmirror(left), BUN_NONE));
	else
		bn = BAThashjoin(left, right, BUN_NONE);

	if (bn) {
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
		*result = bn->batCacheid;
		BBPkeepref(*result);
		BBPreleaseref(left->batCacheid);
		BBPreleaseref(right->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(left->batCacheid);
	BBPreleaseref(right->batCacheid);
	throw(MAL, "algebra.hashjoin", MAL_MALLOC_FAIL);
}

str
ALGmergejoin(int *result, int *lid, int *rid)
{
	BAT *left, *right, *bn;

	if ((left = BATdescriptor(*lid)) == NULL) {
		throw(MAL, "algebra.mergejoin", RUNTIME_OBJECT_MISSING);
	}
	if ((right = BATdescriptor(*rid)) == NULL) {
		BBPreleaseref(left->batCacheid);
		throw(MAL, "algebra.mergejoin", RUNTIME_OBJECT_MISSING);
	}
	if (!((BATtordered(left) & 1) || (BAThordered(right) & 1)))
		throw(MAL, "algebra.mergejoin", ILLEGAL_ARGUMENT " Neither left nor right bat is ordered.\n");

	if ((left->ttype == TYPE_void) || (right->htype == TYPE_void))
		throw(MAL, "algebra.mergejoin", ILLEGAL_ARGUMENT " Cannot perform mergejoin on void fields.\n");
	bn = BATmergejoin(left, right, BUN_NONE);
	if (bn) {
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
		*result = bn->batCacheid;
		BBPkeepref(*result);
		BBPreleaseref(left->batCacheid);
		BBPreleaseref(right->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(left->batCacheid);
	BBPreleaseref(right->batCacheid);
	throw(MAL, "algebra.mergejoin", MAL_MALLOC_FAIL);
}

str
ALGindexjoin(int *result, int *lid, int *rid)
{
	BAT *left, *right, *bn;

	if ((left = BATdescriptor(*lid)) == NULL) {
		throw(MAL, "algebra.indexjoin", RUNTIME_OBJECT_MISSING);
	}
	if ((right = BATdescriptor(*rid)) == NULL) {
		BBPreleaseref(left->batCacheid);
		throw(MAL, "algebra.indexjoin", RUNTIME_OBJECT_MISSING);
	}

	bn = BATthetajoin(left, right, JOIN_EQ, BUN_NONE);
	if (bn) {
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
		*result = bn->batCacheid;
		BBPkeepref(*result);
		BBPreleaseref(left->batCacheid);
		BBPreleaseref(right->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(left->batCacheid);
	BBPreleaseref(right->batCacheid);
	throw(MAL, "algebra.indexjoin", MAL_MALLOC_FAIL);
}

str
ALGprojectNIL(int *ret, int *bid)
{
    BAT *b, *bn;

    if ((b = BATdescriptor(*bid)) == NULL) {
        throw(MAL, "algebra.project", RUNTIME_OBJECT_MISSING);
    }

    bn = BATconst(b, TYPE_void, (ptr) &int_nil);
    if (bn) {
        *ret = bn->batCacheid;
        BBPkeepref(bn->batCacheid);
		BBPunfix(b->batCacheid);
        return MAL_SUCCEED;
    }
    BBPunfix(b->batCacheid);
    throw(MAL, "algebra.project", MAL_MALLOC_FAIL);
}

@-
The constant versions are typed by the parser
@= projectImpl
str ALGprojecthead_@1(int *ret,ptr *val, int *bid){
	BAT *b, *bn;
	BUN p,q;
	BATiter bi;

	@:getBATdescriptor(bid,b,"batcalc.project")@

	bn= BATnew(TYPE_@1,BATttype(b),BATcount(b));
	@:tstBAT("algebra.project")@
	bi = bat_iterator(b);
	BATaccessBegin(b,USE_TAIL,MMAP_SEQUENTIAL);
	BATloop(b, p, q) {
		ptr v = BUNtail(bi,p);
		bunfastins(bn, val,v);
	}
	bn->H->nonil = (ATOMcmp(bn->htype, val, ATOMnilptr(bn->htype))); 
	bn->T->nonil = b->T->nonil;
bunins_failed:
	BATaccessEnd(b,USE_TAIL,MMAP_SEQUENTIAL);
	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); \
	*ret= bn->batCacheid;
	BBPkeepref(bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}
str ALGprojecttail_@1(int *ret,int *bid, ptr *val){
	BAT *b, *bn;
	BUN p,q;
	BATiter bi;

	@:getBATdescriptor(bid,b,"batcalc.project")@

	bn= BATnew(BAThtype(b),TYPE_@1,BATcount(b));
	@:tstBAT("algebra.project")@
	bi = bat_iterator(b);
	BATaccessBegin(b,USE_HEAD,MMAP_SEQUENTIAL);
	BATloop(b, p, q) {
		ptr v = BUNhead(bi,p);
		bunfastins(bn,v, val);
	}
	bn->H->nonil = b->H->nonil;
	bn->T->nonil = (ATOMcmp(bn->ttype, val, ATOMnilptr(bn->ttype))); 
bunins_failed:
	BATaccessEnd(b,USE_HEAD,MMAP_SEQUENTIAL);
	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); \
	*ret= bn->batCacheid;
	BBPkeepref(bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}
@-

@c
@:projectImpl(int)@
@:projectImpl(sht)@
@:projectImpl(lng)@
@:projectImpl(oid)@
@:projectImpl(flt)@
@:projectImpl(dbl)@
@:projectImpl(str)@
@:projectImpl(chr)@
@:projectImpl(bit)@


/* You don;t have to materialize the oids.
This is taken care upon access */
str
ALGidentity(int *ret, int *bid)
{
	BAT *b;

	@:getBATdescriptor(bid,b,"algebra.identity")@
	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ); \
	BBPkeepref(*ret = b->batCacheid);
	return MAL_SUCCEED;
}
str
ALGmaterialize(int *ret, int *bid)
{
	BAT *b, *bn;

	@:getBATdescriptor(bid,b,"algebra.materialize")@
	if( b->htype == TYPE_void){
		bn= BATmaterialize(b);
		if( bn == NULL)
			throw(MAL, "batcalc.materialize", MAL_MALLOC_FAIL);
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
		BBPkeepref(*ret= bn->batCacheid);
	} else 
		BBPkeepref(*ret = b->batCacheid);
	return MAL_SUCCEED;
}

str ALGreuse(int *ret, int *bid)
{
	BAT *b,*bn;
	@:getBATdescriptor(bid,b,"algebra.reuse")@

	if( b->batPersistence != TRANSIENT || b->batRestricted != BAT_WRITE){
		if( ATOMvarsized(b->ttype) || b->htype != TYPE_void){
			bn= BATwcopy(b);
		} else {
			bn = BATnew(b->htype,b->ttype,BATcount(b));
			BATsetcount(bn,BATcount(b));
			bn->tsorted = FALSE; 
			BATkey(bn,FALSE);
			/* head is void */
			BATseqbase(bn, b->hseqbase);
		}
		BBPkeepref(*ret= bn->batCacheid);
		BBPreleaseref(b->batCacheid);
	} else 
		BBPkeepref(*ret = *bid);
	return MAL_SUCCEED;
}

@+ BAT avg operation
The avg aggregate only works for int and float fields.

@= avg_implementation
int
CMDavg_@1(dbl* res, BAT *b)
{
	BUN cnt = BATcount(b);

	if (cnt) {
		bit t = TRUE;
		dbl result=0;

		CMDsum_@1_dbl(&result, b, &t);
		*res = result/cnt;
	} else {
		*res = dbl_nil;
	}
	return GDK_SUCCEED;
}

@c
@:avg_implementation(bte)@
@:avg_implementation(sht)@
@:avg_implementation(int)@
@:avg_implementation(wrd)@
@:avg_implementation(lng)@
@:avg_implementation(flt)@
@:avg_implementation(dbl)@

@= avg_impl
str ALGavg_@1(dbl *res, int *bid) {
	BAT *b;
	if( (b= BATdescriptor(*bid)) == NULL ){
		 throw(MAL, "algebra.avg", RUNTIME_OBJECT_MISSING);
	}
	CMDavg_@1(res,b);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}
@c
@:avg_impl(bte)@
@:avg_impl(sht)@
@:avg_impl(int)@
@:avg_impl(wrd)@
@:avg_impl(lng)@
@:avg_impl(flt)@
@:avg_impl(dbl)@

@+ BAT standard deviation

@= stdev_impl
str ALGstdev_@1(dbl *res, int *bid) {
	BAT *b;
	BUN cnt = 0;

	if ((b=BATdescriptor(*bid)) == NULL) {
		throw(MAL, "algebra.stdev", RUNTIME_OBJECT_MISSING);
	}
	cnt = BATcount(b);

	if (cnt) {
		dbl stdev = 0;
		/* first, we need the average of the tail values */
		bit t = TRUE;
		dbl avg = 0;
		CMDsum_@1_dbl(&avg, b, &t);
		if (avg != dbl_nil) {
			BATiter bi = bat_iterator(b);
			BUN p,q;

			avg /= cnt;

			/* next, we need the sum of the squares of the difference of each
			   value in the tail with the avg */

			/* no need to check for nil values on the tail, the CMDsum has
			   already done that and reported back */
			BATloop(b, p, q) {
				dbl value = (dbl) *(@1*) BUNtloc(bi, p);
				value -= avg;    /* diff from avg  */
				value *= value;  /* square         */
				stdev += value;  /* sum of squares */
			}

			/* finaly, divide by the cnt and compute the square root */
			*res = sqrt(stdev/cnt);
		} else {
			*res = dbl_nil;
		}
	} else {
		*res = dbl_nil;
	}

	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}

@c
@:stdev_impl(bte)@
@:stdev_impl(sht)@
@:stdev_impl(int)@
@:stdev_impl(wrd)@
@:stdev_impl(lng)@
@:stdev_impl(flt)@
@:stdev_impl(dbl)@

@}
