@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.monetdb.org/Legal/MonetDBLicense

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2011 MonetDB B.V.
All Rights Reserved.
@

@f batmmath
@a M.L. Kersten
@+ BAT math calculator
This module contains the multiplex versions of the linked
in mathematical functions.
@{
@= tstBat
if( bn== NULL) {*ret= 0;
	throw(MAL, "batcalc.@1", MAL_MALLOC_FAIL);}

@+ Scientific routines
The mmath functions are also overloaded to provide for
the fast execution of expanded code blocks.
The common set of math functions is supported.
@= scienceFcn
	command @1(x:bat[:oid,:dbl])  :bat[:oid,:dbl] 
	address CMDscience_bat_dbl_@1;
	command @1(x:bat[:oid,:flt])  :bat[:oid,:flt] 
	address CMDscience_bat_flt_@1;
@= scienceFcnBinary
	command @1(x:bat[:oid,:dbl],y:dbl):bat[:oid,:dbl] 
	address CMDscience_bat_cst_@1_dbl;
	command @1(x:bat[:oid,:flt],y:flt):bat[:oid,:flt] 
	address CMDscience_bat_cst_@1_flt;
@-
@mal
module batmmath;
	@:scienceFcn(asin)@
	@:scienceFcn(acos)@
	@:scienceFcn(atan)@
	@:scienceFcn(cos)@
	@:scienceFcn(sin)@
	@:scienceFcn(tan)@
	@:scienceFcn(cosh)@
	@:scienceFcn(sinh)@
	@:scienceFcn(tanh)@
	@:scienceFcn(radians)@
	@:scienceFcn(degrees)@
	@:scienceFcn(exp)@
	@:scienceFcn(log)@
	@:scienceFcn(log10)@
	@:scienceFcn(sqrt)@
	@:scienceFcn(ceil)@
	@:scienceFcn(fabs)@
	@:scienceFcn(floor)@
@-
	round is not binary...
	@:scienceFcnBinary(round,int)@
@mal
	@:scienceFcnBinary(fmod)@
	@:scienceFcnBinary(atan2)@
	@:scienceFcnBinary(pow)@
@- Implementation
@include kprelude.mx

@h
#ifdef _BATMATH_H
#define _BATMATH_H

#endif  /* _BATMATH_H */
@- Implementations of scientific functions
@c
#include "monetdb_config.h"
#include "gdk.h"
#include "math.h"
#include "mal_exception.h"
#include "batmmath.h"

#ifdef WIN32
#if !defined(LIBMAL) && !defined(LIBATOMS) && !defined(LIBKERNEL) && !defined(LIBMAL) && !defined(LIBOPTIMIZER) && !defined(LIBSCHEDULER) && !defined(LIBMONETDB5)
#define batmmath_export extern __declspec(dllimport)
#else
#define batmmath_export extern __declspec(dllexport)
#endif
#else
#define batmmath_export extern
#endif

#define radians(x)       ((x) * 3.14159265358979323846 / 180.0)
#define degrees(x)       ((x) * 180.0 / 3.14159265358979323846)
#define radiansf(x)      ((flt) radians(x))
#define degreesf(x)      ((flt) degrees(x))
@-
@= scienceFcnImpl
batmmath_export str CMDscience_bat_@2_@1(int *ret, int *bid);
str CMDscience_bat_@2_@1(int *ret, int *bid)
{
	BAT *b,*bn;
	@2 *o, *p, *q;

	@:getBATdescriptor(bid,b,"batcalc.@1")@
	@:voidresultBAT(TYPE_@2,"batcalc.@1")@

	o = (@2*) Tloc(bn, BUNfirst(bn));
	p = (@2*) Tloc(b, BUNfirst(b));
	q = (@2*) Tloc(b, BUNlast(b));

	BATaccessBegin(b, USE_TAIL, MMAP_SEQUENTIAL);
	if (b->T->nonil){
		for(;p<q; o++, p++)
			*o = @1@3(*p);
	} else
		for(;p<q; o++, p++){
			*o = *p == @2_nil? @2_nil: @1@3(*p);
		}
	BATaccessEnd(b, USE_TAIL, MMAP_SEQUENTIAL);
	BATsetcount(bn, BATcount(b));
	bn->tsorted = 0;
	BATkey(BATmirror(bn),0);           
	
	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); 

	if (b->htype != bn->htype) {
		BAT *r = VIEWcreate(b,bn);

		BBPreleaseref(bn->batCacheid);
		bn = r;
	}
	BBPkeepref(*ret = bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}
@= scienceBinaryImpl
batmmath_export str CMDscience_bat_cst_@1_@2(int *ret, int *bid, @2 *d);
str CMDscience_bat_cst_@1_@2(int *ret, int *bid, @2 *d)
{
	BAT *b,*bn;
	@2 *o, *p, *q;

	@:getBATdescriptor(bid,b,"batcalc.@1")@
	@:voidresultBAT(TYPE_@2,"batcalc.@1")@

	o = (@2*) Tloc(bn, BUNfirst(bn));
	p = (@2*) Tloc(b, BUNfirst(b));
	q = (@2*) Tloc(b, BUNlast(b));

	BATaccessBegin(b, USE_TAIL, MMAP_SEQUENTIAL);
	if (b->T->nonil){
		for(;p<q; o++, p++)
			*o = @1@3(*p,*d);
	} else
		for(;p<q; o++, p++){
			*o = *p == @2_nil? @2_nil: @1@3(*p,*d);
		}
	BATaccessEnd(b, USE_TAIL, MMAP_SEQUENTIAL);

	BATsetcount(bn, BATcount(b));
	bn->tsorted = 0;
	BATkey(BATmirror(bn),0);           

	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); 

	if (b->htype != bn->htype) {
		BAT *r = VIEWcreate(b,bn);

		BBPreleaseref(bn->batCacheid);
		bn = r;
	}
	BBPkeepref(*ret = bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}
@= scienceImpl
@:scienceFcnImpl(@1,dbl,)@
@:scienceFcnImpl(@1,flt,f)@
@c
@:scienceImpl(asin)@
@:scienceImpl(acos)@
@:scienceImpl(atan)@
@:scienceImpl(cos)@
@:scienceImpl(sin)@
@:scienceImpl(tan)@
@:scienceImpl(cosh)@
@:scienceImpl(sinh)@
@:scienceImpl(tanh)@
@:scienceImpl(radians)@
@:scienceImpl(degrees)@
@:scienceImpl(exp)@
@:scienceImpl(log)@
@:scienceImpl(log10)@
@:scienceImpl(sqrt)@
@:scienceImpl(ceil)@
@:scienceImpl(fabs)@
@:scienceImpl(floor)@
@-
	round is not binary...
	@:scienceBinaryImpl(round,int)@
@c
@:scienceBinaryImpl(fmod,dbl,)@
@:scienceBinaryImpl(fmod,flt,f)@
@:scienceBinaryImpl(atan2,dbl,)@
@:scienceBinaryImpl(atan2,flt,f)@
@:scienceBinaryImpl(pow,dbl,)@
@:scienceBinaryImpl(pow,flt,f)@

@}
