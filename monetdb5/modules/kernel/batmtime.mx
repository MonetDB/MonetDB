@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.monetdb.org/Legal/MonetDBLicense

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2011 MonetDB B.V.
All Rights Reserved.
@

@f batmtime
@a M.L. Kersten
@+ Time/Date multiplexes
[TODO: arithmetic multiplexes]
The collection of routines provided here are map operations
for the atom time and date primitives. 

In line with the batcalc module, we assume that
if two bat operands are provided that they are already
aligned on the head. Moreover, the head of the BATs
are limited to :void, which can be cheaply realized using
the GRPsplit operation.
@{
@= compareOp
command batcalc.@2( l:bat[:oid,:@1], r:bat[:oid,:@1]) :bat[:oid,:bit]
address MTIMEbat_@1_@3;

command batcalc.@2( l:bat[:void,:@1], r:bat[:void,:@1]) :bat[:void,:bit]
address MTIMEbat_@1_@3
comment "Compare a bat of @1 against each other";
command batcalc.@2( l:bat[:oid,:@1], r:@1) :bat[:oid,:bit]
address MTIMEbat_@1_@3_cst;
command batcalc.@2( l:bat[:void,:@1], r:@1) :bat[:void,:bit]
address MTIMEbat_@1_cst_@3
comment "Compare a bat of @1 against a singleton";

command batcalc.@2(a:bat[:void,:bit], l:bat[:void,:@1], r:bat[:void,:@1]) :bat[:void,:bit]
address MTIMEaccum_@1_@3
comment "Compare a bat of @1 against each other";
command batcalc.@2(a:bat[:void,:bit], l:bat[:oid,:@1], r:@1) :bat[:oid,:bit]
address MTIMEaccum_@1_@3_cst;
command batcalc.@2(a:bat[:void,:bit], l:bat[:void,:@1], r:@1) :bat[:void,:bit]
address MTIMEaccum_@1_cst_@3
comment "Compare a bat of @1 against a singleton";


@= compareGrp
@:compareOp(@1,==,EQ)@
@:compareOp(@1,!=,NEQ)@
@:compareOp(@1,<,LT)@
@:compareOp(@1,<=,LE)@
@:compareOp(@1,>,GT)@
@:compareOp(@1,>=,GE)@

@= unaryISNIL
    command batcalc.isnil(b:bat[:any_1,:@1]):bat[:any_1,:bit]
    address MTIMEunaryISNIL
    comment "Unary check for nil over the tail of the bat";

@mal
@:compareGrp(date)@
@:compareGrp(daytime)@
@:compareGrp(timestamp)@

@:unaryISNIL(date)@
@:unaryISNIL(daytime)@
@:unaryISNIL(timestamp)@

@+ Implementation
@h
#include "gdk.h"
#include "ctype.h"
#include "mal_exception.h"
#include "mtime.h"

#ifdef WIN32
#if !defined(LIBMAL) && !defined(LIBATOMS) && !defined(LIBKERNEL) && !defined(LIBMAL) && !defined(LIBOPTIMIZER) && !defined(LIBSCHEDULER) && !defined(LIBMONETDB5)
#define batmtime_export extern __declspec(dllimport)
#else
#define batmtime_export extern __declspec(dllexport)
#endif
#else
#define batmtime_export extern
#endif

@c
#include "monetdb_config.h"
#include "batmtime.h"

@-
A general assumption in all cases is the bats are synchronized on their
head column. This is not checked and may be mis-used to deploy the
implementation for shifted window arithmetic as well.
@= chkSize
	if( BATcount(@1) != BATcount(@2) )
		throw(MAL, "batcalc.@3", ILLEGAL_ARGUMENT " Requires bats of identical size");

@= implDef
batmtime_export str MTIMEbat_@1_@2(int *ret, int *l, int *r);
batmtime_export str MTIMEbat_@1_@2_cst(int *ret, int *l, @1 *cst);
batmtime_export str MTIMEbat_@1_cst_@2(int *ret, @1 *cst, int *l);
batmtime_export str MTIMEaccum_@1_@2(int *ret, int *d, int *l, int *r);
batmtime_export str MTIMEaccum_@1_@2_cst(int *ret, int *r, int *l, @1 *cst);
batmtime_export str MTIMEaccum_@1_cst_@2(int *ret, int *r, @1 *cst, int *l);
batmtime_export str MTIMEunaryISNIL(int *ret, int *bid);

@- Comparison operator implementation for temporal objects
The structure of this code is copied from the arithmetic scheme.
@-
@include kprelude.mx
@-
The basic wrappers code structures.
@= unarybaselineCode
str MTIMEbat_@1_@2_@3(int *ret, int *l)
{	
	BAT *bn, *b;
	@1 *p, *q, *t;
	bit *o;

	@:getBATdescriptor(l,b,"batcalc.@2")@
	@:voidresultBAT(@3,"batcalc.@2")@

	o = (bit*)Tloc(bn,BUNfirst(bn));
	p = (@1*)Tloc(b,BUNfirst(b));
	q = (@1*)Tloc(b,BUNlast(b));
	t = (@1*)Tloc(right,BUNfirst(right));
		
	BATaccessBegin(b, USE_TAIL, MMAP_SEQUENTIAL);
	BATaccessBegin(right, USE_TAIL, MMAP_SEQUENTIAL);
	if (b->T->nonil)
		for (;p<q; p++, t++, o++)
			@1@2(o,p,t);
	else
		for (;p<q; p++, t++, o++) 
			if ( @1_isnil(*p))
				*o = bit_nil;
			else @1@2(o,p,t);

	BATaccessEnd(right, USE_TAIL, MMAP_SEQUENTIAL);
	BATaccessEnd(b, USE_TAIL, MMAP_SEQUENTIAL);
	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); 

    if (b->htype != bn->htype) {
        BAT *r = VIEWcreate(b,bn);

        BBPreleaseref(bn->batCacheid);
        bn = r;
    }

	BATsetcount(bn, BATcount(b));
	bn->tsorted = 0;
	BATkey(BATmirror(bn),FALSE);
	BBPkeepref(*ret= bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}

@= baselineCode
str MTIMEbat_@1_@2(int *ret, int *l, int *r)
{	
	BAT *bn, *b, *right;
	@1 *p, *q, *t;
	bit *o;

	@:getBATdescriptor(l,b,"batcalc.@2")@
	@:getBATdescriptor(r,right,"batcalc.@2", BBPreleaseref(b->batCacheid);)@
	@:chkSize(b,right,batcalc.@2)@
	@:voidresultBAT(TYPE_bit,"batcalc.@2")@

	o = (bit*)Tloc(bn,BUNfirst(bn));
	p = (@1*)Tloc(b,BUNfirst(b));
	q = (@1*)Tloc(b,BUNlast(b));
	t = (@1*)Tloc(right,BUNfirst(right));
		
	BATaccessBegin(b, USE_TAIL, MMAP_SEQUENTIAL);
	BATaccessBegin(right, USE_TAIL, MMAP_SEQUENTIAL);
	if (b->T->nonil && right->T->nonil) {
		for (;p<q; p++, t++, o++)
			@1@2(o,p,t);
	} else
	if (b->T->nonil)
		for (;p<q; p++, t++, o++)
			if (@1_isnil(*t))
				*o = bit_nil;
			else @1@2(o,p,t);
	else
	if (right->T->nonil)
		for (;p<q; p++, t++, o++)
			if ( @1_isnil(*p))
				*o = bit_nil;
			else @1@2(o,p,t);
	else
		for (;p<q; p++, t++, o++) 
			if ( @1_isnil(*p) || @1_isnil(*t))
				*o = bit_nil;
			else @1@2(o,p,t);

	BATaccessEnd(right, USE_TAIL, MMAP_SEQUENTIAL);
	BATaccessEnd(b, USE_TAIL, MMAP_SEQUENTIAL);
	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); 


    if (b->htype != bn->htype) {
        BAT *r = VIEWcreate(b,bn);

        BBPreleaseref(bn->batCacheid);
        bn = r;
    }

	BATsetcount(bn, BATcount(b));
	bn->tsorted = 0;
	BATkey(BATmirror(bn),FALSE);
	BBPkeepref(*ret= bn->batCacheid);
	BBPreleaseref(right->batCacheid);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}

str MTIMEaccum_@1_@2(int *ret, int *d, int *l, int *r)
{	
	BAT *bn, *b, *right;
	@1 *p, *q, *t;
	bit *o;

	@:getBATdescriptor(l,b,"batcalc.@2")@
	@:getBATdescriptor(r,right,"batcalc.@2", BBPreleaseref(b->batCacheid);)@
	@:getBATdescriptor(d,bn,"batcalc.@2", BBPreleaseref(b->batCacheid);BBPreleaseref(right->batCacheid);)@
	@:chkSize(bn,b,batcalc.@2)@
	@:chkSize(bn,right,batcalc.@2)@

	o = (bit*)Tloc(bn,BUNfirst(bn));
	p = (@1*)Tloc(b,BUNfirst(b));
	q = (@1*)Tloc(b,BUNlast(b));
	t = (@1*)Tloc(right,BUNfirst(right));
		
	BATaccessBegin(b, USE_TAIL, MMAP_SEQUENTIAL);
	BATaccessBegin(right, USE_TAIL, MMAP_SEQUENTIAL);
	if (b->T->nonil && right->T->nonil) {
		for (;p<q; p++, t++, o++)
			@1@2(o,p,t);
	} else
	if (b->T->nonil)
		for (;p<q; p++, t++, o++) 
			if ( @1_isnil(*t))
				*o = bit_nil;
			else @1@2(o,p,t);
	else
	if (right->T->nonil)
		for (;p<q; p++, t++, o++)
			if ( @1_isnil(*p) )
				*o = bit_nil;
			else @1@2(o,p,t);
	else
		for (;p<q; p++, t++, o++) 
			if ( @1_isnil(*p) || @1_isnil(*t))
				*o = bit_nil;
			else @1@2(o,p,t);

	BATaccessEnd(right, USE_TAIL, MMAP_SEQUENTIAL);
	BATaccessEnd(b, USE_TAIL, MMAP_SEQUENTIAL);

	BATsetcount(bn, BATcount(b));
	bn->tsorted = 0;
	BATkey(BATmirror(bn),FALSE);
	BBPkeepref(*ret= bn->batCacheid);
	BBPreleaseref(right->batCacheid);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}

str MTIMEbat_@1_@2_cst(int *ret, int *l, @1 *cst)
{	
	BAT *bn, *b;
	@1 *p, *q;
	bit *o;

	@:getBATdescriptor(l,b,"batcalc.@2")@
	@:voidresultBAT(TYPE_bit,"batcalc.@2")@
	BATsetcount(bn, BATcount(b));
	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);

	o = (bit*)Tloc(bn,BUNfirst(bn));
	p = (@1*)Tloc(b,BUNfirst(b));
	q = (@1*)Tloc(b,BUNlast(b));
		
	BATaccessBegin(b, USE_TAIL, MMAP_SEQUENTIAL);
	if ( @1_isnil(*cst))
		for (;p<q; p++, o++) 
				*o = bit_nil;
	else
	if (b->T->nonil )
		for (;p<q; p++, o++)
			@1@2(o,p,cst);
	else
		for (;p<q; p++, o++)
			if( @1_isnil(*p) )
				*o = bit_nil;
			else @1@2(o,p,cst);

	BATaccessEnd(b, USE_TAIL, MMAP_SEQUENTIAL);

	bn->tsorted = 0;
	BATkey(BATmirror(bn),FALSE);
	BBPkeepref(*ret= bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}

str MTIMEbat_@1_cst_@2(int *ret, @1 *cst, int *l)
{	
	BAT *bn, *b;
	@1 *p, *q;
	bit *o;

	@:getBATdescriptor(l,b,"batcalc.@2")@
	@:voidresultBAT(TYPE_bit,"batcalc.@2")@
	BATsetcount(bn, BATcount(b));

	o = (bit*)Tloc(bn,BUNfirst(bn));
	p = (@1*)Tloc(b,BUNfirst(b));
	q = (@1*)Tloc(b,BUNlast(b));
		
	BATaccessBegin(b, USE_TAIL, MMAP_SEQUENTIAL);
	if (@1_isnil(*cst))
		for (;p<q; p++, o++) 
				*o = bit_nil;
	else
	if (b->T->nonil )
		for (;p<q; p++, o++)
			@1@2(o,cst,p);
	else
		for (;p<q; p++, o++)
			if( @1_isnil(*p) )
				*o = bit_nil;
			else @1@2(o,cst,p);
	BATaccessEnd(b, USE_TAIL, MMAP_SEQUENTIAL);

	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);

	if (b->htype != bn->htype) {
		BAT *r = VIEWcreate(b,bn);

		BBPreleaseref(bn->batCacheid);
		bn = r;
	}

	bn->tsorted = 0;
	BATkey(BATmirror(bn),FALSE);
	BBPkeepref(*ret= bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}

str MTIMEaccum_@1_@2_cst(int *ret, int *r, int *l, @1 *cst)
{	
	BAT *bn, *b;
	@1 *p, *q;
	bit *o;

	@:getBATdescriptor(r,bn,"batcalc.@2")@
	@:getBATdescriptor(l,b,"batcalc.@2", BBPreleaseref(bn->batCacheid);)@
	@:chkSize(bn,b,batcalc.@2)@

	o = (bit*)Tloc(bn,BUNfirst(bn));
	p = (@1*)Tloc(b,BUNfirst(b));
	q = (@1*)Tloc(b,BUNlast(b));
		
	BATaccessBegin(b, USE_TAIL, MMAP_SEQUENTIAL);
	if ( @1_isnil(*cst))
		for (;p<q; p++, o++)
			*o = bit_nil;
	else
	if (b->T->nonil)
		for (;p<q; p++, o++)
			@1@2(o,p,cst);
	else
		for (;p<q; p++, o++)
			if ( @1_isnil(*p) )
				*o = bit_nil;
			else @1@2(o,p,cst);

	BATaccessEnd(b, USE_TAIL, MMAP_SEQUENTIAL);
	bn->tsorted = 0;
	BATkey(BATmirror(bn),FALSE);
	BBPkeepref(*ret= bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}

str MTIMEaccum_@1_cst_@2(int *ret, int *r, @1 *cst, int *l)
{
	BAT *bn, *b;
	@1 *p, *q;
	bit *o;

	@:getBATdescriptor(r,bn,"batcalc.@2")@
	@:getBATdescriptor(l,b,"batcalc.@2", BBPreleaseref(bn->batCacheid);)@
	@:chkSize(bn,b,batcalc.@2)@

	o = (bit*)Tloc(bn,BUNfirst(bn));
	p = (@1*)Tloc(b,BUNfirst(b));
	q = (@1*)Tloc(b,BUNlast(b));
		
	BATaccessBegin(b, USE_TAIL, MMAP_SEQUENTIAL);
	if ( @1_isnil(*cst))
		for (;p<q; p++, o++)
			*o = bit_nil;
	else
	if (b->T->nonil)
		for (;p<q; p++, o++)
			@1@2(o,cst,p);
	else
		for (;p<q; p++, o++)
			if ( @1_isnil(*p) )
				*o = bit_nil;
			else @1@2(o,cst,p);
	BATaccessEnd(b, USE_TAIL, MMAP_SEQUENTIAL);

	bn->tsorted = 0;
	BATkey(BATmirror(bn),FALSE);
	BBPkeepref(*ret= bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}

@-
The implementation section.

@= implCmpGrpDef
@:implDef(@1,EQ)@
@:implDef(@1,NEQ)@
@:implDef(@1,LT)@
@:implDef(@1,LE)@
@:implDef(@1,GT)@
@:implDef(@1,GE)@

@h
@:implCmpGrpDef(date)@
@:implCmpGrpDef(daytime)@
@:implCmpGrpDef(timestamp)@
@c
@:baselineCode(date,EQ)@
@:baselineCode(date,NEQ)@
@:baselineCode(date,LT)@
@:baselineCode(date,LE)@
@:baselineCode(date,GT)@
@:baselineCode(date,GE)@

@:baselineCode(daytime,EQ)@
@:baselineCode(daytime,NEQ)@
@:baselineCode(daytime,LT)@
@:baselineCode(daytime,LE)@
@:baselineCode(daytime,GT)@
@:baselineCode(daytime,GE)@

@:baselineCode(timestamp,EQ)@
@:baselineCode(timestamp,NEQ)@
@:baselineCode(timestamp,LT)@
@:baselineCode(timestamp,LE)@
@:baselineCode(timestamp,GT)@
@:baselineCode(timestamp,GE)@

@= accumUnaryISNIL
{
    @1 *p = (@1*)Tloc(b,BUNfirst(b));
    @1 *q = (@1*)Tloc(b,BUNlast(b)); 
    BATaccessBegin(b, USE_TAIL, MMAP_SEQUENTIAL);
    if (b->T->nonil){
        for(; p<q; p++, o++ )
            *o = FALSE;
    } else
        for(; p<q; p++, o++ )
            *o = @1_isnil(*p);
    BATaccessEnd(b, USE_TAIL, MMAP_SEQUENTIAL);
}
@c
str MTIMEunaryISNIL(int *ret, int *bid)
{
    BAT *b,*bn;
    bit *o;

    @:getBATdescriptor(bid,b,"batcalc.isnil")@
    @:voidresultBAT(TYPE_bit,"batcalc.isnil")@

	o = (bit*)Tloc(bn,BUNfirst(bn));
	if ( BATttype(b) == TYPE_date) {
		@:accumUnaryISNIL(date)@ 
	} else
	if ( BATttype(b) == TYPE_daytime) {
		@:accumUnaryISNIL(daytime)@ 
	} else
	if ( BATttype(b) == TYPE_timestamp) {
		@:accumUnaryISNIL(timestamp)@ 
	} 

	BATsetcount(bn, BATcount(b));
    bn->tsorted = 0;
    BATkey(BATmirror(bn),FALSE);

    if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);

    if (b->htype != bn->htype) {
        BAT *r = VIEWcreate(b,bn);

        BBPreleaseref(bn->batCacheid);
        bn = r;
    }
    BBPkeepref(*ret = bn->batCacheid);
    BBPreleaseref(b->batCacheid);
    return MAL_SUCCEED;
}

@}
