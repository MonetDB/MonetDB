@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.monetdb.org/Legal/MonetDBLicense

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2011 MonetDB B.V.
All Rights Reserved.
@

@f aggr
@a S. Manegold 
@v 1.0
@+ Aggregates Module

This module contains some efficient aggregate functions that compute their
result in one scan, rather than in the iterative manner of the generic
MIL aggregrate implementations.

The implementation code is derived from the original 'aggr' module. 
It uses a complete type-specific code expansion to avoid any type-checking
in the inner-most loops.
Where feasible, it replaced (expansive) hash-lookup by significantly cheaper positional
void-lookups (if the head-column of the group-extend BAT ("e") is "void") or at least by 
(also positional) array lookups (in case the group-ids span a reasonably small range);

In addition to the 2-parameter @{ { } @{ } }(BAT[oid,any::1] b, BAT[oid,any] e)
functions, there are now also 3-parameter @{ { } @{ } }(BAT[void,any::1] b,
BAT[void,oid] g, BAT[oid,any] e) functions, that require b & g to be
head-aligned, and do the fetchjoin(reverse(g),b) on-the-fly;

The routines should not be stored in their own module, but
added to the 'group' module. This can be achieved by setting
the module.
@{
@mal
module aggr;
@= sumprod_signatures
command sum(b:bat[:oid,:@1], e:bat[:oid,:any_1]) :bat[:oid,:@2] 
address AX3aggrX3_sum_@1_@2
comment "Sum over grouped tail sum on @1";

command sum(b:bat[:oid,:@1],g:bat[:oid,:oid],e:bat[:oid,:any_1])
		:bat[:oid,:@2]
address AX3aggrX3_sum3_@1_@2
comment "Grouped tail sum on @1";

command product(b:bat[:oid,:@1], g:bat[:oid,:oid], e:bat[:oid,:any_1])
		:bat[:oid,:@2] 
address AX3aggrX3_prod3_@1_@2
comment "Product over grouped tail on @1";
@mal
@:sumprod_signatures(bte,bte)@
@:sumprod_signatures(bte,sht)@
@:sumprod_signatures(bte,int)@
@:sumprod_signatures(bte,wrd)@
@:sumprod_signatures(bte,lng)@
@:sumprod_signatures(sht,sht)@
@:sumprod_signatures(sht,int)@
@:sumprod_signatures(sht,wrd)@
@:sumprod_signatures(sht,lng)@
@:sumprod_signatures(int,int)@
@:sumprod_signatures(int,wrd)@
@:sumprod_signatures(int,lng)@
@:sumprod_signatures(wrd,wrd)@
@:sumprod_signatures(wrd,lng)@
@:sumprod_signatures(lng,wrd)@
@:sumprod_signatures(lng,lng)@
@:sumprod_signatures(flt,flt)@
@:sumprod_signatures(flt,dbl)@
@:sumprod_signatures(dbl,dbl)@

@= sum_avg_signatures
command avg(b:bat[:oid,:@1], e:bat[:oid,:any_1]) :bat[:oid,:dbl] 
address AX3aggrX3_avg_@1
comment "Grouped tail average on @1";

command avg(b:bat[:oid,:@1], g:bat[:oid,:oid], e:bat[:oid,:any_1]):bat[:oid,:dbl] 
address AX3aggrX3_avg3_@1
comment "Grouped tail average on @1";

@-
We may have to extend the signatures to all possible {void,oid} combos
@mal
@:sum_avg_signatures(bte)@
@:sum_avg_signatures(sht)@
@:sum_avg_signatures(int)@
@:sum_avg_signatures(wrd)@
@:sum_avg_signatures(lng)@
@:sum_avg_signatures(flt)@
@:sum_avg_signatures(dbl)@

command min(b:bat[:oid,:any_1], e:bat[:oid,:any_2]) :bat[:oid,:any_1] 
address AX3aggrX3_min;

command max(b:bat[:oid,:any_1], e:bat[:oid,:any_2]) :bat[:oid,:any_1] 
address AX3aggrX3_max;

command min(b:bat[:oid,:any_1],g:bat[:oid,:oid],e:bat[:oid,:any_2]):bat[:oid,:any_1]
address AX3aggrX3_min3;

command max(b:bat[:oid,:any_1], g:bat[:oid,:oid], e:bat[:oid,:any_2]) 
		:bat[:oid,:any_1] 
address AX3aggrX3_max3;

command count(b:bat[:oid,:any_1], e:bat[:oid,:any_2], ignorenils:bit)
	:bat[:oid,:wrd] 
address AX3aggrX3_count
comment "Grouped count";

command count(b:bat[:oid,:any_1], g:bat[:oid,:oid], e:bat[:oid,:any_2], 
		nonils:bit) :bat[:void,:wrd] 
address AX3aggrX3_count3;

command size(b:bat[:void,:bit], e:bat[:void,:any_1]) :bat[:void,:wrd] 
address AX3aggrX3_size
comment "Grouped count of true values";

command count(b:bat[:void,:any_1], e:bat[:oid,:any_2]) :bat[:void,:wrd] 
address AX3aggrX3_count2Nils
comment "Grouped count";
command count(b:bat[:void,:any_1], e:bat[:void,:any_2]) :bat[:void,:wrd] 
address AX3aggrX3_count2Nils;

command count_no_nil(b:bat[:oid,:any_1],e:bat[:oid,:any_1]):bat[:oid,:wrd]
address AX3count_no_nil2;

command count(b:bat[:oid,:any_1], g:bat[:oid,:oid], e:bat[:oid,:any_2])
	:bat[:oid,:wrd] 
address AX3aggrX3_count3Nils
comment "Grouped count";

command count_no_nil(b:bat[:oid,:any_1],g:bat[:oid,:oid],e:bat[:oid,:any_2])
	:bat[:oid,:wrd]
address AX3count_no_nil3;

@+ Implementation
These implementations need just one scan and a simple hash-maintained data
structure to compute a group of common aggregates.

@-
With group OIDs spanning a range of less than SMALL_AGGR_MAX (the actual
number of groups might be even less, in case there are "holes" in the group
OID range), we use a simple array as temporary sum/cnt table on order to
benefit from positional lookups; with size of sum <= 8 bytes and size of
cnt == 4 bytes, we stay below 16 KBytes, i.e., within (almost) any L1 cache.
@h
#define SMALL_AGGR_MAX 1024

@-
The macro CHKrange is just for array-lookups, analogously to BUNfndVOID &
HASHfnd_oid for void- and hash-lookups, respectively
@h
/* if the test succeeds, we must return something not equal to
   BUN_NONE, but the actual value doesn't matter since it is not
   otherwise used */
#define CHKrange(r, bn, h)	r = (BUN)(*(oid*)(h) >= min && *(oid*)(h) <= max ? 0 : BUN_NONE)

@-
In case the group OIDs span a range of more than SMALL_AGGR_MAX,
but the number of groups is less then SCAN_AGGR_MAX,
we use (backward-) "scan"-lookup (unrolled implementation exploiting
fall-through in C's switch statment) instead of hash-lookup,
as the latter turned out to be rather expensive ...
@h
#define SCAN_AGGR_MAX 8

#define SCAN_aggr_init \
	oid _h; \
	BUN _j = BATcount(bn); \
	oid *_bnh = (oid*) Hloc(bn, BUNfirst(bn)); \
	BUN _r = BUNfirst(bn);

#define SCANfndOID(r, bn, h)	\
	_h = *(oid*)(h), _j = BATcount(bn.b);         \
	r = BUN_NONE;                                     \
	switch (_j) {                                     \
	case 8: if (_bnh[7] == _h) { r = _r + 7; break; } \
	case 7: if (_bnh[6] == _h) { r = _r + 6; break; } \
	case 6: if (_bnh[5] == _h) { r = _r + 5; break; } \
	case 5: if (_bnh[4] == _h) { r = _r + 4; break; } \
	case 4: if (_bnh[3] == _h) { r = _r + 3; break; } \
	case 3: if (_bnh[2] == _h) { r = _r + 2; break; } \
	case 2: if (_bnh[1] == _h) { r = _r + 1; break; } \
	case 1: if (_bnh[0] == _h) { r = _r + 0; break; } \
	}

@-
In case the head of the group extend (e) is sorted, we assume that also the
the tail of the group map (g) is "almost" sorted or "mostly ascending" ---
or at least clustered such that group IDs in cluster i are smaller than
those in cluster i+1; this is the case if the first grouping attribute
(column/BAT) is sorted --- and resorted to "local scanning" rather than
(inherently random and expensive) hash-lookups.
Lacking a suitable and efficient way to detect that the tail of the group
map (g) is "almost sorted" or "mostly ascending", we require that the tail
of the group map (g) is sorted --- the "local scanning" performs much worse
than hash-lookups in case the tail of the group map (g) is in random order.
@h
#define MERGE_aggr_init						\
	BUN _i = 0, _j = BATcount(bn), _r = BUNfirst(bn);	\
	oid _h, *_bnh = (oid*) Hloc(bn, _r);		\
	if (_j > 0)						\
		_j--;

#define MERGEfndOID(r, bn, h)				\
	_h = *(oid*)(h);				\
	r = BUN_NONE;					\
	if (min <= _h && _h <= max ) {			\
		while ( _i < _j && _bnh[_i] < _h)	\
			_i++;				\
		while ( _i > 0 && _bnh[_i] > _h)	\
			_i--;				\
		if (_bnh[_i] == _h)			\
			r = _i + _r;			\
	}

/*
#define _MERGE_aggr_init					\
	BUN _i = 0, _j = BATcount(bn), _r = BUNfirst(bn);	\
	oid _h, *_bnh = (oid*) Hloc(bn, _r);		\
	dbl s = (dbl)_j / (dbl)range;				\
	if (_j > 0)						\
		_j--;

#define _MERGEfndOID(r, bn, h)				\
	_h = *(oid*)(h);				\
	r = BUN_NONE;					\
	if (min <= _h && _h <= max ) {			\
		_i = (BUN)((_h - min) * s);		\
		while ( _i < _j && _bnh[_i] < _h)	\
			_i++;				\
		while ( _i > 0 && _bnh[_i] > _h)	\
			_i--;				\
		if (_bnh[_i] == _h)			\
			r = _i + _r;			\
	}
*/

@- Wrapper
The remainder is a wrapper around the V4 code base.

@c
#include "monetdb_config.h"
@(
#include <gdk.h>
#include <gdk_scanselect.h>	/* for type-specific HT_bunfastins_nocheck_noinc(), until they're moved to gdk.mx */
@)

@c
#include "mal.h"
#include "mal_exception.h"
#include "aggr_be_sum.h"
#include "aggr_be_prod.h"
#include "aggr_be_avg.h"
#include "aggr_be_minmax.h"
#include "aggr_be_count.h"
#include "aggr_bge_sum.h"
#include "aggr_bge_prod.h"
#include "aggr_bge_avg.h"
#include "aggr_bge_minmax.h"
#include "aggr_bge_count.h"

#ifdef WIN32
#if !defined(LIBMAL) && !defined(LIBATOMS) && !defined(LIBKERNEL) && !defined(LIBMAL) && !defined(LIBOPTIMIZER) && !defined(LIBSCHEDULER) && !defined(LIBMONETDB5)
#define aggr_export extern __declspec(dllimport)
#else
#define aggr_export extern __declspec(dllexport)
#endif
#else
#define aggr_export extern
#endif

@-
@= AX3sum
aggr_export str AX3aggrX3_sum_@1_@2(int *retid, int *bid, int *eid);
str AX3aggrX3_sum_@1_@2(int *retid, int *bid, int *eid){
	BAT *b, *e;
	BAT *bn;

	if( (b= BATdescriptor(*bid)) == NULL ){
		throw(MAL, "aggr.sum", RUNTIME_OBJECT_MISSING);
	}
	if( (e= BATdescriptor(*eid)) == NULL ){
		BBPreleaseref(b->batCacheid);
		throw(MAL, "aggr.sum", RUNTIME_OBJECT_MISSING);
	}
	if( CMDaggrX3_sum_@1_@2(&bn,b,e) == GDK_SUCCEED){
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); 
		*retid = bn->batCacheid;
		BBPkeepref(*retid);
		BBPreleaseref(b->batCacheid);
		BBPreleaseref(e->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(b->batCacheid);
	BBPreleaseref(e->batCacheid);
	throw(MAL, "aggrX3_sum.@4",GDK_EXCEPTION);
}
@-

@= AX3prod
aggr_export str AX3aggrX3_prod_@1_@2(int *retid, int *bid, int *eid);
str AX3aggrX3_prod_@1_@2(int *retid, int *bid, int *eid){
	BAT *b, *e, *bn;

	if( (b= BATdescriptor(*bid)) == NULL ){
		throw(MAL, "aggr.prod", RUNTIME_OBJECT_MISSING);
	}
	if( (e= BATdescriptor(*eid)) == NULL ){
		BBPreleaseref(b->batCacheid);
		throw(MAL, "aggr.prod", RUNTIME_OBJECT_MISSING);
	}
	if( CMDaggrX3_prod_@1_@2(&bn,b,e) == GDK_SUCCEED){
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); 
		*retid = bn->batCacheid;
		BBPkeepref(*retid);
		BBPreleaseref(b->batCacheid);
		BBPreleaseref(e->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(b->batCacheid);
	BBPreleaseref(e->batCacheid);
	throw(MAL, "aggrX3_prod.@4",GDK_EXCEPTION);
}
@-
@= AX3sumprod
	@:AX3sum(@1,@2)@
	/* product here */
	@:AX3prod(@1,@2)@
@c

@:AX3sumprod(bte,bte)@
@:AX3sumprod(bte,sht)@
@:AX3sumprod(bte,int)@
@:AX3sumprod(bte,wrd)@
@:AX3sumprod(bte,lng)@
@:AX3sumprod(sht,sht)@
@:AX3sumprod(sht,int)@
@:AX3sumprod(sht,wrd)@
@:AX3sumprod(sht,lng)@
@:AX3sumprod(int,int)@
@:AX3sumprod(int,wrd)@
@:AX3sumprod(int,lng)@
@:AX3sumprod(wrd,wrd)@
@:AX3sumprod(wrd,lng)@
@:AX3sumprod(lng,wrd)@
@:AX3sumprod(lng,lng)@
@:AX3sumprod(flt,flt)@
@:AX3sumprod(flt,dbl)@
@:AX3sumprod(dbl,dbl)@

@-
@= AX3arithavg
aggr_export str AX3aggrX3_avg_@1(int *retid, int *bid, int *eid);
str AX3aggrX3_avg_@1(int *retid, int *bid, int *eid){
	BAT *b, *e, *bn;

	if( (b= BATdescriptor(*bid)) == NULL ){
		throw(MAL, "aggr.avg", RUNTIME_OBJECT_MISSING);
	}
	if( (e= BATdescriptor(*eid)) == NULL ){
		BBPreleaseref(b->batCacheid);
		throw(MAL, "aggr.avg", RUNTIME_OBJECT_MISSING);
	}
	if( CMDaggrX3_avg_@1(&bn,b,e) == GDK_SUCCEED){
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); 
		*retid = bn->batCacheid;
		BBPkeepref(*retid);
		BBPreleaseref(b->batCacheid);
		BBPreleaseref(e->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(b->batCacheid);
	BBPreleaseref(e->batCacheid);
	throw(MAL, "aggrX3_avg.@1",GDK_EXCEPTION);
}
@c
@:AX3arithavg(bte)@
@:AX3arithavg(sht)@
@:AX3arithavg(int)@
@:AX3arithavg(wrd)@
@:AX3arithavg(lng)@
@:AX3arithavg(flt)@
@:AX3arithavg(dbl)@


@- "Extremes" (Min & Max)
@= AX3extreme
aggr_export str AX3aggrX3_@1(int *ret, int *bid, int *eid);
str AX3aggrX3_@1(int *ret, int *bid, int *eid){
	BAT *b, *e, *bn;
	if( (b= BATdescriptor(*bid)) == NULL ){
		throw(MAL, "aggr.@1", RUNTIME_OBJECT_MISSING);
	}
	if( (e= BATdescriptor(*eid)) == NULL ){
		BBPreleaseref(b->batCacheid);
		throw(MAL, "aggr.@1", RUNTIME_OBJECT_MISSING);
	}

	if( CMDaggrX3_@1(&bn,b,e) == GDK_SUCCEED){
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); 
		*ret = bn->batCacheid;
		BBPkeepref(*ret);
		BBPreleaseref(b->batCacheid);
		BBPreleaseref(e->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(b->batCacheid);
	BBPreleaseref(e->batCacheid);
	throw(MAL, "aggrX3_@1",GDK_EXCEPTION);
}
@c
@:AX3extreme(min,<)@
@:AX3extreme(max,>)@

@- Count
@c
aggr_export str AX3aggrX3_count(int *retid, int *bid, int *eid, bit *ignore_nils);
str
AX3aggrX3_count(int *retid, int *bid, int *eid, bit *ignore_nils)
{
	BAT *b, *e, *bn;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "aggr.count", RUNTIME_OBJECT_MISSING);
	}
	if ((e = BATdescriptor(*eid)) == NULL) {
		BBPreleaseref(b->batCacheid);
		throw(MAL, "aggr.count", RUNTIME_OBJECT_MISSING);
	}

	if (CMDaggrX3_count(&bn, b, e, ignore_nils) == GDK_SUCCEED) {
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); 
		*retid = bn->batCacheid;
		BBPkeepref(*retid);
		BBPreleaseref(b->batCacheid);
		BBPreleaseref(e->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(b->batCacheid);
	BBPreleaseref(e->batCacheid);
	throw(MAL, "aggrX3_count", GDK_EXCEPTION);
}

@- Size
@c
aggr_export str AX3aggrX3_size(int *retid, int *bid, int *eid);
str
AX3aggrX3_size(int *retid, int *bid, int *eid)
{
	BAT *b, *e;
	BAT *bn;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "aggr.size", RUNTIME_OBJECT_MISSING);
	}
	if ((e = BATdescriptor(*eid)) == NULL) {
		BBPreleaseref(b->batCacheid);
		throw(MAL, "aggr.size", RUNTIME_OBJECT_MISSING);
	}
	if (CMDaggrX3_size(&bn, b, e) == GDK_SUCCEED) {
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); 
		*retid = bn->batCacheid;
		BBPkeepref(*retid);
		BBPreleaseref(b->batCacheid);
		BBPreleaseref(e->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(b->batCacheid);
	BBPreleaseref(e->batCacheid);
	throw(MAL, "aggrX3_size", GDK_EXCEPTION);
}

@- Sum & Average & Prod	
@= AX3arithsum3
aggr_export str AX3aggrX3_sum3_@1_@2(int *retid,int *bid, int *gid, int *eid);
str AX3aggrX3_sum3_@1_@2(int *retid,int *bid, int *gid, int *eid){
	BAT *b,*g, *e;
	BAT *bn;

	if( (b= BATdescriptor(*bid)) == NULL ){
		throw(MAL, "aggr.sum3", RUNTIME_OBJECT_MISSING);
	}
	if( (e= BATdescriptor(*eid)) == NULL ){
		BBPreleaseref(b->batCacheid);
		throw(MAL, "aggr.sum3", RUNTIME_OBJECT_MISSING);
	}
	if( (g= BATdescriptor(*gid)) == NULL ){
		BBPreleaseref(e->batCacheid);
		BBPreleaseref(b->batCacheid);
		throw(MAL, "aggr.sum3", RUNTIME_OBJECT_MISSING);
	}
	if( CMDaggrX3_sum3_@1_@2(&bn,b,g,e) == GDK_SUCCEED){
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); 
		*retid = bn->batCacheid;
		BBPkeepref(*retid);
		BBPreleaseref(b->batCacheid);
		BBPreleaseref(e->batCacheid);
		BBPreleaseref(g->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(b->batCacheid);
	BBPreleaseref(e->batCacheid);
	BBPreleaseref(g->batCacheid);
	throw(MAL, "aggrX3_sum3",GDK_EXCEPTION);
}
@-
@= AX3prod3
aggr_export str AX3aggrX3_prod3_@1_@2(int *retid,int *bid, int *gid, int *eid);
str AX3aggrX3_prod3_@1_@2(int *retid,int *bid, int *gid, int *eid){
	BAT *b,*g, *e;
	BAT *bn;

	if ((b = BATdescriptor(*bid)) == NULL)
		throw(MAL, "aggr.prod3", RUNTIME_OBJECT_MISSING);
	if( (e= BATdescriptor(*eid)) == NULL ){
		BBPreleaseref(b->batCacheid);
		throw(MAL, "aggr.prod3", RUNTIME_OBJECT_MISSING);
	}
	if( (g= BATdescriptor(*gid)) == NULL ){
		BBPreleaseref(e->batCacheid);
		BBPreleaseref(b->batCacheid);
		throw(MAL, "aggr.prod3", RUNTIME_OBJECT_MISSING);
	}
	if( CMDaggrX3_prod3_@1_@2(&bn,b,g,e) == GDK_SUCCEED){
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); 
		*retid = bn->batCacheid;
		BBPkeepref(*retid);
		BBPreleaseref(b->batCacheid);
		BBPreleaseref(e->batCacheid);
		BBPreleaseref(g->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(b->batCacheid);
	BBPreleaseref(e->batCacheid);
	BBPreleaseref(g->batCacheid);
	throw(MAL, "aggrX3_prod3",GDK_EXCEPTION);
}
@-
@= AX3sumprod3
@:AX3arithsum3(@1,@2)@
@:AX3prod3(@1,@2)@
@c

@:AX3sumprod3(bte,bte)@
@:AX3sumprod3(bte,sht)@
@:AX3sumprod3(bte,int)@
@:AX3sumprod3(bte,wrd)@
@:AX3sumprod3(bte,lng)@
@:AX3sumprod3(sht,sht)@
@:AX3sumprod3(sht,int)@
@:AX3sumprod3(sht,wrd)@
@:AX3sumprod3(sht,lng)@
@:AX3sumprod3(int,int)@
@:AX3sumprod3(int,wrd)@
@:AX3sumprod3(int,lng)@
@:AX3sumprod3(wrd,wrd)@
@:AX3sumprod3(wrd,lng)@
@:AX3sumprod3(lng,wrd)@
@:AX3sumprod3(lng,lng)@
@:AX3sumprod3(flt,flt)@
@:AX3sumprod3(flt,dbl)@
@:AX3sumprod3(dbl,dbl)@

@= AX3arithavg3
aggr_export str AX3aggrX3_avg3_@1(int *retid,int *bid, int *gid, int *eid);
str AX3aggrX3_avg3_@1(int *retid,int *bid, int *gid, int *eid){
	BAT *b,*g,*e;
	BAT *bn;

	if( (b= BATdescriptor(*bid)) == NULL ){
		throw(MAL, "aggr.avg3", RUNTIME_OBJECT_MISSING);
	}
	if( (e= BATdescriptor(*eid)) == NULL ){
		BBPreleaseref(b->batCacheid);
		throw(MAL, "aggr.avg3", RUNTIME_OBJECT_MISSING);
	}
	if( (g= BATdescriptor(*gid)) == NULL ){
		BBPreleaseref(e->batCacheid);
		BBPreleaseref(b->batCacheid);
		throw(MAL, "aggr.avg3", RUNTIME_OBJECT_MISSING);
	}
	if( CMDaggrX3_avg3_@1(&bn,b,g,e) == GDK_SUCCEED){
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); 
		*retid = bn->batCacheid;
		BBPkeepref(*retid);
		BBPreleaseref(b->batCacheid);
		BBPreleaseref(e->batCacheid);
		BBPreleaseref(g->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(b->batCacheid);
	BBPreleaseref(e->batCacheid);
	BBPreleaseref(g->batCacheid);
	throw(MAL, "aggrX3_avg3",GDK_EXCEPTION);
}
@c
@:AX3arithavg3(bte)@
@:AX3arithavg3(sht)@
@:AX3arithavg3(int)@
@:AX3arithavg3(wrd)@
@:AX3arithavg3(lng)@
@:AX3arithavg3(flt)@
@:AX3arithavg3(dbl)@

@- "Extremes" (Min & Max)
@c
@= AX3extreme3
aggr_export str AX3aggrX3_@13(int *ret,int *bid, int *gid, int *eid);
str AX3aggrX3_@13(int *ret,int *bid, int *gid, int *eid){
	BAT *b,*g,*e, *bn;

	if( (b= BATdescriptor(*bid)) == NULL ){
		throw(MAL, "aggr.@13", RUNTIME_OBJECT_MISSING);
	}
	if( (e= BATdescriptor(*eid)) == NULL ){
		BBPreleaseref(b->batCacheid);
		throw(MAL, "aggr.@13", RUNTIME_OBJECT_MISSING);
	}
	if( (g= BATdescriptor(*gid)) == NULL ){
		BBPreleaseref(e->batCacheid);
		BBPreleaseref(b->batCacheid);
		throw(MAL, "aggr.@13", RUNTIME_OBJECT_MISSING);
	}
	if( CMDaggrX3_@13(&bn,b,g,e) == GDK_SUCCEED){
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); 
		*ret = bn->batCacheid;
		BBPkeepref(*ret);
		BBPreleaseref(b->batCacheid);
		BBPreleaseref(e->batCacheid);
		BBPreleaseref(g->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(b->batCacheid);
	BBPreleaseref(e->batCacheid);
	BBPreleaseref(g->batCacheid);
	throw(MAL, "aggrX3_@13",GDK_EXCEPTION);
}
@c
@:AX3extreme3(min,<)@
@:AX3extreme3(max,>)@

aggr_export str AX3aggrX3_count3(int *retid, int *bid, int *gid, int *eid, bit *ignore_nils);
str
AX3aggrX3_count3(int *retid, int *bid, int *gid, int *eid, bit *ignore_nils)
{
	BAT *b, *g, *e;
	BAT *bn;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "aggr.count3", RUNTIME_OBJECT_MISSING);
	}
	if ((e = BATdescriptor(*eid)) == NULL) {
		BBPreleaseref(b->batCacheid);
		throw(MAL, "aggr.count3", RUNTIME_OBJECT_MISSING);
	}
	if ((g = BATdescriptor(*gid)) == NULL) {
		BBPreleaseref(e->batCacheid);
		BBPreleaseref(b->batCacheid);
		throw(MAL, "aggr.count3", RUNTIME_OBJECT_MISSING);
	}
	if (CMDaggrX3_count3(&bn, b, g, e, ignore_nils) == GDK_SUCCEED) {
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); 
		*retid = bn->batCacheid;
		BBPkeepref(*retid);
		BBPreleaseref(b->batCacheid);
		BBPreleaseref(e->batCacheid);
		BBPreleaseref(g->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(b->batCacheid);
	BBPreleaseref(e->batCacheid);
	BBPreleaseref(g->batCacheid);
	throw(MAL, "aggrX3_count3", GDK_EXCEPTION);
}
@-
The remainder contains the few MIL proc translations 
@c
aggr_export str AX3aggrX3_count3Nils(int *retid, int *bid, int *gid, int *eid);
str
AX3aggrX3_count3Nils(int *retid, int *bid, int *gid, int *eid)
{
	bit ignore_nils = 0;
	return AX3aggrX3_count3(retid, bid, gid, eid, &ignore_nils);
}

aggr_export str AX3count_no_nil3(int *retid, int *bid, int *gid, int *eid);
str 
AX3count_no_nil3(int *retid, int *bid, int *gid, int *eid)
{
	bit ignore_nils = TRUE;
	return AX3aggrX3_count3(retid, bid, gid, eid, &ignore_nils);
}

aggr_export str AX3aggrX3_count2Nils(int *retid, int *bid, int *eid);
str
AX3aggrX3_count2Nils(int *retid, int *bid, int *eid)
{
	bit ignore_nils = 0;
	return AX3aggrX3_count(retid, bid, eid, &ignore_nils);
}

aggr_export str AX3count_no_nil2(int *retid, int *bid, int *eid);
str
AX3count_no_nil2(int *retid, int *bid, int *eid)
{
	bit ignore_nils = TRUE;
	return AX3aggrX3_count(retid, bid, eid, &ignore_nils);
}
@-
@}
