@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.monetdb.org/Legal/MonetDBLicense

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2011 MonetDB B.V.
All Rights Reserved.
@

@f algebra2
@a Arjen P. de Vries, S. Manegold
@v 1.0
@t Work around internal select and join algorithm selection
@+ Introduction

Too many bugs.[ Unclear if this still holds]
The module is a copy of modules/contrib/malalgebra and heavily used
by Pathfinder.
The commands are added to the algebra module, because it is considered
a natural extension of the operations provided there.
@{
@mal

@= join
command algebra.@1join( left:bat[:any_1,:any_2], right:bat[:any_2,:any_3])
	:bat[:any_1,:any_3] 
address AL2@1join
comment "Hook directly into the '@1join' implementation of the join.";
@= leftjoin
command algebra.left@1join(left:bat[:any_1,:any_2], 
			right:bat[:any_2,:any_3] ) :bat[:any_1,:any_3] 
address AL2@1join
comment "Hook directly into the 'left@1join' implementation of the join.
prefix 'left' means that left and right input are not swapped during 
processing, and hence, the order of the left input's head in maintained 
in the result.";
@mal
@:join(fetch)@
@:join(merge)@
@:join(hash)@
@:leftjoin()@
@:leftjoin(fetch)@
@:leftjoin(merge)@
@:leftjoin(hash)@

command algebra.leftjoin(left:bat[:any_1,:any_2], 
			right:bat[:any_2,:any_3] ) :bat[:any_1,:any_3] 
address ALGjoin
comment "Hook directly into the 'left@1join' implementation of the join.
prefix 'left' means that left and right input are not swapped during 
processing, and hence, the order of the left input's head in maintained 
in the result.";

command algebra.leftthetajoin(left:bat[:any_1,:any_2],
			right:bat[:any_2,:any_3], mode:int ) :bat[:any_1,:any_3] 
address AL2leftthetajoin
comment "Hook directly into the 'leftthetajoin' implementation of the join.
prefix 'left' means that left and right input are not swapped during 
processing, and hence, the order of the left input's head in maintained 
in the result.";

command algebra.nlthetajoin(left:bat[:any_1,:any_2],
	right:bat[:any_2,:any_3], mode:int, estimate:lng) :bat[:any_1,:any_3] 
address AL2nlthetajoin
comment "Hook directly into the 'nested-loop-thetajoin' implementation 
	of the join. prefix 'left' means that left and right input are not 
	swapped during processing, and hence, the order of the left input's 
	head in maintained in the result.
	Also, for each left tuple, all matching right tuples will appear in 
	their order of appearrance in the right BAT. ";


@= select
command algebra.ord_@1select( b:bat[:any_1,:any_2], low:any_2,high:any_2 ) 
		:bat[:any_1, @2] 
address AL2ord_@1select
comment "Like standard '@1select(b, low, high);', but preserves the 
	order of the input BAT; (for the time being) this means, only 
	the scan-based select algorithm is used.";

command algebra.ord_@1select( b:bat[:any_1,:any_2], low:any_2, 
		high:any_2,l_in:bit,h_in:bit) :bat[:any_1, @2] 
address AL2ord_@1select_
comment "Like standard '@1select(b, low, high, l_in, h_in);', but 
		preserves the order of the input BAT (for the time being) 
		this means, only the scan-based select algorithm is used.";

command algebra.ord_@1select(b:bat[:any_1,:any_2], value:any_2) :bat[:any_1, @2] 
address AL2ord_@1select1
comment "Like standard '@1select(b, value)', but preserves the order of 
	the input BAT; (for the time being) this means, only the scan-based 
		select algorithm is used.";
@mal
@:select(,:any_2)@
@:select(u,:void)@


@- 
old stuff
@= sum
command {_csum}(BAT[oid,@1] b) : BAT[oid,@1] 
address CMDclustered_sum_@1
comment "grouped tail sum";
@:sum(bte)@
@:sum(sht)@
@:sum(int)@
@:sum(wrd)@
@:sum(lng)@
@:sum(flt)@
@:sum(dbl)@

@* Implementation Code
@h
#ifndef __MALALGEBRA_H__
#define __MALALGEBRA_H__
#include "gdk.h"

/* nothing much */

#endif /* __MALALGEBRA_H__ */

@c
#include "monetdb_config.h"
#include "algebra2.h"

/* don't reorder! */
static BAT *
BATmalleftjoin(BAT *l, BAT *r)
{
	return BATleftjoin(l, r, BUN_NONE);
}

static BAT *
BATmalfetchjoin(BAT *l, BAT *r)
{
	int rfetch = (BAThdense(r) && ATOMstorage(l->ttype) <= ATOMstorage(TYPE_oid));
	int lfetch = (BATtdense(l) && ATOMstorage(r->htype) <= ATOMstorage(TYPE_oid));

	if (lfetch && !(rfetch && BATcount(l) < BATcount(r))) {
		return BATmirror(BATfetchjoin(BATmirror(r), BATmirror(l), BUN_NONE));
	} else if (rfetch) {
		return BATfetchjoin(l, r, BUN_NONE);
	}
	GDKerror("BATmalfetchjoin: Cannot perform fetchjoin: neither left tail nor right head are dense OID columns.\n");
	return NULL;
}

/* don't reorder! */
static BAT *
BATmalleftfetchjoin(BAT *l, BAT *r)
{
	int rfetch = (BAThdense(r) && ATOMstorage(l->ttype) <= ATOMstorage(TYPE_oid));

	if (rfetch) {
		return BATleftfetchjoin(l, r, BUN_NONE);
	}
	GDKerror("BATmalleftfetchjoin: Cannot perform leftfetchjoin: right head is no dense OID column.\n");
	return NULL;
}

static BAT *
BATmalhashjoin(BAT *l, BAT *r)
{
	size_t lsize = l->H->heap.size + l->T->heap.size + (l->H->vheap ? l->H->vheap->size : 0) + (l->theap ? l->theap->size : 0);
	size_t rsize = r->H->heap.size + r->T->heap.size + (r->H->vheap ? r->H->vheap->size : 0) + (r->theap ? r->theap->size : 0);

	if (rsize < lsize) {
		return BATmirror(BAThashjoin(BATmirror(r), BATmirror(l), BUN_NONE));
	}
	return BAThashjoin(l, r, BUN_NONE);
}

/* don't reorder! */
static BAT *
BATmallefthashjoin(BAT *l, BAT *r)
{
	return BAThashjoin(l, r, BUN_NONE);
}

static BAT *
BATmalmergejoin(BAT *l, BAT *r)
{
	if (!((BATtordered(l) & 1) || (BAThordered(r) & 1))) {
		GDKerror("BATmalmergejoin: Cannot perform mergejoin: neither left tail nor right head is ordered.\n");
		return NULL;
	}
/*
 * Stefan: There is no reason not to perform a mergejoin on voids, is there?
 *
  if ( (l->ttype==TYPE_void) || (r->htype==TYPE_void) ) {
	GDKerror( "BATmalmergejoin: Cannot perform mergejoin on void fields.\n" );
	return NULL;
  }
*/
	return BATmergejoin(l, r, BUN_NONE);
}

/* don't reorder! */
static BAT *
BATmalleftmergejoin(BAT *l, BAT *r)
{
	if (!(BAThordered(r) & 1)) {
		GDKerror("BATmalleftmergejoin: Cannot perform leftmergejoin: right head is ordered.\n");
		return NULL;
	}
	return BATleftmergejoin(l, r, BUN_NONE);
}

BAT *
BATmalindexjoin(BAT *l, BAT *r)
{
	if (l->ttype == TYPE_void && r->htype == TYPE_void) {
		GDKerror("BATmalindexjoin: Cannot perform indexjoin on void columns.\n");
		return NULL;
	}
	return BATindexjoin(l, r, BUN_NONE);
}

/* don't reorder! */
BAT *
BATmalleftindexjoin(BAT *l, BAT *r)
{
	if (r->htype == TYPE_void) {
		GDKerror("BATmalleftindexjoin: Cannot perform leftindexjoin: right head must not be void.\n");
		return NULL;
	}
	return BATleftindexjoin(l, r, BUN_NONE);
}

@= joincmd
int CMD@1join(BAT **result, BAT *left, BAT* right) {
  ERRORcheck(left == NULL, "@1-join: invalid left operand"); 
  ERRORcheck(right == NULL, "@1-join: invalid right operand"); 
  ERRORcheck(TYPEerror(left->ttype, right->htype), "@1-join: type conflict\n"); 
  return (*result = (BAT*) BATmal@1join(left, right))?GDK_SUCCEED:GDK_FAIL;
}
@c
@:joincmd(left)@
@:joincmd(fetch)@
@:joincmd(leftfetch)@
@:joincmd(merge)@
@:joincmd(leftmerge)@
@:joincmd(hash)@
@:joincmd(lefthash)@

int
CMDleftthetajoin(BAT **result, BAT *l, BAT *r, int *mode)
{
	return (*result = BATleftthetajoin(l, r, *mode, MIN(BATcount(l), BATcount(r)))) ? GDK_SUCCEED : GDK_FAIL;
}

int
CMDnlthetajoin(BAT **result, BAT *l, BAT *r, int *mode, lng *estimate)
{
	return (*result = BATnlthetajoin(l, r, *mode, *estimate == lng_nil || *estimate < 0 ? BUN_NONE : (*estimate >= BUN_MAX ? BUN_MAX : (BUN) *estimate))) ? GDK_SUCCEED : GDK_FAIL;
}

@= selectcmd
int CMDord_@1select1(BAT **result, BAT* b, ptr value) {
	return (*result = BAT_select_(b, value, 0, TRUE, TRUE, @2, FALSE, TRUE))?GDK_SUCCEED:GDK_FAIL;
}
int CMDord_@1select(BAT **result, BAT *b, ptr low, ptr high) {
	return (*result = BAT_select_(b, low, high, TRUE, TRUE, @2, FALSE, TRUE))?GDK_SUCCEED:GDK_FAIL;
}
int CMDord_@1select_(BAT **result, BAT *b, ptr low, ptr high, bit* l_in, bit* h_in) {
	int tt = b->ttype;
	ptr nil = ATOMnilptr(tt);
	if (*l_in == bit_nil && ATOMcmp(tt, low, nil)) {
		GDKerror("CMDord_@1select: flag 'l_in' must not be NIL, unless boundary 'low' is NIL\n");
		return GDK_FAIL;
	}
	if (*h_in == bit_nil && ATOMcmp(tt, high, nil)) {
		GDKerror("CMDord_@1select: flag 'h_in' must not be NIL, unless boundary 'high' is NIL\n");
		return GDK_FAIL;
	}
	return (*result = BAT_select_(b, low, high, *l_in, *h_in, @2, FALSE, TRUE))?GDK_SUCCEED:GDK_FAIL;
}
@c
@:selectcmd(,TRUE)@
@:selectcmd(u,FALSE)@


@= sumcmd
int CMDclustered_sum_@1(BAT **ret, BAT *b ) {
	BATiter bi = bat_iterator(b);
	BAT *bn = BATnew(b->htype, BATttype(b), BATcount(b));	
	BUN p, q;
	oid cur;
	@1 sum = 0;

	bn->hsorted = b->hsorted;
	bn->tsorted = 0;
	bn->H->nonil = b->H->nonil;
	bn->T->nonil = 0;
	if (BATcount(b))
 		cur = *(oid*)BUNhead(bi,BUNfirst(b));
	BATaccessBegin(b,USE_HEAD|USE_TAIL,MMAP_SEQUENTIAL);
	BATloop(b, p, q) {
		oid *h = (oid*) BUNhead(bi,p);
		@1 *t = (@1*) BUNtail(bi,p);

		if (cur != *h){
			BUNfastins(bn, &cur, &sum );
			cur = *h;
			sum = 0;
		}
		sum += *t;
	}
	BATaccessEnd(b,USE_HEAD|USE_TAIL,MMAP_SEQUENTIAL);
	if (BATcount(b))
		BUNfastins(bn, &cur, &sum );

	*ret = bn;
	return GDK_SUCCEED;
}
@c
@:sumcmd(bte)@
@:sumcmd(sht)@
@:sumcmd(int)@
@:sumcmd(wrd)@
@:sumcmd(lng)@
@:sumcmd(flt)@
@:sumcmd(dbl)@

@}
@-
@include ../mal/prelude.mx
@-
@c
#include "algebra.h"
#include "algebra2.h"

@= joincmdMAL
algebra_export str AL2@1join(int *ret, int *lid, int *rid );
str AL2@1join(int *ret, int *lid, int *rid ){
	BAT *bn,*left, *right;
	if( (left= BATdescriptor(*lid)) == NULL ){
		return throwMessage("algebra.@1join", RUNTIME_OBJECT_MISSING);
	}

	if( (right= BATdescriptor(*rid)) == NULL ){
		BBPreleaseref(left->batCacheid);
		return throwMessage("algebra.@1join", RUNTIME_OBJECT_MISSING);
	}
  	bn = (BAT*) BATmal@1join(left, right);
	BBPreleaseref(left->batCacheid);
	BBPreleaseref(right->batCacheid);
	if( bn == NULL)
		return throwMessage("@1join",GDK_EXCEPTION);
	*ret = bn->batCacheid;
	BBPkeepref(*ret);
	return MAL_SUCCEED;
}
@c
@:joincmdMAL(left)@
@:joincmdMAL(fetch)@
@:joincmdMAL(leftfetch)@
@:joincmdMAL(merge)@
@:joincmdMAL(leftmerge)@
@:joincmdMAL(hash)@
@:joincmdMAL(lefthash)@
@:joincmdMAL(index)@
@:joincmdMAL(leftindex)@

algebra_export str AL2leftthetajoin(int *ret, int *lid, int *rid, int *mode);
str
AL2leftthetajoin(int *ret, int *lid, int *rid, int *mode)
{
	BAT *bn, *l, *r;

	if ((l = BATdescriptor(*lid)) == NULL) {
		return throwMessage("algebra.@1join", RUNTIME_OBJECT_MISSING);
	}
	if ((r = BATdescriptor(*rid)) == NULL) {
		BBPreleaseref(l->batCacheid);
		return throwMessage("algebra.@1join", RUNTIME_OBJECT_MISSING);
	}
	bn = BATleftthetajoin(l, r, *mode, MIN(BATcount(l), BATcount(r)));
	BBPreleaseref(l->batCacheid);
	BBPreleaseref(r->batCacheid);

	if (bn == NULL)
		return throwMessage("algebra2.leftthetajoin", GDK_EXCEPTION);
	*ret = bn->batCacheid;
	BBPkeepref(*ret);
	return MAL_SUCCEED;
}

algebra_export str AL2nlthetajoin(int *ret, int *lid, int *rid, int *mode, lng *estimate);
str
AL2nlthetajoin(int *ret, int *lid, int *rid, int *mode, lng *estimate)
{
	BAT *bn, *l, *r;

	if ((l = BATdescriptor(*lid)) == NULL) {
		return throwMessage("algebra.@1join", RUNTIME_OBJECT_MISSING);
	}
	if ((r = BATdescriptor(*rid)) == NULL) {
		BBPreleaseref(l->batCacheid);
		return throwMessage("algebra.@1join", RUNTIME_OBJECT_MISSING);
	}
	bn = BATnlthetajoin(l, r, *mode, *estimate == lng_nil || *estimate < 0 ? BUN_NONE : (*estimate >= BUN_MAX ? BUN_MAX : (BUN) *estimate));
	BBPreleaseref(l->batCacheid);
	BBPreleaseref(r->batCacheid);
	if (bn == NULL)
		return throwMessage("algebra2.thetajoin", GDK_EXCEPTION);
	*ret = bn->batCacheid;
	BBPkeepref(*ret);
	return MAL_SUCCEED;
}

@= selectcmdMAL
algebra_export str AL2ord_@1select1(int *ret, int * bid, ptr *value);
str AL2ord_@1select1(int *ret, int * bid, ptr *value) {
	BAT *bn, *b;
	if( (b= BATdescriptor(*bid)) == NULL ){
		 return throwMessage("algebra2.select", RUNTIME_OBJECT_MISSING);
	}

	bn = BAT_select_(b, *value, 0, TRUE, TRUE, @2, TRUE);
	BBPreleaseref(b->batCacheid);
	if( bn == NULL)
		return throwMessage("ord_@1select",GDK_EXCEPTION);
	*ret = bn->batCacheid;
	BBPkeepref(*ret);
	return MAL_SUCCEED;
}
algebra_export str AL2ord_@1select(int *ret, int *bid, ptr *low, ptr *high);
str AL2ord_@1select(int *ret, int *bid, ptr *low, ptr *high) {
	BAT *bn, *b;
	if( (b= BATdescriptor(*bid)) == NULL ){
		 return throwMessage("algebra2.@1select", RUNTIME_OBJECT_MISSING);
	}
	bn = BAT_select_(b, *low, *high, TRUE, TRUE, @2, TRUE);
	BBPreleaseref(b->batCacheid);
	if( bn == NULL)
		return throwMessage("ord_@1select",GDK_EXCEPTION);
	*ret = bn->batCacheid;
	BBPkeepref(*ret);
	return MAL_SUCCEED;
}
algebra_export str AL2ord_@1select_(int *ret, int *bid, ptr *lval, ptr *hval, bit *l_in, bit *h_in);
str AL2ord_@1select_(int *ret, int *bid, ptr *lval, ptr *hval, bit *l_in, bit *h_in){
	ptr low=*lval, high= *hval;
	int tt ;
	ptr nil ;
	BAT *bn, *b;
	if( (b= BATdescriptor(*bid)) == NULL ){
		 return throwMessage("algebra2.@1select", RUNTIME_OBJECT_MISSING);
	}
	tt = b->ttype;
	nil = ATOMnilptr(tt);

	if (*l_in == bit_nil && ATOMcmp(tt, low, nil)) 
		return throwMessage("AL2ord_@1select", ILLEGAL_ARGUMENT
			" Flag 'l_in' must not be NIL, unless boundary 'low' is NIL\n");
	if (*h_in == bit_nil && ATOMcmp(tt, high, nil)) 
		return throwMessage("AL2ord_@1select", ILLEGAL_ARGUMENT
			" Flag 'h_in' must not be NIL, unless boundary 'high' is NIL\n");
	bn = BAT_select_(b, low, high, *l_in, *h_in, @2, TRUE);
	BBPreleaseref(b->batCacheid);
	if( bn == NULL)
		return throwMessage("ord_@1select",GDK_EXCEPTION);
	*ret = bn->batCacheid;
	BBPkeepref(*ret);
	return MAL_SUCCEED;
}
@c
@:selectcmdMAL(, TRUE)@
@:selectcmdMAL(u, FALSE)@


@= jointest_void
VAR @1result_void := @1join( l, r );
@
@= jointest_oid
VAR @1result_oid := @1join( [oid](l), [oid](r.reverse()).reverse() );
@
@= compresults
@:jointest_@2(@1)
IF( not( isnil(@1result_@2) ) ) {
  Ndiff := diff( result_@2, @1result_@2 ).count();
  printf( "Algorithm @1 leads to %d different answers.\n", Ndiff );
  IF (Ndiff>0) {
	Ntestfailed :+= 1;
	print(result_@2);
	print(@1result_@2);
	print(diff(result_@2,@1result_@2));
	print(diff(@1result_@2,result_@2));
  }
}
@
