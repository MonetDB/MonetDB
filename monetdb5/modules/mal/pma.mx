@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2011 MonetDB B.V.
All Rights Reserved.
@

@f pma
@a N.Tang and P.Boncz
@+ PMA Organized BAT
The database columns have high maintance cost for inserting/deleting items,
while keeping some specific columns sorted. Basically, to insert/delete an
item to a sorted column in size n will render O(n) items to move. With PMA,
however, normal insertion/deletion have only O(log^n) amortized item movement.
PMA leaves gaps between items, to ensure that to operate on a particular item,
only a few items around the particular item are required to move.

Different from traditional PMA, our PMA fnd function returns a range which
may contains some items with equivalent values. This design is to facilitate
the relational table sorting in multiple columns (i.e. attribute), e.g., to
sort a table of students on age first, and then on their names.

@mal
module pma;

command new(tpe:int, sze:wrd) :bat[:oid,:any_1]
address PMAnew_wrd
comment "create a new empty PMA-organized BAT (PMA for short)";

@= pma_mal
command ins(b:bat[:oid,:@1], pos:oid, val:@1) :oid
address PMAins_@1
comment "insert a value into a PMA at some position";

command bulkins(b:bat[:oid,:@1], pos:oid, bi:bat[:oid,:@1]) :oid
address PMAbulkins_@1
comment "insert a bat into a PMA at some position";

command del(b:bat[:oid,:@1], pos:oid) :void
address PMAdel_@1
comment "delete a value from a PMA BAT at some position";

command bulkdel(b:bat[:oid,:@1], lo:oid, hi:oid) :void
address PMAbulkdel_@1
comment "delete all values from a range lo to hi";

command fnd(b:bat[:oid, :@1], lo:oid, hi:oid, val:@1) (:oid,:oid)
address PMAfnd_@1
comment "look up the range where a value occurs in a PMA";

command testins(b:bat[:oid,:@1], num:int) :void
address PMAtestins_@1
comment "test the function of insertion"

command testdel(b:bat[:oid,:@1]) :void
address PMAtestdel_@1
comment "test the function of deletion"

@mal
@:pma_mal(chr)@
@:pma_mal(bte)@
@:pma_mal(sht)@
@:pma_mal(int)@
@:pma_mal(wrd)@
@:pma_mal(lng)@
@:pma_mal(flt)@
@:pma_mal(dbl)@

@+ PMA API
@h
#ifndef _PMA_H_
#define _PMA_H_

#ifdef WIN32
#if !defined(LIBMAL) && !defined(LIBATOMS) && !defined(LIBKERNEL) && !defined(LIBMAL) && !defined(LIBOPTIMIZER) && !defined(LIBSCHEDULER) && !defined(LIBMONETDB5)
#define pma_export extern __declspec(dllimport)
#else
#define pma_export extern __declspec(dllexport)
#endif
#else
#define pma_export extern
#endif

#include <gdk.h>
pma_export str PMAnew_wrd(bat *res, int *tpe, wrd *sz);
@= pma_decl
pma_export str PMAins_@1(oid *pos_res, bat *b, oid *pos, @1 *val);
pma_export str PMAbulkins_@1(oid *pos_res, bat *b, oid *pos, bat *bi);
pma_export str PMAdel_@1(void *dummy, bat *b, oid *pos);
pma_export str PMAbulkdel_@1(void *dummy, bat *b, oid *lo, oid *hi);
pma_export str PMAfnd_@1(oid *lo_res, oid *hi_res, bat *b, oid *lo, oid *hi, @1 *val);
pma_export str PMAtestins_@1(void *dummy, bat *b, int *val);
pma_export str PMAtestdel_@1(void *dummy, bat *b);
@h
@:pma_decl(chr)@
@:pma_decl(bte)@
@:pma_decl(sht)@
@:pma_decl(int)@
@:pma_decl(wrd)@
@:pma_decl(lng)@
@:pma_decl(flt)@
@:pma_decl(dbl)@
#endif	/* _PMA_H_ */

@+ PMA implementation
@c
#include "monetdb_config.h"
#include "mal_exception.h"
#include "pma.h"
#include <math.h>

#define Dmax 1
#define Dmin 0.1
#define TaoMin 0.5
#define RouMax 0.2

#define PMA_SHT 4
#define PMA_SEG 16

@= fillnill
{	@1 *cur = (@1 *) Tloc(b, BUNfirst(b));
	for (i = 0; i < cnt; i++) cur[i] = @2;
	break;
}

@c
static str
PMAnew(bat *res, int *tpe, BUN *sz) {
	BAT *b;
	BUN cnt, i;
	if (*tpe < 0)
		throw(MAL,"pma.new","tpe argument is incorrect");
	if (ATOMstorage(*tpe) == TYPE_void || ATOMstorage(*tpe) > TYPE_lng)
		throw(MAL,"pma.new","tpe not supported (yet?)");
	for (cnt = PMA_SEG; cnt < *sz; cnt <<= 1);	/* figure out the size */
	b = BATnew(TYPE_void, *tpe, cnt);
	if (b) {
		switch(ATOMstorage(*tpe)) {
		case TYPE_chr: @:fillnill(chr, chr_nil)@
		case TYPE_bte: @:fillnill(bte, bte_nil)@
		case TYPE_sht: @:fillnill(sht, sht_nil)@
		case TYPE_int: @:fillnill(int, int_nil)@
		case TYPE_lng: @:fillnill(lng, lng_nil)@
		case TYPE_flt: @:fillnill(flt, flt_nil)@
		case TYPE_dbl: @:fillnill(dbl, dbl_nil)@
		case TYPE_ptr: @:fillnill(ptr, ptr_nil)@
		default:		BBPunfix(b->batCacheid);
						throw(MAL,"pma.new","tpe not supported (yet?)");
		}
		BATsetcount(b, cnt);
		b->tsorted = 0;
		BATkey(BATmirror(b), FALSE);
		BBPkeepref(*res = b->batCacheid);
		return MAL_SUCCEED;
	}
	throw(MAL,"pma.new","pma allocation failed");
}

pma_export str
PMAnew_wrd(bat *res, int *tpe, wrd *_sz) {
	BUN sz;
	if (*_sz <= 0)
		throw(MAL,"pma.new","size must be > 0");
	if (*_sz > (wrd) BUN_MAX)
		throw(MAL,"pma.new","size must be <= "BUNFMT, BUN_MAX);
	sz = (BUN) *_sz;
	return PMAnew(res, tpe, &sz);
}

@= pma_impl
pma_export str
PMAins_@1(oid *pos_res, bat *bid, oid *pos, @1 *val) {
	bit fgw, fg;
	BUN i, j, k, lt, rt, ht, sz , psz, cnt, lv, wsz, snum, scl, scr, wbeg, wend, mpos, slen;
	dbl dens, dent, step;
	BAT *b;
	@1 *base;

	b =  BATdescriptor(*bid);
	if (b == NULL) throw(MAL,"pma.ins","illegal bat parameter");
	base = (@1*) Tloc(b, BUNfirst(b));
	sz = PMA_SEG;
	psz = BATcount(b);
	for (ht = 0; psz > sz; sz <<= 1) ht++;
	if (psz != sz) throw(MAL,"pma.ins","illegal bat size");
	if (ht == 0) {
		dent = TaoMin;
		step = 0;
	} else {
		dent = Dmax;
		step = (Dmax - TaoMin) / ht;
	}
	fgw = FALSE;
	lv = cnt = 0;
	mpos = *pos;
	if (*pos == psz) mpos--;	/* new value is largest, and the last bat cell is not empty */
	snum = mpos >> PMA_SHT;	/* segment number of $pos */
	while (!fgw) {	/* search a window to insert the new value, in a bottom-up fashion */
		wsz = PMA_SEG << lv;
		if (lv == 0) {
			scl = snum << PMA_SHT;
			scr = scl + wsz;
		} else {
			wbeg = (snum >> lv) << lv << PMA_SHT;
			scl = wbeg;
			scr = wbeg + (wsz >> 1);
			if (mpos < wbeg + (wsz >> 1)) {
				scl += (wsz >> 1);
				scr += (wsz >> 1);
			}
		}
		for (i = scl; i < scr; i++) {
			if (base[i] != @1_nil) cnt++;
		}
		dens = (dbl)(cnt + 1) / wsz;
		lv++;
		if (dens <= dent) fgw = TRUE;	/* find an appropriate window */
		else if (lv > ht) break;		/* current BAT has no space */
		else              dent -= step;	/* scan the parent window */
	}
	lv--;
	fg = FALSE;
	if (fgw){
		if (*pos == psz) {
			wbeg = (snum >> lv) << lv << PMA_SHT;
			for (i = j = wbeg; i < *pos; i++) {
				if (base[i] == @1_nil) {
					fg = TRUE;
				} else if (fg || i > j + 1) {
					j = (j + i) >> 1;
					base[j] = base[i];
					base[i] = (@1)@1_nil;
					fg = FALSE;
				} else {
					j = i;
				}
			}
			*pos_res = (j + *pos) >> 1;
		} else {
			if (lv == 0) {	/* the botttom segment [scl, scr) has space */
				for (i = mpos; i >= scl; i--) {
					if (base[i]==@1_nil) fg = TRUE;
					else if (fg)         break;	/* not a hole and have space between i to mpos */
					if (i == scl)        break;
				}
				if (i != scl)                     lt = i;		/* find a hole */
				else if (base[scl]==@1_nil || fg) lt = scl;		/* all left parts are holes, with consecutive elements */
				else                              lt = mpos;	/* no space on the left */
				for (i = mpos, fg = FALSE; i < scr; i++) {
					if (base[i] == @1_nil) fg = TRUE;
					else if (fg)           break;
				}
				if (i < scr)                    rt = i;
				else if (base[scr-1] == @1_nil) rt = scr-1;	/* consecutive elements, with all right parts are holes */
				else                            rt = mpos;	/* no space on the right */
				if (lt == rt) {
					assert(base[lt] == @1_nil);	/* since there must have space in this segment */
				} else {
					if (base[lt] != @1_nil && lt != mpos) lt++;
					for (i = lt; i < mpos; i++) {
						if (base[i] != @1_nil) {
							j = (i + lt) >> 1;
							base[j] = base[i];
							base[i] = (@1)@1_nil;
							lt = j;
						}
					}
					for (i = rt - 1; i >= mpos; i--) {
						if (base[i] != @1_nil) {
							j = (i + rt) >> 1;
							if (base[j] != @1_nil) j++;
							base[j] = base[i];
							base[i] = (@1)@1_nil;
							rt = j;
						}
						if (i == mpos) break;
					}
				}
				*pos_res = (lt + rt) >> 1;
				if (base[*pos_res] != @1_nil) (*pos_res)++;
			} else {	/* rebalance */
				/* An implicit rebalance consists of two scans, one to the left and one the right
				 * of the insertion point until we find a region of the appropriate density
				 */
				wbeg = (snum >> lv) << lv << PMA_SHT;
				wend = wbeg + wsz - 1;
				if (mpos >= wbeg + (wsz>>1)) {	/* rebalance on the left */
					for (i = j = wbeg; i < mpos; i++) {
						if (base[i] == @1_nil) {
							fg = TRUE;
						} else if (fg || i > j + 1) {
							j = (j + i) >> 1;
							base[j] = base[i];
							base[i] = (@1)@1_nil;
							fg = FALSE;
						} else {
							j = i;
						}
					}
				} else {	/* rebalance on the right */
					for (i = j = wend; i >= mpos; i--) {
						if (base[i] == @1_nil) {
							fg = TRUE;
						} else if (fg || j > i + 1) {
							j = (j + i) >> 1;
							if (j == i) j++;
							base[j] = base[i];
							base[i] = (@1)@1_nil;
							fg = FALSE;
						} else {
							j = i;
						}
						if (i == mpos) break;
					}
				}
				*pos_res = (j + mpos) >> 1;
			}
		}
	} else {	/* extend to a double sized new PMA-managed BAT */
		psz <<= 1;
		if ((b = BATextend(b, (BUN)psz)) == NULL) throw(MAL,"pma.ins","BATextend fails");
		BATsetcount(b, psz);
		b->tsorted = 0;
		BATkey(BATmirror(b), FALSE);
		BBPkeepref(*bid = b->batCacheid);
		base = (@1*) Tloc(b, BUNfirst(b));
		slen = (psz + cnt) / (cnt + 1);
		for (k = psz - 1; k >= (psz>>1); k--) base[k] = (@1)@1_nil;
		if (cnt * slen + 1 > psz) slen--;
		j = psz - 1;
		i = (psz>>1) - 1;
		if (*pos == psz>>1) {
			*pos_res = j;
			for (k = 1; k < slen; k++) base[j-k] = (@1)@1_nil;
			j -= slen;
			for (; i > 0; i--) {
				if (base[i] != @1_nil) {
					base[j] = base[i];
					base[i] = (@1)@1_nil;
					for (k = 1; k < slen; k++) base[j-k] = (@1)@1_nil;
					j -= slen;
				}
				if (i == 0 || j <= slen || j < i) break;
			}
		} else {
			for (; i >= mpos; i--) {
				if (j <= i) break;
				if (base[i] != @1_nil) {
					base[j] = base[i];
					base[i] = (@1)@1_nil;
					for (k = 1; k < slen; k++) base[j-k] = (@1)@1_nil;
					j -= slen;
				}
				if (i == mpos) break;
			}
			*pos_res = j;
			for (k = 1; k < slen; k++) 	base[j-k] = (@1)@1_nil;
			j -= slen;
			assert(j + slen > i);
			for (; i > 0; i--) {
				if (j < i + slen) break;
				if (base[i] != @1_nil) {
					base[j] = base[i];
					base[i] = (@1)@1_nil;
					for (k = 1; k < slen; k++) base[j-k] = (@1)@1_nil;
					j -= slen;
				}
				if (i == 0) break;
			}
		}
	}
	/* check only, for debugging */
	/*for (i = *pos_res; i > 0; i--) {
		if (base[i] == @1_nil) continue;
		else if (base[i] > *val) { printf("PMAins before: %d\n", i); assert(0); }
		else if (base[i] < *val) break;
		if (i == 0) break;
	}
	for (i++; i < psz; i++) {
		if (base[i] == @1_nil) continue;
		else if (base[i] < *val) { printf("PMAfnd after: %d\n", i); assert(0); }
		else if (base[i] > *val) break;
	}*/
	/* ~check only, for debugging */
	assert(base[*pos_res] == @1_nil);
	base[*pos_res] = *val;
	return MAL_SUCCEED;
}

pma_export str
PMAdel_@1(void *dummy, bat *bid, oid *pos) {
	bit fg, fgw;
	BUN i, j, ht, sz, wsz, psz, wbeg, lv, snum, scl, scr, cnt, slen, nsz;
	int tpe;
	dbl dens, dent, step;
	bat ret;
	BAT *b, *bn;
	@1 *base, *basen;
	(void)dummy;
	b = BATdescriptor(*bid);
	if (b == NULL) throw(MAL,"pma.del","illegal bat parameter");
	psz = BATcount(b);
	sz = PMA_SEG;
	for(ht = 0; psz > sz; sz <<= 1) ht++;
	if (psz != sz) throw(MAL,"pma.del","illegal bat size");
	base = (@1 *) Tloc(b, BUNfirst(b));
	if (base[*pos] == @1_nil) return MAL_SUCCEED;
	base[*pos] = (@1)@1_nil;
	dent = Dmin;
	(ht == 0) ? (step = 0) : (step = (RouMax - Dmin) / ht);
	fgw = FALSE;
	lv = cnt = 0;
	snum = *pos >> PMA_SHT;
	while (!fgw && lv <= ht) {
		wsz = PMA_SEG << lv;
		if (lv == 0) {
			wbeg = 0;
			scl = snum << PMA_SHT;
			scr = scl + wsz;
		} else {
			scl = wbeg = (snum >> lv) << lv << PMA_SHT;
			scr = wbeg + (wsz >> 1);
			if (*pos < wbeg + (wsz >> 1)) {
				scl += (wsz >> 1);
				scr += (wsz >> 1);
			}
		}
		for (i = scl; i < scr; i++) {
			if (base[i] != @1_nil) cnt++;
		}
		dens = (dbl)cnt / wsz;
		lv++;
		(dens > dent) ? (fgw = TRUE) : (dent += step);
	}
	if (!fgw) {	/* the whole PMA is required to be rebalanced */
		if (cnt == 0) {	/* an empty PMA */
			BATdelete(b);
			bid = NULL;
		} else if (psz != PMA_SEG){	/* shrink this PMA into half size */
			tpe = TYPE_@1;
			psz >>= 1;
			nsz = psz;
			PMAnew(&ret, &tpe, &nsz);
			*bid = ret;
			bn = BATdescriptor(ret);
			basen = (@1*)Tloc(bn, BUNfirst(bn));
			slen = (psz + cnt - 1) / cnt;
			if ((cnt - 1) * slen + 1 > psz) slen--;
			for (i = j = 0; i < sz; i++) {
				if (base[i] != @1_nil) {
					basen[j] = base[i];
					j += slen;
				}
			}
			BATdelete(b);
		} /* else: only 1 segment, simply delete the element */
	} else {	/* a window is required to be rebalanced */
		fg = FALSE;
		if (*pos >= wbeg + (wsz>>1)) {	/* rebalance from the beginning of the window */
			for (i = j = wbeg; i < wbeg + wsz; i++) {
				if (base[i] == @1_nil) {
					fg = TRUE;
				} else if (fg) {
					j = (j + i) >> 1;
					base[j] = base[i];
					base[i] = (@1)@1_nil;
					fg = FALSE;
				} else {
					j = i;
				}
			}
		} else {	/* rebalance from the end of the window */
			for (i = j = wbeg + wsz - 1; i >= wbeg; i--) {
				if (base[i] == @1_nil) {
					fg = TRUE;
				} else if (fg) {
					j = (j + i) >> 1;
					base[j] = base[i];
					base[i] = (@1)@1_nil;
					fg = FALSE;
				} else {
					j = i;
				}
				if (i == 0) break;
			}
		}
	}
	return MAL_SUCCEED;
}

pma_export str
PMAbulkdel_@1(void *dummy, bat *bid, oid *lo, oid *hi) {
	BUN i, j, k, ht, lv, snum, wbeg, wsz, sz, psz, cnt, icnt, scl, scr, nsz, slen;
	bit fg, fgw;
	dbl dens, dent, step;
	int tpe;
	bat ret;
	BAT *b, *bn;
	@1 *base, *basen;
	b = BATdescriptor(*bid);
	psz = BATcount(b);
	if (b == NULL) throw(MAL,"pma.bulkdel","illegal bat parameter");
	if (*lo > *hi || *hi > psz) return MAL_SUCCEED;
	if (*lo == *hi) return PMAdel_@1(dummy, bid, hi);
	sz = PMA_SEG;
	for(ht = 0; psz > sz; sz <<= 1) ht++;
	if (psz != sz) throw(MAL,"pma.bulkdel","illegal bat size");
	(ht == 0) ? (step = 0) : (step = (RouMax - Dmin) / ht);
	base = (@1 *) Tloc(b, BUNfirst(b));
	icnt = 0;
	for (i = *lo; i <= *hi; i++) {
		if (base[i] != @1_nil) {
			base[i] = (@1)@1_nil;
			icnt++;
		}
	}
	if (icnt == 0) return MAL_SUCCEED;
	snum = *lo >> PMA_SHT;
	lv = 0;
	dent = Dmin;
	while (TRUE) {
		wsz = PMA_SEG << lv;
		wbeg = (snum >> lv) << lv << PMA_SHT;
		if (wbeg + wsz > *hi) break;
		lv++;
		dent += step;
	}
	cnt = 0;
	for (i = wbeg; i < *lo; i++) {
		if (base[i] != @1_nil) cnt++;
	}
	j = wbeg + wsz;
	for (i = *hi + 1; i < j; i++) {
		if (base[i] != @1_nil) cnt++;
	}
	dens = (dbl)cnt / wsz;
	fgw = (dens > dent ? TRUE : FALSE);
	lv++;
	while (!fgw && lv <= ht) {
		wsz = PMA_SEG << lv;
		scl = wbeg = (snum >> lv) << lv << PMA_SHT;
		scr = wbeg + (wsz >> 1);
		if (*lo < wbeg + (wsz >> 1)) {
			scl += wsz >> 1;
			scr += wsz >> 1;
		}
		for (i = scl; i < scr; i++) {
			if (base[i] != @1_nil) cnt++;
		}
		dens = (dbl)cnt / wsz;
		lv++;
		(dens > dent) ? (fgw = TRUE) : (dent += step);
	}
	lv--;
	if (!fgw) {	/* the whole PMA is required to be rebalanced */
		if (cnt == 0) {	/* an empty PMA */
			BATdelete(b);
			bid = NULL;
		} else if (psz != PMA_SEG){	/* shrink this PMA into half size */
			tpe = TYPE_@1;
			psz >>= 1;
			nsz = psz;
			PMAnew(&ret, &tpe, &nsz);
			*bid = ret;
			bn = BATdescriptor(ret);
			basen = (@1*)Tloc(bn, BUNfirst(bn));
			slen = (psz + cnt - 1) / cnt;
			if ((cnt - 1) * slen + 1 > psz) slen--;
			for (i = j = 0; i < sz; i++) {
				if (base[i] != @1_nil) {
					basen[j] = base[i];
					j += slen;
				}
			}
			BATdelete(b);
		} /* else: only 1 segment, simply delete the element */
	} else {	/* a window is required to be rebalanced */
		fg = FALSE;
		if (*lo >= wbeg + (wsz >> 1)) {	/* rebalance from the beginning of the window */
			k = wbeg + wsz;
			for (i = j = wbeg; i < k; i++) {
				if (base[i] == @1_nil) {
					fg = TRUE;
				} else if (fg) {
					j = (j + i) >> 1;
					base[j] = base[i];
					base[i] = (@1)@1_nil;
					fg = FALSE;
				} else {
					j = i;
				}
			}
		} else {	/* rebalance from the end of the window */
			for (i = j = wbeg + wsz - 1; i >= wbeg; i--) {
				if (base[i] == @1_nil) {
					fg = TRUE;
				} else if (fg) {
					j = (j + i) >> 1;
					base[j] = base[i];
					base[i] = (@1)@1_nil;
					fg = FALSE;
				} else {
					j = i;
				}
				if (i == 0) break;
			}
		}
	}
	return MAL_SUCCEED;
}

pma_export str
PMAfnd_@1(oid *lo_res, oid *hi_res, bat *bid, oid *lo, oid *hi, @1 *val) {
	BAT* b = BATdescriptor(*bid);
	BUN i, md, h, l;
	@1 *base;
	if (b == NULL) throw(MAL,"pma.fnd","illegal bat parameter");
	if (*lo > *hi) throw(MAL,"pma.fnd","low>high");
	base = (@1*) Tloc(b, BUNfirst(b));
	if (*lo == *hi) md = *lo;
	h = *hi;
	l = *lo;
	while (l <= h) {
		md = l + ((h - l) >> 1);
		if (md == l) {
			if (l < h && (base[l] == @1_nil || base[l] <= *val) ) md = h;
			/* if (l<h && (base[l]==@1_nil || base[l]<*val) && (base[h]==@1_nil || base[h]<=*val)) md = h;*/
			break;
		}
		if (base[md] == @1_nil) {
			for (i = md - 1; i >= l; i--) {
				if (base[i] != @1_nil || i == l) break;
			}
			if (base[i] != @1_nil) {
				if (base[i] == *val) {
					md = i;
					break;
				} else if (base[i] > *val) {
					h = i;
					if (i > l && (base[i-1] == @1_nil || base[i-1] > *val)) h--;
				} else {
					l = i;
					if (i < h) l++;
				}
				continue;
			}
			/* now, all elements from l to md are empty */
			for (i = md; i <= h; i++) {
				if (base[i] != @1_nil || i == h) break;
			}
			if (base[i] != @1_nil) {
				if (base[i] == *val) {
					md = i;
					break;
				} else if (base[i] > *val) {
					h = i;
					if (i > l && (base[i-1] == @1_nil || base[i-1] > *val)) h--;
				} else {
					l = i;
					if (l < h) l++;
				}
				continue;
			} else {	/* all elements from md to h are empty */
				md = l;
				break;
			}
		} else {
			if (base[md] < *val) {
				l = md + 1;
			} else if (base[md] > *val) {
				h = md;
				if (base[h-1] == @1_nil || base[h-1] > *val) h--;
			} else {
				break;
			}
		}
	}
	if (base[md] == @1_nil) {
		*lo_res = *hi_res = md;
	} else if (base[md] != *val) {
		*lo_res = *hi_res = md;
		if (base[md] != @1_nil && base[md] <= *val) *lo_res = *hi_res = md + 1;
	} else {	/* scan the adjacent elements of md */
		*lo_res = *hi_res = md;
		for (i = md; i >= l; i--) {
			if (base[i] == @1_nil)    continue;
			else if (base[i] == *val) *lo_res = i;
			else if (base[i] < *val)  break;
			else                      throw(MAL,"pma.fnd","pma not ordered");
			if (i == l) break;
		}
		for (i = md + 1; i <= h; i++) {
			if (base[i] == @1_nil)    continue;
			else if (base[i] == *val) *hi_res = i;
			else if (base[i] > *val)  break;
			else                      throw(MAL,"pma.fnd","pma not ordered");
		}
	}
	return MAL_SUCCEED;
}

pma_export str
PMAbulkins_@1(oid *pos_res, bat *bid, oid *pos, bat *ibid) {
	bit fgw, fg;
	int tpe;
	BUN i, j, k, ht, sz, isz, psz, cnt, icnt, lv, wsz, snum, scl, scr, wbeg, mpos, cur, slen, size;
	dbl dens, dent, step;
	bat ret;
	BAT *b, *bi, *bn;
	@1 *base, *basei, *basen;
	b =  BATdescriptor(*bid);
	bi =  BATdescriptor(*ibid);
	if (b == NULL || bi == NULL) throw(MAL,"pma.bulkins","illegal bat parameter");
	base = (@1*) Tloc(b, BUNfirst(b));
	basei = (@1*) Tloc(bi, BUNfirst(bi));
	isz = BATcount(bi);
	icnt = 0;
	for (i = 0; i < isz; i++) {
		if (basei[i] != @1_nil) icnt++;	/* figure out #-elements to be inserted */
	}
	if (icnt == 0) return MAL_SUCCEED;
	sz = PMA_SEG;
	psz = BATcount(b);
	for (ht = 0; psz > sz; sz <<= 1) ht++;
	if (psz != sz) throw(MAL,"pma.bulkins","illegal bat size");
	if (ht == 0) {
		dent = TaoMin;
		step = 0;
	} else {
		dent = Dmax;
		step = (Dmax - TaoMin) / ht;
	}
	fgw = FALSE;
	lv = cnt = 0;
	mpos = *pos;
	if (*pos == psz) mpos--;	/* new value is largest, and the last bat cell is not empty */
	snum = mpos >> PMA_SHT;	/* segment number of $pos */
	while (!fgw) {	/* search a window to insert the new value, in a bottom-up fashion */
		wsz = PMA_SEG << lv;
		if (lv == 0) {
			scl = snum << PMA_SHT;
			scr = scl + wsz;
		} else {
			wbeg = (snum >> lv) << lv << PMA_SHT;
			scl = wbeg;
			scr = wbeg + (wsz >> 1);
			if (mpos < wbeg + (wsz >> 1)) {
				scl += (wsz >> 1);
				scr += (wsz >> 1);
			}
		}
		for (i = scl; i < scr; i++) {
			if (base[i] != @1_nil) cnt++;
		}
		dens = (dbl)(cnt + icnt) / wsz;
		lv++;
		if (dens <= dent) fgw = TRUE;	/* find an appropriate window */
		else if (lv > ht) break;		/* current BAT has no space */
		else              dent -= step;	/* scan the parent window */
	}
	lv--;
	if (fgw){
		wbeg = (snum >> lv) << lv << PMA_SHT;
		fg = FALSE;
		slen = (wsz + cnt + icnt - 1) / (cnt + icnt);
		if ((cnt + icnt) * slen > wsz) slen--;
		for (i = cur = wbeg; i < *pos; i++) {
			if (base[i] == @1_nil) {
				if (!fg) {	/* the first hole */
					fg = TRUE;
					cur = i;
				}
			} else {
				if (fg && ((i - cur) >= slen)) {
					base[cur] = base[i];
					base[i] = (@1)@1_nil;
					cur += slen;
				} else {
					cur = i;
					fg = FALSE;
				}
			}
		}
		if (base[cur] != @1_nil) k = cur + slen;
		else k = cur;
		fg = FALSE;
		for (i = wbeg + wsz - 1; i >= *pos; i--) {
			if (base[i] == @1_nil) {
				if (!fg) {	/* the first hole */
					fg = TRUE;
					cur = i;
				}
			} else {
				if (fg && ((cur - i) >= slen)) {
					base[cur] = base[i];
					base[i] = (@1)@1_nil;
					cur -= slen;
				} else {
					cur = i;
					fg = FALSE;
				}
			}
			if (i == *pos) break;
		}
		*pos_res = k;
		for (i = 0; i < isz; i++) {
			if (basei[i] != @1_nil) {
				assert(base[k] == @1_nil);
				base[k] = basei[i];
				k += slen;
			}
		}
	} else {	/* creat a bat large enough to store cnt + icnt */
		size = BATcount(b);
		while (TaoMin * size < cnt + icnt) size <<= 1;
		slen = (size + cnt + icnt) / (cnt + icnt - 1);
		if ((cnt + icnt) * slen > size) slen--;
		tpe = TYPE_@1;
		PMAnew(&ret, &tpe, &size);
		bn =  BATdescriptor(ret);
		*bid = ret;
		basen = (@1*) Tloc(bn, BUNfirst(bn));
		sz = BATcount(b);
		isz = BATcount(bi);
		for (i = j = 0; i < *pos; i++) {
			if (base[i] != @1_nil) {
				basen[j] = base[i];
				j += slen;
			}
		}
		*pos_res = j;
		for (k = 0; k < isz; k++) {
			if (basei[k] != @1_nil) {
				basen[j] = basei[k];
				j += slen;
			}
		}
		for (; i < sz; i++) {
			if (base[i] != @1_nil) {
				basen[j] = base[i];
				j += slen;
			}
		}
		BATdelete(b);
	}
	BATdelete(bi);
	return MAL_SUCCEED;
}

pma_export str
PMAtestins_@1(void *dummy, bat *bid, int *num) {
	BAT *b;
	oid lo, hi, lo_res, hi_res, pos_res;
	int i;
	(void)dummy;
	b = BATdescriptor(*bid);
	if (b == NULL) throw(MAL,"pma.testins","illegal bat parameter");
	for (i = 0; i < *num; i++) {
		int ival = rand();
		@1 val = (@1) ival;
		lo = 0;
		hi = BATcount(b) - 1;
		val = (@1) rand();
		printf("loop %d: %d\n", i, ival);
		PMAfnd_@1(&lo_res, &hi_res, bid, &lo, &hi, &val);
		PMAins_@1(&pos_res, bid, &hi_res, &val);
	}
	return MAL_SUCCEED;
}

pma_export str
PMAtestdel_@1(void *dummy, bat *bid) {
	oid sz, pos;
	BAT *b;
	while (1) {
		b = BATdescriptor(*bid);
		if (b == NULL) throw(MAL,"pma.testdel","illegal bat parameter");
		sz = BATcount(b);
		if (sz == PMA_SEG) break;
		pos = rand() % sz;
		PMAdel_@1(dummy, bid, &pos);
	}
	return MAL_SUCCEED;
}
@c
@:pma_impl(chr)@
@:pma_impl(bte)@
@:pma_impl(sht)@
@:pma_impl(int)@
@:pma_impl(wrd)@
@:pma_impl(lng)@
@:pma_impl(flt)@
@:pma_impl(dbl)@
