@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2011 MonetDB B.V.
All Rights Reserved.
@

@f bpm
@v 0.5
@a M.L.Kersten, M. Ivanova, N.J. Nes
@+ BAT Partition Manager
In real-life database applications the BATs tend to grow beyond
the memory size. This leads to a heavy IO dominated behavior,
which can partly be avoided by breaking up the query into a sequence
of subqueries using a map-reduce strategy.
The BAT partition manager (BPM) module is designed to 
support this strategy using range- and hash-partitioning.

Consider we want to reorganize R:bat[:oid,:int] into two partitions,
based on splitting by tail value. 
The following MAL program illustrates the snippet of actions needed:
@example
bpm.open();
Ralias:= bpm.deposit("myversion",R:bat[:oid,:int]);
bpm.rangePartition(Ralias,nil:int,100);
bpm.rangePartition(Ralias,101,200);
bpm.close();
@end example
The command @sc{bpm.deposit} registers a BAT as one 
for which a partitioned copy is required.
The first partition call breaks the orginal BAT into
two pieces: (nil:int,100) and (101,nil:int).
The second call breaks the latter into (101,200)
and (201,nil:int).
The BAT partitions share the persistency properties.
Partitioning on the head simple calls for a reverse operation
on the source BAT first. 

The partition manager also supports hash-based partitioning.
Its argument is the number of hash bucket bits.
@example
bpm.open();
Rev:= bat.reverse(R:bat[:oid,:int]);
Ralias:= bpm.deposit("myHashVersion",Rev);	# creates side effects
bpm.hashPartition(Ralias,2);
bpm.close();
@end example
This example creates a hash-partition based on the head.

The design is based on the assumption that partitions
are reasonably large. This helps to limit plan explosion.
(or a scheduler should step in)

@- Derived partitioning
A relational front-end would benefit from derived horizontal
fragmentation. It would enable grouping together related
fragments on the same site. 
Assume a relation R(A,B) which is already partitioned on A
the derived fragmentation on the head is enforced with
@example
bpm.derivePartition(B,A);
@end example
@- Using partitions
The partitioned BAT can be used in two ways. A query plan can be
rewritten into a generator over the partitions, or it can be
used by optimizers to derived all subqueries first for
symbolic evaluation.

The former is illustrated with the snippet to select part of
a partitioned BAT. In this example we collect the partial
results in the accumulator BAT U.
@example
    bpm.open();
    Ralias:bat[:oid,:int]:= bpm.take("myversion");
    U:= bat.new(:oid,:int);
barrier Rp:= bpm.newIterator(Ralias);
    ...
    t:= algebra.select(Rp,0,100);
    U:= algebra.union(tu,t);
    ...
    redo Rp:= bpm.hasMoreElements(Ralias);
exit Rp;
    bpm.close();
@end example

The properties of the partitioned BATs are particularly useful during query
optimization. However, it only works if the BAT identifier
can be determined at compile time. For SQL it can be simply looked up in
the catalog as part of a preparatory optimizer step.

To illustrate, the same problem handled by an optimizer that produces the plan
based on a known number of partitions:
@example
    bpm.open();
    R:bat[:oid,:int]:= bpm.take("myversion"); # get the partition alias
    optimizer.mergetable();
    T:= algebra.select(R,0,100);
@end example
is translated to the plan:
@example
    bpm.open();
    R:bat[:oid,:int]:= bpm.take("myversion"); # get the partition alias
    R0:bat[:oid,:int]:= bpm.take(R,0, nil:oid,nil:oid, 0,100);
    R1:bat[:oid,:int]:= bpm.take(R,1, nil:oid,nil:oid, 101,200);
    R2:bat[:oid,:int]:= bpm.take(R,2, nil:oid,nil:oid, 201,nil:int);
    R:= mat.new(R0,R1,R2);
    T:= algebra.select(R,0,100);
    optimizer.multitable();
@end example
In this translation Ri also gets the properties of the BATs.
It is now up to the @sc{mat} optimizer to decide about
further plan expansion or an iterator approach.

@- Partition updates
The content of the partitions is preferrable updated in bulk.
This calls for accumulation of insertions/deletions in pending
update BATs, as already performed in the SQL code generator.
Once the transaction is commited, the updates are propagated
(in parallel) to all partitions.
@example
    bpm.open();
    Ralias:bat[:oid,:int] := bpm.take("myversion"); 
    bpm.insert(Ralias, Rinsert);# handle pending inserts
    bpm.delete(Ralias, Rdelete);# handle pending deletes
    bpm.replace(Ralias, Rold, Rnew);# handle pending updates
    bpm.close();
@end example
The @sc{replace} operator works on the assumption that
the head of @sc{Rold} and @sc{Rnew} is unique.

It remains possible to retrieve a partition and directly
insert elements, but then it is up to the compiler to
ensure that the boundery conditions are met.

@- Partitioned results
In many situations, you would like to keep the partial results
as a partitioned BAT again.
The easiest solution is to create a partitioned BAT,
whose partitions are empty. Subsequently, we insert the temporary results. 
Depending on the fragmentation criteria, pieces may align
with the pieces known, or lead to a redistribution of the
buns to the correct bats.

In the previous plan for this becomes
@example
    bpm.open();
    Tmp := bpm.deposit("tmp",:bat[:oid,:int]);
    bpm.rangePartition(tmp,nil:int,100);
    bpm.rangePartition(tmp,101,nil:int);

    Ralias:bat[:oid,:int]:= bpm.take("myversion"); # get the partition alias
    R0:bat[:oid,:int]:= bpm.take("myversion", nil:oid,nil:oid, 0,100);
    T0:= algebra.select(R0,0,100);
    bpm.insert(Tmp,T0);

    R1:bat[:oid,:int]:= bpm.take("myversion", nil:oid,nil:oid, 101,200);
    T1:= algebra.select(R1,0,100);
    bpm.insert(Tmp,T1);

    R2:bat[:oid,:int]:= bpm.take("myversion", nil:oid,nil:oid, 201,nil:int);
    T2:= algebra.select(R2,0,100);
    bpm.insert(Tmp,T2);
@end example
Note that a symbolic optimizer can reduce this plan to a small snippet.

The rationale for the update approach is that re-distribution
of temporary results are hidden behind the @sc{bpm.insert()} interface.
The only decision that should be taken by the optimizer is
the fragmentation criteria for the temporary results.

For temporary results the range bounds need not be
stored in the BPM catalog. Instead, the mat approach could
be used to reduce the plan size.
@example
    bpm.open();
    Ralias:= bpm.take("myversion",:bat[:oid,:int]); # get the partition alias
    R0@{hlow=nil:oid,hhigh=nil:oid,tlow=nil:int,thigh=100@}:= bpm.take(Ralias, 0);
    T0:=algebra.select(R0,0,100);

    R1@{hlow=nil:oid,hhigh=nil:oid,tlow=101,thigh=200@}:= bpm.take(Ralias, 1);
    T1:= algebra.select(R1,0,100);

    R2@{hlow=nil:oid,hhigh=nil:oid,tlow=201,thigh=nil:int@}:=  bpm.take(Ralias, 2);
    R:= mat.new(T0,T1,T2);
    T2:=algebra.select(R2,0,100);
@end example

@- Partition iterators
The default strategy for an optimizer is to replace a
reference to a partitioned BAT by an iterator.
@example
    l:= bpm.new();
barrier Elm:bat[:oid,:int]:= bpm.newIterator(Ralias);
    t:= algebra.select(Elm,0,20);
    bpm.addPartition(l,t);
    redo Elm:bat[:oid,:int]:= bpm.newIterator(Ralias);
exit Elm;
@end example
Variations on this theme are iterators that search for
partitions overlapping a range or those that are not empty.

@- Partition selection
Partition aware relational operators further reduce the
performance overhead and at the same time avoid cluttering
the MAL plans with too much flow of control constructs.
A few operators relevant for the SQL environment will be added.

The select operation can be overloaded in the BPM to
improve processing further. For example, the operation
@example
    t := bpm.select(Ralias,0,100);
@end example
extracts portions of all three partitions and creates 
a non-partitioned result BAT. 
If the partition bounds align with the selection criteria
this operation becomes cheap. It can be used to convey
information on the bounds to optimizers.


The lifetime of a partitioned table is inherited from its components. 
How to detect that a temporary BAT is removed from the BBP?
Currently we have to explicitly call the bpm.garbage() on
those partitioned BATs.

@-
At the end of a query plan we have to garbage collect any of the
left-over partitioned temporary tables.
@{
@mal
module bpm;

command open():void
address BPMopen
comment "Locate and open the BAT partition box.";

command close():void
address BPMclose
comment "Save and close the BAT partition box.";

command destroy():void
address BPMdestroy
comment "Destroy the BAT partition box.";

command deposit(nme:str,b:bat[:oid,:any_2]) :bat[:oid,:any_2]
address BPMdeposit
comment "Create a new partitioned BAT by name.";

@-
Temporary results can be administered as partitioned tables as well.
There is no a priori need to have the partitioned non-overlapping.
@mal
pattern new(ht:any_1,tt:any_2):bat[:any_1,:any_2]
address BPMnew
comment "Create a temporary partitioned table.";

command fold(b:bat[:any_1,:any_2]):bat[:any_1,:any_2]
address BPMfold
comment "Collapse the partitioned BAT into a single BAT.";

command unfold(alias:bat[:any_1,:any_2]) :bat[:any_1,:any_2]
address BPMunfold
comment "Unfold a BAT into a partitioned one.";

command garbage(b:bat[:any_1,:any_2]):void
address BPMgarbage
comment "Remove a temporary partitioned table.";

command pieces(b:bat[:any_1,:any_2]):int
address BPMpieces
comment "Count the number of partitions.";

command count(b:bat[:any_1,:any_2]):wrd
address BPMcount;
command emptySet(b:bat[:any_1,:any_2]):void
address BPMemptySet
comment "Implement the empty set constraints test efficiently.";

command sortTail(b:bat[:any_1,:any_2]):bat[:any_1,:any_2]
address BPMsortTail
comment "Implement the sort on tail for partitioned BAT efficiently.";
@-
The partitioning is handled inside the module.
If the alias BAT denotes an existing partition, it is
further broken into pieces.
@mal
command rangePartition(pb:bat[:any_1,:any_2], rl:any_2, rh:any_2):void
address BPMrange
comment "Create a range partition on a BAT.";

command rangePartition(pb:bat[:any_1,:any_2], pv:bat[:oid,:any_2]):void
address BPMrangeVector
comment "Create the partitions based on a range vector.";

command rangePartitionSort(pb:bat[:any_1,:any_2], pv:bat[:oid,:any_2]):void
address BPMrangeVectorSort
comment "Create the partitions based on a range vector.";

command sortPartitions(b:bat[:any_1,:any_2]):void
address BPMsortPartitions
comment "Sort all partitions of alias b on the tail.";

command hashPartitions(b:bat[:any_1,:any_2]):void
address BPMhashPartitions
comment "Ensure all partitions have a hash in the head.";

command partition(pb:bat[:any_1,:any_2], val:any_2):void
address BPMsplitpartition
comment "Split all partitions that cover the split value.";

command addPartition(b:bat[:any_1,:any_2],s:bat[:any_1,:any_2]):void
address BPMaddPartition
comment "Add a partition to a fragmented temporary table.";
command addPartition(b:bat[:any_1,:any_2],s:BAT):void
address BPMaddPartition
comment "Add a partition to a fragmented temporary table.";

command hashPartition(pb:bat[:any_1,:any_2], slots:int):void
address BPMhash
comment "Create a hash partition on a BAT.";
command derivePartition(pb:bat[:any_1,:any_2], 
	src:bat[:any_1,:any_2]):bat[:any_1,:any_2]
address BPMderived
comment "Create a derived fragmentation over the head using src.";

command adapt(s:bat[:any_1,:any_2], low:any_2, hgh:any_2, rs:bat[:any_1,:any_3], pol:int) :bat[:any_1,:any_2]
address BPMadapt
comment "Re-organize segment s using the selection (val1,val2) stored in bat rs.";


command take(pb:int):bat[:any_1,:any_2]
address BPMtakeIndexed
comment "Retrieve the partition given the its index.";
command take(pb:str):bat[:any_1,:any_2]
address BPMtake
comment "Retrieve the alias given the name of a partitioned BAT.";

command take(nme:str, hl:any_1, hh:any_1, tl:any_2, th:any_2) :bat[:any_1,:any_2]
address BPMtakePartition
comment "Retrieve a single component of a partitioned BAT by index.";

command take(nme:bat[:any_1,:any_2],idx:int, hl:any_1, hh:any_1, tl:any_2, th:any_2) :bat[:any_1,:any_2]
address BPMtakePartitionIndexed
comment "Retrieve a single component of a partitioned BAT by index.";

command insert(pb:bat[:any_1,:any_2],b:bat[:any_1,:any_2]) :void
address BPMinsert
comment "Insert elements into the BAT partitions.";
command delete(pb:bat[:any_1,:any_2],b:bat[:any_1,:any_2]) :void
address BPMdelete
comment "Delete elements from the BAT partitions.";
command replace(pb:bat[:any_1,:any_2],old:bat[:any_1,:any_2],
		nwe:bat[:any_1,:any_2]) :void
address BPMreplace
comment "Replace the content of the BAT partitions.";

command getNames():bat[:oid,:str]
address BPMgetNames
comment "Retrieve the names of all known partitioned BATs.";

command discard(alias:bat[:any_1,:any_2]) :void
address BPMdiscard
comment "Release a partitioned BAT from the box.";
command discard() :void
address BPMdiscardAll
comment "Release all partitioned BATs.";

@-
In most situations we would like to iterator over
the components of a single partitioned BAT. 
Wherever possible skipping elements that don't qualify
the bounds given for the head.
@mal
pattern newIterator(grp:bat[:any_1,:any_2],b:bat[:any_1,:any_3], c:bat[:oid,:any_4])
	(:bat[:any_1,:any_2], :bat[:any_1,:any_3], :bat[:any_1,:any_4])
address BPMnewIterator3;
pattern newIterator(grp:bat[:any_1,:any_2],b:bat[:any_1,:any_3])
	(:bat[:any_1,:any_2], :bat[:any_1,:any_2])
address BPMnewIterator2;
pattern newIterator(grp:bat[:any_1,:any_2]) :bat[:any_1,:any_2]
address BPMnewIterator
comment "Create an iterator over the BAT partitions.";

pattern newIterator(grp:bat[:any_1,:any_2],first:any_2,last:any_2)
		:bat[:any_1,:any_2]
address BPMnewIteratorRng
comment "Create an iterator over the BAT partitions overlapping with range.";

pattern newIterator(pb:bat[:any_1,:any_2], first:any_1,last:any_1,
		vlow:any_2, vhgh:any_2) :bat[:oid,:any_2]
address BPMnewIteratorRng4
comment "Create an iterator over the BAT partitions.";

pattern hasMoreElements(grp:bat[:any_1,:any_2],b:bat[:any_1,:any_3], c:bat[:oid,:any_4])
	(:bat[:any_1,:any_2], :bat[:any_1,:any_3], :bat[:any_1,:any_4])
address BPMhasMoreElements3;
pattern hasMoreElements(grp:bat[:any_1,:any_2],b:bat[:any_1,:any_3])
	(:bat[:any_1,:any_2], :bat[:any_1,:any_2])
address BPMhasMoreElements2;
pattern hasMoreElements(grp:bat[:any_1,:any_2]) :bat[:any_1,:any_2]
address BPMhasMoreElements
comment "Localize the next partition for processing.";

pattern hasMoreElements(pb:bat[:any_1,:any_2], 
		low:any_2, hgh:any_2) :bat[:any_1,:any_2]
address BPMhasMoreElementsRng
comment "Localize the next partition overlapping with range.";

pattern hasMoreElements(pb:bat[:any_1,:any_2], first:any_1,last:any_1,
		vlow:any_2, vhgh:any_2) :bat[:any_1,:any_2]
address BPMhasMoreElementsRng4
comment "Localize the next partition for processing.";

command getDimension(b:bat[:any_1,:any_2])(first:any_1,last:any_1, 
	vlow:any_2, vhgh:any_2)
address BPMgetDimension
comment "Obtain the partition boundary values.";
@-
Optimizers will be interested in properties for
the partitions.
@mal
command getNumberOfPartitions(alias:bat[:any_1,:any_2]):int
address BPMgetNumberOfPartitions
comment "Return the number of partitions known";

command select(part:bat[:any_1,:any_2], low:any_2, hgh:any_2):bat[:any_1,:any_2]
address BPMselect
comment "Partitioned based selection ";
command select(part:bat[:any_1,:any_2], low:any_2, hgh:any_2, li:bit, hi:bit):bat[:any_1,:any_2]
address BPMselectInclusive
comment "Partitioned based selection ";
@-
command getCount(alias:bat[:any_1,:any_2]):bat[:ins,:int]
address BPMgetCount
comment "Return the number of tuples in each partition ";
@mal
command dump(alias:bat[:any_1,:any_2])
address BPMdumpAlias
comment "Give the details of the partition tree";
command dump()
address BPMdump;
@-
The partition catalog is stored on disk as a collection
of BATs. This can also be used to analyse/debug the
partition manager.
@mal
command mapName() :bat[:int,:str] 
address BPMmapname;
command mapBid() :bat[:int,:bat] 
address BPMmapbid;
command mapAlias() :bat[:int,:bat] 
address BPMmapalias;
command mapNxt() :bat[:int,:int] 
address BPMmapnxt;
command mapPrv() :bat[:int,:int] 
address BPMmapprv;
command mapCnt() :bat[:int,:int] 
address BPMmapcnt;
command mapTlowLng() :bat[:int,:lng] 
address BPMmaptlowlng;
command mapTlowDbl() :bat[:int,:dbl] 
address BPMmaptlowdbl;
command mapThghLng() :bat[:int,:lng] 
address BPMmapthghlng;
command mapThghDbl() :bat[:int,:dbl] 
address BPMmapthghdbl;

command saveCatalog() 
address BPMsaveCatalog;

command splitquant(pb:bat[:any_1,:any_2], mb:int):void
address BPMsplitquant
comment "Split all partitions to fit into a memory bound in KB";


command prelude()
address BPMprelude;

command epilogue()
address BPMepilogue;
bpm.prelude();
@-
@include ../kernel/kprelude.mx
@+ BAT Partition Manager Implementation
The implementation is organized around a shared box, which should
be saved between session. It is up to other layers to ensure that BATs
being deleted are also removed from the partition box to avoid
mis-represented information.

@h
#ifndef _MAL_BPM
#define _MAL_BPM
#include "mal.h"
#include "mal_client.h"
#include "mal_interpreter.h"

/* #define _DEBUG_BPM_ */

#ifdef WIN32
#if !defined(LIBMAL) && !defined(LIBATOMS) && !defined(LIBKERNEL) && !defined(LIBMAL) && !defined(LIBOPTIMIZER) && !defined(LIBSCHEDULER) && !defined(LIBMONETDB5)
#define bpm_export extern __declspec(dllimport)
#else
#define bpm_export extern __declspec(dllexport)
#endif
#else
#define bpm_export extern
#endif

bpm_export str BPMopen(void);
bpm_export str BPMclose(int *ret);
bpm_export str BPMdestroy(int *ret);
bpm_export str BPMdeposit(bat *ret, str *nme, bat *src);

bpm_export str BPMrange(bat *ret, bat *bid, ptr low, ptr hgh);
bpm_export str BPMsplitpartition(bat *ret, bat *bid, ptr val);
bpm_export str BPMrangeVector(bat *ret, bat *bid, bat *pv);
bpm_export str BPMrangeVectorSort(bat *ret, bat *bid, bat *pv);
bpm_export str BPMsortPartitions(int *ret, bat *bid);
bpm_export str BPMhashPartitions(int *ret, bat *bid);

bpm_export int BPMisPartitioned(bat src);
bpm_export str BPMpieces(int *ret, bat *src);

/* some primitives replacing the algebra/aggr versions */
bpm_export str BPMcount(wrd *ret, bat *src);
bpm_export str BPMemptySet(int *ret, bat *src);
bpm_export str BPMsortTail(int *ret, bat *src);

bpm_export str BPMaddPartition(int *ret, bat *dst, bat *src);
bpm_export str BPMhash(bat *ret, bat *bid, int *slots);
bpm_export str BPMderived(bat *ret, bat *bid, bat *src);
bpm_export str BPMadapt(bat *ret, bat *bid, ptr low, ptr hgh, bat *rs, int *pol);
bpm_export str BPMoracle(bat *ret, bat *bid, ptr low, ptr hgh, bat *rs );

bpm_export str BPMtakeIndexed(bat *ret, int *nme);
bpm_export str BPMtake(bat *ret, str *nme);
bpm_export str BPMtakePartition(bat *ret, str *nme, ptr *hl, ptr *hh, ptr *tl, ptr *th);
bpm_export str BPMtakePartitionIndexed(bat *ret, int *bid, int *idx, ptr *hl, ptr *hh, ptr *tl, ptr *th);

bpm_export str BPMexpand(Client cntxt, MalBlkPtr mb, int varid, int bid);

bpm_export str BPMunfold(bat *ret, bat *bid);
bpm_export str BPMfold(int *ret, bat *src);
bpm_export str BPMgarbage(int *ret, int *bid);

bpm_export str BPMinsert(bat *ret, bat *bid, bat *ins);
bpm_export str BPMdelete(bat *ret, bat *bid, bat *del);
bpm_export str BPMreplace(bat *ret, bat *bid, bat *ins, bat *del);

bpm_export str BPMgetNames(bat *bid);
bpm_export str BPMdiscard(int *ret, bat *bid);
bpm_export str BPMdiscardAll(int *ret);

bpm_export str BPMnew(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
bpm_export str BPMnewIterator2(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
bpm_export str BPMnewIterator3(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
bpm_export str BPMnewIterator(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
bpm_export str BPMnewIteratorRng(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
bpm_export str BPMnewIteratorRng4(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);

bpm_export str BPMhasMoreElements(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
bpm_export str BPMhasMoreElements2(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
bpm_export str BPMhasMoreElements3(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
bpm_export str BPMhasMoreElementsRng(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
bpm_export str BPMhasMoreElementsRng4(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);

bpm_export str BPMgetNumberOfPartitions(int *ret, int *bid);
bpm_export str BPMselect(int *ret, int *bid, ptr low, ptr hgh);
bpm_export str BPMselectInclusive(int *ret, int *bid, ptr low, ptr hgh, bit *li, bit *hi);

bpm_export str BPMgetDimension(ptr *first, ptr *last,
	ptr *vlow, ptr *vhgh, bat *bid);
bpm_export str BPMdump(int *ret);
bpm_export str BPMdumpAlias(int *ret, bat *bid);

bpm_export str BPMmapname(int *ret);
bpm_export str BPMmapbid(int *ret);
bpm_export str BPMmapalias(int *ret);
bpm_export str BPMmapnxt(int *ret);
bpm_export str BPMmapprv(int *ret);
bpm_export str BPMmapcnt(int *ret);
bpm_export str BPMmaptlowlng(int *ret);
bpm_export str BPMmaptlowdbl(int *ret);
bpm_export str BPMmapthghlng(int *ret);
bpm_export str BPMmapthghdbl(int *ret);

bpm_export str BPMsaveCatalog(int *ret);

bpm_export str BPMsplitquant(bat *ret, bat *bid, int *mb);

bpm_export str BPMprelude(int *ret);
bpm_export str BPMepilogue(int *ret);
#endif
@c
#include "monetdb_config.h"
#include "bpm.h"
#include "bat5.h"
#include "algebra.h"
#include "mal_builder.h"
#define _USE_MATH_DEFINES /* needed to get M_PI on Windows */
#include <math.h>

#define KB	1024
#define Mmin	1024*KB
#define Mmax	10240*KB

@-
The partition manager uses its private catalog 
of persistent BATs. The size of the catalog is aligned with
the BBP size.

Each partitioned BAT is represented by a circular ring
of  BAT descriptors. The anchor point does not have content.
This is used as  a stable handle for applications.
The nxt provides access to the first element, while prv
provides access to the last one.
The anchor BAT is also the only one that holds the 
name of the partitioned bat.
It can be skipped by the iterators.
At a later stage, it may contain coarse grain
information on the combined content.

A ring may be empty.

CAVEAT 1. Operations like revert do not return a new bat descriptor,
which may lead to a situation that BATs may end up to be shared
in two rings. This is currently caught in addPartition, which takes
a copy of the BAT instead. Further optimization is needed here.

CAVEAT 2. Grouping and aggregations are handled using reconstruction
of the original table. This is not the most optimal scheme.
The optimizer should be patched to handel more cases.

CAVEAT 3. A MAL program may generate an exception, which should
not disturb garbage collection of temporary partitions. Otherwise,
the bpm catalog becomes polluted.

Every partition is the result of at most four operations:
range/hash partition on head/tail.
The consolidated properties are administered for use
by the compiler/optimizer.
For range-based partitions it simply means the range bounds,
for hash-based partitions we need the hash bucket properties.

The partition record table is aligned with the bbp, such
that the ABS(batCachid) can be used to quickly obtain it.
A partition record may only be present when the corresponding
BAT represents a partition, i.e. they should be garbage
collected properly.

@c
#define	RANGE	1
#define HASH	2

#define rngType(B) (B==TYPE_void?TYPE_oid:B)

typedef struct PARTITIONREC {
	char *name;		/* only stored for the alias */
	bat alias;		/* partition BAT alias, back into BBP*/
	bat bid;		/* partition BAT, back into BBP */
	int type;		/* BAT type */

	ValRecord hlow,hhgh; /* head range */
	ValRecord tlow,thgh; /* tail range */
	int hbits, tbits; /* linear hashing bits */
	int nxt, prv;	/* list of all related partitions*/
	BUN cnt;	/* how many tuples */
@-
Each partition may be designated as delayed,
which is materialized only when you need it completely needed.
@c
	int delayed;
} *Partition, PartitionRec;

#define emptyRing(p) (p->nxt==p->prv && p->nxt== p->alias)
@-
The size of the BBP is relatively small, which can be
used as a handle to quickly access properties of
partitioned BATs.
A partition record is created the first time the BAT
is used for this purpose.
@c
static Partition *bpmcat= 0;
static int bpmcatsize=0;
static int BPMpiecesImpl(bat bid);

static void BPMprintInfo(stream *f, Partition p){
	mnstr_printf(f,"bits %d %d ", p->hbits,p->tbits);
	mnstr_printf(f,"["); VALprint(f,&p->hlow);
	mnstr_printf(f,":"); VALprint(f,&p->hhgh);
	mnstr_printf(f,", "); VALprint(f,&p->tlow);
	mnstr_printf(f,":"); VALprint(f,&p->thgh);
}

static void BPMprintPartition(stream *f, Partition p){
	mnstr_printf(f,"partition: %s alias %d bid %d ",
		bpmcat[p->alias]->name, (int) p->alias, (int) p->bid);
	BPMprintInfo(f,p);
	mnstr_printf(f,"] nxt %d prv %d cnt " BUNFMT "\n", p->nxt,p->prv,p->cnt);
}

static void BPMprintRing(stream *f, Partition p){
	int i, base;
	if( p== 0) return;
	mnstr_printf(f,"RING[%d] %s ", p->bid,BBPname(p->bid));
	BPMprintInfo(f,p);
	mnstr_printf(f,"] cnt " BUNFMT "\n", p->cnt);
	base= p->alias;
	for(i= p->nxt; bpmcat[i]->bid!= base; i= bpmcat[i]->nxt){
		mnstr_printf(f,"[%d] %s ", bpmcat[i]->bid, BBPname(bpmcat[i]->bid));
		BPMprintInfo(f,p);
		mnstr_printf(f,"] cnt " BUNFMT "\n", bpmcat[i]->cnt);
	}
}

@-
Make sure we allocate space for both straight and reversed
BAT rings.
@c
static Partition *bpmcatbase = 0;

static void assureSpace(){
	if( BBPlimit >bpmcatsize){
		Partition *new;
		mal_set_lock(mal_contextLock, "bpm");
		new = (Partition*) GDKzalloc(sizeof(Partition)* BBPlimit*2);
		memcpy((char*)new, ((char*)bpmcat)-sizeof(Partition)*bpmcatsize,
		2* sizeof(Partition)*bpmcatsize);
		if( bpmcatsize && bpmcatbase)
			GDKfree(bpmcatbase);
		bpmcatsize= BBPlimit;
		bpmcatbase=new;
		bpmcat=new+BBPlimit;
		mal_unset_lock(mal_contextLock, "bpm");
	}
}

static Partition getByName(str nme){
	int i;
	assureSpace();
	for(i=0; i< bpmcatsize; i++)
		if( bpmcat[i] && 
			bpmcat[i]->name &&
			strcmp(bpmcat[i]->name,nme)==0)
			return bpmcat[i];
	return 0;
}

static Partition getByNumber(int n){
	assureSpace();
	return bpmcat[n];
}

static Partition getAlias(bat i){
	/* go to the anchor point */
	Partition p;
	p= getByNumber(i);
	if( p == 0) return 0;
	return bpmcat[p->alias];
}

static Partition newPartition(int i){
	assureSpace();
	if( i<-BBPlimit || i==0 || i>BBPlimit)
		return NULL;
#ifdef _DEBUG_BPM_
	if( bpmcat[i]!= 0)
		mnstr_printf(GDKout,"re-alloc of partition record %d\n",i);
#endif
	if( bpmcat[i]== 0){
		mal_set_lock(mal_contextLock, "bpm");
		bpmcat[i]= (Partition) GDKzalloc(sizeof(PartitionRec));
		mal_unset_lock(mal_contextLock, "bpm");
	}
	return bpmcat[i];
}

static void insertPartition(Partition parent, Partition new){
	assureSpace();
	new->nxt= parent->nxt;
	new->prv= parent->bid;
	bpmcat[parent->nxt]->prv= new->bid;
	parent->nxt= new->bid;
}

static void dropPartition(Partition p){
	int r;

	BKCsetTransient(&r,&p->bid);
	BBPdecref(p->bid,TRUE); 
	bpmcat[p->prv]->nxt= p->nxt;
	bpmcat[p->nxt]->prv= p->prv;
	bpmcat[p->bid]= NULL;
	GDKfree(p);
}
@-
Partitions marked as delayed should be materialized
before they can be used.
It may happen that a scan requires multiple delayed
partitions, then we might save time by performing
one pass over the underlying source
@c

static str 
materializePartition(Partition p){
	BAT *b,*bn;

	if( p->delayed== 0)
		return MAL_SUCCEED;
	assureSpace();
	b= BATdescriptor(p->bid);
	if ( b == NULL)
		throw(MAL,"bpm.materialize", INTERNAL_OBJ_CREATE);
	bn= BATselect_(b, VALptr(&p->tlow),VALptr(&p->thgh), TRUE, FALSE);
	BBPunfix(b->batCacheid);
	if( bn== NULL)
		throw(MAL,"bpm.materialize", INTERNAL_OBJ_CREATE);
	BBPkeepref(bn->batCacheid);
	p->bid= bn->batCacheid;
	p->delayed = 0;
	return MAL_SUCCEED;
}
@- Box administration
The box currently does not carry any client protection yet.
This should later be added or being provided by the BAT access.

The partition catalog is saved between sessions as a collection
of BATs.

@= defaultRange
	/* default range @1= Partition @2= BAT * */
	VALset(&@1->hlow, rngType(@2->htype), ATOMnil(rngType(@2->htype)));
	VALset(&@1->hhgh, rngType(@2->htype), ATOMnil(rngType(@2->htype)) );
	VALset(&@1->tlow, rngType(@2->ttype), ATOMnil(rngType(@2->ttype)) );
	VALset(&@1->thgh, rngType(@2->ttype), ATOMnil(rngType(@2->ttype)) );
	@1->hbits= @1->tbits= 0;

@= loadBPMbat
	idx= BBPindex("bpm_@1");
	if ((b = BATdescriptor(idx)) == NULL) 
		throw(MAL, "bpm.loadCatalog", INTERNAL_BAT_ACCESS);
	BATloop(b, p, q) {
		i = *(int *)Hloc(b,p);
		k = *(@2 *) Tloc(b,p);
		newPartition(i)->@1 = k;	
		bpmcat[i]->bid = k;
	}
	BBPunfix(b->batCacheid);

@= openBPMbat
	idx= BBPindex("bpm_@2");
        if ((@1 = BATdescriptor(idx)) == NULL) 
                throw(MAL, "bpm.loadCatalog", INTERNAL_BAT_ACCESS);
	@1i = bat_iterator(@1);

@= BPMunfix
	BBPunfix(nxt->batCacheid);
	BBPunfix(prv->batCacheid);
	BBPunfix(bll->batCacheid);
	BBPunfix(bld->batCacheid);
	BBPunfix(bhl->batCacheid);
	BBPunfix(bhd->batCacheid);

@= getPartitionBound
	r= BUNfnd(@3,&i); 
	if (r != BUN_NONE){
	   val= BUNtail(@3i,r);
	   vl= (lng) * (@5 *) val;	
	   @2= (@1) vl;
	   VALset(&bpmcat[i]->@4, tp, &@2); 
	} else 
	   VALset(&bpmcat[i]->@4, tp, ATOMnil(tp) );

@= getPartitionBoundLng
	@:getPartitionBound(@1,@2,bll,tlow,lng)@
	@:getPartitionBound(@1,@2,bhl,thgh,lng)@

@= getPartitionBoundDbl
	@:getPartitionBound(@1,@2,bld,tlow,dbl)@
	@:getPartitionBound(@1,@2,bhd,thgh,dbl)@
@c

static str
BPMloadCatalog(){
	int i,k,tp,vi;
	bat idx;
	BAT *b, *pb;
	BATiter nxti, prvi, cnti, bldi, blli, bhdi, bhli;
	BAT *nxt, *prv, *cnt, *bld, *bll, *bhd, *bhl;
	BUN p,q,r;
	str nm;
	ptr val;
	sht vs;
	flt vf;
	dbl vd;
	lng vl;
	BATiter bi;

	assureSpace();
	idx= BBPindex("bpm_name");
	if ((b = BATdescriptor(idx)) == NULL) 
		throw(MAL, "bpm.loadCatalog", INTERNAL_BAT_ACCESS);
	bi = bat_iterator(b);
	BATloop(b, p, q) {
		i = *(int *)BUNhead(bi,p);
		nm = (str) BUNtail(bi,p);
		newPartition(i)->name = GDKstrdup(nm);	
		bpmcat[i]->type= newBatType(b->htype, b->ttype);
		bpmcat[i]->bid = i;
		BBPincref(i,TRUE);
	}
	BBPunfix(b->batCacheid);

	@:loadBPMbat(alias,int)@
/*	@:loadBPMbat(bid,int)@ */
	@:openBPMbat(nxt,nxt)@
	@:openBPMbat(prv,prv)@
	@:openBPMbat(cnt,cnt)@
	@:openBPMbat(bll,tlowlng)@
	@:openBPMbat(bld,tlowdbl)@
	@:openBPMbat(bhl,thghlng)@
	@:openBPMbat(bhd,thghdbl)@

/*  Initialize the partition fields */
	for( i=1; i<bpmcatsize; i++)
	if( bpmcat[i] ){
		if ((pb = BATdescriptor(bpmcat[i]->bid)) == NULL) {
			@:BPMunfix@
			throw(MAL, "bpm.loadCatalog", OPERATION_FAILED);
		}

	
@-
@= getPartitionField
		r= BUNfnd(@1,&i);
		if (r != BUN_NONE)
			bpmcat[i]->@1= *(int *) BUNtail(@1i,r);
		else {	
			@:BPMunfix@
			throw(MAL, "bpm.loadCatalog", OPERATION_FAILED);
		}
@c
		@:getPartitionField(prv)@
		@:getPartitionField(nxt)@
		@:getPartitionField(cnt)@
	
		@:defaultRange(bpmcat[i],pb)@
	
		switch (tp= pb->ttype) {
		case TYPE_int:  @:getPartitionBoundLng(int,vi)@
				break;
		case TYPE_lng:  
				@:getPartitionBound(lng,vl,bll,tlow,lng)@
				@:getPartitionBound(lng,vl,bhl,thgh,lng)@
				break;
		case TYPE_sht: 	@:getPartitionBoundLng(sht,vs)@
				break;
		case TYPE_dbl: 	@:getPartitionBoundDbl(dbl,vd)@
				break;
		case TYPE_flt:	@:getPartitionBoundDbl(flt,vf)@
				break;

		}
	}
	@:BPMunfix@
	return MAL_SUCCEED;
}

str
BPMopen()
{
	if(bpmcat) {
		assureSpace();
		return MAL_SUCCEED;
	}
	mal_set_lock(mal_contextLock, "bpm");
	if(BBPindex("bpm_name"))
		BPMloadCatalog();
	mal_unset_lock(mal_contextLock, "bpm");
	return MAL_SUCCEED;
}
@-
The remainder contains the implementation.
@c
str
BPMclose(int *ret)
{
	(void) ret;
	mal_set_lock(mal_contextLock, "bpm");
	/* save the partition table structure */
	mal_unset_lock(mal_contextLock, "bpm");
	throw(MAL, "bpm.close", PROGRAM_NYI);
}

str
BPMdestroy(int *ret)
{
	(void) ret;
	mal_set_lock(mal_contextLock, "bpm");
	/* remove a partition table */
	mal_unset_lock(mal_contextLock, "bpm");
	throw(MAL, "bpm.destroy", PROGRAM_NYI);
}
@-
Before you enter a BAT for partitioning
we should assure it is not already partitioned.
@c
str
BPMdeposit(bat *ret, str *nme, bat *src)
{
	BAT *b,*ba;
	Partition p,pa;

	BPMopen();

	/* test for duplicate names */
	if(nme && getByName(*nme) )
		throw(MAL,"bpm.deposit", DUPLICATE_DEFINITION);
	/* get target bat */
	@:getBATdescriptor(src,b,"bpm.deposit")@

	if( (p=getByNumber(b->batCacheid)) != 0){
#ifdef _DEBUG_BPM_
		printf("partitioned already %d %d\n", b->batCacheid,p->alias);
		BPMprintPartition(GDKout, p);
#endif
		BBPunfix(b->batCacheid);
		throw(MAL,"bpm.deposit", DUPLICATE_DEFINITION);
	}
	/* we can enter a new partition */
	/* create the ring alias bat first*/
	ba= BATnew( b->htype,b->ttype,BATTINY); 
	if( ba == 0){
		BBPunfix(b->batCacheid);
		throw(MAL,"bpm.deposit", MAL_MALLOC_FAIL);
	}
	pa = newPartition(ba->batCacheid);
	pa->type = newBatType(ba->htype,ba->ttype);
	bpmcat[ba->batCacheid]->bid = ba->batCacheid;
	pa->alias= pa->bid;
	pa->name= nme? GDKstrdup(*nme): BBPname(ba->batCacheid);
	pa->nxt= pa->prv= pa->bid;
	@:defaultRange(pa,ba)@

	p = newPartition(b->batCacheid);
	p->type = newBatType(b->htype,b->ttype);
	bpmcat[b->batCacheid]->bid = b->batCacheid;
	BBPincref(b->batCacheid,TRUE);
	p->alias= pa->bid;
	@:defaultRange(p,b)@
	insertPartition(pa,p);
	p->cnt= BATcount(b);
#ifdef _DEBUG_BPM_
	mnstr_printf(GDKout,"#Enter the partition '%s' at %d\n",
		(nme?*nme:"tmp"),b->batCacheid);
	BPMprintRing(GDKout, pa);
#endif
	BBPkeepref(*ret= ba->batCacheid);

	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}
@-
Given a particular partition, split it into two
pieces based on the value referenced
@c
#define equal(X,A,Y) \
		((*cmp)((ptr) &bpmcat[X]->A, Y) == 0)
#define greater(X,A,Y) \
	   ((*cmp)((ptr)&bpmcat[X]->A, nilptr)!=0 && \
		(*cmp)((ptr) &bpmcat[X]->A, Y) > 0)
#define less(X,A,Y) \
	   ((*cmp)((ptr)&bpmcat[X]->A, nilptr)!=0 && \
		(*cmp)((ptr) &bpmcat[X]->A, Y) < 0)
#define inbetween(X,A,B,Y) \
	   ( ((*cmp)((ptr)&bpmcat[X]->A, nilptr)==0 || \
		(*cmp)((ptr) &bpmcat[X]->A, Y) < 0)  && \
		((*cmp) ((ptr)&bpmcat[X]->B, nilptr)==0 || \
		(*cmp)((ptr) &bpmcat[X]->B, Y) > 0) )

@-
split partitions only if the range overlaps the split value
@c
str
BPMsplitpartition(bat *ret, bat *bid, ptr val)
{
	BAT *b,*bn;
	Partition ps, p;
	int (*cmp) (ptr, ptr);
	ptr nilptr;
	int i;
	str msg=MAL_SUCCEED;
	(void) ret;

	BPMopen();

	if( (ps= bpmcat[ i=*bid]) == 0)
		throw(MAL,"bpm.split", RUNTIME_OBJECT_MISSING);
	@:getBATdescriptor(bid,b,"bpm.splitPartition");
	/* get the comparison function */
	cmp= BATatoms[b->ttype].atomCmp;
	nilptr = ATOMnilptr(b->ttype);
	BBPunfix(b->batCacheid);

#ifdef _DEBUG_BPM_
	mnstr_printf(GDKout,"reverse call?%d\n",*bid);
	mnstr_printf(GDKout," break on "); VALprint(GDKout,val);
	mnstr_printf(GDKout," \n"); 
#endif
	/* overlap by excluding outliers */
	for(i= ps->nxt ; i!=ps->bid && bpmcat[i] ; i= bpmcat[i]->nxt){
	if( (msg=materializePartition(bpmcat[i])) )
		return msg; 
	if( *bid > 0){
		if( greater(i,tlow,val) || equal(i,tlow,val) ||
			less(i,thgh,val) || equal(i,thgh,val) ){
				/* this fragment need not be split */
				continue;
			}
	} else
		if( greater(i,hlow,val) || equal(i,hlow,val) ||
			less(i,hhgh,val) || equal(i,hhgh,val) ){
				/* this fragment need not be split */
				continue;
			}

#ifdef _DEBUG_BPM_
			BPMprintPartition(GDKout,bpmcat[i]);
#endif
		/* we can enter a new partition */
		@:getBATdescriptor(&bpmcat[i]->bid,b,"bpm.splitPartition");
		if( *bid > 0) {
			bn= BATselect_(b, val, nilptr, TRUE, FALSE);
		} else {
			bn= BATselect_(BATmirror(b), val, nilptr, TRUE, FALSE);
			bn= BATcopy(BATmirror(bn), bn->ttype, bn->htype,1);
		}

		if( bn == 0){
			BBPunfix(b->batCacheid);
			throw(MAL,"bpm.split", MAL_MALLOC_FAIL);
		}
		BBPkeepref(bn->batCacheid);
		p= newPartition(bn->batCacheid);
		p->type = newBatType(bn->htype,bn->ttype);
		bpmcat[bn->batCacheid]->bid = bn->batCacheid;
		BBPincref(bn->batCacheid,TRUE);
		p->alias= bpmcat[i]->alias;
		@:defaultRange(p,bn)@
		insertPartition(bpmcat[i],p);

		bpmcat[p->bid]->cnt= BATcount(bn);
		if( *bid> 0){
			VALset(&p->hlow, rngType(b->htype), &bpmcat[i]->hlow );
			VALset(&p->hhgh, rngType(b->htype), &bpmcat[i]->hhgh  );
			VALset(&p->tlow, rngType(b->ttype), val );
			VALset(&p->thgh, rngType(b->ttype), &bpmcat[i]->thgh );

			VALset(& bpmcat[i]->thgh, rngType(b->ttype), val );
		} else {
			VALset(&p->hlow, rngType(b->htype), val );
			VALset(&p->hhgh, rngType(b->htype), &bpmcat[i]->hhgh  );
			VALset(&p->tlow, rngType(b->ttype), &bpmcat[i]->tlow );
			VALset(&p->thgh, rngType(b->ttype), &bpmcat[i]->thgh );

			VALset(& bpmcat[i]->hhgh, rngType(b->htype), val );
		}

		/* default hash */
		p->hbits=  bpmcat[i]->hbits;
		p->tbits=  bpmcat[i]->tbits;

		
#ifdef _DEBUG_BPM_
		mnstr_printf(GDKout,"Broke partition '%s' at %d\n", bpmcat[i]->name,i);
		BPMprintPartition(GDKout, bpmcat[i]);
		BPMprintPartition(GDKout,p);
		mnstr_printf(GDKout,"Finished partition\n");
#endif

		BATdel(b,bn,FALSE); /* assume unique heads */
		bpmcat[i]->cnt= BATcount(b);
		BBPunfix(b->batCacheid);
	}
	return MAL_SUCCEED;
}

@-
Range partitioning simply runs through all partitions
and creates new ones, keeping the partitions in order.
@c
str
BPMrange(bat *ret, bat *bid, ptr low, ptr hgh){
	BPMopen();

	if( getAlias(*bid) == NULL)
		throw(MAL, "bpm.range", RUNTIME_OBJECT_MISSING);
	BPMsplitpartition(ret,bid,low);
	BPMsplitpartition(ret,bid,hgh);
	return MAL_SUCCEED;
}
@-
The vector approach is simply a list of split points.
@c
str
BPMrangeVector(bat *ret, bat *bid, bat *pv)
{
	BATiter bpvi;
	BAT *b, *bpv;
	BUN cur,q;
	ptr val;

	BPMopen();

	if( bpmcat[*bid] == 0)
		throw(MAL,"bpm.rangeVector", RUNTIME_OBJECT_MISSING);
	@:getBATdescriptor(bid,b,"bpm.rangeVector");
	@:getBATdescriptor(pv,bpv,"bpm.range")@
	if( bpv == 0){
		BBPunfix(b->batCacheid);
		throw(MAL,"bpm.range", INTERNAL_BAT_ACCESS);
	}
	bpvi = bat_iterator(bpv);
	BATloop(bpv,cur,q){
		val= BUNtail(bpvi,cur);
		BPMsplitpartition(ret,bid,val);
	}
	*ret= 0;
	return MAL_SUCCEED;
}


str
BPMsortPartitions(int *ret, bat *bid)
{
	int i,r,nx=0;
	Partition a, p;
	str msg = MAL_SUCCEED;
	BAT *b, *bs, *bn;

	BPMopen();
	if( (a= getAlias(*bid)) == 0)
		throw(MAL,"bpm.sort", RUNTIME_OBJECT_MISSING);
	/* replace each partition with its sorted version */
	for(i= a->nxt ; i!= a->alias; i= nx){
		if( (msg=materializePartition(bpmcat[i])) )
			return msg; 
		nx= bpmcat[i]->nxt;
		
		@:getBATdescriptor(&bpmcat[i]->bid,b,"bpm.sortPartitions");
		if (!BATtordered(b)) { 
			bs= BATsort(BATmirror(b));
			bs = BATmirror(bs);
					if (!(bs->batDirty&2)) bs = BATsetaccess(bs, BAT_READ);
			bn= BATcopy(bs, bs->htype,bs->ttype,1);

			p= newPartition(bn->batCacheid);
			p->type = newBatType(bn->htype,bn->ttype);
			bpmcat[bn->batCacheid]->bid = bn->batCacheid;
			BBPincref(bn->batCacheid,TRUE);
			memcpy((char*) p, (char*) bpmcat[i],sizeof(PartitionRec));
			p->bid= bn->batCacheid;
			BBPincref(bn->batCacheid,TRUE);
			bpmcat[p->prv]->nxt= p->bid;
			bpmcat[p->nxt]->prv= p->bid;

			BKCsetTransient(&r,&bpmcat[i]->bid);
/*			BBPdecref(bpmcat[i]->bid,TRUE);*/
			GDKfree(bpmcat[i]);
			bpmcat[i]= NULL;
		
			BBPunfix(bs->batCacheid);
			BBPunfix(bn->batCacheid);
		}
		BBPunfix(b->batCacheid);

	}
	*ret=0;
	return msg;
}

str
BPMhashPartitions(int *ret, bat *bid)
{
	int i;
	Partition a;
	str msg = MAL_SUCCEED;
	BAT *b;

	BPMopen();
	if( (a= getAlias(*bid)) == 0)
		throw(MAL,"bpm.hash", RUNTIME_OBJECT_MISSING);
	for(i= a->nxt; i!= a->alias; i= bpmcat[i]->nxt) {
		if( (msg=materializePartition(bpmcat[i])) )
			return msg; 
				
		@:getBATdescriptor(&bpmcat[i]->bid,b,"bpm.hashPartitions");
		if (b == NULL) {
				throw(MAL, "bat.setHash", INTERNAL_BAT_ACCESS);
		}
		BAThash(b, 0);
		BBPunfix(b->batCacheid);
	}
	*ret=0;
	return msg;
}

str
BPMrangeVectorSort(bat *ret, bat *bid, bat *pv)
{	
	str msg;
	msg=BPMrangeVector(ret,bid,pv);
	if (msg == MAL_SUCCEED)
		msg=BPMsortPartitions(ret,bid);	
	return msg;
}

int
BPMisPartitioned(bat bid){
	return getAlias(bid)!= 0;
}

static BUN
BPMcountInternal(bat bid)
{
	BUN ret=0;
	int i;
	Partition ps;
	BAT *b;

	if( (ps= getAlias(bid)) == 0)
		return 0;
	for(i= ps->nxt ; i!=ps->bid && bpmcat[i] ; i= bpmcat[i]->nxt){
		materializePartition(bpmcat[i]);
		b= BATdescriptor(bpmcat[i]->bid);
		if ( b == NULL)
			GDKsyserror("wrong count administration\n");
		else {
		if( BATcount(b) != bpmcat[i]->cnt)
			GDKsyserror("wrong count administration\n");
			BBPunfix(b->batCacheid);
		}
		ret += bpmcat[i]->cnt;
	}
#ifdef _DEBUG_BPM_
	printf("bpmcountInternal %d ->" BUNFMT "\n",bid,ret);
#endif
	return ret;
}

str
BPMcount(wrd *ret, bat *bid){
	*ret= (wrd) BPMcountInternal(*bid);
	return MAL_SUCCEED;
}

@-
The emptySet constraint superseeds the similar version
for ordinary BATs.
@c
str
BPMemptySet(int *ret, bat *bid)
{
	int i;
	BUN cnt=0;
	Partition ps;
	BAT *b;

	*ret=0;
	if( (ps= getAlias(*bid)) == 0){
		b= BATdescriptor(*bid);
		if(b==0)
			throw(MAL,"bpm.emptySet", INTERNAL_BAT_ACCESS);
		cnt = BATcount(b);
		BBPunfix(b->batCacheid);
		if (cnt)
			throw(OPTIMIZER, "mal.assert", "emptySet");
		return MAL_SUCCEED;
	}
	for(i= ps->nxt ; i!=ps->bid && bpmcat[i] ; i= bpmcat[i]->nxt){
		b = BATdescriptor(bpmcat[i]->bid);
		if (b){
			cnt = BATcount(b);
			BBPunfix(b->batCacheid);
		}
		if (cnt)
			throw(OPTIMIZER, "mal.assert", "emptySet");
	}
	return MAL_SUCCEED;
}

static int BPMpiecesCnt(bat bid){
	int i,cnt=0;
	Partition ps;
	if( (ps= getAlias(bid)) == 0)
		return 1;
	for(i= ps->nxt ; i!=ps->bid && bpmcat[i] ; i= bpmcat[i]->nxt)
		cnt +=1;
	return cnt;
}

str
BPMsortTail(int *ret, bat *bid)
{
	BAT *b;
	str msg;

	if( getAlias(*bid) == 0)
		throw(MAL,"bpm.emptySet", RUNTIME_OBJECT_MISSING);
	if( (msg= BPMfold(ret,bid)) )
		return msg;
	b= BATdescriptor(*ret);
	BATmirror(BATsort(BATmirror(b)));
	return MAL_SUCCEED;
}

static int 
BPMpiecesImpl(bat bid){
	int i,cnt=0;
	Partition ps;

	if( (ps= getAlias(bid)) == 0)
		return 1;
	for(i= ps->nxt ; i!=ps->bid && bpmcat[i] ; i= bpmcat[i]->nxt){
		materializePartition(bpmcat[i]);
		cnt +=1;
	}
	return cnt;
}

str
BPMpieces(int *ret, bat *bid)
{
	*ret= BPMpiecesImpl(*bid);
	return MAL_SUCCEED;
}
@-
The partitioning scheme should become adaptive.
@c

static int 
guessNewPartition(BAT *b){
	if( BATcount(b) >BATTINY )
		return 1;
	return 0;
}

static Partition 
getAcceptor(bat ba, BUN maxcnt){
	Partition p;
	int i;
	BAT *b,*bn;

	p = getAlias(ba);
	if ( p == NULL)
		return 0;
	if( emptyRing(p)){
		b= BATdescriptor(p->bid);
		if ( b == NULL)
			return 0;
		bn= BATnew(b->htype, b->ttype, maxcnt);
		newPartition(bn->batCacheid);
		p->type = newBatType(bn->htype,bn->ttype);
		bpmcat[bn->batCacheid]->bid = bn->batCacheid;
		BBPkeepref(bn->batCacheid);
		BBPunfix(b->batCacheid);
		return bpmcat[bn->batCacheid];
	}
	for(i=p->nxt; i!= p->bid && bpmcat[i]; i=bpmcat[i]->nxt){
		materializePartition(bpmcat[i]);
		if( bpmcat[i]->cnt < maxcnt)
			return bpmcat[i];
	}
	return 0;
}

str
BPMaddPartition(int *ret, bat *bid, bat *src){
	BUN cnt=0, maxcnt;
	Partition pa,p,px;
	BAT *b,*bn, *ba;

	assureSpace();
	if( (pa= getAlias(*bid)) == 0)
		throw(MAL,"bpm.addPartition",RUNTIME_OBJECT_MISSING);
	ba= BATdescriptor(pa->bid);
	if( ba== NULL)
		throw(MAL,"bpm.addPartition",INTERNAL_BAT_ACCESS);
	b= BATdescriptor(*src);
	if( b== NULL) {
		BBPunfix(ba->batCacheid); 
		throw(MAL,"bpm.addPartition",INTERNAL_BAT_ACCESS);
	}
	if(bpmcat[*src] ){
		BAT *bb;
#ifdef _DEBUG_BPM_
		mnstr_printf(GDKout,"Attempt to share a ring segment");
		BPMprintRing(GDKout,bpmcat[*src]);
#endif
		bb= BATcopy(b, b->htype, b->ttype,TRUE);
		BBPunfix(b->batCacheid);
		b= bb;
	}
	if ((rngType(b->htype) !=rngType(ba->htype)) ||
		 (rngType(b->ttype) != rngType(ba->ttype))) {
#ifdef _DEBUG_BPM_
		mnstr_printf(GDKout,"b: %d,%d alias: %d,%d\n", 
		b->htype,b->ttype,ba->htype,ba->ttype);
#endif
		BBPunfix(ba->batCacheid); 
		BBPunfix(b->batCacheid); 
		throw(MAL,"bpm.addPartition",SEMANTIC_TYPE_MISMATCH);
	}

	BBPunfix(ba->batCacheid); 
	cnt = BATcount(b);
#ifdef _DEBUG_BPM_
	printf("addPartition %d -> %d\n",*bid, *src);
#endif
	maxcnt = 2*BATTINY - cnt;
	/* is it a big piece or no enough space in the existing? */
	if( guessNewPartition(b) || 
		emptyRing(pa) ||
		(px= getAcceptor(*bid,maxcnt))==0 ) {
		p= newPartition(b->batCacheid);
		p->type = newBatType(b->htype,b->ttype);
		bpmcat[b->batCacheid]->bid = b->batCacheid;
		BBPincref(b->batCacheid,TRUE);
		insertPartition(pa,p);
		p->cnt = cnt;
		p->alias = pa->alias;
		@:defaultRange(p,b)@
#ifdef _DEBUG_BPM_
		printf("guess-> " BUNFMT " ring %d px %d\n",p->cnt, emptyRing(pa), px!=0);
		BPMprintRing(GDKout,pa);
#endif
	} else {
		/* add the content to the acceptor segment */
		bn= BATdescriptor(px->bid);
		if( bn== NULL)
			throw(MAL,"bpm.addPartition", RUNTIME_OBJECT_MISSING);
		bn= BATappend(bn,b,TRUE);
		assert(bn!=NULL);
		px ->cnt += BATcount(b);
		BBPunfix(bn->batCacheid); 
#ifdef _DEBUG_BPM_
		@:defaultRange(px,bn)@
		printf("no guess-> " BUNFMT "\n",px->cnt);
		BPMprintRing(GDKout,px);
#endif
	}
	BBPunfix(b->batCacheid);
	(void)ret;
	return MAL_SUCCEED;
}


str
BPMhash(bat *ret, bat *bid, int *bits)
{
	BAT *b;
	BPMopen();
	@:getBATdescriptor(bid,b,"bpm.hash")@
	/* get hash slot administration */
	(void) b;
	(void) bits;
	*ret= 0;
	throw(MAL, "bpm.hash",PROGRAM_NYI);
}

str
BPMderived(bat *ret, bat *bid, bat *src)
{
	BAT *b;
	BPMopen();
	@:getBATdescriptor(bid,b,"bpm.derived")@
	/* partition into two direction */
	(void) b;
	(void) src;
	*ret= 0;
	throw(MAL, "bpm.derived",PROGRAM_NYI);
}

@-
Take a sample from a BAT and determine the median value.
It is the candidate split value.
@c
static void findMedian(ValPtr vp, BAT * b)
{
	BUN c; 
	BAT *bh, *bs;
	BATiter bsi;

	bh = BATsample(b,100);
	bs = BATtsort(bh);
	c = BATcount(bh)/2;
	bsi = bat_iterator(bs);
	VALset(vp, b->ttype, BUNtail(bsi,c));

	BBPunfix(bs->batCacheid);
	BBPunfix(bh->batCacheid);
}

@- Adaptive segmentation
The adapt() routine breaks up a BAT into multiple pieces.
Several policies will be implemented and explored.
The SIZEPOLICY just looks at the absolute
size of the pieces produced. They may not get too small.

The ORACLEPOLICY implements a random decision based
on a Gaussian distribution, the total number of fragments
and the relative size of the piece to be broken op.

Both policies need to analize the overlap of selection and segment.
overlap 0- selection covers entire segment
overlap 1- selection covers the lower part of the segment
overlap 2- selection covers the upper part of the segment
overlap 3- selection covers intermediate part of the segment

@c
#define SIZEPOLICY 1
#define ORACLEPOLICY 2
#define HYBRIDPOLICY 3


static int 
overlap( BAT *b, int *bid, ptr low, ptr hgh)
{
	int ov=0;
	int (*cmp) (ptr, ptr);
	ptr nilptr;

	cmp= BATatoms[b->ttype].atomCmp;
	nilptr = ATOMnilptr(b->ttype);

	if((((*cmp)(low, nilptr)==0) || greater(*bid,tlow,low) ||
	     equal(*bid,tlow,low)) && 
	   (((*cmp)(hgh, nilptr)==0) || less(*bid,thgh,hgh) ||
	     equal(*bid,thgh,hgh))) {
		ov =0;
	} else if(((*cmp)(low, nilptr)==0) || greater(*bid,tlow,low) ||
		equal(*bid,tlow,low)) { 
		ov=1; 
	} else if (((*cmp)(hgh, nilptr)==0) || less(*bid,thgh,hgh) ||
		equal(*bid,thgh,hgh)) {
		ov=2;
	} else { 	
		ov=3;
	}

	return ov;
}

static int 
BPMsizePolicy( BAT *b, BAT *bs, int ov)
{
	int cs=0;
	lng space, space1, space2=0;

	space = BATcount(b)* (Hsize(b) + Tsize(b) + sizeof(BUN)) + sizeof(BATstore);
	space1 = BATcount(bs)* (Hsize(b) + Tsize(b) + sizeof(BUN)) + sizeof(BATstore);

/*	mnstr_printf(GDKout,"tuples " BUNFMT " size  " LLFMT " selection " LLFMT "\n", BATcount(b),space, space1); */
	if(ov <3) {
		space2 = space -space1;
	}
	else if (ov==3){
	 	space2 = (space -space1)/2; /* rough estimate of two remainders*/
	}
	if ((space1 < Mmin) || (space2 < Mmin)) {
		if (space > Mmax) { 
			/* little parts in large segment- split on median*/
			cs = 4;}
		else cs = 0;
	} else cs =ov;

	return cs;
}

static double
gaussian(double x, double sigma, double m){
	double s2= sigma*sigma;
	double f1= 1.0/(sigma *sqrt(2*M_PI));
	double f2= f1 * exp(-(x-m)*(x-m)/(2*s2));
	return f2;
}

static int
BPMoraclePolicy(double x, double sigma)
{
	double rnd, g;

	rnd= (double)rand()/(double)RAND_MAX;
	g= gaussian(x,sigma,0.5)/ gaussian(0.5,sigma,0.5);
#ifdef _DEBUG_BPM_
	printf("oracle rnd %f x %f sigma %f gaussian %f\n",
	rnd,x,sigma,g);
#endif
	return g>rnd;
}

static int 
BPMhybridPolicy( BAT *b, BAT *bs, int ov)
{
	int cs=0, or;
	BUN cnt=0;
	lng space, space1, space2=0;

	space = BATcount(b)* (Hsize(b) + Tsize(b) + sizeof(BUN)) + sizeof(BATstore);
	space1 = BATcount(bs)* (Hsize(b) + Tsize(b) + sizeof(BUN)) + sizeof(BATstore);

	if(ov <3) {
		space2 = space -space1;
	}
	else if (ov==3){
	 	space2 = (space -space1)/2; /* rough estimate of two remainders*/
	}
#ifdef _DEBUG_BPM_
	mnstr_printf(GDKout,"Space1  " LLFMT " Space2 " LLFMT "\n",space1,space2);
#endif

	if ((space1 < Mmin) || (space2 < Mmin)) {
		cnt= BPMcountInternal(b->batCacheid);
		if (cnt ==0) or =0;
		else or=BPMoraclePolicy(0.4, (double)BATcount(b)/(BPMpiecesCnt(b->batCacheid)*cnt));
#ifdef _DEBUG_BPM_
	mnstr_printf(GDKout,"Oracle %d \n",or);
#endif
		if (or) { 
			/* little parts in large segment- split on median*/
			cs = 4;}
		else cs = 0;
	} else cs =ov;

	return cs;
}

@= inheritRange
	/* default range @1= Partition @2= BAT * */
	VALset(&@1->hlow, rngType(@2->htype), (ptr) &(@3->hlow) );
	VALset(&@1->hhgh, rngType(@2->htype), (ptr) &(@3->hhgh) );
	VALset(&@1->tlow, rngType(@2->ttype), (ptr) &(@3->tlow) );
	VALset(&@1->thgh, rngType(@2->ttype), (ptr) &(@3->thgh) );
	@1->hbits= @3->hbits;
	@1->tbits= @3->tbits;

@c

static int 
spread( bat *ret, BUN *cnt, BAT *b, ValPtr sep, int n, int skip)
{	
	int k=n-2, i;
	BUN p,q;
	BAT **bs = alloca(sizeof(*bs) * (n-1)); /* Visual Studio doesn't accept BAT *bs[n-1] */
	ptr val;

	int (*cmp) (ptr, ptr);
	cmp= BATatoms[b->ttype].atomCmp;

	for(i=0; i<=k; i++)
		if (i!=skip){
			bs[i] = BATnew(b->htype, b->ttype, BATcount(b)/k );
	}

	BATloop(b, p, q) {
		val = Tloc(b, p);
		for(i=0; i<k; i++) {
			if( ((*cmp)(val,(ptr) &sep[i+1]) <0) && (i!= skip)) {
				BUNins(bs[i], Hloc(b, p), val, TRUE);
				break;
			}	
		} 
		if( (i == k) && (i!=skip) &&
		    ((*cmp)(val,(ptr) &sep[i]) >0) )
			BUNins(bs[k], Hloc(b, p), val, TRUE);
	}		
	
	for(i=0; i<=k; i++)
		if (i!=skip){
			ret[i]= bs[i]->batCacheid;
			cnt[i]= BATcount(bs[i]);
			BBPkeepref(bs[i]->batCacheid);
		#ifdef _DEBUG_BPM_
			mnstr_printf(GDKout,"New bat %d\n",ret[i]);
		#endif
	}
	return 0;
}

static str
BPMadaptImpl(bat *ret, bat *bid, ptr low, ptr hgh, bat *rs, int policy )
{
	BAT *b,*bs;
	Partition ps, p, pprev;
	bat *bb;
	ValPtr sep = NULL;
	int cs=0, ov, or;
	BUN cnt=0, bcnt;
	int i, n=0, tpe, skip=-1;
	BUN cnts[4]={0};
	lng space;
	(void) ret;

	BPMopen();

	if( (ps = getByNumber(*bid)) == 0)
		throw(MAL,"bpm.split",ILLEGAL_ARGUMENT);
	@:getBATdescriptor(bid,b,"bpm.adapt");

	tpe = rngType(b->ttype);

/* baseline size, too small BATs are never broken*/
	space = BATcount(b)* (Hsize(b) + Tsize(b) + sizeof(BUN)) + sizeof(BATstore);
	if (space < Mmin) { /* no re-org.*/
		BBPkeepref(*ret = b->batCacheid);
		return MAL_SUCCEED;
	}
	ov = overlap(b,bid,low,hgh);

	if( ov==0)
	{ 	/* entire segment selected - no reorg.*/
		BBPkeepref(*ret = b->batCacheid);
		return MAL_SUCCEED;
	}

	@:getBATdescriptor(rs,bs,"bpm.adapt");
	if( policy == SIZEPOLICY)
		cs= BPMsizePolicy(b,bs,ov);
	if( policy == HYBRIDPOLICY)
		cs= BPMhybridPolicy(b,bs,ov);

	if(policy == ORACLEPOLICY ) {
		cnt= BPMcountInternal(b->batCacheid);
		bcnt = BATcount(b);
		if ( (cnt ==0) || (bcnt ==0) || (BATcount(bs) ==0) ) or =0;
		else or=BPMoraclePolicy((double)BATcount(bs)/bcnt, (double)bcnt/cnt);
	
#ifdef _DEBUG_BPM_
/*	mnstr_printf(GDKout,"Oracle %d bcnt " BUNFMT " cnt " BUNFMT " \n",or, bcnt,cnt);*/
#endif
		if (or) cs= ov; 
	}
	
#ifdef _DEBUG_BPM_
/*	mnstr_printf(GDKout,"Case %d policy %d\n",cs, policy); */
#endif

	
	if( cs==0){	/* no re-org. */
		
			BBPkeepref(*ret = b->batCacheid);
			BBPunfix(bs->batCacheid);
			return MAL_SUCCEED;
	}
	

/* form array of segment separators */
	sep= (ValPtr) GDKzalloc(4*sizeof(ValRecord));
	VALset(sep, tpe, &ps->tlow );
	n++;
	switch (cs){	
		case 1: VALset(sep+n, tpe, hgh ); n++; skip= 0;
			break;

		case 2: VALset(sep+n, tpe, low ); n++; skip= 1;
			break;

		case 3: VALset(sep+n, tpe, low );n++;  skip= 1;
			VALset(sep+n, tpe, hgh );n++;
			break;

		case 4:	findMedian(sep+n,b); n++;

	}
	VALset(sep+n, tpe, &ps->thgh );n++;

#ifdef _DEBUG_BPM_
		mnstr_printf(GDKout,"Found separators ");
		for(i=0;i<n;i++)
			VALprint(GDKout,&sep[i]);
			mnstr_printf(GDKout,"\n");
#endif	

/* re-organize */
	bb= (bat *) GDKzalloc( sizeof(bat) * (n-1));
	spread(bb,cnts,b,sep,n,skip);
	if ( (skip >-1) && (skip <n-1) ){
		bb[skip]= bs->batCacheid;
		BBPincref(bs->batCacheid,TRUE);
		cnts[skip]= BATcount(bs);
	}
	BBPunfix(bs->batCacheid);

/* replace segment ps by a chain of new segments */
	pprev = getByNumber(ps->prv);
	for(i=0; i<n-1; i++, pprev=p){
		p= newPartition(bb[i]);
		p->type = pprev->type;
		bpmcat[bb[i]]->bid = bb[i];
		BBPincref(bb[i],TRUE);
		p->alias= ps->alias;
		@:inheritRange(p,b,ps)@
		p->cnt= cnts[i];
		if( *bid> 0){
			VALset(&p->tlow, tpe, &sep[i]);	
			VALset(&p->thgh, tpe, &sep[i+1] );
		} else {
			VALset(&p->hlow, tpe, &sep[i] );
			VALset(&p->hhgh, tpe, &sep[i+1] );	
		}
		
		insertPartition(pprev,p);
		#ifdef _DEBUG_BPM_
			mnstr_printf(GDKout,"Inserted partition: \n ");
			BPMprintPartition(GDKout,p);
			mnstr_printf(GDKout,"Lrefs %d: refs %d\n ",BBP_lrefs(bb[i]),BBP_refs(bb[i]));
		#endif
	}

	dropPartition(ps);
	GDKfree(sep);

	BBPunfix(b->batCacheid);
	BBPincref(bb[n-2],TRUE);
	*ret=bb[n-2];
	return MAL_SUCCEED;
}

@-
Split the implementation to have a second implementation
scheme to also study effects of splitting itself.
The delayed flag generates complementary partitions,
which still have to be filled upon use.
@c
static str
BPMoracleImpl(int *ret, bat *bid, ptr low, ptr hgh, bat *rs, int delayed)
{
	BAT *b,*bs, *bs1, *bs2;
	Partition ps, p;
	int (*cmp) (ptr, ptr);
	ptr nilptr;
	(void) ret;

	BPMopen();

	if( (ps = getByNumber(*bid)) == 0)
		throw(MAL,"bpm.oracle", ILLEGAL_ARGUMENT);
	@:getBATdescriptor(bid,b,"bpm.oracle");
	/* get the comparison function */
	cmp= BATatoms[b->ttype].atomCmp;
	nilptr = ATOMnilptr(b->ttype);

@-
We are only interested in partitions that partly overlap
Complete segment require no reorganization.
@c
	if((((*cmp)(low, nilptr)==0) || greater(*bid,tlow,low) ||
	     equal(*bid,tlow,low)) && 
	   (((*cmp)(hgh, nilptr)==0) || less(*bid,thgh,hgh) ||
	     equal(*bid,thgh,hgh))) 
	 { 
		BBPunfix(b->batCacheid);
		return MAL_SUCCEED;
	}
@-
Call the oracle to determine if it makes sense to
break the partition further
@c
	@:getBATdescriptor(rs,bs,"bpm.oracle");
	if( BPMoraclePolicy((double)BATcount(bs)/BATcount(b), 
				1.0/BPMpiecesImpl(b->batCacheid)) == 0) {
			BBPunfix(b->batCacheid);
			BBPunfix(bs->batCacheid);
			return MAL_SUCCEED;
	}
@- 
The plan is to use the result table RS as a new partition
and to correct B from which it is derived. BS1 is the new partition.
We know that B and RS have the same signature, but it may be
reversed. Let's prepare this partition and add it.
@c
#ifdef _DEBUG_BPM_
	mnstr_printf(GDKout,"Oracle dictates split\n");
#endif
	if( *bid > 0)
		bs1= BATcopy(bs, bs->htype, bs->ttype,1);
	else
		bs1= BATcopy(BATmirror(bs), bs->ttype, bs->htype,1);
	if( bs1 == 0){
		BBPunfix(bs->batCacheid);
		BBPunfix(b->batCacheid);
		throw(MAL,"bpm.adapt", MAL_MALLOC_FAIL"Can not create new segment");
	}
	BBPkeepref(bs1->batCacheid);

	if( delayed== FALSE){
		/* and reduce the source partition */
		BATdel(b,bs1,FALSE);
@-
Beware, now B contains elements <low and >=hgh.
So we may have to split it further 
@c
		bs2 =  BATselect_(b, hgh, nilptr, FALSE, FALSE);
		if( BATcount(bs2) > 0){
			BATdel(b,bs2,FALSE);
			if( BATcount(bs1)==0){
				BBPunfix(bs1->batCacheid);
				bs1=NULL;
			}
		} else {
			BBPunfix(bs2->batCacheid);
			bs2= NULL;
		}
@-
We have now at most three partitions. If there is 1, we are done.
The  newbounds should be set and they should be added to the ring.
@c
		if( bs1== NULL && bs2==NULL){
			return MAL_SUCCEED;
		}
		if (bs2)
			BBPkeepref(bs2->batCacheid);
	} else bs1= bs2= b;
@-
Add the new partition based on RS.
@c
	if( bs1){
		p= newPartition(bs1->batCacheid);
		p->type= ps->type;
		bpmcat[bs1->batCacheid]->bid = bs1->batCacheid;
		BBPincref(bs1->batCacheid,TRUE);
		insertPartition(ps,p);
		p->alias= ps->alias;
		p->hbits=  ps->hbits;
		p->tbits=  ps->tbits;
		p->cnt= BATcount(bs1);
		p->delayed= delayed;
		if( *bid> 0){
			VALset(&p->hlow, rngType(b->htype), &ps->hlow);
			VALset(&p->hhgh, rngType(b->htype), &ps->hhgh);
			VALset(&p->tlow, rngType(b->ttype), low );
			VALset(&p->thgh, rngType(b->ttype), hgh );
		} else {
			VALset(&p->hlow, rngType(b->htype), low );
			VALset(&p->hhgh, rngType(b->htype), hgh  );
			VALset(&p->tlow, rngType(b->ttype), &ps->tlow );
			VALset(&p->thgh, rngType(b->ttype), &ps->thgh );
		}
	}
@-
Add the left-over partition to the ring as well.
@c
	if( bs2){
		p= newPartition(bs2->batCacheid);
		p->type= ps->type;
		bpmcat[bs2->batCacheid]->bid = bs2->batCacheid;
		BBPincref(bs2->batCacheid,TRUE);
		insertPartition(ps,p);
		p->alias= ps->alias;
		p->hbits=  ps->hbits;
		p->tbits=  ps->tbits;
		p->cnt= BATcount(bs2);
		p->delayed= delayed;
		@:defaultRange(p,bs2)@
		if( *bid> 0){
			VALset(&p->hlow, rngType(b->htype), &ps->hlow);
			VALset(&p->hhgh, rngType(b->htype), &ps->hhgh);
			VALset(&p->tlow, rngType(b->ttype), hgh );
		} else {
			VALset(&p->hlow, rngType(b->htype), hgh );
			VALset(&p->tlow, rngType(b->ttype), &ps->tlow );
			VALset(&p->thgh, rngType(b->ttype), &ps->thgh );
		}
	}
@-
And finally adjust the source partition.
It only lost tuples.
@c
	if( *bid> 0)
		VALset(&ps->thgh, rngType(b->ttype), low );
	else
		VALset(&ps->hhgh, rngType(b->ttype), low );
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

str BPMadapt(int *ret, bat *bid, ptr low, ptr hgh, bat *rs, int *pol )
{
	return BPMadaptImpl(ret,bid,low,hgh,rs, *pol);
}

/*
str BPMadapt(int *ret, bat *bid, ptr low, ptr hgh, bat *rs )
{
	return BPMadaptImpl(ret,bid,low,hgh,rs,SIZEPOLICY);
}
*/


str BPMoracle(int *ret, bat *bid, ptr low, ptr hgh, bat *rs )
{
	return BPMoracleImpl(ret,bid,low,hgh,rs,FALSE);
}


@-
Takeing out partitions.
@c
str
BPMtakeIndexed(bat *ret, int *nme)
{
	BAT *b= BATdescriptor(*nme);
	if( b==0 )
		throw(MAL,"bpm.take", RUNTIME_OBJECT_MISSING);
	BBPkeepref(*ret= b->batCacheid);
	return MAL_SUCCEED;
}

str
BPMtake(bat *ret, str *nme)
{
	Partition p;
	BPMopen();
	if( (p=getByName(*nme)) == 0)
		throw(MAL,"bpm.take", RUNTIME_OBJECT_MISSING);
	*ret = p->alias;
	BBPincref(p->alias,TRUE);
	return MAL_SUCCEED;
}

str
BPMtakePartition(bat *ret, str *nme, ptr *hl, ptr *hh, ptr *tl, ptr *th)
{
	Partition p;
	int index=0;

	BPMopen();
	p= getByName(*nme);
	if( p== 0)
		throw(MAL,"bpm.take", RUNTIME_OBJECT_MISSING);
	return BPMtakePartitionIndexed(ret,&p->alias, &index,hl,hh,tl,th);
}

str
BPMtakePartitionIndexed(bat *ret, int *bid, int *idx, ptr *hl, ptr *hh, ptr *tl, ptr *th)
{
	/* for the time being assume that the index is correct */
	BAT *b= BATdescriptor(*bid);
	if( b== NULL)
		throw(MAL,"bpm.take", INTERNAL_BAT_ACCESS);
	(void) idx;
	(void) hl;
	(void) hh;
	(void) tl;
	(void) th;
	BBPkeepref(*ret= b->batCacheid);
	return MAL_SUCCEED;
}
@-
The Mergetable optimizer may request a list of fragments
to be included.
@c
str
BPMexpand(Client cntxt, MalBlkPtr mb, int varid, int bid){
	Partition p;
	InstrPtr q;
	int i,fragment=0;

	(void) cntxt;
	/* fake the partitioned version */
	BPMunfold( &i, &bid);
	p= getByNumber(bid);
	
	if(p)
	for(i= p->nxt ; i!=p->bid && bpmcat[i] ; i= bpmcat[i]->nxt) {
		q = newStmt(mb,"bpm","take");
		q=pushArgument(mb,q,varid);
		/* add the fragmentation dimension properties */
		q=pushInt(mb,q,fragment);
		q=pushValue(mb,q,&p->hlow);
		q=pushValue(mb,q,&p->hhgh);
		q=pushValue(mb,q,&p->tlow);
		q=pushValue(mb,q,&p->thgh);
		fragment++;
	}
	return MAL_SUCCEED;
}
@-
For debugging the SQL frontend we unfold its BATs.
It means we move the data to the storage ring
using any of the partitioning schemes. The original
BAT remains as the anchor point.
The action can be undone with the 'unfold' operation.
@c
str
BPMunfold(bat *ret, bat *bid)
{
	Partition p;
	str msg= MAL_SUCCEED;

	BPMopen();
	assureSpace();
	p= bpmcat[*bid];
	if( p== 0){
		msg= BPMdeposit(ret, 0, bid);
#ifdef _DEBUG_BPM_
		printf("unfold %d %d \n", *bid, *ret);
#endif
		p= bpmcat[*ret];
		/* throw(MAL,"bpm.take","Partitioned BAT does not exist");*/
	} else{
		BBPincref(*ret=p->alias,TRUE);
#ifdef _DEBUG_BPM_
		printf("already unfolded %d %d \n", *bid, *ret);
#endif
	}
	return msg;
}

@-
At some point the partitioned BAT is brought back
into a single one. If we have a single partition,
it is just propagated to become the primary(again).
The implementation favors SQL with a single partition,
because the BAT id remains intact. A better solution
should be sought for bulk updates.
@c
str
BPMfold(bat *ret, bat *bid){
	int i,j;
	BUN cnt=0;
	Partition ps;
	BAT *b,*bn;
	str msg= MAL_SUCCEED;

	i= *bid;
	if( (ps= getAlias(i)) == 0){
		BBPincref(*ret=*bid,TRUE);
		return MAL_SUCCEED; /* alias bas may already be folded */
	}

	if( BPMpiecesCnt(ps->alias) == 1){
		/* promote */
#ifdef _DEBUG_BPM_
		printf("fold %d %d %d %d\n", *bid, ps->bid, ps->alias, bpmcat[ps->nxt]->bid);
#endif
		b= BATdescriptor(bpmcat[ps->nxt]->bid);
		if( b== NULL)
			throw(MAL,"bpm.fold","Partition element not found");
		*ret= b->batCacheid;
/* printf("free %d\n", b->batCacheid);*/
		GDKfree(bpmcat[b->batCacheid]);
		bpmcat[b->batCacheid]= 0;
		BBPunfix(*ret);
		assert(i!= *ret);
/* printf("free %d\n", i);*/
		GDKfree(bpmcat[i]);
		bpmcat[i]= 0;
		return MAL_SUCCEED;
	}

	cnt=BPMcountInternal(*bid);
	b= BATdescriptor(i);
	if( b== NULL)
		throw(MAL,"bpm.fold","Partitioned BAT not found");
	bn= BATnew(b->htype, b->ttype, cnt);
	BBPunfix(b->batCacheid);
	if( bn== NULL)
		throw(MAL,"bpm.fold","Can not create BAT");

	for(i= ps->nxt ; i!=ps->bid && bpmcat[i] ; ) {
		if( (msg=materializePartition(bpmcat[i])) )
			return msg; 
		b= BATdescriptor(i);
		if( b== NULL)
			throw(MAL,"bpm.fold","Partitioned BAT not found");
		bn= BATappend(bn,b,FALSE);
		assert(bn!=NULL);
		/* remove its persistency counter */
		BBPdecref(b->batCacheid,TRUE);
		BBPunfix(b->batCacheid);
		j= bpmcat[i]->nxt;
		GDKfree(bpmcat[i]);
		bpmcat[i]= 0;
		i=j;
	}
	ps->nxt= ps->prv=  ps->bid;
	BBPkeepref(*ret= bn->batCacheid);
	return MAL_SUCCEED;
}
@-
The BPM garbage collector should be made specific for the partitions
being created. For now, we simple clear the catalog.
@c
str
BPMgarbage(int *ret,int *bid){
	int i,j;
	(void) ret;
#ifdef _DEBUG_BPM_
	printf("garbage %d\n",*bid);
#endif
	for(i= *bid; bpmcat[i]; ){
		j= bpmcat[i]->nxt;
#ifdef _DEBUG_BPM_
		printf("freeing %d\n",i);
#endif
		GDKfree(bpmcat[i]);
		bpmcat[i]= 0;
		if( i != *bid) 
			BBPdecref(i,TRUE);
		i= j;
	}
	return MAL_SUCCEED;
}
@- Updates
The update operations simply loop through the partitions
and apply the results. We can optimize this by inspection
of the range tables, but that is considered relevant in a distributed
case.
The updates are merely convenient operators, because ideally
the optimizer already filters out the partitions of interest.
@c
str
BPMinsert(bat *ret, bat *bid, bat *ins)
{
	int i;
	str msg= MAL_SUCCEED;
	Partition p;

	BPMopen();
	if( (p= getAlias(*bid)) == 0)
		throw(MAL,"bpm.insert","Can not access partitioned BAT");
	/* distributed the content */
	for(i= bpmcat[p->alias]->nxt;
		i!= p->alias && msg== MAL_SUCCEED; 
		i= bpmcat[i]->nxt){
			if( (msg=materializePartition(bpmcat[i])) )
				return msg; 
			msg=BKCinsert_bat(ret,&bpmcat[i]->bid,ins);
		}
	*ret= 0;
	return msg;
}

str
BPMdelete(bat *ret, bat *bid, bat *del)
{
	int i;
	Partition p;
	str msg= MAL_SUCCEED;

	BPMopen();
	if( (p=getAlias(*bid)) == 0)
		throw(MAL,"bpm.insert","Can not access partitioned BAT");
	/* distributed the content */
	for(i= bpmcat[p->alias]->nxt;
		i!= p->alias && msg== MAL_SUCCEED; 
		i= bpmcat[i]->nxt){
			if( (msg=materializePartition(bpmcat[i])) )
				return msg; 
			msg=BKCdelete_bat(ret,&bpmcat[i]->bid,del);
	}
	*ret= 0;
	return msg;
}

str
BPMreplace(bat *ret, bat *bid, bat *ins, bat *del)
{
	int i;
	Partition p;
	str msg= MAL_SUCCEED;

	BPMopen();
	if( (p= getAlias(*bid)) == 0)
		throw(MAL,"bpm.insert","Can not alias BAT");
	/* distributed the content */
	for(i= bpmcat[p->alias]->nxt;
		i!= p->alias && msg== MAL_SUCCEED; 
		i= bpmcat[i]->nxt) {
			if( (msg=materializePartition(bpmcat[i])) )
				return msg; 
			msg=BKCdelete_bat(ret,&bpmcat[i]->bid,del);
			if( msg == MAL_SUCCEED)
				msg=BKCinsert_bat(ret,&bpmcat[i]->bid,ins);
	}
	*ret= 0;
	return msg;
}

str
BPMgetNames(bat *ret)
{
	BAT *b;
	int i;
	str msg= MAL_SUCCEED;

	BPMopen();
	b = BATnew(TYPE_int, TYPE_str, BBPlimit);
	if (b == 0)
		throw(MAL, "catalog.bbpNames", MAL_MALLOC_FAIL);
	
	for(i=1; i<bpmcatsize; i++)
	if (bpmcat[i] && bpmcat[i]->name){
		if( (msg=materializePartition(bpmcat[i])) )
			return msg; 
		BUNins(b, &i, bpmcat[i]->name,TRUE);
	}
	
	BBPkeepref(*ret = b->batCacheid);
	if (!(b->batDirty&2)) 
		b = BATsetaccess(b, BAT_READ);
	return MAL_SUCCEED;
}

str
BPMdiscard(int *ret, bat *bid)
{
	int i,r;
	str msg= MAL_SUCCEED;
	Partition p;

	BPMopen();
	if( (p= getAlias(*bid)) == 0)
		throw(MAL,"bpm.discard", RUNTIME_OBJECT_MISSING);
	/* discard the content */
	for(i= p->nxt ;
		i!= p->alias && msg== MAL_SUCCEED; 
		i= r) {
	/*	msg= BKCdestroy(&r, &bpmcat[i]->bid); */
		if( (msg=materializePartition(bpmcat[i])) )
			return msg; 
		msg= BKCsetTransient(&r,&bpmcat[i]->bid);
		if( bpmcat[i]->name)
			GDKfree(bpmcat[i]->name);
		r= bpmcat[i]->nxt;
		GDKfree(bpmcat[i]);
		bpmcat[i]= NULL;
	}
	bpmcat[p->bid]= NULL;
	GDKfree(p);
	BBPdecref(*bid,TRUE);	
	msg= BKCsetTransient(&r,bid);

	*ret =0;
	return msg;
}

str
BPMdiscardAll(int *ret)
{
	int i;
	str msg= MAL_SUCCEED;

	BPMopen();
	for( i=1; i<bpmcatsize && msg== MAL_SUCCEED; i++)
	if( bpmcat[i] && bpmcat[i]->name){
		if( (msg=materializePartition(bpmcat[i])) )
			return msg; 
		msg= BPMdiscard(ret, &i);
	}
	*ret =0;
	return msg;
}

@- Iterations
We start with the large chunk iterator.
The definition of the control statements require the same
control variables, which means that the BATview is accessible
to determine how far to advance when the next chunk is retrieved.
The number of elements in the chunk is limited by the granule
size.

Iterations over partitioned BATs can be valued constrainted.
@c
str
BPMnew(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	BAT *bn;
	bat *ret;
	int ht, tt;
	Partition pa;

	(void) cntxt;
	(void) mb;

	ret= (bat *)getArgReference(stk, pci, 0);
	ht = getArgType(mb, pci, 1);
	tt = getArgType(mb, pci, 2);

	BPMopen();

	bn= BATnew(ht,tt,0);
	if( bn == 0)
		throw(MAL,"bpm.new", MAL_MALLOC_FAIL);
	
	pa = newPartition(bn->batCacheid);
	pa->type= newBatType(bn->htype,bn->ttype);
	bpmcat[bn->batCacheid]->bid = bn->batCacheid;
	pa->alias= pa->bid;
	pa->name= GDKstrdup(BBPname(bn->batCacheid));
	pa->nxt= pa->prv= pa->bid;
	@:defaultRange(pa,bn)@
#ifdef _DEBUG_BPM_
	mnstr_printf(GDKout,"new partitioned table: %d\n",*ret);
	BPMprintRing(GDKout,pa);
#endif
	BBPkeepref(*ret=bn->batCacheid);
	return MAL_SUCCEED;
}

str
BPMnewIterator(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	bat *ret, *bid;
	Partition p;
	str msg= MAL_SUCCEED;

	(void) cntxt;
	(void) mb;

	ret= (bat *)getArgReference(stk, pci, 0);
	bid= (bat *)getArgReference(stk, pci, 1);
	
	BPMopen();
	
	if( (p= getAlias(*bid)) == 0){
		mdbDump(cntxt,mb,stk,pci);
		throw(MAL,"bpm.newIterator", RUNTIME_OBJECT_MISSING);
	}

	if( emptyRing(p)){
		*ret= 0;
		return MAL_SUCCEED;
	}
	if( (msg=materializePartition(bpmcat[p->nxt])) )
		return msg; 
	if( p->alias== p->nxt)
		*ret= 0;
	else *ret = p->nxt;
#ifdef _DEBUG_BPM_
	mnstr_printf(GDKout,"new iterator %d: %d\n",*bid,*ret);
	BPMprintRing(GDKout, p);
#endif
	BBPincref(p->nxt,TRUE);
	return MAL_SUCCEED;
}
@-
The pair and triple iterators should more consciously
walk thru the partition lists. At each step making
a minimal move to ensure alignment of the iterator
values.
@c
str
BPMnewIterator2(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	(void) cntxt;
	(void) mb;
	(void) stk;
	(void) pci;
	return MAL_SUCCEED;
}
str
BPMnewIterator3(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	(void) cntxt;
	(void) mb;
	(void) stk;
	(void) pci;
	return MAL_SUCCEED;
}
str
BPMhasMoreElements2(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	(void) cntxt;
	(void) mb;
	(void) stk;
	(void) pci;
	return MAL_SUCCEED;
}
str
BPMhasMoreElements3(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	(void) cntxt;
	(void) mb;
	(void) stk;
	(void) pci;
	return MAL_SUCCEED;
}

str
BPMnewIteratorRng(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	bat *ret, *bid;
	Partition p;
	BAT *b;
	int i;
	int (*cmp) (ptr, ptr);
	ptr nilptr, low, hgh;
	str msg= MAL_SUCCEED;

	(void) cntxt;
	(void) mb;

	ret= (bat *)getArgReference(stk, pci, 0);
	bid= (bat *)getArgReference(stk, pci, 1);
	low= (ptr) getArgReference(stk, pci, 2);
	hgh= (ptr) getArgReference(stk, pci, 3);

	BPMopen();
	
	if( (p= getAlias(*bid)) == 0){
		mdbDump(cntxt,mb,stk,pci);
		throw(MAL,"bpm.newIterator", RUNTIME_OBJECT_MISSING);
	}
	@:getBATdescriptor(&p->bid,b,"bpm.newIterator")@

	/* get the comparison function */
	cmp= BATatoms[b->ttype].atomCmp;
	nilptr = ATOMnilptr(b->ttype);

	BBPunfix(b->batCacheid);	/* don't need it anymore */

	for( i= bpmcat[p->alias]->nxt; i!= p->alias ; i= bpmcat[i]->nxt){
		if( (msg=materializePartition(bpmcat[i])) )
			return msg; 
		if( *bid > 0){
			if( greater(i,tlow,hgh) || less(i,thgh,low) ){
					/* this fragment need not needed */
					continue;
				}
		} else
			if( greater(i,hlow,hgh) || less(i,hhgh,low) ){
					/* this fragment need not needed */
					continue;
				}
		@:getBATdescriptor(&bpmcat[i]->bid,b,"bpm.range")@
#ifdef _DEBUG_BPM_
				mnstr_printf(GDKout, "got matching fragment %d\n",i);
#endif
		BBPkeepref(*ret= b->batCacheid);
		return MAL_SUCCEED;
	}
	*ret= 0;
	return MAL_SUCCEED;
}


str
BPMnewIteratorRng4(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	(void) cntxt;
	(void) mb;
	(void) stk;
	(void) pci;
	throw(MAL, "bpm.newIterator", PROGRAM_NYI);
}

@-
For the iteration we assume that the bid is already
a correct element in the paritition list.

@c
str
BPMhasMoreElements(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	bat idx, *ret, bid;
	Partition p;
	(void) cntxt;
	(void) mb;

	ret= (bat *)getArgReference(stk, pci, 0);
	idx= *ret;
	bid= *(bat *)getArgReference(stk, pci, 1);

	BPMopen();
	if( (p= getAlias(bid)) == 0){
		mdbDump(cntxt,mb,stk,pci);
		throw(MAL,"bpm.hasMoreElements", RUNTIME_OBJECT_MISSING);
	}
	if( bpmcat[idx] == 0)
		throw(MAL,"bpm.hasMoreElements", INTERNAL_BAT_ACCESS);
	if( bpmcat[idx]->nxt == p->alias)
		*ret= 0;	/* end of sequence */
	else {
		materializePartition(bpmcat[bpmcat[idx]->nxt]);
		BBPincref(*ret= bpmcat[idx]->nxt,TRUE);
	}
#ifdef _DEBUG_BPM_
	mnstr_printf(GDKout,"hasmore : %d %d %d\n",idx, bid, *ret);
	BPMprintPartition(GDKout, p);
#endif
	return MAL_SUCCEED;
}

str
BPMhasMoreElementsRng(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	bat *ret, *bid;
	BAT *b;
	int i;
	int (*cmp) (ptr, ptr);
	ptr nilptr, low, hgh;
	Partition p;
	str msg= MAL_SUCCEED;

	(void) cntxt;
	(void) mb;

	ret= (bat *)getArgReference(stk, pci, 0);
	bid= (bat *)getArgReference(stk, pci, 1);
	low= (ptr) getArgReference(stk, pci, 2);
	hgh= (ptr) getArgReference(stk, pci, 3);

	BPMopen();

	/* get last partition returned */
	if( (p=bpmcat[*bid]) == 0 )
		throw(MAL,"bpm.hasMoreElements", RUNTIME_OBJECT_MISSING);

	@:getBATdescriptor(&p->bid,b,"bpm.hasMoreElementsRng")@

	/* get the comparison function */
	cmp= BATatoms[b->ttype].atomCmp;
	nilptr = ATOMnilptr(b->ttype);

	BBPunfix(b->batCacheid);	/* don't need it anymore */

	for( i= bpmcat[*ret]->nxt; i!= p->alias ; i= bpmcat[i]->nxt) {
		if( (msg=materializePartition(bpmcat[i])) )
			return msg; 
		if( *bid > 0){
			if( greater(i,tlow,hgh) || less(i,thgh,low) ){
					/* this fragment need not needed */
					continue;
				}
		} else
			if( greater(i,hlow,hgh) || less(i,hhgh,low) ){
					/* this fragment need not needed */
					continue;
				}
		if( (msg=materializePartition(bpmcat[i])) )
			return msg; 
		@:getBATdescriptor(&bpmcat[i]->bid,b,"bpm.range")@
#ifdef _DEBUG_BPM_
				mnstr_printf(GDKout, "got matching fragment %d\n",i);
#endif
		BBPkeepref(*ret= b->batCacheid);
		return MAL_SUCCEED;
	}
	*ret= 0;
	return MAL_SUCCEED;
}


str
BPMhasMoreElementsRng4(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	(void) cntxt;
	(void) mb;
	(void) stk;
	(void) pci;
	throw(MAL, "bpm.newIterator",PROGRAM_NYI);
}

str
BPMgetDimension(ptr *first, ptr *last, ptr *vlow, ptr *vhgh, int *bid)
{
	(void) first;
	(void) last;
	(void) vlow;
	(void) vhgh;
	(void) bid;
	throw(MAL, "bpm.getDimension", PROGRAM_NYI);
}

str
BPMgetNumberOfPartitions(int *ret, int *bid){
	int base,i,cnt=0;
	str msg= MAL_SUCCEED;
	base = *bid;
	for( i= bpmcat[base]->nxt;
		 base != i && i ;
		 i= bpmcat[i]->nxt){
		if( (msg=materializePartition(bpmcat[i])) )
			return msg; 
		cnt++;
	}
	*ret= cnt;
	return MAL_SUCCEED;
}
@-
Selections over partitioned BATs is encapsulated here.
Note that we use the catalog to determine a match.
This way the operation can be used to optimize programs
more easily.
@c
str 
BPMselect(int *ret, int *bid, ptr low, ptr hgh){
	/* handle the test against the boundary */
	return ALGselect(ret,bid,low,hgh);
}
str 
BPMselectInclusive(int *ret, int *bid, ptr low, ptr hgh, bit *li, bit *ri){
	/* handle the test against the boundary */
	return ALGselectInclusive(ret,bid,low,hgh,li,ri);
}

str
BPMdump(int *ret)
{
	int i;
	for( i=1; i<bpmcatsize; i++)
	if( bpmcat[i])
		BPMprintPartition(GDKout, bpmcat[i]);
	(void) ret;
	return MAL_SUCCEED;
}
str
BPMdumpAlias(int *ret, bat *bid)
{
	Partition p;
	if( (p=getAlias(*bid)) == 0)
		throw(MAL,"bpm.dump", RUNTIME_OBJECT_MISSING);
	BPMprintRing(GDKout,p);
	(void) ret;
	return MAL_SUCCEED;
}

@= getBPMbat
if (idx == 0) {
	b = BATnew(TYPE_int, TYPE_@2, bpmcatsize);
	if (b == 0)
		throw(MAL, "bpm.map@1",MAL_MALLOC_FAIL);
	idx= b->batCacheid;
	msg= BKCsetName(&r,(int *)&idx, &nm);
	if( msg != MAL_SUCCEED) return msg;
		
}else {
	BKCdelete_all(&r,&idx);
	b = BATdescriptor(idx);
	if (b == 0)
		throw(MAL, "bpm.map@1", MAL_MALLOC_FAIL);
}
@c
str
BPMmapname(int *ret)
{
	BAT *b;
	bat idx;
	int i,r;
	str msg = MAL_SUCCEED, nm="bpm_name";

	idx= BBPindex(nm);
	@:getBPMbat(name,str)@

	for(i=1; i< bpmcatsize; i++)
		if( bpmcat[i] && bpmcat[i]->name){
			if( (msg=materializePartition(bpmcat[i])) )
				return msg; 
	 		BUNins(b, &i, bpmcat[i]->name, FALSE);
		}

	msg= BKCsetPersistent(&r,(int *)&idx);
	if( msg != MAL_SUCCEED) return msg;
	BBPkeepref(*ret = b->batCacheid);
	return MAL_SUCCEED;
}
@= bpmView
str
BPMmap@1(int *ret)
{
	BAT *b;
	bat idx;
	int i,r;
	str msg = MAL_SUCCEED, nm="bpm_@1";

	idx= BBPindex(nm);
	@:getBPMbat(@1,@2)@

	for(i=1; i< bpmcatsize; i++)
		if( bpmcat[i]){
			if( (msg=materializePartition(bpmcat[i])) )
				return msg; 
	 		BUNins(b, &i, &bpmcat[i]->@1, FALSE);
		}

	msg= BKCsetPersistent(&r,(int *)&idx);
	if( msg != MAL_SUCCEED) return msg;
	BBPkeepref(*ret = b->batCacheid);
	return MAL_SUCCEED;
}
@c
@:bpmView(bid,int)@
@:bpmView(alias,int)@
@:bpmView(nxt,int)@
@:bpmView(prv,int)@
@:bpmView(cnt,int)@

static int nilval(ValPtr v)
{
	int tpe; 
	int (*cmp) (ptr, ptr);
	ptr nilptr;

	tpe= v->vtype;
	cmp= BATatoms[tpe].atomCmp;
	nilptr = ATOMnilptr(tpe);
	if ((*cmp) ((ptr)v, nilptr)==0) return 1;
	else return 0;
}

@= lowlng
str
BPMmap@1lng(int *ret)
{
	BAT *b;
	int i,t,r;
	lng val;
	ValPtr v;
	bat idx;
	str msg = MAL_SUCCEED, nm="bpm_@1lng";

	idx= BBPindex(nm);
	@:getBPMbat(@1lng,lng)@

	for(i=1; i< bpmcatsize; i++)
		if( bpmcat[i]){
			if( (msg=materializePartition(bpmcat[i])) )
				return msg; 
			v= &bpmcat[i]->@1;
			if (!nilval(v)){
				t= v->vtype;
				switch  (ATOMstorage(t)) {
					case TYPE_int: 	val= *(int *)VALget(v);
							BUNins(b, &i, &val, FALSE);
							break;
			    		case TYPE_sht: 	val= *(sht *)VALget(v);
							BUNins(b, &i, &val, FALSE);
							break;
					case TYPE_lng: 	val= *(lng *)VALget(v);
							BUNins(b, &i, &val, FALSE);
					}
			}
		}

	msg= BKCsetPersistent(&r,(int *)&idx);
	if( msg != MAL_SUCCEED) return msg;

	*ret = b->batCacheid;
	BBPkeepref(*ret);
	return MAL_SUCCEED;
}

str
BPMmap@1dbl(int *ret)
{
	BAT *b;
	int i,t,r;
	dbl val;
	ValPtr v;
	bat idx;
	str msg = MAL_SUCCEED, nm="bpm_@1dbl";

	idx= BBPindex(nm);
	@:getBPMbat(@1dbl,dbl)@	

	for(i=1; i< bpmcatsize; i++)
		if( bpmcat[i]){
			if( (msg=materializePartition(bpmcat[i])) )
				return msg; 
			v= &bpmcat[i]->@1;
			if (!nilval(v)){
			t= v->vtype;
			switch  (ATOMstorage(t)) {
				case TYPE_dbl: 	val= *(dbl *)VALget(v);
						BUNins(b, &i, &val, FALSE);
						break;
			    	case TYPE_flt: 	val= *(flt *)VALget(v);
						BUNins(b, &i, &val, FALSE);
						break;
			}}
		
		}

	msg= BKCsetPersistent(&r,(int *)&idx);
	if( msg != MAL_SUCCEED) return msg;

	*ret = b->batCacheid;
	BBPkeepref(*ret);
	return MAL_SUCCEED;
}
@c
	@:lowlng(tlow)@
	@:lowlng(thgh)@

str
BPMsaveCatalog(int *r)
{	
	int i, n;
	bat bt,idx;
	bat *tr;
	str nm;
	str msg=MAL_SUCCEED;


	/* using alloca, since the old TMsubcommit interface also uses
	   alloca */
	tr = alloca((bpmcatsize+10) * sizeof(bat));
	n = 0;
	tr[n++] = 0;

	for(i=1; i< bpmcatsize; i++)
		if( bpmcat[i]){
			if( (msg=materializePartition(bpmcat[i])) )
				return msg; 
			bt=bpmcat[i]->bid;
			nm = GDKmalloc(12);
			if ( nm == NULL)
				throw(MAL, "bpm.saveCatalog", MAL_MALLOC_FAIL);
			snprintf(nm, 12, "bpm_%d", i);
#ifdef _DEBUG_BPM_
			printf("#Name %s\n",nm);
#endif
		
			/* Check if the name exists already */
			idx= BBPindex(nm);
			if (idx == 0) {
				msg= BKCsetName(r,(int *) &bt,(str *) &nm);
				if( msg != MAL_SUCCEED) return msg;
			} else {
				if (bt!=idx)
					throw(MAL, "bpm.saveCatalog", DUPLICATE_DEFINITION);
			}
	
			msg= BKCsetPersistent(r, (int *)&bt);
			if( msg != MAL_SUCCEED) return msg;
			tr[n++] = ABS(bt);
		}
	
	BPMmapname(&bt);
	tr[n++] = ABS(bt);
	BPMmapalias(&bt);
	tr[n++] = ABS(bt);
	BPMmapbid(&bt);
	tr[n++] = ABS(bt);
	BPMmapnxt(&bt);
	tr[n++] = ABS(bt);
	BPMmapprv(&bt);
	tr[n++] = ABS(bt);
	BPMmapcnt(&bt);
	tr[n++] = ABS(bt);
	BPMmaptlowlng(&bt);
	tr[n++] = ABS(bt);
	BPMmaptlowdbl(&bt);
	tr[n++] = ABS(bt);
	BPMmapthghlng(&bt);
	tr[n++] = ABS(bt);
	BPMmapthghdbl(&bt);
	tr[n++] = ABS(bt);

	TMsubcommit_list(tr, n);

	return MAL_SUCCEED;
}



static void findQuantHisto(ValPtr vp, BAT * b, lng sp, lng msz, lng maxno)
{
	BUN p, pprev, stop; 
	BUN c;
	int tpe, s=0, cn, it =0;
	lng pertpl, quan;
	BATiter bsi;
	BAT *bh, *bs;
	ValPtr v = vp;

	c = BATcount(b);
	if ((c==0) || (msz>=sp)) return ;
	pertpl = (lng) ceil((sp - sizeof(BATstore))/ (double)c);
	quan = (lng) floor((msz- sizeof(BATstore))/  (double)pertpl);

	tpe = b->ttype;
	bh = BAThistogram(b);
	bs = BATsort(bh);

	/* iterate on the sorted histogram */
	pprev = BUNfirst(bs);
	bsi = bat_iterator(bs);
	BATloop(bs, p, stop) {
		cn = * (int *) BUNtail(bsi,p);
		if (s + cn <quan) 
			s += cn;
		else {
			VALset(v,tpe, BUNhead(bsi,pprev));
			v++; it++;
			s = cn;
			if (it >= maxno) break;
		}
		pprev = p;
	}

	BBPunfix(bs->batCacheid);
	BBPunfix(bh->batCacheid);
}


/* split all segments of alias *bid to fit into memory bound mb in KB.
 Creates all sub-segments of a given segment at once */
str
BPMsplitquant(bat *ret, bat *bid, int *mb)
{
	BAT *b;
	Partition ps, p, pprev;
	ValPtr sep, v;
	bat *bb;
	int k,nxt, i, n=0, tpe;
	BUN *cnts;
	ptr nilptr;
	int (*cmp) (ptr, ptr);
	lng sf, msz, space;
	(void) ret;

	BPMopen();

	if( (ps= bpmcat[ i= *bid]) == 0)
		throw(MAL,"bpm.split", RUNTIME_OBJECT_MISSING);
	@:getBATdescriptor(bid,b,"bpm.splitPartition");
	/* get the comparison function */
	tpe = rngType(b->ttype);
	nilptr = ATOMnilptr(b->ttype);
	BBPunfix(b->batCacheid);

	msz = *mb * KB;

	cmp= BATatoms[b->ttype].atomCmp;

	/* check the size of each segment and split if necessary */
	for(i= ps->nxt ; i!=ps->bid && bpmcat[i] ; i= nxt) {
	/*	materializePartition(bpmcat[i]); */
		@:getBATdescriptor(&bpmcat[i]->bid,b,"bpm.splitquantile");
		
		space = BATcount(b)* (Hsize(b) + Tsize(b) + sizeof(BUN)) + sizeof(BATstore);
		if ((b->htype == TYPE_void) || (b->ttype == TYPE_void))
			space += BATcount(b)* sizeof(oid);
	#ifdef _DEBUG_BPM_
		mnstr_printf(GDKout," partition '%d' size  " LLFMT "\n", i, space);
	#endif
		if (space <= msz) {
	 		BBPunfix(b->batCacheid);
			nxt= bpmcat[i]->nxt;
			continue;  
		}

		sf = (lng) ceil(space/(double)msz) + 3;
		sep= (ValPtr) GDKzalloc( (size_t) (sizeof(ValRecord) * sf));
		for (k=0; k<sf; k++)
			VALinit(sep+k,tpe,nilptr);
	/* form array of separators */
		findQuantHisto(sep+1, b, space, msz, sf-2);
		VALset(sep, tpe, &bpmcat[i]->tlow );
		v =sep+1; n=2;
		while ((*cmp) (v, nilptr)!=0) {n++; v++;}
		VALset(v, tpe, &bpmcat[i]->thgh );

	/* spread values */		
		bb= (bat *) GDKzalloc( sizeof(bat) * (n-1));
		cnts= (BUN *) GDKzalloc( sizeof(BUN) * (n-1));
		spread(bb,cnts,b,sep,n,-1);
		
#ifdef _DEBUG_BPM_
		for(k=0;k<n-1; k++) 
			mnstr_printf(GDKout," spread to partition %d size  " BUNFMT "\n", bb[k], cnts[k]);
#endif
		pprev = getByNumber(bpmcat[i]->prv);
		for(k=0; k<n-1; k++, pprev=p){
			p= newPartition(bb[k]);
			p->type= pprev->type;
			bpmcat[bb[k]]->bid = bb[k];
			BBPincref(bb[k],TRUE);
			p->alias= bpmcat[i]->alias;
			@:inheritRange(p,b,bpmcat[i])@
			p->cnt= cnts[k];
			if( *bid> 0){
				VALset(&p->tlow, tpe, &sep[k]);	
				VALset(&p->thgh, tpe, &sep[k+1] );
			} else {
				VALset(&p->hlow, tpe, &sep[k] );
				VALset(&p->hhgh, tpe, &sep[k+1] );	
			}
			insertPartition(pprev,p);
#ifdef _DEBUG_BPM_
			BPMprintPartition(GDKout,p);
#endif
		}
		dropPartition(bpmcat[i]);
		BBPunfix(b->batCacheid);
		nxt = bpmcat[bb[n-2]]->nxt;
		GDKfree(sep);
		GDKfree(bb);
		GDKfree(cnts);
	}
	return MAL_SUCCEED;
}

str
BPMprelude(int *ret)
{
    mal_set_lock(mal_contextLock, "bpm.prelude");
	*ret =0;
    mal_unset_lock(mal_contextLock, "bpm.prelude");
	return MAL_SUCCEED;
}
@-
In the epilogue phase we should discard any temporary MAT.
@c
str
BPMepilogue(int *ret)
{
	/* TODO: Make sure these are used. This is needed by icc only. And 
	   should be removed once the implementation matures.
	 */
	*ret =0;
	return MAL_SUCCEED;
}
@}
