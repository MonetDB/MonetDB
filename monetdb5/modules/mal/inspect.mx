@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.monetdb.org/Legal/MonetDBLicense

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2011 MonetDB B.V.
All Rights Reserved.
@

@f inspect
@a Martin Kersten
@v 1
@+ Inspection 
This module introduces a series of commands that provide access
to information stored within the interpreter data structures.
It's primary use is debugging.
In all cases, the pseudo BAT operation is returned that
should be garbage collected after being used.

The main performance drain would be to use a pseudo BAT directly to
successively access it components. This can be avoided by first assigning
the pseudo BAT to a variable.

@mal
module inspect;

pattern getDefinition(mod:str,fcn:str) :bat[:str,:str] 
address INSPECTgetDefinition
comment "Returns a string representation of a specific function.";
pattern getSignature(mod:str,fcn:str) :bat[:str,:str] 
address INSPECTgetSignature
comment "Returns the function signature(s).";
pattern getAddress(mod:str,fcn:str) :bat[:str,:str] 
address INSPECTgetAddress
comment "Returns the function signature(s).";
pattern getComment(mod:str,fcn:str) :bat[:str,:str]
address INSPECTgetComment
comment "Returns the function help information.";
pattern getSource(mod:str,fcn:str):str
address INSPECTgetSource
comment "Return the original input for a function.";

pattern getKind():bat[:oid,:str]
address INSPECTgetkind
comment "Obtain the instruction kind.";
pattern getModule():bat[:oid,:str]
address INSPECTgetAllModules
comment "Obtain the function name.";
pattern getFunction():bat[:oid,:str]
address INSPECTgetAllFunctions
comment "Obtain the function name.";
pattern getSignatures():bat[:oid,:str]
address INSPECTgetAllSignatures
comment "Obtain the function signatures.";
pattern getAddresses():bat[:oid,:str]
address INSPECTgetAllAddresses
comment "Obtain the function address.";


pattern getSize():lng
address INSPECTgetSize
comment "Return the storage size for the current function (in bytes).";
pattern getSize(mod:str):bat[:str,:lng]
address INSPECTgetModuleSize
comment "Return the storage size for a module (in bytes).";
pattern getSize(mod:str,fcn:str):lng
address INSPECTgetFunctionSize
comment "Return the storage size for a function (in bytes).";

pattern getType(v:bat[:any_1,:any_2]) (ht:str, tt:str)
address INSPECTtypeName
comment "Return the concrete type of a variable (expression).";
pattern getType(v:any_1) :str 
address INSPECTtypeName
comment "Return the concrete type of a variable (expression).";

command getTypeName(v:int):str 
address INSPECTtypename
comment "Get the type name associated with a type id.";
pattern getTypeIndex(v:bat[:any_1,:any_2]) (ht:int, tt:int)
address INSPECTtypeIndex
comment "Return the type index of a BAT head and tail.";
pattern getTypeIndex(v:any_1):int 
address INSPECTtypeIndex
comment "Return the type index of a variable. For BATs, return
the type index for its tail.";

pattern equalType(l:any, r:any):bit
address INSPECTequalType
comment "Return true if both operands are of the same type";
command getAtomNames():bat[:int,:str] 
address INSPECTatom_names
comment "Collect a BAT with the atom names.";
command getAtomSuper():bat[:int,:str] 
address INSPECTatom_sup_names
comment "Collect a BAT with the atom names.";
command getAtomSizes():bat[:int,:int] 
address INSPECTatom_sizes
comment "Collect a BAT with the atom sizes.";

command getEnvironment():bat[:str,:str]
address INSPECTgetEnvironment
comment "Collect the environment variables.";
@-
@{
@+ Implementation
@include prelude.mx
@h
#ifdef _INSPECT_H
#endif /* _INSPECT_H */
@c
#include "monetdb_config.h"
#include "gdk.h"
#include <stdarg.h>
#include <time.h>
#include "mal_resolve.h"
#include "mal_client.h"
#include "mal_exception.h"
#include "mal_debugger.h"
#include "mal_interpreter.h"
#include "mal_namespace.h"

#ifdef WIN32
#if !defined(LIBMAL) && !defined(LIBATOMS) && !defined(LIBKERNEL) && !defined(LIBMAL) && !defined(LIBOPTIMIZER) && !defined(LIBSCHEDULER) && !defined(LIBMONETDB5)
#define inspect_export extern __declspec(dllimport)
#else
#define inspect_export extern __declspec(dllexport)
#endif
#else
#define inspect_export extern
#endif

inspect_export str INSPECTgetFunction(int *ret);
inspect_export str INSPECTgetModule(int *ret);
inspect_export str INSPECTgetkind(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
inspect_export str INSPECTgetAllSignatures(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
inspect_export str INSPECTgetAllModules(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
inspect_export str INSPECTgetAllFunctions(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
inspect_export str INSPECTgetAllAddresses(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
inspect_export str INSPECTgetDefinition(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
inspect_export str INSPECTgetSignature(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
inspect_export str INSPECTgetAddress(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
inspect_export str INSPECTgetComment(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
inspect_export str INSPECTgetSource(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
inspect_export str INSPECTgetModuleSize(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
inspect_export str INSPECTgetFunctionSize(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
inspect_export str INSPECTgetSize(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
inspect_export str INSPECTgetEnvironment(int *ret);
inspect_export str INSPECTsymbolType(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
inspect_export str INSPECTatom_names(int *ret);
inspect_export str INSPECTatom_sup_names(int *ret);
inspect_export str INSPECTatom_sizes(int *ret);
inspect_export str INSPECTshowFunction(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
inspect_export str INSPECTshowFunction3(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
inspect_export str INSPECTtypename(str *ret, int *tpe);
inspect_export str INSPECTtype(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
inspect_export str INSPECTtypeName(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
inspect_export str INSPECTtypeIndex(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
inspect_export str INSPECTequalType(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);

@+ Symbol table 
Mal symbol table and environment analysis.

Collect symbol table information in a series of BATs for analysis
and display. Note, the elements are aligned using a counter,
which makes it susceptable for intermediate updates
@c

str
INSPECTgetAllFunctions(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	Module s;
	Symbol t;
	int i;
	oid k = 0;
	BAT *b = BATnew(TYPE_oid, TYPE_str, 256);
	int *ret = (int *) getArgReference(stk,pci,0);

	(void) mb;
	if (b == 0)
		throw(MAL, "inspect.getgetFunctionId", MAL_MALLOC_FAIL );
	BATseqbase(b, k);
	s = cntxt->nspace;
	while (s) {
		for (i = 0; s && i < MAXSCOPE; i++)
			if (s->subscope[i]) {
				for (t = s->subscope[i]; t; t = t->peer) {
					InstrPtr sig = getSignature(t);

					BUNins(b, &k, getFunctionId(sig), FALSE);
					k++;
				}
			}
		s = s->outer;
	}
	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(view,symbol,function)@

	return MAL_SUCCEED;
}

str
INSPECTgetAllModules(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	Module s;
	Symbol t;
	int i;
	oid k = 0;
	BAT *b = BATnew(TYPE_oid, TYPE_str, 256);
	int *ret = (int *) getArgReference(stk,pci,0);

	(void) mb;
	if (b == 0)
		throw(MAL, "inspect.getmodule", MAL_MALLOC_FAIL);
	BATseqbase(b, k);
	s = cntxt->nspace;
	while (s) {
		for (i = 0; s && i < MAXSCOPE; i++)
			if (s->subscope[i]) {
				for (t = s->subscope[i]; t; t = t->peer) {
					InstrPtr sig = getSignature(t);

					BUNins(b, &k, getModuleId(sig), FALSE);
					k++;
				}
			}
		s = s->outer;
	}
	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(view,symbol,module)@

	return MAL_SUCCEED;
}

str
INSPECTgetkind(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	Module s;
	Symbol t;
	int i;
	oid k = 0;
	BAT *b = BATnew(TYPE_oid, TYPE_str, 256);
	int *ret = (int *) getArgReference(stk,pci,0);

	(void)mb;
	if (b == 0)
		throw(MAL, "inspect.get@1", MAL_MALLOC_FAIL);
	BATseqbase(b, k);
	s = cntxt->nspace;
	while (s) {
		for (i = 0; s && i < MAXSCOPE; i++)
			if (s->subscope[i]) {
				for (t = s->subscope[i]; t; t = t->peer) {
					InstrPtr sig = getSignature(t);
					str kind = operatorName(sig->token);

					BUNins(b, &k, kind, FALSE);
					k++;
				}
			}
		s = s->outer;
	}
	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(view,symbol,kind)@

	return MAL_SUCCEED;
}


str
INSPECTgetAllSignatures(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	Module s;
	Symbol t;
	int i;
	oid k = 0;
	BAT *b = BATnew(TYPE_oid, TYPE_str, 256);
	char sig[BLOCK],*a;
	int *ret = (int *) getArgReference(stk,pci,0);

	(void)mb;

	if (b == 0)
		throw(MAL, "inspect.get@1", MAL_MALLOC_FAIL);
	BATseqbase(b, k);
	s = cntxt->nspace;
	while (s) {
		for (i = 0; s && i < MAXSCOPE; i++)
			if (s->subscope[i]) {
				for (t = s->subscope[i]; t; t = t->peer) {
					fcnDefinition(t->def, getSignature(t), sig, 0,sig,BLOCK);
					a= strstr(sig,"address");
					if(a) *a = 0;
					BUNins(b, &k, strchr(sig, '('), FALSE);
					k++;
				}
			}
		s = s->outer;
	}
	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(view, symbol,address)@

	return MAL_SUCCEED;
}
str
INSPECTgetAllAddresses(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	Module s;
	Symbol t;
	int i;
	oid k = 0;
	BAT *b = BATnew(TYPE_oid, TYPE_str, 256);
	char sig[BLOCK],*a;
	int *ret = (int *) getArgReference(stk,pci,0);

	(void)mb;

	if (b == 0)
		throw(MAL, "inspect.get@1", MAL_MALLOC_FAIL);
	BATseqbase(b, k);
	s = cntxt->nspace;
	while (s) {
		for (i = 0; s && i < MAXSCOPE; i++)
			if (s->subscope[i]) {
				for (t = s->subscope[i]; t; t = t->peer) {
					fcnDefinition(t->def, getSignature(t), sig, 0,sig,BLOCK);
					a= strstr(sig,"address");
					if( a)
						for( a=a+7; isspace((int) *a); a++)
							;
					BUNins(b, &k, (a? a: "nil"), FALSE);
					k++;
				}
			}
		s = s->outer;
	}
	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(view, symbol,address)@

	return MAL_SUCCEED;
}

str
INSPECTgetDefinition(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int *ret = (int*) getArgReference(stk,pci,0);
	str *mod = (str*) getArgReference(stk,pci,1);
	str *fcn = (str*) getArgReference(stk,pci,2);
	Symbol s;
	char buf[BUFSIZ];
	BAT *b;
	(void)mb;

	s = findSymbol(cntxt->nspace, putName(*mod,strlen(*mod)), putName(*fcn, strlen(*fcn)));
	if (s == 0)
		throw(MAL, "inspect.getDefinition", RUNTIME_SIGNATURE_MISSING);

	b = BATnew(TYPE_str, TYPE_str, 256);
	if (b == 0)
		throw(MAL, "inspect.getDefinition", MAL_MALLOC_FAIL);

	snprintf(buf,BUFSIZ,"%s.%s",*mod,*fcn);
	while (s) {
		int i;
		str ps;

		for (i = 0; i < s->def->stop; i++) {
			ps = instruction2str(s->def,0, getInstrPtr(s->def, i), 0);
			BUNins(b, buf, ps + 1, FALSE);
			GDKfree(ps);
		}
		s = s->peer;
	}
	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(view,fcn,stmt)@

	return MAL_SUCCEED;
}

str
INSPECTgetSignature(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int *ret = (int*) getArgReference(stk,pci,0);
	str *mod = (str*) getArgReference(stk,pci,1);
	str *fcn = (str*) getArgReference(stk,pci,2);
	Symbol s;
	char buf[BUFSIZ];
	str ps, tail;
	BAT *b;
	(void) mb;

	s = findSymbol(cntxt->nspace, getName(*mod,strlen(*mod)), putName(*fcn, strlen(*fcn)));
	if (s == 0)
		throw(MAL, "inspect.getSignature", RUNTIME_SIGNATURE_MISSING);
	b = BATnew(TYPE_str, TYPE_str, 12);
	if (b == 0)
		throw(MAL, "inspect.getSignature", MAL_MALLOC_FAIL);

	snprintf(buf,BUFSIZ,"%s.%s",*mod,*fcn);
	while (s != NULL) {
		if (idcmp(s->name, *fcn) == 0) {
			char *c, *w;

			ps = instruction2str(s->def, 0, getSignature(s), 0);
			c = strchr(ps, '(');
			if (c == 0)
				continue;
			tail= strstr(c,"address");
			if( tail)
				*tail = 0;
			if (tail && (w=strchr(tail, ';')) )
				*w = 0;
			BUNins(b, buf, c, FALSE);
			GDKfree(ps);
		}
		s = s->peer;
	}

	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(view,input,result)@
	return MAL_SUCCEED;
}

str
INSPECTgetAddress(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int *ret = (int*) getArgReference(stk,pci,0);
	str *mod = (str*) getArgReference(stk,pci,1);
	str *fcn = (str*) getArgReference(stk,pci,2);
	Symbol s;
	char buf[BUFSIZ];
	str ps, tail;
	BAT *b;
	(void) mb;

	s = findSymbol(cntxt->nspace, getName(*mod,strlen(*mod)), putName(*fcn, strlen(*fcn)));
	if (s == 0)
		throw(MAL, "inspect.getAddress", RUNTIME_SIGNATURE_MISSING);
	b = BATnew(TYPE_str, TYPE_str, 12);
	if (b == 0)
		throw(MAL, "inspect.getAddress", MAL_MALLOC_FAIL);

	snprintf(buf,BUFSIZ,"%s.%s",*mod,*fcn);
	while (s != NULL) {
		if (idcmp(s->name, *fcn) == 0) {
			char *c,*w;

			ps = instruction2str(s->def, 0, getSignature(s), 0);
			c = strchr(ps, '(');
			if (c == 0)
				continue;
			tail= strstr(c,"address");
			if( tail){
				*tail = 0;
				for( tail=tail+7; isspace((int) *tail); tail++)  ;
			}
			if (tail && (w=strchr(tail, ';')) )
				*w = 0;
			BUNins(b, buf, (tail? tail: "nil"), FALSE);
			GDKfree(ps);
		}
		s = s->peer;
	}

	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(view,input,result)@
	return MAL_SUCCEED;
}
str
INSPECTgetComment(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int *ret = (int*) getArgReference(stk,pci,0);
	str *mod = (str*) getArgReference(stk,pci,1);
	str *fcn = (str*) getArgReference(stk,pci,2);
	Symbol s;
	char buf[BUFSIZ];
	BAT *b;
	(void) mb;

	s = findSymbol(cntxt->nspace, getName(*mod,strlen(*mod)), putName(*fcn, strlen(*fcn)));
	if (s == 0)
		throw(MAL, "inspect.getComment", RUNTIME_SIGNATURE_MISSING);
	b = BATnew(TYPE_str, TYPE_str, 12);
	if (b == 0)
		throw(MAL, "inspect.getSignature", MAL_MALLOC_FAIL);

	snprintf(buf,BUFSIZ,"%s.%s",*mod,*fcn);
	while (s != NULL) {
		if (idcmp(s->name, *fcn) == 0) {
			BUNins(b, buf, s->def->help, FALSE);
		}
		s = s->peer;
	}

	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(view,input,result)@
	return MAL_SUCCEED;
}

str
INSPECTgetSource(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str *ret = (str*) getArgReference(stk,pci,0);
	str *mod = (str*) getArgReference(stk,pci,1);
	str *fcn = (str*) getArgReference(stk,pci,2);
	Symbol s;
	char *buf;
	size_t len,lim;
	(void) mb;

	s = findSymbol( cntxt->nspace, getName(*mod,strlen(*mod)), putName(*fcn, strlen(*fcn)));
	if (s == 0)
		throw(MAL, "inspect.getSource", RUNTIME_SIGNATURE_MISSING);

	buf= (char*) GDKmalloc(BUFSIZ);
	if ( buf == NULL)
		throw(MAL, "inspect.getSource", MAL_MALLOC_FAIL);
	snprintf(buf,BUFSIZ,"%s.%s",*mod,*fcn);
	buf[0]=0;
	len= 0;
	lim= BUFSIZ;

	while (s) {
		int i;
		str ps;

		for (i = 0; i < s->def->stop; i++) {
			ps = instruction2str(s->def, 0, getInstrPtr(s->def, i), LIST_MAL_STMT);
			if( strlen(ps) >= lim-len){
				/* expand the buffer */
				char *bn;
				bn= GDKmalloc(lim+BUFSIZ);
				if ( bn == NULL) {
					GDKfree(ps);
					throw(MAL, "inspect.getSource", MAL_MALLOC_FAIL);
				}
				strcpy(bn,buf);
				GDKfree(buf);
				buf=bn;
				lim+= BUFSIZ;
			}
			strcat(buf+len,ps);
			len+= strlen(ps);
			buf[len++]='\n';
			buf[len]=0;
			GDKfree(ps);
		}
		s = s->peer;
	}
	*ret= buf;
	return MAL_SUCCEED;
}

str
INSPECTsymbolType(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int *ret = (int*) getArgReference(stk,pci,0);
	str *mod = (str*) getArgReference(stk,pci,1);
	str *fcn = (str*) getArgReference(stk,pci,2);
	Symbol s;
	BAT *b;
	(void) mb;

	s = findSymbol( cntxt->nspace, getName(*mod,strlen(*mod)), putName(*fcn, strlen(*fcn)));
	if (s == 0)
		throw(MAL, "inspect.getSignature", RUNTIME_SIGNATURE_MISSING);
	b = BATnew(TYPE_str, TYPE_str, 256);
	if (b == 0)
		throw(MAL, "inspect.getType", MAL_MALLOC_FAIL);
	while (s != NULL) {
		if (idcmp(s->name, *fcn) == 0) {
			str t = getTypeName(getDestType(s->def, getSignature(s)));

			BUNins(b, s->name, t, FALSE);
			GDKfree(t);
		}
		s = s->peer;
	}
	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(view,fcn,type)@
	return MAL_SUCCEED;
}

str
INSPECTatom_names(int *ret)
{
	int i;
	BAT *b = BATnew(TYPE_int, TYPE_str, 256);

	if (b == 0)
		throw(MAL, "inspect.getAtomNames", MAL_MALLOC_FAIL);

	for (i = 0; i < GDKatomcnt; i++)
		BUNins(b, &i, ATOMname(i), FALSE);

	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(view,atom,name)@

	return MAL_SUCCEED;
}
str
INSPECTgetEnvironment(int *ret)
{
	BAT *b;

	b= GDKenv;
	if (b == 0)
		throw(MAL, "inspect.getEnvironment", MAL_MALLOC_FAIL);

	BBPincref(b->batCacheid,TRUE);
	*ret = b->batCacheid;
	return MAL_SUCCEED;
}

str
INSPECTatom_sup_names(int *ret)
{
	int i, k;
	BAT *b = BATnew(TYPE_int, TYPE_str, 256);

	if (b == 0)
		throw(MAL, "inspect.getAtomSuper", MAL_MALLOC_FAIL);

	for (i = 0; i < GDKatomcnt; i++) {
		for (k = BATatoms[i].storage; k > TYPE_str; k = BATatoms[k].storage)
			;
		BUNins(b, &i, ATOMname(k), FALSE);
	}

	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(view,atom,sup_name)@

	return MAL_SUCCEED;
}

str
INSPECTatom_sizes(int *ret)
{
	int i;
	int s;
	BAT *b = BATnew(TYPE_int, TYPE_int, 256);

	if (b == 0)
		throw(MAL, "inspect.getAtomSizes", MAL_MALLOC_FAIL);

	for (i = 0; i < GDKatomcnt; i++) {
		s = ATOMsize(i);
		BUNins(b, &i, &s, FALSE);
	}

	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(view,atom,size)@

	return MAL_SUCCEED;
}

/* calculate to trimmed storage space */
static lng
INSPECTcalcSize(MalBlkPtr mb){
	lng size,args=0,i;
	InstrPtr p;

	for(i=0;i<mb->stop; i++){
		p= getInstrPtr(mb,i);
		args += (p->argc-1)* sizeof(*p->argv);
	}
	size = (sizeof(InstrRecord) +sizeof(InstrPtr)) * mb->stop;
	size += (sizeof(VarRecord)+ sizeof(InstrPtr)) * mb->vtop;
	size += args;
	return size;
}

str
INSPECTgetSize(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p){
	lng *ret = (lng*) getArgReference(stk,p,0);


	*ret= INSPECTcalcSize(mb);
	(void) cntxt;
	(void) mb;
	return MAL_SUCCEED;
}
str
INSPECTgetModuleSize(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	Symbol s;
	Module m;
	int i;
	lng total=0;
	BAT *b = BATnew(TYPE_str, TYPE_lng, 256);
	int *ret= (int*) getArgReference(stk,pci,0);
	str *mod= (str*) getArgReference(stk,pci,1);

	(void) mb;
	if (b == 0)
		throw(MAL, "inspect.getSize", MAL_MALLOC_FAIL);

	m = findModule(cntxt->nspace, putName(*mod, strlen(*mod)));
	if (m == 0)
		throw(MAL, "inspect.getSize", RUNTIME_SIGNATURE_MISSING);

	for( i=0; i<MAXSCOPE; i++){
		s= m->subscope[i];
		while (s != NULL) {
			lng size;
			total+= (size = INSPECTcalcSize(s->def));
			BUNins(b, s->name, &size, FALSE);
			s = s->peer;
		}
	}
	BUNins(b, *mod, &total, FALSE);

	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(view,input,result)@
	return MAL_SUCCEED;
}

str
INSPECTgetFunctionSize(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	lng *ret = (lng*) getArgReference(stk,pci,0);
	str *mod = (str*) getArgReference(stk,pci,1);
	str *fcn = (str*) getArgReference(stk,pci,2);
	Symbol s;
	(void) mb;

	s = findSymbol(cntxt->nspace, getName(*mod,strlen(*mod)), putName(*fcn, strlen(*fcn)));
	if (s == 0)
		throw(MAL, "inspect.getSize", RUNTIME_SIGNATURE_MISSING);
	*ret= INSPECTcalcSize(s->def);
	return MAL_SUCCEED;
}
@+ Display routines
@c
str
INSPECTshowFunction(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	(void) p;
	printFunction(cntxt->fdout, mb, stk, LIST_INPUT);
	return MAL_SUCCEED;
}

str
INSPECTshowFunction3(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	str modnme = getArgName(mb, p, 1);
	str fcnnme = getArgName(mb, p, 2);
	Symbol s = NULL;

	s = findSymbol(cntxt->nspace,getName(modnme,strlen(modnme)), putName(fcnnme, strlen(fcnnme)));

	if (s == NULL){
		char buf[BUFSIZ];
		snprintf(buf,BUFSIZ,"%s.%s", modnme, fcnnme);
		throw(MAL, "inspect.showSource",RUNTIME_SIGNATURE_MISSING "%s",buf);
	} else
		printFunction(cntxt->fdout, s->def, stk, LIST_INPUT);
	return MAL_SUCCEED;
}

str
INSPECTtypename(str *ret, int *tpe)
{
	*ret = getTypeName(*tpe);
	return MAL_SUCCEED;
}
str
INSPECTtypeIndex(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int *ret;

	(void) cntxt;
	if( pci->retc== 2){
		ret = (int *) getArgReference(stk, pci, 0);
		*ret = getHeadType(getArgType(mb, pci, 2));
		ret = (int *) getArgReference(stk, pci, 1);
		*ret = getTailType(getArgType(mb, pci, 2));
	}else {
		ret = (int *) getArgReference(stk, pci, 0);
		*ret = getTailType(getArgType(mb, pci, 1));
	}
	return MAL_SUCCEED;
}
str
INSPECTequalType(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	bit *ret;
	(void) stk;
	(void) cntxt;
	ret = (bit *) getArgReference(stk, pci, 0);
	*ret = getArgType(mb,pci,1)== getArgType(mb,pci,2);
	return MAL_SUCCEED;
}

str
INSPECTtypeName(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str *hn, *tn =0;

	hn = (str *) getArgReference(stk, pci, 0);

	(void) cntxt;
	if( pci->retc== 2){
		tn = (str *) getArgReference(stk, pci, 1);
		*hn = getTypeName(getHeadType(getArgType(mb, pci, 2)));
		*tn = getTypeName(getTailType(getArgType(mb, pci, 2)));
	} else if (isaBatType(getArgType(mb,pci,1) ) ){
		int *bid= (int*) getArgReference(stk,pci,1);
		BAT *b;
		if ((b = BATdescriptor(*bid)) ) {
			*hn = getTypeName(newBatType((b->htype==TYPE_void?TYPE_oid:b->htype),b->ttype));
			BBPunfix(b->batCacheid);
		} else
			*hn = getTypeName(getArgType(mb, pci, 1));
	} else
		*hn = getTypeName(getArgType(mb, pci, 1));
	return MAL_SUCCEED;
}


@}
