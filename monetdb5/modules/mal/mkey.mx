@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.monetdb.org/Legal/MonetDBLicense

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2011 MonetDB B.V.
All Rights Reserved.
@

@f mkey
@a Peter Boncz, Stefan Manegold, Niels Nes
@-
@v 1.1
@+ Multi-Attribute Equi-Join
@{
@mal
module mkey;

command rotate(v:wrd, nbits:int) :wrd 
address MKEYrotate
comment "left-rotate an int by nbits";

pattern hash(v:any):wrd 
address MKEYhash 
comment "compute a hash int number from any value";

command hash(v:bit):wrd 
address MKEYhash_bit; 
command hash(v:chr):wrd 
address MKEYhash_chr; 
command hash(v:bte):wrd 
address MKEYhash_bte; 
command hash(v:sht):wrd 
address MKEYhash_sht; 
command hash(v:int):wrd 
address MKEYhash_int; 
command hash(v:flt):wrd 
address MKEYhash_flt; 
command hash(v:wrd):wrd 
address MKEYhash_wrd; 
command hash(v:dbl):wrd 
address MKEYhash_dbl; 
command hash(v:lng):wrd 
address MKEYhash_lng; 
command hash(v:str):wrd 
address MKEYhash_str; 

command hash( b:bat[:oid,:any_1] ) :bat[:oid,:wrd]
address MKEYbathash
comment "calculate a hash value";

pattern bulk_rotate_xor_hash(h:wrd, nbits:int, v:any) :wrd 
address MKEYrotate_xor_hash
comment "post: [:xor=]([:rotate=](h, nbits), [hash](b))";

command bulk_rotate_xor_hash(h:wrd, nbits:int,b:bat[:oid,:any_1])
	:bat[:oid,:wrd] 
address MKEYconstbulk_rotate_xor_hash
comment "pre:  h and b should be synced on head
         post: [:xor=]([:rotate=](h, nbits), [hash](b))";

pattern bulk_rotate_xor_hash(h:bat[:oid,:wrd], nbits:int, v:any)
	:bat[:oid,:wrd] 
address MKEYbulkconst_rotate_xor_hash
comment "pre:  h and b should be synced on head
         post: [:xor=]([:rotate=](h, nbits), [hash](b))";

command bulk_rotate_xor_hash(h:bat[:oid,:wrd], nbits:int,b:bat[:oid,:any_1])
	:bat[:oid,:wrd] 
address MKEYbulk_rotate_xor_hash
comment "pre:  h and b should be synced on head
         post: [:xor=]([:rotate=](h, nbits), [hash](b))";

@- The Problem
@}
When creating a join, we want to make a unique key of the attributes on both
sides and then join these keys. Consider the following BATs.

@verbatim
orders                  customer                link
====================    =====================   ===========
        zipcode h_nr            zipcode hnr    oid     cid
o1      13      9       c1      11      10      o1      c5
o2      11      10      c2      11      11      o2      c1
o3      11      11      c3      12      2       o3      c2
o4      12      5       c4      12      1       o4      nil
o5      11      10      c5      13      9       o5      c1
o6      12      2       c6      14      7       o6      c3
o7      13      9                               o7      c5
o8      12      1                               o8      c4
o9      13      9                               o9      c5
@end verbatim

The current approach is designed to take minimal memory, as our previous
solutions to the problem did not scale well. In case of singular keys,
the link is executed by a simple join. Before going into the join, we
make sure the end result size is not too large, which is done by looking
at relation sizes (if the other key is unique) or, if that is not possible,
by computing the exact join size.

The join algorithm was also improved to do dynamic sampling to determine
with high accuracy the join size, so that we can alloc in one go a memory
region of sufficient size. This also reduces the ds\_link memory requirements.

For compound keys, those that consist of multiple attributes, we now compute
a derived column that contains an integer hash value derived from all
key columns.
This is done by computing a hash value for each individual key column
and combining those by bitwise XOR and left-rotation. That is, for each
column,we rotate the working hash value by N bits and XOR the hash value
of the column over it. The working hash value is initialized with zero,
and after all columns are processed, this working value is used as output.
Computing the hash value for all columns in the key for one table is done
by the command hash(). Hence, we do hash on both sides, and join
that together with a simple join:

@code{join(hash(keys), hash(keys.reverse);}

One complication of this procedure are nil values:
@table
@itemize
@item 
it may happen that the final hash-value (an int formed by a
random bit pattern) accidentally has the value of int(nil).
Notice that join never matches nil values.
Hence these accidental nils must be replaced by a begin value (currently: 0).
@item 
in case any of the compound key values is nil, our nil semantics
require us that those tuples may never match on a join. Consequently,
during the hash() processing of all compound key columns for computing
the hash value, we also maintain a bit-bat that records which tuples had
a nil value. The bit-bat is initialized to false, and the results of the
nil-check on each column is OR-ed to it.
Afterwards, the hash-value of all tuples that have this nil-bit set to
TRUE are forced to int(nil), which will exclude them from matching.
@end itemize

Joining on hash values produces a @emph{superset} of the join result:
it may happen that  two different key combinations hash on the same value,
which will make them match on the join (false hits). The final part
of the ds\_link therefore consists of filtering out the false hits.
This is done incrementally by joining back the join result to the original
columns, incrementally one by one for each pair of corresponding
columns. These values are compared with each other and we AND the
result of this comparison together for each pair of columns.
The bat containing these bits is initialized to all TRUE and serves as
final result after all column pairs have been compared.
The initial join result is finally filtered with this bit-bat.

Joining back from the initial join-result to the original columns on
both sides takes quite a lot of memory. For this reason, the false
hit-filtering is done in slices (not all tuples at one time).
In this way the memory requirements of this phase are kept low.
In fact, the most memory demanding part of the join is the int-join
on hash number, which takes N*24 bytes (where N= |L| = |R|).
In comparison, the previous CTmultigroup/CTmultiderive approach
took N*48 bytes. Additionally, by making it possible to use merge-sort,
it avoids severe performance degradation (memory thrashing) as produced
by the old ds\_link when the inner join relation would be larger than memory.

If ds\_link performance is still an issue, the sort-merge join used here
could be replaced by partitioned hash-join with radix-cluster/decluster.

@{
@+ Implementation
@h
#ifndef _MKEY_H
#define _MKEY_H

/*#define _DEBUG_MKEY_  */

#include <mal.h>
#include "mal_interpreter.h"
#include "mal_exception.h"

#ifdef WIN32
#if !defined(LIBMAL) && !defined(LIBATOMS) && !defined(LIBKERNEL) && !defined(LIBMAL) && !defined(LIBOPTIMIZER) && !defined(LIBSCHEDULER) && !defined(LIBMONETDB5)
#define mkey_export extern __declspec(dllimport)
#else
#define mkey_export extern __declspec(dllexport)
#endif
#else
#define mkey_export extern
#endif

#define GDK_ROTATE(x,y,z,m) ((((x) << (y)) & ~(m)) | (((x) >> (z)) & (m)))

mkey_export str  MKEYrotate(wrd *ret, wrd *v, int *nbits);
mkey_export str  MKEYhash(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mkey_export str  MKEYhash_bit(wrd *ret, bit *v);
mkey_export str  MKEYhash_chr(wrd *ret, chr *v);
mkey_export str  MKEYhash_bte(wrd *ret, bte *v);
mkey_export str  MKEYhash_sht(wrd *ret, sht *v);
mkey_export str  MKEYhash_int(wrd *ret, int *v);
mkey_export str  MKEYhash_flt(wrd *ret, flt *v);
mkey_export str  MKEYhash_wrd(wrd *ret, wrd *v);
mkey_export str  MKEYhash_dbl(wrd *ret, dbl *v);
mkey_export str  MKEYhash_lng(wrd *ret, lng *v);
mkey_export str  MKEYhash_str(wrd *ret, str *v);
mkey_export str  MKEYrotate_xor_hash(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mkey_export str  MKEYbulk_rotate_xor_hash(int *ret, int *hid, int *nbits,int *bid);
mkey_export str  MKEYbulkconst_rotate_xor_hash(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mkey_export str  MKEYconstbulk_rotate_xor_hash(int *ret, wrd *h, int *nbits,int *bid);
mkey_export str  MKEYbathash(bat *res, bat *bid );

#endif /* _MKEY_H */
@-
new functionality for the low-resource-consumption ds_link. It will
first one by one create a hash value out of the multiple attributes.
This hash value is computed by xoring and rotating individual hash
values together. We create a hash and rotate command to do this.
@c
#include "monetdb_config.h"
#include "mkey.h"
/* TODO: nil handling. however; we do not want to lose time in bulk_rotate_xor_hash with that */
static int
CMDrotate(wrd *res, wrd *val, int *n)
{
	*res = GDK_ROTATE(*val, *n, (sizeof(wrd)*8) - *n, (((wrd)1) << *n) - 1);
	return GDK_SUCCEED;
}

static int
CMDhash_bte(wrd *res, bte *val)
{
	*res = *val;
	return GDK_SUCCEED;
}

static int
CMDhash_sht(wrd *res, sht *val)
{
	*res = *val;
	return GDK_SUCCEED;
}

static int
CMDhash_int(wrd *res, int *val)
{
	*res = *val;
	return GDK_SUCCEED;
}

static int
CMDhash_flt(wrd *res, flt *val)
{
	*res = *(int*) val;
	return GDK_SUCCEED;
}

static int
CMDhash_wrd(wrd *res, wrd *val)
{
	*res = *val;
	return GDK_SUCCEED;
}

static int
CMDhash_lng(wrd *res, lng *val)
{
#if SIZEOF_WRD == SIZEOF_LNG
	*res = (wrd) *val;
#else
	*res = ((wrd *) val)[0] ^ ((wrd *) val)[1];
#endif
	return GDK_SUCCEED;
}

static int
CMDhash_dbl(wrd *res, dbl *val)
{
#if SIZEOF_WRD == SIZEOF_LNG
	*res = (wrd) *val;
#else
	*res = ((wrd *) val)[0] ^ ((wrd *) val)[1];
#endif
	return GDK_SUCCEED;
}

static int
CMDhash_str(wrd *res, str val)
{
	BUN h = strHash(val);
	*res = h;
	return GDK_SUCCEED;
}

static int
CMDhash(wrd *res, ptr val, int tpe)
{
	wrd code;
	BUN h;

	switch (ATOMstorage(tpe)) {
	case TYPE_void:
		code = int_nil;
		break;
	case TYPE_chr:
		code = *(chr *) val;
		break;
	case TYPE_bte:
		code = *(bte *) val;
		break;
	case TYPE_sht:
		code = *(sht *) val;
		break;
	case TYPE_int:
	case TYPE_flt:
		code = *(int *) val;
		break;
	case TYPE_lng:
	case TYPE_dbl:
#if SIZEOF_WRD == SIZEOF_LNG
		code = *(wrd *) val;
#else
		code = ((wrd *) val)[0] ^ ((wrd *) val)[1];
#endif
		break;
	case TYPE_str:
		h = strHash((char*)val);
		code = h;
		break;
	default:
		h = (*BATatoms[tpe].atomHash)(val);
		code = h;
	}
	*res = code;
	return GDK_SUCCEED;
}

static str
voidbathash(BAT **res, BAT *b )
{
	BAT *dst;
	BUN (*hash)(ptr v); 
	wrd *r, *f;
	BATiter bi, dsti;

	dst = BATnew(TYPE_void, TYPE_wrd, BATcount(b));
	if (!dst) 
		throw(SQL, "bathash", "can not create bat");
	BATseqbase(dst, b->hseqbase);

	dsti = bat_iterator(dst);
	bi = bat_iterator(b);
 	r = (wrd*)BUNtail(dsti, BUNfirst(dst));
	f = r;
	hash = BATatoms[b->ttype].atomHash;
	if (ATOMvarsized(b->ttype)) { /* ugh */
		BUN p,q;

		BATloop(b,p,q) {
			ptr v = BUNtail(bi,p);
			*r++ = hash(v);
		}
	} else {
		char *v = BUNtail(bi,BUNfirst(b)), *e = BUNtail(bi,BUNlast(b));
		int sz = Tsize(b), tpe = b->ttype;

		switch (ATOMstorage(tpe)) {
		case TYPE_chr: 
			for(; v < e; v+=sz) 
				*r++ = *(chr*)v;
			break;
		case TYPE_bte:
			for(; v < e; v+=sz) 
				*r++ = *(bte*)v;
			break;
		case TYPE_sht:
			for(; v < e; v+=sz) 
				*r++ = *(sht*)v;
			break;
		case TYPE_int:
		case TYPE_flt:
			for(; v < e; v+=sz) 
				*r++ = *(int*)v;
			break;
		case TYPE_lng:
		case TYPE_dbl:
			for(; v < e; v+=sz) 
#if SIZEOF_WRD == SIZEOF_LNG
				*r++ = *(wrd*)v;
#else
				*r++ = ((wrd *) v)[0] ^ ((wrd *) v)[1];
#endif
			break;
		default:
			for(; v < e; v+=sz) 
				*r++ = hash(v);
		}
	}
	BATsetcount(dst, (BUN) (r-f));
	BATkey(BATmirror(dst), 0);
	dst->tsorted = ATOMvarsized(b->ttype)?0: 
			(Tsize(b)<=sizeof(wrd)?b->tsorted:0);
	dst->T->nonil = b->T->nonil;

	*res = dst;
	return MAL_SUCCEED;
}

str
MKEYbathash(bat *res, bat *bid )
{
	str msg;
	BAT *b, *dst = 0;

	if( (b = BATdescriptor(*bid)) == NULL ){
		throw(SQL, "bathash", "Cannot access descriptor");
	}
	assert(BAThvoid(b) || BAThrestricted(b));

	msg = voidbathash(&dst, b);
	if (!BAThvoid(b)) {
		BAT *x = VIEWcreate(b, dst);
		BBPreleaseref(dst->batCacheid);
		dst = x;
	}
	BBPkeepref( *res = dst->batCacheid);
	BBPunfix(b->batCacheid);
	return msg;
}

str
MKEYrotate_xor_hash(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	wrd *dst = (wrd*) getArgReference(stk,p,0);
	wrd *h = (wrd*) getArgReference(stk,p,1);
	int *rotate = (int*) getArgReference(stk,p,2);
	int tpe = getArgType(mb,p,3);
	ptr *pval = (ptr) getArgReference(stk,p,3);
	int lbit = *rotate;
	int rbit = (sizeof(wrd)*8) - *rotate;
	wrd mask = (((wrd)1) << lbit) - 1;

	(void) cntxt;
	if (tpe == TYPE_chr || tpe == TYPE_bte) {
		chr *cur = (chr*) pval;
		*dst = GDK_ROTATE(*h, lbit, rbit, mask) ^ *cur;
	} else if (tpe == TYPE_sht) {
		sht *cur = (sht*) pval;
		*dst = GDK_ROTATE(*h, lbit, rbit, mask) ^ *cur;
	} else if (tpe == TYPE_int || tpe == TYPE_flt) {
		int *cur = (int*) pval;
		*dst = GDK_ROTATE(*h, lbit, rbit, mask) ^ *cur;
	} else if (tpe == TYPE_lng || tpe == TYPE_dbl) {
		lng *cur = (lng*) pval;
#if SIZEOF_WRD == SIZEOF_LNG
		wrd val = *(wrd *) cur;
#else
		wrd val = ((wrd *) cur)[0] ^ ((wrd *) cur)[1];
#endif
		*dst = GDK_ROTATE(*h, lbit, rbit, mask) ^ val;
	} else if (tpe == TYPE_str) {	/* TYPE_str */
		str cur = *(str*) pval;
		BUN val = strHash(cur);
		*dst = GDK_ROTATE(*h, lbit, rbit, mask) ^ val;
	} else {
		BUN val = (*BATatoms[tpe].atomHash)(pval);
		*dst = GDK_ROTATE(*h, lbit, rbit, mask) ^ val;
	}
	return MAL_SUCCEED;
}

static str
CMDconstbulk_rotate_xor_hash(BAT **res, wrd *hsh, int *rotate, BAT *b)
{
	BAT* br = NULL;
	BATiter bi = bat_iterator(b);
	wrd *dst = NULL;
	int tpe = ATOMstorage(b->ttype);
	int lbit = *rotate;
	int rbit = (sizeof(wrd)*8) - *rotate;
	wrd mask = (((wrd)1) << lbit) - 1;

	if (*rotate < 0 || *rotate >= (int)(sizeof(wrd)*8)) {
#ifdef _DEBUG_MKEY_
		mnstr_printf(GDKout,"CMDbulk_rotate_xor_hash: (" SZFMT ",%d,%s): illegal number of rotate bits.\n", *hsh, *rotate, BATgetId(b));
#endif
		return " Illegal number of rotate bits";
	}
	
	BATaccessBegin(b, USE_TAIL, MMAP_SEQUENTIAL);
	br = BATnew(TYPE_void, TYPE_wrd, BATcount(b));
	if (br == NULL) {
#ifdef _DEBUG_MKEY_
		mnstr_printf(GDKout,"CMDbulk_rotate_xor_hash: fail to allocate result BAT[void,wrd] of "SZFMT" tuples.\n", BATcount(b));
#endif
		return MAL_MALLOC_FAIL;
	}
	BATseqbase(br, b->hseqbase);
	dst = (wrd *) Tloc(br, BUNfirst(br));

	if (tpe == TYPE_bte || tpe == TYPE_chr) {
		bte *cur = (bte *) BUNtloc(bi, BUNfirst(b));
		bte *end = (bte *) BUNtloc(bi, BUNlast(b));

		while (cur < end) {
			*dst = GDK_ROTATE(*hsh, lbit, rbit, mask) ^ *cur;
			cur++;
			dst++;
		}
	} else if (tpe == TYPE_sht) {
		sht *cur = (sht *) BUNtloc(bi, BUNfirst(b));
		sht *end = (sht *) BUNtloc(bi, BUNlast(b));

		while (cur < end) {
			*dst = GDK_ROTATE(*hsh, lbit, rbit, mask) ^ *cur;
			cur++;
			dst++;
		}
	} else if (tpe == TYPE_int || tpe == TYPE_flt) {
		int *cur = (int *) BUNtloc(bi, BUNfirst(b));
		int *end = (int *) BUNtloc(bi, BUNlast(b));

		while (cur < end) {
			*dst = GDK_ROTATE(*hsh, lbit, rbit, mask) ^ *cur;
			cur++;
			dst++;
		}
	} else if (tpe == TYPE_lng || tpe == TYPE_dbl) {
		lng *cur = (lng *) BUNtloc(bi, BUNfirst(b));
		lng *end = (lng *) BUNtloc(bi, BUNlast(b));

		while (cur < end) {
			wrd *t = (wrd*)cur;
#if SIZEOF_WRD == SIZEOF_LNG
			wrd val = *t;
#else
			wrd val = t[0] ^ t[1];
#endif

			*dst = GDK_ROTATE(*hsh, lbit, rbit, mask) ^ val;
			cur++;
			dst++;
		}
	} else if (tpe == TYPE_str) {	/* TYPE_str */
		BUN p, q;

		if (b->T->vheap->hashash) {
			BATloop(b, p, q) {
				str val_p = (str) BUNtvar(bi, p);
				BUN h;
				wrd val;
				h = ((BUN *) val_p)[-1];
				val = (wrd) h;
				*dst = GDK_ROTATE(*hsh, lbit, rbit, mask) ^ val;
				dst++;
			}
		} else {
			BATloop(b, p, q) {
				str val_p = (str) BUNtvar(bi, p);
				BUN h;
				wrd val;
				GDK_STRHASH(val_p, h);
				val = (wrd) h;
				*dst = GDK_ROTATE(*hsh, lbit, rbit, mask) ^ val;
				dst++;
			}
		}
	} else if (b->ttype == TYPE_void) {
		BUN p, q;

		BATloop(b, p, q) {
			*dst = GDK_ROTATE(*hsh, lbit, rbit, mask) ^ *(wrd *) BUNtail(bi, p);
			dst++;
		}
	} else {
		BUN (*hash)(ptr) = BATatoms[b->ttype].atomHash;
		BUN p, q;

		BATloop(b, p, q) {
			BUN val = (*hash)(BUNtail(bi, p));
			*dst = GDK_ROTATE(*hsh, lbit, rbit, mask) ^ val;
			dst++;
		}
	}
	BATaccessEnd(b, USE_TAIL, MMAP_SEQUENTIAL);

	BATsetcount(br, BATcount(b));
	br->tsorted = 0;
	if (br->tkey)
		BATkey(BATmirror(br), FALSE);
	if (br->htype != b->htype) {
		*res = VIEWcreate(b,br);

		BBPreleaseref(br->batCacheid);
		br = NULL;
	} else {
		*res = br;
	}

	return MAL_SUCCEED;
}

str
MKEYbulkconst_rotate_xor_hash(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	int *res = (int*) getArgReference(stk,p,0);
	int *hid = (int*) getArgReference(stk,p,1);
	int *rotate = (int*) getArgReference(stk,p,2);
	int tpe = getArgType(mb,p,3);
	ptr *pval = (ptr) getArgReference(stk,p,3);
	wrd *dst, *src, *end;
	int lbit = *rotate;
	int rbit = (sizeof(wrd)*8) - *rotate;
	wrd mask = (((wrd)1) << lbit) - 1;
	wrd cur = 0;
	BAT *br, *hn;

	if ((hn = BATdescriptor(*hid)) == NULL) {
        	throw(MAL, "mkey.bulk_rotate_xor_hash", RUNTIME_OBJECT_MISSING);
    	}

	(void) cntxt;
	if (tpe == TYPE_chr || tpe == TYPE_bte) {
		cur = *(chr*) pval;
	} else if (tpe == TYPE_sht) {
		cur = *(sht*) pval;
	} else if (tpe == TYPE_int || tpe == TYPE_flt) {
		cur = *(int*) pval;
	} else if (tpe == TYPE_lng || tpe == TYPE_dbl) {
		lng *pcur = (lng*) pval;
#if SIZEOF_WRD == SIZEOF_LNG
		cur = *(wrd *) pcur;
#else
		cur = ((wrd *) pcur)[0] ^ ((wrd *) pcur)[1];
#endif
	} else if (tpe == TYPE_str) {	/* TYPE_str */
		str pcur = *(str*) pval;
		cur = strHash(pcur);
	} else {
		cur = (*BATatoms[tpe].atomHash)(pval);
	}
	br = BATnew(TYPE_void, TYPE_wrd, BATcount(hn));
	if (br == NULL) {
#ifdef _DEBUG_MKEY_
		mnstr_printf(GDKout,"CMDbulk_rotate_xor_hash: fail to allocate result BAT[void,wrd] of "SZFMT" tuples.\n", BATcount(hn));
#endif
		return MAL_MALLOC_FAIL;
	}
	BATseqbase(br, hn->hseqbase);
	dst = (wrd *) Tloc(br, BUNfirst(br));
	src = (wrd *) Tloc(hn, BUNfirst(hn));
	end = (wrd *) Tloc(hn, BUNlast(hn));

	while (src < end) {
		*dst = GDK_ROTATE(*src, lbit, rbit, mask) ^ cur;
		dst++;
		src++;
	}

	BATsetcount(br, BATcount(hn));
	br->tsorted = 0;
	if (br->tkey)
		BATkey(BATmirror(br), FALSE);
	if (br->htype != hn->htype) {
		BAT *tmp = VIEWcreate(hn,br);

		BBPreleaseref(br->batCacheid);
		br = tmp;
	}
	BBPkeepref(*res = br->batCacheid);
	BBPreleaseref(hn->batCacheid);
	return MAL_SUCCEED;
}

static str
CMDbulk_rotate_xor_hash(BAT **res, BAT *bn, int *rotate, BAT *b)
{
	BAT* br = NULL;
	BATiter bi = bat_iterator(b);
	wrd *src = (wrd *) Tloc(bn, BUNfirst(bn));
	wrd *dst = NULL;
	int tpe = ATOMstorage(b->ttype);
	int lbit = *rotate;
	int rbit = (sizeof(wrd)*8) - *rotate;
	wrd mask = (((wrd)1) << lbit) - 1;

	if (!ALIGNsynced(bn, b) && (BATcount(b) || BATcount(bn))) {
#ifdef _DEBUG_MKEY_
		mnstr_printf(GDKout,"#CMDbulk_rotate_xor_hash: (%s,%d,%s): not synced on head.\n", BATgetId(bn), *rotate, BATgetId(b));
#endif
		return " Operands not synced on head";
	} else if (*rotate < 0 || *rotate >= (int)(sizeof(wrd)*8)) {
#ifdef _DEBUG_MKEY_
		mnstr_printf(GDKout,"CMDbulk_rotate_xor_hash: (%s,%d,%s): illegal number of rotate bits.\n", BATgetId(bn), *rotate, BATgetId(b));
#endif
		return " Illegal number of rotate bits";
	}
	
	BATaccessBegin(b, USE_TAIL, MMAP_SEQUENTIAL);
	br = BATnew(TYPE_void, TYPE_wrd, BATcount(bn));
	if (br == NULL) {
#ifdef _DEBUG_MKEY_
		mnstr_printf(GDKout,"CMDbulk_rotate_xor_hash: fail to allocate result BAT[void,wrd] of "SZFMT" tuples.\n", BATcount(bn));
#endif
		return MAL_MALLOC_FAIL;
	}
	BATseqbase(br, bn->hseqbase);
	dst = (wrd *) Tloc(br, BUNfirst(br));

	if (tpe == TYPE_bte || tpe == TYPE_chr) {
		bte *cur = (bte *) BUNtloc(bi, BUNfirst(b));
		bte *end = (bte *) BUNtloc(bi, BUNlast(b));

		while (cur < end) {
			*dst = GDK_ROTATE(*src, lbit, rbit, mask) ^ *cur;
			cur++;
			dst++;
			src++;
		}
	} else if (tpe == TYPE_sht) {
		sht *cur = (sht *) BUNtloc(bi, BUNfirst(b));
		sht *end = (sht *) BUNtloc(bi, BUNlast(b));

		while (cur < end) {
			*dst = GDK_ROTATE(*src, lbit, rbit, mask) ^ *cur;
			cur++;
			dst++;
			src++;
		}
	} else if (tpe == TYPE_int || tpe == TYPE_flt) {
		int *cur = (int *) BUNtloc(bi, BUNfirst(b));
		int *end = (int *) BUNtloc(bi, BUNlast(b));

		while (cur < end) {
			*dst = GDK_ROTATE(*src, lbit, rbit, mask) ^ *cur;
			cur++;
			dst++;
			src++;
		}
	} else if (tpe == TYPE_lng || tpe == TYPE_dbl) {
		lng *cur = (lng *) BUNtloc(bi, BUNfirst(b));
		lng *end = (lng *) BUNtloc(bi, BUNlast(b));

		while (cur < end) {
			wrd *t = (wrd*)cur;
#if SIZEOF_WRD == SIZEOF_LNG
			wrd val = *t;
#else
			wrd val = t[0] ^ t[1];
#endif

			*dst = GDK_ROTATE(*src, lbit, rbit, mask) ^ val;
			cur++;
			dst++;
			src++;
		}
	} else if (tpe == TYPE_str) {	/* TYPE_str */
		BUN p, q;

		if (b->T->vheap->hashash) {
			BATloop(b, p, q) {
				str val_p = (str) BUNtvar(bi, p);
				BUN h;
				wrd val;
				h = ((BUN *) val_p)[-1];
				val = (wrd) h;
				*dst = GDK_ROTATE(*src, lbit, rbit, mask) ^ val;
				dst++;
				src++;
			}
		} else {
			BATloop(b, p, q) {
				str val_p = (str) BUNtvar(bi, p);
				BUN h;
				wrd val;
				GDK_STRHASH(val_p, h);
				val = (wrd) h;
				*dst = GDK_ROTATE(*src, lbit, rbit, mask) ^ val;
				dst++;
				src++;
			}
		}
	} else if (b->ttype == TYPE_void) {
		BUN p, q;

		BATloop(b, p, q) {
			*dst = GDK_ROTATE(*src, lbit, rbit, mask) ^ *(wrd *) BUNtail(bi, p);
			dst++;
			src++;
		}
	} else {
		BUN (*hash)(ptr) = BATatoms[b->ttype].atomHash;
		BUN p, q;

		BATloop(b, p, q) {
			BUN val = (*hash)(BUNtail(bi, p));
			*dst = GDK_ROTATE(*src, lbit, rbit, mask) ^ val;
			dst++;
			src++;
		}
	}
	BATaccessEnd(b, USE_TAIL, MMAP_SEQUENTIAL);

	BATsetcount(br, BATcount(bn));
	br->tsorted = 0;
	if (br->tkey)
		BATkey(BATmirror(br), FALSE);
	if (br->htype != bn->htype) {
		*res = VIEWcreate(bn,br);

		BBPreleaseref(br->batCacheid);
		br = NULL;
	} else {
		*res = br;
	}

	return MAL_SUCCEED;
}
@+ MAL wrapper
The remainder contains the wrapping needed for M5
@c
str  
MKEYhash_bit(wrd *ret, bit *v)
{
	CMDhash_bte(ret,v);
	return MAL_SUCCEED;
}
str  
MKEYhash_chr(wrd *ret, chr *v)
{
	CMDhash_bte(ret,v);
	return MAL_SUCCEED;
}
str  
MKEYhash_bte(wrd *ret, chr *v)
{
	CMDhash_bte(ret,v);
	return MAL_SUCCEED;
}
str  
MKEYhash_sht(wrd *ret, sht *v)
{
	CMDhash_sht(ret,v);
	return MAL_SUCCEED;
}
str  
MKEYhash_int(wrd *ret, int *v)
{
	CMDhash_int(ret,v);
	return MAL_SUCCEED;
}

str  
MKEYhash_flt(wrd *ret, flt *v)
{
	CMDhash_flt(ret,v);
	return MAL_SUCCEED;
}

str  
MKEYhash_wrd(wrd *ret, wrd *v)
{
	CMDhash_wrd(ret,v);
	return MAL_SUCCEED;
}

str  
MKEYhash_dbl(wrd *ret, dbl *v)
{
	CMDhash_dbl(ret,v);
	return MAL_SUCCEED;
}

str  
MKEYhash_lng(wrd *ret, lng *v)
{
	CMDhash_lng(ret,v);
	return MAL_SUCCEED;
}

str  
MKEYhash_str(wrd *ret, str *v)
{
	CMDhash_str(ret,*v);
	return MAL_SUCCEED;
}

str
MKEYrotate(wrd *res, wrd *val, int *n){
	CMDrotate(res,val,n);
	return MAL_SUCCEED;
}

str
MKEYhash(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	wrd *ret;
	ptr val;
	int tpe = getArgType(mb,p,1);

	(void) cntxt;
	ret= (wrd*) getArgReference(stk,p,0);
	val= (ptr) getArgReference(stk,p,1);
	if (ATOMextern(tpe)) 
		val = *(ptr*)val;
	CMDhash(ret, val, tpe);
	return MAL_SUCCEED;
}

str
MKEYconstbulk_rotate_xor_hash(int *ret, wrd *h, int *nbits, int *bid){
	BAT *b, *bn=0;
	str msg;

	if ((b = BATdescriptor(*bid)) == NULL) {
       	    throw(MAL, "mkey.bulk_rotate_xor_hash",  RUNTIME_OBJECT_MISSING);
    	}

	if( (msg= CMDconstbulk_rotate_xor_hash(&bn,h,nbits,b)) != MAL_SUCCEED){
	    BBPreleaseref(b->batCacheid);
            throw(MAL, "mkey.bulk_rotate_xor_hash", OPERATION_FAILED "%s", msg);
	}
	BBPreleaseref(b->batCacheid);
	*ret= bn->batCacheid;
	BBPkeepref(bn->batCacheid);
	return MAL_SUCCEED;
}

str
MKEYbulk_rotate_xor_hash(int *ret, int *hid, int *nbits, int *bid){
	BAT *hn, *b, *bn=0;
	str msg;

	if ((hn = BATdescriptor(*hid)) == NULL) {
        throw(MAL, "mkey.bulk_rotate_xor_hash", RUNTIME_OBJECT_MISSING);
    }
	if ((b = BATdescriptor(*bid)) == NULL) {
		BBPreleaseref(hn->batCacheid);
        throw(MAL, "mkey.bulk_rotate_xor_hash",  RUNTIME_OBJECT_MISSING);
    }

	if( (msg= CMDbulk_rotate_xor_hash(&bn,hn,nbits,b)) != MAL_SUCCEED){
		BBPreleaseref(hn->batCacheid);
		BBPreleaseref(b->batCacheid);
        throw(MAL, "mkey.bulk_rotate_xor_hash", OPERATION_FAILED "%s", msg);
	}
	BBPreleaseref(hn->batCacheid);
	BBPreleaseref(b->batCacheid);
	*ret= bn->batCacheid;
	BBPkeepref(bn->batCacheid);
	return MAL_SUCCEED;
}
@}
