@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2011 MonetDB B.V.
All Rights Reserved.
@

@f mat
@a Martin Kersten
@v 1
@+ Multiple association tables
A MAT is a convenient way to deal represent horizontal fragmented
tables. It combines the definitions of several, type compatible
BATs under a single name. 
It is produced by the mitosis optimizer and the operations
are the target of the mergetable optimizer.

The MAT is materialized when the operations
can not deal with the components individually,
or the incremental operation is not supported.
Normally all mat.new() operations are removed by the
mergetable optimizer.
In case a mat.new() is retained in the code, then it will
behaves as a mat.pack();

The primitives below are chosen to accomodate the SQL
front-end to produce reasonable efficient code.
@mal
module mat;

pattern new(b:bat[:any_1,:any_2]...):bat[:any_1,:any_2]
address MATpack
comment "Define a Merge Association Table (MAT). Faal back to the pack operation
when this is called ";

pattern pack(:any_2...):bat[:void,:any_2]
address MATpackValues
comment "Materialize the MAT (of values) into a BAT";

pattern pack(:any_2...):bat[:oid,:any_2]
address MATpackValues
comment "Materialize the MAT (of values) into a BAT";

pattern pack(b:bat[:any_1,:any_2]...):bat[:any_1,:any_2]
address MATpack
comment "Materialize the MAT into a BAT";

pattern pack2(b:bat[:any_1,:any_2]...):bat[:any_1,:any_2]
address MATpack2
comment "Materialize the MAT into a BAT (by an append all)";

pattern slice(first:wrd, last:wrd, b:bat[:any_1,:any_2]...):bat[:any_1,:any_2]
address MATpackSlice
comment "Materialize a sliced MAT into a BAT";

pattern slice(first:int, last:int, b:bat[:any_1,:any_2]...):bat[:any_1,:any_2]
address MATpackSlice
comment "Materialize a sliced MAT into a BAT";

pattern slice(first:lng, last:lng, b:bat[:any_1,:any_2]...):bat[:any_1,:any_2]
address MATpackSlice
comment "Materialize a sliced MAT into a BAT";

pattern project(map:bat[:void,:bte], b:bat[:any_1,:any_2]...):bat[:any_1,:any_2]
address MATproject
comment "project using the map bat (contains which bat to use in scan order)";

pattern project(map:bat[:void,:bte], b:bat[:any_1,:any_2]...):bat[:void,:any_2]
address MATproject
comment "project using the map bat (contains which bat to use in scan order)";

pattern sortTail(b:bat[:any_1,:any_2]...)
	(sorted:bat[:void,:any_2], map:bat[:void,:bte]) 
address MATsortTail
comment "Returns a BAT copy sorted on the head column.";

pattern sortReverseTail(b:bat[:any_1,:any_2]...)
	(sorted:bat[:void,:any_2], map:bat[:void,:bte]) 
address MATsortReverseTail
comment "Returns a BAT copy sorted on the head column.";

pattern refine(sorted:bat[:void,:any_2], map:bat[:void,:bte], b:bat[:any_1,:any_3]...)
	(rsorted:bat[:void,:oid], rmap:bat[:void,:bte]) 
address MATrefine
comment "refine map.";

pattern refine_rev(sorted:bat[:void,:any_2], map:bat[:void,:bte], b:bat[:any_1,:any_3]...)
	(rsorted:bat[:void,:oid], rmap:bat[:void,:bte]) 
address MATrefineReverse
comment "refine map.";

pattern print(b:bat[:any_1,:any_2]...):void
address MATprint;

pattern newIterator(grp:bat[:any_1,:any_2]...):bat[:any_1,:any_2]
address MATnewIterator
comment "Create an iterator over a MAT";

pattern hasMoreElements(grp:bat[:any_1,:any_2]...):bat[:any_1,:any_2]
address MAThasMoreElements
comment "Find the next element in the merge table";

command info(g:str, e:str):bat[:any_1,:any_2]
address MATinfo
comment "retrieve the definition from the partition catalogue";

@-
@{
@+ Implementation
@include prelude.mx
@h
#ifndef _INSPECT_H
#define _INSPECT_H 
#include <stdarg.h>
#include "mal_resolve.h"
#include "mal_exception.h"
#include "mal_interpreter.h"

#ifdef WIN32
#if !defined(LIBMAL) && !defined(LIBATOMS) && !defined(LIBKERNEL) && !defined(LIBMAL) && !defined(LIBOPTIMIZER) && !defined(LIBSCHEDULER) && !defined(LIBMONETDB5)
#define mat_export extern __declspec(dllimport)
#else
#define mat_export extern __declspec(dllexport)
#endif
#else
#define mat_export extern
#endif

mat_export str MATpack(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mat_export str MATpack2(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mat_export str MATpackValues(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mat_export str MATpackSlice(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mat_export str MATnewIterator(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mat_export str MAThasMoreElements(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mat_export str MATdummy(int *ret, str *grp);
mat_export str MATinfo(int *ret, str *grp, str *elm);
mat_export str MATprint(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mat_export str MATproject(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mat_export str MATrefine(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mat_export str MATsortReverseTail(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mat_export str MATsortTail(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mat_export str MATrefineReverse(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
#endif /* _INSPECT_H */
@- 
Mal symbol table and environment analysis.
@c
#include "monetdb_config.h"
#include "mat.h"
#include "group.h"

str
MATnewIterator(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	int *ret = (int*) getArgReference(stk,p,0);
	(void) cntxt;
	(void) mb; 
	if( p->argc == 1){
		*ret = 0;
	} else
		*ret= *(int*) getArgReference(stk,p,1);
	return MAL_SUCCEED;
}
str
MAThasMoreElements(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	int *ret = (int*) getArgReference(stk,p,0);
	int i, idx = *ret;

	(void) cntxt;
	(void) mb; 
	for(i=1; i< p->argc; i++)
	if( *(int*) getArgReference(stk,p,i) == idx){
		i++;
		break;
	}
	if( i < p->argc)
		*ret= *(int*) getArgReference(stk,p,i);
	else
		*ret = 0;
	(void) mb; 
	return MAL_SUCCEED;
}
@-
The pack is an ordinary multi BAT insert. Oid synchronistion
between pieces should be ensured by the code generators.
The pack operation could be quite expensive, because it
may create a really large BAT.
The slice over a mat helps to avoid constructing intermediates
that are subsequently reduced.
@c
static str
MATpackInternal(MalStkPtr stk, InstrPtr p)
{
	int i, *ret = (int*) getArgReference(stk,p,0);
	BAT *b, *bn;
	BUN cap = 0;
	int ht = TYPE_any, tt = TYPE_any;

	for (i = 1; i < p->argc; i++) {
		int bid = stk->stk[getArg(p,i)].val.ival;
		b = BBPquickdesc(ABS(bid),FALSE);
		if (b && bid < 0)
			b = BATmirror(b);
		if( b == NULL)
			throw(MAL, "mat.pack", RUNTIME_OBJECT_MISSING);
		if (ht == TYPE_any){
			ht = b->htype;
			tt = b->ttype;
		}
		cap += BATcount(b);
	}
	assert(ht != TYPE_any);

	bn = BATnew(ht, tt, cap);
	if (bn == NULL)
		throw(MAL, "mat.pack", MAL_MALLOC_FAIL);
	/* must set seqbase or else BATins will not materialize column */
	if (ht == TYPE_void)
		BATseqbase(bn, 0);
	if (tt == TYPE_void)
		BATseqbase(BATmirror(bn), 0);

	for (i = 1; i < p->argc; i++) {
		b = BATdescriptor(stk->stk[getArg(p,i)].val.ival);
		if( b == NULL){
			BBPreleaseref(bn->batCacheid);
			throw(MAL, "mat.pack", RUNTIME_OBJECT_MISSING);
		}
		/* use the right oid ranges, don't change the input */
		BATins(bn,b,FALSE);
		BBPunfix(b->batCacheid);
	}
	BBPkeepref(*ret = bn->batCacheid);
	return MAL_SUCCEED;
}

static str
MATpackSliceInternal(MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	int i, i1 = p->argc, i2 = -1, *ret = (int*) getArgReference(stk,p,0);
	BAT *b, *bn;
	BUN cap = 0, fst, lst, cnt, c;
	int ht = TYPE_any, tt = TYPE_any;

	assert(p->argc > 3);
	switch getArgType(mb,p,1) {
	case TYPE_wrd:
		fst = (BUN) *(wrd*) getArgReference(stk,p,1);
		break;
	case TYPE_lng:
		fst = (BUN) *(lng*) getArgReference(stk,p,1);
		break;
	case TYPE_int:
		fst = (BUN) *(int*) getArgReference(stk,p,1);
		break;
	default:
		throw(MAL, "mat.packSlice", "wrong type for lower bound");
	}
	switch getArgType(mb,p,2) {
	case TYPE_wrd: {
		wrd l = *(wrd*) getArgReference(stk,p,2);
		if (l == wrd_nil)
			lst = BUN_MAX; /* no upper bound */
		else
			lst = (BUN) l;
		break;
	}
	case TYPE_lng: {
		lng l = *(lng*) getArgReference(stk,p,2);
		if (l == lng_nil)
			lst = BUN_MAX; /* no upper bound */
		else
			lst = (BUN) l;
		break;
	}
	case TYPE_int: {
		int l = *(int*) getArgReference(stk,p,2);
		if (l == int_nil)
			lst = BUN_MAX; /* no upper bound */
		else
			lst = (BUN) l;
		break;
	}
	default:
		throw(MAL, "mat.packSlice", "wrong type for upper bound");
	}
	if (lst < BUN_MAX)
		lst++; /* inclusive -> exclusive upper bound */
	if (lst < fst)
		lst = fst;
	cnt = lst - fst;

	for (i = 3; i < p->argc && cap < lst; i++) {
		int bid = stk->stk[getArg(p,i)].val.ival;
		b = BBPquickdesc(ABS(bid),FALSE);
		if (b && bid < 0)
			b = BATmirror(b);
		if (b == NULL)
			throw(MAL, "mat.packSlice", RUNTIME_OBJECT_MISSING);
		if (ht == TYPE_any){
			ht = b->htype;
			tt = b->ttype;
		}
		c = BATcount(b);
		if (cap <= fst) {
			/* The optimal case is when the requested slice falls completely in one BAT.
			 * In that case, we can simply return a slice (view) of that BAT.
			 * (A pitty that we have calculated the other slices as well.)
			 */
			if (lst <= cap + c) {
				b = BATdescriptor(bid);
				bn = BATslice(b, fst - cap, lst - cap);
				BBPunfix(b->batCacheid);
				BBPkeepref(*ret = bn->batCacheid);
				return MAL_SUCCEED;
			}
			if (fst < cap + c) {
				/* fst falls in BAT i1 == i */
				i1 = i;
				fst -= cap;
				lst -= cap;
				cap = 0;
			}
		}
		cap += c;
	}
	/* lst falls in BAT i2 == i-1 */
	i2 = i - 1;
	if (cap <= fst) /* i.e., (i1 > i2) */
		cap = 0;
	else
		cap -= fst;
	cnt = MIN(cnt, cap);

	bn = BATnew(ht, tt, cnt);
	if (bn == NULL)
		throw(MAL, "mat.packSlice", MAL_MALLOC_FAIL);
	/* must set seqbase or else BATins will not materialize column */
	if (ht == TYPE_void)
		BATseqbase(bn, 0);
	if (tt == TYPE_void)
		BATseqbase(BATmirror(bn), 0);

	for (i = i1; i <= i2; i++) {
		b = BATdescriptor(stk->stk[getArg(p,i)].val.ival);
		if (b == NULL){
			BBPreleaseref(bn->batCacheid);
			throw(MAL, "mat.packSlice", RUNTIME_OBJECT_MISSING);
		}
		c = BATcount(b);
		/* use the right oid ranges, don't change the input */
		if (i == i1 && fst > 0) {
			BAT *bb = b;
			b = BATslice(bb, fst, c);
			BBPunfix(bb->batCacheid);
		} else
		if (i == i2 && lst < c) {
			BAT *bb = b;
			b = BATslice(bb, 0, lst);
			BBPunfix(bb->batCacheid);
		}
		BATins(bn,b,FALSE);
		lst -= c;
		BBPunfix(b->batCacheid);
	}
	BBPkeepref(*ret = bn->batCacheid);
	return MAL_SUCCEED;
}

static str
MATpack2Internal(MalStkPtr stk, InstrPtr p)
{
	int i,*ret;
	BAT *b, *bn;
	BUN cap=0;

	b= BATdescriptor(stk->stk[getArg(p,1)].val.ival);
	if( b == NULL)
		throw(MAL, "mat.pack", RUNTIME_OBJECT_MISSING);
	bn = BATcopy(b, b->htype, b->ttype, TRUE);
	BBPunfix(b->batCacheid);
	if( bn == NULL)
		throw(MAL, "mat.pack", MAL_MALLOC_FAIL);

	for(i = 2; i < p->argc; i++){
		b= BATdescriptor(stk->stk[getArg(p,i)].val.ival);
		if( b == NULL){
			BBPreleaseref(bn->batCacheid);
			throw(MAL, "mat.pack", RUNTIME_OBJECT_MISSING);
		}
		cap += BATcount(b);
		BBPunfix(b->batCacheid);
	}
	bn = BATextend(bn, cap);
	for( i = 2; i < p->argc; i++){
		b= BATdescriptor(stk->stk[getArg(p,i)].val.ival);
		if( b == NULL){
			BBPreleaseref(bn->batCacheid);
			throw(MAL, "mat.pack", RUNTIME_OBJECT_MISSING);
		}
		BATappend(bn,b,FALSE);
		BBPunfix(b->batCacheid);
	}
	ret= (int*) getArgReference(stk,p,0);
	BBPkeepref(*ret = bn->batCacheid);
	return MAL_SUCCEED;
}

str
MATpack2(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	(void) cntxt;
	(void) mb;
	return MATpack2Internal(stk,p);
}

str
MATpack(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	(void) cntxt;
	(void) mb;
	return MATpackInternal(stk,p);
}

str
MATpackValues(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	int i,*ret, type, first = 1;
	BAT *bn;

	(void) cntxt;
	type = getArgType(mb,p,first);
	bn = BATnew(TYPE_void, type, p->argc);
	if( bn == NULL)
		throw(MAL, "mat.pack", MAL_MALLOC_FAIL);

	if (ATOMvarsized(type)) {
		for(i = first; i < p->argc; i++)
			BUNappend(bn, stk->stk[getArg(p,i)].val.sval, TRUE);
	} else {
		for(i = first; i < p->argc; i++)
			BUNappend(bn, getArgReference(stk, p, i), TRUE);
	}
	ret= (int*) getArgReference(stk,p,0);
	BBPkeepref(*ret = bn->batCacheid);
	return MAL_SUCCEED;
}
str
MATpackSlice(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	(void) cntxt;
	return MATpackSliceInternal(mb,stk,p);
}


str
MATprint(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	(void) cntxt; (void) mb; (void) stk; (void) p;
	return MAL_SUCCEED;
}

str
MATdummy(int *ret, str *grp){
	(void) grp; (void) ret;
	return MAL_SUCCEED;
}
str
MATinfo(int *ret, str *grp, str *elm){
	(void) grp; (void) elm; (void) ret;
	return MAL_SUCCEED;
}

static BAT *
MATproject_any( BAT *map, BAT **bats, int len )
{
	BAT *res;
	int i;
	BUN j, cnt = BATcount(map);
	BATiter *bats_i;
	BUN *batsT;
	bte *mapT;

	res = BATnew(TYPE_void, bats[0]->ttype, cnt);
	BATseqbase(res, map->hseqbase);
	mapT = (bte*)Tloc(map, 0);
	batsT = (BUN*)GDKmalloc(sizeof(BUN) * len);
	bats_i = (BATiter*)GDKmalloc(sizeof(BATiter) * len);
	for (i=0; i<len; i++) {
		batsT[i] = 0;
		bats_i[i] = bat_iterator(bats[i]);
	}
	for (j=0; j<cnt; j++)
		BUNappend(res, BUNtail(bats_i[mapT[j]], batsT[mapT[j]]++), FALSE);
	GDKfree(batsT);
	return res;
}

@= project
static BAT *
MATproject_@1( BAT *map, BAT **bats, int len )
{
	BAT *res;
	int i;
	BUN j, cnt = BATcount(map);
	@1 *resT, **batsT;
	bte *mapT;

	res = BATnew(TYPE_void, bats[0]->ttype, cnt);
	BATseqbase(res, map->hseqbase);
	resT = (@1*)Tloc(res, 0);
	mapT = (bte*)Tloc(map, 0);
	batsT = (@1**)GDKmalloc(sizeof(@1*) * len);
	for (i=0; i<len; i++)
		batsT[i] = (@1*)Tloc(bats[i], 0);
	for (j=0; j<cnt; j++)
		resT[j] = *batsT[mapT[j]]++;
	BATsetcount(res, j);
	GDKfree(batsT);
	return res;
}
@c
@:project(bte)@
@:project(sht)@
@:project(int)@
@:project(lng)@

static int
MATnonil( BAT **bats, int len)
{
	int i, nonil = 1;

	for (i=0; i<len && nonil; i++) {
		nonil &= bats[i]->T->nonil;
	}
	return nonil;
}

BAT *
MATproject_( BAT *map, BAT **bats, int len ) 
{
	BAT *res = NULL;

	if (ATOMstorage(bats[0]->ttype) <= TYPE_void) {
		/*error*/
	} else if (ATOMvarsized(bats[0]->ttype)) {
		res = MATproject_any(map, bats, len);
	} else if (ATOMsize(bats[0]->ttype) == sizeof(bte)) {
		res = MATproject_bte(map, bats, len);
	} else if (ATOMsize(bats[0]->ttype) == sizeof(sht)) {
		res = MATproject_sht(map, bats, len);
	} else if (ATOMsize(bats[0]->ttype) == sizeof(int)) {
		res = MATproject_int(map, bats, len);
	} else if (ATOMsize(bats[0]->ttype) == sizeof(lng)) {
		res = MATproject_lng(map, bats, len);
	} else {
		res = MATproject_any(map, bats, len);
	}
	res->tsorted = 0;
	res->T->nonil = MATnonil(bats, len);
	return res;
}

str
MATproject(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	bat *res_id = (bat*) getArgReference(stk,pci,0);
	bat map_id = *(bat*) getArgReference(stk,pci,1);
	BAT *res = NULL, *map;
	/* rest of the args are parts, (excluding result and map) */
	BAT **bats = GDKzalloc(sizeof(BAT*) * pci->argc - 2);
	BUN bcnt = 0; 
	int i, len = pci->argc-2, sorted = 1;

	(void) cntxt; (void) mb; (void) stk; 
	map = BATdescriptor(map_id);
	if (!map)
		goto error;
	for (i=2; i<pci->argc; i++) {
		bat id = *(bat*) getArgReference(stk,pci,i);
		bats[i-2] = BATdescriptor(id);
		if (!bats[i-2])
			goto error;
		bcnt += BATcount(bats[i-2]);
		if (bats[i-2]->T->sorted != GDK_SORTED)
			sorted = 0;
	}
	assert(bcnt == BATcount(map));

	res = MATproject_(map, bats, len );
	if (sorted && res)
		BATordered(BATmirror(res));
error:
	if (map) BBPunfix(map->batCacheid);
	if (bats) {
		for (i=0; i<len && bats[i]; i++)
			BBPunfix(bats[i]->batCacheid);
		GDKfree(bats);
	}
	if (res) {
		BATsettrivprop(res);
		BBPkeepref( *res_id = res->batCacheid);
		return MAL_SUCCEED;
	}
	throw(SQL, "mat.project","Cannot access descriptor");
}

@= sort_any2
static BAT*
MATsortloop_@1( bte *map_res, BAT *i1, bte *map_i1, BUN cnt_i1, BAT *i2, bte map_i2, BUN cnt_i2) 
{
	int c;
	BUN val_i1 = BUNfirst(i1);
	BUN val_i2 = BUNfirst(i2);
	BUN end_i1 = val_i1 + cnt_i1;
	BUN end_i2 = val_i2 + cnt_i2;
	BATiter bi_i1 = bat_iterator(i1); 
	BATiter bi_i2 = bat_iterator(i2);
	int (*cmp) (ptr, ptr) = BATatoms[i1->ttype].atomCmp;
	BAT *res = BATnew(TYPE_void, i1->ttype, cnt_i1 + cnt_i2);

	BATseqbase(res, 0);
	if (map_i1 == NULL) {
		/* map_i1 = 0 */
		while ( val_i1 < end_i1 && val_i2 < end_i2) {
			if ((c = cmp(BUNtail(bi_i1,val_i1),BUNtail(bi_i2,val_i2))) @2 0) {
				BUNappend(res, BUNtail(bi_i1,val_i1), FALSE);
				*map_res++ = 0;
				val_i1++;
			} else if (c @3 0) {
				BUNappend(res, BUNtail(bi_i2,val_i2), FALSE);
				*map_res++ = map_i2;
				val_i2++;
			}
		}
		while ( val_i1 < end_i1 ) {
			BUNappend(res, BUNtail(bi_i1,val_i1), FALSE);
			*map_res++ = 0;
			val_i1++;
		}
	} else {
		while ( val_i1 < end_i1 && val_i2 < end_i2) {
			if ((c = cmp(BUNtail(bi_i1,val_i1),BUNtail(bi_i2,val_i2))) @2 0) {
				BUNappend(res, BUNtail(bi_i1,val_i1), FALSE);
				*map_res++ = *map_i1++;
				val_i1++;
			} else if (c @3 0) {
				BUNappend(res, BUNtail(bi_i2,val_i2), FALSE);
				*map_res++ = map_i2;
				val_i2++;
			}
		}
		while ( val_i1 < end_i1 ) {
			BUNappend(res, BUNtail(bi_i1,val_i1), FALSE);
			*map_res++ = *map_i1++;
			val_i1++;
		}
	}
	while ( val_i2 < end_i2 ) {
		BUNappend(res, BUNtail(bi_i2,val_i2), FALSE);
		*map_res++ = map_i2;
		val_i2++;
	}
	return res;
}
@c

@:sort_any2(rev,>=,<)@
@:sort_any2(,<=,>)@
static BAT *
MATsort_any( BAT **map, BAT **bats, int len, BUN cnt, int rev )
{
	BAT *res = 0, *in;
	int i;
	bte *mapT;
	BUN len1, len2;
	bte *map_in = NULL;

	*map = BATnew(TYPE_void, TYPE_bte, cnt);
	BATseqbase(*map, 0);
	mapT = (bte*)Tloc(*map, 0);
	/* merge */
	/* TODO: change into a tree version */
	in = bats[0];
	len1 = BATcount(in);
	for (i=1; i<len; i++) {
		len2 = BATcount(bats[i]);
		if (rev) {
			res = MATsortloop_rev( 
				mapT+cnt-len1-len2, 
		        	in, map_in, len1, 
				bats[i], i, len2);
		} else {
			res = MATsortloop_( 
				mapT+cnt-len1-len2, 
		        	in, map_in, len1, 
				bats[i], i, len2);
		}
		if (i != 1)
			BBPunfix(in->batCacheid);
		in = res;
		map_in = mapT+cnt-len1-len2;
		len1 += len2;
	}
	BATsetcount(*map, len1);
	return res;
}
@c

@= sort2
static int
MATsortloop_@1_@2( @1 *val_res, bte *map_res, @1 *val_i1, bte *map_i1, BUN cnt_i1, @1 *val_i2, bte map_i2, BUN cnt_i2 ) {

	@1 *end_i1 = val_i1 + cnt_i1;
	@1 *end_i2 = val_i2 + cnt_i2;

	if (map_i1 == NULL) {
		/* map_i1 = 0 */
		while ( val_i1 < end_i1 && val_i2 < end_i2) {
			if (*val_i1 @3 *val_i2) {
				*val_res++ = *val_i1++;
				*map_res++ = 0;
			} else if (*val_i1 @4 *val_i2) {
				*val_res++ = *val_i2++;
				*map_res++ = map_i2;
			}
		}
		while ( val_i1 < end_i1 ) {
			*val_res++ = *val_i1++;
			*map_res++ = 0;
		}
	} else {
		while ( val_i1 < end_i1 && val_i2 < end_i2) {
			if (*val_i1 @3 *val_i2) {
				*val_res++ = *val_i1++;
				*map_res++ = *map_i1++;
			} else if (*val_i1 @4 *val_i2) {
				*val_res++ = *val_i2++;
				*map_res++ = map_i2;
			}
		}
		while ( val_i1 < end_i1 ) {
			*val_res++ = *val_i1++;
			*map_res++ = *map_i1++;
		}
	}
	while ( val_i2 < end_i2 ) {
		*val_res++ = *val_i2++;
		*map_res++ = map_i2;
	}
	return 0;
}
@c

@= sort
@:sort2(@1,rev,>=,<)@
@:sort2(@1,,<=,>)@
static BAT *
MATsort_@1( BAT **map, BAT **bats, int len, BUN cnt, int rev )
{
	BAT *res;
	int i;
	@1 *resT, **batsT, *in;
	bte *mapT;
	BUN len1, len2;
	bte *map_in = NULL;

	res = BATnew(TYPE_void, bats[0]->ttype, cnt);
	*map = BATnew(TYPE_void, TYPE_bte, cnt);
	BATseqbase(res, 0);
	BATseqbase(*map, 0);
	resT = (@1*)Tloc(res, 0);
	mapT = (bte*)Tloc(*map, 0);
	batsT = (@1**)GDKmalloc(sizeof(@1*) * len);
	for (i=0; i<len; i++)
		batsT[i] = (@1*)Tloc(bats[i], 0);
	/* merge */
	in = batsT[0];
	len1 = BATcount(bats[0]);
	map_in = NULL;
	/* TODO: change into a tree version */
	for (i=1; i<len; i++) {
		len2 = BATcount(bats[i]);
		if (rev) {
			MATsortloop_@1_rev( resT+cnt-len1-len2, 
					mapT+cnt-len1-len2, 
				        in, map_in, len1, 
					batsT[i], i, len2);
		} else {
			MATsortloop_@1_( resT+cnt-len1-len2, 
					mapT+cnt-len1-len2, 
				        in, map_in, len1, 
					batsT[i], i, len2);
		}
		in = resT+cnt-len1-len2;
		map_in = mapT+cnt-len1-len2;
		len1 += len2;
	}
	BATsetcount(res, len1);
	BATsetcount(*map, len1);
	GDKfree(batsT);
	return res;
}
@c
@:sort(bte)@
@:sort(sht)@
@:sort(int)@
@:sort(lng)@

static str
MATsort(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci, int rev)
{
	bat *res_id = (bat*) getArgReference(stk,pci,0); /* result sorted */
	bat *map_id = (bat*) getArgReference(stk,pci,1); /* result map */
	BAT *res = NULL, *map = NULL;
	/* rest of the args are sorted parts, (excluding sorted and map) */
	BAT **bats = GDKzalloc(sizeof(BAT*) * pci->argc - 2);
	BUN pcnt = 0; 
	int i, len = pci->argc-2;

	(void) cntxt; (void) mb; (void) stk; 
	for (i=2; i<pci->argc; i++) {
		bat id = *(bat*) getArgReference(stk,pci,i);
		bats[i-2] = BATdescriptor(id);
		if (!bats[i-2])
			goto error;
		pcnt += BATcount(bats[i-2]);
	}

	if (ATOMstorage(bats[0]->ttype) <= TYPE_void) {
		/*error*/
	} else if (ATOMvarsized(bats[0]->ttype)) {
		res = MATsort_any(&map, bats, len, pcnt, rev);
	} else if (ATOMsize(bats[0]->ttype) == sizeof(bte)) {
		res = MATsort_bte(&map, bats, len, pcnt, rev);
	} else if (ATOMsize(bats[0]->ttype) == sizeof(sht)) {
		res = MATsort_sht(&map, bats, len, pcnt, rev);
	} else if (ATOMsize(bats[0]->ttype) == sizeof(int)) {
		res = MATsort_int(&map, bats, len, pcnt, rev);
	} else if (ATOMsize(bats[0]->ttype) == sizeof(lng)) {
		res = MATsort_lng(&map, bats, len, pcnt, rev);
	} else {
		res = MATsort_any(&map, bats, len, pcnt, rev);
	}
	if (res) 
		res->T->nonil = MATnonil(bats, len);
	if (res && rev)
		res->T->sorted = GDK_SORTED_REV;
error:
	if (bats) {
		for (i=0; i<len && bats[i]; i++)
			BBPunfix(bats[i]->batCacheid);
	}
	GDKfree(bats);
	if (map && res) {
		map->tsorted = 0;
		BBPkeepref( *map_id = map->batCacheid);
		BBPkeepref( *res_id = res->batCacheid);
		return MAL_SUCCEED;
	}
	if (map) BBPunfix(map->batCacheid);
	throw(SQL, "mat.sortTail","Cannot access descriptor");
}

str
MATsortTail(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	return MATsort( cntxt, mb, stk, pci, 0);
}

str
MATsortReverseTail(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	return MATsort( cntxt, mb, stk, pci, 1);
}

str
MATrefine_(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci, int rev)
{
	bat *rval_id = (bat*) getArgReference(stk,pci,0); /* result sorted */
	bat *rmap_id = (bat*) getArgReference(stk,pci,1); /* result map */
	bat val_id = *(bat*) getArgReference(stk,pci,2); /* sorted */
	bat map_id = *(bat*) getArgReference(stk,pci,3); /* map */
	BAT *res = NULL, *val = NULL, *map = NULL, *rmap = NULL, *r = NULL;
	/* rest of the args are sorted parts, (excluding sorted and map) */
	BAT **bats = GDKzalloc(sizeof(BAT*) * pci->argc - 4);
	BUN pcnt = 0; 
	int i, len = pci->argc-4;

	(void) cntxt; (void) mb; (void) stk; 
	map = BATdescriptor(map_id);
	val = BATdescriptor(val_id);
	if (!map || !val)
		goto error;
	for (i=4; i<pci->argc; i++) {
		bat id = *(bat*) getArgReference(stk,pci,i);
		bats[i-4] = BATdescriptor(id);
		if (!bats[i-4])
			goto error;
		pcnt += BATcount(bats[i-4]);
	}

	res = MATproject_( map, bats, len); 
	/* rmap = leftjoin(nres=refine(val, res), map); */
	if (rev) {
		rev = CTrefine_rev(&r, val, res); 
	} else {
		rev = CTrefine(&r, val, res); 
	}
	if (rev == GDK_SUCCEED) {
		BAT *ores = res;
		BAT *rr = BATmark(r, 0);
		rmap = BATleftjoin(BATmirror(rr), map, BATcount(map));
		res = BATmirror(BATmark(BATmirror(r), 0));
		BBPunfix(ores->batCacheid);
		BBPunfix(r->batCacheid);
		BBPunfix(rr->batCacheid);
	}
error:
	if (map)
		BBPunfix(map->batCacheid);
	if (val)
		BBPunfix(val->batCacheid);
	if (bats) {
		for (i=0; i<len && bats[i]; i++)
			BBPunfix(bats[i]->batCacheid);
		GDKfree(bats);
	}
	if (rmap && res) {
		BBPkeepref( *rmap_id = rmap->batCacheid);
		BBPkeepref( *rval_id = res->batCacheid);
		return MAL_SUCCEED;
	}
	if (rmap) BBPunfix(rmap->batCacheid);
	if (res) BBPunfix(res->batCacheid);
	throw(SQL, "mat.refine","Cannot access descriptor");
}

str
MATrefine(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	return MATrefine_( cntxt, mb, stk, pci, 0);
}

str
MATrefineReverse(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	return MATrefine_( cntxt, mb, stk, pci, 1);
}

@}
