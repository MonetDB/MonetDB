# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0.  If a copy of the MPL was not distributed with this
# file, You can obtain one at http://mozilla.org/MPL/2.0/.
#
# Copyright 1997 - July 2008 CWI, August 2008 - 2018 MonetDB B.V.

# This file was generated by using the script 01_batcalc.mal.sh.

module batcalc;

pattern iszero(b:bat[:bte]) :bat[:bit]
address CMDbatISZERO
comment "Unary check for zero over the tail of the bat";
pattern iszero(b:bat[:bte],s:bat[:oid]) :bat[:bit]
address CMDbatISZERO
comment "Unary check for zero over the tail of the bat with candidates list";

pattern iszero(b:bat[:sht]) :bat[:bit]
address CMDbatISZERO
comment "Unary check for zero over the tail of the bat";
pattern iszero(b:bat[:sht],s:bat[:oid]) :bat[:bit]
address CMDbatISZERO
comment "Unary check for zero over the tail of the bat with candidates list";

pattern iszero(b:bat[:int]) :bat[:bit]
address CMDbatISZERO
comment "Unary check for zero over the tail of the bat";
pattern iszero(b:bat[:int],s:bat[:oid]) :bat[:bit]
address CMDbatISZERO
comment "Unary check for zero over the tail of the bat with candidates list";

pattern iszero(b:bat[:lng]) :bat[:bit]
address CMDbatISZERO
comment "Unary check for zero over the tail of the bat";
pattern iszero(b:bat[:lng],s:bat[:oid]) :bat[:bit]
address CMDbatISZERO
comment "Unary check for zero over the tail of the bat with candidates list";

pattern iszero(b:bat[:flt]) :bat[:bit]
address CMDbatISZERO
comment "Unary check for zero over the tail of the bat";
pattern iszero(b:bat[:flt],s:bat[:oid]) :bat[:bit]
address CMDbatISZERO
comment "Unary check for zero over the tail of the bat with candidates list";

pattern iszero(b:bat[:dbl]) :bat[:bit]
address CMDbatISZERO
comment "Unary check for zero over the tail of the bat";
pattern iszero(b:bat[:dbl],s:bat[:oid]) :bat[:bit]
address CMDbatISZERO
comment "Unary check for zero over the tail of the bat with candidates list";


pattern isnil(b:bat[:any]) :bat[:bit]
address CMDbatISNIL
comment "Unary check for nil over the tail of the bat";
pattern isnil(b:bat[:any],s:bat[:oid]) :bat[:bit]
address CMDbatISNIL
comment "Unary check for nil over the tail of the bat with candidates list";

pattern isnotnil(b:bat[:any]) :bat[:bit]
address CMDbatISNOTNIL
comment "Unary check for notnil over the tail of the bat";
pattern isnotnil(b:bat[:any],s:bat[:oid]) :bat[:bit]
address CMDbatISNOTNIL
comment "Unary check for notnil over the tail of the bat with candidates list";


pattern not(b:bat[:bit]) :bat[:bit]
address CMDbatNOT
comment "Return the Boolean inverse";
pattern not(b:bat[:bit],s:bat[:oid]) :bat[:bit]
address CMDbatNOT
comment "Return the Boolean inverse with candidates list";

pattern not(b:bat[:bte]) :bat[:bte]
address CMDbatNOT
comment "Unary bitwise not over the tail of the bat";
pattern not(b:bat[:bte],s:bat[:oid]) :bat[:bte]
address CMDbatNOT
comment "Unary bitwise not over the tail of the bat with candidates list";

pattern not(b:bat[:sht]) :bat[:sht]
address CMDbatNOT
comment "Unary bitwise not over the tail of the bat";
pattern not(b:bat[:sht],s:bat[:oid]) :bat[:sht]
address CMDbatNOT
comment "Unary bitwise not over the tail of the bat with candidates list";

pattern not(b:bat[:int]) :bat[:int]
address CMDbatNOT
comment "Unary bitwise not over the tail of the bat";
pattern not(b:bat[:int],s:bat[:oid]) :bat[:int]
address CMDbatNOT
comment "Unary bitwise not over the tail of the bat with candidates list";

pattern not(b:bat[:lng]) :bat[:lng]
address CMDbatNOT
comment "Unary bitwise not over the tail of the bat";
pattern not(b:bat[:lng],s:bat[:oid]) :bat[:lng]
address CMDbatNOT
comment "Unary bitwise not over the tail of the bat with candidates list";


pattern sign(b:bat[:bte]) :bat[:bte]
address CMDbatSIGN
comment "Unary sign (-1,0,1) over the tail of the bat";
pattern sign(b:bat[:bte],s:bat[:oid]) :bat[:bte]
address CMDbatSIGN
comment "Unary sign (-1,0,1) over the tail of the bat with candidates list";

pattern sign(b:bat[:sht]) :bat[:bte]
address CMDbatSIGN
comment "Unary sign (-1,0,1) over the tail of the bat";
pattern sign(b:bat[:sht],s:bat[:oid]) :bat[:bte]
address CMDbatSIGN
comment "Unary sign (-1,0,1) over the tail of the bat with candidates list";

pattern sign(b:bat[:int]) :bat[:bte]
address CMDbatSIGN
comment "Unary sign (-1,0,1) over the tail of the bat";
pattern sign(b:bat[:int],s:bat[:oid]) :bat[:bte]
address CMDbatSIGN
comment "Unary sign (-1,0,1) over the tail of the bat with candidates list";

pattern sign(b:bat[:lng]) :bat[:bte]
address CMDbatSIGN
comment "Unary sign (-1,0,1) over the tail of the bat";
pattern sign(b:bat[:lng],s:bat[:oid]) :bat[:bte]
address CMDbatSIGN
comment "Unary sign (-1,0,1) over the tail of the bat with candidates list";

pattern sign(b:bat[:flt]) :bat[:bte]
address CMDbatSIGN
comment "Unary sign (-1,0,1) over the tail of the bat";
pattern sign(b:bat[:flt],s:bat[:oid]) :bat[:bte]
address CMDbatSIGN
comment "Unary sign (-1,0,1) over the tail of the bat with candidates list";

pattern sign(b:bat[:dbl]) :bat[:bte]
address CMDbatSIGN
comment "Unary sign (-1,0,1) over the tail of the bat";
pattern sign(b:bat[:dbl],s:bat[:oid]) :bat[:bte]
address CMDbatSIGN
comment "Unary sign (-1,0,1) over the tail of the bat with candidates list";


pattern abs(b:bat[:bte]) :bat[:bte]
address CMDbatABS
comment "Unary abs over the tail of the bat";
pattern abs(b:bat[:bte],s:bat[:oid]) :bat[:bte]
address CMDbatABS
comment "Unary abs over the tail of the bat with candidates list";

pattern abs(b:bat[:sht]) :bat[:sht]
address CMDbatABS
comment "Unary abs over the tail of the bat";
pattern abs(b:bat[:sht],s:bat[:oid]) :bat[:sht]
address CMDbatABS
comment "Unary abs over the tail of the bat with candidates list";

pattern abs(b:bat[:int]) :bat[:int]
address CMDbatABS
comment "Unary abs over the tail of the bat";
pattern abs(b:bat[:int],s:bat[:oid]) :bat[:int]
address CMDbatABS
comment "Unary abs over the tail of the bat with candidates list";

pattern abs(b:bat[:lng]) :bat[:lng]
address CMDbatABS
comment "Unary abs over the tail of the bat";
pattern abs(b:bat[:lng],s:bat[:oid]) :bat[:lng]
address CMDbatABS
comment "Unary abs over the tail of the bat with candidates list";

pattern abs(b:bat[:flt]) :bat[:flt]
address CMDbatABS
comment "Unary abs over the tail of the bat";
pattern abs(b:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatABS
comment "Unary abs over the tail of the bat with candidates list";

pattern abs(b:bat[:dbl]) :bat[:dbl]
address CMDbatABS
comment "Unary abs over the tail of the bat";
pattern abs(b:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatABS
comment "Unary abs over the tail of the bat with candidates list";


pattern -(b:bat[:bte]) :bat[:bte]
address CMDbatNEG
comment "Unary neg over the tail of the bat";
pattern -(b:bat[:bte],s:bat[:oid]) :bat[:bte]
address CMDbatNEG
comment "Unary neg over the tail of the bat with candidates list";

pattern -(b:bat[:sht]) :bat[:sht]
address CMDbatNEG
comment "Unary neg over the tail of the bat";
pattern -(b:bat[:sht],s:bat[:oid]) :bat[:sht]
address CMDbatNEG
comment "Unary neg over the tail of the bat with candidates list";

pattern -(b:bat[:int]) :bat[:int]
address CMDbatNEG
comment "Unary neg over the tail of the bat";
pattern -(b:bat[:int],s:bat[:oid]) :bat[:int]
address CMDbatNEG
comment "Unary neg over the tail of the bat with candidates list";

pattern -(b:bat[:lng]) :bat[:lng]
address CMDbatNEG
comment "Unary neg over the tail of the bat";
pattern -(b:bat[:lng],s:bat[:oid]) :bat[:lng]
address CMDbatNEG
comment "Unary neg over the tail of the bat with candidates list";

pattern -(b:bat[:flt]) :bat[:flt]
address CMDbatNEG
comment "Unary neg over the tail of the bat";
pattern -(b:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatNEG
comment "Unary neg over the tail of the bat with candidates list";

pattern -(b:bat[:dbl]) :bat[:dbl]
address CMDbatNEG
comment "Unary neg over the tail of the bat";
pattern -(b:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatNEG
comment "Unary neg over the tail of the bat with candidates list";


pattern ++(b:bat[:bte]) :bat[:bte]
address CMDbatINCR
comment "Unary increment over the tail of the bat";
pattern ++(b:bat[:bte],s:bat[:oid]) :bat[:bte]
address CMDbatINCR
comment "Unary increment over the tail of the bat with candidates list";

pattern ++(b:bat[:sht]) :bat[:sht]
address CMDbatINCR
comment "Unary increment over the tail of the bat";
pattern ++(b:bat[:sht],s:bat[:oid]) :bat[:sht]
address CMDbatINCR
comment "Unary increment over the tail of the bat with candidates list";

pattern ++(b:bat[:int]) :bat[:int]
address CMDbatINCR
comment "Unary increment over the tail of the bat";
pattern ++(b:bat[:int],s:bat[:oid]) :bat[:int]
address CMDbatINCR
comment "Unary increment over the tail of the bat with candidates list";

pattern ++(b:bat[:lng]) :bat[:lng]
address CMDbatINCR
comment "Unary increment over the tail of the bat";
pattern ++(b:bat[:lng],s:bat[:oid]) :bat[:lng]
address CMDbatINCR
comment "Unary increment over the tail of the bat with candidates list";

pattern ++(b:bat[:flt]) :bat[:flt]
address CMDbatINCR
comment "Unary increment over the tail of the bat";
pattern ++(b:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatINCR
comment "Unary increment over the tail of the bat with candidates list";

pattern ++(b:bat[:dbl]) :bat[:dbl]
address CMDbatINCR
comment "Unary increment over the tail of the bat";
pattern ++(b:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatINCR
comment "Unary increment over the tail of the bat with candidates list";


pattern --(b:bat[:bte]) :bat[:bte]
address CMDbatDECR
comment "Unary decrement over the tail of the bat";
pattern --(b:bat[:bte],s:bat[:oid]) :bat[:bte]
address CMDbatDECR
comment "Unary decrement over the tail of the bat with candidates list";

pattern --(b:bat[:sht]) :bat[:sht]
address CMDbatDECR
comment "Unary decrement over the tail of the bat";
pattern --(b:bat[:sht],s:bat[:oid]) :bat[:sht]
address CMDbatDECR
comment "Unary decrement over the tail of the bat with candidates list";

pattern --(b:bat[:int]) :bat[:int]
address CMDbatDECR
comment "Unary decrement over the tail of the bat";
pattern --(b:bat[:int],s:bat[:oid]) :bat[:int]
address CMDbatDECR
comment "Unary decrement over the tail of the bat with candidates list";

pattern --(b:bat[:lng]) :bat[:lng]
address CMDbatDECR
comment "Unary decrement over the tail of the bat";
pattern --(b:bat[:lng],s:bat[:oid]) :bat[:lng]
address CMDbatDECR
comment "Unary decrement over the tail of the bat with candidates list";

pattern --(b:bat[:flt]) :bat[:flt]
address CMDbatDECR
comment "Unary decrement over the tail of the bat";
pattern --(b:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatDECR
comment "Unary decrement over the tail of the bat with candidates list";

pattern --(b:bat[:dbl]) :bat[:dbl]
address CMDbatDECR
comment "Unary decrement over the tail of the bat";
pattern --(b:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatDECR
comment "Unary decrement over the tail of the bat with candidates list";


pattern min(b1:bat[:any_1],b2:bat[:any_1]) :bat[:any_1]
address CMDbatMIN
comment "Return bat with minimum value of each pair of inputs";
pattern min(b1:bat[:any_1],b2:bat[:any_1],s:bat[:oid]) :bat[:any_1]
address CMDbatMIN
comment "Return bat with minimum value of each pair of inputs";
pattern min(b:bat[:any_1],v:any_1) :bat[:any_1]
address CMDbatMIN
comment "Return bat with minimum value of each pair of inputs";
pattern min(b:bat[:any_1],v:any_1,s:bat[:oid]) :bat[:any_1]
address CMDbatMIN
comment "Return bat with minimum value of each pair of inputs";
pattern min(v:any_1,b:bat[:any_1]) :bat[:any_1]
address CMDbatMIN
comment "Return bat with minimum value of each pair of inputs";
pattern min(v:any_1,b:bat[:any_1],s:bat[:oid]) :bat[:any_1]
address CMDbatMIN
comment "Return bat with minimum value of each pair of inputs";

pattern min_no_nil(b1:bat[:any_1],b2:bat[:any_1]) :bat[:any_1]
address CMDbatMIN_no_nil
comment "Return bat with minimum value of each pair of inputs, ignoring nil values";
pattern min_no_nil(b1:bat[:any_1],b2:bat[:any_1],s:bat[:oid]) :bat[:any_1]
address CMDbatMIN_no_nil
comment "Return bat with minimum value of each pair of inputs, ignoring nil values";
pattern min_no_nil(b:bat[:any_1],v:any_1) :bat[:any_1]
address CMDbatMIN_no_nil
comment "Return bat with minimum value of each pair of inputs, ignoring nil values";
pattern min_no_nil(b:bat[:any_1],v:any_1,s:bat[:oid]) :bat[:any_1]
address CMDbatMIN_no_nil
comment "Return bat with minimum value of each pair of inputs, ignoring nil values";
pattern min_no_nil(v:any_1,b:bat[:any_1]) :bat[:any_1]
address CMDbatMIN_no_nil
comment "Return bat with minimum value of each pair of inputs, ignoring nil values";
pattern min_no_nil(v:any_1,b:bat[:any_1],s:bat[:oid]) :bat[:any_1]
address CMDbatMIN_no_nil
comment "Return bat with minimum value of each pair of inputs, ignoring nil values";

pattern max(b1:bat[:any_1],b2:bat[:any_1]) :bat[:any_1]
address CMDbatMAX
comment "Return bat with maximum value of each pair of inputs";
pattern max(b1:bat[:any_1],b2:bat[:any_1],s:bat[:oid]) :bat[:any_1]
address CMDbatMAX
comment "Return bat with maximum value of each pair of inputs";
pattern max(b:bat[:any_1],v:any_1) :bat[:any_1]
address CMDbatMAX
comment "Return bat with maximum value of each pair of inputs";
pattern max(b:bat[:any_1],v:any_1,s:bat[:oid]) :bat[:any_1]
address CMDbatMAX
comment "Return bat with maximum value of each pair of inputs";
pattern max(v:any_1,b:bat[:any_1]) :bat[:any_1]
address CMDbatMAX
comment "Return bat with maximum value of each pair of inputs";
pattern max(v:any_1,b:bat[:any_1],s:bat[:oid]) :bat[:any_1]
address CMDbatMAX
comment "Return bat with maximum value of each pair of inputs";

pattern max_no_nil(b1:bat[:any_1],b2:bat[:any_1]) :bat[:any_1]
address CMDbatMAX_no_nil
comment "Return bat with maximum value of each pair of inputs, ignoring nil values";
pattern max_no_nil(b1:bat[:any_1],b2:bat[:any_1],s:bat[:oid]) :bat[:any_1]
address CMDbatMAX_no_nil
comment "Return bat with maximum value of each pair of inputs, ignoring nil values";
pattern max_no_nil(b:bat[:any_1],v:any_1) :bat[:any_1]
address CMDbatMAX_no_nil
comment "Return bat with maximum value of each pair of inputs, ignoring nil values";
pattern max_no_nil(b:bat[:any_1],v:any_1,s:bat[:oid]) :bat[:any_1]
address CMDbatMAX_no_nil
comment "Return bat with maximum value of each pair of inputs, ignoring nil values";
pattern max_no_nil(v:any_1,b:bat[:any_1]) :bat[:any_1]
address CMDbatMAX_no_nil
comment "Return bat with maximum value of each pair of inputs, ignoring nil values";
pattern max_no_nil(v:any_1,b:bat[:any_1],s:bat[:oid]) :bat[:any_1]
address CMDbatMAX_no_nil
comment "Return bat with maximum value of each pair of inputs, ignoring nil values";


pattern +(b1:bat[:bte],b2:bat[:bte]) :bat[:sht]
address CMDbatADDenlarge
comment "Return B1 + B2, guarantee no overflow by returning larger type";
pattern +(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]) :bat[:sht]
address CMDbatADDenlarge
comment "Return B1 + B2 with candidates list, guarantee no overflow by returning larger type";
pattern +(b:bat[:bte],v:bte) :bat[:sht]
address CMDbatADDenlarge
comment "Return B + V, guarantee no overflow by returning larger type";
pattern +(b:bat[:bte],v:bte,s:bat[:oid]) :bat[:sht]
address CMDbatADDenlarge
comment "Return B + V with candidates list, guarantee no overflow by returning larger type";
pattern +(v:bte,b:bat[:bte]) :bat[:sht]
address CMDbatADDenlarge
comment "Return V + B, guarantee no overflow by returning larger type";
pattern +(v:bte,b:bat[:bte],s:bat[:oid]) :bat[:sht]
address CMDbatADDenlarge
comment "Return V + B with candidates list, guarantee no overflow by returning larger type";

pattern +(b1:bat[:bte],b2:bat[:sht]) :bat[:int]
address CMDbatADDenlarge
comment "Return B1 + B2, guarantee no overflow by returning larger type";
pattern +(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]) :bat[:int]
address CMDbatADDenlarge
comment "Return B1 + B2 with candidates list, guarantee no overflow by returning larger type";
pattern +(b:bat[:bte],v:sht) :bat[:int]
address CMDbatADDenlarge
comment "Return B + V, guarantee no overflow by returning larger type";
pattern +(b:bat[:bte],v:sht,s:bat[:oid]) :bat[:int]
address CMDbatADDenlarge
comment "Return B + V with candidates list, guarantee no overflow by returning larger type";
pattern +(v:bte,b:bat[:sht]) :bat[:int]
address CMDbatADDenlarge
comment "Return V + B, guarantee no overflow by returning larger type";
pattern +(v:bte,b:bat[:sht],s:bat[:oid]) :bat[:int]
address CMDbatADDenlarge
comment "Return V + B with candidates list, guarantee no overflow by returning larger type";

pattern +(b1:bat[:bte],b2:bat[:int]) :bat[:lng]
address CMDbatADDenlarge
comment "Return B1 + B2, guarantee no overflow by returning larger type";
pattern +(b1:bat[:bte],b2:bat[:int],s:bat[:oid]) :bat[:lng]
address CMDbatADDenlarge
comment "Return B1 + B2 with candidates list, guarantee no overflow by returning larger type";
pattern +(b:bat[:bte],v:int) :bat[:lng]
address CMDbatADDenlarge
comment "Return B + V, guarantee no overflow by returning larger type";
pattern +(b:bat[:bte],v:int,s:bat[:oid]) :bat[:lng]
address CMDbatADDenlarge
comment "Return B + V with candidates list, guarantee no overflow by returning larger type";
pattern +(v:bte,b:bat[:int]) :bat[:lng]
address CMDbatADDenlarge
comment "Return V + B, guarantee no overflow by returning larger type";
pattern +(v:bte,b:bat[:int],s:bat[:oid]) :bat[:lng]
address CMDbatADDenlarge
comment "Return V + B with candidates list, guarantee no overflow by returning larger type";

pattern +(b1:bat[:bte],b2:bat[:flt]) :bat[:dbl]
address CMDbatADDenlarge
comment "Return B1 + B2, guarantee no overflow by returning larger type";
pattern +(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]) :bat[:dbl]
address CMDbatADDenlarge
comment "Return B1 + B2 with candidates list, guarantee no overflow by returning larger type";
pattern +(b:bat[:bte],v:flt) :bat[:dbl]
address CMDbatADDenlarge
comment "Return B + V, guarantee no overflow by returning larger type";
pattern +(b:bat[:bte],v:flt,s:bat[:oid]) :bat[:dbl]
address CMDbatADDenlarge
comment "Return B + V with candidates list, guarantee no overflow by returning larger type";
pattern +(v:bte,b:bat[:flt]) :bat[:dbl]
address CMDbatADDenlarge
comment "Return V + B, guarantee no overflow by returning larger type";
pattern +(v:bte,b:bat[:flt],s:bat[:oid]) :bat[:dbl]
address CMDbatADDenlarge
comment "Return V + B with candidates list, guarantee no overflow by returning larger type";

pattern +(b1:bat[:sht],b2:bat[:bte]) :bat[:int]
address CMDbatADDenlarge
comment "Return B1 + B2, guarantee no overflow by returning larger type";
pattern +(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]) :bat[:int]
address CMDbatADDenlarge
comment "Return B1 + B2 with candidates list, guarantee no overflow by returning larger type";
pattern +(b:bat[:sht],v:bte) :bat[:int]
address CMDbatADDenlarge
comment "Return B + V, guarantee no overflow by returning larger type";
pattern +(b:bat[:sht],v:bte,s:bat[:oid]) :bat[:int]
address CMDbatADDenlarge
comment "Return B + V with candidates list, guarantee no overflow by returning larger type";
pattern +(v:sht,b:bat[:bte]) :bat[:int]
address CMDbatADDenlarge
comment "Return V + B, guarantee no overflow by returning larger type";
pattern +(v:sht,b:bat[:bte],s:bat[:oid]) :bat[:int]
address CMDbatADDenlarge
comment "Return V + B with candidates list, guarantee no overflow by returning larger type";

pattern +(b1:bat[:sht],b2:bat[:sht]) :bat[:int]
address CMDbatADDenlarge
comment "Return B1 + B2, guarantee no overflow by returning larger type";
pattern +(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]) :bat[:int]
address CMDbatADDenlarge
comment "Return B1 + B2 with candidates list, guarantee no overflow by returning larger type";
pattern +(b:bat[:sht],v:sht) :bat[:int]
address CMDbatADDenlarge
comment "Return B + V, guarantee no overflow by returning larger type";
pattern +(b:bat[:sht],v:sht,s:bat[:oid]) :bat[:int]
address CMDbatADDenlarge
comment "Return B + V with candidates list, guarantee no overflow by returning larger type";
pattern +(v:sht,b:bat[:sht]) :bat[:int]
address CMDbatADDenlarge
comment "Return V + B, guarantee no overflow by returning larger type";
pattern +(v:sht,b:bat[:sht],s:bat[:oid]) :bat[:int]
address CMDbatADDenlarge
comment "Return V + B with candidates list, guarantee no overflow by returning larger type";

pattern +(b1:bat[:sht],b2:bat[:int]) :bat[:lng]
address CMDbatADDenlarge
comment "Return B1 + B2, guarantee no overflow by returning larger type";
pattern +(b1:bat[:sht],b2:bat[:int],s:bat[:oid]) :bat[:lng]
address CMDbatADDenlarge
comment "Return B1 + B2 with candidates list, guarantee no overflow by returning larger type";
pattern +(b:bat[:sht],v:int) :bat[:lng]
address CMDbatADDenlarge
comment "Return B + V, guarantee no overflow by returning larger type";
pattern +(b:bat[:sht],v:int,s:bat[:oid]) :bat[:lng]
address CMDbatADDenlarge
comment "Return B + V with candidates list, guarantee no overflow by returning larger type";
pattern +(v:sht,b:bat[:int]) :bat[:lng]
address CMDbatADDenlarge
comment "Return V + B, guarantee no overflow by returning larger type";
pattern +(v:sht,b:bat[:int],s:bat[:oid]) :bat[:lng]
address CMDbatADDenlarge
comment "Return V + B with candidates list, guarantee no overflow by returning larger type";

pattern +(b1:bat[:sht],b2:bat[:flt]) :bat[:dbl]
address CMDbatADDenlarge
comment "Return B1 + B2, guarantee no overflow by returning larger type";
pattern +(b1:bat[:sht],b2:bat[:flt],s:bat[:oid]) :bat[:dbl]
address CMDbatADDenlarge
comment "Return B1 + B2 with candidates list, guarantee no overflow by returning larger type";
pattern +(b:bat[:sht],v:flt) :bat[:dbl]
address CMDbatADDenlarge
comment "Return B + V, guarantee no overflow by returning larger type";
pattern +(b:bat[:sht],v:flt,s:bat[:oid]) :bat[:dbl]
address CMDbatADDenlarge
comment "Return B + V with candidates list, guarantee no overflow by returning larger type";
pattern +(v:sht,b:bat[:flt]) :bat[:dbl]
address CMDbatADDenlarge
comment "Return V + B, guarantee no overflow by returning larger type";
pattern +(v:sht,b:bat[:flt],s:bat[:oid]) :bat[:dbl]
address CMDbatADDenlarge
comment "Return V + B with candidates list, guarantee no overflow by returning larger type";

pattern +(b1:bat[:int],b2:bat[:bte]) :bat[:lng]
address CMDbatADDenlarge
comment "Return B1 + B2, guarantee no overflow by returning larger type";
pattern +(b1:bat[:int],b2:bat[:bte],s:bat[:oid]) :bat[:lng]
address CMDbatADDenlarge
comment "Return B1 + B2 with candidates list, guarantee no overflow by returning larger type";
pattern +(b:bat[:int],v:bte) :bat[:lng]
address CMDbatADDenlarge
comment "Return B + V, guarantee no overflow by returning larger type";
pattern +(b:bat[:int],v:bte,s:bat[:oid]) :bat[:lng]
address CMDbatADDenlarge
comment "Return B + V with candidates list, guarantee no overflow by returning larger type";
pattern +(v:int,b:bat[:bte]) :bat[:lng]
address CMDbatADDenlarge
comment "Return V + B, guarantee no overflow by returning larger type";
pattern +(v:int,b:bat[:bte],s:bat[:oid]) :bat[:lng]
address CMDbatADDenlarge
comment "Return V + B with candidates list, guarantee no overflow by returning larger type";

pattern +(b1:bat[:int],b2:bat[:sht]) :bat[:lng]
address CMDbatADDenlarge
comment "Return B1 + B2, guarantee no overflow by returning larger type";
pattern +(b1:bat[:int],b2:bat[:sht],s:bat[:oid]) :bat[:lng]
address CMDbatADDenlarge
comment "Return B1 + B2 with candidates list, guarantee no overflow by returning larger type";
pattern +(b:bat[:int],v:sht) :bat[:lng]
address CMDbatADDenlarge
comment "Return B + V, guarantee no overflow by returning larger type";
pattern +(b:bat[:int],v:sht,s:bat[:oid]) :bat[:lng]
address CMDbatADDenlarge
comment "Return B + V with candidates list, guarantee no overflow by returning larger type";
pattern +(v:int,b:bat[:sht]) :bat[:lng]
address CMDbatADDenlarge
comment "Return V + B, guarantee no overflow by returning larger type";
pattern +(v:int,b:bat[:sht],s:bat[:oid]) :bat[:lng]
address CMDbatADDenlarge
comment "Return V + B with candidates list, guarantee no overflow by returning larger type";

pattern +(b1:bat[:int],b2:bat[:int]) :bat[:lng]
address CMDbatADDenlarge
comment "Return B1 + B2, guarantee no overflow by returning larger type";
pattern +(b1:bat[:int],b2:bat[:int],s:bat[:oid]) :bat[:lng]
address CMDbatADDenlarge
comment "Return B1 + B2 with candidates list, guarantee no overflow by returning larger type";
pattern +(b:bat[:int],v:int) :bat[:lng]
address CMDbatADDenlarge
comment "Return B + V, guarantee no overflow by returning larger type";
pattern +(b:bat[:int],v:int,s:bat[:oid]) :bat[:lng]
address CMDbatADDenlarge
comment "Return B + V with candidates list, guarantee no overflow by returning larger type";
pattern +(v:int,b:bat[:int]) :bat[:lng]
address CMDbatADDenlarge
comment "Return V + B, guarantee no overflow by returning larger type";
pattern +(v:int,b:bat[:int],s:bat[:oid]) :bat[:lng]
address CMDbatADDenlarge
comment "Return V + B with candidates list, guarantee no overflow by returning larger type";

pattern +(b1:bat[:int],b2:bat[:flt]) :bat[:dbl]
address CMDbatADDenlarge
comment "Return B1 + B2, guarantee no overflow by returning larger type";
pattern +(b1:bat[:int],b2:bat[:flt],s:bat[:oid]) :bat[:dbl]
address CMDbatADDenlarge
comment "Return B1 + B2 with candidates list, guarantee no overflow by returning larger type";
pattern +(b:bat[:int],v:flt) :bat[:dbl]
address CMDbatADDenlarge
comment "Return B + V, guarantee no overflow by returning larger type";
pattern +(b:bat[:int],v:flt,s:bat[:oid]) :bat[:dbl]
address CMDbatADDenlarge
comment "Return B + V with candidates list, guarantee no overflow by returning larger type";
pattern +(v:int,b:bat[:flt]) :bat[:dbl]
address CMDbatADDenlarge
comment "Return V + B, guarantee no overflow by returning larger type";
pattern +(v:int,b:bat[:flt],s:bat[:oid]) :bat[:dbl]
address CMDbatADDenlarge
comment "Return V + B with candidates list, guarantee no overflow by returning larger type";

pattern +(b1:bat[:lng],b2:bat[:flt]) :bat[:dbl]
address CMDbatADDenlarge
comment "Return B1 + B2, guarantee no overflow by returning larger type";
pattern +(b1:bat[:lng],b2:bat[:flt],s:bat[:oid]) :bat[:dbl]
address CMDbatADDenlarge
comment "Return B1 + B2 with candidates list, guarantee no overflow by returning larger type";
pattern +(b:bat[:lng],v:flt) :bat[:dbl]
address CMDbatADDenlarge
comment "Return B + V, guarantee no overflow by returning larger type";
pattern +(b:bat[:lng],v:flt,s:bat[:oid]) :bat[:dbl]
address CMDbatADDenlarge
comment "Return B + V with candidates list, guarantee no overflow by returning larger type";
pattern +(v:lng,b:bat[:flt]) :bat[:dbl]
address CMDbatADDenlarge
comment "Return V + B, guarantee no overflow by returning larger type";
pattern +(v:lng,b:bat[:flt],s:bat[:oid]) :bat[:dbl]
address CMDbatADDenlarge
comment "Return V + B with candidates list, guarantee no overflow by returning larger type";

pattern +(b1:bat[:flt],b2:bat[:bte]) :bat[:dbl]
address CMDbatADDenlarge
comment "Return B1 + B2, guarantee no overflow by returning larger type";
pattern +(b1:bat[:flt],b2:bat[:bte],s:bat[:oid]) :bat[:dbl]
address CMDbatADDenlarge
comment "Return B1 + B2 with candidates list, guarantee no overflow by returning larger type";
pattern +(b:bat[:flt],v:bte) :bat[:dbl]
address CMDbatADDenlarge
comment "Return B + V, guarantee no overflow by returning larger type";
pattern +(b:bat[:flt],v:bte,s:bat[:oid]) :bat[:dbl]
address CMDbatADDenlarge
comment "Return B + V with candidates list, guarantee no overflow by returning larger type";
pattern +(v:flt,b:bat[:bte]) :bat[:dbl]
address CMDbatADDenlarge
comment "Return V + B, guarantee no overflow by returning larger type";
pattern +(v:flt,b:bat[:bte],s:bat[:oid]) :bat[:dbl]
address CMDbatADDenlarge
comment "Return V + B with candidates list, guarantee no overflow by returning larger type";

pattern +(b1:bat[:flt],b2:bat[:sht]) :bat[:dbl]
address CMDbatADDenlarge
comment "Return B1 + B2, guarantee no overflow by returning larger type";
pattern +(b1:bat[:flt],b2:bat[:sht],s:bat[:oid]) :bat[:dbl]
address CMDbatADDenlarge
comment "Return B1 + B2 with candidates list, guarantee no overflow by returning larger type";
pattern +(b:bat[:flt],v:sht) :bat[:dbl]
address CMDbatADDenlarge
comment "Return B + V, guarantee no overflow by returning larger type";
pattern +(b:bat[:flt],v:sht,s:bat[:oid]) :bat[:dbl]
address CMDbatADDenlarge
comment "Return B + V with candidates list, guarantee no overflow by returning larger type";
pattern +(v:flt,b:bat[:sht]) :bat[:dbl]
address CMDbatADDenlarge
comment "Return V + B, guarantee no overflow by returning larger type";
pattern +(v:flt,b:bat[:sht],s:bat[:oid]) :bat[:dbl]
address CMDbatADDenlarge
comment "Return V + B with candidates list, guarantee no overflow by returning larger type";

pattern +(b1:bat[:flt],b2:bat[:int]) :bat[:dbl]
address CMDbatADDenlarge
comment "Return B1 + B2, guarantee no overflow by returning larger type";
pattern +(b1:bat[:flt],b2:bat[:int],s:bat[:oid]) :bat[:dbl]
address CMDbatADDenlarge
comment "Return B1 + B2 with candidates list, guarantee no overflow by returning larger type";
pattern +(b:bat[:flt],v:int) :bat[:dbl]
address CMDbatADDenlarge
comment "Return B + V, guarantee no overflow by returning larger type";
pattern +(b:bat[:flt],v:int,s:bat[:oid]) :bat[:dbl]
address CMDbatADDenlarge
comment "Return B + V with candidates list, guarantee no overflow by returning larger type";
pattern +(v:flt,b:bat[:int]) :bat[:dbl]
address CMDbatADDenlarge
comment "Return V + B, guarantee no overflow by returning larger type";
pattern +(v:flt,b:bat[:int],s:bat[:oid]) :bat[:dbl]
address CMDbatADDenlarge
comment "Return V + B with candidates list, guarantee no overflow by returning larger type";

pattern +(b1:bat[:flt],b2:bat[:lng]) :bat[:dbl]
address CMDbatADDenlarge
comment "Return B1 + B2, guarantee no overflow by returning larger type";
pattern +(b1:bat[:flt],b2:bat[:lng],s:bat[:oid]) :bat[:dbl]
address CMDbatADDenlarge
comment "Return B1 + B2 with candidates list, guarantee no overflow by returning larger type";
pattern +(b:bat[:flt],v:lng) :bat[:dbl]
address CMDbatADDenlarge
comment "Return B + V, guarantee no overflow by returning larger type";
pattern +(b:bat[:flt],v:lng,s:bat[:oid]) :bat[:dbl]
address CMDbatADDenlarge
comment "Return B + V with candidates list, guarantee no overflow by returning larger type";
pattern +(v:flt,b:bat[:lng]) :bat[:dbl]
address CMDbatADDenlarge
comment "Return V + B, guarantee no overflow by returning larger type";
pattern +(v:flt,b:bat[:lng],s:bat[:oid]) :bat[:dbl]
address CMDbatADDenlarge
comment "Return V + B with candidates list, guarantee no overflow by returning larger type";

pattern +(b1:bat[:flt],b2:bat[:flt]) :bat[:dbl]
address CMDbatADDenlarge
comment "Return B1 + B2, guarantee no overflow by returning larger type";
pattern +(b1:bat[:flt],b2:bat[:flt],s:bat[:oid]) :bat[:dbl]
address CMDbatADDenlarge
comment "Return B1 + B2 with candidates list, guarantee no overflow by returning larger type";
pattern +(b:bat[:flt],v:flt) :bat[:dbl]
address CMDbatADDenlarge
comment "Return B + V, guarantee no overflow by returning larger type";
pattern +(b:bat[:flt],v:flt,s:bat[:oid]) :bat[:dbl]
address CMDbatADDenlarge
comment "Return B + V with candidates list, guarantee no overflow by returning larger type";
pattern +(v:flt,b:bat[:flt]) :bat[:dbl]
address CMDbatADDenlarge
comment "Return V + B, guarantee no overflow by returning larger type";
pattern +(v:flt,b:bat[:flt],s:bat[:oid]) :bat[:dbl]
address CMDbatADDenlarge
comment "Return V + B with candidates list, guarantee no overflow by returning larger type";


pattern -(b1:bat[:bte],b2:bat[:bte]) :bat[:sht]
address CMDbatSUBenlarge
comment "Return B1 - B2, guarantee no overflow by returning larger type";
pattern -(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]) :bat[:sht]
address CMDbatSUBenlarge
comment "Return B1 - B2 with candidates list, guarantee no overflow by returning larger type";
pattern -(b:bat[:bte],v:bte) :bat[:sht]
address CMDbatSUBenlarge
comment "Return B - V, guarantee no overflow by returning larger type";
pattern -(b:bat[:bte],v:bte,s:bat[:oid]) :bat[:sht]
address CMDbatSUBenlarge
comment "Return B - V with candidates list, guarantee no overflow by returning larger type";
pattern -(v:bte,b:bat[:bte]) :bat[:sht]
address CMDbatSUBenlarge
comment "Return V - B, guarantee no overflow by returning larger type";
pattern -(v:bte,b:bat[:bte],s:bat[:oid]) :bat[:sht]
address CMDbatSUBenlarge
comment "Return V - B with candidates list, guarantee no overflow by returning larger type";

pattern -(b1:bat[:bte],b2:bat[:sht]) :bat[:int]
address CMDbatSUBenlarge
comment "Return B1 - B2, guarantee no overflow by returning larger type";
pattern -(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]) :bat[:int]
address CMDbatSUBenlarge
comment "Return B1 - B2 with candidates list, guarantee no overflow by returning larger type";
pattern -(b:bat[:bte],v:sht) :bat[:int]
address CMDbatSUBenlarge
comment "Return B - V, guarantee no overflow by returning larger type";
pattern -(b:bat[:bte],v:sht,s:bat[:oid]) :bat[:int]
address CMDbatSUBenlarge
comment "Return B - V with candidates list, guarantee no overflow by returning larger type";
pattern -(v:bte,b:bat[:sht]) :bat[:int]
address CMDbatSUBenlarge
comment "Return V - B, guarantee no overflow by returning larger type";
pattern -(v:bte,b:bat[:sht],s:bat[:oid]) :bat[:int]
address CMDbatSUBenlarge
comment "Return V - B with candidates list, guarantee no overflow by returning larger type";

pattern -(b1:bat[:bte],b2:bat[:int]) :bat[:lng]
address CMDbatSUBenlarge
comment "Return B1 - B2, guarantee no overflow by returning larger type";
pattern -(b1:bat[:bte],b2:bat[:int],s:bat[:oid]) :bat[:lng]
address CMDbatSUBenlarge
comment "Return B1 - B2 with candidates list, guarantee no overflow by returning larger type";
pattern -(b:bat[:bte],v:int) :bat[:lng]
address CMDbatSUBenlarge
comment "Return B - V, guarantee no overflow by returning larger type";
pattern -(b:bat[:bte],v:int,s:bat[:oid]) :bat[:lng]
address CMDbatSUBenlarge
comment "Return B - V with candidates list, guarantee no overflow by returning larger type";
pattern -(v:bte,b:bat[:int]) :bat[:lng]
address CMDbatSUBenlarge
comment "Return V - B, guarantee no overflow by returning larger type";
pattern -(v:bte,b:bat[:int],s:bat[:oid]) :bat[:lng]
address CMDbatSUBenlarge
comment "Return V - B with candidates list, guarantee no overflow by returning larger type";

pattern -(b1:bat[:bte],b2:bat[:flt]) :bat[:dbl]
address CMDbatSUBenlarge
comment "Return B1 - B2, guarantee no overflow by returning larger type";
pattern -(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]) :bat[:dbl]
address CMDbatSUBenlarge
comment "Return B1 - B2 with candidates list, guarantee no overflow by returning larger type";
pattern -(b:bat[:bte],v:flt) :bat[:dbl]
address CMDbatSUBenlarge
comment "Return B - V, guarantee no overflow by returning larger type";
pattern -(b:bat[:bte],v:flt,s:bat[:oid]) :bat[:dbl]
address CMDbatSUBenlarge
comment "Return B - V with candidates list, guarantee no overflow by returning larger type";
pattern -(v:bte,b:bat[:flt]) :bat[:dbl]
address CMDbatSUBenlarge
comment "Return V - B, guarantee no overflow by returning larger type";
pattern -(v:bte,b:bat[:flt],s:bat[:oid]) :bat[:dbl]
address CMDbatSUBenlarge
comment "Return V - B with candidates list, guarantee no overflow by returning larger type";

pattern -(b1:bat[:sht],b2:bat[:bte]) :bat[:int]
address CMDbatSUBenlarge
comment "Return B1 - B2, guarantee no overflow by returning larger type";
pattern -(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]) :bat[:int]
address CMDbatSUBenlarge
comment "Return B1 - B2 with candidates list, guarantee no overflow by returning larger type";
pattern -(b:bat[:sht],v:bte) :bat[:int]
address CMDbatSUBenlarge
comment "Return B - V, guarantee no overflow by returning larger type";
pattern -(b:bat[:sht],v:bte,s:bat[:oid]) :bat[:int]
address CMDbatSUBenlarge
comment "Return B - V with candidates list, guarantee no overflow by returning larger type";
pattern -(v:sht,b:bat[:bte]) :bat[:int]
address CMDbatSUBenlarge
comment "Return V - B, guarantee no overflow by returning larger type";
pattern -(v:sht,b:bat[:bte],s:bat[:oid]) :bat[:int]
address CMDbatSUBenlarge
comment "Return V - B with candidates list, guarantee no overflow by returning larger type";

pattern -(b1:bat[:sht],b2:bat[:sht]) :bat[:int]
address CMDbatSUBenlarge
comment "Return B1 - B2, guarantee no overflow by returning larger type";
pattern -(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]) :bat[:int]
address CMDbatSUBenlarge
comment "Return B1 - B2 with candidates list, guarantee no overflow by returning larger type";
pattern -(b:bat[:sht],v:sht) :bat[:int]
address CMDbatSUBenlarge
comment "Return B - V, guarantee no overflow by returning larger type";
pattern -(b:bat[:sht],v:sht,s:bat[:oid]) :bat[:int]
address CMDbatSUBenlarge
comment "Return B - V with candidates list, guarantee no overflow by returning larger type";
pattern -(v:sht,b:bat[:sht]) :bat[:int]
address CMDbatSUBenlarge
comment "Return V - B, guarantee no overflow by returning larger type";
pattern -(v:sht,b:bat[:sht],s:bat[:oid]) :bat[:int]
address CMDbatSUBenlarge
comment "Return V - B with candidates list, guarantee no overflow by returning larger type";

pattern -(b1:bat[:sht],b2:bat[:int]) :bat[:lng]
address CMDbatSUBenlarge
comment "Return B1 - B2, guarantee no overflow by returning larger type";
pattern -(b1:bat[:sht],b2:bat[:int],s:bat[:oid]) :bat[:lng]
address CMDbatSUBenlarge
comment "Return B1 - B2 with candidates list, guarantee no overflow by returning larger type";
pattern -(b:bat[:sht],v:int) :bat[:lng]
address CMDbatSUBenlarge
comment "Return B - V, guarantee no overflow by returning larger type";
pattern -(b:bat[:sht],v:int,s:bat[:oid]) :bat[:lng]
address CMDbatSUBenlarge
comment "Return B - V with candidates list, guarantee no overflow by returning larger type";
pattern -(v:sht,b:bat[:int]) :bat[:lng]
address CMDbatSUBenlarge
comment "Return V - B, guarantee no overflow by returning larger type";
pattern -(v:sht,b:bat[:int],s:bat[:oid]) :bat[:lng]
address CMDbatSUBenlarge
comment "Return V - B with candidates list, guarantee no overflow by returning larger type";

pattern -(b1:bat[:sht],b2:bat[:flt]) :bat[:dbl]
address CMDbatSUBenlarge
comment "Return B1 - B2, guarantee no overflow by returning larger type";
pattern -(b1:bat[:sht],b2:bat[:flt],s:bat[:oid]) :bat[:dbl]
address CMDbatSUBenlarge
comment "Return B1 - B2 with candidates list, guarantee no overflow by returning larger type";
pattern -(b:bat[:sht],v:flt) :bat[:dbl]
address CMDbatSUBenlarge
comment "Return B - V, guarantee no overflow by returning larger type";
pattern -(b:bat[:sht],v:flt,s:bat[:oid]) :bat[:dbl]
address CMDbatSUBenlarge
comment "Return B - V with candidates list, guarantee no overflow by returning larger type";
pattern -(v:sht,b:bat[:flt]) :bat[:dbl]
address CMDbatSUBenlarge
comment "Return V - B, guarantee no overflow by returning larger type";
pattern -(v:sht,b:bat[:flt],s:bat[:oid]) :bat[:dbl]
address CMDbatSUBenlarge
comment "Return V - B with candidates list, guarantee no overflow by returning larger type";

pattern -(b1:bat[:int],b2:bat[:bte]) :bat[:lng]
address CMDbatSUBenlarge
comment "Return B1 - B2, guarantee no overflow by returning larger type";
pattern -(b1:bat[:int],b2:bat[:bte],s:bat[:oid]) :bat[:lng]
address CMDbatSUBenlarge
comment "Return B1 - B2 with candidates list, guarantee no overflow by returning larger type";
pattern -(b:bat[:int],v:bte) :bat[:lng]
address CMDbatSUBenlarge
comment "Return B - V, guarantee no overflow by returning larger type";
pattern -(b:bat[:int],v:bte,s:bat[:oid]) :bat[:lng]
address CMDbatSUBenlarge
comment "Return B - V with candidates list, guarantee no overflow by returning larger type";
pattern -(v:int,b:bat[:bte]) :bat[:lng]
address CMDbatSUBenlarge
comment "Return V - B, guarantee no overflow by returning larger type";
pattern -(v:int,b:bat[:bte],s:bat[:oid]) :bat[:lng]
address CMDbatSUBenlarge
comment "Return V - B with candidates list, guarantee no overflow by returning larger type";

pattern -(b1:bat[:int],b2:bat[:sht]) :bat[:lng]
address CMDbatSUBenlarge
comment "Return B1 - B2, guarantee no overflow by returning larger type";
pattern -(b1:bat[:int],b2:bat[:sht],s:bat[:oid]) :bat[:lng]
address CMDbatSUBenlarge
comment "Return B1 - B2 with candidates list, guarantee no overflow by returning larger type";
pattern -(b:bat[:int],v:sht) :bat[:lng]
address CMDbatSUBenlarge
comment "Return B - V, guarantee no overflow by returning larger type";
pattern -(b:bat[:int],v:sht,s:bat[:oid]) :bat[:lng]
address CMDbatSUBenlarge
comment "Return B - V with candidates list, guarantee no overflow by returning larger type";
pattern -(v:int,b:bat[:sht]) :bat[:lng]
address CMDbatSUBenlarge
comment "Return V - B, guarantee no overflow by returning larger type";
pattern -(v:int,b:bat[:sht],s:bat[:oid]) :bat[:lng]
address CMDbatSUBenlarge
comment "Return V - B with candidates list, guarantee no overflow by returning larger type";

pattern -(b1:bat[:int],b2:bat[:int]) :bat[:lng]
address CMDbatSUBenlarge
comment "Return B1 - B2, guarantee no overflow by returning larger type";
pattern -(b1:bat[:int],b2:bat[:int],s:bat[:oid]) :bat[:lng]
address CMDbatSUBenlarge
comment "Return B1 - B2 with candidates list, guarantee no overflow by returning larger type";
pattern -(b:bat[:int],v:int) :bat[:lng]
address CMDbatSUBenlarge
comment "Return B - V, guarantee no overflow by returning larger type";
pattern -(b:bat[:int],v:int,s:bat[:oid]) :bat[:lng]
address CMDbatSUBenlarge
comment "Return B - V with candidates list, guarantee no overflow by returning larger type";
pattern -(v:int,b:bat[:int]) :bat[:lng]
address CMDbatSUBenlarge
comment "Return V - B, guarantee no overflow by returning larger type";
pattern -(v:int,b:bat[:int],s:bat[:oid]) :bat[:lng]
address CMDbatSUBenlarge
comment "Return V - B with candidates list, guarantee no overflow by returning larger type";

pattern -(b1:bat[:int],b2:bat[:flt]) :bat[:dbl]
address CMDbatSUBenlarge
comment "Return B1 - B2, guarantee no overflow by returning larger type";
pattern -(b1:bat[:int],b2:bat[:flt],s:bat[:oid]) :bat[:dbl]
address CMDbatSUBenlarge
comment "Return B1 - B2 with candidates list, guarantee no overflow by returning larger type";
pattern -(b:bat[:int],v:flt) :bat[:dbl]
address CMDbatSUBenlarge
comment "Return B - V, guarantee no overflow by returning larger type";
pattern -(b:bat[:int],v:flt,s:bat[:oid]) :bat[:dbl]
address CMDbatSUBenlarge
comment "Return B - V with candidates list, guarantee no overflow by returning larger type";
pattern -(v:int,b:bat[:flt]) :bat[:dbl]
address CMDbatSUBenlarge
comment "Return V - B, guarantee no overflow by returning larger type";
pattern -(v:int,b:bat[:flt],s:bat[:oid]) :bat[:dbl]
address CMDbatSUBenlarge
comment "Return V - B with candidates list, guarantee no overflow by returning larger type";

pattern -(b1:bat[:lng],b2:bat[:flt]) :bat[:dbl]
address CMDbatSUBenlarge
comment "Return B1 - B2, guarantee no overflow by returning larger type";
pattern -(b1:bat[:lng],b2:bat[:flt],s:bat[:oid]) :bat[:dbl]
address CMDbatSUBenlarge
comment "Return B1 - B2 with candidates list, guarantee no overflow by returning larger type";
pattern -(b:bat[:lng],v:flt) :bat[:dbl]
address CMDbatSUBenlarge
comment "Return B - V, guarantee no overflow by returning larger type";
pattern -(b:bat[:lng],v:flt,s:bat[:oid]) :bat[:dbl]
address CMDbatSUBenlarge
comment "Return B - V with candidates list, guarantee no overflow by returning larger type";
pattern -(v:lng,b:bat[:flt]) :bat[:dbl]
address CMDbatSUBenlarge
comment "Return V - B, guarantee no overflow by returning larger type";
pattern -(v:lng,b:bat[:flt],s:bat[:oid]) :bat[:dbl]
address CMDbatSUBenlarge
comment "Return V - B with candidates list, guarantee no overflow by returning larger type";

pattern -(b1:bat[:flt],b2:bat[:bte]) :bat[:dbl]
address CMDbatSUBenlarge
comment "Return B1 - B2, guarantee no overflow by returning larger type";
pattern -(b1:bat[:flt],b2:bat[:bte],s:bat[:oid]) :bat[:dbl]
address CMDbatSUBenlarge
comment "Return B1 - B2 with candidates list, guarantee no overflow by returning larger type";
pattern -(b:bat[:flt],v:bte) :bat[:dbl]
address CMDbatSUBenlarge
comment "Return B - V, guarantee no overflow by returning larger type";
pattern -(b:bat[:flt],v:bte,s:bat[:oid]) :bat[:dbl]
address CMDbatSUBenlarge
comment "Return B - V with candidates list, guarantee no overflow by returning larger type";
pattern -(v:flt,b:bat[:bte]) :bat[:dbl]
address CMDbatSUBenlarge
comment "Return V - B, guarantee no overflow by returning larger type";
pattern -(v:flt,b:bat[:bte],s:bat[:oid]) :bat[:dbl]
address CMDbatSUBenlarge
comment "Return V - B with candidates list, guarantee no overflow by returning larger type";

pattern -(b1:bat[:flt],b2:bat[:sht]) :bat[:dbl]
address CMDbatSUBenlarge
comment "Return B1 - B2, guarantee no overflow by returning larger type";
pattern -(b1:bat[:flt],b2:bat[:sht],s:bat[:oid]) :bat[:dbl]
address CMDbatSUBenlarge
comment "Return B1 - B2 with candidates list, guarantee no overflow by returning larger type";
pattern -(b:bat[:flt],v:sht) :bat[:dbl]
address CMDbatSUBenlarge
comment "Return B - V, guarantee no overflow by returning larger type";
pattern -(b:bat[:flt],v:sht,s:bat[:oid]) :bat[:dbl]
address CMDbatSUBenlarge
comment "Return B - V with candidates list, guarantee no overflow by returning larger type";
pattern -(v:flt,b:bat[:sht]) :bat[:dbl]
address CMDbatSUBenlarge
comment "Return V - B, guarantee no overflow by returning larger type";
pattern -(v:flt,b:bat[:sht],s:bat[:oid]) :bat[:dbl]
address CMDbatSUBenlarge
comment "Return V - B with candidates list, guarantee no overflow by returning larger type";

pattern -(b1:bat[:flt],b2:bat[:int]) :bat[:dbl]
address CMDbatSUBenlarge
comment "Return B1 - B2, guarantee no overflow by returning larger type";
pattern -(b1:bat[:flt],b2:bat[:int],s:bat[:oid]) :bat[:dbl]
address CMDbatSUBenlarge
comment "Return B1 - B2 with candidates list, guarantee no overflow by returning larger type";
pattern -(b:bat[:flt],v:int) :bat[:dbl]
address CMDbatSUBenlarge
comment "Return B - V, guarantee no overflow by returning larger type";
pattern -(b:bat[:flt],v:int,s:bat[:oid]) :bat[:dbl]
address CMDbatSUBenlarge
comment "Return B - V with candidates list, guarantee no overflow by returning larger type";
pattern -(v:flt,b:bat[:int]) :bat[:dbl]
address CMDbatSUBenlarge
comment "Return V - B, guarantee no overflow by returning larger type";
pattern -(v:flt,b:bat[:int],s:bat[:oid]) :bat[:dbl]
address CMDbatSUBenlarge
comment "Return V - B with candidates list, guarantee no overflow by returning larger type";

pattern -(b1:bat[:flt],b2:bat[:lng]) :bat[:dbl]
address CMDbatSUBenlarge
comment "Return B1 - B2, guarantee no overflow by returning larger type";
pattern -(b1:bat[:flt],b2:bat[:lng],s:bat[:oid]) :bat[:dbl]
address CMDbatSUBenlarge
comment "Return B1 - B2 with candidates list, guarantee no overflow by returning larger type";
pattern -(b:bat[:flt],v:lng) :bat[:dbl]
address CMDbatSUBenlarge
comment "Return B - V, guarantee no overflow by returning larger type";
pattern -(b:bat[:flt],v:lng,s:bat[:oid]) :bat[:dbl]
address CMDbatSUBenlarge
comment "Return B - V with candidates list, guarantee no overflow by returning larger type";
pattern -(v:flt,b:bat[:lng]) :bat[:dbl]
address CMDbatSUBenlarge
comment "Return V - B, guarantee no overflow by returning larger type";
pattern -(v:flt,b:bat[:lng],s:bat[:oid]) :bat[:dbl]
address CMDbatSUBenlarge
comment "Return V - B with candidates list, guarantee no overflow by returning larger type";

pattern -(b1:bat[:flt],b2:bat[:flt]) :bat[:dbl]
address CMDbatSUBenlarge
comment "Return B1 - B2, guarantee no overflow by returning larger type";
pattern -(b1:bat[:flt],b2:bat[:flt],s:bat[:oid]) :bat[:dbl]
address CMDbatSUBenlarge
comment "Return B1 - B2 with candidates list, guarantee no overflow by returning larger type";
pattern -(b:bat[:flt],v:flt) :bat[:dbl]
address CMDbatSUBenlarge
comment "Return B - V, guarantee no overflow by returning larger type";
pattern -(b:bat[:flt],v:flt,s:bat[:oid]) :bat[:dbl]
address CMDbatSUBenlarge
comment "Return B - V with candidates list, guarantee no overflow by returning larger type";
pattern -(v:flt,b:bat[:flt]) :bat[:dbl]
address CMDbatSUBenlarge
comment "Return V - B, guarantee no overflow by returning larger type";
pattern -(v:flt,b:bat[:flt],s:bat[:oid]) :bat[:dbl]
address CMDbatSUBenlarge
comment "Return V - B with candidates list, guarantee no overflow by returning larger type";


pattern *(b1:bat[:bte],b2:bat[:bte]) :bat[:sht]
address CMDbatMULenlarge
comment "Return B1 * B2, guarantee no overflow by returning larger type";
pattern *(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]) :bat[:sht]
address CMDbatMULenlarge
comment "Return B1 * B2 with candidates list, guarantee no overflow by returning larger type";
pattern *(b:bat[:bte],v:bte) :bat[:sht]
address CMDbatMULenlarge
comment "Return B * V, guarantee no overflow by returning larger type";
pattern *(b:bat[:bte],v:bte,s:bat[:oid]) :bat[:sht]
address CMDbatMULenlarge
comment "Return B * V with candidates list, guarantee no overflow by returning larger type";
pattern *(v:bte,b:bat[:bte]) :bat[:sht]
address CMDbatMULenlarge
comment "Return V * B, guarantee no overflow by returning larger type";
pattern *(v:bte,b:bat[:bte],s:bat[:oid]) :bat[:sht]
address CMDbatMULenlarge
comment "Return V * B with candidates list, guarantee no overflow by returning larger type";

pattern *(b1:bat[:bte],b2:bat[:sht]) :bat[:int]
address CMDbatMULenlarge
comment "Return B1 * B2, guarantee no overflow by returning larger type";
pattern *(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]) :bat[:int]
address CMDbatMULenlarge
comment "Return B1 * B2 with candidates list, guarantee no overflow by returning larger type";
pattern *(b:bat[:bte],v:sht) :bat[:int]
address CMDbatMULenlarge
comment "Return B * V, guarantee no overflow by returning larger type";
pattern *(b:bat[:bte],v:sht,s:bat[:oid]) :bat[:int]
address CMDbatMULenlarge
comment "Return B * V with candidates list, guarantee no overflow by returning larger type";
pattern *(v:bte,b:bat[:sht]) :bat[:int]
address CMDbatMULenlarge
comment "Return V * B, guarantee no overflow by returning larger type";
pattern *(v:bte,b:bat[:sht],s:bat[:oid]) :bat[:int]
address CMDbatMULenlarge
comment "Return V * B with candidates list, guarantee no overflow by returning larger type";

pattern *(b1:bat[:bte],b2:bat[:int]) :bat[:lng]
address CMDbatMULenlarge
comment "Return B1 * B2, guarantee no overflow by returning larger type";
pattern *(b1:bat[:bte],b2:bat[:int],s:bat[:oid]) :bat[:lng]
address CMDbatMULenlarge
comment "Return B1 * B2 with candidates list, guarantee no overflow by returning larger type";
pattern *(b:bat[:bte],v:int) :bat[:lng]
address CMDbatMULenlarge
comment "Return B * V, guarantee no overflow by returning larger type";
pattern *(b:bat[:bte],v:int,s:bat[:oid]) :bat[:lng]
address CMDbatMULenlarge
comment "Return B * V with candidates list, guarantee no overflow by returning larger type";
pattern *(v:bte,b:bat[:int]) :bat[:lng]
address CMDbatMULenlarge
comment "Return V * B, guarantee no overflow by returning larger type";
pattern *(v:bte,b:bat[:int],s:bat[:oid]) :bat[:lng]
address CMDbatMULenlarge
comment "Return V * B with candidates list, guarantee no overflow by returning larger type";

pattern *(b1:bat[:bte],b2:bat[:flt]) :bat[:dbl]
address CMDbatMULenlarge
comment "Return B1 * B2, guarantee no overflow by returning larger type";
pattern *(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]) :bat[:dbl]
address CMDbatMULenlarge
comment "Return B1 * B2 with candidates list, guarantee no overflow by returning larger type";
pattern *(b:bat[:bte],v:flt) :bat[:dbl]
address CMDbatMULenlarge
comment "Return B * V, guarantee no overflow by returning larger type";
pattern *(b:bat[:bte],v:flt,s:bat[:oid]) :bat[:dbl]
address CMDbatMULenlarge
comment "Return B * V with candidates list, guarantee no overflow by returning larger type";
pattern *(v:bte,b:bat[:flt]) :bat[:dbl]
address CMDbatMULenlarge
comment "Return V * B, guarantee no overflow by returning larger type";
pattern *(v:bte,b:bat[:flt],s:bat[:oid]) :bat[:dbl]
address CMDbatMULenlarge
comment "Return V * B with candidates list, guarantee no overflow by returning larger type";

pattern *(b1:bat[:sht],b2:bat[:bte]) :bat[:int]
address CMDbatMULenlarge
comment "Return B1 * B2, guarantee no overflow by returning larger type";
pattern *(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]) :bat[:int]
address CMDbatMULenlarge
comment "Return B1 * B2 with candidates list, guarantee no overflow by returning larger type";
pattern *(b:bat[:sht],v:bte) :bat[:int]
address CMDbatMULenlarge
comment "Return B * V, guarantee no overflow by returning larger type";
pattern *(b:bat[:sht],v:bte,s:bat[:oid]) :bat[:int]
address CMDbatMULenlarge
comment "Return B * V with candidates list, guarantee no overflow by returning larger type";
pattern *(v:sht,b:bat[:bte]) :bat[:int]
address CMDbatMULenlarge
comment "Return V * B, guarantee no overflow by returning larger type";
pattern *(v:sht,b:bat[:bte],s:bat[:oid]) :bat[:int]
address CMDbatMULenlarge
comment "Return V * B with candidates list, guarantee no overflow by returning larger type";

pattern *(b1:bat[:sht],b2:bat[:sht]) :bat[:int]
address CMDbatMULenlarge
comment "Return B1 * B2, guarantee no overflow by returning larger type";
pattern *(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]) :bat[:int]
address CMDbatMULenlarge
comment "Return B1 * B2 with candidates list, guarantee no overflow by returning larger type";
pattern *(b:bat[:sht],v:sht) :bat[:int]
address CMDbatMULenlarge
comment "Return B * V, guarantee no overflow by returning larger type";
pattern *(b:bat[:sht],v:sht,s:bat[:oid]) :bat[:int]
address CMDbatMULenlarge
comment "Return B * V with candidates list, guarantee no overflow by returning larger type";
pattern *(v:sht,b:bat[:sht]) :bat[:int]
address CMDbatMULenlarge
comment "Return V * B, guarantee no overflow by returning larger type";
pattern *(v:sht,b:bat[:sht],s:bat[:oid]) :bat[:int]
address CMDbatMULenlarge
comment "Return V * B with candidates list, guarantee no overflow by returning larger type";

pattern *(b1:bat[:sht],b2:bat[:int]) :bat[:lng]
address CMDbatMULenlarge
comment "Return B1 * B2, guarantee no overflow by returning larger type";
pattern *(b1:bat[:sht],b2:bat[:int],s:bat[:oid]) :bat[:lng]
address CMDbatMULenlarge
comment "Return B1 * B2 with candidates list, guarantee no overflow by returning larger type";
pattern *(b:bat[:sht],v:int) :bat[:lng]
address CMDbatMULenlarge
comment "Return B * V, guarantee no overflow by returning larger type";
pattern *(b:bat[:sht],v:int,s:bat[:oid]) :bat[:lng]
address CMDbatMULenlarge
comment "Return B * V with candidates list, guarantee no overflow by returning larger type";
pattern *(v:sht,b:bat[:int]) :bat[:lng]
address CMDbatMULenlarge
comment "Return V * B, guarantee no overflow by returning larger type";
pattern *(v:sht,b:bat[:int],s:bat[:oid]) :bat[:lng]
address CMDbatMULenlarge
comment "Return V * B with candidates list, guarantee no overflow by returning larger type";

pattern *(b1:bat[:sht],b2:bat[:flt]) :bat[:dbl]
address CMDbatMULenlarge
comment "Return B1 * B2, guarantee no overflow by returning larger type";
pattern *(b1:bat[:sht],b2:bat[:flt],s:bat[:oid]) :bat[:dbl]
address CMDbatMULenlarge
comment "Return B1 * B2 with candidates list, guarantee no overflow by returning larger type";
pattern *(b:bat[:sht],v:flt) :bat[:dbl]
address CMDbatMULenlarge
comment "Return B * V, guarantee no overflow by returning larger type";
pattern *(b:bat[:sht],v:flt,s:bat[:oid]) :bat[:dbl]
address CMDbatMULenlarge
comment "Return B * V with candidates list, guarantee no overflow by returning larger type";
pattern *(v:sht,b:bat[:flt]) :bat[:dbl]
address CMDbatMULenlarge
comment "Return V * B, guarantee no overflow by returning larger type";
pattern *(v:sht,b:bat[:flt],s:bat[:oid]) :bat[:dbl]
address CMDbatMULenlarge
comment "Return V * B with candidates list, guarantee no overflow by returning larger type";

pattern *(b1:bat[:int],b2:bat[:bte]) :bat[:lng]
address CMDbatMULenlarge
comment "Return B1 * B2, guarantee no overflow by returning larger type";
pattern *(b1:bat[:int],b2:bat[:bte],s:bat[:oid]) :bat[:lng]
address CMDbatMULenlarge
comment "Return B1 * B2 with candidates list, guarantee no overflow by returning larger type";
pattern *(b:bat[:int],v:bte) :bat[:lng]
address CMDbatMULenlarge
comment "Return B * V, guarantee no overflow by returning larger type";
pattern *(b:bat[:int],v:bte,s:bat[:oid]) :bat[:lng]
address CMDbatMULenlarge
comment "Return B * V with candidates list, guarantee no overflow by returning larger type";
pattern *(v:int,b:bat[:bte]) :bat[:lng]
address CMDbatMULenlarge
comment "Return V * B, guarantee no overflow by returning larger type";
pattern *(v:int,b:bat[:bte],s:bat[:oid]) :bat[:lng]
address CMDbatMULenlarge
comment "Return V * B with candidates list, guarantee no overflow by returning larger type";

pattern *(b1:bat[:int],b2:bat[:sht]) :bat[:lng]
address CMDbatMULenlarge
comment "Return B1 * B2, guarantee no overflow by returning larger type";
pattern *(b1:bat[:int],b2:bat[:sht],s:bat[:oid]) :bat[:lng]
address CMDbatMULenlarge
comment "Return B1 * B2 with candidates list, guarantee no overflow by returning larger type";
pattern *(b:bat[:int],v:sht) :bat[:lng]
address CMDbatMULenlarge
comment "Return B * V, guarantee no overflow by returning larger type";
pattern *(b:bat[:int],v:sht,s:bat[:oid]) :bat[:lng]
address CMDbatMULenlarge
comment "Return B * V with candidates list, guarantee no overflow by returning larger type";
pattern *(v:int,b:bat[:sht]) :bat[:lng]
address CMDbatMULenlarge
comment "Return V * B, guarantee no overflow by returning larger type";
pattern *(v:int,b:bat[:sht],s:bat[:oid]) :bat[:lng]
address CMDbatMULenlarge
comment "Return V * B with candidates list, guarantee no overflow by returning larger type";

pattern *(b1:bat[:int],b2:bat[:int]) :bat[:lng]
address CMDbatMULenlarge
comment "Return B1 * B2, guarantee no overflow by returning larger type";
pattern *(b1:bat[:int],b2:bat[:int],s:bat[:oid]) :bat[:lng]
address CMDbatMULenlarge
comment "Return B1 * B2 with candidates list, guarantee no overflow by returning larger type";
pattern *(b:bat[:int],v:int) :bat[:lng]
address CMDbatMULenlarge
comment "Return B * V, guarantee no overflow by returning larger type";
pattern *(b:bat[:int],v:int,s:bat[:oid]) :bat[:lng]
address CMDbatMULenlarge
comment "Return B * V with candidates list, guarantee no overflow by returning larger type";
pattern *(v:int,b:bat[:int]) :bat[:lng]
address CMDbatMULenlarge
comment "Return V * B, guarantee no overflow by returning larger type";
pattern *(v:int,b:bat[:int],s:bat[:oid]) :bat[:lng]
address CMDbatMULenlarge
comment "Return V * B with candidates list, guarantee no overflow by returning larger type";

pattern *(b1:bat[:int],b2:bat[:flt]) :bat[:dbl]
address CMDbatMULenlarge
comment "Return B1 * B2, guarantee no overflow by returning larger type";
pattern *(b1:bat[:int],b2:bat[:flt],s:bat[:oid]) :bat[:dbl]
address CMDbatMULenlarge
comment "Return B1 * B2 with candidates list, guarantee no overflow by returning larger type";
pattern *(b:bat[:int],v:flt) :bat[:dbl]
address CMDbatMULenlarge
comment "Return B * V, guarantee no overflow by returning larger type";
pattern *(b:bat[:int],v:flt,s:bat[:oid]) :bat[:dbl]
address CMDbatMULenlarge
comment "Return B * V with candidates list, guarantee no overflow by returning larger type";
pattern *(v:int,b:bat[:flt]) :bat[:dbl]
address CMDbatMULenlarge
comment "Return V * B, guarantee no overflow by returning larger type";
pattern *(v:int,b:bat[:flt],s:bat[:oid]) :bat[:dbl]
address CMDbatMULenlarge
comment "Return V * B with candidates list, guarantee no overflow by returning larger type";

pattern *(b1:bat[:lng],b2:bat[:flt]) :bat[:dbl]
address CMDbatMULenlarge
comment "Return B1 * B2, guarantee no overflow by returning larger type";
pattern *(b1:bat[:lng],b2:bat[:flt],s:bat[:oid]) :bat[:dbl]
address CMDbatMULenlarge
comment "Return B1 * B2 with candidates list, guarantee no overflow by returning larger type";
pattern *(b:bat[:lng],v:flt) :bat[:dbl]
address CMDbatMULenlarge
comment "Return B * V, guarantee no overflow by returning larger type";
pattern *(b:bat[:lng],v:flt,s:bat[:oid]) :bat[:dbl]
address CMDbatMULenlarge
comment "Return B * V with candidates list, guarantee no overflow by returning larger type";
pattern *(v:lng,b:bat[:flt]) :bat[:dbl]
address CMDbatMULenlarge
comment "Return V * B, guarantee no overflow by returning larger type";
pattern *(v:lng,b:bat[:flt],s:bat[:oid]) :bat[:dbl]
address CMDbatMULenlarge
comment "Return V * B with candidates list, guarantee no overflow by returning larger type";

pattern *(b1:bat[:flt],b2:bat[:bte]) :bat[:dbl]
address CMDbatMULenlarge
comment "Return B1 * B2, guarantee no overflow by returning larger type";
pattern *(b1:bat[:flt],b2:bat[:bte],s:bat[:oid]) :bat[:dbl]
address CMDbatMULenlarge
comment "Return B1 * B2 with candidates list, guarantee no overflow by returning larger type";
pattern *(b:bat[:flt],v:bte) :bat[:dbl]
address CMDbatMULenlarge
comment "Return B * V, guarantee no overflow by returning larger type";
pattern *(b:bat[:flt],v:bte,s:bat[:oid]) :bat[:dbl]
address CMDbatMULenlarge
comment "Return B * V with candidates list, guarantee no overflow by returning larger type";
pattern *(v:flt,b:bat[:bte]) :bat[:dbl]
address CMDbatMULenlarge
comment "Return V * B, guarantee no overflow by returning larger type";
pattern *(v:flt,b:bat[:bte],s:bat[:oid]) :bat[:dbl]
address CMDbatMULenlarge
comment "Return V * B with candidates list, guarantee no overflow by returning larger type";

pattern *(b1:bat[:flt],b2:bat[:sht]) :bat[:dbl]
address CMDbatMULenlarge
comment "Return B1 * B2, guarantee no overflow by returning larger type";
pattern *(b1:bat[:flt],b2:bat[:sht],s:bat[:oid]) :bat[:dbl]
address CMDbatMULenlarge
comment "Return B1 * B2 with candidates list, guarantee no overflow by returning larger type";
pattern *(b:bat[:flt],v:sht) :bat[:dbl]
address CMDbatMULenlarge
comment "Return B * V, guarantee no overflow by returning larger type";
pattern *(b:bat[:flt],v:sht,s:bat[:oid]) :bat[:dbl]
address CMDbatMULenlarge
comment "Return B * V with candidates list, guarantee no overflow by returning larger type";
pattern *(v:flt,b:bat[:sht]) :bat[:dbl]
address CMDbatMULenlarge
comment "Return V * B, guarantee no overflow by returning larger type";
pattern *(v:flt,b:bat[:sht],s:bat[:oid]) :bat[:dbl]
address CMDbatMULenlarge
comment "Return V * B with candidates list, guarantee no overflow by returning larger type";

pattern *(b1:bat[:flt],b2:bat[:int]) :bat[:dbl]
address CMDbatMULenlarge
comment "Return B1 * B2, guarantee no overflow by returning larger type";
pattern *(b1:bat[:flt],b2:bat[:int],s:bat[:oid]) :bat[:dbl]
address CMDbatMULenlarge
comment "Return B1 * B2 with candidates list, guarantee no overflow by returning larger type";
pattern *(b:bat[:flt],v:int) :bat[:dbl]
address CMDbatMULenlarge
comment "Return B * V, guarantee no overflow by returning larger type";
pattern *(b:bat[:flt],v:int,s:bat[:oid]) :bat[:dbl]
address CMDbatMULenlarge
comment "Return B * V with candidates list, guarantee no overflow by returning larger type";
pattern *(v:flt,b:bat[:int]) :bat[:dbl]
address CMDbatMULenlarge
comment "Return V * B, guarantee no overflow by returning larger type";
pattern *(v:flt,b:bat[:int],s:bat[:oid]) :bat[:dbl]
address CMDbatMULenlarge
comment "Return V * B with candidates list, guarantee no overflow by returning larger type";

pattern *(b1:bat[:flt],b2:bat[:lng]) :bat[:dbl]
address CMDbatMULenlarge
comment "Return B1 * B2, guarantee no overflow by returning larger type";
pattern *(b1:bat[:flt],b2:bat[:lng],s:bat[:oid]) :bat[:dbl]
address CMDbatMULenlarge
comment "Return B1 * B2 with candidates list, guarantee no overflow by returning larger type";
pattern *(b:bat[:flt],v:lng) :bat[:dbl]
address CMDbatMULenlarge
comment "Return B * V, guarantee no overflow by returning larger type";
pattern *(b:bat[:flt],v:lng,s:bat[:oid]) :bat[:dbl]
address CMDbatMULenlarge
comment "Return B * V with candidates list, guarantee no overflow by returning larger type";
pattern *(v:flt,b:bat[:lng]) :bat[:dbl]
address CMDbatMULenlarge
comment "Return V * B, guarantee no overflow by returning larger type";
pattern *(v:flt,b:bat[:lng],s:bat[:oid]) :bat[:dbl]
address CMDbatMULenlarge
comment "Return V * B with candidates list, guarantee no overflow by returning larger type";

pattern *(b1:bat[:flt],b2:bat[:flt]) :bat[:dbl]
address CMDbatMULenlarge
comment "Return B1 * B2, guarantee no overflow by returning larger type";
pattern *(b1:bat[:flt],b2:bat[:flt],s:bat[:oid]) :bat[:dbl]
address CMDbatMULenlarge
comment "Return B1 * B2 with candidates list, guarantee no overflow by returning larger type";
pattern *(b:bat[:flt],v:flt) :bat[:dbl]
address CMDbatMULenlarge
comment "Return B * V, guarantee no overflow by returning larger type";
pattern *(b:bat[:flt],v:flt,s:bat[:oid]) :bat[:dbl]
address CMDbatMULenlarge
comment "Return B * V with candidates list, guarantee no overflow by returning larger type";
pattern *(v:flt,b:bat[:flt]) :bat[:dbl]
address CMDbatMULenlarge
comment "Return V * B, guarantee no overflow by returning larger type";
pattern *(v:flt,b:bat[:flt],s:bat[:oid]) :bat[:dbl]
address CMDbatMULenlarge
comment "Return V * B with candidates list, guarantee no overflow by returning larger type";


pattern +(b1:bat[:bte],b2:bat[:bte]) :bat[:bte]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
pattern +(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]) :bat[:bte]
address CMDbatADDsignal
comment "Return B1 + B2 with candidates list, signal error on overflow";
pattern add_noerror(b1:bat[:bte],b2:bat[:bte]) :bat[:bte]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern add_noerror(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]) :bat[:bte]
address CMDbatADD
comment "Return B1 + B2 with candidates list, overflow causes NIL value";
pattern +(b:bat[:bte],v:bte) :bat[:bte]
address CMDbatADDsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:bte],v:bte,s:bat[:oid]) :bat[:bte]
address CMDbatADDsignal
comment "Return B + V with candidates list, signal error on overflow";
pattern add_noerror(b:bat[:bte],v:bte) :bat[:bte]
address CMDbatADD
comment "Return B + V, overflow causes NIL value";
pattern add_noerror(b:bat[:bte],v:bte,s:bat[:oid]) :bat[:bte]
address CMDbatADD
comment "Return B + V with candidates list, overflow causes NIL value";
pattern +(v:bte,b:bat[:bte]) :bat[:bte]
address CMDbatADDsignal
comment "Return V + B, signal error on overflow";
pattern +(v:bte,b:bat[:bte],s:bat[:oid]) :bat[:bte]
address CMDbatADDsignal
comment "Return V + B with candidates list, signal error on overflow";
pattern add_noerror(v:bte,b:bat[:bte]) :bat[:bte]
address CMDbatADD
comment "Return V + B, overflow causes NIL value";
pattern add_noerror(v:bte,b:bat[:bte],s:bat[:oid]) :bat[:bte]
address CMDbatADD
comment "Return V + B with candidates list, overflow causes NIL value";

pattern +(b1:bat[:bte],b2:bat[:sht]) :bat[:sht]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
pattern +(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]) :bat[:sht]
address CMDbatADDsignal
comment "Return B1 + B2 with candidates list, signal error on overflow";
pattern add_noerror(b1:bat[:bte],b2:bat[:sht]) :bat[:sht]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern add_noerror(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]) :bat[:sht]
address CMDbatADD
comment "Return B1 + B2 with candidates list, overflow causes NIL value";
pattern +(b:bat[:bte],v:sht) :bat[:sht]
address CMDbatADDsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:bte],v:sht,s:bat[:oid]) :bat[:sht]
address CMDbatADDsignal
comment "Return B + V with candidates list, signal error on overflow";
pattern add_noerror(b:bat[:bte],v:sht) :bat[:sht]
address CMDbatADD
comment "Return B + V, overflow causes NIL value";
pattern add_noerror(b:bat[:bte],v:sht,s:bat[:oid]) :bat[:sht]
address CMDbatADD
comment "Return B + V with candidates list, overflow causes NIL value";
pattern +(v:bte,b:bat[:sht]) :bat[:sht]
address CMDbatADDsignal
comment "Return V + B, signal error on overflow";
pattern +(v:bte,b:bat[:sht],s:bat[:oid]) :bat[:sht]
address CMDbatADDsignal
comment "Return V + B with candidates list, signal error on overflow";
pattern add_noerror(v:bte,b:bat[:sht]) :bat[:sht]
address CMDbatADD
comment "Return V + B, overflow causes NIL value";
pattern add_noerror(v:bte,b:bat[:sht],s:bat[:oid]) :bat[:sht]
address CMDbatADD
comment "Return V + B with candidates list, overflow causes NIL value";

pattern +(b1:bat[:bte],b2:bat[:int]) :bat[:int]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
pattern +(b1:bat[:bte],b2:bat[:int],s:bat[:oid]) :bat[:int]
address CMDbatADDsignal
comment "Return B1 + B2 with candidates list, signal error on overflow";
pattern add_noerror(b1:bat[:bte],b2:bat[:int]) :bat[:int]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern add_noerror(b1:bat[:bte],b2:bat[:int],s:bat[:oid]) :bat[:int]
address CMDbatADD
comment "Return B1 + B2 with candidates list, overflow causes NIL value";
pattern +(b:bat[:bte],v:int) :bat[:int]
address CMDbatADDsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:bte],v:int,s:bat[:oid]) :bat[:int]
address CMDbatADDsignal
comment "Return B + V with candidates list, signal error on overflow";
pattern add_noerror(b:bat[:bte],v:int) :bat[:int]
address CMDbatADD
comment "Return B + V, overflow causes NIL value";
pattern add_noerror(b:bat[:bte],v:int,s:bat[:oid]) :bat[:int]
address CMDbatADD
comment "Return B + V with candidates list, overflow causes NIL value";
pattern +(v:bte,b:bat[:int]) :bat[:int]
address CMDbatADDsignal
comment "Return V + B, signal error on overflow";
pattern +(v:bte,b:bat[:int],s:bat[:oid]) :bat[:int]
address CMDbatADDsignal
comment "Return V + B with candidates list, signal error on overflow";
pattern add_noerror(v:bte,b:bat[:int]) :bat[:int]
address CMDbatADD
comment "Return V + B, overflow causes NIL value";
pattern add_noerror(v:bte,b:bat[:int],s:bat[:oid]) :bat[:int]
address CMDbatADD
comment "Return V + B with candidates list, overflow causes NIL value";

pattern +(b1:bat[:bte],b2:bat[:lng]) :bat[:lng]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
pattern +(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]) :bat[:lng]
address CMDbatADDsignal
comment "Return B1 + B2 with candidates list, signal error on overflow";
pattern add_noerror(b1:bat[:bte],b2:bat[:lng]) :bat[:lng]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern add_noerror(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]) :bat[:lng]
address CMDbatADD
comment "Return B1 + B2 with candidates list, overflow causes NIL value";
pattern +(b:bat[:bte],v:lng) :bat[:lng]
address CMDbatADDsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:bte],v:lng,s:bat[:oid]) :bat[:lng]
address CMDbatADDsignal
comment "Return B + V with candidates list, signal error on overflow";
pattern add_noerror(b:bat[:bte],v:lng) :bat[:lng]
address CMDbatADD
comment "Return B + V, overflow causes NIL value";
pattern add_noerror(b:bat[:bte],v:lng,s:bat[:oid]) :bat[:lng]
address CMDbatADD
comment "Return B + V with candidates list, overflow causes NIL value";
pattern +(v:bte,b:bat[:lng]) :bat[:lng]
address CMDbatADDsignal
comment "Return V + B, signal error on overflow";
pattern +(v:bte,b:bat[:lng],s:bat[:oid]) :bat[:lng]
address CMDbatADDsignal
comment "Return V + B with candidates list, signal error on overflow";
pattern add_noerror(v:bte,b:bat[:lng]) :bat[:lng]
address CMDbatADD
comment "Return V + B, overflow causes NIL value";
pattern add_noerror(v:bte,b:bat[:lng],s:bat[:oid]) :bat[:lng]
address CMDbatADD
comment "Return V + B with candidates list, overflow causes NIL value";

pattern +(b1:bat[:bte],b2:bat[:flt]) :bat[:flt]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
pattern +(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatADDsignal
comment "Return B1 + B2 with candidates list, signal error on overflow";
pattern add_noerror(b1:bat[:bte],b2:bat[:flt]) :bat[:flt]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern add_noerror(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatADD
comment "Return B1 + B2 with candidates list, overflow causes NIL value";
pattern +(b:bat[:bte],v:flt) :bat[:flt]
address CMDbatADDsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:bte],v:flt,s:bat[:oid]) :bat[:flt]
address CMDbatADDsignal
comment "Return B + V with candidates list, signal error on overflow";
pattern add_noerror(b:bat[:bte],v:flt) :bat[:flt]
address CMDbatADD
comment "Return B + V, overflow causes NIL value";
pattern add_noerror(b:bat[:bte],v:flt,s:bat[:oid]) :bat[:flt]
address CMDbatADD
comment "Return B + V with candidates list, overflow causes NIL value";
pattern +(v:bte,b:bat[:flt]) :bat[:flt]
address CMDbatADDsignal
comment "Return V + B, signal error on overflow";
pattern +(v:bte,b:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatADDsignal
comment "Return V + B with candidates list, signal error on overflow";
pattern add_noerror(v:bte,b:bat[:flt]) :bat[:flt]
address CMDbatADD
comment "Return V + B, overflow causes NIL value";
pattern add_noerror(v:bte,b:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatADD
comment "Return V + B with candidates list, overflow causes NIL value";

pattern +(b1:bat[:bte],b2:bat[:dbl]) :bat[:dbl]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
pattern +(b1:bat[:bte],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatADDsignal
comment "Return B1 + B2 with candidates list, signal error on overflow";
pattern add_noerror(b1:bat[:bte],b2:bat[:dbl]) :bat[:dbl]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern add_noerror(b1:bat[:bte],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatADD
comment "Return B1 + B2 with candidates list, overflow causes NIL value";
pattern +(b:bat[:bte],v:dbl) :bat[:dbl]
address CMDbatADDsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:bte],v:dbl,s:bat[:oid]) :bat[:dbl]
address CMDbatADDsignal
comment "Return B + V with candidates list, signal error on overflow";
pattern add_noerror(b:bat[:bte],v:dbl) :bat[:dbl]
address CMDbatADD
comment "Return B + V, overflow causes NIL value";
pattern add_noerror(b:bat[:bte],v:dbl,s:bat[:oid]) :bat[:dbl]
address CMDbatADD
comment "Return B + V with candidates list, overflow causes NIL value";
pattern +(v:bte,b:bat[:dbl]) :bat[:dbl]
address CMDbatADDsignal
comment "Return V + B, signal error on overflow";
pattern +(v:bte,b:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatADDsignal
comment "Return V + B with candidates list, signal error on overflow";
pattern add_noerror(v:bte,b:bat[:dbl]) :bat[:dbl]
address CMDbatADD
comment "Return V + B, overflow causes NIL value";
pattern add_noerror(v:bte,b:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatADD
comment "Return V + B with candidates list, overflow causes NIL value";

pattern +(b1:bat[:sht],b2:bat[:bte]) :bat[:sht]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
pattern +(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]) :bat[:sht]
address CMDbatADDsignal
comment "Return B1 + B2 with candidates list, signal error on overflow";
pattern add_noerror(b1:bat[:sht],b2:bat[:bte]) :bat[:sht]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern add_noerror(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]) :bat[:sht]
address CMDbatADD
comment "Return B1 + B2 with candidates list, overflow causes NIL value";
pattern +(b:bat[:sht],v:bte) :bat[:sht]
address CMDbatADDsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:sht],v:bte,s:bat[:oid]) :bat[:sht]
address CMDbatADDsignal
comment "Return B + V with candidates list, signal error on overflow";
pattern add_noerror(b:bat[:sht],v:bte) :bat[:sht]
address CMDbatADD
comment "Return B + V, overflow causes NIL value";
pattern add_noerror(b:bat[:sht],v:bte,s:bat[:oid]) :bat[:sht]
address CMDbatADD
comment "Return B + V with candidates list, overflow causes NIL value";
pattern +(v:sht,b:bat[:bte]) :bat[:sht]
address CMDbatADDsignal
comment "Return V + B, signal error on overflow";
pattern +(v:sht,b:bat[:bte],s:bat[:oid]) :bat[:sht]
address CMDbatADDsignal
comment "Return V + B with candidates list, signal error on overflow";
pattern add_noerror(v:sht,b:bat[:bte]) :bat[:sht]
address CMDbatADD
comment "Return V + B, overflow causes NIL value";
pattern add_noerror(v:sht,b:bat[:bte],s:bat[:oid]) :bat[:sht]
address CMDbatADD
comment "Return V + B with candidates list, overflow causes NIL value";

pattern +(b1:bat[:sht],b2:bat[:sht]) :bat[:sht]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
pattern +(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]) :bat[:sht]
address CMDbatADDsignal
comment "Return B1 + B2 with candidates list, signal error on overflow";
pattern add_noerror(b1:bat[:sht],b2:bat[:sht]) :bat[:sht]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern add_noerror(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]) :bat[:sht]
address CMDbatADD
comment "Return B1 + B2 with candidates list, overflow causes NIL value";
pattern +(b:bat[:sht],v:sht) :bat[:sht]
address CMDbatADDsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:sht],v:sht,s:bat[:oid]) :bat[:sht]
address CMDbatADDsignal
comment "Return B + V with candidates list, signal error on overflow";
pattern add_noerror(b:bat[:sht],v:sht) :bat[:sht]
address CMDbatADD
comment "Return B + V, overflow causes NIL value";
pattern add_noerror(b:bat[:sht],v:sht,s:bat[:oid]) :bat[:sht]
address CMDbatADD
comment "Return B + V with candidates list, overflow causes NIL value";
pattern +(v:sht,b:bat[:sht]) :bat[:sht]
address CMDbatADDsignal
comment "Return V + B, signal error on overflow";
pattern +(v:sht,b:bat[:sht],s:bat[:oid]) :bat[:sht]
address CMDbatADDsignal
comment "Return V + B with candidates list, signal error on overflow";
pattern add_noerror(v:sht,b:bat[:sht]) :bat[:sht]
address CMDbatADD
comment "Return V + B, overflow causes NIL value";
pattern add_noerror(v:sht,b:bat[:sht],s:bat[:oid]) :bat[:sht]
address CMDbatADD
comment "Return V + B with candidates list, overflow causes NIL value";

pattern +(b1:bat[:sht],b2:bat[:int]) :bat[:int]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
pattern +(b1:bat[:sht],b2:bat[:int],s:bat[:oid]) :bat[:int]
address CMDbatADDsignal
comment "Return B1 + B2 with candidates list, signal error on overflow";
pattern add_noerror(b1:bat[:sht],b2:bat[:int]) :bat[:int]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern add_noerror(b1:bat[:sht],b2:bat[:int],s:bat[:oid]) :bat[:int]
address CMDbatADD
comment "Return B1 + B2 with candidates list, overflow causes NIL value";
pattern +(b:bat[:sht],v:int) :bat[:int]
address CMDbatADDsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:sht],v:int,s:bat[:oid]) :bat[:int]
address CMDbatADDsignal
comment "Return B + V with candidates list, signal error on overflow";
pattern add_noerror(b:bat[:sht],v:int) :bat[:int]
address CMDbatADD
comment "Return B + V, overflow causes NIL value";
pattern add_noerror(b:bat[:sht],v:int,s:bat[:oid]) :bat[:int]
address CMDbatADD
comment "Return B + V with candidates list, overflow causes NIL value";
pattern +(v:sht,b:bat[:int]) :bat[:int]
address CMDbatADDsignal
comment "Return V + B, signal error on overflow";
pattern +(v:sht,b:bat[:int],s:bat[:oid]) :bat[:int]
address CMDbatADDsignal
comment "Return V + B with candidates list, signal error on overflow";
pattern add_noerror(v:sht,b:bat[:int]) :bat[:int]
address CMDbatADD
comment "Return V + B, overflow causes NIL value";
pattern add_noerror(v:sht,b:bat[:int],s:bat[:oid]) :bat[:int]
address CMDbatADD
comment "Return V + B with candidates list, overflow causes NIL value";

pattern +(b1:bat[:sht],b2:bat[:lng]) :bat[:lng]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
pattern +(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]) :bat[:lng]
address CMDbatADDsignal
comment "Return B1 + B2 with candidates list, signal error on overflow";
pattern add_noerror(b1:bat[:sht],b2:bat[:lng]) :bat[:lng]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern add_noerror(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]) :bat[:lng]
address CMDbatADD
comment "Return B1 + B2 with candidates list, overflow causes NIL value";
pattern +(b:bat[:sht],v:lng) :bat[:lng]
address CMDbatADDsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:sht],v:lng,s:bat[:oid]) :bat[:lng]
address CMDbatADDsignal
comment "Return B + V with candidates list, signal error on overflow";
pattern add_noerror(b:bat[:sht],v:lng) :bat[:lng]
address CMDbatADD
comment "Return B + V, overflow causes NIL value";
pattern add_noerror(b:bat[:sht],v:lng,s:bat[:oid]) :bat[:lng]
address CMDbatADD
comment "Return B + V with candidates list, overflow causes NIL value";
pattern +(v:sht,b:bat[:lng]) :bat[:lng]
address CMDbatADDsignal
comment "Return V + B, signal error on overflow";
pattern +(v:sht,b:bat[:lng],s:bat[:oid]) :bat[:lng]
address CMDbatADDsignal
comment "Return V + B with candidates list, signal error on overflow";
pattern add_noerror(v:sht,b:bat[:lng]) :bat[:lng]
address CMDbatADD
comment "Return V + B, overflow causes NIL value";
pattern add_noerror(v:sht,b:bat[:lng],s:bat[:oid]) :bat[:lng]
address CMDbatADD
comment "Return V + B with candidates list, overflow causes NIL value";

pattern +(b1:bat[:sht],b2:bat[:flt]) :bat[:flt]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
pattern +(b1:bat[:sht],b2:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatADDsignal
comment "Return B1 + B2 with candidates list, signal error on overflow";
pattern add_noerror(b1:bat[:sht],b2:bat[:flt]) :bat[:flt]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern add_noerror(b1:bat[:sht],b2:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatADD
comment "Return B1 + B2 with candidates list, overflow causes NIL value";
pattern +(b:bat[:sht],v:flt) :bat[:flt]
address CMDbatADDsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:sht],v:flt,s:bat[:oid]) :bat[:flt]
address CMDbatADDsignal
comment "Return B + V with candidates list, signal error on overflow";
pattern add_noerror(b:bat[:sht],v:flt) :bat[:flt]
address CMDbatADD
comment "Return B + V, overflow causes NIL value";
pattern add_noerror(b:bat[:sht],v:flt,s:bat[:oid]) :bat[:flt]
address CMDbatADD
comment "Return B + V with candidates list, overflow causes NIL value";
pattern +(v:sht,b:bat[:flt]) :bat[:flt]
address CMDbatADDsignal
comment "Return V + B, signal error on overflow";
pattern +(v:sht,b:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatADDsignal
comment "Return V + B with candidates list, signal error on overflow";
pattern add_noerror(v:sht,b:bat[:flt]) :bat[:flt]
address CMDbatADD
comment "Return V + B, overflow causes NIL value";
pattern add_noerror(v:sht,b:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatADD
comment "Return V + B with candidates list, overflow causes NIL value";

pattern +(b1:bat[:sht],b2:bat[:dbl]) :bat[:dbl]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
pattern +(b1:bat[:sht],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatADDsignal
comment "Return B1 + B2 with candidates list, signal error on overflow";
pattern add_noerror(b1:bat[:sht],b2:bat[:dbl]) :bat[:dbl]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern add_noerror(b1:bat[:sht],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatADD
comment "Return B1 + B2 with candidates list, overflow causes NIL value";
pattern +(b:bat[:sht],v:dbl) :bat[:dbl]
address CMDbatADDsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:sht],v:dbl,s:bat[:oid]) :bat[:dbl]
address CMDbatADDsignal
comment "Return B + V with candidates list, signal error on overflow";
pattern add_noerror(b:bat[:sht],v:dbl) :bat[:dbl]
address CMDbatADD
comment "Return B + V, overflow causes NIL value";
pattern add_noerror(b:bat[:sht],v:dbl,s:bat[:oid]) :bat[:dbl]
address CMDbatADD
comment "Return B + V with candidates list, overflow causes NIL value";
pattern +(v:sht,b:bat[:dbl]) :bat[:dbl]
address CMDbatADDsignal
comment "Return V + B, signal error on overflow";
pattern +(v:sht,b:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatADDsignal
comment "Return V + B with candidates list, signal error on overflow";
pattern add_noerror(v:sht,b:bat[:dbl]) :bat[:dbl]
address CMDbatADD
comment "Return V + B, overflow causes NIL value";
pattern add_noerror(v:sht,b:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatADD
comment "Return V + B with candidates list, overflow causes NIL value";

pattern +(b1:bat[:int],b2:bat[:bte]) :bat[:int]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
pattern +(b1:bat[:int],b2:bat[:bte],s:bat[:oid]) :bat[:int]
address CMDbatADDsignal
comment "Return B1 + B2 with candidates list, signal error on overflow";
pattern add_noerror(b1:bat[:int],b2:bat[:bte]) :bat[:int]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern add_noerror(b1:bat[:int],b2:bat[:bte],s:bat[:oid]) :bat[:int]
address CMDbatADD
comment "Return B1 + B2 with candidates list, overflow causes NIL value";
pattern +(b:bat[:int],v:bte) :bat[:int]
address CMDbatADDsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:int],v:bte,s:bat[:oid]) :bat[:int]
address CMDbatADDsignal
comment "Return B + V with candidates list, signal error on overflow";
pattern add_noerror(b:bat[:int],v:bte) :bat[:int]
address CMDbatADD
comment "Return B + V, overflow causes NIL value";
pattern add_noerror(b:bat[:int],v:bte,s:bat[:oid]) :bat[:int]
address CMDbatADD
comment "Return B + V with candidates list, overflow causes NIL value";
pattern +(v:int,b:bat[:bte]) :bat[:int]
address CMDbatADDsignal
comment "Return V + B, signal error on overflow";
pattern +(v:int,b:bat[:bte],s:bat[:oid]) :bat[:int]
address CMDbatADDsignal
comment "Return V + B with candidates list, signal error on overflow";
pattern add_noerror(v:int,b:bat[:bte]) :bat[:int]
address CMDbatADD
comment "Return V + B, overflow causes NIL value";
pattern add_noerror(v:int,b:bat[:bte],s:bat[:oid]) :bat[:int]
address CMDbatADD
comment "Return V + B with candidates list, overflow causes NIL value";

pattern +(b1:bat[:int],b2:bat[:sht]) :bat[:int]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
pattern +(b1:bat[:int],b2:bat[:sht],s:bat[:oid]) :bat[:int]
address CMDbatADDsignal
comment "Return B1 + B2 with candidates list, signal error on overflow";
pattern add_noerror(b1:bat[:int],b2:bat[:sht]) :bat[:int]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern add_noerror(b1:bat[:int],b2:bat[:sht],s:bat[:oid]) :bat[:int]
address CMDbatADD
comment "Return B1 + B2 with candidates list, overflow causes NIL value";
pattern +(b:bat[:int],v:sht) :bat[:int]
address CMDbatADDsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:int],v:sht,s:bat[:oid]) :bat[:int]
address CMDbatADDsignal
comment "Return B + V with candidates list, signal error on overflow";
pattern add_noerror(b:bat[:int],v:sht) :bat[:int]
address CMDbatADD
comment "Return B + V, overflow causes NIL value";
pattern add_noerror(b:bat[:int],v:sht,s:bat[:oid]) :bat[:int]
address CMDbatADD
comment "Return B + V with candidates list, overflow causes NIL value";
pattern +(v:int,b:bat[:sht]) :bat[:int]
address CMDbatADDsignal
comment "Return V + B, signal error on overflow";
pattern +(v:int,b:bat[:sht],s:bat[:oid]) :bat[:int]
address CMDbatADDsignal
comment "Return V + B with candidates list, signal error on overflow";
pattern add_noerror(v:int,b:bat[:sht]) :bat[:int]
address CMDbatADD
comment "Return V + B, overflow causes NIL value";
pattern add_noerror(v:int,b:bat[:sht],s:bat[:oid]) :bat[:int]
address CMDbatADD
comment "Return V + B with candidates list, overflow causes NIL value";

pattern +(b1:bat[:int],b2:bat[:int]) :bat[:int]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
pattern +(b1:bat[:int],b2:bat[:int],s:bat[:oid]) :bat[:int]
address CMDbatADDsignal
comment "Return B1 + B2 with candidates list, signal error on overflow";
pattern add_noerror(b1:bat[:int],b2:bat[:int]) :bat[:int]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern add_noerror(b1:bat[:int],b2:bat[:int],s:bat[:oid]) :bat[:int]
address CMDbatADD
comment "Return B1 + B2 with candidates list, overflow causes NIL value";
pattern +(b:bat[:int],v:int) :bat[:int]
address CMDbatADDsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:int],v:int,s:bat[:oid]) :bat[:int]
address CMDbatADDsignal
comment "Return B + V with candidates list, signal error on overflow";
pattern add_noerror(b:bat[:int],v:int) :bat[:int]
address CMDbatADD
comment "Return B + V, overflow causes NIL value";
pattern add_noerror(b:bat[:int],v:int,s:bat[:oid]) :bat[:int]
address CMDbatADD
comment "Return B + V with candidates list, overflow causes NIL value";
pattern +(v:int,b:bat[:int]) :bat[:int]
address CMDbatADDsignal
comment "Return V + B, signal error on overflow";
pattern +(v:int,b:bat[:int],s:bat[:oid]) :bat[:int]
address CMDbatADDsignal
comment "Return V + B with candidates list, signal error on overflow";
pattern add_noerror(v:int,b:bat[:int]) :bat[:int]
address CMDbatADD
comment "Return V + B, overflow causes NIL value";
pattern add_noerror(v:int,b:bat[:int],s:bat[:oid]) :bat[:int]
address CMDbatADD
comment "Return V + B with candidates list, overflow causes NIL value";

pattern +(b1:bat[:int],b2:bat[:lng]) :bat[:lng]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
pattern +(b1:bat[:int],b2:bat[:lng],s:bat[:oid]) :bat[:lng]
address CMDbatADDsignal
comment "Return B1 + B2 with candidates list, signal error on overflow";
pattern add_noerror(b1:bat[:int],b2:bat[:lng]) :bat[:lng]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern add_noerror(b1:bat[:int],b2:bat[:lng],s:bat[:oid]) :bat[:lng]
address CMDbatADD
comment "Return B1 + B2 with candidates list, overflow causes NIL value";
pattern +(b:bat[:int],v:lng) :bat[:lng]
address CMDbatADDsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:int],v:lng,s:bat[:oid]) :bat[:lng]
address CMDbatADDsignal
comment "Return B + V with candidates list, signal error on overflow";
pattern add_noerror(b:bat[:int],v:lng) :bat[:lng]
address CMDbatADD
comment "Return B + V, overflow causes NIL value";
pattern add_noerror(b:bat[:int],v:lng,s:bat[:oid]) :bat[:lng]
address CMDbatADD
comment "Return B + V with candidates list, overflow causes NIL value";
pattern +(v:int,b:bat[:lng]) :bat[:lng]
address CMDbatADDsignal
comment "Return V + B, signal error on overflow";
pattern +(v:int,b:bat[:lng],s:bat[:oid]) :bat[:lng]
address CMDbatADDsignal
comment "Return V + B with candidates list, signal error on overflow";
pattern add_noerror(v:int,b:bat[:lng]) :bat[:lng]
address CMDbatADD
comment "Return V + B, overflow causes NIL value";
pattern add_noerror(v:int,b:bat[:lng],s:bat[:oid]) :bat[:lng]
address CMDbatADD
comment "Return V + B with candidates list, overflow causes NIL value";

pattern +(b1:bat[:int],b2:bat[:flt]) :bat[:flt]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
pattern +(b1:bat[:int],b2:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatADDsignal
comment "Return B1 + B2 with candidates list, signal error on overflow";
pattern add_noerror(b1:bat[:int],b2:bat[:flt]) :bat[:flt]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern add_noerror(b1:bat[:int],b2:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatADD
comment "Return B1 + B2 with candidates list, overflow causes NIL value";
pattern +(b:bat[:int],v:flt) :bat[:flt]
address CMDbatADDsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:int],v:flt,s:bat[:oid]) :bat[:flt]
address CMDbatADDsignal
comment "Return B + V with candidates list, signal error on overflow";
pattern add_noerror(b:bat[:int],v:flt) :bat[:flt]
address CMDbatADD
comment "Return B + V, overflow causes NIL value";
pattern add_noerror(b:bat[:int],v:flt,s:bat[:oid]) :bat[:flt]
address CMDbatADD
comment "Return B + V with candidates list, overflow causes NIL value";
pattern +(v:int,b:bat[:flt]) :bat[:flt]
address CMDbatADDsignal
comment "Return V + B, signal error on overflow";
pattern +(v:int,b:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatADDsignal
comment "Return V + B with candidates list, signal error on overflow";
pattern add_noerror(v:int,b:bat[:flt]) :bat[:flt]
address CMDbatADD
comment "Return V + B, overflow causes NIL value";
pattern add_noerror(v:int,b:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatADD
comment "Return V + B with candidates list, overflow causes NIL value";

pattern +(b1:bat[:int],b2:bat[:dbl]) :bat[:dbl]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
pattern +(b1:bat[:int],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatADDsignal
comment "Return B1 + B2 with candidates list, signal error on overflow";
pattern add_noerror(b1:bat[:int],b2:bat[:dbl]) :bat[:dbl]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern add_noerror(b1:bat[:int],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatADD
comment "Return B1 + B2 with candidates list, overflow causes NIL value";
pattern +(b:bat[:int],v:dbl) :bat[:dbl]
address CMDbatADDsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:int],v:dbl,s:bat[:oid]) :bat[:dbl]
address CMDbatADDsignal
comment "Return B + V with candidates list, signal error on overflow";
pattern add_noerror(b:bat[:int],v:dbl) :bat[:dbl]
address CMDbatADD
comment "Return B + V, overflow causes NIL value";
pattern add_noerror(b:bat[:int],v:dbl,s:bat[:oid]) :bat[:dbl]
address CMDbatADD
comment "Return B + V with candidates list, overflow causes NIL value";
pattern +(v:int,b:bat[:dbl]) :bat[:dbl]
address CMDbatADDsignal
comment "Return V + B, signal error on overflow";
pattern +(v:int,b:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatADDsignal
comment "Return V + B with candidates list, signal error on overflow";
pattern add_noerror(v:int,b:bat[:dbl]) :bat[:dbl]
address CMDbatADD
comment "Return V + B, overflow causes NIL value";
pattern add_noerror(v:int,b:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatADD
comment "Return V + B with candidates list, overflow causes NIL value";

pattern +(b1:bat[:lng],b2:bat[:bte]) :bat[:lng]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
pattern +(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]) :bat[:lng]
address CMDbatADDsignal
comment "Return B1 + B2 with candidates list, signal error on overflow";
pattern add_noerror(b1:bat[:lng],b2:bat[:bte]) :bat[:lng]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern add_noerror(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]) :bat[:lng]
address CMDbatADD
comment "Return B1 + B2 with candidates list, overflow causes NIL value";
pattern +(b:bat[:lng],v:bte) :bat[:lng]
address CMDbatADDsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:lng],v:bte,s:bat[:oid]) :bat[:lng]
address CMDbatADDsignal
comment "Return B + V with candidates list, signal error on overflow";
pattern add_noerror(b:bat[:lng],v:bte) :bat[:lng]
address CMDbatADD
comment "Return B + V, overflow causes NIL value";
pattern add_noerror(b:bat[:lng],v:bte,s:bat[:oid]) :bat[:lng]
address CMDbatADD
comment "Return B + V with candidates list, overflow causes NIL value";
pattern +(v:lng,b:bat[:bte]) :bat[:lng]
address CMDbatADDsignal
comment "Return V + B, signal error on overflow";
pattern +(v:lng,b:bat[:bte],s:bat[:oid]) :bat[:lng]
address CMDbatADDsignal
comment "Return V + B with candidates list, signal error on overflow";
pattern add_noerror(v:lng,b:bat[:bte]) :bat[:lng]
address CMDbatADD
comment "Return V + B, overflow causes NIL value";
pattern add_noerror(v:lng,b:bat[:bte],s:bat[:oid]) :bat[:lng]
address CMDbatADD
comment "Return V + B with candidates list, overflow causes NIL value";

pattern +(b1:bat[:lng],b2:bat[:sht]) :bat[:lng]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
pattern +(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]) :bat[:lng]
address CMDbatADDsignal
comment "Return B1 + B2 with candidates list, signal error on overflow";
pattern add_noerror(b1:bat[:lng],b2:bat[:sht]) :bat[:lng]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern add_noerror(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]) :bat[:lng]
address CMDbatADD
comment "Return B1 + B2 with candidates list, overflow causes NIL value";
pattern +(b:bat[:lng],v:sht) :bat[:lng]
address CMDbatADDsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:lng],v:sht,s:bat[:oid]) :bat[:lng]
address CMDbatADDsignal
comment "Return B + V with candidates list, signal error on overflow";
pattern add_noerror(b:bat[:lng],v:sht) :bat[:lng]
address CMDbatADD
comment "Return B + V, overflow causes NIL value";
pattern add_noerror(b:bat[:lng],v:sht,s:bat[:oid]) :bat[:lng]
address CMDbatADD
comment "Return B + V with candidates list, overflow causes NIL value";
pattern +(v:lng,b:bat[:sht]) :bat[:lng]
address CMDbatADDsignal
comment "Return V + B, signal error on overflow";
pattern +(v:lng,b:bat[:sht],s:bat[:oid]) :bat[:lng]
address CMDbatADDsignal
comment "Return V + B with candidates list, signal error on overflow";
pattern add_noerror(v:lng,b:bat[:sht]) :bat[:lng]
address CMDbatADD
comment "Return V + B, overflow causes NIL value";
pattern add_noerror(v:lng,b:bat[:sht],s:bat[:oid]) :bat[:lng]
address CMDbatADD
comment "Return V + B with candidates list, overflow causes NIL value";

pattern +(b1:bat[:lng],b2:bat[:int]) :bat[:lng]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
pattern +(b1:bat[:lng],b2:bat[:int],s:bat[:oid]) :bat[:lng]
address CMDbatADDsignal
comment "Return B1 + B2 with candidates list, signal error on overflow";
pattern add_noerror(b1:bat[:lng],b2:bat[:int]) :bat[:lng]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern add_noerror(b1:bat[:lng],b2:bat[:int],s:bat[:oid]) :bat[:lng]
address CMDbatADD
comment "Return B1 + B2 with candidates list, overflow causes NIL value";
pattern +(b:bat[:lng],v:int) :bat[:lng]
address CMDbatADDsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:lng],v:int,s:bat[:oid]) :bat[:lng]
address CMDbatADDsignal
comment "Return B + V with candidates list, signal error on overflow";
pattern add_noerror(b:bat[:lng],v:int) :bat[:lng]
address CMDbatADD
comment "Return B + V, overflow causes NIL value";
pattern add_noerror(b:bat[:lng],v:int,s:bat[:oid]) :bat[:lng]
address CMDbatADD
comment "Return B + V with candidates list, overflow causes NIL value";
pattern +(v:lng,b:bat[:int]) :bat[:lng]
address CMDbatADDsignal
comment "Return V + B, signal error on overflow";
pattern +(v:lng,b:bat[:int],s:bat[:oid]) :bat[:lng]
address CMDbatADDsignal
comment "Return V + B with candidates list, signal error on overflow";
pattern add_noerror(v:lng,b:bat[:int]) :bat[:lng]
address CMDbatADD
comment "Return V + B, overflow causes NIL value";
pattern add_noerror(v:lng,b:bat[:int],s:bat[:oid]) :bat[:lng]
address CMDbatADD
comment "Return V + B with candidates list, overflow causes NIL value";

pattern +(b1:bat[:lng],b2:bat[:lng]) :bat[:lng]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
pattern +(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]) :bat[:lng]
address CMDbatADDsignal
comment "Return B1 + B2 with candidates list, signal error on overflow";
pattern add_noerror(b1:bat[:lng],b2:bat[:lng]) :bat[:lng]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern add_noerror(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]) :bat[:lng]
address CMDbatADD
comment "Return B1 + B2 with candidates list, overflow causes NIL value";
pattern +(b:bat[:lng],v:lng) :bat[:lng]
address CMDbatADDsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:lng],v:lng,s:bat[:oid]) :bat[:lng]
address CMDbatADDsignal
comment "Return B + V with candidates list, signal error on overflow";
pattern add_noerror(b:bat[:lng],v:lng) :bat[:lng]
address CMDbatADD
comment "Return B + V, overflow causes NIL value";
pattern add_noerror(b:bat[:lng],v:lng,s:bat[:oid]) :bat[:lng]
address CMDbatADD
comment "Return B + V with candidates list, overflow causes NIL value";
pattern +(v:lng,b:bat[:lng]) :bat[:lng]
address CMDbatADDsignal
comment "Return V + B, signal error on overflow";
pattern +(v:lng,b:bat[:lng],s:bat[:oid]) :bat[:lng]
address CMDbatADDsignal
comment "Return V + B with candidates list, signal error on overflow";
pattern add_noerror(v:lng,b:bat[:lng]) :bat[:lng]
address CMDbatADD
comment "Return V + B, overflow causes NIL value";
pattern add_noerror(v:lng,b:bat[:lng],s:bat[:oid]) :bat[:lng]
address CMDbatADD
comment "Return V + B with candidates list, overflow causes NIL value";

pattern +(b1:bat[:lng],b2:bat[:flt]) :bat[:flt]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
pattern +(b1:bat[:lng],b2:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatADDsignal
comment "Return B1 + B2 with candidates list, signal error on overflow";
pattern add_noerror(b1:bat[:lng],b2:bat[:flt]) :bat[:flt]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern add_noerror(b1:bat[:lng],b2:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatADD
comment "Return B1 + B2 with candidates list, overflow causes NIL value";
pattern +(b:bat[:lng],v:flt) :bat[:flt]
address CMDbatADDsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:lng],v:flt,s:bat[:oid]) :bat[:flt]
address CMDbatADDsignal
comment "Return B + V with candidates list, signal error on overflow";
pattern add_noerror(b:bat[:lng],v:flt) :bat[:flt]
address CMDbatADD
comment "Return B + V, overflow causes NIL value";
pattern add_noerror(b:bat[:lng],v:flt,s:bat[:oid]) :bat[:flt]
address CMDbatADD
comment "Return B + V with candidates list, overflow causes NIL value";
pattern +(v:lng,b:bat[:flt]) :bat[:flt]
address CMDbatADDsignal
comment "Return V + B, signal error on overflow";
pattern +(v:lng,b:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatADDsignal
comment "Return V + B with candidates list, signal error on overflow";
pattern add_noerror(v:lng,b:bat[:flt]) :bat[:flt]
address CMDbatADD
comment "Return V + B, overflow causes NIL value";
pattern add_noerror(v:lng,b:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatADD
comment "Return V + B with candidates list, overflow causes NIL value";

pattern +(b1:bat[:lng],b2:bat[:dbl]) :bat[:dbl]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
pattern +(b1:bat[:lng],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatADDsignal
comment "Return B1 + B2 with candidates list, signal error on overflow";
pattern add_noerror(b1:bat[:lng],b2:bat[:dbl]) :bat[:dbl]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern add_noerror(b1:bat[:lng],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatADD
comment "Return B1 + B2 with candidates list, overflow causes NIL value";
pattern +(b:bat[:lng],v:dbl) :bat[:dbl]
address CMDbatADDsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:lng],v:dbl,s:bat[:oid]) :bat[:dbl]
address CMDbatADDsignal
comment "Return B + V with candidates list, signal error on overflow";
pattern add_noerror(b:bat[:lng],v:dbl) :bat[:dbl]
address CMDbatADD
comment "Return B + V, overflow causes NIL value";
pattern add_noerror(b:bat[:lng],v:dbl,s:bat[:oid]) :bat[:dbl]
address CMDbatADD
comment "Return B + V with candidates list, overflow causes NIL value";
pattern +(v:lng,b:bat[:dbl]) :bat[:dbl]
address CMDbatADDsignal
comment "Return V + B, signal error on overflow";
pattern +(v:lng,b:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatADDsignal
comment "Return V + B with candidates list, signal error on overflow";
pattern add_noerror(v:lng,b:bat[:dbl]) :bat[:dbl]
address CMDbatADD
comment "Return V + B, overflow causes NIL value";
pattern add_noerror(v:lng,b:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatADD
comment "Return V + B with candidates list, overflow causes NIL value";

pattern +(b1:bat[:flt],b2:bat[:bte]) :bat[:flt]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
pattern +(b1:bat[:flt],b2:bat[:bte],s:bat[:oid]) :bat[:flt]
address CMDbatADDsignal
comment "Return B1 + B2 with candidates list, signal error on overflow";
pattern add_noerror(b1:bat[:flt],b2:bat[:bte]) :bat[:flt]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern add_noerror(b1:bat[:flt],b2:bat[:bte],s:bat[:oid]) :bat[:flt]
address CMDbatADD
comment "Return B1 + B2 with candidates list, overflow causes NIL value";
pattern +(b:bat[:flt],v:bte) :bat[:flt]
address CMDbatADDsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:flt],v:bte,s:bat[:oid]) :bat[:flt]
address CMDbatADDsignal
comment "Return B + V with candidates list, signal error on overflow";
pattern add_noerror(b:bat[:flt],v:bte) :bat[:flt]
address CMDbatADD
comment "Return B + V, overflow causes NIL value";
pattern add_noerror(b:bat[:flt],v:bte,s:bat[:oid]) :bat[:flt]
address CMDbatADD
comment "Return B + V with candidates list, overflow causes NIL value";
pattern +(v:flt,b:bat[:bte]) :bat[:flt]
address CMDbatADDsignal
comment "Return V + B, signal error on overflow";
pattern +(v:flt,b:bat[:bte],s:bat[:oid]) :bat[:flt]
address CMDbatADDsignal
comment "Return V + B with candidates list, signal error on overflow";
pattern add_noerror(v:flt,b:bat[:bte]) :bat[:flt]
address CMDbatADD
comment "Return V + B, overflow causes NIL value";
pattern add_noerror(v:flt,b:bat[:bte],s:bat[:oid]) :bat[:flt]
address CMDbatADD
comment "Return V + B with candidates list, overflow causes NIL value";

pattern +(b1:bat[:flt],b2:bat[:sht]) :bat[:flt]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
pattern +(b1:bat[:flt],b2:bat[:sht],s:bat[:oid]) :bat[:flt]
address CMDbatADDsignal
comment "Return B1 + B2 with candidates list, signal error on overflow";
pattern add_noerror(b1:bat[:flt],b2:bat[:sht]) :bat[:flt]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern add_noerror(b1:bat[:flt],b2:bat[:sht],s:bat[:oid]) :bat[:flt]
address CMDbatADD
comment "Return B1 + B2 with candidates list, overflow causes NIL value";
pattern +(b:bat[:flt],v:sht) :bat[:flt]
address CMDbatADDsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:flt],v:sht,s:bat[:oid]) :bat[:flt]
address CMDbatADDsignal
comment "Return B + V with candidates list, signal error on overflow";
pattern add_noerror(b:bat[:flt],v:sht) :bat[:flt]
address CMDbatADD
comment "Return B + V, overflow causes NIL value";
pattern add_noerror(b:bat[:flt],v:sht,s:bat[:oid]) :bat[:flt]
address CMDbatADD
comment "Return B + V with candidates list, overflow causes NIL value";
pattern +(v:flt,b:bat[:sht]) :bat[:flt]
address CMDbatADDsignal
comment "Return V + B, signal error on overflow";
pattern +(v:flt,b:bat[:sht],s:bat[:oid]) :bat[:flt]
address CMDbatADDsignal
comment "Return V + B with candidates list, signal error on overflow";
pattern add_noerror(v:flt,b:bat[:sht]) :bat[:flt]
address CMDbatADD
comment "Return V + B, overflow causes NIL value";
pattern add_noerror(v:flt,b:bat[:sht],s:bat[:oid]) :bat[:flt]
address CMDbatADD
comment "Return V + B with candidates list, overflow causes NIL value";

pattern +(b1:bat[:flt],b2:bat[:int]) :bat[:flt]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
pattern +(b1:bat[:flt],b2:bat[:int],s:bat[:oid]) :bat[:flt]
address CMDbatADDsignal
comment "Return B1 + B2 with candidates list, signal error on overflow";
pattern add_noerror(b1:bat[:flt],b2:bat[:int]) :bat[:flt]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern add_noerror(b1:bat[:flt],b2:bat[:int],s:bat[:oid]) :bat[:flt]
address CMDbatADD
comment "Return B1 + B2 with candidates list, overflow causes NIL value";
pattern +(b:bat[:flt],v:int) :bat[:flt]
address CMDbatADDsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:flt],v:int,s:bat[:oid]) :bat[:flt]
address CMDbatADDsignal
comment "Return B + V with candidates list, signal error on overflow";
pattern add_noerror(b:bat[:flt],v:int) :bat[:flt]
address CMDbatADD
comment "Return B + V, overflow causes NIL value";
pattern add_noerror(b:bat[:flt],v:int,s:bat[:oid]) :bat[:flt]
address CMDbatADD
comment "Return B + V with candidates list, overflow causes NIL value";
pattern +(v:flt,b:bat[:int]) :bat[:flt]
address CMDbatADDsignal
comment "Return V + B, signal error on overflow";
pattern +(v:flt,b:bat[:int],s:bat[:oid]) :bat[:flt]
address CMDbatADDsignal
comment "Return V + B with candidates list, signal error on overflow";
pattern add_noerror(v:flt,b:bat[:int]) :bat[:flt]
address CMDbatADD
comment "Return V + B, overflow causes NIL value";
pattern add_noerror(v:flt,b:bat[:int],s:bat[:oid]) :bat[:flt]
address CMDbatADD
comment "Return V + B with candidates list, overflow causes NIL value";

pattern +(b1:bat[:flt],b2:bat[:lng]) :bat[:flt]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
pattern +(b1:bat[:flt],b2:bat[:lng],s:bat[:oid]) :bat[:flt]
address CMDbatADDsignal
comment "Return B1 + B2 with candidates list, signal error on overflow";
pattern add_noerror(b1:bat[:flt],b2:bat[:lng]) :bat[:flt]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern add_noerror(b1:bat[:flt],b2:bat[:lng],s:bat[:oid]) :bat[:flt]
address CMDbatADD
comment "Return B1 + B2 with candidates list, overflow causes NIL value";
pattern +(b:bat[:flt],v:lng) :bat[:flt]
address CMDbatADDsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:flt],v:lng,s:bat[:oid]) :bat[:flt]
address CMDbatADDsignal
comment "Return B + V with candidates list, signal error on overflow";
pattern add_noerror(b:bat[:flt],v:lng) :bat[:flt]
address CMDbatADD
comment "Return B + V, overflow causes NIL value";
pattern add_noerror(b:bat[:flt],v:lng,s:bat[:oid]) :bat[:flt]
address CMDbatADD
comment "Return B + V with candidates list, overflow causes NIL value";
pattern +(v:flt,b:bat[:lng]) :bat[:flt]
address CMDbatADDsignal
comment "Return V + B, signal error on overflow";
pattern +(v:flt,b:bat[:lng],s:bat[:oid]) :bat[:flt]
address CMDbatADDsignal
comment "Return V + B with candidates list, signal error on overflow";
pattern add_noerror(v:flt,b:bat[:lng]) :bat[:flt]
address CMDbatADD
comment "Return V + B, overflow causes NIL value";
pattern add_noerror(v:flt,b:bat[:lng],s:bat[:oid]) :bat[:flt]
address CMDbatADD
comment "Return V + B with candidates list, overflow causes NIL value";

pattern +(b1:bat[:flt],b2:bat[:flt]) :bat[:flt]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
pattern +(b1:bat[:flt],b2:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatADDsignal
comment "Return B1 + B2 with candidates list, signal error on overflow";
pattern add_noerror(b1:bat[:flt],b2:bat[:flt]) :bat[:flt]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern add_noerror(b1:bat[:flt],b2:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatADD
comment "Return B1 + B2 with candidates list, overflow causes NIL value";
pattern +(b:bat[:flt],v:flt) :bat[:flt]
address CMDbatADDsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:flt],v:flt,s:bat[:oid]) :bat[:flt]
address CMDbatADDsignal
comment "Return B + V with candidates list, signal error on overflow";
pattern add_noerror(b:bat[:flt],v:flt) :bat[:flt]
address CMDbatADD
comment "Return B + V, overflow causes NIL value";
pattern add_noerror(b:bat[:flt],v:flt,s:bat[:oid]) :bat[:flt]
address CMDbatADD
comment "Return B + V with candidates list, overflow causes NIL value";
pattern +(v:flt,b:bat[:flt]) :bat[:flt]
address CMDbatADDsignal
comment "Return V + B, signal error on overflow";
pattern +(v:flt,b:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatADDsignal
comment "Return V + B with candidates list, signal error on overflow";
pattern add_noerror(v:flt,b:bat[:flt]) :bat[:flt]
address CMDbatADD
comment "Return V + B, overflow causes NIL value";
pattern add_noerror(v:flt,b:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatADD
comment "Return V + B with candidates list, overflow causes NIL value";

pattern +(b1:bat[:flt],b2:bat[:dbl]) :bat[:dbl]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
pattern +(b1:bat[:flt],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatADDsignal
comment "Return B1 + B2 with candidates list, signal error on overflow";
pattern add_noerror(b1:bat[:flt],b2:bat[:dbl]) :bat[:dbl]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern add_noerror(b1:bat[:flt],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatADD
comment "Return B1 + B2 with candidates list, overflow causes NIL value";
pattern +(b:bat[:flt],v:dbl) :bat[:dbl]
address CMDbatADDsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:flt],v:dbl,s:bat[:oid]) :bat[:dbl]
address CMDbatADDsignal
comment "Return B + V with candidates list, signal error on overflow";
pattern add_noerror(b:bat[:flt],v:dbl) :bat[:dbl]
address CMDbatADD
comment "Return B + V, overflow causes NIL value";
pattern add_noerror(b:bat[:flt],v:dbl,s:bat[:oid]) :bat[:dbl]
address CMDbatADD
comment "Return B + V with candidates list, overflow causes NIL value";
pattern +(v:flt,b:bat[:dbl]) :bat[:dbl]
address CMDbatADDsignal
comment "Return V + B, signal error on overflow";
pattern +(v:flt,b:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatADDsignal
comment "Return V + B with candidates list, signal error on overflow";
pattern add_noerror(v:flt,b:bat[:dbl]) :bat[:dbl]
address CMDbatADD
comment "Return V + B, overflow causes NIL value";
pattern add_noerror(v:flt,b:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatADD
comment "Return V + B with candidates list, overflow causes NIL value";

pattern +(b1:bat[:dbl],b2:bat[:bte]) :bat[:dbl]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
pattern +(b1:bat[:dbl],b2:bat[:bte],s:bat[:oid]) :bat[:dbl]
address CMDbatADDsignal
comment "Return B1 + B2 with candidates list, signal error on overflow";
pattern add_noerror(b1:bat[:dbl],b2:bat[:bte]) :bat[:dbl]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern add_noerror(b1:bat[:dbl],b2:bat[:bte],s:bat[:oid]) :bat[:dbl]
address CMDbatADD
comment "Return B1 + B2 with candidates list, overflow causes NIL value";
pattern +(b:bat[:dbl],v:bte) :bat[:dbl]
address CMDbatADDsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:dbl],v:bte,s:bat[:oid]) :bat[:dbl]
address CMDbatADDsignal
comment "Return B + V with candidates list, signal error on overflow";
pattern add_noerror(b:bat[:dbl],v:bte) :bat[:dbl]
address CMDbatADD
comment "Return B + V, overflow causes NIL value";
pattern add_noerror(b:bat[:dbl],v:bte,s:bat[:oid]) :bat[:dbl]
address CMDbatADD
comment "Return B + V with candidates list, overflow causes NIL value";
pattern +(v:dbl,b:bat[:bte]) :bat[:dbl]
address CMDbatADDsignal
comment "Return V + B, signal error on overflow";
pattern +(v:dbl,b:bat[:bte],s:bat[:oid]) :bat[:dbl]
address CMDbatADDsignal
comment "Return V + B with candidates list, signal error on overflow";
pattern add_noerror(v:dbl,b:bat[:bte]) :bat[:dbl]
address CMDbatADD
comment "Return V + B, overflow causes NIL value";
pattern add_noerror(v:dbl,b:bat[:bte],s:bat[:oid]) :bat[:dbl]
address CMDbatADD
comment "Return V + B with candidates list, overflow causes NIL value";

pattern +(b1:bat[:dbl],b2:bat[:sht]) :bat[:dbl]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
pattern +(b1:bat[:dbl],b2:bat[:sht],s:bat[:oid]) :bat[:dbl]
address CMDbatADDsignal
comment "Return B1 + B2 with candidates list, signal error on overflow";
pattern add_noerror(b1:bat[:dbl],b2:bat[:sht]) :bat[:dbl]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern add_noerror(b1:bat[:dbl],b2:bat[:sht],s:bat[:oid]) :bat[:dbl]
address CMDbatADD
comment "Return B1 + B2 with candidates list, overflow causes NIL value";
pattern +(b:bat[:dbl],v:sht) :bat[:dbl]
address CMDbatADDsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:dbl],v:sht,s:bat[:oid]) :bat[:dbl]
address CMDbatADDsignal
comment "Return B + V with candidates list, signal error on overflow";
pattern add_noerror(b:bat[:dbl],v:sht) :bat[:dbl]
address CMDbatADD
comment "Return B + V, overflow causes NIL value";
pattern add_noerror(b:bat[:dbl],v:sht,s:bat[:oid]) :bat[:dbl]
address CMDbatADD
comment "Return B + V with candidates list, overflow causes NIL value";
pattern +(v:dbl,b:bat[:sht]) :bat[:dbl]
address CMDbatADDsignal
comment "Return V + B, signal error on overflow";
pattern +(v:dbl,b:bat[:sht],s:bat[:oid]) :bat[:dbl]
address CMDbatADDsignal
comment "Return V + B with candidates list, signal error on overflow";
pattern add_noerror(v:dbl,b:bat[:sht]) :bat[:dbl]
address CMDbatADD
comment "Return V + B, overflow causes NIL value";
pattern add_noerror(v:dbl,b:bat[:sht],s:bat[:oid]) :bat[:dbl]
address CMDbatADD
comment "Return V + B with candidates list, overflow causes NIL value";

pattern +(b1:bat[:dbl],b2:bat[:int]) :bat[:dbl]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
pattern +(b1:bat[:dbl],b2:bat[:int],s:bat[:oid]) :bat[:dbl]
address CMDbatADDsignal
comment "Return B1 + B2 with candidates list, signal error on overflow";
pattern add_noerror(b1:bat[:dbl],b2:bat[:int]) :bat[:dbl]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern add_noerror(b1:bat[:dbl],b2:bat[:int],s:bat[:oid]) :bat[:dbl]
address CMDbatADD
comment "Return B1 + B2 with candidates list, overflow causes NIL value";
pattern +(b:bat[:dbl],v:int) :bat[:dbl]
address CMDbatADDsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:dbl],v:int,s:bat[:oid]) :bat[:dbl]
address CMDbatADDsignal
comment "Return B + V with candidates list, signal error on overflow";
pattern add_noerror(b:bat[:dbl],v:int) :bat[:dbl]
address CMDbatADD
comment "Return B + V, overflow causes NIL value";
pattern add_noerror(b:bat[:dbl],v:int,s:bat[:oid]) :bat[:dbl]
address CMDbatADD
comment "Return B + V with candidates list, overflow causes NIL value";
pattern +(v:dbl,b:bat[:int]) :bat[:dbl]
address CMDbatADDsignal
comment "Return V + B, signal error on overflow";
pattern +(v:dbl,b:bat[:int],s:bat[:oid]) :bat[:dbl]
address CMDbatADDsignal
comment "Return V + B with candidates list, signal error on overflow";
pattern add_noerror(v:dbl,b:bat[:int]) :bat[:dbl]
address CMDbatADD
comment "Return V + B, overflow causes NIL value";
pattern add_noerror(v:dbl,b:bat[:int],s:bat[:oid]) :bat[:dbl]
address CMDbatADD
comment "Return V + B with candidates list, overflow causes NIL value";

pattern +(b1:bat[:dbl],b2:bat[:lng]) :bat[:dbl]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
pattern +(b1:bat[:dbl],b2:bat[:lng],s:bat[:oid]) :bat[:dbl]
address CMDbatADDsignal
comment "Return B1 + B2 with candidates list, signal error on overflow";
pattern add_noerror(b1:bat[:dbl],b2:bat[:lng]) :bat[:dbl]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern add_noerror(b1:bat[:dbl],b2:bat[:lng],s:bat[:oid]) :bat[:dbl]
address CMDbatADD
comment "Return B1 + B2 with candidates list, overflow causes NIL value";
pattern +(b:bat[:dbl],v:lng) :bat[:dbl]
address CMDbatADDsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:dbl],v:lng,s:bat[:oid]) :bat[:dbl]
address CMDbatADDsignal
comment "Return B + V with candidates list, signal error on overflow";
pattern add_noerror(b:bat[:dbl],v:lng) :bat[:dbl]
address CMDbatADD
comment "Return B + V, overflow causes NIL value";
pattern add_noerror(b:bat[:dbl],v:lng,s:bat[:oid]) :bat[:dbl]
address CMDbatADD
comment "Return B + V with candidates list, overflow causes NIL value";
pattern +(v:dbl,b:bat[:lng]) :bat[:dbl]
address CMDbatADDsignal
comment "Return V + B, signal error on overflow";
pattern +(v:dbl,b:bat[:lng],s:bat[:oid]) :bat[:dbl]
address CMDbatADDsignal
comment "Return V + B with candidates list, signal error on overflow";
pattern add_noerror(v:dbl,b:bat[:lng]) :bat[:dbl]
address CMDbatADD
comment "Return V + B, overflow causes NIL value";
pattern add_noerror(v:dbl,b:bat[:lng],s:bat[:oid]) :bat[:dbl]
address CMDbatADD
comment "Return V + B with candidates list, overflow causes NIL value";

pattern +(b1:bat[:dbl],b2:bat[:flt]) :bat[:dbl]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
pattern +(b1:bat[:dbl],b2:bat[:flt],s:bat[:oid]) :bat[:dbl]
address CMDbatADDsignal
comment "Return B1 + B2 with candidates list, signal error on overflow";
pattern add_noerror(b1:bat[:dbl],b2:bat[:flt]) :bat[:dbl]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern add_noerror(b1:bat[:dbl],b2:bat[:flt],s:bat[:oid]) :bat[:dbl]
address CMDbatADD
comment "Return B1 + B2 with candidates list, overflow causes NIL value";
pattern +(b:bat[:dbl],v:flt) :bat[:dbl]
address CMDbatADDsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:dbl],v:flt,s:bat[:oid]) :bat[:dbl]
address CMDbatADDsignal
comment "Return B + V with candidates list, signal error on overflow";
pattern add_noerror(b:bat[:dbl],v:flt) :bat[:dbl]
address CMDbatADD
comment "Return B + V, overflow causes NIL value";
pattern add_noerror(b:bat[:dbl],v:flt,s:bat[:oid]) :bat[:dbl]
address CMDbatADD
comment "Return B + V with candidates list, overflow causes NIL value";
pattern +(v:dbl,b:bat[:flt]) :bat[:dbl]
address CMDbatADDsignal
comment "Return V + B, signal error on overflow";
pattern +(v:dbl,b:bat[:flt],s:bat[:oid]) :bat[:dbl]
address CMDbatADDsignal
comment "Return V + B with candidates list, signal error on overflow";
pattern add_noerror(v:dbl,b:bat[:flt]) :bat[:dbl]
address CMDbatADD
comment "Return V + B, overflow causes NIL value";
pattern add_noerror(v:dbl,b:bat[:flt],s:bat[:oid]) :bat[:dbl]
address CMDbatADD
comment "Return V + B with candidates list, overflow causes NIL value";

pattern +(b1:bat[:dbl],b2:bat[:dbl]) :bat[:dbl]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
pattern +(b1:bat[:dbl],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatADDsignal
comment "Return B1 + B2 with candidates list, signal error on overflow";
pattern add_noerror(b1:bat[:dbl],b2:bat[:dbl]) :bat[:dbl]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern add_noerror(b1:bat[:dbl],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatADD
comment "Return B1 + B2 with candidates list, overflow causes NIL value";
pattern +(b:bat[:dbl],v:dbl) :bat[:dbl]
address CMDbatADDsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:dbl],v:dbl,s:bat[:oid]) :bat[:dbl]
address CMDbatADDsignal
comment "Return B + V with candidates list, signal error on overflow";
pattern add_noerror(b:bat[:dbl],v:dbl) :bat[:dbl]
address CMDbatADD
comment "Return B + V, overflow causes NIL value";
pattern add_noerror(b:bat[:dbl],v:dbl,s:bat[:oid]) :bat[:dbl]
address CMDbatADD
comment "Return B + V with candidates list, overflow causes NIL value";
pattern +(v:dbl,b:bat[:dbl]) :bat[:dbl]
address CMDbatADDsignal
comment "Return V + B, signal error on overflow";
pattern +(v:dbl,b:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatADDsignal
comment "Return V + B with candidates list, signal error on overflow";
pattern add_noerror(v:dbl,b:bat[:dbl]) :bat[:dbl]
address CMDbatADD
comment "Return V + B, overflow causes NIL value";
pattern add_noerror(v:dbl,b:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatADD
comment "Return V + B with candidates list, overflow causes NIL value";


pattern -(b1:bat[:bte],b2:bat[:bte]) :bat[:bte]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
pattern -(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]) :bat[:bte]
address CMDbatSUBsignal
comment "Return B1 - B2 with candidates list, signal error on overflow";
pattern sub_noerror(b1:bat[:bte],b2:bat[:bte]) :bat[:bte]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern sub_noerror(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]) :bat[:bte]
address CMDbatSUB
comment "Return B1 - B2 with candidates list, overflow causes NIL value";
pattern -(b:bat[:bte],v:bte) :bat[:bte]
address CMDbatSUBsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:bte],v:bte,s:bat[:oid]) :bat[:bte]
address CMDbatSUBsignal
comment "Return B - V with candidates list, signal error on overflow";
pattern sub_noerror(b:bat[:bte],v:bte) :bat[:bte]
address CMDbatSUB
comment "Return B - V, overflow causes NIL value";
pattern sub_noerror(b:bat[:bte],v:bte,s:bat[:oid]) :bat[:bte]
address CMDbatSUB
comment "Return B - V with candidates list, overflow causes NIL value";
pattern -(v:bte,b:bat[:bte]) :bat[:bte]
address CMDbatSUBsignal
comment "Return V - B, signal error on overflow";
pattern -(v:bte,b:bat[:bte],s:bat[:oid]) :bat[:bte]
address CMDbatSUBsignal
comment "Return V - B with candidates list, signal error on overflow";
pattern sub_noerror(v:bte,b:bat[:bte]) :bat[:bte]
address CMDbatSUB
comment "Return V - B, overflow causes NIL value";
pattern sub_noerror(v:bte,b:bat[:bte],s:bat[:oid]) :bat[:bte]
address CMDbatSUB
comment "Return V - B with candidates list, overflow causes NIL value";

pattern -(b1:bat[:bte],b2:bat[:sht]) :bat[:sht]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
pattern -(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]) :bat[:sht]
address CMDbatSUBsignal
comment "Return B1 - B2 with candidates list, signal error on overflow";
pattern sub_noerror(b1:bat[:bte],b2:bat[:sht]) :bat[:sht]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern sub_noerror(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]) :bat[:sht]
address CMDbatSUB
comment "Return B1 - B2 with candidates list, overflow causes NIL value";
pattern -(b:bat[:bte],v:sht) :bat[:sht]
address CMDbatSUBsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:bte],v:sht,s:bat[:oid]) :bat[:sht]
address CMDbatSUBsignal
comment "Return B - V with candidates list, signal error on overflow";
pattern sub_noerror(b:bat[:bte],v:sht) :bat[:sht]
address CMDbatSUB
comment "Return B - V, overflow causes NIL value";
pattern sub_noerror(b:bat[:bte],v:sht,s:bat[:oid]) :bat[:sht]
address CMDbatSUB
comment "Return B - V with candidates list, overflow causes NIL value";
pattern -(v:bte,b:bat[:sht]) :bat[:sht]
address CMDbatSUBsignal
comment "Return V - B, signal error on overflow";
pattern -(v:bte,b:bat[:sht],s:bat[:oid]) :bat[:sht]
address CMDbatSUBsignal
comment "Return V - B with candidates list, signal error on overflow";
pattern sub_noerror(v:bte,b:bat[:sht]) :bat[:sht]
address CMDbatSUB
comment "Return V - B, overflow causes NIL value";
pattern sub_noerror(v:bte,b:bat[:sht],s:bat[:oid]) :bat[:sht]
address CMDbatSUB
comment "Return V - B with candidates list, overflow causes NIL value";

pattern -(b1:bat[:bte],b2:bat[:int]) :bat[:int]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
pattern -(b1:bat[:bte],b2:bat[:int],s:bat[:oid]) :bat[:int]
address CMDbatSUBsignal
comment "Return B1 - B2 with candidates list, signal error on overflow";
pattern sub_noerror(b1:bat[:bte],b2:bat[:int]) :bat[:int]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern sub_noerror(b1:bat[:bte],b2:bat[:int],s:bat[:oid]) :bat[:int]
address CMDbatSUB
comment "Return B1 - B2 with candidates list, overflow causes NIL value";
pattern -(b:bat[:bte],v:int) :bat[:int]
address CMDbatSUBsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:bte],v:int,s:bat[:oid]) :bat[:int]
address CMDbatSUBsignal
comment "Return B - V with candidates list, signal error on overflow";
pattern sub_noerror(b:bat[:bte],v:int) :bat[:int]
address CMDbatSUB
comment "Return B - V, overflow causes NIL value";
pattern sub_noerror(b:bat[:bte],v:int,s:bat[:oid]) :bat[:int]
address CMDbatSUB
comment "Return B - V with candidates list, overflow causes NIL value";
pattern -(v:bte,b:bat[:int]) :bat[:int]
address CMDbatSUBsignal
comment "Return V - B, signal error on overflow";
pattern -(v:bte,b:bat[:int],s:bat[:oid]) :bat[:int]
address CMDbatSUBsignal
comment "Return V - B with candidates list, signal error on overflow";
pattern sub_noerror(v:bte,b:bat[:int]) :bat[:int]
address CMDbatSUB
comment "Return V - B, overflow causes NIL value";
pattern sub_noerror(v:bte,b:bat[:int],s:bat[:oid]) :bat[:int]
address CMDbatSUB
comment "Return V - B with candidates list, overflow causes NIL value";

pattern -(b1:bat[:bte],b2:bat[:lng]) :bat[:lng]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
pattern -(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]) :bat[:lng]
address CMDbatSUBsignal
comment "Return B1 - B2 with candidates list, signal error on overflow";
pattern sub_noerror(b1:bat[:bte],b2:bat[:lng]) :bat[:lng]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern sub_noerror(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]) :bat[:lng]
address CMDbatSUB
comment "Return B1 - B2 with candidates list, overflow causes NIL value";
pattern -(b:bat[:bte],v:lng) :bat[:lng]
address CMDbatSUBsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:bte],v:lng,s:bat[:oid]) :bat[:lng]
address CMDbatSUBsignal
comment "Return B - V with candidates list, signal error on overflow";
pattern sub_noerror(b:bat[:bte],v:lng) :bat[:lng]
address CMDbatSUB
comment "Return B - V, overflow causes NIL value";
pattern sub_noerror(b:bat[:bte],v:lng,s:bat[:oid]) :bat[:lng]
address CMDbatSUB
comment "Return B - V with candidates list, overflow causes NIL value";
pattern -(v:bte,b:bat[:lng]) :bat[:lng]
address CMDbatSUBsignal
comment "Return V - B, signal error on overflow";
pattern -(v:bte,b:bat[:lng],s:bat[:oid]) :bat[:lng]
address CMDbatSUBsignal
comment "Return V - B with candidates list, signal error on overflow";
pattern sub_noerror(v:bte,b:bat[:lng]) :bat[:lng]
address CMDbatSUB
comment "Return V - B, overflow causes NIL value";
pattern sub_noerror(v:bte,b:bat[:lng],s:bat[:oid]) :bat[:lng]
address CMDbatSUB
comment "Return V - B with candidates list, overflow causes NIL value";

pattern -(b1:bat[:bte],b2:bat[:flt]) :bat[:flt]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
pattern -(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatSUBsignal
comment "Return B1 - B2 with candidates list, signal error on overflow";
pattern sub_noerror(b1:bat[:bte],b2:bat[:flt]) :bat[:flt]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern sub_noerror(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatSUB
comment "Return B1 - B2 with candidates list, overflow causes NIL value";
pattern -(b:bat[:bte],v:flt) :bat[:flt]
address CMDbatSUBsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:bte],v:flt,s:bat[:oid]) :bat[:flt]
address CMDbatSUBsignal
comment "Return B - V with candidates list, signal error on overflow";
pattern sub_noerror(b:bat[:bte],v:flt) :bat[:flt]
address CMDbatSUB
comment "Return B - V, overflow causes NIL value";
pattern sub_noerror(b:bat[:bte],v:flt,s:bat[:oid]) :bat[:flt]
address CMDbatSUB
comment "Return B - V with candidates list, overflow causes NIL value";
pattern -(v:bte,b:bat[:flt]) :bat[:flt]
address CMDbatSUBsignal
comment "Return V - B, signal error on overflow";
pattern -(v:bte,b:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatSUBsignal
comment "Return V - B with candidates list, signal error on overflow";
pattern sub_noerror(v:bte,b:bat[:flt]) :bat[:flt]
address CMDbatSUB
comment "Return V - B, overflow causes NIL value";
pattern sub_noerror(v:bte,b:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatSUB
comment "Return V - B with candidates list, overflow causes NIL value";

pattern -(b1:bat[:bte],b2:bat[:dbl]) :bat[:dbl]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
pattern -(b1:bat[:bte],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatSUBsignal
comment "Return B1 - B2 with candidates list, signal error on overflow";
pattern sub_noerror(b1:bat[:bte],b2:bat[:dbl]) :bat[:dbl]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern sub_noerror(b1:bat[:bte],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatSUB
comment "Return B1 - B2 with candidates list, overflow causes NIL value";
pattern -(b:bat[:bte],v:dbl) :bat[:dbl]
address CMDbatSUBsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:bte],v:dbl,s:bat[:oid]) :bat[:dbl]
address CMDbatSUBsignal
comment "Return B - V with candidates list, signal error on overflow";
pattern sub_noerror(b:bat[:bte],v:dbl) :bat[:dbl]
address CMDbatSUB
comment "Return B - V, overflow causes NIL value";
pattern sub_noerror(b:bat[:bte],v:dbl,s:bat[:oid]) :bat[:dbl]
address CMDbatSUB
comment "Return B - V with candidates list, overflow causes NIL value";
pattern -(v:bte,b:bat[:dbl]) :bat[:dbl]
address CMDbatSUBsignal
comment "Return V - B, signal error on overflow";
pattern -(v:bte,b:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatSUBsignal
comment "Return V - B with candidates list, signal error on overflow";
pattern sub_noerror(v:bte,b:bat[:dbl]) :bat[:dbl]
address CMDbatSUB
comment "Return V - B, overflow causes NIL value";
pattern sub_noerror(v:bte,b:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatSUB
comment "Return V - B with candidates list, overflow causes NIL value";

pattern -(b1:bat[:sht],b2:bat[:bte]) :bat[:sht]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
pattern -(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]) :bat[:sht]
address CMDbatSUBsignal
comment "Return B1 - B2 with candidates list, signal error on overflow";
pattern sub_noerror(b1:bat[:sht],b2:bat[:bte]) :bat[:sht]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern sub_noerror(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]) :bat[:sht]
address CMDbatSUB
comment "Return B1 - B2 with candidates list, overflow causes NIL value";
pattern -(b:bat[:sht],v:bte) :bat[:sht]
address CMDbatSUBsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:sht],v:bte,s:bat[:oid]) :bat[:sht]
address CMDbatSUBsignal
comment "Return B - V with candidates list, signal error on overflow";
pattern sub_noerror(b:bat[:sht],v:bte) :bat[:sht]
address CMDbatSUB
comment "Return B - V, overflow causes NIL value";
pattern sub_noerror(b:bat[:sht],v:bte,s:bat[:oid]) :bat[:sht]
address CMDbatSUB
comment "Return B - V with candidates list, overflow causes NIL value";
pattern -(v:sht,b:bat[:bte]) :bat[:sht]
address CMDbatSUBsignal
comment "Return V - B, signal error on overflow";
pattern -(v:sht,b:bat[:bte],s:bat[:oid]) :bat[:sht]
address CMDbatSUBsignal
comment "Return V - B with candidates list, signal error on overflow";
pattern sub_noerror(v:sht,b:bat[:bte]) :bat[:sht]
address CMDbatSUB
comment "Return V - B, overflow causes NIL value";
pattern sub_noerror(v:sht,b:bat[:bte],s:bat[:oid]) :bat[:sht]
address CMDbatSUB
comment "Return V - B with candidates list, overflow causes NIL value";

pattern -(b1:bat[:sht],b2:bat[:sht]) :bat[:sht]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
pattern -(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]) :bat[:sht]
address CMDbatSUBsignal
comment "Return B1 - B2 with candidates list, signal error on overflow";
pattern sub_noerror(b1:bat[:sht],b2:bat[:sht]) :bat[:sht]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern sub_noerror(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]) :bat[:sht]
address CMDbatSUB
comment "Return B1 - B2 with candidates list, overflow causes NIL value";
pattern -(b:bat[:sht],v:sht) :bat[:sht]
address CMDbatSUBsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:sht],v:sht,s:bat[:oid]) :bat[:sht]
address CMDbatSUBsignal
comment "Return B - V with candidates list, signal error on overflow";
pattern sub_noerror(b:bat[:sht],v:sht) :bat[:sht]
address CMDbatSUB
comment "Return B - V, overflow causes NIL value";
pattern sub_noerror(b:bat[:sht],v:sht,s:bat[:oid]) :bat[:sht]
address CMDbatSUB
comment "Return B - V with candidates list, overflow causes NIL value";
pattern -(v:sht,b:bat[:sht]) :bat[:sht]
address CMDbatSUBsignal
comment "Return V - B, signal error on overflow";
pattern -(v:sht,b:bat[:sht],s:bat[:oid]) :bat[:sht]
address CMDbatSUBsignal
comment "Return V - B with candidates list, signal error on overflow";
pattern sub_noerror(v:sht,b:bat[:sht]) :bat[:sht]
address CMDbatSUB
comment "Return V - B, overflow causes NIL value";
pattern sub_noerror(v:sht,b:bat[:sht],s:bat[:oid]) :bat[:sht]
address CMDbatSUB
comment "Return V - B with candidates list, overflow causes NIL value";

pattern -(b1:bat[:sht],b2:bat[:int]) :bat[:int]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
pattern -(b1:bat[:sht],b2:bat[:int],s:bat[:oid]) :bat[:int]
address CMDbatSUBsignal
comment "Return B1 - B2 with candidates list, signal error on overflow";
pattern sub_noerror(b1:bat[:sht],b2:bat[:int]) :bat[:int]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern sub_noerror(b1:bat[:sht],b2:bat[:int],s:bat[:oid]) :bat[:int]
address CMDbatSUB
comment "Return B1 - B2 with candidates list, overflow causes NIL value";
pattern -(b:bat[:sht],v:int) :bat[:int]
address CMDbatSUBsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:sht],v:int,s:bat[:oid]) :bat[:int]
address CMDbatSUBsignal
comment "Return B - V with candidates list, signal error on overflow";
pattern sub_noerror(b:bat[:sht],v:int) :bat[:int]
address CMDbatSUB
comment "Return B - V, overflow causes NIL value";
pattern sub_noerror(b:bat[:sht],v:int,s:bat[:oid]) :bat[:int]
address CMDbatSUB
comment "Return B - V with candidates list, overflow causes NIL value";
pattern -(v:sht,b:bat[:int]) :bat[:int]
address CMDbatSUBsignal
comment "Return V - B, signal error on overflow";
pattern -(v:sht,b:bat[:int],s:bat[:oid]) :bat[:int]
address CMDbatSUBsignal
comment "Return V - B with candidates list, signal error on overflow";
pattern sub_noerror(v:sht,b:bat[:int]) :bat[:int]
address CMDbatSUB
comment "Return V - B, overflow causes NIL value";
pattern sub_noerror(v:sht,b:bat[:int],s:bat[:oid]) :bat[:int]
address CMDbatSUB
comment "Return V - B with candidates list, overflow causes NIL value";

pattern -(b1:bat[:sht],b2:bat[:lng]) :bat[:lng]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
pattern -(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]) :bat[:lng]
address CMDbatSUBsignal
comment "Return B1 - B2 with candidates list, signal error on overflow";
pattern sub_noerror(b1:bat[:sht],b2:bat[:lng]) :bat[:lng]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern sub_noerror(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]) :bat[:lng]
address CMDbatSUB
comment "Return B1 - B2 with candidates list, overflow causes NIL value";
pattern -(b:bat[:sht],v:lng) :bat[:lng]
address CMDbatSUBsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:sht],v:lng,s:bat[:oid]) :bat[:lng]
address CMDbatSUBsignal
comment "Return B - V with candidates list, signal error on overflow";
pattern sub_noerror(b:bat[:sht],v:lng) :bat[:lng]
address CMDbatSUB
comment "Return B - V, overflow causes NIL value";
pattern sub_noerror(b:bat[:sht],v:lng,s:bat[:oid]) :bat[:lng]
address CMDbatSUB
comment "Return B - V with candidates list, overflow causes NIL value";
pattern -(v:sht,b:bat[:lng]) :bat[:lng]
address CMDbatSUBsignal
comment "Return V - B, signal error on overflow";
pattern -(v:sht,b:bat[:lng],s:bat[:oid]) :bat[:lng]
address CMDbatSUBsignal
comment "Return V - B with candidates list, signal error on overflow";
pattern sub_noerror(v:sht,b:bat[:lng]) :bat[:lng]
address CMDbatSUB
comment "Return V - B, overflow causes NIL value";
pattern sub_noerror(v:sht,b:bat[:lng],s:bat[:oid]) :bat[:lng]
address CMDbatSUB
comment "Return V - B with candidates list, overflow causes NIL value";

pattern -(b1:bat[:sht],b2:bat[:flt]) :bat[:flt]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
pattern -(b1:bat[:sht],b2:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatSUBsignal
comment "Return B1 - B2 with candidates list, signal error on overflow";
pattern sub_noerror(b1:bat[:sht],b2:bat[:flt]) :bat[:flt]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern sub_noerror(b1:bat[:sht],b2:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatSUB
comment "Return B1 - B2 with candidates list, overflow causes NIL value";
pattern -(b:bat[:sht],v:flt) :bat[:flt]
address CMDbatSUBsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:sht],v:flt,s:bat[:oid]) :bat[:flt]
address CMDbatSUBsignal
comment "Return B - V with candidates list, signal error on overflow";
pattern sub_noerror(b:bat[:sht],v:flt) :bat[:flt]
address CMDbatSUB
comment "Return B - V, overflow causes NIL value";
pattern sub_noerror(b:bat[:sht],v:flt,s:bat[:oid]) :bat[:flt]
address CMDbatSUB
comment "Return B - V with candidates list, overflow causes NIL value";
pattern -(v:sht,b:bat[:flt]) :bat[:flt]
address CMDbatSUBsignal
comment "Return V - B, signal error on overflow";
pattern -(v:sht,b:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatSUBsignal
comment "Return V - B with candidates list, signal error on overflow";
pattern sub_noerror(v:sht,b:bat[:flt]) :bat[:flt]
address CMDbatSUB
comment "Return V - B, overflow causes NIL value";
pattern sub_noerror(v:sht,b:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatSUB
comment "Return V - B with candidates list, overflow causes NIL value";

pattern -(b1:bat[:sht],b2:bat[:dbl]) :bat[:dbl]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
pattern -(b1:bat[:sht],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatSUBsignal
comment "Return B1 - B2 with candidates list, signal error on overflow";
pattern sub_noerror(b1:bat[:sht],b2:bat[:dbl]) :bat[:dbl]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern sub_noerror(b1:bat[:sht],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatSUB
comment "Return B1 - B2 with candidates list, overflow causes NIL value";
pattern -(b:bat[:sht],v:dbl) :bat[:dbl]
address CMDbatSUBsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:sht],v:dbl,s:bat[:oid]) :bat[:dbl]
address CMDbatSUBsignal
comment "Return B - V with candidates list, signal error on overflow";
pattern sub_noerror(b:bat[:sht],v:dbl) :bat[:dbl]
address CMDbatSUB
comment "Return B - V, overflow causes NIL value";
pattern sub_noerror(b:bat[:sht],v:dbl,s:bat[:oid]) :bat[:dbl]
address CMDbatSUB
comment "Return B - V with candidates list, overflow causes NIL value";
pattern -(v:sht,b:bat[:dbl]) :bat[:dbl]
address CMDbatSUBsignal
comment "Return V - B, signal error on overflow";
pattern -(v:sht,b:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatSUBsignal
comment "Return V - B with candidates list, signal error on overflow";
pattern sub_noerror(v:sht,b:bat[:dbl]) :bat[:dbl]
address CMDbatSUB
comment "Return V - B, overflow causes NIL value";
pattern sub_noerror(v:sht,b:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatSUB
comment "Return V - B with candidates list, overflow causes NIL value";

pattern -(b1:bat[:int],b2:bat[:bte]) :bat[:int]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
pattern -(b1:bat[:int],b2:bat[:bte],s:bat[:oid]) :bat[:int]
address CMDbatSUBsignal
comment "Return B1 - B2 with candidates list, signal error on overflow";
pattern sub_noerror(b1:bat[:int],b2:bat[:bte]) :bat[:int]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern sub_noerror(b1:bat[:int],b2:bat[:bte],s:bat[:oid]) :bat[:int]
address CMDbatSUB
comment "Return B1 - B2 with candidates list, overflow causes NIL value";
pattern -(b:bat[:int],v:bte) :bat[:int]
address CMDbatSUBsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:int],v:bte,s:bat[:oid]) :bat[:int]
address CMDbatSUBsignal
comment "Return B - V with candidates list, signal error on overflow";
pattern sub_noerror(b:bat[:int],v:bte) :bat[:int]
address CMDbatSUB
comment "Return B - V, overflow causes NIL value";
pattern sub_noerror(b:bat[:int],v:bte,s:bat[:oid]) :bat[:int]
address CMDbatSUB
comment "Return B - V with candidates list, overflow causes NIL value";
pattern -(v:int,b:bat[:bte]) :bat[:int]
address CMDbatSUBsignal
comment "Return V - B, signal error on overflow";
pattern -(v:int,b:bat[:bte],s:bat[:oid]) :bat[:int]
address CMDbatSUBsignal
comment "Return V - B with candidates list, signal error on overflow";
pattern sub_noerror(v:int,b:bat[:bte]) :bat[:int]
address CMDbatSUB
comment "Return V - B, overflow causes NIL value";
pattern sub_noerror(v:int,b:bat[:bte],s:bat[:oid]) :bat[:int]
address CMDbatSUB
comment "Return V - B with candidates list, overflow causes NIL value";

pattern -(b1:bat[:int],b2:bat[:sht]) :bat[:int]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
pattern -(b1:bat[:int],b2:bat[:sht],s:bat[:oid]) :bat[:int]
address CMDbatSUBsignal
comment "Return B1 - B2 with candidates list, signal error on overflow";
pattern sub_noerror(b1:bat[:int],b2:bat[:sht]) :bat[:int]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern sub_noerror(b1:bat[:int],b2:bat[:sht],s:bat[:oid]) :bat[:int]
address CMDbatSUB
comment "Return B1 - B2 with candidates list, overflow causes NIL value";
pattern -(b:bat[:int],v:sht) :bat[:int]
address CMDbatSUBsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:int],v:sht,s:bat[:oid]) :bat[:int]
address CMDbatSUBsignal
comment "Return B - V with candidates list, signal error on overflow";
pattern sub_noerror(b:bat[:int],v:sht) :bat[:int]
address CMDbatSUB
comment "Return B - V, overflow causes NIL value";
pattern sub_noerror(b:bat[:int],v:sht,s:bat[:oid]) :bat[:int]
address CMDbatSUB
comment "Return B - V with candidates list, overflow causes NIL value";
pattern -(v:int,b:bat[:sht]) :bat[:int]
address CMDbatSUBsignal
comment "Return V - B, signal error on overflow";
pattern -(v:int,b:bat[:sht],s:bat[:oid]) :bat[:int]
address CMDbatSUBsignal
comment "Return V - B with candidates list, signal error on overflow";
pattern sub_noerror(v:int,b:bat[:sht]) :bat[:int]
address CMDbatSUB
comment "Return V - B, overflow causes NIL value";
pattern sub_noerror(v:int,b:bat[:sht],s:bat[:oid]) :bat[:int]
address CMDbatSUB
comment "Return V - B with candidates list, overflow causes NIL value";

pattern -(b1:bat[:int],b2:bat[:int]) :bat[:int]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
pattern -(b1:bat[:int],b2:bat[:int],s:bat[:oid]) :bat[:int]
address CMDbatSUBsignal
comment "Return B1 - B2 with candidates list, signal error on overflow";
pattern sub_noerror(b1:bat[:int],b2:bat[:int]) :bat[:int]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern sub_noerror(b1:bat[:int],b2:bat[:int],s:bat[:oid]) :bat[:int]
address CMDbatSUB
comment "Return B1 - B2 with candidates list, overflow causes NIL value";
pattern -(b:bat[:int],v:int) :bat[:int]
address CMDbatSUBsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:int],v:int,s:bat[:oid]) :bat[:int]
address CMDbatSUBsignal
comment "Return B - V with candidates list, signal error on overflow";
pattern sub_noerror(b:bat[:int],v:int) :bat[:int]
address CMDbatSUB
comment "Return B - V, overflow causes NIL value";
pattern sub_noerror(b:bat[:int],v:int,s:bat[:oid]) :bat[:int]
address CMDbatSUB
comment "Return B - V with candidates list, overflow causes NIL value";
pattern -(v:int,b:bat[:int]) :bat[:int]
address CMDbatSUBsignal
comment "Return V - B, signal error on overflow";
pattern -(v:int,b:bat[:int],s:bat[:oid]) :bat[:int]
address CMDbatSUBsignal
comment "Return V - B with candidates list, signal error on overflow";
pattern sub_noerror(v:int,b:bat[:int]) :bat[:int]
address CMDbatSUB
comment "Return V - B, overflow causes NIL value";
pattern sub_noerror(v:int,b:bat[:int],s:bat[:oid]) :bat[:int]
address CMDbatSUB
comment "Return V - B with candidates list, overflow causes NIL value";

pattern -(b1:bat[:int],b2:bat[:lng]) :bat[:lng]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
pattern -(b1:bat[:int],b2:bat[:lng],s:bat[:oid]) :bat[:lng]
address CMDbatSUBsignal
comment "Return B1 - B2 with candidates list, signal error on overflow";
pattern sub_noerror(b1:bat[:int],b2:bat[:lng]) :bat[:lng]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern sub_noerror(b1:bat[:int],b2:bat[:lng],s:bat[:oid]) :bat[:lng]
address CMDbatSUB
comment "Return B1 - B2 with candidates list, overflow causes NIL value";
pattern -(b:bat[:int],v:lng) :bat[:lng]
address CMDbatSUBsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:int],v:lng,s:bat[:oid]) :bat[:lng]
address CMDbatSUBsignal
comment "Return B - V with candidates list, signal error on overflow";
pattern sub_noerror(b:bat[:int],v:lng) :bat[:lng]
address CMDbatSUB
comment "Return B - V, overflow causes NIL value";
pattern sub_noerror(b:bat[:int],v:lng,s:bat[:oid]) :bat[:lng]
address CMDbatSUB
comment "Return B - V with candidates list, overflow causes NIL value";
pattern -(v:int,b:bat[:lng]) :bat[:lng]
address CMDbatSUBsignal
comment "Return V - B, signal error on overflow";
pattern -(v:int,b:bat[:lng],s:bat[:oid]) :bat[:lng]
address CMDbatSUBsignal
comment "Return V - B with candidates list, signal error on overflow";
pattern sub_noerror(v:int,b:bat[:lng]) :bat[:lng]
address CMDbatSUB
comment "Return V - B, overflow causes NIL value";
pattern sub_noerror(v:int,b:bat[:lng],s:bat[:oid]) :bat[:lng]
address CMDbatSUB
comment "Return V - B with candidates list, overflow causes NIL value";

pattern -(b1:bat[:int],b2:bat[:flt]) :bat[:flt]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
pattern -(b1:bat[:int],b2:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatSUBsignal
comment "Return B1 - B2 with candidates list, signal error on overflow";
pattern sub_noerror(b1:bat[:int],b2:bat[:flt]) :bat[:flt]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern sub_noerror(b1:bat[:int],b2:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatSUB
comment "Return B1 - B2 with candidates list, overflow causes NIL value";
pattern -(b:bat[:int],v:flt) :bat[:flt]
address CMDbatSUBsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:int],v:flt,s:bat[:oid]) :bat[:flt]
address CMDbatSUBsignal
comment "Return B - V with candidates list, signal error on overflow";
pattern sub_noerror(b:bat[:int],v:flt) :bat[:flt]
address CMDbatSUB
comment "Return B - V, overflow causes NIL value";
pattern sub_noerror(b:bat[:int],v:flt,s:bat[:oid]) :bat[:flt]
address CMDbatSUB
comment "Return B - V with candidates list, overflow causes NIL value";
pattern -(v:int,b:bat[:flt]) :bat[:flt]
address CMDbatSUBsignal
comment "Return V - B, signal error on overflow";
pattern -(v:int,b:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatSUBsignal
comment "Return V - B with candidates list, signal error on overflow";
pattern sub_noerror(v:int,b:bat[:flt]) :bat[:flt]
address CMDbatSUB
comment "Return V - B, overflow causes NIL value";
pattern sub_noerror(v:int,b:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatSUB
comment "Return V - B with candidates list, overflow causes NIL value";

pattern -(b1:bat[:int],b2:bat[:dbl]) :bat[:dbl]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
pattern -(b1:bat[:int],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatSUBsignal
comment "Return B1 - B2 with candidates list, signal error on overflow";
pattern sub_noerror(b1:bat[:int],b2:bat[:dbl]) :bat[:dbl]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern sub_noerror(b1:bat[:int],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatSUB
comment "Return B1 - B2 with candidates list, overflow causes NIL value";
pattern -(b:bat[:int],v:dbl) :bat[:dbl]
address CMDbatSUBsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:int],v:dbl,s:bat[:oid]) :bat[:dbl]
address CMDbatSUBsignal
comment "Return B - V with candidates list, signal error on overflow";
pattern sub_noerror(b:bat[:int],v:dbl) :bat[:dbl]
address CMDbatSUB
comment "Return B - V, overflow causes NIL value";
pattern sub_noerror(b:bat[:int],v:dbl,s:bat[:oid]) :bat[:dbl]
address CMDbatSUB
comment "Return B - V with candidates list, overflow causes NIL value";
pattern -(v:int,b:bat[:dbl]) :bat[:dbl]
address CMDbatSUBsignal
comment "Return V - B, signal error on overflow";
pattern -(v:int,b:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatSUBsignal
comment "Return V - B with candidates list, signal error on overflow";
pattern sub_noerror(v:int,b:bat[:dbl]) :bat[:dbl]
address CMDbatSUB
comment "Return V - B, overflow causes NIL value";
pattern sub_noerror(v:int,b:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatSUB
comment "Return V - B with candidates list, overflow causes NIL value";

pattern -(b1:bat[:lng],b2:bat[:bte]) :bat[:lng]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
pattern -(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]) :bat[:lng]
address CMDbatSUBsignal
comment "Return B1 - B2 with candidates list, signal error on overflow";
pattern sub_noerror(b1:bat[:lng],b2:bat[:bte]) :bat[:lng]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern sub_noerror(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]) :bat[:lng]
address CMDbatSUB
comment "Return B1 - B2 with candidates list, overflow causes NIL value";
pattern -(b:bat[:lng],v:bte) :bat[:lng]
address CMDbatSUBsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:lng],v:bte,s:bat[:oid]) :bat[:lng]
address CMDbatSUBsignal
comment "Return B - V with candidates list, signal error on overflow";
pattern sub_noerror(b:bat[:lng],v:bte) :bat[:lng]
address CMDbatSUB
comment "Return B - V, overflow causes NIL value";
pattern sub_noerror(b:bat[:lng],v:bte,s:bat[:oid]) :bat[:lng]
address CMDbatSUB
comment "Return B - V with candidates list, overflow causes NIL value";
pattern -(v:lng,b:bat[:bte]) :bat[:lng]
address CMDbatSUBsignal
comment "Return V - B, signal error on overflow";
pattern -(v:lng,b:bat[:bte],s:bat[:oid]) :bat[:lng]
address CMDbatSUBsignal
comment "Return V - B with candidates list, signal error on overflow";
pattern sub_noerror(v:lng,b:bat[:bte]) :bat[:lng]
address CMDbatSUB
comment "Return V - B, overflow causes NIL value";
pattern sub_noerror(v:lng,b:bat[:bte],s:bat[:oid]) :bat[:lng]
address CMDbatSUB
comment "Return V - B with candidates list, overflow causes NIL value";

pattern -(b1:bat[:lng],b2:bat[:sht]) :bat[:lng]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
pattern -(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]) :bat[:lng]
address CMDbatSUBsignal
comment "Return B1 - B2 with candidates list, signal error on overflow";
pattern sub_noerror(b1:bat[:lng],b2:bat[:sht]) :bat[:lng]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern sub_noerror(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]) :bat[:lng]
address CMDbatSUB
comment "Return B1 - B2 with candidates list, overflow causes NIL value";
pattern -(b:bat[:lng],v:sht) :bat[:lng]
address CMDbatSUBsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:lng],v:sht,s:bat[:oid]) :bat[:lng]
address CMDbatSUBsignal
comment "Return B - V with candidates list, signal error on overflow";
pattern sub_noerror(b:bat[:lng],v:sht) :bat[:lng]
address CMDbatSUB
comment "Return B - V, overflow causes NIL value";
pattern sub_noerror(b:bat[:lng],v:sht,s:bat[:oid]) :bat[:lng]
address CMDbatSUB
comment "Return B - V with candidates list, overflow causes NIL value";
pattern -(v:lng,b:bat[:sht]) :bat[:lng]
address CMDbatSUBsignal
comment "Return V - B, signal error on overflow";
pattern -(v:lng,b:bat[:sht],s:bat[:oid]) :bat[:lng]
address CMDbatSUBsignal
comment "Return V - B with candidates list, signal error on overflow";
pattern sub_noerror(v:lng,b:bat[:sht]) :bat[:lng]
address CMDbatSUB
comment "Return V - B, overflow causes NIL value";
pattern sub_noerror(v:lng,b:bat[:sht],s:bat[:oid]) :bat[:lng]
address CMDbatSUB
comment "Return V - B with candidates list, overflow causes NIL value";

pattern -(b1:bat[:lng],b2:bat[:int]) :bat[:lng]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
pattern -(b1:bat[:lng],b2:bat[:int],s:bat[:oid]) :bat[:lng]
address CMDbatSUBsignal
comment "Return B1 - B2 with candidates list, signal error on overflow";
pattern sub_noerror(b1:bat[:lng],b2:bat[:int]) :bat[:lng]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern sub_noerror(b1:bat[:lng],b2:bat[:int],s:bat[:oid]) :bat[:lng]
address CMDbatSUB
comment "Return B1 - B2 with candidates list, overflow causes NIL value";
pattern -(b:bat[:lng],v:int) :bat[:lng]
address CMDbatSUBsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:lng],v:int,s:bat[:oid]) :bat[:lng]
address CMDbatSUBsignal
comment "Return B - V with candidates list, signal error on overflow";
pattern sub_noerror(b:bat[:lng],v:int) :bat[:lng]
address CMDbatSUB
comment "Return B - V, overflow causes NIL value";
pattern sub_noerror(b:bat[:lng],v:int,s:bat[:oid]) :bat[:lng]
address CMDbatSUB
comment "Return B - V with candidates list, overflow causes NIL value";
pattern -(v:lng,b:bat[:int]) :bat[:lng]
address CMDbatSUBsignal
comment "Return V - B, signal error on overflow";
pattern -(v:lng,b:bat[:int],s:bat[:oid]) :bat[:lng]
address CMDbatSUBsignal
comment "Return V - B with candidates list, signal error on overflow";
pattern sub_noerror(v:lng,b:bat[:int]) :bat[:lng]
address CMDbatSUB
comment "Return V - B, overflow causes NIL value";
pattern sub_noerror(v:lng,b:bat[:int],s:bat[:oid]) :bat[:lng]
address CMDbatSUB
comment "Return V - B with candidates list, overflow causes NIL value";

pattern -(b1:bat[:lng],b2:bat[:lng]) :bat[:lng]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
pattern -(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]) :bat[:lng]
address CMDbatSUBsignal
comment "Return B1 - B2 with candidates list, signal error on overflow";
pattern sub_noerror(b1:bat[:lng],b2:bat[:lng]) :bat[:lng]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern sub_noerror(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]) :bat[:lng]
address CMDbatSUB
comment "Return B1 - B2 with candidates list, overflow causes NIL value";
pattern -(b:bat[:lng],v:lng) :bat[:lng]
address CMDbatSUBsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:lng],v:lng,s:bat[:oid]) :bat[:lng]
address CMDbatSUBsignal
comment "Return B - V with candidates list, signal error on overflow";
pattern sub_noerror(b:bat[:lng],v:lng) :bat[:lng]
address CMDbatSUB
comment "Return B - V, overflow causes NIL value";
pattern sub_noerror(b:bat[:lng],v:lng,s:bat[:oid]) :bat[:lng]
address CMDbatSUB
comment "Return B - V with candidates list, overflow causes NIL value";
pattern -(v:lng,b:bat[:lng]) :bat[:lng]
address CMDbatSUBsignal
comment "Return V - B, signal error on overflow";
pattern -(v:lng,b:bat[:lng],s:bat[:oid]) :bat[:lng]
address CMDbatSUBsignal
comment "Return V - B with candidates list, signal error on overflow";
pattern sub_noerror(v:lng,b:bat[:lng]) :bat[:lng]
address CMDbatSUB
comment "Return V - B, overflow causes NIL value";
pattern sub_noerror(v:lng,b:bat[:lng],s:bat[:oid]) :bat[:lng]
address CMDbatSUB
comment "Return V - B with candidates list, overflow causes NIL value";

pattern -(b1:bat[:lng],b2:bat[:flt]) :bat[:flt]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
pattern -(b1:bat[:lng],b2:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatSUBsignal
comment "Return B1 - B2 with candidates list, signal error on overflow";
pattern sub_noerror(b1:bat[:lng],b2:bat[:flt]) :bat[:flt]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern sub_noerror(b1:bat[:lng],b2:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatSUB
comment "Return B1 - B2 with candidates list, overflow causes NIL value";
pattern -(b:bat[:lng],v:flt) :bat[:flt]
address CMDbatSUBsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:lng],v:flt,s:bat[:oid]) :bat[:flt]
address CMDbatSUBsignal
comment "Return B - V with candidates list, signal error on overflow";
pattern sub_noerror(b:bat[:lng],v:flt) :bat[:flt]
address CMDbatSUB
comment "Return B - V, overflow causes NIL value";
pattern sub_noerror(b:bat[:lng],v:flt,s:bat[:oid]) :bat[:flt]
address CMDbatSUB
comment "Return B - V with candidates list, overflow causes NIL value";
pattern -(v:lng,b:bat[:flt]) :bat[:flt]
address CMDbatSUBsignal
comment "Return V - B, signal error on overflow";
pattern -(v:lng,b:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatSUBsignal
comment "Return V - B with candidates list, signal error on overflow";
pattern sub_noerror(v:lng,b:bat[:flt]) :bat[:flt]
address CMDbatSUB
comment "Return V - B, overflow causes NIL value";
pattern sub_noerror(v:lng,b:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatSUB
comment "Return V - B with candidates list, overflow causes NIL value";

pattern -(b1:bat[:lng],b2:bat[:dbl]) :bat[:dbl]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
pattern -(b1:bat[:lng],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatSUBsignal
comment "Return B1 - B2 with candidates list, signal error on overflow";
pattern sub_noerror(b1:bat[:lng],b2:bat[:dbl]) :bat[:dbl]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern sub_noerror(b1:bat[:lng],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatSUB
comment "Return B1 - B2 with candidates list, overflow causes NIL value";
pattern -(b:bat[:lng],v:dbl) :bat[:dbl]
address CMDbatSUBsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:lng],v:dbl,s:bat[:oid]) :bat[:dbl]
address CMDbatSUBsignal
comment "Return B - V with candidates list, signal error on overflow";
pattern sub_noerror(b:bat[:lng],v:dbl) :bat[:dbl]
address CMDbatSUB
comment "Return B - V, overflow causes NIL value";
pattern sub_noerror(b:bat[:lng],v:dbl,s:bat[:oid]) :bat[:dbl]
address CMDbatSUB
comment "Return B - V with candidates list, overflow causes NIL value";
pattern -(v:lng,b:bat[:dbl]) :bat[:dbl]
address CMDbatSUBsignal
comment "Return V - B, signal error on overflow";
pattern -(v:lng,b:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatSUBsignal
comment "Return V - B with candidates list, signal error on overflow";
pattern sub_noerror(v:lng,b:bat[:dbl]) :bat[:dbl]
address CMDbatSUB
comment "Return V - B, overflow causes NIL value";
pattern sub_noerror(v:lng,b:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatSUB
comment "Return V - B with candidates list, overflow causes NIL value";

pattern -(b1:bat[:flt],b2:bat[:bte]) :bat[:flt]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
pattern -(b1:bat[:flt],b2:bat[:bte],s:bat[:oid]) :bat[:flt]
address CMDbatSUBsignal
comment "Return B1 - B2 with candidates list, signal error on overflow";
pattern sub_noerror(b1:bat[:flt],b2:bat[:bte]) :bat[:flt]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern sub_noerror(b1:bat[:flt],b2:bat[:bte],s:bat[:oid]) :bat[:flt]
address CMDbatSUB
comment "Return B1 - B2 with candidates list, overflow causes NIL value";
pattern -(b:bat[:flt],v:bte) :bat[:flt]
address CMDbatSUBsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:flt],v:bte,s:bat[:oid]) :bat[:flt]
address CMDbatSUBsignal
comment "Return B - V with candidates list, signal error on overflow";
pattern sub_noerror(b:bat[:flt],v:bte) :bat[:flt]
address CMDbatSUB
comment "Return B - V, overflow causes NIL value";
pattern sub_noerror(b:bat[:flt],v:bte,s:bat[:oid]) :bat[:flt]
address CMDbatSUB
comment "Return B - V with candidates list, overflow causes NIL value";
pattern -(v:flt,b:bat[:bte]) :bat[:flt]
address CMDbatSUBsignal
comment "Return V - B, signal error on overflow";
pattern -(v:flt,b:bat[:bte],s:bat[:oid]) :bat[:flt]
address CMDbatSUBsignal
comment "Return V - B with candidates list, signal error on overflow";
pattern sub_noerror(v:flt,b:bat[:bte]) :bat[:flt]
address CMDbatSUB
comment "Return V - B, overflow causes NIL value";
pattern sub_noerror(v:flt,b:bat[:bte],s:bat[:oid]) :bat[:flt]
address CMDbatSUB
comment "Return V - B with candidates list, overflow causes NIL value";

pattern -(b1:bat[:flt],b2:bat[:sht]) :bat[:flt]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
pattern -(b1:bat[:flt],b2:bat[:sht],s:bat[:oid]) :bat[:flt]
address CMDbatSUBsignal
comment "Return B1 - B2 with candidates list, signal error on overflow";
pattern sub_noerror(b1:bat[:flt],b2:bat[:sht]) :bat[:flt]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern sub_noerror(b1:bat[:flt],b2:bat[:sht],s:bat[:oid]) :bat[:flt]
address CMDbatSUB
comment "Return B1 - B2 with candidates list, overflow causes NIL value";
pattern -(b:bat[:flt],v:sht) :bat[:flt]
address CMDbatSUBsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:flt],v:sht,s:bat[:oid]) :bat[:flt]
address CMDbatSUBsignal
comment "Return B - V with candidates list, signal error on overflow";
pattern sub_noerror(b:bat[:flt],v:sht) :bat[:flt]
address CMDbatSUB
comment "Return B - V, overflow causes NIL value";
pattern sub_noerror(b:bat[:flt],v:sht,s:bat[:oid]) :bat[:flt]
address CMDbatSUB
comment "Return B - V with candidates list, overflow causes NIL value";
pattern -(v:flt,b:bat[:sht]) :bat[:flt]
address CMDbatSUBsignal
comment "Return V - B, signal error on overflow";
pattern -(v:flt,b:bat[:sht],s:bat[:oid]) :bat[:flt]
address CMDbatSUBsignal
comment "Return V - B with candidates list, signal error on overflow";
pattern sub_noerror(v:flt,b:bat[:sht]) :bat[:flt]
address CMDbatSUB
comment "Return V - B, overflow causes NIL value";
pattern sub_noerror(v:flt,b:bat[:sht],s:bat[:oid]) :bat[:flt]
address CMDbatSUB
comment "Return V - B with candidates list, overflow causes NIL value";

pattern -(b1:bat[:flt],b2:bat[:int]) :bat[:flt]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
pattern -(b1:bat[:flt],b2:bat[:int],s:bat[:oid]) :bat[:flt]
address CMDbatSUBsignal
comment "Return B1 - B2 with candidates list, signal error on overflow";
pattern sub_noerror(b1:bat[:flt],b2:bat[:int]) :bat[:flt]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern sub_noerror(b1:bat[:flt],b2:bat[:int],s:bat[:oid]) :bat[:flt]
address CMDbatSUB
comment "Return B1 - B2 with candidates list, overflow causes NIL value";
pattern -(b:bat[:flt],v:int) :bat[:flt]
address CMDbatSUBsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:flt],v:int,s:bat[:oid]) :bat[:flt]
address CMDbatSUBsignal
comment "Return B - V with candidates list, signal error on overflow";
pattern sub_noerror(b:bat[:flt],v:int) :bat[:flt]
address CMDbatSUB
comment "Return B - V, overflow causes NIL value";
pattern sub_noerror(b:bat[:flt],v:int,s:bat[:oid]) :bat[:flt]
address CMDbatSUB
comment "Return B - V with candidates list, overflow causes NIL value";
pattern -(v:flt,b:bat[:int]) :bat[:flt]
address CMDbatSUBsignal
comment "Return V - B, signal error on overflow";
pattern -(v:flt,b:bat[:int],s:bat[:oid]) :bat[:flt]
address CMDbatSUBsignal
comment "Return V - B with candidates list, signal error on overflow";
pattern sub_noerror(v:flt,b:bat[:int]) :bat[:flt]
address CMDbatSUB
comment "Return V - B, overflow causes NIL value";
pattern sub_noerror(v:flt,b:bat[:int],s:bat[:oid]) :bat[:flt]
address CMDbatSUB
comment "Return V - B with candidates list, overflow causes NIL value";

pattern -(b1:bat[:flt],b2:bat[:lng]) :bat[:flt]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
pattern -(b1:bat[:flt],b2:bat[:lng],s:bat[:oid]) :bat[:flt]
address CMDbatSUBsignal
comment "Return B1 - B2 with candidates list, signal error on overflow";
pattern sub_noerror(b1:bat[:flt],b2:bat[:lng]) :bat[:flt]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern sub_noerror(b1:bat[:flt],b2:bat[:lng],s:bat[:oid]) :bat[:flt]
address CMDbatSUB
comment "Return B1 - B2 with candidates list, overflow causes NIL value";
pattern -(b:bat[:flt],v:lng) :bat[:flt]
address CMDbatSUBsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:flt],v:lng,s:bat[:oid]) :bat[:flt]
address CMDbatSUBsignal
comment "Return B - V with candidates list, signal error on overflow";
pattern sub_noerror(b:bat[:flt],v:lng) :bat[:flt]
address CMDbatSUB
comment "Return B - V, overflow causes NIL value";
pattern sub_noerror(b:bat[:flt],v:lng,s:bat[:oid]) :bat[:flt]
address CMDbatSUB
comment "Return B - V with candidates list, overflow causes NIL value";
pattern -(v:flt,b:bat[:lng]) :bat[:flt]
address CMDbatSUBsignal
comment "Return V - B, signal error on overflow";
pattern -(v:flt,b:bat[:lng],s:bat[:oid]) :bat[:flt]
address CMDbatSUBsignal
comment "Return V - B with candidates list, signal error on overflow";
pattern sub_noerror(v:flt,b:bat[:lng]) :bat[:flt]
address CMDbatSUB
comment "Return V - B, overflow causes NIL value";
pattern sub_noerror(v:flt,b:bat[:lng],s:bat[:oid]) :bat[:flt]
address CMDbatSUB
comment "Return V - B with candidates list, overflow causes NIL value";

pattern -(b1:bat[:flt],b2:bat[:flt]) :bat[:flt]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
pattern -(b1:bat[:flt],b2:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatSUBsignal
comment "Return B1 - B2 with candidates list, signal error on overflow";
pattern sub_noerror(b1:bat[:flt],b2:bat[:flt]) :bat[:flt]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern sub_noerror(b1:bat[:flt],b2:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatSUB
comment "Return B1 - B2 with candidates list, overflow causes NIL value";
pattern -(b:bat[:flt],v:flt) :bat[:flt]
address CMDbatSUBsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:flt],v:flt,s:bat[:oid]) :bat[:flt]
address CMDbatSUBsignal
comment "Return B - V with candidates list, signal error on overflow";
pattern sub_noerror(b:bat[:flt],v:flt) :bat[:flt]
address CMDbatSUB
comment "Return B - V, overflow causes NIL value";
pattern sub_noerror(b:bat[:flt],v:flt,s:bat[:oid]) :bat[:flt]
address CMDbatSUB
comment "Return B - V with candidates list, overflow causes NIL value";
pattern -(v:flt,b:bat[:flt]) :bat[:flt]
address CMDbatSUBsignal
comment "Return V - B, signal error on overflow";
pattern -(v:flt,b:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatSUBsignal
comment "Return V - B with candidates list, signal error on overflow";
pattern sub_noerror(v:flt,b:bat[:flt]) :bat[:flt]
address CMDbatSUB
comment "Return V - B, overflow causes NIL value";
pattern sub_noerror(v:flt,b:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatSUB
comment "Return V - B with candidates list, overflow causes NIL value";

pattern -(b1:bat[:flt],b2:bat[:dbl]) :bat[:dbl]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
pattern -(b1:bat[:flt],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatSUBsignal
comment "Return B1 - B2 with candidates list, signal error on overflow";
pattern sub_noerror(b1:bat[:flt],b2:bat[:dbl]) :bat[:dbl]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern sub_noerror(b1:bat[:flt],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatSUB
comment "Return B1 - B2 with candidates list, overflow causes NIL value";
pattern -(b:bat[:flt],v:dbl) :bat[:dbl]
address CMDbatSUBsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:flt],v:dbl,s:bat[:oid]) :bat[:dbl]
address CMDbatSUBsignal
comment "Return B - V with candidates list, signal error on overflow";
pattern sub_noerror(b:bat[:flt],v:dbl) :bat[:dbl]
address CMDbatSUB
comment "Return B - V, overflow causes NIL value";
pattern sub_noerror(b:bat[:flt],v:dbl,s:bat[:oid]) :bat[:dbl]
address CMDbatSUB
comment "Return B - V with candidates list, overflow causes NIL value";
pattern -(v:flt,b:bat[:dbl]) :bat[:dbl]
address CMDbatSUBsignal
comment "Return V - B, signal error on overflow";
pattern -(v:flt,b:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatSUBsignal
comment "Return V - B with candidates list, signal error on overflow";
pattern sub_noerror(v:flt,b:bat[:dbl]) :bat[:dbl]
address CMDbatSUB
comment "Return V - B, overflow causes NIL value";
pattern sub_noerror(v:flt,b:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatSUB
comment "Return V - B with candidates list, overflow causes NIL value";

pattern -(b1:bat[:dbl],b2:bat[:bte]) :bat[:dbl]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
pattern -(b1:bat[:dbl],b2:bat[:bte],s:bat[:oid]) :bat[:dbl]
address CMDbatSUBsignal
comment "Return B1 - B2 with candidates list, signal error on overflow";
pattern sub_noerror(b1:bat[:dbl],b2:bat[:bte]) :bat[:dbl]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern sub_noerror(b1:bat[:dbl],b2:bat[:bte],s:bat[:oid]) :bat[:dbl]
address CMDbatSUB
comment "Return B1 - B2 with candidates list, overflow causes NIL value";
pattern -(b:bat[:dbl],v:bte) :bat[:dbl]
address CMDbatSUBsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:dbl],v:bte,s:bat[:oid]) :bat[:dbl]
address CMDbatSUBsignal
comment "Return B - V with candidates list, signal error on overflow";
pattern sub_noerror(b:bat[:dbl],v:bte) :bat[:dbl]
address CMDbatSUB
comment "Return B - V, overflow causes NIL value";
pattern sub_noerror(b:bat[:dbl],v:bte,s:bat[:oid]) :bat[:dbl]
address CMDbatSUB
comment "Return B - V with candidates list, overflow causes NIL value";
pattern -(v:dbl,b:bat[:bte]) :bat[:dbl]
address CMDbatSUBsignal
comment "Return V - B, signal error on overflow";
pattern -(v:dbl,b:bat[:bte],s:bat[:oid]) :bat[:dbl]
address CMDbatSUBsignal
comment "Return V - B with candidates list, signal error on overflow";
pattern sub_noerror(v:dbl,b:bat[:bte]) :bat[:dbl]
address CMDbatSUB
comment "Return V - B, overflow causes NIL value";
pattern sub_noerror(v:dbl,b:bat[:bte],s:bat[:oid]) :bat[:dbl]
address CMDbatSUB
comment "Return V - B with candidates list, overflow causes NIL value";

pattern -(b1:bat[:dbl],b2:bat[:sht]) :bat[:dbl]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
pattern -(b1:bat[:dbl],b2:bat[:sht],s:bat[:oid]) :bat[:dbl]
address CMDbatSUBsignal
comment "Return B1 - B2 with candidates list, signal error on overflow";
pattern sub_noerror(b1:bat[:dbl],b2:bat[:sht]) :bat[:dbl]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern sub_noerror(b1:bat[:dbl],b2:bat[:sht],s:bat[:oid]) :bat[:dbl]
address CMDbatSUB
comment "Return B1 - B2 with candidates list, overflow causes NIL value";
pattern -(b:bat[:dbl],v:sht) :bat[:dbl]
address CMDbatSUBsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:dbl],v:sht,s:bat[:oid]) :bat[:dbl]
address CMDbatSUBsignal
comment "Return B - V with candidates list, signal error on overflow";
pattern sub_noerror(b:bat[:dbl],v:sht) :bat[:dbl]
address CMDbatSUB
comment "Return B - V, overflow causes NIL value";
pattern sub_noerror(b:bat[:dbl],v:sht,s:bat[:oid]) :bat[:dbl]
address CMDbatSUB
comment "Return B - V with candidates list, overflow causes NIL value";
pattern -(v:dbl,b:bat[:sht]) :bat[:dbl]
address CMDbatSUBsignal
comment "Return V - B, signal error on overflow";
pattern -(v:dbl,b:bat[:sht],s:bat[:oid]) :bat[:dbl]
address CMDbatSUBsignal
comment "Return V - B with candidates list, signal error on overflow";
pattern sub_noerror(v:dbl,b:bat[:sht]) :bat[:dbl]
address CMDbatSUB
comment "Return V - B, overflow causes NIL value";
pattern sub_noerror(v:dbl,b:bat[:sht],s:bat[:oid]) :bat[:dbl]
address CMDbatSUB
comment "Return V - B with candidates list, overflow causes NIL value";

pattern -(b1:bat[:dbl],b2:bat[:int]) :bat[:dbl]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
pattern -(b1:bat[:dbl],b2:bat[:int],s:bat[:oid]) :bat[:dbl]
address CMDbatSUBsignal
comment "Return B1 - B2 with candidates list, signal error on overflow";
pattern sub_noerror(b1:bat[:dbl],b2:bat[:int]) :bat[:dbl]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern sub_noerror(b1:bat[:dbl],b2:bat[:int],s:bat[:oid]) :bat[:dbl]
address CMDbatSUB
comment "Return B1 - B2 with candidates list, overflow causes NIL value";
pattern -(b:bat[:dbl],v:int) :bat[:dbl]
address CMDbatSUBsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:dbl],v:int,s:bat[:oid]) :bat[:dbl]
address CMDbatSUBsignal
comment "Return B - V with candidates list, signal error on overflow";
pattern sub_noerror(b:bat[:dbl],v:int) :bat[:dbl]
address CMDbatSUB
comment "Return B - V, overflow causes NIL value";
pattern sub_noerror(b:bat[:dbl],v:int,s:bat[:oid]) :bat[:dbl]
address CMDbatSUB
comment "Return B - V with candidates list, overflow causes NIL value";
pattern -(v:dbl,b:bat[:int]) :bat[:dbl]
address CMDbatSUBsignal
comment "Return V - B, signal error on overflow";
pattern -(v:dbl,b:bat[:int],s:bat[:oid]) :bat[:dbl]
address CMDbatSUBsignal
comment "Return V - B with candidates list, signal error on overflow";
pattern sub_noerror(v:dbl,b:bat[:int]) :bat[:dbl]
address CMDbatSUB
comment "Return V - B, overflow causes NIL value";
pattern sub_noerror(v:dbl,b:bat[:int],s:bat[:oid]) :bat[:dbl]
address CMDbatSUB
comment "Return V - B with candidates list, overflow causes NIL value";

pattern -(b1:bat[:dbl],b2:bat[:lng]) :bat[:dbl]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
pattern -(b1:bat[:dbl],b2:bat[:lng],s:bat[:oid]) :bat[:dbl]
address CMDbatSUBsignal
comment "Return B1 - B2 with candidates list, signal error on overflow";
pattern sub_noerror(b1:bat[:dbl],b2:bat[:lng]) :bat[:dbl]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern sub_noerror(b1:bat[:dbl],b2:bat[:lng],s:bat[:oid]) :bat[:dbl]
address CMDbatSUB
comment "Return B1 - B2 with candidates list, overflow causes NIL value";
pattern -(b:bat[:dbl],v:lng) :bat[:dbl]
address CMDbatSUBsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:dbl],v:lng,s:bat[:oid]) :bat[:dbl]
address CMDbatSUBsignal
comment "Return B - V with candidates list, signal error on overflow";
pattern sub_noerror(b:bat[:dbl],v:lng) :bat[:dbl]
address CMDbatSUB
comment "Return B - V, overflow causes NIL value";
pattern sub_noerror(b:bat[:dbl],v:lng,s:bat[:oid]) :bat[:dbl]
address CMDbatSUB
comment "Return B - V with candidates list, overflow causes NIL value";
pattern -(v:dbl,b:bat[:lng]) :bat[:dbl]
address CMDbatSUBsignal
comment "Return V - B, signal error on overflow";
pattern -(v:dbl,b:bat[:lng],s:bat[:oid]) :bat[:dbl]
address CMDbatSUBsignal
comment "Return V - B with candidates list, signal error on overflow";
pattern sub_noerror(v:dbl,b:bat[:lng]) :bat[:dbl]
address CMDbatSUB
comment "Return V - B, overflow causes NIL value";
pattern sub_noerror(v:dbl,b:bat[:lng],s:bat[:oid]) :bat[:dbl]
address CMDbatSUB
comment "Return V - B with candidates list, overflow causes NIL value";

pattern -(b1:bat[:dbl],b2:bat[:flt]) :bat[:dbl]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
pattern -(b1:bat[:dbl],b2:bat[:flt],s:bat[:oid]) :bat[:dbl]
address CMDbatSUBsignal
comment "Return B1 - B2 with candidates list, signal error on overflow";
pattern sub_noerror(b1:bat[:dbl],b2:bat[:flt]) :bat[:dbl]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern sub_noerror(b1:bat[:dbl],b2:bat[:flt],s:bat[:oid]) :bat[:dbl]
address CMDbatSUB
comment "Return B1 - B2 with candidates list, overflow causes NIL value";
pattern -(b:bat[:dbl],v:flt) :bat[:dbl]
address CMDbatSUBsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:dbl],v:flt,s:bat[:oid]) :bat[:dbl]
address CMDbatSUBsignal
comment "Return B - V with candidates list, signal error on overflow";
pattern sub_noerror(b:bat[:dbl],v:flt) :bat[:dbl]
address CMDbatSUB
comment "Return B - V, overflow causes NIL value";
pattern sub_noerror(b:bat[:dbl],v:flt,s:bat[:oid]) :bat[:dbl]
address CMDbatSUB
comment "Return B - V with candidates list, overflow causes NIL value";
pattern -(v:dbl,b:bat[:flt]) :bat[:dbl]
address CMDbatSUBsignal
comment "Return V - B, signal error on overflow";
pattern -(v:dbl,b:bat[:flt],s:bat[:oid]) :bat[:dbl]
address CMDbatSUBsignal
comment "Return V - B with candidates list, signal error on overflow";
pattern sub_noerror(v:dbl,b:bat[:flt]) :bat[:dbl]
address CMDbatSUB
comment "Return V - B, overflow causes NIL value";
pattern sub_noerror(v:dbl,b:bat[:flt],s:bat[:oid]) :bat[:dbl]
address CMDbatSUB
comment "Return V - B with candidates list, overflow causes NIL value";

pattern -(b1:bat[:dbl],b2:bat[:dbl]) :bat[:dbl]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
pattern -(b1:bat[:dbl],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatSUBsignal
comment "Return B1 - B2 with candidates list, signal error on overflow";
pattern sub_noerror(b1:bat[:dbl],b2:bat[:dbl]) :bat[:dbl]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern sub_noerror(b1:bat[:dbl],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatSUB
comment "Return B1 - B2 with candidates list, overflow causes NIL value";
pattern -(b:bat[:dbl],v:dbl) :bat[:dbl]
address CMDbatSUBsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:dbl],v:dbl,s:bat[:oid]) :bat[:dbl]
address CMDbatSUBsignal
comment "Return B - V with candidates list, signal error on overflow";
pattern sub_noerror(b:bat[:dbl],v:dbl) :bat[:dbl]
address CMDbatSUB
comment "Return B - V, overflow causes NIL value";
pattern sub_noerror(b:bat[:dbl],v:dbl,s:bat[:oid]) :bat[:dbl]
address CMDbatSUB
comment "Return B - V with candidates list, overflow causes NIL value";
pattern -(v:dbl,b:bat[:dbl]) :bat[:dbl]
address CMDbatSUBsignal
comment "Return V - B, signal error on overflow";
pattern -(v:dbl,b:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatSUBsignal
comment "Return V - B with candidates list, signal error on overflow";
pattern sub_noerror(v:dbl,b:bat[:dbl]) :bat[:dbl]
address CMDbatSUB
comment "Return V - B, overflow causes NIL value";
pattern sub_noerror(v:dbl,b:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatSUB
comment "Return V - B with candidates list, overflow causes NIL value";


pattern *(b1:bat[:bte],b2:bat[:bte]) :bat[:bte]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
pattern *(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]) :bat[:bte]
address CMDbatMULsignal
comment "Return B1 * B2 with candidates list, signal error on overflow";
pattern mul_noerror(b1:bat[:bte],b2:bat[:bte]) :bat[:bte]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern mul_noerror(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]) :bat[:bte]
address CMDbatMUL
comment "Return B1 * B2 with candidates list, overflow causes NIL value";
pattern *(b:bat[:bte],v:bte) :bat[:bte]
address CMDbatMULsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:bte],v:bte,s:bat[:oid]) :bat[:bte]
address CMDbatMULsignal
comment "Return B * V with candidates list, signal error on overflow";
pattern mul_noerror(b:bat[:bte],v:bte) :bat[:bte]
address CMDbatMUL
comment "Return B * V, overflow causes NIL value";
pattern mul_noerror(b:bat[:bte],v:bte,s:bat[:oid]) :bat[:bte]
address CMDbatMUL
comment "Return B * V with candidates list, overflow causes NIL value";
pattern *(v:bte,b:bat[:bte]) :bat[:bte]
address CMDbatMULsignal
comment "Return V * B, signal error on overflow";
pattern *(v:bte,b:bat[:bte],s:bat[:oid]) :bat[:bte]
address CMDbatMULsignal
comment "Return V * B with candidates list, signal error on overflow";
pattern mul_noerror(v:bte,b:bat[:bte]) :bat[:bte]
address CMDbatMUL
comment "Return V * B, overflow causes NIL value";
pattern mul_noerror(v:bte,b:bat[:bte],s:bat[:oid]) :bat[:bte]
address CMDbatMUL
comment "Return V * B with candidates list, overflow causes NIL value";

pattern *(b1:bat[:bte],b2:bat[:sht]) :bat[:sht]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
pattern *(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]) :bat[:sht]
address CMDbatMULsignal
comment "Return B1 * B2 with candidates list, signal error on overflow";
pattern mul_noerror(b1:bat[:bte],b2:bat[:sht]) :bat[:sht]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern mul_noerror(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]) :bat[:sht]
address CMDbatMUL
comment "Return B1 * B2 with candidates list, overflow causes NIL value";
pattern *(b:bat[:bte],v:sht) :bat[:sht]
address CMDbatMULsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:bte],v:sht,s:bat[:oid]) :bat[:sht]
address CMDbatMULsignal
comment "Return B * V with candidates list, signal error on overflow";
pattern mul_noerror(b:bat[:bte],v:sht) :bat[:sht]
address CMDbatMUL
comment "Return B * V, overflow causes NIL value";
pattern mul_noerror(b:bat[:bte],v:sht,s:bat[:oid]) :bat[:sht]
address CMDbatMUL
comment "Return B * V with candidates list, overflow causes NIL value";
pattern *(v:bte,b:bat[:sht]) :bat[:sht]
address CMDbatMULsignal
comment "Return V * B, signal error on overflow";
pattern *(v:bte,b:bat[:sht],s:bat[:oid]) :bat[:sht]
address CMDbatMULsignal
comment "Return V * B with candidates list, signal error on overflow";
pattern mul_noerror(v:bte,b:bat[:sht]) :bat[:sht]
address CMDbatMUL
comment "Return V * B, overflow causes NIL value";
pattern mul_noerror(v:bte,b:bat[:sht],s:bat[:oid]) :bat[:sht]
address CMDbatMUL
comment "Return V * B with candidates list, overflow causes NIL value";

pattern *(b1:bat[:bte],b2:bat[:int]) :bat[:int]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
pattern *(b1:bat[:bte],b2:bat[:int],s:bat[:oid]) :bat[:int]
address CMDbatMULsignal
comment "Return B1 * B2 with candidates list, signal error on overflow";
pattern mul_noerror(b1:bat[:bte],b2:bat[:int]) :bat[:int]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern mul_noerror(b1:bat[:bte],b2:bat[:int],s:bat[:oid]) :bat[:int]
address CMDbatMUL
comment "Return B1 * B2 with candidates list, overflow causes NIL value";
pattern *(b:bat[:bte],v:int) :bat[:int]
address CMDbatMULsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:bte],v:int,s:bat[:oid]) :bat[:int]
address CMDbatMULsignal
comment "Return B * V with candidates list, signal error on overflow";
pattern mul_noerror(b:bat[:bte],v:int) :bat[:int]
address CMDbatMUL
comment "Return B * V, overflow causes NIL value";
pattern mul_noerror(b:bat[:bte],v:int,s:bat[:oid]) :bat[:int]
address CMDbatMUL
comment "Return B * V with candidates list, overflow causes NIL value";
pattern *(v:bte,b:bat[:int]) :bat[:int]
address CMDbatMULsignal
comment "Return V * B, signal error on overflow";
pattern *(v:bte,b:bat[:int],s:bat[:oid]) :bat[:int]
address CMDbatMULsignal
comment "Return V * B with candidates list, signal error on overflow";
pattern mul_noerror(v:bte,b:bat[:int]) :bat[:int]
address CMDbatMUL
comment "Return V * B, overflow causes NIL value";
pattern mul_noerror(v:bte,b:bat[:int],s:bat[:oid]) :bat[:int]
address CMDbatMUL
comment "Return V * B with candidates list, overflow causes NIL value";

pattern *(b1:bat[:bte],b2:bat[:lng]) :bat[:lng]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
pattern *(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]) :bat[:lng]
address CMDbatMULsignal
comment "Return B1 * B2 with candidates list, signal error on overflow";
pattern mul_noerror(b1:bat[:bte],b2:bat[:lng]) :bat[:lng]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern mul_noerror(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]) :bat[:lng]
address CMDbatMUL
comment "Return B1 * B2 with candidates list, overflow causes NIL value";
pattern *(b:bat[:bte],v:lng) :bat[:lng]
address CMDbatMULsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:bte],v:lng,s:bat[:oid]) :bat[:lng]
address CMDbatMULsignal
comment "Return B * V with candidates list, signal error on overflow";
pattern mul_noerror(b:bat[:bte],v:lng) :bat[:lng]
address CMDbatMUL
comment "Return B * V, overflow causes NIL value";
pattern mul_noerror(b:bat[:bte],v:lng,s:bat[:oid]) :bat[:lng]
address CMDbatMUL
comment "Return B * V with candidates list, overflow causes NIL value";
pattern *(v:bte,b:bat[:lng]) :bat[:lng]
address CMDbatMULsignal
comment "Return V * B, signal error on overflow";
pattern *(v:bte,b:bat[:lng],s:bat[:oid]) :bat[:lng]
address CMDbatMULsignal
comment "Return V * B with candidates list, signal error on overflow";
pattern mul_noerror(v:bte,b:bat[:lng]) :bat[:lng]
address CMDbatMUL
comment "Return V * B, overflow causes NIL value";
pattern mul_noerror(v:bte,b:bat[:lng],s:bat[:oid]) :bat[:lng]
address CMDbatMUL
comment "Return V * B with candidates list, overflow causes NIL value";

pattern *(b1:bat[:bte],b2:bat[:flt]) :bat[:flt]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
pattern *(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatMULsignal
comment "Return B1 * B2 with candidates list, signal error on overflow";
pattern mul_noerror(b1:bat[:bte],b2:bat[:flt]) :bat[:flt]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern mul_noerror(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatMUL
comment "Return B1 * B2 with candidates list, overflow causes NIL value";
pattern *(b:bat[:bte],v:flt) :bat[:flt]
address CMDbatMULsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:bte],v:flt,s:bat[:oid]) :bat[:flt]
address CMDbatMULsignal
comment "Return B * V with candidates list, signal error on overflow";
pattern mul_noerror(b:bat[:bte],v:flt) :bat[:flt]
address CMDbatMUL
comment "Return B * V, overflow causes NIL value";
pattern mul_noerror(b:bat[:bte],v:flt,s:bat[:oid]) :bat[:flt]
address CMDbatMUL
comment "Return B * V with candidates list, overflow causes NIL value";
pattern *(v:bte,b:bat[:flt]) :bat[:flt]
address CMDbatMULsignal
comment "Return V * B, signal error on overflow";
pattern *(v:bte,b:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatMULsignal
comment "Return V * B with candidates list, signal error on overflow";
pattern mul_noerror(v:bte,b:bat[:flt]) :bat[:flt]
address CMDbatMUL
comment "Return V * B, overflow causes NIL value";
pattern mul_noerror(v:bte,b:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatMUL
comment "Return V * B with candidates list, overflow causes NIL value";

pattern *(b1:bat[:bte],b2:bat[:dbl]) :bat[:dbl]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
pattern *(b1:bat[:bte],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatMULsignal
comment "Return B1 * B2 with candidates list, signal error on overflow";
pattern mul_noerror(b1:bat[:bte],b2:bat[:dbl]) :bat[:dbl]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern mul_noerror(b1:bat[:bte],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatMUL
comment "Return B1 * B2 with candidates list, overflow causes NIL value";
pattern *(b:bat[:bte],v:dbl) :bat[:dbl]
address CMDbatMULsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:bte],v:dbl,s:bat[:oid]) :bat[:dbl]
address CMDbatMULsignal
comment "Return B * V with candidates list, signal error on overflow";
pattern mul_noerror(b:bat[:bte],v:dbl) :bat[:dbl]
address CMDbatMUL
comment "Return B * V, overflow causes NIL value";
pattern mul_noerror(b:bat[:bte],v:dbl,s:bat[:oid]) :bat[:dbl]
address CMDbatMUL
comment "Return B * V with candidates list, overflow causes NIL value";
pattern *(v:bte,b:bat[:dbl]) :bat[:dbl]
address CMDbatMULsignal
comment "Return V * B, signal error on overflow";
pattern *(v:bte,b:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatMULsignal
comment "Return V * B with candidates list, signal error on overflow";
pattern mul_noerror(v:bte,b:bat[:dbl]) :bat[:dbl]
address CMDbatMUL
comment "Return V * B, overflow causes NIL value";
pattern mul_noerror(v:bte,b:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatMUL
comment "Return V * B with candidates list, overflow causes NIL value";

pattern *(b1:bat[:sht],b2:bat[:bte]) :bat[:sht]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
pattern *(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]) :bat[:sht]
address CMDbatMULsignal
comment "Return B1 * B2 with candidates list, signal error on overflow";
pattern mul_noerror(b1:bat[:sht],b2:bat[:bte]) :bat[:sht]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern mul_noerror(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]) :bat[:sht]
address CMDbatMUL
comment "Return B1 * B2 with candidates list, overflow causes NIL value";
pattern *(b:bat[:sht],v:bte) :bat[:sht]
address CMDbatMULsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:sht],v:bte,s:bat[:oid]) :bat[:sht]
address CMDbatMULsignal
comment "Return B * V with candidates list, signal error on overflow";
pattern mul_noerror(b:bat[:sht],v:bte) :bat[:sht]
address CMDbatMUL
comment "Return B * V, overflow causes NIL value";
pattern mul_noerror(b:bat[:sht],v:bte,s:bat[:oid]) :bat[:sht]
address CMDbatMUL
comment "Return B * V with candidates list, overflow causes NIL value";
pattern *(v:sht,b:bat[:bte]) :bat[:sht]
address CMDbatMULsignal
comment "Return V * B, signal error on overflow";
pattern *(v:sht,b:bat[:bte],s:bat[:oid]) :bat[:sht]
address CMDbatMULsignal
comment "Return V * B with candidates list, signal error on overflow";
pattern mul_noerror(v:sht,b:bat[:bte]) :bat[:sht]
address CMDbatMUL
comment "Return V * B, overflow causes NIL value";
pattern mul_noerror(v:sht,b:bat[:bte],s:bat[:oid]) :bat[:sht]
address CMDbatMUL
comment "Return V * B with candidates list, overflow causes NIL value";

pattern *(b1:bat[:sht],b2:bat[:sht]) :bat[:sht]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
pattern *(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]) :bat[:sht]
address CMDbatMULsignal
comment "Return B1 * B2 with candidates list, signal error on overflow";
pattern mul_noerror(b1:bat[:sht],b2:bat[:sht]) :bat[:sht]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern mul_noerror(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]) :bat[:sht]
address CMDbatMUL
comment "Return B1 * B2 with candidates list, overflow causes NIL value";
pattern *(b:bat[:sht],v:sht) :bat[:sht]
address CMDbatMULsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:sht],v:sht,s:bat[:oid]) :bat[:sht]
address CMDbatMULsignal
comment "Return B * V with candidates list, signal error on overflow";
pattern mul_noerror(b:bat[:sht],v:sht) :bat[:sht]
address CMDbatMUL
comment "Return B * V, overflow causes NIL value";
pattern mul_noerror(b:bat[:sht],v:sht,s:bat[:oid]) :bat[:sht]
address CMDbatMUL
comment "Return B * V with candidates list, overflow causes NIL value";
pattern *(v:sht,b:bat[:sht]) :bat[:sht]
address CMDbatMULsignal
comment "Return V * B, signal error on overflow";
pattern *(v:sht,b:bat[:sht],s:bat[:oid]) :bat[:sht]
address CMDbatMULsignal
comment "Return V * B with candidates list, signal error on overflow";
pattern mul_noerror(v:sht,b:bat[:sht]) :bat[:sht]
address CMDbatMUL
comment "Return V * B, overflow causes NIL value";
pattern mul_noerror(v:sht,b:bat[:sht],s:bat[:oid]) :bat[:sht]
address CMDbatMUL
comment "Return V * B with candidates list, overflow causes NIL value";

pattern *(b1:bat[:sht],b2:bat[:int]) :bat[:int]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
pattern *(b1:bat[:sht],b2:bat[:int],s:bat[:oid]) :bat[:int]
address CMDbatMULsignal
comment "Return B1 * B2 with candidates list, signal error on overflow";
pattern mul_noerror(b1:bat[:sht],b2:bat[:int]) :bat[:int]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern mul_noerror(b1:bat[:sht],b2:bat[:int],s:bat[:oid]) :bat[:int]
address CMDbatMUL
comment "Return B1 * B2 with candidates list, overflow causes NIL value";
pattern *(b:bat[:sht],v:int) :bat[:int]
address CMDbatMULsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:sht],v:int,s:bat[:oid]) :bat[:int]
address CMDbatMULsignal
comment "Return B * V with candidates list, signal error on overflow";
pattern mul_noerror(b:bat[:sht],v:int) :bat[:int]
address CMDbatMUL
comment "Return B * V, overflow causes NIL value";
pattern mul_noerror(b:bat[:sht],v:int,s:bat[:oid]) :bat[:int]
address CMDbatMUL
comment "Return B * V with candidates list, overflow causes NIL value";
pattern *(v:sht,b:bat[:int]) :bat[:int]
address CMDbatMULsignal
comment "Return V * B, signal error on overflow";
pattern *(v:sht,b:bat[:int],s:bat[:oid]) :bat[:int]
address CMDbatMULsignal
comment "Return V * B with candidates list, signal error on overflow";
pattern mul_noerror(v:sht,b:bat[:int]) :bat[:int]
address CMDbatMUL
comment "Return V * B, overflow causes NIL value";
pattern mul_noerror(v:sht,b:bat[:int],s:bat[:oid]) :bat[:int]
address CMDbatMUL
comment "Return V * B with candidates list, overflow causes NIL value";

pattern *(b1:bat[:sht],b2:bat[:lng]) :bat[:lng]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
pattern *(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]) :bat[:lng]
address CMDbatMULsignal
comment "Return B1 * B2 with candidates list, signal error on overflow";
pattern mul_noerror(b1:bat[:sht],b2:bat[:lng]) :bat[:lng]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern mul_noerror(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]) :bat[:lng]
address CMDbatMUL
comment "Return B1 * B2 with candidates list, overflow causes NIL value";
pattern *(b:bat[:sht],v:lng) :bat[:lng]
address CMDbatMULsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:sht],v:lng,s:bat[:oid]) :bat[:lng]
address CMDbatMULsignal
comment "Return B * V with candidates list, signal error on overflow";
pattern mul_noerror(b:bat[:sht],v:lng) :bat[:lng]
address CMDbatMUL
comment "Return B * V, overflow causes NIL value";
pattern mul_noerror(b:bat[:sht],v:lng,s:bat[:oid]) :bat[:lng]
address CMDbatMUL
comment "Return B * V with candidates list, overflow causes NIL value";
pattern *(v:sht,b:bat[:lng]) :bat[:lng]
address CMDbatMULsignal
comment "Return V * B, signal error on overflow";
pattern *(v:sht,b:bat[:lng],s:bat[:oid]) :bat[:lng]
address CMDbatMULsignal
comment "Return V * B with candidates list, signal error on overflow";
pattern mul_noerror(v:sht,b:bat[:lng]) :bat[:lng]
address CMDbatMUL
comment "Return V * B, overflow causes NIL value";
pattern mul_noerror(v:sht,b:bat[:lng],s:bat[:oid]) :bat[:lng]
address CMDbatMUL
comment "Return V * B with candidates list, overflow causes NIL value";

pattern *(b1:bat[:sht],b2:bat[:flt]) :bat[:flt]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
pattern *(b1:bat[:sht],b2:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatMULsignal
comment "Return B1 * B2 with candidates list, signal error on overflow";
pattern mul_noerror(b1:bat[:sht],b2:bat[:flt]) :bat[:flt]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern mul_noerror(b1:bat[:sht],b2:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatMUL
comment "Return B1 * B2 with candidates list, overflow causes NIL value";
pattern *(b:bat[:sht],v:flt) :bat[:flt]
address CMDbatMULsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:sht],v:flt,s:bat[:oid]) :bat[:flt]
address CMDbatMULsignal
comment "Return B * V with candidates list, signal error on overflow";
pattern mul_noerror(b:bat[:sht],v:flt) :bat[:flt]
address CMDbatMUL
comment "Return B * V, overflow causes NIL value";
pattern mul_noerror(b:bat[:sht],v:flt,s:bat[:oid]) :bat[:flt]
address CMDbatMUL
comment "Return B * V with candidates list, overflow causes NIL value";
pattern *(v:sht,b:bat[:flt]) :bat[:flt]
address CMDbatMULsignal
comment "Return V * B, signal error on overflow";
pattern *(v:sht,b:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatMULsignal
comment "Return V * B with candidates list, signal error on overflow";
pattern mul_noerror(v:sht,b:bat[:flt]) :bat[:flt]
address CMDbatMUL
comment "Return V * B, overflow causes NIL value";
pattern mul_noerror(v:sht,b:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatMUL
comment "Return V * B with candidates list, overflow causes NIL value";

pattern *(b1:bat[:sht],b2:bat[:dbl]) :bat[:dbl]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
pattern *(b1:bat[:sht],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatMULsignal
comment "Return B1 * B2 with candidates list, signal error on overflow";
pattern mul_noerror(b1:bat[:sht],b2:bat[:dbl]) :bat[:dbl]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern mul_noerror(b1:bat[:sht],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatMUL
comment "Return B1 * B2 with candidates list, overflow causes NIL value";
pattern *(b:bat[:sht],v:dbl) :bat[:dbl]
address CMDbatMULsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:sht],v:dbl,s:bat[:oid]) :bat[:dbl]
address CMDbatMULsignal
comment "Return B * V with candidates list, signal error on overflow";
pattern mul_noerror(b:bat[:sht],v:dbl) :bat[:dbl]
address CMDbatMUL
comment "Return B * V, overflow causes NIL value";
pattern mul_noerror(b:bat[:sht],v:dbl,s:bat[:oid]) :bat[:dbl]
address CMDbatMUL
comment "Return B * V with candidates list, overflow causes NIL value";
pattern *(v:sht,b:bat[:dbl]) :bat[:dbl]
address CMDbatMULsignal
comment "Return V * B, signal error on overflow";
pattern *(v:sht,b:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatMULsignal
comment "Return V * B with candidates list, signal error on overflow";
pattern mul_noerror(v:sht,b:bat[:dbl]) :bat[:dbl]
address CMDbatMUL
comment "Return V * B, overflow causes NIL value";
pattern mul_noerror(v:sht,b:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatMUL
comment "Return V * B with candidates list, overflow causes NIL value";

pattern *(b1:bat[:int],b2:bat[:bte]) :bat[:int]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
pattern *(b1:bat[:int],b2:bat[:bte],s:bat[:oid]) :bat[:int]
address CMDbatMULsignal
comment "Return B1 * B2 with candidates list, signal error on overflow";
pattern mul_noerror(b1:bat[:int],b2:bat[:bte]) :bat[:int]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern mul_noerror(b1:bat[:int],b2:bat[:bte],s:bat[:oid]) :bat[:int]
address CMDbatMUL
comment "Return B1 * B2 with candidates list, overflow causes NIL value";
pattern *(b:bat[:int],v:bte) :bat[:int]
address CMDbatMULsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:int],v:bte,s:bat[:oid]) :bat[:int]
address CMDbatMULsignal
comment "Return B * V with candidates list, signal error on overflow";
pattern mul_noerror(b:bat[:int],v:bte) :bat[:int]
address CMDbatMUL
comment "Return B * V, overflow causes NIL value";
pattern mul_noerror(b:bat[:int],v:bte,s:bat[:oid]) :bat[:int]
address CMDbatMUL
comment "Return B * V with candidates list, overflow causes NIL value";
pattern *(v:int,b:bat[:bte]) :bat[:int]
address CMDbatMULsignal
comment "Return V * B, signal error on overflow";
pattern *(v:int,b:bat[:bte],s:bat[:oid]) :bat[:int]
address CMDbatMULsignal
comment "Return V * B with candidates list, signal error on overflow";
pattern mul_noerror(v:int,b:bat[:bte]) :bat[:int]
address CMDbatMUL
comment "Return V * B, overflow causes NIL value";
pattern mul_noerror(v:int,b:bat[:bte],s:bat[:oid]) :bat[:int]
address CMDbatMUL
comment "Return V * B with candidates list, overflow causes NIL value";

pattern *(b1:bat[:int],b2:bat[:sht]) :bat[:int]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
pattern *(b1:bat[:int],b2:bat[:sht],s:bat[:oid]) :bat[:int]
address CMDbatMULsignal
comment "Return B1 * B2 with candidates list, signal error on overflow";
pattern mul_noerror(b1:bat[:int],b2:bat[:sht]) :bat[:int]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern mul_noerror(b1:bat[:int],b2:bat[:sht],s:bat[:oid]) :bat[:int]
address CMDbatMUL
comment "Return B1 * B2 with candidates list, overflow causes NIL value";
pattern *(b:bat[:int],v:sht) :bat[:int]
address CMDbatMULsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:int],v:sht,s:bat[:oid]) :bat[:int]
address CMDbatMULsignal
comment "Return B * V with candidates list, signal error on overflow";
pattern mul_noerror(b:bat[:int],v:sht) :bat[:int]
address CMDbatMUL
comment "Return B * V, overflow causes NIL value";
pattern mul_noerror(b:bat[:int],v:sht,s:bat[:oid]) :bat[:int]
address CMDbatMUL
comment "Return B * V with candidates list, overflow causes NIL value";
pattern *(v:int,b:bat[:sht]) :bat[:int]
address CMDbatMULsignal
comment "Return V * B, signal error on overflow";
pattern *(v:int,b:bat[:sht],s:bat[:oid]) :bat[:int]
address CMDbatMULsignal
comment "Return V * B with candidates list, signal error on overflow";
pattern mul_noerror(v:int,b:bat[:sht]) :bat[:int]
address CMDbatMUL
comment "Return V * B, overflow causes NIL value";
pattern mul_noerror(v:int,b:bat[:sht],s:bat[:oid]) :bat[:int]
address CMDbatMUL
comment "Return V * B with candidates list, overflow causes NIL value";

pattern *(b1:bat[:int],b2:bat[:int]) :bat[:int]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
pattern *(b1:bat[:int],b2:bat[:int],s:bat[:oid]) :bat[:int]
address CMDbatMULsignal
comment "Return B1 * B2 with candidates list, signal error on overflow";
pattern mul_noerror(b1:bat[:int],b2:bat[:int]) :bat[:int]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern mul_noerror(b1:bat[:int],b2:bat[:int],s:bat[:oid]) :bat[:int]
address CMDbatMUL
comment "Return B1 * B2 with candidates list, overflow causes NIL value";
pattern *(b:bat[:int],v:int) :bat[:int]
address CMDbatMULsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:int],v:int,s:bat[:oid]) :bat[:int]
address CMDbatMULsignal
comment "Return B * V with candidates list, signal error on overflow";
pattern mul_noerror(b:bat[:int],v:int) :bat[:int]
address CMDbatMUL
comment "Return B * V, overflow causes NIL value";
pattern mul_noerror(b:bat[:int],v:int,s:bat[:oid]) :bat[:int]
address CMDbatMUL
comment "Return B * V with candidates list, overflow causes NIL value";
pattern *(v:int,b:bat[:int]) :bat[:int]
address CMDbatMULsignal
comment "Return V * B, signal error on overflow";
pattern *(v:int,b:bat[:int],s:bat[:oid]) :bat[:int]
address CMDbatMULsignal
comment "Return V * B with candidates list, signal error on overflow";
pattern mul_noerror(v:int,b:bat[:int]) :bat[:int]
address CMDbatMUL
comment "Return V * B, overflow causes NIL value";
pattern mul_noerror(v:int,b:bat[:int],s:bat[:oid]) :bat[:int]
address CMDbatMUL
comment "Return V * B with candidates list, overflow causes NIL value";

pattern *(b1:bat[:int],b2:bat[:lng]) :bat[:lng]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
pattern *(b1:bat[:int],b2:bat[:lng],s:bat[:oid]) :bat[:lng]
address CMDbatMULsignal
comment "Return B1 * B2 with candidates list, signal error on overflow";
pattern mul_noerror(b1:bat[:int],b2:bat[:lng]) :bat[:lng]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern mul_noerror(b1:bat[:int],b2:bat[:lng],s:bat[:oid]) :bat[:lng]
address CMDbatMUL
comment "Return B1 * B2 with candidates list, overflow causes NIL value";
pattern *(b:bat[:int],v:lng) :bat[:lng]
address CMDbatMULsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:int],v:lng,s:bat[:oid]) :bat[:lng]
address CMDbatMULsignal
comment "Return B * V with candidates list, signal error on overflow";
pattern mul_noerror(b:bat[:int],v:lng) :bat[:lng]
address CMDbatMUL
comment "Return B * V, overflow causes NIL value";
pattern mul_noerror(b:bat[:int],v:lng,s:bat[:oid]) :bat[:lng]
address CMDbatMUL
comment "Return B * V with candidates list, overflow causes NIL value";
pattern *(v:int,b:bat[:lng]) :bat[:lng]
address CMDbatMULsignal
comment "Return V * B, signal error on overflow";
pattern *(v:int,b:bat[:lng],s:bat[:oid]) :bat[:lng]
address CMDbatMULsignal
comment "Return V * B with candidates list, signal error on overflow";
pattern mul_noerror(v:int,b:bat[:lng]) :bat[:lng]
address CMDbatMUL
comment "Return V * B, overflow causes NIL value";
pattern mul_noerror(v:int,b:bat[:lng],s:bat[:oid]) :bat[:lng]
address CMDbatMUL
comment "Return V * B with candidates list, overflow causes NIL value";

pattern *(b1:bat[:int],b2:bat[:flt]) :bat[:flt]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
pattern *(b1:bat[:int],b2:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatMULsignal
comment "Return B1 * B2 with candidates list, signal error on overflow";
pattern mul_noerror(b1:bat[:int],b2:bat[:flt]) :bat[:flt]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern mul_noerror(b1:bat[:int],b2:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatMUL
comment "Return B1 * B2 with candidates list, overflow causes NIL value";
pattern *(b:bat[:int],v:flt) :bat[:flt]
address CMDbatMULsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:int],v:flt,s:bat[:oid]) :bat[:flt]
address CMDbatMULsignal
comment "Return B * V with candidates list, signal error on overflow";
pattern mul_noerror(b:bat[:int],v:flt) :bat[:flt]
address CMDbatMUL
comment "Return B * V, overflow causes NIL value";
pattern mul_noerror(b:bat[:int],v:flt,s:bat[:oid]) :bat[:flt]
address CMDbatMUL
comment "Return B * V with candidates list, overflow causes NIL value";
pattern *(v:int,b:bat[:flt]) :bat[:flt]
address CMDbatMULsignal
comment "Return V * B, signal error on overflow";
pattern *(v:int,b:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatMULsignal
comment "Return V * B with candidates list, signal error on overflow";
pattern mul_noerror(v:int,b:bat[:flt]) :bat[:flt]
address CMDbatMUL
comment "Return V * B, overflow causes NIL value";
pattern mul_noerror(v:int,b:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatMUL
comment "Return V * B with candidates list, overflow causes NIL value";

pattern *(b1:bat[:int],b2:bat[:dbl]) :bat[:dbl]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
pattern *(b1:bat[:int],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatMULsignal
comment "Return B1 * B2 with candidates list, signal error on overflow";
pattern mul_noerror(b1:bat[:int],b2:bat[:dbl]) :bat[:dbl]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern mul_noerror(b1:bat[:int],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatMUL
comment "Return B1 * B2 with candidates list, overflow causes NIL value";
pattern *(b:bat[:int],v:dbl) :bat[:dbl]
address CMDbatMULsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:int],v:dbl,s:bat[:oid]) :bat[:dbl]
address CMDbatMULsignal
comment "Return B * V with candidates list, signal error on overflow";
pattern mul_noerror(b:bat[:int],v:dbl) :bat[:dbl]
address CMDbatMUL
comment "Return B * V, overflow causes NIL value";
pattern mul_noerror(b:bat[:int],v:dbl,s:bat[:oid]) :bat[:dbl]
address CMDbatMUL
comment "Return B * V with candidates list, overflow causes NIL value";
pattern *(v:int,b:bat[:dbl]) :bat[:dbl]
address CMDbatMULsignal
comment "Return V * B, signal error on overflow";
pattern *(v:int,b:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatMULsignal
comment "Return V * B with candidates list, signal error on overflow";
pattern mul_noerror(v:int,b:bat[:dbl]) :bat[:dbl]
address CMDbatMUL
comment "Return V * B, overflow causes NIL value";
pattern mul_noerror(v:int,b:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatMUL
comment "Return V * B with candidates list, overflow causes NIL value";

pattern *(b1:bat[:lng],b2:bat[:bte]) :bat[:lng]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
pattern *(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]) :bat[:lng]
address CMDbatMULsignal
comment "Return B1 * B2 with candidates list, signal error on overflow";
pattern mul_noerror(b1:bat[:lng],b2:bat[:bte]) :bat[:lng]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern mul_noerror(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]) :bat[:lng]
address CMDbatMUL
comment "Return B1 * B2 with candidates list, overflow causes NIL value";
pattern *(b:bat[:lng],v:bte) :bat[:lng]
address CMDbatMULsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:lng],v:bte,s:bat[:oid]) :bat[:lng]
address CMDbatMULsignal
comment "Return B * V with candidates list, signal error on overflow";
pattern mul_noerror(b:bat[:lng],v:bte) :bat[:lng]
address CMDbatMUL
comment "Return B * V, overflow causes NIL value";
pattern mul_noerror(b:bat[:lng],v:bte,s:bat[:oid]) :bat[:lng]
address CMDbatMUL
comment "Return B * V with candidates list, overflow causes NIL value";
pattern *(v:lng,b:bat[:bte]) :bat[:lng]
address CMDbatMULsignal
comment "Return V * B, signal error on overflow";
pattern *(v:lng,b:bat[:bte],s:bat[:oid]) :bat[:lng]
address CMDbatMULsignal
comment "Return V * B with candidates list, signal error on overflow";
pattern mul_noerror(v:lng,b:bat[:bte]) :bat[:lng]
address CMDbatMUL
comment "Return V * B, overflow causes NIL value";
pattern mul_noerror(v:lng,b:bat[:bte],s:bat[:oid]) :bat[:lng]
address CMDbatMUL
comment "Return V * B with candidates list, overflow causes NIL value";

pattern *(b1:bat[:lng],b2:bat[:sht]) :bat[:lng]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
pattern *(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]) :bat[:lng]
address CMDbatMULsignal
comment "Return B1 * B2 with candidates list, signal error on overflow";
pattern mul_noerror(b1:bat[:lng],b2:bat[:sht]) :bat[:lng]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern mul_noerror(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]) :bat[:lng]
address CMDbatMUL
comment "Return B1 * B2 with candidates list, overflow causes NIL value";
pattern *(b:bat[:lng],v:sht) :bat[:lng]
address CMDbatMULsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:lng],v:sht,s:bat[:oid]) :bat[:lng]
address CMDbatMULsignal
comment "Return B * V with candidates list, signal error on overflow";
pattern mul_noerror(b:bat[:lng],v:sht) :bat[:lng]
address CMDbatMUL
comment "Return B * V, overflow causes NIL value";
pattern mul_noerror(b:bat[:lng],v:sht,s:bat[:oid]) :bat[:lng]
address CMDbatMUL
comment "Return B * V with candidates list, overflow causes NIL value";
pattern *(v:lng,b:bat[:sht]) :bat[:lng]
address CMDbatMULsignal
comment "Return V * B, signal error on overflow";
pattern *(v:lng,b:bat[:sht],s:bat[:oid]) :bat[:lng]
address CMDbatMULsignal
comment "Return V * B with candidates list, signal error on overflow";
pattern mul_noerror(v:lng,b:bat[:sht]) :bat[:lng]
address CMDbatMUL
comment "Return V * B, overflow causes NIL value";
pattern mul_noerror(v:lng,b:bat[:sht],s:bat[:oid]) :bat[:lng]
address CMDbatMUL
comment "Return V * B with candidates list, overflow causes NIL value";

pattern *(b1:bat[:lng],b2:bat[:int]) :bat[:lng]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
pattern *(b1:bat[:lng],b2:bat[:int],s:bat[:oid]) :bat[:lng]
address CMDbatMULsignal
comment "Return B1 * B2 with candidates list, signal error on overflow";
pattern mul_noerror(b1:bat[:lng],b2:bat[:int]) :bat[:lng]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern mul_noerror(b1:bat[:lng],b2:bat[:int],s:bat[:oid]) :bat[:lng]
address CMDbatMUL
comment "Return B1 * B2 with candidates list, overflow causes NIL value";
pattern *(b:bat[:lng],v:int) :bat[:lng]
address CMDbatMULsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:lng],v:int,s:bat[:oid]) :bat[:lng]
address CMDbatMULsignal
comment "Return B * V with candidates list, signal error on overflow";
pattern mul_noerror(b:bat[:lng],v:int) :bat[:lng]
address CMDbatMUL
comment "Return B * V, overflow causes NIL value";
pattern mul_noerror(b:bat[:lng],v:int,s:bat[:oid]) :bat[:lng]
address CMDbatMUL
comment "Return B * V with candidates list, overflow causes NIL value";
pattern *(v:lng,b:bat[:int]) :bat[:lng]
address CMDbatMULsignal
comment "Return V * B, signal error on overflow";
pattern *(v:lng,b:bat[:int],s:bat[:oid]) :bat[:lng]
address CMDbatMULsignal
comment "Return V * B with candidates list, signal error on overflow";
pattern mul_noerror(v:lng,b:bat[:int]) :bat[:lng]
address CMDbatMUL
comment "Return V * B, overflow causes NIL value";
pattern mul_noerror(v:lng,b:bat[:int],s:bat[:oid]) :bat[:lng]
address CMDbatMUL
comment "Return V * B with candidates list, overflow causes NIL value";

pattern *(b1:bat[:lng],b2:bat[:lng]) :bat[:lng]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
pattern *(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]) :bat[:lng]
address CMDbatMULsignal
comment "Return B1 * B2 with candidates list, signal error on overflow";
pattern mul_noerror(b1:bat[:lng],b2:bat[:lng]) :bat[:lng]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern mul_noerror(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]) :bat[:lng]
address CMDbatMUL
comment "Return B1 * B2 with candidates list, overflow causes NIL value";
pattern *(b:bat[:lng],v:lng) :bat[:lng]
address CMDbatMULsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:lng],v:lng,s:bat[:oid]) :bat[:lng]
address CMDbatMULsignal
comment "Return B * V with candidates list, signal error on overflow";
pattern mul_noerror(b:bat[:lng],v:lng) :bat[:lng]
address CMDbatMUL
comment "Return B * V, overflow causes NIL value";
pattern mul_noerror(b:bat[:lng],v:lng,s:bat[:oid]) :bat[:lng]
address CMDbatMUL
comment "Return B * V with candidates list, overflow causes NIL value";
pattern *(v:lng,b:bat[:lng]) :bat[:lng]
address CMDbatMULsignal
comment "Return V * B, signal error on overflow";
pattern *(v:lng,b:bat[:lng],s:bat[:oid]) :bat[:lng]
address CMDbatMULsignal
comment "Return V * B with candidates list, signal error on overflow";
pattern mul_noerror(v:lng,b:bat[:lng]) :bat[:lng]
address CMDbatMUL
comment "Return V * B, overflow causes NIL value";
pattern mul_noerror(v:lng,b:bat[:lng],s:bat[:oid]) :bat[:lng]
address CMDbatMUL
comment "Return V * B with candidates list, overflow causes NIL value";

pattern *(b1:bat[:lng],b2:bat[:flt]) :bat[:flt]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
pattern *(b1:bat[:lng],b2:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatMULsignal
comment "Return B1 * B2 with candidates list, signal error on overflow";
pattern mul_noerror(b1:bat[:lng],b2:bat[:flt]) :bat[:flt]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern mul_noerror(b1:bat[:lng],b2:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatMUL
comment "Return B1 * B2 with candidates list, overflow causes NIL value";
pattern *(b:bat[:lng],v:flt) :bat[:flt]
address CMDbatMULsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:lng],v:flt,s:bat[:oid]) :bat[:flt]
address CMDbatMULsignal
comment "Return B * V with candidates list, signal error on overflow";
pattern mul_noerror(b:bat[:lng],v:flt) :bat[:flt]
address CMDbatMUL
comment "Return B * V, overflow causes NIL value";
pattern mul_noerror(b:bat[:lng],v:flt,s:bat[:oid]) :bat[:flt]
address CMDbatMUL
comment "Return B * V with candidates list, overflow causes NIL value";
pattern *(v:lng,b:bat[:flt]) :bat[:flt]
address CMDbatMULsignal
comment "Return V * B, signal error on overflow";
pattern *(v:lng,b:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatMULsignal
comment "Return V * B with candidates list, signal error on overflow";
pattern mul_noerror(v:lng,b:bat[:flt]) :bat[:flt]
address CMDbatMUL
comment "Return V * B, overflow causes NIL value";
pattern mul_noerror(v:lng,b:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatMUL
comment "Return V * B with candidates list, overflow causes NIL value";

pattern *(b1:bat[:lng],b2:bat[:dbl]) :bat[:dbl]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
pattern *(b1:bat[:lng],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatMULsignal
comment "Return B1 * B2 with candidates list, signal error on overflow";
pattern mul_noerror(b1:bat[:lng],b2:bat[:dbl]) :bat[:dbl]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern mul_noerror(b1:bat[:lng],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatMUL
comment "Return B1 * B2 with candidates list, overflow causes NIL value";
pattern *(b:bat[:lng],v:dbl) :bat[:dbl]
address CMDbatMULsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:lng],v:dbl,s:bat[:oid]) :bat[:dbl]
address CMDbatMULsignal
comment "Return B * V with candidates list, signal error on overflow";
pattern mul_noerror(b:bat[:lng],v:dbl) :bat[:dbl]
address CMDbatMUL
comment "Return B * V, overflow causes NIL value";
pattern mul_noerror(b:bat[:lng],v:dbl,s:bat[:oid]) :bat[:dbl]
address CMDbatMUL
comment "Return B * V with candidates list, overflow causes NIL value";
pattern *(v:lng,b:bat[:dbl]) :bat[:dbl]
address CMDbatMULsignal
comment "Return V * B, signal error on overflow";
pattern *(v:lng,b:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatMULsignal
comment "Return V * B with candidates list, signal error on overflow";
pattern mul_noerror(v:lng,b:bat[:dbl]) :bat[:dbl]
address CMDbatMUL
comment "Return V * B, overflow causes NIL value";
pattern mul_noerror(v:lng,b:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatMUL
comment "Return V * B with candidates list, overflow causes NIL value";

pattern *(b1:bat[:flt],b2:bat[:bte]) :bat[:flt]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
pattern *(b1:bat[:flt],b2:bat[:bte],s:bat[:oid]) :bat[:flt]
address CMDbatMULsignal
comment "Return B1 * B2 with candidates list, signal error on overflow";
pattern mul_noerror(b1:bat[:flt],b2:bat[:bte]) :bat[:flt]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern mul_noerror(b1:bat[:flt],b2:bat[:bte],s:bat[:oid]) :bat[:flt]
address CMDbatMUL
comment "Return B1 * B2 with candidates list, overflow causes NIL value";
pattern *(b:bat[:flt],v:bte) :bat[:flt]
address CMDbatMULsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:flt],v:bte,s:bat[:oid]) :bat[:flt]
address CMDbatMULsignal
comment "Return B * V with candidates list, signal error on overflow";
pattern mul_noerror(b:bat[:flt],v:bte) :bat[:flt]
address CMDbatMUL
comment "Return B * V, overflow causes NIL value";
pattern mul_noerror(b:bat[:flt],v:bte,s:bat[:oid]) :bat[:flt]
address CMDbatMUL
comment "Return B * V with candidates list, overflow causes NIL value";
pattern *(v:flt,b:bat[:bte]) :bat[:flt]
address CMDbatMULsignal
comment "Return V * B, signal error on overflow";
pattern *(v:flt,b:bat[:bte],s:bat[:oid]) :bat[:flt]
address CMDbatMULsignal
comment "Return V * B with candidates list, signal error on overflow";
pattern mul_noerror(v:flt,b:bat[:bte]) :bat[:flt]
address CMDbatMUL
comment "Return V * B, overflow causes NIL value";
pattern mul_noerror(v:flt,b:bat[:bte],s:bat[:oid]) :bat[:flt]
address CMDbatMUL
comment "Return V * B with candidates list, overflow causes NIL value";

pattern *(b1:bat[:flt],b2:bat[:sht]) :bat[:flt]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
pattern *(b1:bat[:flt],b2:bat[:sht],s:bat[:oid]) :bat[:flt]
address CMDbatMULsignal
comment "Return B1 * B2 with candidates list, signal error on overflow";
pattern mul_noerror(b1:bat[:flt],b2:bat[:sht]) :bat[:flt]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern mul_noerror(b1:bat[:flt],b2:bat[:sht],s:bat[:oid]) :bat[:flt]
address CMDbatMUL
comment "Return B1 * B2 with candidates list, overflow causes NIL value";
pattern *(b:bat[:flt],v:sht) :bat[:flt]
address CMDbatMULsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:flt],v:sht,s:bat[:oid]) :bat[:flt]
address CMDbatMULsignal
comment "Return B * V with candidates list, signal error on overflow";
pattern mul_noerror(b:bat[:flt],v:sht) :bat[:flt]
address CMDbatMUL
comment "Return B * V, overflow causes NIL value";
pattern mul_noerror(b:bat[:flt],v:sht,s:bat[:oid]) :bat[:flt]
address CMDbatMUL
comment "Return B * V with candidates list, overflow causes NIL value";
pattern *(v:flt,b:bat[:sht]) :bat[:flt]
address CMDbatMULsignal
comment "Return V * B, signal error on overflow";
pattern *(v:flt,b:bat[:sht],s:bat[:oid]) :bat[:flt]
address CMDbatMULsignal
comment "Return V * B with candidates list, signal error on overflow";
pattern mul_noerror(v:flt,b:bat[:sht]) :bat[:flt]
address CMDbatMUL
comment "Return V * B, overflow causes NIL value";
pattern mul_noerror(v:flt,b:bat[:sht],s:bat[:oid]) :bat[:flt]
address CMDbatMUL
comment "Return V * B with candidates list, overflow causes NIL value";

pattern *(b1:bat[:flt],b2:bat[:int]) :bat[:flt]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
pattern *(b1:bat[:flt],b2:bat[:int],s:bat[:oid]) :bat[:flt]
address CMDbatMULsignal
comment "Return B1 * B2 with candidates list, signal error on overflow";
pattern mul_noerror(b1:bat[:flt],b2:bat[:int]) :bat[:flt]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern mul_noerror(b1:bat[:flt],b2:bat[:int],s:bat[:oid]) :bat[:flt]
address CMDbatMUL
comment "Return B1 * B2 with candidates list, overflow causes NIL value";
pattern *(b:bat[:flt],v:int) :bat[:flt]
address CMDbatMULsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:flt],v:int,s:bat[:oid]) :bat[:flt]
address CMDbatMULsignal
comment "Return B * V with candidates list, signal error on overflow";
pattern mul_noerror(b:bat[:flt],v:int) :bat[:flt]
address CMDbatMUL
comment "Return B * V, overflow causes NIL value";
pattern mul_noerror(b:bat[:flt],v:int,s:bat[:oid]) :bat[:flt]
address CMDbatMUL
comment "Return B * V with candidates list, overflow causes NIL value";
pattern *(v:flt,b:bat[:int]) :bat[:flt]
address CMDbatMULsignal
comment "Return V * B, signal error on overflow";
pattern *(v:flt,b:bat[:int],s:bat[:oid]) :bat[:flt]
address CMDbatMULsignal
comment "Return V * B with candidates list, signal error on overflow";
pattern mul_noerror(v:flt,b:bat[:int]) :bat[:flt]
address CMDbatMUL
comment "Return V * B, overflow causes NIL value";
pattern mul_noerror(v:flt,b:bat[:int],s:bat[:oid]) :bat[:flt]
address CMDbatMUL
comment "Return V * B with candidates list, overflow causes NIL value";

pattern *(b1:bat[:flt],b2:bat[:lng]) :bat[:flt]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
pattern *(b1:bat[:flt],b2:bat[:lng],s:bat[:oid]) :bat[:flt]
address CMDbatMULsignal
comment "Return B1 * B2 with candidates list, signal error on overflow";
pattern mul_noerror(b1:bat[:flt],b2:bat[:lng]) :bat[:flt]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern mul_noerror(b1:bat[:flt],b2:bat[:lng],s:bat[:oid]) :bat[:flt]
address CMDbatMUL
comment "Return B1 * B2 with candidates list, overflow causes NIL value";
pattern *(b:bat[:flt],v:lng) :bat[:flt]
address CMDbatMULsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:flt],v:lng,s:bat[:oid]) :bat[:flt]
address CMDbatMULsignal
comment "Return B * V with candidates list, signal error on overflow";
pattern mul_noerror(b:bat[:flt],v:lng) :bat[:flt]
address CMDbatMUL
comment "Return B * V, overflow causes NIL value";
pattern mul_noerror(b:bat[:flt],v:lng,s:bat[:oid]) :bat[:flt]
address CMDbatMUL
comment "Return B * V with candidates list, overflow causes NIL value";
pattern *(v:flt,b:bat[:lng]) :bat[:flt]
address CMDbatMULsignal
comment "Return V * B, signal error on overflow";
pattern *(v:flt,b:bat[:lng],s:bat[:oid]) :bat[:flt]
address CMDbatMULsignal
comment "Return V * B with candidates list, signal error on overflow";
pattern mul_noerror(v:flt,b:bat[:lng]) :bat[:flt]
address CMDbatMUL
comment "Return V * B, overflow causes NIL value";
pattern mul_noerror(v:flt,b:bat[:lng],s:bat[:oid]) :bat[:flt]
address CMDbatMUL
comment "Return V * B with candidates list, overflow causes NIL value";

pattern *(b1:bat[:flt],b2:bat[:flt]) :bat[:flt]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
pattern *(b1:bat[:flt],b2:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatMULsignal
comment "Return B1 * B2 with candidates list, signal error on overflow";
pattern mul_noerror(b1:bat[:flt],b2:bat[:flt]) :bat[:flt]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern mul_noerror(b1:bat[:flt],b2:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatMUL
comment "Return B1 * B2 with candidates list, overflow causes NIL value";
pattern *(b:bat[:flt],v:flt) :bat[:flt]
address CMDbatMULsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:flt],v:flt,s:bat[:oid]) :bat[:flt]
address CMDbatMULsignal
comment "Return B * V with candidates list, signal error on overflow";
pattern mul_noerror(b:bat[:flt],v:flt) :bat[:flt]
address CMDbatMUL
comment "Return B * V, overflow causes NIL value";
pattern mul_noerror(b:bat[:flt],v:flt,s:bat[:oid]) :bat[:flt]
address CMDbatMUL
comment "Return B * V with candidates list, overflow causes NIL value";
pattern *(v:flt,b:bat[:flt]) :bat[:flt]
address CMDbatMULsignal
comment "Return V * B, signal error on overflow";
pattern *(v:flt,b:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatMULsignal
comment "Return V * B with candidates list, signal error on overflow";
pattern mul_noerror(v:flt,b:bat[:flt]) :bat[:flt]
address CMDbatMUL
comment "Return V * B, overflow causes NIL value";
pattern mul_noerror(v:flt,b:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatMUL
comment "Return V * B with candidates list, overflow causes NIL value";

pattern *(b1:bat[:flt],b2:bat[:dbl]) :bat[:dbl]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
pattern *(b1:bat[:flt],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatMULsignal
comment "Return B1 * B2 with candidates list, signal error on overflow";
pattern mul_noerror(b1:bat[:flt],b2:bat[:dbl]) :bat[:dbl]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern mul_noerror(b1:bat[:flt],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatMUL
comment "Return B1 * B2 with candidates list, overflow causes NIL value";
pattern *(b:bat[:flt],v:dbl) :bat[:dbl]
address CMDbatMULsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:flt],v:dbl,s:bat[:oid]) :bat[:dbl]
address CMDbatMULsignal
comment "Return B * V with candidates list, signal error on overflow";
pattern mul_noerror(b:bat[:flt],v:dbl) :bat[:dbl]
address CMDbatMUL
comment "Return B * V, overflow causes NIL value";
pattern mul_noerror(b:bat[:flt],v:dbl,s:bat[:oid]) :bat[:dbl]
address CMDbatMUL
comment "Return B * V with candidates list, overflow causes NIL value";
pattern *(v:flt,b:bat[:dbl]) :bat[:dbl]
address CMDbatMULsignal
comment "Return V * B, signal error on overflow";
pattern *(v:flt,b:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatMULsignal
comment "Return V * B with candidates list, signal error on overflow";
pattern mul_noerror(v:flt,b:bat[:dbl]) :bat[:dbl]
address CMDbatMUL
comment "Return V * B, overflow causes NIL value";
pattern mul_noerror(v:flt,b:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatMUL
comment "Return V * B with candidates list, overflow causes NIL value";

pattern *(b1:bat[:dbl],b2:bat[:bte]) :bat[:dbl]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
pattern *(b1:bat[:dbl],b2:bat[:bte],s:bat[:oid]) :bat[:dbl]
address CMDbatMULsignal
comment "Return B1 * B2 with candidates list, signal error on overflow";
pattern mul_noerror(b1:bat[:dbl],b2:bat[:bte]) :bat[:dbl]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern mul_noerror(b1:bat[:dbl],b2:bat[:bte],s:bat[:oid]) :bat[:dbl]
address CMDbatMUL
comment "Return B1 * B2 with candidates list, overflow causes NIL value";
pattern *(b:bat[:dbl],v:bte) :bat[:dbl]
address CMDbatMULsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:dbl],v:bte,s:bat[:oid]) :bat[:dbl]
address CMDbatMULsignal
comment "Return B * V with candidates list, signal error on overflow";
pattern mul_noerror(b:bat[:dbl],v:bte) :bat[:dbl]
address CMDbatMUL
comment "Return B * V, overflow causes NIL value";
pattern mul_noerror(b:bat[:dbl],v:bte,s:bat[:oid]) :bat[:dbl]
address CMDbatMUL
comment "Return B * V with candidates list, overflow causes NIL value";
pattern *(v:dbl,b:bat[:bte]) :bat[:dbl]
address CMDbatMULsignal
comment "Return V * B, signal error on overflow";
pattern *(v:dbl,b:bat[:bte],s:bat[:oid]) :bat[:dbl]
address CMDbatMULsignal
comment "Return V * B with candidates list, signal error on overflow";
pattern mul_noerror(v:dbl,b:bat[:bte]) :bat[:dbl]
address CMDbatMUL
comment "Return V * B, overflow causes NIL value";
pattern mul_noerror(v:dbl,b:bat[:bte],s:bat[:oid]) :bat[:dbl]
address CMDbatMUL
comment "Return V * B with candidates list, overflow causes NIL value";

pattern *(b1:bat[:dbl],b2:bat[:sht]) :bat[:dbl]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
pattern *(b1:bat[:dbl],b2:bat[:sht],s:bat[:oid]) :bat[:dbl]
address CMDbatMULsignal
comment "Return B1 * B2 with candidates list, signal error on overflow";
pattern mul_noerror(b1:bat[:dbl],b2:bat[:sht]) :bat[:dbl]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern mul_noerror(b1:bat[:dbl],b2:bat[:sht],s:bat[:oid]) :bat[:dbl]
address CMDbatMUL
comment "Return B1 * B2 with candidates list, overflow causes NIL value";
pattern *(b:bat[:dbl],v:sht) :bat[:dbl]
address CMDbatMULsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:dbl],v:sht,s:bat[:oid]) :bat[:dbl]
address CMDbatMULsignal
comment "Return B * V with candidates list, signal error on overflow";
pattern mul_noerror(b:bat[:dbl],v:sht) :bat[:dbl]
address CMDbatMUL
comment "Return B * V, overflow causes NIL value";
pattern mul_noerror(b:bat[:dbl],v:sht,s:bat[:oid]) :bat[:dbl]
address CMDbatMUL
comment "Return B * V with candidates list, overflow causes NIL value";
pattern *(v:dbl,b:bat[:sht]) :bat[:dbl]
address CMDbatMULsignal
comment "Return V * B, signal error on overflow";
pattern *(v:dbl,b:bat[:sht],s:bat[:oid]) :bat[:dbl]
address CMDbatMULsignal
comment "Return V * B with candidates list, signal error on overflow";
pattern mul_noerror(v:dbl,b:bat[:sht]) :bat[:dbl]
address CMDbatMUL
comment "Return V * B, overflow causes NIL value";
pattern mul_noerror(v:dbl,b:bat[:sht],s:bat[:oid]) :bat[:dbl]
address CMDbatMUL
comment "Return V * B with candidates list, overflow causes NIL value";

pattern *(b1:bat[:dbl],b2:bat[:int]) :bat[:dbl]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
pattern *(b1:bat[:dbl],b2:bat[:int],s:bat[:oid]) :bat[:dbl]
address CMDbatMULsignal
comment "Return B1 * B2 with candidates list, signal error on overflow";
pattern mul_noerror(b1:bat[:dbl],b2:bat[:int]) :bat[:dbl]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern mul_noerror(b1:bat[:dbl],b2:bat[:int],s:bat[:oid]) :bat[:dbl]
address CMDbatMUL
comment "Return B1 * B2 with candidates list, overflow causes NIL value";
pattern *(b:bat[:dbl],v:int) :bat[:dbl]
address CMDbatMULsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:dbl],v:int,s:bat[:oid]) :bat[:dbl]
address CMDbatMULsignal
comment "Return B * V with candidates list, signal error on overflow";
pattern mul_noerror(b:bat[:dbl],v:int) :bat[:dbl]
address CMDbatMUL
comment "Return B * V, overflow causes NIL value";
pattern mul_noerror(b:bat[:dbl],v:int,s:bat[:oid]) :bat[:dbl]
address CMDbatMUL
comment "Return B * V with candidates list, overflow causes NIL value";
pattern *(v:dbl,b:bat[:int]) :bat[:dbl]
address CMDbatMULsignal
comment "Return V * B, signal error on overflow";
pattern *(v:dbl,b:bat[:int],s:bat[:oid]) :bat[:dbl]
address CMDbatMULsignal
comment "Return V * B with candidates list, signal error on overflow";
pattern mul_noerror(v:dbl,b:bat[:int]) :bat[:dbl]
address CMDbatMUL
comment "Return V * B, overflow causes NIL value";
pattern mul_noerror(v:dbl,b:bat[:int],s:bat[:oid]) :bat[:dbl]
address CMDbatMUL
comment "Return V * B with candidates list, overflow causes NIL value";

pattern *(b1:bat[:dbl],b2:bat[:lng]) :bat[:dbl]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
pattern *(b1:bat[:dbl],b2:bat[:lng],s:bat[:oid]) :bat[:dbl]
address CMDbatMULsignal
comment "Return B1 * B2 with candidates list, signal error on overflow";
pattern mul_noerror(b1:bat[:dbl],b2:bat[:lng]) :bat[:dbl]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern mul_noerror(b1:bat[:dbl],b2:bat[:lng],s:bat[:oid]) :bat[:dbl]
address CMDbatMUL
comment "Return B1 * B2 with candidates list, overflow causes NIL value";
pattern *(b:bat[:dbl],v:lng) :bat[:dbl]
address CMDbatMULsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:dbl],v:lng,s:bat[:oid]) :bat[:dbl]
address CMDbatMULsignal
comment "Return B * V with candidates list, signal error on overflow";
pattern mul_noerror(b:bat[:dbl],v:lng) :bat[:dbl]
address CMDbatMUL
comment "Return B * V, overflow causes NIL value";
pattern mul_noerror(b:bat[:dbl],v:lng,s:bat[:oid]) :bat[:dbl]
address CMDbatMUL
comment "Return B * V with candidates list, overflow causes NIL value";
pattern *(v:dbl,b:bat[:lng]) :bat[:dbl]
address CMDbatMULsignal
comment "Return V * B, signal error on overflow";
pattern *(v:dbl,b:bat[:lng],s:bat[:oid]) :bat[:dbl]
address CMDbatMULsignal
comment "Return V * B with candidates list, signal error on overflow";
pattern mul_noerror(v:dbl,b:bat[:lng]) :bat[:dbl]
address CMDbatMUL
comment "Return V * B, overflow causes NIL value";
pattern mul_noerror(v:dbl,b:bat[:lng],s:bat[:oid]) :bat[:dbl]
address CMDbatMUL
comment "Return V * B with candidates list, overflow causes NIL value";

pattern *(b1:bat[:dbl],b2:bat[:flt]) :bat[:dbl]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
pattern *(b1:bat[:dbl],b2:bat[:flt],s:bat[:oid]) :bat[:dbl]
address CMDbatMULsignal
comment "Return B1 * B2 with candidates list, signal error on overflow";
pattern mul_noerror(b1:bat[:dbl],b2:bat[:flt]) :bat[:dbl]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern mul_noerror(b1:bat[:dbl],b2:bat[:flt],s:bat[:oid]) :bat[:dbl]
address CMDbatMUL
comment "Return B1 * B2 with candidates list, overflow causes NIL value";
pattern *(b:bat[:dbl],v:flt) :bat[:dbl]
address CMDbatMULsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:dbl],v:flt,s:bat[:oid]) :bat[:dbl]
address CMDbatMULsignal
comment "Return B * V with candidates list, signal error on overflow";
pattern mul_noerror(b:bat[:dbl],v:flt) :bat[:dbl]
address CMDbatMUL
comment "Return B * V, overflow causes NIL value";
pattern mul_noerror(b:bat[:dbl],v:flt,s:bat[:oid]) :bat[:dbl]
address CMDbatMUL
comment "Return B * V with candidates list, overflow causes NIL value";
pattern *(v:dbl,b:bat[:flt]) :bat[:dbl]
address CMDbatMULsignal
comment "Return V * B, signal error on overflow";
pattern *(v:dbl,b:bat[:flt],s:bat[:oid]) :bat[:dbl]
address CMDbatMULsignal
comment "Return V * B with candidates list, signal error on overflow";
pattern mul_noerror(v:dbl,b:bat[:flt]) :bat[:dbl]
address CMDbatMUL
comment "Return V * B, overflow causes NIL value";
pattern mul_noerror(v:dbl,b:bat[:flt],s:bat[:oid]) :bat[:dbl]
address CMDbatMUL
comment "Return V * B with candidates list, overflow causes NIL value";

pattern *(b1:bat[:dbl],b2:bat[:dbl]) :bat[:dbl]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
pattern *(b1:bat[:dbl],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatMULsignal
comment "Return B1 * B2 with candidates list, signal error on overflow";
pattern mul_noerror(b1:bat[:dbl],b2:bat[:dbl]) :bat[:dbl]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern mul_noerror(b1:bat[:dbl],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatMUL
comment "Return B1 * B2 with candidates list, overflow causes NIL value";
pattern *(b:bat[:dbl],v:dbl) :bat[:dbl]
address CMDbatMULsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:dbl],v:dbl,s:bat[:oid]) :bat[:dbl]
address CMDbatMULsignal
comment "Return B * V with candidates list, signal error on overflow";
pattern mul_noerror(b:bat[:dbl],v:dbl) :bat[:dbl]
address CMDbatMUL
comment "Return B * V, overflow causes NIL value";
pattern mul_noerror(b:bat[:dbl],v:dbl,s:bat[:oid]) :bat[:dbl]
address CMDbatMUL
comment "Return B * V with candidates list, overflow causes NIL value";
pattern *(v:dbl,b:bat[:dbl]) :bat[:dbl]
address CMDbatMULsignal
comment "Return V * B, signal error on overflow";
pattern *(v:dbl,b:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatMULsignal
comment "Return V * B with candidates list, signal error on overflow";
pattern mul_noerror(v:dbl,b:bat[:dbl]) :bat[:dbl]
address CMDbatMUL
comment "Return V * B, overflow causes NIL value";
pattern mul_noerror(v:dbl,b:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatMUL
comment "Return V * B with candidates list, overflow causes NIL value";


pattern +(b1:bat[:str],b2:bat[:str]) :bat[:str]
address CMDbatADD
comment "Return concatenation of B1 and B2";
pattern +(b1:bat[:str],b2:bat[:str],s:bat[:oid]) :bat[:str]
address CMDbatADD
comment "Return concatenation of B1 and B2 with candidates list";
pattern +(b:bat[:str],v:str) :bat[:str]
address CMDbatADD
comment "Return concatenation of B and V";
pattern +(b:bat[:str],v:str,s:bat[:oid]) :bat[:str]
address CMDbatADD
comment "Return concatenation of B and V with candidates list";
pattern +(v:str,b:bat[:str]) :bat[:str]
address CMDbatADD
comment "Return concatenation of V and B";
pattern +(v:str,b:bat[:str],s:bat[:oid]) :bat[:str]
address CMDbatADD
comment "Return concatenation of V and B with candidates list";

pattern /(b1:bat[:bte],b2:bat[:bte]) :bat[:bte]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
pattern /(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]) :bat[:bte]
address CMDbatDIVsignal
comment "Return B1 / B2 with candidates list, signal error on overflow";
pattern div_noerror(b1:bat[:bte],b2:bat[:bte]) :bat[:bte]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern div_noerror(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]) :bat[:bte]
address CMDbatDIV
comment "Return B1 / B2 with candidates list, overflow causes NIL value";
pattern /(b:bat[:bte],v:bte) :bat[:bte]
address CMDbatDIVsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:bte],v:bte,s:bat[:oid]) :bat[:bte]
address CMDbatDIVsignal
comment "Return B / V with candidates list, signal error on overflow";
pattern div_noerror(b:bat[:bte],v:bte) :bat[:bte]
address CMDbatDIV
comment "Return B / V, overflow causes NIL value";
pattern div_noerror(b:bat[:bte],v:bte,s:bat[:oid]) :bat[:bte]
address CMDbatDIV
comment "Return B / V with candidates list, overflow causes NIL value";
pattern /(v:bte,b:bat[:bte]) :bat[:bte]
address CMDbatDIVsignal
comment "Return V / B, signal error on overflow";
pattern /(v:bte,b:bat[:bte],s:bat[:oid]) :bat[:bte]
address CMDbatDIVsignal
comment "Return V / B with candidates list, signal error on overflow";
pattern div_noerror(v:bte,b:bat[:bte]) :bat[:bte]
address CMDbatDIV
comment "Return V / B, overflow causes NIL value";
pattern div_noerror(v:bte,b:bat[:bte],s:bat[:oid]) :bat[:bte]
address CMDbatDIV
comment "Return V / B with candidates list, overflow causes NIL value";

pattern /(b1:bat[:bte],b2:bat[:sht]) :bat[:bte]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
pattern /(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]) :bat[:bte]
address CMDbatDIVsignal
comment "Return B1 / B2 with candidates list, signal error on overflow";
pattern div_noerror(b1:bat[:bte],b2:bat[:sht]) :bat[:bte]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern div_noerror(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]) :bat[:bte]
address CMDbatDIV
comment "Return B1 / B2 with candidates list, overflow causes NIL value";
pattern /(b:bat[:bte],v:sht) :bat[:bte]
address CMDbatDIVsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:bte],v:sht,s:bat[:oid]) :bat[:bte]
address CMDbatDIVsignal
comment "Return B / V with candidates list, signal error on overflow";
pattern div_noerror(b:bat[:bte],v:sht) :bat[:bte]
address CMDbatDIV
comment "Return B / V, overflow causes NIL value";
pattern div_noerror(b:bat[:bte],v:sht,s:bat[:oid]) :bat[:bte]
address CMDbatDIV
comment "Return B / V with candidates list, overflow causes NIL value";
pattern /(v:bte,b:bat[:sht]) :bat[:bte]
address CMDbatDIVsignal
comment "Return V / B, signal error on overflow";
pattern /(v:bte,b:bat[:sht],s:bat[:oid]) :bat[:bte]
address CMDbatDIVsignal
comment "Return V / B with candidates list, signal error on overflow";
pattern div_noerror(v:bte,b:bat[:sht]) :bat[:bte]
address CMDbatDIV
comment "Return V / B, overflow causes NIL value";
pattern div_noerror(v:bte,b:bat[:sht],s:bat[:oid]) :bat[:bte]
address CMDbatDIV
comment "Return V / B with candidates list, overflow causes NIL value";

pattern /(b1:bat[:bte],b2:bat[:int]) :bat[:bte]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
pattern /(b1:bat[:bte],b2:bat[:int],s:bat[:oid]) :bat[:bte]
address CMDbatDIVsignal
comment "Return B1 / B2 with candidates list, signal error on overflow";
pattern div_noerror(b1:bat[:bte],b2:bat[:int]) :bat[:bte]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern div_noerror(b1:bat[:bte],b2:bat[:int],s:bat[:oid]) :bat[:bte]
address CMDbatDIV
comment "Return B1 / B2 with candidates list, overflow causes NIL value";
pattern /(b:bat[:bte],v:int) :bat[:bte]
address CMDbatDIVsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:bte],v:int,s:bat[:oid]) :bat[:bte]
address CMDbatDIVsignal
comment "Return B / V with candidates list, signal error on overflow";
pattern div_noerror(b:bat[:bte],v:int) :bat[:bte]
address CMDbatDIV
comment "Return B / V, overflow causes NIL value";
pattern div_noerror(b:bat[:bte],v:int,s:bat[:oid]) :bat[:bte]
address CMDbatDIV
comment "Return B / V with candidates list, overflow causes NIL value";
pattern /(v:bte,b:bat[:int]) :bat[:bte]
address CMDbatDIVsignal
comment "Return V / B, signal error on overflow";
pattern /(v:bte,b:bat[:int],s:bat[:oid]) :bat[:bte]
address CMDbatDIVsignal
comment "Return V / B with candidates list, signal error on overflow";
pattern div_noerror(v:bte,b:bat[:int]) :bat[:bte]
address CMDbatDIV
comment "Return V / B, overflow causes NIL value";
pattern div_noerror(v:bte,b:bat[:int],s:bat[:oid]) :bat[:bte]
address CMDbatDIV
comment "Return V / B with candidates list, overflow causes NIL value";

pattern /(b1:bat[:bte],b2:bat[:lng]) :bat[:bte]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
pattern /(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]) :bat[:bte]
address CMDbatDIVsignal
comment "Return B1 / B2 with candidates list, signal error on overflow";
pattern div_noerror(b1:bat[:bte],b2:bat[:lng]) :bat[:bte]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern div_noerror(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]) :bat[:bte]
address CMDbatDIV
comment "Return B1 / B2 with candidates list, overflow causes NIL value";
pattern /(b:bat[:bte],v:lng) :bat[:bte]
address CMDbatDIVsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:bte],v:lng,s:bat[:oid]) :bat[:bte]
address CMDbatDIVsignal
comment "Return B / V with candidates list, signal error on overflow";
pattern div_noerror(b:bat[:bte],v:lng) :bat[:bte]
address CMDbatDIV
comment "Return B / V, overflow causes NIL value";
pattern div_noerror(b:bat[:bte],v:lng,s:bat[:oid]) :bat[:bte]
address CMDbatDIV
comment "Return B / V with candidates list, overflow causes NIL value";
pattern /(v:bte,b:bat[:lng]) :bat[:bte]
address CMDbatDIVsignal
comment "Return V / B, signal error on overflow";
pattern /(v:bte,b:bat[:lng],s:bat[:oid]) :bat[:bte]
address CMDbatDIVsignal
comment "Return V / B with candidates list, signal error on overflow";
pattern div_noerror(v:bte,b:bat[:lng]) :bat[:bte]
address CMDbatDIV
comment "Return V / B, overflow causes NIL value";
pattern div_noerror(v:bte,b:bat[:lng],s:bat[:oid]) :bat[:bte]
address CMDbatDIV
comment "Return V / B with candidates list, overflow causes NIL value";

pattern /(b1:bat[:bte],b2:bat[:flt]) :bat[:flt]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
pattern /(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatDIVsignal
comment "Return B1 / B2 with candidates list, signal error on overflow";
pattern div_noerror(b1:bat[:bte],b2:bat[:flt]) :bat[:flt]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern div_noerror(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatDIV
comment "Return B1 / B2 with candidates list, overflow causes NIL value";
pattern /(b:bat[:bte],v:flt) :bat[:flt]
address CMDbatDIVsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:bte],v:flt,s:bat[:oid]) :bat[:flt]
address CMDbatDIVsignal
comment "Return B / V with candidates list, signal error on overflow";
pattern div_noerror(b:bat[:bte],v:flt) :bat[:flt]
address CMDbatDIV
comment "Return B / V, overflow causes NIL value";
pattern div_noerror(b:bat[:bte],v:flt,s:bat[:oid]) :bat[:flt]
address CMDbatDIV
comment "Return B / V with candidates list, overflow causes NIL value";
pattern /(v:bte,b:bat[:flt]) :bat[:flt]
address CMDbatDIVsignal
comment "Return V / B, signal error on overflow";
pattern /(v:bte,b:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatDIVsignal
comment "Return V / B with candidates list, signal error on overflow";
pattern div_noerror(v:bte,b:bat[:flt]) :bat[:flt]
address CMDbatDIV
comment "Return V / B, overflow causes NIL value";
pattern div_noerror(v:bte,b:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatDIV
comment "Return V / B with candidates list, overflow causes NIL value";

pattern /(b1:bat[:bte],b2:bat[:dbl]) :bat[:dbl]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
pattern /(b1:bat[:bte],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatDIVsignal
comment "Return B1 / B2 with candidates list, signal error on overflow";
pattern div_noerror(b1:bat[:bte],b2:bat[:dbl]) :bat[:dbl]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern div_noerror(b1:bat[:bte],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatDIV
comment "Return B1 / B2 with candidates list, overflow causes NIL value";
pattern /(b:bat[:bte],v:dbl) :bat[:dbl]
address CMDbatDIVsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:bte],v:dbl,s:bat[:oid]) :bat[:dbl]
address CMDbatDIVsignal
comment "Return B / V with candidates list, signal error on overflow";
pattern div_noerror(b:bat[:bte],v:dbl) :bat[:dbl]
address CMDbatDIV
comment "Return B / V, overflow causes NIL value";
pattern div_noerror(b:bat[:bte],v:dbl,s:bat[:oid]) :bat[:dbl]
address CMDbatDIV
comment "Return B / V with candidates list, overflow causes NIL value";
pattern /(v:bte,b:bat[:dbl]) :bat[:dbl]
address CMDbatDIVsignal
comment "Return V / B, signal error on overflow";
pattern /(v:bte,b:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatDIVsignal
comment "Return V / B with candidates list, signal error on overflow";
pattern div_noerror(v:bte,b:bat[:dbl]) :bat[:dbl]
address CMDbatDIV
comment "Return V / B, overflow causes NIL value";
pattern div_noerror(v:bte,b:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatDIV
comment "Return V / B with candidates list, overflow causes NIL value";

pattern /(b1:bat[:sht],b2:bat[:bte]) :bat[:sht]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
pattern /(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]) :bat[:sht]
address CMDbatDIVsignal
comment "Return B1 / B2 with candidates list, signal error on overflow";
pattern div_noerror(b1:bat[:sht],b2:bat[:bte]) :bat[:sht]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern div_noerror(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]) :bat[:sht]
address CMDbatDIV
comment "Return B1 / B2 with candidates list, overflow causes NIL value";
pattern /(b:bat[:sht],v:bte) :bat[:sht]
address CMDbatDIVsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:sht],v:bte,s:bat[:oid]) :bat[:sht]
address CMDbatDIVsignal
comment "Return B / V with candidates list, signal error on overflow";
pattern div_noerror(b:bat[:sht],v:bte) :bat[:sht]
address CMDbatDIV
comment "Return B / V, overflow causes NIL value";
pattern div_noerror(b:bat[:sht],v:bte,s:bat[:oid]) :bat[:sht]
address CMDbatDIV
comment "Return B / V with candidates list, overflow causes NIL value";
pattern /(v:sht,b:bat[:bte]) :bat[:sht]
address CMDbatDIVsignal
comment "Return V / B, signal error on overflow";
pattern /(v:sht,b:bat[:bte],s:bat[:oid]) :bat[:sht]
address CMDbatDIVsignal
comment "Return V / B with candidates list, signal error on overflow";
pattern div_noerror(v:sht,b:bat[:bte]) :bat[:sht]
address CMDbatDIV
comment "Return V / B, overflow causes NIL value";
pattern div_noerror(v:sht,b:bat[:bte],s:bat[:oid]) :bat[:sht]
address CMDbatDIV
comment "Return V / B with candidates list, overflow causes NIL value";

pattern /(b1:bat[:sht],b2:bat[:sht]) :bat[:sht]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
pattern /(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]) :bat[:sht]
address CMDbatDIVsignal
comment "Return B1 / B2 with candidates list, signal error on overflow";
pattern div_noerror(b1:bat[:sht],b2:bat[:sht]) :bat[:sht]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern div_noerror(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]) :bat[:sht]
address CMDbatDIV
comment "Return B1 / B2 with candidates list, overflow causes NIL value";
pattern /(b:bat[:sht],v:sht) :bat[:sht]
address CMDbatDIVsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:sht],v:sht,s:bat[:oid]) :bat[:sht]
address CMDbatDIVsignal
comment "Return B / V with candidates list, signal error on overflow";
pattern div_noerror(b:bat[:sht],v:sht) :bat[:sht]
address CMDbatDIV
comment "Return B / V, overflow causes NIL value";
pattern div_noerror(b:bat[:sht],v:sht,s:bat[:oid]) :bat[:sht]
address CMDbatDIV
comment "Return B / V with candidates list, overflow causes NIL value";
pattern /(v:sht,b:bat[:sht]) :bat[:sht]
address CMDbatDIVsignal
comment "Return V / B, signal error on overflow";
pattern /(v:sht,b:bat[:sht],s:bat[:oid]) :bat[:sht]
address CMDbatDIVsignal
comment "Return V / B with candidates list, signal error on overflow";
pattern div_noerror(v:sht,b:bat[:sht]) :bat[:sht]
address CMDbatDIV
comment "Return V / B, overflow causes NIL value";
pattern div_noerror(v:sht,b:bat[:sht],s:bat[:oid]) :bat[:sht]
address CMDbatDIV
comment "Return V / B with candidates list, overflow causes NIL value";

pattern /(b1:bat[:sht],b2:bat[:int]) :bat[:sht]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
pattern /(b1:bat[:sht],b2:bat[:int],s:bat[:oid]) :bat[:sht]
address CMDbatDIVsignal
comment "Return B1 / B2 with candidates list, signal error on overflow";
pattern div_noerror(b1:bat[:sht],b2:bat[:int]) :bat[:sht]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern div_noerror(b1:bat[:sht],b2:bat[:int],s:bat[:oid]) :bat[:sht]
address CMDbatDIV
comment "Return B1 / B2 with candidates list, overflow causes NIL value";
pattern /(b:bat[:sht],v:int) :bat[:sht]
address CMDbatDIVsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:sht],v:int,s:bat[:oid]) :bat[:sht]
address CMDbatDIVsignal
comment "Return B / V with candidates list, signal error on overflow";
pattern div_noerror(b:bat[:sht],v:int) :bat[:sht]
address CMDbatDIV
comment "Return B / V, overflow causes NIL value";
pattern div_noerror(b:bat[:sht],v:int,s:bat[:oid]) :bat[:sht]
address CMDbatDIV
comment "Return B / V with candidates list, overflow causes NIL value";
pattern /(v:sht,b:bat[:int]) :bat[:sht]
address CMDbatDIVsignal
comment "Return V / B, signal error on overflow";
pattern /(v:sht,b:bat[:int],s:bat[:oid]) :bat[:sht]
address CMDbatDIVsignal
comment "Return V / B with candidates list, signal error on overflow";
pattern div_noerror(v:sht,b:bat[:int]) :bat[:sht]
address CMDbatDIV
comment "Return V / B, overflow causes NIL value";
pattern div_noerror(v:sht,b:bat[:int],s:bat[:oid]) :bat[:sht]
address CMDbatDIV
comment "Return V / B with candidates list, overflow causes NIL value";

pattern /(b1:bat[:sht],b2:bat[:lng]) :bat[:sht]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
pattern /(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]) :bat[:sht]
address CMDbatDIVsignal
comment "Return B1 / B2 with candidates list, signal error on overflow";
pattern div_noerror(b1:bat[:sht],b2:bat[:lng]) :bat[:sht]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern div_noerror(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]) :bat[:sht]
address CMDbatDIV
comment "Return B1 / B2 with candidates list, overflow causes NIL value";
pattern /(b:bat[:sht],v:lng) :bat[:sht]
address CMDbatDIVsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:sht],v:lng,s:bat[:oid]) :bat[:sht]
address CMDbatDIVsignal
comment "Return B / V with candidates list, signal error on overflow";
pattern div_noerror(b:bat[:sht],v:lng) :bat[:sht]
address CMDbatDIV
comment "Return B / V, overflow causes NIL value";
pattern div_noerror(b:bat[:sht],v:lng,s:bat[:oid]) :bat[:sht]
address CMDbatDIV
comment "Return B / V with candidates list, overflow causes NIL value";
pattern /(v:sht,b:bat[:lng]) :bat[:sht]
address CMDbatDIVsignal
comment "Return V / B, signal error on overflow";
pattern /(v:sht,b:bat[:lng],s:bat[:oid]) :bat[:sht]
address CMDbatDIVsignal
comment "Return V / B with candidates list, signal error on overflow";
pattern div_noerror(v:sht,b:bat[:lng]) :bat[:sht]
address CMDbatDIV
comment "Return V / B, overflow causes NIL value";
pattern div_noerror(v:sht,b:bat[:lng],s:bat[:oid]) :bat[:sht]
address CMDbatDIV
comment "Return V / B with candidates list, overflow causes NIL value";

pattern /(b1:bat[:sht],b2:bat[:flt]) :bat[:flt]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
pattern /(b1:bat[:sht],b2:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatDIVsignal
comment "Return B1 / B2 with candidates list, signal error on overflow";
pattern div_noerror(b1:bat[:sht],b2:bat[:flt]) :bat[:flt]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern div_noerror(b1:bat[:sht],b2:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatDIV
comment "Return B1 / B2 with candidates list, overflow causes NIL value";
pattern /(b:bat[:sht],v:flt) :bat[:flt]
address CMDbatDIVsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:sht],v:flt,s:bat[:oid]) :bat[:flt]
address CMDbatDIVsignal
comment "Return B / V with candidates list, signal error on overflow";
pattern div_noerror(b:bat[:sht],v:flt) :bat[:flt]
address CMDbatDIV
comment "Return B / V, overflow causes NIL value";
pattern div_noerror(b:bat[:sht],v:flt,s:bat[:oid]) :bat[:flt]
address CMDbatDIV
comment "Return B / V with candidates list, overflow causes NIL value";
pattern /(v:sht,b:bat[:flt]) :bat[:flt]
address CMDbatDIVsignal
comment "Return V / B, signal error on overflow";
pattern /(v:sht,b:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatDIVsignal
comment "Return V / B with candidates list, signal error on overflow";
pattern div_noerror(v:sht,b:bat[:flt]) :bat[:flt]
address CMDbatDIV
comment "Return V / B, overflow causes NIL value";
pattern div_noerror(v:sht,b:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatDIV
comment "Return V / B with candidates list, overflow causes NIL value";

pattern /(b1:bat[:sht],b2:bat[:dbl]) :bat[:dbl]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
pattern /(b1:bat[:sht],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatDIVsignal
comment "Return B1 / B2 with candidates list, signal error on overflow";
pattern div_noerror(b1:bat[:sht],b2:bat[:dbl]) :bat[:dbl]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern div_noerror(b1:bat[:sht],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatDIV
comment "Return B1 / B2 with candidates list, overflow causes NIL value";
pattern /(b:bat[:sht],v:dbl) :bat[:dbl]
address CMDbatDIVsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:sht],v:dbl,s:bat[:oid]) :bat[:dbl]
address CMDbatDIVsignal
comment "Return B / V with candidates list, signal error on overflow";
pattern div_noerror(b:bat[:sht],v:dbl) :bat[:dbl]
address CMDbatDIV
comment "Return B / V, overflow causes NIL value";
pattern div_noerror(b:bat[:sht],v:dbl,s:bat[:oid]) :bat[:dbl]
address CMDbatDIV
comment "Return B / V with candidates list, overflow causes NIL value";
pattern /(v:sht,b:bat[:dbl]) :bat[:dbl]
address CMDbatDIVsignal
comment "Return V / B, signal error on overflow";
pattern /(v:sht,b:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatDIVsignal
comment "Return V / B with candidates list, signal error on overflow";
pattern div_noerror(v:sht,b:bat[:dbl]) :bat[:dbl]
address CMDbatDIV
comment "Return V / B, overflow causes NIL value";
pattern div_noerror(v:sht,b:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatDIV
comment "Return V / B with candidates list, overflow causes NIL value";

pattern /(b1:bat[:int],b2:bat[:bte]) :bat[:int]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
pattern /(b1:bat[:int],b2:bat[:bte],s:bat[:oid]) :bat[:int]
address CMDbatDIVsignal
comment "Return B1 / B2 with candidates list, signal error on overflow";
pattern div_noerror(b1:bat[:int],b2:bat[:bte]) :bat[:int]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern div_noerror(b1:bat[:int],b2:bat[:bte],s:bat[:oid]) :bat[:int]
address CMDbatDIV
comment "Return B1 / B2 with candidates list, overflow causes NIL value";
pattern /(b:bat[:int],v:bte) :bat[:int]
address CMDbatDIVsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:int],v:bte,s:bat[:oid]) :bat[:int]
address CMDbatDIVsignal
comment "Return B / V with candidates list, signal error on overflow";
pattern div_noerror(b:bat[:int],v:bte) :bat[:int]
address CMDbatDIV
comment "Return B / V, overflow causes NIL value";
pattern div_noerror(b:bat[:int],v:bte,s:bat[:oid]) :bat[:int]
address CMDbatDIV
comment "Return B / V with candidates list, overflow causes NIL value";
pattern /(v:int,b:bat[:bte]) :bat[:int]
address CMDbatDIVsignal
comment "Return V / B, signal error on overflow";
pattern /(v:int,b:bat[:bte],s:bat[:oid]) :bat[:int]
address CMDbatDIVsignal
comment "Return V / B with candidates list, signal error on overflow";
pattern div_noerror(v:int,b:bat[:bte]) :bat[:int]
address CMDbatDIV
comment "Return V / B, overflow causes NIL value";
pattern div_noerror(v:int,b:bat[:bte],s:bat[:oid]) :bat[:int]
address CMDbatDIV
comment "Return V / B with candidates list, overflow causes NIL value";

pattern /(b1:bat[:int],b2:bat[:sht]) :bat[:int]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
pattern /(b1:bat[:int],b2:bat[:sht],s:bat[:oid]) :bat[:int]
address CMDbatDIVsignal
comment "Return B1 / B2 with candidates list, signal error on overflow";
pattern div_noerror(b1:bat[:int],b2:bat[:sht]) :bat[:int]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern div_noerror(b1:bat[:int],b2:bat[:sht],s:bat[:oid]) :bat[:int]
address CMDbatDIV
comment "Return B1 / B2 with candidates list, overflow causes NIL value";
pattern /(b:bat[:int],v:sht) :bat[:int]
address CMDbatDIVsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:int],v:sht,s:bat[:oid]) :bat[:int]
address CMDbatDIVsignal
comment "Return B / V with candidates list, signal error on overflow";
pattern div_noerror(b:bat[:int],v:sht) :bat[:int]
address CMDbatDIV
comment "Return B / V, overflow causes NIL value";
pattern div_noerror(b:bat[:int],v:sht,s:bat[:oid]) :bat[:int]
address CMDbatDIV
comment "Return B / V with candidates list, overflow causes NIL value";
pattern /(v:int,b:bat[:sht]) :bat[:int]
address CMDbatDIVsignal
comment "Return V / B, signal error on overflow";
pattern /(v:int,b:bat[:sht],s:bat[:oid]) :bat[:int]
address CMDbatDIVsignal
comment "Return V / B with candidates list, signal error on overflow";
pattern div_noerror(v:int,b:bat[:sht]) :bat[:int]
address CMDbatDIV
comment "Return V / B, overflow causes NIL value";
pattern div_noerror(v:int,b:bat[:sht],s:bat[:oid]) :bat[:int]
address CMDbatDIV
comment "Return V / B with candidates list, overflow causes NIL value";

pattern /(b1:bat[:int],b2:bat[:int]) :bat[:int]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
pattern /(b1:bat[:int],b2:bat[:int],s:bat[:oid]) :bat[:int]
address CMDbatDIVsignal
comment "Return B1 / B2 with candidates list, signal error on overflow";
pattern div_noerror(b1:bat[:int],b2:bat[:int]) :bat[:int]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern div_noerror(b1:bat[:int],b2:bat[:int],s:bat[:oid]) :bat[:int]
address CMDbatDIV
comment "Return B1 / B2 with candidates list, overflow causes NIL value";
pattern /(b:bat[:int],v:int) :bat[:int]
address CMDbatDIVsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:int],v:int,s:bat[:oid]) :bat[:int]
address CMDbatDIVsignal
comment "Return B / V with candidates list, signal error on overflow";
pattern div_noerror(b:bat[:int],v:int) :bat[:int]
address CMDbatDIV
comment "Return B / V, overflow causes NIL value";
pattern div_noerror(b:bat[:int],v:int,s:bat[:oid]) :bat[:int]
address CMDbatDIV
comment "Return B / V with candidates list, overflow causes NIL value";
pattern /(v:int,b:bat[:int]) :bat[:int]
address CMDbatDIVsignal
comment "Return V / B, signal error on overflow";
pattern /(v:int,b:bat[:int],s:bat[:oid]) :bat[:int]
address CMDbatDIVsignal
comment "Return V / B with candidates list, signal error on overflow";
pattern div_noerror(v:int,b:bat[:int]) :bat[:int]
address CMDbatDIV
comment "Return V / B, overflow causes NIL value";
pattern div_noerror(v:int,b:bat[:int],s:bat[:oid]) :bat[:int]
address CMDbatDIV
comment "Return V / B with candidates list, overflow causes NIL value";

pattern /(b1:bat[:int],b2:bat[:lng]) :bat[:int]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
pattern /(b1:bat[:int],b2:bat[:lng],s:bat[:oid]) :bat[:int]
address CMDbatDIVsignal
comment "Return B1 / B2 with candidates list, signal error on overflow";
pattern div_noerror(b1:bat[:int],b2:bat[:lng]) :bat[:int]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern div_noerror(b1:bat[:int],b2:bat[:lng],s:bat[:oid]) :bat[:int]
address CMDbatDIV
comment "Return B1 / B2 with candidates list, overflow causes NIL value";
pattern /(b:bat[:int],v:lng) :bat[:int]
address CMDbatDIVsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:int],v:lng,s:bat[:oid]) :bat[:int]
address CMDbatDIVsignal
comment "Return B / V with candidates list, signal error on overflow";
pattern div_noerror(b:bat[:int],v:lng) :bat[:int]
address CMDbatDIV
comment "Return B / V, overflow causes NIL value";
pattern div_noerror(b:bat[:int],v:lng,s:bat[:oid]) :bat[:int]
address CMDbatDIV
comment "Return B / V with candidates list, overflow causes NIL value";
pattern /(v:int,b:bat[:lng]) :bat[:int]
address CMDbatDIVsignal
comment "Return V / B, signal error on overflow";
pattern /(v:int,b:bat[:lng],s:bat[:oid]) :bat[:int]
address CMDbatDIVsignal
comment "Return V / B with candidates list, signal error on overflow";
pattern div_noerror(v:int,b:bat[:lng]) :bat[:int]
address CMDbatDIV
comment "Return V / B, overflow causes NIL value";
pattern div_noerror(v:int,b:bat[:lng],s:bat[:oid]) :bat[:int]
address CMDbatDIV
comment "Return V / B with candidates list, overflow causes NIL value";

pattern /(b1:bat[:int],b2:bat[:flt]) :bat[:flt]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
pattern /(b1:bat[:int],b2:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatDIVsignal
comment "Return B1 / B2 with candidates list, signal error on overflow";
pattern div_noerror(b1:bat[:int],b2:bat[:flt]) :bat[:flt]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern div_noerror(b1:bat[:int],b2:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatDIV
comment "Return B1 / B2 with candidates list, overflow causes NIL value";
pattern /(b:bat[:int],v:flt) :bat[:flt]
address CMDbatDIVsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:int],v:flt,s:bat[:oid]) :bat[:flt]
address CMDbatDIVsignal
comment "Return B / V with candidates list, signal error on overflow";
pattern div_noerror(b:bat[:int],v:flt) :bat[:flt]
address CMDbatDIV
comment "Return B / V, overflow causes NIL value";
pattern div_noerror(b:bat[:int],v:flt,s:bat[:oid]) :bat[:flt]
address CMDbatDIV
comment "Return B / V with candidates list, overflow causes NIL value";
pattern /(v:int,b:bat[:flt]) :bat[:flt]
address CMDbatDIVsignal
comment "Return V / B, signal error on overflow";
pattern /(v:int,b:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatDIVsignal
comment "Return V / B with candidates list, signal error on overflow";
pattern div_noerror(v:int,b:bat[:flt]) :bat[:flt]
address CMDbatDIV
comment "Return V / B, overflow causes NIL value";
pattern div_noerror(v:int,b:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatDIV
comment "Return V / B with candidates list, overflow causes NIL value";

pattern /(b1:bat[:int],b2:bat[:dbl]) :bat[:dbl]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
pattern /(b1:bat[:int],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatDIVsignal
comment "Return B1 / B2 with candidates list, signal error on overflow";
pattern div_noerror(b1:bat[:int],b2:bat[:dbl]) :bat[:dbl]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern div_noerror(b1:bat[:int],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatDIV
comment "Return B1 / B2 with candidates list, overflow causes NIL value";
pattern /(b:bat[:int],v:dbl) :bat[:dbl]
address CMDbatDIVsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:int],v:dbl,s:bat[:oid]) :bat[:dbl]
address CMDbatDIVsignal
comment "Return B / V with candidates list, signal error on overflow";
pattern div_noerror(b:bat[:int],v:dbl) :bat[:dbl]
address CMDbatDIV
comment "Return B / V, overflow causes NIL value";
pattern div_noerror(b:bat[:int],v:dbl,s:bat[:oid]) :bat[:dbl]
address CMDbatDIV
comment "Return B / V with candidates list, overflow causes NIL value";
pattern /(v:int,b:bat[:dbl]) :bat[:dbl]
address CMDbatDIVsignal
comment "Return V / B, signal error on overflow";
pattern /(v:int,b:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatDIVsignal
comment "Return V / B with candidates list, signal error on overflow";
pattern div_noerror(v:int,b:bat[:dbl]) :bat[:dbl]
address CMDbatDIV
comment "Return V / B, overflow causes NIL value";
pattern div_noerror(v:int,b:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatDIV
comment "Return V / B with candidates list, overflow causes NIL value";

pattern /(b1:bat[:lng],b2:bat[:bte]) :bat[:lng]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
pattern /(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]) :bat[:lng]
address CMDbatDIVsignal
comment "Return B1 / B2 with candidates list, signal error on overflow";
pattern div_noerror(b1:bat[:lng],b2:bat[:bte]) :bat[:lng]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern div_noerror(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]) :bat[:lng]
address CMDbatDIV
comment "Return B1 / B2 with candidates list, overflow causes NIL value";
pattern /(b:bat[:lng],v:bte) :bat[:lng]
address CMDbatDIVsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:lng],v:bte,s:bat[:oid]) :bat[:lng]
address CMDbatDIVsignal
comment "Return B / V with candidates list, signal error on overflow";
pattern div_noerror(b:bat[:lng],v:bte) :bat[:lng]
address CMDbatDIV
comment "Return B / V, overflow causes NIL value";
pattern div_noerror(b:bat[:lng],v:bte,s:bat[:oid]) :bat[:lng]
address CMDbatDIV
comment "Return B / V with candidates list, overflow causes NIL value";
pattern /(v:lng,b:bat[:bte]) :bat[:lng]
address CMDbatDIVsignal
comment "Return V / B, signal error on overflow";
pattern /(v:lng,b:bat[:bte],s:bat[:oid]) :bat[:lng]
address CMDbatDIVsignal
comment "Return V / B with candidates list, signal error on overflow";
pattern div_noerror(v:lng,b:bat[:bte]) :bat[:lng]
address CMDbatDIV
comment "Return V / B, overflow causes NIL value";
pattern div_noerror(v:lng,b:bat[:bte],s:bat[:oid]) :bat[:lng]
address CMDbatDIV
comment "Return V / B with candidates list, overflow causes NIL value";

pattern /(b1:bat[:lng],b2:bat[:sht]) :bat[:lng]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
pattern /(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]) :bat[:lng]
address CMDbatDIVsignal
comment "Return B1 / B2 with candidates list, signal error on overflow";
pattern div_noerror(b1:bat[:lng],b2:bat[:sht]) :bat[:lng]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern div_noerror(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]) :bat[:lng]
address CMDbatDIV
comment "Return B1 / B2 with candidates list, overflow causes NIL value";
pattern /(b:bat[:lng],v:sht) :bat[:lng]
address CMDbatDIVsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:lng],v:sht,s:bat[:oid]) :bat[:lng]
address CMDbatDIVsignal
comment "Return B / V with candidates list, signal error on overflow";
pattern div_noerror(b:bat[:lng],v:sht) :bat[:lng]
address CMDbatDIV
comment "Return B / V, overflow causes NIL value";
pattern div_noerror(b:bat[:lng],v:sht,s:bat[:oid]) :bat[:lng]
address CMDbatDIV
comment "Return B / V with candidates list, overflow causes NIL value";
pattern /(v:lng,b:bat[:sht]) :bat[:lng]
address CMDbatDIVsignal
comment "Return V / B, signal error on overflow";
pattern /(v:lng,b:bat[:sht],s:bat[:oid]) :bat[:lng]
address CMDbatDIVsignal
comment "Return V / B with candidates list, signal error on overflow";
pattern div_noerror(v:lng,b:bat[:sht]) :bat[:lng]
address CMDbatDIV
comment "Return V / B, overflow causes NIL value";
pattern div_noerror(v:lng,b:bat[:sht],s:bat[:oid]) :bat[:lng]
address CMDbatDIV
comment "Return V / B with candidates list, overflow causes NIL value";

pattern /(b1:bat[:lng],b2:bat[:int]) :bat[:lng]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
pattern /(b1:bat[:lng],b2:bat[:int],s:bat[:oid]) :bat[:lng]
address CMDbatDIVsignal
comment "Return B1 / B2 with candidates list, signal error on overflow";
pattern div_noerror(b1:bat[:lng],b2:bat[:int]) :bat[:lng]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern div_noerror(b1:bat[:lng],b2:bat[:int],s:bat[:oid]) :bat[:lng]
address CMDbatDIV
comment "Return B1 / B2 with candidates list, overflow causes NIL value";
pattern /(b:bat[:lng],v:int) :bat[:lng]
address CMDbatDIVsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:lng],v:int,s:bat[:oid]) :bat[:lng]
address CMDbatDIVsignal
comment "Return B / V with candidates list, signal error on overflow";
pattern div_noerror(b:bat[:lng],v:int) :bat[:lng]
address CMDbatDIV
comment "Return B / V, overflow causes NIL value";
pattern div_noerror(b:bat[:lng],v:int,s:bat[:oid]) :bat[:lng]
address CMDbatDIV
comment "Return B / V with candidates list, overflow causes NIL value";
pattern /(v:lng,b:bat[:int]) :bat[:lng]
address CMDbatDIVsignal
comment "Return V / B, signal error on overflow";
pattern /(v:lng,b:bat[:int],s:bat[:oid]) :bat[:lng]
address CMDbatDIVsignal
comment "Return V / B with candidates list, signal error on overflow";
pattern div_noerror(v:lng,b:bat[:int]) :bat[:lng]
address CMDbatDIV
comment "Return V / B, overflow causes NIL value";
pattern div_noerror(v:lng,b:bat[:int],s:bat[:oid]) :bat[:lng]
address CMDbatDIV
comment "Return V / B with candidates list, overflow causes NIL value";

pattern /(b1:bat[:lng],b2:bat[:lng]) :bat[:lng]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
pattern /(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]) :bat[:lng]
address CMDbatDIVsignal
comment "Return B1 / B2 with candidates list, signal error on overflow";
pattern div_noerror(b1:bat[:lng],b2:bat[:lng]) :bat[:lng]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern div_noerror(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]) :bat[:lng]
address CMDbatDIV
comment "Return B1 / B2 with candidates list, overflow causes NIL value";
pattern /(b:bat[:lng],v:lng) :bat[:lng]
address CMDbatDIVsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:lng],v:lng,s:bat[:oid]) :bat[:lng]
address CMDbatDIVsignal
comment "Return B / V with candidates list, signal error on overflow";
pattern div_noerror(b:bat[:lng],v:lng) :bat[:lng]
address CMDbatDIV
comment "Return B / V, overflow causes NIL value";
pattern div_noerror(b:bat[:lng],v:lng,s:bat[:oid]) :bat[:lng]
address CMDbatDIV
comment "Return B / V with candidates list, overflow causes NIL value";
pattern /(v:lng,b:bat[:lng]) :bat[:lng]
address CMDbatDIVsignal
comment "Return V / B, signal error on overflow";
pattern /(v:lng,b:bat[:lng],s:bat[:oid]) :bat[:lng]
address CMDbatDIVsignal
comment "Return V / B with candidates list, signal error on overflow";
pattern div_noerror(v:lng,b:bat[:lng]) :bat[:lng]
address CMDbatDIV
comment "Return V / B, overflow causes NIL value";
pattern div_noerror(v:lng,b:bat[:lng],s:bat[:oid]) :bat[:lng]
address CMDbatDIV
comment "Return V / B with candidates list, overflow causes NIL value";

pattern /(b1:bat[:lng],b2:bat[:flt]) :bat[:flt]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
pattern /(b1:bat[:lng],b2:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatDIVsignal
comment "Return B1 / B2 with candidates list, signal error on overflow";
pattern div_noerror(b1:bat[:lng],b2:bat[:flt]) :bat[:flt]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern div_noerror(b1:bat[:lng],b2:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatDIV
comment "Return B1 / B2 with candidates list, overflow causes NIL value";
pattern /(b:bat[:lng],v:flt) :bat[:flt]
address CMDbatDIVsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:lng],v:flt,s:bat[:oid]) :bat[:flt]
address CMDbatDIVsignal
comment "Return B / V with candidates list, signal error on overflow";
pattern div_noerror(b:bat[:lng],v:flt) :bat[:flt]
address CMDbatDIV
comment "Return B / V, overflow causes NIL value";
pattern div_noerror(b:bat[:lng],v:flt,s:bat[:oid]) :bat[:flt]
address CMDbatDIV
comment "Return B / V with candidates list, overflow causes NIL value";
pattern /(v:lng,b:bat[:flt]) :bat[:flt]
address CMDbatDIVsignal
comment "Return V / B, signal error on overflow";
pattern /(v:lng,b:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatDIVsignal
comment "Return V / B with candidates list, signal error on overflow";
pattern div_noerror(v:lng,b:bat[:flt]) :bat[:flt]
address CMDbatDIV
comment "Return V / B, overflow causes NIL value";
pattern div_noerror(v:lng,b:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatDIV
comment "Return V / B with candidates list, overflow causes NIL value";

pattern /(b1:bat[:lng],b2:bat[:dbl]) :bat[:dbl]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
pattern /(b1:bat[:lng],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatDIVsignal
comment "Return B1 / B2 with candidates list, signal error on overflow";
pattern div_noerror(b1:bat[:lng],b2:bat[:dbl]) :bat[:dbl]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern div_noerror(b1:bat[:lng],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatDIV
comment "Return B1 / B2 with candidates list, overflow causes NIL value";
pattern /(b:bat[:lng],v:dbl) :bat[:dbl]
address CMDbatDIVsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:lng],v:dbl,s:bat[:oid]) :bat[:dbl]
address CMDbatDIVsignal
comment "Return B / V with candidates list, signal error on overflow";
pattern div_noerror(b:bat[:lng],v:dbl) :bat[:dbl]
address CMDbatDIV
comment "Return B / V, overflow causes NIL value";
pattern div_noerror(b:bat[:lng],v:dbl,s:bat[:oid]) :bat[:dbl]
address CMDbatDIV
comment "Return B / V with candidates list, overflow causes NIL value";
pattern /(v:lng,b:bat[:dbl]) :bat[:dbl]
address CMDbatDIVsignal
comment "Return V / B, signal error on overflow";
pattern /(v:lng,b:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatDIVsignal
comment "Return V / B with candidates list, signal error on overflow";
pattern div_noerror(v:lng,b:bat[:dbl]) :bat[:dbl]
address CMDbatDIV
comment "Return V / B, overflow causes NIL value";
pattern div_noerror(v:lng,b:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatDIV
comment "Return V / B with candidates list, overflow causes NIL value";

pattern /(b1:bat[:flt],b2:bat[:bte]) :bat[:flt]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
pattern /(b1:bat[:flt],b2:bat[:bte],s:bat[:oid]) :bat[:flt]
address CMDbatDIVsignal
comment "Return B1 / B2 with candidates list, signal error on overflow";
pattern div_noerror(b1:bat[:flt],b2:bat[:bte]) :bat[:flt]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern div_noerror(b1:bat[:flt],b2:bat[:bte],s:bat[:oid]) :bat[:flt]
address CMDbatDIV
comment "Return B1 / B2 with candidates list, overflow causes NIL value";
pattern /(b:bat[:flt],v:bte) :bat[:flt]
address CMDbatDIVsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:flt],v:bte,s:bat[:oid]) :bat[:flt]
address CMDbatDIVsignal
comment "Return B / V with candidates list, signal error on overflow";
pattern div_noerror(b:bat[:flt],v:bte) :bat[:flt]
address CMDbatDIV
comment "Return B / V, overflow causes NIL value";
pattern div_noerror(b:bat[:flt],v:bte,s:bat[:oid]) :bat[:flt]
address CMDbatDIV
comment "Return B / V with candidates list, overflow causes NIL value";
pattern /(v:flt,b:bat[:bte]) :bat[:flt]
address CMDbatDIVsignal
comment "Return V / B, signal error on overflow";
pattern /(v:flt,b:bat[:bte],s:bat[:oid]) :bat[:flt]
address CMDbatDIVsignal
comment "Return V / B with candidates list, signal error on overflow";
pattern div_noerror(v:flt,b:bat[:bte]) :bat[:flt]
address CMDbatDIV
comment "Return V / B, overflow causes NIL value";
pattern div_noerror(v:flt,b:bat[:bte],s:bat[:oid]) :bat[:flt]
address CMDbatDIV
comment "Return V / B with candidates list, overflow causes NIL value";

pattern /(b1:bat[:flt],b2:bat[:sht]) :bat[:flt]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
pattern /(b1:bat[:flt],b2:bat[:sht],s:bat[:oid]) :bat[:flt]
address CMDbatDIVsignal
comment "Return B1 / B2 with candidates list, signal error on overflow";
pattern div_noerror(b1:bat[:flt],b2:bat[:sht]) :bat[:flt]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern div_noerror(b1:bat[:flt],b2:bat[:sht],s:bat[:oid]) :bat[:flt]
address CMDbatDIV
comment "Return B1 / B2 with candidates list, overflow causes NIL value";
pattern /(b:bat[:flt],v:sht) :bat[:flt]
address CMDbatDIVsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:flt],v:sht,s:bat[:oid]) :bat[:flt]
address CMDbatDIVsignal
comment "Return B / V with candidates list, signal error on overflow";
pattern div_noerror(b:bat[:flt],v:sht) :bat[:flt]
address CMDbatDIV
comment "Return B / V, overflow causes NIL value";
pattern div_noerror(b:bat[:flt],v:sht,s:bat[:oid]) :bat[:flt]
address CMDbatDIV
comment "Return B / V with candidates list, overflow causes NIL value";
pattern /(v:flt,b:bat[:sht]) :bat[:flt]
address CMDbatDIVsignal
comment "Return V / B, signal error on overflow";
pattern /(v:flt,b:bat[:sht],s:bat[:oid]) :bat[:flt]
address CMDbatDIVsignal
comment "Return V / B with candidates list, signal error on overflow";
pattern div_noerror(v:flt,b:bat[:sht]) :bat[:flt]
address CMDbatDIV
comment "Return V / B, overflow causes NIL value";
pattern div_noerror(v:flt,b:bat[:sht],s:bat[:oid]) :bat[:flt]
address CMDbatDIV
comment "Return V / B with candidates list, overflow causes NIL value";

pattern /(b1:bat[:flt],b2:bat[:int]) :bat[:flt]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
pattern /(b1:bat[:flt],b2:bat[:int],s:bat[:oid]) :bat[:flt]
address CMDbatDIVsignal
comment "Return B1 / B2 with candidates list, signal error on overflow";
pattern div_noerror(b1:bat[:flt],b2:bat[:int]) :bat[:flt]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern div_noerror(b1:bat[:flt],b2:bat[:int],s:bat[:oid]) :bat[:flt]
address CMDbatDIV
comment "Return B1 / B2 with candidates list, overflow causes NIL value";
pattern /(b:bat[:flt],v:int) :bat[:flt]
address CMDbatDIVsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:flt],v:int,s:bat[:oid]) :bat[:flt]
address CMDbatDIVsignal
comment "Return B / V with candidates list, signal error on overflow";
pattern div_noerror(b:bat[:flt],v:int) :bat[:flt]
address CMDbatDIV
comment "Return B / V, overflow causes NIL value";
pattern div_noerror(b:bat[:flt],v:int,s:bat[:oid]) :bat[:flt]
address CMDbatDIV
comment "Return B / V with candidates list, overflow causes NIL value";
pattern /(v:flt,b:bat[:int]) :bat[:flt]
address CMDbatDIVsignal
comment "Return V / B, signal error on overflow";
pattern /(v:flt,b:bat[:int],s:bat[:oid]) :bat[:flt]
address CMDbatDIVsignal
comment "Return V / B with candidates list, signal error on overflow";
pattern div_noerror(v:flt,b:bat[:int]) :bat[:flt]
address CMDbatDIV
comment "Return V / B, overflow causes NIL value";
pattern div_noerror(v:flt,b:bat[:int],s:bat[:oid]) :bat[:flt]
address CMDbatDIV
comment "Return V / B with candidates list, overflow causes NIL value";

pattern /(b1:bat[:flt],b2:bat[:lng]) :bat[:flt]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
pattern /(b1:bat[:flt],b2:bat[:lng],s:bat[:oid]) :bat[:flt]
address CMDbatDIVsignal
comment "Return B1 / B2 with candidates list, signal error on overflow";
pattern div_noerror(b1:bat[:flt],b2:bat[:lng]) :bat[:flt]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern div_noerror(b1:bat[:flt],b2:bat[:lng],s:bat[:oid]) :bat[:flt]
address CMDbatDIV
comment "Return B1 / B2 with candidates list, overflow causes NIL value";
pattern /(b:bat[:flt],v:lng) :bat[:flt]
address CMDbatDIVsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:flt],v:lng,s:bat[:oid]) :bat[:flt]
address CMDbatDIVsignal
comment "Return B / V with candidates list, signal error on overflow";
pattern div_noerror(b:bat[:flt],v:lng) :bat[:flt]
address CMDbatDIV
comment "Return B / V, overflow causes NIL value";
pattern div_noerror(b:bat[:flt],v:lng,s:bat[:oid]) :bat[:flt]
address CMDbatDIV
comment "Return B / V with candidates list, overflow causes NIL value";
pattern /(v:flt,b:bat[:lng]) :bat[:flt]
address CMDbatDIVsignal
comment "Return V / B, signal error on overflow";
pattern /(v:flt,b:bat[:lng],s:bat[:oid]) :bat[:flt]
address CMDbatDIVsignal
comment "Return V / B with candidates list, signal error on overflow";
pattern div_noerror(v:flt,b:bat[:lng]) :bat[:flt]
address CMDbatDIV
comment "Return V / B, overflow causes NIL value";
pattern div_noerror(v:flt,b:bat[:lng],s:bat[:oid]) :bat[:flt]
address CMDbatDIV
comment "Return V / B with candidates list, overflow causes NIL value";

pattern /(b1:bat[:flt],b2:bat[:flt]) :bat[:flt]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
pattern /(b1:bat[:flt],b2:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatDIVsignal
comment "Return B1 / B2 with candidates list, signal error on overflow";
pattern div_noerror(b1:bat[:flt],b2:bat[:flt]) :bat[:flt]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern div_noerror(b1:bat[:flt],b2:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatDIV
comment "Return B1 / B2 with candidates list, overflow causes NIL value";
pattern /(b:bat[:flt],v:flt) :bat[:flt]
address CMDbatDIVsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:flt],v:flt,s:bat[:oid]) :bat[:flt]
address CMDbatDIVsignal
comment "Return B / V with candidates list, signal error on overflow";
pattern div_noerror(b:bat[:flt],v:flt) :bat[:flt]
address CMDbatDIV
comment "Return B / V, overflow causes NIL value";
pattern div_noerror(b:bat[:flt],v:flt,s:bat[:oid]) :bat[:flt]
address CMDbatDIV
comment "Return B / V with candidates list, overflow causes NIL value";
pattern /(v:flt,b:bat[:flt]) :bat[:flt]
address CMDbatDIVsignal
comment "Return V / B, signal error on overflow";
pattern /(v:flt,b:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatDIVsignal
comment "Return V / B with candidates list, signal error on overflow";
pattern div_noerror(v:flt,b:bat[:flt]) :bat[:flt]
address CMDbatDIV
comment "Return V / B, overflow causes NIL value";
pattern div_noerror(v:flt,b:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatDIV
comment "Return V / B with candidates list, overflow causes NIL value";

pattern /(b1:bat[:flt],b2:bat[:dbl]) :bat[:dbl]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
pattern /(b1:bat[:flt],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatDIVsignal
comment "Return B1 / B2 with candidates list, signal error on overflow";
pattern div_noerror(b1:bat[:flt],b2:bat[:dbl]) :bat[:dbl]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern div_noerror(b1:bat[:flt],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatDIV
comment "Return B1 / B2 with candidates list, overflow causes NIL value";
pattern /(b:bat[:flt],v:dbl) :bat[:dbl]
address CMDbatDIVsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:flt],v:dbl,s:bat[:oid]) :bat[:dbl]
address CMDbatDIVsignal
comment "Return B / V with candidates list, signal error on overflow";
pattern div_noerror(b:bat[:flt],v:dbl) :bat[:dbl]
address CMDbatDIV
comment "Return B / V, overflow causes NIL value";
pattern div_noerror(b:bat[:flt],v:dbl,s:bat[:oid]) :bat[:dbl]
address CMDbatDIV
comment "Return B / V with candidates list, overflow causes NIL value";
pattern /(v:flt,b:bat[:dbl]) :bat[:dbl]
address CMDbatDIVsignal
comment "Return V / B, signal error on overflow";
pattern /(v:flt,b:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatDIVsignal
comment "Return V / B with candidates list, signal error on overflow";
pattern div_noerror(v:flt,b:bat[:dbl]) :bat[:dbl]
address CMDbatDIV
comment "Return V / B, overflow causes NIL value";
pattern div_noerror(v:flt,b:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatDIV
comment "Return V / B with candidates list, overflow causes NIL value";

pattern /(b1:bat[:dbl],b2:bat[:bte]) :bat[:dbl]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
pattern /(b1:bat[:dbl],b2:bat[:bte],s:bat[:oid]) :bat[:dbl]
address CMDbatDIVsignal
comment "Return B1 / B2 with candidates list, signal error on overflow";
pattern div_noerror(b1:bat[:dbl],b2:bat[:bte]) :bat[:dbl]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern div_noerror(b1:bat[:dbl],b2:bat[:bte],s:bat[:oid]) :bat[:dbl]
address CMDbatDIV
comment "Return B1 / B2 with candidates list, overflow causes NIL value";
pattern /(b:bat[:dbl],v:bte) :bat[:dbl]
address CMDbatDIVsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:dbl],v:bte,s:bat[:oid]) :bat[:dbl]
address CMDbatDIVsignal
comment "Return B / V with candidates list, signal error on overflow";
pattern div_noerror(b:bat[:dbl],v:bte) :bat[:dbl]
address CMDbatDIV
comment "Return B / V, overflow causes NIL value";
pattern div_noerror(b:bat[:dbl],v:bte,s:bat[:oid]) :bat[:dbl]
address CMDbatDIV
comment "Return B / V with candidates list, overflow causes NIL value";
pattern /(v:dbl,b:bat[:bte]) :bat[:dbl]
address CMDbatDIVsignal
comment "Return V / B, signal error on overflow";
pattern /(v:dbl,b:bat[:bte],s:bat[:oid]) :bat[:dbl]
address CMDbatDIVsignal
comment "Return V / B with candidates list, signal error on overflow";
pattern div_noerror(v:dbl,b:bat[:bte]) :bat[:dbl]
address CMDbatDIV
comment "Return V / B, overflow causes NIL value";
pattern div_noerror(v:dbl,b:bat[:bte],s:bat[:oid]) :bat[:dbl]
address CMDbatDIV
comment "Return V / B with candidates list, overflow causes NIL value";

pattern /(b1:bat[:dbl],b2:bat[:sht]) :bat[:dbl]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
pattern /(b1:bat[:dbl],b2:bat[:sht],s:bat[:oid]) :bat[:dbl]
address CMDbatDIVsignal
comment "Return B1 / B2 with candidates list, signal error on overflow";
pattern div_noerror(b1:bat[:dbl],b2:bat[:sht]) :bat[:dbl]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern div_noerror(b1:bat[:dbl],b2:bat[:sht],s:bat[:oid]) :bat[:dbl]
address CMDbatDIV
comment "Return B1 / B2 with candidates list, overflow causes NIL value";
pattern /(b:bat[:dbl],v:sht) :bat[:dbl]
address CMDbatDIVsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:dbl],v:sht,s:bat[:oid]) :bat[:dbl]
address CMDbatDIVsignal
comment "Return B / V with candidates list, signal error on overflow";
pattern div_noerror(b:bat[:dbl],v:sht) :bat[:dbl]
address CMDbatDIV
comment "Return B / V, overflow causes NIL value";
pattern div_noerror(b:bat[:dbl],v:sht,s:bat[:oid]) :bat[:dbl]
address CMDbatDIV
comment "Return B / V with candidates list, overflow causes NIL value";
pattern /(v:dbl,b:bat[:sht]) :bat[:dbl]
address CMDbatDIVsignal
comment "Return V / B, signal error on overflow";
pattern /(v:dbl,b:bat[:sht],s:bat[:oid]) :bat[:dbl]
address CMDbatDIVsignal
comment "Return V / B with candidates list, signal error on overflow";
pattern div_noerror(v:dbl,b:bat[:sht]) :bat[:dbl]
address CMDbatDIV
comment "Return V / B, overflow causes NIL value";
pattern div_noerror(v:dbl,b:bat[:sht],s:bat[:oid]) :bat[:dbl]
address CMDbatDIV
comment "Return V / B with candidates list, overflow causes NIL value";

pattern /(b1:bat[:dbl],b2:bat[:int]) :bat[:dbl]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
pattern /(b1:bat[:dbl],b2:bat[:int],s:bat[:oid]) :bat[:dbl]
address CMDbatDIVsignal
comment "Return B1 / B2 with candidates list, signal error on overflow";
pattern div_noerror(b1:bat[:dbl],b2:bat[:int]) :bat[:dbl]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern div_noerror(b1:bat[:dbl],b2:bat[:int],s:bat[:oid]) :bat[:dbl]
address CMDbatDIV
comment "Return B1 / B2 with candidates list, overflow causes NIL value";
pattern /(b:bat[:dbl],v:int) :bat[:dbl]
address CMDbatDIVsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:dbl],v:int,s:bat[:oid]) :bat[:dbl]
address CMDbatDIVsignal
comment "Return B / V with candidates list, signal error on overflow";
pattern div_noerror(b:bat[:dbl],v:int) :bat[:dbl]
address CMDbatDIV
comment "Return B / V, overflow causes NIL value";
pattern div_noerror(b:bat[:dbl],v:int,s:bat[:oid]) :bat[:dbl]
address CMDbatDIV
comment "Return B / V with candidates list, overflow causes NIL value";
pattern /(v:dbl,b:bat[:int]) :bat[:dbl]
address CMDbatDIVsignal
comment "Return V / B, signal error on overflow";
pattern /(v:dbl,b:bat[:int],s:bat[:oid]) :bat[:dbl]
address CMDbatDIVsignal
comment "Return V / B with candidates list, signal error on overflow";
pattern div_noerror(v:dbl,b:bat[:int]) :bat[:dbl]
address CMDbatDIV
comment "Return V / B, overflow causes NIL value";
pattern div_noerror(v:dbl,b:bat[:int],s:bat[:oid]) :bat[:dbl]
address CMDbatDIV
comment "Return V / B with candidates list, overflow causes NIL value";

pattern /(b1:bat[:dbl],b2:bat[:lng]) :bat[:dbl]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
pattern /(b1:bat[:dbl],b2:bat[:lng],s:bat[:oid]) :bat[:dbl]
address CMDbatDIVsignal
comment "Return B1 / B2 with candidates list, signal error on overflow";
pattern div_noerror(b1:bat[:dbl],b2:bat[:lng]) :bat[:dbl]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern div_noerror(b1:bat[:dbl],b2:bat[:lng],s:bat[:oid]) :bat[:dbl]
address CMDbatDIV
comment "Return B1 / B2 with candidates list, overflow causes NIL value";
pattern /(b:bat[:dbl],v:lng) :bat[:dbl]
address CMDbatDIVsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:dbl],v:lng,s:bat[:oid]) :bat[:dbl]
address CMDbatDIVsignal
comment "Return B / V with candidates list, signal error on overflow";
pattern div_noerror(b:bat[:dbl],v:lng) :bat[:dbl]
address CMDbatDIV
comment "Return B / V, overflow causes NIL value";
pattern div_noerror(b:bat[:dbl],v:lng,s:bat[:oid]) :bat[:dbl]
address CMDbatDIV
comment "Return B / V with candidates list, overflow causes NIL value";
pattern /(v:dbl,b:bat[:lng]) :bat[:dbl]
address CMDbatDIVsignal
comment "Return V / B, signal error on overflow";
pattern /(v:dbl,b:bat[:lng],s:bat[:oid]) :bat[:dbl]
address CMDbatDIVsignal
comment "Return V / B with candidates list, signal error on overflow";
pattern div_noerror(v:dbl,b:bat[:lng]) :bat[:dbl]
address CMDbatDIV
comment "Return V / B, overflow causes NIL value";
pattern div_noerror(v:dbl,b:bat[:lng],s:bat[:oid]) :bat[:dbl]
address CMDbatDIV
comment "Return V / B with candidates list, overflow causes NIL value";

pattern /(b1:bat[:dbl],b2:bat[:flt]) :bat[:dbl]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
pattern /(b1:bat[:dbl],b2:bat[:flt],s:bat[:oid]) :bat[:dbl]
address CMDbatDIVsignal
comment "Return B1 / B2 with candidates list, signal error on overflow";
pattern div_noerror(b1:bat[:dbl],b2:bat[:flt]) :bat[:dbl]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern div_noerror(b1:bat[:dbl],b2:bat[:flt],s:bat[:oid]) :bat[:dbl]
address CMDbatDIV
comment "Return B1 / B2 with candidates list, overflow causes NIL value";
pattern /(b:bat[:dbl],v:flt) :bat[:dbl]
address CMDbatDIVsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:dbl],v:flt,s:bat[:oid]) :bat[:dbl]
address CMDbatDIVsignal
comment "Return B / V with candidates list, signal error on overflow";
pattern div_noerror(b:bat[:dbl],v:flt) :bat[:dbl]
address CMDbatDIV
comment "Return B / V, overflow causes NIL value";
pattern div_noerror(b:bat[:dbl],v:flt,s:bat[:oid]) :bat[:dbl]
address CMDbatDIV
comment "Return B / V with candidates list, overflow causes NIL value";
pattern /(v:dbl,b:bat[:flt]) :bat[:dbl]
address CMDbatDIVsignal
comment "Return V / B, signal error on overflow";
pattern /(v:dbl,b:bat[:flt],s:bat[:oid]) :bat[:dbl]
address CMDbatDIVsignal
comment "Return V / B with candidates list, signal error on overflow";
pattern div_noerror(v:dbl,b:bat[:flt]) :bat[:dbl]
address CMDbatDIV
comment "Return V / B, overflow causes NIL value";
pattern div_noerror(v:dbl,b:bat[:flt],s:bat[:oid]) :bat[:dbl]
address CMDbatDIV
comment "Return V / B with candidates list, overflow causes NIL value";

pattern /(b1:bat[:dbl],b2:bat[:dbl]) :bat[:dbl]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
pattern /(b1:bat[:dbl],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatDIVsignal
comment "Return B1 / B2 with candidates list, signal error on overflow";
pattern div_noerror(b1:bat[:dbl],b2:bat[:dbl]) :bat[:dbl]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern div_noerror(b1:bat[:dbl],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatDIV
comment "Return B1 / B2 with candidates list, overflow causes NIL value";
pattern /(b:bat[:dbl],v:dbl) :bat[:dbl]
address CMDbatDIVsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:dbl],v:dbl,s:bat[:oid]) :bat[:dbl]
address CMDbatDIVsignal
comment "Return B / V with candidates list, signal error on overflow";
pattern div_noerror(b:bat[:dbl],v:dbl) :bat[:dbl]
address CMDbatDIV
comment "Return B / V, overflow causes NIL value";
pattern div_noerror(b:bat[:dbl],v:dbl,s:bat[:oid]) :bat[:dbl]
address CMDbatDIV
comment "Return B / V with candidates list, overflow causes NIL value";
pattern /(v:dbl,b:bat[:dbl]) :bat[:dbl]
address CMDbatDIVsignal
comment "Return V / B, signal error on overflow";
pattern /(v:dbl,b:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatDIVsignal
comment "Return V / B with candidates list, signal error on overflow";
pattern div_noerror(v:dbl,b:bat[:dbl]) :bat[:dbl]
address CMDbatDIV
comment "Return V / B, overflow causes NIL value";
pattern div_noerror(v:dbl,b:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatDIV
comment "Return V / B with candidates list, overflow causes NIL value";


pattern %(b1:bat[:bte],b2:bat[:bte]) :bat[:bte]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
pattern %(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]) :bat[:bte]
address CMDbatMODsignal
comment "Return B1 % B2 with candidates list, signal error on divide by zero";
pattern mod_noerror(b1:bat[:bte],b2:bat[:bte]) :bat[:bte]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern mod_noerror(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]) :bat[:bte]
address CMDbatMOD
comment "Return B1 % B2 with candidates list, divide by zero causes NIL value";
pattern %(b:bat[:bte],v:bte) :bat[:bte]
address CMDbatMODsignal
comment "Return B % V, signal error on divide by zero";
pattern %(b:bat[:bte],v:bte,s:bat[:oid]) :bat[:bte]
address CMDbatMODsignal
comment "Return B % V with candidates list, signal error on divide by zero";
pattern mod_noerror(b:bat[:bte],v:bte) :bat[:bte]
address CMDbatMOD
comment "Return B % V, divide by zero causes NIL value";
pattern mod_noerror(b:bat[:bte],v:bte,s:bat[:oid]) :bat[:bte]
address CMDbatMOD
comment "Return B % V with candidates list, divide by zero causes NIL value";
pattern %(v:bte,b:bat[:bte]) :bat[:bte]
address CMDbatMODsignal
comment "Return V % B, signal error on divide by zero";
pattern %(v:bte,b:bat[:bte],s:bat[:oid]) :bat[:bte]
address CMDbatMODsignal
comment "Return V % B with candidates list, signal error on divide by zero";
pattern mod_noerror(v:bte,b:bat[:bte]) :bat[:bte]
address CMDbatMOD
comment "Return V % B, divide by zero causes NIL value";
pattern mod_noerror(v:bte,b:bat[:bte],s:bat[:oid]) :bat[:bte]
address CMDbatMOD
comment "Return V % B with candidates list, divide by zero causes NIL value";

pattern %(b1:bat[:bte],b2:bat[:sht]) :bat[:bte]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
pattern %(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]) :bat[:bte]
address CMDbatMODsignal
comment "Return B1 % B2 with candidates list, signal error on divide by zero";
pattern mod_noerror(b1:bat[:bte],b2:bat[:sht]) :bat[:bte]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern mod_noerror(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]) :bat[:bte]
address CMDbatMOD
comment "Return B1 % B2 with candidates list, divide by zero causes NIL value";
pattern %(b:bat[:bte],v:sht) :bat[:bte]
address CMDbatMODsignal
comment "Return B % V, signal error on divide by zero";
pattern %(b:bat[:bte],v:sht,s:bat[:oid]) :bat[:bte]
address CMDbatMODsignal
comment "Return B % V with candidates list, signal error on divide by zero";
pattern mod_noerror(b:bat[:bte],v:sht) :bat[:bte]
address CMDbatMOD
comment "Return B % V, divide by zero causes NIL value";
pattern mod_noerror(b:bat[:bte],v:sht,s:bat[:oid]) :bat[:bte]
address CMDbatMOD
comment "Return B % V with candidates list, divide by zero causes NIL value";
pattern %(v:bte,b:bat[:sht]) :bat[:bte]
address CMDbatMODsignal
comment "Return V % B, signal error on divide by zero";
pattern %(v:bte,b:bat[:sht],s:bat[:oid]) :bat[:bte]
address CMDbatMODsignal
comment "Return V % B with candidates list, signal error on divide by zero";
pattern mod_noerror(v:bte,b:bat[:sht]) :bat[:bte]
address CMDbatMOD
comment "Return V % B, divide by zero causes NIL value";
pattern mod_noerror(v:bte,b:bat[:sht],s:bat[:oid]) :bat[:bte]
address CMDbatMOD
comment "Return V % B with candidates list, divide by zero causes NIL value";

pattern %(b1:bat[:bte],b2:bat[:int]) :bat[:bte]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
pattern %(b1:bat[:bte],b2:bat[:int],s:bat[:oid]) :bat[:bte]
address CMDbatMODsignal
comment "Return B1 % B2 with candidates list, signal error on divide by zero";
pattern mod_noerror(b1:bat[:bte],b2:bat[:int]) :bat[:bte]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern mod_noerror(b1:bat[:bte],b2:bat[:int],s:bat[:oid]) :bat[:bte]
address CMDbatMOD
comment "Return B1 % B2 with candidates list, divide by zero causes NIL value";
pattern %(b:bat[:bte],v:int) :bat[:bte]
address CMDbatMODsignal
comment "Return B % V, signal error on divide by zero";
pattern %(b:bat[:bte],v:int,s:bat[:oid]) :bat[:bte]
address CMDbatMODsignal
comment "Return B % V with candidates list, signal error on divide by zero";
pattern mod_noerror(b:bat[:bte],v:int) :bat[:bte]
address CMDbatMOD
comment "Return B % V, divide by zero causes NIL value";
pattern mod_noerror(b:bat[:bte],v:int,s:bat[:oid]) :bat[:bte]
address CMDbatMOD
comment "Return B % V with candidates list, divide by zero causes NIL value";
pattern %(v:bte,b:bat[:int]) :bat[:bte]
address CMDbatMODsignal
comment "Return V % B, signal error on divide by zero";
pattern %(v:bte,b:bat[:int],s:bat[:oid]) :bat[:bte]
address CMDbatMODsignal
comment "Return V % B with candidates list, signal error on divide by zero";
pattern mod_noerror(v:bte,b:bat[:int]) :bat[:bte]
address CMDbatMOD
comment "Return V % B, divide by zero causes NIL value";
pattern mod_noerror(v:bte,b:bat[:int],s:bat[:oid]) :bat[:bte]
address CMDbatMOD
comment "Return V % B with candidates list, divide by zero causes NIL value";

pattern %(b1:bat[:bte],b2:bat[:lng]) :bat[:bte]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
pattern %(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]) :bat[:bte]
address CMDbatMODsignal
comment "Return B1 % B2 with candidates list, signal error on divide by zero";
pattern mod_noerror(b1:bat[:bte],b2:bat[:lng]) :bat[:bte]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern mod_noerror(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]) :bat[:bte]
address CMDbatMOD
comment "Return B1 % B2 with candidates list, divide by zero causes NIL value";
pattern %(b:bat[:bte],v:lng) :bat[:bte]
address CMDbatMODsignal
comment "Return B % V, signal error on divide by zero";
pattern %(b:bat[:bte],v:lng,s:bat[:oid]) :bat[:bte]
address CMDbatMODsignal
comment "Return B % V with candidates list, signal error on divide by zero";
pattern mod_noerror(b:bat[:bte],v:lng) :bat[:bte]
address CMDbatMOD
comment "Return B % V, divide by zero causes NIL value";
pattern mod_noerror(b:bat[:bte],v:lng,s:bat[:oid]) :bat[:bte]
address CMDbatMOD
comment "Return B % V with candidates list, divide by zero causes NIL value";
pattern %(v:bte,b:bat[:lng]) :bat[:bte]
address CMDbatMODsignal
comment "Return V % B, signal error on divide by zero";
pattern %(v:bte,b:bat[:lng],s:bat[:oid]) :bat[:bte]
address CMDbatMODsignal
comment "Return V % B with candidates list, signal error on divide by zero";
pattern mod_noerror(v:bte,b:bat[:lng]) :bat[:bte]
address CMDbatMOD
comment "Return V % B, divide by zero causes NIL value";
pattern mod_noerror(v:bte,b:bat[:lng],s:bat[:oid]) :bat[:bte]
address CMDbatMOD
comment "Return V % B with candidates list, divide by zero causes NIL value";

pattern %(b1:bat[:bte],b2:bat[:flt]) :bat[:flt]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
pattern %(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatMODsignal
comment "Return B1 % B2 with candidates list, signal error on divide by zero";
pattern mod_noerror(b1:bat[:bte],b2:bat[:flt]) :bat[:flt]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern mod_noerror(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatMOD
comment "Return B1 % B2 with candidates list, divide by zero causes NIL value";
pattern %(b:bat[:bte],v:flt) :bat[:flt]
address CMDbatMODsignal
comment "Return B % V, signal error on divide by zero";
pattern %(b:bat[:bte],v:flt,s:bat[:oid]) :bat[:flt]
address CMDbatMODsignal
comment "Return B % V with candidates list, signal error on divide by zero";
pattern mod_noerror(b:bat[:bte],v:flt) :bat[:flt]
address CMDbatMOD
comment "Return B % V, divide by zero causes NIL value";
pattern mod_noerror(b:bat[:bte],v:flt,s:bat[:oid]) :bat[:flt]
address CMDbatMOD
comment "Return B % V with candidates list, divide by zero causes NIL value";
pattern %(v:bte,b:bat[:flt]) :bat[:flt]
address CMDbatMODsignal
comment "Return V % B, signal error on divide by zero";
pattern %(v:bte,b:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatMODsignal
comment "Return V % B with candidates list, signal error on divide by zero";
pattern mod_noerror(v:bte,b:bat[:flt]) :bat[:flt]
address CMDbatMOD
comment "Return V % B, divide by zero causes NIL value";
pattern mod_noerror(v:bte,b:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatMOD
comment "Return V % B with candidates list, divide by zero causes NIL value";

pattern %(b1:bat[:bte],b2:bat[:dbl]) :bat[:dbl]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
pattern %(b1:bat[:bte],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatMODsignal
comment "Return B1 % B2 with candidates list, signal error on divide by zero";
pattern mod_noerror(b1:bat[:bte],b2:bat[:dbl]) :bat[:dbl]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern mod_noerror(b1:bat[:bte],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatMOD
comment "Return B1 % B2 with candidates list, divide by zero causes NIL value";
pattern %(b:bat[:bte],v:dbl) :bat[:dbl]
address CMDbatMODsignal
comment "Return B % V, signal error on divide by zero";
pattern %(b:bat[:bte],v:dbl,s:bat[:oid]) :bat[:dbl]
address CMDbatMODsignal
comment "Return B % V with candidates list, signal error on divide by zero";
pattern mod_noerror(b:bat[:bte],v:dbl) :bat[:dbl]
address CMDbatMOD
comment "Return B % V, divide by zero causes NIL value";
pattern mod_noerror(b:bat[:bte],v:dbl,s:bat[:oid]) :bat[:dbl]
address CMDbatMOD
comment "Return B % V with candidates list, divide by zero causes NIL value";
pattern %(v:bte,b:bat[:dbl]) :bat[:dbl]
address CMDbatMODsignal
comment "Return V % B, signal error on divide by zero";
pattern %(v:bte,b:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatMODsignal
comment "Return V % B with candidates list, signal error on divide by zero";
pattern mod_noerror(v:bte,b:bat[:dbl]) :bat[:dbl]
address CMDbatMOD
comment "Return V % B, divide by zero causes NIL value";
pattern mod_noerror(v:bte,b:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatMOD
comment "Return V % B with candidates list, divide by zero causes NIL value";

pattern %(b1:bat[:sht],b2:bat[:bte]) :bat[:bte]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
pattern %(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]) :bat[:bte]
address CMDbatMODsignal
comment "Return B1 % B2 with candidates list, signal error on divide by zero";
pattern mod_noerror(b1:bat[:sht],b2:bat[:bte]) :bat[:bte]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern mod_noerror(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]) :bat[:bte]
address CMDbatMOD
comment "Return B1 % B2 with candidates list, divide by zero causes NIL value";
pattern %(b:bat[:sht],v:bte) :bat[:bte]
address CMDbatMODsignal
comment "Return B % V, signal error on divide by zero";
pattern %(b:bat[:sht],v:bte,s:bat[:oid]) :bat[:bte]
address CMDbatMODsignal
comment "Return B % V with candidates list, signal error on divide by zero";
pattern mod_noerror(b:bat[:sht],v:bte) :bat[:bte]
address CMDbatMOD
comment "Return B % V, divide by zero causes NIL value";
pattern mod_noerror(b:bat[:sht],v:bte,s:bat[:oid]) :bat[:bte]
address CMDbatMOD
comment "Return B % V with candidates list, divide by zero causes NIL value";
pattern %(v:sht,b:bat[:bte]) :bat[:bte]
address CMDbatMODsignal
comment "Return V % B, signal error on divide by zero";
pattern %(v:sht,b:bat[:bte],s:bat[:oid]) :bat[:bte]
address CMDbatMODsignal
comment "Return V % B with candidates list, signal error on divide by zero";
pattern mod_noerror(v:sht,b:bat[:bte]) :bat[:bte]
address CMDbatMOD
comment "Return V % B, divide by zero causes NIL value";
pattern mod_noerror(v:sht,b:bat[:bte],s:bat[:oid]) :bat[:bte]
address CMDbatMOD
comment "Return V % B with candidates list, divide by zero causes NIL value";

pattern %(b1:bat[:sht],b2:bat[:sht]) :bat[:sht]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
pattern %(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]) :bat[:sht]
address CMDbatMODsignal
comment "Return B1 % B2 with candidates list, signal error on divide by zero";
pattern mod_noerror(b1:bat[:sht],b2:bat[:sht]) :bat[:sht]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern mod_noerror(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]) :bat[:sht]
address CMDbatMOD
comment "Return B1 % B2 with candidates list, divide by zero causes NIL value";
pattern %(b:bat[:sht],v:sht) :bat[:sht]
address CMDbatMODsignal
comment "Return B % V, signal error on divide by zero";
pattern %(b:bat[:sht],v:sht,s:bat[:oid]) :bat[:sht]
address CMDbatMODsignal
comment "Return B % V with candidates list, signal error on divide by zero";
pattern mod_noerror(b:bat[:sht],v:sht) :bat[:sht]
address CMDbatMOD
comment "Return B % V, divide by zero causes NIL value";
pattern mod_noerror(b:bat[:sht],v:sht,s:bat[:oid]) :bat[:sht]
address CMDbatMOD
comment "Return B % V with candidates list, divide by zero causes NIL value";
pattern %(v:sht,b:bat[:sht]) :bat[:sht]
address CMDbatMODsignal
comment "Return V % B, signal error on divide by zero";
pattern %(v:sht,b:bat[:sht],s:bat[:oid]) :bat[:sht]
address CMDbatMODsignal
comment "Return V % B with candidates list, signal error on divide by zero";
pattern mod_noerror(v:sht,b:bat[:sht]) :bat[:sht]
address CMDbatMOD
comment "Return V % B, divide by zero causes NIL value";
pattern mod_noerror(v:sht,b:bat[:sht],s:bat[:oid]) :bat[:sht]
address CMDbatMOD
comment "Return V % B with candidates list, divide by zero causes NIL value";

pattern %(b1:bat[:sht],b2:bat[:int]) :bat[:sht]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
pattern %(b1:bat[:sht],b2:bat[:int],s:bat[:oid]) :bat[:sht]
address CMDbatMODsignal
comment "Return B1 % B2 with candidates list, signal error on divide by zero";
pattern mod_noerror(b1:bat[:sht],b2:bat[:int]) :bat[:sht]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern mod_noerror(b1:bat[:sht],b2:bat[:int],s:bat[:oid]) :bat[:sht]
address CMDbatMOD
comment "Return B1 % B2 with candidates list, divide by zero causes NIL value";
pattern %(b:bat[:sht],v:int) :bat[:sht]
address CMDbatMODsignal
comment "Return B % V, signal error on divide by zero";
pattern %(b:bat[:sht],v:int,s:bat[:oid]) :bat[:sht]
address CMDbatMODsignal
comment "Return B % V with candidates list, signal error on divide by zero";
pattern mod_noerror(b:bat[:sht],v:int) :bat[:sht]
address CMDbatMOD
comment "Return B % V, divide by zero causes NIL value";
pattern mod_noerror(b:bat[:sht],v:int,s:bat[:oid]) :bat[:sht]
address CMDbatMOD
comment "Return B % V with candidates list, divide by zero causes NIL value";
pattern %(v:sht,b:bat[:int]) :bat[:sht]
address CMDbatMODsignal
comment "Return V % B, signal error on divide by zero";
pattern %(v:sht,b:bat[:int],s:bat[:oid]) :bat[:sht]
address CMDbatMODsignal
comment "Return V % B with candidates list, signal error on divide by zero";
pattern mod_noerror(v:sht,b:bat[:int]) :bat[:sht]
address CMDbatMOD
comment "Return V % B, divide by zero causes NIL value";
pattern mod_noerror(v:sht,b:bat[:int],s:bat[:oid]) :bat[:sht]
address CMDbatMOD
comment "Return V % B with candidates list, divide by zero causes NIL value";

pattern %(b1:bat[:sht],b2:bat[:lng]) :bat[:sht]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
pattern %(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]) :bat[:sht]
address CMDbatMODsignal
comment "Return B1 % B2 with candidates list, signal error on divide by zero";
pattern mod_noerror(b1:bat[:sht],b2:bat[:lng]) :bat[:sht]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern mod_noerror(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]) :bat[:sht]
address CMDbatMOD
comment "Return B1 % B2 with candidates list, divide by zero causes NIL value";
pattern %(b:bat[:sht],v:lng) :bat[:sht]
address CMDbatMODsignal
comment "Return B % V, signal error on divide by zero";
pattern %(b:bat[:sht],v:lng,s:bat[:oid]) :bat[:sht]
address CMDbatMODsignal
comment "Return B % V with candidates list, signal error on divide by zero";
pattern mod_noerror(b:bat[:sht],v:lng) :bat[:sht]
address CMDbatMOD
comment "Return B % V, divide by zero causes NIL value";
pattern mod_noerror(b:bat[:sht],v:lng,s:bat[:oid]) :bat[:sht]
address CMDbatMOD
comment "Return B % V with candidates list, divide by zero causes NIL value";
pattern %(v:sht,b:bat[:lng]) :bat[:sht]
address CMDbatMODsignal
comment "Return V % B, signal error on divide by zero";
pattern %(v:sht,b:bat[:lng],s:bat[:oid]) :bat[:sht]
address CMDbatMODsignal
comment "Return V % B with candidates list, signal error on divide by zero";
pattern mod_noerror(v:sht,b:bat[:lng]) :bat[:sht]
address CMDbatMOD
comment "Return V % B, divide by zero causes NIL value";
pattern mod_noerror(v:sht,b:bat[:lng],s:bat[:oid]) :bat[:sht]
address CMDbatMOD
comment "Return V % B with candidates list, divide by zero causes NIL value";

pattern %(b1:bat[:sht],b2:bat[:flt]) :bat[:flt]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
pattern %(b1:bat[:sht],b2:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatMODsignal
comment "Return B1 % B2 with candidates list, signal error on divide by zero";
pattern mod_noerror(b1:bat[:sht],b2:bat[:flt]) :bat[:flt]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern mod_noerror(b1:bat[:sht],b2:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatMOD
comment "Return B1 % B2 with candidates list, divide by zero causes NIL value";
pattern %(b:bat[:sht],v:flt) :bat[:flt]
address CMDbatMODsignal
comment "Return B % V, signal error on divide by zero";
pattern %(b:bat[:sht],v:flt,s:bat[:oid]) :bat[:flt]
address CMDbatMODsignal
comment "Return B % V with candidates list, signal error on divide by zero";
pattern mod_noerror(b:bat[:sht],v:flt) :bat[:flt]
address CMDbatMOD
comment "Return B % V, divide by zero causes NIL value";
pattern mod_noerror(b:bat[:sht],v:flt,s:bat[:oid]) :bat[:flt]
address CMDbatMOD
comment "Return B % V with candidates list, divide by zero causes NIL value";
pattern %(v:sht,b:bat[:flt]) :bat[:flt]
address CMDbatMODsignal
comment "Return V % B, signal error on divide by zero";
pattern %(v:sht,b:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatMODsignal
comment "Return V % B with candidates list, signal error on divide by zero";
pattern mod_noerror(v:sht,b:bat[:flt]) :bat[:flt]
address CMDbatMOD
comment "Return V % B, divide by zero causes NIL value";
pattern mod_noerror(v:sht,b:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatMOD
comment "Return V % B with candidates list, divide by zero causes NIL value";

pattern %(b1:bat[:sht],b2:bat[:dbl]) :bat[:dbl]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
pattern %(b1:bat[:sht],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatMODsignal
comment "Return B1 % B2 with candidates list, signal error on divide by zero";
pattern mod_noerror(b1:bat[:sht],b2:bat[:dbl]) :bat[:dbl]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern mod_noerror(b1:bat[:sht],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatMOD
comment "Return B1 % B2 with candidates list, divide by zero causes NIL value";
pattern %(b:bat[:sht],v:dbl) :bat[:dbl]
address CMDbatMODsignal
comment "Return B % V, signal error on divide by zero";
pattern %(b:bat[:sht],v:dbl,s:bat[:oid]) :bat[:dbl]
address CMDbatMODsignal
comment "Return B % V with candidates list, signal error on divide by zero";
pattern mod_noerror(b:bat[:sht],v:dbl) :bat[:dbl]
address CMDbatMOD
comment "Return B % V, divide by zero causes NIL value";
pattern mod_noerror(b:bat[:sht],v:dbl,s:bat[:oid]) :bat[:dbl]
address CMDbatMOD
comment "Return B % V with candidates list, divide by zero causes NIL value";
pattern %(v:sht,b:bat[:dbl]) :bat[:dbl]
address CMDbatMODsignal
comment "Return V % B, signal error on divide by zero";
pattern %(v:sht,b:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatMODsignal
comment "Return V % B with candidates list, signal error on divide by zero";
pattern mod_noerror(v:sht,b:bat[:dbl]) :bat[:dbl]
address CMDbatMOD
comment "Return V % B, divide by zero causes NIL value";
pattern mod_noerror(v:sht,b:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatMOD
comment "Return V % B with candidates list, divide by zero causes NIL value";

pattern %(b1:bat[:int],b2:bat[:bte]) :bat[:bte]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
pattern %(b1:bat[:int],b2:bat[:bte],s:bat[:oid]) :bat[:bte]
address CMDbatMODsignal
comment "Return B1 % B2 with candidates list, signal error on divide by zero";
pattern mod_noerror(b1:bat[:int],b2:bat[:bte]) :bat[:bte]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern mod_noerror(b1:bat[:int],b2:bat[:bte],s:bat[:oid]) :bat[:bte]
address CMDbatMOD
comment "Return B1 % B2 with candidates list, divide by zero causes NIL value";
pattern %(b:bat[:int],v:bte) :bat[:bte]
address CMDbatMODsignal
comment "Return B % V, signal error on divide by zero";
pattern %(b:bat[:int],v:bte,s:bat[:oid]) :bat[:bte]
address CMDbatMODsignal
comment "Return B % V with candidates list, signal error on divide by zero";
pattern mod_noerror(b:bat[:int],v:bte) :bat[:bte]
address CMDbatMOD
comment "Return B % V, divide by zero causes NIL value";
pattern mod_noerror(b:bat[:int],v:bte,s:bat[:oid]) :bat[:bte]
address CMDbatMOD
comment "Return B % V with candidates list, divide by zero causes NIL value";
pattern %(v:int,b:bat[:bte]) :bat[:bte]
address CMDbatMODsignal
comment "Return V % B, signal error on divide by zero";
pattern %(v:int,b:bat[:bte],s:bat[:oid]) :bat[:bte]
address CMDbatMODsignal
comment "Return V % B with candidates list, signal error on divide by zero";
pattern mod_noerror(v:int,b:bat[:bte]) :bat[:bte]
address CMDbatMOD
comment "Return V % B, divide by zero causes NIL value";
pattern mod_noerror(v:int,b:bat[:bte],s:bat[:oid]) :bat[:bte]
address CMDbatMOD
comment "Return V % B with candidates list, divide by zero causes NIL value";

pattern %(b1:bat[:int],b2:bat[:sht]) :bat[:sht]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
pattern %(b1:bat[:int],b2:bat[:sht],s:bat[:oid]) :bat[:sht]
address CMDbatMODsignal
comment "Return B1 % B2 with candidates list, signal error on divide by zero";
pattern mod_noerror(b1:bat[:int],b2:bat[:sht]) :bat[:sht]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern mod_noerror(b1:bat[:int],b2:bat[:sht],s:bat[:oid]) :bat[:sht]
address CMDbatMOD
comment "Return B1 % B2 with candidates list, divide by zero causes NIL value";
pattern %(b:bat[:int],v:sht) :bat[:sht]
address CMDbatMODsignal
comment "Return B % V, signal error on divide by zero";
pattern %(b:bat[:int],v:sht,s:bat[:oid]) :bat[:sht]
address CMDbatMODsignal
comment "Return B % V with candidates list, signal error on divide by zero";
pattern mod_noerror(b:bat[:int],v:sht) :bat[:sht]
address CMDbatMOD
comment "Return B % V, divide by zero causes NIL value";
pattern mod_noerror(b:bat[:int],v:sht,s:bat[:oid]) :bat[:sht]
address CMDbatMOD
comment "Return B % V with candidates list, divide by zero causes NIL value";
pattern %(v:int,b:bat[:sht]) :bat[:sht]
address CMDbatMODsignal
comment "Return V % B, signal error on divide by zero";
pattern %(v:int,b:bat[:sht],s:bat[:oid]) :bat[:sht]
address CMDbatMODsignal
comment "Return V % B with candidates list, signal error on divide by zero";
pattern mod_noerror(v:int,b:bat[:sht]) :bat[:sht]
address CMDbatMOD
comment "Return V % B, divide by zero causes NIL value";
pattern mod_noerror(v:int,b:bat[:sht],s:bat[:oid]) :bat[:sht]
address CMDbatMOD
comment "Return V % B with candidates list, divide by zero causes NIL value";

pattern %(b1:bat[:int],b2:bat[:int]) :bat[:int]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
pattern %(b1:bat[:int],b2:bat[:int],s:bat[:oid]) :bat[:int]
address CMDbatMODsignal
comment "Return B1 % B2 with candidates list, signal error on divide by zero";
pattern mod_noerror(b1:bat[:int],b2:bat[:int]) :bat[:int]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern mod_noerror(b1:bat[:int],b2:bat[:int],s:bat[:oid]) :bat[:int]
address CMDbatMOD
comment "Return B1 % B2 with candidates list, divide by zero causes NIL value";
pattern %(b:bat[:int],v:int) :bat[:int]
address CMDbatMODsignal
comment "Return B % V, signal error on divide by zero";
pattern %(b:bat[:int],v:int,s:bat[:oid]) :bat[:int]
address CMDbatMODsignal
comment "Return B % V with candidates list, signal error on divide by zero";
pattern mod_noerror(b:bat[:int],v:int) :bat[:int]
address CMDbatMOD
comment "Return B % V, divide by zero causes NIL value";
pattern mod_noerror(b:bat[:int],v:int,s:bat[:oid]) :bat[:int]
address CMDbatMOD
comment "Return B % V with candidates list, divide by zero causes NIL value";
pattern %(v:int,b:bat[:int]) :bat[:int]
address CMDbatMODsignal
comment "Return V % B, signal error on divide by zero";
pattern %(v:int,b:bat[:int],s:bat[:oid]) :bat[:int]
address CMDbatMODsignal
comment "Return V % B with candidates list, signal error on divide by zero";
pattern mod_noerror(v:int,b:bat[:int]) :bat[:int]
address CMDbatMOD
comment "Return V % B, divide by zero causes NIL value";
pattern mod_noerror(v:int,b:bat[:int],s:bat[:oid]) :bat[:int]
address CMDbatMOD
comment "Return V % B with candidates list, divide by zero causes NIL value";

pattern %(b1:bat[:int],b2:bat[:lng]) :bat[:int]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
pattern %(b1:bat[:int],b2:bat[:lng],s:bat[:oid]) :bat[:int]
address CMDbatMODsignal
comment "Return B1 % B2 with candidates list, signal error on divide by zero";
pattern mod_noerror(b1:bat[:int],b2:bat[:lng]) :bat[:int]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern mod_noerror(b1:bat[:int],b2:bat[:lng],s:bat[:oid]) :bat[:int]
address CMDbatMOD
comment "Return B1 % B2 with candidates list, divide by zero causes NIL value";
pattern %(b:bat[:int],v:lng) :bat[:int]
address CMDbatMODsignal
comment "Return B % V, signal error on divide by zero";
pattern %(b:bat[:int],v:lng,s:bat[:oid]) :bat[:int]
address CMDbatMODsignal
comment "Return B % V with candidates list, signal error on divide by zero";
pattern mod_noerror(b:bat[:int],v:lng) :bat[:int]
address CMDbatMOD
comment "Return B % V, divide by zero causes NIL value";
pattern mod_noerror(b:bat[:int],v:lng,s:bat[:oid]) :bat[:int]
address CMDbatMOD
comment "Return B % V with candidates list, divide by zero causes NIL value";
pattern %(v:int,b:bat[:lng]) :bat[:int]
address CMDbatMODsignal
comment "Return V % B, signal error on divide by zero";
pattern %(v:int,b:bat[:lng],s:bat[:oid]) :bat[:int]
address CMDbatMODsignal
comment "Return V % B with candidates list, signal error on divide by zero";
pattern mod_noerror(v:int,b:bat[:lng]) :bat[:int]
address CMDbatMOD
comment "Return V % B, divide by zero causes NIL value";
pattern mod_noerror(v:int,b:bat[:lng],s:bat[:oid]) :bat[:int]
address CMDbatMOD
comment "Return V % B with candidates list, divide by zero causes NIL value";

pattern %(b1:bat[:int],b2:bat[:flt]) :bat[:flt]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
pattern %(b1:bat[:int],b2:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatMODsignal
comment "Return B1 % B2 with candidates list, signal error on divide by zero";
pattern mod_noerror(b1:bat[:int],b2:bat[:flt]) :bat[:flt]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern mod_noerror(b1:bat[:int],b2:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatMOD
comment "Return B1 % B2 with candidates list, divide by zero causes NIL value";
pattern %(b:bat[:int],v:flt) :bat[:flt]
address CMDbatMODsignal
comment "Return B % V, signal error on divide by zero";
pattern %(b:bat[:int],v:flt,s:bat[:oid]) :bat[:flt]
address CMDbatMODsignal
comment "Return B % V with candidates list, signal error on divide by zero";
pattern mod_noerror(b:bat[:int],v:flt) :bat[:flt]
address CMDbatMOD
comment "Return B % V, divide by zero causes NIL value";
pattern mod_noerror(b:bat[:int],v:flt,s:bat[:oid]) :bat[:flt]
address CMDbatMOD
comment "Return B % V with candidates list, divide by zero causes NIL value";
pattern %(v:int,b:bat[:flt]) :bat[:flt]
address CMDbatMODsignal
comment "Return V % B, signal error on divide by zero";
pattern %(v:int,b:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatMODsignal
comment "Return V % B with candidates list, signal error on divide by zero";
pattern mod_noerror(v:int,b:bat[:flt]) :bat[:flt]
address CMDbatMOD
comment "Return V % B, divide by zero causes NIL value";
pattern mod_noerror(v:int,b:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatMOD
comment "Return V % B with candidates list, divide by zero causes NIL value";

pattern %(b1:bat[:int],b2:bat[:dbl]) :bat[:dbl]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
pattern %(b1:bat[:int],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatMODsignal
comment "Return B1 % B2 with candidates list, signal error on divide by zero";
pattern mod_noerror(b1:bat[:int],b2:bat[:dbl]) :bat[:dbl]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern mod_noerror(b1:bat[:int],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatMOD
comment "Return B1 % B2 with candidates list, divide by zero causes NIL value";
pattern %(b:bat[:int],v:dbl) :bat[:dbl]
address CMDbatMODsignal
comment "Return B % V, signal error on divide by zero";
pattern %(b:bat[:int],v:dbl,s:bat[:oid]) :bat[:dbl]
address CMDbatMODsignal
comment "Return B % V with candidates list, signal error on divide by zero";
pattern mod_noerror(b:bat[:int],v:dbl) :bat[:dbl]
address CMDbatMOD
comment "Return B % V, divide by zero causes NIL value";
pattern mod_noerror(b:bat[:int],v:dbl,s:bat[:oid]) :bat[:dbl]
address CMDbatMOD
comment "Return B % V with candidates list, divide by zero causes NIL value";
pattern %(v:int,b:bat[:dbl]) :bat[:dbl]
address CMDbatMODsignal
comment "Return V % B, signal error on divide by zero";
pattern %(v:int,b:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatMODsignal
comment "Return V % B with candidates list, signal error on divide by zero";
pattern mod_noerror(v:int,b:bat[:dbl]) :bat[:dbl]
address CMDbatMOD
comment "Return V % B, divide by zero causes NIL value";
pattern mod_noerror(v:int,b:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatMOD
comment "Return V % B with candidates list, divide by zero causes NIL value";

pattern %(b1:bat[:lng],b2:bat[:bte]) :bat[:bte]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
pattern %(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]) :bat[:bte]
address CMDbatMODsignal
comment "Return B1 % B2 with candidates list, signal error on divide by zero";
pattern mod_noerror(b1:bat[:lng],b2:bat[:bte]) :bat[:bte]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern mod_noerror(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]) :bat[:bte]
address CMDbatMOD
comment "Return B1 % B2 with candidates list, divide by zero causes NIL value";
pattern %(b:bat[:lng],v:bte) :bat[:bte]
address CMDbatMODsignal
comment "Return B % V, signal error on divide by zero";
pattern %(b:bat[:lng],v:bte,s:bat[:oid]) :bat[:bte]
address CMDbatMODsignal
comment "Return B % V with candidates list, signal error on divide by zero";
pattern mod_noerror(b:bat[:lng],v:bte) :bat[:bte]
address CMDbatMOD
comment "Return B % V, divide by zero causes NIL value";
pattern mod_noerror(b:bat[:lng],v:bte,s:bat[:oid]) :bat[:bte]
address CMDbatMOD
comment "Return B % V with candidates list, divide by zero causes NIL value";
pattern %(v:lng,b:bat[:bte]) :bat[:bte]
address CMDbatMODsignal
comment "Return V % B, signal error on divide by zero";
pattern %(v:lng,b:bat[:bte],s:bat[:oid]) :bat[:bte]
address CMDbatMODsignal
comment "Return V % B with candidates list, signal error on divide by zero";
pattern mod_noerror(v:lng,b:bat[:bte]) :bat[:bte]
address CMDbatMOD
comment "Return V % B, divide by zero causes NIL value";
pattern mod_noerror(v:lng,b:bat[:bte],s:bat[:oid]) :bat[:bte]
address CMDbatMOD
comment "Return V % B with candidates list, divide by zero causes NIL value";

pattern %(b1:bat[:lng],b2:bat[:sht]) :bat[:sht]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
pattern %(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]) :bat[:sht]
address CMDbatMODsignal
comment "Return B1 % B2 with candidates list, signal error on divide by zero";
pattern mod_noerror(b1:bat[:lng],b2:bat[:sht]) :bat[:sht]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern mod_noerror(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]) :bat[:sht]
address CMDbatMOD
comment "Return B1 % B2 with candidates list, divide by zero causes NIL value";
pattern %(b:bat[:lng],v:sht) :bat[:sht]
address CMDbatMODsignal
comment "Return B % V, signal error on divide by zero";
pattern %(b:bat[:lng],v:sht,s:bat[:oid]) :bat[:sht]
address CMDbatMODsignal
comment "Return B % V with candidates list, signal error on divide by zero";
pattern mod_noerror(b:bat[:lng],v:sht) :bat[:sht]
address CMDbatMOD
comment "Return B % V, divide by zero causes NIL value";
pattern mod_noerror(b:bat[:lng],v:sht,s:bat[:oid]) :bat[:sht]
address CMDbatMOD
comment "Return B % V with candidates list, divide by zero causes NIL value";
pattern %(v:lng,b:bat[:sht]) :bat[:sht]
address CMDbatMODsignal
comment "Return V % B, signal error on divide by zero";
pattern %(v:lng,b:bat[:sht],s:bat[:oid]) :bat[:sht]
address CMDbatMODsignal
comment "Return V % B with candidates list, signal error on divide by zero";
pattern mod_noerror(v:lng,b:bat[:sht]) :bat[:sht]
address CMDbatMOD
comment "Return V % B, divide by zero causes NIL value";
pattern mod_noerror(v:lng,b:bat[:sht],s:bat[:oid]) :bat[:sht]
address CMDbatMOD
comment "Return V % B with candidates list, divide by zero causes NIL value";

pattern %(b1:bat[:lng],b2:bat[:int]) :bat[:int]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
pattern %(b1:bat[:lng],b2:bat[:int],s:bat[:oid]) :bat[:int]
address CMDbatMODsignal
comment "Return B1 % B2 with candidates list, signal error on divide by zero";
pattern mod_noerror(b1:bat[:lng],b2:bat[:int]) :bat[:int]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern mod_noerror(b1:bat[:lng],b2:bat[:int],s:bat[:oid]) :bat[:int]
address CMDbatMOD
comment "Return B1 % B2 with candidates list, divide by zero causes NIL value";
pattern %(b:bat[:lng],v:int) :bat[:int]
address CMDbatMODsignal
comment "Return B % V, signal error on divide by zero";
pattern %(b:bat[:lng],v:int,s:bat[:oid]) :bat[:int]
address CMDbatMODsignal
comment "Return B % V with candidates list, signal error on divide by zero";
pattern mod_noerror(b:bat[:lng],v:int) :bat[:int]
address CMDbatMOD
comment "Return B % V, divide by zero causes NIL value";
pattern mod_noerror(b:bat[:lng],v:int,s:bat[:oid]) :bat[:int]
address CMDbatMOD
comment "Return B % V with candidates list, divide by zero causes NIL value";
pattern %(v:lng,b:bat[:int]) :bat[:int]
address CMDbatMODsignal
comment "Return V % B, signal error on divide by zero";
pattern %(v:lng,b:bat[:int],s:bat[:oid]) :bat[:int]
address CMDbatMODsignal
comment "Return V % B with candidates list, signal error on divide by zero";
pattern mod_noerror(v:lng,b:bat[:int]) :bat[:int]
address CMDbatMOD
comment "Return V % B, divide by zero causes NIL value";
pattern mod_noerror(v:lng,b:bat[:int],s:bat[:oid]) :bat[:int]
address CMDbatMOD
comment "Return V % B with candidates list, divide by zero causes NIL value";

pattern %(b1:bat[:lng],b2:bat[:lng]) :bat[:lng]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
pattern %(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]) :bat[:lng]
address CMDbatMODsignal
comment "Return B1 % B2 with candidates list, signal error on divide by zero";
pattern mod_noerror(b1:bat[:lng],b2:bat[:lng]) :bat[:lng]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern mod_noerror(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]) :bat[:lng]
address CMDbatMOD
comment "Return B1 % B2 with candidates list, divide by zero causes NIL value";
pattern %(b:bat[:lng],v:lng) :bat[:lng]
address CMDbatMODsignal
comment "Return B % V, signal error on divide by zero";
pattern %(b:bat[:lng],v:lng,s:bat[:oid]) :bat[:lng]
address CMDbatMODsignal
comment "Return B % V with candidates list, signal error on divide by zero";
pattern mod_noerror(b:bat[:lng],v:lng) :bat[:lng]
address CMDbatMOD
comment "Return B % V, divide by zero causes NIL value";
pattern mod_noerror(b:bat[:lng],v:lng,s:bat[:oid]) :bat[:lng]
address CMDbatMOD
comment "Return B % V with candidates list, divide by zero causes NIL value";
pattern %(v:lng,b:bat[:lng]) :bat[:lng]
address CMDbatMODsignal
comment "Return V % B, signal error on divide by zero";
pattern %(v:lng,b:bat[:lng],s:bat[:oid]) :bat[:lng]
address CMDbatMODsignal
comment "Return V % B with candidates list, signal error on divide by zero";
pattern mod_noerror(v:lng,b:bat[:lng]) :bat[:lng]
address CMDbatMOD
comment "Return V % B, divide by zero causes NIL value";
pattern mod_noerror(v:lng,b:bat[:lng],s:bat[:oid]) :bat[:lng]
address CMDbatMOD
comment "Return V % B with candidates list, divide by zero causes NIL value";

pattern %(b1:bat[:lng],b2:bat[:flt]) :bat[:flt]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
pattern %(b1:bat[:lng],b2:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatMODsignal
comment "Return B1 % B2 with candidates list, signal error on divide by zero";
pattern mod_noerror(b1:bat[:lng],b2:bat[:flt]) :bat[:flt]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern mod_noerror(b1:bat[:lng],b2:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatMOD
comment "Return B1 % B2 with candidates list, divide by zero causes NIL value";
pattern %(b:bat[:lng],v:flt) :bat[:flt]
address CMDbatMODsignal
comment "Return B % V, signal error on divide by zero";
pattern %(b:bat[:lng],v:flt,s:bat[:oid]) :bat[:flt]
address CMDbatMODsignal
comment "Return B % V with candidates list, signal error on divide by zero";
pattern mod_noerror(b:bat[:lng],v:flt) :bat[:flt]
address CMDbatMOD
comment "Return B % V, divide by zero causes NIL value";
pattern mod_noerror(b:bat[:lng],v:flt,s:bat[:oid]) :bat[:flt]
address CMDbatMOD
comment "Return B % V with candidates list, divide by zero causes NIL value";
pattern %(v:lng,b:bat[:flt]) :bat[:flt]
address CMDbatMODsignal
comment "Return V % B, signal error on divide by zero";
pattern %(v:lng,b:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatMODsignal
comment "Return V % B with candidates list, signal error on divide by zero";
pattern mod_noerror(v:lng,b:bat[:flt]) :bat[:flt]
address CMDbatMOD
comment "Return V % B, divide by zero causes NIL value";
pattern mod_noerror(v:lng,b:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatMOD
comment "Return V % B with candidates list, divide by zero causes NIL value";

pattern %(b1:bat[:lng],b2:bat[:dbl]) :bat[:dbl]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
pattern %(b1:bat[:lng],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatMODsignal
comment "Return B1 % B2 with candidates list, signal error on divide by zero";
pattern mod_noerror(b1:bat[:lng],b2:bat[:dbl]) :bat[:dbl]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern mod_noerror(b1:bat[:lng],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatMOD
comment "Return B1 % B2 with candidates list, divide by zero causes NIL value";
pattern %(b:bat[:lng],v:dbl) :bat[:dbl]
address CMDbatMODsignal
comment "Return B % V, signal error on divide by zero";
pattern %(b:bat[:lng],v:dbl,s:bat[:oid]) :bat[:dbl]
address CMDbatMODsignal
comment "Return B % V with candidates list, signal error on divide by zero";
pattern mod_noerror(b:bat[:lng],v:dbl) :bat[:dbl]
address CMDbatMOD
comment "Return B % V, divide by zero causes NIL value";
pattern mod_noerror(b:bat[:lng],v:dbl,s:bat[:oid]) :bat[:dbl]
address CMDbatMOD
comment "Return B % V with candidates list, divide by zero causes NIL value";
pattern %(v:lng,b:bat[:dbl]) :bat[:dbl]
address CMDbatMODsignal
comment "Return V % B, signal error on divide by zero";
pattern %(v:lng,b:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatMODsignal
comment "Return V % B with candidates list, signal error on divide by zero";
pattern mod_noerror(v:lng,b:bat[:dbl]) :bat[:dbl]
address CMDbatMOD
comment "Return V % B, divide by zero causes NIL value";
pattern mod_noerror(v:lng,b:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatMOD
comment "Return V % B with candidates list, divide by zero causes NIL value";

pattern %(b1:bat[:flt],b2:bat[:bte]) :bat[:flt]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
pattern %(b1:bat[:flt],b2:bat[:bte],s:bat[:oid]) :bat[:flt]
address CMDbatMODsignal
comment "Return B1 % B2 with candidates list, signal error on divide by zero";
pattern mod_noerror(b1:bat[:flt],b2:bat[:bte]) :bat[:flt]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern mod_noerror(b1:bat[:flt],b2:bat[:bte],s:bat[:oid]) :bat[:flt]
address CMDbatMOD
comment "Return B1 % B2 with candidates list, divide by zero causes NIL value";
pattern %(b:bat[:flt],v:bte) :bat[:flt]
address CMDbatMODsignal
comment "Return B % V, signal error on divide by zero";
pattern %(b:bat[:flt],v:bte,s:bat[:oid]) :bat[:flt]
address CMDbatMODsignal
comment "Return B % V with candidates list, signal error on divide by zero";
pattern mod_noerror(b:bat[:flt],v:bte) :bat[:flt]
address CMDbatMOD
comment "Return B % V, divide by zero causes NIL value";
pattern mod_noerror(b:bat[:flt],v:bte,s:bat[:oid]) :bat[:flt]
address CMDbatMOD
comment "Return B % V with candidates list, divide by zero causes NIL value";
pattern %(v:flt,b:bat[:bte]) :bat[:flt]
address CMDbatMODsignal
comment "Return V % B, signal error on divide by zero";
pattern %(v:flt,b:bat[:bte],s:bat[:oid]) :bat[:flt]
address CMDbatMODsignal
comment "Return V % B with candidates list, signal error on divide by zero";
pattern mod_noerror(v:flt,b:bat[:bte]) :bat[:flt]
address CMDbatMOD
comment "Return V % B, divide by zero causes NIL value";
pattern mod_noerror(v:flt,b:bat[:bte],s:bat[:oid]) :bat[:flt]
address CMDbatMOD
comment "Return V % B with candidates list, divide by zero causes NIL value";

pattern %(b1:bat[:flt],b2:bat[:sht]) :bat[:flt]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
pattern %(b1:bat[:flt],b2:bat[:sht],s:bat[:oid]) :bat[:flt]
address CMDbatMODsignal
comment "Return B1 % B2 with candidates list, signal error on divide by zero";
pattern mod_noerror(b1:bat[:flt],b2:bat[:sht]) :bat[:flt]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern mod_noerror(b1:bat[:flt],b2:bat[:sht],s:bat[:oid]) :bat[:flt]
address CMDbatMOD
comment "Return B1 % B2 with candidates list, divide by zero causes NIL value";
pattern %(b:bat[:flt],v:sht) :bat[:flt]
address CMDbatMODsignal
comment "Return B % V, signal error on divide by zero";
pattern %(b:bat[:flt],v:sht,s:bat[:oid]) :bat[:flt]
address CMDbatMODsignal
comment "Return B % V with candidates list, signal error on divide by zero";
pattern mod_noerror(b:bat[:flt],v:sht) :bat[:flt]
address CMDbatMOD
comment "Return B % V, divide by zero causes NIL value";
pattern mod_noerror(b:bat[:flt],v:sht,s:bat[:oid]) :bat[:flt]
address CMDbatMOD
comment "Return B % V with candidates list, divide by zero causes NIL value";
pattern %(v:flt,b:bat[:sht]) :bat[:flt]
address CMDbatMODsignal
comment "Return V % B, signal error on divide by zero";
pattern %(v:flt,b:bat[:sht],s:bat[:oid]) :bat[:flt]
address CMDbatMODsignal
comment "Return V % B with candidates list, signal error on divide by zero";
pattern mod_noerror(v:flt,b:bat[:sht]) :bat[:flt]
address CMDbatMOD
comment "Return V % B, divide by zero causes NIL value";
pattern mod_noerror(v:flt,b:bat[:sht],s:bat[:oid]) :bat[:flt]
address CMDbatMOD
comment "Return V % B with candidates list, divide by zero causes NIL value";

pattern %(b1:bat[:flt],b2:bat[:int]) :bat[:flt]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
pattern %(b1:bat[:flt],b2:bat[:int],s:bat[:oid]) :bat[:flt]
address CMDbatMODsignal
comment "Return B1 % B2 with candidates list, signal error on divide by zero";
pattern mod_noerror(b1:bat[:flt],b2:bat[:int]) :bat[:flt]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern mod_noerror(b1:bat[:flt],b2:bat[:int],s:bat[:oid]) :bat[:flt]
address CMDbatMOD
comment "Return B1 % B2 with candidates list, divide by zero causes NIL value";
pattern %(b:bat[:flt],v:int) :bat[:flt]
address CMDbatMODsignal
comment "Return B % V, signal error on divide by zero";
pattern %(b:bat[:flt],v:int,s:bat[:oid]) :bat[:flt]
address CMDbatMODsignal
comment "Return B % V with candidates list, signal error on divide by zero";
pattern mod_noerror(b:bat[:flt],v:int) :bat[:flt]
address CMDbatMOD
comment "Return B % V, divide by zero causes NIL value";
pattern mod_noerror(b:bat[:flt],v:int,s:bat[:oid]) :bat[:flt]
address CMDbatMOD
comment "Return B % V with candidates list, divide by zero causes NIL value";
pattern %(v:flt,b:bat[:int]) :bat[:flt]
address CMDbatMODsignal
comment "Return V % B, signal error on divide by zero";
pattern %(v:flt,b:bat[:int],s:bat[:oid]) :bat[:flt]
address CMDbatMODsignal
comment "Return V % B with candidates list, signal error on divide by zero";
pattern mod_noerror(v:flt,b:bat[:int]) :bat[:flt]
address CMDbatMOD
comment "Return V % B, divide by zero causes NIL value";
pattern mod_noerror(v:flt,b:bat[:int],s:bat[:oid]) :bat[:flt]
address CMDbatMOD
comment "Return V % B with candidates list, divide by zero causes NIL value";

pattern %(b1:bat[:flt],b2:bat[:lng]) :bat[:flt]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
pattern %(b1:bat[:flt],b2:bat[:lng],s:bat[:oid]) :bat[:flt]
address CMDbatMODsignal
comment "Return B1 % B2 with candidates list, signal error on divide by zero";
pattern mod_noerror(b1:bat[:flt],b2:bat[:lng]) :bat[:flt]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern mod_noerror(b1:bat[:flt],b2:bat[:lng],s:bat[:oid]) :bat[:flt]
address CMDbatMOD
comment "Return B1 % B2 with candidates list, divide by zero causes NIL value";
pattern %(b:bat[:flt],v:lng) :bat[:flt]
address CMDbatMODsignal
comment "Return B % V, signal error on divide by zero";
pattern %(b:bat[:flt],v:lng,s:bat[:oid]) :bat[:flt]
address CMDbatMODsignal
comment "Return B % V with candidates list, signal error on divide by zero";
pattern mod_noerror(b:bat[:flt],v:lng) :bat[:flt]
address CMDbatMOD
comment "Return B % V, divide by zero causes NIL value";
pattern mod_noerror(b:bat[:flt],v:lng,s:bat[:oid]) :bat[:flt]
address CMDbatMOD
comment "Return B % V with candidates list, divide by zero causes NIL value";
pattern %(v:flt,b:bat[:lng]) :bat[:flt]
address CMDbatMODsignal
comment "Return V % B, signal error on divide by zero";
pattern %(v:flt,b:bat[:lng],s:bat[:oid]) :bat[:flt]
address CMDbatMODsignal
comment "Return V % B with candidates list, signal error on divide by zero";
pattern mod_noerror(v:flt,b:bat[:lng]) :bat[:flt]
address CMDbatMOD
comment "Return V % B, divide by zero causes NIL value";
pattern mod_noerror(v:flt,b:bat[:lng],s:bat[:oid]) :bat[:flt]
address CMDbatMOD
comment "Return V % B with candidates list, divide by zero causes NIL value";

pattern %(b1:bat[:flt],b2:bat[:flt]) :bat[:flt]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
pattern %(b1:bat[:flt],b2:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatMODsignal
comment "Return B1 % B2 with candidates list, signal error on divide by zero";
pattern mod_noerror(b1:bat[:flt],b2:bat[:flt]) :bat[:flt]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern mod_noerror(b1:bat[:flt],b2:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatMOD
comment "Return B1 % B2 with candidates list, divide by zero causes NIL value";
pattern %(b:bat[:flt],v:flt) :bat[:flt]
address CMDbatMODsignal
comment "Return B % V, signal error on divide by zero";
pattern %(b:bat[:flt],v:flt,s:bat[:oid]) :bat[:flt]
address CMDbatMODsignal
comment "Return B % V with candidates list, signal error on divide by zero";
pattern mod_noerror(b:bat[:flt],v:flt) :bat[:flt]
address CMDbatMOD
comment "Return B % V, divide by zero causes NIL value";
pattern mod_noerror(b:bat[:flt],v:flt,s:bat[:oid]) :bat[:flt]
address CMDbatMOD
comment "Return B % V with candidates list, divide by zero causes NIL value";
pattern %(v:flt,b:bat[:flt]) :bat[:flt]
address CMDbatMODsignal
comment "Return V % B, signal error on divide by zero";
pattern %(v:flt,b:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatMODsignal
comment "Return V % B with candidates list, signal error on divide by zero";
pattern mod_noerror(v:flt,b:bat[:flt]) :bat[:flt]
address CMDbatMOD
comment "Return V % B, divide by zero causes NIL value";
pattern mod_noerror(v:flt,b:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatMOD
comment "Return V % B with candidates list, divide by zero causes NIL value";

pattern %(b1:bat[:flt],b2:bat[:dbl]) :bat[:dbl]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
pattern %(b1:bat[:flt],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatMODsignal
comment "Return B1 % B2 with candidates list, signal error on divide by zero";
pattern mod_noerror(b1:bat[:flt],b2:bat[:dbl]) :bat[:dbl]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern mod_noerror(b1:bat[:flt],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatMOD
comment "Return B1 % B2 with candidates list, divide by zero causes NIL value";
pattern %(b:bat[:flt],v:dbl) :bat[:dbl]
address CMDbatMODsignal
comment "Return B % V, signal error on divide by zero";
pattern %(b:bat[:flt],v:dbl,s:bat[:oid]) :bat[:dbl]
address CMDbatMODsignal
comment "Return B % V with candidates list, signal error on divide by zero";
pattern mod_noerror(b:bat[:flt],v:dbl) :bat[:dbl]
address CMDbatMOD
comment "Return B % V, divide by zero causes NIL value";
pattern mod_noerror(b:bat[:flt],v:dbl,s:bat[:oid]) :bat[:dbl]
address CMDbatMOD
comment "Return B % V with candidates list, divide by zero causes NIL value";
pattern %(v:flt,b:bat[:dbl]) :bat[:dbl]
address CMDbatMODsignal
comment "Return V % B, signal error on divide by zero";
pattern %(v:flt,b:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatMODsignal
comment "Return V % B with candidates list, signal error on divide by zero";
pattern mod_noerror(v:flt,b:bat[:dbl]) :bat[:dbl]
address CMDbatMOD
comment "Return V % B, divide by zero causes NIL value";
pattern mod_noerror(v:flt,b:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatMOD
comment "Return V % B with candidates list, divide by zero causes NIL value";

pattern %(b1:bat[:dbl],b2:bat[:bte]) :bat[:dbl]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
pattern %(b1:bat[:dbl],b2:bat[:bte],s:bat[:oid]) :bat[:dbl]
address CMDbatMODsignal
comment "Return B1 % B2 with candidates list, signal error on divide by zero";
pattern mod_noerror(b1:bat[:dbl],b2:bat[:bte]) :bat[:dbl]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern mod_noerror(b1:bat[:dbl],b2:bat[:bte],s:bat[:oid]) :bat[:dbl]
address CMDbatMOD
comment "Return B1 % B2 with candidates list, divide by zero causes NIL value";
pattern %(b:bat[:dbl],v:bte) :bat[:dbl]
address CMDbatMODsignal
comment "Return B % V, signal error on divide by zero";
pattern %(b:bat[:dbl],v:bte,s:bat[:oid]) :bat[:dbl]
address CMDbatMODsignal
comment "Return B % V with candidates list, signal error on divide by zero";
pattern mod_noerror(b:bat[:dbl],v:bte) :bat[:dbl]
address CMDbatMOD
comment "Return B % V, divide by zero causes NIL value";
pattern mod_noerror(b:bat[:dbl],v:bte,s:bat[:oid]) :bat[:dbl]
address CMDbatMOD
comment "Return B % V with candidates list, divide by zero causes NIL value";
pattern %(v:dbl,b:bat[:bte]) :bat[:dbl]
address CMDbatMODsignal
comment "Return V % B, signal error on divide by zero";
pattern %(v:dbl,b:bat[:bte],s:bat[:oid]) :bat[:dbl]
address CMDbatMODsignal
comment "Return V % B with candidates list, signal error on divide by zero";
pattern mod_noerror(v:dbl,b:bat[:bte]) :bat[:dbl]
address CMDbatMOD
comment "Return V % B, divide by zero causes NIL value";
pattern mod_noerror(v:dbl,b:bat[:bte],s:bat[:oid]) :bat[:dbl]
address CMDbatMOD
comment "Return V % B with candidates list, divide by zero causes NIL value";

pattern %(b1:bat[:dbl],b2:bat[:sht]) :bat[:dbl]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
pattern %(b1:bat[:dbl],b2:bat[:sht],s:bat[:oid]) :bat[:dbl]
address CMDbatMODsignal
comment "Return B1 % B2 with candidates list, signal error on divide by zero";
pattern mod_noerror(b1:bat[:dbl],b2:bat[:sht]) :bat[:dbl]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern mod_noerror(b1:bat[:dbl],b2:bat[:sht],s:bat[:oid]) :bat[:dbl]
address CMDbatMOD
comment "Return B1 % B2 with candidates list, divide by zero causes NIL value";
pattern %(b:bat[:dbl],v:sht) :bat[:dbl]
address CMDbatMODsignal
comment "Return B % V, signal error on divide by zero";
pattern %(b:bat[:dbl],v:sht,s:bat[:oid]) :bat[:dbl]
address CMDbatMODsignal
comment "Return B % V with candidates list, signal error on divide by zero";
pattern mod_noerror(b:bat[:dbl],v:sht) :bat[:dbl]
address CMDbatMOD
comment "Return B % V, divide by zero causes NIL value";
pattern mod_noerror(b:bat[:dbl],v:sht,s:bat[:oid]) :bat[:dbl]
address CMDbatMOD
comment "Return B % V with candidates list, divide by zero causes NIL value";
pattern %(v:dbl,b:bat[:sht]) :bat[:dbl]
address CMDbatMODsignal
comment "Return V % B, signal error on divide by zero";
pattern %(v:dbl,b:bat[:sht],s:bat[:oid]) :bat[:dbl]
address CMDbatMODsignal
comment "Return V % B with candidates list, signal error on divide by zero";
pattern mod_noerror(v:dbl,b:bat[:sht]) :bat[:dbl]
address CMDbatMOD
comment "Return V % B, divide by zero causes NIL value";
pattern mod_noerror(v:dbl,b:bat[:sht],s:bat[:oid]) :bat[:dbl]
address CMDbatMOD
comment "Return V % B with candidates list, divide by zero causes NIL value";

pattern %(b1:bat[:dbl],b2:bat[:int]) :bat[:dbl]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
pattern %(b1:bat[:dbl],b2:bat[:int],s:bat[:oid]) :bat[:dbl]
address CMDbatMODsignal
comment "Return B1 % B2 with candidates list, signal error on divide by zero";
pattern mod_noerror(b1:bat[:dbl],b2:bat[:int]) :bat[:dbl]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern mod_noerror(b1:bat[:dbl],b2:bat[:int],s:bat[:oid]) :bat[:dbl]
address CMDbatMOD
comment "Return B1 % B2 with candidates list, divide by zero causes NIL value";
pattern %(b:bat[:dbl],v:int) :bat[:dbl]
address CMDbatMODsignal
comment "Return B % V, signal error on divide by zero";
pattern %(b:bat[:dbl],v:int,s:bat[:oid]) :bat[:dbl]
address CMDbatMODsignal
comment "Return B % V with candidates list, signal error on divide by zero";
pattern mod_noerror(b:bat[:dbl],v:int) :bat[:dbl]
address CMDbatMOD
comment "Return B % V, divide by zero causes NIL value";
pattern mod_noerror(b:bat[:dbl],v:int,s:bat[:oid]) :bat[:dbl]
address CMDbatMOD
comment "Return B % V with candidates list, divide by zero causes NIL value";
pattern %(v:dbl,b:bat[:int]) :bat[:dbl]
address CMDbatMODsignal
comment "Return V % B, signal error on divide by zero";
pattern %(v:dbl,b:bat[:int],s:bat[:oid]) :bat[:dbl]
address CMDbatMODsignal
comment "Return V % B with candidates list, signal error on divide by zero";
pattern mod_noerror(v:dbl,b:bat[:int]) :bat[:dbl]
address CMDbatMOD
comment "Return V % B, divide by zero causes NIL value";
pattern mod_noerror(v:dbl,b:bat[:int],s:bat[:oid]) :bat[:dbl]
address CMDbatMOD
comment "Return V % B with candidates list, divide by zero causes NIL value";

pattern %(b1:bat[:dbl],b2:bat[:lng]) :bat[:dbl]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
pattern %(b1:bat[:dbl],b2:bat[:lng],s:bat[:oid]) :bat[:dbl]
address CMDbatMODsignal
comment "Return B1 % B2 with candidates list, signal error on divide by zero";
pattern mod_noerror(b1:bat[:dbl],b2:bat[:lng]) :bat[:dbl]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern mod_noerror(b1:bat[:dbl],b2:bat[:lng],s:bat[:oid]) :bat[:dbl]
address CMDbatMOD
comment "Return B1 % B2 with candidates list, divide by zero causes NIL value";
pattern %(b:bat[:dbl],v:lng) :bat[:dbl]
address CMDbatMODsignal
comment "Return B % V, signal error on divide by zero";
pattern %(b:bat[:dbl],v:lng,s:bat[:oid]) :bat[:dbl]
address CMDbatMODsignal
comment "Return B % V with candidates list, signal error on divide by zero";
pattern mod_noerror(b:bat[:dbl],v:lng) :bat[:dbl]
address CMDbatMOD
comment "Return B % V, divide by zero causes NIL value";
pattern mod_noerror(b:bat[:dbl],v:lng,s:bat[:oid]) :bat[:dbl]
address CMDbatMOD
comment "Return B % V with candidates list, divide by zero causes NIL value";
pattern %(v:dbl,b:bat[:lng]) :bat[:dbl]
address CMDbatMODsignal
comment "Return V % B, signal error on divide by zero";
pattern %(v:dbl,b:bat[:lng],s:bat[:oid]) :bat[:dbl]
address CMDbatMODsignal
comment "Return V % B with candidates list, signal error on divide by zero";
pattern mod_noerror(v:dbl,b:bat[:lng]) :bat[:dbl]
address CMDbatMOD
comment "Return V % B, divide by zero causes NIL value";
pattern mod_noerror(v:dbl,b:bat[:lng],s:bat[:oid]) :bat[:dbl]
address CMDbatMOD
comment "Return V % B with candidates list, divide by zero causes NIL value";

pattern %(b1:bat[:dbl],b2:bat[:flt]) :bat[:dbl]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
pattern %(b1:bat[:dbl],b2:bat[:flt],s:bat[:oid]) :bat[:dbl]
address CMDbatMODsignal
comment "Return B1 % B2 with candidates list, signal error on divide by zero";
pattern mod_noerror(b1:bat[:dbl],b2:bat[:flt]) :bat[:dbl]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern mod_noerror(b1:bat[:dbl],b2:bat[:flt],s:bat[:oid]) :bat[:dbl]
address CMDbatMOD
comment "Return B1 % B2 with candidates list, divide by zero causes NIL value";
pattern %(b:bat[:dbl],v:flt) :bat[:dbl]
address CMDbatMODsignal
comment "Return B % V, signal error on divide by zero";
pattern %(b:bat[:dbl],v:flt,s:bat[:oid]) :bat[:dbl]
address CMDbatMODsignal
comment "Return B % V with candidates list, signal error on divide by zero";
pattern mod_noerror(b:bat[:dbl],v:flt) :bat[:dbl]
address CMDbatMOD
comment "Return B % V, divide by zero causes NIL value";
pattern mod_noerror(b:bat[:dbl],v:flt,s:bat[:oid]) :bat[:dbl]
address CMDbatMOD
comment "Return B % V with candidates list, divide by zero causes NIL value";
pattern %(v:dbl,b:bat[:flt]) :bat[:dbl]
address CMDbatMODsignal
comment "Return V % B, signal error on divide by zero";
pattern %(v:dbl,b:bat[:flt],s:bat[:oid]) :bat[:dbl]
address CMDbatMODsignal
comment "Return V % B with candidates list, signal error on divide by zero";
pattern mod_noerror(v:dbl,b:bat[:flt]) :bat[:dbl]
address CMDbatMOD
comment "Return V % B, divide by zero causes NIL value";
pattern mod_noerror(v:dbl,b:bat[:flt],s:bat[:oid]) :bat[:dbl]
address CMDbatMOD
comment "Return V % B with candidates list, divide by zero causes NIL value";

pattern %(b1:bat[:dbl],b2:bat[:dbl]) :bat[:dbl]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
pattern %(b1:bat[:dbl],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatMODsignal
comment "Return B1 % B2 with candidates list, signal error on divide by zero";
pattern mod_noerror(b1:bat[:dbl],b2:bat[:dbl]) :bat[:dbl]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern mod_noerror(b1:bat[:dbl],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatMOD
comment "Return B1 % B2 with candidates list, divide by zero causes NIL value";
pattern %(b:bat[:dbl],v:dbl) :bat[:dbl]
address CMDbatMODsignal
comment "Return B % V, signal error on divide by zero";
pattern %(b:bat[:dbl],v:dbl,s:bat[:oid]) :bat[:dbl]
address CMDbatMODsignal
comment "Return B % V with candidates list, signal error on divide by zero";
pattern mod_noerror(b:bat[:dbl],v:dbl) :bat[:dbl]
address CMDbatMOD
comment "Return B % V, divide by zero causes NIL value";
pattern mod_noerror(b:bat[:dbl],v:dbl,s:bat[:oid]) :bat[:dbl]
address CMDbatMOD
comment "Return B % V with candidates list, divide by zero causes NIL value";
pattern %(v:dbl,b:bat[:dbl]) :bat[:dbl]
address CMDbatMODsignal
comment "Return V % B, signal error on divide by zero";
pattern %(v:dbl,b:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatMODsignal
comment "Return V % B with candidates list, signal error on divide by zero";
pattern mod_noerror(v:dbl,b:bat[:dbl]) :bat[:dbl]
address CMDbatMOD
comment "Return V % B, divide by zero causes NIL value";
pattern mod_noerror(v:dbl,b:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatMOD
comment "Return V % B with candidates list, divide by zero causes NIL value";


pattern and(b1:bat[:bit],b2:bat[:bit]) :bat[:bit]
address CMDbatAND
comment "Return B1 AND B2";
pattern and(b1:bat[:bit],b2:bat[:bit],s:bat[:oid]) :bat[:bit]
address CMDbatAND
comment "Return B1 AND B2 with candidates list";
pattern and(b:bat[:bit],v:bit) :bat[:bit]
address CMDbatAND
comment "Return B AND V";
pattern and(b:bat[:bit],v:bit,s:bat[:oid]) :bat[:bit]
address CMDbatAND
comment "Return B AND V with candidates list";
pattern and(v:bit,b:bat[:bit]) :bat[:bit]
address CMDbatAND
comment "Return V AND B";
pattern and(v:bit,b:bat[:bit],s:bat[:oid]) :bat[:bit]
address CMDbatAND
comment "Return V AND B with candidates list";

pattern and(b1:bat[:bte],b2:bat[:bte]) :bat[:bte]
address CMDbatAND
comment "Return B1 AND B2";
pattern and(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]) :bat[:bte]
address CMDbatAND
comment "Return B1 AND B2 with candidates list";
pattern and(b:bat[:bte],v:bte) :bat[:bte]
address CMDbatAND
comment "Return B AND V";
pattern and(b:bat[:bte],v:bte,s:bat[:oid]) :bat[:bte]
address CMDbatAND
comment "Return B AND V with candidates list";
pattern and(v:bte,b:bat[:bte]) :bat[:bte]
address CMDbatAND
comment "Return V AND B";
pattern and(v:bte,b:bat[:bte],s:bat[:oid]) :bat[:bte]
address CMDbatAND
comment "Return V AND B with candidates list";

pattern and(b1:bat[:sht],b2:bat[:sht]) :bat[:sht]
address CMDbatAND
comment "Return B1 AND B2";
pattern and(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]) :bat[:sht]
address CMDbatAND
comment "Return B1 AND B2 with candidates list";
pattern and(b:bat[:sht],v:sht) :bat[:sht]
address CMDbatAND
comment "Return B AND V";
pattern and(b:bat[:sht],v:sht,s:bat[:oid]) :bat[:sht]
address CMDbatAND
comment "Return B AND V with candidates list";
pattern and(v:sht,b:bat[:sht]) :bat[:sht]
address CMDbatAND
comment "Return V AND B";
pattern and(v:sht,b:bat[:sht],s:bat[:oid]) :bat[:sht]
address CMDbatAND
comment "Return V AND B with candidates list";

pattern and(b1:bat[:int],b2:bat[:int]) :bat[:int]
address CMDbatAND
comment "Return B1 AND B2";
pattern and(b1:bat[:int],b2:bat[:int],s:bat[:oid]) :bat[:int]
address CMDbatAND
comment "Return B1 AND B2 with candidates list";
pattern and(b:bat[:int],v:int) :bat[:int]
address CMDbatAND
comment "Return B AND V";
pattern and(b:bat[:int],v:int,s:bat[:oid]) :bat[:int]
address CMDbatAND
comment "Return B AND V with candidates list";
pattern and(v:int,b:bat[:int]) :bat[:int]
address CMDbatAND
comment "Return V AND B";
pattern and(v:int,b:bat[:int],s:bat[:oid]) :bat[:int]
address CMDbatAND
comment "Return V AND B with candidates list";

pattern and(b1:bat[:lng],b2:bat[:lng]) :bat[:lng]
address CMDbatAND
comment "Return B1 AND B2";
pattern and(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]) :bat[:lng]
address CMDbatAND
comment "Return B1 AND B2 with candidates list";
pattern and(b:bat[:lng],v:lng) :bat[:lng]
address CMDbatAND
comment "Return B AND V";
pattern and(b:bat[:lng],v:lng,s:bat[:oid]) :bat[:lng]
address CMDbatAND
comment "Return B AND V with candidates list";
pattern and(v:lng,b:bat[:lng]) :bat[:lng]
address CMDbatAND
comment "Return V AND B";
pattern and(v:lng,b:bat[:lng],s:bat[:oid]) :bat[:lng]
address CMDbatAND
comment "Return V AND B with candidates list";


pattern or(b1:bat[:bit],b2:bat[:bit]) :bat[:bit]
address CMDbatOR
comment "Return B1 OR B2";
pattern or(b1:bat[:bit],b2:bat[:bit],s:bat[:oid]) :bat[:bit]
address CMDbatOR
comment "Return B1 OR B2 with candidates list";
pattern or(b:bat[:bit],v:bit) :bat[:bit]
address CMDbatOR
comment "Return B OR V";
pattern or(b:bat[:bit],v:bit,s:bat[:oid]) :bat[:bit]
address CMDbatOR
comment "Return B OR V with candidates list";
pattern or(v:bit,b:bat[:bit]) :bat[:bit]
address CMDbatOR
comment "Return V OR B";
pattern or(v:bit,b:bat[:bit],s:bat[:oid]) :bat[:bit]
address CMDbatOR
comment "Return V OR B with candidates list";

pattern or(b1:bat[:bte],b2:bat[:bte]) :bat[:bte]
address CMDbatOR
comment "Return B1 OR B2";
pattern or(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]) :bat[:bte]
address CMDbatOR
comment "Return B1 OR B2 with candidates list";
pattern or(b:bat[:bte],v:bte) :bat[:bte]
address CMDbatOR
comment "Return B OR V";
pattern or(b:bat[:bte],v:bte,s:bat[:oid]) :bat[:bte]
address CMDbatOR
comment "Return B OR V with candidates list";
pattern or(v:bte,b:bat[:bte]) :bat[:bte]
address CMDbatOR
comment "Return V OR B";
pattern or(v:bte,b:bat[:bte],s:bat[:oid]) :bat[:bte]
address CMDbatOR
comment "Return V OR B with candidates list";

pattern or(b1:bat[:sht],b2:bat[:sht]) :bat[:sht]
address CMDbatOR
comment "Return B1 OR B2";
pattern or(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]) :bat[:sht]
address CMDbatOR
comment "Return B1 OR B2 with candidates list";
pattern or(b:bat[:sht],v:sht) :bat[:sht]
address CMDbatOR
comment "Return B OR V";
pattern or(b:bat[:sht],v:sht,s:bat[:oid]) :bat[:sht]
address CMDbatOR
comment "Return B OR V with candidates list";
pattern or(v:sht,b:bat[:sht]) :bat[:sht]
address CMDbatOR
comment "Return V OR B";
pattern or(v:sht,b:bat[:sht],s:bat[:oid]) :bat[:sht]
address CMDbatOR
comment "Return V OR B with candidates list";

pattern or(b1:bat[:int],b2:bat[:int]) :bat[:int]
address CMDbatOR
comment "Return B1 OR B2";
pattern or(b1:bat[:int],b2:bat[:int],s:bat[:oid]) :bat[:int]
address CMDbatOR
comment "Return B1 OR B2 with candidates list";
pattern or(b:bat[:int],v:int) :bat[:int]
address CMDbatOR
comment "Return B OR V";
pattern or(b:bat[:int],v:int,s:bat[:oid]) :bat[:int]
address CMDbatOR
comment "Return B OR V with candidates list";
pattern or(v:int,b:bat[:int]) :bat[:int]
address CMDbatOR
comment "Return V OR B";
pattern or(v:int,b:bat[:int],s:bat[:oid]) :bat[:int]
address CMDbatOR
comment "Return V OR B with candidates list";

pattern or(b1:bat[:lng],b2:bat[:lng]) :bat[:lng]
address CMDbatOR
comment "Return B1 OR B2";
pattern or(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]) :bat[:lng]
address CMDbatOR
comment "Return B1 OR B2 with candidates list";
pattern or(b:bat[:lng],v:lng) :bat[:lng]
address CMDbatOR
comment "Return B OR V";
pattern or(b:bat[:lng],v:lng,s:bat[:oid]) :bat[:lng]
address CMDbatOR
comment "Return B OR V with candidates list";
pattern or(v:lng,b:bat[:lng]) :bat[:lng]
address CMDbatOR
comment "Return V OR B";
pattern or(v:lng,b:bat[:lng],s:bat[:oid]) :bat[:lng]
address CMDbatOR
comment "Return V OR B with candidates list";


pattern xor(b1:bat[:bit],b2:bat[:bit]) :bat[:bit]
address CMDbatXOR
comment "Return B1 XOR B2";
pattern xor(b1:bat[:bit],b2:bat[:bit],s:bat[:oid]) :bat[:bit]
address CMDbatXOR
comment "Return B1 XOR B2 with candidates list";
pattern xor(b:bat[:bit],v:bit) :bat[:bit]
address CMDbatXOR
comment "Return B XOR V";
pattern xor(b:bat[:bit],v:bit,s:bat[:oid]) :bat[:bit]
address CMDbatXOR
comment "Return B XOR V with candidates list";
pattern xor(v:bit,b:bat[:bit]) :bat[:bit]
address CMDbatXOR
comment "Return V XOR B";
pattern xor(v:bit,b:bat[:bit],s:bat[:oid]) :bat[:bit]
address CMDbatXOR
comment "Return V XOR B with candidates list";

pattern xor(b1:bat[:bte],b2:bat[:bte]) :bat[:bte]
address CMDbatXOR
comment "Return B1 XOR B2";
pattern xor(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]) :bat[:bte]
address CMDbatXOR
comment "Return B1 XOR B2 with candidates list";
pattern xor(b:bat[:bte],v:bte) :bat[:bte]
address CMDbatXOR
comment "Return B XOR V";
pattern xor(b:bat[:bte],v:bte,s:bat[:oid]) :bat[:bte]
address CMDbatXOR
comment "Return B XOR V with candidates list";
pattern xor(v:bte,b:bat[:bte]) :bat[:bte]
address CMDbatXOR
comment "Return V XOR B";
pattern xor(v:bte,b:bat[:bte],s:bat[:oid]) :bat[:bte]
address CMDbatXOR
comment "Return V XOR B with candidates list";

pattern xor(b1:bat[:sht],b2:bat[:sht]) :bat[:sht]
address CMDbatXOR
comment "Return B1 XOR B2";
pattern xor(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]) :bat[:sht]
address CMDbatXOR
comment "Return B1 XOR B2 with candidates list";
pattern xor(b:bat[:sht],v:sht) :bat[:sht]
address CMDbatXOR
comment "Return B XOR V";
pattern xor(b:bat[:sht],v:sht,s:bat[:oid]) :bat[:sht]
address CMDbatXOR
comment "Return B XOR V with candidates list";
pattern xor(v:sht,b:bat[:sht]) :bat[:sht]
address CMDbatXOR
comment "Return V XOR B";
pattern xor(v:sht,b:bat[:sht],s:bat[:oid]) :bat[:sht]
address CMDbatXOR
comment "Return V XOR B with candidates list";

pattern xor(b1:bat[:int],b2:bat[:int]) :bat[:int]
address CMDbatXOR
comment "Return B1 XOR B2";
pattern xor(b1:bat[:int],b2:bat[:int],s:bat[:oid]) :bat[:int]
address CMDbatXOR
comment "Return B1 XOR B2 with candidates list";
pattern xor(b:bat[:int],v:int) :bat[:int]
address CMDbatXOR
comment "Return B XOR V";
pattern xor(b:bat[:int],v:int,s:bat[:oid]) :bat[:int]
address CMDbatXOR
comment "Return B XOR V with candidates list";
pattern xor(v:int,b:bat[:int]) :bat[:int]
address CMDbatXOR
comment "Return V XOR B";
pattern xor(v:int,b:bat[:int],s:bat[:oid]) :bat[:int]
address CMDbatXOR
comment "Return V XOR B with candidates list";

pattern xor(b1:bat[:lng],b2:bat[:lng]) :bat[:lng]
address CMDbatXOR
comment "Return B1 XOR B2";
pattern xor(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]) :bat[:lng]
address CMDbatXOR
comment "Return B1 XOR B2 with candidates list";
pattern xor(b:bat[:lng],v:lng) :bat[:lng]
address CMDbatXOR
comment "Return B XOR V";
pattern xor(b:bat[:lng],v:lng,s:bat[:oid]) :bat[:lng]
address CMDbatXOR
comment "Return B XOR V with candidates list";
pattern xor(v:lng,b:bat[:lng]) :bat[:lng]
address CMDbatXOR
comment "Return V XOR B";
pattern xor(v:lng,b:bat[:lng],s:bat[:oid]) :bat[:lng]
address CMDbatXOR
comment "Return V XOR B with candidates list";


pattern <<(b1:bat[:bte],b2:bat[:bte]) :bat[:bte]
address CMDbatLSHsignal
comment "Return B1 << B2, raise error on out of range second operand";
pattern <<(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]) :bat[:bte]
address CMDbatLSHsignal
comment "Return B1 << B2 with candidates list, raise error on out of range second operand";
pattern lsh_noerror(b1:bat[:bte],b2:bat[:bte]) :bat[:bte]
address CMDbatLSH
comment "Return B1 << B2, out of range second operand causes NIL value";
pattern lsh_noerror(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]) :bat[:bte]
address CMDbatLSH
comment "Return B1 << B2 with candidates list, out of range second operand causes NIL value";
pattern <<(b:bat[:bte],v:bte) :bat[:bte]
address CMDbatLSHsignal
comment "Return B << V, raise error on out of range second operand";
pattern <<(b:bat[:bte],v:bte,s:bat[:oid]) :bat[:bte]
address CMDbatLSHsignal
comment "Return B << V with candidates list, raise error on out of range second operand";
pattern lsh_noerror(b:bat[:bte],v:bte) :bat[:bte]
address CMDbatLSH
comment "Return B << V, out of range second operand causes NIL value";
pattern lsh_noerror(b:bat[:bte],v:bte,s:bat[:oid]) :bat[:bte]
address CMDbatLSH
comment "Return B << V with candidates list, out of range second operand causes NIL value";
pattern <<(v:bte,b:bat[:bte]) :bat[:bte]
address CMDbatLSHsignal
comment "Return V << B, raise error on out of range second operand";
pattern <<(v:bte,b:bat[:bte],s:bat[:oid]) :bat[:bte]
address CMDbatLSHsignal
comment "Return V << B with candidates list, raise error on out of range second operand";
pattern lsh_noerror(v:bte,b:bat[:bte]) :bat[:bte]
address CMDbatLSH
comment "Return V << B, out of range second operand causes NIL value";
pattern lsh_noerror(v:bte,b:bat[:bte],s:bat[:oid]) :bat[:bte]
address CMDbatLSH
comment "Return V << B with candidates list, out of range second operand causes NIL value";

pattern <<(b1:bat[:bte],b2:bat[:sht]) :bat[:bte]
address CMDbatLSHsignal
comment "Return B1 << B2, raise error on out of range second operand";
pattern <<(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]) :bat[:bte]
address CMDbatLSHsignal
comment "Return B1 << B2 with candidates list, raise error on out of range second operand";
pattern lsh_noerror(b1:bat[:bte],b2:bat[:sht]) :bat[:bte]
address CMDbatLSH
comment "Return B1 << B2, out of range second operand causes NIL value";
pattern lsh_noerror(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]) :bat[:bte]
address CMDbatLSH
comment "Return B1 << B2 with candidates list, out of range second operand causes NIL value";
pattern <<(b:bat[:bte],v:sht) :bat[:bte]
address CMDbatLSHsignal
comment "Return B << V, raise error on out of range second operand";
pattern <<(b:bat[:bte],v:sht,s:bat[:oid]) :bat[:bte]
address CMDbatLSHsignal
comment "Return B << V with candidates list, raise error on out of range second operand";
pattern lsh_noerror(b:bat[:bte],v:sht) :bat[:bte]
address CMDbatLSH
comment "Return B << V, out of range second operand causes NIL value";
pattern lsh_noerror(b:bat[:bte],v:sht,s:bat[:oid]) :bat[:bte]
address CMDbatLSH
comment "Return B << V with candidates list, out of range second operand causes NIL value";
pattern <<(v:bte,b:bat[:sht]) :bat[:bte]
address CMDbatLSHsignal
comment "Return V << B, raise error on out of range second operand";
pattern <<(v:bte,b:bat[:sht],s:bat[:oid]) :bat[:bte]
address CMDbatLSHsignal
comment "Return V << B with candidates list, raise error on out of range second operand";
pattern lsh_noerror(v:bte,b:bat[:sht]) :bat[:bte]
address CMDbatLSH
comment "Return V << B, out of range second operand causes NIL value";
pattern lsh_noerror(v:bte,b:bat[:sht],s:bat[:oid]) :bat[:bte]
address CMDbatLSH
comment "Return V << B with candidates list, out of range second operand causes NIL value";

pattern <<(b1:bat[:bte],b2:bat[:int]) :bat[:bte]
address CMDbatLSHsignal
comment "Return B1 << B2, raise error on out of range second operand";
pattern <<(b1:bat[:bte],b2:bat[:int],s:bat[:oid]) :bat[:bte]
address CMDbatLSHsignal
comment "Return B1 << B2 with candidates list, raise error on out of range second operand";
pattern lsh_noerror(b1:bat[:bte],b2:bat[:int]) :bat[:bte]
address CMDbatLSH
comment "Return B1 << B2, out of range second operand causes NIL value";
pattern lsh_noerror(b1:bat[:bte],b2:bat[:int],s:bat[:oid]) :bat[:bte]
address CMDbatLSH
comment "Return B1 << B2 with candidates list, out of range second operand causes NIL value";
pattern <<(b:bat[:bte],v:int) :bat[:bte]
address CMDbatLSHsignal
comment "Return B << V, raise error on out of range second operand";
pattern <<(b:bat[:bte],v:int,s:bat[:oid]) :bat[:bte]
address CMDbatLSHsignal
comment "Return B << V with candidates list, raise error on out of range second operand";
pattern lsh_noerror(b:bat[:bte],v:int) :bat[:bte]
address CMDbatLSH
comment "Return B << V, out of range second operand causes NIL value";
pattern lsh_noerror(b:bat[:bte],v:int,s:bat[:oid]) :bat[:bte]
address CMDbatLSH
comment "Return B << V with candidates list, out of range second operand causes NIL value";
pattern <<(v:bte,b:bat[:int]) :bat[:bte]
address CMDbatLSHsignal
comment "Return V << B, raise error on out of range second operand";
pattern <<(v:bte,b:bat[:int],s:bat[:oid]) :bat[:bte]
address CMDbatLSHsignal
comment "Return V << B with candidates list, raise error on out of range second operand";
pattern lsh_noerror(v:bte,b:bat[:int]) :bat[:bte]
address CMDbatLSH
comment "Return V << B, out of range second operand causes NIL value";
pattern lsh_noerror(v:bte,b:bat[:int],s:bat[:oid]) :bat[:bte]
address CMDbatLSH
comment "Return V << B with candidates list, out of range second operand causes NIL value";

pattern <<(b1:bat[:bte],b2:bat[:lng]) :bat[:bte]
address CMDbatLSHsignal
comment "Return B1 << B2, raise error on out of range second operand";
pattern <<(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]) :bat[:bte]
address CMDbatLSHsignal
comment "Return B1 << B2 with candidates list, raise error on out of range second operand";
pattern lsh_noerror(b1:bat[:bte],b2:bat[:lng]) :bat[:bte]
address CMDbatLSH
comment "Return B1 << B2, out of range second operand causes NIL value";
pattern lsh_noerror(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]) :bat[:bte]
address CMDbatLSH
comment "Return B1 << B2 with candidates list, out of range second operand causes NIL value";
pattern <<(b:bat[:bte],v:lng) :bat[:bte]
address CMDbatLSHsignal
comment "Return B << V, raise error on out of range second operand";
pattern <<(b:bat[:bte],v:lng,s:bat[:oid]) :bat[:bte]
address CMDbatLSHsignal
comment "Return B << V with candidates list, raise error on out of range second operand";
pattern lsh_noerror(b:bat[:bte],v:lng) :bat[:bte]
address CMDbatLSH
comment "Return B << V, out of range second operand causes NIL value";
pattern lsh_noerror(b:bat[:bte],v:lng,s:bat[:oid]) :bat[:bte]
address CMDbatLSH
comment "Return B << V with candidates list, out of range second operand causes NIL value";
pattern <<(v:bte,b:bat[:lng]) :bat[:bte]
address CMDbatLSHsignal
comment "Return V << B, raise error on out of range second operand";
pattern <<(v:bte,b:bat[:lng],s:bat[:oid]) :bat[:bte]
address CMDbatLSHsignal
comment "Return V << B with candidates list, raise error on out of range second operand";
pattern lsh_noerror(v:bte,b:bat[:lng]) :bat[:bte]
address CMDbatLSH
comment "Return V << B, out of range second operand causes NIL value";
pattern lsh_noerror(v:bte,b:bat[:lng],s:bat[:oid]) :bat[:bte]
address CMDbatLSH
comment "Return V << B with candidates list, out of range second operand causes NIL value";

pattern <<(b1:bat[:sht],b2:bat[:bte]) :bat[:sht]
address CMDbatLSHsignal
comment "Return B1 << B2, raise error on out of range second operand";
pattern <<(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]) :bat[:sht]
address CMDbatLSHsignal
comment "Return B1 << B2 with candidates list, raise error on out of range second operand";
pattern lsh_noerror(b1:bat[:sht],b2:bat[:bte]) :bat[:sht]
address CMDbatLSH
comment "Return B1 << B2, out of range second operand causes NIL value";
pattern lsh_noerror(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]) :bat[:sht]
address CMDbatLSH
comment "Return B1 << B2 with candidates list, out of range second operand causes NIL value";
pattern <<(b:bat[:sht],v:bte) :bat[:sht]
address CMDbatLSHsignal
comment "Return B << V, raise error on out of range second operand";
pattern <<(b:bat[:sht],v:bte,s:bat[:oid]) :bat[:sht]
address CMDbatLSHsignal
comment "Return B << V with candidates list, raise error on out of range second operand";
pattern lsh_noerror(b:bat[:sht],v:bte) :bat[:sht]
address CMDbatLSH
comment "Return B << V, out of range second operand causes NIL value";
pattern lsh_noerror(b:bat[:sht],v:bte,s:bat[:oid]) :bat[:sht]
address CMDbatLSH
comment "Return B << V with candidates list, out of range second operand causes NIL value";
pattern <<(v:sht,b:bat[:bte]) :bat[:sht]
address CMDbatLSHsignal
comment "Return V << B, raise error on out of range second operand";
pattern <<(v:sht,b:bat[:bte],s:bat[:oid]) :bat[:sht]
address CMDbatLSHsignal
comment "Return V << B with candidates list, raise error on out of range second operand";
pattern lsh_noerror(v:sht,b:bat[:bte]) :bat[:sht]
address CMDbatLSH
comment "Return V << B, out of range second operand causes NIL value";
pattern lsh_noerror(v:sht,b:bat[:bte],s:bat[:oid]) :bat[:sht]
address CMDbatLSH
comment "Return V << B with candidates list, out of range second operand causes NIL value";

pattern <<(b1:bat[:sht],b2:bat[:sht]) :bat[:sht]
address CMDbatLSHsignal
comment "Return B1 << B2, raise error on out of range second operand";
pattern <<(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]) :bat[:sht]
address CMDbatLSHsignal
comment "Return B1 << B2 with candidates list, raise error on out of range second operand";
pattern lsh_noerror(b1:bat[:sht],b2:bat[:sht]) :bat[:sht]
address CMDbatLSH
comment "Return B1 << B2, out of range second operand causes NIL value";
pattern lsh_noerror(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]) :bat[:sht]
address CMDbatLSH
comment "Return B1 << B2 with candidates list, out of range second operand causes NIL value";
pattern <<(b:bat[:sht],v:sht) :bat[:sht]
address CMDbatLSHsignal
comment "Return B << V, raise error on out of range second operand";
pattern <<(b:bat[:sht],v:sht,s:bat[:oid]) :bat[:sht]
address CMDbatLSHsignal
comment "Return B << V with candidates list, raise error on out of range second operand";
pattern lsh_noerror(b:bat[:sht],v:sht) :bat[:sht]
address CMDbatLSH
comment "Return B << V, out of range second operand causes NIL value";
pattern lsh_noerror(b:bat[:sht],v:sht,s:bat[:oid]) :bat[:sht]
address CMDbatLSH
comment "Return B << V with candidates list, out of range second operand causes NIL value";
pattern <<(v:sht,b:bat[:sht]) :bat[:sht]
address CMDbatLSHsignal
comment "Return V << B, raise error on out of range second operand";
pattern <<(v:sht,b:bat[:sht],s:bat[:oid]) :bat[:sht]
address CMDbatLSHsignal
comment "Return V << B with candidates list, raise error on out of range second operand";
pattern lsh_noerror(v:sht,b:bat[:sht]) :bat[:sht]
address CMDbatLSH
comment "Return V << B, out of range second operand causes NIL value";
pattern lsh_noerror(v:sht,b:bat[:sht],s:bat[:oid]) :bat[:sht]
address CMDbatLSH
comment "Return V << B with candidates list, out of range second operand causes NIL value";

pattern <<(b1:bat[:sht],b2:bat[:int]) :bat[:sht]
address CMDbatLSHsignal
comment "Return B1 << B2, raise error on out of range second operand";
pattern <<(b1:bat[:sht],b2:bat[:int],s:bat[:oid]) :bat[:sht]
address CMDbatLSHsignal
comment "Return B1 << B2 with candidates list, raise error on out of range second operand";
pattern lsh_noerror(b1:bat[:sht],b2:bat[:int]) :bat[:sht]
address CMDbatLSH
comment "Return B1 << B2, out of range second operand causes NIL value";
pattern lsh_noerror(b1:bat[:sht],b2:bat[:int],s:bat[:oid]) :bat[:sht]
address CMDbatLSH
comment "Return B1 << B2 with candidates list, out of range second operand causes NIL value";
pattern <<(b:bat[:sht],v:int) :bat[:sht]
address CMDbatLSHsignal
comment "Return B << V, raise error on out of range second operand";
pattern <<(b:bat[:sht],v:int,s:bat[:oid]) :bat[:sht]
address CMDbatLSHsignal
comment "Return B << V with candidates list, raise error on out of range second operand";
pattern lsh_noerror(b:bat[:sht],v:int) :bat[:sht]
address CMDbatLSH
comment "Return B << V, out of range second operand causes NIL value";
pattern lsh_noerror(b:bat[:sht],v:int,s:bat[:oid]) :bat[:sht]
address CMDbatLSH
comment "Return B << V with candidates list, out of range second operand causes NIL value";
pattern <<(v:sht,b:bat[:int]) :bat[:sht]
address CMDbatLSHsignal
comment "Return V << B, raise error on out of range second operand";
pattern <<(v:sht,b:bat[:int],s:bat[:oid]) :bat[:sht]
address CMDbatLSHsignal
comment "Return V << B with candidates list, raise error on out of range second operand";
pattern lsh_noerror(v:sht,b:bat[:int]) :bat[:sht]
address CMDbatLSH
comment "Return V << B, out of range second operand causes NIL value";
pattern lsh_noerror(v:sht,b:bat[:int],s:bat[:oid]) :bat[:sht]
address CMDbatLSH
comment "Return V << B with candidates list, out of range second operand causes NIL value";

pattern <<(b1:bat[:sht],b2:bat[:lng]) :bat[:sht]
address CMDbatLSHsignal
comment "Return B1 << B2, raise error on out of range second operand";
pattern <<(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]) :bat[:sht]
address CMDbatLSHsignal
comment "Return B1 << B2 with candidates list, raise error on out of range second operand";
pattern lsh_noerror(b1:bat[:sht],b2:bat[:lng]) :bat[:sht]
address CMDbatLSH
comment "Return B1 << B2, out of range second operand causes NIL value";
pattern lsh_noerror(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]) :bat[:sht]
address CMDbatLSH
comment "Return B1 << B2 with candidates list, out of range second operand causes NIL value";
pattern <<(b:bat[:sht],v:lng) :bat[:sht]
address CMDbatLSHsignal
comment "Return B << V, raise error on out of range second operand";
pattern <<(b:bat[:sht],v:lng,s:bat[:oid]) :bat[:sht]
address CMDbatLSHsignal
comment "Return B << V with candidates list, raise error on out of range second operand";
pattern lsh_noerror(b:bat[:sht],v:lng) :bat[:sht]
address CMDbatLSH
comment "Return B << V, out of range second operand causes NIL value";
pattern lsh_noerror(b:bat[:sht],v:lng,s:bat[:oid]) :bat[:sht]
address CMDbatLSH
comment "Return B << V with candidates list, out of range second operand causes NIL value";
pattern <<(v:sht,b:bat[:lng]) :bat[:sht]
address CMDbatLSHsignal
comment "Return V << B, raise error on out of range second operand";
pattern <<(v:sht,b:bat[:lng],s:bat[:oid]) :bat[:sht]
address CMDbatLSHsignal
comment "Return V << B with candidates list, raise error on out of range second operand";
pattern lsh_noerror(v:sht,b:bat[:lng]) :bat[:sht]
address CMDbatLSH
comment "Return V << B, out of range second operand causes NIL value";
pattern lsh_noerror(v:sht,b:bat[:lng],s:bat[:oid]) :bat[:sht]
address CMDbatLSH
comment "Return V << B with candidates list, out of range second operand causes NIL value";

pattern <<(b1:bat[:int],b2:bat[:bte]) :bat[:int]
address CMDbatLSHsignal
comment "Return B1 << B2, raise error on out of range second operand";
pattern <<(b1:bat[:int],b2:bat[:bte],s:bat[:oid]) :bat[:int]
address CMDbatLSHsignal
comment "Return B1 << B2 with candidates list, raise error on out of range second operand";
pattern lsh_noerror(b1:bat[:int],b2:bat[:bte]) :bat[:int]
address CMDbatLSH
comment "Return B1 << B2, out of range second operand causes NIL value";
pattern lsh_noerror(b1:bat[:int],b2:bat[:bte],s:bat[:oid]) :bat[:int]
address CMDbatLSH
comment "Return B1 << B2 with candidates list, out of range second operand causes NIL value";
pattern <<(b:bat[:int],v:bte) :bat[:int]
address CMDbatLSHsignal
comment "Return B << V, raise error on out of range second operand";
pattern <<(b:bat[:int],v:bte,s:bat[:oid]) :bat[:int]
address CMDbatLSHsignal
comment "Return B << V with candidates list, raise error on out of range second operand";
pattern lsh_noerror(b:bat[:int],v:bte) :bat[:int]
address CMDbatLSH
comment "Return B << V, out of range second operand causes NIL value";
pattern lsh_noerror(b:bat[:int],v:bte,s:bat[:oid]) :bat[:int]
address CMDbatLSH
comment "Return B << V with candidates list, out of range second operand causes NIL value";
pattern <<(v:int,b:bat[:bte]) :bat[:int]
address CMDbatLSHsignal
comment "Return V << B, raise error on out of range second operand";
pattern <<(v:int,b:bat[:bte],s:bat[:oid]) :bat[:int]
address CMDbatLSHsignal
comment "Return V << B with candidates list, raise error on out of range second operand";
pattern lsh_noerror(v:int,b:bat[:bte]) :bat[:int]
address CMDbatLSH
comment "Return V << B, out of range second operand causes NIL value";
pattern lsh_noerror(v:int,b:bat[:bte],s:bat[:oid]) :bat[:int]
address CMDbatLSH
comment "Return V << B with candidates list, out of range second operand causes NIL value";

pattern <<(b1:bat[:int],b2:bat[:sht]) :bat[:int]
address CMDbatLSHsignal
comment "Return B1 << B2, raise error on out of range second operand";
pattern <<(b1:bat[:int],b2:bat[:sht],s:bat[:oid]) :bat[:int]
address CMDbatLSHsignal
comment "Return B1 << B2 with candidates list, raise error on out of range second operand";
pattern lsh_noerror(b1:bat[:int],b2:bat[:sht]) :bat[:int]
address CMDbatLSH
comment "Return B1 << B2, out of range second operand causes NIL value";
pattern lsh_noerror(b1:bat[:int],b2:bat[:sht],s:bat[:oid]) :bat[:int]
address CMDbatLSH
comment "Return B1 << B2 with candidates list, out of range second operand causes NIL value";
pattern <<(b:bat[:int],v:sht) :bat[:int]
address CMDbatLSHsignal
comment "Return B << V, raise error on out of range second operand";
pattern <<(b:bat[:int],v:sht,s:bat[:oid]) :bat[:int]
address CMDbatLSHsignal
comment "Return B << V with candidates list, raise error on out of range second operand";
pattern lsh_noerror(b:bat[:int],v:sht) :bat[:int]
address CMDbatLSH
comment "Return B << V, out of range second operand causes NIL value";
pattern lsh_noerror(b:bat[:int],v:sht,s:bat[:oid]) :bat[:int]
address CMDbatLSH
comment "Return B << V with candidates list, out of range second operand causes NIL value";
pattern <<(v:int,b:bat[:sht]) :bat[:int]
address CMDbatLSHsignal
comment "Return V << B, raise error on out of range second operand";
pattern <<(v:int,b:bat[:sht],s:bat[:oid]) :bat[:int]
address CMDbatLSHsignal
comment "Return V << B with candidates list, raise error on out of range second operand";
pattern lsh_noerror(v:int,b:bat[:sht]) :bat[:int]
address CMDbatLSH
comment "Return V << B, out of range second operand causes NIL value";
pattern lsh_noerror(v:int,b:bat[:sht],s:bat[:oid]) :bat[:int]
address CMDbatLSH
comment "Return V << B with candidates list, out of range second operand causes NIL value";

pattern <<(b1:bat[:int],b2:bat[:int]) :bat[:int]
address CMDbatLSHsignal
comment "Return B1 << B2, raise error on out of range second operand";
pattern <<(b1:bat[:int],b2:bat[:int],s:bat[:oid]) :bat[:int]
address CMDbatLSHsignal
comment "Return B1 << B2 with candidates list, raise error on out of range second operand";
pattern lsh_noerror(b1:bat[:int],b2:bat[:int]) :bat[:int]
address CMDbatLSH
comment "Return B1 << B2, out of range second operand causes NIL value";
pattern lsh_noerror(b1:bat[:int],b2:bat[:int],s:bat[:oid]) :bat[:int]
address CMDbatLSH
comment "Return B1 << B2 with candidates list, out of range second operand causes NIL value";
pattern <<(b:bat[:int],v:int) :bat[:int]
address CMDbatLSHsignal
comment "Return B << V, raise error on out of range second operand";
pattern <<(b:bat[:int],v:int,s:bat[:oid]) :bat[:int]
address CMDbatLSHsignal
comment "Return B << V with candidates list, raise error on out of range second operand";
pattern lsh_noerror(b:bat[:int],v:int) :bat[:int]
address CMDbatLSH
comment "Return B << V, out of range second operand causes NIL value";
pattern lsh_noerror(b:bat[:int],v:int,s:bat[:oid]) :bat[:int]
address CMDbatLSH
comment "Return B << V with candidates list, out of range second operand causes NIL value";
pattern <<(v:int,b:bat[:int]) :bat[:int]
address CMDbatLSHsignal
comment "Return V << B, raise error on out of range second operand";
pattern <<(v:int,b:bat[:int],s:bat[:oid]) :bat[:int]
address CMDbatLSHsignal
comment "Return V << B with candidates list, raise error on out of range second operand";
pattern lsh_noerror(v:int,b:bat[:int]) :bat[:int]
address CMDbatLSH
comment "Return V << B, out of range second operand causes NIL value";
pattern lsh_noerror(v:int,b:bat[:int],s:bat[:oid]) :bat[:int]
address CMDbatLSH
comment "Return V << B with candidates list, out of range second operand causes NIL value";

pattern <<(b1:bat[:int],b2:bat[:lng]) :bat[:int]
address CMDbatLSHsignal
comment "Return B1 << B2, raise error on out of range second operand";
pattern <<(b1:bat[:int],b2:bat[:lng],s:bat[:oid]) :bat[:int]
address CMDbatLSHsignal
comment "Return B1 << B2 with candidates list, raise error on out of range second operand";
pattern lsh_noerror(b1:bat[:int],b2:bat[:lng]) :bat[:int]
address CMDbatLSH
comment "Return B1 << B2, out of range second operand causes NIL value";
pattern lsh_noerror(b1:bat[:int],b2:bat[:lng],s:bat[:oid]) :bat[:int]
address CMDbatLSH
comment "Return B1 << B2 with candidates list, out of range second operand causes NIL value";
pattern <<(b:bat[:int],v:lng) :bat[:int]
address CMDbatLSHsignal
comment "Return B << V, raise error on out of range second operand";
pattern <<(b:bat[:int],v:lng,s:bat[:oid]) :bat[:int]
address CMDbatLSHsignal
comment "Return B << V with candidates list, raise error on out of range second operand";
pattern lsh_noerror(b:bat[:int],v:lng) :bat[:int]
address CMDbatLSH
comment "Return B << V, out of range second operand causes NIL value";
pattern lsh_noerror(b:bat[:int],v:lng,s:bat[:oid]) :bat[:int]
address CMDbatLSH
comment "Return B << V with candidates list, out of range second operand causes NIL value";
pattern <<(v:int,b:bat[:lng]) :bat[:int]
address CMDbatLSHsignal
comment "Return V << B, raise error on out of range second operand";
pattern <<(v:int,b:bat[:lng],s:bat[:oid]) :bat[:int]
address CMDbatLSHsignal
comment "Return V << B with candidates list, raise error on out of range second operand";
pattern lsh_noerror(v:int,b:bat[:lng]) :bat[:int]
address CMDbatLSH
comment "Return V << B, out of range second operand causes NIL value";
pattern lsh_noerror(v:int,b:bat[:lng],s:bat[:oid]) :bat[:int]
address CMDbatLSH
comment "Return V << B with candidates list, out of range second operand causes NIL value";

pattern <<(b1:bat[:lng],b2:bat[:bte]) :bat[:lng]
address CMDbatLSHsignal
comment "Return B1 << B2, raise error on out of range second operand";
pattern <<(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]) :bat[:lng]
address CMDbatLSHsignal
comment "Return B1 << B2 with candidates list, raise error on out of range second operand";
pattern lsh_noerror(b1:bat[:lng],b2:bat[:bte]) :bat[:lng]
address CMDbatLSH
comment "Return B1 << B2, out of range second operand causes NIL value";
pattern lsh_noerror(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]) :bat[:lng]
address CMDbatLSH
comment "Return B1 << B2 with candidates list, out of range second operand causes NIL value";
pattern <<(b:bat[:lng],v:bte) :bat[:lng]
address CMDbatLSHsignal
comment "Return B << V, raise error on out of range second operand";
pattern <<(b:bat[:lng],v:bte,s:bat[:oid]) :bat[:lng]
address CMDbatLSHsignal
comment "Return B << V with candidates list, raise error on out of range second operand";
pattern lsh_noerror(b:bat[:lng],v:bte) :bat[:lng]
address CMDbatLSH
comment "Return B << V, out of range second operand causes NIL value";
pattern lsh_noerror(b:bat[:lng],v:bte,s:bat[:oid]) :bat[:lng]
address CMDbatLSH
comment "Return B << V with candidates list, out of range second operand causes NIL value";
pattern <<(v:lng,b:bat[:bte]) :bat[:lng]
address CMDbatLSHsignal
comment "Return V << B, raise error on out of range second operand";
pattern <<(v:lng,b:bat[:bte],s:bat[:oid]) :bat[:lng]
address CMDbatLSHsignal
comment "Return V << B with candidates list, raise error on out of range second operand";
pattern lsh_noerror(v:lng,b:bat[:bte]) :bat[:lng]
address CMDbatLSH
comment "Return V << B, out of range second operand causes NIL value";
pattern lsh_noerror(v:lng,b:bat[:bte],s:bat[:oid]) :bat[:lng]
address CMDbatLSH
comment "Return V << B with candidates list, out of range second operand causes NIL value";

pattern <<(b1:bat[:lng],b2:bat[:sht]) :bat[:lng]
address CMDbatLSHsignal
comment "Return B1 << B2, raise error on out of range second operand";
pattern <<(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]) :bat[:lng]
address CMDbatLSHsignal
comment "Return B1 << B2 with candidates list, raise error on out of range second operand";
pattern lsh_noerror(b1:bat[:lng],b2:bat[:sht]) :bat[:lng]
address CMDbatLSH
comment "Return B1 << B2, out of range second operand causes NIL value";
pattern lsh_noerror(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]) :bat[:lng]
address CMDbatLSH
comment "Return B1 << B2 with candidates list, out of range second operand causes NIL value";
pattern <<(b:bat[:lng],v:sht) :bat[:lng]
address CMDbatLSHsignal
comment "Return B << V, raise error on out of range second operand";
pattern <<(b:bat[:lng],v:sht,s:bat[:oid]) :bat[:lng]
address CMDbatLSHsignal
comment "Return B << V with candidates list, raise error on out of range second operand";
pattern lsh_noerror(b:bat[:lng],v:sht) :bat[:lng]
address CMDbatLSH
comment "Return B << V, out of range second operand causes NIL value";
pattern lsh_noerror(b:bat[:lng],v:sht,s:bat[:oid]) :bat[:lng]
address CMDbatLSH
comment "Return B << V with candidates list, out of range second operand causes NIL value";
pattern <<(v:lng,b:bat[:sht]) :bat[:lng]
address CMDbatLSHsignal
comment "Return V << B, raise error on out of range second operand";
pattern <<(v:lng,b:bat[:sht],s:bat[:oid]) :bat[:lng]
address CMDbatLSHsignal
comment "Return V << B with candidates list, raise error on out of range second operand";
pattern lsh_noerror(v:lng,b:bat[:sht]) :bat[:lng]
address CMDbatLSH
comment "Return V << B, out of range second operand causes NIL value";
pattern lsh_noerror(v:lng,b:bat[:sht],s:bat[:oid]) :bat[:lng]
address CMDbatLSH
comment "Return V << B with candidates list, out of range second operand causes NIL value";

pattern <<(b1:bat[:lng],b2:bat[:int]) :bat[:lng]
address CMDbatLSHsignal
comment "Return B1 << B2, raise error on out of range second operand";
pattern <<(b1:bat[:lng],b2:bat[:int],s:bat[:oid]) :bat[:lng]
address CMDbatLSHsignal
comment "Return B1 << B2 with candidates list, raise error on out of range second operand";
pattern lsh_noerror(b1:bat[:lng],b2:bat[:int]) :bat[:lng]
address CMDbatLSH
comment "Return B1 << B2, out of range second operand causes NIL value";
pattern lsh_noerror(b1:bat[:lng],b2:bat[:int],s:bat[:oid]) :bat[:lng]
address CMDbatLSH
comment "Return B1 << B2 with candidates list, out of range second operand causes NIL value";
pattern <<(b:bat[:lng],v:int) :bat[:lng]
address CMDbatLSHsignal
comment "Return B << V, raise error on out of range second operand";
pattern <<(b:bat[:lng],v:int,s:bat[:oid]) :bat[:lng]
address CMDbatLSHsignal
comment "Return B << V with candidates list, raise error on out of range second operand";
pattern lsh_noerror(b:bat[:lng],v:int) :bat[:lng]
address CMDbatLSH
comment "Return B << V, out of range second operand causes NIL value";
pattern lsh_noerror(b:bat[:lng],v:int,s:bat[:oid]) :bat[:lng]
address CMDbatLSH
comment "Return B << V with candidates list, out of range second operand causes NIL value";
pattern <<(v:lng,b:bat[:int]) :bat[:lng]
address CMDbatLSHsignal
comment "Return V << B, raise error on out of range second operand";
pattern <<(v:lng,b:bat[:int],s:bat[:oid]) :bat[:lng]
address CMDbatLSHsignal
comment "Return V << B with candidates list, raise error on out of range second operand";
pattern lsh_noerror(v:lng,b:bat[:int]) :bat[:lng]
address CMDbatLSH
comment "Return V << B, out of range second operand causes NIL value";
pattern lsh_noerror(v:lng,b:bat[:int],s:bat[:oid]) :bat[:lng]
address CMDbatLSH
comment "Return V << B with candidates list, out of range second operand causes NIL value";

pattern <<(b1:bat[:lng],b2:bat[:lng]) :bat[:lng]
address CMDbatLSHsignal
comment "Return B1 << B2, raise error on out of range second operand";
pattern <<(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]) :bat[:lng]
address CMDbatLSHsignal
comment "Return B1 << B2 with candidates list, raise error on out of range second operand";
pattern lsh_noerror(b1:bat[:lng],b2:bat[:lng]) :bat[:lng]
address CMDbatLSH
comment "Return B1 << B2, out of range second operand causes NIL value";
pattern lsh_noerror(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]) :bat[:lng]
address CMDbatLSH
comment "Return B1 << B2 with candidates list, out of range second operand causes NIL value";
pattern <<(b:bat[:lng],v:lng) :bat[:lng]
address CMDbatLSHsignal
comment "Return B << V, raise error on out of range second operand";
pattern <<(b:bat[:lng],v:lng,s:bat[:oid]) :bat[:lng]
address CMDbatLSHsignal
comment "Return B << V with candidates list, raise error on out of range second operand";
pattern lsh_noerror(b:bat[:lng],v:lng) :bat[:lng]
address CMDbatLSH
comment "Return B << V, out of range second operand causes NIL value";
pattern lsh_noerror(b:bat[:lng],v:lng,s:bat[:oid]) :bat[:lng]
address CMDbatLSH
comment "Return B << V with candidates list, out of range second operand causes NIL value";
pattern <<(v:lng,b:bat[:lng]) :bat[:lng]
address CMDbatLSHsignal
comment "Return V << B, raise error on out of range second operand";
pattern <<(v:lng,b:bat[:lng],s:bat[:oid]) :bat[:lng]
address CMDbatLSHsignal
comment "Return V << B with candidates list, raise error on out of range second operand";
pattern lsh_noerror(v:lng,b:bat[:lng]) :bat[:lng]
address CMDbatLSH
comment "Return V << B, out of range second operand causes NIL value";
pattern lsh_noerror(v:lng,b:bat[:lng],s:bat[:oid]) :bat[:lng]
address CMDbatLSH
comment "Return V << B with candidates list, out of range second operand causes NIL value";


pattern >>(b1:bat[:bte],b2:bat[:bte]) :bat[:bte]
address CMDbatRSHsignal
comment "Return B1 >> B2, raise error on out of range second operand";
pattern >>(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]) :bat[:bte]
address CMDbatRSHsignal
comment "Return B1 >> B2 with candidates list, raise error on out of range second operand";
pattern rsh_noerror(b1:bat[:bte],b2:bat[:bte]) :bat[:bte]
address CMDbatRSH
comment "Return B1 >> B2, out of range second operand causes NIL value";
pattern rsh_noerror(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]) :bat[:bte]
address CMDbatRSH
comment "Return B1 >> B2 with candidates list, out of range second operand causes NIL value";
pattern >>(b:bat[:bte],v:bte) :bat[:bte]
address CMDbatRSHsignal
comment "Return B >> V, raise error on out of range second operand";
pattern >>(b:bat[:bte],v:bte,s:bat[:oid]) :bat[:bte]
address CMDbatRSHsignal
comment "Return B >> V with candidates list, raise error on out of range second operand";
pattern rsh_noerror(b:bat[:bte],v:bte) :bat[:bte]
address CMDbatRSH
comment "Return B >> V, out of range second operand causes NIL value";
pattern rsh_noerror(b:bat[:bte],v:bte,s:bat[:oid]) :bat[:bte]
address CMDbatRSH
comment "Return B >> V with candidates list, out of range second operand causes NIL value";
pattern >>(v:bte,b:bat[:bte]) :bat[:bte]
address CMDbatRSHsignal
comment "Return V >> B, raise error on out of range second operand";
pattern >>(v:bte,b:bat[:bte],s:bat[:oid]) :bat[:bte]
address CMDbatRSHsignal
comment "Return V >> B with candidates list, raise error on out of range second operand";
pattern rsh_noerror(v:bte,b:bat[:bte]) :bat[:bte]
address CMDbatRSH
comment "Return V >> B, out of range second operand causes NIL value";
pattern rsh_noerror(v:bte,b:bat[:bte],s:bat[:oid]) :bat[:bte]
address CMDbatRSH
comment "Return V >> B with candidates list, out of range second operand causes NIL value";

pattern >>(b1:bat[:bte],b2:bat[:sht]) :bat[:bte]
address CMDbatRSHsignal
comment "Return B1 >> B2, raise error on out of range second operand";
pattern >>(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]) :bat[:bte]
address CMDbatRSHsignal
comment "Return B1 >> B2 with candidates list, raise error on out of range second operand";
pattern rsh_noerror(b1:bat[:bte],b2:bat[:sht]) :bat[:bte]
address CMDbatRSH
comment "Return B1 >> B2, out of range second operand causes NIL value";
pattern rsh_noerror(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]) :bat[:bte]
address CMDbatRSH
comment "Return B1 >> B2 with candidates list, out of range second operand causes NIL value";
pattern >>(b:bat[:bte],v:sht) :bat[:bte]
address CMDbatRSHsignal
comment "Return B >> V, raise error on out of range second operand";
pattern >>(b:bat[:bte],v:sht,s:bat[:oid]) :bat[:bte]
address CMDbatRSHsignal
comment "Return B >> V with candidates list, raise error on out of range second operand";
pattern rsh_noerror(b:bat[:bte],v:sht) :bat[:bte]
address CMDbatRSH
comment "Return B >> V, out of range second operand causes NIL value";
pattern rsh_noerror(b:bat[:bte],v:sht,s:bat[:oid]) :bat[:bte]
address CMDbatRSH
comment "Return B >> V with candidates list, out of range second operand causes NIL value";
pattern >>(v:bte,b:bat[:sht]) :bat[:bte]
address CMDbatRSHsignal
comment "Return V >> B, raise error on out of range second operand";
pattern >>(v:bte,b:bat[:sht],s:bat[:oid]) :bat[:bte]
address CMDbatRSHsignal
comment "Return V >> B with candidates list, raise error on out of range second operand";
pattern rsh_noerror(v:bte,b:bat[:sht]) :bat[:bte]
address CMDbatRSH
comment "Return V >> B, out of range second operand causes NIL value";
pattern rsh_noerror(v:bte,b:bat[:sht],s:bat[:oid]) :bat[:bte]
address CMDbatRSH
comment "Return V >> B with candidates list, out of range second operand causes NIL value";

pattern >>(b1:bat[:bte],b2:bat[:int]) :bat[:bte]
address CMDbatRSHsignal
comment "Return B1 >> B2, raise error on out of range second operand";
pattern >>(b1:bat[:bte],b2:bat[:int],s:bat[:oid]) :bat[:bte]
address CMDbatRSHsignal
comment "Return B1 >> B2 with candidates list, raise error on out of range second operand";
pattern rsh_noerror(b1:bat[:bte],b2:bat[:int]) :bat[:bte]
address CMDbatRSH
comment "Return B1 >> B2, out of range second operand causes NIL value";
pattern rsh_noerror(b1:bat[:bte],b2:bat[:int],s:bat[:oid]) :bat[:bte]
address CMDbatRSH
comment "Return B1 >> B2 with candidates list, out of range second operand causes NIL value";
pattern >>(b:bat[:bte],v:int) :bat[:bte]
address CMDbatRSHsignal
comment "Return B >> V, raise error on out of range second operand";
pattern >>(b:bat[:bte],v:int,s:bat[:oid]) :bat[:bte]
address CMDbatRSHsignal
comment "Return B >> V with candidates list, raise error on out of range second operand";
pattern rsh_noerror(b:bat[:bte],v:int) :bat[:bte]
address CMDbatRSH
comment "Return B >> V, out of range second operand causes NIL value";
pattern rsh_noerror(b:bat[:bte],v:int,s:bat[:oid]) :bat[:bte]
address CMDbatRSH
comment "Return B >> V with candidates list, out of range second operand causes NIL value";
pattern >>(v:bte,b:bat[:int]) :bat[:bte]
address CMDbatRSHsignal
comment "Return V >> B, raise error on out of range second operand";
pattern >>(v:bte,b:bat[:int],s:bat[:oid]) :bat[:bte]
address CMDbatRSHsignal
comment "Return V >> B with candidates list, raise error on out of range second operand";
pattern rsh_noerror(v:bte,b:bat[:int]) :bat[:bte]
address CMDbatRSH
comment "Return V >> B, out of range second operand causes NIL value";
pattern rsh_noerror(v:bte,b:bat[:int],s:bat[:oid]) :bat[:bte]
address CMDbatRSH
comment "Return V >> B with candidates list, out of range second operand causes NIL value";

pattern >>(b1:bat[:bte],b2:bat[:lng]) :bat[:bte]
address CMDbatRSHsignal
comment "Return B1 >> B2, raise error on out of range second operand";
pattern >>(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]) :bat[:bte]
address CMDbatRSHsignal
comment "Return B1 >> B2 with candidates list, raise error on out of range second operand";
pattern rsh_noerror(b1:bat[:bte],b2:bat[:lng]) :bat[:bte]
address CMDbatRSH
comment "Return B1 >> B2, out of range second operand causes NIL value";
pattern rsh_noerror(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]) :bat[:bte]
address CMDbatRSH
comment "Return B1 >> B2 with candidates list, out of range second operand causes NIL value";
pattern >>(b:bat[:bte],v:lng) :bat[:bte]
address CMDbatRSHsignal
comment "Return B >> V, raise error on out of range second operand";
pattern >>(b:bat[:bte],v:lng,s:bat[:oid]) :bat[:bte]
address CMDbatRSHsignal
comment "Return B >> V with candidates list, raise error on out of range second operand";
pattern rsh_noerror(b:bat[:bte],v:lng) :bat[:bte]
address CMDbatRSH
comment "Return B >> V, out of range second operand causes NIL value";
pattern rsh_noerror(b:bat[:bte],v:lng,s:bat[:oid]) :bat[:bte]
address CMDbatRSH
comment "Return B >> V with candidates list, out of range second operand causes NIL value";
pattern >>(v:bte,b:bat[:lng]) :bat[:bte]
address CMDbatRSHsignal
comment "Return V >> B, raise error on out of range second operand";
pattern >>(v:bte,b:bat[:lng],s:bat[:oid]) :bat[:bte]
address CMDbatRSHsignal
comment "Return V >> B with candidates list, raise error on out of range second operand";
pattern rsh_noerror(v:bte,b:bat[:lng]) :bat[:bte]
address CMDbatRSH
comment "Return V >> B, out of range second operand causes NIL value";
pattern rsh_noerror(v:bte,b:bat[:lng],s:bat[:oid]) :bat[:bte]
address CMDbatRSH
comment "Return V >> B with candidates list, out of range second operand causes NIL value";

pattern >>(b1:bat[:sht],b2:bat[:bte]) :bat[:sht]
address CMDbatRSHsignal
comment "Return B1 >> B2, raise error on out of range second operand";
pattern >>(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]) :bat[:sht]
address CMDbatRSHsignal
comment "Return B1 >> B2 with candidates list, raise error on out of range second operand";
pattern rsh_noerror(b1:bat[:sht],b2:bat[:bte]) :bat[:sht]
address CMDbatRSH
comment "Return B1 >> B2, out of range second operand causes NIL value";
pattern rsh_noerror(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]) :bat[:sht]
address CMDbatRSH
comment "Return B1 >> B2 with candidates list, out of range second operand causes NIL value";
pattern >>(b:bat[:sht],v:bte) :bat[:sht]
address CMDbatRSHsignal
comment "Return B >> V, raise error on out of range second operand";
pattern >>(b:bat[:sht],v:bte,s:bat[:oid]) :bat[:sht]
address CMDbatRSHsignal
comment "Return B >> V with candidates list, raise error on out of range second operand";
pattern rsh_noerror(b:bat[:sht],v:bte) :bat[:sht]
address CMDbatRSH
comment "Return B >> V, out of range second operand causes NIL value";
pattern rsh_noerror(b:bat[:sht],v:bte,s:bat[:oid]) :bat[:sht]
address CMDbatRSH
comment "Return B >> V with candidates list, out of range second operand causes NIL value";
pattern >>(v:sht,b:bat[:bte]) :bat[:sht]
address CMDbatRSHsignal
comment "Return V >> B, raise error on out of range second operand";
pattern >>(v:sht,b:bat[:bte],s:bat[:oid]) :bat[:sht]
address CMDbatRSHsignal
comment "Return V >> B with candidates list, raise error on out of range second operand";
pattern rsh_noerror(v:sht,b:bat[:bte]) :bat[:sht]
address CMDbatRSH
comment "Return V >> B, out of range second operand causes NIL value";
pattern rsh_noerror(v:sht,b:bat[:bte],s:bat[:oid]) :bat[:sht]
address CMDbatRSH
comment "Return V >> B with candidates list, out of range second operand causes NIL value";

pattern >>(b1:bat[:sht],b2:bat[:sht]) :bat[:sht]
address CMDbatRSHsignal
comment "Return B1 >> B2, raise error on out of range second operand";
pattern >>(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]) :bat[:sht]
address CMDbatRSHsignal
comment "Return B1 >> B2 with candidates list, raise error on out of range second operand";
pattern rsh_noerror(b1:bat[:sht],b2:bat[:sht]) :bat[:sht]
address CMDbatRSH
comment "Return B1 >> B2, out of range second operand causes NIL value";
pattern rsh_noerror(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]) :bat[:sht]
address CMDbatRSH
comment "Return B1 >> B2 with candidates list, out of range second operand causes NIL value";
pattern >>(b:bat[:sht],v:sht) :bat[:sht]
address CMDbatRSHsignal
comment "Return B >> V, raise error on out of range second operand";
pattern >>(b:bat[:sht],v:sht,s:bat[:oid]) :bat[:sht]
address CMDbatRSHsignal
comment "Return B >> V with candidates list, raise error on out of range second operand";
pattern rsh_noerror(b:bat[:sht],v:sht) :bat[:sht]
address CMDbatRSH
comment "Return B >> V, out of range second operand causes NIL value";
pattern rsh_noerror(b:bat[:sht],v:sht,s:bat[:oid]) :bat[:sht]
address CMDbatRSH
comment "Return B >> V with candidates list, out of range second operand causes NIL value";
pattern >>(v:sht,b:bat[:sht]) :bat[:sht]
address CMDbatRSHsignal
comment "Return V >> B, raise error on out of range second operand";
pattern >>(v:sht,b:bat[:sht],s:bat[:oid]) :bat[:sht]
address CMDbatRSHsignal
comment "Return V >> B with candidates list, raise error on out of range second operand";
pattern rsh_noerror(v:sht,b:bat[:sht]) :bat[:sht]
address CMDbatRSH
comment "Return V >> B, out of range second operand causes NIL value";
pattern rsh_noerror(v:sht,b:bat[:sht],s:bat[:oid]) :bat[:sht]
address CMDbatRSH
comment "Return V >> B with candidates list, out of range second operand causes NIL value";

pattern >>(b1:bat[:sht],b2:bat[:int]) :bat[:sht]
address CMDbatRSHsignal
comment "Return B1 >> B2, raise error on out of range second operand";
pattern >>(b1:bat[:sht],b2:bat[:int],s:bat[:oid]) :bat[:sht]
address CMDbatRSHsignal
comment "Return B1 >> B2 with candidates list, raise error on out of range second operand";
pattern rsh_noerror(b1:bat[:sht],b2:bat[:int]) :bat[:sht]
address CMDbatRSH
comment "Return B1 >> B2, out of range second operand causes NIL value";
pattern rsh_noerror(b1:bat[:sht],b2:bat[:int],s:bat[:oid]) :bat[:sht]
address CMDbatRSH
comment "Return B1 >> B2 with candidates list, out of range second operand causes NIL value";
pattern >>(b:bat[:sht],v:int) :bat[:sht]
address CMDbatRSHsignal
comment "Return B >> V, raise error on out of range second operand";
pattern >>(b:bat[:sht],v:int,s:bat[:oid]) :bat[:sht]
address CMDbatRSHsignal
comment "Return B >> V with candidates list, raise error on out of range second operand";
pattern rsh_noerror(b:bat[:sht],v:int) :bat[:sht]
address CMDbatRSH
comment "Return B >> V, out of range second operand causes NIL value";
pattern rsh_noerror(b:bat[:sht],v:int,s:bat[:oid]) :bat[:sht]
address CMDbatRSH
comment "Return B >> V with candidates list, out of range second operand causes NIL value";
pattern >>(v:sht,b:bat[:int]) :bat[:sht]
address CMDbatRSHsignal
comment "Return V >> B, raise error on out of range second operand";
pattern >>(v:sht,b:bat[:int],s:bat[:oid]) :bat[:sht]
address CMDbatRSHsignal
comment "Return V >> B with candidates list, raise error on out of range second operand";
pattern rsh_noerror(v:sht,b:bat[:int]) :bat[:sht]
address CMDbatRSH
comment "Return V >> B, out of range second operand causes NIL value";
pattern rsh_noerror(v:sht,b:bat[:int],s:bat[:oid]) :bat[:sht]
address CMDbatRSH
comment "Return V >> B with candidates list, out of range second operand causes NIL value";

pattern >>(b1:bat[:sht],b2:bat[:lng]) :bat[:sht]
address CMDbatRSHsignal
comment "Return B1 >> B2, raise error on out of range second operand";
pattern >>(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]) :bat[:sht]
address CMDbatRSHsignal
comment "Return B1 >> B2 with candidates list, raise error on out of range second operand";
pattern rsh_noerror(b1:bat[:sht],b2:bat[:lng]) :bat[:sht]
address CMDbatRSH
comment "Return B1 >> B2, out of range second operand causes NIL value";
pattern rsh_noerror(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]) :bat[:sht]
address CMDbatRSH
comment "Return B1 >> B2 with candidates list, out of range second operand causes NIL value";
pattern >>(b:bat[:sht],v:lng) :bat[:sht]
address CMDbatRSHsignal
comment "Return B >> V, raise error on out of range second operand";
pattern >>(b:bat[:sht],v:lng,s:bat[:oid]) :bat[:sht]
address CMDbatRSHsignal
comment "Return B >> V with candidates list, raise error on out of range second operand";
pattern rsh_noerror(b:bat[:sht],v:lng) :bat[:sht]
address CMDbatRSH
comment "Return B >> V, out of range second operand causes NIL value";
pattern rsh_noerror(b:bat[:sht],v:lng,s:bat[:oid]) :bat[:sht]
address CMDbatRSH
comment "Return B >> V with candidates list, out of range second operand causes NIL value";
pattern >>(v:sht,b:bat[:lng]) :bat[:sht]
address CMDbatRSHsignal
comment "Return V >> B, raise error on out of range second operand";
pattern >>(v:sht,b:bat[:lng],s:bat[:oid]) :bat[:sht]
address CMDbatRSHsignal
comment "Return V >> B with candidates list, raise error on out of range second operand";
pattern rsh_noerror(v:sht,b:bat[:lng]) :bat[:sht]
address CMDbatRSH
comment "Return V >> B, out of range second operand causes NIL value";
pattern rsh_noerror(v:sht,b:bat[:lng],s:bat[:oid]) :bat[:sht]
address CMDbatRSH
comment "Return V >> B with candidates list, out of range second operand causes NIL value";

pattern >>(b1:bat[:int],b2:bat[:bte]) :bat[:int]
address CMDbatRSHsignal
comment "Return B1 >> B2, raise error on out of range second operand";
pattern >>(b1:bat[:int],b2:bat[:bte],s:bat[:oid]) :bat[:int]
address CMDbatRSHsignal
comment "Return B1 >> B2 with candidates list, raise error on out of range second operand";
pattern rsh_noerror(b1:bat[:int],b2:bat[:bte]) :bat[:int]
address CMDbatRSH
comment "Return B1 >> B2, out of range second operand causes NIL value";
pattern rsh_noerror(b1:bat[:int],b2:bat[:bte],s:bat[:oid]) :bat[:int]
address CMDbatRSH
comment "Return B1 >> B2 with candidates list, out of range second operand causes NIL value";
pattern >>(b:bat[:int],v:bte) :bat[:int]
address CMDbatRSHsignal
comment "Return B >> V, raise error on out of range second operand";
pattern >>(b:bat[:int],v:bte,s:bat[:oid]) :bat[:int]
address CMDbatRSHsignal
comment "Return B >> V with candidates list, raise error on out of range second operand";
pattern rsh_noerror(b:bat[:int],v:bte) :bat[:int]
address CMDbatRSH
comment "Return B >> V, out of range second operand causes NIL value";
pattern rsh_noerror(b:bat[:int],v:bte,s:bat[:oid]) :bat[:int]
address CMDbatRSH
comment "Return B >> V with candidates list, out of range second operand causes NIL value";
pattern >>(v:int,b:bat[:bte]) :bat[:int]
address CMDbatRSHsignal
comment "Return V >> B, raise error on out of range second operand";
pattern >>(v:int,b:bat[:bte],s:bat[:oid]) :bat[:int]
address CMDbatRSHsignal
comment "Return V >> B with candidates list, raise error on out of range second operand";
pattern rsh_noerror(v:int,b:bat[:bte]) :bat[:int]
address CMDbatRSH
comment "Return V >> B, out of range second operand causes NIL value";
pattern rsh_noerror(v:int,b:bat[:bte],s:bat[:oid]) :bat[:int]
address CMDbatRSH
comment "Return V >> B with candidates list, out of range second operand causes NIL value";

pattern >>(b1:bat[:int],b2:bat[:sht]) :bat[:int]
address CMDbatRSHsignal
comment "Return B1 >> B2, raise error on out of range second operand";
pattern >>(b1:bat[:int],b2:bat[:sht],s:bat[:oid]) :bat[:int]
address CMDbatRSHsignal
comment "Return B1 >> B2 with candidates list, raise error on out of range second operand";
pattern rsh_noerror(b1:bat[:int],b2:bat[:sht]) :bat[:int]
address CMDbatRSH
comment "Return B1 >> B2, out of range second operand causes NIL value";
pattern rsh_noerror(b1:bat[:int],b2:bat[:sht],s:bat[:oid]) :bat[:int]
address CMDbatRSH
comment "Return B1 >> B2 with candidates list, out of range second operand causes NIL value";
pattern >>(b:bat[:int],v:sht) :bat[:int]
address CMDbatRSHsignal
comment "Return B >> V, raise error on out of range second operand";
pattern >>(b:bat[:int],v:sht,s:bat[:oid]) :bat[:int]
address CMDbatRSHsignal
comment "Return B >> V with candidates list, raise error on out of range second operand";
pattern rsh_noerror(b:bat[:int],v:sht) :bat[:int]
address CMDbatRSH
comment "Return B >> V, out of range second operand causes NIL value";
pattern rsh_noerror(b:bat[:int],v:sht,s:bat[:oid]) :bat[:int]
address CMDbatRSH
comment "Return B >> V with candidates list, out of range second operand causes NIL value";
pattern >>(v:int,b:bat[:sht]) :bat[:int]
address CMDbatRSHsignal
comment "Return V >> B, raise error on out of range second operand";
pattern >>(v:int,b:bat[:sht],s:bat[:oid]) :bat[:int]
address CMDbatRSHsignal
comment "Return V >> B with candidates list, raise error on out of range second operand";
pattern rsh_noerror(v:int,b:bat[:sht]) :bat[:int]
address CMDbatRSH
comment "Return V >> B, out of range second operand causes NIL value";
pattern rsh_noerror(v:int,b:bat[:sht],s:bat[:oid]) :bat[:int]
address CMDbatRSH
comment "Return V >> B with candidates list, out of range second operand causes NIL value";

pattern >>(b1:bat[:int],b2:bat[:int]) :bat[:int]
address CMDbatRSHsignal
comment "Return B1 >> B2, raise error on out of range second operand";
pattern >>(b1:bat[:int],b2:bat[:int],s:bat[:oid]) :bat[:int]
address CMDbatRSHsignal
comment "Return B1 >> B2 with candidates list, raise error on out of range second operand";
pattern rsh_noerror(b1:bat[:int],b2:bat[:int]) :bat[:int]
address CMDbatRSH
comment "Return B1 >> B2, out of range second operand causes NIL value";
pattern rsh_noerror(b1:bat[:int],b2:bat[:int],s:bat[:oid]) :bat[:int]
address CMDbatRSH
comment "Return B1 >> B2 with candidates list, out of range second operand causes NIL value";
pattern >>(b:bat[:int],v:int) :bat[:int]
address CMDbatRSHsignal
comment "Return B >> V, raise error on out of range second operand";
pattern >>(b:bat[:int],v:int,s:bat[:oid]) :bat[:int]
address CMDbatRSHsignal
comment "Return B >> V with candidates list, raise error on out of range second operand";
pattern rsh_noerror(b:bat[:int],v:int) :bat[:int]
address CMDbatRSH
comment "Return B >> V, out of range second operand causes NIL value";
pattern rsh_noerror(b:bat[:int],v:int,s:bat[:oid]) :bat[:int]
address CMDbatRSH
comment "Return B >> V with candidates list, out of range second operand causes NIL value";
pattern >>(v:int,b:bat[:int]) :bat[:int]
address CMDbatRSHsignal
comment "Return V >> B, raise error on out of range second operand";
pattern >>(v:int,b:bat[:int],s:bat[:oid]) :bat[:int]
address CMDbatRSHsignal
comment "Return V >> B with candidates list, raise error on out of range second operand";
pattern rsh_noerror(v:int,b:bat[:int]) :bat[:int]
address CMDbatRSH
comment "Return V >> B, out of range second operand causes NIL value";
pattern rsh_noerror(v:int,b:bat[:int],s:bat[:oid]) :bat[:int]
address CMDbatRSH
comment "Return V >> B with candidates list, out of range second operand causes NIL value";

pattern >>(b1:bat[:int],b2:bat[:lng]) :bat[:int]
address CMDbatRSHsignal
comment "Return B1 >> B2, raise error on out of range second operand";
pattern >>(b1:bat[:int],b2:bat[:lng],s:bat[:oid]) :bat[:int]
address CMDbatRSHsignal
comment "Return B1 >> B2 with candidates list, raise error on out of range second operand";
pattern rsh_noerror(b1:bat[:int],b2:bat[:lng]) :bat[:int]
address CMDbatRSH
comment "Return B1 >> B2, out of range second operand causes NIL value";
pattern rsh_noerror(b1:bat[:int],b2:bat[:lng],s:bat[:oid]) :bat[:int]
address CMDbatRSH
comment "Return B1 >> B2 with candidates list, out of range second operand causes NIL value";
pattern >>(b:bat[:int],v:lng) :bat[:int]
address CMDbatRSHsignal
comment "Return B >> V, raise error on out of range second operand";
pattern >>(b:bat[:int],v:lng,s:bat[:oid]) :bat[:int]
address CMDbatRSHsignal
comment "Return B >> V with candidates list, raise error on out of range second operand";
pattern rsh_noerror(b:bat[:int],v:lng) :bat[:int]
address CMDbatRSH
comment "Return B >> V, out of range second operand causes NIL value";
pattern rsh_noerror(b:bat[:int],v:lng,s:bat[:oid]) :bat[:int]
address CMDbatRSH
comment "Return B >> V with candidates list, out of range second operand causes NIL value";
pattern >>(v:int,b:bat[:lng]) :bat[:int]
address CMDbatRSHsignal
comment "Return V >> B, raise error on out of range second operand";
pattern >>(v:int,b:bat[:lng],s:bat[:oid]) :bat[:int]
address CMDbatRSHsignal
comment "Return V >> B with candidates list, raise error on out of range second operand";
pattern rsh_noerror(v:int,b:bat[:lng]) :bat[:int]
address CMDbatRSH
comment "Return V >> B, out of range second operand causes NIL value";
pattern rsh_noerror(v:int,b:bat[:lng],s:bat[:oid]) :bat[:int]
address CMDbatRSH
comment "Return V >> B with candidates list, out of range second operand causes NIL value";

pattern >>(b1:bat[:lng],b2:bat[:bte]) :bat[:lng]
address CMDbatRSHsignal
comment "Return B1 >> B2, raise error on out of range second operand";
pattern >>(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]) :bat[:lng]
address CMDbatRSHsignal
comment "Return B1 >> B2 with candidates list, raise error on out of range second operand";
pattern rsh_noerror(b1:bat[:lng],b2:bat[:bte]) :bat[:lng]
address CMDbatRSH
comment "Return B1 >> B2, out of range second operand causes NIL value";
pattern rsh_noerror(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]) :bat[:lng]
address CMDbatRSH
comment "Return B1 >> B2 with candidates list, out of range second operand causes NIL value";
pattern >>(b:bat[:lng],v:bte) :bat[:lng]
address CMDbatRSHsignal
comment "Return B >> V, raise error on out of range second operand";
pattern >>(b:bat[:lng],v:bte,s:bat[:oid]) :bat[:lng]
address CMDbatRSHsignal
comment "Return B >> V with candidates list, raise error on out of range second operand";
pattern rsh_noerror(b:bat[:lng],v:bte) :bat[:lng]
address CMDbatRSH
comment "Return B >> V, out of range second operand causes NIL value";
pattern rsh_noerror(b:bat[:lng],v:bte,s:bat[:oid]) :bat[:lng]
address CMDbatRSH
comment "Return B >> V with candidates list, out of range second operand causes NIL value";
pattern >>(v:lng,b:bat[:bte]) :bat[:lng]
address CMDbatRSHsignal
comment "Return V >> B, raise error on out of range second operand";
pattern >>(v:lng,b:bat[:bte],s:bat[:oid]) :bat[:lng]
address CMDbatRSHsignal
comment "Return V >> B with candidates list, raise error on out of range second operand";
pattern rsh_noerror(v:lng,b:bat[:bte]) :bat[:lng]
address CMDbatRSH
comment "Return V >> B, out of range second operand causes NIL value";
pattern rsh_noerror(v:lng,b:bat[:bte],s:bat[:oid]) :bat[:lng]
address CMDbatRSH
comment "Return V >> B with candidates list, out of range second operand causes NIL value";

pattern >>(b1:bat[:lng],b2:bat[:sht]) :bat[:lng]
address CMDbatRSHsignal
comment "Return B1 >> B2, raise error on out of range second operand";
pattern >>(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]) :bat[:lng]
address CMDbatRSHsignal
comment "Return B1 >> B2 with candidates list, raise error on out of range second operand";
pattern rsh_noerror(b1:bat[:lng],b2:bat[:sht]) :bat[:lng]
address CMDbatRSH
comment "Return B1 >> B2, out of range second operand causes NIL value";
pattern rsh_noerror(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]) :bat[:lng]
address CMDbatRSH
comment "Return B1 >> B2 with candidates list, out of range second operand causes NIL value";
pattern >>(b:bat[:lng],v:sht) :bat[:lng]
address CMDbatRSHsignal
comment "Return B >> V, raise error on out of range second operand";
pattern >>(b:bat[:lng],v:sht,s:bat[:oid]) :bat[:lng]
address CMDbatRSHsignal
comment "Return B >> V with candidates list, raise error on out of range second operand";
pattern rsh_noerror(b:bat[:lng],v:sht) :bat[:lng]
address CMDbatRSH
comment "Return B >> V, out of range second operand causes NIL value";
pattern rsh_noerror(b:bat[:lng],v:sht,s:bat[:oid]) :bat[:lng]
address CMDbatRSH
comment "Return B >> V with candidates list, out of range second operand causes NIL value";
pattern >>(v:lng,b:bat[:sht]) :bat[:lng]
address CMDbatRSHsignal
comment "Return V >> B, raise error on out of range second operand";
pattern >>(v:lng,b:bat[:sht],s:bat[:oid]) :bat[:lng]
address CMDbatRSHsignal
comment "Return V >> B with candidates list, raise error on out of range second operand";
pattern rsh_noerror(v:lng,b:bat[:sht]) :bat[:lng]
address CMDbatRSH
comment "Return V >> B, out of range second operand causes NIL value";
pattern rsh_noerror(v:lng,b:bat[:sht],s:bat[:oid]) :bat[:lng]
address CMDbatRSH
comment "Return V >> B with candidates list, out of range second operand causes NIL value";

pattern >>(b1:bat[:lng],b2:bat[:int]) :bat[:lng]
address CMDbatRSHsignal
comment "Return B1 >> B2, raise error on out of range second operand";
pattern >>(b1:bat[:lng],b2:bat[:int],s:bat[:oid]) :bat[:lng]
address CMDbatRSHsignal
comment "Return B1 >> B2 with candidates list, raise error on out of range second operand";
pattern rsh_noerror(b1:bat[:lng],b2:bat[:int]) :bat[:lng]
address CMDbatRSH
comment "Return B1 >> B2, out of range second operand causes NIL value";
pattern rsh_noerror(b1:bat[:lng],b2:bat[:int],s:bat[:oid]) :bat[:lng]
address CMDbatRSH
comment "Return B1 >> B2 with candidates list, out of range second operand causes NIL value";
pattern >>(b:bat[:lng],v:int) :bat[:lng]
address CMDbatRSHsignal
comment "Return B >> V, raise error on out of range second operand";
pattern >>(b:bat[:lng],v:int,s:bat[:oid]) :bat[:lng]
address CMDbatRSHsignal
comment "Return B >> V with candidates list, raise error on out of range second operand";
pattern rsh_noerror(b:bat[:lng],v:int) :bat[:lng]
address CMDbatRSH
comment "Return B >> V, out of range second operand causes NIL value";
pattern rsh_noerror(b:bat[:lng],v:int,s:bat[:oid]) :bat[:lng]
address CMDbatRSH
comment "Return B >> V with candidates list, out of range second operand causes NIL value";
pattern >>(v:lng,b:bat[:int]) :bat[:lng]
address CMDbatRSHsignal
comment "Return V >> B, raise error on out of range second operand";
pattern >>(v:lng,b:bat[:int],s:bat[:oid]) :bat[:lng]
address CMDbatRSHsignal
comment "Return V >> B with candidates list, raise error on out of range second operand";
pattern rsh_noerror(v:lng,b:bat[:int]) :bat[:lng]
address CMDbatRSH
comment "Return V >> B, out of range second operand causes NIL value";
pattern rsh_noerror(v:lng,b:bat[:int],s:bat[:oid]) :bat[:lng]
address CMDbatRSH
comment "Return V >> B with candidates list, out of range second operand causes NIL value";

pattern >>(b1:bat[:lng],b2:bat[:lng]) :bat[:lng]
address CMDbatRSHsignal
comment "Return B1 >> B2, raise error on out of range second operand";
pattern >>(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]) :bat[:lng]
address CMDbatRSHsignal
comment "Return B1 >> B2 with candidates list, raise error on out of range second operand";
pattern rsh_noerror(b1:bat[:lng],b2:bat[:lng]) :bat[:lng]
address CMDbatRSH
comment "Return B1 >> B2, out of range second operand causes NIL value";
pattern rsh_noerror(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]) :bat[:lng]
address CMDbatRSH
comment "Return B1 >> B2 with candidates list, out of range second operand causes NIL value";
pattern >>(b:bat[:lng],v:lng) :bat[:lng]
address CMDbatRSHsignal
comment "Return B >> V, raise error on out of range second operand";
pattern >>(b:bat[:lng],v:lng,s:bat[:oid]) :bat[:lng]
address CMDbatRSHsignal
comment "Return B >> V with candidates list, raise error on out of range second operand";
pattern rsh_noerror(b:bat[:lng],v:lng) :bat[:lng]
address CMDbatRSH
comment "Return B >> V, out of range second operand causes NIL value";
pattern rsh_noerror(b:bat[:lng],v:lng,s:bat[:oid]) :bat[:lng]
address CMDbatRSH
comment "Return B >> V with candidates list, out of range second operand causes NIL value";
pattern >>(v:lng,b:bat[:lng]) :bat[:lng]
address CMDbatRSHsignal
comment "Return V >> B, raise error on out of range second operand";
pattern >>(v:lng,b:bat[:lng],s:bat[:oid]) :bat[:lng]
address CMDbatRSHsignal
comment "Return V >> B with candidates list, raise error on out of range second operand";
pattern rsh_noerror(v:lng,b:bat[:lng]) :bat[:lng]
address CMDbatRSH
comment "Return V >> B, out of range second operand causes NIL value";
pattern rsh_noerror(v:lng,b:bat[:lng],s:bat[:oid]) :bat[:lng]
address CMDbatRSH
comment "Return V >> B with candidates list, out of range second operand causes NIL value";


pattern <(b1:bat[:bit],b2:bat[:bit]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b1:bat[:bit],b2:bat[:bit],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2 with candidates list";
pattern <(b:bat[:bit],v:bit) :bat[:bit]
address CMDbatLT
comment "Return B < V";
pattern <(b:bat[:bit],v:bit,s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B < V with candidates list";
pattern <(v:bit,b:bat[:bit]) :bat[:bit]
address CMDbatLT
comment "Return V < B";
pattern <(v:bit,b:bat[:bit],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return V < B with candidates list";

pattern <(b1:bat[:str],b2:bat[:str]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b1:bat[:str],b2:bat[:str],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2 with candidates list";
pattern <(b:bat[:str],v:str) :bat[:bit]
address CMDbatLT
comment "Return B < V";
pattern <(b:bat[:str],v:str,s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B < V with candidates list";
pattern <(v:str,b:bat[:str]) :bat[:bit]
address CMDbatLT
comment "Return V < B";
pattern <(v:str,b:bat[:str],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return V < B with candidates list";

pattern <(b1:bat[:oid],b2:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b1:bat[:oid],b2:bat[:oid],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2 with candidates list";
pattern <(b:bat[:oid],v:oid) :bat[:bit]
address CMDbatLT
comment "Return B < V";
pattern <(b:bat[:oid],v:oid,s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B < V with candidates list";
pattern <(v:oid,b:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return V < B";
pattern <(v:oid,b:bat[:oid],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return V < B with candidates list";

pattern <(b1:bat[:bte],b2:bat[:bte]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2 with candidates list";
pattern <(b:bat[:bte],v:bte) :bat[:bit]
address CMDbatLT
comment "Return B < V";
pattern <(b:bat[:bte],v:bte,s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B < V with candidates list";
pattern <(v:bte,b:bat[:bte]) :bat[:bit]
address CMDbatLT
comment "Return V < B";
pattern <(v:bte,b:bat[:bte],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return V < B with candidates list";

pattern <(b1:bat[:bte],b2:bat[:sht]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2 with candidates list";
pattern <(b:bat[:bte],v:sht) :bat[:bit]
address CMDbatLT
comment "Return B < V";
pattern <(b:bat[:bte],v:sht,s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B < V with candidates list";
pattern <(v:bte,b:bat[:sht]) :bat[:bit]
address CMDbatLT
comment "Return V < B";
pattern <(v:bte,b:bat[:sht],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return V < B with candidates list";

pattern <(b1:bat[:bte],b2:bat[:int]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b1:bat[:bte],b2:bat[:int],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2 with candidates list";
pattern <(b:bat[:bte],v:int) :bat[:bit]
address CMDbatLT
comment "Return B < V";
pattern <(b:bat[:bte],v:int,s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B < V with candidates list";
pattern <(v:bte,b:bat[:int]) :bat[:bit]
address CMDbatLT
comment "Return V < B";
pattern <(v:bte,b:bat[:int],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return V < B with candidates list";

pattern <(b1:bat[:bte],b2:bat[:lng]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2 with candidates list";
pattern <(b:bat[:bte],v:lng) :bat[:bit]
address CMDbatLT
comment "Return B < V";
pattern <(b:bat[:bte],v:lng,s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B < V with candidates list";
pattern <(v:bte,b:bat[:lng]) :bat[:bit]
address CMDbatLT
comment "Return V < B";
pattern <(v:bte,b:bat[:lng],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return V < B with candidates list";

pattern <(b1:bat[:bte],b2:bat[:flt]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2 with candidates list";
pattern <(b:bat[:bte],v:flt) :bat[:bit]
address CMDbatLT
comment "Return B < V";
pattern <(b:bat[:bte],v:flt,s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B < V with candidates list";
pattern <(v:bte,b:bat[:flt]) :bat[:bit]
address CMDbatLT
comment "Return V < B";
pattern <(v:bte,b:bat[:flt],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return V < B with candidates list";

pattern <(b1:bat[:bte],b2:bat[:dbl]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b1:bat[:bte],b2:bat[:dbl],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2 with candidates list";
pattern <(b:bat[:bte],v:dbl) :bat[:bit]
address CMDbatLT
comment "Return B < V";
pattern <(b:bat[:bte],v:dbl,s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B < V with candidates list";
pattern <(v:bte,b:bat[:dbl]) :bat[:bit]
address CMDbatLT
comment "Return V < B";
pattern <(v:bte,b:bat[:dbl],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return V < B with candidates list";

pattern <(b1:bat[:sht],b2:bat[:bte]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2 with candidates list";
pattern <(b:bat[:sht],v:bte) :bat[:bit]
address CMDbatLT
comment "Return B < V";
pattern <(b:bat[:sht],v:bte,s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B < V with candidates list";
pattern <(v:sht,b:bat[:bte]) :bat[:bit]
address CMDbatLT
comment "Return V < B";
pattern <(v:sht,b:bat[:bte],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return V < B with candidates list";

pattern <(b1:bat[:sht],b2:bat[:sht]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2 with candidates list";
pattern <(b:bat[:sht],v:sht) :bat[:bit]
address CMDbatLT
comment "Return B < V";
pattern <(b:bat[:sht],v:sht,s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B < V with candidates list";
pattern <(v:sht,b:bat[:sht]) :bat[:bit]
address CMDbatLT
comment "Return V < B";
pattern <(v:sht,b:bat[:sht],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return V < B with candidates list";

pattern <(b1:bat[:sht],b2:bat[:int]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b1:bat[:sht],b2:bat[:int],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2 with candidates list";
pattern <(b:bat[:sht],v:int) :bat[:bit]
address CMDbatLT
comment "Return B < V";
pattern <(b:bat[:sht],v:int,s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B < V with candidates list";
pattern <(v:sht,b:bat[:int]) :bat[:bit]
address CMDbatLT
comment "Return V < B";
pattern <(v:sht,b:bat[:int],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return V < B with candidates list";

pattern <(b1:bat[:sht],b2:bat[:lng]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2 with candidates list";
pattern <(b:bat[:sht],v:lng) :bat[:bit]
address CMDbatLT
comment "Return B < V";
pattern <(b:bat[:sht],v:lng,s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B < V with candidates list";
pattern <(v:sht,b:bat[:lng]) :bat[:bit]
address CMDbatLT
comment "Return V < B";
pattern <(v:sht,b:bat[:lng],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return V < B with candidates list";

pattern <(b1:bat[:sht],b2:bat[:flt]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b1:bat[:sht],b2:bat[:flt],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2 with candidates list";
pattern <(b:bat[:sht],v:flt) :bat[:bit]
address CMDbatLT
comment "Return B < V";
pattern <(b:bat[:sht],v:flt,s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B < V with candidates list";
pattern <(v:sht,b:bat[:flt]) :bat[:bit]
address CMDbatLT
comment "Return V < B";
pattern <(v:sht,b:bat[:flt],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return V < B with candidates list";

pattern <(b1:bat[:sht],b2:bat[:dbl]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b1:bat[:sht],b2:bat[:dbl],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2 with candidates list";
pattern <(b:bat[:sht],v:dbl) :bat[:bit]
address CMDbatLT
comment "Return B < V";
pattern <(b:bat[:sht],v:dbl,s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B < V with candidates list";
pattern <(v:sht,b:bat[:dbl]) :bat[:bit]
address CMDbatLT
comment "Return V < B";
pattern <(v:sht,b:bat[:dbl],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return V < B with candidates list";

pattern <(b1:bat[:int],b2:bat[:bte]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b1:bat[:int],b2:bat[:bte],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2 with candidates list";
pattern <(b:bat[:int],v:bte) :bat[:bit]
address CMDbatLT
comment "Return B < V";
pattern <(b:bat[:int],v:bte,s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B < V with candidates list";
pattern <(v:int,b:bat[:bte]) :bat[:bit]
address CMDbatLT
comment "Return V < B";
pattern <(v:int,b:bat[:bte],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return V < B with candidates list";

pattern <(b1:bat[:int],b2:bat[:sht]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b1:bat[:int],b2:bat[:sht],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2 with candidates list";
pattern <(b:bat[:int],v:sht) :bat[:bit]
address CMDbatLT
comment "Return B < V";
pattern <(b:bat[:int],v:sht,s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B < V with candidates list";
pattern <(v:int,b:bat[:sht]) :bat[:bit]
address CMDbatLT
comment "Return V < B";
pattern <(v:int,b:bat[:sht],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return V < B with candidates list";

pattern <(b1:bat[:int],b2:bat[:int]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b1:bat[:int],b2:bat[:int],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2 with candidates list";
pattern <(b:bat[:int],v:int) :bat[:bit]
address CMDbatLT
comment "Return B < V";
pattern <(b:bat[:int],v:int,s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B < V with candidates list";
pattern <(v:int,b:bat[:int]) :bat[:bit]
address CMDbatLT
comment "Return V < B";
pattern <(v:int,b:bat[:int],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return V < B with candidates list";

pattern <(b1:bat[:int],b2:bat[:lng]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b1:bat[:int],b2:bat[:lng],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2 with candidates list";
pattern <(b:bat[:int],v:lng) :bat[:bit]
address CMDbatLT
comment "Return B < V";
pattern <(b:bat[:int],v:lng,s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B < V with candidates list";
pattern <(v:int,b:bat[:lng]) :bat[:bit]
address CMDbatLT
comment "Return V < B";
pattern <(v:int,b:bat[:lng],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return V < B with candidates list";

pattern <(b1:bat[:int],b2:bat[:flt]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b1:bat[:int],b2:bat[:flt],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2 with candidates list";
pattern <(b:bat[:int],v:flt) :bat[:bit]
address CMDbatLT
comment "Return B < V";
pattern <(b:bat[:int],v:flt,s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B < V with candidates list";
pattern <(v:int,b:bat[:flt]) :bat[:bit]
address CMDbatLT
comment "Return V < B";
pattern <(v:int,b:bat[:flt],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return V < B with candidates list";

pattern <(b1:bat[:int],b2:bat[:dbl]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b1:bat[:int],b2:bat[:dbl],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2 with candidates list";
pattern <(b:bat[:int],v:dbl) :bat[:bit]
address CMDbatLT
comment "Return B < V";
pattern <(b:bat[:int],v:dbl,s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B < V with candidates list";
pattern <(v:int,b:bat[:dbl]) :bat[:bit]
address CMDbatLT
comment "Return V < B";
pattern <(v:int,b:bat[:dbl],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return V < B with candidates list";

pattern <(b1:bat[:lng],b2:bat[:bte]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2 with candidates list";
pattern <(b:bat[:lng],v:bte) :bat[:bit]
address CMDbatLT
comment "Return B < V";
pattern <(b:bat[:lng],v:bte,s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B < V with candidates list";
pattern <(v:lng,b:bat[:bte]) :bat[:bit]
address CMDbatLT
comment "Return V < B";
pattern <(v:lng,b:bat[:bte],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return V < B with candidates list";

pattern <(b1:bat[:lng],b2:bat[:sht]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2 with candidates list";
pattern <(b:bat[:lng],v:sht) :bat[:bit]
address CMDbatLT
comment "Return B < V";
pattern <(b:bat[:lng],v:sht,s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B < V with candidates list";
pattern <(v:lng,b:bat[:sht]) :bat[:bit]
address CMDbatLT
comment "Return V < B";
pattern <(v:lng,b:bat[:sht],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return V < B with candidates list";

pattern <(b1:bat[:lng],b2:bat[:int]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b1:bat[:lng],b2:bat[:int],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2 with candidates list";
pattern <(b:bat[:lng],v:int) :bat[:bit]
address CMDbatLT
comment "Return B < V";
pattern <(b:bat[:lng],v:int,s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B < V with candidates list";
pattern <(v:lng,b:bat[:int]) :bat[:bit]
address CMDbatLT
comment "Return V < B";
pattern <(v:lng,b:bat[:int],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return V < B with candidates list";

pattern <(b1:bat[:lng],b2:bat[:lng]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2 with candidates list";
pattern <(b:bat[:lng],v:lng) :bat[:bit]
address CMDbatLT
comment "Return B < V";
pattern <(b:bat[:lng],v:lng,s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B < V with candidates list";
pattern <(v:lng,b:bat[:lng]) :bat[:bit]
address CMDbatLT
comment "Return V < B";
pattern <(v:lng,b:bat[:lng],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return V < B with candidates list";

pattern <(b1:bat[:lng],b2:bat[:flt]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b1:bat[:lng],b2:bat[:flt],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2 with candidates list";
pattern <(b:bat[:lng],v:flt) :bat[:bit]
address CMDbatLT
comment "Return B < V";
pattern <(b:bat[:lng],v:flt,s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B < V with candidates list";
pattern <(v:lng,b:bat[:flt]) :bat[:bit]
address CMDbatLT
comment "Return V < B";
pattern <(v:lng,b:bat[:flt],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return V < B with candidates list";

pattern <(b1:bat[:lng],b2:bat[:dbl]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b1:bat[:lng],b2:bat[:dbl],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2 with candidates list";
pattern <(b:bat[:lng],v:dbl) :bat[:bit]
address CMDbatLT
comment "Return B < V";
pattern <(b:bat[:lng],v:dbl,s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B < V with candidates list";
pattern <(v:lng,b:bat[:dbl]) :bat[:bit]
address CMDbatLT
comment "Return V < B";
pattern <(v:lng,b:bat[:dbl],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return V < B with candidates list";

pattern <(b1:bat[:flt],b2:bat[:bte]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b1:bat[:flt],b2:bat[:bte],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2 with candidates list";
pattern <(b:bat[:flt],v:bte) :bat[:bit]
address CMDbatLT
comment "Return B < V";
pattern <(b:bat[:flt],v:bte,s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B < V with candidates list";
pattern <(v:flt,b:bat[:bte]) :bat[:bit]
address CMDbatLT
comment "Return V < B";
pattern <(v:flt,b:bat[:bte],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return V < B with candidates list";

pattern <(b1:bat[:flt],b2:bat[:sht]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b1:bat[:flt],b2:bat[:sht],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2 with candidates list";
pattern <(b:bat[:flt],v:sht) :bat[:bit]
address CMDbatLT
comment "Return B < V";
pattern <(b:bat[:flt],v:sht,s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B < V with candidates list";
pattern <(v:flt,b:bat[:sht]) :bat[:bit]
address CMDbatLT
comment "Return V < B";
pattern <(v:flt,b:bat[:sht],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return V < B with candidates list";

pattern <(b1:bat[:flt],b2:bat[:int]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b1:bat[:flt],b2:bat[:int],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2 with candidates list";
pattern <(b:bat[:flt],v:int) :bat[:bit]
address CMDbatLT
comment "Return B < V";
pattern <(b:bat[:flt],v:int,s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B < V with candidates list";
pattern <(v:flt,b:bat[:int]) :bat[:bit]
address CMDbatLT
comment "Return V < B";
pattern <(v:flt,b:bat[:int],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return V < B with candidates list";

pattern <(b1:bat[:flt],b2:bat[:lng]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b1:bat[:flt],b2:bat[:lng],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2 with candidates list";
pattern <(b:bat[:flt],v:lng) :bat[:bit]
address CMDbatLT
comment "Return B < V";
pattern <(b:bat[:flt],v:lng,s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B < V with candidates list";
pattern <(v:flt,b:bat[:lng]) :bat[:bit]
address CMDbatLT
comment "Return V < B";
pattern <(v:flt,b:bat[:lng],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return V < B with candidates list";

pattern <(b1:bat[:flt],b2:bat[:flt]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b1:bat[:flt],b2:bat[:flt],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2 with candidates list";
pattern <(b:bat[:flt],v:flt) :bat[:bit]
address CMDbatLT
comment "Return B < V";
pattern <(b:bat[:flt],v:flt,s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B < V with candidates list";
pattern <(v:flt,b:bat[:flt]) :bat[:bit]
address CMDbatLT
comment "Return V < B";
pattern <(v:flt,b:bat[:flt],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return V < B with candidates list";

pattern <(b1:bat[:flt],b2:bat[:dbl]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b1:bat[:flt],b2:bat[:dbl],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2 with candidates list";
pattern <(b:bat[:flt],v:dbl) :bat[:bit]
address CMDbatLT
comment "Return B < V";
pattern <(b:bat[:flt],v:dbl,s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B < V with candidates list";
pattern <(v:flt,b:bat[:dbl]) :bat[:bit]
address CMDbatLT
comment "Return V < B";
pattern <(v:flt,b:bat[:dbl],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return V < B with candidates list";

pattern <(b1:bat[:dbl],b2:bat[:bte]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b1:bat[:dbl],b2:bat[:bte],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2 with candidates list";
pattern <(b:bat[:dbl],v:bte) :bat[:bit]
address CMDbatLT
comment "Return B < V";
pattern <(b:bat[:dbl],v:bte,s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B < V with candidates list";
pattern <(v:dbl,b:bat[:bte]) :bat[:bit]
address CMDbatLT
comment "Return V < B";
pattern <(v:dbl,b:bat[:bte],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return V < B with candidates list";

pattern <(b1:bat[:dbl],b2:bat[:sht]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b1:bat[:dbl],b2:bat[:sht],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2 with candidates list";
pattern <(b:bat[:dbl],v:sht) :bat[:bit]
address CMDbatLT
comment "Return B < V";
pattern <(b:bat[:dbl],v:sht,s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B < V with candidates list";
pattern <(v:dbl,b:bat[:sht]) :bat[:bit]
address CMDbatLT
comment "Return V < B";
pattern <(v:dbl,b:bat[:sht],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return V < B with candidates list";

pattern <(b1:bat[:dbl],b2:bat[:int]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b1:bat[:dbl],b2:bat[:int],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2 with candidates list";
pattern <(b:bat[:dbl],v:int) :bat[:bit]
address CMDbatLT
comment "Return B < V";
pattern <(b:bat[:dbl],v:int,s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B < V with candidates list";
pattern <(v:dbl,b:bat[:int]) :bat[:bit]
address CMDbatLT
comment "Return V < B";
pattern <(v:dbl,b:bat[:int],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return V < B with candidates list";

pattern <(b1:bat[:dbl],b2:bat[:lng]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b1:bat[:dbl],b2:bat[:lng],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2 with candidates list";
pattern <(b:bat[:dbl],v:lng) :bat[:bit]
address CMDbatLT
comment "Return B < V";
pattern <(b:bat[:dbl],v:lng,s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B < V with candidates list";
pattern <(v:dbl,b:bat[:lng]) :bat[:bit]
address CMDbatLT
comment "Return V < B";
pattern <(v:dbl,b:bat[:lng],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return V < B with candidates list";

pattern <(b1:bat[:dbl],b2:bat[:flt]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b1:bat[:dbl],b2:bat[:flt],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2 with candidates list";
pattern <(b:bat[:dbl],v:flt) :bat[:bit]
address CMDbatLT
comment "Return B < V";
pattern <(b:bat[:dbl],v:flt,s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B < V with candidates list";
pattern <(v:dbl,b:bat[:flt]) :bat[:bit]
address CMDbatLT
comment "Return V < B";
pattern <(v:dbl,b:bat[:flt],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return V < B with candidates list";

pattern <(b1:bat[:dbl],b2:bat[:dbl]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b1:bat[:dbl],b2:bat[:dbl],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2 with candidates list";
pattern <(b:bat[:dbl],v:dbl) :bat[:bit]
address CMDbatLT
comment "Return B < V";
pattern <(b:bat[:dbl],v:dbl,s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B < V with candidates list";
pattern <(v:dbl,b:bat[:dbl]) :bat[:bit]
address CMDbatLT
comment "Return V < B";
pattern <(v:dbl,b:bat[:dbl],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return V < B with candidates list";


pattern <=(b1:bat[:bit],b2:bat[:bit]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b1:bat[:bit],b2:bat[:bit],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2 with candidates list";
pattern <=(b:bat[:bit],v:bit) :bat[:bit]
address CMDbatLE
comment "Return B <= V";
pattern <=(b:bat[:bit],v:bit,s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B <= V with candidates list";
pattern <=(v:bit,b:bat[:bit]) :bat[:bit]
address CMDbatLE
comment "Return V <= B";
pattern <=(v:bit,b:bat[:bit],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return V <= B with candidates list";

pattern <=(b1:bat[:str],b2:bat[:str]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b1:bat[:str],b2:bat[:str],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2 with candidates list";
pattern <=(b:bat[:str],v:str) :bat[:bit]
address CMDbatLE
comment "Return B <= V";
pattern <=(b:bat[:str],v:str,s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B <= V with candidates list";
pattern <=(v:str,b:bat[:str]) :bat[:bit]
address CMDbatLE
comment "Return V <= B";
pattern <=(v:str,b:bat[:str],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return V <= B with candidates list";

pattern <=(b1:bat[:oid],b2:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b1:bat[:oid],b2:bat[:oid],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2 with candidates list";
pattern <=(b:bat[:oid],v:oid) :bat[:bit]
address CMDbatLE
comment "Return B <= V";
pattern <=(b:bat[:oid],v:oid,s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B <= V with candidates list";
pattern <=(v:oid,b:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return V <= B";
pattern <=(v:oid,b:bat[:oid],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return V <= B with candidates list";

pattern <=(b1:bat[:bte],b2:bat[:bte]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2 with candidates list";
pattern <=(b:bat[:bte],v:bte) :bat[:bit]
address CMDbatLE
comment "Return B <= V";
pattern <=(b:bat[:bte],v:bte,s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B <= V with candidates list";
pattern <=(v:bte,b:bat[:bte]) :bat[:bit]
address CMDbatLE
comment "Return V <= B";
pattern <=(v:bte,b:bat[:bte],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return V <= B with candidates list";

pattern <=(b1:bat[:bte],b2:bat[:sht]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2 with candidates list";
pattern <=(b:bat[:bte],v:sht) :bat[:bit]
address CMDbatLE
comment "Return B <= V";
pattern <=(b:bat[:bte],v:sht,s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B <= V with candidates list";
pattern <=(v:bte,b:bat[:sht]) :bat[:bit]
address CMDbatLE
comment "Return V <= B";
pattern <=(v:bte,b:bat[:sht],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return V <= B with candidates list";

pattern <=(b1:bat[:bte],b2:bat[:int]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b1:bat[:bte],b2:bat[:int],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2 with candidates list";
pattern <=(b:bat[:bte],v:int) :bat[:bit]
address CMDbatLE
comment "Return B <= V";
pattern <=(b:bat[:bte],v:int,s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B <= V with candidates list";
pattern <=(v:bte,b:bat[:int]) :bat[:bit]
address CMDbatLE
comment "Return V <= B";
pattern <=(v:bte,b:bat[:int],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return V <= B with candidates list";

pattern <=(b1:bat[:bte],b2:bat[:lng]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2 with candidates list";
pattern <=(b:bat[:bte],v:lng) :bat[:bit]
address CMDbatLE
comment "Return B <= V";
pattern <=(b:bat[:bte],v:lng,s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B <= V with candidates list";
pattern <=(v:bte,b:bat[:lng]) :bat[:bit]
address CMDbatLE
comment "Return V <= B";
pattern <=(v:bte,b:bat[:lng],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return V <= B with candidates list";

pattern <=(b1:bat[:bte],b2:bat[:flt]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2 with candidates list";
pattern <=(b:bat[:bte],v:flt) :bat[:bit]
address CMDbatLE
comment "Return B <= V";
pattern <=(b:bat[:bte],v:flt,s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B <= V with candidates list";
pattern <=(v:bte,b:bat[:flt]) :bat[:bit]
address CMDbatLE
comment "Return V <= B";
pattern <=(v:bte,b:bat[:flt],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return V <= B with candidates list";

pattern <=(b1:bat[:bte],b2:bat[:dbl]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b1:bat[:bte],b2:bat[:dbl],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2 with candidates list";
pattern <=(b:bat[:bte],v:dbl) :bat[:bit]
address CMDbatLE
comment "Return B <= V";
pattern <=(b:bat[:bte],v:dbl,s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B <= V with candidates list";
pattern <=(v:bte,b:bat[:dbl]) :bat[:bit]
address CMDbatLE
comment "Return V <= B";
pattern <=(v:bte,b:bat[:dbl],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return V <= B with candidates list";

pattern <=(b1:bat[:sht],b2:bat[:bte]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2 with candidates list";
pattern <=(b:bat[:sht],v:bte) :bat[:bit]
address CMDbatLE
comment "Return B <= V";
pattern <=(b:bat[:sht],v:bte,s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B <= V with candidates list";
pattern <=(v:sht,b:bat[:bte]) :bat[:bit]
address CMDbatLE
comment "Return V <= B";
pattern <=(v:sht,b:bat[:bte],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return V <= B with candidates list";

pattern <=(b1:bat[:sht],b2:bat[:sht]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2 with candidates list";
pattern <=(b:bat[:sht],v:sht) :bat[:bit]
address CMDbatLE
comment "Return B <= V";
pattern <=(b:bat[:sht],v:sht,s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B <= V with candidates list";
pattern <=(v:sht,b:bat[:sht]) :bat[:bit]
address CMDbatLE
comment "Return V <= B";
pattern <=(v:sht,b:bat[:sht],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return V <= B with candidates list";

pattern <=(b1:bat[:sht],b2:bat[:int]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b1:bat[:sht],b2:bat[:int],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2 with candidates list";
pattern <=(b:bat[:sht],v:int) :bat[:bit]
address CMDbatLE
comment "Return B <= V";
pattern <=(b:bat[:sht],v:int,s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B <= V with candidates list";
pattern <=(v:sht,b:bat[:int]) :bat[:bit]
address CMDbatLE
comment "Return V <= B";
pattern <=(v:sht,b:bat[:int],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return V <= B with candidates list";

pattern <=(b1:bat[:sht],b2:bat[:lng]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2 with candidates list";
pattern <=(b:bat[:sht],v:lng) :bat[:bit]
address CMDbatLE
comment "Return B <= V";
pattern <=(b:bat[:sht],v:lng,s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B <= V with candidates list";
pattern <=(v:sht,b:bat[:lng]) :bat[:bit]
address CMDbatLE
comment "Return V <= B";
pattern <=(v:sht,b:bat[:lng],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return V <= B with candidates list";

pattern <=(b1:bat[:sht],b2:bat[:flt]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b1:bat[:sht],b2:bat[:flt],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2 with candidates list";
pattern <=(b:bat[:sht],v:flt) :bat[:bit]
address CMDbatLE
comment "Return B <= V";
pattern <=(b:bat[:sht],v:flt,s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B <= V with candidates list";
pattern <=(v:sht,b:bat[:flt]) :bat[:bit]
address CMDbatLE
comment "Return V <= B";
pattern <=(v:sht,b:bat[:flt],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return V <= B with candidates list";

pattern <=(b1:bat[:sht],b2:bat[:dbl]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b1:bat[:sht],b2:bat[:dbl],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2 with candidates list";
pattern <=(b:bat[:sht],v:dbl) :bat[:bit]
address CMDbatLE
comment "Return B <= V";
pattern <=(b:bat[:sht],v:dbl,s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B <= V with candidates list";
pattern <=(v:sht,b:bat[:dbl]) :bat[:bit]
address CMDbatLE
comment "Return V <= B";
pattern <=(v:sht,b:bat[:dbl],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return V <= B with candidates list";

pattern <=(b1:bat[:int],b2:bat[:bte]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b1:bat[:int],b2:bat[:bte],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2 with candidates list";
pattern <=(b:bat[:int],v:bte) :bat[:bit]
address CMDbatLE
comment "Return B <= V";
pattern <=(b:bat[:int],v:bte,s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B <= V with candidates list";
pattern <=(v:int,b:bat[:bte]) :bat[:bit]
address CMDbatLE
comment "Return V <= B";
pattern <=(v:int,b:bat[:bte],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return V <= B with candidates list";

pattern <=(b1:bat[:int],b2:bat[:sht]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b1:bat[:int],b2:bat[:sht],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2 with candidates list";
pattern <=(b:bat[:int],v:sht) :bat[:bit]
address CMDbatLE
comment "Return B <= V";
pattern <=(b:bat[:int],v:sht,s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B <= V with candidates list";
pattern <=(v:int,b:bat[:sht]) :bat[:bit]
address CMDbatLE
comment "Return V <= B";
pattern <=(v:int,b:bat[:sht],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return V <= B with candidates list";

pattern <=(b1:bat[:int],b2:bat[:int]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b1:bat[:int],b2:bat[:int],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2 with candidates list";
pattern <=(b:bat[:int],v:int) :bat[:bit]
address CMDbatLE
comment "Return B <= V";
pattern <=(b:bat[:int],v:int,s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B <= V with candidates list";
pattern <=(v:int,b:bat[:int]) :bat[:bit]
address CMDbatLE
comment "Return V <= B";
pattern <=(v:int,b:bat[:int],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return V <= B with candidates list";

pattern <=(b1:bat[:int],b2:bat[:lng]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b1:bat[:int],b2:bat[:lng],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2 with candidates list";
pattern <=(b:bat[:int],v:lng) :bat[:bit]
address CMDbatLE
comment "Return B <= V";
pattern <=(b:bat[:int],v:lng,s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B <= V with candidates list";
pattern <=(v:int,b:bat[:lng]) :bat[:bit]
address CMDbatLE
comment "Return V <= B";
pattern <=(v:int,b:bat[:lng],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return V <= B with candidates list";

pattern <=(b1:bat[:int],b2:bat[:flt]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b1:bat[:int],b2:bat[:flt],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2 with candidates list";
pattern <=(b:bat[:int],v:flt) :bat[:bit]
address CMDbatLE
comment "Return B <= V";
pattern <=(b:bat[:int],v:flt,s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B <= V with candidates list";
pattern <=(v:int,b:bat[:flt]) :bat[:bit]
address CMDbatLE
comment "Return V <= B";
pattern <=(v:int,b:bat[:flt],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return V <= B with candidates list";

pattern <=(b1:bat[:int],b2:bat[:dbl]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b1:bat[:int],b2:bat[:dbl],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2 with candidates list";
pattern <=(b:bat[:int],v:dbl) :bat[:bit]
address CMDbatLE
comment "Return B <= V";
pattern <=(b:bat[:int],v:dbl,s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B <= V with candidates list";
pattern <=(v:int,b:bat[:dbl]) :bat[:bit]
address CMDbatLE
comment "Return V <= B";
pattern <=(v:int,b:bat[:dbl],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return V <= B with candidates list";

pattern <=(b1:bat[:lng],b2:bat[:bte]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2 with candidates list";
pattern <=(b:bat[:lng],v:bte) :bat[:bit]
address CMDbatLE
comment "Return B <= V";
pattern <=(b:bat[:lng],v:bte,s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B <= V with candidates list";
pattern <=(v:lng,b:bat[:bte]) :bat[:bit]
address CMDbatLE
comment "Return V <= B";
pattern <=(v:lng,b:bat[:bte],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return V <= B with candidates list";

pattern <=(b1:bat[:lng],b2:bat[:sht]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2 with candidates list";
pattern <=(b:bat[:lng],v:sht) :bat[:bit]
address CMDbatLE
comment "Return B <= V";
pattern <=(b:bat[:lng],v:sht,s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B <= V with candidates list";
pattern <=(v:lng,b:bat[:sht]) :bat[:bit]
address CMDbatLE
comment "Return V <= B";
pattern <=(v:lng,b:bat[:sht],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return V <= B with candidates list";

pattern <=(b1:bat[:lng],b2:bat[:int]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b1:bat[:lng],b2:bat[:int],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2 with candidates list";
pattern <=(b:bat[:lng],v:int) :bat[:bit]
address CMDbatLE
comment "Return B <= V";
pattern <=(b:bat[:lng],v:int,s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B <= V with candidates list";
pattern <=(v:lng,b:bat[:int]) :bat[:bit]
address CMDbatLE
comment "Return V <= B";
pattern <=(v:lng,b:bat[:int],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return V <= B with candidates list";

pattern <=(b1:bat[:lng],b2:bat[:lng]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2 with candidates list";
pattern <=(b:bat[:lng],v:lng) :bat[:bit]
address CMDbatLE
comment "Return B <= V";
pattern <=(b:bat[:lng],v:lng,s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B <= V with candidates list";
pattern <=(v:lng,b:bat[:lng]) :bat[:bit]
address CMDbatLE
comment "Return V <= B";
pattern <=(v:lng,b:bat[:lng],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return V <= B with candidates list";

pattern <=(b1:bat[:lng],b2:bat[:flt]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b1:bat[:lng],b2:bat[:flt],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2 with candidates list";
pattern <=(b:bat[:lng],v:flt) :bat[:bit]
address CMDbatLE
comment "Return B <= V";
pattern <=(b:bat[:lng],v:flt,s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B <= V with candidates list";
pattern <=(v:lng,b:bat[:flt]) :bat[:bit]
address CMDbatLE
comment "Return V <= B";
pattern <=(v:lng,b:bat[:flt],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return V <= B with candidates list";

pattern <=(b1:bat[:lng],b2:bat[:dbl]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b1:bat[:lng],b2:bat[:dbl],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2 with candidates list";
pattern <=(b:bat[:lng],v:dbl) :bat[:bit]
address CMDbatLE
comment "Return B <= V";
pattern <=(b:bat[:lng],v:dbl,s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B <= V with candidates list";
pattern <=(v:lng,b:bat[:dbl]) :bat[:bit]
address CMDbatLE
comment "Return V <= B";
pattern <=(v:lng,b:bat[:dbl],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return V <= B with candidates list";

pattern <=(b1:bat[:flt],b2:bat[:bte]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b1:bat[:flt],b2:bat[:bte],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2 with candidates list";
pattern <=(b:bat[:flt],v:bte) :bat[:bit]
address CMDbatLE
comment "Return B <= V";
pattern <=(b:bat[:flt],v:bte,s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B <= V with candidates list";
pattern <=(v:flt,b:bat[:bte]) :bat[:bit]
address CMDbatLE
comment "Return V <= B";
pattern <=(v:flt,b:bat[:bte],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return V <= B with candidates list";

pattern <=(b1:bat[:flt],b2:bat[:sht]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b1:bat[:flt],b2:bat[:sht],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2 with candidates list";
pattern <=(b:bat[:flt],v:sht) :bat[:bit]
address CMDbatLE
comment "Return B <= V";
pattern <=(b:bat[:flt],v:sht,s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B <= V with candidates list";
pattern <=(v:flt,b:bat[:sht]) :bat[:bit]
address CMDbatLE
comment "Return V <= B";
pattern <=(v:flt,b:bat[:sht],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return V <= B with candidates list";

pattern <=(b1:bat[:flt],b2:bat[:int]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b1:bat[:flt],b2:bat[:int],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2 with candidates list";
pattern <=(b:bat[:flt],v:int) :bat[:bit]
address CMDbatLE
comment "Return B <= V";
pattern <=(b:bat[:flt],v:int,s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B <= V with candidates list";
pattern <=(v:flt,b:bat[:int]) :bat[:bit]
address CMDbatLE
comment "Return V <= B";
pattern <=(v:flt,b:bat[:int],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return V <= B with candidates list";

pattern <=(b1:bat[:flt],b2:bat[:lng]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b1:bat[:flt],b2:bat[:lng],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2 with candidates list";
pattern <=(b:bat[:flt],v:lng) :bat[:bit]
address CMDbatLE
comment "Return B <= V";
pattern <=(b:bat[:flt],v:lng,s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B <= V with candidates list";
pattern <=(v:flt,b:bat[:lng]) :bat[:bit]
address CMDbatLE
comment "Return V <= B";
pattern <=(v:flt,b:bat[:lng],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return V <= B with candidates list";

pattern <=(b1:bat[:flt],b2:bat[:flt]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b1:bat[:flt],b2:bat[:flt],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2 with candidates list";
pattern <=(b:bat[:flt],v:flt) :bat[:bit]
address CMDbatLE
comment "Return B <= V";
pattern <=(b:bat[:flt],v:flt,s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B <= V with candidates list";
pattern <=(v:flt,b:bat[:flt]) :bat[:bit]
address CMDbatLE
comment "Return V <= B";
pattern <=(v:flt,b:bat[:flt],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return V <= B with candidates list";

pattern <=(b1:bat[:flt],b2:bat[:dbl]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b1:bat[:flt],b2:bat[:dbl],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2 with candidates list";
pattern <=(b:bat[:flt],v:dbl) :bat[:bit]
address CMDbatLE
comment "Return B <= V";
pattern <=(b:bat[:flt],v:dbl,s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B <= V with candidates list";
pattern <=(v:flt,b:bat[:dbl]) :bat[:bit]
address CMDbatLE
comment "Return V <= B";
pattern <=(v:flt,b:bat[:dbl],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return V <= B with candidates list";

pattern <=(b1:bat[:dbl],b2:bat[:bte]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b1:bat[:dbl],b2:bat[:bte],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2 with candidates list";
pattern <=(b:bat[:dbl],v:bte) :bat[:bit]
address CMDbatLE
comment "Return B <= V";
pattern <=(b:bat[:dbl],v:bte,s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B <= V with candidates list";
pattern <=(v:dbl,b:bat[:bte]) :bat[:bit]
address CMDbatLE
comment "Return V <= B";
pattern <=(v:dbl,b:bat[:bte],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return V <= B with candidates list";

pattern <=(b1:bat[:dbl],b2:bat[:sht]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b1:bat[:dbl],b2:bat[:sht],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2 with candidates list";
pattern <=(b:bat[:dbl],v:sht) :bat[:bit]
address CMDbatLE
comment "Return B <= V";
pattern <=(b:bat[:dbl],v:sht,s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B <= V with candidates list";
pattern <=(v:dbl,b:bat[:sht]) :bat[:bit]
address CMDbatLE
comment "Return V <= B";
pattern <=(v:dbl,b:bat[:sht],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return V <= B with candidates list";

pattern <=(b1:bat[:dbl],b2:bat[:int]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b1:bat[:dbl],b2:bat[:int],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2 with candidates list";
pattern <=(b:bat[:dbl],v:int) :bat[:bit]
address CMDbatLE
comment "Return B <= V";
pattern <=(b:bat[:dbl],v:int,s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B <= V with candidates list";
pattern <=(v:dbl,b:bat[:int]) :bat[:bit]
address CMDbatLE
comment "Return V <= B";
pattern <=(v:dbl,b:bat[:int],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return V <= B with candidates list";

pattern <=(b1:bat[:dbl],b2:bat[:lng]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b1:bat[:dbl],b2:bat[:lng],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2 with candidates list";
pattern <=(b:bat[:dbl],v:lng) :bat[:bit]
address CMDbatLE
comment "Return B <= V";
pattern <=(b:bat[:dbl],v:lng,s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B <= V with candidates list";
pattern <=(v:dbl,b:bat[:lng]) :bat[:bit]
address CMDbatLE
comment "Return V <= B";
pattern <=(v:dbl,b:bat[:lng],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return V <= B with candidates list";

pattern <=(b1:bat[:dbl],b2:bat[:flt]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b1:bat[:dbl],b2:bat[:flt],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2 with candidates list";
pattern <=(b:bat[:dbl],v:flt) :bat[:bit]
address CMDbatLE
comment "Return B <= V";
pattern <=(b:bat[:dbl],v:flt,s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B <= V with candidates list";
pattern <=(v:dbl,b:bat[:flt]) :bat[:bit]
address CMDbatLE
comment "Return V <= B";
pattern <=(v:dbl,b:bat[:flt],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return V <= B with candidates list";

pattern <=(b1:bat[:dbl],b2:bat[:dbl]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b1:bat[:dbl],b2:bat[:dbl],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2 with candidates list";
pattern <=(b:bat[:dbl],v:dbl) :bat[:bit]
address CMDbatLE
comment "Return B <= V";
pattern <=(b:bat[:dbl],v:dbl,s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B <= V with candidates list";
pattern <=(v:dbl,b:bat[:dbl]) :bat[:bit]
address CMDbatLE
comment "Return V <= B";
pattern <=(v:dbl,b:bat[:dbl],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return V <= B with candidates list";


pattern >(b1:bat[:bit],b2:bat[:bit]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b1:bat[:bit],b2:bat[:bit],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2 with candidates list";
pattern >(b:bat[:bit],v:bit) :bat[:bit]
address CMDbatGT
comment "Return B > V";
pattern >(b:bat[:bit],v:bit,s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B > V with candidates list";
pattern >(v:bit,b:bat[:bit]) :bat[:bit]
address CMDbatGT
comment "Return V > B";
pattern >(v:bit,b:bat[:bit],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return V > B with candidates list";

pattern >(b1:bat[:str],b2:bat[:str]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b1:bat[:str],b2:bat[:str],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2 with candidates list";
pattern >(b:bat[:str],v:str) :bat[:bit]
address CMDbatGT
comment "Return B > V";
pattern >(b:bat[:str],v:str,s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B > V with candidates list";
pattern >(v:str,b:bat[:str]) :bat[:bit]
address CMDbatGT
comment "Return V > B";
pattern >(v:str,b:bat[:str],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return V > B with candidates list";

pattern >(b1:bat[:oid],b2:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b1:bat[:oid],b2:bat[:oid],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2 with candidates list";
pattern >(b:bat[:oid],v:oid) :bat[:bit]
address CMDbatGT
comment "Return B > V";
pattern >(b:bat[:oid],v:oid,s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B > V with candidates list";
pattern >(v:oid,b:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return V > B";
pattern >(v:oid,b:bat[:oid],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return V > B with candidates list";

pattern >(b1:bat[:bte],b2:bat[:bte]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2 with candidates list";
pattern >(b:bat[:bte],v:bte) :bat[:bit]
address CMDbatGT
comment "Return B > V";
pattern >(b:bat[:bte],v:bte,s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B > V with candidates list";
pattern >(v:bte,b:bat[:bte]) :bat[:bit]
address CMDbatGT
comment "Return V > B";
pattern >(v:bte,b:bat[:bte],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return V > B with candidates list";

pattern >(b1:bat[:bte],b2:bat[:sht]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2 with candidates list";
pattern >(b:bat[:bte],v:sht) :bat[:bit]
address CMDbatGT
comment "Return B > V";
pattern >(b:bat[:bte],v:sht,s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B > V with candidates list";
pattern >(v:bte,b:bat[:sht]) :bat[:bit]
address CMDbatGT
comment "Return V > B";
pattern >(v:bte,b:bat[:sht],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return V > B with candidates list";

pattern >(b1:bat[:bte],b2:bat[:int]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b1:bat[:bte],b2:bat[:int],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2 with candidates list";
pattern >(b:bat[:bte],v:int) :bat[:bit]
address CMDbatGT
comment "Return B > V";
pattern >(b:bat[:bte],v:int,s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B > V with candidates list";
pattern >(v:bte,b:bat[:int]) :bat[:bit]
address CMDbatGT
comment "Return V > B";
pattern >(v:bte,b:bat[:int],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return V > B with candidates list";

pattern >(b1:bat[:bte],b2:bat[:lng]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2 with candidates list";
pattern >(b:bat[:bte],v:lng) :bat[:bit]
address CMDbatGT
comment "Return B > V";
pattern >(b:bat[:bte],v:lng,s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B > V with candidates list";
pattern >(v:bte,b:bat[:lng]) :bat[:bit]
address CMDbatGT
comment "Return V > B";
pattern >(v:bte,b:bat[:lng],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return V > B with candidates list";

pattern >(b1:bat[:bte],b2:bat[:flt]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2 with candidates list";
pattern >(b:bat[:bte],v:flt) :bat[:bit]
address CMDbatGT
comment "Return B > V";
pattern >(b:bat[:bte],v:flt,s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B > V with candidates list";
pattern >(v:bte,b:bat[:flt]) :bat[:bit]
address CMDbatGT
comment "Return V > B";
pattern >(v:bte,b:bat[:flt],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return V > B with candidates list";

pattern >(b1:bat[:bte],b2:bat[:dbl]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b1:bat[:bte],b2:bat[:dbl],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2 with candidates list";
pattern >(b:bat[:bte],v:dbl) :bat[:bit]
address CMDbatGT
comment "Return B > V";
pattern >(b:bat[:bte],v:dbl,s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B > V with candidates list";
pattern >(v:bte,b:bat[:dbl]) :bat[:bit]
address CMDbatGT
comment "Return V > B";
pattern >(v:bte,b:bat[:dbl],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return V > B with candidates list";

pattern >(b1:bat[:sht],b2:bat[:bte]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2 with candidates list";
pattern >(b:bat[:sht],v:bte) :bat[:bit]
address CMDbatGT
comment "Return B > V";
pattern >(b:bat[:sht],v:bte,s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B > V with candidates list";
pattern >(v:sht,b:bat[:bte]) :bat[:bit]
address CMDbatGT
comment "Return V > B";
pattern >(v:sht,b:bat[:bte],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return V > B with candidates list";

pattern >(b1:bat[:sht],b2:bat[:sht]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2 with candidates list";
pattern >(b:bat[:sht],v:sht) :bat[:bit]
address CMDbatGT
comment "Return B > V";
pattern >(b:bat[:sht],v:sht,s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B > V with candidates list";
pattern >(v:sht,b:bat[:sht]) :bat[:bit]
address CMDbatGT
comment "Return V > B";
pattern >(v:sht,b:bat[:sht],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return V > B with candidates list";

pattern >(b1:bat[:sht],b2:bat[:int]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b1:bat[:sht],b2:bat[:int],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2 with candidates list";
pattern >(b:bat[:sht],v:int) :bat[:bit]
address CMDbatGT
comment "Return B > V";
pattern >(b:bat[:sht],v:int,s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B > V with candidates list";
pattern >(v:sht,b:bat[:int]) :bat[:bit]
address CMDbatGT
comment "Return V > B";
pattern >(v:sht,b:bat[:int],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return V > B with candidates list";

pattern >(b1:bat[:sht],b2:bat[:lng]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2 with candidates list";
pattern >(b:bat[:sht],v:lng) :bat[:bit]
address CMDbatGT
comment "Return B > V";
pattern >(b:bat[:sht],v:lng,s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B > V with candidates list";
pattern >(v:sht,b:bat[:lng]) :bat[:bit]
address CMDbatGT
comment "Return V > B";
pattern >(v:sht,b:bat[:lng],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return V > B with candidates list";

pattern >(b1:bat[:sht],b2:bat[:flt]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b1:bat[:sht],b2:bat[:flt],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2 with candidates list";
pattern >(b:bat[:sht],v:flt) :bat[:bit]
address CMDbatGT
comment "Return B > V";
pattern >(b:bat[:sht],v:flt,s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B > V with candidates list";
pattern >(v:sht,b:bat[:flt]) :bat[:bit]
address CMDbatGT
comment "Return V > B";
pattern >(v:sht,b:bat[:flt],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return V > B with candidates list";

pattern >(b1:bat[:sht],b2:bat[:dbl]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b1:bat[:sht],b2:bat[:dbl],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2 with candidates list";
pattern >(b:bat[:sht],v:dbl) :bat[:bit]
address CMDbatGT
comment "Return B > V";
pattern >(b:bat[:sht],v:dbl,s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B > V with candidates list";
pattern >(v:sht,b:bat[:dbl]) :bat[:bit]
address CMDbatGT
comment "Return V > B";
pattern >(v:sht,b:bat[:dbl],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return V > B with candidates list";

pattern >(b1:bat[:int],b2:bat[:bte]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b1:bat[:int],b2:bat[:bte],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2 with candidates list";
pattern >(b:bat[:int],v:bte) :bat[:bit]
address CMDbatGT
comment "Return B > V";
pattern >(b:bat[:int],v:bte,s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B > V with candidates list";
pattern >(v:int,b:bat[:bte]) :bat[:bit]
address CMDbatGT
comment "Return V > B";
pattern >(v:int,b:bat[:bte],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return V > B with candidates list";

pattern >(b1:bat[:int],b2:bat[:sht]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b1:bat[:int],b2:bat[:sht],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2 with candidates list";
pattern >(b:bat[:int],v:sht) :bat[:bit]
address CMDbatGT
comment "Return B > V";
pattern >(b:bat[:int],v:sht,s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B > V with candidates list";
pattern >(v:int,b:bat[:sht]) :bat[:bit]
address CMDbatGT
comment "Return V > B";
pattern >(v:int,b:bat[:sht],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return V > B with candidates list";

pattern >(b1:bat[:int],b2:bat[:int]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b1:bat[:int],b2:bat[:int],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2 with candidates list";
pattern >(b:bat[:int],v:int) :bat[:bit]
address CMDbatGT
comment "Return B > V";
pattern >(b:bat[:int],v:int,s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B > V with candidates list";
pattern >(v:int,b:bat[:int]) :bat[:bit]
address CMDbatGT
comment "Return V > B";
pattern >(v:int,b:bat[:int],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return V > B with candidates list";

pattern >(b1:bat[:int],b2:bat[:lng]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b1:bat[:int],b2:bat[:lng],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2 with candidates list";
pattern >(b:bat[:int],v:lng) :bat[:bit]
address CMDbatGT
comment "Return B > V";
pattern >(b:bat[:int],v:lng,s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B > V with candidates list";
pattern >(v:int,b:bat[:lng]) :bat[:bit]
address CMDbatGT
comment "Return V > B";
pattern >(v:int,b:bat[:lng],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return V > B with candidates list";

pattern >(b1:bat[:int],b2:bat[:flt]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b1:bat[:int],b2:bat[:flt],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2 with candidates list";
pattern >(b:bat[:int],v:flt) :bat[:bit]
address CMDbatGT
comment "Return B > V";
pattern >(b:bat[:int],v:flt,s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B > V with candidates list";
pattern >(v:int,b:bat[:flt]) :bat[:bit]
address CMDbatGT
comment "Return V > B";
pattern >(v:int,b:bat[:flt],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return V > B with candidates list";

pattern >(b1:bat[:int],b2:bat[:dbl]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b1:bat[:int],b2:bat[:dbl],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2 with candidates list";
pattern >(b:bat[:int],v:dbl) :bat[:bit]
address CMDbatGT
comment "Return B > V";
pattern >(b:bat[:int],v:dbl,s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B > V with candidates list";
pattern >(v:int,b:bat[:dbl]) :bat[:bit]
address CMDbatGT
comment "Return V > B";
pattern >(v:int,b:bat[:dbl],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return V > B with candidates list";

pattern >(b1:bat[:lng],b2:bat[:bte]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2 with candidates list";
pattern >(b:bat[:lng],v:bte) :bat[:bit]
address CMDbatGT
comment "Return B > V";
pattern >(b:bat[:lng],v:bte,s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B > V with candidates list";
pattern >(v:lng,b:bat[:bte]) :bat[:bit]
address CMDbatGT
comment "Return V > B";
pattern >(v:lng,b:bat[:bte],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return V > B with candidates list";

pattern >(b1:bat[:lng],b2:bat[:sht]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2 with candidates list";
pattern >(b:bat[:lng],v:sht) :bat[:bit]
address CMDbatGT
comment "Return B > V";
pattern >(b:bat[:lng],v:sht,s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B > V with candidates list";
pattern >(v:lng,b:bat[:sht]) :bat[:bit]
address CMDbatGT
comment "Return V > B";
pattern >(v:lng,b:bat[:sht],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return V > B with candidates list";

pattern >(b1:bat[:lng],b2:bat[:int]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b1:bat[:lng],b2:bat[:int],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2 with candidates list";
pattern >(b:bat[:lng],v:int) :bat[:bit]
address CMDbatGT
comment "Return B > V";
pattern >(b:bat[:lng],v:int,s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B > V with candidates list";
pattern >(v:lng,b:bat[:int]) :bat[:bit]
address CMDbatGT
comment "Return V > B";
pattern >(v:lng,b:bat[:int],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return V > B with candidates list";

pattern >(b1:bat[:lng],b2:bat[:lng]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2 with candidates list";
pattern >(b:bat[:lng],v:lng) :bat[:bit]
address CMDbatGT
comment "Return B > V";
pattern >(b:bat[:lng],v:lng,s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B > V with candidates list";
pattern >(v:lng,b:bat[:lng]) :bat[:bit]
address CMDbatGT
comment "Return V > B";
pattern >(v:lng,b:bat[:lng],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return V > B with candidates list";

pattern >(b1:bat[:lng],b2:bat[:flt]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b1:bat[:lng],b2:bat[:flt],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2 with candidates list";
pattern >(b:bat[:lng],v:flt) :bat[:bit]
address CMDbatGT
comment "Return B > V";
pattern >(b:bat[:lng],v:flt,s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B > V with candidates list";
pattern >(v:lng,b:bat[:flt]) :bat[:bit]
address CMDbatGT
comment "Return V > B";
pattern >(v:lng,b:bat[:flt],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return V > B with candidates list";

pattern >(b1:bat[:lng],b2:bat[:dbl]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b1:bat[:lng],b2:bat[:dbl],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2 with candidates list";
pattern >(b:bat[:lng],v:dbl) :bat[:bit]
address CMDbatGT
comment "Return B > V";
pattern >(b:bat[:lng],v:dbl,s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B > V with candidates list";
pattern >(v:lng,b:bat[:dbl]) :bat[:bit]
address CMDbatGT
comment "Return V > B";
pattern >(v:lng,b:bat[:dbl],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return V > B with candidates list";

pattern >(b1:bat[:flt],b2:bat[:bte]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b1:bat[:flt],b2:bat[:bte],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2 with candidates list";
pattern >(b:bat[:flt],v:bte) :bat[:bit]
address CMDbatGT
comment "Return B > V";
pattern >(b:bat[:flt],v:bte,s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B > V with candidates list";
pattern >(v:flt,b:bat[:bte]) :bat[:bit]
address CMDbatGT
comment "Return V > B";
pattern >(v:flt,b:bat[:bte],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return V > B with candidates list";

pattern >(b1:bat[:flt],b2:bat[:sht]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b1:bat[:flt],b2:bat[:sht],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2 with candidates list";
pattern >(b:bat[:flt],v:sht) :bat[:bit]
address CMDbatGT
comment "Return B > V";
pattern >(b:bat[:flt],v:sht,s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B > V with candidates list";
pattern >(v:flt,b:bat[:sht]) :bat[:bit]
address CMDbatGT
comment "Return V > B";
pattern >(v:flt,b:bat[:sht],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return V > B with candidates list";

pattern >(b1:bat[:flt],b2:bat[:int]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b1:bat[:flt],b2:bat[:int],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2 with candidates list";
pattern >(b:bat[:flt],v:int) :bat[:bit]
address CMDbatGT
comment "Return B > V";
pattern >(b:bat[:flt],v:int,s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B > V with candidates list";
pattern >(v:flt,b:bat[:int]) :bat[:bit]
address CMDbatGT
comment "Return V > B";
pattern >(v:flt,b:bat[:int],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return V > B with candidates list";

pattern >(b1:bat[:flt],b2:bat[:lng]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b1:bat[:flt],b2:bat[:lng],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2 with candidates list";
pattern >(b:bat[:flt],v:lng) :bat[:bit]
address CMDbatGT
comment "Return B > V";
pattern >(b:bat[:flt],v:lng,s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B > V with candidates list";
pattern >(v:flt,b:bat[:lng]) :bat[:bit]
address CMDbatGT
comment "Return V > B";
pattern >(v:flt,b:bat[:lng],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return V > B with candidates list";

pattern >(b1:bat[:flt],b2:bat[:flt]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b1:bat[:flt],b2:bat[:flt],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2 with candidates list";
pattern >(b:bat[:flt],v:flt) :bat[:bit]
address CMDbatGT
comment "Return B > V";
pattern >(b:bat[:flt],v:flt,s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B > V with candidates list";
pattern >(v:flt,b:bat[:flt]) :bat[:bit]
address CMDbatGT
comment "Return V > B";
pattern >(v:flt,b:bat[:flt],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return V > B with candidates list";

pattern >(b1:bat[:flt],b2:bat[:dbl]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b1:bat[:flt],b2:bat[:dbl],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2 with candidates list";
pattern >(b:bat[:flt],v:dbl) :bat[:bit]
address CMDbatGT
comment "Return B > V";
pattern >(b:bat[:flt],v:dbl,s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B > V with candidates list";
pattern >(v:flt,b:bat[:dbl]) :bat[:bit]
address CMDbatGT
comment "Return V > B";
pattern >(v:flt,b:bat[:dbl],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return V > B with candidates list";

pattern >(b1:bat[:dbl],b2:bat[:bte]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b1:bat[:dbl],b2:bat[:bte],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2 with candidates list";
pattern >(b:bat[:dbl],v:bte) :bat[:bit]
address CMDbatGT
comment "Return B > V";
pattern >(b:bat[:dbl],v:bte,s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B > V with candidates list";
pattern >(v:dbl,b:bat[:bte]) :bat[:bit]
address CMDbatGT
comment "Return V > B";
pattern >(v:dbl,b:bat[:bte],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return V > B with candidates list";

pattern >(b1:bat[:dbl],b2:bat[:sht]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b1:bat[:dbl],b2:bat[:sht],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2 with candidates list";
pattern >(b:bat[:dbl],v:sht) :bat[:bit]
address CMDbatGT
comment "Return B > V";
pattern >(b:bat[:dbl],v:sht,s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B > V with candidates list";
pattern >(v:dbl,b:bat[:sht]) :bat[:bit]
address CMDbatGT
comment "Return V > B";
pattern >(v:dbl,b:bat[:sht],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return V > B with candidates list";

pattern >(b1:bat[:dbl],b2:bat[:int]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b1:bat[:dbl],b2:bat[:int],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2 with candidates list";
pattern >(b:bat[:dbl],v:int) :bat[:bit]
address CMDbatGT
comment "Return B > V";
pattern >(b:bat[:dbl],v:int,s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B > V with candidates list";
pattern >(v:dbl,b:bat[:int]) :bat[:bit]
address CMDbatGT
comment "Return V > B";
pattern >(v:dbl,b:bat[:int],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return V > B with candidates list";

pattern >(b1:bat[:dbl],b2:bat[:lng]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b1:bat[:dbl],b2:bat[:lng],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2 with candidates list";
pattern >(b:bat[:dbl],v:lng) :bat[:bit]
address CMDbatGT
comment "Return B > V";
pattern >(b:bat[:dbl],v:lng,s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B > V with candidates list";
pattern >(v:dbl,b:bat[:lng]) :bat[:bit]
address CMDbatGT
comment "Return V > B";
pattern >(v:dbl,b:bat[:lng],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return V > B with candidates list";

pattern >(b1:bat[:dbl],b2:bat[:flt]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b1:bat[:dbl],b2:bat[:flt],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2 with candidates list";
pattern >(b:bat[:dbl],v:flt) :bat[:bit]
address CMDbatGT
comment "Return B > V";
pattern >(b:bat[:dbl],v:flt,s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B > V with candidates list";
pattern >(v:dbl,b:bat[:flt]) :bat[:bit]
address CMDbatGT
comment "Return V > B";
pattern >(v:dbl,b:bat[:flt],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return V > B with candidates list";

pattern >(b1:bat[:dbl],b2:bat[:dbl]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b1:bat[:dbl],b2:bat[:dbl],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2 with candidates list";
pattern >(b:bat[:dbl],v:dbl) :bat[:bit]
address CMDbatGT
comment "Return B > V";
pattern >(b:bat[:dbl],v:dbl,s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B > V with candidates list";
pattern >(v:dbl,b:bat[:dbl]) :bat[:bit]
address CMDbatGT
comment "Return V > B";
pattern >(v:dbl,b:bat[:dbl],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return V > B with candidates list";


pattern >=(b1:bat[:bit],b2:bat[:bit]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b1:bat[:bit],b2:bat[:bit],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2 with candidates list";
pattern >=(b:bat[:bit],v:bit) :bat[:bit]
address CMDbatGE
comment "Return B >= V";
pattern >=(b:bat[:bit],v:bit,s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B >= V with candidates list";
pattern >=(v:bit,b:bat[:bit]) :bat[:bit]
address CMDbatGE
comment "Return V >= B";
pattern >=(v:bit,b:bat[:bit],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return V >= B with candidates list";

pattern >=(b1:bat[:str],b2:bat[:str]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b1:bat[:str],b2:bat[:str],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2 with candidates list";
pattern >=(b:bat[:str],v:str) :bat[:bit]
address CMDbatGE
comment "Return B >= V";
pattern >=(b:bat[:str],v:str,s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B >= V with candidates list";
pattern >=(v:str,b:bat[:str]) :bat[:bit]
address CMDbatGE
comment "Return V >= B";
pattern >=(v:str,b:bat[:str],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return V >= B with candidates list";

pattern >=(b1:bat[:oid],b2:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b1:bat[:oid],b2:bat[:oid],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2 with candidates list";
pattern >=(b:bat[:oid],v:oid) :bat[:bit]
address CMDbatGE
comment "Return B >= V";
pattern >=(b:bat[:oid],v:oid,s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B >= V with candidates list";
pattern >=(v:oid,b:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return V >= B";
pattern >=(v:oid,b:bat[:oid],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return V >= B with candidates list";

pattern >=(b1:bat[:bte],b2:bat[:bte]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2 with candidates list";
pattern >=(b:bat[:bte],v:bte) :bat[:bit]
address CMDbatGE
comment "Return B >= V";
pattern >=(b:bat[:bte],v:bte,s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B >= V with candidates list";
pattern >=(v:bte,b:bat[:bte]) :bat[:bit]
address CMDbatGE
comment "Return V >= B";
pattern >=(v:bte,b:bat[:bte],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return V >= B with candidates list";

pattern >=(b1:bat[:bte],b2:bat[:sht]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2 with candidates list";
pattern >=(b:bat[:bte],v:sht) :bat[:bit]
address CMDbatGE
comment "Return B >= V";
pattern >=(b:bat[:bte],v:sht,s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B >= V with candidates list";
pattern >=(v:bte,b:bat[:sht]) :bat[:bit]
address CMDbatGE
comment "Return V >= B";
pattern >=(v:bte,b:bat[:sht],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return V >= B with candidates list";

pattern >=(b1:bat[:bte],b2:bat[:int]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b1:bat[:bte],b2:bat[:int],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2 with candidates list";
pattern >=(b:bat[:bte],v:int) :bat[:bit]
address CMDbatGE
comment "Return B >= V";
pattern >=(b:bat[:bte],v:int,s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B >= V with candidates list";
pattern >=(v:bte,b:bat[:int]) :bat[:bit]
address CMDbatGE
comment "Return V >= B";
pattern >=(v:bte,b:bat[:int],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return V >= B with candidates list";

pattern >=(b1:bat[:bte],b2:bat[:lng]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2 with candidates list";
pattern >=(b:bat[:bte],v:lng) :bat[:bit]
address CMDbatGE
comment "Return B >= V";
pattern >=(b:bat[:bte],v:lng,s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B >= V with candidates list";
pattern >=(v:bte,b:bat[:lng]) :bat[:bit]
address CMDbatGE
comment "Return V >= B";
pattern >=(v:bte,b:bat[:lng],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return V >= B with candidates list";

pattern >=(b1:bat[:bte],b2:bat[:flt]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2 with candidates list";
pattern >=(b:bat[:bte],v:flt) :bat[:bit]
address CMDbatGE
comment "Return B >= V";
pattern >=(b:bat[:bte],v:flt,s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B >= V with candidates list";
pattern >=(v:bte,b:bat[:flt]) :bat[:bit]
address CMDbatGE
comment "Return V >= B";
pattern >=(v:bte,b:bat[:flt],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return V >= B with candidates list";

pattern >=(b1:bat[:bte],b2:bat[:dbl]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b1:bat[:bte],b2:bat[:dbl],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2 with candidates list";
pattern >=(b:bat[:bte],v:dbl) :bat[:bit]
address CMDbatGE
comment "Return B >= V";
pattern >=(b:bat[:bte],v:dbl,s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B >= V with candidates list";
pattern >=(v:bte,b:bat[:dbl]) :bat[:bit]
address CMDbatGE
comment "Return V >= B";
pattern >=(v:bte,b:bat[:dbl],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return V >= B with candidates list";

pattern >=(b1:bat[:sht],b2:bat[:bte]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2 with candidates list";
pattern >=(b:bat[:sht],v:bte) :bat[:bit]
address CMDbatGE
comment "Return B >= V";
pattern >=(b:bat[:sht],v:bte,s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B >= V with candidates list";
pattern >=(v:sht,b:bat[:bte]) :bat[:bit]
address CMDbatGE
comment "Return V >= B";
pattern >=(v:sht,b:bat[:bte],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return V >= B with candidates list";

pattern >=(b1:bat[:sht],b2:bat[:sht]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2 with candidates list";
pattern >=(b:bat[:sht],v:sht) :bat[:bit]
address CMDbatGE
comment "Return B >= V";
pattern >=(b:bat[:sht],v:sht,s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B >= V with candidates list";
pattern >=(v:sht,b:bat[:sht]) :bat[:bit]
address CMDbatGE
comment "Return V >= B";
pattern >=(v:sht,b:bat[:sht],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return V >= B with candidates list";

pattern >=(b1:bat[:sht],b2:bat[:int]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b1:bat[:sht],b2:bat[:int],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2 with candidates list";
pattern >=(b:bat[:sht],v:int) :bat[:bit]
address CMDbatGE
comment "Return B >= V";
pattern >=(b:bat[:sht],v:int,s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B >= V with candidates list";
pattern >=(v:sht,b:bat[:int]) :bat[:bit]
address CMDbatGE
comment "Return V >= B";
pattern >=(v:sht,b:bat[:int],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return V >= B with candidates list";

pattern >=(b1:bat[:sht],b2:bat[:lng]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2 with candidates list";
pattern >=(b:bat[:sht],v:lng) :bat[:bit]
address CMDbatGE
comment "Return B >= V";
pattern >=(b:bat[:sht],v:lng,s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B >= V with candidates list";
pattern >=(v:sht,b:bat[:lng]) :bat[:bit]
address CMDbatGE
comment "Return V >= B";
pattern >=(v:sht,b:bat[:lng],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return V >= B with candidates list";

pattern >=(b1:bat[:sht],b2:bat[:flt]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b1:bat[:sht],b2:bat[:flt],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2 with candidates list";
pattern >=(b:bat[:sht],v:flt) :bat[:bit]
address CMDbatGE
comment "Return B >= V";
pattern >=(b:bat[:sht],v:flt,s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B >= V with candidates list";
pattern >=(v:sht,b:bat[:flt]) :bat[:bit]
address CMDbatGE
comment "Return V >= B";
pattern >=(v:sht,b:bat[:flt],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return V >= B with candidates list";

pattern >=(b1:bat[:sht],b2:bat[:dbl]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b1:bat[:sht],b2:bat[:dbl],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2 with candidates list";
pattern >=(b:bat[:sht],v:dbl) :bat[:bit]
address CMDbatGE
comment "Return B >= V";
pattern >=(b:bat[:sht],v:dbl,s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B >= V with candidates list";
pattern >=(v:sht,b:bat[:dbl]) :bat[:bit]
address CMDbatGE
comment "Return V >= B";
pattern >=(v:sht,b:bat[:dbl],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return V >= B with candidates list";

pattern >=(b1:bat[:int],b2:bat[:bte]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b1:bat[:int],b2:bat[:bte],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2 with candidates list";
pattern >=(b:bat[:int],v:bte) :bat[:bit]
address CMDbatGE
comment "Return B >= V";
pattern >=(b:bat[:int],v:bte,s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B >= V with candidates list";
pattern >=(v:int,b:bat[:bte]) :bat[:bit]
address CMDbatGE
comment "Return V >= B";
pattern >=(v:int,b:bat[:bte],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return V >= B with candidates list";

pattern >=(b1:bat[:int],b2:bat[:sht]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b1:bat[:int],b2:bat[:sht],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2 with candidates list";
pattern >=(b:bat[:int],v:sht) :bat[:bit]
address CMDbatGE
comment "Return B >= V";
pattern >=(b:bat[:int],v:sht,s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B >= V with candidates list";
pattern >=(v:int,b:bat[:sht]) :bat[:bit]
address CMDbatGE
comment "Return V >= B";
pattern >=(v:int,b:bat[:sht],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return V >= B with candidates list";

pattern >=(b1:bat[:int],b2:bat[:int]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b1:bat[:int],b2:bat[:int],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2 with candidates list";
pattern >=(b:bat[:int],v:int) :bat[:bit]
address CMDbatGE
comment "Return B >= V";
pattern >=(b:bat[:int],v:int,s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B >= V with candidates list";
pattern >=(v:int,b:bat[:int]) :bat[:bit]
address CMDbatGE
comment "Return V >= B";
pattern >=(v:int,b:bat[:int],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return V >= B with candidates list";

pattern >=(b1:bat[:int],b2:bat[:lng]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b1:bat[:int],b2:bat[:lng],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2 with candidates list";
pattern >=(b:bat[:int],v:lng) :bat[:bit]
address CMDbatGE
comment "Return B >= V";
pattern >=(b:bat[:int],v:lng,s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B >= V with candidates list";
pattern >=(v:int,b:bat[:lng]) :bat[:bit]
address CMDbatGE
comment "Return V >= B";
pattern >=(v:int,b:bat[:lng],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return V >= B with candidates list";

pattern >=(b1:bat[:int],b2:bat[:flt]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b1:bat[:int],b2:bat[:flt],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2 with candidates list";
pattern >=(b:bat[:int],v:flt) :bat[:bit]
address CMDbatGE
comment "Return B >= V";
pattern >=(b:bat[:int],v:flt,s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B >= V with candidates list";
pattern >=(v:int,b:bat[:flt]) :bat[:bit]
address CMDbatGE
comment "Return V >= B";
pattern >=(v:int,b:bat[:flt],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return V >= B with candidates list";

pattern >=(b1:bat[:int],b2:bat[:dbl]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b1:bat[:int],b2:bat[:dbl],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2 with candidates list";
pattern >=(b:bat[:int],v:dbl) :bat[:bit]
address CMDbatGE
comment "Return B >= V";
pattern >=(b:bat[:int],v:dbl,s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B >= V with candidates list";
pattern >=(v:int,b:bat[:dbl]) :bat[:bit]
address CMDbatGE
comment "Return V >= B";
pattern >=(v:int,b:bat[:dbl],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return V >= B with candidates list";

pattern >=(b1:bat[:lng],b2:bat[:bte]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2 with candidates list";
pattern >=(b:bat[:lng],v:bte) :bat[:bit]
address CMDbatGE
comment "Return B >= V";
pattern >=(b:bat[:lng],v:bte,s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B >= V with candidates list";
pattern >=(v:lng,b:bat[:bte]) :bat[:bit]
address CMDbatGE
comment "Return V >= B";
pattern >=(v:lng,b:bat[:bte],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return V >= B with candidates list";

pattern >=(b1:bat[:lng],b2:bat[:sht]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2 with candidates list";
pattern >=(b:bat[:lng],v:sht) :bat[:bit]
address CMDbatGE
comment "Return B >= V";
pattern >=(b:bat[:lng],v:sht,s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B >= V with candidates list";
pattern >=(v:lng,b:bat[:sht]) :bat[:bit]
address CMDbatGE
comment "Return V >= B";
pattern >=(v:lng,b:bat[:sht],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return V >= B with candidates list";

pattern >=(b1:bat[:lng],b2:bat[:int]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b1:bat[:lng],b2:bat[:int],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2 with candidates list";
pattern >=(b:bat[:lng],v:int) :bat[:bit]
address CMDbatGE
comment "Return B >= V";
pattern >=(b:bat[:lng],v:int,s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B >= V with candidates list";
pattern >=(v:lng,b:bat[:int]) :bat[:bit]
address CMDbatGE
comment "Return V >= B";
pattern >=(v:lng,b:bat[:int],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return V >= B with candidates list";

pattern >=(b1:bat[:lng],b2:bat[:lng]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2 with candidates list";
pattern >=(b:bat[:lng],v:lng) :bat[:bit]
address CMDbatGE
comment "Return B >= V";
pattern >=(b:bat[:lng],v:lng,s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B >= V with candidates list";
pattern >=(v:lng,b:bat[:lng]) :bat[:bit]
address CMDbatGE
comment "Return V >= B";
pattern >=(v:lng,b:bat[:lng],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return V >= B with candidates list";

pattern >=(b1:bat[:lng],b2:bat[:flt]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b1:bat[:lng],b2:bat[:flt],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2 with candidates list";
pattern >=(b:bat[:lng],v:flt) :bat[:bit]
address CMDbatGE
comment "Return B >= V";
pattern >=(b:bat[:lng],v:flt,s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B >= V with candidates list";
pattern >=(v:lng,b:bat[:flt]) :bat[:bit]
address CMDbatGE
comment "Return V >= B";
pattern >=(v:lng,b:bat[:flt],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return V >= B with candidates list";

pattern >=(b1:bat[:lng],b2:bat[:dbl]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b1:bat[:lng],b2:bat[:dbl],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2 with candidates list";
pattern >=(b:bat[:lng],v:dbl) :bat[:bit]
address CMDbatGE
comment "Return B >= V";
pattern >=(b:bat[:lng],v:dbl,s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B >= V with candidates list";
pattern >=(v:lng,b:bat[:dbl]) :bat[:bit]
address CMDbatGE
comment "Return V >= B";
pattern >=(v:lng,b:bat[:dbl],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return V >= B with candidates list";

pattern >=(b1:bat[:flt],b2:bat[:bte]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b1:bat[:flt],b2:bat[:bte],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2 with candidates list";
pattern >=(b:bat[:flt],v:bte) :bat[:bit]
address CMDbatGE
comment "Return B >= V";
pattern >=(b:bat[:flt],v:bte,s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B >= V with candidates list";
pattern >=(v:flt,b:bat[:bte]) :bat[:bit]
address CMDbatGE
comment "Return V >= B";
pattern >=(v:flt,b:bat[:bte],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return V >= B with candidates list";

pattern >=(b1:bat[:flt],b2:bat[:sht]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b1:bat[:flt],b2:bat[:sht],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2 with candidates list";
pattern >=(b:bat[:flt],v:sht) :bat[:bit]
address CMDbatGE
comment "Return B >= V";
pattern >=(b:bat[:flt],v:sht,s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B >= V with candidates list";
pattern >=(v:flt,b:bat[:sht]) :bat[:bit]
address CMDbatGE
comment "Return V >= B";
pattern >=(v:flt,b:bat[:sht],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return V >= B with candidates list";

pattern >=(b1:bat[:flt],b2:bat[:int]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b1:bat[:flt],b2:bat[:int],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2 with candidates list";
pattern >=(b:bat[:flt],v:int) :bat[:bit]
address CMDbatGE
comment "Return B >= V";
pattern >=(b:bat[:flt],v:int,s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B >= V with candidates list";
pattern >=(v:flt,b:bat[:int]) :bat[:bit]
address CMDbatGE
comment "Return V >= B";
pattern >=(v:flt,b:bat[:int],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return V >= B with candidates list";

pattern >=(b1:bat[:flt],b2:bat[:lng]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b1:bat[:flt],b2:bat[:lng],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2 with candidates list";
pattern >=(b:bat[:flt],v:lng) :bat[:bit]
address CMDbatGE
comment "Return B >= V";
pattern >=(b:bat[:flt],v:lng,s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B >= V with candidates list";
pattern >=(v:flt,b:bat[:lng]) :bat[:bit]
address CMDbatGE
comment "Return V >= B";
pattern >=(v:flt,b:bat[:lng],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return V >= B with candidates list";

pattern >=(b1:bat[:flt],b2:bat[:flt]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b1:bat[:flt],b2:bat[:flt],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2 with candidates list";
pattern >=(b:bat[:flt],v:flt) :bat[:bit]
address CMDbatGE
comment "Return B >= V";
pattern >=(b:bat[:flt],v:flt,s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B >= V with candidates list";
pattern >=(v:flt,b:bat[:flt]) :bat[:bit]
address CMDbatGE
comment "Return V >= B";
pattern >=(v:flt,b:bat[:flt],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return V >= B with candidates list";

pattern >=(b1:bat[:flt],b2:bat[:dbl]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b1:bat[:flt],b2:bat[:dbl],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2 with candidates list";
pattern >=(b:bat[:flt],v:dbl) :bat[:bit]
address CMDbatGE
comment "Return B >= V";
pattern >=(b:bat[:flt],v:dbl,s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B >= V with candidates list";
pattern >=(v:flt,b:bat[:dbl]) :bat[:bit]
address CMDbatGE
comment "Return V >= B";
pattern >=(v:flt,b:bat[:dbl],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return V >= B with candidates list";

pattern >=(b1:bat[:dbl],b2:bat[:bte]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b1:bat[:dbl],b2:bat[:bte],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2 with candidates list";
pattern >=(b:bat[:dbl],v:bte) :bat[:bit]
address CMDbatGE
comment "Return B >= V";
pattern >=(b:bat[:dbl],v:bte,s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B >= V with candidates list";
pattern >=(v:dbl,b:bat[:bte]) :bat[:bit]
address CMDbatGE
comment "Return V >= B";
pattern >=(v:dbl,b:bat[:bte],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return V >= B with candidates list";

pattern >=(b1:bat[:dbl],b2:bat[:sht]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b1:bat[:dbl],b2:bat[:sht],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2 with candidates list";
pattern >=(b:bat[:dbl],v:sht) :bat[:bit]
address CMDbatGE
comment "Return B >= V";
pattern >=(b:bat[:dbl],v:sht,s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B >= V with candidates list";
pattern >=(v:dbl,b:bat[:sht]) :bat[:bit]
address CMDbatGE
comment "Return V >= B";
pattern >=(v:dbl,b:bat[:sht],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return V >= B with candidates list";

pattern >=(b1:bat[:dbl],b2:bat[:int]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b1:bat[:dbl],b2:bat[:int],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2 with candidates list";
pattern >=(b:bat[:dbl],v:int) :bat[:bit]
address CMDbatGE
comment "Return B >= V";
pattern >=(b:bat[:dbl],v:int,s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B >= V with candidates list";
pattern >=(v:dbl,b:bat[:int]) :bat[:bit]
address CMDbatGE
comment "Return V >= B";
pattern >=(v:dbl,b:bat[:int],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return V >= B with candidates list";

pattern >=(b1:bat[:dbl],b2:bat[:lng]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b1:bat[:dbl],b2:bat[:lng],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2 with candidates list";
pattern >=(b:bat[:dbl],v:lng) :bat[:bit]
address CMDbatGE
comment "Return B >= V";
pattern >=(b:bat[:dbl],v:lng,s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B >= V with candidates list";
pattern >=(v:dbl,b:bat[:lng]) :bat[:bit]
address CMDbatGE
comment "Return V >= B";
pattern >=(v:dbl,b:bat[:lng],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return V >= B with candidates list";

pattern >=(b1:bat[:dbl],b2:bat[:flt]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b1:bat[:dbl],b2:bat[:flt],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2 with candidates list";
pattern >=(b:bat[:dbl],v:flt) :bat[:bit]
address CMDbatGE
comment "Return B >= V";
pattern >=(b:bat[:dbl],v:flt,s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B >= V with candidates list";
pattern >=(v:dbl,b:bat[:flt]) :bat[:bit]
address CMDbatGE
comment "Return V >= B";
pattern >=(v:dbl,b:bat[:flt],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return V >= B with candidates list";

pattern >=(b1:bat[:dbl],b2:bat[:dbl]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b1:bat[:dbl],b2:bat[:dbl],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2 with candidates list";
pattern >=(b:bat[:dbl],v:dbl) :bat[:bit]
address CMDbatGE
comment "Return B >= V";
pattern >=(b:bat[:dbl],v:dbl,s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B >= V with candidates list";
pattern >=(v:dbl,b:bat[:dbl]) :bat[:bit]
address CMDbatGE
comment "Return V >= B";
pattern >=(v:dbl,b:bat[:dbl],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return V >= B with candidates list";


pattern ==(b1:bat[:bit],b2:bat[:bit]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b1:bat[:bit],b2:bat[:bit],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2 with candidates list";
pattern ==(b:bat[:bit],v:bit) :bat[:bit]
address CMDbatEQ
comment "Return B == V";
pattern ==(b:bat[:bit],v:bit,s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B == V with candidates list";
pattern ==(v:bit,b:bat[:bit]) :bat[:bit]
address CMDbatEQ
comment "Return V == B";
pattern ==(v:bit,b:bat[:bit],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return V == B with candidates list";

pattern ==(b1:bat[:str],b2:bat[:str]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b1:bat[:str],b2:bat[:str],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2 with candidates list";
pattern ==(b:bat[:str],v:str) :bat[:bit]
address CMDbatEQ
comment "Return B == V";
pattern ==(b:bat[:str],v:str,s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B == V with candidates list";
pattern ==(v:str,b:bat[:str]) :bat[:bit]
address CMDbatEQ
comment "Return V == B";
pattern ==(v:str,b:bat[:str],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return V == B with candidates list";

pattern ==(b1:bat[:oid],b2:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b1:bat[:oid],b2:bat[:oid],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2 with candidates list";
pattern ==(b:bat[:oid],v:oid) :bat[:bit]
address CMDbatEQ
comment "Return B == V";
pattern ==(b:bat[:oid],v:oid,s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B == V with candidates list";
pattern ==(v:oid,b:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return V == B";
pattern ==(v:oid,b:bat[:oid],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return V == B with candidates list";

pattern ==(b1:bat[:bte],b2:bat[:bte]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2 with candidates list";
pattern ==(b:bat[:bte],v:bte) :bat[:bit]
address CMDbatEQ
comment "Return B == V";
pattern ==(b:bat[:bte],v:bte,s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B == V with candidates list";
pattern ==(v:bte,b:bat[:bte]) :bat[:bit]
address CMDbatEQ
comment "Return V == B";
pattern ==(v:bte,b:bat[:bte],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return V == B with candidates list";

pattern ==(b1:bat[:bte],b2:bat[:sht]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2 with candidates list";
pattern ==(b:bat[:bte],v:sht) :bat[:bit]
address CMDbatEQ
comment "Return B == V";
pattern ==(b:bat[:bte],v:sht,s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B == V with candidates list";
pattern ==(v:bte,b:bat[:sht]) :bat[:bit]
address CMDbatEQ
comment "Return V == B";
pattern ==(v:bte,b:bat[:sht],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return V == B with candidates list";

pattern ==(b1:bat[:bte],b2:bat[:int]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b1:bat[:bte],b2:bat[:int],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2 with candidates list";
pattern ==(b:bat[:bte],v:int) :bat[:bit]
address CMDbatEQ
comment "Return B == V";
pattern ==(b:bat[:bte],v:int,s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B == V with candidates list";
pattern ==(v:bte,b:bat[:int]) :bat[:bit]
address CMDbatEQ
comment "Return V == B";
pattern ==(v:bte,b:bat[:int],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return V == B with candidates list";

pattern ==(b1:bat[:bte],b2:bat[:lng]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2 with candidates list";
pattern ==(b:bat[:bte],v:lng) :bat[:bit]
address CMDbatEQ
comment "Return B == V";
pattern ==(b:bat[:bte],v:lng,s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B == V with candidates list";
pattern ==(v:bte,b:bat[:lng]) :bat[:bit]
address CMDbatEQ
comment "Return V == B";
pattern ==(v:bte,b:bat[:lng],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return V == B with candidates list";

pattern ==(b1:bat[:bte],b2:bat[:flt]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2 with candidates list";
pattern ==(b:bat[:bte],v:flt) :bat[:bit]
address CMDbatEQ
comment "Return B == V";
pattern ==(b:bat[:bte],v:flt,s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B == V with candidates list";
pattern ==(v:bte,b:bat[:flt]) :bat[:bit]
address CMDbatEQ
comment "Return V == B";
pattern ==(v:bte,b:bat[:flt],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return V == B with candidates list";

pattern ==(b1:bat[:bte],b2:bat[:dbl]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b1:bat[:bte],b2:bat[:dbl],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2 with candidates list";
pattern ==(b:bat[:bte],v:dbl) :bat[:bit]
address CMDbatEQ
comment "Return B == V";
pattern ==(b:bat[:bte],v:dbl,s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B == V with candidates list";
pattern ==(v:bte,b:bat[:dbl]) :bat[:bit]
address CMDbatEQ
comment "Return V == B";
pattern ==(v:bte,b:bat[:dbl],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return V == B with candidates list";

pattern ==(b1:bat[:sht],b2:bat[:bte]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2 with candidates list";
pattern ==(b:bat[:sht],v:bte) :bat[:bit]
address CMDbatEQ
comment "Return B == V";
pattern ==(b:bat[:sht],v:bte,s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B == V with candidates list";
pattern ==(v:sht,b:bat[:bte]) :bat[:bit]
address CMDbatEQ
comment "Return V == B";
pattern ==(v:sht,b:bat[:bte],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return V == B with candidates list";

pattern ==(b1:bat[:sht],b2:bat[:sht]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2 with candidates list";
pattern ==(b:bat[:sht],v:sht) :bat[:bit]
address CMDbatEQ
comment "Return B == V";
pattern ==(b:bat[:sht],v:sht,s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B == V with candidates list";
pattern ==(v:sht,b:bat[:sht]) :bat[:bit]
address CMDbatEQ
comment "Return V == B";
pattern ==(v:sht,b:bat[:sht],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return V == B with candidates list";

pattern ==(b1:bat[:sht],b2:bat[:int]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b1:bat[:sht],b2:bat[:int],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2 with candidates list";
pattern ==(b:bat[:sht],v:int) :bat[:bit]
address CMDbatEQ
comment "Return B == V";
pattern ==(b:bat[:sht],v:int,s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B == V with candidates list";
pattern ==(v:sht,b:bat[:int]) :bat[:bit]
address CMDbatEQ
comment "Return V == B";
pattern ==(v:sht,b:bat[:int],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return V == B with candidates list";

pattern ==(b1:bat[:sht],b2:bat[:lng]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2 with candidates list";
pattern ==(b:bat[:sht],v:lng) :bat[:bit]
address CMDbatEQ
comment "Return B == V";
pattern ==(b:bat[:sht],v:lng,s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B == V with candidates list";
pattern ==(v:sht,b:bat[:lng]) :bat[:bit]
address CMDbatEQ
comment "Return V == B";
pattern ==(v:sht,b:bat[:lng],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return V == B with candidates list";

pattern ==(b1:bat[:sht],b2:bat[:flt]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b1:bat[:sht],b2:bat[:flt],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2 with candidates list";
pattern ==(b:bat[:sht],v:flt) :bat[:bit]
address CMDbatEQ
comment "Return B == V";
pattern ==(b:bat[:sht],v:flt,s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B == V with candidates list";
pattern ==(v:sht,b:bat[:flt]) :bat[:bit]
address CMDbatEQ
comment "Return V == B";
pattern ==(v:sht,b:bat[:flt],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return V == B with candidates list";

pattern ==(b1:bat[:sht],b2:bat[:dbl]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b1:bat[:sht],b2:bat[:dbl],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2 with candidates list";
pattern ==(b:bat[:sht],v:dbl) :bat[:bit]
address CMDbatEQ
comment "Return B == V";
pattern ==(b:bat[:sht],v:dbl,s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B == V with candidates list";
pattern ==(v:sht,b:bat[:dbl]) :bat[:bit]
address CMDbatEQ
comment "Return V == B";
pattern ==(v:sht,b:bat[:dbl],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return V == B with candidates list";

pattern ==(b1:bat[:int],b2:bat[:bte]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b1:bat[:int],b2:bat[:bte],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2 with candidates list";
pattern ==(b:bat[:int],v:bte) :bat[:bit]
address CMDbatEQ
comment "Return B == V";
pattern ==(b:bat[:int],v:bte,s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B == V with candidates list";
pattern ==(v:int,b:bat[:bte]) :bat[:bit]
address CMDbatEQ
comment "Return V == B";
pattern ==(v:int,b:bat[:bte],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return V == B with candidates list";

pattern ==(b1:bat[:int],b2:bat[:sht]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b1:bat[:int],b2:bat[:sht],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2 with candidates list";
pattern ==(b:bat[:int],v:sht) :bat[:bit]
address CMDbatEQ
comment "Return B == V";
pattern ==(b:bat[:int],v:sht,s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B == V with candidates list";
pattern ==(v:int,b:bat[:sht]) :bat[:bit]
address CMDbatEQ
comment "Return V == B";
pattern ==(v:int,b:bat[:sht],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return V == B with candidates list";

pattern ==(b1:bat[:int],b2:bat[:int]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b1:bat[:int],b2:bat[:int],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2 with candidates list";
pattern ==(b:bat[:int],v:int) :bat[:bit]
address CMDbatEQ
comment "Return B == V";
pattern ==(b:bat[:int],v:int,s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B == V with candidates list";
pattern ==(v:int,b:bat[:int]) :bat[:bit]
address CMDbatEQ
comment "Return V == B";
pattern ==(v:int,b:bat[:int],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return V == B with candidates list";

pattern ==(b1:bat[:int],b2:bat[:lng]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b1:bat[:int],b2:bat[:lng],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2 with candidates list";
pattern ==(b:bat[:int],v:lng) :bat[:bit]
address CMDbatEQ
comment "Return B == V";
pattern ==(b:bat[:int],v:lng,s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B == V with candidates list";
pattern ==(v:int,b:bat[:lng]) :bat[:bit]
address CMDbatEQ
comment "Return V == B";
pattern ==(v:int,b:bat[:lng],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return V == B with candidates list";

pattern ==(b1:bat[:int],b2:bat[:flt]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b1:bat[:int],b2:bat[:flt],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2 with candidates list";
pattern ==(b:bat[:int],v:flt) :bat[:bit]
address CMDbatEQ
comment "Return B == V";
pattern ==(b:bat[:int],v:flt,s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B == V with candidates list";
pattern ==(v:int,b:bat[:flt]) :bat[:bit]
address CMDbatEQ
comment "Return V == B";
pattern ==(v:int,b:bat[:flt],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return V == B with candidates list";

pattern ==(b1:bat[:int],b2:bat[:dbl]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b1:bat[:int],b2:bat[:dbl],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2 with candidates list";
pattern ==(b:bat[:int],v:dbl) :bat[:bit]
address CMDbatEQ
comment "Return B == V";
pattern ==(b:bat[:int],v:dbl,s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B == V with candidates list";
pattern ==(v:int,b:bat[:dbl]) :bat[:bit]
address CMDbatEQ
comment "Return V == B";
pattern ==(v:int,b:bat[:dbl],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return V == B with candidates list";

pattern ==(b1:bat[:lng],b2:bat[:bte]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2 with candidates list";
pattern ==(b:bat[:lng],v:bte) :bat[:bit]
address CMDbatEQ
comment "Return B == V";
pattern ==(b:bat[:lng],v:bte,s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B == V with candidates list";
pattern ==(v:lng,b:bat[:bte]) :bat[:bit]
address CMDbatEQ
comment "Return V == B";
pattern ==(v:lng,b:bat[:bte],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return V == B with candidates list";

pattern ==(b1:bat[:lng],b2:bat[:sht]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2 with candidates list";
pattern ==(b:bat[:lng],v:sht) :bat[:bit]
address CMDbatEQ
comment "Return B == V";
pattern ==(b:bat[:lng],v:sht,s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B == V with candidates list";
pattern ==(v:lng,b:bat[:sht]) :bat[:bit]
address CMDbatEQ
comment "Return V == B";
pattern ==(v:lng,b:bat[:sht],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return V == B with candidates list";

pattern ==(b1:bat[:lng],b2:bat[:int]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b1:bat[:lng],b2:bat[:int],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2 with candidates list";
pattern ==(b:bat[:lng],v:int) :bat[:bit]
address CMDbatEQ
comment "Return B == V";
pattern ==(b:bat[:lng],v:int,s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B == V with candidates list";
pattern ==(v:lng,b:bat[:int]) :bat[:bit]
address CMDbatEQ
comment "Return V == B";
pattern ==(v:lng,b:bat[:int],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return V == B with candidates list";

pattern ==(b1:bat[:lng],b2:bat[:lng]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2 with candidates list";
pattern ==(b:bat[:lng],v:lng) :bat[:bit]
address CMDbatEQ
comment "Return B == V";
pattern ==(b:bat[:lng],v:lng,s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B == V with candidates list";
pattern ==(v:lng,b:bat[:lng]) :bat[:bit]
address CMDbatEQ
comment "Return V == B";
pattern ==(v:lng,b:bat[:lng],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return V == B with candidates list";

pattern ==(b1:bat[:lng],b2:bat[:flt]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b1:bat[:lng],b2:bat[:flt],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2 with candidates list";
pattern ==(b:bat[:lng],v:flt) :bat[:bit]
address CMDbatEQ
comment "Return B == V";
pattern ==(b:bat[:lng],v:flt,s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B == V with candidates list";
pattern ==(v:lng,b:bat[:flt]) :bat[:bit]
address CMDbatEQ
comment "Return V == B";
pattern ==(v:lng,b:bat[:flt],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return V == B with candidates list";

pattern ==(b1:bat[:lng],b2:bat[:dbl]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b1:bat[:lng],b2:bat[:dbl],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2 with candidates list";
pattern ==(b:bat[:lng],v:dbl) :bat[:bit]
address CMDbatEQ
comment "Return B == V";
pattern ==(b:bat[:lng],v:dbl,s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B == V with candidates list";
pattern ==(v:lng,b:bat[:dbl]) :bat[:bit]
address CMDbatEQ
comment "Return V == B";
pattern ==(v:lng,b:bat[:dbl],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return V == B with candidates list";

pattern ==(b1:bat[:flt],b2:bat[:bte]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b1:bat[:flt],b2:bat[:bte],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2 with candidates list";
pattern ==(b:bat[:flt],v:bte) :bat[:bit]
address CMDbatEQ
comment "Return B == V";
pattern ==(b:bat[:flt],v:bte,s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B == V with candidates list";
pattern ==(v:flt,b:bat[:bte]) :bat[:bit]
address CMDbatEQ
comment "Return V == B";
pattern ==(v:flt,b:bat[:bte],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return V == B with candidates list";

pattern ==(b1:bat[:flt],b2:bat[:sht]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b1:bat[:flt],b2:bat[:sht],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2 with candidates list";
pattern ==(b:bat[:flt],v:sht) :bat[:bit]
address CMDbatEQ
comment "Return B == V";
pattern ==(b:bat[:flt],v:sht,s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B == V with candidates list";
pattern ==(v:flt,b:bat[:sht]) :bat[:bit]
address CMDbatEQ
comment "Return V == B";
pattern ==(v:flt,b:bat[:sht],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return V == B with candidates list";

pattern ==(b1:bat[:flt],b2:bat[:int]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b1:bat[:flt],b2:bat[:int],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2 with candidates list";
pattern ==(b:bat[:flt],v:int) :bat[:bit]
address CMDbatEQ
comment "Return B == V";
pattern ==(b:bat[:flt],v:int,s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B == V with candidates list";
pattern ==(v:flt,b:bat[:int]) :bat[:bit]
address CMDbatEQ
comment "Return V == B";
pattern ==(v:flt,b:bat[:int],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return V == B with candidates list";

pattern ==(b1:bat[:flt],b2:bat[:lng]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b1:bat[:flt],b2:bat[:lng],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2 with candidates list";
pattern ==(b:bat[:flt],v:lng) :bat[:bit]
address CMDbatEQ
comment "Return B == V";
pattern ==(b:bat[:flt],v:lng,s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B == V with candidates list";
pattern ==(v:flt,b:bat[:lng]) :bat[:bit]
address CMDbatEQ
comment "Return V == B";
pattern ==(v:flt,b:bat[:lng],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return V == B with candidates list";

pattern ==(b1:bat[:flt],b2:bat[:flt]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b1:bat[:flt],b2:bat[:flt],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2 with candidates list";
pattern ==(b:bat[:flt],v:flt) :bat[:bit]
address CMDbatEQ
comment "Return B == V";
pattern ==(b:bat[:flt],v:flt,s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B == V with candidates list";
pattern ==(v:flt,b:bat[:flt]) :bat[:bit]
address CMDbatEQ
comment "Return V == B";
pattern ==(v:flt,b:bat[:flt],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return V == B with candidates list";

pattern ==(b1:bat[:flt],b2:bat[:dbl]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b1:bat[:flt],b2:bat[:dbl],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2 with candidates list";
pattern ==(b:bat[:flt],v:dbl) :bat[:bit]
address CMDbatEQ
comment "Return B == V";
pattern ==(b:bat[:flt],v:dbl,s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B == V with candidates list";
pattern ==(v:flt,b:bat[:dbl]) :bat[:bit]
address CMDbatEQ
comment "Return V == B";
pattern ==(v:flt,b:bat[:dbl],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return V == B with candidates list";

pattern ==(b1:bat[:dbl],b2:bat[:bte]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b1:bat[:dbl],b2:bat[:bte],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2 with candidates list";
pattern ==(b:bat[:dbl],v:bte) :bat[:bit]
address CMDbatEQ
comment "Return B == V";
pattern ==(b:bat[:dbl],v:bte,s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B == V with candidates list";
pattern ==(v:dbl,b:bat[:bte]) :bat[:bit]
address CMDbatEQ
comment "Return V == B";
pattern ==(v:dbl,b:bat[:bte],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return V == B with candidates list";

pattern ==(b1:bat[:dbl],b2:bat[:sht]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b1:bat[:dbl],b2:bat[:sht],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2 with candidates list";
pattern ==(b:bat[:dbl],v:sht) :bat[:bit]
address CMDbatEQ
comment "Return B == V";
pattern ==(b:bat[:dbl],v:sht,s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B == V with candidates list";
pattern ==(v:dbl,b:bat[:sht]) :bat[:bit]
address CMDbatEQ
comment "Return V == B";
pattern ==(v:dbl,b:bat[:sht],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return V == B with candidates list";

pattern ==(b1:bat[:dbl],b2:bat[:int]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b1:bat[:dbl],b2:bat[:int],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2 with candidates list";
pattern ==(b:bat[:dbl],v:int) :bat[:bit]
address CMDbatEQ
comment "Return B == V";
pattern ==(b:bat[:dbl],v:int,s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B == V with candidates list";
pattern ==(v:dbl,b:bat[:int]) :bat[:bit]
address CMDbatEQ
comment "Return V == B";
pattern ==(v:dbl,b:bat[:int],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return V == B with candidates list";

pattern ==(b1:bat[:dbl],b2:bat[:lng]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b1:bat[:dbl],b2:bat[:lng],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2 with candidates list";
pattern ==(b:bat[:dbl],v:lng) :bat[:bit]
address CMDbatEQ
comment "Return B == V";
pattern ==(b:bat[:dbl],v:lng,s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B == V with candidates list";
pattern ==(v:dbl,b:bat[:lng]) :bat[:bit]
address CMDbatEQ
comment "Return V == B";
pattern ==(v:dbl,b:bat[:lng],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return V == B with candidates list";

pattern ==(b1:bat[:dbl],b2:bat[:flt]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b1:bat[:dbl],b2:bat[:flt],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2 with candidates list";
pattern ==(b:bat[:dbl],v:flt) :bat[:bit]
address CMDbatEQ
comment "Return B == V";
pattern ==(b:bat[:dbl],v:flt,s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B == V with candidates list";
pattern ==(v:dbl,b:bat[:flt]) :bat[:bit]
address CMDbatEQ
comment "Return V == B";
pattern ==(v:dbl,b:bat[:flt],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return V == B with candidates list";

pattern ==(b1:bat[:dbl],b2:bat[:dbl]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b1:bat[:dbl],b2:bat[:dbl],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2 with candidates list";
pattern ==(b:bat[:dbl],v:dbl) :bat[:bit]
address CMDbatEQ
comment "Return B == V";
pattern ==(b:bat[:dbl],v:dbl,s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B == V with candidates list";
pattern ==(v:dbl,b:bat[:dbl]) :bat[:bit]
address CMDbatEQ
comment "Return V == B";
pattern ==(v:dbl,b:bat[:dbl],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return V == B with candidates list";


pattern !=(b1:bat[:bit],b2:bat[:bit]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b1:bat[:bit],b2:bat[:bit],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2 with candidates list";
pattern !=(b:bat[:bit],v:bit) :bat[:bit]
address CMDbatNE
comment "Return B != V";
pattern !=(b:bat[:bit],v:bit,s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B != V with candidates list";
pattern !=(v:bit,b:bat[:bit]) :bat[:bit]
address CMDbatNE
comment "Return V != B";
pattern !=(v:bit,b:bat[:bit],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return V != B with candidates list";

pattern !=(b1:bat[:str],b2:bat[:str]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b1:bat[:str],b2:bat[:str],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2 with candidates list";
pattern !=(b:bat[:str],v:str) :bat[:bit]
address CMDbatNE
comment "Return B != V";
pattern !=(b:bat[:str],v:str,s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B != V with candidates list";
pattern !=(v:str,b:bat[:str]) :bat[:bit]
address CMDbatNE
comment "Return V != B";
pattern !=(v:str,b:bat[:str],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return V != B with candidates list";

pattern !=(b1:bat[:oid],b2:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b1:bat[:oid],b2:bat[:oid],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2 with candidates list";
pattern !=(b:bat[:oid],v:oid) :bat[:bit]
address CMDbatNE
comment "Return B != V";
pattern !=(b:bat[:oid],v:oid,s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B != V with candidates list";
pattern !=(v:oid,b:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return V != B";
pattern !=(v:oid,b:bat[:oid],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return V != B with candidates list";

pattern !=(b1:bat[:bte],b2:bat[:bte]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2 with candidates list";
pattern !=(b:bat[:bte],v:bte) :bat[:bit]
address CMDbatNE
comment "Return B != V";
pattern !=(b:bat[:bte],v:bte,s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B != V with candidates list";
pattern !=(v:bte,b:bat[:bte]) :bat[:bit]
address CMDbatNE
comment "Return V != B";
pattern !=(v:bte,b:bat[:bte],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return V != B with candidates list";

pattern !=(b1:bat[:bte],b2:bat[:sht]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2 with candidates list";
pattern !=(b:bat[:bte],v:sht) :bat[:bit]
address CMDbatNE
comment "Return B != V";
pattern !=(b:bat[:bte],v:sht,s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B != V with candidates list";
pattern !=(v:bte,b:bat[:sht]) :bat[:bit]
address CMDbatNE
comment "Return V != B";
pattern !=(v:bte,b:bat[:sht],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return V != B with candidates list";

pattern !=(b1:bat[:bte],b2:bat[:int]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b1:bat[:bte],b2:bat[:int],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2 with candidates list";
pattern !=(b:bat[:bte],v:int) :bat[:bit]
address CMDbatNE
comment "Return B != V";
pattern !=(b:bat[:bte],v:int,s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B != V with candidates list";
pattern !=(v:bte,b:bat[:int]) :bat[:bit]
address CMDbatNE
comment "Return V != B";
pattern !=(v:bte,b:bat[:int],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return V != B with candidates list";

pattern !=(b1:bat[:bte],b2:bat[:lng]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2 with candidates list";
pattern !=(b:bat[:bte],v:lng) :bat[:bit]
address CMDbatNE
comment "Return B != V";
pattern !=(b:bat[:bte],v:lng,s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B != V with candidates list";
pattern !=(v:bte,b:bat[:lng]) :bat[:bit]
address CMDbatNE
comment "Return V != B";
pattern !=(v:bte,b:bat[:lng],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return V != B with candidates list";

pattern !=(b1:bat[:bte],b2:bat[:flt]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2 with candidates list";
pattern !=(b:bat[:bte],v:flt) :bat[:bit]
address CMDbatNE
comment "Return B != V";
pattern !=(b:bat[:bte],v:flt,s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B != V with candidates list";
pattern !=(v:bte,b:bat[:flt]) :bat[:bit]
address CMDbatNE
comment "Return V != B";
pattern !=(v:bte,b:bat[:flt],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return V != B with candidates list";

pattern !=(b1:bat[:bte],b2:bat[:dbl]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b1:bat[:bte],b2:bat[:dbl],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2 with candidates list";
pattern !=(b:bat[:bte],v:dbl) :bat[:bit]
address CMDbatNE
comment "Return B != V";
pattern !=(b:bat[:bte],v:dbl,s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B != V with candidates list";
pattern !=(v:bte,b:bat[:dbl]) :bat[:bit]
address CMDbatNE
comment "Return V != B";
pattern !=(v:bte,b:bat[:dbl],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return V != B with candidates list";

pattern !=(b1:bat[:sht],b2:bat[:bte]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2 with candidates list";
pattern !=(b:bat[:sht],v:bte) :bat[:bit]
address CMDbatNE
comment "Return B != V";
pattern !=(b:bat[:sht],v:bte,s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B != V with candidates list";
pattern !=(v:sht,b:bat[:bte]) :bat[:bit]
address CMDbatNE
comment "Return V != B";
pattern !=(v:sht,b:bat[:bte],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return V != B with candidates list";

pattern !=(b1:bat[:sht],b2:bat[:sht]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2 with candidates list";
pattern !=(b:bat[:sht],v:sht) :bat[:bit]
address CMDbatNE
comment "Return B != V";
pattern !=(b:bat[:sht],v:sht,s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B != V with candidates list";
pattern !=(v:sht,b:bat[:sht]) :bat[:bit]
address CMDbatNE
comment "Return V != B";
pattern !=(v:sht,b:bat[:sht],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return V != B with candidates list";

pattern !=(b1:bat[:sht],b2:bat[:int]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b1:bat[:sht],b2:bat[:int],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2 with candidates list";
pattern !=(b:bat[:sht],v:int) :bat[:bit]
address CMDbatNE
comment "Return B != V";
pattern !=(b:bat[:sht],v:int,s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B != V with candidates list";
pattern !=(v:sht,b:bat[:int]) :bat[:bit]
address CMDbatNE
comment "Return V != B";
pattern !=(v:sht,b:bat[:int],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return V != B with candidates list";

pattern !=(b1:bat[:sht],b2:bat[:lng]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2 with candidates list";
pattern !=(b:bat[:sht],v:lng) :bat[:bit]
address CMDbatNE
comment "Return B != V";
pattern !=(b:bat[:sht],v:lng,s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B != V with candidates list";
pattern !=(v:sht,b:bat[:lng]) :bat[:bit]
address CMDbatNE
comment "Return V != B";
pattern !=(v:sht,b:bat[:lng],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return V != B with candidates list";

pattern !=(b1:bat[:sht],b2:bat[:flt]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b1:bat[:sht],b2:bat[:flt],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2 with candidates list";
pattern !=(b:bat[:sht],v:flt) :bat[:bit]
address CMDbatNE
comment "Return B != V";
pattern !=(b:bat[:sht],v:flt,s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B != V with candidates list";
pattern !=(v:sht,b:bat[:flt]) :bat[:bit]
address CMDbatNE
comment "Return V != B";
pattern !=(v:sht,b:bat[:flt],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return V != B with candidates list";

pattern !=(b1:bat[:sht],b2:bat[:dbl]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b1:bat[:sht],b2:bat[:dbl],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2 with candidates list";
pattern !=(b:bat[:sht],v:dbl) :bat[:bit]
address CMDbatNE
comment "Return B != V";
pattern !=(b:bat[:sht],v:dbl,s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B != V with candidates list";
pattern !=(v:sht,b:bat[:dbl]) :bat[:bit]
address CMDbatNE
comment "Return V != B";
pattern !=(v:sht,b:bat[:dbl],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return V != B with candidates list";

pattern !=(b1:bat[:int],b2:bat[:bte]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b1:bat[:int],b2:bat[:bte],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2 with candidates list";
pattern !=(b:bat[:int],v:bte) :bat[:bit]
address CMDbatNE
comment "Return B != V";
pattern !=(b:bat[:int],v:bte,s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B != V with candidates list";
pattern !=(v:int,b:bat[:bte]) :bat[:bit]
address CMDbatNE
comment "Return V != B";
pattern !=(v:int,b:bat[:bte],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return V != B with candidates list";

pattern !=(b1:bat[:int],b2:bat[:sht]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b1:bat[:int],b2:bat[:sht],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2 with candidates list";
pattern !=(b:bat[:int],v:sht) :bat[:bit]
address CMDbatNE
comment "Return B != V";
pattern !=(b:bat[:int],v:sht,s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B != V with candidates list";
pattern !=(v:int,b:bat[:sht]) :bat[:bit]
address CMDbatNE
comment "Return V != B";
pattern !=(v:int,b:bat[:sht],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return V != B with candidates list";

pattern !=(b1:bat[:int],b2:bat[:int]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b1:bat[:int],b2:bat[:int],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2 with candidates list";
pattern !=(b:bat[:int],v:int) :bat[:bit]
address CMDbatNE
comment "Return B != V";
pattern !=(b:bat[:int],v:int,s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B != V with candidates list";
pattern !=(v:int,b:bat[:int]) :bat[:bit]
address CMDbatNE
comment "Return V != B";
pattern !=(v:int,b:bat[:int],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return V != B with candidates list";

pattern !=(b1:bat[:int],b2:bat[:lng]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b1:bat[:int],b2:bat[:lng],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2 with candidates list";
pattern !=(b:bat[:int],v:lng) :bat[:bit]
address CMDbatNE
comment "Return B != V";
pattern !=(b:bat[:int],v:lng,s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B != V with candidates list";
pattern !=(v:int,b:bat[:lng]) :bat[:bit]
address CMDbatNE
comment "Return V != B";
pattern !=(v:int,b:bat[:lng],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return V != B with candidates list";

pattern !=(b1:bat[:int],b2:bat[:flt]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b1:bat[:int],b2:bat[:flt],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2 with candidates list";
pattern !=(b:bat[:int],v:flt) :bat[:bit]
address CMDbatNE
comment "Return B != V";
pattern !=(b:bat[:int],v:flt,s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B != V with candidates list";
pattern !=(v:int,b:bat[:flt]) :bat[:bit]
address CMDbatNE
comment "Return V != B";
pattern !=(v:int,b:bat[:flt],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return V != B with candidates list";

pattern !=(b1:bat[:int],b2:bat[:dbl]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b1:bat[:int],b2:bat[:dbl],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2 with candidates list";
pattern !=(b:bat[:int],v:dbl) :bat[:bit]
address CMDbatNE
comment "Return B != V";
pattern !=(b:bat[:int],v:dbl,s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B != V with candidates list";
pattern !=(v:int,b:bat[:dbl]) :bat[:bit]
address CMDbatNE
comment "Return V != B";
pattern !=(v:int,b:bat[:dbl],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return V != B with candidates list";

pattern !=(b1:bat[:lng],b2:bat[:bte]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2 with candidates list";
pattern !=(b:bat[:lng],v:bte) :bat[:bit]
address CMDbatNE
comment "Return B != V";
pattern !=(b:bat[:lng],v:bte,s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B != V with candidates list";
pattern !=(v:lng,b:bat[:bte]) :bat[:bit]
address CMDbatNE
comment "Return V != B";
pattern !=(v:lng,b:bat[:bte],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return V != B with candidates list";

pattern !=(b1:bat[:lng],b2:bat[:sht]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2 with candidates list";
pattern !=(b:bat[:lng],v:sht) :bat[:bit]
address CMDbatNE
comment "Return B != V";
pattern !=(b:bat[:lng],v:sht,s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B != V with candidates list";
pattern !=(v:lng,b:bat[:sht]) :bat[:bit]
address CMDbatNE
comment "Return V != B";
pattern !=(v:lng,b:bat[:sht],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return V != B with candidates list";

pattern !=(b1:bat[:lng],b2:bat[:int]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b1:bat[:lng],b2:bat[:int],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2 with candidates list";
pattern !=(b:bat[:lng],v:int) :bat[:bit]
address CMDbatNE
comment "Return B != V";
pattern !=(b:bat[:lng],v:int,s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B != V with candidates list";
pattern !=(v:lng,b:bat[:int]) :bat[:bit]
address CMDbatNE
comment "Return V != B";
pattern !=(v:lng,b:bat[:int],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return V != B with candidates list";

pattern !=(b1:bat[:lng],b2:bat[:lng]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2 with candidates list";
pattern !=(b:bat[:lng],v:lng) :bat[:bit]
address CMDbatNE
comment "Return B != V";
pattern !=(b:bat[:lng],v:lng,s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B != V with candidates list";
pattern !=(v:lng,b:bat[:lng]) :bat[:bit]
address CMDbatNE
comment "Return V != B";
pattern !=(v:lng,b:bat[:lng],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return V != B with candidates list";

pattern !=(b1:bat[:lng],b2:bat[:flt]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b1:bat[:lng],b2:bat[:flt],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2 with candidates list";
pattern !=(b:bat[:lng],v:flt) :bat[:bit]
address CMDbatNE
comment "Return B != V";
pattern !=(b:bat[:lng],v:flt,s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B != V with candidates list";
pattern !=(v:lng,b:bat[:flt]) :bat[:bit]
address CMDbatNE
comment "Return V != B";
pattern !=(v:lng,b:bat[:flt],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return V != B with candidates list";

pattern !=(b1:bat[:lng],b2:bat[:dbl]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b1:bat[:lng],b2:bat[:dbl],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2 with candidates list";
pattern !=(b:bat[:lng],v:dbl) :bat[:bit]
address CMDbatNE
comment "Return B != V";
pattern !=(b:bat[:lng],v:dbl,s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B != V with candidates list";
pattern !=(v:lng,b:bat[:dbl]) :bat[:bit]
address CMDbatNE
comment "Return V != B";
pattern !=(v:lng,b:bat[:dbl],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return V != B with candidates list";

pattern !=(b1:bat[:flt],b2:bat[:bte]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b1:bat[:flt],b2:bat[:bte],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2 with candidates list";
pattern !=(b:bat[:flt],v:bte) :bat[:bit]
address CMDbatNE
comment "Return B != V";
pattern !=(b:bat[:flt],v:bte,s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B != V with candidates list";
pattern !=(v:flt,b:bat[:bte]) :bat[:bit]
address CMDbatNE
comment "Return V != B";
pattern !=(v:flt,b:bat[:bte],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return V != B with candidates list";

pattern !=(b1:bat[:flt],b2:bat[:sht]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b1:bat[:flt],b2:bat[:sht],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2 with candidates list";
pattern !=(b:bat[:flt],v:sht) :bat[:bit]
address CMDbatNE
comment "Return B != V";
pattern !=(b:bat[:flt],v:sht,s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B != V with candidates list";
pattern !=(v:flt,b:bat[:sht]) :bat[:bit]
address CMDbatNE
comment "Return V != B";
pattern !=(v:flt,b:bat[:sht],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return V != B with candidates list";

pattern !=(b1:bat[:flt],b2:bat[:int]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b1:bat[:flt],b2:bat[:int],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2 with candidates list";
pattern !=(b:bat[:flt],v:int) :bat[:bit]
address CMDbatNE
comment "Return B != V";
pattern !=(b:bat[:flt],v:int,s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B != V with candidates list";
pattern !=(v:flt,b:bat[:int]) :bat[:bit]
address CMDbatNE
comment "Return V != B";
pattern !=(v:flt,b:bat[:int],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return V != B with candidates list";

pattern !=(b1:bat[:flt],b2:bat[:lng]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b1:bat[:flt],b2:bat[:lng],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2 with candidates list";
pattern !=(b:bat[:flt],v:lng) :bat[:bit]
address CMDbatNE
comment "Return B != V";
pattern !=(b:bat[:flt],v:lng,s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B != V with candidates list";
pattern !=(v:flt,b:bat[:lng]) :bat[:bit]
address CMDbatNE
comment "Return V != B";
pattern !=(v:flt,b:bat[:lng],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return V != B with candidates list";

pattern !=(b1:bat[:flt],b2:bat[:flt]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b1:bat[:flt],b2:bat[:flt],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2 with candidates list";
pattern !=(b:bat[:flt],v:flt) :bat[:bit]
address CMDbatNE
comment "Return B != V";
pattern !=(b:bat[:flt],v:flt,s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B != V with candidates list";
pattern !=(v:flt,b:bat[:flt]) :bat[:bit]
address CMDbatNE
comment "Return V != B";
pattern !=(v:flt,b:bat[:flt],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return V != B with candidates list";

pattern !=(b1:bat[:flt],b2:bat[:dbl]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b1:bat[:flt],b2:bat[:dbl],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2 with candidates list";
pattern !=(b:bat[:flt],v:dbl) :bat[:bit]
address CMDbatNE
comment "Return B != V";
pattern !=(b:bat[:flt],v:dbl,s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B != V with candidates list";
pattern !=(v:flt,b:bat[:dbl]) :bat[:bit]
address CMDbatNE
comment "Return V != B";
pattern !=(v:flt,b:bat[:dbl],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return V != B with candidates list";

pattern !=(b1:bat[:dbl],b2:bat[:bte]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b1:bat[:dbl],b2:bat[:bte],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2 with candidates list";
pattern !=(b:bat[:dbl],v:bte) :bat[:bit]
address CMDbatNE
comment "Return B != V";
pattern !=(b:bat[:dbl],v:bte,s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B != V with candidates list";
pattern !=(v:dbl,b:bat[:bte]) :bat[:bit]
address CMDbatNE
comment "Return V != B";
pattern !=(v:dbl,b:bat[:bte],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return V != B with candidates list";

pattern !=(b1:bat[:dbl],b2:bat[:sht]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b1:bat[:dbl],b2:bat[:sht],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2 with candidates list";
pattern !=(b:bat[:dbl],v:sht) :bat[:bit]
address CMDbatNE
comment "Return B != V";
pattern !=(b:bat[:dbl],v:sht,s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B != V with candidates list";
pattern !=(v:dbl,b:bat[:sht]) :bat[:bit]
address CMDbatNE
comment "Return V != B";
pattern !=(v:dbl,b:bat[:sht],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return V != B with candidates list";

pattern !=(b1:bat[:dbl],b2:bat[:int]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b1:bat[:dbl],b2:bat[:int],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2 with candidates list";
pattern !=(b:bat[:dbl],v:int) :bat[:bit]
address CMDbatNE
comment "Return B != V";
pattern !=(b:bat[:dbl],v:int,s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B != V with candidates list";
pattern !=(v:dbl,b:bat[:int]) :bat[:bit]
address CMDbatNE
comment "Return V != B";
pattern !=(v:dbl,b:bat[:int],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return V != B with candidates list";

pattern !=(b1:bat[:dbl],b2:bat[:lng]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b1:bat[:dbl],b2:bat[:lng],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2 with candidates list";
pattern !=(b:bat[:dbl],v:lng) :bat[:bit]
address CMDbatNE
comment "Return B != V";
pattern !=(b:bat[:dbl],v:lng,s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B != V with candidates list";
pattern !=(v:dbl,b:bat[:lng]) :bat[:bit]
address CMDbatNE
comment "Return V != B";
pattern !=(v:dbl,b:bat[:lng],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return V != B with candidates list";

pattern !=(b1:bat[:dbl],b2:bat[:flt]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b1:bat[:dbl],b2:bat[:flt],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2 with candidates list";
pattern !=(b:bat[:dbl],v:flt) :bat[:bit]
address CMDbatNE
comment "Return B != V";
pattern !=(b:bat[:dbl],v:flt,s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B != V with candidates list";
pattern !=(v:dbl,b:bat[:flt]) :bat[:bit]
address CMDbatNE
comment "Return V != B";
pattern !=(v:dbl,b:bat[:flt],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return V != B with candidates list";

pattern !=(b1:bat[:dbl],b2:bat[:dbl]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b1:bat[:dbl],b2:bat[:dbl],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2 with candidates list";
pattern !=(b:bat[:dbl],v:dbl) :bat[:bit]
address CMDbatNE
comment "Return B != V";
pattern !=(b:bat[:dbl],v:dbl,s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B != V with candidates list";
pattern !=(v:dbl,b:bat[:dbl]) :bat[:bit]
address CMDbatNE
comment "Return V != B";
pattern !=(v:dbl,b:bat[:dbl],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return V != B with candidates list";


pattern cmp(b1:bat[:bit],b2:bat[:bit]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b1:bat[:bit],b2:bat[:bit],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2 with candidates list";
pattern cmp(b:bat[:bit],v:bit) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:bit,b:bat[:bit]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B";
pattern cmp(b:bat[:bit],v:bit,s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V with candidates list";
pattern cmp(v:bit,b:bat[:bit],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B with candidates list";

pattern cmp(b1:bat[:str],b2:bat[:str]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b1:bat[:str],b2:bat[:str],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2 with candidates list";
pattern cmp(b:bat[:str],v:str) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:str,b:bat[:str]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B";
pattern cmp(b:bat[:str],v:str,s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V with candidates list";
pattern cmp(v:str,b:bat[:str],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B with candidates list";

pattern cmp(b1:bat[:oid],b2:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b1:bat[:oid],b2:bat[:oid],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2 with candidates list";
pattern cmp(b:bat[:oid],v:oid) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:oid,b:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B";
pattern cmp(b:bat[:oid],v:oid,s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V with candidates list";
pattern cmp(v:oid,b:bat[:oid],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B with candidates list";

pattern cmp(b1:bat[:bte],b2:bat[:bte]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b1:bat[:bte],b2:bat[:bte],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2 with candidates list";
pattern cmp(b:bat[:bte],v:bte) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:bte,b:bat[:bte]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B";
pattern cmp(b:bat[:bte],v:bte,s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V with candidates list";
pattern cmp(v:bte,b:bat[:bte],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B with candidates list";

pattern cmp(b1:bat[:bte],b2:bat[:sht]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b1:bat[:bte],b2:bat[:sht],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2 with candidates list";
pattern cmp(b:bat[:bte],v:sht) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:bte,b:bat[:sht]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B";
pattern cmp(b:bat[:bte],v:sht,s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V with candidates list";
pattern cmp(v:bte,b:bat[:sht],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B with candidates list";

pattern cmp(b1:bat[:bte],b2:bat[:int]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b1:bat[:bte],b2:bat[:int],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2 with candidates list";
pattern cmp(b:bat[:bte],v:int) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:bte,b:bat[:int]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B";
pattern cmp(b:bat[:bte],v:int,s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V with candidates list";
pattern cmp(v:bte,b:bat[:int],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B with candidates list";

pattern cmp(b1:bat[:bte],b2:bat[:lng]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2 with candidates list";
pattern cmp(b:bat[:bte],v:lng) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:bte,b:bat[:lng]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B";
pattern cmp(b:bat[:bte],v:lng,s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V with candidates list";
pattern cmp(v:bte,b:bat[:lng],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B with candidates list";

pattern cmp(b1:bat[:bte],b2:bat[:flt]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b1:bat[:bte],b2:bat[:flt],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2 with candidates list";
pattern cmp(b:bat[:bte],v:flt) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:bte,b:bat[:flt]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B";
pattern cmp(b:bat[:bte],v:flt,s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V with candidates list";
pattern cmp(v:bte,b:bat[:flt],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B with candidates list";

pattern cmp(b1:bat[:bte],b2:bat[:dbl]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b1:bat[:bte],b2:bat[:dbl],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2 with candidates list";
pattern cmp(b:bat[:bte],v:dbl) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:bte,b:bat[:dbl]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B";
pattern cmp(b:bat[:bte],v:dbl,s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V with candidates list";
pattern cmp(v:bte,b:bat[:dbl],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B with candidates list";

pattern cmp(b1:bat[:sht],b2:bat[:bte]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b1:bat[:sht],b2:bat[:bte],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2 with candidates list";
pattern cmp(b:bat[:sht],v:bte) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:sht,b:bat[:bte]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B";
pattern cmp(b:bat[:sht],v:bte,s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V with candidates list";
pattern cmp(v:sht,b:bat[:bte],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B with candidates list";

pattern cmp(b1:bat[:sht],b2:bat[:sht]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b1:bat[:sht],b2:bat[:sht],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2 with candidates list";
pattern cmp(b:bat[:sht],v:sht) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:sht,b:bat[:sht]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B";
pattern cmp(b:bat[:sht],v:sht,s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V with candidates list";
pattern cmp(v:sht,b:bat[:sht],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B with candidates list";

pattern cmp(b1:bat[:sht],b2:bat[:int]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b1:bat[:sht],b2:bat[:int],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2 with candidates list";
pattern cmp(b:bat[:sht],v:int) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:sht,b:bat[:int]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B";
pattern cmp(b:bat[:sht],v:int,s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V with candidates list";
pattern cmp(v:sht,b:bat[:int],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B with candidates list";

pattern cmp(b1:bat[:sht],b2:bat[:lng]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2 with candidates list";
pattern cmp(b:bat[:sht],v:lng) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:sht,b:bat[:lng]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B";
pattern cmp(b:bat[:sht],v:lng,s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V with candidates list";
pattern cmp(v:sht,b:bat[:lng],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B with candidates list";

pattern cmp(b1:bat[:sht],b2:bat[:flt]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b1:bat[:sht],b2:bat[:flt],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2 with candidates list";
pattern cmp(b:bat[:sht],v:flt) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:sht,b:bat[:flt]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B";
pattern cmp(b:bat[:sht],v:flt,s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V with candidates list";
pattern cmp(v:sht,b:bat[:flt],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B with candidates list";

pattern cmp(b1:bat[:sht],b2:bat[:dbl]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b1:bat[:sht],b2:bat[:dbl],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2 with candidates list";
pattern cmp(b:bat[:sht],v:dbl) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:sht,b:bat[:dbl]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B";
pattern cmp(b:bat[:sht],v:dbl,s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V with candidates list";
pattern cmp(v:sht,b:bat[:dbl],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B with candidates list";

pattern cmp(b1:bat[:int],b2:bat[:bte]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b1:bat[:int],b2:bat[:bte],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2 with candidates list";
pattern cmp(b:bat[:int],v:bte) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:int,b:bat[:bte]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B";
pattern cmp(b:bat[:int],v:bte,s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V with candidates list";
pattern cmp(v:int,b:bat[:bte],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B with candidates list";

pattern cmp(b1:bat[:int],b2:bat[:sht]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b1:bat[:int],b2:bat[:sht],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2 with candidates list";
pattern cmp(b:bat[:int],v:sht) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:int,b:bat[:sht]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B";
pattern cmp(b:bat[:int],v:sht,s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V with candidates list";
pattern cmp(v:int,b:bat[:sht],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B with candidates list";

pattern cmp(b1:bat[:int],b2:bat[:int]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b1:bat[:int],b2:bat[:int],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2 with candidates list";
pattern cmp(b:bat[:int],v:int) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:int,b:bat[:int]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B";
pattern cmp(b:bat[:int],v:int,s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V with candidates list";
pattern cmp(v:int,b:bat[:int],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B with candidates list";

pattern cmp(b1:bat[:int],b2:bat[:lng]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b1:bat[:int],b2:bat[:lng],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2 with candidates list";
pattern cmp(b:bat[:int],v:lng) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:int,b:bat[:lng]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B";
pattern cmp(b:bat[:int],v:lng,s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V with candidates list";
pattern cmp(v:int,b:bat[:lng],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B with candidates list";

pattern cmp(b1:bat[:int],b2:bat[:flt]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b1:bat[:int],b2:bat[:flt],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2 with candidates list";
pattern cmp(b:bat[:int],v:flt) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:int,b:bat[:flt]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B";
pattern cmp(b:bat[:int],v:flt,s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V with candidates list";
pattern cmp(v:int,b:bat[:flt],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B with candidates list";

pattern cmp(b1:bat[:int],b2:bat[:dbl]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b1:bat[:int],b2:bat[:dbl],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2 with candidates list";
pattern cmp(b:bat[:int],v:dbl) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:int,b:bat[:dbl]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B";
pattern cmp(b:bat[:int],v:dbl,s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V with candidates list";
pattern cmp(v:int,b:bat[:dbl],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B with candidates list";

pattern cmp(b1:bat[:lng],b2:bat[:bte]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2 with candidates list";
pattern cmp(b:bat[:lng],v:bte) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:lng,b:bat[:bte]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B";
pattern cmp(b:bat[:lng],v:bte,s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V with candidates list";
pattern cmp(v:lng,b:bat[:bte],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B with candidates list";

pattern cmp(b1:bat[:lng],b2:bat[:sht]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2 with candidates list";
pattern cmp(b:bat[:lng],v:sht) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:lng,b:bat[:sht]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B";
pattern cmp(b:bat[:lng],v:sht,s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V with candidates list";
pattern cmp(v:lng,b:bat[:sht],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B with candidates list";

pattern cmp(b1:bat[:lng],b2:bat[:int]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b1:bat[:lng],b2:bat[:int],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2 with candidates list";
pattern cmp(b:bat[:lng],v:int) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:lng,b:bat[:int]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B";
pattern cmp(b:bat[:lng],v:int,s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V with candidates list";
pattern cmp(v:lng,b:bat[:int],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B with candidates list";

pattern cmp(b1:bat[:lng],b2:bat[:lng]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2 with candidates list";
pattern cmp(b:bat[:lng],v:lng) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:lng,b:bat[:lng]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B";
pattern cmp(b:bat[:lng],v:lng,s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V with candidates list";
pattern cmp(v:lng,b:bat[:lng],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B with candidates list";

pattern cmp(b1:bat[:lng],b2:bat[:flt]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b1:bat[:lng],b2:bat[:flt],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2 with candidates list";
pattern cmp(b:bat[:lng],v:flt) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:lng,b:bat[:flt]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B";
pattern cmp(b:bat[:lng],v:flt,s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V with candidates list";
pattern cmp(v:lng,b:bat[:flt],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B with candidates list";

pattern cmp(b1:bat[:lng],b2:bat[:dbl]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b1:bat[:lng],b2:bat[:dbl],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2 with candidates list";
pattern cmp(b:bat[:lng],v:dbl) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:lng,b:bat[:dbl]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B";
pattern cmp(b:bat[:lng],v:dbl,s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V with candidates list";
pattern cmp(v:lng,b:bat[:dbl],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B with candidates list";

pattern cmp(b1:bat[:flt],b2:bat[:bte]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b1:bat[:flt],b2:bat[:bte],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2 with candidates list";
pattern cmp(b:bat[:flt],v:bte) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:flt,b:bat[:bte]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B";
pattern cmp(b:bat[:flt],v:bte,s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V with candidates list";
pattern cmp(v:flt,b:bat[:bte],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B with candidates list";

pattern cmp(b1:bat[:flt],b2:bat[:sht]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b1:bat[:flt],b2:bat[:sht],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2 with candidates list";
pattern cmp(b:bat[:flt],v:sht) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:flt,b:bat[:sht]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B";
pattern cmp(b:bat[:flt],v:sht,s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V with candidates list";
pattern cmp(v:flt,b:bat[:sht],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B with candidates list";

pattern cmp(b1:bat[:flt],b2:bat[:int]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b1:bat[:flt],b2:bat[:int],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2 with candidates list";
pattern cmp(b:bat[:flt],v:int) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:flt,b:bat[:int]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B";
pattern cmp(b:bat[:flt],v:int,s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V with candidates list";
pattern cmp(v:flt,b:bat[:int],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B with candidates list";

pattern cmp(b1:bat[:flt],b2:bat[:lng]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b1:bat[:flt],b2:bat[:lng],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2 with candidates list";
pattern cmp(b:bat[:flt],v:lng) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:flt,b:bat[:lng]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B";
pattern cmp(b:bat[:flt],v:lng,s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V with candidates list";
pattern cmp(v:flt,b:bat[:lng],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B with candidates list";

pattern cmp(b1:bat[:flt],b2:bat[:flt]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b1:bat[:flt],b2:bat[:flt],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2 with candidates list";
pattern cmp(b:bat[:flt],v:flt) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:flt,b:bat[:flt]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B";
pattern cmp(b:bat[:flt],v:flt,s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V with candidates list";
pattern cmp(v:flt,b:bat[:flt],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B with candidates list";

pattern cmp(b1:bat[:flt],b2:bat[:dbl]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b1:bat[:flt],b2:bat[:dbl],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2 with candidates list";
pattern cmp(b:bat[:flt],v:dbl) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:flt,b:bat[:dbl]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B";
pattern cmp(b:bat[:flt],v:dbl,s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V with candidates list";
pattern cmp(v:flt,b:bat[:dbl],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B with candidates list";

pattern cmp(b1:bat[:dbl],b2:bat[:bte]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b1:bat[:dbl],b2:bat[:bte],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2 with candidates list";
pattern cmp(b:bat[:dbl],v:bte) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:dbl,b:bat[:bte]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B";
pattern cmp(b:bat[:dbl],v:bte,s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V with candidates list";
pattern cmp(v:dbl,b:bat[:bte],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B with candidates list";

pattern cmp(b1:bat[:dbl],b2:bat[:sht]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b1:bat[:dbl],b2:bat[:sht],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2 with candidates list";
pattern cmp(b:bat[:dbl],v:sht) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:dbl,b:bat[:sht]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B";
pattern cmp(b:bat[:dbl],v:sht,s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V with candidates list";
pattern cmp(v:dbl,b:bat[:sht],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B with candidates list";

pattern cmp(b1:bat[:dbl],b2:bat[:int]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b1:bat[:dbl],b2:bat[:int],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2 with candidates list";
pattern cmp(b:bat[:dbl],v:int) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:dbl,b:bat[:int]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B";
pattern cmp(b:bat[:dbl],v:int,s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V with candidates list";
pattern cmp(v:dbl,b:bat[:int],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B with candidates list";

pattern cmp(b1:bat[:dbl],b2:bat[:lng]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b1:bat[:dbl],b2:bat[:lng],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2 with candidates list";
pattern cmp(b:bat[:dbl],v:lng) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:dbl,b:bat[:lng]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B";
pattern cmp(b:bat[:dbl],v:lng,s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V with candidates list";
pattern cmp(v:dbl,b:bat[:lng],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B with candidates list";

pattern cmp(b1:bat[:dbl],b2:bat[:flt]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b1:bat[:dbl],b2:bat[:flt],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2 with candidates list";
pattern cmp(b:bat[:dbl],v:flt) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:dbl,b:bat[:flt]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B";
pattern cmp(b:bat[:dbl],v:flt,s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V with candidates list";
pattern cmp(v:dbl,b:bat[:flt],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B with candidates list";

pattern cmp(b1:bat[:dbl],b2:bat[:dbl]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b1:bat[:dbl],b2:bat[:dbl],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2 with candidates list";
pattern cmp(b:bat[:dbl],v:dbl) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:dbl,b:bat[:dbl]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B";
pattern cmp(b:bat[:dbl],v:dbl,s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V with candidates list";
pattern cmp(v:dbl,b:bat[:dbl],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B with candidates list";


pattern between(b:bat[:any_1],lo:bat[:any_1],hi:bat[:any_1]) :bat[:bit]
address CMDbatBETWEEN
comment "B between LO and HI inclusive";
pattern between(b:bat[:any_1],lo:bat[:any_1],hi:bat[:any_1],s:bat[:oid]) :bat[:bit]
address CMDbatBETWEEN
comment "B between LO and HI inclusive with candidates list";
pattern between(b:bat[:any_1],lo:bat[:any_1],hi:any_1) :bat[:bit]
address CMDbatBETWEEN
comment "B between LO and HI inclusive";
pattern between(b:bat[:any_1],lo:bat[:any_1],hi:any_1,s:bat[:oid]) :bat[:bit]
address CMDbatBETWEEN
comment "B between LO and HI inclusive with candidates list";
pattern between(b:bat[:any_1],lo:any_1,hi:bat[:any_1]) :bat[:bit]
address CMDbatBETWEEN
comment "B between LO and HI inclusive";
pattern between(b:bat[:any_1],lo:any_1,hi:bat[:any_1],s:bat[:oid]) :bat[:bit]
address CMDbatBETWEEN
comment "B between LO and HI inclusive with candidates list";
pattern between(b:bat[:any_1],lo:any_1,hi:any_1) :bat[:bit]
address CMDbatBETWEEN
comment "B between LO and HI inclusive";
pattern between(b:bat[:any_1],lo:any_1,hi:any_1,s:bat[:oid]) :bat[:bit]
address CMDbatBETWEEN
comment "B between LO and HI inclusive with candidates list";

pattern between_symmetric(b:bat[:any_1],v1:bat[:any_1],v2:bat[:any_1]) :bat[:bit]
address CMDbatBETWEENsymmetric
comment "B between V1 and V2 (or vice versa) inclusive";
pattern between_symmetric(b:bat[:any_1],v1:bat[:any_1],v2:bat[:any_1],s:bat[:oid]) :bat[:bit]
address CMDbatBETWEENsymmetric
comment "B between V1 and V2 (or vice versa) inclusive with candidates list";
pattern between_symmetric(b:bat[:any_1],v1:bat[:any_1],v2:any_1) :bat[:bit]
address CMDbatBETWEENsymmetric
comment "B between V1 and V2 (or vice versa) inclusive";
pattern between_symmetric(b:bat[:any_1],v1:bat[:any_1],v2:any_1,s:bat[:oid]) :bat[:bit]
address CMDbatBETWEENsymmetric
comment "B between V1 and V2 (or vice versa) inclusive with candidates list";
pattern between_symmetric(b:bat[:any_1],v1:any_1,v2:bat[:any_1]) :bat[:bit]
address CMDbatBETWEENsymmetric
comment "B between V1 and V2 (or vice versa) inclusive";
pattern between_symmetric(b:bat[:any_1],v1:any_1,v2:bat[:any_1],s:bat[:oid]) :bat[:bit]
address CMDbatBETWEENsymmetric
comment "B between V1 and V2 (or vice versa) inclusive with candidates list";
pattern between_symmetric(b:bat[:any_1],v1:any_1,v2:any_1) :bat[:bit]
address CMDbatBETWEENsymmetric
comment "B between V1 and V2 (or vice versa) inclusive";
pattern between_symmetric(b:bat[:any_1],v1:any_1,v2:any_1,s:bat[:oid]) :bat[:bit]
address CMDbatBETWEENsymmetric
comment "B between V1 and V2 (or vice versa) inclusive with candidates list";


pattern avg(b:bat[:bte]) :dbl
address CMDcalcavg
comment "average of non-nil values of B with candidates list";
pattern avg(b:bat[:bte],s:bat[:oid]) :dbl
address CMDcalcavg
comment "average of non-nil values of B";
pattern avg(b:bat[:bte]) (:dbl, :lng)
address CMDcalcavg
comment "average and number of non-nil values of B";
pattern avg(b:bat[:bte],s:bat[:oid]) (:dbl, :lng)
address CMDcalcavg
comment "average and number of non-nil values of B with candidates list";

pattern avg(b:bat[:sht]) :dbl
address CMDcalcavg
comment "average of non-nil values of B with candidates list";
pattern avg(b:bat[:sht],s:bat[:oid]) :dbl
address CMDcalcavg
comment "average of non-nil values of B";
pattern avg(b:bat[:sht]) (:dbl, :lng)
address CMDcalcavg
comment "average and number of non-nil values of B";
pattern avg(b:bat[:sht],s:bat[:oid]) (:dbl, :lng)
address CMDcalcavg
comment "average and number of non-nil values of B with candidates list";

pattern avg(b:bat[:int]) :dbl
address CMDcalcavg
comment "average of non-nil values of B with candidates list";
pattern avg(b:bat[:int],s:bat[:oid]) :dbl
address CMDcalcavg
comment "average of non-nil values of B";
pattern avg(b:bat[:int]) (:dbl, :lng)
address CMDcalcavg
comment "average and number of non-nil values of B";
pattern avg(b:bat[:int],s:bat[:oid]) (:dbl, :lng)
address CMDcalcavg
comment "average and number of non-nil values of B with candidates list";

pattern avg(b:bat[:lng]) :dbl
address CMDcalcavg
comment "average of non-nil values of B with candidates list";
pattern avg(b:bat[:lng],s:bat[:oid]) :dbl
address CMDcalcavg
comment "average of non-nil values of B";
pattern avg(b:bat[:lng]) (:dbl, :lng)
address CMDcalcavg
comment "average and number of non-nil values of B";
pattern avg(b:bat[:lng],s:bat[:oid]) (:dbl, :lng)
address CMDcalcavg
comment "average and number of non-nil values of B with candidates list";

pattern avg(b:bat[:flt]) :dbl
address CMDcalcavg
comment "average of non-nil values of B with candidates list";
pattern avg(b:bat[:flt],s:bat[:oid]) :dbl
address CMDcalcavg
comment "average of non-nil values of B";
pattern avg(b:bat[:flt]) (:dbl, :lng)
address CMDcalcavg
comment "average and number of non-nil values of B";
pattern avg(b:bat[:flt],s:bat[:oid]) (:dbl, :lng)
address CMDcalcavg
comment "average and number of non-nil values of B with candidates list";

pattern avg(b:bat[:dbl]) :dbl
address CMDcalcavg
comment "average of non-nil values of B with candidates list";
pattern avg(b:bat[:dbl],s:bat[:oid]) :dbl
address CMDcalcavg
comment "average of non-nil values of B";
pattern avg(b:bat[:dbl]) (:dbl, :lng)
address CMDcalcavg
comment "average and number of non-nil values of B";
pattern avg(b:bat[:dbl],s:bat[:oid]) (:dbl, :lng)
address CMDcalcavg
comment "average and number of non-nil values of B with candidates list";

pattern bit(b:bat[:bit]) :bat[:bit]
address CMDconvertsignal_bit
comment "cast from bit to bit, signal error on overflow";
pattern bit(b:bat[:bit],s:bat[:oid]) :bat[:bit]
address CMDconvertsignal_bit
comment "cast from bit to bit with candidates list, signal error on overflow";
pattern bit_noerror(b:bat[:bit]) :bat[:bit]
address CMDconvert_bit
comment "cast from bit to bit";
pattern bit_noerror(b:bat[:bit],s:bat[:oid]) :bat[:bit]
address CMDconvert_bit
comment "cast from bit to bit with candidates list";

pattern bit(b:bat[:bte]) :bat[:bit]
address CMDconvertsignal_bit
comment "cast from bte to bit, signal error on overflow";
pattern bit(b:bat[:bte],s:bat[:oid]) :bat[:bit]
address CMDconvertsignal_bit
comment "cast from bte to bit with candidates list, signal error on overflow";
pattern bit_noerror(b:bat[:bte]) :bat[:bit]
address CMDconvert_bit
comment "cast from bte to bit";
pattern bit_noerror(b:bat[:bte],s:bat[:oid]) :bat[:bit]
address CMDconvert_bit
comment "cast from bte to bit with candidates list";

pattern bit(b:bat[:sht]) :bat[:bit]
address CMDconvertsignal_bit
comment "cast from sht to bit, signal error on overflow";
pattern bit(b:bat[:sht],s:bat[:oid]) :bat[:bit]
address CMDconvertsignal_bit
comment "cast from sht to bit with candidates list, signal error on overflow";
pattern bit_noerror(b:bat[:sht]) :bat[:bit]
address CMDconvert_bit
comment "cast from sht to bit";
pattern bit_noerror(b:bat[:sht],s:bat[:oid]) :bat[:bit]
address CMDconvert_bit
comment "cast from sht to bit with candidates list";

pattern bit(b:bat[:int]) :bat[:bit]
address CMDconvertsignal_bit
comment "cast from int to bit, signal error on overflow";
pattern bit(b:bat[:int],s:bat[:oid]) :bat[:bit]
address CMDconvertsignal_bit
comment "cast from int to bit with candidates list, signal error on overflow";
pattern bit_noerror(b:bat[:int]) :bat[:bit]
address CMDconvert_bit
comment "cast from int to bit";
pattern bit_noerror(b:bat[:int],s:bat[:oid]) :bat[:bit]
address CMDconvert_bit
comment "cast from int to bit with candidates list";

pattern bit(b:bat[:lng]) :bat[:bit]
address CMDconvertsignal_bit
comment "cast from lng to bit, signal error on overflow";
pattern bit(b:bat[:lng],s:bat[:oid]) :bat[:bit]
address CMDconvertsignal_bit
comment "cast from lng to bit with candidates list, signal error on overflow";
pattern bit_noerror(b:bat[:lng]) :bat[:bit]
address CMDconvert_bit
comment "cast from lng to bit";
pattern bit_noerror(b:bat[:lng],s:bat[:oid]) :bat[:bit]
address CMDconvert_bit
comment "cast from lng to bit with candidates list";

pattern bit(b:bat[:flt]) :bat[:bit]
address CMDconvertsignal_bit
comment "cast from flt to bit, signal error on overflow";
pattern bit(b:bat[:flt],s:bat[:oid]) :bat[:bit]
address CMDconvertsignal_bit
comment "cast from flt to bit with candidates list, signal error on overflow";
pattern bit_noerror(b:bat[:flt]) :bat[:bit]
address CMDconvert_bit
comment "cast from flt to bit";
pattern bit_noerror(b:bat[:flt],s:bat[:oid]) :bat[:bit]
address CMDconvert_bit
comment "cast from flt to bit with candidates list";

pattern bit(b:bat[:dbl]) :bat[:bit]
address CMDconvertsignal_bit
comment "cast from dbl to bit, signal error on overflow";
pattern bit(b:bat[:dbl],s:bat[:oid]) :bat[:bit]
address CMDconvertsignal_bit
comment "cast from dbl to bit with candidates list, signal error on overflow";
pattern bit_noerror(b:bat[:dbl]) :bat[:bit]
address CMDconvert_bit
comment "cast from dbl to bit";
pattern bit_noerror(b:bat[:dbl],s:bat[:oid]) :bat[:bit]
address CMDconvert_bit
comment "cast from dbl to bit with candidates list";

pattern bit(b:bat[:oid]) :bat[:bit]
address CMDconvertsignal_bit
comment "cast from oid to bit, signal error on overflow";
pattern bit(b:bat[:oid],s:bat[:oid]) :bat[:bit]
address CMDconvertsignal_bit
comment "cast from oid to bit with candidates list, signal error on overflow";
pattern bit_noerror(b:bat[:oid]) :bat[:bit]
address CMDconvert_bit
comment "cast from oid to bit";
pattern bit_noerror(b:bat[:oid],s:bat[:oid]) :bat[:bit]
address CMDconvert_bit
comment "cast from oid to bit with candidates list";

pattern bit(b:bat[:str]) :bat[:bit]
address CMDconvertsignal_bit
comment "cast from str to bit, signal error on overflow";
pattern bit(b:bat[:str],s:bat[:oid]) :bat[:bit]
address CMDconvertsignal_bit
comment "cast from str to bit with candidates list, signal error on overflow";
pattern bit_noerror(b:bat[:str]) :bat[:bit]
address CMDconvert_bit
comment "cast from str to bit";
pattern bit_noerror(b:bat[:str],s:bat[:oid]) :bat[:bit]
address CMDconvert_bit
comment "cast from str to bit with candidates list";

pattern bte(b:bat[:bit]) :bat[:bte]
address CMDconvertsignal_bte
comment "cast from bit to bte, signal error on overflow";
pattern bte(b:bat[:bit],s:bat[:oid]) :bat[:bte]
address CMDconvertsignal_bte
comment "cast from bit to bte with candidates list, signal error on overflow";
pattern bte_noerror(b:bat[:bit]) :bat[:bte]
address CMDconvert_bte
comment "cast from bit to bte";
pattern bte_noerror(b:bat[:bit],s:bat[:oid]) :bat[:bte]
address CMDconvert_bte
comment "cast from bit to bte with candidates list";

pattern bte(b:bat[:bte]) :bat[:bte]
address CMDconvertsignal_bte
comment "cast from bte to bte, signal error on overflow";
pattern bte(b:bat[:bte],s:bat[:oid]) :bat[:bte]
address CMDconvertsignal_bte
comment "cast from bte to bte with candidates list, signal error on overflow";
pattern bte_noerror(b:bat[:bte]) :bat[:bte]
address CMDconvert_bte
comment "cast from bte to bte";
pattern bte_noerror(b:bat[:bte],s:bat[:oid]) :bat[:bte]
address CMDconvert_bte
comment "cast from bte to bte with candidates list";

pattern bte(b:bat[:sht]) :bat[:bte]
address CMDconvertsignal_bte
comment "cast from sht to bte, signal error on overflow";
pattern bte(b:bat[:sht],s:bat[:oid]) :bat[:bte]
address CMDconvertsignal_bte
comment "cast from sht to bte with candidates list, signal error on overflow";
pattern bte_noerror(b:bat[:sht]) :bat[:bte]
address CMDconvert_bte
comment "cast from sht to bte";
pattern bte_noerror(b:bat[:sht],s:bat[:oid]) :bat[:bte]
address CMDconvert_bte
comment "cast from sht to bte with candidates list";

pattern bte(b:bat[:int]) :bat[:bte]
address CMDconvertsignal_bte
comment "cast from int to bte, signal error on overflow";
pattern bte(b:bat[:int],s:bat[:oid]) :bat[:bte]
address CMDconvertsignal_bte
comment "cast from int to bte with candidates list, signal error on overflow";
pattern bte_noerror(b:bat[:int]) :bat[:bte]
address CMDconvert_bte
comment "cast from int to bte";
pattern bte_noerror(b:bat[:int],s:bat[:oid]) :bat[:bte]
address CMDconvert_bte
comment "cast from int to bte with candidates list";

pattern bte(b:bat[:lng]) :bat[:bte]
address CMDconvertsignal_bte
comment "cast from lng to bte, signal error on overflow";
pattern bte(b:bat[:lng],s:bat[:oid]) :bat[:bte]
address CMDconvertsignal_bte
comment "cast from lng to bte with candidates list, signal error on overflow";
pattern bte_noerror(b:bat[:lng]) :bat[:bte]
address CMDconvert_bte
comment "cast from lng to bte";
pattern bte_noerror(b:bat[:lng],s:bat[:oid]) :bat[:bte]
address CMDconvert_bte
comment "cast from lng to bte with candidates list";

pattern bte(b:bat[:flt]) :bat[:bte]
address CMDconvertsignal_bte
comment "cast from flt to bte, signal error on overflow";
pattern bte(b:bat[:flt],s:bat[:oid]) :bat[:bte]
address CMDconvertsignal_bte
comment "cast from flt to bte with candidates list, signal error on overflow";
pattern bte_noerror(b:bat[:flt]) :bat[:bte]
address CMDconvert_bte
comment "cast from flt to bte";
pattern bte_noerror(b:bat[:flt],s:bat[:oid]) :bat[:bte]
address CMDconvert_bte
comment "cast from flt to bte with candidates list";

pattern bte(b:bat[:dbl]) :bat[:bte]
address CMDconvertsignal_bte
comment "cast from dbl to bte, signal error on overflow";
pattern bte(b:bat[:dbl],s:bat[:oid]) :bat[:bte]
address CMDconvertsignal_bte
comment "cast from dbl to bte with candidates list, signal error on overflow";
pattern bte_noerror(b:bat[:dbl]) :bat[:bte]
address CMDconvert_bte
comment "cast from dbl to bte";
pattern bte_noerror(b:bat[:dbl],s:bat[:oid]) :bat[:bte]
address CMDconvert_bte
comment "cast from dbl to bte with candidates list";

pattern bte(b:bat[:oid]) :bat[:bte]
address CMDconvertsignal_bte
comment "cast from oid to bte, signal error on overflow";
pattern bte(b:bat[:oid],s:bat[:oid]) :bat[:bte]
address CMDconvertsignal_bte
comment "cast from oid to bte with candidates list, signal error on overflow";
pattern bte_noerror(b:bat[:oid]) :bat[:bte]
address CMDconvert_bte
comment "cast from oid to bte";
pattern bte_noerror(b:bat[:oid],s:bat[:oid]) :bat[:bte]
address CMDconvert_bte
comment "cast from oid to bte with candidates list";

pattern bte(b:bat[:str]) :bat[:bte]
address CMDconvertsignal_bte
comment "cast from str to bte, signal error on overflow";
pattern bte(b:bat[:str],s:bat[:oid]) :bat[:bte]
address CMDconvertsignal_bte
comment "cast from str to bte with candidates list, signal error on overflow";
pattern bte_noerror(b:bat[:str]) :bat[:bte]
address CMDconvert_bte
comment "cast from str to bte";
pattern bte_noerror(b:bat[:str],s:bat[:oid]) :bat[:bte]
address CMDconvert_bte
comment "cast from str to bte with candidates list";

pattern sht(b:bat[:bit]) :bat[:sht]
address CMDconvertsignal_sht
comment "cast from bit to sht, signal error on overflow";
pattern sht(b:bat[:bit],s:bat[:oid]) :bat[:sht]
address CMDconvertsignal_sht
comment "cast from bit to sht with candidates list, signal error on overflow";
pattern sht_noerror(b:bat[:bit]) :bat[:sht]
address CMDconvert_sht
comment "cast from bit to sht";
pattern sht_noerror(b:bat[:bit],s:bat[:oid]) :bat[:sht]
address CMDconvert_sht
comment "cast from bit to sht with candidates list";

pattern sht(b:bat[:bte]) :bat[:sht]
address CMDconvertsignal_sht
comment "cast from bte to sht, signal error on overflow";
pattern sht(b:bat[:bte],s:bat[:oid]) :bat[:sht]
address CMDconvertsignal_sht
comment "cast from bte to sht with candidates list, signal error on overflow";
pattern sht_noerror(b:bat[:bte]) :bat[:sht]
address CMDconvert_sht
comment "cast from bte to sht";
pattern sht_noerror(b:bat[:bte],s:bat[:oid]) :bat[:sht]
address CMDconvert_sht
comment "cast from bte to sht with candidates list";

pattern sht(b:bat[:sht]) :bat[:sht]
address CMDconvertsignal_sht
comment "cast from sht to sht, signal error on overflow";
pattern sht(b:bat[:sht],s:bat[:oid]) :bat[:sht]
address CMDconvertsignal_sht
comment "cast from sht to sht with candidates list, signal error on overflow";
pattern sht_noerror(b:bat[:sht]) :bat[:sht]
address CMDconvert_sht
comment "cast from sht to sht";
pattern sht_noerror(b:bat[:sht],s:bat[:oid]) :bat[:sht]
address CMDconvert_sht
comment "cast from sht to sht with candidates list";

pattern sht(b:bat[:int]) :bat[:sht]
address CMDconvertsignal_sht
comment "cast from int to sht, signal error on overflow";
pattern sht(b:bat[:int],s:bat[:oid]) :bat[:sht]
address CMDconvertsignal_sht
comment "cast from int to sht with candidates list, signal error on overflow";
pattern sht_noerror(b:bat[:int]) :bat[:sht]
address CMDconvert_sht
comment "cast from int to sht";
pattern sht_noerror(b:bat[:int],s:bat[:oid]) :bat[:sht]
address CMDconvert_sht
comment "cast from int to sht with candidates list";

pattern sht(b:bat[:lng]) :bat[:sht]
address CMDconvertsignal_sht
comment "cast from lng to sht, signal error on overflow";
pattern sht(b:bat[:lng],s:bat[:oid]) :bat[:sht]
address CMDconvertsignal_sht
comment "cast from lng to sht with candidates list, signal error on overflow";
pattern sht_noerror(b:bat[:lng]) :bat[:sht]
address CMDconvert_sht
comment "cast from lng to sht";
pattern sht_noerror(b:bat[:lng],s:bat[:oid]) :bat[:sht]
address CMDconvert_sht
comment "cast from lng to sht with candidates list";

pattern sht(b:bat[:flt]) :bat[:sht]
address CMDconvertsignal_sht
comment "cast from flt to sht, signal error on overflow";
pattern sht(b:bat[:flt],s:bat[:oid]) :bat[:sht]
address CMDconvertsignal_sht
comment "cast from flt to sht with candidates list, signal error on overflow";
pattern sht_noerror(b:bat[:flt]) :bat[:sht]
address CMDconvert_sht
comment "cast from flt to sht";
pattern sht_noerror(b:bat[:flt],s:bat[:oid]) :bat[:sht]
address CMDconvert_sht
comment "cast from flt to sht with candidates list";

pattern sht(b:bat[:dbl]) :bat[:sht]
address CMDconvertsignal_sht
comment "cast from dbl to sht, signal error on overflow";
pattern sht(b:bat[:dbl],s:bat[:oid]) :bat[:sht]
address CMDconvertsignal_sht
comment "cast from dbl to sht with candidates list, signal error on overflow";
pattern sht_noerror(b:bat[:dbl]) :bat[:sht]
address CMDconvert_sht
comment "cast from dbl to sht";
pattern sht_noerror(b:bat[:dbl],s:bat[:oid]) :bat[:sht]
address CMDconvert_sht
comment "cast from dbl to sht with candidates list";

pattern sht(b:bat[:oid]) :bat[:sht]
address CMDconvertsignal_sht
comment "cast from oid to sht, signal error on overflow";
pattern sht(b:bat[:oid],s:bat[:oid]) :bat[:sht]
address CMDconvertsignal_sht
comment "cast from oid to sht with candidates list, signal error on overflow";
pattern sht_noerror(b:bat[:oid]) :bat[:sht]
address CMDconvert_sht
comment "cast from oid to sht";
pattern sht_noerror(b:bat[:oid],s:bat[:oid]) :bat[:sht]
address CMDconvert_sht
comment "cast from oid to sht with candidates list";

pattern sht(b:bat[:str]) :bat[:sht]
address CMDconvertsignal_sht
comment "cast from str to sht, signal error on overflow";
pattern sht(b:bat[:str],s:bat[:oid]) :bat[:sht]
address CMDconvertsignal_sht
comment "cast from str to sht with candidates list, signal error on overflow";
pattern sht_noerror(b:bat[:str]) :bat[:sht]
address CMDconvert_sht
comment "cast from str to sht";
pattern sht_noerror(b:bat[:str],s:bat[:oid]) :bat[:sht]
address CMDconvert_sht
comment "cast from str to sht with candidates list";

pattern int(b:bat[:bit]) :bat[:int]
address CMDconvertsignal_int
comment "cast from bit to int, signal error on overflow";
pattern int(b:bat[:bit],s:bat[:oid]) :bat[:int]
address CMDconvertsignal_int
comment "cast from bit to int with candidates list, signal error on overflow";
pattern int_noerror(b:bat[:bit]) :bat[:int]
address CMDconvert_int
comment "cast from bit to int";
pattern int_noerror(b:bat[:bit],s:bat[:oid]) :bat[:int]
address CMDconvert_int
comment "cast from bit to int with candidates list";

pattern int(b:bat[:bte]) :bat[:int]
address CMDconvertsignal_int
comment "cast from bte to int, signal error on overflow";
pattern int(b:bat[:bte],s:bat[:oid]) :bat[:int]
address CMDconvertsignal_int
comment "cast from bte to int with candidates list, signal error on overflow";
pattern int_noerror(b:bat[:bte]) :bat[:int]
address CMDconvert_int
comment "cast from bte to int";
pattern int_noerror(b:bat[:bte],s:bat[:oid]) :bat[:int]
address CMDconvert_int
comment "cast from bte to int with candidates list";

pattern int(b:bat[:sht]) :bat[:int]
address CMDconvertsignal_int
comment "cast from sht to int, signal error on overflow";
pattern int(b:bat[:sht],s:bat[:oid]) :bat[:int]
address CMDconvertsignal_int
comment "cast from sht to int with candidates list, signal error on overflow";
pattern int_noerror(b:bat[:sht]) :bat[:int]
address CMDconvert_int
comment "cast from sht to int";
pattern int_noerror(b:bat[:sht],s:bat[:oid]) :bat[:int]
address CMDconvert_int
comment "cast from sht to int with candidates list";

pattern int(b:bat[:int]) :bat[:int]
address CMDconvertsignal_int
comment "cast from int to int, signal error on overflow";
pattern int(b:bat[:int],s:bat[:oid]) :bat[:int]
address CMDconvertsignal_int
comment "cast from int to int with candidates list, signal error on overflow";
pattern int_noerror(b:bat[:int]) :bat[:int]
address CMDconvert_int
comment "cast from int to int";
pattern int_noerror(b:bat[:int],s:bat[:oid]) :bat[:int]
address CMDconvert_int
comment "cast from int to int with candidates list";

pattern int(b:bat[:lng]) :bat[:int]
address CMDconvertsignal_int
comment "cast from lng to int, signal error on overflow";
pattern int(b:bat[:lng],s:bat[:oid]) :bat[:int]
address CMDconvertsignal_int
comment "cast from lng to int with candidates list, signal error on overflow";
pattern int_noerror(b:bat[:lng]) :bat[:int]
address CMDconvert_int
comment "cast from lng to int";
pattern int_noerror(b:bat[:lng],s:bat[:oid]) :bat[:int]
address CMDconvert_int
comment "cast from lng to int with candidates list";

pattern int(b:bat[:flt]) :bat[:int]
address CMDconvertsignal_int
comment "cast from flt to int, signal error on overflow";
pattern int(b:bat[:flt],s:bat[:oid]) :bat[:int]
address CMDconvertsignal_int
comment "cast from flt to int with candidates list, signal error on overflow";
pattern int_noerror(b:bat[:flt]) :bat[:int]
address CMDconvert_int
comment "cast from flt to int";
pattern int_noerror(b:bat[:flt],s:bat[:oid]) :bat[:int]
address CMDconvert_int
comment "cast from flt to int with candidates list";

pattern int(b:bat[:dbl]) :bat[:int]
address CMDconvertsignal_int
comment "cast from dbl to int, signal error on overflow";
pattern int(b:bat[:dbl],s:bat[:oid]) :bat[:int]
address CMDconvertsignal_int
comment "cast from dbl to int with candidates list, signal error on overflow";
pattern int_noerror(b:bat[:dbl]) :bat[:int]
address CMDconvert_int
comment "cast from dbl to int";
pattern int_noerror(b:bat[:dbl],s:bat[:oid]) :bat[:int]
address CMDconvert_int
comment "cast from dbl to int with candidates list";

pattern int(b:bat[:oid]) :bat[:int]
address CMDconvertsignal_int
comment "cast from oid to int, signal error on overflow";
pattern int(b:bat[:oid],s:bat[:oid]) :bat[:int]
address CMDconvertsignal_int
comment "cast from oid to int with candidates list, signal error on overflow";
pattern int_noerror(b:bat[:oid]) :bat[:int]
address CMDconvert_int
comment "cast from oid to int";
pattern int_noerror(b:bat[:oid],s:bat[:oid]) :bat[:int]
address CMDconvert_int
comment "cast from oid to int with candidates list";

pattern int(b:bat[:str]) :bat[:int]
address CMDconvertsignal_int
comment "cast from str to int, signal error on overflow";
pattern int(b:bat[:str],s:bat[:oid]) :bat[:int]
address CMDconvertsignal_int
comment "cast from str to int with candidates list, signal error on overflow";
pattern int_noerror(b:bat[:str]) :bat[:int]
address CMDconvert_int
comment "cast from str to int";
pattern int_noerror(b:bat[:str],s:bat[:oid]) :bat[:int]
address CMDconvert_int
comment "cast from str to int with candidates list";

pattern lng(b:bat[:bit]) :bat[:lng]
address CMDconvertsignal_lng
comment "cast from bit to lng, signal error on overflow";
pattern lng(b:bat[:bit],s:bat[:oid]) :bat[:lng]
address CMDconvertsignal_lng
comment "cast from bit to lng with candidates list, signal error on overflow";
pattern lng_noerror(b:bat[:bit]) :bat[:lng]
address CMDconvert_lng
comment "cast from bit to lng";
pattern lng_noerror(b:bat[:bit],s:bat[:oid]) :bat[:lng]
address CMDconvert_lng
comment "cast from bit to lng with candidates list";

pattern lng(b:bat[:bte]) :bat[:lng]
address CMDconvertsignal_lng
comment "cast from bte to lng, signal error on overflow";
pattern lng(b:bat[:bte],s:bat[:oid]) :bat[:lng]
address CMDconvertsignal_lng
comment "cast from bte to lng with candidates list, signal error on overflow";
pattern lng_noerror(b:bat[:bte]) :bat[:lng]
address CMDconvert_lng
comment "cast from bte to lng";
pattern lng_noerror(b:bat[:bte],s:bat[:oid]) :bat[:lng]
address CMDconvert_lng
comment "cast from bte to lng with candidates list";

pattern lng(b:bat[:sht]) :bat[:lng]
address CMDconvertsignal_lng
comment "cast from sht to lng, signal error on overflow";
pattern lng(b:bat[:sht],s:bat[:oid]) :bat[:lng]
address CMDconvertsignal_lng
comment "cast from sht to lng with candidates list, signal error on overflow";
pattern lng_noerror(b:bat[:sht]) :bat[:lng]
address CMDconvert_lng
comment "cast from sht to lng";
pattern lng_noerror(b:bat[:sht],s:bat[:oid]) :bat[:lng]
address CMDconvert_lng
comment "cast from sht to lng with candidates list";

pattern lng(b:bat[:int]) :bat[:lng]
address CMDconvertsignal_lng
comment "cast from int to lng, signal error on overflow";
pattern lng(b:bat[:int],s:bat[:oid]) :bat[:lng]
address CMDconvertsignal_lng
comment "cast from int to lng with candidates list, signal error on overflow";
pattern lng_noerror(b:bat[:int]) :bat[:lng]
address CMDconvert_lng
comment "cast from int to lng";
pattern lng_noerror(b:bat[:int],s:bat[:oid]) :bat[:lng]
address CMDconvert_lng
comment "cast from int to lng with candidates list";

pattern lng(b:bat[:lng]) :bat[:lng]
address CMDconvertsignal_lng
comment "cast from lng to lng, signal error on overflow";
pattern lng(b:bat[:lng],s:bat[:oid]) :bat[:lng]
address CMDconvertsignal_lng
comment "cast from lng to lng with candidates list, signal error on overflow";
pattern lng_noerror(b:bat[:lng]) :bat[:lng]
address CMDconvert_lng
comment "cast from lng to lng";
pattern lng_noerror(b:bat[:lng],s:bat[:oid]) :bat[:lng]
address CMDconvert_lng
comment "cast from lng to lng with candidates list";

pattern lng(b:bat[:flt]) :bat[:lng]
address CMDconvertsignal_lng
comment "cast from flt to lng, signal error on overflow";
pattern lng(b:bat[:flt],s:bat[:oid]) :bat[:lng]
address CMDconvertsignal_lng
comment "cast from flt to lng with candidates list, signal error on overflow";
pattern lng_noerror(b:bat[:flt]) :bat[:lng]
address CMDconvert_lng
comment "cast from flt to lng";
pattern lng_noerror(b:bat[:flt],s:bat[:oid]) :bat[:lng]
address CMDconvert_lng
comment "cast from flt to lng with candidates list";

pattern lng(b:bat[:dbl]) :bat[:lng]
address CMDconvertsignal_lng
comment "cast from dbl to lng, signal error on overflow";
pattern lng(b:bat[:dbl],s:bat[:oid]) :bat[:lng]
address CMDconvertsignal_lng
comment "cast from dbl to lng with candidates list, signal error on overflow";
pattern lng_noerror(b:bat[:dbl]) :bat[:lng]
address CMDconvert_lng
comment "cast from dbl to lng";
pattern lng_noerror(b:bat[:dbl],s:bat[:oid]) :bat[:lng]
address CMDconvert_lng
comment "cast from dbl to lng with candidates list";

pattern lng(b:bat[:oid]) :bat[:lng]
address CMDconvertsignal_lng
comment "cast from oid to lng, signal error on overflow";
pattern lng(b:bat[:oid],s:bat[:oid]) :bat[:lng]
address CMDconvertsignal_lng
comment "cast from oid to lng with candidates list, signal error on overflow";
pattern lng_noerror(b:bat[:oid]) :bat[:lng]
address CMDconvert_lng
comment "cast from oid to lng";
pattern lng_noerror(b:bat[:oid],s:bat[:oid]) :bat[:lng]
address CMDconvert_lng
comment "cast from oid to lng with candidates list";

pattern lng(b:bat[:str]) :bat[:lng]
address CMDconvertsignal_lng
comment "cast from str to lng, signal error on overflow";
pattern lng(b:bat[:str],s:bat[:oid]) :bat[:lng]
address CMDconvertsignal_lng
comment "cast from str to lng with candidates list, signal error on overflow";
pattern lng_noerror(b:bat[:str]) :bat[:lng]
address CMDconvert_lng
comment "cast from str to lng";
pattern lng_noerror(b:bat[:str],s:bat[:oid]) :bat[:lng]
address CMDconvert_lng
comment "cast from str to lng with candidates list";

pattern flt(b:bat[:bit]) :bat[:flt]
address CMDconvertsignal_flt
comment "cast from bit to flt, signal error on overflow";
pattern flt(b:bat[:bit],s:bat[:oid]) :bat[:flt]
address CMDconvertsignal_flt
comment "cast from bit to flt with candidates list, signal error on overflow";
pattern flt_noerror(b:bat[:bit]) :bat[:flt]
address CMDconvert_flt
comment "cast from bit to flt";
pattern flt_noerror(b:bat[:bit],s:bat[:oid]) :bat[:flt]
address CMDconvert_flt
comment "cast from bit to flt with candidates list";

pattern flt(b:bat[:bte]) :bat[:flt]
address CMDconvertsignal_flt
comment "cast from bte to flt, signal error on overflow";
pattern flt(b:bat[:bte],s:bat[:oid]) :bat[:flt]
address CMDconvertsignal_flt
comment "cast from bte to flt with candidates list, signal error on overflow";
pattern flt_noerror(b:bat[:bte]) :bat[:flt]
address CMDconvert_flt
comment "cast from bte to flt";
pattern flt_noerror(b:bat[:bte],s:bat[:oid]) :bat[:flt]
address CMDconvert_flt
comment "cast from bte to flt with candidates list";

pattern flt(b:bat[:sht]) :bat[:flt]
address CMDconvertsignal_flt
comment "cast from sht to flt, signal error on overflow";
pattern flt(b:bat[:sht],s:bat[:oid]) :bat[:flt]
address CMDconvertsignal_flt
comment "cast from sht to flt with candidates list, signal error on overflow";
pattern flt_noerror(b:bat[:sht]) :bat[:flt]
address CMDconvert_flt
comment "cast from sht to flt";
pattern flt_noerror(b:bat[:sht],s:bat[:oid]) :bat[:flt]
address CMDconvert_flt
comment "cast from sht to flt with candidates list";

pattern flt(b:bat[:int]) :bat[:flt]
address CMDconvertsignal_flt
comment "cast from int to flt, signal error on overflow";
pattern flt(b:bat[:int],s:bat[:oid]) :bat[:flt]
address CMDconvertsignal_flt
comment "cast from int to flt with candidates list, signal error on overflow";
pattern flt_noerror(b:bat[:int]) :bat[:flt]
address CMDconvert_flt
comment "cast from int to flt";
pattern flt_noerror(b:bat[:int],s:bat[:oid]) :bat[:flt]
address CMDconvert_flt
comment "cast from int to flt with candidates list";

pattern flt(b:bat[:lng]) :bat[:flt]
address CMDconvertsignal_flt
comment "cast from lng to flt, signal error on overflow";
pattern flt(b:bat[:lng],s:bat[:oid]) :bat[:flt]
address CMDconvertsignal_flt
comment "cast from lng to flt with candidates list, signal error on overflow";
pattern flt_noerror(b:bat[:lng]) :bat[:flt]
address CMDconvert_flt
comment "cast from lng to flt";
pattern flt_noerror(b:bat[:lng],s:bat[:oid]) :bat[:flt]
address CMDconvert_flt
comment "cast from lng to flt with candidates list";

pattern flt(b:bat[:flt]) :bat[:flt]
address CMDconvertsignal_flt
comment "cast from flt to flt, signal error on overflow";
pattern flt(b:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDconvertsignal_flt
comment "cast from flt to flt with candidates list, signal error on overflow";
pattern flt_noerror(b:bat[:flt]) :bat[:flt]
address CMDconvert_flt
comment "cast from flt to flt";
pattern flt_noerror(b:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDconvert_flt
comment "cast from flt to flt with candidates list";

pattern flt(b:bat[:dbl]) :bat[:flt]
address CMDconvertsignal_flt
comment "cast from dbl to flt, signal error on overflow";
pattern flt(b:bat[:dbl],s:bat[:oid]) :bat[:flt]
address CMDconvertsignal_flt
comment "cast from dbl to flt with candidates list, signal error on overflow";
pattern flt_noerror(b:bat[:dbl]) :bat[:flt]
address CMDconvert_flt
comment "cast from dbl to flt";
pattern flt_noerror(b:bat[:dbl],s:bat[:oid]) :bat[:flt]
address CMDconvert_flt
comment "cast from dbl to flt with candidates list";

pattern flt(b:bat[:oid]) :bat[:flt]
address CMDconvertsignal_flt
comment "cast from oid to flt, signal error on overflow";
pattern flt(b:bat[:oid],s:bat[:oid]) :bat[:flt]
address CMDconvertsignal_flt
comment "cast from oid to flt with candidates list, signal error on overflow";
pattern flt_noerror(b:bat[:oid]) :bat[:flt]
address CMDconvert_flt
comment "cast from oid to flt";
pattern flt_noerror(b:bat[:oid],s:bat[:oid]) :bat[:flt]
address CMDconvert_flt
comment "cast from oid to flt with candidates list";

pattern flt(b:bat[:str]) :bat[:flt]
address CMDconvertsignal_flt
comment "cast from str to flt, signal error on overflow";
pattern flt(b:bat[:str],s:bat[:oid]) :bat[:flt]
address CMDconvertsignal_flt
comment "cast from str to flt with candidates list, signal error on overflow";
pattern flt_noerror(b:bat[:str]) :bat[:flt]
address CMDconvert_flt
comment "cast from str to flt";
pattern flt_noerror(b:bat[:str],s:bat[:oid]) :bat[:flt]
address CMDconvert_flt
comment "cast from str to flt with candidates list";

pattern dbl(b:bat[:bit]) :bat[:dbl]
address CMDconvertsignal_dbl
comment "cast from bit to dbl, signal error on overflow";
pattern dbl(b:bat[:bit],s:bat[:oid]) :bat[:dbl]
address CMDconvertsignal_dbl
comment "cast from bit to dbl with candidates list, signal error on overflow";
pattern dbl_noerror(b:bat[:bit]) :bat[:dbl]
address CMDconvert_dbl
comment "cast from bit to dbl";
pattern dbl_noerror(b:bat[:bit],s:bat[:oid]) :bat[:dbl]
address CMDconvert_dbl
comment "cast from bit to dbl with candidates list";

pattern dbl(b:bat[:bte]) :bat[:dbl]
address CMDconvertsignal_dbl
comment "cast from bte to dbl, signal error on overflow";
pattern dbl(b:bat[:bte],s:bat[:oid]) :bat[:dbl]
address CMDconvertsignal_dbl
comment "cast from bte to dbl with candidates list, signal error on overflow";
pattern dbl_noerror(b:bat[:bte]) :bat[:dbl]
address CMDconvert_dbl
comment "cast from bte to dbl";
pattern dbl_noerror(b:bat[:bte],s:bat[:oid]) :bat[:dbl]
address CMDconvert_dbl
comment "cast from bte to dbl with candidates list";

pattern dbl(b:bat[:sht]) :bat[:dbl]
address CMDconvertsignal_dbl
comment "cast from sht to dbl, signal error on overflow";
pattern dbl(b:bat[:sht],s:bat[:oid]) :bat[:dbl]
address CMDconvertsignal_dbl
comment "cast from sht to dbl with candidates list, signal error on overflow";
pattern dbl_noerror(b:bat[:sht]) :bat[:dbl]
address CMDconvert_dbl
comment "cast from sht to dbl";
pattern dbl_noerror(b:bat[:sht],s:bat[:oid]) :bat[:dbl]
address CMDconvert_dbl
comment "cast from sht to dbl with candidates list";

pattern dbl(b:bat[:int]) :bat[:dbl]
address CMDconvertsignal_dbl
comment "cast from int to dbl, signal error on overflow";
pattern dbl(b:bat[:int],s:bat[:oid]) :bat[:dbl]
address CMDconvertsignal_dbl
comment "cast from int to dbl with candidates list, signal error on overflow";
pattern dbl_noerror(b:bat[:int]) :bat[:dbl]
address CMDconvert_dbl
comment "cast from int to dbl";
pattern dbl_noerror(b:bat[:int],s:bat[:oid]) :bat[:dbl]
address CMDconvert_dbl
comment "cast from int to dbl with candidates list";

pattern dbl(b:bat[:lng]) :bat[:dbl]
address CMDconvertsignal_dbl
comment "cast from lng to dbl, signal error on overflow";
pattern dbl(b:bat[:lng],s:bat[:oid]) :bat[:dbl]
address CMDconvertsignal_dbl
comment "cast from lng to dbl with candidates list, signal error on overflow";
pattern dbl_noerror(b:bat[:lng]) :bat[:dbl]
address CMDconvert_dbl
comment "cast from lng to dbl";
pattern dbl_noerror(b:bat[:lng],s:bat[:oid]) :bat[:dbl]
address CMDconvert_dbl
comment "cast from lng to dbl with candidates list";

pattern dbl(b:bat[:flt]) :bat[:dbl]
address CMDconvertsignal_dbl
comment "cast from flt to dbl, signal error on overflow";
pattern dbl(b:bat[:flt],s:bat[:oid]) :bat[:dbl]
address CMDconvertsignal_dbl
comment "cast from flt to dbl with candidates list, signal error on overflow";
pattern dbl_noerror(b:bat[:flt]) :bat[:dbl]
address CMDconvert_dbl
comment "cast from flt to dbl";
pattern dbl_noerror(b:bat[:flt],s:bat[:oid]) :bat[:dbl]
address CMDconvert_dbl
comment "cast from flt to dbl with candidates list";

pattern dbl(b:bat[:dbl]) :bat[:dbl]
address CMDconvertsignal_dbl
comment "cast from dbl to dbl, signal error on overflow";
pattern dbl(b:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDconvertsignal_dbl
comment "cast from dbl to dbl with candidates list, signal error on overflow";
pattern dbl_noerror(b:bat[:dbl]) :bat[:dbl]
address CMDconvert_dbl
comment "cast from dbl to dbl";
pattern dbl_noerror(b:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDconvert_dbl
comment "cast from dbl to dbl with candidates list";

pattern dbl(b:bat[:oid]) :bat[:dbl]
address CMDconvertsignal_dbl
comment "cast from oid to dbl, signal error on overflow";
pattern dbl(b:bat[:oid],s:bat[:oid]) :bat[:dbl]
address CMDconvertsignal_dbl
comment "cast from oid to dbl with candidates list, signal error on overflow";
pattern dbl_noerror(b:bat[:oid]) :bat[:dbl]
address CMDconvert_dbl
comment "cast from oid to dbl";
pattern dbl_noerror(b:bat[:oid],s:bat[:oid]) :bat[:dbl]
address CMDconvert_dbl
comment "cast from oid to dbl with candidates list";

pattern dbl(b:bat[:str]) :bat[:dbl]
address CMDconvertsignal_dbl
comment "cast from str to dbl, signal error on overflow";
pattern dbl(b:bat[:str],s:bat[:oid]) :bat[:dbl]
address CMDconvertsignal_dbl
comment "cast from str to dbl with candidates list, signal error on overflow";
pattern dbl_noerror(b:bat[:str]) :bat[:dbl]
address CMDconvert_dbl
comment "cast from str to dbl";
pattern dbl_noerror(b:bat[:str],s:bat[:oid]) :bat[:dbl]
address CMDconvert_dbl
comment "cast from str to dbl with candidates list";

pattern oid(b:bat[:bit]) :bat[:oid]
address CMDconvertsignal_oid
comment "cast from bit to oid, signal error on overflow";
pattern oid(b:bat[:bit],s:bat[:oid]) :bat[:oid]
address CMDconvertsignal_oid
comment "cast from bit to oid with candidates list, signal error on overflow";
pattern oid_noerror(b:bat[:bit]) :bat[:oid]
address CMDconvert_oid
comment "cast from bit to oid";
pattern oid_noerror(b:bat[:bit],s:bat[:oid]) :bat[:oid]
address CMDconvert_oid
comment "cast from bit to oid with candidates list";

pattern oid(b:bat[:bte]) :bat[:oid]
address CMDconvertsignal_oid
comment "cast from bte to oid, signal error on overflow";
pattern oid(b:bat[:bte],s:bat[:oid]) :bat[:oid]
address CMDconvertsignal_oid
comment "cast from bte to oid with candidates list, signal error on overflow";
pattern oid_noerror(b:bat[:bte]) :bat[:oid]
address CMDconvert_oid
comment "cast from bte to oid";
pattern oid_noerror(b:bat[:bte],s:bat[:oid]) :bat[:oid]
address CMDconvert_oid
comment "cast from bte to oid with candidates list";

pattern oid(b:bat[:sht]) :bat[:oid]
address CMDconvertsignal_oid
comment "cast from sht to oid, signal error on overflow";
pattern oid(b:bat[:sht],s:bat[:oid]) :bat[:oid]
address CMDconvertsignal_oid
comment "cast from sht to oid with candidates list, signal error on overflow";
pattern oid_noerror(b:bat[:sht]) :bat[:oid]
address CMDconvert_oid
comment "cast from sht to oid";
pattern oid_noerror(b:bat[:sht],s:bat[:oid]) :bat[:oid]
address CMDconvert_oid
comment "cast from sht to oid with candidates list";

pattern oid(b:bat[:int]) :bat[:oid]
address CMDconvertsignal_oid
comment "cast from int to oid, signal error on overflow";
pattern oid(b:bat[:int],s:bat[:oid]) :bat[:oid]
address CMDconvertsignal_oid
comment "cast from int to oid with candidates list, signal error on overflow";
pattern oid_noerror(b:bat[:int]) :bat[:oid]
address CMDconvert_oid
comment "cast from int to oid";
pattern oid_noerror(b:bat[:int],s:bat[:oid]) :bat[:oid]
address CMDconvert_oid
comment "cast from int to oid with candidates list";

pattern oid(b:bat[:lng]) :bat[:oid]
address CMDconvertsignal_oid
comment "cast from lng to oid, signal error on overflow";
pattern oid(b:bat[:lng],s:bat[:oid]) :bat[:oid]
address CMDconvertsignal_oid
comment "cast from lng to oid with candidates list, signal error on overflow";
pattern oid_noerror(b:bat[:lng]) :bat[:oid]
address CMDconvert_oid
comment "cast from lng to oid";
pattern oid_noerror(b:bat[:lng],s:bat[:oid]) :bat[:oid]
address CMDconvert_oid
comment "cast from lng to oid with candidates list";

pattern oid(b:bat[:flt]) :bat[:oid]
address CMDconvertsignal_oid
comment "cast from flt to oid, signal error on overflow";
pattern oid(b:bat[:flt],s:bat[:oid]) :bat[:oid]
address CMDconvertsignal_oid
comment "cast from flt to oid with candidates list, signal error on overflow";
pattern oid_noerror(b:bat[:flt]) :bat[:oid]
address CMDconvert_oid
comment "cast from flt to oid";
pattern oid_noerror(b:bat[:flt],s:bat[:oid]) :bat[:oid]
address CMDconvert_oid
comment "cast from flt to oid with candidates list";

pattern oid(b:bat[:dbl]) :bat[:oid]
address CMDconvertsignal_oid
comment "cast from dbl to oid, signal error on overflow";
pattern oid(b:bat[:dbl],s:bat[:oid]) :bat[:oid]
address CMDconvertsignal_oid
comment "cast from dbl to oid with candidates list, signal error on overflow";
pattern oid_noerror(b:bat[:dbl]) :bat[:oid]
address CMDconvert_oid
comment "cast from dbl to oid";
pattern oid_noerror(b:bat[:dbl],s:bat[:oid]) :bat[:oid]
address CMDconvert_oid
comment "cast from dbl to oid with candidates list";

pattern oid(b:bat[:oid]) :bat[:oid]
address CMDconvertsignal_oid
comment "cast from oid to oid, signal error on overflow";
pattern oid(b:bat[:oid],s:bat[:oid]) :bat[:oid]
address CMDconvertsignal_oid
comment "cast from oid to oid with candidates list, signal error on overflow";
pattern oid_noerror(b:bat[:oid]) :bat[:oid]
address CMDconvert_oid
comment "cast from oid to oid";
pattern oid_noerror(b:bat[:oid],s:bat[:oid]) :bat[:oid]
address CMDconvert_oid
comment "cast from oid to oid with candidates list";

pattern oid(b:bat[:str]) :bat[:oid]
address CMDconvertsignal_oid
comment "cast from str to oid, signal error on overflow";
pattern oid(b:bat[:str],s:bat[:oid]) :bat[:oid]
address CMDconvertsignal_oid
comment "cast from str to oid with candidates list, signal error on overflow";
pattern oid_noerror(b:bat[:str]) :bat[:oid]
address CMDconvert_oid
comment "cast from str to oid";
pattern oid_noerror(b:bat[:str],s:bat[:oid]) :bat[:oid]
address CMDconvert_oid
comment "cast from str to oid with candidates list";

pattern str(b:bat[:any]) :bat[:str]
address CMDconvertsignal_str
comment "cast from any to str, signal error on overflow";
pattern str(b:bat[:any],s:bat[:oid]) :bat[:str]
address CMDconvertsignal_str
comment "cast from any to str with candidates list, signal error on overflow";
pattern str_noerror(b:bat[:any]) :bat[:str]
address CMDconvert_str
comment "cast from any to str";
pattern str_noerror(b:bat[:any],s:bat[:oid]) :bat[:str]
address CMDconvert_str
comment "cast from any to str with candidates list";

pattern ifthenelse(v:bit, b1:bat[:any_1], b2:bat[:any_1]) :bat[:any_1]
address CMDifthen
comment "If-then-else operation to assemble a conditional result";

pattern ifthenelse(v:bit, v1:any_1, b2:bat[:any_1]) :bat[:any_1]
address CMDifthen
comment "If-then-else operation to assemble a conditional result";

pattern ifthenelse(v:bit, b1:bat[:any_1], v2:any_1) :bat[:any_1]
address CMDifthen
comment "If-then-else operation to assemble a conditional result";

pattern ifthenelse(b:bat[:bit], v1:any_1, v2:any_1) :bat[:any_1]
address CMDifthen
comment "If-then-else operation to assemble a conditional result";

pattern ifthenelse(b:bat[:bit], b1:bat[:any_1], v2:any_1) :bat[:any_1]
address CMDifthen
comment "If-then-else operation to assemble a conditional result";

pattern ifthenelse(b:bat[:bit], v1:any_1, b2:bat[:any_1]) :bat[:any_1]
address CMDifthen
comment "If-then-else operation to assemble a conditional result";

pattern ifthenelse(b:bat[:bit], b1:bat[:any_1], b2:bat[:any_1]) :bat[:any_1]
address CMDifthen
comment "If-then-else operation to assemble a conditional result";

