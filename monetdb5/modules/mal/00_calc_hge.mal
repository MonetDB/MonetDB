# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0.  If a copy of the MPL was not distributed with this
# file, You can obtain one at http://mozilla.org/MPL/2.0/.
#
# Copyright 1997 - July 2008 CWI, August 2008 - 2018 MonetDB B.V.

# This file was generated by using the script 00_calc_hge.mal.sh.

module calc;

pattern iszero(v:hge) :bit
address CMDvarISZERO
comment "Unary check for zero of V";


pattern not(v:hge) :hge
address CMDvarNOT
comment "Unary bitwise not of V";


pattern sign(v:hge) :bte
address CMDvarSIGN
comment "Unary sign (-1,0,1) of V";


pattern abs(v:hge) :hge
address CMDvarABS
comment "Unary absolute value of V";


pattern -(v:hge) :hge
address CMDvarNEG
comment "Unary negation of V";


pattern ++(v:hge) :hge
address CMDvarINCRsignal
comment "Unary V + 1";


pattern --(v:hge) :hge
address CMDvarDECRsignal
comment "Unary V - 1";


pattern +(v1:bte,v2:lng) :hge
address CMDvarADDsignal
comment "Return V1 + V2, guarantee no overflow by returning larger type";

pattern +(v1:sht,v2:lng) :hge
address CMDvarADDsignal
comment "Return V1 + V2, guarantee no overflow by returning larger type";

pattern +(v1:int,v2:lng) :hge
address CMDvarADDsignal
comment "Return V1 + V2, guarantee no overflow by returning larger type";

pattern +(v1:lng,v2:bte) :hge
address CMDvarADDsignal
comment "Return V1 + V2, guarantee no overflow by returning larger type";

pattern +(v1:lng,v2:sht) :hge
address CMDvarADDsignal
comment "Return V1 + V2, guarantee no overflow by returning larger type";

pattern +(v1:lng,v2:int) :hge
address CMDvarADDsignal
comment "Return V1 + V2, guarantee no overflow by returning larger type";

pattern +(v1:lng,v2:lng) :hge
address CMDvarADDsignal
comment "Return V1 + V2, guarantee no overflow by returning larger type";

pattern +(v1:hge,v2:flt) :dbl
address CMDvarADDsignal
comment "Return V1 + V2, guarantee no overflow by returning larger type";

pattern +(v1:flt,v2:hge) :dbl
address CMDvarADDsignal
comment "Return V1 + V2, guarantee no overflow by returning larger type";


pattern -(v1:bte,v2:lng) :hge
address CMDvarSUBsignal
comment "Return V1 - V2, guarantee no overflow by returning larger type";

pattern -(v1:sht,v2:lng) :hge
address CMDvarSUBsignal
comment "Return V1 - V2, guarantee no overflow by returning larger type";

pattern -(v1:int,v2:lng) :hge
address CMDvarSUBsignal
comment "Return V1 - V2, guarantee no overflow by returning larger type";

pattern -(v1:lng,v2:bte) :hge
address CMDvarSUBsignal
comment "Return V1 - V2, guarantee no overflow by returning larger type";

pattern -(v1:lng,v2:sht) :hge
address CMDvarSUBsignal
comment "Return V1 - V2, guarantee no overflow by returning larger type";

pattern -(v1:lng,v2:int) :hge
address CMDvarSUBsignal
comment "Return V1 - V2, guarantee no overflow by returning larger type";

pattern -(v1:lng,v2:lng) :hge
address CMDvarSUBsignal
comment "Return V1 - V2, guarantee no overflow by returning larger type";

pattern -(v1:hge,v2:flt) :dbl
address CMDvarSUBsignal
comment "Return V1 - V2, guarantee no overflow by returning larger type";

pattern -(v1:flt,v2:hge) :dbl
address CMDvarSUBsignal
comment "Return V1 - V2, guarantee no overflow by returning larger type";


pattern *(v1:bte,v2:lng) :hge
address CMDvarMULsignal
comment "Return V1 * V2, guarantee no overflow by returning larger type";

pattern *(v1:sht,v2:lng) :hge
address CMDvarMULsignal
comment "Return V1 * V2, guarantee no overflow by returning larger type";

pattern *(v1:int,v2:lng) :hge
address CMDvarMULsignal
comment "Return V1 * V2, guarantee no overflow by returning larger type";

pattern *(v1:lng,v2:bte) :hge
address CMDvarMULsignal
comment "Return V1 * V2, guarantee no overflow by returning larger type";

pattern *(v1:lng,v2:sht) :hge
address CMDvarMULsignal
comment "Return V1 * V2, guarantee no overflow by returning larger type";

pattern *(v1:lng,v2:int) :hge
address CMDvarMULsignal
comment "Return V1 * V2, guarantee no overflow by returning larger type";

pattern *(v1:lng,v2:lng) :hge
address CMDvarMULsignal
comment "Return V1 * V2, guarantee no overflow by returning larger type";

pattern *(v1:hge,v2:flt) :dbl
address CMDvarMULsignal
comment "Return V1 * V2, guarantee no overflow by returning larger type";

pattern *(v1:flt,v2:hge) :dbl
address CMDvarMULsignal
comment "Return V1 * V2, guarantee no overflow by returning larger type";


pattern +(v1:bte,v2:hge) :hge
address CMDvarADDsignal
comment "Return V1 + V2, signal error on overflow";
pattern add_noerror(v1:bte,v2:hge) :hge
address CMDvarADD
comment "Return V1 + V2, overflow causes NIL value";

pattern +(v1:sht,v2:hge) :hge
address CMDvarADDsignal
comment "Return V1 + V2, signal error on overflow";
pattern add_noerror(v1:sht,v2:hge) :hge
address CMDvarADD
comment "Return V1 + V2, overflow causes NIL value";

pattern +(v1:int,v2:hge) :hge
address CMDvarADDsignal
comment "Return V1 + V2, signal error on overflow";
pattern add_noerror(v1:int,v2:hge) :hge
address CMDvarADD
comment "Return V1 + V2, overflow causes NIL value";

pattern +(v1:lng,v2:hge) :hge
address CMDvarADDsignal
comment "Return V1 + V2, signal error on overflow";
pattern add_noerror(v1:lng,v2:hge) :hge
address CMDvarADD
comment "Return V1 + V2, overflow causes NIL value";

pattern +(v1:hge,v2:bte) :hge
address CMDvarADDsignal
comment "Return V1 + V2, signal error on overflow";
pattern add_noerror(v1:hge,v2:bte) :hge
address CMDvarADD
comment "Return V1 + V2, overflow causes NIL value";

pattern +(v1:hge,v2:sht) :hge
address CMDvarADDsignal
comment "Return V1 + V2, signal error on overflow";
pattern add_noerror(v1:hge,v2:sht) :hge
address CMDvarADD
comment "Return V1 + V2, overflow causes NIL value";

pattern +(v1:hge,v2:int) :hge
address CMDvarADDsignal
comment "Return V1 + V2, signal error on overflow";
pattern add_noerror(v1:hge,v2:int) :hge
address CMDvarADD
comment "Return V1 + V2, overflow causes NIL value";

pattern +(v1:hge,v2:lng) :hge
address CMDvarADDsignal
comment "Return V1 + V2, signal error on overflow";
pattern add_noerror(v1:hge,v2:lng) :hge
address CMDvarADD
comment "Return V1 + V2, overflow causes NIL value";

pattern +(v1:hge,v2:hge) :hge
address CMDvarADDsignal
comment "Return V1 + V2, signal error on overflow";
pattern add_noerror(v1:hge,v2:hge) :hge
address CMDvarADD
comment "Return V1 + V2, overflow causes NIL value";

pattern +(v1:hge,v2:flt) :flt
address CMDvarADDsignal
comment "Return V1 + V2, signal error on overflow";
pattern add_noerror(v1:hge,v2:flt) :flt
address CMDvarADD
comment "Return V1 + V2, overflow causes NIL value";

pattern +(v1:hge,v2:dbl) :dbl
address CMDvarADDsignal
comment "Return V1 + V2, signal error on overflow";
pattern add_noerror(v1:hge,v2:dbl) :dbl
address CMDvarADD
comment "Return V1 + V2, overflow causes NIL value";

pattern +(v1:flt,v2:hge) :flt
address CMDvarADDsignal
comment "Return V1 + V2, signal error on overflow";
pattern add_noerror(v1:flt,v2:hge) :flt
address CMDvarADD
comment "Return V1 + V2, overflow causes NIL value";

pattern +(v1:dbl,v2:hge) :dbl
address CMDvarADDsignal
comment "Return V1 + V2, signal error on overflow";
pattern add_noerror(v1:dbl,v2:hge) :dbl
address CMDvarADD
comment "Return V1 + V2, overflow causes NIL value";


pattern -(v1:bte,v2:hge) :hge
address CMDvarSUBsignal
comment "Return V1 - V2, signal error on overflow";
pattern sub_noerror(v1:bte,v2:hge) :hge
address CMDvarSUB
comment "Return V1 - V2, overflow causes NIL value";

pattern -(v1:sht,v2:hge) :hge
address CMDvarSUBsignal
comment "Return V1 - V2, signal error on overflow";
pattern sub_noerror(v1:sht,v2:hge) :hge
address CMDvarSUB
comment "Return V1 - V2, overflow causes NIL value";

pattern -(v1:int,v2:hge) :hge
address CMDvarSUBsignal
comment "Return V1 - V2, signal error on overflow";
pattern sub_noerror(v1:int,v2:hge) :hge
address CMDvarSUB
comment "Return V1 - V2, overflow causes NIL value";

pattern -(v1:lng,v2:hge) :hge
address CMDvarSUBsignal
comment "Return V1 - V2, signal error on overflow";
pattern sub_noerror(v1:lng,v2:hge) :hge
address CMDvarSUB
comment "Return V1 - V2, overflow causes NIL value";

pattern -(v1:hge,v2:bte) :hge
address CMDvarSUBsignal
comment "Return V1 - V2, signal error on overflow";
pattern sub_noerror(v1:hge,v2:bte) :hge
address CMDvarSUB
comment "Return V1 - V2, overflow causes NIL value";

pattern -(v1:hge,v2:sht) :hge
address CMDvarSUBsignal
comment "Return V1 - V2, signal error on overflow";
pattern sub_noerror(v1:hge,v2:sht) :hge
address CMDvarSUB
comment "Return V1 - V2, overflow causes NIL value";

pattern -(v1:hge,v2:int) :hge
address CMDvarSUBsignal
comment "Return V1 - V2, signal error on overflow";
pattern sub_noerror(v1:hge,v2:int) :hge
address CMDvarSUB
comment "Return V1 - V2, overflow causes NIL value";

pattern -(v1:hge,v2:lng) :hge
address CMDvarSUBsignal
comment "Return V1 - V2, signal error on overflow";
pattern sub_noerror(v1:hge,v2:lng) :hge
address CMDvarSUB
comment "Return V1 - V2, overflow causes NIL value";

pattern -(v1:hge,v2:hge) :hge
address CMDvarSUBsignal
comment "Return V1 - V2, signal error on overflow";
pattern sub_noerror(v1:hge,v2:hge) :hge
address CMDvarSUB
comment "Return V1 - V2, overflow causes NIL value";

pattern -(v1:hge,v2:flt) :flt
address CMDvarSUBsignal
comment "Return V1 - V2, signal error on overflow";
pattern sub_noerror(v1:hge,v2:flt) :flt
address CMDvarSUB
comment "Return V1 - V2, overflow causes NIL value";

pattern -(v1:hge,v2:dbl) :dbl
address CMDvarSUBsignal
comment "Return V1 - V2, signal error on overflow";
pattern sub_noerror(v1:hge,v2:dbl) :dbl
address CMDvarSUB
comment "Return V1 - V2, overflow causes NIL value";

pattern -(v1:flt,v2:hge) :flt
address CMDvarSUBsignal
comment "Return V1 - V2, signal error on overflow";
pattern sub_noerror(v1:flt,v2:hge) :flt
address CMDvarSUB
comment "Return V1 - V2, overflow causes NIL value";

pattern -(v1:dbl,v2:hge) :dbl
address CMDvarSUBsignal
comment "Return V1 - V2, signal error on overflow";
pattern sub_noerror(v1:dbl,v2:hge) :dbl
address CMDvarSUB
comment "Return V1 - V2, overflow causes NIL value";


pattern *(v1:bte,v2:hge) :hge
address CMDvarMULsignal
comment "Return V1 * V2, signal error on overflow";
pattern mul_noerror(v1:bte,v2:hge) :hge
address CMDvarMUL
comment "Return V1 * V2, overflow causes NIL value";

pattern *(v1:sht,v2:hge) :hge
address CMDvarMULsignal
comment "Return V1 * V2, signal error on overflow";
pattern mul_noerror(v1:sht,v2:hge) :hge
address CMDvarMUL
comment "Return V1 * V2, overflow causes NIL value";

pattern *(v1:int,v2:hge) :hge
address CMDvarMULsignal
comment "Return V1 * V2, signal error on overflow";
pattern mul_noerror(v1:int,v2:hge) :hge
address CMDvarMUL
comment "Return V1 * V2, overflow causes NIL value";

pattern *(v1:lng,v2:hge) :hge
address CMDvarMULsignal
comment "Return V1 * V2, signal error on overflow";
pattern mul_noerror(v1:lng,v2:hge) :hge
address CMDvarMUL
comment "Return V1 * V2, overflow causes NIL value";

pattern *(v1:hge,v2:bte) :hge
address CMDvarMULsignal
comment "Return V1 * V2, signal error on overflow";
pattern mul_noerror(v1:hge,v2:bte) :hge
address CMDvarMUL
comment "Return V1 * V2, overflow causes NIL value";

pattern *(v1:hge,v2:sht) :hge
address CMDvarMULsignal
comment "Return V1 * V2, signal error on overflow";
pattern mul_noerror(v1:hge,v2:sht) :hge
address CMDvarMUL
comment "Return V1 * V2, overflow causes NIL value";

pattern *(v1:hge,v2:int) :hge
address CMDvarMULsignal
comment "Return V1 * V2, signal error on overflow";
pattern mul_noerror(v1:hge,v2:int) :hge
address CMDvarMUL
comment "Return V1 * V2, overflow causes NIL value";

pattern *(v1:hge,v2:lng) :hge
address CMDvarMULsignal
comment "Return V1 * V2, signal error on overflow";
pattern mul_noerror(v1:hge,v2:lng) :hge
address CMDvarMUL
comment "Return V1 * V2, overflow causes NIL value";

pattern *(v1:hge,v2:hge) :hge
address CMDvarMULsignal
comment "Return V1 * V2, signal error on overflow";
pattern mul_noerror(v1:hge,v2:hge) :hge
address CMDvarMUL
comment "Return V1 * V2, overflow causes NIL value";

pattern *(v1:hge,v2:flt) :flt
address CMDvarMULsignal
comment "Return V1 * V2, signal error on overflow";
pattern mul_noerror(v1:hge,v2:flt) :flt
address CMDvarMUL
comment "Return V1 * V2, overflow causes NIL value";

pattern *(v1:hge,v2:dbl) :dbl
address CMDvarMULsignal
comment "Return V1 * V2, signal error on overflow";
pattern mul_noerror(v1:hge,v2:dbl) :dbl
address CMDvarMUL
comment "Return V1 * V2, overflow causes NIL value";

pattern *(v1:flt,v2:hge) :flt
address CMDvarMULsignal
comment "Return V1 * V2, signal error on overflow";
pattern mul_noerror(v1:flt,v2:hge) :flt
address CMDvarMUL
comment "Return V1 * V2, overflow causes NIL value";

pattern *(v1:dbl,v2:hge) :dbl
address CMDvarMULsignal
comment "Return V1 * V2, signal error on overflow";
pattern mul_noerror(v1:dbl,v2:hge) :dbl
address CMDvarMUL
comment "Return V1 * V2, overflow causes NIL value";


pattern /(v1:bte,v2:hge) :flt
address CMDvarDIVsignal
comment "Return V1 / V2, signal error on overflow";
pattern /(v1:bte,v2:hge) :dbl
address CMDvarDIVsignal
comment "Return V1 / V2, signal error on overflow";
pattern /(v1:bte,v2:hge) :bte
address CMDvarDIVsignal
comment "Return V1 / V2, signal error on overflow";
pattern div_noerror(v1:bte,v2:hge) :bte
address CMDvarDIV
comment "Return V1 / V2, overflow causes NIL value";

pattern /(v1:sht,v2:hge) :flt
address CMDvarDIVsignal
comment "Return V1 / V2, signal error on overflow";
pattern /(v1:sht,v2:hge) :dbl
address CMDvarDIVsignal
comment "Return V1 / V2, signal error on overflow";
pattern /(v1:sht,v2:hge) :sht
address CMDvarDIVsignal
comment "Return V1 / V2, signal error on overflow";
pattern div_noerror(v1:sht,v2:hge) :sht
address CMDvarDIV
comment "Return V1 / V2, overflow causes NIL value";

pattern /(v1:int,v2:hge) :flt
address CMDvarDIVsignal
comment "Return V1 / V2, signal error on overflow";
pattern /(v1:int,v2:hge) :dbl
address CMDvarDIVsignal
comment "Return V1 / V2, signal error on overflow";
pattern /(v1:int,v2:hge) :int
address CMDvarDIVsignal
comment "Return V1 / V2, signal error on overflow";
pattern div_noerror(v1:int,v2:hge) :int
address CMDvarDIV
comment "Return V1 / V2, overflow causes NIL value";

pattern /(v1:lng,v2:hge) :flt
address CMDvarDIVsignal
comment "Return V1 / V2, signal error on overflow";
pattern /(v1:lng,v2:hge) :dbl
address CMDvarDIVsignal
comment "Return V1 / V2, signal error on overflow";
pattern /(v1:lng,v2:hge) :lng
address CMDvarDIVsignal
comment "Return V1 / V2, signal error on overflow";
pattern div_noerror(v1:lng,v2:hge) :lng
address CMDvarDIV
comment "Return V1 / V2, overflow causes NIL value";

pattern /(v1:hge,v2:bte) :flt
address CMDvarDIVsignal
comment "Return V1 / V2, signal error on overflow";
pattern /(v1:hge,v2:bte) :dbl
address CMDvarDIVsignal
comment "Return V1 / V2, signal error on overflow";
pattern /(v1:hge,v2:bte) :hge
address CMDvarDIVsignal
comment "Return V1 / V2, signal error on overflow";
pattern div_noerror(v1:hge,v2:bte) :hge
address CMDvarDIV
comment "Return V1 / V2, overflow causes NIL value";

pattern /(v1:hge,v2:sht) :flt
address CMDvarDIVsignal
comment "Return V1 / V2, signal error on overflow";
pattern /(v1:hge,v2:sht) :dbl
address CMDvarDIVsignal
comment "Return V1 / V2, signal error on overflow";
pattern /(v1:hge,v2:sht) :hge
address CMDvarDIVsignal
comment "Return V1 / V2, signal error on overflow";
pattern div_noerror(v1:hge,v2:sht) :hge
address CMDvarDIV
comment "Return V1 / V2, overflow causes NIL value";

pattern /(v1:hge,v2:int) :flt
address CMDvarDIVsignal
comment "Return V1 / V2, signal error on overflow";
pattern /(v1:hge,v2:int) :dbl
address CMDvarDIVsignal
comment "Return V1 / V2, signal error on overflow";
pattern /(v1:hge,v2:int) :hge
address CMDvarDIVsignal
comment "Return V1 / V2, signal error on overflow";
pattern div_noerror(v1:hge,v2:int) :hge
address CMDvarDIV
comment "Return V1 / V2, overflow causes NIL value";

pattern /(v1:hge,v2:lng) :flt
address CMDvarDIVsignal
comment "Return V1 / V2, signal error on overflow";
pattern /(v1:hge,v2:lng) :dbl
address CMDvarDIVsignal
comment "Return V1 / V2, signal error on overflow";
pattern /(v1:hge,v2:lng) :hge
address CMDvarDIVsignal
comment "Return V1 / V2, signal error on overflow";
pattern div_noerror(v1:hge,v2:lng) :hge
address CMDvarDIV
comment "Return V1 / V2, overflow causes NIL value";

pattern /(v1:hge,v2:hge) :flt
address CMDvarDIVsignal
comment "Return V1 / V2, signal error on overflow";
pattern /(v1:hge,v2:hge) :dbl
address CMDvarDIVsignal
comment "Return V1 / V2, signal error on overflow";
pattern /(v1:hge,v2:hge) :hge
address CMDvarDIVsignal
comment "Return V1 / V2, signal error on overflow";
pattern div_noerror(v1:hge,v2:hge) :hge
address CMDvarDIV
comment "Return V1 / V2, overflow causes NIL value";

pattern /(v1:hge,v2:flt) :dbl
address CMDvarDIVsignal
comment "Return V1 / V2, signal error on overflow";
pattern /(v1:hge,v2:flt) :flt
address CMDvarDIVsignal
comment "Return V1 / V2, signal error on overflow";
pattern div_noerror(v1:hge,v2:flt) :flt
address CMDvarDIV
comment "Return V1 / V2, overflow causes NIL value";

pattern /(v1:hge,v2:dbl) :dbl
address CMDvarDIVsignal
comment "Return V1 / V2, signal error on overflow";
pattern div_noerror(v1:hge,v2:dbl) :dbl
address CMDvarDIV
comment "Return V1 / V2, overflow causes NIL value";

pattern /(v1:flt,v2:hge) :dbl
address CMDvarDIVsignal
comment "Return V1 / V2, signal error on overflow";
pattern /(v1:flt,v2:hge) :flt
address CMDvarDIVsignal
comment "Return V1 / V2, signal error on overflow";
pattern div_noerror(v1:flt,v2:hge) :flt
address CMDvarDIV
comment "Return V1 / V2, overflow causes NIL value";

pattern /(v1:dbl,v2:hge) :dbl
address CMDvarDIVsignal
comment "Return V1 / V2, signal error on overflow";
pattern div_noerror(v1:dbl,v2:hge) :dbl
address CMDvarDIV
comment "Return V1 / V2, overflow causes NIL value";


pattern %(v1:bte,v2:hge) :bte
address CMDvarMODsignal
comment "Return V1 % V2, signal error on divide by zero";
pattern mod_noerror(v1:bte,v2:hge) :bte
address CMDvarMOD
comment "Return V1 % V2, divide by zero causes NIL value";

pattern %(v1:sht,v2:hge) :sht
address CMDvarMODsignal
comment "Return V1 % V2, signal error on divide by zero";
pattern mod_noerror(v1:sht,v2:hge) :sht
address CMDvarMOD
comment "Return V1 % V2, divide by zero causes NIL value";

pattern %(v1:int,v2:hge) :int
address CMDvarMODsignal
comment "Return V1 % V2, signal error on divide by zero";
pattern mod_noerror(v1:int,v2:hge) :int
address CMDvarMOD
comment "Return V1 % V2, divide by zero causes NIL value";

pattern %(v1:lng,v2:hge) :lng
address CMDvarMODsignal
comment "Return V1 % V2, signal error on divide by zero";
pattern mod_noerror(v1:lng,v2:hge) :lng
address CMDvarMOD
comment "Return V1 % V2, divide by zero causes NIL value";

pattern %(v1:hge,v2:bte) :bte
address CMDvarMODsignal
comment "Return V1 % V2, signal error on divide by zero";
pattern mod_noerror(v1:hge,v2:bte) :bte
address CMDvarMOD
comment "Return V1 % V2, divide by zero causes NIL value";

pattern %(v1:hge,v2:sht) :sht
address CMDvarMODsignal
comment "Return V1 % V2, signal error on divide by zero";
pattern mod_noerror(v1:hge,v2:sht) :sht
address CMDvarMOD
comment "Return V1 % V2, divide by zero causes NIL value";

pattern %(v1:hge,v2:int) :int
address CMDvarMODsignal
comment "Return V1 % V2, signal error on divide by zero";
pattern mod_noerror(v1:hge,v2:int) :int
address CMDvarMOD
comment "Return V1 % V2, divide by zero causes NIL value";

pattern %(v1:hge,v2:lng) :lng
address CMDvarMODsignal
comment "Return V1 % V2, signal error on divide by zero";
pattern mod_noerror(v1:hge,v2:lng) :lng
address CMDvarMOD
comment "Return V1 % V2, divide by zero causes NIL value";

pattern %(v1:hge,v2:hge) :hge
address CMDvarMODsignal
comment "Return V1 % V2, signal error on divide by zero";
pattern mod_noerror(v1:hge,v2:hge) :hge
address CMDvarMOD
comment "Return V1 % V2, divide by zero causes NIL value";

pattern %(v1:hge,v2:flt) :flt
address CMDvarMODsignal
comment "Return V1 % V2, signal error on divide by zero";
pattern mod_noerror(v1:hge,v2:flt) :flt
address CMDvarMOD
comment "Return V1 % V2, divide by zero causes NIL value";

pattern %(v1:hge,v2:dbl) :dbl
address CMDvarMODsignal
comment "Return V1 % V2, signal error on divide by zero";
pattern mod_noerror(v1:hge,v2:dbl) :dbl
address CMDvarMOD
comment "Return V1 % V2, divide by zero causes NIL value";

pattern %(v1:flt,v2:hge) :flt
address CMDvarMODsignal
comment "Return V1 % V2, signal error on divide by zero";
pattern mod_noerror(v1:flt,v2:hge) :flt
address CMDvarMOD
comment "Return V1 % V2, divide by zero causes NIL value";

pattern %(v1:dbl,v2:hge) :dbl
address CMDvarMODsignal
comment "Return V1 % V2, signal error on divide by zero";
pattern mod_noerror(v1:dbl,v2:hge) :dbl
address CMDvarMOD
comment "Return V1 % V2, divide by zero causes NIL value";


pattern and(v1:hge,v2:hge) :hge
address CMDvarAND
comment "Return V1 AND V2";


pattern or(v1:hge,v2:hge) :hge
address CMDvarOR
comment "Return V1 OR V2";


pattern xor(v1:hge,v2:hge) :hge
address CMDvarXOR
comment "Return V1 XOR V2";


pattern <<(v1:bte,v2:hge) :bte
address CMDvarLSHsignal
comment "Return V1 << V2, raise error on out of range second operand";
pattern lsh_noerror(v1:bte,v2:hge) :bte
address CMDvarLSH
comment "Return V1 << V2, out of range second operand causes NIL value";

pattern <<(v1:sht,v2:hge) :sht
address CMDvarLSHsignal
comment "Return V1 << V2, raise error on out of range second operand";
pattern lsh_noerror(v1:sht,v2:hge) :sht
address CMDvarLSH
comment "Return V1 << V2, out of range second operand causes NIL value";

pattern <<(v1:int,v2:hge) :int
address CMDvarLSHsignal
comment "Return V1 << V2, raise error on out of range second operand";
pattern lsh_noerror(v1:int,v2:hge) :int
address CMDvarLSH
comment "Return V1 << V2, out of range second operand causes NIL value";

pattern <<(v1:lng,v2:hge) :lng
address CMDvarLSHsignal
comment "Return V1 << V2, raise error on out of range second operand";
pattern lsh_noerror(v1:lng,v2:hge) :lng
address CMDvarLSH
comment "Return V1 << V2, out of range second operand causes NIL value";

pattern <<(v1:hge,v2:bte) :hge
address CMDvarLSHsignal
comment "Return V1 << V2, raise error on out of range second operand";
pattern lsh_noerror(v1:hge,v2:bte) :hge
address CMDvarLSH
comment "Return V1 << V2, out of range second operand causes NIL value";

pattern <<(v1:hge,v2:sht) :hge
address CMDvarLSHsignal
comment "Return V1 << V2, raise error on out of range second operand";
pattern lsh_noerror(v1:hge,v2:sht) :hge
address CMDvarLSH
comment "Return V1 << V2, out of range second operand causes NIL value";

pattern <<(v1:hge,v2:int) :hge
address CMDvarLSHsignal
comment "Return V1 << V2, raise error on out of range second operand";
pattern lsh_noerror(v1:hge,v2:int) :hge
address CMDvarLSH
comment "Return V1 << V2, out of range second operand causes NIL value";

pattern <<(v1:hge,v2:lng) :hge
address CMDvarLSHsignal
comment "Return V1 << V2, raise error on out of range second operand";
pattern lsh_noerror(v1:hge,v2:lng) :hge
address CMDvarLSH
comment "Return V1 << V2, out of range second operand causes NIL value";

pattern <<(v1:hge,v2:hge) :hge
address CMDvarLSHsignal
comment "Return V1 << V2, raise error on out of range second operand";
pattern lsh_noerror(v1:hge,v2:hge) :hge
address CMDvarLSH
comment "Return V1 << V2, out of range second operand causes NIL value";


pattern >>(v1:bte,v2:hge) :bte
address CMDvarRSHsignal
comment "Return V1 >> V2, raise error on out of range second operand";
pattern rsh_noerror(v1:bte,v2:hge) :bte
address CMDvarRSH
comment "Return V1 >> V2, out of range second operand causes NIL value";

pattern >>(v1:sht,v2:hge) :sht
address CMDvarRSHsignal
comment "Return V1 >> V2, raise error on out of range second operand";
pattern rsh_noerror(v1:sht,v2:hge) :sht
address CMDvarRSH
comment "Return V1 >> V2, out of range second operand causes NIL value";

pattern >>(v1:int,v2:hge) :int
address CMDvarRSHsignal
comment "Return V1 >> V2, raise error on out of range second operand";
pattern rsh_noerror(v1:int,v2:hge) :int
address CMDvarRSH
comment "Return V1 >> V2, out of range second operand causes NIL value";

pattern >>(v1:lng,v2:hge) :lng
address CMDvarRSHsignal
comment "Return V1 >> V2, raise error on out of range second operand";
pattern rsh_noerror(v1:lng,v2:hge) :lng
address CMDvarRSH
comment "Return V1 >> V2, out of range second operand causes NIL value";

pattern >>(v1:hge,v2:bte) :hge
address CMDvarRSHsignal
comment "Return V1 >> V2, raise error on out of range second operand";
pattern rsh_noerror(v1:hge,v2:bte) :hge
address CMDvarRSH
comment "Return V1 >> V2, out of range second operand causes NIL value";

pattern >>(v1:hge,v2:sht) :hge
address CMDvarRSHsignal
comment "Return V1 >> V2, raise error on out of range second operand";
pattern rsh_noerror(v1:hge,v2:sht) :hge
address CMDvarRSH
comment "Return V1 >> V2, out of range second operand causes NIL value";

pattern >>(v1:hge,v2:int) :hge
address CMDvarRSHsignal
comment "Return V1 >> V2, raise error on out of range second operand";
pattern rsh_noerror(v1:hge,v2:int) :hge
address CMDvarRSH
comment "Return V1 >> V2, out of range second operand causes NIL value";

pattern >>(v1:hge,v2:lng) :hge
address CMDvarRSHsignal
comment "Return V1 >> V2, raise error on out of range second operand";
pattern rsh_noerror(v1:hge,v2:lng) :hge
address CMDvarRSH
comment "Return V1 >> V2, out of range second operand causes NIL value";

pattern >>(v1:hge,v2:hge) :hge
address CMDvarRSHsignal
comment "Return V1 >> V2, raise error on out of range second operand";
pattern rsh_noerror(v1:hge,v2:hge) :hge
address CMDvarRSH
comment "Return V1 >> V2, out of range second operand causes NIL value";


pattern <(v1:bte,v2:hge) :bit
address CMDvarLT
comment "Return V1 < V2";

pattern <(v1:sht,v2:hge) :bit
address CMDvarLT
comment "Return V1 < V2";

pattern <(v1:int,v2:hge) :bit
address CMDvarLT
comment "Return V1 < V2";

pattern <(v1:lng,v2:hge) :bit
address CMDvarLT
comment "Return V1 < V2";

pattern <(v1:hge,v2:bte) :bit
address CMDvarLT
comment "Return V1 < V2";

pattern <(v1:hge,v2:sht) :bit
address CMDvarLT
comment "Return V1 < V2";

pattern <(v1:hge,v2:int) :bit
address CMDvarLT
comment "Return V1 < V2";

pattern <(v1:hge,v2:lng) :bit
address CMDvarLT
comment "Return V1 < V2";

pattern <(v1:hge,v2:hge) :bit
address CMDvarLT
comment "Return V1 < V2";

pattern <(v1:hge,v2:flt) :bit
address CMDvarLT
comment "Return V1 < V2";

pattern <(v1:hge,v2:dbl) :bit
address CMDvarLT
comment "Return V1 < V2";

pattern <(v1:flt,v2:hge) :bit
address CMDvarLT
comment "Return V1 < V2";

pattern <(v1:dbl,v2:hge) :bit
address CMDvarLT
comment "Return V1 < V2";


pattern <=(v1:bte,v2:hge) :bit
address CMDvarLE
comment "Return V1 <= V2";

pattern <=(v1:sht,v2:hge) :bit
address CMDvarLE
comment "Return V1 <= V2";

pattern <=(v1:int,v2:hge) :bit
address CMDvarLE
comment "Return V1 <= V2";

pattern <=(v1:lng,v2:hge) :bit
address CMDvarLE
comment "Return V1 <= V2";

pattern <=(v1:hge,v2:bte) :bit
address CMDvarLE
comment "Return V1 <= V2";

pattern <=(v1:hge,v2:sht) :bit
address CMDvarLE
comment "Return V1 <= V2";

pattern <=(v1:hge,v2:int) :bit
address CMDvarLE
comment "Return V1 <= V2";

pattern <=(v1:hge,v2:lng) :bit
address CMDvarLE
comment "Return V1 <= V2";

pattern <=(v1:hge,v2:hge) :bit
address CMDvarLE
comment "Return V1 <= V2";

pattern <=(v1:hge,v2:flt) :bit
address CMDvarLE
comment "Return V1 <= V2";

pattern <=(v1:hge,v2:dbl) :bit
address CMDvarLE
comment "Return V1 <= V2";

pattern <=(v1:flt,v2:hge) :bit
address CMDvarLE
comment "Return V1 <= V2";

pattern <=(v1:dbl,v2:hge) :bit
address CMDvarLE
comment "Return V1 <= V2";


pattern >(v1:bte,v2:hge) :bit
address CMDvarGT
comment "Return V1 > V2";

pattern >(v1:sht,v2:hge) :bit
address CMDvarGT
comment "Return V1 > V2";

pattern >(v1:int,v2:hge) :bit
address CMDvarGT
comment "Return V1 > V2";

pattern >(v1:lng,v2:hge) :bit
address CMDvarGT
comment "Return V1 > V2";

pattern >(v1:hge,v2:bte) :bit
address CMDvarGT
comment "Return V1 > V2";

pattern >(v1:hge,v2:sht) :bit
address CMDvarGT
comment "Return V1 > V2";

pattern >(v1:hge,v2:int) :bit
address CMDvarGT
comment "Return V1 > V2";

pattern >(v1:hge,v2:lng) :bit
address CMDvarGT
comment "Return V1 > V2";

pattern >(v1:hge,v2:hge) :bit
address CMDvarGT
comment "Return V1 > V2";

pattern >(v1:hge,v2:flt) :bit
address CMDvarGT
comment "Return V1 > V2";

pattern >(v1:hge,v2:dbl) :bit
address CMDvarGT
comment "Return V1 > V2";

pattern >(v1:flt,v2:hge) :bit
address CMDvarGT
comment "Return V1 > V2";

pattern >(v1:dbl,v2:hge) :bit
address CMDvarGT
comment "Return V1 > V2";


pattern >=(v1:bte,v2:hge) :bit
address CMDvarGE
comment "Return V1 >= V2";

pattern >=(v1:sht,v2:hge) :bit
address CMDvarGE
comment "Return V1 >= V2";

pattern >=(v1:int,v2:hge) :bit
address CMDvarGE
comment "Return V1 >= V2";

pattern >=(v1:lng,v2:hge) :bit
address CMDvarGE
comment "Return V1 >= V2";

pattern >=(v1:hge,v2:bte) :bit
address CMDvarGE
comment "Return V1 >= V2";

pattern >=(v1:hge,v2:sht) :bit
address CMDvarGE
comment "Return V1 >= V2";

pattern >=(v1:hge,v2:int) :bit
address CMDvarGE
comment "Return V1 >= V2";

pattern >=(v1:hge,v2:lng) :bit
address CMDvarGE
comment "Return V1 >= V2";

pattern >=(v1:hge,v2:hge) :bit
address CMDvarGE
comment "Return V1 >= V2";

pattern >=(v1:hge,v2:flt) :bit
address CMDvarGE
comment "Return V1 >= V2";

pattern >=(v1:hge,v2:dbl) :bit
address CMDvarGE
comment "Return V1 >= V2";

pattern >=(v1:flt,v2:hge) :bit
address CMDvarGE
comment "Return V1 >= V2";

pattern >=(v1:dbl,v2:hge) :bit
address CMDvarGE
comment "Return V1 >= V2";


pattern ==(v1:bte,v2:hge) :bit
address CMDvarEQ
comment "Return V1 == V2";

pattern ==(v1:sht,v2:hge) :bit
address CMDvarEQ
comment "Return V1 == V2";

pattern ==(v1:int,v2:hge) :bit
address CMDvarEQ
comment "Return V1 == V2";

pattern ==(v1:lng,v2:hge) :bit
address CMDvarEQ
comment "Return V1 == V2";

pattern ==(v1:hge,v2:bte) :bit
address CMDvarEQ
comment "Return V1 == V2";

pattern ==(v1:hge,v2:sht) :bit
address CMDvarEQ
comment "Return V1 == V2";

pattern ==(v1:hge,v2:int) :bit
address CMDvarEQ
comment "Return V1 == V2";

pattern ==(v1:hge,v2:lng) :bit
address CMDvarEQ
comment "Return V1 == V2";

pattern ==(v1:hge,v2:hge) :bit
address CMDvarEQ
comment "Return V1 == V2";

pattern ==(v1:hge,v2:flt) :bit
address CMDvarEQ
comment "Return V1 == V2";

pattern ==(v1:hge,v2:dbl) :bit
address CMDvarEQ
comment "Return V1 == V2";

pattern ==(v1:flt,v2:hge) :bit
address CMDvarEQ
comment "Return V1 == V2";

pattern ==(v1:dbl,v2:hge) :bit
address CMDvarEQ
comment "Return V1 == V2";


pattern !=(v1:bte,v2:hge) :bit
address CMDvarNE
comment "Return V1 != V2";

pattern !=(v1:sht,v2:hge) :bit
address CMDvarNE
comment "Return V1 != V2";

pattern !=(v1:int,v2:hge) :bit
address CMDvarNE
comment "Return V1 != V2";

pattern !=(v1:lng,v2:hge) :bit
address CMDvarNE
comment "Return V1 != V2";

pattern !=(v1:hge,v2:bte) :bit
address CMDvarNE
comment "Return V1 != V2";

pattern !=(v1:hge,v2:sht) :bit
address CMDvarNE
comment "Return V1 != V2";

pattern !=(v1:hge,v2:int) :bit
address CMDvarNE
comment "Return V1 != V2";

pattern !=(v1:hge,v2:lng) :bit
address CMDvarNE
comment "Return V1 != V2";

pattern !=(v1:hge,v2:hge) :bit
address CMDvarNE
comment "Return V1 != V2";

pattern !=(v1:hge,v2:flt) :bit
address CMDvarNE
comment "Return V1 != V2";

pattern !=(v1:hge,v2:dbl) :bit
address CMDvarNE
comment "Return V1 != V2";

pattern !=(v1:flt,v2:hge) :bit
address CMDvarNE
comment "Return V1 != V2";

pattern !=(v1:dbl,v2:hge) :bit
address CMDvarNE
comment "Return V1 != V2";


pattern cmp(v1:bte,v2:hge) :bte
address CMDvarCMP
comment "Return -1/0/1 if V1 </==/> V2";

pattern cmp(v1:sht,v2:hge) :bte
address CMDvarCMP
comment "Return -1/0/1 if V1 </==/> V2";

pattern cmp(v1:int,v2:hge) :bte
address CMDvarCMP
comment "Return -1/0/1 if V1 </==/> V2";

pattern cmp(v1:lng,v2:hge) :bte
address CMDvarCMP
comment "Return -1/0/1 if V1 </==/> V2";

pattern cmp(v1:hge,v2:bte) :bte
address CMDvarCMP
comment "Return -1/0/1 if V1 </==/> V2";

pattern cmp(v1:hge,v2:sht) :bte
address CMDvarCMP
comment "Return -1/0/1 if V1 </==/> V2";

pattern cmp(v1:hge,v2:int) :bte
address CMDvarCMP
comment "Return -1/0/1 if V1 </==/> V2";

pattern cmp(v1:hge,v2:lng) :bte
address CMDvarCMP
comment "Return -1/0/1 if V1 </==/> V2";

pattern cmp(v1:hge,v2:hge) :bte
address CMDvarCMP
comment "Return -1/0/1 if V1 </==/> V2";

pattern cmp(v1:hge,v2:flt) :bte
address CMDvarCMP
comment "Return -1/0/1 if V1 </==/> V2";

pattern cmp(v1:hge,v2:dbl) :bte
address CMDvarCMP
comment "Return -1/0/1 if V1 </==/> V2";

pattern cmp(v1:flt,v2:hge) :bte
address CMDvarCMP
comment "Return -1/0/1 if V1 </==/> V2";

pattern cmp(v1:dbl,v2:hge) :bte
address CMDvarCMP
comment "Return -1/0/1 if V1 </==/> V2";


pattern void(v:hge) :void
address CMDvarCONVERT
comment "Cast VALUE to void";


pattern bit(v:hge) :bit
address CMDvarCONVERT
comment "Cast VALUE to bit";


pattern bte(v:hge) :bte
address CMDvarCONVERT
comment "Cast VALUE to bte";


pattern sht(v:hge) :sht
address CMDvarCONVERT
comment "Cast VALUE to sht";


pattern int(v:hge) :int
address CMDvarCONVERT
comment "Cast VALUE to int";


pattern lng(v:hge) :lng
address CMDvarCONVERT
comment "Cast VALUE to lng";


pattern hge(v:void) :hge
address CMDvarCONVERT
comment "Cast VALUE to hge";

pattern hge(v:bit) :hge
address CMDvarCONVERT
comment "Cast VALUE to hge";

pattern hge(v:bte) :hge
address CMDvarCONVERT
comment "Cast VALUE to hge";

pattern hge(v:sht) :hge
address CMDvarCONVERT
comment "Cast VALUE to hge";

pattern hge(v:int) :hge
address CMDvarCONVERT
comment "Cast VALUE to hge";

pattern hge(v:lng) :hge
address CMDvarCONVERT
comment "Cast VALUE to hge";

pattern hge(v:hge) :hge
address CMDvarCONVERT
comment "Cast VALUE to hge";

pattern hge(v:flt) :hge
address CMDvarCONVERT
comment "Cast VALUE to hge";

pattern hge(v:dbl) :hge
address CMDvarCONVERT
comment "Cast VALUE to hge";

pattern hge(v:oid) :hge
address CMDvarCONVERT
comment "Cast VALUE to hge";

pattern hge(v:str) :hge
address CMDvarCONVERT
comment "Cast VALUE to hge";


pattern flt(v:hge) :flt
address CMDvarCONVERT
comment "Cast VALUE to flt";


pattern dbl(v:hge) :dbl
address CMDvarCONVERT
comment "Cast VALUE to dbl";


pattern oid(v:hge) :oid
address CMDvarCONVERT
comment "Cast VALUE to oid";


module aggr;

pattern sum(b:bat[:bte]) :hge
address CMDBATsum
comment "Calculate aggregate sum of B.";
pattern sum(b:bat[:bte],nil_if_empty:bit) :hge
address CMDBATsum
comment "Calculate aggregate sum of B.";
pattern sum(b:bat[:bte],s:bat[:oid]) :hge
address CMDBATsum
comment "Calculate aggregate sum of B with candidate list.";
pattern sum(b:bat[:bte],s:bat[:oid],nil_if_empty:bit) :hge
address CMDBATsum
comment "Calculate aggregate sum of B with candidate list.";

pattern sum(b:bat[:sht]) :hge
address CMDBATsum
comment "Calculate aggregate sum of B.";
pattern sum(b:bat[:sht],nil_if_empty:bit) :hge
address CMDBATsum
comment "Calculate aggregate sum of B.";
pattern sum(b:bat[:sht],s:bat[:oid]) :hge
address CMDBATsum
comment "Calculate aggregate sum of B with candidate list.";
pattern sum(b:bat[:sht],s:bat[:oid],nil_if_empty:bit) :hge
address CMDBATsum
comment "Calculate aggregate sum of B with candidate list.";

pattern sum(b:bat[:int]) :hge
address CMDBATsum
comment "Calculate aggregate sum of B.";
pattern sum(b:bat[:int],nil_if_empty:bit) :hge
address CMDBATsum
comment "Calculate aggregate sum of B.";
pattern sum(b:bat[:int],s:bat[:oid]) :hge
address CMDBATsum
comment "Calculate aggregate sum of B with candidate list.";
pattern sum(b:bat[:int],s:bat[:oid],nil_if_empty:bit) :hge
address CMDBATsum
comment "Calculate aggregate sum of B with candidate list.";

pattern sum(b:bat[:lng]) :hge
address CMDBATsum
comment "Calculate aggregate sum of B.";
pattern sum(b:bat[:lng],nil_if_empty:bit) :hge
address CMDBATsum
comment "Calculate aggregate sum of B.";
pattern sum(b:bat[:lng],s:bat[:oid]) :hge
address CMDBATsum
comment "Calculate aggregate sum of B with candidate list.";
pattern sum(b:bat[:lng],s:bat[:oid],nil_if_empty:bit) :hge
address CMDBATsum
comment "Calculate aggregate sum of B with candidate list.";

pattern sum(b:bat[:hge]) :hge
address CMDBATsum
comment "Calculate aggregate sum of B.";
pattern sum(b:bat[:hge],nil_if_empty:bit) :hge
address CMDBATsum
comment "Calculate aggregate sum of B.";
pattern sum(b:bat[:hge],s:bat[:oid]) :hge
address CMDBATsum
comment "Calculate aggregate sum of B with candidate list.";
pattern sum(b:bat[:hge],s:bat[:oid],nil_if_empty:bit) :hge
address CMDBATsum
comment "Calculate aggregate sum of B with candidate list.";

pattern sum(b:bat[:hge]) :dbl
address CMDBATsum
comment "Calculate aggregate sum of B.";
pattern sum(b:bat[:hge],nil_if_empty:bit) :dbl
address CMDBATsum
comment "Calculate aggregate sum of B.";
pattern sum(b:bat[:hge],s:bat[:oid]) :dbl
address CMDBATsum
comment "Calculate aggregate sum of B with candidate list.";
pattern sum(b:bat[:hge],s:bat[:oid],nil_if_empty:bit) :dbl
address CMDBATsum
comment "Calculate aggregate sum of B with candidate list.";

pattern prod(b:bat[:bte]) :hge
address CMDBATprod
comment "Calculate aggregate product of B.";
pattern prod(b:bat[:bte],nil_if_empty:bit) :hge
address CMDBATprod
comment "Calculate aggregate product of B.";
pattern prod(b:bat[:bte],s:bat[:oid]) :hge
address CMDBATprod
comment "Calculate aggregate product of B with candidate list.";
pattern prod(b:bat[:bte],s:bat[:oid],nil_if_empty:bit) :hge
address CMDBATprod
comment "Calculate aggregate product of B with candidate list.";

pattern prod(b:bat[:sht]) :hge
address CMDBATprod
comment "Calculate aggregate product of B.";
pattern prod(b:bat[:sht],nil_if_empty:bit) :hge
address CMDBATprod
comment "Calculate aggregate product of B.";
pattern prod(b:bat[:sht],s:bat[:oid]) :hge
address CMDBATprod
comment "Calculate aggregate product of B with candidate list.";
pattern prod(b:bat[:sht],s:bat[:oid],nil_if_empty:bit) :hge
address CMDBATprod
comment "Calculate aggregate product of B with candidate list.";

pattern prod(b:bat[:int]) :hge
address CMDBATprod
comment "Calculate aggregate product of B.";
pattern prod(b:bat[:int],nil_if_empty:bit) :hge
address CMDBATprod
comment "Calculate aggregate product of B.";
pattern prod(b:bat[:int],s:bat[:oid]) :hge
address CMDBATprod
comment "Calculate aggregate product of B with candidate list.";
pattern prod(b:bat[:int],s:bat[:oid],nil_if_empty:bit) :hge
address CMDBATprod
comment "Calculate aggregate product of B with candidate list.";

pattern prod(b:bat[:lng]) :hge
address CMDBATprod
comment "Calculate aggregate product of B.";
pattern prod(b:bat[:lng],nil_if_empty:bit) :hge
address CMDBATprod
comment "Calculate aggregate product of B.";
pattern prod(b:bat[:lng],s:bat[:oid]) :hge
address CMDBATprod
comment "Calculate aggregate product of B with candidate list.";
pattern prod(b:bat[:lng],s:bat[:oid],nil_if_empty:bit) :hge
address CMDBATprod
comment "Calculate aggregate product of B with candidate list.";

pattern prod(b:bat[:hge]) :hge
address CMDBATprod
comment "Calculate aggregate product of B.";
pattern prod(b:bat[:hge],nil_if_empty:bit) :hge
address CMDBATprod
comment "Calculate aggregate product of B.";
pattern prod(b:bat[:hge],s:bat[:oid]) :hge
address CMDBATprod
comment "Calculate aggregate product of B with candidate list.";
pattern prod(b:bat[:hge],s:bat[:oid],nil_if_empty:bit) :hge
address CMDBATprod
comment "Calculate aggregate product of B with candidate list.";

pattern prod(b:bat[:hge]) :dbl
address CMDBATprod
comment "Calculate aggregate product of B.";
pattern prod(b:bat[:hge],nil_if_empty:bit) :dbl
address CMDBATprod
comment "Calculate aggregate product of B.";
pattern prod(b:bat[:hge],s:bat[:oid]) :dbl
address CMDBATprod
comment "Calculate aggregate product of B with candidate list.";
pattern prod(b:bat[:hge],s:bat[:oid],nil_if_empty:bit) :dbl
address CMDBATprod
comment "Calculate aggregate product of B with candidate list.";

