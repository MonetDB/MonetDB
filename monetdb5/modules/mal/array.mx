@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2011 MonetDB B.V.
All Rights Reserved.
@

@f array
@a M.L. Kersten, Y.Zhang, M. Ivanova
@+ Basic array support

Arrays are represented by a collection of BATs.
One for each dimension and one for the non-dimension attributes. 
The structure of the dimension is captured in
a shape description, which is an ordered list of tripples
(Start,Step,Stop) where for index variable i the constraint Start<=i<Stop holds
and where the step size is Step.

In the MAL instructions the shape descriptor should be the last
of the arguments. Since every dimension can be of a different
type, we have to rely on runtime type checking. Of course,
the SciQL compiler already can ensure proper type equality
for each shape tripple.
@{

@= array_mdefs
command series_(start:@1, step:@1, stop:@1, N:int, M:int) :bat[:oid,:@1] 
address ARRAYseries_@1
comment  "Generates a single series BAT based on range condition, repeating each value N times and repeat the process M times.";

function series (start:@1, step:@1, stop:@1, N:int, M:int) :bat[:str,:bat];
	b1 := bat.new(:str,:bat,1);
	b2 := series_(start, step, stop, N, M);
	b3 := bat.insert(b1, "dim", b2);
	return series := b3;
end series;

@mal
module array;
@:array_mdefs(oid)@
@:array_mdefs(sht)@
@:array_mdefs(int)@
@:array_mdefs(lng)@
@:array_mdefs(flt)@
@:array_mdefs(dbl)@
@-
to be dealt with differently
@:array_mdefs(date)@
@:array_mdefs(daytime)@
@:array_mdefs(timestamp)@

@mal
pattern filler_(idx:bat[:oid,:any_1], v:any_2):bat[:oid,:any_2]
address ARRAYfiller_bat
comment "Create an array value representation described by a series column and fill it with V";

pattern filler_(cnt:oid, v:any_2):bat[:oid,:any_2]
address ARRAYfiller
comment "Create an array value representation of CNT items and fill it with V";

function filler(cnt:oid, v:any_2):bat[:str,:bat];
	b1 := bat.new(:str,:bat,1);
	b2 := filler_(cnt, v);
	b3 := bat.insert(b1, "vals", b2);
	return filler := b3;
end filler;

pattern map(dims:bat[:oid,:any]...):bat[:oid,:oid]
address ARRAYmap
comment "The argument is a double set of dimension columns. The first set describes the shape
of the target array and the second one holds the index values of interest. The result is a column
with the oid positions of the elements in target. ";

pattern unmap(cells:bat[:oid,:oid], dims:bat[:oid,:any]...):bat[:oid,:any]...
address ARRAYumap
comment "Extract the index columns from a shape based on the cell identifier list";

pattern isFixed(dims:bat[:oid,:any]...):bit
address ARRAYisFixed
comment "Determine fixed size property of an array";

pattern isUnbounded(dims:bat[:oid,:any]...):bit
address ARRAYisUnbounded
comment "Determine unboundedness property of an array";

pattern getDimensions(dims:bat[:oid,:any]...):int...
address ARRAYgetDimensions
comment "Extract the series sizes";

pattern replace(v1:bat[:oid, :any_1], idx:bat[:oid, :oid], v2:any_1):bat[:oid,:any_1]
address ARRAYreplaceScalar
comment "Replace values in v1 at the positions determined by idx with v2, return the modified v1.";

pattern replace(v1:bat[:oid, :any_1], idx:bat[:oid, :oid], v2:bat[:oid, :any_1]):bat[:oid,:any_1]
address ARRAYreplace
comment "Replace values in v1 at the positions determined by idx with values in v2, return the modified v1.";

pattern tiles(cells:bat[:oid,:any_1], template:bat[:oid,:oid]):bat[:oid,:oid]
address ARRAYtiles
comment "Construct the tiled cell id list using a template with relative offsets";

command product(b:bat[:any_3,:any_1],c:bat[:any_4,:any_2]):bat[:any_1,:any_2]
address ARRAYproduct
comment "Produce an array product";

pattern sum(cells:bat[:oid,:any_1], template:bat[:oid,:oid]):bat[:oid,:any_2]
address ARRAYtilesSum
comment "Construct the sum over all tiles";

pattern sum(cells:bat[:oid,:any_1], template:bat[:oid,:oid]):bat[:oid,:any_1]
address ARRAYtilesSum
comment "Construct the sum over all tiles, but take also care of the boundaries in each dimension,
which is expressed in the number of eligible cells.";

pattern embed(shapes:bat[:oid,:any]...):bat[:oid,:oid]
address ARRAYembed
comment "Take two shapes N and M and derive a mapping between the elements based on the index values.
It can be used to create an embedding of values from one array into another.";
@- Implementation
@include ../mal/prelude.mx
@h

/*============================================================================*/
#ifndef __array_h__
#define __array_h__

#include "gdk.h"
#include "algebra.h"		/* to include BATmin and BATmax */
#include "mtime.h"
#include <math.h>
#include <time.h>

#ifdef WIN32
#if !defined(LIBMAL) && !defined(LIBATOMS) && !defined(LIBKERNEL) && !defined(LIBMAL) && !defined(LIBOPTIMIZER) && !defined(LIBSCHEDULER) && !defined(LIBMONETDB5)
#define array_export extern __declspec(dllimport)
#else
#define array_export extern __declspec(dllexport)
#endif
#else
#define array_export extern
#endif

array_export str ARRAYisFixed(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
array_export str ARRAYgetDimensions(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
array_export str ARRAYproduct(int *ret, int *bid, int *rid);
array_export str ARRAYfiller_bat(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
array_export str ARRAYfiller(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
array_export str ARRAYmap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
array_export str ARRAYumap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
array_export str ARRAYreplace(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
array_export str ARRAYreplaceScalar(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
array_export str ARRAYtiles(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
array_export str ARRAYtilesSum(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
array_export str ARRAYembed(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);

@= array_defs
array_export str ARRAYseries_@1(int *ret, @1 *start, @1 *step, @1 *stop, int *grp, int *series);
array_export str ARRAYtilesSum_@1(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
@h
@:array_defs(oid)@
@:array_defs(sht)@
@:array_defs(int)@
@:array_defs(lng)@
@:array_defs(flt)@
@:array_defs(dbl)@
@-
to be dealt with differently
@:array_defs(date)@
@:array_defs(daytime)@
@:array_defs(timestamp)@

@h
/* The maximum number of series_ that the print-function can handle... */
#define MAX_ARRAY_DIM 16

#endif
/*============================================================================*/
@c
/*============================================================================*/
#include "monetdb_config.h"
#include "mal_client.h"
#include "array.h"

/*----------------------------------------------------------------------------*/

@c
#include "mal.h"
#include "mal_interpreter.h"
@= dim_wrapper_impl
str
ARRAYseries_@1(int *ret, @1 *start, @1 *step, @1 *stop, int *group, int *series)
{
	BAT *bn;
	@1 i, *o;
	BUN cnt= 0;
	int s,g;

	if ( *start < *stop && *step > 0) {
		cnt =  (BUN) ((*stop - *start) / *step) * *group * *series ;
	} else
	if ( abs(*start) < abs(*stop) && abs(*step) > 0) {
		cnt =  (BUN) ((-*stop + *start) / *step ) * *group * *series ;
	} else
		throw(MAL, "array.series", "illegal range");
	bn = BATnew(TYPE_void, TYPE_@1, cnt);
	if ( bn == NULL)
		throw(MAL, "array.series", MAL_MALLOC_FAIL);

	BATseqbase(bn,0);
	o = (@1*)Tloc(bn, BUNfirst(bn));

	if ( *start < *stop && *step > 0) {
		for ( s = 0; s < *series; s++)
			for ( i = *start; i < *stop; i += *step)
				for( g = 0; g < *group; g++){
					*o = i;
					o++;
				}
	} else {
		for ( s = 0; s < *series; s++)
			for ( i = *start; i > *stop; i += *step)
				for( g = 0; g < *group; g++){
					*o = i;
					o++;
				}
	}
	BATsetcount(bn, cnt);
	bn->tsorted = *series == 1;
	bn->T->nonil = TRUE;

	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); \
	*ret = bn->batCacheid;
	BBPkeepref((int)*ret);
	return MAL_SUCCEED;
}

@c
@:dim_wrapper_impl(oid)@
@:dim_wrapper_impl(sht)@
@:dim_wrapper_impl(int)@
@:dim_wrapper_impl(lng)@
@:dim_wrapper_impl(flt)@
@:dim_wrapper_impl(dbl)@
@-
to be dealt with differently
@:dim_wrapper_impl(date)@
@:dim_wrapper_impl(daytime)@
@:dim_wrapper_impl(timestamp)@

@-
@= arraymultiply
array_export str ARRAYmultiply_@1_@2(int *ret, int *bid, int *rid);
str
ARRAYmultiply_@1_@2(int *ret, int *bid, int *rid){
	BAT *bn, *b, *r;
	BUN p,q, s,t;
	@2 val;
	oid o= oid_nil;
	BATiter bi, ri;

	if( (b= BATdescriptor(*bid)) == NULL ){
		 throw(MAL, "array.*", RUNTIME_OBJECT_MISSING);
	}
	if( (r= BATdescriptor(*rid)) == NULL ){
		BBPreleaseref(b->batCacheid);
		 throw(MAL, "array.*", RUNTIME_OBJECT_MISSING);
	}
	bn= BATnew(TYPE_void, TYPE_@2, BATcount(b)*BATcount(r));
	BATseqbase(bn,0);

	bi = bat_iterator(b);
	ri = bat_iterator(r);
	BATloop(b,p,q){
		BATloop(r,s,t){
			val = (*(@1*) BUNtail(bi,p)) * (*(@1*)BUNtail(ri,s));
			BUNfastins(bn,&o,&val);
		}
	}
	bn->T->nonil = b->T->nonil & r->T->nonil;
	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); \
	*ret= bn->batCacheid;
	BBPkeepref(*ret);
	BBPreleaseref(b->batCacheid);
	BBPreleaseref(r->batCacheid);
	return MAL_SUCCEED;
}
@c
@:arraymultiply(sht,lng)@
@:arraymultiply(sht,int)@
@:arraymultiply(int,int)@
@:arraymultiply(int,lng)@
@:arraymultiply(lng,lng)@
@:arraymultiply(flt,flt)@
@:arraymultiply(dbl,dbl)@

str
ARRAYproduct(int *ret, int *bid, int *rid)
{
	BAT *bn, *b, *r;
	BUN p, q, s, t;
	BATiter bi, ri;

	if ((b = BATdescriptor(*bid)) == NULL) 
		throw(MAL, "array.product", RUNTIME_OBJECT_MISSING);
	
	if ((r = BATdescriptor(*rid)) == NULL) {
		BBPreleaseref(b->batCacheid);
		throw(MAL, "array.product", RUNTIME_OBJECT_MISSING);
	}
	if (BATcount(b) > BATcount(r) || (BATcount(b) % BATcount(r)) != BATcount(b)) {
		BBPreleaseref(b->batCacheid);
		BBPreleaseref(r->batCacheid);
		throw(MAL, "array.product", "Illegal argument bounds");
	}
	bn = BATnew(b->ttype, r->ttype, BATcount(r));

	bi = bat_iterator(b);
	ri = bat_iterator(r);
	BATloop(r, s, t) {
		BATloop(b, p, q) {
			BUNfastins(bn, BUNtail(bi, p), BUNtail(ri, s));
			s++;
		}
		s--;
	}
	/* not sorted at best we have some fixed offset partial sorting */
	bn->hsorted = 0;
	bn->tsorted = 0;
	bn->T->nonil = b->T->nonil & r->T->nonil;
	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); \
	*ret = bn->batCacheid;
	BBPkeepref(*ret);
	BBPreleaseref(b->batCacheid);
	BBPreleaseref(r->batCacheid);
	return MAL_SUCCEED;
}

str
ARRAYfiller_bat(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	BAT *bn, *b;
	BUN p, q;
	BATiter bi;
	int *ret = (int*) getArgReference(stk,pci,0);
	int bid = *(int*) getArgReference(stk,pci,1);
	void *val = (void*) getArgReference(stk,pci,2);

	if ((b = BATdescriptor(bid)) == NULL) 
		throw(MAL, "array.filler", RUNTIME_OBJECT_MISSING);
	
	bn = BATnew(b->htype, getArgType(mb,pci,2), BATcount(b));
	BATseqbase(bn,0);

	bi = bat_iterator(b);
	BATloop(b,p,q){
		BUNfastins(bn, BUNhead(bi, p), val);
	}
	(void) cntxt;
	BBPkeepref(*ret = bn->batCacheid);
	return MAL_SUCCEED;
}

str
ARRAYfiller(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	BAT *bn;
	BATiter bi;
	int *ret = (int*) getArgReference(stk,pci,0);
	oid i = 0, cnt = *(oid*) getArgReference(stk,pci,1);
	void *val = (void*) getArgReference(stk,pci,2);

	(void) cntxt;

	/* TODO: why not TYPE_void? */
	if(!(bn = BATnew(TYPE_oid, getArgType(mb,pci,2), cnt)))
		throw(MAL, "array.filler", MAL_MALLOC_FAIL);

	bi = bat_iterator(bn);
	for (i = 0; i < cnt; i++)
		BUNfastins(bn, BUNhead(bi, i), val);

	BATsetcount(bn, cnt);
	bn->tsorted = 1;
	bn->T->nonil = TRUE;
	BBPkeepref(*ret = bn->batCacheid);
	return MAL_SUCCEED;
}

str
ARRAYmap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	BAT **b, *bn = NULL, *bo;
	int i,n = 0, error = 0;

	(void) cntxt;
	(void) mb;
	if ( (pci->argc - pci->retc) % 2 != 0)
		throw(MAL, "array.map", "Unbalanced index arguments");

	b= (BAT**) GDKzalloc(sizeof(BAT*) * pci->argc-pci->retc);
	if( b == NULL)
		throw(MAL, "array.map", MAL_MALLOC_FAIL);

	for ( i=pci->retc; i< pci->argc; i++){
		if ((b[n++] = BATdescriptor(*(int*)getArgReference(stk,pci,i))) == NULL) {
			for ( n--; n>= 0; n--)
				BBPreleaseref(b[n]->batCacheid);
			GDKfree(b);
			throw(MAL, "array.map", RUNTIME_OBJECT_MISSING);
		}
	}
	/* type check the shapes and prepare iterators */
	for ( i= 0; i< n/2; i++) 
		error |= b[i]->ttype != b[i+n/2]->ttype;

	if ( error ){
		for ( n--; n>= 0; n--)
			BBPreleaseref(b[n]->batCacheid);
		GDKfree(b);
		throw(MAL, "array.map", "Incompatible index types");
	}

	/* select the oids we need by searching all matching index vectors */
	bn = b[0];
	for ( i=0; i<n/2; i++){
		bo = BATsemijoin(b[i],bn);
		bn= BATmirror(BATsemijoin(BATmirror(bo), BATmirror(b[i+n/2])));
		BBPreleaseref(bo->batCacheid);
	}
	bn = BATmark(bn,0);

	*(int*) getArgReference(stk,pci,0) = bn->batCacheid;
	BBPkeepref(bn->batCacheid);
	for ( n--; n>= 0; n--)
		BBPreleaseref(b[n]->batCacheid);
	GDKfree(b);
	return MAL_SUCCEED;
}

str
ARRAYumap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	BAT *b, *bn, *bo;
	int i;

	(void) cntxt;
	(void) mb;
	if ( (pci->argc -1 - pci->retc) != pci->retc)
		throw(MAL, "array.unmap", "Unbalanced index arguments and return list");
	if ((b = BATdescriptor(*(int*)getArgReference(stk,pci,pci->retc))) == NULL) 
		throw(MAL, "array.unmap", RUNTIME_OBJECT_MISSING);
	
	for ( i=pci->retc+1; i<pci->argc; i++){
		bo = BATdescriptor(*(int*)getArgReference(stk,pci,i));
		if ( bo == NULL){
			BBPreleaseref(b->batCacheid);
			throw(MAL, "array.unmap", RUNTIME_OBJECT_MISSING);
		}
		bn = BATsemijoin( bo,b);
		if ( bn ) {
			*(int*) getArgReference(stk,pci,i-pci->retc -1 ) = bn->batCacheid;
			BBPkeepref(bn->batCacheid);
		}
			BBPkeepref(bo->batCacheid);
	}
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}

str
ARRAYisFixed(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	(void) cntxt;
	(void) mb;
	(void) stk;
	(void) p;
	throw(MAL,"array.isFixed", PROGRAM_NYI);
}

str
ARRAYisUnbounded(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	(void) cntxt;
	(void) mb;
	(void) stk;
	(void) p;
	throw(MAL,"array.isUnbounded", PROGRAM_NYI);
}

str
ARRAYgetDimensions(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	(void) cntxt;
	(void) mb;
	(void) stk;
	(void) p;
	throw(MAL,"array.getDimensions", PROGRAM_NYI);
}

str
ARRAYreplace(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	BAT *b, *bo, *bc, *bv,*bn;
	int *ret = (int*) getArgReference(stk,pci,0);

	(void) cntxt;
	(void) mb;
	if ((b = BATdescriptor(*(int*)getArgReference(stk,pci,1))) == NULL) 
		throw(MAL, "array.replace", RUNTIME_OBJECT_MISSING);
	if ((bc = BATdescriptor(*(int*)getArgReference(stk,pci,2))) == NULL) {
		BBPreleaseref(b->batCacheid);
		throw(MAL, "array.replace", RUNTIME_OBJECT_MISSING);
	}
	if ((bv = BATdescriptor(*(int*)getArgReference(stk,pci,3))) == NULL) {
		BBPreleaseref(b->batCacheid);
		BBPreleaseref(bc->batCacheid);
		throw(MAL, "array.replace", RUNTIME_OBJECT_MISSING);
	}
	if ( BATcount(bc) != BATcount(bv)){
		BBPreleaseref(b->batCacheid);
		BBPreleaseref(bc->batCacheid);
		BBPreleaseref(bv->batCacheid);
		throw(MAL, "array.replace", "unbalanced array arguments");
	}
	bn = BATcopy(b, b->htype, b->ttype, TRUE);
	bo = BATjoin(bc,bv,0);
	if ( bo )
		bn = BATreplace(bn,bo, TRUE);
	if ( bn == NULL || bo == NULL){
		BBPreleaseref(b->batCacheid);
		BBPreleaseref(bc->batCacheid);
		BBPreleaseref(bv->batCacheid);
		if ( bo == NULL) BBPreleaseref(bo->batCacheid);
		throw(MAL, "array.replace", RUNTIME_OBJECT_MISSING);
	}
	BBPkeepref(*ret = bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	BBPreleaseref(bc->batCacheid);
	BBPreleaseref(bv->batCacheid);
	BBPreleaseref(bo->batCacheid);
	return MAL_SUCCEED;
}

str
ARRAYreplaceScalar(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	BAT *b, *bc, *bn, *bo;
	int *ret = (int*) getArgReference(stk,pci,0);
	void *val = (void*) getArgReference(stk,pci,3);
	BATiter bi;
	BUN p,q;

	(void) cntxt;
	(void) mb;
	if ((b = BATdescriptor(*(int*)getArgReference(stk,pci,1))) == NULL) 
		throw(MAL, "array.replace", RUNTIME_OBJECT_MISSING);
	if ((bc = BATdescriptor(*(int*)getArgReference(stk,pci,2))) == NULL) {
		BBPreleaseref(b->batCacheid);
		throw(MAL, "array.replace", RUNTIME_OBJECT_MISSING);
	}
	bo = BATnew(bc->ttype, b->ttype, TRUE);
	bi = bat_iterator(bc);
	BATloop(bc,p,q){
		oid o = *(oid*) BUNhead(bi,p);
		BUNins(bo, &o, val, TRUE);
	}
	bn=  BATreplace(b,bo,TRUE);
	BBPreleaseref(bo->batCacheid);
	if ( bn == NULL ){
		BBPreleaseref(b->batCacheid);
		BBPreleaseref(bc->batCacheid);
		throw(MAL, "array.replace", RUNTIME_OBJECT_MISSING);
	}
	BBPkeepref(*ret = bn->batCacheid);
	BBPreleaseref(bc->batCacheid);
	return MAL_SUCCEED;
}

str
ARRAYtiles(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	BAT *b, *bt, *bn;
	int *ret = (int*) getArgReference(stk,pci,0);
	BATiter bi, br;
	BUN p,q;
	BUN r,s;
	oid g = 0, limit;

	(void) cntxt;
	(void) mb;
	if ((b = BATdescriptor(*(int*)getArgReference(stk,pci,1))) == NULL) 
		throw(MAL, "array.tiles", RUNTIME_OBJECT_MISSING);
	if ((bt = BATdescriptor(*(int*)getArgReference(stk,pci,2))) == NULL) {
		BBPreleaseref(b->batCacheid);
		throw(MAL, "array.tiles", RUNTIME_OBJECT_MISSING);
	}
	bn = BATnew(TYPE_oid, TYPE_oid, TRUE);
	bi = bat_iterator(b);
	br = bat_iterator(bt);
	limit= BATcount(b);
	BATloop(b,p,q){
		g = *(oid*) BUNhead(bi,p);
		BATloop(bt,r,s){
			oid o = g + *(oid*) BUNhead(br,r);
			if ( o < limit)
				BUNins(bn, &g, &o, TRUE);
		}
	}
	BBPkeepref(*ret = bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	BBPreleaseref(bt->batCacheid);
	return MAL_SUCCEED;
}

@= tilesAggr
str
ARRAYtilesSum_@1(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	BAT *b, *bt, *bn;
	int *ret = (int*) getArgReference(stk,pci,0);
	BATiter bi, br;
	BUN p,q;
	BUN r,s,z;
	oid g = 0, limit;
	@1 sum, elm;

	(void) cntxt;
	(void) mb;
	if ((b = BATdescriptor(*(int*)getArgReference(stk,pci,1))) == NULL) 
		throw(MAL, "array.tiles", RUNTIME_OBJECT_MISSING);
	if ((bt = BATdescriptor(*(int*)getArgReference(stk,pci,2))) == NULL) {
		BBPreleaseref(b->batCacheid);
		throw(MAL, "array.tiles", RUNTIME_OBJECT_MISSING);
	}

	bn = BATnew(TYPE_oid, TYPE_@1, TRUE);
	bi = bat_iterator(b);
	br = bat_iterator(bt);
	limit= BATcount(b);
	BATloop(b,p,q){
		sum = 0;
		g = *(oid*) BUNhead(bi,p);
		BATloop(bt,r,s){
			oid o = g + *(oid*) BUNhead(br,r);
			if ( o < limit) {
				BUNfndOID(z,bi, &o);
				if ( z != oid_nil){
					elm= *(@1*) BUNtail(bi, z);
					if ( elm != @1_nil)
						sum += elm;
				}
			}
		}
		BUNins(bn, &g, &sum, TRUE);
	}
	BBPkeepref(*ret = bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	BBPreleaseref(bt->batCacheid);
	return MAL_SUCCEED;
}
@-
The compilating factor is that in general the tile enumeration is dense, while
the tile structure can go over its boundaries. For this to control, we first
embed the array into a slightly larger array, filled with nulls.

@c
@:tilesAggr(sht)@
@:tilesAggr(int)@
@:tilesAggr(lng)@
@:tilesAggr(flt)@
@:tilesAggr(dbl)@
str
ARRAYtilesSum(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci) {
	int type = getTailType(getArgType(mb,pci,1));
	switch(type){
	case TYPE_sht:
		return ARRAYtilesSum_sht(cntxt,mb,stk,pci);
	case TYPE_int:
		return ARRAYtilesSum_int(cntxt,mb,stk,pci);
	case TYPE_lng:
		return ARRAYtilesSum_lng(cntxt,mb,stk,pci);
	case TYPE_flt:
		return ARRAYtilesSum_flt(cntxt,mb,stk,pci);
	case TYPE_dbl:
		return ARRAYtilesSum_dbl(cntxt,mb,stk,pci);
	default:
		throw(MAL, "array.sum", "illegal type");
	}
	return MAL_SUCCEED;
}

str
ARRAYembed(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	BAT **b, *bn = NULL, *bo;
	int i,n = 0, error = FALSE;

	(void) cntxt;
	(void) mb;
	if ( (pci->argc - pci->retc) % 2 != 0)
		throw(MAL, "array.map", "Unbalanced index arguments");

	b= (BAT**) GDKzalloc(sizeof(BAT*) * pci->argc-pci->retc);
	if( b == NULL)
		throw(MAL, "array.embed", MAL_MALLOC_FAIL);

	for ( i=pci->retc; i< pci->argc; i++){
		if ((b[n++] = BATdescriptor(*(int*)getArgReference(stk,pci,i))) == NULL) {
			for ( n--; n>= 0; n--)
				BBPreleaseref(b[n]->batCacheid);
			GDKfree(b);
			throw(MAL, "array.embed", RUNTIME_OBJECT_MISSING);
		}
	}
	/* type check the shapes and prepare iterators */
	for ( i= 0; i< n/2; i++) 
		error |= b[i]->ttype != b[i+n/2]->ttype;

	if ( error ){
		for ( n--; n>= 0; n--)
			BBPreleaseref(b[n]->batCacheid);
		GDKfree(b);
		throw(MAL, "array.embed", "Incompatible index types");
	}

	/* select the oids we need by searching all matching index vectors */
	bn = b[0];
	for ( i=0; i<n/2; i++){
		bo = BATsemijoin(b[i],bn);
		bn= BATmirror(BATsemijoin(BATmirror(bo), BATmirror(b[i+n/2])));
		BBPreleaseref(bo->batCacheid);
		bo = b[i+n/2];
	}

	if ( BATcount(bn) == BATcount(b[n/2]) ) {
		bn = BATmark(bn,0);
		BBPkeepref(bn->batCacheid);
		*(int*) getArgReference(stk,pci,0) = bn->batCacheid;
	} else {
		error = TRUE;
		BBPreleaseref(bn->batCacheid);
	}

	for ( n--; n>= 0; n--)
		BBPreleaseref(b[n]->batCacheid);
	GDKfree(b);
	if( error)
		throw(MAL,"map.embed","incomplete embedding");
	return MAL_SUCCEED;
}
@-
The printing stuff is postponed to the future. Then it also needs
a solution to the GDKout issues.
/*---------------------------------------------------------------------------*/
/*
   memory-hungry function;
   it internally builds the index to be able to print the array in-order.
	This is postpone to the future of arrays.
*/

static int
print_array(BAT *val, ...)
{
	BATiter vali = bat_iterator(val);
	va_list ap;
	BAT *tmp, *batptr[MAX_ARRAY_DIM];
	int *minvector;
	int *idxvector;
	int *maxvector;
	int *lenvector;
	oid *arrayindex;
	int i, dims;
	BUN j, c;
	stream *st = GDKout;
	int type_id = BATttype(val);

	va_start(ap, val);
	dims = 0;
	while ((tmp = va_arg(ap, BAT *)) != NULL) {
		if (dims == MAX_ARRAY_DIM) {
			GDKerror("print_array: Error, too high dimensionality.\n");
			goto exit_err_none;
		}
		batptr[dims++] = tmp;
	}
	if (dims == 0) {
		GDKerror("print_array: Error, no index bats provided.\n");
		goto exit_err_none;
	}
	va_end(ap);

#ifdef EXCESSIVE_DEBUGGING
	fprintf(stderr, "[PRINT_ARRAY] Dims = %d\n", dims);
#endif

	minvector = GDKmalloc(sizeof(ptr) * dims);
	if ( minvector == NULL) 
		goto exit_err_full;
	idxvector = GDKzalloc(sizeof(int) * dims);
	if ( idxvector == NULL) 
		goto exit_err_full;
	maxvector = GDKmalloc(sizeof(ptr) * dims);
	if ( maxvector == NULL) 
		goto exit_err_full;
	lenvector = GDKmalloc(sizeof(ptr) * dims);
	if ( lenvector == NULL) 
		goto exit_err_full;

	c = 1;
	j = BATcount(val);
	for (i = 0; i < dims; i++) {
		if (BATttype(batptr[i]) != TYPE_int) {
			GDKerror("print_array: Index %d error, not int type\n", i);
			goto exit_err_part;
		}
		if (BATcount(batptr[i]) != j) {
			GDKerror("print_array: Index %d error, count doesn't match\n", i);
			goto exit_err_part;
		}

		BATmin(batptr[i], &(minvector[i]));
		BATmax(batptr[i], &(maxvector[i]));
		lenvector[i] = maxvector[i] - minvector[i] + 1;
		c *= lenvector[i];
#ifdef EXCESSIVE_DEBUGGING
		fprintf(stderr, "[PRINT_ARRAY] Axis %d = %d..%d\n", i, minvector[i], maxvector[i]);
#endif
	}

	if (c != j) {
		GDKerror("print_array: array size does not match array count\n");
		goto exit_err_part;
	}
	arrayindex = GDKmalloc(sizeof(oid) * c);
	if ( arrayindex == NULL)
		goto exit_err_full;

	/* Iterate over the first index BAT.              */
	/* And fetch additional indices (for a given oid) */
	/* building the full M-D structure (of oid's).    */
	{
		BATiter b0i = bat_iterator(batptr[0]);
		register BUN p, q;

		p = BUNfirst(batptr[0]);
		q = BUNlast(batptr[0]);
		while (p < q) {
			register oid *o = (oid *) BUNhead(b0i, p);
			register int offset;

			offset = *((int *) BUNtail(b0i, p)) - minvector[0];
			for (i = 1; i < dims; i++) {
				register BUN p = BUNfnd(batptr[i], o);

				if (p == BUN_NONE) {
					GDKerror("print_array: Index %d missing for oid " OIDFMT ".\n", i, *o);
					goto exit_err_full;
				}
				offset = (offset * lenvector[i]) + ((*((int *) Tloc(batptr[i],p))) - minvector[i]);
			}
			arrayindex[offset] = *o;
			p++;
		}
	}

	/* Iterate over all valid indices             */
	/* (note: normalized to [0..l-1] ranges !)    */
	/* And print the values within the 'correct'  */
	/* bracket structure...                       */
#ifdef EXCESSIVE_DEBUGGING
	fprintf(stderr, "[PRINT_ARRAY] ");
#endif
	while (idxvector[dims - 1] < lenvector[dims - 1]) {
		int offset;

		for (i = 0; i < dims; i++) {
			if (idxvector[i] != 0) {
#ifdef EXCESSIVE_DEBUGGING
				fprintf(stderr, ",");
#endif
				mnstr_printf(st, ",");
				break;
			}
		}
		i = 0;
		while (i < dims && idxvector[i] == 0) {
#ifdef EXCESSIVE_DEBUGGING
			fprintf(stderr, "[");
#endif
			mnstr_printf(st, "[");
			i++;
		}
		for (offset = idxvector[0], i = 1; i < dims; i++) {
			offset = (offset * lenvector[i]) + idxvector[i];
		}
		{
			register BUN p = BUNfnd(val, &arrayindex[offset]);

			if (p == BUN_NONE) {
				GDKerror("print_array: Value missing for oid " OIDFMT ".\n", arrayindex[offset]);
				goto exit_err_full;
			}
#ifdef EXCESSIVE_DEBUGGING
			fprintf(stderr, OIDFMT "\@0", arrayindex[offset]);
#endif
			ATOMprint(type_id, BUNtail(vali, p), st);
			if (mnstr_errnr(st))
				goto exit_err_full;
		}
		i = 0;
		while (i < dims && (++idxvector[i]) == lenvector[i]) {
#ifdef EXCESSIVE_DEBUGGING
			fprintf(stderr, "]");
#endif
			mnstr_printf(st, "]");
			if (i < dims - 1) {
				idxvector[i] = 0;
				i++;
			}
		}
	}
#ifdef EXCESSIVE_DEBUGGING
	fprintf(stderr, "\n");
#endif
	mnstr_printf(st, "\n");

	/* Exit strategies... */
	GDKfree(arrayindex);
	GDKfree(maxvector);
	GDKfree(idxvector);
	GDKfree(minvector);
	GDKfree(lenvector);
	return GDK_SUCCEED;

exit_err_full:
	if (arrayindex)
		GDKfree(arrayindex);
exit_err_part:
	if ( maxvector)
		GDKfree(maxvector);
	if (idxvector)
		GDKfree(idxvector);
	if (minvector)
		GDKfree(minvector);
	if (lenvector)
		GDKfree(lenvector);
exit_err_none:
	return GDK_FAIL;
}
@}
