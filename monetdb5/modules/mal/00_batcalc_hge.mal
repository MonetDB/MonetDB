# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0.  If a copy of the MPL was not distributed with this
# file, You can obtain one at http://mozilla.org/MPL/2.0/.
#
# Copyright 1997 - July 2008 CWI, August 2008 - 2018 MonetDB B.V.

# This file was generated by using the script 00_batcalc_hge.mal.sh.

module batcalc;

pattern iszero(b:bat[:hge]) :bat[:bit]
address CMDbatISZERO
comment "Unary check for zero over the tail of the bat";
pattern iszero(b:bat[:hge],s:bat[:oid]) :bat[:bit]
address CMDbatISZERO
comment "Unary check for zero over the tail of the bat with candidates list";


pattern not(b:bat[:hge]) :bat[:hge]
address CMDbatNOT
comment "Unary bitwise not over the tail of the bat";
pattern not(b:bat[:hge],s:bat[:oid]) :bat[:hge]
address CMDbatNOT
comment "Unary bitwise not over the tail of the bat with candidates list";


pattern sign(b:bat[:hge]) :bat[:bte]
address CMDbatSIGN
comment "Unary sign (-1,0,1) over the tail of the bat";
pattern sign(b:bat[:hge],s:bat[:oid]) :bat[:bte]
address CMDbatSIGN
comment "Unary sign (-1,0,1) over the tail of the bat with candidates list";


pattern abs(b:bat[:hge]) :bat[:hge]
address CMDbatABS
comment "Unary abs over the tail of the bat";
pattern abs(b:bat[:hge],s:bat[:oid]) :bat[:hge]
address CMDbatABS
comment "Unary abs over the tail of the bat with candidates list";


pattern -(b:bat[:hge]) :bat[:hge]
address CMDbatNEG
comment "Unary neg over the tail of the bat";
pattern -(b:bat[:hge],s:bat[:oid]) :bat[:hge]
address CMDbatNEG
comment "Unary neg over the tail of the bat with candidates list";


pattern ++(b:bat[:hge]) :bat[:hge]
address CMDbatINCR
comment "Unary increment over the tail of the bat";
pattern ++(b:bat[:hge],s:bat[:oid]) :bat[:hge]
address CMDbatINCR
comment "Unary increment over the tail of the bat with candidates list";


pattern --(b:bat[:hge]) :bat[:hge]
address CMDbatDECR
comment "Unary decrement over the tail of the bat";
pattern --(b:bat[:hge],s:bat[:oid]) :bat[:hge]
address CMDbatDECR
comment "Unary decrement over the tail of the bat with candidates list";


pattern +(b1:bat[:bte],b2:bat[:lng]) :bat[:hge]
address CMDbatADDenlarge
comment "Return B1 + B2, guarantee no overflow by returning larger type";
pattern +(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]) :bat[:hge]
address CMDbatADDenlarge
comment "Return B1 + B2 with candidates list, guarantee no overflow by returning larger type";
pattern +(b:bat[:bte],v:lng) :bat[:hge]
address CMDbatADDenlarge
comment "Return B + V, guarantee no overflow by returning larger type";
pattern +(b:bat[:bte],v:lng,s:bat[:oid]) :bat[:hge]
address CMDbatADDenlarge
comment "Return B + V with candidates list, guarantee no overflow by returning larger type";
pattern +(v:bte,b:bat[:lng]) :bat[:hge]
address CMDbatADDenlarge
comment "Return V + B, guarantee no overflow by returning larger type";
pattern +(v:bte,b:bat[:lng],s:bat[:oid]) :bat[:hge]
address CMDbatADDenlarge
comment "Return V + B with candidates list, guarantee no overflow by returning larger type";

pattern +(b1:bat[:sht],b2:bat[:lng]) :bat[:hge]
address CMDbatADDenlarge
comment "Return B1 + B2, guarantee no overflow by returning larger type";
pattern +(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]) :bat[:hge]
address CMDbatADDenlarge
comment "Return B1 + B2 with candidates list, guarantee no overflow by returning larger type";
pattern +(b:bat[:sht],v:lng) :bat[:hge]
address CMDbatADDenlarge
comment "Return B + V, guarantee no overflow by returning larger type";
pattern +(b:bat[:sht],v:lng,s:bat[:oid]) :bat[:hge]
address CMDbatADDenlarge
comment "Return B + V with candidates list, guarantee no overflow by returning larger type";
pattern +(v:sht,b:bat[:lng]) :bat[:hge]
address CMDbatADDenlarge
comment "Return V + B, guarantee no overflow by returning larger type";
pattern +(v:sht,b:bat[:lng],s:bat[:oid]) :bat[:hge]
address CMDbatADDenlarge
comment "Return V + B with candidates list, guarantee no overflow by returning larger type";

pattern +(b1:bat[:int],b2:bat[:lng]) :bat[:hge]
address CMDbatADDenlarge
comment "Return B1 + B2, guarantee no overflow by returning larger type";
pattern +(b1:bat[:int],b2:bat[:lng],s:bat[:oid]) :bat[:hge]
address CMDbatADDenlarge
comment "Return B1 + B2 with candidates list, guarantee no overflow by returning larger type";
pattern +(b:bat[:int],v:lng) :bat[:hge]
address CMDbatADDenlarge
comment "Return B + V, guarantee no overflow by returning larger type";
pattern +(b:bat[:int],v:lng,s:bat[:oid]) :bat[:hge]
address CMDbatADDenlarge
comment "Return B + V with candidates list, guarantee no overflow by returning larger type";
pattern +(v:int,b:bat[:lng]) :bat[:hge]
address CMDbatADDenlarge
comment "Return V + B, guarantee no overflow by returning larger type";
pattern +(v:int,b:bat[:lng],s:bat[:oid]) :bat[:hge]
address CMDbatADDenlarge
comment "Return V + B with candidates list, guarantee no overflow by returning larger type";

pattern +(b1:bat[:lng],b2:bat[:bte]) :bat[:hge]
address CMDbatADDenlarge
comment "Return B1 + B2, guarantee no overflow by returning larger type";
pattern +(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]) :bat[:hge]
address CMDbatADDenlarge
comment "Return B1 + B2 with candidates list, guarantee no overflow by returning larger type";
pattern +(b:bat[:lng],v:bte) :bat[:hge]
address CMDbatADDenlarge
comment "Return B + V, guarantee no overflow by returning larger type";
pattern +(b:bat[:lng],v:bte,s:bat[:oid]) :bat[:hge]
address CMDbatADDenlarge
comment "Return B + V with candidates list, guarantee no overflow by returning larger type";
pattern +(v:lng,b:bat[:bte]) :bat[:hge]
address CMDbatADDenlarge
comment "Return V + B, guarantee no overflow by returning larger type";
pattern +(v:lng,b:bat[:bte],s:bat[:oid]) :bat[:hge]
address CMDbatADDenlarge
comment "Return V + B with candidates list, guarantee no overflow by returning larger type";

pattern +(b1:bat[:lng],b2:bat[:sht]) :bat[:hge]
address CMDbatADDenlarge
comment "Return B1 + B2, guarantee no overflow by returning larger type";
pattern +(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]) :bat[:hge]
address CMDbatADDenlarge
comment "Return B1 + B2 with candidates list, guarantee no overflow by returning larger type";
pattern +(b:bat[:lng],v:sht) :bat[:hge]
address CMDbatADDenlarge
comment "Return B + V, guarantee no overflow by returning larger type";
pattern +(b:bat[:lng],v:sht,s:bat[:oid]) :bat[:hge]
address CMDbatADDenlarge
comment "Return B + V with candidates list, guarantee no overflow by returning larger type";
pattern +(v:lng,b:bat[:sht]) :bat[:hge]
address CMDbatADDenlarge
comment "Return V + B, guarantee no overflow by returning larger type";
pattern +(v:lng,b:bat[:sht],s:bat[:oid]) :bat[:hge]
address CMDbatADDenlarge
comment "Return V + B with candidates list, guarantee no overflow by returning larger type";

pattern +(b1:bat[:lng],b2:bat[:int]) :bat[:hge]
address CMDbatADDenlarge
comment "Return B1 + B2, guarantee no overflow by returning larger type";
pattern +(b1:bat[:lng],b2:bat[:int],s:bat[:oid]) :bat[:hge]
address CMDbatADDenlarge
comment "Return B1 + B2 with candidates list, guarantee no overflow by returning larger type";
pattern +(b:bat[:lng],v:int) :bat[:hge]
address CMDbatADDenlarge
comment "Return B + V, guarantee no overflow by returning larger type";
pattern +(b:bat[:lng],v:int,s:bat[:oid]) :bat[:hge]
address CMDbatADDenlarge
comment "Return B + V with candidates list, guarantee no overflow by returning larger type";
pattern +(v:lng,b:bat[:int]) :bat[:hge]
address CMDbatADDenlarge
comment "Return V + B, guarantee no overflow by returning larger type";
pattern +(v:lng,b:bat[:int],s:bat[:oid]) :bat[:hge]
address CMDbatADDenlarge
comment "Return V + B with candidates list, guarantee no overflow by returning larger type";

pattern +(b1:bat[:lng],b2:bat[:lng]) :bat[:hge]
address CMDbatADDenlarge
comment "Return B1 + B2, guarantee no overflow by returning larger type";
pattern +(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]) :bat[:hge]
address CMDbatADDenlarge
comment "Return B1 + B2 with candidates list, guarantee no overflow by returning larger type";
pattern +(b:bat[:lng],v:lng) :bat[:hge]
address CMDbatADDenlarge
comment "Return B + V, guarantee no overflow by returning larger type";
pattern +(b:bat[:lng],v:lng,s:bat[:oid]) :bat[:hge]
address CMDbatADDenlarge
comment "Return B + V with candidates list, guarantee no overflow by returning larger type";
pattern +(v:lng,b:bat[:lng]) :bat[:hge]
address CMDbatADDenlarge
comment "Return V + B, guarantee no overflow by returning larger type";
pattern +(v:lng,b:bat[:lng],s:bat[:oid]) :bat[:hge]
address CMDbatADDenlarge
comment "Return V + B with candidates list, guarantee no overflow by returning larger type";

pattern +(b1:bat[:hge],b2:bat[:flt]) :bat[:dbl]
address CMDbatADDenlarge
comment "Return B1 + B2, guarantee no overflow by returning larger type";
pattern +(b1:bat[:hge],b2:bat[:flt],s:bat[:oid]) :bat[:dbl]
address CMDbatADDenlarge
comment "Return B1 + B2 with candidates list, guarantee no overflow by returning larger type";
pattern +(b:bat[:hge],v:flt) :bat[:dbl]
address CMDbatADDenlarge
comment "Return B + V, guarantee no overflow by returning larger type";
pattern +(b:bat[:hge],v:flt,s:bat[:oid]) :bat[:dbl]
address CMDbatADDenlarge
comment "Return B + V with candidates list, guarantee no overflow by returning larger type";
pattern +(v:hge,b:bat[:flt]) :bat[:dbl]
address CMDbatADDenlarge
comment "Return V + B, guarantee no overflow by returning larger type";
pattern +(v:hge,b:bat[:flt],s:bat[:oid]) :bat[:dbl]
address CMDbatADDenlarge
comment "Return V + B with candidates list, guarantee no overflow by returning larger type";

pattern +(b1:bat[:flt],b2:bat[:hge]) :bat[:dbl]
address CMDbatADDenlarge
comment "Return B1 + B2, guarantee no overflow by returning larger type";
pattern +(b1:bat[:flt],b2:bat[:hge],s:bat[:oid]) :bat[:dbl]
address CMDbatADDenlarge
comment "Return B1 + B2 with candidates list, guarantee no overflow by returning larger type";
pattern +(b:bat[:flt],v:hge) :bat[:dbl]
address CMDbatADDenlarge
comment "Return B + V, guarantee no overflow by returning larger type";
pattern +(b:bat[:flt],v:hge,s:bat[:oid]) :bat[:dbl]
address CMDbatADDenlarge
comment "Return B + V with candidates list, guarantee no overflow by returning larger type";
pattern +(v:flt,b:bat[:hge]) :bat[:dbl]
address CMDbatADDenlarge
comment "Return V + B, guarantee no overflow by returning larger type";
pattern +(v:flt,b:bat[:hge],s:bat[:oid]) :bat[:dbl]
address CMDbatADDenlarge
comment "Return V + B with candidates list, guarantee no overflow by returning larger type";


pattern -(b1:bat[:bte],b2:bat[:lng]) :bat[:hge]
address CMDbatSUBenlarge
comment "Return B1 - B2, guarantee no overflow by returning larger type";
pattern -(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]) :bat[:hge]
address CMDbatSUBenlarge
comment "Return B1 - B2 with candidates list, guarantee no overflow by returning larger type";
pattern -(b:bat[:bte],v:lng) :bat[:hge]
address CMDbatSUBenlarge
comment "Return B - V, guarantee no overflow by returning larger type";
pattern -(b:bat[:bte],v:lng,s:bat[:oid]) :bat[:hge]
address CMDbatSUBenlarge
comment "Return B - V with candidates list, guarantee no overflow by returning larger type";
pattern -(v:bte,b:bat[:lng]) :bat[:hge]
address CMDbatSUBenlarge
comment "Return V - B, guarantee no overflow by returning larger type";
pattern -(v:bte,b:bat[:lng],s:bat[:oid]) :bat[:hge]
address CMDbatSUBenlarge
comment "Return V - B with candidates list, guarantee no overflow by returning larger type";

pattern -(b1:bat[:sht],b2:bat[:lng]) :bat[:hge]
address CMDbatSUBenlarge
comment "Return B1 - B2, guarantee no overflow by returning larger type";
pattern -(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]) :bat[:hge]
address CMDbatSUBenlarge
comment "Return B1 - B2 with candidates list, guarantee no overflow by returning larger type";
pattern -(b:bat[:sht],v:lng) :bat[:hge]
address CMDbatSUBenlarge
comment "Return B - V, guarantee no overflow by returning larger type";
pattern -(b:bat[:sht],v:lng,s:bat[:oid]) :bat[:hge]
address CMDbatSUBenlarge
comment "Return B - V with candidates list, guarantee no overflow by returning larger type";
pattern -(v:sht,b:bat[:lng]) :bat[:hge]
address CMDbatSUBenlarge
comment "Return V - B, guarantee no overflow by returning larger type";
pattern -(v:sht,b:bat[:lng],s:bat[:oid]) :bat[:hge]
address CMDbatSUBenlarge
comment "Return V - B with candidates list, guarantee no overflow by returning larger type";

pattern -(b1:bat[:int],b2:bat[:lng]) :bat[:hge]
address CMDbatSUBenlarge
comment "Return B1 - B2, guarantee no overflow by returning larger type";
pattern -(b1:bat[:int],b2:bat[:lng],s:bat[:oid]) :bat[:hge]
address CMDbatSUBenlarge
comment "Return B1 - B2 with candidates list, guarantee no overflow by returning larger type";
pattern -(b:bat[:int],v:lng) :bat[:hge]
address CMDbatSUBenlarge
comment "Return B - V, guarantee no overflow by returning larger type";
pattern -(b:bat[:int],v:lng,s:bat[:oid]) :bat[:hge]
address CMDbatSUBenlarge
comment "Return B - V with candidates list, guarantee no overflow by returning larger type";
pattern -(v:int,b:bat[:lng]) :bat[:hge]
address CMDbatSUBenlarge
comment "Return V - B, guarantee no overflow by returning larger type";
pattern -(v:int,b:bat[:lng],s:bat[:oid]) :bat[:hge]
address CMDbatSUBenlarge
comment "Return V - B with candidates list, guarantee no overflow by returning larger type";

pattern -(b1:bat[:lng],b2:bat[:bte]) :bat[:hge]
address CMDbatSUBenlarge
comment "Return B1 - B2, guarantee no overflow by returning larger type";
pattern -(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]) :bat[:hge]
address CMDbatSUBenlarge
comment "Return B1 - B2 with candidates list, guarantee no overflow by returning larger type";
pattern -(b:bat[:lng],v:bte) :bat[:hge]
address CMDbatSUBenlarge
comment "Return B - V, guarantee no overflow by returning larger type";
pattern -(b:bat[:lng],v:bte,s:bat[:oid]) :bat[:hge]
address CMDbatSUBenlarge
comment "Return B - V with candidates list, guarantee no overflow by returning larger type";
pattern -(v:lng,b:bat[:bte]) :bat[:hge]
address CMDbatSUBenlarge
comment "Return V - B, guarantee no overflow by returning larger type";
pattern -(v:lng,b:bat[:bte],s:bat[:oid]) :bat[:hge]
address CMDbatSUBenlarge
comment "Return V - B with candidates list, guarantee no overflow by returning larger type";

pattern -(b1:bat[:lng],b2:bat[:sht]) :bat[:hge]
address CMDbatSUBenlarge
comment "Return B1 - B2, guarantee no overflow by returning larger type";
pattern -(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]) :bat[:hge]
address CMDbatSUBenlarge
comment "Return B1 - B2 with candidates list, guarantee no overflow by returning larger type";
pattern -(b:bat[:lng],v:sht) :bat[:hge]
address CMDbatSUBenlarge
comment "Return B - V, guarantee no overflow by returning larger type";
pattern -(b:bat[:lng],v:sht,s:bat[:oid]) :bat[:hge]
address CMDbatSUBenlarge
comment "Return B - V with candidates list, guarantee no overflow by returning larger type";
pattern -(v:lng,b:bat[:sht]) :bat[:hge]
address CMDbatSUBenlarge
comment "Return V - B, guarantee no overflow by returning larger type";
pattern -(v:lng,b:bat[:sht],s:bat[:oid]) :bat[:hge]
address CMDbatSUBenlarge
comment "Return V - B with candidates list, guarantee no overflow by returning larger type";

pattern -(b1:bat[:lng],b2:bat[:int]) :bat[:hge]
address CMDbatSUBenlarge
comment "Return B1 - B2, guarantee no overflow by returning larger type";
pattern -(b1:bat[:lng],b2:bat[:int],s:bat[:oid]) :bat[:hge]
address CMDbatSUBenlarge
comment "Return B1 - B2 with candidates list, guarantee no overflow by returning larger type";
pattern -(b:bat[:lng],v:int) :bat[:hge]
address CMDbatSUBenlarge
comment "Return B - V, guarantee no overflow by returning larger type";
pattern -(b:bat[:lng],v:int,s:bat[:oid]) :bat[:hge]
address CMDbatSUBenlarge
comment "Return B - V with candidates list, guarantee no overflow by returning larger type";
pattern -(v:lng,b:bat[:int]) :bat[:hge]
address CMDbatSUBenlarge
comment "Return V - B, guarantee no overflow by returning larger type";
pattern -(v:lng,b:bat[:int],s:bat[:oid]) :bat[:hge]
address CMDbatSUBenlarge
comment "Return V - B with candidates list, guarantee no overflow by returning larger type";

pattern -(b1:bat[:lng],b2:bat[:lng]) :bat[:hge]
address CMDbatSUBenlarge
comment "Return B1 - B2, guarantee no overflow by returning larger type";
pattern -(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]) :bat[:hge]
address CMDbatSUBenlarge
comment "Return B1 - B2 with candidates list, guarantee no overflow by returning larger type";
pattern -(b:bat[:lng],v:lng) :bat[:hge]
address CMDbatSUBenlarge
comment "Return B - V, guarantee no overflow by returning larger type";
pattern -(b:bat[:lng],v:lng,s:bat[:oid]) :bat[:hge]
address CMDbatSUBenlarge
comment "Return B - V with candidates list, guarantee no overflow by returning larger type";
pattern -(v:lng,b:bat[:lng]) :bat[:hge]
address CMDbatSUBenlarge
comment "Return V - B, guarantee no overflow by returning larger type";
pattern -(v:lng,b:bat[:lng],s:bat[:oid]) :bat[:hge]
address CMDbatSUBenlarge
comment "Return V - B with candidates list, guarantee no overflow by returning larger type";

pattern -(b1:bat[:hge],b2:bat[:flt]) :bat[:dbl]
address CMDbatSUBenlarge
comment "Return B1 - B2, guarantee no overflow by returning larger type";
pattern -(b1:bat[:hge],b2:bat[:flt],s:bat[:oid]) :bat[:dbl]
address CMDbatSUBenlarge
comment "Return B1 - B2 with candidates list, guarantee no overflow by returning larger type";
pattern -(b:bat[:hge],v:flt) :bat[:dbl]
address CMDbatSUBenlarge
comment "Return B - V, guarantee no overflow by returning larger type";
pattern -(b:bat[:hge],v:flt,s:bat[:oid]) :bat[:dbl]
address CMDbatSUBenlarge
comment "Return B - V with candidates list, guarantee no overflow by returning larger type";
pattern -(v:hge,b:bat[:flt]) :bat[:dbl]
address CMDbatSUBenlarge
comment "Return V - B, guarantee no overflow by returning larger type";
pattern -(v:hge,b:bat[:flt],s:bat[:oid]) :bat[:dbl]
address CMDbatSUBenlarge
comment "Return V - B with candidates list, guarantee no overflow by returning larger type";

pattern -(b1:bat[:flt],b2:bat[:hge]) :bat[:dbl]
address CMDbatSUBenlarge
comment "Return B1 - B2, guarantee no overflow by returning larger type";
pattern -(b1:bat[:flt],b2:bat[:hge],s:bat[:oid]) :bat[:dbl]
address CMDbatSUBenlarge
comment "Return B1 - B2 with candidates list, guarantee no overflow by returning larger type";
pattern -(b:bat[:flt],v:hge) :bat[:dbl]
address CMDbatSUBenlarge
comment "Return B - V, guarantee no overflow by returning larger type";
pattern -(b:bat[:flt],v:hge,s:bat[:oid]) :bat[:dbl]
address CMDbatSUBenlarge
comment "Return B - V with candidates list, guarantee no overflow by returning larger type";
pattern -(v:flt,b:bat[:hge]) :bat[:dbl]
address CMDbatSUBenlarge
comment "Return V - B, guarantee no overflow by returning larger type";
pattern -(v:flt,b:bat[:hge],s:bat[:oid]) :bat[:dbl]
address CMDbatSUBenlarge
comment "Return V - B with candidates list, guarantee no overflow by returning larger type";


pattern *(b1:bat[:bte],b2:bat[:lng]) :bat[:hge]
address CMDbatMULenlarge
comment "Return B1 * B2, guarantee no overflow by returning larger type";
pattern *(b1:bat[:bte],b2:bat[:lng],s:bat[:oid]) :bat[:hge]
address CMDbatMULenlarge
comment "Return B1 * B2 with candidates list, guarantee no overflow by returning larger type";
pattern *(b:bat[:bte],v:lng) :bat[:hge]
address CMDbatMULenlarge
comment "Return B * V, guarantee no overflow by returning larger type";
pattern *(b:bat[:bte],v:lng,s:bat[:oid]) :bat[:hge]
address CMDbatMULenlarge
comment "Return B * V with candidates list, guarantee no overflow by returning larger type";
pattern *(v:bte,b:bat[:lng]) :bat[:hge]
address CMDbatMULenlarge
comment "Return V * B, guarantee no overflow by returning larger type";
pattern *(v:bte,b:bat[:lng],s:bat[:oid]) :bat[:hge]
address CMDbatMULenlarge
comment "Return V * B with candidates list, guarantee no overflow by returning larger type";

pattern *(b1:bat[:sht],b2:bat[:lng]) :bat[:hge]
address CMDbatMULenlarge
comment "Return B1 * B2, guarantee no overflow by returning larger type";
pattern *(b1:bat[:sht],b2:bat[:lng],s:bat[:oid]) :bat[:hge]
address CMDbatMULenlarge
comment "Return B1 * B2 with candidates list, guarantee no overflow by returning larger type";
pattern *(b:bat[:sht],v:lng) :bat[:hge]
address CMDbatMULenlarge
comment "Return B * V, guarantee no overflow by returning larger type";
pattern *(b:bat[:sht],v:lng,s:bat[:oid]) :bat[:hge]
address CMDbatMULenlarge
comment "Return B * V with candidates list, guarantee no overflow by returning larger type";
pattern *(v:sht,b:bat[:lng]) :bat[:hge]
address CMDbatMULenlarge
comment "Return V * B, guarantee no overflow by returning larger type";
pattern *(v:sht,b:bat[:lng],s:bat[:oid]) :bat[:hge]
address CMDbatMULenlarge
comment "Return V * B with candidates list, guarantee no overflow by returning larger type";

pattern *(b1:bat[:int],b2:bat[:lng]) :bat[:hge]
address CMDbatMULenlarge
comment "Return B1 * B2, guarantee no overflow by returning larger type";
pattern *(b1:bat[:int],b2:bat[:lng],s:bat[:oid]) :bat[:hge]
address CMDbatMULenlarge
comment "Return B1 * B2 with candidates list, guarantee no overflow by returning larger type";
pattern *(b:bat[:int],v:lng) :bat[:hge]
address CMDbatMULenlarge
comment "Return B * V, guarantee no overflow by returning larger type";
pattern *(b:bat[:int],v:lng,s:bat[:oid]) :bat[:hge]
address CMDbatMULenlarge
comment "Return B * V with candidates list, guarantee no overflow by returning larger type";
pattern *(v:int,b:bat[:lng]) :bat[:hge]
address CMDbatMULenlarge
comment "Return V * B, guarantee no overflow by returning larger type";
pattern *(v:int,b:bat[:lng],s:bat[:oid]) :bat[:hge]
address CMDbatMULenlarge
comment "Return V * B with candidates list, guarantee no overflow by returning larger type";

pattern *(b1:bat[:lng],b2:bat[:bte]) :bat[:hge]
address CMDbatMULenlarge
comment "Return B1 * B2, guarantee no overflow by returning larger type";
pattern *(b1:bat[:lng],b2:bat[:bte],s:bat[:oid]) :bat[:hge]
address CMDbatMULenlarge
comment "Return B1 * B2 with candidates list, guarantee no overflow by returning larger type";
pattern *(b:bat[:lng],v:bte) :bat[:hge]
address CMDbatMULenlarge
comment "Return B * V, guarantee no overflow by returning larger type";
pattern *(b:bat[:lng],v:bte,s:bat[:oid]) :bat[:hge]
address CMDbatMULenlarge
comment "Return B * V with candidates list, guarantee no overflow by returning larger type";
pattern *(v:lng,b:bat[:bte]) :bat[:hge]
address CMDbatMULenlarge
comment "Return V * B, guarantee no overflow by returning larger type";
pattern *(v:lng,b:bat[:bte],s:bat[:oid]) :bat[:hge]
address CMDbatMULenlarge
comment "Return V * B with candidates list, guarantee no overflow by returning larger type";

pattern *(b1:bat[:lng],b2:bat[:sht]) :bat[:hge]
address CMDbatMULenlarge
comment "Return B1 * B2, guarantee no overflow by returning larger type";
pattern *(b1:bat[:lng],b2:bat[:sht],s:bat[:oid]) :bat[:hge]
address CMDbatMULenlarge
comment "Return B1 * B2 with candidates list, guarantee no overflow by returning larger type";
pattern *(b:bat[:lng],v:sht) :bat[:hge]
address CMDbatMULenlarge
comment "Return B * V, guarantee no overflow by returning larger type";
pattern *(b:bat[:lng],v:sht,s:bat[:oid]) :bat[:hge]
address CMDbatMULenlarge
comment "Return B * V with candidates list, guarantee no overflow by returning larger type";
pattern *(v:lng,b:bat[:sht]) :bat[:hge]
address CMDbatMULenlarge
comment "Return V * B, guarantee no overflow by returning larger type";
pattern *(v:lng,b:bat[:sht],s:bat[:oid]) :bat[:hge]
address CMDbatMULenlarge
comment "Return V * B with candidates list, guarantee no overflow by returning larger type";

pattern *(b1:bat[:lng],b2:bat[:int]) :bat[:hge]
address CMDbatMULenlarge
comment "Return B1 * B2, guarantee no overflow by returning larger type";
pattern *(b1:bat[:lng],b2:bat[:int],s:bat[:oid]) :bat[:hge]
address CMDbatMULenlarge
comment "Return B1 * B2 with candidates list, guarantee no overflow by returning larger type";
pattern *(b:bat[:lng],v:int) :bat[:hge]
address CMDbatMULenlarge
comment "Return B * V, guarantee no overflow by returning larger type";
pattern *(b:bat[:lng],v:int,s:bat[:oid]) :bat[:hge]
address CMDbatMULenlarge
comment "Return B * V with candidates list, guarantee no overflow by returning larger type";
pattern *(v:lng,b:bat[:int]) :bat[:hge]
address CMDbatMULenlarge
comment "Return V * B, guarantee no overflow by returning larger type";
pattern *(v:lng,b:bat[:int],s:bat[:oid]) :bat[:hge]
address CMDbatMULenlarge
comment "Return V * B with candidates list, guarantee no overflow by returning larger type";

pattern *(b1:bat[:lng],b2:bat[:lng]) :bat[:hge]
address CMDbatMULenlarge
comment "Return B1 * B2, guarantee no overflow by returning larger type";
pattern *(b1:bat[:lng],b2:bat[:lng],s:bat[:oid]) :bat[:hge]
address CMDbatMULenlarge
comment "Return B1 * B2 with candidates list, guarantee no overflow by returning larger type";
pattern *(b:bat[:lng],v:lng) :bat[:hge]
address CMDbatMULenlarge
comment "Return B * V, guarantee no overflow by returning larger type";
pattern *(b:bat[:lng],v:lng,s:bat[:oid]) :bat[:hge]
address CMDbatMULenlarge
comment "Return B * V with candidates list, guarantee no overflow by returning larger type";
pattern *(v:lng,b:bat[:lng]) :bat[:hge]
address CMDbatMULenlarge
comment "Return V * B, guarantee no overflow by returning larger type";
pattern *(v:lng,b:bat[:lng],s:bat[:oid]) :bat[:hge]
address CMDbatMULenlarge
comment "Return V * B with candidates list, guarantee no overflow by returning larger type";

pattern *(b1:bat[:hge],b2:bat[:flt]) :bat[:dbl]
address CMDbatMULenlarge
comment "Return B1 * B2, guarantee no overflow by returning larger type";
pattern *(b1:bat[:hge],b2:bat[:flt],s:bat[:oid]) :bat[:dbl]
address CMDbatMULenlarge
comment "Return B1 * B2 with candidates list, guarantee no overflow by returning larger type";
pattern *(b:bat[:hge],v:flt) :bat[:dbl]
address CMDbatMULenlarge
comment "Return B * V, guarantee no overflow by returning larger type";
pattern *(b:bat[:hge],v:flt,s:bat[:oid]) :bat[:dbl]
address CMDbatMULenlarge
comment "Return B * V with candidates list, guarantee no overflow by returning larger type";
pattern *(v:hge,b:bat[:flt]) :bat[:dbl]
address CMDbatMULenlarge
comment "Return V * B, guarantee no overflow by returning larger type";
pattern *(v:hge,b:bat[:flt],s:bat[:oid]) :bat[:dbl]
address CMDbatMULenlarge
comment "Return V * B with candidates list, guarantee no overflow by returning larger type";

pattern *(b1:bat[:flt],b2:bat[:hge]) :bat[:dbl]
address CMDbatMULenlarge
comment "Return B1 * B2, guarantee no overflow by returning larger type";
pattern *(b1:bat[:flt],b2:bat[:hge],s:bat[:oid]) :bat[:dbl]
address CMDbatMULenlarge
comment "Return B1 * B2 with candidates list, guarantee no overflow by returning larger type";
pattern *(b:bat[:flt],v:hge) :bat[:dbl]
address CMDbatMULenlarge
comment "Return B * V, guarantee no overflow by returning larger type";
pattern *(b:bat[:flt],v:hge,s:bat[:oid]) :bat[:dbl]
address CMDbatMULenlarge
comment "Return B * V with candidates list, guarantee no overflow by returning larger type";
pattern *(v:flt,b:bat[:hge]) :bat[:dbl]
address CMDbatMULenlarge
comment "Return V * B, guarantee no overflow by returning larger type";
pattern *(v:flt,b:bat[:hge],s:bat[:oid]) :bat[:dbl]
address CMDbatMULenlarge
comment "Return V * B with candidates list, guarantee no overflow by returning larger type";


pattern +(b1:bat[:bte],b2:bat[:hge]) :bat[:hge]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
pattern +(b1:bat[:bte],b2:bat[:hge],s:bat[:oid]) :bat[:hge]
address CMDbatADDsignal
comment "Return B1 + B2 with candidates list, signal error on overflow";
pattern add_noerror(b1:bat[:bte],b2:bat[:hge]) :bat[:hge]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern add_noerror(b1:bat[:bte],b2:bat[:hge],s:bat[:oid]) :bat[:hge]
address CMDbatADD
comment "Return B1 + B2 with candidates list, overflow causes NIL value";
pattern +(b:bat[:bte],v:hge) :bat[:hge]
address CMDbatADDsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:bte],v:hge,s:bat[:oid]) :bat[:hge]
address CMDbatADDsignal
comment "Return B + V with candidates list, signal error on overflow";
pattern add_noerror(b:bat[:bte],v:hge) :bat[:hge]
address CMDbatADD
comment "Return B + V, overflow causes NIL value";
pattern add_noerror(b:bat[:bte],v:hge,s:bat[:oid]) :bat[:hge]
address CMDbatADD
comment "Return B + V with candidates list, overflow causes NIL value";
pattern +(v:bte,b:bat[:hge]) :bat[:hge]
address CMDbatADDsignal
comment "Return V + B, signal error on overflow";
pattern +(v:bte,b:bat[:hge],s:bat[:oid]) :bat[:hge]
address CMDbatADDsignal
comment "Return V + B with candidates list, signal error on overflow";
pattern add_noerror(v:bte,b:bat[:hge]) :bat[:hge]
address CMDbatADD
comment "Return V + B, overflow causes NIL value";
pattern add_noerror(v:bte,b:bat[:hge],s:bat[:oid]) :bat[:hge]
address CMDbatADD
comment "Return V + B with candidates list, overflow causes NIL value";

pattern +(b1:bat[:sht],b2:bat[:hge]) :bat[:hge]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
pattern +(b1:bat[:sht],b2:bat[:hge],s:bat[:oid]) :bat[:hge]
address CMDbatADDsignal
comment "Return B1 + B2 with candidates list, signal error on overflow";
pattern add_noerror(b1:bat[:sht],b2:bat[:hge]) :bat[:hge]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern add_noerror(b1:bat[:sht],b2:bat[:hge],s:bat[:oid]) :bat[:hge]
address CMDbatADD
comment "Return B1 + B2 with candidates list, overflow causes NIL value";
pattern +(b:bat[:sht],v:hge) :bat[:hge]
address CMDbatADDsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:sht],v:hge,s:bat[:oid]) :bat[:hge]
address CMDbatADDsignal
comment "Return B + V with candidates list, signal error on overflow";
pattern add_noerror(b:bat[:sht],v:hge) :bat[:hge]
address CMDbatADD
comment "Return B + V, overflow causes NIL value";
pattern add_noerror(b:bat[:sht],v:hge,s:bat[:oid]) :bat[:hge]
address CMDbatADD
comment "Return B + V with candidates list, overflow causes NIL value";
pattern +(v:sht,b:bat[:hge]) :bat[:hge]
address CMDbatADDsignal
comment "Return V + B, signal error on overflow";
pattern +(v:sht,b:bat[:hge],s:bat[:oid]) :bat[:hge]
address CMDbatADDsignal
comment "Return V + B with candidates list, signal error on overflow";
pattern add_noerror(v:sht,b:bat[:hge]) :bat[:hge]
address CMDbatADD
comment "Return V + B, overflow causes NIL value";
pattern add_noerror(v:sht,b:bat[:hge],s:bat[:oid]) :bat[:hge]
address CMDbatADD
comment "Return V + B with candidates list, overflow causes NIL value";

pattern +(b1:bat[:int],b2:bat[:hge]) :bat[:hge]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
pattern +(b1:bat[:int],b2:bat[:hge],s:bat[:oid]) :bat[:hge]
address CMDbatADDsignal
comment "Return B1 + B2 with candidates list, signal error on overflow";
pattern add_noerror(b1:bat[:int],b2:bat[:hge]) :bat[:hge]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern add_noerror(b1:bat[:int],b2:bat[:hge],s:bat[:oid]) :bat[:hge]
address CMDbatADD
comment "Return B1 + B2 with candidates list, overflow causes NIL value";
pattern +(b:bat[:int],v:hge) :bat[:hge]
address CMDbatADDsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:int],v:hge,s:bat[:oid]) :bat[:hge]
address CMDbatADDsignal
comment "Return B + V with candidates list, signal error on overflow";
pattern add_noerror(b:bat[:int],v:hge) :bat[:hge]
address CMDbatADD
comment "Return B + V, overflow causes NIL value";
pattern add_noerror(b:bat[:int],v:hge,s:bat[:oid]) :bat[:hge]
address CMDbatADD
comment "Return B + V with candidates list, overflow causes NIL value";
pattern +(v:int,b:bat[:hge]) :bat[:hge]
address CMDbatADDsignal
comment "Return V + B, signal error on overflow";
pattern +(v:int,b:bat[:hge],s:bat[:oid]) :bat[:hge]
address CMDbatADDsignal
comment "Return V + B with candidates list, signal error on overflow";
pattern add_noerror(v:int,b:bat[:hge]) :bat[:hge]
address CMDbatADD
comment "Return V + B, overflow causes NIL value";
pattern add_noerror(v:int,b:bat[:hge],s:bat[:oid]) :bat[:hge]
address CMDbatADD
comment "Return V + B with candidates list, overflow causes NIL value";

pattern +(b1:bat[:lng],b2:bat[:hge]) :bat[:hge]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
pattern +(b1:bat[:lng],b2:bat[:hge],s:bat[:oid]) :bat[:hge]
address CMDbatADDsignal
comment "Return B1 + B2 with candidates list, signal error on overflow";
pattern add_noerror(b1:bat[:lng],b2:bat[:hge]) :bat[:hge]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern add_noerror(b1:bat[:lng],b2:bat[:hge],s:bat[:oid]) :bat[:hge]
address CMDbatADD
comment "Return B1 + B2 with candidates list, overflow causes NIL value";
pattern +(b:bat[:lng],v:hge) :bat[:hge]
address CMDbatADDsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:lng],v:hge,s:bat[:oid]) :bat[:hge]
address CMDbatADDsignal
comment "Return B + V with candidates list, signal error on overflow";
pattern add_noerror(b:bat[:lng],v:hge) :bat[:hge]
address CMDbatADD
comment "Return B + V, overflow causes NIL value";
pattern add_noerror(b:bat[:lng],v:hge,s:bat[:oid]) :bat[:hge]
address CMDbatADD
comment "Return B + V with candidates list, overflow causes NIL value";
pattern +(v:lng,b:bat[:hge]) :bat[:hge]
address CMDbatADDsignal
comment "Return V + B, signal error on overflow";
pattern +(v:lng,b:bat[:hge],s:bat[:oid]) :bat[:hge]
address CMDbatADDsignal
comment "Return V + B with candidates list, signal error on overflow";
pattern add_noerror(v:lng,b:bat[:hge]) :bat[:hge]
address CMDbatADD
comment "Return V + B, overflow causes NIL value";
pattern add_noerror(v:lng,b:bat[:hge],s:bat[:oid]) :bat[:hge]
address CMDbatADD
comment "Return V + B with candidates list, overflow causes NIL value";

pattern +(b1:bat[:hge],b2:bat[:bte]) :bat[:hge]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
pattern +(b1:bat[:hge],b2:bat[:bte],s:bat[:oid]) :bat[:hge]
address CMDbatADDsignal
comment "Return B1 + B2 with candidates list, signal error on overflow";
pattern add_noerror(b1:bat[:hge],b2:bat[:bte]) :bat[:hge]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern add_noerror(b1:bat[:hge],b2:bat[:bte],s:bat[:oid]) :bat[:hge]
address CMDbatADD
comment "Return B1 + B2 with candidates list, overflow causes NIL value";
pattern +(b:bat[:hge],v:bte) :bat[:hge]
address CMDbatADDsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:hge],v:bte,s:bat[:oid]) :bat[:hge]
address CMDbatADDsignal
comment "Return B + V with candidates list, signal error on overflow";
pattern add_noerror(b:bat[:hge],v:bte) :bat[:hge]
address CMDbatADD
comment "Return B + V, overflow causes NIL value";
pattern add_noerror(b:bat[:hge],v:bte,s:bat[:oid]) :bat[:hge]
address CMDbatADD
comment "Return B + V with candidates list, overflow causes NIL value";
pattern +(v:hge,b:bat[:bte]) :bat[:hge]
address CMDbatADDsignal
comment "Return V + B, signal error on overflow";
pattern +(v:hge,b:bat[:bte],s:bat[:oid]) :bat[:hge]
address CMDbatADDsignal
comment "Return V + B with candidates list, signal error on overflow";
pattern add_noerror(v:hge,b:bat[:bte]) :bat[:hge]
address CMDbatADD
comment "Return V + B, overflow causes NIL value";
pattern add_noerror(v:hge,b:bat[:bte],s:bat[:oid]) :bat[:hge]
address CMDbatADD
comment "Return V + B with candidates list, overflow causes NIL value";

pattern +(b1:bat[:hge],b2:bat[:sht]) :bat[:hge]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
pattern +(b1:bat[:hge],b2:bat[:sht],s:bat[:oid]) :bat[:hge]
address CMDbatADDsignal
comment "Return B1 + B2 with candidates list, signal error on overflow";
pattern add_noerror(b1:bat[:hge],b2:bat[:sht]) :bat[:hge]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern add_noerror(b1:bat[:hge],b2:bat[:sht],s:bat[:oid]) :bat[:hge]
address CMDbatADD
comment "Return B1 + B2 with candidates list, overflow causes NIL value";
pattern +(b:bat[:hge],v:sht) :bat[:hge]
address CMDbatADDsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:hge],v:sht,s:bat[:oid]) :bat[:hge]
address CMDbatADDsignal
comment "Return B + V with candidates list, signal error on overflow";
pattern add_noerror(b:bat[:hge],v:sht) :bat[:hge]
address CMDbatADD
comment "Return B + V, overflow causes NIL value";
pattern add_noerror(b:bat[:hge],v:sht,s:bat[:oid]) :bat[:hge]
address CMDbatADD
comment "Return B + V with candidates list, overflow causes NIL value";
pattern +(v:hge,b:bat[:sht]) :bat[:hge]
address CMDbatADDsignal
comment "Return V + B, signal error on overflow";
pattern +(v:hge,b:bat[:sht],s:bat[:oid]) :bat[:hge]
address CMDbatADDsignal
comment "Return V + B with candidates list, signal error on overflow";
pattern add_noerror(v:hge,b:bat[:sht]) :bat[:hge]
address CMDbatADD
comment "Return V + B, overflow causes NIL value";
pattern add_noerror(v:hge,b:bat[:sht],s:bat[:oid]) :bat[:hge]
address CMDbatADD
comment "Return V + B with candidates list, overflow causes NIL value";

pattern +(b1:bat[:hge],b2:bat[:int]) :bat[:hge]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
pattern +(b1:bat[:hge],b2:bat[:int],s:bat[:oid]) :bat[:hge]
address CMDbatADDsignal
comment "Return B1 + B2 with candidates list, signal error on overflow";
pattern add_noerror(b1:bat[:hge],b2:bat[:int]) :bat[:hge]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern add_noerror(b1:bat[:hge],b2:bat[:int],s:bat[:oid]) :bat[:hge]
address CMDbatADD
comment "Return B1 + B2 with candidates list, overflow causes NIL value";
pattern +(b:bat[:hge],v:int) :bat[:hge]
address CMDbatADDsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:hge],v:int,s:bat[:oid]) :bat[:hge]
address CMDbatADDsignal
comment "Return B + V with candidates list, signal error on overflow";
pattern add_noerror(b:bat[:hge],v:int) :bat[:hge]
address CMDbatADD
comment "Return B + V, overflow causes NIL value";
pattern add_noerror(b:bat[:hge],v:int,s:bat[:oid]) :bat[:hge]
address CMDbatADD
comment "Return B + V with candidates list, overflow causes NIL value";
pattern +(v:hge,b:bat[:int]) :bat[:hge]
address CMDbatADDsignal
comment "Return V + B, signal error on overflow";
pattern +(v:hge,b:bat[:int],s:bat[:oid]) :bat[:hge]
address CMDbatADDsignal
comment "Return V + B with candidates list, signal error on overflow";
pattern add_noerror(v:hge,b:bat[:int]) :bat[:hge]
address CMDbatADD
comment "Return V + B, overflow causes NIL value";
pattern add_noerror(v:hge,b:bat[:int],s:bat[:oid]) :bat[:hge]
address CMDbatADD
comment "Return V + B with candidates list, overflow causes NIL value";

pattern +(b1:bat[:hge],b2:bat[:lng]) :bat[:hge]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
pattern +(b1:bat[:hge],b2:bat[:lng],s:bat[:oid]) :bat[:hge]
address CMDbatADDsignal
comment "Return B1 + B2 with candidates list, signal error on overflow";
pattern add_noerror(b1:bat[:hge],b2:bat[:lng]) :bat[:hge]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern add_noerror(b1:bat[:hge],b2:bat[:lng],s:bat[:oid]) :bat[:hge]
address CMDbatADD
comment "Return B1 + B2 with candidates list, overflow causes NIL value";
pattern +(b:bat[:hge],v:lng) :bat[:hge]
address CMDbatADDsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:hge],v:lng,s:bat[:oid]) :bat[:hge]
address CMDbatADDsignal
comment "Return B + V with candidates list, signal error on overflow";
pattern add_noerror(b:bat[:hge],v:lng) :bat[:hge]
address CMDbatADD
comment "Return B + V, overflow causes NIL value";
pattern add_noerror(b:bat[:hge],v:lng,s:bat[:oid]) :bat[:hge]
address CMDbatADD
comment "Return B + V with candidates list, overflow causes NIL value";
pattern +(v:hge,b:bat[:lng]) :bat[:hge]
address CMDbatADDsignal
comment "Return V + B, signal error on overflow";
pattern +(v:hge,b:bat[:lng],s:bat[:oid]) :bat[:hge]
address CMDbatADDsignal
comment "Return V + B with candidates list, signal error on overflow";
pattern add_noerror(v:hge,b:bat[:lng]) :bat[:hge]
address CMDbatADD
comment "Return V + B, overflow causes NIL value";
pattern add_noerror(v:hge,b:bat[:lng],s:bat[:oid]) :bat[:hge]
address CMDbatADD
comment "Return V + B with candidates list, overflow causes NIL value";

pattern +(b1:bat[:hge],b2:bat[:hge]) :bat[:hge]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
pattern +(b1:bat[:hge],b2:bat[:hge],s:bat[:oid]) :bat[:hge]
address CMDbatADDsignal
comment "Return B1 + B2 with candidates list, signal error on overflow";
pattern add_noerror(b1:bat[:hge],b2:bat[:hge]) :bat[:hge]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern add_noerror(b1:bat[:hge],b2:bat[:hge],s:bat[:oid]) :bat[:hge]
address CMDbatADD
comment "Return B1 + B2 with candidates list, overflow causes NIL value";
pattern +(b:bat[:hge],v:hge) :bat[:hge]
address CMDbatADDsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:hge],v:hge,s:bat[:oid]) :bat[:hge]
address CMDbatADDsignal
comment "Return B + V with candidates list, signal error on overflow";
pattern add_noerror(b:bat[:hge],v:hge) :bat[:hge]
address CMDbatADD
comment "Return B + V, overflow causes NIL value";
pattern add_noerror(b:bat[:hge],v:hge,s:bat[:oid]) :bat[:hge]
address CMDbatADD
comment "Return B + V with candidates list, overflow causes NIL value";
pattern +(v:hge,b:bat[:hge]) :bat[:hge]
address CMDbatADDsignal
comment "Return V + B, signal error on overflow";
pattern +(v:hge,b:bat[:hge],s:bat[:oid]) :bat[:hge]
address CMDbatADDsignal
comment "Return V + B with candidates list, signal error on overflow";
pattern add_noerror(v:hge,b:bat[:hge]) :bat[:hge]
address CMDbatADD
comment "Return V + B, overflow causes NIL value";
pattern add_noerror(v:hge,b:bat[:hge],s:bat[:oid]) :bat[:hge]
address CMDbatADD
comment "Return V + B with candidates list, overflow causes NIL value";

pattern +(b1:bat[:hge],b2:bat[:flt]) :bat[:flt]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
pattern +(b1:bat[:hge],b2:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatADDsignal
comment "Return B1 + B2 with candidates list, signal error on overflow";
pattern add_noerror(b1:bat[:hge],b2:bat[:flt]) :bat[:flt]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern add_noerror(b1:bat[:hge],b2:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatADD
comment "Return B1 + B2 with candidates list, overflow causes NIL value";
pattern +(b:bat[:hge],v:flt) :bat[:flt]
address CMDbatADDsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:hge],v:flt,s:bat[:oid]) :bat[:flt]
address CMDbatADDsignal
comment "Return B + V with candidates list, signal error on overflow";
pattern add_noerror(b:bat[:hge],v:flt) :bat[:flt]
address CMDbatADD
comment "Return B + V, overflow causes NIL value";
pattern add_noerror(b:bat[:hge],v:flt,s:bat[:oid]) :bat[:flt]
address CMDbatADD
comment "Return B + V with candidates list, overflow causes NIL value";
pattern +(v:hge,b:bat[:flt]) :bat[:flt]
address CMDbatADDsignal
comment "Return V + B, signal error on overflow";
pattern +(v:hge,b:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatADDsignal
comment "Return V + B with candidates list, signal error on overflow";
pattern add_noerror(v:hge,b:bat[:flt]) :bat[:flt]
address CMDbatADD
comment "Return V + B, overflow causes NIL value";
pattern add_noerror(v:hge,b:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatADD
comment "Return V + B with candidates list, overflow causes NIL value";

pattern +(b1:bat[:hge],b2:bat[:dbl]) :bat[:dbl]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
pattern +(b1:bat[:hge],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatADDsignal
comment "Return B1 + B2 with candidates list, signal error on overflow";
pattern add_noerror(b1:bat[:hge],b2:bat[:dbl]) :bat[:dbl]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern add_noerror(b1:bat[:hge],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatADD
comment "Return B1 + B2 with candidates list, overflow causes NIL value";
pattern +(b:bat[:hge],v:dbl) :bat[:dbl]
address CMDbatADDsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:hge],v:dbl,s:bat[:oid]) :bat[:dbl]
address CMDbatADDsignal
comment "Return B + V with candidates list, signal error on overflow";
pattern add_noerror(b:bat[:hge],v:dbl) :bat[:dbl]
address CMDbatADD
comment "Return B + V, overflow causes NIL value";
pattern add_noerror(b:bat[:hge],v:dbl,s:bat[:oid]) :bat[:dbl]
address CMDbatADD
comment "Return B + V with candidates list, overflow causes NIL value";
pattern +(v:hge,b:bat[:dbl]) :bat[:dbl]
address CMDbatADDsignal
comment "Return V + B, signal error on overflow";
pattern +(v:hge,b:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatADDsignal
comment "Return V + B with candidates list, signal error on overflow";
pattern add_noerror(v:hge,b:bat[:dbl]) :bat[:dbl]
address CMDbatADD
comment "Return V + B, overflow causes NIL value";
pattern add_noerror(v:hge,b:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatADD
comment "Return V + B with candidates list, overflow causes NIL value";

pattern +(b1:bat[:flt],b2:bat[:hge]) :bat[:flt]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
pattern +(b1:bat[:flt],b2:bat[:hge],s:bat[:oid]) :bat[:flt]
address CMDbatADDsignal
comment "Return B1 + B2 with candidates list, signal error on overflow";
pattern add_noerror(b1:bat[:flt],b2:bat[:hge]) :bat[:flt]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern add_noerror(b1:bat[:flt],b2:bat[:hge],s:bat[:oid]) :bat[:flt]
address CMDbatADD
comment "Return B1 + B2 with candidates list, overflow causes NIL value";
pattern +(b:bat[:flt],v:hge) :bat[:flt]
address CMDbatADDsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:flt],v:hge,s:bat[:oid]) :bat[:flt]
address CMDbatADDsignal
comment "Return B + V with candidates list, signal error on overflow";
pattern add_noerror(b:bat[:flt],v:hge) :bat[:flt]
address CMDbatADD
comment "Return B + V, overflow causes NIL value";
pattern add_noerror(b:bat[:flt],v:hge,s:bat[:oid]) :bat[:flt]
address CMDbatADD
comment "Return B + V with candidates list, overflow causes NIL value";
pattern +(v:flt,b:bat[:hge]) :bat[:flt]
address CMDbatADDsignal
comment "Return V + B, signal error on overflow";
pattern +(v:flt,b:bat[:hge],s:bat[:oid]) :bat[:flt]
address CMDbatADDsignal
comment "Return V + B with candidates list, signal error on overflow";
pattern add_noerror(v:flt,b:bat[:hge]) :bat[:flt]
address CMDbatADD
comment "Return V + B, overflow causes NIL value";
pattern add_noerror(v:flt,b:bat[:hge],s:bat[:oid]) :bat[:flt]
address CMDbatADD
comment "Return V + B with candidates list, overflow causes NIL value";

pattern +(b1:bat[:dbl],b2:bat[:hge]) :bat[:dbl]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
pattern +(b1:bat[:dbl],b2:bat[:hge],s:bat[:oid]) :bat[:dbl]
address CMDbatADDsignal
comment "Return B1 + B2 with candidates list, signal error on overflow";
pattern add_noerror(b1:bat[:dbl],b2:bat[:hge]) :bat[:dbl]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern add_noerror(b1:bat[:dbl],b2:bat[:hge],s:bat[:oid]) :bat[:dbl]
address CMDbatADD
comment "Return B1 + B2 with candidates list, overflow causes NIL value";
pattern +(b:bat[:dbl],v:hge) :bat[:dbl]
address CMDbatADDsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:dbl],v:hge,s:bat[:oid]) :bat[:dbl]
address CMDbatADDsignal
comment "Return B + V with candidates list, signal error on overflow";
pattern add_noerror(b:bat[:dbl],v:hge) :bat[:dbl]
address CMDbatADD
comment "Return B + V, overflow causes NIL value";
pattern add_noerror(b:bat[:dbl],v:hge,s:bat[:oid]) :bat[:dbl]
address CMDbatADD
comment "Return B + V with candidates list, overflow causes NIL value";
pattern +(v:dbl,b:bat[:hge]) :bat[:dbl]
address CMDbatADDsignal
comment "Return V + B, signal error on overflow";
pattern +(v:dbl,b:bat[:hge],s:bat[:oid]) :bat[:dbl]
address CMDbatADDsignal
comment "Return V + B with candidates list, signal error on overflow";
pattern add_noerror(v:dbl,b:bat[:hge]) :bat[:dbl]
address CMDbatADD
comment "Return V + B, overflow causes NIL value";
pattern add_noerror(v:dbl,b:bat[:hge],s:bat[:oid]) :bat[:dbl]
address CMDbatADD
comment "Return V + B with candidates list, overflow causes NIL value";


pattern -(b1:bat[:bte],b2:bat[:hge]) :bat[:hge]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
pattern -(b1:bat[:bte],b2:bat[:hge],s:bat[:oid]) :bat[:hge]
address CMDbatSUBsignal
comment "Return B1 - B2 with candidates list, signal error on overflow";
pattern sub_noerror(b1:bat[:bte],b2:bat[:hge]) :bat[:hge]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern sub_noerror(b1:bat[:bte],b2:bat[:hge],s:bat[:oid]) :bat[:hge]
address CMDbatSUB
comment "Return B1 - B2 with candidates list, overflow causes NIL value";
pattern -(b:bat[:bte],v:hge) :bat[:hge]
address CMDbatSUBsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:bte],v:hge,s:bat[:oid]) :bat[:hge]
address CMDbatSUBsignal
comment "Return B - V with candidates list, signal error on overflow";
pattern sub_noerror(b:bat[:bte],v:hge) :bat[:hge]
address CMDbatSUB
comment "Return B - V, overflow causes NIL value";
pattern sub_noerror(b:bat[:bte],v:hge,s:bat[:oid]) :bat[:hge]
address CMDbatSUB
comment "Return B - V with candidates list, overflow causes NIL value";
pattern -(v:bte,b:bat[:hge]) :bat[:hge]
address CMDbatSUBsignal
comment "Return V - B, signal error on overflow";
pattern -(v:bte,b:bat[:hge],s:bat[:oid]) :bat[:hge]
address CMDbatSUBsignal
comment "Return V - B with candidates list, signal error on overflow";
pattern sub_noerror(v:bte,b:bat[:hge]) :bat[:hge]
address CMDbatSUB
comment "Return V - B, overflow causes NIL value";
pattern sub_noerror(v:bte,b:bat[:hge],s:bat[:oid]) :bat[:hge]
address CMDbatSUB
comment "Return V - B with candidates list, overflow causes NIL value";

pattern -(b1:bat[:sht],b2:bat[:hge]) :bat[:hge]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
pattern -(b1:bat[:sht],b2:bat[:hge],s:bat[:oid]) :bat[:hge]
address CMDbatSUBsignal
comment "Return B1 - B2 with candidates list, signal error on overflow";
pattern sub_noerror(b1:bat[:sht],b2:bat[:hge]) :bat[:hge]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern sub_noerror(b1:bat[:sht],b2:bat[:hge],s:bat[:oid]) :bat[:hge]
address CMDbatSUB
comment "Return B1 - B2 with candidates list, overflow causes NIL value";
pattern -(b:bat[:sht],v:hge) :bat[:hge]
address CMDbatSUBsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:sht],v:hge,s:bat[:oid]) :bat[:hge]
address CMDbatSUBsignal
comment "Return B - V with candidates list, signal error on overflow";
pattern sub_noerror(b:bat[:sht],v:hge) :bat[:hge]
address CMDbatSUB
comment "Return B - V, overflow causes NIL value";
pattern sub_noerror(b:bat[:sht],v:hge,s:bat[:oid]) :bat[:hge]
address CMDbatSUB
comment "Return B - V with candidates list, overflow causes NIL value";
pattern -(v:sht,b:bat[:hge]) :bat[:hge]
address CMDbatSUBsignal
comment "Return V - B, signal error on overflow";
pattern -(v:sht,b:bat[:hge],s:bat[:oid]) :bat[:hge]
address CMDbatSUBsignal
comment "Return V - B with candidates list, signal error on overflow";
pattern sub_noerror(v:sht,b:bat[:hge]) :bat[:hge]
address CMDbatSUB
comment "Return V - B, overflow causes NIL value";
pattern sub_noerror(v:sht,b:bat[:hge],s:bat[:oid]) :bat[:hge]
address CMDbatSUB
comment "Return V - B with candidates list, overflow causes NIL value";

pattern -(b1:bat[:int],b2:bat[:hge]) :bat[:hge]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
pattern -(b1:bat[:int],b2:bat[:hge],s:bat[:oid]) :bat[:hge]
address CMDbatSUBsignal
comment "Return B1 - B2 with candidates list, signal error on overflow";
pattern sub_noerror(b1:bat[:int],b2:bat[:hge]) :bat[:hge]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern sub_noerror(b1:bat[:int],b2:bat[:hge],s:bat[:oid]) :bat[:hge]
address CMDbatSUB
comment "Return B1 - B2 with candidates list, overflow causes NIL value";
pattern -(b:bat[:int],v:hge) :bat[:hge]
address CMDbatSUBsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:int],v:hge,s:bat[:oid]) :bat[:hge]
address CMDbatSUBsignal
comment "Return B - V with candidates list, signal error on overflow";
pattern sub_noerror(b:bat[:int],v:hge) :bat[:hge]
address CMDbatSUB
comment "Return B - V, overflow causes NIL value";
pattern sub_noerror(b:bat[:int],v:hge,s:bat[:oid]) :bat[:hge]
address CMDbatSUB
comment "Return B - V with candidates list, overflow causes NIL value";
pattern -(v:int,b:bat[:hge]) :bat[:hge]
address CMDbatSUBsignal
comment "Return V - B, signal error on overflow";
pattern -(v:int,b:bat[:hge],s:bat[:oid]) :bat[:hge]
address CMDbatSUBsignal
comment "Return V - B with candidates list, signal error on overflow";
pattern sub_noerror(v:int,b:bat[:hge]) :bat[:hge]
address CMDbatSUB
comment "Return V - B, overflow causes NIL value";
pattern sub_noerror(v:int,b:bat[:hge],s:bat[:oid]) :bat[:hge]
address CMDbatSUB
comment "Return V - B with candidates list, overflow causes NIL value";

pattern -(b1:bat[:lng],b2:bat[:hge]) :bat[:hge]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
pattern -(b1:bat[:lng],b2:bat[:hge],s:bat[:oid]) :bat[:hge]
address CMDbatSUBsignal
comment "Return B1 - B2 with candidates list, signal error on overflow";
pattern sub_noerror(b1:bat[:lng],b2:bat[:hge]) :bat[:hge]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern sub_noerror(b1:bat[:lng],b2:bat[:hge],s:bat[:oid]) :bat[:hge]
address CMDbatSUB
comment "Return B1 - B2 with candidates list, overflow causes NIL value";
pattern -(b:bat[:lng],v:hge) :bat[:hge]
address CMDbatSUBsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:lng],v:hge,s:bat[:oid]) :bat[:hge]
address CMDbatSUBsignal
comment "Return B - V with candidates list, signal error on overflow";
pattern sub_noerror(b:bat[:lng],v:hge) :bat[:hge]
address CMDbatSUB
comment "Return B - V, overflow causes NIL value";
pattern sub_noerror(b:bat[:lng],v:hge,s:bat[:oid]) :bat[:hge]
address CMDbatSUB
comment "Return B - V with candidates list, overflow causes NIL value";
pattern -(v:lng,b:bat[:hge]) :bat[:hge]
address CMDbatSUBsignal
comment "Return V - B, signal error on overflow";
pattern -(v:lng,b:bat[:hge],s:bat[:oid]) :bat[:hge]
address CMDbatSUBsignal
comment "Return V - B with candidates list, signal error on overflow";
pattern sub_noerror(v:lng,b:bat[:hge]) :bat[:hge]
address CMDbatSUB
comment "Return V - B, overflow causes NIL value";
pattern sub_noerror(v:lng,b:bat[:hge],s:bat[:oid]) :bat[:hge]
address CMDbatSUB
comment "Return V - B with candidates list, overflow causes NIL value";

pattern -(b1:bat[:hge],b2:bat[:bte]) :bat[:hge]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
pattern -(b1:bat[:hge],b2:bat[:bte],s:bat[:oid]) :bat[:hge]
address CMDbatSUBsignal
comment "Return B1 - B2 with candidates list, signal error on overflow";
pattern sub_noerror(b1:bat[:hge],b2:bat[:bte]) :bat[:hge]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern sub_noerror(b1:bat[:hge],b2:bat[:bte],s:bat[:oid]) :bat[:hge]
address CMDbatSUB
comment "Return B1 - B2 with candidates list, overflow causes NIL value";
pattern -(b:bat[:hge],v:bte) :bat[:hge]
address CMDbatSUBsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:hge],v:bte,s:bat[:oid]) :bat[:hge]
address CMDbatSUBsignal
comment "Return B - V with candidates list, signal error on overflow";
pattern sub_noerror(b:bat[:hge],v:bte) :bat[:hge]
address CMDbatSUB
comment "Return B - V, overflow causes NIL value";
pattern sub_noerror(b:bat[:hge],v:bte,s:bat[:oid]) :bat[:hge]
address CMDbatSUB
comment "Return B - V with candidates list, overflow causes NIL value";
pattern -(v:hge,b:bat[:bte]) :bat[:hge]
address CMDbatSUBsignal
comment "Return V - B, signal error on overflow";
pattern -(v:hge,b:bat[:bte],s:bat[:oid]) :bat[:hge]
address CMDbatSUBsignal
comment "Return V - B with candidates list, signal error on overflow";
pattern sub_noerror(v:hge,b:bat[:bte]) :bat[:hge]
address CMDbatSUB
comment "Return V - B, overflow causes NIL value";
pattern sub_noerror(v:hge,b:bat[:bte],s:bat[:oid]) :bat[:hge]
address CMDbatSUB
comment "Return V - B with candidates list, overflow causes NIL value";

pattern -(b1:bat[:hge],b2:bat[:sht]) :bat[:hge]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
pattern -(b1:bat[:hge],b2:bat[:sht],s:bat[:oid]) :bat[:hge]
address CMDbatSUBsignal
comment "Return B1 - B2 with candidates list, signal error on overflow";
pattern sub_noerror(b1:bat[:hge],b2:bat[:sht]) :bat[:hge]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern sub_noerror(b1:bat[:hge],b2:bat[:sht],s:bat[:oid]) :bat[:hge]
address CMDbatSUB
comment "Return B1 - B2 with candidates list, overflow causes NIL value";
pattern -(b:bat[:hge],v:sht) :bat[:hge]
address CMDbatSUBsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:hge],v:sht,s:bat[:oid]) :bat[:hge]
address CMDbatSUBsignal
comment "Return B - V with candidates list, signal error on overflow";
pattern sub_noerror(b:bat[:hge],v:sht) :bat[:hge]
address CMDbatSUB
comment "Return B - V, overflow causes NIL value";
pattern sub_noerror(b:bat[:hge],v:sht,s:bat[:oid]) :bat[:hge]
address CMDbatSUB
comment "Return B - V with candidates list, overflow causes NIL value";
pattern -(v:hge,b:bat[:sht]) :bat[:hge]
address CMDbatSUBsignal
comment "Return V - B, signal error on overflow";
pattern -(v:hge,b:bat[:sht],s:bat[:oid]) :bat[:hge]
address CMDbatSUBsignal
comment "Return V - B with candidates list, signal error on overflow";
pattern sub_noerror(v:hge,b:bat[:sht]) :bat[:hge]
address CMDbatSUB
comment "Return V - B, overflow causes NIL value";
pattern sub_noerror(v:hge,b:bat[:sht],s:bat[:oid]) :bat[:hge]
address CMDbatSUB
comment "Return V - B with candidates list, overflow causes NIL value";

pattern -(b1:bat[:hge],b2:bat[:int]) :bat[:hge]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
pattern -(b1:bat[:hge],b2:bat[:int],s:bat[:oid]) :bat[:hge]
address CMDbatSUBsignal
comment "Return B1 - B2 with candidates list, signal error on overflow";
pattern sub_noerror(b1:bat[:hge],b2:bat[:int]) :bat[:hge]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern sub_noerror(b1:bat[:hge],b2:bat[:int],s:bat[:oid]) :bat[:hge]
address CMDbatSUB
comment "Return B1 - B2 with candidates list, overflow causes NIL value";
pattern -(b:bat[:hge],v:int) :bat[:hge]
address CMDbatSUBsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:hge],v:int,s:bat[:oid]) :bat[:hge]
address CMDbatSUBsignal
comment "Return B - V with candidates list, signal error on overflow";
pattern sub_noerror(b:bat[:hge],v:int) :bat[:hge]
address CMDbatSUB
comment "Return B - V, overflow causes NIL value";
pattern sub_noerror(b:bat[:hge],v:int,s:bat[:oid]) :bat[:hge]
address CMDbatSUB
comment "Return B - V with candidates list, overflow causes NIL value";
pattern -(v:hge,b:bat[:int]) :bat[:hge]
address CMDbatSUBsignal
comment "Return V - B, signal error on overflow";
pattern -(v:hge,b:bat[:int],s:bat[:oid]) :bat[:hge]
address CMDbatSUBsignal
comment "Return V - B with candidates list, signal error on overflow";
pattern sub_noerror(v:hge,b:bat[:int]) :bat[:hge]
address CMDbatSUB
comment "Return V - B, overflow causes NIL value";
pattern sub_noerror(v:hge,b:bat[:int],s:bat[:oid]) :bat[:hge]
address CMDbatSUB
comment "Return V - B with candidates list, overflow causes NIL value";

pattern -(b1:bat[:hge],b2:bat[:lng]) :bat[:hge]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
pattern -(b1:bat[:hge],b2:bat[:lng],s:bat[:oid]) :bat[:hge]
address CMDbatSUBsignal
comment "Return B1 - B2 with candidates list, signal error on overflow";
pattern sub_noerror(b1:bat[:hge],b2:bat[:lng]) :bat[:hge]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern sub_noerror(b1:bat[:hge],b2:bat[:lng],s:bat[:oid]) :bat[:hge]
address CMDbatSUB
comment "Return B1 - B2 with candidates list, overflow causes NIL value";
pattern -(b:bat[:hge],v:lng) :bat[:hge]
address CMDbatSUBsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:hge],v:lng,s:bat[:oid]) :bat[:hge]
address CMDbatSUBsignal
comment "Return B - V with candidates list, signal error on overflow";
pattern sub_noerror(b:bat[:hge],v:lng) :bat[:hge]
address CMDbatSUB
comment "Return B - V, overflow causes NIL value";
pattern sub_noerror(b:bat[:hge],v:lng,s:bat[:oid]) :bat[:hge]
address CMDbatSUB
comment "Return B - V with candidates list, overflow causes NIL value";
pattern -(v:hge,b:bat[:lng]) :bat[:hge]
address CMDbatSUBsignal
comment "Return V - B, signal error on overflow";
pattern -(v:hge,b:bat[:lng],s:bat[:oid]) :bat[:hge]
address CMDbatSUBsignal
comment "Return V - B with candidates list, signal error on overflow";
pattern sub_noerror(v:hge,b:bat[:lng]) :bat[:hge]
address CMDbatSUB
comment "Return V - B, overflow causes NIL value";
pattern sub_noerror(v:hge,b:bat[:lng],s:bat[:oid]) :bat[:hge]
address CMDbatSUB
comment "Return V - B with candidates list, overflow causes NIL value";

pattern -(b1:bat[:hge],b2:bat[:hge]) :bat[:hge]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
pattern -(b1:bat[:hge],b2:bat[:hge],s:bat[:oid]) :bat[:hge]
address CMDbatSUBsignal
comment "Return B1 - B2 with candidates list, signal error on overflow";
pattern sub_noerror(b1:bat[:hge],b2:bat[:hge]) :bat[:hge]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern sub_noerror(b1:bat[:hge],b2:bat[:hge],s:bat[:oid]) :bat[:hge]
address CMDbatSUB
comment "Return B1 - B2 with candidates list, overflow causes NIL value";
pattern -(b:bat[:hge],v:hge) :bat[:hge]
address CMDbatSUBsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:hge],v:hge,s:bat[:oid]) :bat[:hge]
address CMDbatSUBsignal
comment "Return B - V with candidates list, signal error on overflow";
pattern sub_noerror(b:bat[:hge],v:hge) :bat[:hge]
address CMDbatSUB
comment "Return B - V, overflow causes NIL value";
pattern sub_noerror(b:bat[:hge],v:hge,s:bat[:oid]) :bat[:hge]
address CMDbatSUB
comment "Return B - V with candidates list, overflow causes NIL value";
pattern -(v:hge,b:bat[:hge]) :bat[:hge]
address CMDbatSUBsignal
comment "Return V - B, signal error on overflow";
pattern -(v:hge,b:bat[:hge],s:bat[:oid]) :bat[:hge]
address CMDbatSUBsignal
comment "Return V - B with candidates list, signal error on overflow";
pattern sub_noerror(v:hge,b:bat[:hge]) :bat[:hge]
address CMDbatSUB
comment "Return V - B, overflow causes NIL value";
pattern sub_noerror(v:hge,b:bat[:hge],s:bat[:oid]) :bat[:hge]
address CMDbatSUB
comment "Return V - B with candidates list, overflow causes NIL value";

pattern -(b1:bat[:hge],b2:bat[:flt]) :bat[:flt]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
pattern -(b1:bat[:hge],b2:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatSUBsignal
comment "Return B1 - B2 with candidates list, signal error on overflow";
pattern sub_noerror(b1:bat[:hge],b2:bat[:flt]) :bat[:flt]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern sub_noerror(b1:bat[:hge],b2:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatSUB
comment "Return B1 - B2 with candidates list, overflow causes NIL value";
pattern -(b:bat[:hge],v:flt) :bat[:flt]
address CMDbatSUBsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:hge],v:flt,s:bat[:oid]) :bat[:flt]
address CMDbatSUBsignal
comment "Return B - V with candidates list, signal error on overflow";
pattern sub_noerror(b:bat[:hge],v:flt) :bat[:flt]
address CMDbatSUB
comment "Return B - V, overflow causes NIL value";
pattern sub_noerror(b:bat[:hge],v:flt,s:bat[:oid]) :bat[:flt]
address CMDbatSUB
comment "Return B - V with candidates list, overflow causes NIL value";
pattern -(v:hge,b:bat[:flt]) :bat[:flt]
address CMDbatSUBsignal
comment "Return V - B, signal error on overflow";
pattern -(v:hge,b:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatSUBsignal
comment "Return V - B with candidates list, signal error on overflow";
pattern sub_noerror(v:hge,b:bat[:flt]) :bat[:flt]
address CMDbatSUB
comment "Return V - B, overflow causes NIL value";
pattern sub_noerror(v:hge,b:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatSUB
comment "Return V - B with candidates list, overflow causes NIL value";

pattern -(b1:bat[:hge],b2:bat[:dbl]) :bat[:dbl]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
pattern -(b1:bat[:hge],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatSUBsignal
comment "Return B1 - B2 with candidates list, signal error on overflow";
pattern sub_noerror(b1:bat[:hge],b2:bat[:dbl]) :bat[:dbl]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern sub_noerror(b1:bat[:hge],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatSUB
comment "Return B1 - B2 with candidates list, overflow causes NIL value";
pattern -(b:bat[:hge],v:dbl) :bat[:dbl]
address CMDbatSUBsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:hge],v:dbl,s:bat[:oid]) :bat[:dbl]
address CMDbatSUBsignal
comment "Return B - V with candidates list, signal error on overflow";
pattern sub_noerror(b:bat[:hge],v:dbl) :bat[:dbl]
address CMDbatSUB
comment "Return B - V, overflow causes NIL value";
pattern sub_noerror(b:bat[:hge],v:dbl,s:bat[:oid]) :bat[:dbl]
address CMDbatSUB
comment "Return B - V with candidates list, overflow causes NIL value";
pattern -(v:hge,b:bat[:dbl]) :bat[:dbl]
address CMDbatSUBsignal
comment "Return V - B, signal error on overflow";
pattern -(v:hge,b:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatSUBsignal
comment "Return V - B with candidates list, signal error on overflow";
pattern sub_noerror(v:hge,b:bat[:dbl]) :bat[:dbl]
address CMDbatSUB
comment "Return V - B, overflow causes NIL value";
pattern sub_noerror(v:hge,b:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatSUB
comment "Return V - B with candidates list, overflow causes NIL value";

pattern -(b1:bat[:flt],b2:bat[:hge]) :bat[:flt]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
pattern -(b1:bat[:flt],b2:bat[:hge],s:bat[:oid]) :bat[:flt]
address CMDbatSUBsignal
comment "Return B1 - B2 with candidates list, signal error on overflow";
pattern sub_noerror(b1:bat[:flt],b2:bat[:hge]) :bat[:flt]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern sub_noerror(b1:bat[:flt],b2:bat[:hge],s:bat[:oid]) :bat[:flt]
address CMDbatSUB
comment "Return B1 - B2 with candidates list, overflow causes NIL value";
pattern -(b:bat[:flt],v:hge) :bat[:flt]
address CMDbatSUBsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:flt],v:hge,s:bat[:oid]) :bat[:flt]
address CMDbatSUBsignal
comment "Return B - V with candidates list, signal error on overflow";
pattern sub_noerror(b:bat[:flt],v:hge) :bat[:flt]
address CMDbatSUB
comment "Return B - V, overflow causes NIL value";
pattern sub_noerror(b:bat[:flt],v:hge,s:bat[:oid]) :bat[:flt]
address CMDbatSUB
comment "Return B - V with candidates list, overflow causes NIL value";
pattern -(v:flt,b:bat[:hge]) :bat[:flt]
address CMDbatSUBsignal
comment "Return V - B, signal error on overflow";
pattern -(v:flt,b:bat[:hge],s:bat[:oid]) :bat[:flt]
address CMDbatSUBsignal
comment "Return V - B with candidates list, signal error on overflow";
pattern sub_noerror(v:flt,b:bat[:hge]) :bat[:flt]
address CMDbatSUB
comment "Return V - B, overflow causes NIL value";
pattern sub_noerror(v:flt,b:bat[:hge],s:bat[:oid]) :bat[:flt]
address CMDbatSUB
comment "Return V - B with candidates list, overflow causes NIL value";

pattern -(b1:bat[:dbl],b2:bat[:hge]) :bat[:dbl]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
pattern -(b1:bat[:dbl],b2:bat[:hge],s:bat[:oid]) :bat[:dbl]
address CMDbatSUBsignal
comment "Return B1 - B2 with candidates list, signal error on overflow";
pattern sub_noerror(b1:bat[:dbl],b2:bat[:hge]) :bat[:dbl]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern sub_noerror(b1:bat[:dbl],b2:bat[:hge],s:bat[:oid]) :bat[:dbl]
address CMDbatSUB
comment "Return B1 - B2 with candidates list, overflow causes NIL value";
pattern -(b:bat[:dbl],v:hge) :bat[:dbl]
address CMDbatSUBsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:dbl],v:hge,s:bat[:oid]) :bat[:dbl]
address CMDbatSUBsignal
comment "Return B - V with candidates list, signal error on overflow";
pattern sub_noerror(b:bat[:dbl],v:hge) :bat[:dbl]
address CMDbatSUB
comment "Return B - V, overflow causes NIL value";
pattern sub_noerror(b:bat[:dbl],v:hge,s:bat[:oid]) :bat[:dbl]
address CMDbatSUB
comment "Return B - V with candidates list, overflow causes NIL value";
pattern -(v:dbl,b:bat[:hge]) :bat[:dbl]
address CMDbatSUBsignal
comment "Return V - B, signal error on overflow";
pattern -(v:dbl,b:bat[:hge],s:bat[:oid]) :bat[:dbl]
address CMDbatSUBsignal
comment "Return V - B with candidates list, signal error on overflow";
pattern sub_noerror(v:dbl,b:bat[:hge]) :bat[:dbl]
address CMDbatSUB
comment "Return V - B, overflow causes NIL value";
pattern sub_noerror(v:dbl,b:bat[:hge],s:bat[:oid]) :bat[:dbl]
address CMDbatSUB
comment "Return V - B with candidates list, overflow causes NIL value";


pattern *(b1:bat[:bte],b2:bat[:hge]) :bat[:hge]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
pattern *(b1:bat[:bte],b2:bat[:hge],s:bat[:oid]) :bat[:hge]
address CMDbatMULsignal
comment "Return B1 * B2 with candidates list, signal error on overflow";
pattern mul_noerror(b1:bat[:bte],b2:bat[:hge]) :bat[:hge]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern mul_noerror(b1:bat[:bte],b2:bat[:hge],s:bat[:oid]) :bat[:hge]
address CMDbatMUL
comment "Return B1 * B2 with candidates list, overflow causes NIL value";
pattern *(b:bat[:bte],v:hge) :bat[:hge]
address CMDbatMULsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:bte],v:hge,s:bat[:oid]) :bat[:hge]
address CMDbatMULsignal
comment "Return B * V with candidates list, signal error on overflow";
pattern mul_noerror(b:bat[:bte],v:hge) :bat[:hge]
address CMDbatMUL
comment "Return B * V, overflow causes NIL value";
pattern mul_noerror(b:bat[:bte],v:hge,s:bat[:oid]) :bat[:hge]
address CMDbatMUL
comment "Return B * V with candidates list, overflow causes NIL value";
pattern *(v:bte,b:bat[:hge]) :bat[:hge]
address CMDbatMULsignal
comment "Return V * B, signal error on overflow";
pattern *(v:bte,b:bat[:hge],s:bat[:oid]) :bat[:hge]
address CMDbatMULsignal
comment "Return V * B with candidates list, signal error on overflow";
pattern mul_noerror(v:bte,b:bat[:hge]) :bat[:hge]
address CMDbatMUL
comment "Return V * B, overflow causes NIL value";
pattern mul_noerror(v:bte,b:bat[:hge],s:bat[:oid]) :bat[:hge]
address CMDbatMUL
comment "Return V * B with candidates list, overflow causes NIL value";

pattern *(b1:bat[:sht],b2:bat[:hge]) :bat[:hge]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
pattern *(b1:bat[:sht],b2:bat[:hge],s:bat[:oid]) :bat[:hge]
address CMDbatMULsignal
comment "Return B1 * B2 with candidates list, signal error on overflow";
pattern mul_noerror(b1:bat[:sht],b2:bat[:hge]) :bat[:hge]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern mul_noerror(b1:bat[:sht],b2:bat[:hge],s:bat[:oid]) :bat[:hge]
address CMDbatMUL
comment "Return B1 * B2 with candidates list, overflow causes NIL value";
pattern *(b:bat[:sht],v:hge) :bat[:hge]
address CMDbatMULsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:sht],v:hge,s:bat[:oid]) :bat[:hge]
address CMDbatMULsignal
comment "Return B * V with candidates list, signal error on overflow";
pattern mul_noerror(b:bat[:sht],v:hge) :bat[:hge]
address CMDbatMUL
comment "Return B * V, overflow causes NIL value";
pattern mul_noerror(b:bat[:sht],v:hge,s:bat[:oid]) :bat[:hge]
address CMDbatMUL
comment "Return B * V with candidates list, overflow causes NIL value";
pattern *(v:sht,b:bat[:hge]) :bat[:hge]
address CMDbatMULsignal
comment "Return V * B, signal error on overflow";
pattern *(v:sht,b:bat[:hge],s:bat[:oid]) :bat[:hge]
address CMDbatMULsignal
comment "Return V * B with candidates list, signal error on overflow";
pattern mul_noerror(v:sht,b:bat[:hge]) :bat[:hge]
address CMDbatMUL
comment "Return V * B, overflow causes NIL value";
pattern mul_noerror(v:sht,b:bat[:hge],s:bat[:oid]) :bat[:hge]
address CMDbatMUL
comment "Return V * B with candidates list, overflow causes NIL value";

pattern *(b1:bat[:int],b2:bat[:hge]) :bat[:hge]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
pattern *(b1:bat[:int],b2:bat[:hge],s:bat[:oid]) :bat[:hge]
address CMDbatMULsignal
comment "Return B1 * B2 with candidates list, signal error on overflow";
pattern mul_noerror(b1:bat[:int],b2:bat[:hge]) :bat[:hge]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern mul_noerror(b1:bat[:int],b2:bat[:hge],s:bat[:oid]) :bat[:hge]
address CMDbatMUL
comment "Return B1 * B2 with candidates list, overflow causes NIL value";
pattern *(b:bat[:int],v:hge) :bat[:hge]
address CMDbatMULsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:int],v:hge,s:bat[:oid]) :bat[:hge]
address CMDbatMULsignal
comment "Return B * V with candidates list, signal error on overflow";
pattern mul_noerror(b:bat[:int],v:hge) :bat[:hge]
address CMDbatMUL
comment "Return B * V, overflow causes NIL value";
pattern mul_noerror(b:bat[:int],v:hge,s:bat[:oid]) :bat[:hge]
address CMDbatMUL
comment "Return B * V with candidates list, overflow causes NIL value";
pattern *(v:int,b:bat[:hge]) :bat[:hge]
address CMDbatMULsignal
comment "Return V * B, signal error on overflow";
pattern *(v:int,b:bat[:hge],s:bat[:oid]) :bat[:hge]
address CMDbatMULsignal
comment "Return V * B with candidates list, signal error on overflow";
pattern mul_noerror(v:int,b:bat[:hge]) :bat[:hge]
address CMDbatMUL
comment "Return V * B, overflow causes NIL value";
pattern mul_noerror(v:int,b:bat[:hge],s:bat[:oid]) :bat[:hge]
address CMDbatMUL
comment "Return V * B with candidates list, overflow causes NIL value";

pattern *(b1:bat[:lng],b2:bat[:hge]) :bat[:hge]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
pattern *(b1:bat[:lng],b2:bat[:hge],s:bat[:oid]) :bat[:hge]
address CMDbatMULsignal
comment "Return B1 * B2 with candidates list, signal error on overflow";
pattern mul_noerror(b1:bat[:lng],b2:bat[:hge]) :bat[:hge]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern mul_noerror(b1:bat[:lng],b2:bat[:hge],s:bat[:oid]) :bat[:hge]
address CMDbatMUL
comment "Return B1 * B2 with candidates list, overflow causes NIL value";
pattern *(b:bat[:lng],v:hge) :bat[:hge]
address CMDbatMULsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:lng],v:hge,s:bat[:oid]) :bat[:hge]
address CMDbatMULsignal
comment "Return B * V with candidates list, signal error on overflow";
pattern mul_noerror(b:bat[:lng],v:hge) :bat[:hge]
address CMDbatMUL
comment "Return B * V, overflow causes NIL value";
pattern mul_noerror(b:bat[:lng],v:hge,s:bat[:oid]) :bat[:hge]
address CMDbatMUL
comment "Return B * V with candidates list, overflow causes NIL value";
pattern *(v:lng,b:bat[:hge]) :bat[:hge]
address CMDbatMULsignal
comment "Return V * B, signal error on overflow";
pattern *(v:lng,b:bat[:hge],s:bat[:oid]) :bat[:hge]
address CMDbatMULsignal
comment "Return V * B with candidates list, signal error on overflow";
pattern mul_noerror(v:lng,b:bat[:hge]) :bat[:hge]
address CMDbatMUL
comment "Return V * B, overflow causes NIL value";
pattern mul_noerror(v:lng,b:bat[:hge],s:bat[:oid]) :bat[:hge]
address CMDbatMUL
comment "Return V * B with candidates list, overflow causes NIL value";

pattern *(b1:bat[:hge],b2:bat[:bte]) :bat[:hge]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
pattern *(b1:bat[:hge],b2:bat[:bte],s:bat[:oid]) :bat[:hge]
address CMDbatMULsignal
comment "Return B1 * B2 with candidates list, signal error on overflow";
pattern mul_noerror(b1:bat[:hge],b2:bat[:bte]) :bat[:hge]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern mul_noerror(b1:bat[:hge],b2:bat[:bte],s:bat[:oid]) :bat[:hge]
address CMDbatMUL
comment "Return B1 * B2 with candidates list, overflow causes NIL value";
pattern *(b:bat[:hge],v:bte) :bat[:hge]
address CMDbatMULsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:hge],v:bte,s:bat[:oid]) :bat[:hge]
address CMDbatMULsignal
comment "Return B * V with candidates list, signal error on overflow";
pattern mul_noerror(b:bat[:hge],v:bte) :bat[:hge]
address CMDbatMUL
comment "Return B * V, overflow causes NIL value";
pattern mul_noerror(b:bat[:hge],v:bte,s:bat[:oid]) :bat[:hge]
address CMDbatMUL
comment "Return B * V with candidates list, overflow causes NIL value";
pattern *(v:hge,b:bat[:bte]) :bat[:hge]
address CMDbatMULsignal
comment "Return V * B, signal error on overflow";
pattern *(v:hge,b:bat[:bte],s:bat[:oid]) :bat[:hge]
address CMDbatMULsignal
comment "Return V * B with candidates list, signal error on overflow";
pattern mul_noerror(v:hge,b:bat[:bte]) :bat[:hge]
address CMDbatMUL
comment "Return V * B, overflow causes NIL value";
pattern mul_noerror(v:hge,b:bat[:bte],s:bat[:oid]) :bat[:hge]
address CMDbatMUL
comment "Return V * B with candidates list, overflow causes NIL value";

pattern *(b1:bat[:hge],b2:bat[:sht]) :bat[:hge]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
pattern *(b1:bat[:hge],b2:bat[:sht],s:bat[:oid]) :bat[:hge]
address CMDbatMULsignal
comment "Return B1 * B2 with candidates list, signal error on overflow";
pattern mul_noerror(b1:bat[:hge],b2:bat[:sht]) :bat[:hge]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern mul_noerror(b1:bat[:hge],b2:bat[:sht],s:bat[:oid]) :bat[:hge]
address CMDbatMUL
comment "Return B1 * B2 with candidates list, overflow causes NIL value";
pattern *(b:bat[:hge],v:sht) :bat[:hge]
address CMDbatMULsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:hge],v:sht,s:bat[:oid]) :bat[:hge]
address CMDbatMULsignal
comment "Return B * V with candidates list, signal error on overflow";
pattern mul_noerror(b:bat[:hge],v:sht) :bat[:hge]
address CMDbatMUL
comment "Return B * V, overflow causes NIL value";
pattern mul_noerror(b:bat[:hge],v:sht,s:bat[:oid]) :bat[:hge]
address CMDbatMUL
comment "Return B * V with candidates list, overflow causes NIL value";
pattern *(v:hge,b:bat[:sht]) :bat[:hge]
address CMDbatMULsignal
comment "Return V * B, signal error on overflow";
pattern *(v:hge,b:bat[:sht],s:bat[:oid]) :bat[:hge]
address CMDbatMULsignal
comment "Return V * B with candidates list, signal error on overflow";
pattern mul_noerror(v:hge,b:bat[:sht]) :bat[:hge]
address CMDbatMUL
comment "Return V * B, overflow causes NIL value";
pattern mul_noerror(v:hge,b:bat[:sht],s:bat[:oid]) :bat[:hge]
address CMDbatMUL
comment "Return V * B with candidates list, overflow causes NIL value";

pattern *(b1:bat[:hge],b2:bat[:int]) :bat[:hge]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
pattern *(b1:bat[:hge],b2:bat[:int],s:bat[:oid]) :bat[:hge]
address CMDbatMULsignal
comment "Return B1 * B2 with candidates list, signal error on overflow";
pattern mul_noerror(b1:bat[:hge],b2:bat[:int]) :bat[:hge]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern mul_noerror(b1:bat[:hge],b2:bat[:int],s:bat[:oid]) :bat[:hge]
address CMDbatMUL
comment "Return B1 * B2 with candidates list, overflow causes NIL value";
pattern *(b:bat[:hge],v:int) :bat[:hge]
address CMDbatMULsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:hge],v:int,s:bat[:oid]) :bat[:hge]
address CMDbatMULsignal
comment "Return B * V with candidates list, signal error on overflow";
pattern mul_noerror(b:bat[:hge],v:int) :bat[:hge]
address CMDbatMUL
comment "Return B * V, overflow causes NIL value";
pattern mul_noerror(b:bat[:hge],v:int,s:bat[:oid]) :bat[:hge]
address CMDbatMUL
comment "Return B * V with candidates list, overflow causes NIL value";
pattern *(v:hge,b:bat[:int]) :bat[:hge]
address CMDbatMULsignal
comment "Return V * B, signal error on overflow";
pattern *(v:hge,b:bat[:int],s:bat[:oid]) :bat[:hge]
address CMDbatMULsignal
comment "Return V * B with candidates list, signal error on overflow";
pattern mul_noerror(v:hge,b:bat[:int]) :bat[:hge]
address CMDbatMUL
comment "Return V * B, overflow causes NIL value";
pattern mul_noerror(v:hge,b:bat[:int],s:bat[:oid]) :bat[:hge]
address CMDbatMUL
comment "Return V * B with candidates list, overflow causes NIL value";

pattern *(b1:bat[:hge],b2:bat[:lng]) :bat[:hge]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
pattern *(b1:bat[:hge],b2:bat[:lng],s:bat[:oid]) :bat[:hge]
address CMDbatMULsignal
comment "Return B1 * B2 with candidates list, signal error on overflow";
pattern mul_noerror(b1:bat[:hge],b2:bat[:lng]) :bat[:hge]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern mul_noerror(b1:bat[:hge],b2:bat[:lng],s:bat[:oid]) :bat[:hge]
address CMDbatMUL
comment "Return B1 * B2 with candidates list, overflow causes NIL value";
pattern *(b:bat[:hge],v:lng) :bat[:hge]
address CMDbatMULsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:hge],v:lng,s:bat[:oid]) :bat[:hge]
address CMDbatMULsignal
comment "Return B * V with candidates list, signal error on overflow";
pattern mul_noerror(b:bat[:hge],v:lng) :bat[:hge]
address CMDbatMUL
comment "Return B * V, overflow causes NIL value";
pattern mul_noerror(b:bat[:hge],v:lng,s:bat[:oid]) :bat[:hge]
address CMDbatMUL
comment "Return B * V with candidates list, overflow causes NIL value";
pattern *(v:hge,b:bat[:lng]) :bat[:hge]
address CMDbatMULsignal
comment "Return V * B, signal error on overflow";
pattern *(v:hge,b:bat[:lng],s:bat[:oid]) :bat[:hge]
address CMDbatMULsignal
comment "Return V * B with candidates list, signal error on overflow";
pattern mul_noerror(v:hge,b:bat[:lng]) :bat[:hge]
address CMDbatMUL
comment "Return V * B, overflow causes NIL value";
pattern mul_noerror(v:hge,b:bat[:lng],s:bat[:oid]) :bat[:hge]
address CMDbatMUL
comment "Return V * B with candidates list, overflow causes NIL value";

pattern *(b1:bat[:hge],b2:bat[:hge]) :bat[:hge]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
pattern *(b1:bat[:hge],b2:bat[:hge],s:bat[:oid]) :bat[:hge]
address CMDbatMULsignal
comment "Return B1 * B2 with candidates list, signal error on overflow";
pattern mul_noerror(b1:bat[:hge],b2:bat[:hge]) :bat[:hge]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern mul_noerror(b1:bat[:hge],b2:bat[:hge],s:bat[:oid]) :bat[:hge]
address CMDbatMUL
comment "Return B1 * B2 with candidates list, overflow causes NIL value";
pattern *(b:bat[:hge],v:hge) :bat[:hge]
address CMDbatMULsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:hge],v:hge,s:bat[:oid]) :bat[:hge]
address CMDbatMULsignal
comment "Return B * V with candidates list, signal error on overflow";
pattern mul_noerror(b:bat[:hge],v:hge) :bat[:hge]
address CMDbatMUL
comment "Return B * V, overflow causes NIL value";
pattern mul_noerror(b:bat[:hge],v:hge,s:bat[:oid]) :bat[:hge]
address CMDbatMUL
comment "Return B * V with candidates list, overflow causes NIL value";
pattern *(v:hge,b:bat[:hge]) :bat[:hge]
address CMDbatMULsignal
comment "Return V * B, signal error on overflow";
pattern *(v:hge,b:bat[:hge],s:bat[:oid]) :bat[:hge]
address CMDbatMULsignal
comment "Return V * B with candidates list, signal error on overflow";
pattern mul_noerror(v:hge,b:bat[:hge]) :bat[:hge]
address CMDbatMUL
comment "Return V * B, overflow causes NIL value";
pattern mul_noerror(v:hge,b:bat[:hge],s:bat[:oid]) :bat[:hge]
address CMDbatMUL
comment "Return V * B with candidates list, overflow causes NIL value";

pattern *(b1:bat[:hge],b2:bat[:flt]) :bat[:flt]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
pattern *(b1:bat[:hge],b2:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatMULsignal
comment "Return B1 * B2 with candidates list, signal error on overflow";
pattern mul_noerror(b1:bat[:hge],b2:bat[:flt]) :bat[:flt]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern mul_noerror(b1:bat[:hge],b2:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatMUL
comment "Return B1 * B2 with candidates list, overflow causes NIL value";
pattern *(b:bat[:hge],v:flt) :bat[:flt]
address CMDbatMULsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:hge],v:flt,s:bat[:oid]) :bat[:flt]
address CMDbatMULsignal
comment "Return B * V with candidates list, signal error on overflow";
pattern mul_noerror(b:bat[:hge],v:flt) :bat[:flt]
address CMDbatMUL
comment "Return B * V, overflow causes NIL value";
pattern mul_noerror(b:bat[:hge],v:flt,s:bat[:oid]) :bat[:flt]
address CMDbatMUL
comment "Return B * V with candidates list, overflow causes NIL value";
pattern *(v:hge,b:bat[:flt]) :bat[:flt]
address CMDbatMULsignal
comment "Return V * B, signal error on overflow";
pattern *(v:hge,b:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatMULsignal
comment "Return V * B with candidates list, signal error on overflow";
pattern mul_noerror(v:hge,b:bat[:flt]) :bat[:flt]
address CMDbatMUL
comment "Return V * B, overflow causes NIL value";
pattern mul_noerror(v:hge,b:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatMUL
comment "Return V * B with candidates list, overflow causes NIL value";

pattern *(b1:bat[:hge],b2:bat[:dbl]) :bat[:dbl]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
pattern *(b1:bat[:hge],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatMULsignal
comment "Return B1 * B2 with candidates list, signal error on overflow";
pattern mul_noerror(b1:bat[:hge],b2:bat[:dbl]) :bat[:dbl]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern mul_noerror(b1:bat[:hge],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatMUL
comment "Return B1 * B2 with candidates list, overflow causes NIL value";
pattern *(b:bat[:hge],v:dbl) :bat[:dbl]
address CMDbatMULsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:hge],v:dbl,s:bat[:oid]) :bat[:dbl]
address CMDbatMULsignal
comment "Return B * V with candidates list, signal error on overflow";
pattern mul_noerror(b:bat[:hge],v:dbl) :bat[:dbl]
address CMDbatMUL
comment "Return B * V, overflow causes NIL value";
pattern mul_noerror(b:bat[:hge],v:dbl,s:bat[:oid]) :bat[:dbl]
address CMDbatMUL
comment "Return B * V with candidates list, overflow causes NIL value";
pattern *(v:hge,b:bat[:dbl]) :bat[:dbl]
address CMDbatMULsignal
comment "Return V * B, signal error on overflow";
pattern *(v:hge,b:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatMULsignal
comment "Return V * B with candidates list, signal error on overflow";
pattern mul_noerror(v:hge,b:bat[:dbl]) :bat[:dbl]
address CMDbatMUL
comment "Return V * B, overflow causes NIL value";
pattern mul_noerror(v:hge,b:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatMUL
comment "Return V * B with candidates list, overflow causes NIL value";

pattern *(b1:bat[:flt],b2:bat[:hge]) :bat[:flt]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
pattern *(b1:bat[:flt],b2:bat[:hge],s:bat[:oid]) :bat[:flt]
address CMDbatMULsignal
comment "Return B1 * B2 with candidates list, signal error on overflow";
pattern mul_noerror(b1:bat[:flt],b2:bat[:hge]) :bat[:flt]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern mul_noerror(b1:bat[:flt],b2:bat[:hge],s:bat[:oid]) :bat[:flt]
address CMDbatMUL
comment "Return B1 * B2 with candidates list, overflow causes NIL value";
pattern *(b:bat[:flt],v:hge) :bat[:flt]
address CMDbatMULsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:flt],v:hge,s:bat[:oid]) :bat[:flt]
address CMDbatMULsignal
comment "Return B * V with candidates list, signal error on overflow";
pattern mul_noerror(b:bat[:flt],v:hge) :bat[:flt]
address CMDbatMUL
comment "Return B * V, overflow causes NIL value";
pattern mul_noerror(b:bat[:flt],v:hge,s:bat[:oid]) :bat[:flt]
address CMDbatMUL
comment "Return B * V with candidates list, overflow causes NIL value";
pattern *(v:flt,b:bat[:hge]) :bat[:flt]
address CMDbatMULsignal
comment "Return V * B, signal error on overflow";
pattern *(v:flt,b:bat[:hge],s:bat[:oid]) :bat[:flt]
address CMDbatMULsignal
comment "Return V * B with candidates list, signal error on overflow";
pattern mul_noerror(v:flt,b:bat[:hge]) :bat[:flt]
address CMDbatMUL
comment "Return V * B, overflow causes NIL value";
pattern mul_noerror(v:flt,b:bat[:hge],s:bat[:oid]) :bat[:flt]
address CMDbatMUL
comment "Return V * B with candidates list, overflow causes NIL value";

pattern *(b1:bat[:dbl],b2:bat[:hge]) :bat[:dbl]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
pattern *(b1:bat[:dbl],b2:bat[:hge],s:bat[:oid]) :bat[:dbl]
address CMDbatMULsignal
comment "Return B1 * B2 with candidates list, signal error on overflow";
pattern mul_noerror(b1:bat[:dbl],b2:bat[:hge]) :bat[:dbl]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern mul_noerror(b1:bat[:dbl],b2:bat[:hge],s:bat[:oid]) :bat[:dbl]
address CMDbatMUL
comment "Return B1 * B2 with candidates list, overflow causes NIL value";
pattern *(b:bat[:dbl],v:hge) :bat[:dbl]
address CMDbatMULsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:dbl],v:hge,s:bat[:oid]) :bat[:dbl]
address CMDbatMULsignal
comment "Return B * V with candidates list, signal error on overflow";
pattern mul_noerror(b:bat[:dbl],v:hge) :bat[:dbl]
address CMDbatMUL
comment "Return B * V, overflow causes NIL value";
pattern mul_noerror(b:bat[:dbl],v:hge,s:bat[:oid]) :bat[:dbl]
address CMDbatMUL
comment "Return B * V with candidates list, overflow causes NIL value";
pattern *(v:dbl,b:bat[:hge]) :bat[:dbl]
address CMDbatMULsignal
comment "Return V * B, signal error on overflow";
pattern *(v:dbl,b:bat[:hge],s:bat[:oid]) :bat[:dbl]
address CMDbatMULsignal
comment "Return V * B with candidates list, signal error on overflow";
pattern mul_noerror(v:dbl,b:bat[:hge]) :bat[:dbl]
address CMDbatMUL
comment "Return V * B, overflow causes NIL value";
pattern mul_noerror(v:dbl,b:bat[:hge],s:bat[:oid]) :bat[:dbl]
address CMDbatMUL
comment "Return V * B with candidates list, overflow causes NIL value";


pattern /(b1:bat[:bte],b2:bat[:hge]) :bat[:bte]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
pattern /(b1:bat[:bte],b2:bat[:hge],s:bat[:oid]) :bat[:bte]
address CMDbatDIVsignal
comment "Return B1 / B2 with candidates list, signal error on overflow";
pattern div_noerror(b1:bat[:bte],b2:bat[:hge]) :bat[:bte]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern div_noerror(b1:bat[:bte],b2:bat[:hge],s:bat[:oid]) :bat[:bte]
address CMDbatDIV
comment "Return B1 / B2 with candidates list, overflow causes NIL value";
pattern /(b:bat[:bte],v:hge) :bat[:bte]
address CMDbatDIVsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:bte],v:hge,s:bat[:oid]) :bat[:bte]
address CMDbatDIVsignal
comment "Return B / V with candidates list, signal error on overflow";
pattern div_noerror(b:bat[:bte],v:hge) :bat[:bte]
address CMDbatDIV
comment "Return B / V, overflow causes NIL value";
pattern div_noerror(b:bat[:bte],v:hge,s:bat[:oid]) :bat[:bte]
address CMDbatDIV
comment "Return B / V with candidates list, overflow causes NIL value";
pattern /(v:bte,b:bat[:hge]) :bat[:bte]
address CMDbatDIVsignal
comment "Return V / B, signal error on overflow";
pattern /(v:bte,b:bat[:hge],s:bat[:oid]) :bat[:bte]
address CMDbatDIVsignal
comment "Return V / B with candidates list, signal error on overflow";
pattern div_noerror(v:bte,b:bat[:hge]) :bat[:bte]
address CMDbatDIV
comment "Return V / B, overflow causes NIL value";
pattern div_noerror(v:bte,b:bat[:hge],s:bat[:oid]) :bat[:bte]
address CMDbatDIV
comment "Return V / B with candidates list, overflow causes NIL value";

pattern /(b1:bat[:sht],b2:bat[:hge]) :bat[:sht]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
pattern /(b1:bat[:sht],b2:bat[:hge],s:bat[:oid]) :bat[:sht]
address CMDbatDIVsignal
comment "Return B1 / B2 with candidates list, signal error on overflow";
pattern div_noerror(b1:bat[:sht],b2:bat[:hge]) :bat[:sht]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern div_noerror(b1:bat[:sht],b2:bat[:hge],s:bat[:oid]) :bat[:sht]
address CMDbatDIV
comment "Return B1 / B2 with candidates list, overflow causes NIL value";
pattern /(b:bat[:sht],v:hge) :bat[:sht]
address CMDbatDIVsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:sht],v:hge,s:bat[:oid]) :bat[:sht]
address CMDbatDIVsignal
comment "Return B / V with candidates list, signal error on overflow";
pattern div_noerror(b:bat[:sht],v:hge) :bat[:sht]
address CMDbatDIV
comment "Return B / V, overflow causes NIL value";
pattern div_noerror(b:bat[:sht],v:hge,s:bat[:oid]) :bat[:sht]
address CMDbatDIV
comment "Return B / V with candidates list, overflow causes NIL value";
pattern /(v:sht,b:bat[:hge]) :bat[:sht]
address CMDbatDIVsignal
comment "Return V / B, signal error on overflow";
pattern /(v:sht,b:bat[:hge],s:bat[:oid]) :bat[:sht]
address CMDbatDIVsignal
comment "Return V / B with candidates list, signal error on overflow";
pattern div_noerror(v:sht,b:bat[:hge]) :bat[:sht]
address CMDbatDIV
comment "Return V / B, overflow causes NIL value";
pattern div_noerror(v:sht,b:bat[:hge],s:bat[:oid]) :bat[:sht]
address CMDbatDIV
comment "Return V / B with candidates list, overflow causes NIL value";

pattern /(b1:bat[:int],b2:bat[:hge]) :bat[:int]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
pattern /(b1:bat[:int],b2:bat[:hge],s:bat[:oid]) :bat[:int]
address CMDbatDIVsignal
comment "Return B1 / B2 with candidates list, signal error on overflow";
pattern div_noerror(b1:bat[:int],b2:bat[:hge]) :bat[:int]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern div_noerror(b1:bat[:int],b2:bat[:hge],s:bat[:oid]) :bat[:int]
address CMDbatDIV
comment "Return B1 / B2 with candidates list, overflow causes NIL value";
pattern /(b:bat[:int],v:hge) :bat[:int]
address CMDbatDIVsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:int],v:hge,s:bat[:oid]) :bat[:int]
address CMDbatDIVsignal
comment "Return B / V with candidates list, signal error on overflow";
pattern div_noerror(b:bat[:int],v:hge) :bat[:int]
address CMDbatDIV
comment "Return B / V, overflow causes NIL value";
pattern div_noerror(b:bat[:int],v:hge,s:bat[:oid]) :bat[:int]
address CMDbatDIV
comment "Return B / V with candidates list, overflow causes NIL value";
pattern /(v:int,b:bat[:hge]) :bat[:int]
address CMDbatDIVsignal
comment "Return V / B, signal error on overflow";
pattern /(v:int,b:bat[:hge],s:bat[:oid]) :bat[:int]
address CMDbatDIVsignal
comment "Return V / B with candidates list, signal error on overflow";
pattern div_noerror(v:int,b:bat[:hge]) :bat[:int]
address CMDbatDIV
comment "Return V / B, overflow causes NIL value";
pattern div_noerror(v:int,b:bat[:hge],s:bat[:oid]) :bat[:int]
address CMDbatDIV
comment "Return V / B with candidates list, overflow causes NIL value";

pattern /(b1:bat[:lng],b2:bat[:hge]) :bat[:lng]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
pattern /(b1:bat[:lng],b2:bat[:hge],s:bat[:oid]) :bat[:lng]
address CMDbatDIVsignal
comment "Return B1 / B2 with candidates list, signal error on overflow";
pattern div_noerror(b1:bat[:lng],b2:bat[:hge]) :bat[:lng]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern div_noerror(b1:bat[:lng],b2:bat[:hge],s:bat[:oid]) :bat[:lng]
address CMDbatDIV
comment "Return B1 / B2 with candidates list, overflow causes NIL value";
pattern /(b:bat[:lng],v:hge) :bat[:lng]
address CMDbatDIVsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:lng],v:hge,s:bat[:oid]) :bat[:lng]
address CMDbatDIVsignal
comment "Return B / V with candidates list, signal error on overflow";
pattern div_noerror(b:bat[:lng],v:hge) :bat[:lng]
address CMDbatDIV
comment "Return B / V, overflow causes NIL value";
pattern div_noerror(b:bat[:lng],v:hge,s:bat[:oid]) :bat[:lng]
address CMDbatDIV
comment "Return B / V with candidates list, overflow causes NIL value";
pattern /(v:lng,b:bat[:hge]) :bat[:lng]
address CMDbatDIVsignal
comment "Return V / B, signal error on overflow";
pattern /(v:lng,b:bat[:hge],s:bat[:oid]) :bat[:lng]
address CMDbatDIVsignal
comment "Return V / B with candidates list, signal error on overflow";
pattern div_noerror(v:lng,b:bat[:hge]) :bat[:lng]
address CMDbatDIV
comment "Return V / B, overflow causes NIL value";
pattern div_noerror(v:lng,b:bat[:hge],s:bat[:oid]) :bat[:lng]
address CMDbatDIV
comment "Return V / B with candidates list, overflow causes NIL value";

pattern /(b1:bat[:hge],b2:bat[:bte]) :bat[:hge]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
pattern /(b1:bat[:hge],b2:bat[:bte],s:bat[:oid]) :bat[:hge]
address CMDbatDIVsignal
comment "Return B1 / B2 with candidates list, signal error on overflow";
pattern div_noerror(b1:bat[:hge],b2:bat[:bte]) :bat[:hge]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern div_noerror(b1:bat[:hge],b2:bat[:bte],s:bat[:oid]) :bat[:hge]
address CMDbatDIV
comment "Return B1 / B2 with candidates list, overflow causes NIL value";
pattern /(b:bat[:hge],v:bte) :bat[:hge]
address CMDbatDIVsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:hge],v:bte,s:bat[:oid]) :bat[:hge]
address CMDbatDIVsignal
comment "Return B / V with candidates list, signal error on overflow";
pattern div_noerror(b:bat[:hge],v:bte) :bat[:hge]
address CMDbatDIV
comment "Return B / V, overflow causes NIL value";
pattern div_noerror(b:bat[:hge],v:bte,s:bat[:oid]) :bat[:hge]
address CMDbatDIV
comment "Return B / V with candidates list, overflow causes NIL value";
pattern /(v:hge,b:bat[:bte]) :bat[:hge]
address CMDbatDIVsignal
comment "Return V / B, signal error on overflow";
pattern /(v:hge,b:bat[:bte],s:bat[:oid]) :bat[:hge]
address CMDbatDIVsignal
comment "Return V / B with candidates list, signal error on overflow";
pattern div_noerror(v:hge,b:bat[:bte]) :bat[:hge]
address CMDbatDIV
comment "Return V / B, overflow causes NIL value";
pattern div_noerror(v:hge,b:bat[:bte],s:bat[:oid]) :bat[:hge]
address CMDbatDIV
comment "Return V / B with candidates list, overflow causes NIL value";

pattern /(b1:bat[:hge],b2:bat[:sht]) :bat[:hge]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
pattern /(b1:bat[:hge],b2:bat[:sht],s:bat[:oid]) :bat[:hge]
address CMDbatDIVsignal
comment "Return B1 / B2 with candidates list, signal error on overflow";
pattern div_noerror(b1:bat[:hge],b2:bat[:sht]) :bat[:hge]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern div_noerror(b1:bat[:hge],b2:bat[:sht],s:bat[:oid]) :bat[:hge]
address CMDbatDIV
comment "Return B1 / B2 with candidates list, overflow causes NIL value";
pattern /(b:bat[:hge],v:sht) :bat[:hge]
address CMDbatDIVsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:hge],v:sht,s:bat[:oid]) :bat[:hge]
address CMDbatDIVsignal
comment "Return B / V with candidates list, signal error on overflow";
pattern div_noerror(b:bat[:hge],v:sht) :bat[:hge]
address CMDbatDIV
comment "Return B / V, overflow causes NIL value";
pattern div_noerror(b:bat[:hge],v:sht,s:bat[:oid]) :bat[:hge]
address CMDbatDIV
comment "Return B / V with candidates list, overflow causes NIL value";
pattern /(v:hge,b:bat[:sht]) :bat[:hge]
address CMDbatDIVsignal
comment "Return V / B, signal error on overflow";
pattern /(v:hge,b:bat[:sht],s:bat[:oid]) :bat[:hge]
address CMDbatDIVsignal
comment "Return V / B with candidates list, signal error on overflow";
pattern div_noerror(v:hge,b:bat[:sht]) :bat[:hge]
address CMDbatDIV
comment "Return V / B, overflow causes NIL value";
pattern div_noerror(v:hge,b:bat[:sht],s:bat[:oid]) :bat[:hge]
address CMDbatDIV
comment "Return V / B with candidates list, overflow causes NIL value";

pattern /(b1:bat[:hge],b2:bat[:int]) :bat[:hge]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
pattern /(b1:bat[:hge],b2:bat[:int],s:bat[:oid]) :bat[:hge]
address CMDbatDIVsignal
comment "Return B1 / B2 with candidates list, signal error on overflow";
pattern div_noerror(b1:bat[:hge],b2:bat[:int]) :bat[:hge]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern div_noerror(b1:bat[:hge],b2:bat[:int],s:bat[:oid]) :bat[:hge]
address CMDbatDIV
comment "Return B1 / B2 with candidates list, overflow causes NIL value";
pattern /(b:bat[:hge],v:int) :bat[:hge]
address CMDbatDIVsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:hge],v:int,s:bat[:oid]) :bat[:hge]
address CMDbatDIVsignal
comment "Return B / V with candidates list, signal error on overflow";
pattern div_noerror(b:bat[:hge],v:int) :bat[:hge]
address CMDbatDIV
comment "Return B / V, overflow causes NIL value";
pattern div_noerror(b:bat[:hge],v:int,s:bat[:oid]) :bat[:hge]
address CMDbatDIV
comment "Return B / V with candidates list, overflow causes NIL value";
pattern /(v:hge,b:bat[:int]) :bat[:hge]
address CMDbatDIVsignal
comment "Return V / B, signal error on overflow";
pattern /(v:hge,b:bat[:int],s:bat[:oid]) :bat[:hge]
address CMDbatDIVsignal
comment "Return V / B with candidates list, signal error on overflow";
pattern div_noerror(v:hge,b:bat[:int]) :bat[:hge]
address CMDbatDIV
comment "Return V / B, overflow causes NIL value";
pattern div_noerror(v:hge,b:bat[:int],s:bat[:oid]) :bat[:hge]
address CMDbatDIV
comment "Return V / B with candidates list, overflow causes NIL value";

pattern /(b1:bat[:hge],b2:bat[:lng]) :bat[:hge]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
pattern /(b1:bat[:hge],b2:bat[:lng],s:bat[:oid]) :bat[:hge]
address CMDbatDIVsignal
comment "Return B1 / B2 with candidates list, signal error on overflow";
pattern div_noerror(b1:bat[:hge],b2:bat[:lng]) :bat[:hge]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern div_noerror(b1:bat[:hge],b2:bat[:lng],s:bat[:oid]) :bat[:hge]
address CMDbatDIV
comment "Return B1 / B2 with candidates list, overflow causes NIL value";
pattern /(b:bat[:hge],v:lng) :bat[:hge]
address CMDbatDIVsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:hge],v:lng,s:bat[:oid]) :bat[:hge]
address CMDbatDIVsignal
comment "Return B / V with candidates list, signal error on overflow";
pattern div_noerror(b:bat[:hge],v:lng) :bat[:hge]
address CMDbatDIV
comment "Return B / V, overflow causes NIL value";
pattern div_noerror(b:bat[:hge],v:lng,s:bat[:oid]) :bat[:hge]
address CMDbatDIV
comment "Return B / V with candidates list, overflow causes NIL value";
pattern /(v:hge,b:bat[:lng]) :bat[:hge]
address CMDbatDIVsignal
comment "Return V / B, signal error on overflow";
pattern /(v:hge,b:bat[:lng],s:bat[:oid]) :bat[:hge]
address CMDbatDIVsignal
comment "Return V / B with candidates list, signal error on overflow";
pattern div_noerror(v:hge,b:bat[:lng]) :bat[:hge]
address CMDbatDIV
comment "Return V / B, overflow causes NIL value";
pattern div_noerror(v:hge,b:bat[:lng],s:bat[:oid]) :bat[:hge]
address CMDbatDIV
comment "Return V / B with candidates list, overflow causes NIL value";

pattern /(b1:bat[:hge],b2:bat[:hge]) :bat[:hge]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
pattern /(b1:bat[:hge],b2:bat[:hge],s:bat[:oid]) :bat[:hge]
address CMDbatDIVsignal
comment "Return B1 / B2 with candidates list, signal error on overflow";
pattern div_noerror(b1:bat[:hge],b2:bat[:hge]) :bat[:hge]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern div_noerror(b1:bat[:hge],b2:bat[:hge],s:bat[:oid]) :bat[:hge]
address CMDbatDIV
comment "Return B1 / B2 with candidates list, overflow causes NIL value";
pattern /(b:bat[:hge],v:hge) :bat[:hge]
address CMDbatDIVsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:hge],v:hge,s:bat[:oid]) :bat[:hge]
address CMDbatDIVsignal
comment "Return B / V with candidates list, signal error on overflow";
pattern div_noerror(b:bat[:hge],v:hge) :bat[:hge]
address CMDbatDIV
comment "Return B / V, overflow causes NIL value";
pattern div_noerror(b:bat[:hge],v:hge,s:bat[:oid]) :bat[:hge]
address CMDbatDIV
comment "Return B / V with candidates list, overflow causes NIL value";
pattern /(v:hge,b:bat[:hge]) :bat[:hge]
address CMDbatDIVsignal
comment "Return V / B, signal error on overflow";
pattern /(v:hge,b:bat[:hge],s:bat[:oid]) :bat[:hge]
address CMDbatDIVsignal
comment "Return V / B with candidates list, signal error on overflow";
pattern div_noerror(v:hge,b:bat[:hge]) :bat[:hge]
address CMDbatDIV
comment "Return V / B, overflow causes NIL value";
pattern div_noerror(v:hge,b:bat[:hge],s:bat[:oid]) :bat[:hge]
address CMDbatDIV
comment "Return V / B with candidates list, overflow causes NIL value";

pattern /(b1:bat[:hge],b2:bat[:flt]) :bat[:flt]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
pattern /(b1:bat[:hge],b2:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatDIVsignal
comment "Return B1 / B2 with candidates list, signal error on overflow";
pattern div_noerror(b1:bat[:hge],b2:bat[:flt]) :bat[:flt]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern div_noerror(b1:bat[:hge],b2:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatDIV
comment "Return B1 / B2 with candidates list, overflow causes NIL value";
pattern /(b:bat[:hge],v:flt) :bat[:flt]
address CMDbatDIVsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:hge],v:flt,s:bat[:oid]) :bat[:flt]
address CMDbatDIVsignal
comment "Return B / V with candidates list, signal error on overflow";
pattern div_noerror(b:bat[:hge],v:flt) :bat[:flt]
address CMDbatDIV
comment "Return B / V, overflow causes NIL value";
pattern div_noerror(b:bat[:hge],v:flt,s:bat[:oid]) :bat[:flt]
address CMDbatDIV
comment "Return B / V with candidates list, overflow causes NIL value";
pattern /(v:hge,b:bat[:flt]) :bat[:flt]
address CMDbatDIVsignal
comment "Return V / B, signal error on overflow";
pattern /(v:hge,b:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatDIVsignal
comment "Return V / B with candidates list, signal error on overflow";
pattern div_noerror(v:hge,b:bat[:flt]) :bat[:flt]
address CMDbatDIV
comment "Return V / B, overflow causes NIL value";
pattern div_noerror(v:hge,b:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatDIV
comment "Return V / B with candidates list, overflow causes NIL value";

pattern /(b1:bat[:hge],b2:bat[:dbl]) :bat[:dbl]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
pattern /(b1:bat[:hge],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatDIVsignal
comment "Return B1 / B2 with candidates list, signal error on overflow";
pattern div_noerror(b1:bat[:hge],b2:bat[:dbl]) :bat[:dbl]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern div_noerror(b1:bat[:hge],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatDIV
comment "Return B1 / B2 with candidates list, overflow causes NIL value";
pattern /(b:bat[:hge],v:dbl) :bat[:dbl]
address CMDbatDIVsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:hge],v:dbl,s:bat[:oid]) :bat[:dbl]
address CMDbatDIVsignal
comment "Return B / V with candidates list, signal error on overflow";
pattern div_noerror(b:bat[:hge],v:dbl) :bat[:dbl]
address CMDbatDIV
comment "Return B / V, overflow causes NIL value";
pattern div_noerror(b:bat[:hge],v:dbl,s:bat[:oid]) :bat[:dbl]
address CMDbatDIV
comment "Return B / V with candidates list, overflow causes NIL value";
pattern /(v:hge,b:bat[:dbl]) :bat[:dbl]
address CMDbatDIVsignal
comment "Return V / B, signal error on overflow";
pattern /(v:hge,b:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatDIVsignal
comment "Return V / B with candidates list, signal error on overflow";
pattern div_noerror(v:hge,b:bat[:dbl]) :bat[:dbl]
address CMDbatDIV
comment "Return V / B, overflow causes NIL value";
pattern div_noerror(v:hge,b:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatDIV
comment "Return V / B with candidates list, overflow causes NIL value";

pattern /(b1:bat[:flt],b2:bat[:hge]) :bat[:flt]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
pattern /(b1:bat[:flt],b2:bat[:hge],s:bat[:oid]) :bat[:flt]
address CMDbatDIVsignal
comment "Return B1 / B2 with candidates list, signal error on overflow";
pattern div_noerror(b1:bat[:flt],b2:bat[:hge]) :bat[:flt]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern div_noerror(b1:bat[:flt],b2:bat[:hge],s:bat[:oid]) :bat[:flt]
address CMDbatDIV
comment "Return B1 / B2 with candidates list, overflow causes NIL value";
pattern /(b:bat[:flt],v:hge) :bat[:flt]
address CMDbatDIVsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:flt],v:hge,s:bat[:oid]) :bat[:flt]
address CMDbatDIVsignal
comment "Return B / V with candidates list, signal error on overflow";
pattern div_noerror(b:bat[:flt],v:hge) :bat[:flt]
address CMDbatDIV
comment "Return B / V, overflow causes NIL value";
pattern div_noerror(b:bat[:flt],v:hge,s:bat[:oid]) :bat[:flt]
address CMDbatDIV
comment "Return B / V with candidates list, overflow causes NIL value";
pattern /(v:flt,b:bat[:hge]) :bat[:flt]
address CMDbatDIVsignal
comment "Return V / B, signal error on overflow";
pattern /(v:flt,b:bat[:hge],s:bat[:oid]) :bat[:flt]
address CMDbatDIVsignal
comment "Return V / B with candidates list, signal error on overflow";
pattern div_noerror(v:flt,b:bat[:hge]) :bat[:flt]
address CMDbatDIV
comment "Return V / B, overflow causes NIL value";
pattern div_noerror(v:flt,b:bat[:hge],s:bat[:oid]) :bat[:flt]
address CMDbatDIV
comment "Return V / B with candidates list, overflow causes NIL value";

pattern /(b1:bat[:dbl],b2:bat[:hge]) :bat[:dbl]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
pattern /(b1:bat[:dbl],b2:bat[:hge],s:bat[:oid]) :bat[:dbl]
address CMDbatDIVsignal
comment "Return B1 / B2 with candidates list, signal error on overflow";
pattern div_noerror(b1:bat[:dbl],b2:bat[:hge]) :bat[:dbl]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern div_noerror(b1:bat[:dbl],b2:bat[:hge],s:bat[:oid]) :bat[:dbl]
address CMDbatDIV
comment "Return B1 / B2 with candidates list, overflow causes NIL value";
pattern /(b:bat[:dbl],v:hge) :bat[:dbl]
address CMDbatDIVsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:dbl],v:hge,s:bat[:oid]) :bat[:dbl]
address CMDbatDIVsignal
comment "Return B / V with candidates list, signal error on overflow";
pattern div_noerror(b:bat[:dbl],v:hge) :bat[:dbl]
address CMDbatDIV
comment "Return B / V, overflow causes NIL value";
pattern div_noerror(b:bat[:dbl],v:hge,s:bat[:oid]) :bat[:dbl]
address CMDbatDIV
comment "Return B / V with candidates list, overflow causes NIL value";
pattern /(v:dbl,b:bat[:hge]) :bat[:dbl]
address CMDbatDIVsignal
comment "Return V / B, signal error on overflow";
pattern /(v:dbl,b:bat[:hge],s:bat[:oid]) :bat[:dbl]
address CMDbatDIVsignal
comment "Return V / B with candidates list, signal error on overflow";
pattern div_noerror(v:dbl,b:bat[:hge]) :bat[:dbl]
address CMDbatDIV
comment "Return V / B, overflow causes NIL value";
pattern div_noerror(v:dbl,b:bat[:hge],s:bat[:oid]) :bat[:dbl]
address CMDbatDIV
comment "Return V / B with candidates list, overflow causes NIL value";


pattern %(b1:bat[:bte],b2:bat[:hge]) :bat[:bte]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
pattern %(b1:bat[:bte],b2:bat[:hge],s:bat[:oid]) :bat[:bte]
address CMDbatMODsignal
comment "Return B1 % B2 with candidates list, signal error on divide by zero";
pattern mod_noerror(b1:bat[:bte],b2:bat[:hge]) :bat[:bte]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern mod_noerror(b1:bat[:bte],b2:bat[:hge],s:bat[:oid]) :bat[:bte]
address CMDbatMOD
comment "Return B1 % B2 with candidates list, divide by zero causes NIL value";
pattern %(b:bat[:bte],v:hge) :bat[:bte]
address CMDbatMODsignal
comment "Return B % V, signal error on divide by zero";
pattern %(b:bat[:bte],v:hge,s:bat[:oid]) :bat[:bte]
address CMDbatMODsignal
comment "Return B % V with candidates list, signal error on divide by zero";
pattern mod_noerror(b:bat[:bte],v:hge) :bat[:bte]
address CMDbatMOD
comment "Return B % V, divide by zero causes NIL value";
pattern mod_noerror(b:bat[:bte],v:hge,s:bat[:oid]) :bat[:bte]
address CMDbatMOD
comment "Return B % V with candidates list, divide by zero causes NIL value";
pattern %(v:bte,b:bat[:hge]) :bat[:bte]
address CMDbatMODsignal
comment "Return V % B, signal error on divide by zero";
pattern %(v:bte,b:bat[:hge],s:bat[:oid]) :bat[:bte]
address CMDbatMODsignal
comment "Return V % B with candidates list, signal error on divide by zero";
pattern mod_noerror(v:bte,b:bat[:hge]) :bat[:bte]
address CMDbatMOD
comment "Return V % B, divide by zero causes NIL value";
pattern mod_noerror(v:bte,b:bat[:hge],s:bat[:oid]) :bat[:bte]
address CMDbatMOD
comment "Return V % B with candidates list, divide by zero causes NIL value";

pattern %(b1:bat[:sht],b2:bat[:hge]) :bat[:sht]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
pattern %(b1:bat[:sht],b2:bat[:hge],s:bat[:oid]) :bat[:sht]
address CMDbatMODsignal
comment "Return B1 % B2 with candidates list, signal error on divide by zero";
pattern mod_noerror(b1:bat[:sht],b2:bat[:hge]) :bat[:sht]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern mod_noerror(b1:bat[:sht],b2:bat[:hge],s:bat[:oid]) :bat[:sht]
address CMDbatMOD
comment "Return B1 % B2 with candidates list, divide by zero causes NIL value";
pattern %(b:bat[:sht],v:hge) :bat[:sht]
address CMDbatMODsignal
comment "Return B % V, signal error on divide by zero";
pattern %(b:bat[:sht],v:hge,s:bat[:oid]) :bat[:sht]
address CMDbatMODsignal
comment "Return B % V with candidates list, signal error on divide by zero";
pattern mod_noerror(b:bat[:sht],v:hge) :bat[:sht]
address CMDbatMOD
comment "Return B % V, divide by zero causes NIL value";
pattern mod_noerror(b:bat[:sht],v:hge,s:bat[:oid]) :bat[:sht]
address CMDbatMOD
comment "Return B % V with candidates list, divide by zero causes NIL value";
pattern %(v:sht,b:bat[:hge]) :bat[:sht]
address CMDbatMODsignal
comment "Return V % B, signal error on divide by zero";
pattern %(v:sht,b:bat[:hge],s:bat[:oid]) :bat[:sht]
address CMDbatMODsignal
comment "Return V % B with candidates list, signal error on divide by zero";
pattern mod_noerror(v:sht,b:bat[:hge]) :bat[:sht]
address CMDbatMOD
comment "Return V % B, divide by zero causes NIL value";
pattern mod_noerror(v:sht,b:bat[:hge],s:bat[:oid]) :bat[:sht]
address CMDbatMOD
comment "Return V % B with candidates list, divide by zero causes NIL value";

pattern %(b1:bat[:int],b2:bat[:hge]) :bat[:int]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
pattern %(b1:bat[:int],b2:bat[:hge],s:bat[:oid]) :bat[:int]
address CMDbatMODsignal
comment "Return B1 % B2 with candidates list, signal error on divide by zero";
pattern mod_noerror(b1:bat[:int],b2:bat[:hge]) :bat[:int]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern mod_noerror(b1:bat[:int],b2:bat[:hge],s:bat[:oid]) :bat[:int]
address CMDbatMOD
comment "Return B1 % B2 with candidates list, divide by zero causes NIL value";
pattern %(b:bat[:int],v:hge) :bat[:int]
address CMDbatMODsignal
comment "Return B % V, signal error on divide by zero";
pattern %(b:bat[:int],v:hge,s:bat[:oid]) :bat[:int]
address CMDbatMODsignal
comment "Return B % V with candidates list, signal error on divide by zero";
pattern mod_noerror(b:bat[:int],v:hge) :bat[:int]
address CMDbatMOD
comment "Return B % V, divide by zero causes NIL value";
pattern mod_noerror(b:bat[:int],v:hge,s:bat[:oid]) :bat[:int]
address CMDbatMOD
comment "Return B % V with candidates list, divide by zero causes NIL value";
pattern %(v:int,b:bat[:hge]) :bat[:int]
address CMDbatMODsignal
comment "Return V % B, signal error on divide by zero";
pattern %(v:int,b:bat[:hge],s:bat[:oid]) :bat[:int]
address CMDbatMODsignal
comment "Return V % B with candidates list, signal error on divide by zero";
pattern mod_noerror(v:int,b:bat[:hge]) :bat[:int]
address CMDbatMOD
comment "Return V % B, divide by zero causes NIL value";
pattern mod_noerror(v:int,b:bat[:hge],s:bat[:oid]) :bat[:int]
address CMDbatMOD
comment "Return V % B with candidates list, divide by zero causes NIL value";

pattern %(b1:bat[:lng],b2:bat[:hge]) :bat[:lng]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
pattern %(b1:bat[:lng],b2:bat[:hge],s:bat[:oid]) :bat[:lng]
address CMDbatMODsignal
comment "Return B1 % B2 with candidates list, signal error on divide by zero";
pattern mod_noerror(b1:bat[:lng],b2:bat[:hge]) :bat[:lng]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern mod_noerror(b1:bat[:lng],b2:bat[:hge],s:bat[:oid]) :bat[:lng]
address CMDbatMOD
comment "Return B1 % B2 with candidates list, divide by zero causes NIL value";
pattern %(b:bat[:lng],v:hge) :bat[:lng]
address CMDbatMODsignal
comment "Return B % V, signal error on divide by zero";
pattern %(b:bat[:lng],v:hge,s:bat[:oid]) :bat[:lng]
address CMDbatMODsignal
comment "Return B % V with candidates list, signal error on divide by zero";
pattern mod_noerror(b:bat[:lng],v:hge) :bat[:lng]
address CMDbatMOD
comment "Return B % V, divide by zero causes NIL value";
pattern mod_noerror(b:bat[:lng],v:hge,s:bat[:oid]) :bat[:lng]
address CMDbatMOD
comment "Return B % V with candidates list, divide by zero causes NIL value";
pattern %(v:lng,b:bat[:hge]) :bat[:lng]
address CMDbatMODsignal
comment "Return V % B, signal error on divide by zero";
pattern %(v:lng,b:bat[:hge],s:bat[:oid]) :bat[:lng]
address CMDbatMODsignal
comment "Return V % B with candidates list, signal error on divide by zero";
pattern mod_noerror(v:lng,b:bat[:hge]) :bat[:lng]
address CMDbatMOD
comment "Return V % B, divide by zero causes NIL value";
pattern mod_noerror(v:lng,b:bat[:hge],s:bat[:oid]) :bat[:lng]
address CMDbatMOD
comment "Return V % B with candidates list, divide by zero causes NIL value";

pattern %(b1:bat[:hge],b2:bat[:bte]) :bat[:bte]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
pattern %(b1:bat[:hge],b2:bat[:bte],s:bat[:oid]) :bat[:bte]
address CMDbatMODsignal
comment "Return B1 % B2 with candidates list, signal error on divide by zero";
pattern mod_noerror(b1:bat[:hge],b2:bat[:bte]) :bat[:bte]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern mod_noerror(b1:bat[:hge],b2:bat[:bte],s:bat[:oid]) :bat[:bte]
address CMDbatMOD
comment "Return B1 % B2 with candidates list, divide by zero causes NIL value";
pattern %(b:bat[:hge],v:bte) :bat[:bte]
address CMDbatMODsignal
comment "Return B % V, signal error on divide by zero";
pattern %(b:bat[:hge],v:bte,s:bat[:oid]) :bat[:bte]
address CMDbatMODsignal
comment "Return B % V with candidates list, signal error on divide by zero";
pattern mod_noerror(b:bat[:hge],v:bte) :bat[:bte]
address CMDbatMOD
comment "Return B % V, divide by zero causes NIL value";
pattern mod_noerror(b:bat[:hge],v:bte,s:bat[:oid]) :bat[:bte]
address CMDbatMOD
comment "Return B % V with candidates list, divide by zero causes NIL value";
pattern %(v:hge,b:bat[:bte]) :bat[:bte]
address CMDbatMODsignal
comment "Return V % B, signal error on divide by zero";
pattern %(v:hge,b:bat[:bte],s:bat[:oid]) :bat[:bte]
address CMDbatMODsignal
comment "Return V % B with candidates list, signal error on divide by zero";
pattern mod_noerror(v:hge,b:bat[:bte]) :bat[:bte]
address CMDbatMOD
comment "Return V % B, divide by zero causes NIL value";
pattern mod_noerror(v:hge,b:bat[:bte],s:bat[:oid]) :bat[:bte]
address CMDbatMOD
comment "Return V % B with candidates list, divide by zero causes NIL value";

pattern %(b1:bat[:hge],b2:bat[:sht]) :bat[:sht]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
pattern %(b1:bat[:hge],b2:bat[:sht],s:bat[:oid]) :bat[:sht]
address CMDbatMODsignal
comment "Return B1 % B2 with candidates list, signal error on divide by zero";
pattern mod_noerror(b1:bat[:hge],b2:bat[:sht]) :bat[:sht]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern mod_noerror(b1:bat[:hge],b2:bat[:sht],s:bat[:oid]) :bat[:sht]
address CMDbatMOD
comment "Return B1 % B2 with candidates list, divide by zero causes NIL value";
pattern %(b:bat[:hge],v:sht) :bat[:sht]
address CMDbatMODsignal
comment "Return B % V, signal error on divide by zero";
pattern %(b:bat[:hge],v:sht,s:bat[:oid]) :bat[:sht]
address CMDbatMODsignal
comment "Return B % V with candidates list, signal error on divide by zero";
pattern mod_noerror(b:bat[:hge],v:sht) :bat[:sht]
address CMDbatMOD
comment "Return B % V, divide by zero causes NIL value";
pattern mod_noerror(b:bat[:hge],v:sht,s:bat[:oid]) :bat[:sht]
address CMDbatMOD
comment "Return B % V with candidates list, divide by zero causes NIL value";
pattern %(v:hge,b:bat[:sht]) :bat[:sht]
address CMDbatMODsignal
comment "Return V % B, signal error on divide by zero";
pattern %(v:hge,b:bat[:sht],s:bat[:oid]) :bat[:sht]
address CMDbatMODsignal
comment "Return V % B with candidates list, signal error on divide by zero";
pattern mod_noerror(v:hge,b:bat[:sht]) :bat[:sht]
address CMDbatMOD
comment "Return V % B, divide by zero causes NIL value";
pattern mod_noerror(v:hge,b:bat[:sht],s:bat[:oid]) :bat[:sht]
address CMDbatMOD
comment "Return V % B with candidates list, divide by zero causes NIL value";

pattern %(b1:bat[:hge],b2:bat[:int]) :bat[:int]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
pattern %(b1:bat[:hge],b2:bat[:int],s:bat[:oid]) :bat[:int]
address CMDbatMODsignal
comment "Return B1 % B2 with candidates list, signal error on divide by zero";
pattern mod_noerror(b1:bat[:hge],b2:bat[:int]) :bat[:int]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern mod_noerror(b1:bat[:hge],b2:bat[:int],s:bat[:oid]) :bat[:int]
address CMDbatMOD
comment "Return B1 % B2 with candidates list, divide by zero causes NIL value";
pattern %(b:bat[:hge],v:int) :bat[:int]
address CMDbatMODsignal
comment "Return B % V, signal error on divide by zero";
pattern %(b:bat[:hge],v:int,s:bat[:oid]) :bat[:int]
address CMDbatMODsignal
comment "Return B % V with candidates list, signal error on divide by zero";
pattern mod_noerror(b:bat[:hge],v:int) :bat[:int]
address CMDbatMOD
comment "Return B % V, divide by zero causes NIL value";
pattern mod_noerror(b:bat[:hge],v:int,s:bat[:oid]) :bat[:int]
address CMDbatMOD
comment "Return B % V with candidates list, divide by zero causes NIL value";
pattern %(v:hge,b:bat[:int]) :bat[:int]
address CMDbatMODsignal
comment "Return V % B, signal error on divide by zero";
pattern %(v:hge,b:bat[:int],s:bat[:oid]) :bat[:int]
address CMDbatMODsignal
comment "Return V % B with candidates list, signal error on divide by zero";
pattern mod_noerror(v:hge,b:bat[:int]) :bat[:int]
address CMDbatMOD
comment "Return V % B, divide by zero causes NIL value";
pattern mod_noerror(v:hge,b:bat[:int],s:bat[:oid]) :bat[:int]
address CMDbatMOD
comment "Return V % B with candidates list, divide by zero causes NIL value";

pattern %(b1:bat[:hge],b2:bat[:lng]) :bat[:lng]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
pattern %(b1:bat[:hge],b2:bat[:lng],s:bat[:oid]) :bat[:lng]
address CMDbatMODsignal
comment "Return B1 % B2 with candidates list, signal error on divide by zero";
pattern mod_noerror(b1:bat[:hge],b2:bat[:lng]) :bat[:lng]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern mod_noerror(b1:bat[:hge],b2:bat[:lng],s:bat[:oid]) :bat[:lng]
address CMDbatMOD
comment "Return B1 % B2 with candidates list, divide by zero causes NIL value";
pattern %(b:bat[:hge],v:lng) :bat[:lng]
address CMDbatMODsignal
comment "Return B % V, signal error on divide by zero";
pattern %(b:bat[:hge],v:lng,s:bat[:oid]) :bat[:lng]
address CMDbatMODsignal
comment "Return B % V with candidates list, signal error on divide by zero";
pattern mod_noerror(b:bat[:hge],v:lng) :bat[:lng]
address CMDbatMOD
comment "Return B % V, divide by zero causes NIL value";
pattern mod_noerror(b:bat[:hge],v:lng,s:bat[:oid]) :bat[:lng]
address CMDbatMOD
comment "Return B % V with candidates list, divide by zero causes NIL value";
pattern %(v:hge,b:bat[:lng]) :bat[:lng]
address CMDbatMODsignal
comment "Return V % B, signal error on divide by zero";
pattern %(v:hge,b:bat[:lng],s:bat[:oid]) :bat[:lng]
address CMDbatMODsignal
comment "Return V % B with candidates list, signal error on divide by zero";
pattern mod_noerror(v:hge,b:bat[:lng]) :bat[:lng]
address CMDbatMOD
comment "Return V % B, divide by zero causes NIL value";
pattern mod_noerror(v:hge,b:bat[:lng],s:bat[:oid]) :bat[:lng]
address CMDbatMOD
comment "Return V % B with candidates list, divide by zero causes NIL value";

pattern %(b1:bat[:hge],b2:bat[:hge]) :bat[:hge]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
pattern %(b1:bat[:hge],b2:bat[:hge],s:bat[:oid]) :bat[:hge]
address CMDbatMODsignal
comment "Return B1 % B2 with candidates list, signal error on divide by zero";
pattern mod_noerror(b1:bat[:hge],b2:bat[:hge]) :bat[:hge]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern mod_noerror(b1:bat[:hge],b2:bat[:hge],s:bat[:oid]) :bat[:hge]
address CMDbatMOD
comment "Return B1 % B2 with candidates list, divide by zero causes NIL value";
pattern %(b:bat[:hge],v:hge) :bat[:hge]
address CMDbatMODsignal
comment "Return B % V, signal error on divide by zero";
pattern %(b:bat[:hge],v:hge,s:bat[:oid]) :bat[:hge]
address CMDbatMODsignal
comment "Return B % V with candidates list, signal error on divide by zero";
pattern mod_noerror(b:bat[:hge],v:hge) :bat[:hge]
address CMDbatMOD
comment "Return B % V, divide by zero causes NIL value";
pattern mod_noerror(b:bat[:hge],v:hge,s:bat[:oid]) :bat[:hge]
address CMDbatMOD
comment "Return B % V with candidates list, divide by zero causes NIL value";
pattern %(v:hge,b:bat[:hge]) :bat[:hge]
address CMDbatMODsignal
comment "Return V % B, signal error on divide by zero";
pattern %(v:hge,b:bat[:hge],s:bat[:oid]) :bat[:hge]
address CMDbatMODsignal
comment "Return V % B with candidates list, signal error on divide by zero";
pattern mod_noerror(v:hge,b:bat[:hge]) :bat[:hge]
address CMDbatMOD
comment "Return V % B, divide by zero causes NIL value";
pattern mod_noerror(v:hge,b:bat[:hge],s:bat[:oid]) :bat[:hge]
address CMDbatMOD
comment "Return V % B with candidates list, divide by zero causes NIL value";

pattern %(b1:bat[:hge],b2:bat[:flt]) :bat[:flt]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
pattern %(b1:bat[:hge],b2:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatMODsignal
comment "Return B1 % B2 with candidates list, signal error on divide by zero";
pattern mod_noerror(b1:bat[:hge],b2:bat[:flt]) :bat[:flt]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern mod_noerror(b1:bat[:hge],b2:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatMOD
comment "Return B1 % B2 with candidates list, divide by zero causes NIL value";
pattern %(b:bat[:hge],v:flt) :bat[:flt]
address CMDbatMODsignal
comment "Return B % V, signal error on divide by zero";
pattern %(b:bat[:hge],v:flt,s:bat[:oid]) :bat[:flt]
address CMDbatMODsignal
comment "Return B % V with candidates list, signal error on divide by zero";
pattern mod_noerror(b:bat[:hge],v:flt) :bat[:flt]
address CMDbatMOD
comment "Return B % V, divide by zero causes NIL value";
pattern mod_noerror(b:bat[:hge],v:flt,s:bat[:oid]) :bat[:flt]
address CMDbatMOD
comment "Return B % V with candidates list, divide by zero causes NIL value";
pattern %(v:hge,b:bat[:flt]) :bat[:flt]
address CMDbatMODsignal
comment "Return V % B, signal error on divide by zero";
pattern %(v:hge,b:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatMODsignal
comment "Return V % B with candidates list, signal error on divide by zero";
pattern mod_noerror(v:hge,b:bat[:flt]) :bat[:flt]
address CMDbatMOD
comment "Return V % B, divide by zero causes NIL value";
pattern mod_noerror(v:hge,b:bat[:flt],s:bat[:oid]) :bat[:flt]
address CMDbatMOD
comment "Return V % B with candidates list, divide by zero causes NIL value";

pattern %(b1:bat[:hge],b2:bat[:dbl]) :bat[:dbl]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
pattern %(b1:bat[:hge],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatMODsignal
comment "Return B1 % B2 with candidates list, signal error on divide by zero";
pattern mod_noerror(b1:bat[:hge],b2:bat[:dbl]) :bat[:dbl]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern mod_noerror(b1:bat[:hge],b2:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatMOD
comment "Return B1 % B2 with candidates list, divide by zero causes NIL value";
pattern %(b:bat[:hge],v:dbl) :bat[:dbl]
address CMDbatMODsignal
comment "Return B % V, signal error on divide by zero";
pattern %(b:bat[:hge],v:dbl,s:bat[:oid]) :bat[:dbl]
address CMDbatMODsignal
comment "Return B % V with candidates list, signal error on divide by zero";
pattern mod_noerror(b:bat[:hge],v:dbl) :bat[:dbl]
address CMDbatMOD
comment "Return B % V, divide by zero causes NIL value";
pattern mod_noerror(b:bat[:hge],v:dbl,s:bat[:oid]) :bat[:dbl]
address CMDbatMOD
comment "Return B % V with candidates list, divide by zero causes NIL value";
pattern %(v:hge,b:bat[:dbl]) :bat[:dbl]
address CMDbatMODsignal
comment "Return V % B, signal error on divide by zero";
pattern %(v:hge,b:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatMODsignal
comment "Return V % B with candidates list, signal error on divide by zero";
pattern mod_noerror(v:hge,b:bat[:dbl]) :bat[:dbl]
address CMDbatMOD
comment "Return V % B, divide by zero causes NIL value";
pattern mod_noerror(v:hge,b:bat[:dbl],s:bat[:oid]) :bat[:dbl]
address CMDbatMOD
comment "Return V % B with candidates list, divide by zero causes NIL value";

pattern %(b1:bat[:flt],b2:bat[:hge]) :bat[:flt]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
pattern %(b1:bat[:flt],b2:bat[:hge],s:bat[:oid]) :bat[:flt]
address CMDbatMODsignal
comment "Return B1 % B2 with candidates list, signal error on divide by zero";
pattern mod_noerror(b1:bat[:flt],b2:bat[:hge]) :bat[:flt]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern mod_noerror(b1:bat[:flt],b2:bat[:hge],s:bat[:oid]) :bat[:flt]
address CMDbatMOD
comment "Return B1 % B2 with candidates list, divide by zero causes NIL value";
pattern %(b:bat[:flt],v:hge) :bat[:flt]
address CMDbatMODsignal
comment "Return B % V, signal error on divide by zero";
pattern %(b:bat[:flt],v:hge,s:bat[:oid]) :bat[:flt]
address CMDbatMODsignal
comment "Return B % V with candidates list, signal error on divide by zero";
pattern mod_noerror(b:bat[:flt],v:hge) :bat[:flt]
address CMDbatMOD
comment "Return B % V, divide by zero causes NIL value";
pattern mod_noerror(b:bat[:flt],v:hge,s:bat[:oid]) :bat[:flt]
address CMDbatMOD
comment "Return B % V with candidates list, divide by zero causes NIL value";
pattern %(v:flt,b:bat[:hge]) :bat[:flt]
address CMDbatMODsignal
comment "Return V % B, signal error on divide by zero";
pattern %(v:flt,b:bat[:hge],s:bat[:oid]) :bat[:flt]
address CMDbatMODsignal
comment "Return V % B with candidates list, signal error on divide by zero";
pattern mod_noerror(v:flt,b:bat[:hge]) :bat[:flt]
address CMDbatMOD
comment "Return V % B, divide by zero causes NIL value";
pattern mod_noerror(v:flt,b:bat[:hge],s:bat[:oid]) :bat[:flt]
address CMDbatMOD
comment "Return V % B with candidates list, divide by zero causes NIL value";

pattern %(b1:bat[:dbl],b2:bat[:hge]) :bat[:dbl]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
pattern %(b1:bat[:dbl],b2:bat[:hge],s:bat[:oid]) :bat[:dbl]
address CMDbatMODsignal
comment "Return B1 % B2 with candidates list, signal error on divide by zero";
pattern mod_noerror(b1:bat[:dbl],b2:bat[:hge]) :bat[:dbl]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern mod_noerror(b1:bat[:dbl],b2:bat[:hge],s:bat[:oid]) :bat[:dbl]
address CMDbatMOD
comment "Return B1 % B2 with candidates list, divide by zero causes NIL value";
pattern %(b:bat[:dbl],v:hge) :bat[:dbl]
address CMDbatMODsignal
comment "Return B % V, signal error on divide by zero";
pattern %(b:bat[:dbl],v:hge,s:bat[:oid]) :bat[:dbl]
address CMDbatMODsignal
comment "Return B % V with candidates list, signal error on divide by zero";
pattern mod_noerror(b:bat[:dbl],v:hge) :bat[:dbl]
address CMDbatMOD
comment "Return B % V, divide by zero causes NIL value";
pattern mod_noerror(b:bat[:dbl],v:hge,s:bat[:oid]) :bat[:dbl]
address CMDbatMOD
comment "Return B % V with candidates list, divide by zero causes NIL value";
pattern %(v:dbl,b:bat[:hge]) :bat[:dbl]
address CMDbatMODsignal
comment "Return V % B, signal error on divide by zero";
pattern %(v:dbl,b:bat[:hge],s:bat[:oid]) :bat[:dbl]
address CMDbatMODsignal
comment "Return V % B with candidates list, signal error on divide by zero";
pattern mod_noerror(v:dbl,b:bat[:hge]) :bat[:dbl]
address CMDbatMOD
comment "Return V % B, divide by zero causes NIL value";
pattern mod_noerror(v:dbl,b:bat[:hge],s:bat[:oid]) :bat[:dbl]
address CMDbatMOD
comment "Return V % B with candidates list, divide by zero causes NIL value";


pattern and(b1:bat[:hge],b2:bat[:hge]) :bat[:hge]
address CMDbatAND
comment "Return B1 AND B2";
pattern and(b1:bat[:hge],b2:bat[:hge],s:bat[:oid]) :bat[:hge]
address CMDbatAND
comment "Return B1 AND B2 with candidates list";
pattern and(b:bat[:hge],v:hge) :bat[:hge]
address CMDbatAND
comment "Return B AND V";
pattern and(b:bat[:hge],v:hge,s:bat[:oid]) :bat[:hge]
address CMDbatAND
comment "Return B AND V with candidates list";
pattern and(v:hge,b:bat[:hge]) :bat[:hge]
address CMDbatAND
comment "Return V AND B";
pattern and(v:hge,b:bat[:hge],s:bat[:oid]) :bat[:hge]
address CMDbatAND
comment "Return V AND B with candidates list";


pattern or(b1:bat[:hge],b2:bat[:hge]) :bat[:hge]
address CMDbatOR
comment "Return B1 OR B2";
pattern or(b1:bat[:hge],b2:bat[:hge],s:bat[:oid]) :bat[:hge]
address CMDbatOR
comment "Return B1 OR B2 with candidates list";
pattern or(b:bat[:hge],v:hge) :bat[:hge]
address CMDbatOR
comment "Return B OR V";
pattern or(b:bat[:hge],v:hge,s:bat[:oid]) :bat[:hge]
address CMDbatOR
comment "Return B OR V with candidates list";
pattern or(v:hge,b:bat[:hge]) :bat[:hge]
address CMDbatOR
comment "Return V OR B";
pattern or(v:hge,b:bat[:hge],s:bat[:oid]) :bat[:hge]
address CMDbatOR
comment "Return V OR B with candidates list";


pattern xor(b1:bat[:hge],b2:bat[:hge]) :bat[:hge]
address CMDbatXOR
comment "Return B1 XOR B2";
pattern xor(b1:bat[:hge],b2:bat[:hge],s:bat[:oid]) :bat[:hge]
address CMDbatXOR
comment "Return B1 XOR B2 with candidates list";
pattern xor(b:bat[:hge],v:hge) :bat[:hge]
address CMDbatXOR
comment "Return B XOR V";
pattern xor(b:bat[:hge],v:hge,s:bat[:oid]) :bat[:hge]
address CMDbatXOR
comment "Return B XOR V with candidates list";
pattern xor(v:hge,b:bat[:hge]) :bat[:hge]
address CMDbatXOR
comment "Return V XOR B";
pattern xor(v:hge,b:bat[:hge],s:bat[:oid]) :bat[:hge]
address CMDbatXOR
comment "Return V XOR B with candidates list";


pattern <<(b1:bat[:bte],b2:bat[:hge]) :bat[:bte]
address CMDbatLSHsignal
comment "Return B1 << B2, raise error on out of range second operand";
pattern <<(b1:bat[:bte],b2:bat[:hge],s:bat[:oid]) :bat[:bte]
address CMDbatLSHsignal
comment "Return B1 << B2 with candidates list, raise error on out of range second operand";
pattern lsh_noerror(b1:bat[:bte],b2:bat[:hge]) :bat[:bte]
address CMDbatLSH
comment "Return B1 << B2, out of range second operand causes NIL value";
pattern lsh_noerror(b1:bat[:bte],b2:bat[:hge],s:bat[:oid]) :bat[:bte]
address CMDbatLSH
comment "Return B1 << B2 with candidates list, out of range second operand causes NIL value";
pattern <<(b:bat[:bte],v:hge) :bat[:bte]
address CMDbatLSHsignal
comment "Return B << V, raise error on out of range second operand";
pattern <<(b:bat[:bte],v:hge,s:bat[:oid]) :bat[:bte]
address CMDbatLSHsignal
comment "Return B << V with candidates list, raise error on out of range second operand";
pattern lsh_noerror(b:bat[:bte],v:hge) :bat[:bte]
address CMDbatLSH
comment "Return B << V, out of range second operand causes NIL value";
pattern lsh_noerror(b:bat[:bte],v:hge,s:bat[:oid]) :bat[:bte]
address CMDbatLSH
comment "Return B << V with candidates list, out of range second operand causes NIL value";
pattern <<(v:bte,b:bat[:hge]) :bat[:bte]
address CMDbatLSHsignal
comment "Return V << B, raise error on out of range second operand";
pattern <<(v:bte,b:bat[:hge],s:bat[:oid]) :bat[:bte]
address CMDbatLSHsignal
comment "Return V << B with candidates list, raise error on out of range second operand";
pattern lsh_noerror(v:bte,b:bat[:hge]) :bat[:bte]
address CMDbatLSH
comment "Return V << B, out of range second operand causes NIL value";
pattern lsh_noerror(v:bte,b:bat[:hge],s:bat[:oid]) :bat[:bte]
address CMDbatLSH
comment "Return V << B with candidates list, out of range second operand causes NIL value";

pattern <<(b1:bat[:sht],b2:bat[:hge]) :bat[:sht]
address CMDbatLSHsignal
comment "Return B1 << B2, raise error on out of range second operand";
pattern <<(b1:bat[:sht],b2:bat[:hge],s:bat[:oid]) :bat[:sht]
address CMDbatLSHsignal
comment "Return B1 << B2 with candidates list, raise error on out of range second operand";
pattern lsh_noerror(b1:bat[:sht],b2:bat[:hge]) :bat[:sht]
address CMDbatLSH
comment "Return B1 << B2, out of range second operand causes NIL value";
pattern lsh_noerror(b1:bat[:sht],b2:bat[:hge],s:bat[:oid]) :bat[:sht]
address CMDbatLSH
comment "Return B1 << B2 with candidates list, out of range second operand causes NIL value";
pattern <<(b:bat[:sht],v:hge) :bat[:sht]
address CMDbatLSHsignal
comment "Return B << V, raise error on out of range second operand";
pattern <<(b:bat[:sht],v:hge,s:bat[:oid]) :bat[:sht]
address CMDbatLSHsignal
comment "Return B << V with candidates list, raise error on out of range second operand";
pattern lsh_noerror(b:bat[:sht],v:hge) :bat[:sht]
address CMDbatLSH
comment "Return B << V, out of range second operand causes NIL value";
pattern lsh_noerror(b:bat[:sht],v:hge,s:bat[:oid]) :bat[:sht]
address CMDbatLSH
comment "Return B << V with candidates list, out of range second operand causes NIL value";
pattern <<(v:sht,b:bat[:hge]) :bat[:sht]
address CMDbatLSHsignal
comment "Return V << B, raise error on out of range second operand";
pattern <<(v:sht,b:bat[:hge],s:bat[:oid]) :bat[:sht]
address CMDbatLSHsignal
comment "Return V << B with candidates list, raise error on out of range second operand";
pattern lsh_noerror(v:sht,b:bat[:hge]) :bat[:sht]
address CMDbatLSH
comment "Return V << B, out of range second operand causes NIL value";
pattern lsh_noerror(v:sht,b:bat[:hge],s:bat[:oid]) :bat[:sht]
address CMDbatLSH
comment "Return V << B with candidates list, out of range second operand causes NIL value";

pattern <<(b1:bat[:int],b2:bat[:hge]) :bat[:int]
address CMDbatLSHsignal
comment "Return B1 << B2, raise error on out of range second operand";
pattern <<(b1:bat[:int],b2:bat[:hge],s:bat[:oid]) :bat[:int]
address CMDbatLSHsignal
comment "Return B1 << B2 with candidates list, raise error on out of range second operand";
pattern lsh_noerror(b1:bat[:int],b2:bat[:hge]) :bat[:int]
address CMDbatLSH
comment "Return B1 << B2, out of range second operand causes NIL value";
pattern lsh_noerror(b1:bat[:int],b2:bat[:hge],s:bat[:oid]) :bat[:int]
address CMDbatLSH
comment "Return B1 << B2 with candidates list, out of range second operand causes NIL value";
pattern <<(b:bat[:int],v:hge) :bat[:int]
address CMDbatLSHsignal
comment "Return B << V, raise error on out of range second operand";
pattern <<(b:bat[:int],v:hge,s:bat[:oid]) :bat[:int]
address CMDbatLSHsignal
comment "Return B << V with candidates list, raise error on out of range second operand";
pattern lsh_noerror(b:bat[:int],v:hge) :bat[:int]
address CMDbatLSH
comment "Return B << V, out of range second operand causes NIL value";
pattern lsh_noerror(b:bat[:int],v:hge,s:bat[:oid]) :bat[:int]
address CMDbatLSH
comment "Return B << V with candidates list, out of range second operand causes NIL value";
pattern <<(v:int,b:bat[:hge]) :bat[:int]
address CMDbatLSHsignal
comment "Return V << B, raise error on out of range second operand";
pattern <<(v:int,b:bat[:hge],s:bat[:oid]) :bat[:int]
address CMDbatLSHsignal
comment "Return V << B with candidates list, raise error on out of range second operand";
pattern lsh_noerror(v:int,b:bat[:hge]) :bat[:int]
address CMDbatLSH
comment "Return V << B, out of range second operand causes NIL value";
pattern lsh_noerror(v:int,b:bat[:hge],s:bat[:oid]) :bat[:int]
address CMDbatLSH
comment "Return V << B with candidates list, out of range second operand causes NIL value";

pattern <<(b1:bat[:lng],b2:bat[:hge]) :bat[:lng]
address CMDbatLSHsignal
comment "Return B1 << B2, raise error on out of range second operand";
pattern <<(b1:bat[:lng],b2:bat[:hge],s:bat[:oid]) :bat[:lng]
address CMDbatLSHsignal
comment "Return B1 << B2 with candidates list, raise error on out of range second operand";
pattern lsh_noerror(b1:bat[:lng],b2:bat[:hge]) :bat[:lng]
address CMDbatLSH
comment "Return B1 << B2, out of range second operand causes NIL value";
pattern lsh_noerror(b1:bat[:lng],b2:bat[:hge],s:bat[:oid]) :bat[:lng]
address CMDbatLSH
comment "Return B1 << B2 with candidates list, out of range second operand causes NIL value";
pattern <<(b:bat[:lng],v:hge) :bat[:lng]
address CMDbatLSHsignal
comment "Return B << V, raise error on out of range second operand";
pattern <<(b:bat[:lng],v:hge,s:bat[:oid]) :bat[:lng]
address CMDbatLSHsignal
comment "Return B << V with candidates list, raise error on out of range second operand";
pattern lsh_noerror(b:bat[:lng],v:hge) :bat[:lng]
address CMDbatLSH
comment "Return B << V, out of range second operand causes NIL value";
pattern lsh_noerror(b:bat[:lng],v:hge,s:bat[:oid]) :bat[:lng]
address CMDbatLSH
comment "Return B << V with candidates list, out of range second operand causes NIL value";
pattern <<(v:lng,b:bat[:hge]) :bat[:lng]
address CMDbatLSHsignal
comment "Return V << B, raise error on out of range second operand";
pattern <<(v:lng,b:bat[:hge],s:bat[:oid]) :bat[:lng]
address CMDbatLSHsignal
comment "Return V << B with candidates list, raise error on out of range second operand";
pattern lsh_noerror(v:lng,b:bat[:hge]) :bat[:lng]
address CMDbatLSH
comment "Return V << B, out of range second operand causes NIL value";
pattern lsh_noerror(v:lng,b:bat[:hge],s:bat[:oid]) :bat[:lng]
address CMDbatLSH
comment "Return V << B with candidates list, out of range second operand causes NIL value";

pattern <<(b1:bat[:hge],b2:bat[:bte]) :bat[:hge]
address CMDbatLSHsignal
comment "Return B1 << B2, raise error on out of range second operand";
pattern <<(b1:bat[:hge],b2:bat[:bte],s:bat[:oid]) :bat[:hge]
address CMDbatLSHsignal
comment "Return B1 << B2 with candidates list, raise error on out of range second operand";
pattern lsh_noerror(b1:bat[:hge],b2:bat[:bte]) :bat[:hge]
address CMDbatLSH
comment "Return B1 << B2, out of range second operand causes NIL value";
pattern lsh_noerror(b1:bat[:hge],b2:bat[:bte],s:bat[:oid]) :bat[:hge]
address CMDbatLSH
comment "Return B1 << B2 with candidates list, out of range second operand causes NIL value";
pattern <<(b:bat[:hge],v:bte) :bat[:hge]
address CMDbatLSHsignal
comment "Return B << V, raise error on out of range second operand";
pattern <<(b:bat[:hge],v:bte,s:bat[:oid]) :bat[:hge]
address CMDbatLSHsignal
comment "Return B << V with candidates list, raise error on out of range second operand";
pattern lsh_noerror(b:bat[:hge],v:bte) :bat[:hge]
address CMDbatLSH
comment "Return B << V, out of range second operand causes NIL value";
pattern lsh_noerror(b:bat[:hge],v:bte,s:bat[:oid]) :bat[:hge]
address CMDbatLSH
comment "Return B << V with candidates list, out of range second operand causes NIL value";
pattern <<(v:hge,b:bat[:bte]) :bat[:hge]
address CMDbatLSHsignal
comment "Return V << B, raise error on out of range second operand";
pattern <<(v:hge,b:bat[:bte],s:bat[:oid]) :bat[:hge]
address CMDbatLSHsignal
comment "Return V << B with candidates list, raise error on out of range second operand";
pattern lsh_noerror(v:hge,b:bat[:bte]) :bat[:hge]
address CMDbatLSH
comment "Return V << B, out of range second operand causes NIL value";
pattern lsh_noerror(v:hge,b:bat[:bte],s:bat[:oid]) :bat[:hge]
address CMDbatLSH
comment "Return V << B with candidates list, out of range second operand causes NIL value";

pattern <<(b1:bat[:hge],b2:bat[:sht]) :bat[:hge]
address CMDbatLSHsignal
comment "Return B1 << B2, raise error on out of range second operand";
pattern <<(b1:bat[:hge],b2:bat[:sht],s:bat[:oid]) :bat[:hge]
address CMDbatLSHsignal
comment "Return B1 << B2 with candidates list, raise error on out of range second operand";
pattern lsh_noerror(b1:bat[:hge],b2:bat[:sht]) :bat[:hge]
address CMDbatLSH
comment "Return B1 << B2, out of range second operand causes NIL value";
pattern lsh_noerror(b1:bat[:hge],b2:bat[:sht],s:bat[:oid]) :bat[:hge]
address CMDbatLSH
comment "Return B1 << B2 with candidates list, out of range second operand causes NIL value";
pattern <<(b:bat[:hge],v:sht) :bat[:hge]
address CMDbatLSHsignal
comment "Return B << V, raise error on out of range second operand";
pattern <<(b:bat[:hge],v:sht,s:bat[:oid]) :bat[:hge]
address CMDbatLSHsignal
comment "Return B << V with candidates list, raise error on out of range second operand";
pattern lsh_noerror(b:bat[:hge],v:sht) :bat[:hge]
address CMDbatLSH
comment "Return B << V, out of range second operand causes NIL value";
pattern lsh_noerror(b:bat[:hge],v:sht,s:bat[:oid]) :bat[:hge]
address CMDbatLSH
comment "Return B << V with candidates list, out of range second operand causes NIL value";
pattern <<(v:hge,b:bat[:sht]) :bat[:hge]
address CMDbatLSHsignal
comment "Return V << B, raise error on out of range second operand";
pattern <<(v:hge,b:bat[:sht],s:bat[:oid]) :bat[:hge]
address CMDbatLSHsignal
comment "Return V << B with candidates list, raise error on out of range second operand";
pattern lsh_noerror(v:hge,b:bat[:sht]) :bat[:hge]
address CMDbatLSH
comment "Return V << B, out of range second operand causes NIL value";
pattern lsh_noerror(v:hge,b:bat[:sht],s:bat[:oid]) :bat[:hge]
address CMDbatLSH
comment "Return V << B with candidates list, out of range second operand causes NIL value";

pattern <<(b1:bat[:hge],b2:bat[:int]) :bat[:hge]
address CMDbatLSHsignal
comment "Return B1 << B2, raise error on out of range second operand";
pattern <<(b1:bat[:hge],b2:bat[:int],s:bat[:oid]) :bat[:hge]
address CMDbatLSHsignal
comment "Return B1 << B2 with candidates list, raise error on out of range second operand";
pattern lsh_noerror(b1:bat[:hge],b2:bat[:int]) :bat[:hge]
address CMDbatLSH
comment "Return B1 << B2, out of range second operand causes NIL value";
pattern lsh_noerror(b1:bat[:hge],b2:bat[:int],s:bat[:oid]) :bat[:hge]
address CMDbatLSH
comment "Return B1 << B2 with candidates list, out of range second operand causes NIL value";
pattern <<(b:bat[:hge],v:int) :bat[:hge]
address CMDbatLSHsignal
comment "Return B << V, raise error on out of range second operand";
pattern <<(b:bat[:hge],v:int,s:bat[:oid]) :bat[:hge]
address CMDbatLSHsignal
comment "Return B << V with candidates list, raise error on out of range second operand";
pattern lsh_noerror(b:bat[:hge],v:int) :bat[:hge]
address CMDbatLSH
comment "Return B << V, out of range second operand causes NIL value";
pattern lsh_noerror(b:bat[:hge],v:int,s:bat[:oid]) :bat[:hge]
address CMDbatLSH
comment "Return B << V with candidates list, out of range second operand causes NIL value";
pattern <<(v:hge,b:bat[:int]) :bat[:hge]
address CMDbatLSHsignal
comment "Return V << B, raise error on out of range second operand";
pattern <<(v:hge,b:bat[:int],s:bat[:oid]) :bat[:hge]
address CMDbatLSHsignal
comment "Return V << B with candidates list, raise error on out of range second operand";
pattern lsh_noerror(v:hge,b:bat[:int]) :bat[:hge]
address CMDbatLSH
comment "Return V << B, out of range second operand causes NIL value";
pattern lsh_noerror(v:hge,b:bat[:int],s:bat[:oid]) :bat[:hge]
address CMDbatLSH
comment "Return V << B with candidates list, out of range second operand causes NIL value";

pattern <<(b1:bat[:hge],b2:bat[:lng]) :bat[:hge]
address CMDbatLSHsignal
comment "Return B1 << B2, raise error on out of range second operand";
pattern <<(b1:bat[:hge],b2:bat[:lng],s:bat[:oid]) :bat[:hge]
address CMDbatLSHsignal
comment "Return B1 << B2 with candidates list, raise error on out of range second operand";
pattern lsh_noerror(b1:bat[:hge],b2:bat[:lng]) :bat[:hge]
address CMDbatLSH
comment "Return B1 << B2, out of range second operand causes NIL value";
pattern lsh_noerror(b1:bat[:hge],b2:bat[:lng],s:bat[:oid]) :bat[:hge]
address CMDbatLSH
comment "Return B1 << B2 with candidates list, out of range second operand causes NIL value";
pattern <<(b:bat[:hge],v:lng) :bat[:hge]
address CMDbatLSHsignal
comment "Return B << V, raise error on out of range second operand";
pattern <<(b:bat[:hge],v:lng,s:bat[:oid]) :bat[:hge]
address CMDbatLSHsignal
comment "Return B << V with candidates list, raise error on out of range second operand";
pattern lsh_noerror(b:bat[:hge],v:lng) :bat[:hge]
address CMDbatLSH
comment "Return B << V, out of range second operand causes NIL value";
pattern lsh_noerror(b:bat[:hge],v:lng,s:bat[:oid]) :bat[:hge]
address CMDbatLSH
comment "Return B << V with candidates list, out of range second operand causes NIL value";
pattern <<(v:hge,b:bat[:lng]) :bat[:hge]
address CMDbatLSHsignal
comment "Return V << B, raise error on out of range second operand";
pattern <<(v:hge,b:bat[:lng],s:bat[:oid]) :bat[:hge]
address CMDbatLSHsignal
comment "Return V << B with candidates list, raise error on out of range second operand";
pattern lsh_noerror(v:hge,b:bat[:lng]) :bat[:hge]
address CMDbatLSH
comment "Return V << B, out of range second operand causes NIL value";
pattern lsh_noerror(v:hge,b:bat[:lng],s:bat[:oid]) :bat[:hge]
address CMDbatLSH
comment "Return V << B with candidates list, out of range second operand causes NIL value";

pattern <<(b1:bat[:hge],b2:bat[:hge]) :bat[:hge]
address CMDbatLSHsignal
comment "Return B1 << B2, raise error on out of range second operand";
pattern <<(b1:bat[:hge],b2:bat[:hge],s:bat[:oid]) :bat[:hge]
address CMDbatLSHsignal
comment "Return B1 << B2 with candidates list, raise error on out of range second operand";
pattern lsh_noerror(b1:bat[:hge],b2:bat[:hge]) :bat[:hge]
address CMDbatLSH
comment "Return B1 << B2, out of range second operand causes NIL value";
pattern lsh_noerror(b1:bat[:hge],b2:bat[:hge],s:bat[:oid]) :bat[:hge]
address CMDbatLSH
comment "Return B1 << B2 with candidates list, out of range second operand causes NIL value";
pattern <<(b:bat[:hge],v:hge) :bat[:hge]
address CMDbatLSHsignal
comment "Return B << V, raise error on out of range second operand";
pattern <<(b:bat[:hge],v:hge,s:bat[:oid]) :bat[:hge]
address CMDbatLSHsignal
comment "Return B << V with candidates list, raise error on out of range second operand";
pattern lsh_noerror(b:bat[:hge],v:hge) :bat[:hge]
address CMDbatLSH
comment "Return B << V, out of range second operand causes NIL value";
pattern lsh_noerror(b:bat[:hge],v:hge,s:bat[:oid]) :bat[:hge]
address CMDbatLSH
comment "Return B << V with candidates list, out of range second operand causes NIL value";
pattern <<(v:hge,b:bat[:hge]) :bat[:hge]
address CMDbatLSHsignal
comment "Return V << B, raise error on out of range second operand";
pattern <<(v:hge,b:bat[:hge],s:bat[:oid]) :bat[:hge]
address CMDbatLSHsignal
comment "Return V << B with candidates list, raise error on out of range second operand";
pattern lsh_noerror(v:hge,b:bat[:hge]) :bat[:hge]
address CMDbatLSH
comment "Return V << B, out of range second operand causes NIL value";
pattern lsh_noerror(v:hge,b:bat[:hge],s:bat[:oid]) :bat[:hge]
address CMDbatLSH
comment "Return V << B with candidates list, out of range second operand causes NIL value";


pattern >>(b1:bat[:bte],b2:bat[:hge]) :bat[:bte]
address CMDbatRSHsignal
comment "Return B1 >> B2, raise error on out of range second operand";
pattern >>(b1:bat[:bte],b2:bat[:hge],s:bat[:oid]) :bat[:bte]
address CMDbatRSHsignal
comment "Return B1 >> B2 with candidates list, raise error on out of range second operand";
pattern rsh_noerror(b1:bat[:bte],b2:bat[:hge]) :bat[:bte]
address CMDbatRSH
comment "Return B1 >> B2, out of range second operand causes NIL value";
pattern rsh_noerror(b1:bat[:bte],b2:bat[:hge],s:bat[:oid]) :bat[:bte]
address CMDbatRSH
comment "Return B1 >> B2 with candidates list, out of range second operand causes NIL value";
pattern >>(b:bat[:bte],v:hge) :bat[:bte]
address CMDbatRSHsignal
comment "Return B >> V, raise error on out of range second operand";
pattern >>(b:bat[:bte],v:hge,s:bat[:oid]) :bat[:bte]
address CMDbatRSHsignal
comment "Return B >> V with candidates list, raise error on out of range second operand";
pattern rsh_noerror(b:bat[:bte],v:hge) :bat[:bte]
address CMDbatRSH
comment "Return B >> V, out of range second operand causes NIL value";
pattern rsh_noerror(b:bat[:bte],v:hge,s:bat[:oid]) :bat[:bte]
address CMDbatRSH
comment "Return B >> V with candidates list, out of range second operand causes NIL value";
pattern >>(v:bte,b:bat[:hge]) :bat[:bte]
address CMDbatRSHsignal
comment "Return V >> B, raise error on out of range second operand";
pattern >>(v:bte,b:bat[:hge],s:bat[:oid]) :bat[:bte]
address CMDbatRSHsignal
comment "Return V >> B with candidates list, raise error on out of range second operand";
pattern rsh_noerror(v:bte,b:bat[:hge]) :bat[:bte]
address CMDbatRSH
comment "Return V >> B, out of range second operand causes NIL value";
pattern rsh_noerror(v:bte,b:bat[:hge],s:bat[:oid]) :bat[:bte]
address CMDbatRSH
comment "Return V >> B with candidates list, out of range second operand causes NIL value";

pattern >>(b1:bat[:sht],b2:bat[:hge]) :bat[:sht]
address CMDbatRSHsignal
comment "Return B1 >> B2, raise error on out of range second operand";
pattern >>(b1:bat[:sht],b2:bat[:hge],s:bat[:oid]) :bat[:sht]
address CMDbatRSHsignal
comment "Return B1 >> B2 with candidates list, raise error on out of range second operand";
pattern rsh_noerror(b1:bat[:sht],b2:bat[:hge]) :bat[:sht]
address CMDbatRSH
comment "Return B1 >> B2, out of range second operand causes NIL value";
pattern rsh_noerror(b1:bat[:sht],b2:bat[:hge],s:bat[:oid]) :bat[:sht]
address CMDbatRSH
comment "Return B1 >> B2 with candidates list, out of range second operand causes NIL value";
pattern >>(b:bat[:sht],v:hge) :bat[:sht]
address CMDbatRSHsignal
comment "Return B >> V, raise error on out of range second operand";
pattern >>(b:bat[:sht],v:hge,s:bat[:oid]) :bat[:sht]
address CMDbatRSHsignal
comment "Return B >> V with candidates list, raise error on out of range second operand";
pattern rsh_noerror(b:bat[:sht],v:hge) :bat[:sht]
address CMDbatRSH
comment "Return B >> V, out of range second operand causes NIL value";
pattern rsh_noerror(b:bat[:sht],v:hge,s:bat[:oid]) :bat[:sht]
address CMDbatRSH
comment "Return B >> V with candidates list, out of range second operand causes NIL value";
pattern >>(v:sht,b:bat[:hge]) :bat[:sht]
address CMDbatRSHsignal
comment "Return V >> B, raise error on out of range second operand";
pattern >>(v:sht,b:bat[:hge],s:bat[:oid]) :bat[:sht]
address CMDbatRSHsignal
comment "Return V >> B with candidates list, raise error on out of range second operand";
pattern rsh_noerror(v:sht,b:bat[:hge]) :bat[:sht]
address CMDbatRSH
comment "Return V >> B, out of range second operand causes NIL value";
pattern rsh_noerror(v:sht,b:bat[:hge],s:bat[:oid]) :bat[:sht]
address CMDbatRSH
comment "Return V >> B with candidates list, out of range second operand causes NIL value";

pattern >>(b1:bat[:int],b2:bat[:hge]) :bat[:int]
address CMDbatRSHsignal
comment "Return B1 >> B2, raise error on out of range second operand";
pattern >>(b1:bat[:int],b2:bat[:hge],s:bat[:oid]) :bat[:int]
address CMDbatRSHsignal
comment "Return B1 >> B2 with candidates list, raise error on out of range second operand";
pattern rsh_noerror(b1:bat[:int],b2:bat[:hge]) :bat[:int]
address CMDbatRSH
comment "Return B1 >> B2, out of range second operand causes NIL value";
pattern rsh_noerror(b1:bat[:int],b2:bat[:hge],s:bat[:oid]) :bat[:int]
address CMDbatRSH
comment "Return B1 >> B2 with candidates list, out of range second operand causes NIL value";
pattern >>(b:bat[:int],v:hge) :bat[:int]
address CMDbatRSHsignal
comment "Return B >> V, raise error on out of range second operand";
pattern >>(b:bat[:int],v:hge,s:bat[:oid]) :bat[:int]
address CMDbatRSHsignal
comment "Return B >> V with candidates list, raise error on out of range second operand";
pattern rsh_noerror(b:bat[:int],v:hge) :bat[:int]
address CMDbatRSH
comment "Return B >> V, out of range second operand causes NIL value";
pattern rsh_noerror(b:bat[:int],v:hge,s:bat[:oid]) :bat[:int]
address CMDbatRSH
comment "Return B >> V with candidates list, out of range second operand causes NIL value";
pattern >>(v:int,b:bat[:hge]) :bat[:int]
address CMDbatRSHsignal
comment "Return V >> B, raise error on out of range second operand";
pattern >>(v:int,b:bat[:hge],s:bat[:oid]) :bat[:int]
address CMDbatRSHsignal
comment "Return V >> B with candidates list, raise error on out of range second operand";
pattern rsh_noerror(v:int,b:bat[:hge]) :bat[:int]
address CMDbatRSH
comment "Return V >> B, out of range second operand causes NIL value";
pattern rsh_noerror(v:int,b:bat[:hge],s:bat[:oid]) :bat[:int]
address CMDbatRSH
comment "Return V >> B with candidates list, out of range second operand causes NIL value";

pattern >>(b1:bat[:lng],b2:bat[:hge]) :bat[:lng]
address CMDbatRSHsignal
comment "Return B1 >> B2, raise error on out of range second operand";
pattern >>(b1:bat[:lng],b2:bat[:hge],s:bat[:oid]) :bat[:lng]
address CMDbatRSHsignal
comment "Return B1 >> B2 with candidates list, raise error on out of range second operand";
pattern rsh_noerror(b1:bat[:lng],b2:bat[:hge]) :bat[:lng]
address CMDbatRSH
comment "Return B1 >> B2, out of range second operand causes NIL value";
pattern rsh_noerror(b1:bat[:lng],b2:bat[:hge],s:bat[:oid]) :bat[:lng]
address CMDbatRSH
comment "Return B1 >> B2 with candidates list, out of range second operand causes NIL value";
pattern >>(b:bat[:lng],v:hge) :bat[:lng]
address CMDbatRSHsignal
comment "Return B >> V, raise error on out of range second operand";
pattern >>(b:bat[:lng],v:hge,s:bat[:oid]) :bat[:lng]
address CMDbatRSHsignal
comment "Return B >> V with candidates list, raise error on out of range second operand";
pattern rsh_noerror(b:bat[:lng],v:hge) :bat[:lng]
address CMDbatRSH
comment "Return B >> V, out of range second operand causes NIL value";
pattern rsh_noerror(b:bat[:lng],v:hge,s:bat[:oid]) :bat[:lng]
address CMDbatRSH
comment "Return B >> V with candidates list, out of range second operand causes NIL value";
pattern >>(v:lng,b:bat[:hge]) :bat[:lng]
address CMDbatRSHsignal
comment "Return V >> B, raise error on out of range second operand";
pattern >>(v:lng,b:bat[:hge],s:bat[:oid]) :bat[:lng]
address CMDbatRSHsignal
comment "Return V >> B with candidates list, raise error on out of range second operand";
pattern rsh_noerror(v:lng,b:bat[:hge]) :bat[:lng]
address CMDbatRSH
comment "Return V >> B, out of range second operand causes NIL value";
pattern rsh_noerror(v:lng,b:bat[:hge],s:bat[:oid]) :bat[:lng]
address CMDbatRSH
comment "Return V >> B with candidates list, out of range second operand causes NIL value";

pattern >>(b1:bat[:hge],b2:bat[:bte]) :bat[:hge]
address CMDbatRSHsignal
comment "Return B1 >> B2, raise error on out of range second operand";
pattern >>(b1:bat[:hge],b2:bat[:bte],s:bat[:oid]) :bat[:hge]
address CMDbatRSHsignal
comment "Return B1 >> B2 with candidates list, raise error on out of range second operand";
pattern rsh_noerror(b1:bat[:hge],b2:bat[:bte]) :bat[:hge]
address CMDbatRSH
comment "Return B1 >> B2, out of range second operand causes NIL value";
pattern rsh_noerror(b1:bat[:hge],b2:bat[:bte],s:bat[:oid]) :bat[:hge]
address CMDbatRSH
comment "Return B1 >> B2 with candidates list, out of range second operand causes NIL value";
pattern >>(b:bat[:hge],v:bte) :bat[:hge]
address CMDbatRSHsignal
comment "Return B >> V, raise error on out of range second operand";
pattern >>(b:bat[:hge],v:bte,s:bat[:oid]) :bat[:hge]
address CMDbatRSHsignal
comment "Return B >> V with candidates list, raise error on out of range second operand";
pattern rsh_noerror(b:bat[:hge],v:bte) :bat[:hge]
address CMDbatRSH
comment "Return B >> V, out of range second operand causes NIL value";
pattern rsh_noerror(b:bat[:hge],v:bte,s:bat[:oid]) :bat[:hge]
address CMDbatRSH
comment "Return B >> V with candidates list, out of range second operand causes NIL value";
pattern >>(v:hge,b:bat[:bte]) :bat[:hge]
address CMDbatRSHsignal
comment "Return V >> B, raise error on out of range second operand";
pattern >>(v:hge,b:bat[:bte],s:bat[:oid]) :bat[:hge]
address CMDbatRSHsignal
comment "Return V >> B with candidates list, raise error on out of range second operand";
pattern rsh_noerror(v:hge,b:bat[:bte]) :bat[:hge]
address CMDbatRSH
comment "Return V >> B, out of range second operand causes NIL value";
pattern rsh_noerror(v:hge,b:bat[:bte],s:bat[:oid]) :bat[:hge]
address CMDbatRSH
comment "Return V >> B with candidates list, out of range second operand causes NIL value";

pattern >>(b1:bat[:hge],b2:bat[:sht]) :bat[:hge]
address CMDbatRSHsignal
comment "Return B1 >> B2, raise error on out of range second operand";
pattern >>(b1:bat[:hge],b2:bat[:sht],s:bat[:oid]) :bat[:hge]
address CMDbatRSHsignal
comment "Return B1 >> B2 with candidates list, raise error on out of range second operand";
pattern rsh_noerror(b1:bat[:hge],b2:bat[:sht]) :bat[:hge]
address CMDbatRSH
comment "Return B1 >> B2, out of range second operand causes NIL value";
pattern rsh_noerror(b1:bat[:hge],b2:bat[:sht],s:bat[:oid]) :bat[:hge]
address CMDbatRSH
comment "Return B1 >> B2 with candidates list, out of range second operand causes NIL value";
pattern >>(b:bat[:hge],v:sht) :bat[:hge]
address CMDbatRSHsignal
comment "Return B >> V, raise error on out of range second operand";
pattern >>(b:bat[:hge],v:sht,s:bat[:oid]) :bat[:hge]
address CMDbatRSHsignal
comment "Return B >> V with candidates list, raise error on out of range second operand";
pattern rsh_noerror(b:bat[:hge],v:sht) :bat[:hge]
address CMDbatRSH
comment "Return B >> V, out of range second operand causes NIL value";
pattern rsh_noerror(b:bat[:hge],v:sht,s:bat[:oid]) :bat[:hge]
address CMDbatRSH
comment "Return B >> V with candidates list, out of range second operand causes NIL value";
pattern >>(v:hge,b:bat[:sht]) :bat[:hge]
address CMDbatRSHsignal
comment "Return V >> B, raise error on out of range second operand";
pattern >>(v:hge,b:bat[:sht],s:bat[:oid]) :bat[:hge]
address CMDbatRSHsignal
comment "Return V >> B with candidates list, raise error on out of range second operand";
pattern rsh_noerror(v:hge,b:bat[:sht]) :bat[:hge]
address CMDbatRSH
comment "Return V >> B, out of range second operand causes NIL value";
pattern rsh_noerror(v:hge,b:bat[:sht],s:bat[:oid]) :bat[:hge]
address CMDbatRSH
comment "Return V >> B with candidates list, out of range second operand causes NIL value";

pattern >>(b1:bat[:hge],b2:bat[:int]) :bat[:hge]
address CMDbatRSHsignal
comment "Return B1 >> B2, raise error on out of range second operand";
pattern >>(b1:bat[:hge],b2:bat[:int],s:bat[:oid]) :bat[:hge]
address CMDbatRSHsignal
comment "Return B1 >> B2 with candidates list, raise error on out of range second operand";
pattern rsh_noerror(b1:bat[:hge],b2:bat[:int]) :bat[:hge]
address CMDbatRSH
comment "Return B1 >> B2, out of range second operand causes NIL value";
pattern rsh_noerror(b1:bat[:hge],b2:bat[:int],s:bat[:oid]) :bat[:hge]
address CMDbatRSH
comment "Return B1 >> B2 with candidates list, out of range second operand causes NIL value";
pattern >>(b:bat[:hge],v:int) :bat[:hge]
address CMDbatRSHsignal
comment "Return B >> V, raise error on out of range second operand";
pattern >>(b:bat[:hge],v:int,s:bat[:oid]) :bat[:hge]
address CMDbatRSHsignal
comment "Return B >> V with candidates list, raise error on out of range second operand";
pattern rsh_noerror(b:bat[:hge],v:int) :bat[:hge]
address CMDbatRSH
comment "Return B >> V, out of range second operand causes NIL value";
pattern rsh_noerror(b:bat[:hge],v:int,s:bat[:oid]) :bat[:hge]
address CMDbatRSH
comment "Return B >> V with candidates list, out of range second operand causes NIL value";
pattern >>(v:hge,b:bat[:int]) :bat[:hge]
address CMDbatRSHsignal
comment "Return V >> B, raise error on out of range second operand";
pattern >>(v:hge,b:bat[:int],s:bat[:oid]) :bat[:hge]
address CMDbatRSHsignal
comment "Return V >> B with candidates list, raise error on out of range second operand";
pattern rsh_noerror(v:hge,b:bat[:int]) :bat[:hge]
address CMDbatRSH
comment "Return V >> B, out of range second operand causes NIL value";
pattern rsh_noerror(v:hge,b:bat[:int],s:bat[:oid]) :bat[:hge]
address CMDbatRSH
comment "Return V >> B with candidates list, out of range second operand causes NIL value";

pattern >>(b1:bat[:hge],b2:bat[:lng]) :bat[:hge]
address CMDbatRSHsignal
comment "Return B1 >> B2, raise error on out of range second operand";
pattern >>(b1:bat[:hge],b2:bat[:lng],s:bat[:oid]) :bat[:hge]
address CMDbatRSHsignal
comment "Return B1 >> B2 with candidates list, raise error on out of range second operand";
pattern rsh_noerror(b1:bat[:hge],b2:bat[:lng]) :bat[:hge]
address CMDbatRSH
comment "Return B1 >> B2, out of range second operand causes NIL value";
pattern rsh_noerror(b1:bat[:hge],b2:bat[:lng],s:bat[:oid]) :bat[:hge]
address CMDbatRSH
comment "Return B1 >> B2 with candidates list, out of range second operand causes NIL value";
pattern >>(b:bat[:hge],v:lng) :bat[:hge]
address CMDbatRSHsignal
comment "Return B >> V, raise error on out of range second operand";
pattern >>(b:bat[:hge],v:lng,s:bat[:oid]) :bat[:hge]
address CMDbatRSHsignal
comment "Return B >> V with candidates list, raise error on out of range second operand";
pattern rsh_noerror(b:bat[:hge],v:lng) :bat[:hge]
address CMDbatRSH
comment "Return B >> V, out of range second operand causes NIL value";
pattern rsh_noerror(b:bat[:hge],v:lng,s:bat[:oid]) :bat[:hge]
address CMDbatRSH
comment "Return B >> V with candidates list, out of range second operand causes NIL value";
pattern >>(v:hge,b:bat[:lng]) :bat[:hge]
address CMDbatRSHsignal
comment "Return V >> B, raise error on out of range second operand";
pattern >>(v:hge,b:bat[:lng],s:bat[:oid]) :bat[:hge]
address CMDbatRSHsignal
comment "Return V >> B with candidates list, raise error on out of range second operand";
pattern rsh_noerror(v:hge,b:bat[:lng]) :bat[:hge]
address CMDbatRSH
comment "Return V >> B, out of range second operand causes NIL value";
pattern rsh_noerror(v:hge,b:bat[:lng],s:bat[:oid]) :bat[:hge]
address CMDbatRSH
comment "Return V >> B with candidates list, out of range second operand causes NIL value";

pattern >>(b1:bat[:hge],b2:bat[:hge]) :bat[:hge]
address CMDbatRSHsignal
comment "Return B1 >> B2, raise error on out of range second operand";
pattern >>(b1:bat[:hge],b2:bat[:hge],s:bat[:oid]) :bat[:hge]
address CMDbatRSHsignal
comment "Return B1 >> B2 with candidates list, raise error on out of range second operand";
pattern rsh_noerror(b1:bat[:hge],b2:bat[:hge]) :bat[:hge]
address CMDbatRSH
comment "Return B1 >> B2, out of range second operand causes NIL value";
pattern rsh_noerror(b1:bat[:hge],b2:bat[:hge],s:bat[:oid]) :bat[:hge]
address CMDbatRSH
comment "Return B1 >> B2 with candidates list, out of range second operand causes NIL value";
pattern >>(b:bat[:hge],v:hge) :bat[:hge]
address CMDbatRSHsignal
comment "Return B >> V, raise error on out of range second operand";
pattern >>(b:bat[:hge],v:hge,s:bat[:oid]) :bat[:hge]
address CMDbatRSHsignal
comment "Return B >> V with candidates list, raise error on out of range second operand";
pattern rsh_noerror(b:bat[:hge],v:hge) :bat[:hge]
address CMDbatRSH
comment "Return B >> V, out of range second operand causes NIL value";
pattern rsh_noerror(b:bat[:hge],v:hge,s:bat[:oid]) :bat[:hge]
address CMDbatRSH
comment "Return B >> V with candidates list, out of range second operand causes NIL value";
pattern >>(v:hge,b:bat[:hge]) :bat[:hge]
address CMDbatRSHsignal
comment "Return V >> B, raise error on out of range second operand";
pattern >>(v:hge,b:bat[:hge],s:bat[:oid]) :bat[:hge]
address CMDbatRSHsignal
comment "Return V >> B with candidates list, raise error on out of range second operand";
pattern rsh_noerror(v:hge,b:bat[:hge]) :bat[:hge]
address CMDbatRSH
comment "Return V >> B, out of range second operand causes NIL value";
pattern rsh_noerror(v:hge,b:bat[:hge],s:bat[:oid]) :bat[:hge]
address CMDbatRSH
comment "Return V >> B with candidates list, out of range second operand causes NIL value";


pattern <(b1:bat[:bte],b2:bat[:hge]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b1:bat[:bte],b2:bat[:hge],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2 with candidates list";
pattern <(b:bat[:bte],v:hge) :bat[:bit]
address CMDbatLT
comment "Return B < V";
pattern <(b:bat[:bte],v:hge,s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B < V with candidates list";
pattern <(v:bte,b:bat[:hge]) :bat[:bit]
address CMDbatLT
comment "Return V < B";
pattern <(v:bte,b:bat[:hge],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return V < B with candidates list";

pattern <(b1:bat[:sht],b2:bat[:hge]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b1:bat[:sht],b2:bat[:hge],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2 with candidates list";
pattern <(b:bat[:sht],v:hge) :bat[:bit]
address CMDbatLT
comment "Return B < V";
pattern <(b:bat[:sht],v:hge,s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B < V with candidates list";
pattern <(v:sht,b:bat[:hge]) :bat[:bit]
address CMDbatLT
comment "Return V < B";
pattern <(v:sht,b:bat[:hge],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return V < B with candidates list";

pattern <(b1:bat[:int],b2:bat[:hge]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b1:bat[:int],b2:bat[:hge],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2 with candidates list";
pattern <(b:bat[:int],v:hge) :bat[:bit]
address CMDbatLT
comment "Return B < V";
pattern <(b:bat[:int],v:hge,s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B < V with candidates list";
pattern <(v:int,b:bat[:hge]) :bat[:bit]
address CMDbatLT
comment "Return V < B";
pattern <(v:int,b:bat[:hge],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return V < B with candidates list";

pattern <(b1:bat[:lng],b2:bat[:hge]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b1:bat[:lng],b2:bat[:hge],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2 with candidates list";
pattern <(b:bat[:lng],v:hge) :bat[:bit]
address CMDbatLT
comment "Return B < V";
pattern <(b:bat[:lng],v:hge,s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B < V with candidates list";
pattern <(v:lng,b:bat[:hge]) :bat[:bit]
address CMDbatLT
comment "Return V < B";
pattern <(v:lng,b:bat[:hge],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return V < B with candidates list";

pattern <(b1:bat[:hge],b2:bat[:bte]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b1:bat[:hge],b2:bat[:bte],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2 with candidates list";
pattern <(b:bat[:hge],v:bte) :bat[:bit]
address CMDbatLT
comment "Return B < V";
pattern <(b:bat[:hge],v:bte,s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B < V with candidates list";
pattern <(v:hge,b:bat[:bte]) :bat[:bit]
address CMDbatLT
comment "Return V < B";
pattern <(v:hge,b:bat[:bte],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return V < B with candidates list";

pattern <(b1:bat[:hge],b2:bat[:sht]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b1:bat[:hge],b2:bat[:sht],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2 with candidates list";
pattern <(b:bat[:hge],v:sht) :bat[:bit]
address CMDbatLT
comment "Return B < V";
pattern <(b:bat[:hge],v:sht,s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B < V with candidates list";
pattern <(v:hge,b:bat[:sht]) :bat[:bit]
address CMDbatLT
comment "Return V < B";
pattern <(v:hge,b:bat[:sht],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return V < B with candidates list";

pattern <(b1:bat[:hge],b2:bat[:int]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b1:bat[:hge],b2:bat[:int],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2 with candidates list";
pattern <(b:bat[:hge],v:int) :bat[:bit]
address CMDbatLT
comment "Return B < V";
pattern <(b:bat[:hge],v:int,s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B < V with candidates list";
pattern <(v:hge,b:bat[:int]) :bat[:bit]
address CMDbatLT
comment "Return V < B";
pattern <(v:hge,b:bat[:int],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return V < B with candidates list";

pattern <(b1:bat[:hge],b2:bat[:lng]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b1:bat[:hge],b2:bat[:lng],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2 with candidates list";
pattern <(b:bat[:hge],v:lng) :bat[:bit]
address CMDbatLT
comment "Return B < V";
pattern <(b:bat[:hge],v:lng,s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B < V with candidates list";
pattern <(v:hge,b:bat[:lng]) :bat[:bit]
address CMDbatLT
comment "Return V < B";
pattern <(v:hge,b:bat[:lng],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return V < B with candidates list";

pattern <(b1:bat[:hge],b2:bat[:hge]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b1:bat[:hge],b2:bat[:hge],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2 with candidates list";
pattern <(b:bat[:hge],v:hge) :bat[:bit]
address CMDbatLT
comment "Return B < V";
pattern <(b:bat[:hge],v:hge,s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B < V with candidates list";
pattern <(v:hge,b:bat[:hge]) :bat[:bit]
address CMDbatLT
comment "Return V < B";
pattern <(v:hge,b:bat[:hge],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return V < B with candidates list";

pattern <(b1:bat[:hge],b2:bat[:flt]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b1:bat[:hge],b2:bat[:flt],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2 with candidates list";
pattern <(b:bat[:hge],v:flt) :bat[:bit]
address CMDbatLT
comment "Return B < V";
pattern <(b:bat[:hge],v:flt,s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B < V with candidates list";
pattern <(v:hge,b:bat[:flt]) :bat[:bit]
address CMDbatLT
comment "Return V < B";
pattern <(v:hge,b:bat[:flt],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return V < B with candidates list";

pattern <(b1:bat[:hge],b2:bat[:dbl]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b1:bat[:hge],b2:bat[:dbl],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2 with candidates list";
pattern <(b:bat[:hge],v:dbl) :bat[:bit]
address CMDbatLT
comment "Return B < V";
pattern <(b:bat[:hge],v:dbl,s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B < V with candidates list";
pattern <(v:hge,b:bat[:dbl]) :bat[:bit]
address CMDbatLT
comment "Return V < B";
pattern <(v:hge,b:bat[:dbl],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return V < B with candidates list";

pattern <(b1:bat[:flt],b2:bat[:hge]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b1:bat[:flt],b2:bat[:hge],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2 with candidates list";
pattern <(b:bat[:flt],v:hge) :bat[:bit]
address CMDbatLT
comment "Return B < V";
pattern <(b:bat[:flt],v:hge,s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B < V with candidates list";
pattern <(v:flt,b:bat[:hge]) :bat[:bit]
address CMDbatLT
comment "Return V < B";
pattern <(v:flt,b:bat[:hge],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return V < B with candidates list";

pattern <(b1:bat[:dbl],b2:bat[:hge]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b1:bat[:dbl],b2:bat[:hge],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B1 < B2 with candidates list";
pattern <(b:bat[:dbl],v:hge) :bat[:bit]
address CMDbatLT
comment "Return B < V";
pattern <(b:bat[:dbl],v:hge,s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return B < V with candidates list";
pattern <(v:dbl,b:bat[:hge]) :bat[:bit]
address CMDbatLT
comment "Return V < B";
pattern <(v:dbl,b:bat[:hge],s:bat[:oid]) :bat[:bit]
address CMDbatLT
comment "Return V < B with candidates list";


pattern <=(b1:bat[:bte],b2:bat[:hge]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b1:bat[:bte],b2:bat[:hge],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2 with candidates list";
pattern <=(b:bat[:bte],v:hge) :bat[:bit]
address CMDbatLE
comment "Return B <= V";
pattern <=(b:bat[:bte],v:hge,s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B <= V with candidates list";
pattern <=(v:bte,b:bat[:hge]) :bat[:bit]
address CMDbatLE
comment "Return V <= B";
pattern <=(v:bte,b:bat[:hge],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return V <= B with candidates list";

pattern <=(b1:bat[:sht],b2:bat[:hge]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b1:bat[:sht],b2:bat[:hge],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2 with candidates list";
pattern <=(b:bat[:sht],v:hge) :bat[:bit]
address CMDbatLE
comment "Return B <= V";
pattern <=(b:bat[:sht],v:hge,s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B <= V with candidates list";
pattern <=(v:sht,b:bat[:hge]) :bat[:bit]
address CMDbatLE
comment "Return V <= B";
pattern <=(v:sht,b:bat[:hge],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return V <= B with candidates list";

pattern <=(b1:bat[:int],b2:bat[:hge]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b1:bat[:int],b2:bat[:hge],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2 with candidates list";
pattern <=(b:bat[:int],v:hge) :bat[:bit]
address CMDbatLE
comment "Return B <= V";
pattern <=(b:bat[:int],v:hge,s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B <= V with candidates list";
pattern <=(v:int,b:bat[:hge]) :bat[:bit]
address CMDbatLE
comment "Return V <= B";
pattern <=(v:int,b:bat[:hge],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return V <= B with candidates list";

pattern <=(b1:bat[:lng],b2:bat[:hge]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b1:bat[:lng],b2:bat[:hge],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2 with candidates list";
pattern <=(b:bat[:lng],v:hge) :bat[:bit]
address CMDbatLE
comment "Return B <= V";
pattern <=(b:bat[:lng],v:hge,s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B <= V with candidates list";
pattern <=(v:lng,b:bat[:hge]) :bat[:bit]
address CMDbatLE
comment "Return V <= B";
pattern <=(v:lng,b:bat[:hge],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return V <= B with candidates list";

pattern <=(b1:bat[:hge],b2:bat[:bte]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b1:bat[:hge],b2:bat[:bte],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2 with candidates list";
pattern <=(b:bat[:hge],v:bte) :bat[:bit]
address CMDbatLE
comment "Return B <= V";
pattern <=(b:bat[:hge],v:bte,s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B <= V with candidates list";
pattern <=(v:hge,b:bat[:bte]) :bat[:bit]
address CMDbatLE
comment "Return V <= B";
pattern <=(v:hge,b:bat[:bte],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return V <= B with candidates list";

pattern <=(b1:bat[:hge],b2:bat[:sht]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b1:bat[:hge],b2:bat[:sht],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2 with candidates list";
pattern <=(b:bat[:hge],v:sht) :bat[:bit]
address CMDbatLE
comment "Return B <= V";
pattern <=(b:bat[:hge],v:sht,s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B <= V with candidates list";
pattern <=(v:hge,b:bat[:sht]) :bat[:bit]
address CMDbatLE
comment "Return V <= B";
pattern <=(v:hge,b:bat[:sht],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return V <= B with candidates list";

pattern <=(b1:bat[:hge],b2:bat[:int]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b1:bat[:hge],b2:bat[:int],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2 with candidates list";
pattern <=(b:bat[:hge],v:int) :bat[:bit]
address CMDbatLE
comment "Return B <= V";
pattern <=(b:bat[:hge],v:int,s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B <= V with candidates list";
pattern <=(v:hge,b:bat[:int]) :bat[:bit]
address CMDbatLE
comment "Return V <= B";
pattern <=(v:hge,b:bat[:int],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return V <= B with candidates list";

pattern <=(b1:bat[:hge],b2:bat[:lng]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b1:bat[:hge],b2:bat[:lng],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2 with candidates list";
pattern <=(b:bat[:hge],v:lng) :bat[:bit]
address CMDbatLE
comment "Return B <= V";
pattern <=(b:bat[:hge],v:lng,s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B <= V with candidates list";
pattern <=(v:hge,b:bat[:lng]) :bat[:bit]
address CMDbatLE
comment "Return V <= B";
pattern <=(v:hge,b:bat[:lng],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return V <= B with candidates list";

pattern <=(b1:bat[:hge],b2:bat[:hge]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b1:bat[:hge],b2:bat[:hge],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2 with candidates list";
pattern <=(b:bat[:hge],v:hge) :bat[:bit]
address CMDbatLE
comment "Return B <= V";
pattern <=(b:bat[:hge],v:hge,s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B <= V with candidates list";
pattern <=(v:hge,b:bat[:hge]) :bat[:bit]
address CMDbatLE
comment "Return V <= B";
pattern <=(v:hge,b:bat[:hge],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return V <= B with candidates list";

pattern <=(b1:bat[:hge],b2:bat[:flt]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b1:bat[:hge],b2:bat[:flt],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2 with candidates list";
pattern <=(b:bat[:hge],v:flt) :bat[:bit]
address CMDbatLE
comment "Return B <= V";
pattern <=(b:bat[:hge],v:flt,s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B <= V with candidates list";
pattern <=(v:hge,b:bat[:flt]) :bat[:bit]
address CMDbatLE
comment "Return V <= B";
pattern <=(v:hge,b:bat[:flt],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return V <= B with candidates list";

pattern <=(b1:bat[:hge],b2:bat[:dbl]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b1:bat[:hge],b2:bat[:dbl],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2 with candidates list";
pattern <=(b:bat[:hge],v:dbl) :bat[:bit]
address CMDbatLE
comment "Return B <= V";
pattern <=(b:bat[:hge],v:dbl,s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B <= V with candidates list";
pattern <=(v:hge,b:bat[:dbl]) :bat[:bit]
address CMDbatLE
comment "Return V <= B";
pattern <=(v:hge,b:bat[:dbl],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return V <= B with candidates list";

pattern <=(b1:bat[:flt],b2:bat[:hge]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b1:bat[:flt],b2:bat[:hge],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2 with candidates list";
pattern <=(b:bat[:flt],v:hge) :bat[:bit]
address CMDbatLE
comment "Return B <= V";
pattern <=(b:bat[:flt],v:hge,s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B <= V with candidates list";
pattern <=(v:flt,b:bat[:hge]) :bat[:bit]
address CMDbatLE
comment "Return V <= B";
pattern <=(v:flt,b:bat[:hge],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return V <= B with candidates list";

pattern <=(b1:bat[:dbl],b2:bat[:hge]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b1:bat[:dbl],b2:bat[:hge],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B1 <= B2 with candidates list";
pattern <=(b:bat[:dbl],v:hge) :bat[:bit]
address CMDbatLE
comment "Return B <= V";
pattern <=(b:bat[:dbl],v:hge,s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return B <= V with candidates list";
pattern <=(v:dbl,b:bat[:hge]) :bat[:bit]
address CMDbatLE
comment "Return V <= B";
pattern <=(v:dbl,b:bat[:hge],s:bat[:oid]) :bat[:bit]
address CMDbatLE
comment "Return V <= B with candidates list";


pattern >(b1:bat[:bte],b2:bat[:hge]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b1:bat[:bte],b2:bat[:hge],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2 with candidates list";
pattern >(b:bat[:bte],v:hge) :bat[:bit]
address CMDbatGT
comment "Return B > V";
pattern >(b:bat[:bte],v:hge,s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B > V with candidates list";
pattern >(v:bte,b:bat[:hge]) :bat[:bit]
address CMDbatGT
comment "Return V > B";
pattern >(v:bte,b:bat[:hge],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return V > B with candidates list";

pattern >(b1:bat[:sht],b2:bat[:hge]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b1:bat[:sht],b2:bat[:hge],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2 with candidates list";
pattern >(b:bat[:sht],v:hge) :bat[:bit]
address CMDbatGT
comment "Return B > V";
pattern >(b:bat[:sht],v:hge,s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B > V with candidates list";
pattern >(v:sht,b:bat[:hge]) :bat[:bit]
address CMDbatGT
comment "Return V > B";
pattern >(v:sht,b:bat[:hge],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return V > B with candidates list";

pattern >(b1:bat[:int],b2:bat[:hge]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b1:bat[:int],b2:bat[:hge],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2 with candidates list";
pattern >(b:bat[:int],v:hge) :bat[:bit]
address CMDbatGT
comment "Return B > V";
pattern >(b:bat[:int],v:hge,s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B > V with candidates list";
pattern >(v:int,b:bat[:hge]) :bat[:bit]
address CMDbatGT
comment "Return V > B";
pattern >(v:int,b:bat[:hge],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return V > B with candidates list";

pattern >(b1:bat[:lng],b2:bat[:hge]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b1:bat[:lng],b2:bat[:hge],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2 with candidates list";
pattern >(b:bat[:lng],v:hge) :bat[:bit]
address CMDbatGT
comment "Return B > V";
pattern >(b:bat[:lng],v:hge,s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B > V with candidates list";
pattern >(v:lng,b:bat[:hge]) :bat[:bit]
address CMDbatGT
comment "Return V > B";
pattern >(v:lng,b:bat[:hge],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return V > B with candidates list";

pattern >(b1:bat[:hge],b2:bat[:bte]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b1:bat[:hge],b2:bat[:bte],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2 with candidates list";
pattern >(b:bat[:hge],v:bte) :bat[:bit]
address CMDbatGT
comment "Return B > V";
pattern >(b:bat[:hge],v:bte,s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B > V with candidates list";
pattern >(v:hge,b:bat[:bte]) :bat[:bit]
address CMDbatGT
comment "Return V > B";
pattern >(v:hge,b:bat[:bte],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return V > B with candidates list";

pattern >(b1:bat[:hge],b2:bat[:sht]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b1:bat[:hge],b2:bat[:sht],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2 with candidates list";
pattern >(b:bat[:hge],v:sht) :bat[:bit]
address CMDbatGT
comment "Return B > V";
pattern >(b:bat[:hge],v:sht,s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B > V with candidates list";
pattern >(v:hge,b:bat[:sht]) :bat[:bit]
address CMDbatGT
comment "Return V > B";
pattern >(v:hge,b:bat[:sht],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return V > B with candidates list";

pattern >(b1:bat[:hge],b2:bat[:int]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b1:bat[:hge],b2:bat[:int],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2 with candidates list";
pattern >(b:bat[:hge],v:int) :bat[:bit]
address CMDbatGT
comment "Return B > V";
pattern >(b:bat[:hge],v:int,s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B > V with candidates list";
pattern >(v:hge,b:bat[:int]) :bat[:bit]
address CMDbatGT
comment "Return V > B";
pattern >(v:hge,b:bat[:int],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return V > B with candidates list";

pattern >(b1:bat[:hge],b2:bat[:lng]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b1:bat[:hge],b2:bat[:lng],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2 with candidates list";
pattern >(b:bat[:hge],v:lng) :bat[:bit]
address CMDbatGT
comment "Return B > V";
pattern >(b:bat[:hge],v:lng,s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B > V with candidates list";
pattern >(v:hge,b:bat[:lng]) :bat[:bit]
address CMDbatGT
comment "Return V > B";
pattern >(v:hge,b:bat[:lng],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return V > B with candidates list";

pattern >(b1:bat[:hge],b2:bat[:hge]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b1:bat[:hge],b2:bat[:hge],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2 with candidates list";
pattern >(b:bat[:hge],v:hge) :bat[:bit]
address CMDbatGT
comment "Return B > V";
pattern >(b:bat[:hge],v:hge,s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B > V with candidates list";
pattern >(v:hge,b:bat[:hge]) :bat[:bit]
address CMDbatGT
comment "Return V > B";
pattern >(v:hge,b:bat[:hge],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return V > B with candidates list";

pattern >(b1:bat[:hge],b2:bat[:flt]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b1:bat[:hge],b2:bat[:flt],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2 with candidates list";
pattern >(b:bat[:hge],v:flt) :bat[:bit]
address CMDbatGT
comment "Return B > V";
pattern >(b:bat[:hge],v:flt,s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B > V with candidates list";
pattern >(v:hge,b:bat[:flt]) :bat[:bit]
address CMDbatGT
comment "Return V > B";
pattern >(v:hge,b:bat[:flt],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return V > B with candidates list";

pattern >(b1:bat[:hge],b2:bat[:dbl]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b1:bat[:hge],b2:bat[:dbl],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2 with candidates list";
pattern >(b:bat[:hge],v:dbl) :bat[:bit]
address CMDbatGT
comment "Return B > V";
pattern >(b:bat[:hge],v:dbl,s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B > V with candidates list";
pattern >(v:hge,b:bat[:dbl]) :bat[:bit]
address CMDbatGT
comment "Return V > B";
pattern >(v:hge,b:bat[:dbl],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return V > B with candidates list";

pattern >(b1:bat[:flt],b2:bat[:hge]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b1:bat[:flt],b2:bat[:hge],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2 with candidates list";
pattern >(b:bat[:flt],v:hge) :bat[:bit]
address CMDbatGT
comment "Return B > V";
pattern >(b:bat[:flt],v:hge,s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B > V with candidates list";
pattern >(v:flt,b:bat[:hge]) :bat[:bit]
address CMDbatGT
comment "Return V > B";
pattern >(v:flt,b:bat[:hge],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return V > B with candidates list";

pattern >(b1:bat[:dbl],b2:bat[:hge]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b1:bat[:dbl],b2:bat[:hge],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B1 > B2 with candidates list";
pattern >(b:bat[:dbl],v:hge) :bat[:bit]
address CMDbatGT
comment "Return B > V";
pattern >(b:bat[:dbl],v:hge,s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return B > V with candidates list";
pattern >(v:dbl,b:bat[:hge]) :bat[:bit]
address CMDbatGT
comment "Return V > B";
pattern >(v:dbl,b:bat[:hge],s:bat[:oid]) :bat[:bit]
address CMDbatGT
comment "Return V > B with candidates list";


pattern >=(b1:bat[:bte],b2:bat[:hge]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b1:bat[:bte],b2:bat[:hge],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2 with candidates list";
pattern >=(b:bat[:bte],v:hge) :bat[:bit]
address CMDbatGE
comment "Return B >= V";
pattern >=(b:bat[:bte],v:hge,s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B >= V with candidates list";
pattern >=(v:bte,b:bat[:hge]) :bat[:bit]
address CMDbatGE
comment "Return V >= B";
pattern >=(v:bte,b:bat[:hge],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return V >= B with candidates list";

pattern >=(b1:bat[:sht],b2:bat[:hge]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b1:bat[:sht],b2:bat[:hge],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2 with candidates list";
pattern >=(b:bat[:sht],v:hge) :bat[:bit]
address CMDbatGE
comment "Return B >= V";
pattern >=(b:bat[:sht],v:hge,s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B >= V with candidates list";
pattern >=(v:sht,b:bat[:hge]) :bat[:bit]
address CMDbatGE
comment "Return V >= B";
pattern >=(v:sht,b:bat[:hge],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return V >= B with candidates list";

pattern >=(b1:bat[:int],b2:bat[:hge]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b1:bat[:int],b2:bat[:hge],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2 with candidates list";
pattern >=(b:bat[:int],v:hge) :bat[:bit]
address CMDbatGE
comment "Return B >= V";
pattern >=(b:bat[:int],v:hge,s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B >= V with candidates list";
pattern >=(v:int,b:bat[:hge]) :bat[:bit]
address CMDbatGE
comment "Return V >= B";
pattern >=(v:int,b:bat[:hge],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return V >= B with candidates list";

pattern >=(b1:bat[:lng],b2:bat[:hge]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b1:bat[:lng],b2:bat[:hge],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2 with candidates list";
pattern >=(b:bat[:lng],v:hge) :bat[:bit]
address CMDbatGE
comment "Return B >= V";
pattern >=(b:bat[:lng],v:hge,s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B >= V with candidates list";
pattern >=(v:lng,b:bat[:hge]) :bat[:bit]
address CMDbatGE
comment "Return V >= B";
pattern >=(v:lng,b:bat[:hge],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return V >= B with candidates list";

pattern >=(b1:bat[:hge],b2:bat[:bte]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b1:bat[:hge],b2:bat[:bte],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2 with candidates list";
pattern >=(b:bat[:hge],v:bte) :bat[:bit]
address CMDbatGE
comment "Return B >= V";
pattern >=(b:bat[:hge],v:bte,s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B >= V with candidates list";
pattern >=(v:hge,b:bat[:bte]) :bat[:bit]
address CMDbatGE
comment "Return V >= B";
pattern >=(v:hge,b:bat[:bte],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return V >= B with candidates list";

pattern >=(b1:bat[:hge],b2:bat[:sht]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b1:bat[:hge],b2:bat[:sht],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2 with candidates list";
pattern >=(b:bat[:hge],v:sht) :bat[:bit]
address CMDbatGE
comment "Return B >= V";
pattern >=(b:bat[:hge],v:sht,s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B >= V with candidates list";
pattern >=(v:hge,b:bat[:sht]) :bat[:bit]
address CMDbatGE
comment "Return V >= B";
pattern >=(v:hge,b:bat[:sht],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return V >= B with candidates list";

pattern >=(b1:bat[:hge],b2:bat[:int]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b1:bat[:hge],b2:bat[:int],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2 with candidates list";
pattern >=(b:bat[:hge],v:int) :bat[:bit]
address CMDbatGE
comment "Return B >= V";
pattern >=(b:bat[:hge],v:int,s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B >= V with candidates list";
pattern >=(v:hge,b:bat[:int]) :bat[:bit]
address CMDbatGE
comment "Return V >= B";
pattern >=(v:hge,b:bat[:int],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return V >= B with candidates list";

pattern >=(b1:bat[:hge],b2:bat[:lng]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b1:bat[:hge],b2:bat[:lng],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2 with candidates list";
pattern >=(b:bat[:hge],v:lng) :bat[:bit]
address CMDbatGE
comment "Return B >= V";
pattern >=(b:bat[:hge],v:lng,s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B >= V with candidates list";
pattern >=(v:hge,b:bat[:lng]) :bat[:bit]
address CMDbatGE
comment "Return V >= B";
pattern >=(v:hge,b:bat[:lng],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return V >= B with candidates list";

pattern >=(b1:bat[:hge],b2:bat[:hge]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b1:bat[:hge],b2:bat[:hge],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2 with candidates list";
pattern >=(b:bat[:hge],v:hge) :bat[:bit]
address CMDbatGE
comment "Return B >= V";
pattern >=(b:bat[:hge],v:hge,s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B >= V with candidates list";
pattern >=(v:hge,b:bat[:hge]) :bat[:bit]
address CMDbatGE
comment "Return V >= B";
pattern >=(v:hge,b:bat[:hge],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return V >= B with candidates list";

pattern >=(b1:bat[:hge],b2:bat[:flt]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b1:bat[:hge],b2:bat[:flt],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2 with candidates list";
pattern >=(b:bat[:hge],v:flt) :bat[:bit]
address CMDbatGE
comment "Return B >= V";
pattern >=(b:bat[:hge],v:flt,s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B >= V with candidates list";
pattern >=(v:hge,b:bat[:flt]) :bat[:bit]
address CMDbatGE
comment "Return V >= B";
pattern >=(v:hge,b:bat[:flt],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return V >= B with candidates list";

pattern >=(b1:bat[:hge],b2:bat[:dbl]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b1:bat[:hge],b2:bat[:dbl],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2 with candidates list";
pattern >=(b:bat[:hge],v:dbl) :bat[:bit]
address CMDbatGE
comment "Return B >= V";
pattern >=(b:bat[:hge],v:dbl,s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B >= V with candidates list";
pattern >=(v:hge,b:bat[:dbl]) :bat[:bit]
address CMDbatGE
comment "Return V >= B";
pattern >=(v:hge,b:bat[:dbl],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return V >= B with candidates list";

pattern >=(b1:bat[:flt],b2:bat[:hge]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b1:bat[:flt],b2:bat[:hge],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2 with candidates list";
pattern >=(b:bat[:flt],v:hge) :bat[:bit]
address CMDbatGE
comment "Return B >= V";
pattern >=(b:bat[:flt],v:hge,s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B >= V with candidates list";
pattern >=(v:flt,b:bat[:hge]) :bat[:bit]
address CMDbatGE
comment "Return V >= B";
pattern >=(v:flt,b:bat[:hge],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return V >= B with candidates list";

pattern >=(b1:bat[:dbl],b2:bat[:hge]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b1:bat[:dbl],b2:bat[:hge],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B1 >= B2 with candidates list";
pattern >=(b:bat[:dbl],v:hge) :bat[:bit]
address CMDbatGE
comment "Return B >= V";
pattern >=(b:bat[:dbl],v:hge,s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return B >= V with candidates list";
pattern >=(v:dbl,b:bat[:hge]) :bat[:bit]
address CMDbatGE
comment "Return V >= B";
pattern >=(v:dbl,b:bat[:hge],s:bat[:oid]) :bat[:bit]
address CMDbatGE
comment "Return V >= B with candidates list";


pattern ==(b1:bat[:bte],b2:bat[:hge]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b1:bat[:bte],b2:bat[:hge],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2 with candidates list";
pattern ==(b:bat[:bte],v:hge) :bat[:bit]
address CMDbatEQ
comment "Return B == V";
pattern ==(b:bat[:bte],v:hge,s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B == V with candidates list";
pattern ==(v:bte,b:bat[:hge]) :bat[:bit]
address CMDbatEQ
comment "Return V == B";
pattern ==(v:bte,b:bat[:hge],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return V == B with candidates list";

pattern ==(b1:bat[:sht],b2:bat[:hge]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b1:bat[:sht],b2:bat[:hge],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2 with candidates list";
pattern ==(b:bat[:sht],v:hge) :bat[:bit]
address CMDbatEQ
comment "Return B == V";
pattern ==(b:bat[:sht],v:hge,s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B == V with candidates list";
pattern ==(v:sht,b:bat[:hge]) :bat[:bit]
address CMDbatEQ
comment "Return V == B";
pattern ==(v:sht,b:bat[:hge],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return V == B with candidates list";

pattern ==(b1:bat[:int],b2:bat[:hge]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b1:bat[:int],b2:bat[:hge],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2 with candidates list";
pattern ==(b:bat[:int],v:hge) :bat[:bit]
address CMDbatEQ
comment "Return B == V";
pattern ==(b:bat[:int],v:hge,s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B == V with candidates list";
pattern ==(v:int,b:bat[:hge]) :bat[:bit]
address CMDbatEQ
comment "Return V == B";
pattern ==(v:int,b:bat[:hge],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return V == B with candidates list";

pattern ==(b1:bat[:lng],b2:bat[:hge]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b1:bat[:lng],b2:bat[:hge],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2 with candidates list";
pattern ==(b:bat[:lng],v:hge) :bat[:bit]
address CMDbatEQ
comment "Return B == V";
pattern ==(b:bat[:lng],v:hge,s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B == V with candidates list";
pattern ==(v:lng,b:bat[:hge]) :bat[:bit]
address CMDbatEQ
comment "Return V == B";
pattern ==(v:lng,b:bat[:hge],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return V == B with candidates list";

pattern ==(b1:bat[:hge],b2:bat[:bte]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b1:bat[:hge],b2:bat[:bte],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2 with candidates list";
pattern ==(b:bat[:hge],v:bte) :bat[:bit]
address CMDbatEQ
comment "Return B == V";
pattern ==(b:bat[:hge],v:bte,s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B == V with candidates list";
pattern ==(v:hge,b:bat[:bte]) :bat[:bit]
address CMDbatEQ
comment "Return V == B";
pattern ==(v:hge,b:bat[:bte],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return V == B with candidates list";

pattern ==(b1:bat[:hge],b2:bat[:sht]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b1:bat[:hge],b2:bat[:sht],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2 with candidates list";
pattern ==(b:bat[:hge],v:sht) :bat[:bit]
address CMDbatEQ
comment "Return B == V";
pattern ==(b:bat[:hge],v:sht,s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B == V with candidates list";
pattern ==(v:hge,b:bat[:sht]) :bat[:bit]
address CMDbatEQ
comment "Return V == B";
pattern ==(v:hge,b:bat[:sht],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return V == B with candidates list";

pattern ==(b1:bat[:hge],b2:bat[:int]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b1:bat[:hge],b2:bat[:int],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2 with candidates list";
pattern ==(b:bat[:hge],v:int) :bat[:bit]
address CMDbatEQ
comment "Return B == V";
pattern ==(b:bat[:hge],v:int,s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B == V with candidates list";
pattern ==(v:hge,b:bat[:int]) :bat[:bit]
address CMDbatEQ
comment "Return V == B";
pattern ==(v:hge,b:bat[:int],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return V == B with candidates list";

pattern ==(b1:bat[:hge],b2:bat[:lng]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b1:bat[:hge],b2:bat[:lng],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2 with candidates list";
pattern ==(b:bat[:hge],v:lng) :bat[:bit]
address CMDbatEQ
comment "Return B == V";
pattern ==(b:bat[:hge],v:lng,s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B == V with candidates list";
pattern ==(v:hge,b:bat[:lng]) :bat[:bit]
address CMDbatEQ
comment "Return V == B";
pattern ==(v:hge,b:bat[:lng],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return V == B with candidates list";

pattern ==(b1:bat[:hge],b2:bat[:hge]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b1:bat[:hge],b2:bat[:hge],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2 with candidates list";
pattern ==(b:bat[:hge],v:hge) :bat[:bit]
address CMDbatEQ
comment "Return B == V";
pattern ==(b:bat[:hge],v:hge,s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B == V with candidates list";
pattern ==(v:hge,b:bat[:hge]) :bat[:bit]
address CMDbatEQ
comment "Return V == B";
pattern ==(v:hge,b:bat[:hge],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return V == B with candidates list";

pattern ==(b1:bat[:hge],b2:bat[:flt]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b1:bat[:hge],b2:bat[:flt],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2 with candidates list";
pattern ==(b:bat[:hge],v:flt) :bat[:bit]
address CMDbatEQ
comment "Return B == V";
pattern ==(b:bat[:hge],v:flt,s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B == V with candidates list";
pattern ==(v:hge,b:bat[:flt]) :bat[:bit]
address CMDbatEQ
comment "Return V == B";
pattern ==(v:hge,b:bat[:flt],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return V == B with candidates list";

pattern ==(b1:bat[:hge],b2:bat[:dbl]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b1:bat[:hge],b2:bat[:dbl],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2 with candidates list";
pattern ==(b:bat[:hge],v:dbl) :bat[:bit]
address CMDbatEQ
comment "Return B == V";
pattern ==(b:bat[:hge],v:dbl,s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B == V with candidates list";
pattern ==(v:hge,b:bat[:dbl]) :bat[:bit]
address CMDbatEQ
comment "Return V == B";
pattern ==(v:hge,b:bat[:dbl],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return V == B with candidates list";

pattern ==(b1:bat[:flt],b2:bat[:hge]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b1:bat[:flt],b2:bat[:hge],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2 with candidates list";
pattern ==(b:bat[:flt],v:hge) :bat[:bit]
address CMDbatEQ
comment "Return B == V";
pattern ==(b:bat[:flt],v:hge,s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B == V with candidates list";
pattern ==(v:flt,b:bat[:hge]) :bat[:bit]
address CMDbatEQ
comment "Return V == B";
pattern ==(v:flt,b:bat[:hge],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return V == B with candidates list";

pattern ==(b1:bat[:dbl],b2:bat[:hge]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b1:bat[:dbl],b2:bat[:hge],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B1 == B2 with candidates list";
pattern ==(b:bat[:dbl],v:hge) :bat[:bit]
address CMDbatEQ
comment "Return B == V";
pattern ==(b:bat[:dbl],v:hge,s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return B == V with candidates list";
pattern ==(v:dbl,b:bat[:hge]) :bat[:bit]
address CMDbatEQ
comment "Return V == B";
pattern ==(v:dbl,b:bat[:hge],s:bat[:oid]) :bat[:bit]
address CMDbatEQ
comment "Return V == B with candidates list";


pattern !=(b1:bat[:bte],b2:bat[:hge]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b1:bat[:bte],b2:bat[:hge],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2 with candidates list";
pattern !=(b:bat[:bte],v:hge) :bat[:bit]
address CMDbatNE
comment "Return B != V";
pattern !=(b:bat[:bte],v:hge,s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B != V with candidates list";
pattern !=(v:bte,b:bat[:hge]) :bat[:bit]
address CMDbatNE
comment "Return V != B";
pattern !=(v:bte,b:bat[:hge],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return V != B with candidates list";

pattern !=(b1:bat[:sht],b2:bat[:hge]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b1:bat[:sht],b2:bat[:hge],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2 with candidates list";
pattern !=(b:bat[:sht],v:hge) :bat[:bit]
address CMDbatNE
comment "Return B != V";
pattern !=(b:bat[:sht],v:hge,s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B != V with candidates list";
pattern !=(v:sht,b:bat[:hge]) :bat[:bit]
address CMDbatNE
comment "Return V != B";
pattern !=(v:sht,b:bat[:hge],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return V != B with candidates list";

pattern !=(b1:bat[:int],b2:bat[:hge]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b1:bat[:int],b2:bat[:hge],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2 with candidates list";
pattern !=(b:bat[:int],v:hge) :bat[:bit]
address CMDbatNE
comment "Return B != V";
pattern !=(b:bat[:int],v:hge,s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B != V with candidates list";
pattern !=(v:int,b:bat[:hge]) :bat[:bit]
address CMDbatNE
comment "Return V != B";
pattern !=(v:int,b:bat[:hge],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return V != B with candidates list";

pattern !=(b1:bat[:lng],b2:bat[:hge]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b1:bat[:lng],b2:bat[:hge],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2 with candidates list";
pattern !=(b:bat[:lng],v:hge) :bat[:bit]
address CMDbatNE
comment "Return B != V";
pattern !=(b:bat[:lng],v:hge,s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B != V with candidates list";
pattern !=(v:lng,b:bat[:hge]) :bat[:bit]
address CMDbatNE
comment "Return V != B";
pattern !=(v:lng,b:bat[:hge],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return V != B with candidates list";

pattern !=(b1:bat[:hge],b2:bat[:bte]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b1:bat[:hge],b2:bat[:bte],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2 with candidates list";
pattern !=(b:bat[:hge],v:bte) :bat[:bit]
address CMDbatNE
comment "Return B != V";
pattern !=(b:bat[:hge],v:bte,s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B != V with candidates list";
pattern !=(v:hge,b:bat[:bte]) :bat[:bit]
address CMDbatNE
comment "Return V != B";
pattern !=(v:hge,b:bat[:bte],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return V != B with candidates list";

pattern !=(b1:bat[:hge],b2:bat[:sht]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b1:bat[:hge],b2:bat[:sht],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2 with candidates list";
pattern !=(b:bat[:hge],v:sht) :bat[:bit]
address CMDbatNE
comment "Return B != V";
pattern !=(b:bat[:hge],v:sht,s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B != V with candidates list";
pattern !=(v:hge,b:bat[:sht]) :bat[:bit]
address CMDbatNE
comment "Return V != B";
pattern !=(v:hge,b:bat[:sht],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return V != B with candidates list";

pattern !=(b1:bat[:hge],b2:bat[:int]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b1:bat[:hge],b2:bat[:int],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2 with candidates list";
pattern !=(b:bat[:hge],v:int) :bat[:bit]
address CMDbatNE
comment "Return B != V";
pattern !=(b:bat[:hge],v:int,s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B != V with candidates list";
pattern !=(v:hge,b:bat[:int]) :bat[:bit]
address CMDbatNE
comment "Return V != B";
pattern !=(v:hge,b:bat[:int],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return V != B with candidates list";

pattern !=(b1:bat[:hge],b2:bat[:lng]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b1:bat[:hge],b2:bat[:lng],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2 with candidates list";
pattern !=(b:bat[:hge],v:lng) :bat[:bit]
address CMDbatNE
comment "Return B != V";
pattern !=(b:bat[:hge],v:lng,s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B != V with candidates list";
pattern !=(v:hge,b:bat[:lng]) :bat[:bit]
address CMDbatNE
comment "Return V != B";
pattern !=(v:hge,b:bat[:lng],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return V != B with candidates list";

pattern !=(b1:bat[:hge],b2:bat[:hge]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b1:bat[:hge],b2:bat[:hge],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2 with candidates list";
pattern !=(b:bat[:hge],v:hge) :bat[:bit]
address CMDbatNE
comment "Return B != V";
pattern !=(b:bat[:hge],v:hge,s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B != V with candidates list";
pattern !=(v:hge,b:bat[:hge]) :bat[:bit]
address CMDbatNE
comment "Return V != B";
pattern !=(v:hge,b:bat[:hge],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return V != B with candidates list";

pattern !=(b1:bat[:hge],b2:bat[:flt]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b1:bat[:hge],b2:bat[:flt],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2 with candidates list";
pattern !=(b:bat[:hge],v:flt) :bat[:bit]
address CMDbatNE
comment "Return B != V";
pattern !=(b:bat[:hge],v:flt,s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B != V with candidates list";
pattern !=(v:hge,b:bat[:flt]) :bat[:bit]
address CMDbatNE
comment "Return V != B";
pattern !=(v:hge,b:bat[:flt],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return V != B with candidates list";

pattern !=(b1:bat[:hge],b2:bat[:dbl]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b1:bat[:hge],b2:bat[:dbl],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2 with candidates list";
pattern !=(b:bat[:hge],v:dbl) :bat[:bit]
address CMDbatNE
comment "Return B != V";
pattern !=(b:bat[:hge],v:dbl,s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B != V with candidates list";
pattern !=(v:hge,b:bat[:dbl]) :bat[:bit]
address CMDbatNE
comment "Return V != B";
pattern !=(v:hge,b:bat[:dbl],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return V != B with candidates list";

pattern !=(b1:bat[:flt],b2:bat[:hge]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b1:bat[:flt],b2:bat[:hge],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2 with candidates list";
pattern !=(b:bat[:flt],v:hge) :bat[:bit]
address CMDbatNE
comment "Return B != V";
pattern !=(b:bat[:flt],v:hge,s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B != V with candidates list";
pattern !=(v:flt,b:bat[:hge]) :bat[:bit]
address CMDbatNE
comment "Return V != B";
pattern !=(v:flt,b:bat[:hge],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return V != B with candidates list";

pattern !=(b1:bat[:dbl],b2:bat[:hge]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b1:bat[:dbl],b2:bat[:hge],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B1 != B2 with candidates list";
pattern !=(b:bat[:dbl],v:hge) :bat[:bit]
address CMDbatNE
comment "Return B != V";
pattern !=(b:bat[:dbl],v:hge,s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return B != V with candidates list";
pattern !=(v:dbl,b:bat[:hge]) :bat[:bit]
address CMDbatNE
comment "Return V != B";
pattern !=(v:dbl,b:bat[:hge],s:bat[:oid]) :bat[:bit]
address CMDbatNE
comment "Return V != B with candidates list";


pattern cmp(b1:bat[:bte],b2:bat[:hge]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b1:bat[:bte],b2:bat[:hge],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2 with candidates list";
pattern cmp(b:bat[:bte],v:hge) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:bte,b:bat[:hge]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B";
pattern cmp(b:bat[:bte],v:hge,s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V with candidates list";
pattern cmp(v:bte,b:bat[:hge],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B with candidates list";

pattern cmp(b1:bat[:sht],b2:bat[:hge]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b1:bat[:sht],b2:bat[:hge],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2 with candidates list";
pattern cmp(b:bat[:sht],v:hge) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:sht,b:bat[:hge]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B";
pattern cmp(b:bat[:sht],v:hge,s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V with candidates list";
pattern cmp(v:sht,b:bat[:hge],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B with candidates list";

pattern cmp(b1:bat[:int],b2:bat[:hge]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b1:bat[:int],b2:bat[:hge],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2 with candidates list";
pattern cmp(b:bat[:int],v:hge) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:int,b:bat[:hge]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B";
pattern cmp(b:bat[:int],v:hge,s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V with candidates list";
pattern cmp(v:int,b:bat[:hge],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B with candidates list";

pattern cmp(b1:bat[:lng],b2:bat[:hge]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b1:bat[:lng],b2:bat[:hge],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2 with candidates list";
pattern cmp(b:bat[:lng],v:hge) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:lng,b:bat[:hge]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B";
pattern cmp(b:bat[:lng],v:hge,s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V with candidates list";
pattern cmp(v:lng,b:bat[:hge],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B with candidates list";

pattern cmp(b1:bat[:hge],b2:bat[:bte]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b1:bat[:hge],b2:bat[:bte],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2 with candidates list";
pattern cmp(b:bat[:hge],v:bte) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:hge,b:bat[:bte]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B";
pattern cmp(b:bat[:hge],v:bte,s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V with candidates list";
pattern cmp(v:hge,b:bat[:bte],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B with candidates list";

pattern cmp(b1:bat[:hge],b2:bat[:sht]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b1:bat[:hge],b2:bat[:sht],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2 with candidates list";
pattern cmp(b:bat[:hge],v:sht) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:hge,b:bat[:sht]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B";
pattern cmp(b:bat[:hge],v:sht,s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V with candidates list";
pattern cmp(v:hge,b:bat[:sht],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B with candidates list";

pattern cmp(b1:bat[:hge],b2:bat[:int]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b1:bat[:hge],b2:bat[:int],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2 with candidates list";
pattern cmp(b:bat[:hge],v:int) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:hge,b:bat[:int]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B";
pattern cmp(b:bat[:hge],v:int,s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V with candidates list";
pattern cmp(v:hge,b:bat[:int],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B with candidates list";

pattern cmp(b1:bat[:hge],b2:bat[:lng]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b1:bat[:hge],b2:bat[:lng],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2 with candidates list";
pattern cmp(b:bat[:hge],v:lng) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:hge,b:bat[:lng]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B";
pattern cmp(b:bat[:hge],v:lng,s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V with candidates list";
pattern cmp(v:hge,b:bat[:lng],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B with candidates list";

pattern cmp(b1:bat[:hge],b2:bat[:hge]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b1:bat[:hge],b2:bat[:hge],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2 with candidates list";
pattern cmp(b:bat[:hge],v:hge) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:hge,b:bat[:hge]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B";
pattern cmp(b:bat[:hge],v:hge,s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V with candidates list";
pattern cmp(v:hge,b:bat[:hge],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B with candidates list";

pattern cmp(b1:bat[:hge],b2:bat[:flt]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b1:bat[:hge],b2:bat[:flt],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2 with candidates list";
pattern cmp(b:bat[:hge],v:flt) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:hge,b:bat[:flt]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B";
pattern cmp(b:bat[:hge],v:flt,s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V with candidates list";
pattern cmp(v:hge,b:bat[:flt],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B with candidates list";

pattern cmp(b1:bat[:hge],b2:bat[:dbl]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b1:bat[:hge],b2:bat[:dbl],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2 with candidates list";
pattern cmp(b:bat[:hge],v:dbl) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:hge,b:bat[:dbl]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B";
pattern cmp(b:bat[:hge],v:dbl,s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V with candidates list";
pattern cmp(v:hge,b:bat[:dbl],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B with candidates list";

pattern cmp(b1:bat[:flt],b2:bat[:hge]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b1:bat[:flt],b2:bat[:hge],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2 with candidates list";
pattern cmp(b:bat[:flt],v:hge) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:flt,b:bat[:hge]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B";
pattern cmp(b:bat[:flt],v:hge,s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V with candidates list";
pattern cmp(v:flt,b:bat[:hge],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B with candidates list";

pattern cmp(b1:bat[:dbl],b2:bat[:hge]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b1:bat[:dbl],b2:bat[:hge],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2 with candidates list";
pattern cmp(b:bat[:dbl],v:hge) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:dbl,b:bat[:hge]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B";
pattern cmp(b:bat[:dbl],v:hge,s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if B </==/> V with candidates list";
pattern cmp(v:dbl,b:bat[:hge],s:bat[:oid]) :bat[:bte]
address CMDbatCMP
comment "Return -1/0/1 if V </==/> B with candidates list";


pattern between(b:bat[:hge],lo:bat[:hge],hi:bat[:hge]) :bat[:bit]
address CMDbatBETWEEN
comment "B between LO and HI inclusive, nil border is (minus) infinity";
pattern between(b:bat[:hge],lo:bat[:hge],hi:bat[:hge],s:bat[:oid]) :bat[:bit]
address CMDbatBETWEEN
comment "B between LO and HI inclusive with candidates list, nil border is (minus) infinity";
pattern between(b:bat[:hge],lo:bat[:hge],hi:hge) :bat[:bit]
address CMDbatBETWEEN
comment "B between LO and HI inclusive, nil border is (minus) infinity";
pattern between(b:bat[:hge],lo:bat[:hge],hi:hge,s:bat[:oid]) :bat[:bit]
address CMDbatBETWEEN
comment "B between LO and HI inclusive with candidates list, nil border is (minus) infinity";
pattern between(b:bat[:hge],lo:hge,hi:bat[:hge]) :bat[:bit]
address CMDbatBETWEEN
comment "B between LO and HI inclusive, nil border is (minus) infinity";
pattern between(b:bat[:hge],lo:hge,hi:bat[:hge],s:bat[:oid]) :bat[:bit]
address CMDbatBETWEEN
comment "B between LO and HI inclusive with candidates list, nil border is (minus) infinity";
pattern between(b:bat[:hge],lo:hge,hi:hge) :bat[:bit]
address CMDbatBETWEEN
comment "B between LO and HI inclusive, nil border is (minus) infinity";
pattern between(b:bat[:hge],lo:hge,hi:hge,s:bat[:oid]) :bat[:bit]
address CMDbatBETWEEN
comment "B between LO and HI inclusive with candidates list, nil border is (minus) infinity";


pattern avg(b:bat[:hge]) :dbl
address CMDcalcavg
comment "average of non-nil values of B with candidates list";
pattern avg(b:bat[:hge],s:bat[:oid]) :dbl
address CMDcalcavg
comment "average of non-nil values of B";
pattern avg(b:bat[:hge]) (:dbl, :lng)
address CMDcalcavg
comment "average and number of non-nil values of B";
pattern avg(b:bat[:hge],s:bat[:oid]) (:dbl, :lng)
address CMDcalcavg
comment "average and number of non-nil values of B with candidates list";

pattern bit(b:bat[:hge]) :bat[:bit]
address CMDconvertsignal_bit
comment "cast from hge to bit, signal error on overflow";
pattern bit(b:bat[:hge],s:bat[:oid]) :bat[:bit]
address CMDconvertsignal_bit
comment "cast from hge to bit with candidates list, signal error on overflow";
pattern bit_noerror(b:bat[:hge]) :bat[:bit]
address CMDconvert_bit
comment "cast from hge to bit";
pattern bit_noerror(b:bat[:hge],s:bat[:oid]) :bat[:bit]
address CMDconvert_bit
comment "cast from hge to bit with candidates list";

pattern bte(b:bat[:hge]) :bat[:bte]
address CMDconvertsignal_bte
comment "cast from hge to bte, signal error on overflow";
pattern bte(b:bat[:hge],s:bat[:oid]) :bat[:bte]
address CMDconvertsignal_bte
comment "cast from hge to bte with candidates list, signal error on overflow";
pattern bte_noerror(b:bat[:hge]) :bat[:bte]
address CMDconvert_bte
comment "cast from hge to bte";
pattern bte_noerror(b:bat[:hge],s:bat[:oid]) :bat[:bte]
address CMDconvert_bte
comment "cast from hge to bte with candidates list";

pattern sht(b:bat[:hge]) :bat[:sht]
address CMDconvertsignal_sht
comment "cast from hge to sht, signal error on overflow";
pattern sht(b:bat[:hge],s:bat[:oid]) :bat[:sht]
address CMDconvertsignal_sht
comment "cast from hge to sht with candidates list, signal error on overflow";
pattern sht_noerror(b:bat[:hge]) :bat[:sht]
address CMDconvert_sht
comment "cast from hge to sht";
pattern sht_noerror(b:bat[:hge],s:bat[:oid]) :bat[:sht]
address CMDconvert_sht
comment "cast from hge to sht with candidates list";

pattern int(b:bat[:hge]) :bat[:int]
address CMDconvertsignal_int
comment "cast from hge to int, signal error on overflow";
pattern int(b:bat[:hge],s:bat[:oid]) :bat[:int]
address CMDconvertsignal_int
comment "cast from hge to int with candidates list, signal error on overflow";
pattern int_noerror(b:bat[:hge]) :bat[:int]
address CMDconvert_int
comment "cast from hge to int";
pattern int_noerror(b:bat[:hge],s:bat[:oid]) :bat[:int]
address CMDconvert_int
comment "cast from hge to int with candidates list";

pattern lng(b:bat[:hge]) :bat[:lng]
address CMDconvertsignal_lng
comment "cast from hge to lng, signal error on overflow";
pattern lng(b:bat[:hge],s:bat[:oid]) :bat[:lng]
address CMDconvertsignal_lng
comment "cast from hge to lng with candidates list, signal error on overflow";
pattern lng_noerror(b:bat[:hge]) :bat[:lng]
address CMDconvert_lng
comment "cast from hge to lng";
pattern lng_noerror(b:bat[:hge],s:bat[:oid]) :bat[:lng]
address CMDconvert_lng
comment "cast from hge to lng with candidates list";

pattern hge(b:bat[:bit]) :bat[:hge]
address CMDconvertsignal_hge
comment "cast from bit to hge, signal error on overflow";
pattern hge(b:bat[:bit],s:bat[:oid]) :bat[:hge]
address CMDconvertsignal_hge
comment "cast from bit to hge with candidates list, signal error on overflow";
pattern hge_noerror(b:bat[:bit]) :bat[:hge]
address CMDconvert_hge
comment "cast from bit to hge";
pattern hge_noerror(b:bat[:bit],s:bat[:oid]) :bat[:hge]
address CMDconvert_hge
comment "cast from bit to hge with candidates list";

pattern hge(b:bat[:bte]) :bat[:hge]
address CMDconvertsignal_hge
comment "cast from bte to hge, signal error on overflow";
pattern hge(b:bat[:bte],s:bat[:oid]) :bat[:hge]
address CMDconvertsignal_hge
comment "cast from bte to hge with candidates list, signal error on overflow";
pattern hge_noerror(b:bat[:bte]) :bat[:hge]
address CMDconvert_hge
comment "cast from bte to hge";
pattern hge_noerror(b:bat[:bte],s:bat[:oid]) :bat[:hge]
address CMDconvert_hge
comment "cast from bte to hge with candidates list";

pattern hge(b:bat[:sht]) :bat[:hge]
address CMDconvertsignal_hge
comment "cast from sht to hge, signal error on overflow";
pattern hge(b:bat[:sht],s:bat[:oid]) :bat[:hge]
address CMDconvertsignal_hge
comment "cast from sht to hge with candidates list, signal error on overflow";
pattern hge_noerror(b:bat[:sht]) :bat[:hge]
address CMDconvert_hge
comment "cast from sht to hge";
pattern hge_noerror(b:bat[:sht],s:bat[:oid]) :bat[:hge]
address CMDconvert_hge
comment "cast from sht to hge with candidates list";

pattern hge(b:bat[:int]) :bat[:hge]
address CMDconvertsignal_hge
comment "cast from int to hge, signal error on overflow";
pattern hge(b:bat[:int],s:bat[:oid]) :bat[:hge]
address CMDconvertsignal_hge
comment "cast from int to hge with candidates list, signal error on overflow";
pattern hge_noerror(b:bat[:int]) :bat[:hge]
address CMDconvert_hge
comment "cast from int to hge";
pattern hge_noerror(b:bat[:int],s:bat[:oid]) :bat[:hge]
address CMDconvert_hge
comment "cast from int to hge with candidates list";

pattern hge(b:bat[:lng]) :bat[:hge]
address CMDconvertsignal_hge
comment "cast from lng to hge, signal error on overflow";
pattern hge(b:bat[:lng],s:bat[:oid]) :bat[:hge]
address CMDconvertsignal_hge
comment "cast from lng to hge with candidates list, signal error on overflow";
pattern hge_noerror(b:bat[:lng]) :bat[:hge]
address CMDconvert_hge
comment "cast from lng to hge";
pattern hge_noerror(b:bat[:lng],s:bat[:oid]) :bat[:hge]
address CMDconvert_hge
comment "cast from lng to hge with candidates list";

pattern hge(b:bat[:hge]) :bat[:hge]
address CMDconvertsignal_hge
comment "cast from hge to hge, signal error on overflow";
pattern hge(b:bat[:hge],s:bat[:oid]) :bat[:hge]
address CMDconvertsignal_hge
comment "cast from hge to hge with candidates list, signal error on overflow";
pattern hge_noerror(b:bat[:hge]) :bat[:hge]
address CMDconvert_hge
comment "cast from hge to hge";
pattern hge_noerror(b:bat[:hge],s:bat[:oid]) :bat[:hge]
address CMDconvert_hge
comment "cast from hge to hge with candidates list";

pattern hge(b:bat[:flt]) :bat[:hge]
address CMDconvertsignal_hge
comment "cast from flt to hge, signal error on overflow";
pattern hge(b:bat[:flt],s:bat[:oid]) :bat[:hge]
address CMDconvertsignal_hge
comment "cast from flt to hge with candidates list, signal error on overflow";
pattern hge_noerror(b:bat[:flt]) :bat[:hge]
address CMDconvert_hge
comment "cast from flt to hge";
pattern hge_noerror(b:bat[:flt],s:bat[:oid]) :bat[:hge]
address CMDconvert_hge
comment "cast from flt to hge with candidates list";

pattern hge(b:bat[:dbl]) :bat[:hge]
address CMDconvertsignal_hge
comment "cast from dbl to hge, signal error on overflow";
pattern hge(b:bat[:dbl],s:bat[:oid]) :bat[:hge]
address CMDconvertsignal_hge
comment "cast from dbl to hge with candidates list, signal error on overflow";
pattern hge_noerror(b:bat[:dbl]) :bat[:hge]
address CMDconvert_hge
comment "cast from dbl to hge";
pattern hge_noerror(b:bat[:dbl],s:bat[:oid]) :bat[:hge]
address CMDconvert_hge
comment "cast from dbl to hge with candidates list";

pattern hge(b:bat[:oid]) :bat[:hge]
address CMDconvertsignal_hge
comment "cast from oid to hge, signal error on overflow";
pattern hge(b:bat[:oid],s:bat[:oid]) :bat[:hge]
address CMDconvertsignal_hge
comment "cast from oid to hge with candidates list, signal error on overflow";
pattern hge_noerror(b:bat[:oid]) :bat[:hge]
address CMDconvert_hge
comment "cast from oid to hge";
pattern hge_noerror(b:bat[:oid],s:bat[:oid]) :bat[:hge]
address CMDconvert_hge
comment "cast from oid to hge with candidates list";

pattern hge(b:bat[:str]) :bat[:hge]
address CMDconvertsignal_hge
comment "cast from str to hge, signal error on overflow";
pattern hge(b:bat[:str],s:bat[:oid]) :bat[:hge]
address CMDconvertsignal_hge
comment "cast from str to hge with candidates list, signal error on overflow";
pattern hge_noerror(b:bat[:str]) :bat[:hge]
address CMDconvert_hge
comment "cast from str to hge";
pattern hge_noerror(b:bat[:str],s:bat[:oid]) :bat[:hge]
address CMDconvert_hge
comment "cast from str to hge with candidates list";

pattern flt(b:bat[:hge]) :bat[:flt]
address CMDconvertsignal_flt
comment "cast from hge to flt, signal error on overflow";
pattern flt(b:bat[:hge],s:bat[:oid]) :bat[:flt]
address CMDconvertsignal_flt
comment "cast from hge to flt with candidates list, signal error on overflow";
pattern flt_noerror(b:bat[:hge]) :bat[:flt]
address CMDconvert_flt
comment "cast from hge to flt";
pattern flt_noerror(b:bat[:hge],s:bat[:oid]) :bat[:flt]
address CMDconvert_flt
comment "cast from hge to flt with candidates list";

pattern dbl(b:bat[:hge]) :bat[:dbl]
address CMDconvertsignal_dbl
comment "cast from hge to dbl, signal error on overflow";
pattern dbl(b:bat[:hge],s:bat[:oid]) :bat[:dbl]
address CMDconvertsignal_dbl
comment "cast from hge to dbl with candidates list, signal error on overflow";
pattern dbl_noerror(b:bat[:hge]) :bat[:dbl]
address CMDconvert_dbl
comment "cast from hge to dbl";
pattern dbl_noerror(b:bat[:hge],s:bat[:oid]) :bat[:dbl]
address CMDconvert_dbl
comment "cast from hge to dbl with candidates list";

pattern oid(b:bat[:hge]) :bat[:oid]
address CMDconvertsignal_oid
comment "cast from hge to oid, signal error on overflow";
pattern oid(b:bat[:hge],s:bat[:oid]) :bat[:oid]
address CMDconvertsignal_oid
comment "cast from hge to oid with candidates list, signal error on overflow";
pattern oid_noerror(b:bat[:hge]) :bat[:oid]
address CMDconvert_oid
comment "cast from hge to oid";
pattern oid_noerror(b:bat[:hge],s:bat[:oid]) :bat[:oid]
address CMDconvert_oid
comment "cast from hge to oid with candidates list";

