@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.monetdb.org/Legal/MonetDBLicense

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2011 MonetDB B.V.
All Rights Reserved.
@

@f clients
@a Martin Kersten, Fabian Groffen
@v 0.2
@+ Client Management
Each online client is represented with an entry in the clients table.
The client may inspect his record at run-time and partially change its
properties.
The administrator sees all client records and has the right to
adjust global properties.
@mal
module clients;

pattern setListing(flag:int):int
address CLTsetListing
comment "Turn on/off echo of MAL instructions:
	2 - show mal instruction,
	4 - show details of type resolutoin, 
	8 - show binding information.";

pattern setHistory(s:str)
address CLTsetHistory
comment "Designate console history file for readline.";

pattern getId():int
address CLTgetClientId
comment "Return a number that uniquely represents the current client.";

pattern getInfo( ):bat[:str,:str] 
address CLTInfo
comment "Pseudo bat with client attributes.";

pattern getScenario():str 
address CLTgetScenario
comment "Retrieve current scenario name.";
pattern setScenario(msg:str):str 
address CLTsetScenario
comment "Switch to other scenario handler, return previous one.";

pattern quit():void
address CLTquit
comment "Terminate the client session.";

pattern quit(idx:int):void
address CLTquit
comment "Terminate the session for a single client using a soft error.
It is the privilige of the console user.";

@-
Administrator operations
@mal
command getLogins( ):bat[:int,:str] 
address CLTLogin
comment "Pseudo bat of client login time.";

command getLastCommand( ):bat[:int,:str] 
address CLTLastCommand
comment "Pseudo bat of client's last command time.";

command getActions( ):bat[:int,:int] 
address CLTActions
comment "Pseudo bat of client's command counts.";

command getTime( ):bat[:int,:lng] 
address CLTTime
comment "Pseudo bat of client's total time usage(in usec).";

command getUsers( ):bat[:int,:str] 
address CLTusers
comment "Pseudo bat of users logged in.";

pattern stop(id:int)
address CLTstop
comment "Stop the query execution at the next eligble statement.";

pattern suspend(id:int):void
address CLTsuspend
comment "Put a client process to sleep for some time.
It will simple sleep for a second at a time, until
the awake bit has been set in its descriptor";

command wakeup(id:int):void
address CLTwakeup
comment "Wakeup a client process";

pattern setTimeout(q:int,s:int):void
address CLTsetTimeout
comment "Abort a query after q seconds (q=0 means run undisturbed).
The session timeout aborts the connection after spending too
many seconds on query processing.";

pattern getTimeout()(q:int,s:int)
address CLTgetTimeout
comment "A query is aborted after q seconds (q=0 means run undisturbed).
The session timeout aborts the connection after spending too
many seconds on query processing.";

command shutdown(forced:bit):void
address CLTshutdown
comment "Close all client connections. If forced=false the
clients are moved into FINISHING mode, which means that
the process stops at the next cycle of the scenario.
If forced=true all client processes are immediately killed";
@-
@{
@include prelude.mx
@+ Monet client data
Portions of the client record can be directly obtained for
backward compatibility. The routine clientInfo provides more
detailed information.
@h
#ifndef _CLIENTS_H
#define _CLIENTS_H
#include "mal.h"
#include "mal_interpreter.h"

#ifdef WIN32
#if !defined(LIBMAL) && !defined(LIBATOMS) && !defined(LIBKERNEL) && !defined(LIBMAL) && !defined(LIBOPTIMIZER) && !defined(LIBSCHEDULER) && !defined(LIBMONETDB5)
#define clients_export extern __declspec(dllimport)
#else
#define clients_export extern __declspec(dllexport)
#endif
#else
#define clients_export extern
#endif

clients_export str CLTsetListing(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
clients_export str CLTgetClientId(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
clients_export str CLTgetScenario(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
clients_export str CLTsetScenario(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
clients_export str CLTusers(int *ret);
clients_export str CLTsetHistory(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
clients_export str CLTquit(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
clients_export str CLTLogin(int *ret);
clients_export str CLTLastCommand(int *ret);
clients_export str CLTActions(int *ret);
clients_export str CLTTime(int *ret);
clients_export str CLTInfo(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
clients_export str CLTstop(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
clients_export str CLTsuspend(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
clients_export str CLTsetTimeout(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
clients_export str CLTgetTimeout(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
clients_export str CLTwakeup(int *ret, int *id);

clients_export str CLTshutdown(int *ret, bit *forced);
@c
#include "monetdb_config.h"
#include "clients.h"
#include "mal_scenario.h"
#include "mal_instruction.h"
#include "mal_client.h"
#include "mal_authorize.h"

#ifdef HAVE_LIBREADLINE
#include <readline/readline.h>
#include <readline/history.h>
#endif

str
CLTsetListing(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	(void) mb;
	*(int*) getArgReference(stk,pci,0) = cntxt->listing;
	cntxt->listing = *(int*) getArgReference(stk,pci,1);
	return MAL_SUCCEED;
}

str
CLTgetClientId(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	(void) mb;
	assert(cntxt - mal_clients <= INT_MAX);
	*(int*) getArgReference(stk,pci,0) = (int) (cntxt - mal_clients);
	return MAL_SUCCEED;
}

str
CLTgetScenario(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	(void) mb;
	if (cntxt->scenario)
		*(str *) getArgReference(stk,pci,0) = GDKstrdup(cntxt->scenario);
	else
		*(str *) getArgReference(stk,pci,0) = GDKstrdup("nil");
	return MAL_SUCCEED;
}

str
CLTsetScenario(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str msg = MAL_SUCCEED;

	(void) mb;
	msg = setScenario(cntxt, *(str *) getArgReference(stk,pci,1));
	*(str *) getArgReference(stk,pci,0) = 0;
	if (msg == NULL)
		*(str *) getArgReference(stk,pci,0) = GDKstrdup(cntxt->scenario);
	return msg;
}

static char *
local_itoa(int i)
{
	static char buf[32];

	sprintf(buf, "%d", i);
	return buf;
}

void
CLTtimeConvert(time_t l, char *s){
			struct tm localt;

#ifdef HAVE_LOCALTIME_R
			(void) localtime_r(&l, &localt);
#else
			/* race condition: return value could be
			 * overwritten in parallel thread before
			 * assignment complete */
			localt = *localtime(&l);
#endif

#ifdef HAVE_ASCTIME_R3
			asctime_r(&localt, s, 26);
#else
#ifdef HAVE_ASCTIME_R
			asctime_r(&localt, s);
#else
			/* race condition: return value could be
			 * overwritten in parallel thread before copy
			 * complete, however on Windows, asctime is
			 * thread-safe */
			strncpy(s, asctime(&localt), 26);
#endif
#endif
			s[24] = 0;
}

str
CLTInfo(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int *ret=  (int *) getArgReference(stk,pci,0);
	BAT *b = BATnew(TYPE_str, TYPE_str, 12);
	char s[26];

	(void) mb;
	if (b == 0)
		throw(MAL, "clients.info", MAL_MALLOC_FAIL);

	BUNins(b, "user", local_itoa((int)cntxt->user), FALSE);
	BUNins(b, "password", "", FALSE); /* FIXME: get rid of this */
	BUNins(b, "scenario", cntxt->scenario, FALSE);
	BUNins(b, "timer", local_itoa((int) cntxt->timer), FALSE);
	BUNins(b, "trace", local_itoa(cntxt->itrace), FALSE);
	BUNins(b, "listing", local_itoa(cntxt->listing), FALSE);
	BUNins(b, "debug", local_itoa(cntxt->debug), FALSE);
	CLTtimeConvert((time_t) cntxt->login,s);
	BUNins(b, "login", s, FALSE);
	CLTtimeConvert((time_t) cntxt->delay,s);
	BUNins(b, "delay", s, FALSE);
	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(client,info,)@
	return MAL_SUCCEED;
}

str
CLTLogin(int *ret)
{
	BAT *b = BATnew(TYPE_int, TYPE_str, 12);
	int i;
	char s[26];

	if (b == 0)
		throw(MAL, "clients.getLogins", MAL_MALLOC_FAIL);
	for (i = 0; i < MAL_MAXCLIENTS; i++) {
		Client c = mal_clients+i;
		if (c->mode >= CLAIMED && c->user != oid_nil) {
			CLTtimeConvert((time_t) c->login,s);
			BUNins(b, &i, s, FALSE);
		}
	}
	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(client,login,)@
	return MAL_SUCCEED;
}

str
CLTLastCommand(int *ret)
{
	BAT *b = BATnew(TYPE_int, TYPE_str, 12);
	int i;
	char s[26];

	if (b == 0)
		throw(MAL, "clients.getLastCommand", MAL_MALLOC_FAIL);
	for (i = 0; i < MAL_MAXCLIENTS; i++) {
		Client c = mal_clients+i;
		if (c->mode >= CLAIMED && c->user != oid_nil) {
			CLTtimeConvert((time_t) c->lastcmd,s);
			BUNins(b, &i, s, FALSE);
		}
	}
	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(client,lastcommand,)@
	return MAL_SUCCEED;
}

str
CLTActions(int *ret)
{
	BAT *b = BATnew(TYPE_int, TYPE_int, 12);
	int i;

	if (b == 0)
		throw(MAL, "clients.getActions", MAL_MALLOC_FAIL);
	for (i = 0; i < MAL_MAXCLIENTS; i++) {
		Client c = mal_clients+i;
		if (c->mode >= CLAIMED && c->user != oid_nil) {
			BUNins(b, &i, &c->actions, FALSE);
		}
	}
	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(client,actions,)@
	return MAL_SUCCEED;
}
str
CLTTime(int *ret)
{
	BAT *b = BATnew(TYPE_int, TYPE_lng, 12);
	int i;

	if (b == 0)
		throw(MAL, "clients.getTime", MAL_MALLOC_FAIL);
	for (i = 0; i < MAL_MAXCLIENTS; i++) {
		Client c = mal_clients+i;
		if (c->mode >= CLAIMED && c->user != oid_nil) {
			BUNins(b, &i, &c->totaltime, FALSE);
		}
	}
	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(client,usec,)@
	return MAL_SUCCEED;
}

@-
Produce a list of clients currently logged in
@c
str
CLTusers(int *ret)
{
	BAT *b = BATnew(TYPE_int, TYPE_str, 12);
	int i;

	if (b == 0)
		throw(MAL, "clients.users", MAL_MALLOC_FAIL);
	for (i = 0; i < MAL_MAXCLIENTS; i++) {
		Client c = mal_clients+i;
		if (c->mode >= CLAIMED && c->user != oid_nil)
			b = BUNins(b, &i, local_itoa((int)c->user), FALSE);
	}
	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(client,users,)@
	return MAL_SUCCEED;
}

str
CLTsetHistory(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str* fname = (str *) getArgReference(stk,pci,1);
	(void) mb;

	if( cntxt->history){
#ifdef HAVE_LIBREADLINE
		write_history(cntxt->history);
#endif
		GDKfree(cntxt->history);
	}
	if( *fname == str_nil)
		cntxt->history = NULL;
	else {
		cntxt->history = GDKstrdup(*fname);
#ifdef HAVE_LIBREADLINE
		read_history(cntxt->history);
#endif
	}
	return MAL_SUCCEED;
}

str
CLTquit(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int id;
	(void) mb;		/* fool compiler */
	
	if ( pci->argc==2 && cntxt->idx != 0)
		throw(MAL, "client.quit", INVCRED_ACCESS_DENIED);
	if ( pci->argc==2)
		id = *(int*) getArgReference(stk,pci,1);
	else id =cntxt->idx;

	if (id == 0 && cntxt->fdout != GDKout )
		throw(MAL, "client.quit", INVCRED_ACCESS_DENIED);
	if ( cntxt->idx == mal_clients[id].idx)
		mal_clients[id].mode = FINISHING;
	/* the console should be finished with an exception */
	if (id == 0)
		throw(MAL,"client.quit",SERVER_STOPPED);
	return MAL_SUCCEED;
}

str
CLTstop(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int id=  *(int *) getArgReference(stk,pci,1);
	(void) mb;
	if ( cntxt->user == mal_clients[id].user || 
		mal_clients[0].user == cntxt->user){
		mal_clients[id].itrace = 'x';
	}
	/* this forces the designated client to stop at the next instruction */
    return MAL_SUCCEED;
}

str
CLTsuspend(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int *id=  (int *) getArgReference(stk,pci,1);
	(void) cntxt;
	(void) mb;
    return MCsuspendClient(*id,0);
}

str
CLTsetTimeout(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int qto=  *(int *) getArgReference(stk,pci,1);
	int sto=  *(int *) getArgReference(stk,pci,2);
	(void) mb;
	cntxt->qtimeout = qto;
	cntxt->stimeout = sto;
    return MAL_SUCCEED;
}
str
CLTgetTimeout(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int *qto=  (int *) getArgReference(stk,pci,0);
	int *sto=  (int *) getArgReference(stk,pci,1);
	(void) mb;
	*qto = cntxt->qtimeout;
	*sto = cntxt->stimeout;
    return MAL_SUCCEED;
}

str
CLTwakeup(int *ret, int *id)
{
    (void) ret;     /* fool compiler */
    return MCawakeClient(*id);
}

@+ User administration
These commands (except changePassword, changeUsername and
checkPermission) can only be executed by the administrator.

@mal
command md5sum(pw:str):str
address CLTmd5sum
comment "Return hex string representation of the MD5 hash of the given string";
@h
clients_export str CLTmd5sum(str *ret, str *pw);
@c
str CLTmd5sum(str *ret, str *pw) {
	int len = (int) strlen(*pw);
	
	return AUTHMD5Sum(ret, pw, &len);
}

@mal
command sha1sum(pw:str):str
address CLTsha1sum
comment "Return hex string representation of the SHA-1 hash of the given string";
@h
clients_export str CLTsha1sum(str *ret, str *pw);
@c
str CLTsha1sum(str *ret, str *pw) {
	int len = (int) strlen(*pw);
	
	return AUTHSHA1Sum(ret, pw, &len);
}

@mal
command ripemd160sum(pw:str):str
address CLTripemd160sum
comment "Return hex string representation of the RIPEMD160 hash of the given string";
@h
clients_export str CLTripemd160sum(str *ret, str *pw);
@c
str CLTripemd160sum(str *ret, str *pw) {
	int len = (int) strlen(*pw);
	
	return AUTHRIPEMD160Sum(ret, pw, &len);
}

@mal
command sha2sum(pw:str, bits:int):str
address CLTsha2sum
comment "Return hex string representation of the SHA-2 hash with bits of the given string";
@h
clients_export str CLTsha2sum(str *ret, str *pw, int *bits);
@c
str CLTsha2sum(str *ret, str *pw, int *bits) {
	int len = (int) strlen(*pw);
	
	return AUTHSHA2Sum(ret, pw, &len, bits);
}

@mal
command backendsum(pw:str):str
address CLTbackendsum
comment "Return hex string representation of the currently used hash of the given string";
@h
clients_export str CLTbackendsum(str *ret, str *pw);
@c
str CLTbackendsum(str *ret, str *pw) {
	int len = (int) strlen(*pw);
	
	return AUTHBackendSum(ret, pw, &len);
}

@mal
pattern addUser(nme:str, pw:str, scen:bat[:str,:any_1]):oid
address CLTaddUser
comment "Allow user with password access to the given scenarios";
@h
clients_export str CLTaddUser(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
@c
str CLTaddUser(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci) {
	oid *ret = (oid *)getArgReference(stk, pci, 0);
	str *usr = (str *)getArgReference(stk, pci, 1);
	str *pw = (str *)getArgReference(stk, pci, 2);
	bat *sc = (bat *)getArgReference(stk, pci, 3);

	(void)mb;
	
	return AUTHaddUser(ret, &cntxt, usr, pw, sc);
}

@mal
pattern removeUser(nme:str):void
address CLTremoveUser
comment "Remove the given user from the system";
@h
clients_export str CLTremoveUser(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
@c
str CLTremoveUser(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci) {
	str *usr;
	(void)mb;

	usr = (str *)getArgReference(stk, pci, 1);

	return AUTHremoveUser(&cntxt, usr);
}

@mal
pattern getUsername():str
address CLTgetUsername
comment "Return the username of the currently logged in user";
@h
clients_export str CLTgetUsername(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
@c
str CLTgetUsername(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci) {
	str *ret = (str *)getArgReference(stk, pci, 0);
	(void)mb;

	return AUTHgetUsername(ret, &cntxt);
}

@mal
pattern getPasswordHash(user:str):str
address CLTgetPasswordHash
comment "Return the password hash of the given user";
@h
clients_export str CLTgetPasswordHash(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
@c
str CLTgetPasswordHash(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci) {
	str *ret = (str *)getArgReference(stk, pci, 0);
	str *user = (str *)getArgReference(stk, pci, 1);

	(void)mb;

	return AUTHgetPasswordHash(ret, &cntxt, user);
}

@mal
pattern changeUsername(old:str, new:str):void
address CLTchangeUsername
comment "Change the username of the user into the new string";
@h
clients_export str CLTchangeUsername(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
@c
str CLTchangeUsername(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci) {
	str *old = (str *)getArgReference(stk, pci, 1);
	str *new = (str *)getArgReference(stk, pci, 2);

	(void)mb;

	return AUTHchangeUsername(&cntxt, old, new);
}

@mal
pattern changePassword(old:str, new:str):void
address CLTchangePassword
comment "Change the password for the current user";
@h
clients_export str CLTchangePassword(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
@c
str CLTchangePassword(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci) {
	str *old = (str *)getArgReference(stk, pci, 1);
	str *new = (str *)getArgReference(stk, pci, 2);

	(void)mb;

	return AUTHchangePassword(&cntxt, old, new);
}

@mal
pattern setPassword(user:str, pass:str):void
address CLTsetPassword
comment "Set the password for the given user";
@h
clients_export str CLTsetPassword(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
@c
str CLTsetPassword(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci) {
	str *usr = (str *)getArgReference(stk, pci, 1);
	str *new = (str *)getArgReference(stk, pci, 2);

	(void)mb;

	return AUTHsetPassword(&cntxt, usr, new);
}

@mal
pattern checkPermission(usr:str, pw:str, sc:str):void
address CLTcheckPermission
comment "Check permission for a user, requires hashed password (backendsum)";
@h
clients_export str CLTcheckPermission(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
@c
str CLTcheckPermission(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci) {
	str *usr = (str *)getArgReference(stk, pci, 1);
	str *pw = (str *)getArgReference(stk, pci, 2);
	str *sc = (str *)getArgReference(stk, pci, 3);
	str ch = "";
	str algo = "SHA1";
	oid id;
	str pwd,msg;
	int len = (int) strlen(*pw);

	(void)mb;

	msg =AUTHSHA1Sum(&pwd, pw, &len);
	if (msg == MAL_SUCCEED ) {
		msg =AUTHcheckCredentials(&id, &cntxt, usr, &pwd, &ch, &algo, sc);
		GDKfree(pwd);
	}
	return msg;
}

@mal
pattern addScenario(usr:str, sc:str):void
address CLTaddScenario
comment "add the given scenario to the allowed scenarios for the given user";
@h
clients_export str CLTaddScenario(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
@c
str CLTaddScenario(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci) {
	str *usr = (str *)getArgReference(stk, pci, 1);
	str *sc = (str *)getArgReference(stk, pci, 2);

	(void)mb;

	return AUTHaddScenario(&cntxt, usr, sc);
}

@mal
pattern removeScenario(usr:str, sc:str):void
address CLTremoveScenario
comment "remove the given scenario from the allowed scenarios for the given user";
@h
clients_export str CLTremoveScenario(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
@c
str CLTremoveScenario(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci) {
	str *usr = (str *)getArgReference(stk, pci, 1);
	str *sc = (str *)getArgReference(stk, pci, 2);

	(void)mb;

	return  AUTHremoveScenario(&cntxt, usr, sc);
}

@mal
pattern getUsers(s:bat[:str,:any_1]):bat[:oid,:str]
address CLTgetUsers
comment "return a BAT with user id and name available in the system with access to the given scenario(s)";
@h
clients_export str CLTgetUsers(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
@c
str CLTgetUsers(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci) {
	bat *ret = (bat *)getArgReference(stk, pci, 0);
	bat *scens = (bat *)getArgReference(stk, pci, 1);
	BAT *r = NULL;
	str tmp;

	(void)mb;

	tmp= AUTHgetUsers(&r, &cntxt, scens);
	if( tmp)
		return tmp;
	BBPkeepref(*ret = r->batCacheid);
	return(MAL_SUCCEED);
}

str CLTshutdown(int *ret, bit *forced) {
	(void) ret;
	(void) forced;
	throw(MAL,"clients.shutdown", PROGRAM_NYI);
}
@h
#endif /* _CLIENTS_H */
@}
