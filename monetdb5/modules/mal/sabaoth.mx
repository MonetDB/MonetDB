@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.monetdb.org/Legal/MonetDBLicense

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2011 MonetDB B.V.
All Rights Reserved.
@

@f sabaoth
@a Fabian Groffen
@+ Disk-based local database administration
"Sophia starts creation, without her male half.  That causes a shade,
the chaos or the darkness.  The ruler of this darkness is called
Yaldabaoth.  He thinks he is the only god, which makes Sophia angry.
She shows herself as reflection in the water.  Later, Yaldabaoth's son,
Sabaoth, revolts against his father.  Sophia rewards him for that with a
place in the seventh heaven."

Local servers within a dbfarm go largerly by themselves.  However,
multiple databases are a common good among the dinosaurs, and prove to
be useful for us mammals as well.  In particular Merovingian exploits
the multi-database nature to perform it's services.  The Sabaoth module
breaks with the tradition that a database goes by itself, alone.  It
provides means to query which local databases exist and to retrieve
properties of those.  This includes whether or not a database is
running, if it accepts connections and where, if it is under maintance,
etc.

This module is a product of the Armada way of thinking, which nowadays
is best coined under "cloud".  While this module does not perform any
actions itself, let alone remote onces, it is a local building block for
components that do facilitate the cloud, such as Merovingian.

@mal
module sabaoth;

command prelude() :void
address SABprelude
comment "Initialise the sabaoth module";

command epilogue() :void
address SABepilogue
comment "Release the resources held by the sabaoth module";


command marchScenario(lang:str)
address SABmarchScenario
comment "Publishes the given language as available for this server";

command retreatScenario(lang:str)
address SABretreatScenario
comment "Unpublishes the given language as available for this server";

command marchConnection(host:str, port:int)
address SABmarchConnection
comment "Publishes the given host/port as available for connecting to this server";

command getLocalConnectionURI():str
address SABgetLocalConnectionURI
comment "Returns the URI this server can be connected to, or nil if none";

command getLocalConnectionHost():str
address SABgetLocalConnectionHost
comment "Returns the hostname this server can be connected to, or nil if none";

command getLocalConnectionPort():int
address SABgetLocalConnectionPort
comment "Returns the port this server can be connected to, or 0 if none";

command wildRetreat()
address SABwildRetreat
comment "Unpublishes everything known for this server";

# serialise and deserialise are not available from MAL, but can be made
# available if there is reasonable need for it (haven't found one to date)

#sabaoth.prelude();

@- Implementation

@h

#ifndef _SABAOTH_DEF
#define _SABAOTH_DEF

#ifdef WIN32
#if !defined(LIBMAL) && !defined(LIBATOMS) && !defined(LIBKERNEL) && !defined(LIBMAL) && !defined(LIBOPTIMIZER) && !defined(LIBSCHEDULER) && !defined(LIBMONETDB5)
#define sabaoth_export extern __declspec(dllimport)
#else
#define sabaoth_export extern __declspec(dllexport)
#endif
#else
#define sabaoth_export extern
#endif

sabaoth_export str SABprelude(int *ret);
sabaoth_export str SABepilogue(int *ret);
sabaoth_export str SABmarchScenario(int *ret, str *lang);
sabaoth_export str SABretreatScenario(int *ret, str *lang);
sabaoth_export str SABmarchConnection(int *ret, str *host, int *port) ;
sabaoth_export str SABgetLocalConnectionURI(str *ret);
sabaoth_export str SABgetLocalConnectionHost(str *ret);
sabaoth_export str SABgetLocalConnectionPort(int *ret);
sabaoth_export str SABwildRetreat(int *ret);

#endif
@-

@c
#include "monetdb_config.h"
#include <mal.h>
#include <mal_exception.h>
#include <mal_sabaoth.h>	/* for the implementation of the functions */
#include "sabaoth.h"

str SABprelude(int *ret) {
	(void)ret;

	return(MAL_SUCCEED);
}

str SABepilogue(int *ret) {
	(void)ret;

	return(SABAOTHwildRetreat(ret));
}

str SABmarchScenario(int *ret, str *lang){
	return SABAOTHmarchScenario(ret, lang);
}

str SABretreatScenario(int *ret, str *lang){
	return SABAOTHretreatScenario(ret, lang);
}

str SABmarchConnection(int *ret, str *host, int *port) {
	return SABAOTHmarchConnection(ret, host, port);
}

str SABgetLocalConnectionURI(str *ret) {
	str tmp, con;

	rethrow("sabaoth.getLocalConnectionURI", tmp,
			SABAOTHgetLocalConnection(&con));

	*ret = con;
	return(MAL_SUCCEED);
}

str SABgetLocalConnectionHost(str *ret) {
	str tmp, con, p;

	rethrow("sabaoth.getLocalConnectionHost", tmp,
			SABAOTHgetLocalConnection(&con));

	/* this happens if no connection is available */
	if (strcmp(con, (str)str_nil) == 0) {
		*ret = con;
		return(MAL_SUCCEED);
	}

	/* con looks like mapi:monetdb://hostname:port */
	/* do some poor man's parsing */
	tmp = con;
	if ((p = strchr(con, ':')) == NULL) {
		p = createException(MAL, "sabaoth.getLocalConnectionHost",
				"invalid local connection string: %s", tmp);
		GDKfree(tmp);
		return(p);
	}
	if ((con = strchr(p + 1, ':')) == NULL) {
		p = createException(MAL, "sabaoth.getLocalConnectionHost",
				"invalid local connection string: %s", tmp);
		GDKfree(tmp);
		return(p);
	}
	if ((p = strchr(con + 3, ':')) == NULL) {
		p = createException(MAL, "sabaoth.getLocalConnectionHost",
				"invalid local connection string: %s", tmp);
		GDKfree(tmp);
		return(p);
	}
	*p = '\0';

	*ret = GDKstrdup(con + 3);
	GDKfree(tmp);
	return(MAL_SUCCEED);
}

str SABgetLocalConnectionPort(int *ret) {
	str tmp, con, p;

	rethrow("sabaoth.getLocalConnectionHost", tmp,
			SABAOTHgetLocalConnection(&con));

	/* this happens if no connection is available */
	if (strcmp(con, (str)str_nil) == 0) {
		*ret = 0;
		GDKfree(con);
		return(MAL_SUCCEED);
	}

	/* con looks like mapi:monetdb://hostname:port */
	/* do some poor man's parsing */
	tmp = con;
	if ((p = strchr(con, ':')) == NULL) {
		p = createException(MAL, "sabaoth.getLocalConnectionHost",
				"invalid local connection string: %s", tmp);
		GDKfree(tmp);
		return(p);
	}
	if ((p = strchr(p + 1, ':')) == NULL) {
		p = createException(MAL, "sabaoth.getLocalConnectionHost",
				"invalid local connection string: %s", tmp);
		GDKfree(tmp);
		return(p);
	}
	if ((con = strchr(p + 1, ':')) == NULL) {
		p = createException(MAL, "sabaoth.getLocalConnectionHost",
				"invalid local connection string: %s", tmp);
		GDKfree(tmp);
		return(p);
	}
	if ((p = strchr(con + 1, '/')) == NULL) {
		p = createException(MAL, "sabaoth.getLocalConnectionHost",
				"invalid local connection string: %s", tmp);
		GDKfree(tmp);
		return(p);
	}
	*p = '\0';

	*ret = atoi(con + 1);
	GDKfree(tmp);
	return(MAL_SUCCEED);
}

str SABwildRetreat(int *ret) {
	return SABAOTHwildRetreat(ret);
}
