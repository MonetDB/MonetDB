@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2011 MonetDB B.V.
All Rights Reserved.
@

@f streams
@a Niels Nes
@* A simple interface to IO streams
All file IO is tunneled through the stream library, which guarantees
cross-platform capabilities.  Several protocols are provided, e.g. it
can be used to open 'non compressed, gzipped, bzip2ed' data files.  It
encapsulates the corresponding library managed in common/stream.

@mal
module streams;

atom streams:ptr;

command openReadBytes{unsafe}( filename:str ) :streams
address mnstr_open_rstreamwrap
comment "open a file stream for reading";
command openWriteBytes{unsafe}( filename:str ) :streams
address mnstr_open_wstreamwrap
comment "open a file stream for writing";

command openRead{unsafe}( filename:str ) :streams
address mnstr_open_rastreamwrap
comment "open ascii file stream for reading";
command openWrite{unsafe}( filename:str ) :streams
address mnstr_open_wastreamwrap
comment "open ascii file stream for writing";

command openRead{unsafe}(s:streams):streams
address mnstr_stream_rstreamwrap
comment "convert an ascii stream to binary";
command openWrite{unsafe}(s:streams):streams
address mnstr_stream_wstreamwrap
comment "convert an ascii stream to binary";

command socketReadBytes{unsafe}(skt:int,name:str):streams
address mnstr_socket_rstreamwrap
comment "open a socket stream for reading";
command socketWriteBytes{unsafe}(skt:int,name:str):streams
address mnstr_socket_wstreamwrap
comment "open a socket stream for writing";
command socketRead{unsafe}(skt:int,name:str):streams
address mnstr_socket_rastreamwrap
comment "open ascii socket stream for reading";
command socketWrite{unsafe}(skt:int,name:str):streams
address mnstr_socket_wastreamwrap
comment "open ascii socket stream for writing";

command blocked{unsafe}( s:streams ) :streams
address open_block_streamwrap
comment "open a block based stream";

command writeStr{unsafe}( s:streams, data:str ):void
address mnstr_write_stringwrap
comment "write data on the stream";
command writeInt{unsafe}( s:streams, data:int ):void
address mnstr_writeIntwrap
comment "write data on the stream";
command readStr{unsafe}( s:streams):str
address mnstr_read_stringwrap
comment "read string data from the stream";
command readInt{unsafe}( s:streams):int
address mnstr_readIntwrap
comment "read integer data from the stream";

command flush{unsafe}( s:streams )
address mnstr_flush_streamwrap
comment "flush the stream";

command close{unsafe}( s:streams )
address mnstr_close_streamwrap
comment "close and destroy the stream s";

atom bstream:ptr;
command create{unsafe}(s:streams, bufsize:int):bstream
address bstream_create_wrapwrap
comment "create a buffered stream";

command destroy{unsafe}(s:bstream)
address bstream_destroy_wrapwrap
comment "destroy bstream";

command read{unsafe}(s:bstream,size:int):int
address bstream_read_wrapwrap
comment "read at least size bytes into the buffer of s";

@-
@{
@h
#ifndef _STREAMS_H_
#define _STREAMS_H_

typedef ptr Stream;
typedef ptr Bstream;

#endif /*_STREAMS_H_*/
@c
#include "monetdb_config.h"
#include <mal.h>
#include "streams.h"
#include <stdio.h>
#include <stream_socket.h>

#ifdef WIN32
#if !defined(LIBMAL) && !defined(LIBATOMS) && !defined(LIBKERNEL) && !defined(LIBMAL) && !defined(LIBOPTIMIZER) && !defined(LIBSCHEDULER) && !defined(LIBMONETDB5)
#define streams_export extern __declspec(dllimport)
#else
#define streams_export extern __declspec(dllexport)
#endif
#else
#define streams_export extern
#endif

streams_export int mnstr_write_string(Stream *S, str data);
streams_export int mnstr_writeInt_wrap(Stream *S, int *data);
streams_export int mnstr_readInt_wrap(int *data, Stream *S);
streams_export int mnstr_read_string(str *res, Stream *S);
streams_export int mnstr_flush_stream(Stream *S);
streams_export int mnstr_close_stream(Stream *S);
streams_export int open_block_stream(Stream *S, Stream *is);
streams_export int bstream_create_wrap(Bstream *BS, Stream *S, int *bufsize);
streams_export int bstream_destroy_wrap(Bstream *BS);
streams_export int bstream_read_wrap(int *res, Bstream *BS, int *size);
streams_export str mnstr_write_stringwrap(int *ret, Stream *S, str *data);
streams_export str mnstr_writeIntwrap(int *ret, Stream *S, int *data);
streams_export str mnstr_readIntwrap(int *ret, Stream *S);
streams_export str mnstr_read_stringwrap(str *res, Stream *s);
streams_export str mnstr_flush_streamwrap(int *ret, Stream *s);
streams_export str mnstr_close_streamwrap(int *ret, Stream *s);
streams_export str open_block_streamwrap(Stream *S, Stream *is);
streams_export str bstream_create_wrapwrap(Bstream *Bs, Stream *S, int *bufsize);
streams_export str bstream_destroy_wrapwrap(int *ret, Bstream *BS);
streams_export str bstream_read_wrapwrap(int *res, Bstream *BS, int *size);
streams_export str mnstr_readIntwrap(int *ret, Stream *S);
streams_export str mnstr_read_stringwrap(str *res, Stream *s);

@= open_streamwrap
streams_export str mnstr_open_@1wrap(Stream *S, str *filename);
str mnstr_open_@1wrap(Stream *S, str *filename)
{
	stream *s;

	if ((s = open_@1(*filename)) == NULL || mnstr_errnr(s)) {
		int errnr = mnstr_errnr(s);
		if (s)
			mnstr_destroy(s);
		throw(IO, "streams.open", "could not open file '%s': %s",
				*filename, strerror(errnr));
	} else {
		*(stream**)S = s;
	}

	return MAL_SUCCEED;
}
@}
@c
#include "mal_exception.h"

@:open_streamwrap(rstream)@
@:open_streamwrap(wstream)@
@:open_streamwrap(rastream)@
@:open_streamwrap(wastream)@

@-
@= mnstr_streamwrap
streams_export str mnstr_stream_@1wrap(Stream *sout, Stream *sin);
str
mnstr_stream_@1wrap(Stream *sout, Stream *sin)
{
	*(stream**)sout = mnstr_@1(*(stream**)sin);
	return MAL_SUCCEED;
}
@c
@:mnstr_streamwrap(rstream)@
@:mnstr_streamwrap(wstream)@
@-
@= open_socketwrap
streams_export str mnstr_socket_@1wrap(Stream *S, int *socket, str *name);
str
mnstr_socket_@1wrap(Stream *S, int *sock, str *name)
{
	stream *s;

	if ((s = socket_@1(*sock, *name)) == NULL || mnstr_errnr(s)) {
		int errnr = mnstr_errnr(s);
		if (s)
			mnstr_destroy(s);
		throw(IO, "streams.open", "could not open socket: %s",
				strerror(errnr));
	} else {
		*(stream**)S = s;
	}

	return MAL_SUCCEED;
}
@c
@:open_socketwrap(rstream)@
@:open_socketwrap(wstream)@
@:open_socketwrap(rastream)@
@:open_socketwrap(wastream)@

str
mnstr_write_stringwrap(int *ret, Stream *S, str *data)
{
	stream *s = *(stream **)S;
	(void)ret;

	if (mnstr_write(s, *data, 1, strlen(*data)) < 0)
		throw(IO, "streams.writeStr", "failed to write string");

	return MAL_SUCCEED;
}

str
mnstr_writeIntwrap(int *ret, Stream *S, int *data)
{
	stream *s = *(stream **)S;
	(void)ret;

	if (!mnstr_writeInt(s, *data))
		throw(IO, "streams.writeInt", "failed to write int");

	return MAL_SUCCEED;
}

str
mnstr_readIntwrap(int *ret, Stream *S)
{
	stream *s = *(stream **)S;

	if (!mnstr_readInt(s, ret))
		throw(IO, "streams.readInt", "failed to read int");

	return MAL_SUCCEED;
}

#define CHUNK (64 * 1024)
str
mnstr_read_stringwrap(str *res, Stream *S)
{
	stream *s = *(stream **)S;
	ssize_t len = 0;
	size_t size = CHUNK + 1;
	char *buf = GDKmalloc(size), *start = buf;

	while ((len = mnstr_read(s, start, 1, CHUNK)) > 0) {
		size += len;
		buf = GDKrealloc(buf, size);
		start = buf + size - CHUNK - 1;

		*start = '\0';
	}
	if (len < 0)
		throw(IO, "streams.readStr", "failed to read string");
	start += len;
	*start = '\0';
	*res = buf;

	return MAL_SUCCEED;
}

str
mnstr_flush_streamwrap(int *ret, Stream *S)
{
	stream *s = *(stream **)S;
	(void)ret;

	if (mnstr_flush(s))
		throw(IO, "streams.flush", "failed to flush stream");

	return MAL_SUCCEED;
}

str
mnstr_close_streamwrap(int *ret, Stream *S)
{
	(void)ret;

	close_stream(*(stream **)S);

	return MAL_SUCCEED;
}

str
open_block_streamwrap(Stream *S, Stream *is)
{
	if ((*(stream **)S = block_stream(*(stream **)is)) == NULL)
		throw(IO, "bstreams.open", "failed to open block stream");

	return MAL_SUCCEED;
}

str
bstream_create_wrapwrap(Bstream *Bs, Stream *S, int *bufsize)
{
	if ((*(bstream **)Bs = bstream_create(*(stream **)S, (size_t)*bufsize)) == NULL)
		throw(IO, "bstreams.create", "failed to create block stream");

	return MAL_SUCCEED;
}

str
bstream_destroy_wrapwrap(int *ret, Bstream *BS)
{
	(void)ret;

	bstream_destroy(*(bstream **)BS);

	return MAL_SUCCEED;
}

str
bstream_read_wrapwrap(int *res, Bstream *BS, int *size)
{
	*res = (int)bstream_read(*(bstream **)BS, (size_t)*size);

	return MAL_SUCCEED;
}
