@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.monetdb.org/Legal/MonetDBLicense

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2011 MonetDB B.V.
All Rights Reserved.
@

@c
/*
 * @f batxml
 * @a M.L. Kersten
 * @+ XML multiplexes
 * SQL/XML requires a handful of instructions.
 * The collection of routines provided here are map operations
 * for the atom xml primitives.
 *
 * In line with the batcalc module, we assume that
 * if two bat operands are provided that they are already
 * aligned on the head. Moreover, the head of the BATs
 * are limited to :oid.
 *
 * The implementation is focussed on functionality. At a later stage
 * we may postpone string contstruction until it is really needed.
 */
@mal

command xml.xml(src:bat[:oid,:str]):bat[:oid,:xml]
address BATXMLstr2xml
comment "Cast the string to an xml compliant string.";

command xml.str(src:bat[:oid,:xml]):bat[:oid,:str]
address BATXMLxml2str
comment "Cast the xml to a string.";

command xml.document(src:bat[:oid,:str]):bat[:oid,:xml]
address BATXMLdocument
comment "Parse the string as an XML document.";

command xml.content(src:bat[:oid,:str]):bat[:oid,:xml]
address BATXMLcontent
comment "Parse the string as XML element content.";

command xml.comment(val:bat[:oid,:str]):bat[:oid,:xml]
address BATXMLcomment
comment "Create an XML comment element.";

command xml.parse(doccont:str,val:bat[:oid,:str],option:str):bat[:oid,:xml]
address BATXMLparse
comment "Parse the XML document or element string values.";

command xml.serialize(val:bat[:oid,:xml]):bat[:oid,:str]
address BATXMLxml2str
comment "Serialize the XML object to a string.";

command xml.text(val:bat[:oid,:xml]):bat[:oid,:str]
address BATXMLxmltext
comment "Serialize the XML object to a string.";

command xml.xquery(val:bat[:oid,:str],expr:str):bat[:oid,:xml]
address BATXMLxquery
comment "Execute the XQuery against the elements.";

# @-
# todo
# command xml.table(val:bat[:oid,:str],expr:str):bat[:oid,:xml]
# address BATXMLquery
# comment "Execute the XQuery against the elements";

command xml.pi(target:str, val:bat[:oid,:xml]):bat[:oid,:xml]
address BATXMLpi
comment "Construct a processing instruction.";

command xml.attribute(name:str, val:bat[:oid,:str]):bat[:oid,:xml]
address BATXMLattribute
comment "Construct an attribute value pair.";

command xml.element(name:str, s:bat[:oid,:xml]) :bat[:oid,:xml]
address BATXMLelementSmall
comment "The basic building block for XML elements are namespaces, attributes and a sequence of XML elements. The name space and the attributes may be left unspecified."; 

command xml.options(tag:str, option:str,left:bat[:oid,:xml]):bat[:oid,:xml]
address BATXMLoptions
comment "Create the components including NULL conversions.";

command xml.element(name:str, ns:xml, attr:xml, s:bat[:oid,:xml]):bat[:oid,:xml]
address BATXMLelement
comment "The basic building block for XML elements are namespaces, attributes and a sequence of XML elements. The name space and the attributes may be left unspecified(=nil).";

command xml.concat(left:bat[:oid,:xml],right:bat[:oid,:xml] ):bat[:oid,:xml]
address BATXMLconcat
comment "Concatenate the XML values.";

pattern xml.forest(val:bat[:oid,:xml]...):bat[:oid,:xml]
address BATXMLforest
comment "Construct an element list.";

command xml.agg(val:bat[:oid,:xml],grp:bat[:oid,:oid],e:bat[:oid,:any_1]):bat[:oid,:xml]
address BATXMLagg3
comment "Aggregate the XML values over groups specified.";

command xml.agg(val:bat[:oid,:xml],grp:bat[:oid,:oid]):bat[:oid,:xml]
address BATXMLagg
comment "Aggregate the XML values over groups specified.";

command xml.agg(val:bat[:oid,:xml]):xml
address BATXMLgroup
comment "Aggregate the XML values over groups specified.";

command xml.root(val:bat[:oid,:xml], version:str, standalone:str):bat[:oid,:xml]
address BATXMLroot
comment "Contruct the root nodes.";

command xml.isdocument(val:bat[:oid,:str]):bat[:oid,:bit]
address BATXMLisdocument
comment "Validate the string as a XML document.";

module batcalc;
command xml(src:bat[:oid,:str]):bat[:oid,:xml] address BATXMLstr2xml;

@include ../../modules/kernel/kprelude.mx
@h
/*
 * @+ Implementation
 */
#ifndef _BATXML_H_
#define _BATXML_H_
#include <gdk.h>
#include "ctype.h"
#include <string.h>
#include "mal_interpreter.h"
#include "mal_function.h"
#include "xml.h"


#ifdef WIN32
#ifndef LIBATOMS
#define batxml_export extern __declspec(dllimport)
#else
#define batxml_export extern __declspec(dllexport)
#endif
#else
#define batxml_export extern
#endif

batxml_export str BATXMLxml2str(int *ret, int *bid);
batxml_export str BATXMLxmltext(int *ret, int *bid);
batxml_export str BATXMLstr2xml(int *x, int *s);
batxml_export str BATXMLdocument(int *x, int *s);
batxml_export str BATXMLcontent(int *x, int *s);
batxml_export str BATXMLisdocument(int *x, int *s);
batxml_export str BATXMLelementSmall(int *x, str *name, int *s);
batxml_export str BATXMLoptions(int *x, str *name, str *options, int *s);
batxml_export str BATXMLcomment(int *x, int *s);
batxml_export str BATXMLparse(int *x, str *doccont, int *s, str *option);
batxml_export str BATXMLxquery(int *x, int *s, str *expr);
batxml_export str BATXMLpi(int *x, str *tgt, int *s);
batxml_export str BATXMLroot(int *ret, int *bid, str *version, str *standalone);
batxml_export str BATXMLattribute(int *ret, str *name, int *bid);
batxml_export str BATXMLelement(int *ret, str *name, xml *ns, xml *attr, int *bid);
batxml_export str BATXMLconcat(int *ret, int *bid, int *rid);
batxml_export str BATXMLforest(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
batxml_export str BATXMLagg(int *ret, int *bid, int *grp);
batxml_export str BATXMLagg3(int *ret, int *bid, int *grp, int *e);
batxml_export str BATXMLgroup(xml *ret, int *bid);
#endif /* _BATXML_H_ */
@c
#include "monetdb_config.h"
#include "batxml.h"

#include <libxml/parser.h>

#define prepareOperand(X,Y,Z)								\
    if (((X) = BATdescriptor(*(Y))) == NULL )				\
        throw(MAL, "xml." Z, INTERNAL_BAT_ACCESS);

#define prepareResult(X,Y,tpe,Z)					\
    (X) = BATnew((Y)->htype, (tpe), BATcount(Y));	\
    if ((X) == NULL) {								\
        BBPreleaseref((Y)->batCacheid);				\
        throw(MAL, "xml." Z, MAL_MALLOC_FAIL); \
    }												\
    if ((Y)->htype == TYPE_void)					\
        BATseqbase((X), (Y)->hseqbase);				\
    (X)->hsorted = (Y)->hsorted;					\
    (X)->tsorted =  0;								\
    (X)->H->nonil = (Y)->H->nonil;					\
	(X)->T->nonil = 1;

#define finalizeResult(X,Y,Z)					\
    if (!((Y)->batDirty & 2))					\
		(Y) = BATsetaccess((Y), BAT_READ);		\
    *(X) = (Y)->batCacheid;						\
    BBPkeepref(*(X));							\
    BBPreleaseref((Z)->batCacheid);

str
BATXMLxml2str(int *ret, int *bid)
{
	BAT *b, *bn;
	BUN p, q;
	BATiter bi;

	prepareOperand(b, bid, "str");
	prepareResult(bn, b, TYPE_str, "str");
	bi = bat_iterator(b);
	BATaccessBegin(b,USE_HEAD|USE_TAIL,MMAP_SEQUENTIAL);
	BATloop(b, p, q) {
		ptr h = BUNhead(bi, p);
		str t = (str) BUNtail(bi, p);

		if (strNil(t)) {
			bunfastins(bn, h, t);
			bn->T->nonil = 0;
		} else {
			assert(*t == 'A' || *t == 'C' || *t == 'D');
			bunfastins(bn, h, t + 1);
		}
	}
	BATaccessEnd(b,USE_HEAD|USE_TAIL,MMAP_SEQUENTIAL);
	finalizeResult(ret, bn, b);
	return MAL_SUCCEED;
  bunins_failed:
	BATaccessEnd(b,USE_HEAD|USE_TAIL,MMAP_SEQUENTIAL);
	BBPreleaseref(b->batCacheid);
	BBPunfix(bn->batCacheid);
	throw(MAL, "xml.str", OPERATION_FAILED " During bulk coercion");
}

str
BATXMLxmltext(int *ret, int *bid)
{
	BAT *b, *bn;
	BUN p, q;
	BATiter bi;
	size_t size = 0;
	str buf = NULL;
	xmlDocPtr doc = NULL;
	xmlNodePtr elem;
	str content = NULL, err = OPERATION_FAILED;

	prepareOperand(b, bid, "text");
	prepareResult(bn, b, TYPE_str, "text");
	bi = bat_iterator(b);
	BATaccessBegin(b,USE_HEAD|USE_TAIL,MMAP_SEQUENTIAL);
	BATloop(b, p, q) {
		ptr h = BUNhead(bi, p);
		str t = (str) BUNtail(bi, p);
		size_t len;

		if (strNil(t)) {
			bunfastins(bn, h, t);
			bn->T->nonil = 0;
			continue;
		}
		assert(*t == 'A' || *t == 'C' || *t == 'D');
		len = strlen(t);
		if (*t == 'D') {
			xmlDocPtr d = xmlParseMemory(t + 1, (int) (len - 1));
			elem = xmlDocGetRootElement(d);
			content = (str) xmlNodeGetContent(elem);
			xmlFreeDoc(d);
			if (content == NULL) {
				err= MAL_MALLOC_FAIL;
				goto bunins_failed;
			}
		} else if (*t == 'C') {
			if (doc == NULL)
				doc = xmlParseMemory("<doc/>", 6);
			xmlParseInNodeContext(xmlDocGetRootElement(doc), t + 1, (int) (len - 1), 0, &elem);
			content = (str) xmlNodeGetContent(elem);
			xmlFreeNodeList(elem);
			if (content == NULL) {
				err= MAL_MALLOC_FAIL;
				goto bunins_failed;
			}
		} else {
			str s;

			if (buf == 0 || size < len) {
				size = len + 128;
				if (buf != NULL)
					GDKfree(buf);
				buf = GDKmalloc(size);
				if ( buf == 0) {
					err= MAL_MALLOC_FAIL;
					goto bunins_failed;
				}
			}
			s = buf;
			t++;
			while (*t) {
				if (*t == '"' || *t == '\'') {
					char q = *t++;

					s += XMLunquotestring(&t, q, s);
				}
				t++;
			}
			*s = 0;
		}
		assert(content != NULL || buf != NULL);
		bunfastins(bn, h, content != NULL ? content : buf);
		if (content != NULL)
			GDKfree(content);
		content = NULL;
	}
	BATaccessEnd(b,USE_HEAD|USE_TAIL,MMAP_SEQUENTIAL);
	finalizeResult(ret, bn, b);
	if (buf != NULL)
		GDKfree(buf);
	if (doc != NULL)
		xmlFreeDoc(doc);
	return MAL_SUCCEED;
  bunins_failed:
	BATaccessEnd(b,USE_HEAD|USE_TAIL,MMAP_SEQUENTIAL);
	BBPreleaseref(b->batCacheid);
	BBPunfix(bn->batCacheid);
	if (buf != NULL)
		GDKfree(buf);
	if (doc != NULL)
		xmlFreeDoc(doc);
	if (content != NULL)
		GDKfree(content);
	throw(MAL, "xml.text", "%s", err );
}

/*
 * @-
 * The core of the activity is str2xml, where the actual strings
 * are constructed.
 * To avoid repetitive copying we make sure that the garbage
 * collector does not remove the xml intermediates.
 * This way, we know that as long as the xml-variables are not
 * reused, the complete structure of the xml document(s) are available.
 * We merely have to collect the pieces.
 * [FOR LATER, FIRST GO FOR THE EASY IMPLEMENTATION]
 * @-
 * XML values are represented by strings already.
 */
str
BATXMLstr2xml(int *ret, int *bid)
{
	BAT *b, *bn;
	BUN p, q;
	size_t size = BUFSIZ;
	str buf, err= OPERATION_FAILED;
	BATiter bi;

	buf = GDKmalloc(size);
	if ( buf == NULL)
		throw(MAL,"xml.str2xml",MAL_MALLOC_FAIL);
	prepareOperand(b, bid, "xml");
	prepareResult(bn, b, TYPE_xml, "xml");
	bi = bat_iterator(b);
	BATloop(b, p, q) {
		ptr h = BUNhead(bi, p);
		str t = (str) BUNtail(bi, p);
		size_t len;

		if (strNil(t)) {
			bunfastins(bn, h, str_nil);
			bn->T->nonil = 0;
			continue;
		}

		len = strlen(t) * 6 + 1;
		if (size < len) {
			size = len + 128;
			GDKfree(buf);
			buf = GDKmalloc(size);
			if ( buf == NULL){
				err= MAL_MALLOC_FAIL;
				goto bunins_failed;
			}
		}
		buf[0] = 'C';
		XMLquotestring(t, buf + 1, size - 1);
		bunfastins(bn, h, buf);
	}
	GDKfree(buf);
	finalizeResult(ret, bn, b);
	return MAL_SUCCEED;
  bunins_failed:
	BBPreleaseref(b->batCacheid);
	BBPunfix(bn->batCacheid);
	if ( buf != NULL )
		GDKfree(buf);
	throw(MAL, "xml.xml", "%s", err);
}

str
BATXMLdocument(int *ret, int *bid)
{
	BAT *b, *bn;
	BUN p, q;
	BATiter bi;
	size_t size = BUFSIZ;
	str buf = GDKmalloc(size);
	str err = OPERATION_FAILED;

	if ( buf == NULL)
		throw(MAL,"xml.document",MAL_MALLOC_FAIL);
	prepareOperand(b, bid, "document");
	prepareResult(bn, b, TYPE_xml, "document");
	bi = bat_iterator(b);
	BATloop(b, p, q) {
		ptr h = BUNhead(bi, p);
		str t = (str) BUNtail(bi, p);
		xmlDocPtr doc;
		int len;
		xmlChar *s;

		if (strNil(t)) {
			bunfastins(bn, h, str_nil);
			bn->T->nonil = 0;
			continue;
		}
		len = (int) strlen(t);
		doc = xmlParseMemory(t, len);
		if (doc == NULL) {
			BBPreleaseref(b->batCacheid);
			BBPunfix(bn->batCacheid);
			throw(MAL, "xml.document", OPERATION_FAILED XML_PARSE_ERROR);
		}
		xmlDocDumpMemory(doc, &s, &len);
		xmlFreeDoc(doc);
		if ((size_t) len + 2 >= size) {
			GDKfree(buf);
			size = (size_t) len + 128;
			buf = GDKmalloc(size);
			if ( buf == NULL){
				err= MAL_MALLOC_FAIL;
				goto bunins_failed;
			}
		}
		buf[0] = 'D';
		strcpy(buf + 1, (char *) s);
		bunfastins(bn, h, buf);
	}
	GDKfree(buf);
	finalizeResult(ret, bn, b);
	return MAL_SUCCEED;
  bunins_failed:
	GDKfree(buf);
	BBPreleaseref(b->batCacheid);
	BBPunfix(bn->batCacheid);
	throw(MAL, "xml.document", "%s", err);
}

str
BATXMLcontent(int *ret, int *bid)
{
	BAT *b, *bn;
	BUN p, q;
	BATiter bi;
	xmlDocPtr doc;
	xmlNodePtr root;
	size_t size = BUFSIZ;
	str buf = GDKmalloc(size);
	str err = OPERATION_FAILED;
	xmlBufferPtr xbuf;

	if ( buf == NULL)
		throw(MAL,"xml.content",MAL_MALLOC_FAIL);
	doc = xmlParseMemory("<doc/>", 6);
	root = xmlDocGetRootElement(doc);
	prepareOperand(b, bid, "content");
	prepareResult(bn, b, TYPE_xml, "content");
	bi = bat_iterator(b);
	xbuf = xmlBufferCreate();
	BATloop(b, p, q) {
		ptr h = BUNhead(bi, p);
		str t = (str) BUNtail(bi, p);
		size_t len;
		xmlNodePtr elem;
		xmlParserErrors err;
		const xmlChar *s;

		if (strNil(t)) {
			bunfastins(bn, h, str_nil);
			bn->T->nonil = 0;
			continue;
		}
		len = strlen(t);
		err = xmlParseInNodeContext(root, t, (int) len, 0, &elem);
		if (err != XML_ERR_OK) {
			xmlBufferFree(xbuf);
			xmlFreeDoc(doc);
			BBPreleaseref(b->batCacheid);
			BBPunfix(bn->batCacheid);
			throw(MAL, "xml.content", XML_PARSE_ERROR);
		}
		xmlNodeDump(xbuf, doc, elem, 0, 0);
		s = xmlBufferContent(xbuf);
		len = strlen((const char *) s);
		if (len + 2 >= size) {
			GDKfree(buf);
			size = len + 128;
			buf = GDKmalloc(size);
			if ( buf == NULL){
				xmlBufferFree(xbuf);
				xmlFreeDoc(doc);
				BBPreleaseref(b->batCacheid);
				BBPunfix(bn->batCacheid);
				throw(MAL, "xml.document", MAL_MALLOC_FAIL);
			}
		}
		buf[0] = 'C';
		strcpy(buf + 1, (const char *) s);
		bunfastins(bn, h, buf);
		xmlBufferEmpty(xbuf);
		xmlFreeNodeList(elem);
	}
	xmlBufferFree(xbuf);
	xmlFreeDoc(doc);
	GDKfree(buf);
	finalizeResult(ret, bn, b);
	return MAL_SUCCEED;
  bunins_failed:
	xmlBufferFree(xbuf);
	xmlFreeDoc(doc);
	if ( buf != NULL )
		GDKfree(buf);
	BBPreleaseref(b->batCacheid);
	BBPunfix(bn->batCacheid);
	throw(MAL, "xml.document", "%s", err);
}

str
BATXMLisdocument(int *ret, int *bid)
{
	BAT *b, *bn;
	BUN p, q;
	BATiter bi;

	prepareOperand(b, bid, "isdocument");
	prepareResult(bn, b, TYPE_bit, "isdocument");
	bi = bat_iterator(b);
	BATloop(b, p, q) {
		ptr h = BUNhead(bi, p);
		str t = (str) BUNtail(bi, p);
		xmlDocPtr doc;
		bit val;

		if (strNil(t)) {
			val = bit_nil;
			bn->T->nonil = 0;
		} else {
			doc = xmlParseMemory(t, (int) strlen(t));
			if (doc == NULL) {
				val = 0;
			} else {
				xmlFreeDoc(doc);
				val = 1;
			}
		}
		bunfastins(bn, h, &val);
	}
	finalizeResult(ret, bn, b);
	return MAL_SUCCEED;
  bunins_failed:
	BBPreleaseref(b->batCacheid);
	BBPunfix(bn->batCacheid);
	throw(MAL, "xml.isdocument", OPERATION_FAILED " During bulk processing");
}

/*
 * @-
 * The standard supports specific mappings for
 * NULL values,i.e. {null,absent,empty,nil,niloncontent)
 * in the context of an element and forest construction.
 * The standard should be studied in more detail, because
 * the syntax(rules) seem ambiguous.
 * It applies to all components of an element or their
 * concatenation.
 *
 * For the time being, the variaton on XMLtag seems the
 * most reasonable interpretation.
 */
str
BATXMLoptions(int *ret, str *name, str *options, int *bid)
{
	BAT *b, *bn;
	BUN p, q;
	str buf = GDKmalloc(BUFSIZ);
	str val = GDKmalloc(BUFSIZ);
	int size = BUFSIZ, len = (int) strlen(*name);
	BATiter bi;
	str err = OPERATION_FAILED " During bulk options analysis";

	if ( val == NULL || buf == NULL){
		if (val != NULL) GDKfree(val);
		if (buf != NULL) GDKfree(buf);
		throw(MAL, "batxml.options", MAL_MALLOC_FAIL);
	}
	prepareOperand(b, bid, "options");
	prepareResult(bn, b, TYPE_xml, "options");

	if (strcmp(*options, "absent") == 0)
		buf[0] = 0;
	else if (strcmp(*options, "empty") == 0)
		snprintf(buf, size, "<%s></%s>", *name, *name);
	else if (strcmp(*options, "null") == 0)
		snprintf(buf, size, "null");
	else if (strcmp(*options, "nil") == 0)
		snprintf(buf, size, "nil");
	else
		/*if( strcmp(*options,"niloncontent")==0) */
		throw(MAL, "batxml.options", PROGRAM_NYI);

	snprintf(val, size, "<%s>", *name);
	bi = bat_iterator(b);
	BATloop(b, p, q) {
		ptr h = BUNhead(bi, p);
		str t = (str) BUNtail(bi, p);

		if (strNil(t)) {
			bunfastins(bn, h, buf);
		} else {
			if ((int) strlen(t) > size - 2 * len - 6) {
				size += (int) strlen(t);
				val = (char *) GDKrealloc(val, size + strlen(t));
				if (val == NULL) {
					err = MAL_MALLOC_FAIL;
					goto bunins_failed;
				}
			}
			snprintf(val + len + 2, size - len, "%s</%s>", t, *name);
			bunfastins(bn, h, val);
		}
	}
	GDKfree(val);
	GDKfree(buf);
	finalizeResult(ret, bn, b);
	return MAL_SUCCEED;
bunins_failed:
	BBPreleaseref(b->batCacheid);
	BBPunfix(bn->batCacheid);
	if ( buf != NULL)
		GDKfree(buf);
	if ( val != NULL)
		GDKfree(val);
	throw(MAL, "batxml.options", "%s", err);
}

str
BATXMLcomment(int *ret, int *bid)
{
	BAT *b, *bn;
	BUN p, q;
	size_t size = BUFSIZ;
	str buf = GDKmalloc(size);
	BATiter bi;
	str err= OPERATION_FAILED;

	if (buf == NULL)
		throw(MAL, "xml.comment", MAL_MALLOC_FAIL);
	prepareOperand(b, bid, "comment");
	prepareResult(bn, b, TYPE_xml, "comment");
	bi = bat_iterator(b);
	BATloop(b, p, q) {
		ptr h = BUNhead(bi, p);
		str t = (str) BUNtail(bi, p);
		size_t len;

		if (strNil(t)) {
			bunfastins(bn, h, str_nil);
			bn->T->nonil = 0;
			continue;
		}
		if (strstr(t, "--") != NULL) {
			BBPreleaseref(b->batCacheid);
			BBPunfix(bn->batCacheid);
			throw(MAL, "xml.comment", XML_COMMENT_ERROR);
		}
		len = strlen(t);
		if (len + 9 >= size) {
			/* make sure there is enough space */
			size = len + 128;
			/* free/malloc so we don't copy */
			GDKfree(buf);
			buf = GDKmalloc(size);
			if ( buf == NULL){
				err= MAL_MALLOC_FAIL;
				goto bunins_failed;
			}
		}
		snprintf(buf, size, "C<!--%s-->", t);
		bunfastins(bn, h, buf);
	}
	GDKfree(buf);
	finalizeResult(ret, bn, b);
	return MAL_SUCCEED;
  bunins_failed:
	BBPreleaseref(b->batCacheid);
	BBPunfix(bn->batCacheid);
	if ( buf != NULL)
		GDKfree(buf);
	throw(MAL, "xml.comment", "%s", err);
}

str
BATXMLparse(int *ret, str *doccont, int *bid, str *option)
{
	(void) option;
	if (strcmp(*doccont, "content") == 0)
		return BATXMLcontent(ret, bid);
	if (strcmp(*doccont, "document") == 0)
		return BATXMLdocument(ret, bid);
	throw(MAL, "xml.parse", ILLEGAL_ARGUMENT " <document> or <content> expected");
}

str
BATXMLpi(int *ret, str *target, int *bid)
{
	BAT *b, *bn;
	BUN p, q;
	size_t size = BUFSIZ;
	str buf = GDKmalloc(size);
	BATiter bi;
	size_t tgtlen;
	str err = OPERATION_FAILED;

	if ( buf == NULL)
		throw(MAL, "xml.pi", MAL_MALLOC_FAIL);
	if (strNil(*target))
		throw(MAL, "xml.pi", XML_PI_ERROR);

	tgtlen = strlen(*target) + 6;
	prepareOperand(b, bid, "pi");
	prepareResult(bn, b, TYPE_xml, "pi");
	bi = bat_iterator(b);
	BATloop(b, p, q) {
		ptr h = BUNhead(bi, p);
		str t = (str) BUNtail(bi, p);
		size_t len;

		len = tgtlen;
		if (!strNil(t))
			len += strlen(t) * 6 + 1;
		if (len >= size) {
			/* make sure there is enough space */
			size = len + 128;
			/* free/malloc so we don't copy */
			GDKfree(buf);
			buf = GDKmalloc(size);
			if ( buf == NULL){
				err = MAL_MALLOC_FAIL;
				goto bunins_failed;
			}
		}
		if (strNil(t))
			snprintf(buf, size, "C<?%s?>", *target);
		else {
			int n = snprintf(buf, size, "C<?%s ", *target);
			size_t m = XMLquotestring(t, buf + n, size - n);
			strcpy(buf + n + m, "?>");
		}
		bunfastins(bn, h, buf);
	}
	GDKfree(buf);
	finalizeResult(ret, bn, b);
	return MAL_SUCCEED;
  bunins_failed:
	BBPreleaseref(b->batCacheid);
	BBPunfix(bn->batCacheid);
	if ( buf != NULL )
		GDKfree(buf);
	throw(MAL, "xml.pi", "%s", err);
}

str
BATXMLroot(int *ret, int *bid, str *version, str *standalone)
{
	BAT *b, *bn;
	BUN p, q;
	size_t size = BUFSIZ;
	str buf = GDKmalloc(size);
	BATiter bi;
	size_t hdrlen;
	str err = OPERATION_FAILED;

	if ( buf == NULL)
		throw(MAL, "xml.root", MAL_MALLOC_FAIL);
	hdrlen = 8;
	if (!strNil(*version) && **version) {
		if (strcmp(*version, "1.0") != 0 && strcmp(*version, "1.1") != 0)
			throw(MAL, "xml.root", XML_VERSION_ERROR);
		hdrlen += 11 + strlen(*version);  /* strlen(" version=\"\"") */
	}
	if (!strNil(*standalone) && **standalone) {
		if (strcmp(*standalone, "yes") != 0 && strcmp(*standalone, "no") != 0)
			throw(MAL, "xml.root", XML_STANDALONE_ERROR "illegal XML standalone value");
		hdrlen += 14 + strlen(*standalone);  /* strlen(" standalone=\"\"") */
	}
	prepareOperand(b, bid, "pi");
	prepareResult(bn, b, TYPE_xml, "pi");
	bi = bat_iterator(b);
	BATloop(b, p, q) {
		ptr h = BUNhead(bi, p);
		str t = (str) BUNtail(bi, p);
		size_t len, i;
		bit isdoc;

		len = hdrlen;
		if (!strNil(t))
			len += strlen(t);
		if (len >= size) {
			/* make sure there is enough space */
			size = len + 128;
			/* free/malloc so we don't copy */
			GDKfree(buf);
			buf = GDKmalloc(size);
			if ( buf == NULL){
				err = MAL_MALLOC_FAIL;
				goto bunins_failed;
			}
		}
		if (strNil(t)) {
			strcpy(buf, str_nil);
			bn->T->nonil = 0;
		} else {
			strcpy(buf, "D<?xml");
			i = strlen(buf);
			if (!strNil(*version) && **version)
				i += snprintf(buf + i, len - i, " version=\"%s\"", *version);
			if (!strNil(*standalone) && **standalone)
				i += snprintf(buf + i, len - i, " standalone=\"%s\"", *standalone);
			snprintf(buf + i, len - i, "?>%s", t + 1);
			buf++;
			XMLisdocument(&isdoc, &buf); /* check well-formedness */
			buf--;
			if (!isdoc) {
				err = XML_NOT_WELL_FORMED;
				goto bunins_failed;
			}
		}
		bunfastins(bn, h, buf);
	}
	GDKfree(buf);
	finalizeResult(ret, bn, b);
	return MAL_SUCCEED;
  bunins_failed:
	BBPreleaseref(b->batCacheid);
	BBPunfix(bn->batCacheid);
	if ( buf != NULL )
		GDKfree(buf);
	throw(MAL, "xml.root", "%s", err);
}

str
BATXMLattribute(int *ret, str *name, int *bid)
{
	BAT *b, *bn;
	BUN p, q;
	size_t size = BUFSIZ;
	str buf = GDKmalloc(size);
	BATiter bi;
	size_t attrlen;
	str err = OPERATION_FAILED;

	if ( buf == NULL)
		throw(MAL, "xml.attribute", MAL_MALLOC_FAIL);
	if (strNil(*name))
		throw(MAL, "xml.attribute", XML_ATTRIBUTE_ERROR);
	if (xmlValidateName((xmlChar *) *name, 0) != 0)
		throw(MAL, "xml.attribute", XML_ATTRIBUTE_INVALID);
	attrlen = strlen(*name) + 5;
	prepareOperand(b, bid, "attribute");
	prepareResult(bn, b, TYPE_xml, "attribute");
	bi = bat_iterator(b);
	BATloop(b, p, q) {
		ptr h = BUNhead(bi, p);
		str t = (str) BUNtail(bi, p);
		size_t len;

		len = attrlen;
		if (!strNil(t))
			len += strlen(t) * 6 + 1;
		if (len >= size) {
			/* make sure there is enough space */
			size = len + 128;
			/* free/malloc so we don't copy */
			GDKfree(buf);
			buf = GDKmalloc(size);
			if ( buf == NULL){
				err = MAL_MALLOC_FAIL;
				goto bunins_failed;
			}
		}
		if (strNil(t)) {
			strcpy(buf, str_nil);
			bn->T->nonil = 0;
		} else {
			int n = snprintf(buf, size, "A%s = \"", *name);
			size_t m = XMLquotestring(t, buf + n, size - n);
			strcpy(buf + n + m, "\"");
		}
		bunfastins(bn, h, buf);
	}
	GDKfree(buf);
	finalizeResult(ret, bn, b);
	return MAL_SUCCEED;
  bunins_failed:
	BBPreleaseref(b->batCacheid);
	BBPunfix(bn->batCacheid);
	if ( buf != NULL )
		GDKfree(buf);
	throw(MAL, "xml.attribute", "%s", err);
}

str
BATXMLelement(int *ret, str *name, xml *nspace, xml *attr, int *bid)
{
	BAT *b, *bn;
	BUN p, q;
	size_t size = BUFSIZ;
	str buf = GDKmalloc(size);
	BATiter bi;
	size_t elemlen, namelen;
	str err = OPERATION_FAILED;

	if ( buf == NULL)
		throw(MAL, "xml.attribute", MAL_MALLOC_FAIL);
	if (strNil(*name))
		throw(MAL, "xml.element", XML_NO_ELEMENT);
	if (xmlValidateName((xmlChar *) *name, 0) != 0)
		throw(MAL, "xml.element", XML_ATTRIBUTE_INVALID);
	if (nspace && !strNil(*nspace) && **nspace)
		throw(MAL, "xml.element", XML_NO_NAMESPACE);
	namelen = strlen(*name);
	elemlen = namelen + 5;
	if (nspace && !strNil(*nspace)) {
		if (**nspace != 'A')
			throw(MAL, "xml.element", XML_ILLEGAL_NAMESPACE);
		elemlen += strlen(*nspace);	/* " " + nspace (nspace contains initial 'A' which is replaced by space) */
	}
	if (attr && !strNil(*attr)) {
		if (**attr != 'A')
			throw(MAL, "xml.element", XML_ILLEGAL_ATTRIBUTE);
		elemlen += strlen(*attr);	/* " " + attr (attr contains initial 'A' which is replaced by space) */
	}
	prepareOperand(b, bid, "element");
	prepareResult(bn, b, TYPE_xml, "element");
	bi = bat_iterator(b);
	BATloop(b, p, q) {
		ptr h = BUNhead(bi, p);
		str t = (str) BUNtail(bi, p);
		size_t len;

		len = elemlen;
		if (!strNil(t)) {
			if (*t != 'C') {
				BBPreleaseref(b->batCacheid);
				BBPunfix(bn->batCacheid);
				GDKfree(buf);
				throw(MAL, "xml.element", XML_ILLEGAL_CONTENT);
			}
			len += strlen(t + 1) + namelen + 2;  /* extra "<", ">", and name ("/" already counted) */
		}
		if (len >= size) {
			/* make sure there is enough space */
			size = len + 128;
			/* free/malloc so we don't copy */
			GDKfree(buf);
			buf = GDKmalloc(size);
			if ( buf == NULL){
				err = MAL_MALLOC_FAIL;
				goto bunins_failed;
			}
		}
		if (strNil(t)) {
			strcpy(buf, str_nil);
			bn->T->nonil = 0;
		} else {
			int i = snprintf(buf, size, "C<%s", *name);
			if (nspace && !strNil(*nspace))
				i += snprintf(buf + i, size - i, " %s", *nspace + 1);
			if (attr && !strNil(*attr))
				i += snprintf(buf + i, size - i, " %s", *attr + 1);
			if (!strNil(t))
				i += snprintf(buf + i, size - i, ">%s</%s>", t + 1, *name);
			else
				i += snprintf(buf + i, size - i, "/>");
		}
		bunfastins(bn, h, buf);
	}
	GDKfree(buf);
	finalizeResult(ret, bn, b);
	return MAL_SUCCEED;
  bunins_failed:
	BBPreleaseref(b->batCacheid);
	BBPunfix(bn->batCacheid);
	if ( buf != NULL )
		GDKfree(buf);
	throw(MAL, "xml.element", "%s", err);
}

str
BATXMLelementSmall(int *ret, str *name, int *bid)
{
	return BATXMLelement(ret, name, NULL, NULL, bid);
}

str
BATXMLforest(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int *ret = (int *) getArgReference(stk, pci, 0);
	BAT *bn;
	BATiter *bi;
	BUN *p, *q;
	str buf = GDKmalloc(BUFSIZ);
	int i;
	size_t offset, len, size = BUFSIZ;
	str err = OPERATION_FAILED;

	(void) mb;
	(void) cntxt;
	if ( buf == NULL)
		throw(MAL, "xml.forest", MAL_MALLOC_FAIL);
	
	bi = alloca(sizeof(BATiter) * pci->argc);
	p = alloca(sizeof(BUN) * pci->argc);
	q = alloca(sizeof(BUN) * pci->argc);

	/* collect the admin for the xml elements */
	for (i = pci->retc; i < pci->argc; i++) {
		if ((bi[i].b = BATdescriptor(*(int *) getArgReference(stk, pci, i))) == NULL)
			break;
		p[i] = BUNfirst(bi[i].b);
		q[i] = BUNlast(bi[i].b);
	}
	/* check for errors */
	if (i != pci->argc) {
		for (i--; i >= pci->retc; i--)
			if (bi[i].b)
				BBPunfix(bi[i].b->batCacheid);
		throw(MAL, "xml.forest", INTERNAL_BAT_ACCESS);
	}

	prepareResult(bn, bi[pci->retc].b, TYPE_xml, "forest");

	while (p[pci->retc] < q[pci->retc]) {
		str t;
		oid *h;

		/* fetch the elements */
		h = (oid *) BUNhead(bi[pci->retc], p[pci->retc]);
		offset = 0;
		strcpy(buf, str_nil);
		for (i = pci->retc; i < pci->argc; i++) {
			int n;

			t = (str) BUNtail(bi[i], p[i]);
			if (strNil(t))
				continue;

			if ((len = strlen(t)) >= size - offset) {
				size += len + 128;
				buf = GDKrealloc(buf, size);
				if ( buf == NULL) {
					err = MAL_MALLOC_FAIL;
					goto bunins_failed;
				}
			}
			if (offset == 0)
				n = snprintf(buf, size, "%s", t);
			else if (buf[0] != *t) {
				err = "incompatible values in forest";
				goto bunins_failed;
			} else if (buf[0] == 'A')
				n = snprintf(buf + offset, size - offset, " %s", t + 1);
			else if (buf[0] == 'C')
				n = snprintf(buf + offset, size - offset, "%s", t + 1);
			else {
				err = "can only combine attributes and element content";
				goto bunins_failed;
			}
			offset += n;
		}
		bunfastins(bn, h, buf);
		if (offset == 0)
			bn->T->nonil = 0;

		for (i = pci->retc; i < pci->argc; i++)
			if (bi[i].b)
				p[i]++;
	}
	GDKfree(buf);
	finalizeResult(ret, bn, bi[pci->retc].b);
	return MAL_SUCCEED;
  bunins_failed:
	for (i = pci->retc; i < pci->argc; i++)
		if (bi[i].b)
			BBPreleaseref(bi[i].b->batCacheid);
	BBPunfix(bn->batCacheid);
	if ( buf != NULL )
		GDKfree(buf);
	throw(MAL, "xml.forest", "%s", err);
}

str
BATXMLconcat(int *ret, int *bid, int *rid)
{
	BAT *b, *r = 0, *bn;
	BUN p, q, rp = 0;
	size_t len, size = BUFSIZ;
	str buf = GDKmalloc(size);
	BATiter bi, ri;
	str err = OPERATION_FAILED;

	if ( buf == NULL)
		throw(MAL, "xml.concat", MAL_MALLOC_FAIL);

	if (*rid && (r = BATdescriptor(*rid))) {
		rp = BUNfirst(r);
	}
	if (r == 0)
		throw(MAL, "xml.concat", INTERNAL_BAT_ACCESS);

	/* collect the admin for the xml elements */
	if ((b = BATdescriptor(*bid))) {
		p = BUNfirst(b);
		q = BUNlast(b);
	}
	if (b == NULL) {
		if (r)
			BBPunfix(r->batCacheid);
		throw(MAL, "xml.concat", INTERNAL_BAT_ACCESS);
	}

	prepareResult(bn, b, TYPE_xml, "concat");

	bi = bat_iterator(b);
	ri = bat_iterator(r);
	while (p < q) {
		str t = (str) BUNtail(bi, p);
		oid *h = (oid *) BUNhead(bi, p);
		str v = (str) BUNtail(ri, rp);

		len = strlen(t) + strlen(v) + 1;

		if (len >= size) {
			GDKfree(buf);
			size = len + 128;
			buf = GDKmalloc(size);
			if ( buf == NULL){
				err= MAL_MALLOC_FAIL;
				goto bunins_failed;
			}
		}
		if (strNil(t)) {
			if (strNil(v)) {
				strcpy(buf, str_nil);
				bn->T->nonil = 0;
			} else
				strcpy(buf, v);
		} else {
			if (strNil(v))
			   strcpy(buf, t);
			else if (*t != *v) {
				err = "arguments not compatible";
				goto bunins_failed;
			} else if (*t == 'A')
				snprintf(buf, size, "A%s %s", t + 1, v + 1);
			else if (*t == 'C')
				snprintf(buf, size, "C%s%s", t + 1, v + 1);
			else {
				err = "can only concatenate attributes and element content";
				goto bunins_failed;
			}
		}
		bunfastins(bn, h, buf);
		rp++;
		p++;
	}
	GDKfree(buf);
	finalizeResult(ret, bn, b);
	return MAL_SUCCEED;
  bunins_failed:
	BBPreleaseref(r->batCacheid);
	BBPreleaseref(b->batCacheid);
	BBPunfix(bn->batCacheid);
	if ( buf != NULL)
		GDKfree(buf);
	throw(MAL, "xml.concat", "%s", err);
}

str
BATXMLagg3(int *ret, int *bid, int *grp, int *ext)
{
	BAT *j, *r, *g, *b, *bn, *e;
	BUN p, q;
	oid gid, o;
	int first;
	str t;
	size_t len, size = BUFSIZ, offset;
	str buf = GDKmalloc(size);
	BATiter ri;
	str err = "bunins failed";	/* default error message */

	if ( buf == NULL)
		throw(MAL,"xml.agg", MAL_MALLOC_FAIL);
	@:getBATdescriptor(ext,e,"xml.agg")@
	@:getBATdescriptor(grp,g,"xml.agg",BBPunfix(e->batCacheid))@
	@:getBATdescriptor(bid,b,"xml.agg",BBPunfix(e->batCacheid);BBPunfix(g->batCacheid))@

	bn = BATnew(TYPE_oid, b->ttype, BATcount(e));
	if (bn == NULL) {
		BBPunfix(b->batCacheid);
		BBPunfix(g->batCacheid);
		BBPunfix(e->batCacheid);
		throw(MAL, "xml.agg", INTERNAL_OBJ_CREATE);
	}
	bn->T->nonil = 1;

	/* this will not work as it will corrupt the order of the column, ie
	   the order in which the data will be generated */
	j = BATjoin(BATmirror(g), b, BUN_NONE);
	BBPreleaseref(b->batCacheid);
	BBPreleaseref(g->batCacheid);
	BBPreleaseref(e->batCacheid);
	r = BATsort(j);
	BBPunfix(j->batCacheid);

	/* now we can perform a simple scan and emit the group */

	strcpy(buf, str_nil);
	offset = 0;
	first = 1;
	gid = 0;
	ri = bat_iterator(r);
	BATaccessBegin(r,USE_HEAD|USE_TAIL,MMAP_SEQUENTIAL);
	BATloop(r, p, q) {
		int n;

		o = *(oid *) BUNhead(ri, p);
		t = (str) BUNtail(ri, p);

		if (gid != o && !first) {
			/* flush */
			bunfastins(bn, &gid, buf);
			if (offset == 0)
				bn->T->nonil = 0;
			strcpy(buf, str_nil);
			offset = 0;
		}
		gid = o;
		first = 0;
		if (strNil(t))
			continue;
		len = strlen(t) + 1;
		if (len >= size - offset) {
			size += len + 128;
			buf = GDKrealloc(buf, size);
			if ( buf == NULL){
				err= MAL_MALLOC_FAIL;
				goto bunins_failed;
			}
		}
		if (offset == 0)
			n = snprintf(buf, size, "%s", t);
		else if (buf[0] != *t) {
			err = "incompatible values in group";
			goto bunins_failed;
		} else if (buf[0] == 'A')
			n = snprintf(buf + offset, size - offset, " %s", t + 1);
		else if (buf[0] == 'C')
			n = snprintf(buf + offset, size - offset, "%s", t + 1);
		else {
			err = "can only group attributes and element content";
			goto bunins_failed;
		}
		offset += n;
	}
	BATaccessEnd(r,USE_HEAD|USE_TAIL,MMAP_SEQUENTIAL);
	/* end the leftover element */
	if (!first) {
		bunfastins(bn, &gid, buf);
		if (offset == 0)
			bn->T->nonil = 0;
	}

	BBPunfix(r->batCacheid);
	GDKfree(buf);
	bn->tsorted = 0;
	bn->T->nonil = 0;
	BBPkeepref(*ret = bn->batCacheid);
	return MAL_SUCCEED;
  bunins_failed:
	BATaccessEnd(r,USE_HEAD|USE_TAIL,MMAP_SEQUENTIAL);
	BBPunfix(r->batCacheid);
	BBPunfix(bn->batCacheid);
	if ( buf != NULL)
		GDKfree(buf);
	throw(MAL, "xml.agg", "%s", err);
}

str
BATXMLagg(int *ret, int *bid, int *grp)
{
	BAT *j, *r, *g, *b, *bn;
	BUN p, q;
	oid gid = 0, o = 0;
	int first = 1;
	str t;
	size_t len, size = BUFSIZ, offset;
	str buf = GDKmalloc(size);
	BATiter ri;
	str err = "bunins failed";	/* default error message */

	if ( buf == NULL)
		throw(MAL,"xml.agg",MAL_MALLOC_FAIL);
	@:getBATdescriptor(grp,g,"xml.agg")@
	@:getBATdescriptor(bid,b,"xml.agg",BBPunfix(g->batCacheid))@

	bn = BATnew(g->htype, b->ttype, BATcount(g));
	if (bn == NULL) {
		BBPunfix(b->batCacheid);
		BBPunfix(g->batCacheid);
		throw(MAL, "xml.agg", INTERNAL_OBJ_CREATE);
	}
	bn->T->nonil = 1;

	j = BATjoin(BATmirror(g), b, BUN_NONE);
	BBPreleaseref(b->batCacheid);
	BBPreleaseref(g->batCacheid);
	r = BATsort(j);
	BBPunfix(j->batCacheid);

	/* now we can perform a simple scan and emit the group */

	strcpy(buf, str_nil);
	offset = 0;
	first = 1;
	gid = 0;
	ri = bat_iterator(r);
	BATaccessBegin(r,USE_HEAD|USE_TAIL,MMAP_SEQUENTIAL);
	BATloop(r, p, q) {
		int n;

		o = *(oid *) BUNhead(ri, p);
		t = (str) BUNtail(ri, p);

		if (gid != o && !first) {
			/* flush */
			bunfastins(bn, &gid, buf);
			if (offset == 0)
				bn->T->nonil = 0;
			strcpy(buf, str_nil);
			offset = 0;
		}
		gid = o;
		first = 0;
		if (strNil(t))
			continue;
		len = strlen(t) + 1;
		if (len >= size - offset) {
			size += len + 128;
			buf = GDKrealloc(buf, size);
			if ( buf == NULL ){
				err = MAL_MALLOC_FAIL;
				goto bunins_failed;
			}
		}
		if (offset == 0)
			n = snprintf(buf, size, "%s", t);
		else if (buf[0] != *t) {
			err = "incompatible values in group";
			goto bunins_failed;
		} else if (buf[0] == 'A')
			n = snprintf(buf + offset, size - offset, " %s", t + 1);
		else if (buf[0] == 'C')
			n = snprintf(buf + offset, size - offset, "%s", t + 1);
		else {
			err = "can only group attributes and element content";
			goto bunins_failed;
		}
		offset += n;
	}
	BATaccessEnd(r,USE_HEAD|USE_TAIL,MMAP_SEQUENTIAL);
	/* end the leftover element */
	if (!first) {
		bunfastins(bn, &gid, buf);
		if (offset == 0)
			bn->T->nonil = 0;
	}

	BBPunfix(r->batCacheid);
	GDKfree(buf);
	bn->tsorted = 0;
	bn->T->nonil = 0;
	BBPkeepref(*ret = bn->batCacheid);
	return MAL_SUCCEED;
  bunins_failed:
	BATaccessEnd(r,USE_HEAD|USE_TAIL,MMAP_SEQUENTIAL);
	BBPunfix(bn->batCacheid);
	BBPunfix(r->batCacheid);
	if ( buf != NULL)
		GDKfree(buf);
	throw(MAL, "xml.agg", "%s", err);
}

str
BATXMLgroup(xml *ret, int *bid)
{
	BAT *b;
	BUN p, q;
	str t;
	size_t len, size = BUFSIZ, offset;
	str buf = GDKmalloc(size);
	BATiter bi;
	str err = NULL;

	if ( buf == NULL)
		throw( MAL, "xml.group",MAL_MALLOC_FAIL);
	@:getBATdescriptor(bid,b,"xml.agg")@

	strcpy(buf, str_nil);
	offset = 0;
	bi = bat_iterator(b);
	BATaccessBegin(b,USE_HEAD|USE_TAIL,MMAP_SEQUENTIAL);
	BATloop(b, p, q) {
		int n;

		t = (str) BUNtail(bi, p);

		if (strNil(t))
			continue;
		len = strlen(t) + 1;
		if (len >= size - offset) {
			size += len + 128;
			buf = GDKrealloc(buf, size);
			if ( buf == NULL){
				err= MAL_MALLOC_FAIL;
				goto failed;
			}
		}
		if (offset == 0)
			n = snprintf(buf, size, "%s", t);
		else if (buf[0] != *t) {
			err = "incompatible values in group";
			goto failed;
		} else if (buf[0] == 'A')
			n = snprintf(buf + offset, size - offset, " %s", t + 1);
		else if (buf[0] == 'C')
			n = snprintf(buf + offset, size - offset, "%s", t + 1);
		else {
			err = "can only group attributes and element content";
			goto failed;
		}
		offset += n;
	}
	BATaccessEnd(b,USE_HEAD|USE_TAIL,MMAP_SEQUENTIAL);
	BBPreleaseref(b->batCacheid);
	*ret = buf;
	return MAL_SUCCEED;
  failed:
	BATaccessEnd(b,USE_HEAD|USE_TAIL,MMAP_SEQUENTIAL);
	BBPreleaseref(b->batCacheid);
	if ( buf != NULL)
		GDKfree(buf);
	throw(MAL, "xml.agg", "%s", err);
}

str
BATXMLxquery(int *ret, int *bid, str *expr)
{
	(void) ret;
	(void) bid;
	(void) expr;
	/* use external library to solve this */
	throw(MAL, "xml.xquery", PROGRAM_NYI);
}


@sql
CREATE AGGREGATE "xmlagg"( x xml ) RETURNS xml external name xml.agg;
