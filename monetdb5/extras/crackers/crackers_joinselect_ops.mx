@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.monetdb.org/Legal/MonetDBLicense

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2011 MonetDB B.V.
All Rights Reserved.
@

@f crackers_joinselect_ops

@c
/*
 * @a Martin Kersten, Stratos Idreos, Stefan Manegold
 * @d March 2006 - July 2007
 * @* JoinSelect Operators
 *
 *
 * @+ Interface
 *
 *
 * @- Type expansion
 */
@= TypeSwitch
@:@1(chr,simple,)@
@:@1(sht,simple,)@
@:@1(int,simple,)@
@:@1(lng,simple,)@
@:@1(flt,simple,)@
@:@1(dbl,simple,)@
@:@1(date,atom,TYPE_)@
@
@h
/*
 * @- Header file
 */
#ifndef _CRACKERS_JOINSELECT_H_
#define _CRACKERS_JOINSELECT_H_

/* Exported signatures */
@:TypeSwitch(JoinSelectFunctions_decl)@

#endif /* _CRACKERS_JOINSELECT_H */
/*
 * @- Exported signatures
 */
@= JoinSelectFunctions_decl
crackers_export str CRKjoinSelectDefault_@1(int *res, int *right, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh, int *left);
crackers_export str CRKjoinSelectBounds_@1(int *res, int *right, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh, int *left, bit *inPlace, bit *isForeignKey);
crackers_export str CRKjointhetauselect_@1(int *res, int *right, @1 *val, str *OP, int *left, bit *inPlace, bit *isForeignKey);
@
@c
/*
 * @+ Implementation
 *
 *
 * @- C file
 */
#include "monetdb_config.h"
#include "crackers.h"

/* Local support functions and macros */
@:TypeSwitch(JoinSelectOperations)@

/* Exported functions */
@:TypeSwitch(JoinSelectFunctions_impl)@
/*
 * @- Exported functions
 */
@= JoinSelectFunctions_impl
str
CRKjoinSelectDefault_@1(int *res, int *right, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh, int *left){
	bit inPlace = FALSE;
	bit isForeignKey = FALSE;
	return CRKjoinSelectBounds_@1( res, right, low, hgh, inclusiveLow, inclusiveHgh, left, &inPlace, &isForeignKey);
}

str
CRKjoinSelectBounds_@1(int *res, int *right, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh, int *left, bit *inPlace, bit *isForeignKey){
	BAT *l, *r;

	if ((l = BATdescriptor(*left)) == NULL) 
        	throw(MAL, "crackers.crackJoinSelect", "Cannot access descriptor");

	if ((r = BATdescriptor(*right)) == NULL) {
		BBPunfix(*left);
        	throw(MAL, "crackers.crackJoinSelect", "Cannot access descriptor");
        }

	if (!BAThdense(r)) {
		BBPunfix(*left);
		BBPunfix(*right);
		throw(MAL, "crackers.crackJoinSelect", "right BAT must have a dense head");
	}

	if (BATcount(l) == 0 || BATcount(r) == 0){
		BAT *d = BATnew(TYPE_oid, TYPE_void, 0);
		BATsetcount(d, 0);
		d->hsorted = GDK_SORTED;
		d->hdense = TRUE;
		BATseqbase(d, (oid)0);
		BATkey(d, TRUE);
		d->tsorted = FALSE;
		d->tdense = FALSE;
		BATseqbase(BATmirror(d), oid_nil);
		BATkey(BATmirror(d), FALSE);
		d->batRestricted= BAT_READ;
		BBPkeepref(d->batCacheid);
		*res = d->batCacheid;
		BBPunfix(*left);
		BBPunfix(*right);
		return MAL_SUCCEED;
	}	

        if (@2_EQ(low,ATOMnilptr(TYPE_@1),@3@1)){
		if (*inclusiveHgh==TRUE)
                	return JoinSelectSingle_RE_@1(res, l, r, hgh, *inPlace, *isForeignKey);
		else
                	return JoinSelectSingle_RO_@1(res, l, r, hgh, *inPlace, *isForeignKey);
	}
        else if (@2_EQ(hgh,ATOMnilptr(TYPE_@1),@3@1))
		if (*inclusiveLow==TRUE)
                	return JoinSelectSingle_LE_@1(res, l, r, low, *inPlace, *isForeignKey);
		else
                	return JoinSelectSingle_LO_@1(res, l, r, low, *inPlace, *isForeignKey);
        else{
		if ((*inclusiveLow==TRUE) && (*inclusiveHgh==TRUE))
                	return JoinSelectRange_LE_RE_@1(res, l, r, low, hgh, *inPlace, *isForeignKey);
		else
		if ((*inclusiveLow==TRUE) && (*inclusiveHgh==FALSE))
                	return JoinSelectRange_LE_RO_@1(res, l, r, low, hgh, *inPlace, *isForeignKey);
		else
		if ((*inclusiveLow==FALSE) && (*inclusiveHgh==FALSE))
                	return JoinSelectRange_LO_RO_@1(res, l, r, low, hgh, *inPlace, *isForeignKey);
		else
		if ((*inclusiveLow==TRUE) && (*inclusiveHgh==TRUE))
                	return JoinSelectRange_LE_RE_@1(res, l, r, low, hgh, *inPlace, *isForeignKey);
	}
        throw(MAL, "crackers.crackJoinSelect", "case not handled");
}

str
CRKjointhetauselect_@1(int *vid, int *bid, @1 *val, str *OP, int *left, bit *inplace, bit *foreignKey){
	ptr nilptr = ATOMnilptr(TYPE_@1); 
	char *op = *OP; 
	bit lin = TRUE, rin = TRUE;
	@1 *low = nilptr, *high = nilptr;

	if (op[0] == '=') {
		low = val; 
	} else if (op[0] == '<') {
		high = val;
		rin = (op[1] == '=');
	} else if (op[0] == '>') {
		low = val;
		lin = (op[1] == '=');
	} else {
		throw(MAL, "crackers.thetajoinuselect", "unknown operator");
	}

	return CRKjoinSelectBounds_@1(vid, bid, low, high, &lin, &rin, left, inplace, foreignKey);
}
@
 * @- Local support functions and macros
@= JoinSelectOperations
@(
@:JoinSelectR(@1,LO,RE,GT,LE,@2,@3)@
@)
@:JoinSelectR(@1,LE,RE,GE,LE,@2,@3)@
@:JoinSelectR(@1,LO,RO,GT,LT,@2,@3)@
@:JoinSelectR(@1,LE,RO,GE,LT,@2,@3)@
@:JoinSelectS(@1,RO,LT,@2,@3)@
@:JoinSelectS(@1,RE,LE,@2,@3)@
@:JoinSelectS(@1,LO,GT,@2,@3)@
@:JoinSelectS(@1,LE,GE,@2,@3)@
@
@= JoinSelectR
static str
JoinSelectRange_@2_@3_@1(int *res, BAT *l, BAT *r, @1 *low, @1 *hgh, bit inPlace, bit isForeignKey){
	@:JoinSelectBody(@6_@4(rt,low,@7@1) && @6_@5(rt,hgh,@7@1),@1)@
}
@
@= JoinSelectS
static str
JoinSelectSingle_@2_@1(int *res, BAT *l, BAT *r, @1 *mid, bit inPlace, bit isForeignKey){
	@:JoinSelectBody(@4_@3(rt,mid,@5@1),@1)@
}
@
@= JoinSelectBody
/* Joins a left=[oid,void] bat with a right=[void, any_type] bat on head-OIDs.
From the right bat, only BUNs that pass the range-restriction on the tail qualify.
The result is a [oid,void] bat. */
	BAT *d;
	@2 *rt, *rbase;
	oid *dt;
	oid rmin, rmax;
	bit d_hdense = FALSE;

	rmin = 0; /* *(oid*)Hloc(r, BUNfirst(r)); FIX */
	rmax = rmin + (BATcount(r) - 1);
	rbase = (@2*)Tloc(r, BUNfirst(r)) - rmin;

	if (!inPlace || /*l->batParentid != 0 ||*/ l->htype == TYPE_void) {
		d = BATnew(TYPE_oid, TYPE_void, MIN(BATcount(l), BATcount(r)));
	} else {
		d = l;
	}

	dt = (oid*)Hloc(d, BUNfirst(d));

	/* For each BUN of the left bat check if the corresponding BUN in the right bat satisfies the restriction.
	   If yes the respective oid is added to the result */
	if (BAThdense(l)) {
		/*oid lv = MAX(rmin, *(oid*)Hloc(l, BUNfirst(l)));*/
		oid lv = MAX(rmin, l->H->seq);
		oid llast = MIN(rmax, lv + (BATcount(l) - 1));
		oid l0 = lv;
		oid *d0 = dt;
		rt = rbase + lv;
		while (lv <= llast) {
			if (@1) {
				*dt = lv;
				dt ++;	
			}		
			lv++;
			rt ++;
		}
		d_hdense = ((size_t)(dt - d0) == (lv - l0));
	} else {
		oid *llast = (oid*)Hloc(l, BUNlast(l));
		oid *lt = (oid*)Hloc(l, BUNfirst(l));
		oid lv = oid_nil;

		if (isForeignKey) {
			while (lt < llast) {
				lv = *lt;
				rt = rbase + lv;
				if (@1) {
					*dt = lv;
					dt ++;	
				}	
				lt ++;
			}
		} else if (BAThordered(l)&1) {
			while(lt < llast && (lv = *lt) < rmin) {
				lt ++;
			}
			while(lt < llast && (lv = *lt) <= rmax) {
				rt = rbase + lv;
				if (@1) {
					*dt = lv;
					dt ++;	
				}	
				lt ++;
			}
		} else {
			while(lt < llast){
			    lv = *lt;
			    if (lv >= rmin && lv <= rmax) {
				rt = rbase + lv;
				if (@1){
					*dt = lv;
					dt ++;	
				}	
			    }
			    lt ++;
			}
		}
	}

    	BATsetcount(d, (BUN) (dt - (oid*)Hloc(d,BUNfirst(d))));
	d->hsorted = (BATcount(d)<2 || BAThordered(l)&1) ? GDK_SORTED : 0;
	d->hdense = BATcount(d)<2 || d_hdense;
	if (d->hdense) {
		if (BATcount(d)==0) {
			/* does not really matter */
			BATseqbase(d, (oid)0);
		} else {
			BATseqbase(d, *(oid*)Hloc(d,BUNfirst(d)));
		}
	} else {
		BATseqbase(d, oid_nil);
	}
	BATkey(d, BATcount(d)<2 || l->hkey);
	d->tsorted = FALSE;
	d->tdense = FALSE;
	BATseqbase(BATmirror(d), oid_nil);
	BATkey(BATmirror(d), FALSE);
	d->batRestricted= BAT_READ;
	BBPkeepref(d->batCacheid);
	*res=d->batCacheid;

	if (d != l) {
		BBPunfix(l->batCacheid);
	}
	BBPunfix(r->batCacheid);
	
	return MAL_SUCCEED;
@
