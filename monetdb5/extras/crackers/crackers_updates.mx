@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2011 MonetDB B.V.
All Rights Reserved.
@

@f crackers_updates
@a Martin Kersten, Stratos Idreos, Stefan Manegold
@d March 2006 - July 2007
@* Cracker Updates


@+ Interface


@- Type expansion

@= TypeSwitch
@:@1(chr,simple,,oid)@
@:@1(sht,simple,,oid)@
@:@1(int,simple,,oid)@
@:@1(lng,simple,,oid)@
@:@1(flt,simple,,oid)@
@:@1(dbl,simple,,oid)@
@:@1(date,atom,TYPE_,oid)@

@:@1(int,simple,,lng)@
@:@1(int,simple,,int)@
@:@1(int,simple,,str)@
@:@1(int,simple,,date)@

@:@1(dbl,simple,,int)@
@:@1(dbl,simple,,str)@
@:@1(dbl,simple,,dbl)@
@:@1(dbl,simple,,date)@

@:@1(date,atom,TYPE_,int)@
@:@1(date,atom,TYPE_,str)@
@:@1(date,atom,TYPE_,lng)@
@:@1(date,atom,TYPE_,dbl)@
@:@1(date,atom,TYPE_,date)@
@


@- Header file
 
@h
#ifndef _CRACKERS_UPDATES_H_
#define _CRACKERS_UPDATES_H_

/* Signatures shared within the crackers module/library */
@:UpdatesSharedFunctions_decl_0@
@:TypeSwitch(UpdatesSharedFunctions_decl_1)@

/* Exported signatures */
@:UpdatesFunctions_decl_0@
@:TypeSwitch(UpdatesFunctions_decl_1)@

#endif /* _CRACKERS_UPDATES_H */
@


@- Exported signatures
 
@= UpdatesFunctions_decl_0
crackers_export str CRKsizeCrackerInsertions(int *k, int *bid);
crackers_export str CRKsizeCrackerDeletions(int *k, int *bid);
crackers_export str CRKprintCrackerInsertions(int *k, int *bid);
crackers_export str CRKprintCrackerDeletions(int *k, int *bid);
crackers_export str CRKmergeInsertions_Forget(int *k, int *bid, int *new);
crackers_export str CRKextendCrackerBAT(int *k, int *bid, lng *positions);
crackers_export str CRKmergeInsertionsB_OnNeed(int *k, int *bid, int *new);
crackers_export str CRKmergeInsertionsB_OnNeedGradually(int *k, int *bid, int *new);
crackers_export str CRKmergeInsertionsB_OnNeedGraduallyRipple(int *k, int *bid, int *new);
crackers_export str CRKmergeDeletions_OnNeed(int *k, int *bid, int *new);
crackers_export str CRKmergeDeletions_OnNeedGradually(int *k, int *bid, int *new);
crackers_export str CRKmergeDeletions_OnNeedGraduallyRipple(int *k, int *bid, int *new);
@

@= UpdatesFunctions_decl_1
crackers_export str CRKmergeInsertions_PartiallyForget_@1_@4(int *k, int *bid, int *new);
crackers_export str CRKmergeInsertionsB_Force_@1_@4(int *k, int *bid, int *new);
@


@- Signatures shared within the crackers module/library

@= UpdatesSharedFunctions_decl_0
str appendInsertions(int *new, int position);
@

@= UpdatesSharedFunctions_decl_1
/* mergeInsertionOperations */
str mergeInsertionsB_@1_@4(int *bid, int *new, oid startPosition, oid endPosition);
str mergeInsertionsBGradually_@1_@4(int *bid, int *new, oid startPosition, oid endPosition);
str mergeInsertionsBRipple_@1_@4(BAT *b, BAT *u, oid startPosition, oid endPosition, @1 *hgh, bit inclusive, int position);
str mergeDeletions_@1_@4(int *bid, int *del, oid startPosition, oid endPosition);
str mergeDeletionsGradually_@1_@4(int *bid, int *del, oid startPosition, oid endPosition);
str mergeDeletionsGraduallyRipple_@1_@4(int *bid, int *del, oid startPosition, oid endPosition, @1 *lowV, bit inclusiveL, @1 *hghV, bit inclusiveH);
@


@{
@+ Implementation

 
@- C file

@c
#include "monetdb_config.h"
#include "crackers.h"

/* Local support functions and macros */
@:UpdatesLocal@

/* Functions shared within the crackers module/library */
@:UpdatesSharedFunctions_impl_0@
@:TypeSwitch(UpdatesSharedFunctions_impl_1)@

/* Exported functions */
@:UpdatesFunctions_impl_0@
@:updatesOnNeed(,0)@
@:updatesOnNeed(Gradually,1)@
@:updatesOnNeed(GraduallyRipple,2)@
@:TypeSwitch(UpdatesFunctions_impl_1)@
@


@- Exported functions

@= UpdatesFunctions_impl_0
str
CRKsizeCrackerDeletions(int *k, int *bid){
        (void)k;
        sizeCrackerDeletions(*bid);
        return MAL_SUCCEED;
}

str
CRKsizeCrackerInsertions(int *k, int *bid){
	(void)k;
	sizeCrackerInsertions(*bid);

	return MAL_SUCCEED;
}

str
CRKprintCrackerDeletions(int *k, int *bid){
	(void)k;
	printCrackerDeletions(*bid);

	return MAL_SUCCEED;
}

str
CRKprintCrackerInsertions(int *k, int *bid){
	(void)k;
	printCrackerInsertions(*bid);

	return MAL_SUCCEED;
}

str
CRKmergeInsertions_Forget(int *k, int *bid, int *new){
	(void) k;
	appendCrackerBAT(bid,new);
	removeCrackerIndex(bid);

	return MAL_SUCCEED;
}

str
CRKextendCrackerBAT(int *k, int *bid, lng *positions){
	BAT *b;
	int position = existsCrackerIndex(*bid);
	(void) k;

	if (position == -1)
                throw(MAL, "crackers.CRKextendCrackerBAT", "Cannot find cracker index");
	if ((b = BATdescriptor(CrackerIndex[position].cbid)) == NULL)
                throw(MAL, "crackers.CRKextendCrackerBAT", "Cannot access cracker BAT");

	if ( (oid)*positions > BATcapacity(b) - BATcount(b) ){
		BUN ncap;
		BUN grows;
		oid needed = (oid)*positions - (BATcapacity(b) - BATcount(b));
                ncap = BATcapacity(b) + needed;
                grows = BATgrows(b);
                if (ncap > grows)
                        grows = ncap;
                if (BATextend(b, grows) == NULL)
                throw(MAL, "crackers.CRKextendCrackerBAT", "Failed to extend the cracker BAT");
        }

	BBPunfix(b->batCacheid);

	return MAL_SUCCEED;
}
@

@= updatesOnNeed
str
CRKmergeInsertionsB_OnNeed@1(int *k, int *bid, int *new){
	int position = existsCrackerIndex(*bid);
        (void) k;

	if (position == -1)
		throw(MAL, "crackers.CRKmergeInsertionsB_OnNeed@1", "Cannot find cracker index");

	appendInsertions(new,position);
	CrackerIndex[position].mergeInsertions = @2;
	CrackerIndex[position].deleteNodes = FALSE;	

        return MAL_SUCCEED;
}

str
CRKmergeInsertions_OnNeed@1(int *k, int *bid, int *new, bit *deleteNodes){
	int position = existsCrackerIndex(*bid);
        (void) k;

	if (position == -1)
		throw(MAL, "crackers.CRKmergeInsertions_OnNeed@1", "Cannot find cracker index");

	appendInsertions(new,position);
	CrackerIndex[position].mergeInsertions = @2;
	CrackerIndex[position].deleteNodes = *deleteNodes;	

        return MAL_SUCCEED;
}

str
CRKmergeDeletions_OnNeed@1(int *k, int *bid, int *del){
	int position = existsCrackerIndex(*bid);
        (void) k;

	if (position == -1)
		throw(MAL, "crackers.CRKmergeDeletions_OnNeed@1", "Cannot find cracker index");

	appendDeletions(del,position);
	CrackerIndex[position].mergeDeletions = @2;

        return MAL_SUCCEED;
}
@

@= UpdatesFunctions_impl_1
str
CRKmergeInsertions_PartiallyForget_@1_@4(int *k, int *bid, int *new){
	BAT *c, *u;
	@1 min;
	@1 *inst, *insLast;
	int position = -1;
	int i;

	(void) k;

	if ((u = BATdescriptor(*new)) == NULL)
		throw(MAL, "crackers.mergeInsertions_PartiallyForget_@1", "Cannot access insertions");

	if (BATcount(u) == 0)
		return MAL_SUCCEED;

	for (i = 0; i < maxCrackMap; i++)
        	if (CrackerIndex[i].bid == *bid){
                	position = i;	
			break;
		}

	/*if (position == -1) return; Trying to erase an index that does not exist*/

	if ((c = BATdescriptor(CrackerIndex[position].cid)) == NULL){
                BBPunfix(u->batCacheid);
                throw(MAL, "crackers.CRKmergeInsertions_PartiallyForget_@1", "Cannot access cracker index");
        }

	/* get the min value */
	inst    = (@1*)Tloc(u,BUNfirst(u));
	insLast = (@1*)Tloc(u,BUNlast(u));
	min = *inst;
	for(inst+=1;inst < insLast; inst++)
		if (@2_GT(&min,inst,@3@1))
			min = *inst;

	/* Partially delete tree with lazy deletion */
	PartiallyLazyFreeAVLTree_@1(CrackerIndex[position].Tree, min, c, BUNfirst(c));

	appendCrackerBAT(bid,new);

	BBPunfix(c->batCacheid);
	BBPunfix(u->batCacheid);

	return MAL_SUCCEED;
}

str
CRKmergeInsertionsB_Force_@1_@4(int *k, int *bid, int *new){
	oid startPosition = 0;
	oid endPosition;
	@1 *hgh;
	bit inclusive = TRUE;

	@:mergeInsertionsFromTheEndBodyIb(@1,@2,@3,@4)@

	(void)k;
	next = BUNlast(b) - (oid)1;
	hgh = (@1*)Tloc(b,next);
	@:mergeInsertionsFromTheEndBodyCG(@1,@2,@3,@4)@
	@:mergeInsertionsFromTheEndBodyII(@1,@2,@3,@4)@

        BATsetcount(b, BUNlast(b) + insertions);

	BBPunfix(c->batCacheid);
	BBPunfix(u->batCacheid);
	BBPunfix(b->batCacheid);

 	return MAL_SUCCEED;
}
@


@- Functions shared within the crackers module/library

@= UpdatesSharedFunctions_impl_0
/* used both for selection and sideways cracking */
str
appendInsertions(int *new, int position){
	BAT *u, *c;

       	if ((u = BATdescriptor(*new)) == NULL)
      		 throw(MAL, "crackers.appendInsertions", "Cannot access insertions BAT");

	if (CrackerIndex[position].iid < 0 ){
		BATmode(u,PERSISTENT);
		u->batRestricted= BAT_WRITE;
		CrackerIndex[position].iid = u->batCacheid;
		BBPkeepref(u->batCacheid);
	} else {
       		if ((c = BATdescriptor(CrackerIndex[position].iid)) == NULL)
      		 	throw(MAL, "crackers.appendInsertions", "Cannot access cracker insertions BAT");
		
		c = BATins(c, u,TRUE);

		BBPunfix(c->batCacheid);
		BBPunfix(u->batCacheid);
	}

        return MAL_SUCCEED;
}
@

@= UpdatesSharedFunctions_impl_1
/* mergeInsertionOperations */
str
mergeInsertionsB_@1_@4(int *bid, int *new, oid startPosition, oid endPosition){
	@1 *hgh;
	bit inclusive = TRUE;
	@:mergeInsertionsFromTheEndBodyI(@1,@2,@3,@4)@

	next = BUNlast(b) - 1;
	hgh  = (@1*)Tloc(b,next);

	@:mergeInsertionsFromTheEndBodyCG(@1,@2,@3,@4)@
        @:mergeInsertionsFromTheEndBodyII(@1,@2,@3,@4)@

        BATsetcount(b, BUNlast(b) + insertions);
	BBPunfix(c->batCacheid);
	BBPunfix(u->batCacheid);
	BBPunfix(b->batCacheid);

        return MAL_SUCCEED;
}

str
mergeInsertionsBGradually_@1_@4(int *bid, int *new, oid startPosition, oid endPosition){
	/* First merge then shrink the insertions column */
	@1 *hgh;
	bit inclusive = TRUE;
	@:mergeInsertionsFromTheEndBodyI(@1,@2,@3,@4)@

	next = BUNlast(b) - 1;
	hgh = (@1*)Tloc(b,next);
	
	@:mergeInsertionsFromTheEndBodyCG(@1,@2,@3,@4)@
	@:mergeInsertionsFromTheEndBodyII(@1,@2,@3,@4)@

        BATsetcount(b, BUNlast(b) + insertions);
	endPosition++;
	@:shrinkInsertions(@1,@4)@

        BBPunfix(c->batCacheid);
        BBPunfix(u->batCacheid);
        BBPunfix(b->batCacheid);

        return MAL_SUCCEED;
}

str
mergeInsertionsBRipple_@1_@4(BAT *b, BAT *u, oid startPosition, oid endPosition, @1 *hgh, bit inclusive, int position){
        BAT *ripple;
        BUN rnext;
        @4 *rh;
	@1 *rt, *insLast;	
	oid toRippleBuns;
	oid exceedBuns = 0;
	struct Node * NextNode;
	bit fromTheEnd = FALSE;
	oid i;
	oid consumedRipple = 0, consumedInsertions = 0, values, usedHoles = 0;
	struct Node *rippleNode = NULL;

        BAT *c;
	BUN idxFirst, cur, crkFirst, insFirst, next, write;
	@4 *insh, *crkh;
	@1 *inst, *crkt, *crkLast, *curVal;
	oid *curPos;
	struct Node *IndexNode = NULL;
	oid prevPos, prevcrsize, insertions, remainingIns, buns, needed;
	struct Node *prevNode =NULL;
	@1  *startT, *endT;
	@4 *startH, *endH;

	/* abort if there are no insertions to merge */	
	if (BATcount(u) == 0) {
		return MAL_SUCCEED;
	}

	if ((c = BATdescriptor(CrackerIndex[position].cid)) == NULL){
		throw(MAL, "crackers.mergeInsertions_@1", "Cannot access cracker index");
	}

	insertions = endPosition - startPosition + 1;

	/* sort in place the insertions bat */
	if (u->tsorted == FALSE){
		u->batRestricted = BAT_WRITE;
		BATmirror(BATorder(BATmirror(u)));
	}

	remainingIns = insertions;
	prevcrsize = BATcount(b);
	insFirst = BUNfirst(u);	

	/* make room for the new tuples */
	if ( insertions > BATcapacity(b) - BATcount(b) ){
		BUN ncap;
		BUN grows;
		needed = insertions - (BATcapacity(b) - BATcount(b));
                ncap = BATcapacity(b) + needed;
                grows = BATgrows(b);
                if (ncap > grows)
                        grows = ncap;
                if (BATextend(b, grows) == NULL)
                        throw(MAL, "crackers.mergeInsertions_@1", "Failed to make room for the new values");
        }
	
	insh 	 = (@4*)Hloc(u, insFirst + endPosition);
	inst 	 = (@1*)Tloc(u, insFirst + endPosition);
	idxFirst = BUNfirst(c);
	crkFirst = BUNfirst(b);
	prevPos = prevcrsize - 1;

	insLast = (@1*)Tloc(u,BUNlast(u));	
	toRippleBuns = endPosition - startPosition +1;
	ripple = BATnew(TYPE_@4, TYPE_@1, toRippleBuns);

        /* Find out buns that should be rippled. Take this values out in a temporary BAT */

	/* first find the piece where the biggest insertions should be placed */
        if ( (NextNode = findNodeH_@1(*(@1*)hgh, inclusive, CrackerIndex[position].Tree, c, idxFirst, NULL)) != NULL ){

		prevNode = NextNode;
		cur     = idxFirst + NextNode->position;
                curPos  = (oid*)Hloc(c, cur);

		/* prevPos should not be changed! 
		   mergeInsertionsFromTheEndBodyII expects it to point in the position from where merging will start */
		prevPos = *curPos;

		/* merging will start from this bun */		
		next = crkFirst + (*curPos) ;

		/* use hols if any at the end of the result area */
		if (NextNode->hols > 0){
			rippleNode = NextNode;
			if (NextNode->hols >= insertions)
				goto rippled;
			else 
			if (NextNode->hols < insertions)
				toRippleBuns -= NextNode->hols; 
			
		}

		rh = (@4*)Hloc(ripple, BUNfirst(ripple));
		rt = (@1*)Tloc(ripple, BUNfirst(ripple));

                rnext   = crkFirst + (*curPos) + 1;

		NextNode->deleted = TRUE; /* TODO: consider not deleting this piece and instead extend it... */

                crkh = (@4*)Hloc(b,rnext);
                crkt = (@1 *)Tloc(b,rnext);
		crkLast = (@1*)Tloc(b,BUNlast(b));

		/* find out how many buns until we get into the next chunk. Variable buns holds this information*/ 
		if  ((NextNode =findNextPiece(NextNode)) == NULL)
			buns = values = BATcount(b) - prevPos - 1;
		else {
			cur    = idxFirst + NextNode->position;
               		curPos = (oid*)Hloc(c, cur);
                	rnext   = crkFirst + (*curPos)  + 1;
                	buns   = (*curPos) - prevPos;
			values = buns - NextNode->hols;
		}
		/* move values out. If we get into the next piece then we simply delete it */
		for (i=0; i<toRippleBuns; i++){
		
			if (i == buns && crkt < crkLast && NextNode!=NULL){
				NextNode->deleted = TRUE;
				if  ((NextNode =findNextPiece(NextNode)) == NULL)
					buns = values = BATcount(b) - prevPos - 1;
				else {
					cur    = idxFirst + NextNode->position;
               				curPos = (oid*)Hloc(c, cur);
                			rnext  = crkFirst + (*curPos) + 1;
                			buns   = (*curPos) - prevPos;
					values = buns - NextNode->hols;
				}
			}

			/* do not ripple if this is a hole */
			if (i< values){
				*rh = *crkh;
				*rt = *crkt;
				rh++; rt++; 
			} else { 
				if (NextNode!=NULL)
					NextNode->hols --;
				usedHoles++;
			}
			crkh++; crkt++;	

			/* we consumed all values until the end of the column. nothing more to ripple */
			if (crkt >= crkLast){
				i++;
				exceedBuns = toRippleBuns - i;
				break;
			}
		}
		if (i == buns && NextNode != NULL) {
			NextNode->deleted = TRUE;
			/*printf("\n have to delete piece "LLFMT"  \n", *(oid*)curPos);*/
		}
		BATsetcount(ripple, i-usedHoles);
	} else {
		/* then we do not have to ripple. We simply start merging from the end of the cracker column */
		exceedBuns = toRippleBuns;
		next = BUNlast(b) - 1;
		/* prevPos has been correctly set in mergeInsertionsFromTheEndBodyI pointing at the last bun of the cracker column */
		fromTheEnd = TRUE;
	}
	rippled:;

	if (fromTheEnd){
		@:mergeInsertionsFromTheEndBodyCG(@1,@2,@3,@4)@
	}
        @:mergeInsertionsFromTheEndBodyII(@1,@2,@3,@4)@
		
	if (exceedBuns > 0){
       	 	BATsetcount(b, BUNlast(b) + exceedBuns);
        }

	if (rippleNode != NULL){
		if (rippleNode->hols > insertions)
			rippleNode->hols -= insertions;
		else
		if (rippleNode->hols <= insertions)
			rippleNode->hols = 0;
	}
	endPosition++;

	/* now we have to merge the rippled values with the remaining insertions */
	if (BATcount(ripple) > 0){
		/* do not ripple values that are marked as pending deletions */
		if (CrackerIndex[position].mergeDeletions > 0){
			BAT *deletes, *ripBAT;
			if (CrackerIndex[position].did < 0) goto merge;			
			if ((deletes = BATdescriptor(CrackerIndex[position].did)) == NULL)
		                return "Cannot access the deletions BAT";	
			if (BATcount(deletes)==0) {
				BBPunfix(deletes->batCacheid);
				goto merge;
			}

			ripple->hsorted = FALSE;
			ripple->tsorted = FALSE;
			ripple->tdense = FALSE;
			ripple->hdense = FALSE;

			/* this is just to bypass a bug and shuold be removed from here */
			deletes->hsorted = FALSE;
			deletes->tsorted = FALSE;
			deletes->tdense = FALSE;
			deletes->hdense = FALSE;

			ripBAT = BATsintersect(ripple,deletes);

			if (BATcount(ripBAT)>0){
				ripple = BATdel(ripple,ripBAT,TRUE);
				deletes = BATdel(deletes,ripBAT,TRUE);
			} 

                      	BBPunfix(deletes->batCacheid);
                        BBPunfix(ripBAT->batCacheid);
		}
		merge:;
		if (BATcount(ripple)==0)
                        goto EmptyRipple;

		ripple->tsorted = FALSE;		
		ripple->batRestricted = BAT_WRITE;
		BATmirror(BATorder(BATmirror(ripple)));
		
		/* merge */
		rh    = (@4*)Hloc(ripple, BUNfirst(ripple));
		rt    = (@1*)Tloc(ripple, BUNfirst(ripple));
		crkh  = (@4*)Hloc(u,insFirst+startPosition);
		crkt  = (@1*)Tloc(u,insFirst+startPosition);
		insh  = (@4*)Hloc(u,insFirst+endPosition);
		inst  = (@1*)Tloc(u,insFirst+endPosition);

		crkLast = (@1*)Tloc(ripple,BUNlast(ripple));
		while(rt < crkLast && inst < insLast){
			if (@2_LE(rt,inst,@3@1)){	
				*crkh = *rh;
				*crkt = *rt;
				rh++; rt++; consumedRipple++;
			} else {
				*crkh = *insh;
				*crkt = *inst;
				insh++; inst++; consumedInsertions++;
			}
			crkh++; crkt++;
		}
		
		if (rt < crkLast && inst == insLast){
			BUN i;
			for(i = 0; i<BATcount(ripple)-(BUN)consumedRipple; i++){
				*crkh = *rh;
                                *crkt = *rt;
				 rh++; rt++;crkh++; crkt++;
			}
		} else	
		if (rt == crkLast && inst < insLast){
			BUN i;
			for(i = 0; i<BATcount(u)-(BUN)endPosition -(BUN)consumedInsertions; i++){
                                *crkh = *insh;
                                *crkt = *inst;
                                 insh++; inst++;crkh++; crkt++;
                        }
		}
		/* if some of the insertions went at the end of the cracker column, then the pending insertions has less values now */
                BATsetcount(u, BUNlast(u) - (insertions - BATcount(ripple)));
	} else {
		EmptyRipple:;
		@:shrinkInsertions(@1,@4)@
	}

        BBPunfix(c->batCacheid);
	BBPunfix(ripple->batCacheid);

        return MAL_SUCCEED;
}

str
mergeDeletions_@1_@4(int *bid, int *del, oid startPosition, oid endPosition){
	@:mergeDeletionsBody(@1,@2,@3,@4)@

	BBPunfix(c->batCacheid);
	BBPunfix(u->batCacheid);
	BBPunfix(b->batCacheid);

        return MAL_SUCCEED;
}

str
mergeDeletionsGradually_@1_@4(int *bid, int *del, oid startPosition, oid endPosition){
        @:mergeDeletionsBody(@1,@2,@3,@4)@

	@:shrinkDeletions(@1,@4)@

        BBPunfix(c->batCacheid);
        BBPunfix(u->batCacheid);
        BBPunfix(b->batCacheid);

        return MAL_SUCCEED;
}

str
mergeDeletionsGraduallyRipple_@1_@4(int *bid, int *del, oid startPosition, oid endPosition, @1 *lowV, bit inclusiveL, @1 *hghV, bit inclusiveH){
        BAT *c, *u, *b, *crackerPieceO, *deletesPieceO,  *crackerPieceV, *deletesPieceV;
	BAT *positionsO, *positionsV, *positions, *crackerSlice, *deletesSlice;
	BUN idxFirst, crk, crkFirst, delFirst, low, hgh;
	@1 *delt, *lowVal, *hghVal;
	oid *pos, *posLast;
	oid *hghPos=NULL;
	int position = -1;
	oid deletions, remainingDel, buns;
	@4 *startH;
        @1 *startT;
        @4 *endH;
	@1 *endT;


	struct Node *lowNode, *hghNode, *temp, *stopNode;
	oid LposCr=0,HposCr=0, LposDe, HposDe, deletesForCurrentPiece=0, deletedFromCurrentPiece;
	oid holSize, holPiece, notFound = 0, prevPos, notFoundHere;
	int i;


	for (i = 0; i < maxCrackMap; i++)
                if (CrackerIndex[i].bid == *bid){
                        position = i;
			break;	
		}

        if ((u = BATdescriptor(*del)) == NULL)
                throw(MAL, "crackers.mergeDeletions_@1", "Cannot access insertions BAT");

	/* abort if there are no deletions to merge */	
	if (BATcount(u) == 0) {
		BBPunfix(u->batCacheid);
		return MAL_SUCCEED;
	}

	if ((c = BATdescriptor(CrackerIndex[position].cid)) == NULL){
		BBPunfix(u->batCacheid);
		throw(MAL, "crackers.mergeDeletions_@1", "Cannot access cracker index");
	}
	if ((b = BATdescriptor(CrackerIndex[position].cbid)) == NULL){
		BBPunfix(u->batCacheid);
		BBPunfix(c->batCacheid);
		throw(MAL, "crackers.mergeDeletions_@1", "Cannot access cracker BAT");
	}

	deletions = endPosition - startPosition + 1;

	remainingDel = deletions;
	delFirst = BUNfirst(u);	

	delt 	 = (@1*)Tloc(u, delFirst + startPosition);
	idxFirst = BUNfirst(c);
	crkFirst = BUNfirst(b);

	lowNode  = findNodeL_@1(*lowV, inclusiveL, CrackerIndex[position].Tree, c, idxFirst, NULL); 
	stopNode = findNodeH_@1(*hghV, inclusiveH, CrackerIndex[position].Tree, c, idxFirst, NULL); 

	LposDe = startPosition;
	HposDe = 0;
	b->batRestricted= BAT_READ;
	u->batRestricted= BAT_READ;

	if (lowNode != NULL)
		prevPos = *(oid*)Hloc(c,(idxFirst + lowNode->position)) + 1;
	else 
		prevPos = 0;

	while (1){
		if (lowNode == NULL){
			hghNode = NULL;
			temp = CrackerIndex[position].Tree;
			if (temp->deleted == FALSE)
				hghNode = temp;
			while (temp->left != NULL){
				temp = temp->left;
				if (temp->deleted == FALSE)
					hghNode = temp;
			}
		} else
			hghNode = findNextPiece(lowNode);

		/* find deletes that belong in this piece */
		if (lowNode != NULL && hghNode != NULL){
	                low    = idxFirst + lowNode->position;
                	lowVal = (@1*)Tloc(c, low);

	                hgh    = idxFirst + hghNode->position;
                	hghVal = (@1 *)Tloc(c, hgh);
        	        hghPos = (oid*)Hloc(c, hgh);

	                deletesForCurrentPiece = 0;
        	        while((@2_GT(delt,lowVal,@3@1) || (@2_EQ(delt,lowVal,@3@1) && lowNode->inclusive == TRUE))  &&
                	      (@2_LT(delt,hghVal,@3@1) || (@2_EQ(delt,hghVal,@3@1) && hghNode->inclusive == FALSE)) &&
			      remainingDel > deletesForCurrentPiece ){

                        	delt++;
	                        deletesForCurrentPiece++;
        	        }

      		        LposCr = prevPos;
        	        HposCr = *hghPos;
		} else
		if (lowNode == NULL && hghNode != NULL){
			hgh    = idxFirst + hghNode->position;
       		        hghVal = (@1 *)Tloc(c, hgh);
        	        hghPos = (oid*)Hloc(c, hgh);
	
           	        deletesForCurrentPiece = 0;
	                while( (@2_LT(delt,hghVal,@3@1) || (@2_EQ(delt,hghVal,@3@1) && hghNode->inclusive == FALSE)) &&
			       remainingDel > deletesForCurrentPiece){
                	        delt++;
                       		deletesForCurrentPiece++;
	                }

			LposCr = 0;
        	        HposCr = *hghPos;
		} else
		if (lowNode != NULL && hghNode == NULL){
			low    = idxFirst + lowNode->position ;
			deletesForCurrentPiece = remainingDel;
			LposCr = prevPos;
                        HposCr = BATcount(b)-1;
		}

		if (hghNode != NULL)
			holPiece = hghNode->hols;
		else
			holPiece = 0;

		HposCr -= holPiece;

		deletedFromCurrentPiece = 0;
		holSize = deletions - remainingDel - notFound;
		if (deletesForCurrentPiece != 0){
			HposDe = LposDe + deletesForCurrentPiece;
			crackerSlice = BATslice(b, LposCr, HposCr+1);
			deletesSlice = BATslice(u, LposDe, HposDe);
			crackerPieceO = BATmirror(BATmark(crackerSlice,(oid)0));
			deletesPieceO = VIEWhead(deletesSlice);
			positionsO = BATjoin(crackerPieceO,deletesPieceO,BATcount(deletesPieceO));

			crackerPieceV = BATmirror(BATmark(BATmirror(crackerSlice),(oid)0));
			deletesPieceV = VIEWhead(BATmirror(deletesSlice));
			positionsV = BATjoin(crackerPieceV,deletesPieceV,BATcount(deletesPieceV));

			positions = BATkintersect(positionsO, positionsV);

			if (BATcount(positions) > 0){
				positions->batRestricted = BAT_WRITE;
				BATorder(positions);


				/* fill in the hols */
				pos     = (oid*)Hloc(positions, BUNfirst(positions));
				posLast = (oid*)Hloc(positions, BUNlast(positions)-1);
				crk = crkFirst + HposCr;
				buns =  HposCr - LposCr;
				
				while(pos<=posLast){
					if (*posLast != buns){
						startH = (@4*)Hloc(b,crkFirst+(LposCr+(*pos)));
						startT = (@1*)Tloc(b,crkFirst+(LposCr+(*pos)));
						endH  = (@4*)Hloc(b,crk);
						endT  = (@1*)Tloc(b,crk);
						memcpy(startH, endH, sizeof(@4));
						memcpy(startT, endT, sizeof(@1));
						pos++;
					} else 
						posLast--;
					
	
					crk--; buns--;
				}

				/* values requested to be deleted may not exist */
				deletedFromCurrentPiece = BATcount(positions);
				if ( (notFoundHere = deletesForCurrentPiece - deletedFromCurrentPiece) > 0)
					notFound += notFoundHere;
				BBPunfix(positions->batCacheid);
			}

			BBPunfix(crackerSlice->batCacheid); crackerSlice = NULL;
			BBPunfix(crackerPieceO->batCacheid); crackerPieceO = NULL;
			BBPunfix(deletesSlice->batCacheid); deletesSlice = NULL;
			BBPunfix(deletesPieceO->batCacheid); deletesPieceO = NULL;
			BBPunfix(positionsO->batCacheid); positionsO = NULL;
			BBPunfix(positionsV->batCacheid); positionsV = NULL; 
			BBPunfix(crackerPieceV->batCacheid); crackerPieceV = NULL;
			BBPunfix(deletesPieceV->batCacheid); deletesPieceV = NULL;
			positions = NULL;
		}

		/* this will work both if we delete or no (then deletesForCurrentPiece=0) */
		buns = HposCr - LposCr + 1 - deletedFromCurrentPiece;

		/* no need to to shift if nothing has been deleted from previous pieces */
		if (holSize > 0 && buns > 0){
			if (holSize >= buns){
				startH = (@4*)Hloc(b,crkFirst+(LposCr-holSize));
				startT = (@1 *)Tloc(b,crkFirst+(LposCr-holSize));
				endH   = (@4*)Hloc(b,crkFirst+LposCr);
				endT   = (@1 *)Tloc(b,crkFirst+LposCr);
				memcpy(startH, endH, buns*sizeof(@4));
				memcpy(startT, endT, buns*sizeof(@1));
			}
			else{
				startH = (@4*)Hloc(b,crkFirst+(LposCr-holSize));
				startT = (@1*)Tloc(b,crkFirst+(LposCr-holSize));
				endH   = (@4*)Hloc(b, crkFirst+(LposCr+(buns-holSize)));
				endT   = (@1*)Tloc(b, crkFirst+(LposCr+(buns-holSize)));
				memcpy(startH, endH, holSize*sizeof(@4));
				memcpy(startT, endT, holSize*sizeof(@1));
			}
		}
		if (buns == 0 && lowNode != NULL) lowNode->deleted = TRUE; /* deleted all values in current piece*/
		remainingDel -= deletesForCurrentPiece;
		deletions += holPiece;

		/* stop the ripple once at the end of the last piece */
		if (hghNode != NULL){
			if (hghNode == stopNode)
				break;
			if (HposDe > startPosition)
				LposDe = HposDe;
			hghNode ->hols = 0;
			lowNode = hghNode;
			prevPos = *hghPos+1;
			*hghPos = *hghPos - holSize - deletedFromCurrentPiece - holPiece;
			hghNode->indexPosition = *hghPos;
			if (hghNode->slice!=-1){
				BBPdecref(hghNode->slice,TRUE);
				hghNode->slice = -1;
			}
		} else
			break;
	}

	if (hghNode == NULL){
	        BATsetcount(b, BUNlast(b) - (deletions -remainingDel) + notFound);
	} else
		hghNode->hols = deletions-remainingDel - notFound;
	
	 @:shrinkDeletions(@1,@4)@

	BBPunfix(c->batCacheid);
	BBPunfix(u->batCacheid);
	BBPunfix(b->batCacheid);
        return MAL_SUCCEED;
}
@


@- Local support functions and macros

@= UpdatesLocal
static void
printCrackerDeletions(int bid){
	int i = existsCrackerIndex(bid);
	if (i == -1)
		fprintf(stderr, " the crack index does not exist \n");
	if (CrackerIndex[i].did > 0){
		BAT *b;
		b=BATdescriptor(CrackerIndex[i].did);
		if (b == NULL){
                	mnstr_printf(GDKout,"\n crack print deletions", "Failed to access deletions.");
			return;
		}
		BATprint(b);
		BBPunfix(b->batCacheid);
	}	
}

static void
printCrackerInsertions(int bid){
	int i = existsCrackerIndex(bid);
	if (i == -1)
		fprintf(stderr, " the crack index does not exist \n");
	if (CrackerIndex[i].iid > 0){
		BAT *b;
		b=BATdescriptor(CrackerIndex[i].iid);
		if (b == NULL){
                	mnstr_printf(GDKout,"\n crack print insertions", "Failed to access insertions.");
			return;
		}
		BATprint(b);
		BBPunfix(b->batCacheid);
	}
}

static void
sizeCrackerDeletions(int bid){
        BAT *u;
        int i = existsCrackerIndex(bid);

        if (i == -1)
                fprintf(stderr, " the crack index does not exist \n");
        if (CrackerIndex[i].did > 0){
                u = BATdescriptor(CrackerIndex[i].did);
		if (u == NULL){
                	mnstr_printf(GDKout,"\n crack print deletions", "Failed to access deletions.");
			return;
		}
                printf("\n pending deletions size: "BUNFMT"\n",BATcount(u));
                BBPunfix(u->batCacheid);
        }
        else
                printf("\n pending deletions size: 0 \n");
}

static void
sizeCrackerInsertions(int bid){
	BAT *u;

	int i = existsCrackerIndex(bid);
	if (i == -1)
		fprintf(stderr, " the crack index does not exist \n");
	if (CrackerIndex[i].iid > 0){
		u = BATdescriptor(CrackerIndex[i].iid);
		if (u == NULL){
                	mnstr_printf(GDKout,"\n crack print insertions", "Failed to access insertions.");
			return;
		}
		printf("\n pending insertions size: "BUNFMT" \n",BATcount(u));
		BBPunfix(u->batCacheid);
	}
	else
		printf("\n pending insertions size: 0 \n");
}

static str
removeCrackerIndex(int *bid){
	BAT *c;
	int position = -1;
	int i;

	for (i = 0; i < maxCrackMap; i++)
        	if (CrackerIndex[i].bid == *bid){
                	position = i;	
			break;
		}
	/*if (position == -1) return; Trying to erase an index that does not exist*/

	/* Destroy index BAT */
        if ((c = BATdescriptor(CrackerIndex[position].cid)) == NULL) 
                	throw(MAL, "crack remove index", "Failed to access index.");

	BBPunfix(c->batCacheid);
	BBPreclaim(c);
	CrackerIndex[position].cid = -1;
	CrackerIndex[position].reCreate = 1;

	/* Delete Tree */
	FreeAVLTree(CrackerIndex[position].Tree);
	CrackerIndex[position].Tree = NULL;
	
	return MAL_SUCCEED;
}

static str
appendCrackerBAT(int * bid, int * new){
        BAT *c, *u;
	int position = -1;
	int i;

	for (i = 0; i < maxCrackMap; i++)
                if (CrackerIndex[i].bid == *bid){
                        position = i;
			break;	
		}

        if ((c = BATdescriptor(CrackerIndex[position].cbid)) == NULL)
                throw(MAL, "bat.append", "Cannot access descriptor");

        if ((u = BATdescriptor(*new)) == NULL) {
                BBPreleaseref(c->batCacheid);
                throw(MAL, "bat.append", "Cannot access descriptor");
        }
	
	if (BATcount(u) == 0) {
		BBPunfix(c->batCacheid);
		BBPunfix(u->batCacheid);
		return MAL_SUCCEED;
	}

        BATappend(c, u, TRUE);

	BBPunfix(c->batCacheid);
	BBPunfix(u->batCacheid);

	return MAL_SUCCEED;
}

static str
appendDeletions(int *del, int position){
	BAT *u, *c;

       	if ((u = BATdescriptor(*del)) == NULL)
      		 throw(MAL, "crackers.appendDeletions", "Cannot access deletions BAT");

	if (CrackerIndex[position].did < 0 ){
		BATmode(u,PERSISTENT);
		u->batRestricted= BAT_WRITE;
		CrackerIndex[position].did = u->batCacheid;
		BBPkeepref(u->batCacheid);
	} else {
       		if ((c = BATdescriptor(CrackerIndex[position].did)) == NULL)
      		 	throw(MAL, "crackers.appendDeletions", "Cannot access cracker deletions BAT");
		
		c = BATins(c,u, TRUE);

		BBPunfix(c->batCacheid);
		BBPunfix(u->batCacheid);
	}

        return MAL_SUCCEED;
}
@


@= mergeInsertionsFromTheEndBodyI
        BAT *c, *u, *b;
	BUN idxFirst, cur, crkFirst, insFirst, next, write;
	oid *curPos;
	@4 *insh, *crkh;
	@1  *inst, *crkt, *curVal;
	int position = -1;
	struct Node *IndexNode = NULL;
	oid prevPos, prevcrsize, insertions, remainingIns, buns, needed;
	struct Node *prevNode =NULL;
	@4 *startH, *endH;
	@1 *startT, *endT;

	{
		int i;
		for (i = 0; i < maxCrackMap; i++)
			if (CrackerIndex[i].bid == *bid){
				position = i;
				break;	
			}
	}

        if ((u = BATdescriptor(*new)) == NULL)
                throw(MAL, "crackers.mergeInsertions_@1", "Cannot access insertions BAT");

	/* abort if there are no insertions to merge */	
	if (BATcount(u) == 0) {
		BBPunfix(u->batCacheid);
		return MAL_SUCCEED;
	}

	if ((c = BATdescriptor(CrackerIndex[position].cid)) == NULL){
		BBPunfix(u->batCacheid);
		throw(MAL, "crackers.mergeInsertions_@1", "Cannot access cracker index");
	}
	if ((b = BATdescriptor(CrackerIndex[position].cbid)) == NULL){
		BBPunfix(u->batCacheid);
		BBPunfix(c->batCacheid);
		throw(MAL, "crackers.mergeInsertions_@1", "Cannot access cracker BAT");
	}

	insertions = endPosition - startPosition + 1;

	/* sort in place the insertions bat */
	if (u->tsorted == FALSE){
		u->batRestricted = BAT_WRITE;
		BATmirror(BATorder(BATmirror(u)));
	}

	remainingIns = insertions;
	prevcrsize = BATcount(b);
	insFirst = BUNfirst(u);	

	/* make room for the new tuples */
	if ( insertions > BATcapacity(b) - BATcount(b) ){
		BUN ncap;
		BUN grows;
		needed = insertions - (BATcapacity(b) - BATcount(b));
                ncap = BATcapacity(b) + needed;
                grows = BATgrows(b);
                if (ncap > grows)
                        grows = ncap;

                if (BATextend(b, grows) == NULL)
                        throw(MAL, "crackers.mergeInsertions_@1", "Failed to make room for the new values");
        }
	
	insh 	 = (@4*)Hloc(u, insFirst + endPosition);
	inst 	 = (@1*)Tloc(u, insFirst + endPosition);
	idxFirst = BUNfirst(c);
	crkFirst = BUNfirst(b);
	prevPos = prevcrsize - 1;
@

@= mergeInsertionsFromTheEndBodyIb
/*same as above only diffrence is -> endPosition = BATcount(u) - 1*/
        BAT *c, *u, *b;
	BUN idxFirst, cur, crkFirst, insFirst, next, write;
	oid *curPos;
	@4 *insh, *crkh;
	@1  *inst, *crkt, *curVal;
	int position = -1;
	struct Node *IndexNode = NULL;
	oid prevPos, prevcrsize, insertions, remainingIns, buns, needed;
	struct Node *prevNode =NULL;
	@4 *startH, *endH;
	@1 *startT, *endT;

	{
		int i;
		for (i = 0; i < maxCrackMap; i++)
			if (CrackerIndex[i].bid == *bid){
				position = i;
				break;	
			}
	}

        if ((u = BATdescriptor(*new)) == NULL)
                throw(MAL, "crackers.mergeInsertions_@1", "Cannot access insertions BAT");

	/* abort if there are no insertions to merge */	
	if (BATcount(u) == 0) {
		BBPunfix(u->batCacheid);
		return MAL_SUCCEED;
	}

	if ((c = BATdescriptor(CrackerIndex[position].cid)) == NULL){
		BBPunfix(u->batCacheid);
		throw(MAL, "crackers.mergeInsertions_@1", "Cannot access cracker index");
	}
	if ((b = BATdescriptor(CrackerIndex[position].cbid)) == NULL){
		BBPunfix(u->batCacheid);
		BBPunfix(c->batCacheid);
		throw(MAL, "crackers.mergeInsertions_@1", "Cannot access cracker BAT");
	}

	endPosition = BATcount(u) - 1;

	insertions = endPosition - startPosition + 1;

	/* sort in place the insertions bat */
	if (u->tsorted == FALSE){
		u->batRestricted = BAT_WRITE;
		BATmirror(BATorder(BATmirror(u)));
	}

	remainingIns = insertions;
	prevcrsize = BATcount(b);
	insFirst = BUNfirst(u);	

	/* make room for the new tuples */
	if ( insertions > BATcapacity(b) - BATcount(b) ){
		BUN ncap;
		BUN grows;
		needed = insertions - (BATcapacity(b) - BATcount(b));
                ncap = BATcapacity(b) + needed;
                grows = BATgrows(b);
                if (ncap > grows)
                        grows = ncap;

                if (BATextend(b, grows) == NULL)
                        throw(MAL, "crackers.mergeInsertions_@1", "Failed to make room for the new values");
        }
	
	insh 	 = (@4*)Hloc(u, insFirst + endPosition);
	inst 	 = (@1*)Tloc(u, insFirst + endPosition);
	idxFirst = BUNfirst(c);
	crkFirst = BUNfirst(b);
	prevPos = prevcrsize - 1;
@

@= mergeLoop
	if ( IndexNode == NULL )
		goto mergeDone;

	/* First position after the last value of this piece. 
           Here we will start moving values we shift from the begginning of the piece */
		
	prevholes = prevNode==NULL?0:prevNode->hols;
	write  = next + 1 - prevholes;

	cur    = idxFirst + (IndexNode->position);
        curPos = (oid*)Hloc(c, cur);
	curVal = (@1 *)Tloc(c, cur);

	buns   = prevPos - (*curPos) - prevholes; /* find out how many values this piece has */

	/* prevPos takes the correct value for the next iteration */
	prevPos = *curPos;

	/* next takes the corect value for the next iteration. This is the position of the last value of the previous piece */
	next   = crkFirst + (*curPos);
	
	/* First insert any pending insertions that belong to this piece */
	crkh = (@4*)Hloc(b,write+(remainingIns-1));
	crkt = (@1*)Tloc(b,write+(remainingIns-1));
	while(  remainingIns > 0 &&
		(@2_GT(inst,curVal,@3@1) || (@2_EQ(inst,curVal,@3@1) && IndexNode->inclusive == TRUE)) ){
		*crkh = *insh;
		*crkt = *inst;
		crkh--; crkt--; insh--; inst--; remainingIns--;
	}

	if (remainingIns == 0)
               	goto mergeDone;

	/* Then we shift values from the beggining of the piece */
	if (buns > remainingIns){
		startH = (@4*)Hloc(b,write);
		startT = (@1*)Tloc(b,write);
		endH   = (@4*)Hloc(b,next+1);
		endT   = (@1*)Tloc(b,next+1);
	
		memcpy(startH, endH, remainingIns*sizeof(@4));
		memcpy(startT, endT, remainingIns*sizeof(@1));
	
	}
	else{
		startH = (@4*)Hloc(b,write+remainingIns-buns);
		startT = (@1*)Tloc(b,write+remainingIns-buns);
		endH   = (@4*)Hloc(b,next+1);
		endT   = (@1*)Tloc(b,next+1);
	
		memcpy(startH, endH, buns*sizeof(@4));
		memcpy(startT, endT, buns*sizeof(@1));
	}	

	/* we always update the index to be +remainingIns since even if we move 
           buns values we put them remainingIns positions ahead */
	*curPos =  *curPos + remainingIns;
	IndexNode->indexPosition = *curPos;
	{
		struct Node *temp, *prevAffectedNode;
		int batid;
		if (IndexNode->slice != -1){
		  	temp = findPreviousPieceWalkingBack(IndexNode);
			batid = IndexNode->slice;
			BBPdecref(IndexNode->slice,TRUE);
			IndexNode->slice = -1;

			while(temp !=NULL){
				if (temp->slice == batid)
					temp->slice = -1;
				temp = findPreviousPieceWalkingBack(temp);	
			}

			temp = IndexNode->nextValue;
			while(temp!=NULL){
				if (temp->slice == batid)
					temp->slice = -1;
				else
					break;
				temp = temp->nextValue;				
			}

		}
		prevAffectedNode = findPreviousPieceWalkingBack(IndexNode);
		if (prevAffectedNode != NULL){
			if (prevAffectedNode->slice != -1){
				temp = findPreviousPieceWalkingBack(prevAffectedNode);
				batid = prevAffectedNode->slice;
				BBPdecref(prevAffectedNode->slice,TRUE);
				prevAffectedNode->slice = -1;

				while(temp !=NULL){
					if (temp->slice == batid)
						temp->slice = -1;
					temp = findPreviousPieceWalkingBack(temp);	
				}

			}
		}
	}
	prevNode = IndexNode;
@

@= mergeInsertionsFromTheEndBodyCG
	/* merge for the last piece only */
	if ( remainingIns > 0) {
		/* get the last piece */
		oid prevholes=0;
		IndexNode = findNodeL_@1(*hgh, inclusive, CrackerIndex[position].Tree, c, idxFirst, NULL);
		@:mergeLoop(@1,@2,@3,@4)@
	}
@

@= mergeInsertionsFromTheEndBodyII
	/* Here the actual merging happens. Starting from the piece where next belongs we continuously 
	   insert and shift until there are no more insertions or pieces */
	while ( remainingIns > 0) {
		oid prevholes=0;
		IndexNode = findPreviousPieceWalkingBack(prevNode);
		@:mergeLoop(@1,@2,@3,@4)@
	}

	mergeDone:;

	/* We reached the first piece. If there are more insertions then they all go here */
	if (IndexNode == NULL && remainingIns > 0){
		
		crkh = (@4*)Hloc(b,next + 1 - (prevNode==NULL?0:prevNode->hols) + (remainingIns-1));
                crkt = (@1*)Tloc(b,next + 1 - (prevNode==NULL?0:prevNode->hols) + (remainingIns-1));
                while(  remainingIns > 0  ){
                        *crkh = *insh;
                        *crkt = *inst;
                        crkh--; crkt--; insh--; inst--; remainingIns--;
		}
	}
@

@= shrinkInsertions
	if (startPosition == 0 && (BUN)endPosition == BATcount(u)){
        	BATmode(u, TRANSIENT);
                CrackerIndex[position].iid = -1;
        } else  if ((BUN)endPosition == BATcount(u)){
                BATsetcount(u,insFirst + startPosition);
        } else {
		@2 *startH = (@2*)Hloc(u,insFirst+startPosition);
		@1 *startT = (@1*)Tloc(u,insFirst+startPosition);
		@2 *endH   = (@2*)Hloc(u,insFirst+endPosition);
		@1 *endT   = (@1*)Tloc(u,insFirst+endPosition);
		memmove(startH, endH, (BATcount(u)-endPosition)*sizeof(@2));
		memmove(startT, endT, (BATcount(u)-endPosition)*sizeof(@1));

   		BATsetcount(u, insFirst + (startPosition + (BATcount(u) - endPosition)));
	}
@

@= shrinkDeletions
	endPosition += 1;
{
	BAT *shrinkSLice  = BATslice(u,startPosition,endPosition);
	BAT *shrinkCopy = BATcopy(shrinkSLice, shrinkSLice->htype, shrinkSLice->ttype, TRUE);

	u = BATdel(u, shrinkCopy, TRUE);

	BBPunfix(shrinkSLice->batCacheid);
	BBPunfix(shrinkCopy->batCacheid);
}
@

@= mergeDeletionsBody
        BAT *c, *u, *b, *crackerPieceO, *deletesPieceO,  *crackerPieceV, *deletesPieceV;
	BAT *positionsO, *positionsV, *positions, *crackerSlice, *deletesSlice;
	BUN idxFirst, crk, crkFirst, delFirst, low, hgh;
	@1 *delt, *hghVal, *lowVal;
	oid *pos, *posLast;
	oid *hghPos=NULL;
	int position = -1;
	oid deletions, remainingDel, buns;
	struct Node *lowNode, *hghNode, *temp;
	oid LposCr=0,HposCr=0, LposDe, HposDe, deletesForCurrentPiece=0, deletedFromCurrentPiece;
	oid holSize, holPiece, notFound = 0, prevPos, notFoundHere;
	int i;
	@1  *startT, *endT;
	oid *startH, *endH;

	for (i = 0; i < maxCrackMap; i++)
                if (CrackerIndex[i].bid == *bid){
                        position = i;
			break;	
		}

        if ((u = BATdescriptor(*del)) == NULL)
                throw(MAL, "crackers.mergeDeletions_@1", "Cannot access insertions BAT");

	/* abort if there are no deletions to merge */	
	if (BATcount(u) == 0) {
		BBPunfix(u->batCacheid);
		return MAL_SUCCEED;
	}

	if ((c = BATdescriptor(CrackerIndex[position].cid)) == NULL){
		BBPunfix(u->batCacheid);
		throw(MAL, "crackers.mergeDeletions_@1", "Cannot access cracker index");
	}
	if ((b = BATdescriptor(CrackerIndex[position].cbid)) == NULL){
		BBPunfix(u->batCacheid);
		BBPunfix(c->batCacheid);
		throw(MAL, "crackers.mergeDeletions_@1", "Cannot access cracker BAT");
	}

	deletions = endPosition - startPosition + 1;

	remainingDel = deletions;
	delFirst = BUNfirst(u);	

	delt 	 = (@1*)Tloc(u, delFirst + startPosition);
	idxFirst = BUNfirst(c);
	crkFirst = BUNfirst(b);

	lowNode = findNodeL_@1(*delt, TRUE, CrackerIndex[position].Tree, c, idxFirst, NULL);
	LposDe = startPosition;
	HposDe = 0;
	b->batRestricted= BAT_READ;
	u->batRestricted= BAT_READ;
	if (lowNode != NULL)
		prevPos = *(oid*)Hloc(c,(idxFirst + (lowNode->position) )) + 1;
	else 
		prevPos = 0;
	while (1){
		if (lowNode == NULL){
			hghNode = NULL;
			temp = CrackerIndex[position].Tree;
			if (temp->deleted == FALSE)
				hghNode = temp;
			while (temp->left != NULL){
				temp = temp->left;
				if (temp->deleted == FALSE)
					hghNode = temp;
			}
		} else
			hghNode = findNextPiece(lowNode);


		/* find deletes that belong in this piece */
		if (lowNode != NULL && hghNode != NULL){
	                low    = idxFirst + lowNode->position;
                	lowVal = (@1*)Tloc(c, low);

	                hgh    = idxFirst + hghNode->position;
                	hghVal = (@1 *)Tloc(c, hgh);
        	        hghPos = (oid*)Hloc(c, hgh);

	                deletesForCurrentPiece = 0;
        	        while((@2_GT(delt,lowVal,@3@1) || (@2_EQ(delt,lowVal,@3@1) && lowNode->inclusive == TRUE))  &&
                	      (@2_LT(delt,hghVal,@3@1) || (@2_EQ(delt,hghVal,@3@1) && hghNode->inclusive == FALSE)) &&
			      remainingDel > deletesForCurrentPiece ){

                        	delt++;
	                        deletesForCurrentPiece++;
        	        }

      		        LposCr = prevPos;
        	        HposCr = *hghPos;
		} else
		if (lowNode == NULL && hghNode != NULL){
			hgh    = idxFirst + hghNode->position;
       		        hghVal = (@1 *)Tloc(c, hgh);
        	        hghPos = (oid*)Hloc(c, hgh);
	
           	        deletesForCurrentPiece = 0;
	                while( (@2_LT(delt,hghVal,@3@1) || (@2_EQ(delt,hghVal,@3@1) && hghNode->inclusive == FALSE)) &&
			       remainingDel > deletesForCurrentPiece){
                	        delt++;
                       		deletesForCurrentPiece++;
	                }

			LposCr = 0;
        	        HposCr = *hghPos;
		} else
		if (lowNode != NULL && hghNode == NULL){
			low    = idxFirst + lowNode->position;
			deletesForCurrentPiece = remainingDel;
			LposCr = prevPos;
                        HposCr = BATcount(b)-1;
		}

		if (hghNode != NULL)
			holPiece = hghNode->hols;
		else
			holPiece = 0;

		HposCr -= holPiece;

		deletedFromCurrentPiece = 0;
		holSize = deletions - remainingDel - notFound;
		if (deletesForCurrentPiece != 0){
			HposDe = LposDe + deletesForCurrentPiece;
			crackerSlice = BATslice(b, LposCr, HposCr+1);
			deletesSlice = BATslice(u, LposDe, HposDe);

			crackerPieceO = BATmirror(BATmark(crackerSlice,(oid)0));

			deletesPieceO = VIEWhead(deletesSlice);
			positionsO = BATjoin(crackerPieceO,deletesPieceO,BATcount(deletesPieceO));

			crackerPieceV = BATmirror(BATmark(BATmirror(crackerSlice),(oid)0));
			deletesPieceV = VIEWhead(BATmirror(deletesSlice));
			positionsV = BATjoin(crackerPieceV,deletesPieceV,BATcount(deletesPieceV));

			positions = BATkintersect(positionsO, positionsV);
			if (BATcount(positions) > 0){
				positions->batRestricted = BAT_WRITE;
				BATorder(positions);

				/* fill in the hols */
				pos = (oid*)Hloc(positions, BUNfirst(positions));
				posLast = (oid*)Hloc(positions, BUNlast(positions)-1);
				crk  = crkFirst + HposCr;
				buns = HposCr - LposCr;
				while(pos<=posLast){
					if (*posLast != buns){
						startH = (oid*)Hloc(b,crkFirst+(LposCr+(*pos)));
						startT = (@1 *)Tloc(b,crkFirst+(LposCr+(*pos)));
						endH  = (oid*)Hloc(b,crk);
						endT  = (@1 *)Tloc(b,crk);
						memcpy(startH, endH, sizeof(oid));
						memcpy(startT, endT, sizeof(@1));
						pos++;
					} else
						posLast--;
					crk--; buns--;
				}

				deletedFromCurrentPiece = BATcount(positions);
				if ( (notFoundHere = deletesForCurrentPiece - deletedFromCurrentPiece) > 0)
					notFound += notFoundHere;
				BBPunfix(positions->batCacheid);
			}

			BBPunfix(crackerSlice->batCacheid); crackerSlice = NULL;
			BBPunfix(crackerPieceO->batCacheid); crackerPieceO = NULL;
			BBPunfix(deletesSlice->batCacheid); deletesSlice = NULL;
			BBPunfix(deletesPieceO->batCacheid); deletesPieceO = NULL;
			BBPunfix(positionsO->batCacheid); positionsO = NULL;
			BBPunfix(positionsV->batCacheid); positionsV = NULL; 
			BBPunfix(crackerPieceV->batCacheid); crackerPieceV = NULL;
			BBPunfix(deletesPieceV->batCacheid); deletesPieceV = NULL;
			positions = NULL;
		}

		/* this will work both if we delete or no (then deletesForCurrentPiece=0) */
		buns = HposCr - LposCr + 1 - deletedFromCurrentPiece;
		/* no need to to shift if nothing has been deleted from previous pieces */
		if (holSize > 0 && buns > 0){
			if (holSize >= buns){
				startH = (oid*)Hloc(b,crkFirst+(LposCr-holSize));
				startT = (@1 *)Tloc(b,crkFirst+(LposCr-holSize));
				endH  = (oid*)Hloc(b,crkFirst+LposCr);
				endT  = (@1 *)Tloc(b,crkFirst+LposCr);
				memcpy(startH, endH, buns*sizeof(oid));
				memcpy(startT, endT, buns*sizeof(@1));
			}
			else{
				startH = (oid*)Hloc(b,crkFirst+(LposCr-holSize));
				startT = (@1 *)Tloc(b,crkFirst+(LposCr-holSize));
				endH  = (oid*)Hloc(b,crkFirst+(LposCr+(buns-holSize)));
				endT  = (@1 *)Tloc(b,crkFirst+(LposCr+(buns-holSize)));
				memcpy(startH, endH, holSize*sizeof(oid));
				memcpy(startT, endT, holSize*sizeof(@1));
			}
		}
		if (buns == 0 && lowNode != NULL) lowNode->deleted = TRUE; /* deleted all values in current piece*/
		remainingDel -= deletesForCurrentPiece;
		deletions += holPiece;
		if (hghNode != NULL){
			if (HposDe > startPosition)
				LposDe = HposDe;
			hghNode ->hols = 0;
			lowNode = hghNode;
			prevPos = *hghPos+1;
			*hghPos = *hghPos - holSize - deletedFromCurrentPiece - holPiece;

		} else
			break;
	}

        BATsetcount(b, BUNlast(b) - (deletions-remainingDel) + notFound);
@

@}
