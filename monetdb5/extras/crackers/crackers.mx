@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.monetdb.org/Legal/MonetDBLicense

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2011 MonetDB B.V.
All Rights Reserved.
@

@c
/*
 * @f crackers
 * @a Martin Kersten, Stratos Idreos, Stefan Manegold
 * @d March 2006 - July 2007
 * @* Cracker index
 *
 * Database cracking aims at enhancing query processing by adapting the way
 * data is stored to the query workload. Adaptation happens through physical
 * reorganization of data. Each query reorganized the data in such a way that
 * future queries can be answered faster.
 *
 * For each BAT b, the system creates on demand a cracker column c, i.e.,
 * the first time a select operator is fired on b. From there on all queries that
 * perform a select operator on b will physically reorganize (i.e., crack) the cracker column c
 * such that the result set is in a consecutive area in c.
 * The result of the select operator is a non materialized view on c.
 *
 * For each cracker column c, there exists a cracker index, that maintains knowledge
 * on the various pieces created while cracking c. The cracker index is an AVLt-tree
 * data structure. Each select operator uses the appropriate cracker index to determine
 * which pieces it should crack, and updates the index afterwards.
 *
 * The more queries are fired on a bat b the more the cracker column c of b is cracked.
 * This way the cracker index on c, is continuously enriched with information that helps speed up
 * future queries. This way query processing improves as more queries are answered by adapting to
 * the query and data workload.
 *
 * Initial performance shows an exptected gain of at least on order of magnitude,
 * due to analysing less data during the select operator and also due to non materializing
 * the select operator result set.
 *
 * The cracker index can be created for the time being on
 * tail columns of type {int,lng,dbl,flt,time,date,sht}. The head
 * is always of type @sc{oid}.
 *
 * In addition, the cracker index can be used to feed a generator
 * for pieces satisfying a range constraint.
 * A cracker partition is indicated by the index in the cidx
 * table. It can be used to initialize a BATview to represent
 * the partition during processing.
 *
 * Updates support for cracker columns happens again in a self-organizing way.
 * Incoming updates (inserts,deletes or updates) are kept in separate columns for
 * each BAT as pending updates. While processing queries, if the crackers select
 * operator detects that some of the pending updates should be taken into account,
 * then updates are "merged" into the cracker column on the fly by also updating the
 * cracker index accordingly.
 *
 * Since the cracker columns are physically reorganized the result of a select operator is not
 * ordered in the same way as the rest of the bats of the same relation. This has side-effects
 * during projection operations. We cannot use ordered fetch joins anymore.
 * This decrades performance significantly
 * when multiple projections exist in a query plan.
 *
 * This problem is solved by the second generation cracing, i.e.,
 * sideways cracking that uses cracker maps instead of cracker columns.
 * A cracker map contains the values of two attributes of the same relation.
 * These are attributes used together in query plans. The main idea is that
 * cracking based on one of these attributes (the head of the map) is forwarded on the tail.
 * This way projections can be performed by performing simple cracking operations on maps.
 * Multiple maps can exist for each attribute A as head consisting the map set of A. All maps in the same
 * map set S are aligned before used in a query plan. Aligment happens by keeping a history of all cracking
 * operations in maps of S and ensuring that the same cracks have been applied to all necessary maps
 * and in the same order. Sideways cracking maintains the advantage of cracking even
 * in the presence of multiple projection operations.
 *
 * Ongoing work.
 * Multitable cracking.
 *
 * The cracker module should be prepared to deal with any of the base types.
 * For strings this becomes an issue.
 *
 * The current implementation uses an unprotected cracker
 * index. This limits the interface at slightly more overhead
 * of searching the cracker index upon each call.
 *
 * Currently crakcer structures are in memory. They need to be stored in disk and become persistent.
 *
 * Repeated cracking leads to an ever growing index. This process
 * can be stopped by setting the granule size,
 * i.e.  the minimum number of tuples in each piece,
 * or the maximum number of pieces.
 *
 * The implementation is geared at early experimentation
 * without all the details to make the code robust and
 * ultra fast.
 *
 *
 * @+ Interface
 *
 *
 * @- Type expansion
 */
@= TypeSwitch_temp2
@:@1(@2,int)@
@:@1(@2,date)@
@
@= TypeSwitch_1
@:@1(@2,chr)@
@:@1(@2,sht)@
@:@1(@2,int)@
@:@1(@2,lng)@
@:@1(@2,flt)@
@:@1(@2,dbl)@
@:@1(@2,date)@
@
@= TypeSwitch_2
@:TypeSwitch_temp2(@1,int)@
@:TypeSwitch_temp2(@1,date)@
@:TypeSwitch_temp2(@1,dbl)@
@:@1(date,lng)@
@:@1(date,dbl)@
@:@1(date,str)@
@:@1(int,str)@
@:@1(dbl,str)@
@:@1(dbl,int)@
@:@1(dbl,dbl)@
@:@1(int,lng)@
@
@= TypeSwitch_joins1
@:@1(int,int)@
@:@1(int,oid)@
@
@= TypeSwitch_joins2
@:@1(int)@
@
@mal
# @- MAL file
module crackers;

@:TypeSwitch_1(Select)@
@:TypeSwitch_1(JoinSelect)@
@:TypeSwitch_1(Updates)@
@:TypeSwitch_1(Index)@
@:TypeSwitch_1(CoreUnordered)@
@:TypeSwitch_1(CoreOrdered)@
@:TypeSwitch_1(Validate)@
@:TypeSwitch_1(AVLindex)@
@:TypeSwitch_joins1(Joins1)@
@:TypeSwitch_joins2(Joins2)@
@:TypeSwitch_2(Sideways)@

command mapCount(b:bat[:oid,:oid]) :lng
address CRKbatCount
comment "Retrieve the size of the map";

command getTotalStorage( ):void
address CRKgetTotalStorage
comment "Get the number of total tuples stored in sideways maps";

command setStorageThreshold(threshold:lng):void
address CRKsetStorageThreshold
comment "set the maximum number of total tuples that can be stored in sideways maps";

command fmclearReferences():void
address CRKclearReferencesFullMaps
comment "clear all references ";

command fmremoveMap():void
address CRKremoveFullMap
comment "clear all debugging map ";

#
@= Select
command select(b:bat[:oid,:@2],l:@2,h:@2):bat[:oid,:@2]
address CRKselect_@2
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command select(b:bat[:oid,:@2],l:@2):bat[:oid,:@2]
address CRKselectValue_@2
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command select(b:bat[:oid,:@2],l:@2,h:@2,li:bit,hi:bit):bat[:oid,:@2]
address CRKselectBounds_@2
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command uselect(b:bat[:any_1,:@2],l:@2,h:@2):bat[:any_1,:void]
address CRKuselect_@2
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command uselect(b:bat[:any_1,:@2],l:@2):bat[:any_1,:void]
address CRKuselectValue_@2
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command uselect(b:bat[:any_1,:@2],l:@2,h:@2,li:bit,hi:bit):bat[:any_1,:void]
address CRKuselectBounds_@2
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command thetauselect(b:bat[:any_1,:@2],v:@2,op:str):bat[:any_1,:void]
address CRKthetauselect_@2
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command thetaselect(b:bat[:any_1,:@2],v:@2,op:str):bat[:any_1,:oid]
address CRKthetaselect_@2
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";
 
command select2(b:bat[:oid,:@2],l:@2,h:@2,li:bit,hi:bit):bat[:oid,:@2]
address CRKselectBounds2_@2
comment "Similar to select but always make sure that we do not create a large piece 
	 i.e., bigger than half the size of the cracked piece";

command selectsm(b:bat[:oid,:@2],l:@2,h:@2,li:bit,hi:bit, mode:int, rounding:bit,sliceSize:int):bat[:oid,:@2]
address CRKselectSortMerge_@2
comment "Slice and sort for the first query. Incrementally merge slices for the next ones.";

command selectcm(b:bat[:oid,:@2],l:@2,h:@2,li:bit,hi:bit,sliceSize:int,mode:int):bat[:oid,:@2]
address CRKselectCrackMerge_@2
comment "Slice and crack for the first query. Incrementally crack+merge slices for the next ones.";

command extsort(b:bat[:oid,:@2], mode:int):bat[:oid,:@2]
address CRKPartitionedSort_@2
comment "Slice and sort";

command extsort2(b:bat[:oid,:@2], sliceSize:int):bat[:oid,:@2]
address CRKExternalSort_@2
comment "Slice and external sort";
@
@= JoinSelect
command joinuselect( right:bat[:oid,:@2], l:@2, h:@2, li:bit, hi:bit, left:bat[:oid,:void] ):bat[:oid,:void]
address CRKjoinSelectDefault_@2
comment "Join left and right on head-OIDs.
	From right, only those BUNs qualify that satisfy the range-restriction on the tail.
	The result is a new [:oid,:void] BAT.";

command joinuselect( right:bat[:oid,:@2], l:@2, h:@2, li:bit, hi:bit, left:bat[:oid,:void], inPlace:bit , isForeignKey:bit):bat[:oid,:void]
address CRKjoinSelectBounds_@2
comment "Join left and right on head-OIDs.
	From right, only those BUNs qualify that satisfy the range-restriction on the tail.
	If inPlace is TRUE (and left has an OID head and is not a BAT-view), we operate in-place,
	overwriting left and returning it as result. Otherwise, the result is a new [:oid,:void] BAT.
	If isForeignKey is TRUE, we assume that each tuple from left finds a match in right,
	and hence skip the respective check.
	(NOTE: This may lead to CRASHES, if isForeignKey is incorrectly passed as TRUE!)";

command jointhetauselect( right:bat[:oid,:@2],v:@2,op:str, left:bat[:oid,:void], inPlace:bit , isForeignKey:bit):bat[:oid,:void]
address CRKjointhetauselect_@2
comment "Join left and right on head-OIDs.
	From right, only those BUNs qualify that satisfy the range-restriction on the tail.
	If inPlace is TRUE (and left has an OID head and is not a BAT-view), we operate in-place,
	overwriting left and returning it as result. Otherwise, the result is a new [:oid,:void] BAT.
	If isForeignKey is TRUE, we assume that each tuple from left finds a match in right,
	and hence skip the respective check.
	(NOTE: This may lead to CRASHES, if isForeignKey is incorrectly passed as TRUE!)";

command joinselect( b:bat[:oid,:@2],l:@2, h:@2, li:bit, hi:bit ):bat[:oid,:bit]
address CRKjoinSelectSideways_@2
comment "From cpair, only those BUNs qualify that satisfy the range-restriction on the tail.
        The result is a new [:oid,:bit] BAT that reflects the positions of buns in cpair. 
	For each tuple that qualifies in cpair, the respective position in the pivot is marked with a 1";

command jointhetaselect( b:bat[:oid,:@2],v:@2,op:str):bat[:oid,:bit]
address CRKjointhetaSelectSideways_@2
comment "From cpair, only those BUNs qualify that satisfy the range-restriction on the tail.
        The result is a new [:oid,:bit] BAT that reflects the positions of buns in cpair. 
	For each tuple that qualifies in cpair, the respective position in the pivot is marked with a 1";

@
@= Updates
command insertionsPartiallyForget(b:bat[:any_1,:@2], c:bat[:any_1,:@2]):void
address CRKmergeInsertions_PartiallyForget_@2
comment "Append c to the cracked BAT of b and partially forget 
         the cracker index, i.e., forget only what is affected";

command insertionsBForce(b:bat[:any_1,:@2], c:bat[:any_1,:@2]):void
address CRKmergeInsertionsB_Force_@2
comment "Merge the insertions BAT with the cracker bat and update the cracker index";


command printCrackerInsertions(b:bat[:any_1,:@2]):void
address CRKprintCrackerInsertions
comment "Print the pending insertions of the cracker BAT of b";

command printCrackerDeletions(b:bat[:any_1,:@2]):void
address CRKprintCrackerDeletions
comment "Print the pending deletions of the cracker BAT of b";

command sizeCrackerInsertions(b:bat[:any_1,:@2]):void
address CRKsizeCrackerInsertions
comment "Get the size of the pending insertions of the cracker BAT of b";

command sizeCrackerDeletions(b:bat[:any_1,:@2]):void
address CRKsizeCrackerDeletions
comment "Get the size of the pending deletions of the cracker BAT of b";

command insertionsForget(b:bat[:any_1,:@2], c:bat[:any_1,:@2]):void
address CRKmergeInsertions_Forget
comment "Append c to the cracked BAT of b and completelly forget the cracker index";

command insertionsBOnNeed(b:bat[:any_1,:@2], c:bat[:any_1,:@2]):void
address CRKmergeInsertionsB_OnNeed
comment "Keep the insertions BAT separatelly and do a complete merge 
         only if a relevant query arrives in the future";

command insertionsBOnNeedGradually(b:bat[:any_1,:@2], c:bat[:any_1,:@2]):void
address CRKmergeInsertionsB_OnNeedGradually
comment "Keep the insertions BAT separatelly and merge only what is 
         needed if a relevant query arrives in the future";

command insertionsBOnNeedGraduallyRipple(b:bat[:any_1,:@2], c:bat[:any_1,:@2]):void
address CRKmergeInsertionsB_OnNeedGraduallyRipple
comment "Keep the insertions BAT separatelly and merge only what is needed 
         using the ripple strategy if a relevant query arrives in the future";

command deletionsOnNeed(b:bat[:any_1,:@2], c:bat[:any_1,:@2]):void
address CRKmergeDeletions_OnNeed
comment "Keep the deletions BAT separatelly and do a complete merge only 
         if a relevant query arrives in the future";

command deletionsOnNeedGradually(b:bat[:any_1,:@2], c:bat[:any_1,:@2]):void
address CRKmergeDeletions_OnNeedGradually
comment "Keep the deletions BAT separatelly and merge only what is 
         needed if a relevant query arrives in the future";

command deletionsOnNeedGraduallyRipple(b:bat[:any_1,:@2], c:bat[:any_1,:@2]):void
address CRKmergeDeletions_OnNeedGraduallyRipple
comment "Keep the deletions BAT separatelly and merge only what is 
         needed using ripple if a relevant query arrives in the future";

command extendCrackerBAT(b:bat[:any_1,:@2], P:lng):void
address CRKextendCrackerBAT
comment "Extend the cracker column by P positions";
@
@= Index
command printCrackerIndexBATpart(b:bat[:any_1,:@2]):void
address CRKprintCrackerIndexBATpart
comment "Print the cracker index of b";

command printCrackerBAT(b:bat[:any_1,:@2]):void
address CRKprintCrackerBAT
comment "Print the cracker BAT of b";

command getCrackerBAT(b:bat[:oid,:@2]):bat[:oid,:@2]
address CRKgetCrackerBAT
comment "Get the cracker BAT of b";

command printAVLTree_int(b:bat[:any_1,:@2]):void
address CRKprintAVLTree_int
comment "Print the AVL Tree of the cracker index (for debugging purposes)";
@
@= CoreOrdered
command zcrackOrdered (b:bat[:oid,:@2], mid:@2) :bat[:oid,:@2]
address CRKcrackOrderedZero_@2
comment "Break a BAT into two pieces with
	 tail<=mid, tail>mid,
	 respectively; maintaining the head-oid order within each piece.";

command crackOrdered (b:bat[:oid,:@2], mid:@2) :bat[:oid,:@2]
address CRKcrackOrderedOne_@2
comment "Break a BAT into three pieces with
	 tail<mid, tail==mid, tail>mid,
	 respectively; maintaining the head-oid order within each piece.";

command zcrackOrdered (b:bat[:oid,:@2], low:@2, hgh:@2) :bat[:oid,:@2]
address CRKcrackOrderedThree_@2
comment "Break a BAT into three pieces with
	 tail<=low, low<tail<=hgh, tail>hgh,
	 respectively; maintaining the head-oid order within each piece.";
@
@= CoreUnordered
command zcrackUnordered (b:bat[:oid,:@2], mid:@2) :bat[:oid,:@2]
address CRKcrackUnorderedZero_@2
comment "Break a BAT into two pieces with
	 tail<=mid, tail>mid,
	 respectively.";

command zcrackUnordered (b:bat[:oid,:@2], low:@2, hgh:@2) :bat[:oid,:@2]
address CRKcrackUnorderedThree_@2
comment "Break a BAT into three pieces with
	 tail<=low, low<tail<=hgh, tail>hgh,
	 respectively.";
@
@= Validate
@:crack_validate(@2,Ordered,; maintaining the head-oid order within each piece)@
@:crack_validate(@2,Unordered,)@

command verifyCrackerIndex(b:bat[:any_1,:@2]):void
address CRKverifyCrackerIndex_@2
comment "Check the cracker index and column, whether each value is in the correct chunk";
@
@= crack_validate
command zcrack@2_validate (b:bat[:oid,:@1], mid:@1) :bit
address CRKcrack@2Zero_validate_@1
comment "Validate whether a BAT is correctly broken into two pieces with
	 tail<=mid, tail>mid,
	 respectively@3.";

command crack@2_validate (b:bat[:oid,:@1], mid:@1) :bit
address CRKcrack@2One_validate_@1
comment "Validate whether a BAT is correctly broken into three pieces with
	 tail<mid, tail==mid, tail>mid,
	 respectively@3.";

command crack@2_validate (b:bat[:oid,:@1], low:@1, hgh:@1) :bit
address CRKcrack@2Two_validate_@1
comment "Validate whether a BAT is correctly broken into five pieces with
	 tail<low, tail==low, low<tail<hgh, tail==hgh, tail>hgh,
	 respectively@3.";

command zcrack@2_validate (b:bat[:oid,:@1], low:@1, hgh:@1) :bit
address CRKcrack@2Three_validate_@1
comment "Validate whether a BAT is correctly broken into three pieces with
	 tail<=low, low<tail<=hgh, tail>hgh,
	 respectively@3.";
@
@= Sideways
command getMap( b:bat[:oid,:@1], bp:bat[:oid,:@2] ):bat[:@1,:@2]
address getCrackerMap
comment "Get a certain map";

command DeleteMap( b:bat[:oid,:@1], bp:bat[:oid,:@2] ):void
address DeleteCrackerMap
comment "Throw away a certain map"; 

command insert( b:bat[:oid,:@1], bp:bat[:oid,:@2], c:bat[:@1,:@2]):void
address CRKinsert
comment "Keep the insertions BAT separatelly and merge in the future on demand with the Ripple";

command printPendingInsertions( b:bat[:oid,:@1], bp:bat[:oid,:@2]):void
address CRKprintPendingInsertions
comment "Print the pending insertions";

command extendCrackerMap(b:bat[:oid,:@1], bp:bat[:oid,:@2], P:lng):void
address CRKextendCrackerMap
comment "Extend the cracker map by P positions";

command sizePendingInsertions(b:bat[:oid,:@1], bp:bat[:oid,:@2]):void
address CRKsizePendingInsertions
comment "Get the size of the pending insertions for this map";



command hselect(b:bat[:oid,:@1],bp:bat[:oid,:@2],l:@1,h:@1,li:bit,hi:bit):bat[:oid,:@1]
address CRKhselectBoundsSideways_@1_@2
comment "Retrieve the subset head using a cracker
        index producing preferably a BATview.";

command tselect(b:bat[:oid,:@1],bp:bat[:oid,:@2],l:@1,h:@1,li:bit,hi:bit):bat[:oid,:@2]
address CRKtselectBoundsSideways_@1_@2
comment "Retrieve the subset tail using a cracker
        index producing preferably a BATview.";

command dselect(b:bat[:oid,:@1],bp:bat[:oid,:@2],l:@1,h:@1,li:bit,hi:bit,l2:@2,h2:@2,li2:bit,hi2:bit):bat[:oid,:bit]
address CRKdselectBoundsSideways_@1_@2
comment "Crack based on @1 and evaluate the @2 disjunctive predicate outside the cracked area. Return a bit vector.";


command joinselect( b:bat[:oid,:@1],bp:bat[:oid,:@2], pivot:bat[:oid,:bit], cl:@1, ch:@1, cli:bit, chi:bit, l:@2, h:@2, li:bit, hi:bit ):bat[:oid,:bit]
address CRKjoinSelectSideways_P_@1_@2
comment "Use the pivot. For each tuple in pivot with a 1, check if the respective tuple (in the same position)
	 in the tail of cpair satisfies the range restriction. If not mark the pivot BUN as 0.";

command jointhetaselect( b:bat[:oid,:@1],bp:bat[:oid,:@2], pivot:bat[:oid,:bit], cl:@1, ch:@1, cli:bit, chi:bit, l:@2, op:str):bat[:oid,:bit]
address CRKjointhetaSelectSideways_P_@1_@2
comment "Use the pivot. For each tuple in pivot with a 1, check if the respective tuple (in the same position)
	 in the tail of cpair satisfies the range restriction. If not mark the pivot BUN as 0.";

command djoinselect( b:bat[:oid,:@1],bp:bat[:oid,:@2], pivot:bat[:oid,:bit], l:@2, h:@2, li:bit, hi:bit ):bat[:oid,:bit]
address CRKdjoinSelectSideways_P_@1_@2
comment "Use the pivot. For each tuple in pivot with a 0, check if the respective tuple (in the same position)
	 in the tail of cpair satisfies the range restriction. If yes mark the pivot BUN as 1.";


command project( b:bat[:oid,:@1],bp:bat[:oid,:@2], l:@1,h:@1,li:bit,hi:bit):bat[:oid,:@2]
address CRKProjectCrack_@1_@2
comment "Sync map and project the tail";

command project( b:bat[:oid,:@1],bp:bat[:oid,:@2],pivot:bat[:oid,:bit],l:@1,h:@1,li:bit,hi:bit):bat[:oid,:@2]
address CRKProject_@1_@2
comment "Sync map and project tail based on pivot";

command projectH( b:bat[:oid,:@1],bp:bat[:oid,:@2],pivot:bat[:oid,:bit],l:@1,h:@1,li:bit,hi:bit):bat[:oid,:@1]
address CRKProjectH_@1_@2
comment "Sync map and project head based on pivot";

command positionproject( b:bat[:oid,:@1],bp:bat[:oid,:@2],PositionPivot:bat[:oid,:oid],l:@1,h:@1,li:bit,hi:bit):bat[:oid,:@2]
address CRKPositionProject_@1_@2
comment "Sync the cracking pair and project the tail. The pivot holds the positions to be projected";

command markedproject( b:bat[:oid,:@1],bp:bat[:oid,:@2],pivot:bat[:oid,:bit],l:@1,h:@1,li:bit,hi:bit):bat[:oid,:@2]
address CRKMarkedProject_@1_@2
comment "Sync the cracking pair and project the tail. The result bat has a marked head";

command dproject( b:bat[:oid,:@1],bp:bat[:oid,:@2],pivot:bat[:oid,:bit]):bat[:oid,:@2]
address CRKdProject_@1_@2
comment "Sync the cracking pair and project the tail. Use for disjunctive queries that require a larger bit vector";

command dprojectH( b:bat[:oid,:@1],bp:bat[:oid,:@2],pivot:bat[:oid,:bit]):bat[:oid,:@1]
address CRKdProjectH_@1_@2
comment "Sync the cracking pair and project the head. Use for disjunctive queries that require a larger bit vector";

command positionproject( b:bat[:oid,:@1],bp:bat[:oid,:@2],pivot:bat[:oid,:oid]):bat[:oid,:@2]
address CRKdPositionProject_@1_@2
comment "Sync the cracking pair and project the tail. Use position based pivot";

command pmselect(b:bat[:oid,:@1],bp:bat[:oid,:@2],l:@1,h:@1,li:bit,hi:bit,l2:@2,h2:@2,li2:bit,hi2:bit):bat[:oid,:bit]
address CRKselectBoundsIncrementalSideways_@1_@2
comment "Crack based on @1 and evaluate the @2 conjunctive predicate. Return a bit vector.";

command pmtselect(b:bat[:oid,:@1],bp:bat[:oid,:@2],l:@1,h:@1,li:bit,hi:bit):bat[:oid,:@2]
address CRKselectBoundsTailIncrementalSideways_@1_@2
comment "Crack based on @1 and project the @2 tail .";

command pmjoinselect(b:bat[:oid,:@1],bp:bat[:oid,:@2], pivot:bat[:oid,:bit], cl:@1, ch:@1, cli:bit, chi:bit, l:@2, h:@2, li:bit, hi:bit ):bat[:oid,:bit]
address CRKjoinSelectIncrementalSideways_@1_@2
comment "Use the pivot. For each tuple in pivot with a 1, check if the respective tuple (in the same position)
	 in the tail of cpair(collection of pieces) satisfies the range restriction. If not mark the pivot BUN as 0.";

command pmproject(b:bat[:oid,:@1],bp:bat[:oid,:@2],pivot:bat[:oid,:bit],l:@1,h:@1,li:bit,hi:bit):bat[:oid,:@2]
address CRKProjectIncrementalSideways_@1_@2
comment "Sync the map and project the tail based on the pivot";

command pmmaxTail(b:bat[:oid,:@1],bp:bat[:oid,:@2],l:@1,h:@1,li:bit,hi:bit):bat[:oid,:@2]
address CRKMaxTailIncrementalSideways_@1_@2
comment "Sync/crack the map and get the max of the tail";

command pmaddReference(b:bat[:oid,:@1],bp:bat[:oid,:@2]):void
address CRKaddReference
comment "add bp reference to map set of b";

command pmclearReferences(b:bat[:oid,:@1]):void
address CRKclearReferences
comment "clear all references to b";

command fmaddReference(b:bat[:oid,:@1],bp:bat[:oid,:@2]):void
address CRKaddReferenceFullMaps
comment "add bp reference to map set of b";

command fmcreateMap(b:bat[:oid,:@1],bp:bat[:oid,:@2]):void
address CRKcreateFullMap_@1_@2
comment "make new map for debugging";
@
@= AVLindex
command buildAVLIndex(b:bat[:any_1,:@2]):void
address CRKmakeAVLIndex_@2
comment "Create an AVL tree index for this BAT";

command InsertAVLIndex(b:bat[:any_1,:@2], u:bat[:any_1,:@2]):void
address CRKInsertAVLIndex_@2
comment "Insert u in the AVL tree index of BAT b";

command selectAVL(b:bat[:any_1,:@2],l:any_2,h:any_3,li:any_4,hi:any_5):bat[:any_6,:@2]
address CRKAVLIndexSelectBounds_@2
comment "Retrieve the subset using the AVL index";

command deleteAVL(b:bat[:any_1,:@2],u:bat[:any_2,:@2]):void
address CRKdeleteFromAVL_@2
comment "Delete a collection of values from the index";
@
@= Joins1
command simpleJoin(b1:bat[:oid,:@1],b2:bat[:oid,:@2],b3:bat[:oid,:@1],b4:bat[:oid,:@2]):bat[:oid,:oid]
address CRKsimpleJoin_@1_@2
comment "Join two maps based on head values by exploiting the already existing partitioning information";

command crackJoin(b1:bat[:oid,:@1],b2:bat[:oid,:@2],b3:bat[:oid,:@1],b4:bat[:oid,:@2]):bat[:oid,:oid]
address CRKcrackJoin_@1_@2
comment "Join two maps based on head values. Align the maps to avoid overlapping pieces";

command cacheConsciousCrackHashJoin(b1:bat[:oid,:@1],b2:bat[:oid,:@2],b3:bat[:oid,:@1],b4:bat[:oid,:@2],pieceSize:lng,joinThreshold:lng):bat[:oid,:oid]
address CRKcacheConsciousCrackHashJoin_@1_@2
comment "Join two maps based on head values. Align the maps to avoid overlapping pieces. Reuse hash tables";

command activeCacheConsciousCrackHashJoin(b1:bat[:oid,:@1],b2:bat[:oid,:@2],b3:bat[:oid,:@1],b4:bat[:oid,:@2],pieceSize:lng,joinThreshold:lng, minLeft:@1, maxLeft:@1, minRight:@1, maxRight:@1, mode:int):bat[:oid,:oid]
address CRKactiveCacheConsciousCrackHashJoin_@1_@2
comment "Join two maps based on head values with active cracking. Align the maps to avoid overlapping pieces. Reuse hash tables";

command activeCrackSortMergeJoin(b1:bat[:oid,:@1],b2:bat[:oid,:@2],b3:bat[:oid,:@1],b4:bat[:oid,:@2],pieceSize:lng,joinThreshold:lng, minLeft:@1, maxLeft:@1, minRight:@1, maxRight:@1, mode:int):bat[:oid,:oid]
address CRKactiveCrackSortMergeJoin_@1_@2
comment "Join two maps based on head values with active cracking. Align the maps to avoid overlapping pieces. Sort small pieces and use merge join";

command activeJoin(b1:bat[:@1,:@2], reuseLeft:bit, b3:bat[:@1,:@2],reuseRight:bit,pieceSize:lng):bat[:oid,:oid]
address CRKactiveJoin_@1_@2
comment "Join two maps based on head values with active cracking. Align the maps to avoid overlapping pieces. Reuse hash tables";

command cacheConsciousCrackHashJoinAlignOnly(b1:bat[:oid,:@1],b2:bat[:oid,:@2],b3:bat[:oid,:@1],b4:bat[:oid,:@2],pieceSize:lng,joinThreshold:lng):bat[:oid,:oid]
address CRKcacheConsciousCrackHashJoinAlignOnly_@1_@2
comment "Join two maps based on head values. Align the maps to avoid overlapping pieces. Reuse hash tables";

command crackHashJoin(b1:bat[:oid,:@1],b2:bat[:oid,:@2],b3:bat[:oid,:@1],b4:bat[:oid,:@2]):bat[:oid,:oid]
address CRKcrackHashJoin_@1_@2
comment "Join two maps based on head values. Align the maps to avoid overlapping pieces. Reuse hash tables";

command fullAlignment(b1:bat[:oid,:@1],b2:bat[:oid,:@1],b3:bat[:oid,:@2]):void
address CRKFullAlignment_@1_@2
comment "Align a bat with the cracks on a map";

command alignJoin(b1:bat[:oid,:@1],b2:bat[:oid,:@1],b3:bat[:oid,:@2]):bat[:oid,:oid]
address CRKAlignJoin_@1_@2
comment "Join and on the fly align a map with an intermediate result bat, i.e., not cracked";

@
@= Joins2

command bandJoin(b1:bat[:oid,:@1],b2:bat[:oid,:@1],c1:@1,c2:@1,inclusiveLow:bit,inclusiveHgh:bit):bat[:oid,:oid]
address CRKbandJoin_@1
comment "Band Join two maps based on head values. 
	Continuously crack the right BAT for each tuple of the left one";

command sortBandJoin(b1:bat[:oid,:@1],b2:bat[:oid,:@1],c1:@1,c2:@1,inclusiveLow:bit,inclusiveHgh:bit):bat[:oid,:oid]
address CRKsortBandJoin_@1
comment "Band Join two maps based on head values. 
	First sort the right BAT and then continuously binary search the right BAT for each tuple of the left one";

command materializeHead(b:bat[:oid,:@1]) :void
address CRKmaterializeH
comment "Materialize the head of BAT b";

@
@h
/*
 * @- Header file
 */
#ifndef _CRACKERS_H_
#define _CRACKERS_H_

/*#define DEBUG_CRACKERS*/
/*#define DEBUG_CRACKERS_INSERTIONS*/

#ifdef WIN32
#ifndef LIBCRACKERS
#define crackers_export extern __declspec(dllimport)
#else
#define crackers_export extern __declspec(dllexport)
#endif
#else
#define crackers_export extern
#endif

#include "mtime.h"
#include "crackers_index.h"
#include "crackers_select_ops.h"
#include "crackers_joinselect_ops.h"
#include "crackers_sideways.h"
#include "crackers_updates.h"
#include "crackers_validation.h"
#include "crackers_core_unordered.h"
#include "crackers_core_ordered.h"
#include "crackers_AVL_tree.h"
#include "crackers_AVL_index.h"
#include "crackers_joins.h"
#include "crackers_sortmerge.h"
#include "crackers_crackmerge.h"
#include "crackers_pq.h"
#include "crackers_populate.h"

#ifdef LIBCRACKERS 
extern int maxCrackMap;
extern CrackerIndexNode *CrackerIndex;
extern int IndexEntries;
extern int IndexSize;
extern int IndexStop;
extern struct storageManagement *StorageInfo;
#endif

#endif /* _CRACKERS_H */


@c
/*
 * @+ Implementation
 *
 * @- C file
 */
#include "monetdb_config.h"
#include "crackers.h"

int maxCrackMap = 0;

CrackerIndexNode *CrackerIndex;

struct storageManagement *StorageInfo = NULL;

int IndexEntries = 20000000; /* Initial size used for the bat that stores index values */

/* Temp variables used to test the effect of stop updating the index, they operate only on one cracker bat */
int IndexSize = 0;
int IndexStop = 10000000;
