@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2011 MonetDB B.V.
All Rights Reserved.
@

@f crackers_joins
@a Martin Kersten, Stratos Idreos, Stefan Manegold
@d March 2006 - July 2007
@* Cracker Joins 


@+ Interface


@- Type expansion

@= TypeSwitch_1
@:@1(int,simple,,int,int)@
@:@1(int,simple,,int,oid)@
@

@= TypeSwitch_2
@:@1(int,simple,,int)@
@

@- Header file

@h
#ifndef _CRACKERS_JOINS_H_
#define _CRACKERS_JOINS_H_
/* Exported signatures */
@:TypeSwitch_1(JoinFunctions_decl1)@
@:TypeSwitch_2(JoinFunctions_decl2)@
crackers_export str CRKbatCount(lng *count, int *bid);
crackers_export str CRKmaterializeH(int *res, int *bid);

/* #define DEBUG_CRACKERS_JOIN 		to enable debug trace */
 #define TIMER_CRACKERS_JOIN 		to enable timing pieces 
#endif /* _CRACKERS_JOINS_H */
@

@- Exported signatures

@= JoinFunctions_decl1
crackers_export str CRKsimpleJoin_@1_@5(int *res, int *bidL1, int *bidL2, int *bidR1, int *bidR2);
crackers_export str CRKcrackJoin_@1_@5(int *res, int *bidL1, int *bidL2, int *bidR1, int *bidR2);
crackers_export str CRKcrackHashJoin_@1_@5(int *res, int *bidL1, int *bidL2, int *bidR1, int *bidR2);
crackers_export str CRKcacheConsciousCrackHashJoin_@1_@5(int *res, int *bidL1, int *bidL2, int *bidR1, int *bidR2, lng *pieceSize, lng *joinThreshold);
crackers_export str CRKactiveCacheConsciousCrackHashJoin_@1_@5(int *res, int *bidL1, int *bidL2, int *bidR1, int *bidR2, lng *pieceSize, lng *joinThreshold, @1 *minLeft, @1 *maxLeft, @1 *minRight, @1 *maxRight, int *mode);
crackers_export str CRKactiveCrackSortMergeJoin_@1_@5(int *res, int *bidL1, int *bidL2, int *bidR1, int *bidR2, lng *pieceSize, lng *joinThreshold, @1 *minLeft, @1 *maxLeft, @1 *minRight, @1 *maxRight, int *mode);
crackers_export str CRKactiveJoin_@1_@5(int *res, int *bidLeft, bit *makeLeft, int *bidRight, bit *makeRight, lng *pieceSize);
crackers_export str CRKcacheConsciousCrackHashJoinAlignOnly_@1_@5(int *res, int *bidL1, int *bidL2, int *bidR1, int *bidR2, lng *pieceSize, lng *joinThreshold);
crackers_export str CRKFullAlignment_@1_@5(int *res, int *bidL, int *bidR1, int *bidR2);
crackers_export str CRKAlignJoin_@1_@5(int *res, int *bidL, int *bidR1, int *bidR2);
@

@= JoinFunctions_decl2
crackers_export str CRKbandJoin_@1(int *resid, int *bidL, int *bidR, @1 *c1, @1 *c2, bit *inclusiveLow, bit *inclusiveHgh);
crackers_export str CRKsortBandJoin_@1(int *resid, int *bidL, int *bidR, @1 *c1, @1 *c2, bit *inclusiveLow, bit *inclusiveHgh);
@

@{
@+ Implementation


@- C file

@c
#include "monetdb_config.h"
#include "crackers.h"
#include "bat5.h"
#define SAMPLE_TRESHOLD_LOG 17
#define SAMPLE_SLICE_SIZE 1000

/* Local support functions and macros */
@= joinestimate
	if (@3 == BUN_NONE) {
		BUN _lcount = BATcount(l);
		BUN _rcount = BATcount(r);
		BUN _slices = 0;

		/* limit estimate with simple bounds first; only spend effort if the join result might be big */
		if (@1 == JOIN_EQ) {
			if (l->tkey)
				@3 = r->hkey ? MIN(_rcount, _lcount) : _rcount;
			else if (r->hkey)
				@3 = _lcount;
		}
		if (@3 == BUN_NONE) {
			BUN _heuristic = MIN(_lcount, _rcount);

			if (_heuristic <= BUN_MAX / 3) {
				_heuristic *= 3;
				if (_heuristic <= (1 << SAMPLE_TRESHOLD_LOG))
					@3 = _heuristic;
			}
		}
		if (@3 == BUN_NONE) {
			BUN _idx;

			for (_idx = _lcount; _idx > 0; _idx >>= 1)
				_slices++;
		}
		if (_slices > SAMPLE_TRESHOLD_LOG) {
			/* use cheapo sampling by taking a number of slices and joining those with the algo */
			BUN _idx = 0, _tot = 0, _step, _lo, _avg, _sample, *_cnt;
			BAT *_tmp1 = l, *_tmp2, *_tmp3 = NULL;

			_step = _lcount / (_slices -= SAMPLE_TRESHOLD_LOG);
			_sample = _slices * SAMPLE_SLICE_SIZE;
			_cnt = (BUN *) alloca(_slices * sizeof(BUN));
			for (_lo = 0; _idx < _slices; _lo += _step) {
				BUN _size = 0, _hi = _lo + SAMPLE_SLICE_SIZE;

				l = BATslice(_tmp1, _lo, _hi);	/* slice keeps all parent properties */
				if (l == NULL)
					return NULL;
				_tmp2 = @2;	/* @2 = e.g. BATXjoin(l,r) */
				if (_tmp2) {
					_size = BATcount(_tmp2);
					BBPreclaim(_tmp2);
				}
				_tot += (_cnt[_idx++] = _size);
				BBPreclaim(l);
			}
			/* do outlier detection on sampling results; this guards against skew */
			if (@1 == JOIN_EQ) {
				for (_avg = _tot / _slices, _idx = 0; _idx < _slices; _idx++) {
					BUN _diff = _cnt[_idx] - _avg;

					if (_avg > _cnt[_idx])
						_diff = _avg - _cnt[_idx];
					if (_diff > MAX(SAMPLE_SLICE_SIZE, _avg))
						break;
				}
				if (_idx < _slices) {
					/* outliers detected, compute a real sample on at most 1% of the data */
					_sample = MIN(_lcount / 100, (1 << SAMPLE_TRESHOLD_LOG) / 3);
					_tmp2 = BATsample(_tmp1, _sample);
					if (_tmp2) {
						_tmp3 = BATjoin(_tmp2, r, BUN_NONE);	/* might be expensive */
						if (_tmp3) {
							_tot = BATcount(_tmp3);
							BBPreclaim(_tmp3);
						}
						BBPreclaim(_tmp2);
					}
					if (_tmp3 == NULL)
						return NULL;
				}
			}
			/* overestimate always by 5% */
			{
				double _d = (double) (((lng) _tot) * ((lng) _lcount)) / (0.95 * (double) _sample);
				if (_d < (double) BUN_MAX)
					@3 = (BUN) _d;
				else
					@3 = BUN_MAX;
			}
			l = _tmp1;
		} else {
			BUN _m = MIN(_lcount,_rcount);
			if (_m <= BUN_MAX / 32)
				_m *= 32;
			else
				_m = BUN_MAX;
			@3 = MIN(_m,MAX(_lcount,_rcount));
		}
	}
@c
#define BATPERC(lfirst,lcur,lend,rfirst,rcur,rend)\
		((((dbl) (lend-lfirst))*((dbl) (rend-rfirst))) / \
		 MAX(1,((lcur-lfirst)*((dbl) (rend-rfirst))+(dbl) (rcur-rfirst))))

#define bunfastins_limit(b, h, t, limit, percdone) {			\
                register BUN _p = BUNlast(b);				\
		if (_p == BUN_MAX) /* reached maximum, can't do more */	\
			goto bunins_done;				\
                if (_p + 1 > BATcapacity(b)) {				\
                        if (limit) {					\
				*limit = (BUN) (b->batCount * (percdone)); \
                              goto bunins_done;				\
			}						\
                        if (BATextend(b, BATgrows(b)) == NULL)		\
                                goto bunins_failed;			\
                }							\
                hfastins_nocheck(b, _p, h, Hsize(b));			\
                tfastins_nocheck(b, _p, t, Tsize(b));			\
                (b)->batCount++;					\
        }
@= mergejoin
	if (((!BATtvoid(l)) || l->tseqbase != oid_nil) &&
	    ((!BAThvoid(r)) || r->hseqbase != oid_nil || nil_on_miss)) {
		assert(r->htype != TYPE_void);
		while (l_start < l_last) {
			ptr v2, v1 = BUNt@2(li, l_start);
			int neq = 1;

			/* lookup range in l */
			l_end = l_start;
			if (l_key) {
				l_end++;
			} else
				do {
					if ((++l_end) >= l_last)
						break;
					v2 = BUNt@2(li, l_end);
				} while (@1_EQ(v1, v2, @4));

			/* lookup value in r (if not nil, that is) */
			if (!@1_EQ(v1, nil, @4)) {
				if (r_scan > 0) {
					/* first try scanning; but give up after a while */
					for (r_lim = MIN(r_last, r_end + r_scan); r_end < r_lim; r_end++) {
						v2 = BUNh@3(ri, r_end);
						neq = @1_CMP(v1, v2, @4);
						if (neq <= 0)
							break;
					}
					r_start = r_end;
				}
				if (neq == 1) {
					/* use binary search after failed scan or if scanning is impossible (l not sorted) */
					if (r_scan < 0 || r_start < r_last) {
						/* if merge not ended (or if no merge at all) */
						r_start = (BUN) SORTfndfirst_@4(rr, v1);
					}
					if (r_start < r_last) {
						v2 = BUNh@3(ri, r_start);
						neq = !@1_EQ(v1, v2, @4);
					} else if (r_scan >= 0) {
						/* r is already at end => break off merge join */
						break;
					}
				}
			}
			if (neq == 0) {
				/* lookup range in r */
				r_end = r_start+1;
				if (r_key == 0)
					while (r_end < r_last) {
						v2 = BUNh@3(ri, r_end);
						if (!@1_EQ(v1, v2, @4))
							break;
						r_end++ ;
					}
				/* generate match-product as join result */
				for (; l_start < l_end; l_start++)
					for (r_cur = r_start; r_cur < r_end; r_cur++)
						bunfastins_limit(bn, BUNhead(li, l_start), BUNtail(ri, r_cur), limit, BATPERC(BUNfirst(l),l_start,BUNlast(l),r_start,r_cur,r_end));
			} else if (nil_on_miss) {
				/* outerjoin inserts nils on a miss */
				for (; l_start < l_end; l_start++)
					bunfastins_limit(bn, BUNhead(li, l_start), nil_on_miss, limit, BATPERC(BUNfirst(l),l_start,BUNlast(l),0,1,1));
			} else {
				l_start = l_end;	/* no match found in equi-join */
			}
		}
	}
@c
/* serves both normal equi-join (nil_on_miss==NULL) and outerjoin (nil_on_miss=nil) */
lng
CRKmergejoin(BAT *bn,BAT *l, BAT *r){
	ptr nil_on_miss=NULL;
	BUN *limit =NULL;
	lng T1=GDKusec(), T2;

	ptr nil = ATOMnilptr(r->htype);
	int r_scan = -1;	/* no scanning in r */
	BAT *rr = BATmirror(r);
	BUN l_last, r_last;	/* last BUN of the BAT */
	BUN l_start, r_start;	/* start of current chunk  */
	BUN l_end, r_end;	/* end of current chunk */
	int l_key = l->tkey;
	int r_key = r->hkey;
	BUN r_cur, r_lim;
	int loc, var;
	BATiter li = bat_iterator(l);
	BATiter ri = bat_iterator(r);

	if (BATtordered(l) & 1) {
		BUN i;
		int logr = 4;

		/* 4*log2(r.count) = estimation of the cost of binary search in units of scan comparisons */
		for (i = BATcount(r); i > 0; logr++)
			i >>= 1;
		r_scan = logr;	/* opportunistic scan window in r */
	}

	/* the algorithm */
	loc = ATOMstorage(l->ttype);

	l_last = BUNlast(l);
	r_last = BUNlast(r);
	l_start = l_end = BUNfirst(l);
	r_start = r_end = BUNfirst(r);

	switch (loc) {
#ifndef NOEXPAND_CHR
	case TYPE_chr:
		@:mergejoin(simple,loc,loc,chr)@
		break;
#endif
#ifndef NOEXPAND_BTE
	case TYPE_bte:
		@:mergejoin(simple,loc,loc,bte)@
		break;
#endif
#ifndef NOEXPAND_SHT
	case TYPE_sht:
		@:mergejoin(simple,loc,loc,sht)@
		break;
#endif
#ifndef NOEXPAND_INT
	case TYPE_int:
		@:mergejoin(simple,loc,loc,int)@
		break;
#endif
#ifndef NOEXPAND_FLT
	case TYPE_flt:
		@:mergejoin(simple,loc,loc,flt)@
		break;
#endif
#ifndef NOEXPAND_LNG
	case TYPE_lng:
		@:mergejoin(simple,loc,loc,lng)@
		break;
#endif
#ifndef NOEXPAND_DBL
	case TYPE_dbl:
		@:mergejoin(simple,loc,loc,dbl)@
		break;
#endif
	default:
		/* watch it: l->tvarsized may be set due to void l */
		if (l->tvarsized) {
			var = ATOMstorage(l->ttype);

			if (r->hvarsized) {
				/* l and r both real varsized types */
				@:mergejoin(atom,var,var,var)@
			} else {
				/* l is void, r is oid */
				loc = ATOMstorage(r->htype);
				@:mergejoin(atom,var,loc,loc)@
			}
		} else {
			/* we can't handle void r anyway, so don't worry about it here */
			loc = ATOMstorage(l->ttype);
			@:mergejoin(atom,loc,loc,loc)@
		}
		break;
	}

	if (nil_on_miss && l_start < l_last) {
		for (; l_start < l_last; l_start++)
			bunfastins_limit(bn, BUNhead(li, l_start), nil_on_miss, limit, BATPERC(BUNfirst(l),l_start,BUNlast(l),0,1,1));
	}
	/* propagate properties */
      bunins_done:
      bunins_failed:
	T2=GDKusec();
	return T2-T1;
}

@= hashjoin
	{
                BUN yy;

                BATloop(l, p, q) {
                        v = BUN@3(li, p);
                        if (@1_EQ(v, nil, @4)) {
                                continue; /* skip nil */
                        }
                        HASHloop_@2(ri, r->H->hash, yy, v) {
                                bunfastins(bn, BUNhead(li, p), BUNtail(ri, yy));
                        }
                }
                /* set sorted flags by hand, because we used BUNfastins() */
                bn->hsorted = BAThordered(l);
                bn->tsorted = FALSE;
                break;
	}

@c

lng
CRKjoin(BAT *bn, BAT *l, BAT *r) {
	ptr v, nil = ATOMnilptr(r->htype);
	BUN p, q;
	int any;
	lng T1=GDKusec(), T2;
	BATiter li = bat_iterator(l);
        BATiter ri = bat_iterator(r);

	BATaccessBegin(r, USE_HEAD, MMAP_SEQUENTIAL);
	if (BATprepareHash(r)){
		BATaccessEnd(r, USE_HEAD, MMAP_SEQUENTIAL);
		T2=GDKusec();
		return T2-T1;
	}
	BATaccessEnd(r, USE_HEAD, MMAP_SEQUENTIAL);
	BATaccessBegin(r, USE_HEAD|USE_TAIL|USE_HHASH, MMAP_WILLNEED);
	switch (any = ATOMstorage(l->ttype)) {
#ifndef NOEXPAND_CHR
	case TYPE_chr:
		@:hashjoin(simple,chr,tloc,chr)@
#endif
#ifndef NOEXPAND_BTE
	case TYPE_bte:
		@:hashjoin(simple,bte,tloc,bte)@
#endif
#ifndef NOEXPAND_SHT
	case TYPE_sht:
		@:hashjoin(simple,sht,tloc,sht)@
#endif
#if !defined(NOEXPAND_INT) || !defined(NOEXPAND_FLT)
	case TYPE_int:
	case TYPE_flt:
		@:hashjoin(simple,int,tloc,int)@
#endif
#if !defined(NOEXPAND_DBL) || !defined(NOEXPAND_LNG)
	case TYPE_dbl:
	case TYPE_lng:
		@:hashjoin(simple,lng,tloc,lng)@
#endif
	case TYPE_str:
		if (l->T->vheap->hashash) {
			@:hashjoin(atom,str_hv,tail,any)@
		}
		/* fall through */
	default:
		@:hashjoin(atom,any,tail,any)@
	}

      bunins_failed: /* blindly assume bunins does NOT fail*/
	BATaccessEnd(r, USE_HEAD|USE_TAIL|USE_HHASH, MMAP_WILLNEED);
	T2=GDKusec();
	return T2-T1;
}

/* Exported functions */
@:TypeSwitch_2(JoinFunctions_impl_2)@
@:TypeSwitch_1(JoinFunctions_impl_1)@

str CRKbatCount(lng *count, int *bid){
	BAT *b=BATdescriptor(*bid);
	if (b==NULL)
		throw(MAL, "crack bat count", "Cannot access BAT");
	*count = BATcount(b);
	BBPunfix(b->batCacheid);	
	return MAL_SUCCEED;
}

str CRKmaterializeH(int *res, int *bid){
	BAT *b=BATdescriptor(*bid);
	if (b==NULL)
		throw(MAL, "crack materialize head", "Cannot access BAT");
	b=BATmaterializeh(b);
	BBPunfix(b->batCacheid);	
	(void)res;
	return MAL_SUCCEED;
}
@


@- Exported functions

@= JoinTwoPieces
	joinsDone++;
	viewHeadLeft = VIEWhead_(mapLeft,  BAT_READ);
	viewHeadRight = VIEWhead_(mapRight,  BAT_READ);

	viewLeft  = BATslice(viewHeadLeft, prevPosLeft,  curPosLeft +1);
        BBPunfix(viewHeadLeft->batCacheid);

        viewRight = BATslice(viewHeadRight, prevPosRight, curPosRight+1);
        BBPunfix(viewHeadRight->batCacheid);

	markedViewLeft  = (BAT*)BATmark(viewLeft,prevPosLeft);
        BBPunfix(viewLeft->batCacheid);

        markedViewRight = (BAT*)BATmark(viewRight,prevPosRight);
        BBPunfix(viewRight->batCacheid);

	if (curPosLeft - prevPosLeft +1> 0 && curPosRight - prevPosRight+1 > 0) {
		TJtotal+=CRKjoin(BATmirror(res), BATmirror(markedViewRight), markedViewLeft);
	}
/*
printf("Join " LLFMT ", Cost " LLFMT ", Left "OIDFMT" Right "OIDFMT"\n",joinsDone, TJtotal-temp, curPosLeft - prevPosLeft +1, curPosRight - prevPosRight +1);
*/
	BBPunfix(markedViewRight->batCacheid);
	BBPunfix(markedViewLeft->batCacheid);
@

@= dumpIndex
#ifdef DEBUG_CRACKERS_JOIN
	printf("\n @1 \n");
	printAVLTree(CrackerIndex[mapLpos].Tree, indexLeft, baseLeft);
	printf("\n Index Right \n");
	printAVLTree(CrackerIndex[mapRpos].Tree, indexRight, baseRight);
#endif
@

@= JoinTwoSuperPiecesReuseHashTablesIntermediates
#ifdef TIMER_CRACKERS_JOIN
		joinsDone++;
#endif
		markedViewLeft  = BATslice(mapLeft, prevPosLeft,  curPosLeft +1);

	        markedViewRight = BATslice(mapRight, prevPosRight, curPosRight+1);

#ifdef DEBUG_CRACKERS_JOIN
	printf("\n Left \n");
	BATprint(markedViewLeft);
	printf("\n Right \n");
	BATprint(markedViewRight);
#endif
	sizeLeft = curPosLeft - prevPosLeft + 1;
	sizeRight = curPosRight - prevPosRight + 1;

	if (sizeLeft > 0 && sizeRight > 0) {
	(void) joinThreshold;
		if  (sizeLeft < sizeRight){ 
			TJtotal+=CRKjoin(BATmirror(res), BATmirror(markedViewRight), markedViewLeft);
		}else{ 
			TJtotal+=CRKjoin(res, BATmirror(markedViewLeft), markedViewRight);
		}

	}
		BBPunfix(markedViewRight->batCacheid);
		BBPunfix(markedViewLeft->batCacheid);

#ifdef DEBUG_CRACKERS_JOIN
	printf("\n Res \n");
	BATprint(res);
	@:dumpIndex(Index Left)@
#endif
@

@= JoinTwoSuperPiecesReuseHashTablesSortMerge
#ifdef TIMER_CRACKERS_JOIN
		joinsDone++;
#endif
	tempT=GDKusec();
        GDKqsort(Hloc(mapLeft,BUNfirst(mapLeft)+prevPosLeft), Tloc(mapLeft,BUNfirst(mapLeft)+prevPosLeft), (mapLeft->H->vheap)?mapLeft->H->vheap->base:NULL, curPosLeft +1-prevPosLeft, Hsize(mapLeft), Tsize(mapLeft), mapLeft->htype);
        GDKqsort(Hloc(mapRight,BUNfirst(mapRight)+prevPosRight), Tloc(mapRight,BUNfirst(mapRight)+prevPosRight), (mapRight->H->vheap)?mapRight->H->vheap->base:NULL, curPosRight +1-prevPosRight, Hsize(mapRight), Tsize(mapRight), mapRight->htype);
	Tsort+=GDKusec()-tempT;
	markedViewLeft  = BATslice(mapLeft, prevPosLeft,  curPosLeft +1);
	markedViewRight = BATslice(mapRight, prevPosRight, curPosRight+1);

	markedViewLeft->hsorted = TRUE;
	markedViewLeft->tsorted = FALSE;
	markedViewRight->hsorted = TRUE;
	markedViewRight->tsorted = FALSE;
	

#ifdef DEBUG_CRACKERS_JOIN
	printf("\n Left \n");
	BATprint(markedViewLeft);
	printf("\n Right \n");
	BATprint(markedViewRight);
#endif
	sizeLeft = curPosLeft - prevPosLeft + 1;
	sizeRight = curPosRight - prevPosRight + 1;

	if (sizeLeft > 0 && sizeRight > 0) {
	(void) joinThreshold;
		if  (sizeLeft < sizeRight){ 
			TJtotal+=CRKmergejoin(BATmirror(res), BATmirror(markedViewRight), markedViewLeft);
		}else{ 
			TJtotal+=CRKmergejoin(res, BATmirror(markedViewLeft), markedViewRight);
		}

	}
		BBPunfix(markedViewRight->batCacheid);
		BBPunfix(markedViewLeft->batCacheid);

#ifdef DEBUG_CRACKERS_JOIN
	printf("\n Res \n");
	BATprint(res);
	@:dumpIndex(Index Left)@
#endif
@

@= JoinTwoSuperPiecesReuseHashTables
#ifdef TIMER_CRACKERS_JOIN
		joinsDone++;
#endif
	@:dumpIndex(Index Left)@
	/* Exploit existing views if possible */
	invalidateHash=FALSE;
	if (prevNodeLeft != NULL){
		if (prevNodeLeft->slice != -1){
			temp = prevNodeLeft;
			existsHashTableLeft = TRUE;
			while (temp->indexPosition < curPosLeft){
				if (temp->slice != prevNodeLeft->slice){
					invalidateHash=TRUE;
					break;
				}
				if (temp->nextValue==NULL)
					break;
				temp=temp->nextValue;
			}
		}else
			invalidateHash=TRUE;
	}


	if (invalidateHash == TRUE){
		int lastHash=-1;
		existsHashTableLeft = FALSE;
		temp = prevNodeLeft;
		while (temp->indexPosition < curPosLeft){
			if (temp->slice!=-1){
				lastHash=temp->slice;
				BBPdecref(temp->slice,TRUE);
				while (temp->slice==lastHash){
					temp->slice=-1;
					if (temp->nextValue==NULL)
						break;
					temp=temp->nextValue;
				}
				continue;
			}
			if (temp->nextValue==NULL)
				break;
			temp=temp->nextValue;
		}
	}
	if (existsHashTableLeft == FALSE){
		viewHeadLeft = VIEWhead_(mapLeft,  BAT_READ);
		viewLeft  = BATslice(viewHeadLeft, prevPosLeft,  curPosLeft +1);
	        BBPunfix(viewHeadLeft->batCacheid);
		markedViewLeft  = (BAT*)BATmark(viewLeft,prevPosLeft);
	        BBPunfix(viewLeft->batCacheid);
	}
	else {
		if ((markedViewLeft = BATdescriptor(prevNodeLeft->slice)) == NULL)
		        	throw(MAL, "crackers.crackHashJoin", "Cannot access slice");
	}

	invalidateHash=FALSE;
	if (prevNodeRight != NULL){
                if (prevNodeRight->slice != -1){
			temp = prevNodeRight;
			existsHashTableRight = TRUE;
			while (temp->indexPosition < curPosRight){
				if (temp->slice != prevNodeRight->slice){
					invalidateHash=TRUE;
					break;
				}
				if (temp->nextValue==NULL)
					break;
				temp=temp->nextValue;
			}
		}else
			invalidateHash=TRUE;
	}


	if (invalidateHash == TRUE){
		int lastHash=-1;
		existsHashTableRight = FALSE;
		temp = prevNodeRight;
		while (temp->indexPosition < curPosRight){
			if (temp->slice!=-1){
				lastHash=temp->slice;
				BBPdecref(temp->slice,TRUE);
				while (temp->slice==lastHash){
					temp->slice=-1;
					if (temp->nextValue==NULL)
						break;
					temp=temp->nextValue;
				}
				continue;
			}
			if (temp->nextValue==NULL)
				break;
			temp=temp->nextValue;
		}
	}
	if (existsHashTableRight == FALSE){
		viewHeadRight = VIEWhead_(mapRight,  BAT_READ);
	        viewRight = BATslice(viewHeadRight, prevPosRight, curPosRight+1);
	        BBPunfix(viewHeadRight->batCacheid);
        	markedViewRight = (BAT*)BATmark(viewRight,prevPosRight);
	        BBPunfix(viewRight->batCacheid);
	}else{
		if ((markedViewRight = BATdescriptor(prevNodeRight->slice)) == NULL)
			throw(MAL, "crackers.crackHashJoin", "Cannot access slice");
	}

#ifdef DEBUG_CRACKERS_JOIN
	printf("\n Left \n");
	BATprint(markedViewLeft);
	printf("\n Right \n");
	BATprint(markedViewRight);
#endif
	sizeLeft = curPosLeft - prevPosLeft + 1;
	sizeRight = curPosRight - prevPosRight + 1;

	if (sizeLeft > 0 && sizeRight > 0) {
	(void) joinThreshold;
		if (existsHashTableLeft == FALSE && existsHashTableRight == TRUE){
			/* If the size with the hash table does not fit in cache while the other does, then build new hash table on the smaller size */
			if (sizeLeft < sizeRight){
				if (sizeLeft <  (oid)*joinThreshold){
					if  (sizeRight >  (oid)*joinThreshold){
						reversingJoinOrder++;
						TJtotal+=CRKjoin(BATmirror(res), BATmirror(markedViewRight), markedViewLeft);
					}
				}
			}else{	
				TJtotal+=CRKjoin(res, BATmirror(markedViewLeft), markedViewRight);
			}
		}else 
		if (existsHashTableLeft == TRUE && existsHashTableRight == FALSE){
			if (sizeRight < sizeLeft){
				if (sizeRight < (oid)*joinThreshold){
					if  (sizeLeft >  (oid)*joinThreshold){
						reversingJoinOrder++;
						TJtotal+=CRKjoin(res, BATmirror(markedViewLeft), markedViewRight);
					}
				}
			}else{	
				TJtotal+=CRKjoin(BATmirror(res), BATmirror(markedViewRight), markedViewLeft);
			}
		}else{
			if  (sizeLeft < sizeRight){ 
				TJtotal+=CRKjoin(BATmirror(res), BATmirror(markedViewRight), markedViewLeft);
				if (prevNodeLeft != NULL && existsHashTableLeft == FALSE){
					temp = prevNodeLeft;
					while (temp->indexPosition < curPosLeft){

						temp->slice = markedViewLeft->batCacheid;
						if (temp->nextValue==NULL)
							break;
						temp=temp->nextValue;
					}
					BBPincref(markedViewLeft->batCacheid,TRUE);
				}				
			}else{ 
				TJtotal+=CRKjoin(res, BATmirror(markedViewLeft), markedViewRight);
				if (prevNodeRight != NULL && existsHashTableRight == FALSE){
					temp = prevNodeRight;
					while (temp->indexPosition < curPosRight){
						temp->slice = markedViewRight->batCacheid;
						if (temp->nextValue==NULL)
							break;
						temp=temp->nextValue;
					}
					BBPincref(markedViewRight->batCacheid,TRUE);
				}
				
			}

		}
		BBPunfix(markedViewRight->batCacheid);
		BBPunfix(markedViewLeft->batCacheid);
	}

#ifdef DEBUG_CRACKERS_JOIN
	printf("\n Res \n");
	BATprint(res);
	@:dumpIndex(Index Left)@
#endif
@
@= JoinTwoPiecesReuseHashTables
	@:dumpIndex(Index Left)@
	/* Exploit existing views if possible */
	joinsDone++;
	if (prevNodeLeft != NULL){
		if (prevNodeLeft->slice != -1){
			if ((markedViewLeft = BATdescriptor(prevNodeLeft->slice)) == NULL)
		        	throw(MAL, "crackers.crackHashJoin", "Cannot access slice");
			else
				existsHashTableLeft = TRUE;
		}
	}
	if (existsHashTableLeft == FALSE){
		viewHeadLeft = VIEWhead_(mapLeft,  BAT_READ);
		viewLeft  = BATslice(viewHeadLeft, prevPosLeft,  curPosLeft +1);
	        BBPunfix(viewHeadLeft->batCacheid);
		markedViewLeft  = (BAT*)BATmark(viewLeft,prevPosLeft);
	        BBPunfix(viewLeft->batCacheid);
	}

	if (prevNodeRight != NULL){
                if (prevNodeRight->slice != -1){
                        if ((markedViewRight = BATdescriptor(prevNodeRight->slice)) == NULL)
                        	throw(MAL, "crackers.crackHashJoin", "Cannot access slice");
			else
				existsHashTableRight = TRUE;
		}
	}
	if (existsHashTableRight == FALSE){
		viewHeadRight = VIEWhead_(mapRight,  BAT_READ);
	        viewRight = BATslice(viewHeadRight, prevPosRight, curPosRight+1);
	        BBPunfix(viewHeadRight->batCacheid);
        	markedViewRight = (BAT*)BATmark(viewRight,prevPosRight);
	        BBPunfix(viewRight->batCacheid);
	}

#ifdef DEBUG_CRACKERS_JOIN
	printf("\n Left \n");
	BATprint(markedViewLeft);
	printf("\n Right \n");
	BATprint(markedViewRight);
#endif

	if (curPosLeft - prevPosLeft +1> 0 && curPosRight - prevPosRight +1> 0) {
		if (existsHashTableLeft == FALSE && existsHashTableRight == TRUE){
			TJtotal+=CRKjoin(res, BATmirror(markedViewLeft), markedViewRight);
		}else 
		if (existsHashTableLeft == TRUE && existsHashTableRight == FALSE){
			TJtotal+=CRKjoin(BATmirror(res), BATmirror(markedViewRight), markedViewLeft);
		}else{
			if  (curPosLeft - prevPosLeft+1 < curPosRight - prevPosRight+1){ 
				TJtotal+=CRKjoin(BATmirror(res), BATmirror(markedViewRight), markedViewLeft);
				if (prevNodeLeft != NULL && existsHashTableLeft == FALSE){
					prevNodeLeft->slice = markedViewLeft->batCacheid;
					BBPincref(markedViewLeft->batCacheid,TRUE);
				}				
			}else{ 
				TJtotal+=CRKjoin(res, BATmirror(markedViewLeft), markedViewRight);
				if (prevNodeRight != NULL && existsHashTableRight == FALSE){
					prevNodeRight->slice = markedViewRight->batCacheid;
					BBPincref(markedViewRight->batCacheid,TRUE);
				}
				
			}
		}
		BBPunfix(markedViewRight->batCacheid);
		BBPunfix(markedViewLeft->batCacheid);
	}
#ifdef DEBUG_CRACKERS_JOIN
	printf("Join " LLFMT ", Cost " LLFMT ", Left "OIDFMT" Right "OIDFMT" ReuseHash: %d \n",joinsDone, TJtotal-temp, curPosLeft - prevPosLeft +1, curPosRight - prevPosRight +1, (existsHashTableLeft == FALSE && existsHashTableRight == TRUE)?1:0);
	printf("\n Res \n");
	BATprint(res);
	@:dumpIndex(Index Left)@
#endif
@

@= SinglePassJoin
	existsHashTableRight = FALSE;

	if (prevNodeRight != NULL){
                if (prevNodeRight->slice != -1){
			temp = prevNodeRight;
			existsHashTableRight = TRUE;
			while (temp->indexPosition != curPosRight){
				if (temp->slice != prevNodeRight->slice)
					existsHashTableRight = FALSE;
				if (temp->nextValue==NULL)
					break;
				temp=temp->nextValue;
			}
		
		}
	}
	if (existsHashTableRight == FALSE){
		viewHeadRight = VIEWhead_(mapRight,  BAT_READ);
	       	viewRight = BATslice(viewHeadRight, prevPosRight, curPosRight+1);
	       	BBPunfix(viewHeadRight->batCacheid);
		markedViewRight = (BAT*)BATmark(viewRight,prevPosRight);
		BBPunfix(viewRight->batCacheid);


	}else{
		if ((markedViewRight = BATdescriptor(prevNodeRight->slice)) == NULL)
			throw(MAL, "crackers.AlignedJoin", "Cannot access slice");
			
	}

#ifdef DEBUG_CRACKERS_JOIN
	printf("\n Left \n");
	BATprint(viewLeft);
	printf("\n Right \n");
	BATprint(markedViewRight);
#endif

	if (BATcount(markedViewRight) <= BATcount(partitionLeft)){
		CRKjoin(res, partitionLeft, markedViewRight);
		if (existsHashTableRight == FALSE){
			if (prevNodeRight != NULL){
				BBPincref(markedViewRight->batCacheid,TRUE);
			
				temp = prevNodeRight;
				while (temp->indexPosition != curPosRight){
					temp->slice = markedViewRight->batCacheid;
					if (temp->nextValue==NULL)
						break;
					temp=temp->nextValue;
				}
			}
		}
	}else
		CRKjoin(BATmirror(res), BATmirror(markedViewRight), BATmirror(partitionLeft));

	BBPunfix(markedViewRight->batCacheid);
	BBPunfix(partitionLeft->batCacheid);

#ifdef DEBUG_CRACKERS_JOIN
	printf("\n Res \n");
	BATprint(res);
	@:dumpIndex(Index Left)@
#endif
@

@= AlignJoin
	existsHashTableRight = FALSE;
	viewLeft  = BATslice(mapLeft, prevPosLeft,  curPosLeft +1);

	if (prevNodeRight != NULL){
                if (prevNodeRight->slice != -1){
			temp = prevNodeRight;
			existsHashTableRight = TRUE;
			while (temp->indexPosition != curPosRight){
				if (temp->slice != prevNodeRight->slice)
					existsHashTableRight = FALSE;
				if (temp->nextValue==NULL)
					break;
				temp=temp->nextValue;
			}
		
		}
	}
	if (existsHashTableRight == FALSE){
		viewHeadRight = VIEWhead_(mapRight,  BAT_READ);
	       	viewRight = BATslice(viewHeadRight, prevPosRight, curPosRight+1);
	       	BBPunfix(viewHeadRight->batCacheid);
		markedViewRight = (BAT*)BATmark(viewRight,prevPosRight);
		BBPunfix(viewRight->batCacheid);


	}else{
		if ((markedViewRight = BATdescriptor(prevNodeRight->slice)) == NULL)
			throw(MAL, "crackers.AlignedJoin", "Cannot access slice");
			
	}

#ifdef DEBUG_CRACKERS_JOIN
	printf("\n Left \n");
	BATprint(viewLeft);
	printf("\n Right \n");
	BATprint(markedViewRight);
#endif

	if (BATcount(viewLeft)> 0 && BATcount(markedViewRight) > 0){ 
		if (BATcount(markedViewRight) <= BATcount(viewLeft)){
			CRKjoin(res, viewLeft, markedViewRight);
			if (existsHashTableRight == FALSE){
				if (prevNodeRight != NULL){
					BBPincref(markedViewRight->batCacheid,TRUE);
				
					temp = prevNodeRight;
					while (temp->indexPosition != curPosRight){
						temp->slice = markedViewRight->batCacheid;
						if (temp->nextValue==NULL)
							break;
						temp=temp->nextValue;
					}
				}
			}
		}else
			CRKjoin(BATmirror(res), BATmirror(markedViewRight), BATmirror(viewLeft));
	}
	BBPunfix(markedViewRight->batCacheid);
	BBPunfix(viewLeft->batCacheid);

#ifdef DEBUG_CRACKERS_JOIN
	printf("\n Res \n");
	BATprint(res);
	@:dumpIndex(Index Left)@
#endif
@

@= JoinTwoPiecesReuseHashTablesRightFirstCall
	@:dumpIndex(Index Left)@
	/* Exploit existing views if possible */
	viewLeft  = BATslice(mapLeft, prevPosLeft+1,  curPosLeft +1);

	if ((markedViewRight = BATdescriptor(prevNodeRight->slice)) == NULL)
		throw(MAL, "crackers.AlignedJoin", "Cannot access slice");
			
#ifdef DEBUG_CRACKERS_JOIN
	printf("\n Left \n");
	BATprint(viewLeft);
	printf("\n Right \n");
	BATprint(markedViewRight);
#endif
	TJ1=GDKusec();

	if (curPosLeft - prevPosLeft > 0 && curPosRight - prevPosRight > 0){ 
		CRKjoin(res, viewLeft, markedViewRight);
		if (existsHashTableRight == FALSE){
			if (prevNodeRight != NULL){
				BBPincref(markedViewRight->batCacheid,TRUE);
			
				temp = prevNodeRight;
				while (temp->indexPosition != curPosRight){
					temp->slice = markedViewRight->batCacheid;
					if (temp->nextValue==NULL)
						break;
					temp=temp->nextValue;
				}
			}
		}
	}

	BBPunfix(markedViewRight->batCacheid);
	BBPunfix(viewLeft->batCacheid);

	TJ2=GDKusec();
	TJtotal += TJ2 - TJ1;
#ifdef DEBUG_CRACKERS_JOIN
	printf("\n Res \n");
	BATprint(res);
	@:dumpIndex(Index Left)@
#endif
@

@= JoinTwoPiecesReuseHashTablesRight
	@:dumpIndex(Index Left)@
	/* Exploit existing views if possible */
	viewLeft  = BATslice(mapLeft, prevPosLeft+1,  curPosLeft +1);

	if (prevNodeRight != NULL){
                if (prevNodeRight->slice != -1){
			temp = prevNodeRight;
			existsHashTableRight = TRUE;
			while (temp->indexPosition != curPosRight){
				if (temp->slice != prevNodeRight->slice)
					existsHashTableRight = FALSE;
				if (temp->nextValue==NULL)
					break;
				temp=temp->nextValue;
			}
		
		}
	}
	if (existsHashTableRight == FALSE){
		viewHeadRight = VIEWhead_(mapRight,  BAT_READ);
	       	viewRight = BATslice(viewHeadRight, prevPosRight+1, curPosRight+1);
	       	BBPunfix(viewHeadRight->batCacheid);
		markedViewRight = (BAT*)BATmark(viewRight,prevPosRight+1);
		BBPunfix(viewRight->batCacheid);


	}else{
		if ((markedViewRight = BATdescriptor(prevNodeRight->slice)) == NULL)
			throw(MAL, "crackers.AlignedJoin", "Cannot access slice");
			
	}

#ifdef DEBUG_CRACKERS_JOIN
	printf("\n Left \n");
	BATprint(viewLeft);
	printf("\n Right \n");
	BATprint(markedViewRight);
#endif
	TJ1=GDKusec();

	if (curPosLeft - prevPosLeft > 0 && curPosRight - prevPosRight > 0){ 
		CRKjoin(res, viewLeft, markedViewRight);
		if (existsHashTableRight == FALSE){
			if (prevNodeRight != NULL){
				BBPincref(markedViewRight->batCacheid,TRUE);
			
				temp = prevNodeRight;
				while (temp->indexPosition != curPosRight){
					temp->slice = markedViewRight->batCacheid;
					if (temp->nextValue==NULL)
						break;
					temp=temp->nextValue;
				}
			}
		}
	}

	BBPunfix(markedViewRight->batCacheid);
	BBPunfix(viewLeft->batCacheid);

	TJ2=GDKusec();
	TJtotal += TJ2 - TJ1;
#ifdef DEBUG_CRACKERS_JOIN
	printf("\n Res \n");
	BATprint(res);
	@:dumpIndex(Index Left)@
#endif
@

@= MoveToNextPiece
#ifdef DEBUG_CRACKERS_JOIN
	printf("Move @2 \n"); 
#endif
	prevPos@2 = curPos@2;
	curNode@2 = findNextPiece(curNode@2);
	if (curNode@2 != NULL){
		curTuple@2 = base@2 + curNode@2->position;
		curValue@2 =  *(@1 *)Tloc(index@2, curTuple@2);
		curPos@2   =  *(oid*)Hloc(index@2, curTuple@2);
	}
@


@= addPartialResult
	curViewTupleHead = (oid*)Hloc(b,BUNfirst(b)+vl);

#ifdef DEBUG_CRACKERS_JOIN
	printf("\n adding tuples "OIDFMT" to "OIDFMT" \n",vl,vh);
	BATprint(b);
#endif

	for (j=vl;j<vh+1;j++){
		*currentResTupleHead = *currentTupleLeftHead;	
		*currentResTupleTail = *curViewTupleHead;	

		curViewTupleHead ++;
		currentResTupleHead ++;
		currentResTupleTail ++;
	}


	resCount += (vh-vl) + 1;
@

@= sortInsertPartialResult
	*currentResTupleHead = *currentTupleLeftHead;
	*currentResTupleTail = *(oid*)Hloc(BATRight, currentTupleRight);
	
	currentTupleRight   ++;
        currentResTupleHead ++;
        currentResTupleTail ++;
	resCount++;

        if (currentTupleRight == BUNlast(BATRight))
		goto next;
@

@= crackDoubleSidedBound
	if (*inclusiveLow == TRUE && *inclusiveHgh == TRUE)
		CRKcrackUnorderedThree_LE_RE_@1(b,low,hgh, @2, @3, &vl, &vh);
	if (*inclusiveLow == TRUE && *inclusiveHgh == FALSE)
		CRKcrackUnorderedThree_LE_RO_@1(b,low,hgh, @2, @3, &vl, &vh);
	if (*inclusiveLow == FALSE && *inclusiveHgh == TRUE)
		CRKcrackUnorderedThree_LO_RE_@1(b,low,hgh, @2, @3, &vl, &vh);
	if (*inclusiveLow == FALSE && *inclusiveHgh == FALSE)
		CRKcrackUnorderedThree_LO_RO_@1(b,low,hgh, @2, @3, &vl, &vh);
				
	/*if (vl != -1 && vh != -1){*/
		if (vl>0) _vl=vl-1; else _vl=vl;		
		addCrackerIndex_@1(m,&low,*inclusiveLow,_vl,c);
		addCrackerIndex_@1(m,&hgh,HBound,vh,c);
	
@

@= crackSingleSidedBoundLeft
	if (*inclusiveLow == TRUE)
		CRKcrackUnorderedZero_RE_@1(b,low, cl1, ch1,&vl);
	else
		CRKcrackUnorderedZero_LE_@1(b,low, cl1, ch1,&vl);
	if (vl < cl1){
		gapL = -1;
	}
	if (vl > ch1){
		vl--;
		gapL = -1;
	}
	vl++; 
@

@= crackSingleSidedBoundRight
	if (*inclusiveHgh == TRUE)
		CRKcrackUnorderedZero_LE_@1(b,hgh, cl2, ch2,&vh);
	else
		CRKcrackUnorderedZero_RE_@1(b,hgh, cl2, ch2,&vh);

	if (vh < cl2)
		gapH = -1;
	if (vh > ch2){
		gapH = -1;
		vh--;
	}
@

@= CreateCrackerMapReuseExistingBAT
		BAT *c, *b;
		int m;
		oid sizeM;

		TC1=GDKusec();	
                if ((b = BATdescriptor(@3)) == NULL)
                        throw(MAL, "crackers.create new map", "Cannot access descriptor of map head BAT");

                b->batRestricted= BAT_WRITE;
		if ( b->ttype == TYPE_void)
			b = BATmirror(BATmaterializeh(BATmirror(b)));
		if ( b->htype == TYPE_void)
			b = BATmaterializeh(b);
                sizeM = BATcount(b);

                b->hsorted = FALSE;
                b->tsorted = FALSE;
                b->hdense = FALSE;
                b->tdense = FALSE;

                /*BATkey(b,TRUE);*/

                BATkey(BATmirror(b),FALSE);
                b->batRestricted= BAT_READ;
                BATmode(b,PERSISTENT);

		c = BATnew(TYPE_oid, TYPE_@1, IndexEntries);	/* TODO: size */

                m = newCrackerIndexSideways_@1(@3, b->batCacheid, @3, c->batCacheid);
		CrackerIndex[m].creationTimestamp = GDKusec();
		CrackerIndex[m].accesses = 1;
		CrackerIndex[m].dropped = 0;
		CrackerIndex[m].tuples = sizeM; 

		/* storage management should be here as in crackers.sideways*/

                BBPkeepref(c->batCacheid);

		TC2=GDKusec();	
		TCtotal+=TC2-TC1;
@

@= CreateCrackerMapFromExistingBAT
		BAT *bo, *b, *c;
                oid sizeM;
		int m;

		TC1=GDKusec();	
                if ((bo = BATdescriptor(@3)) == NULL)
                        throw(MAL, "crackers.create new map", "Cannot access descriptor of map head BAT");

		b = BATcopy(bo, bo->htype, bo->ttype, TRUE);
                b->batRestricted= BAT_WRITE;
		if ( b->ttype == TYPE_void)
			b = BATmirror(BATmaterializeh(BATmirror(b)));
		if ( b->htype == TYPE_void)
			b = BATmaterializeh(b);

                sizeM = BATcount(bo);

                b->hsorted = FALSE;
                b->tsorted = FALSE;
                b->hdense = FALSE;
                b->tdense = FALSE;

                /*BATkey(b,TRUE);*/

                BATkey(BATmirror(b),FALSE);
                b->batRestricted= BAT_READ;
                BATmode(b,PERSISTENT);

		c = BATnew(TYPE_oid, TYPE_@1, IndexEntries);	/* TODO: size */

                m = newCrackerIndexSideways_@1(@3, b->batCacheid, @3, c->batCacheid);
		CrackerIndex[m].creationTimestamp = GDKusec();
		CrackerIndex[m].accesses = 1;
		CrackerIndex[m].dropped = 0;
		CrackerIndex[m].tuples = sizeM;

		/* storage management should be here as in crackers.sideways*/

                BBPunfix(bo->batCacheid);
                BBPkeepref(b->batCacheid);
                BBPkeepref(c->batCacheid);

		TC2=GDKusec();	
		TCtotal+=TC2-TC1;
@

@= CreateCrackerMapMultiCrack
		BAT *bo, *bp, *b, *c;
                oid sizeM;
		int m;

		TC1=GDKusec();	
                if ((bo = BATdescriptor(@3)) == NULL)
                        throw(MAL, "crackers.create new map", "Cannot access descriptor of map head BAT");
                if ((bp = BATdescriptor(@4)) == NULL)
                        throw(MAL, "crackers.create new map", "Cannot access pdescriptor of map tail BAT");

                sizeM = BATcount(bo);
		b = BATnew(bo->ttype, bp->ttype, sizeM);
                b->hsorted = FALSE;
                b->tsorted = FALSE;
                b->hdense = FALSE;
                b->tdense = FALSE;

                /*BATkey(b,TRUE);*/

                BATkey(BATmirror(b),FALSE);
                b->batRestricted= BAT_READ;
                BATmode(b,PERSISTENT);
	
        	BATsetcount(b, sizeM);

		c = BATnew(TYPE_oid, TYPE_@1, IndexEntries);	/* TODO: size */

                m = newCrackerIndexSideways_@1(@3, b->batCacheid, @4, c->batCacheid);
		CrackerIndex[m].creationTimestamp = GDKusec();
		CrackerIndex[m].accesses = 1;
		CrackerIndex[m].dropped = 0;
		CrackerIndex[m].tuples = sizeM;

		/* storage management should be here as in crackers.sideways*/

		CrackPopulateSideways_@1(bo,bp,b,c,m,*minLeft,*maxLeft,4096);	

                BBPunfix(bo->batCacheid);
                BBPunfix(bp->batCacheid);
                BBPkeepref(b->batCacheid);
                BBPkeepref(c->batCacheid);

		TC2=GDKusec();	
		TCtotal+=TC2-TC1;
@

@= CreateCrackerMap
		BAT *bo, *bp, *b, *c;
                oid sizeM;
                @2 *ptail, *ntail;
		@1 *nhead, *ctail;
		oid j;
		int m;

		TC1=GDKusec();	
                if ((bo = BATdescriptor(@3)) == NULL)
                        throw(MAL, "crackers.create new map", "Cannot access descriptor of map head BAT");
                if ((bp = BATdescriptor(@4)) == NULL)
                        throw(MAL, "crackers.create new map", "Cannot access pdescriptor of map tail BAT");

                sizeM = BATcount(bo);
		b = BATnew(bo->ttype, bp->ttype, sizeM);
		nhead = (@1*)Hloc(b,  BUNfirst(b));
		ctail = (@1*)Tloc(bo, BUNfirst(bo));
		for(j=0;j<sizeM;j++){
			*nhead = *ctail;
			nhead++;
			ctail++;
		}

		/*TODO string support should be done here as in crackeres.sideways*/
		ntail = (@2*)Tloc(b,  BUNfirst(b));
		ptail = (@2*)Tloc(bp, BUNfirst(bp));
		for(j=0;j<sizeM;j++){
			*ntail = *ptail;
			ntail++;
			ptail++;
		}

                b->hsorted = FALSE;
                b->tsorted = FALSE;
                b->hdense = FALSE;
                b->tdense = FALSE;

                /*BATkey(b,TRUE);*/

                BATkey(BATmirror(b),FALSE);
                b->batRestricted= BAT_READ;
                BATmode(b,PERSISTENT);
	
        	BATsetcount(b, sizeM);

		c = BATnew(TYPE_oid, TYPE_@1, IndexEntries);	/* TODO: size */

                m = newCrackerIndexSideways_@1(@3, b->batCacheid, @4, c->batCacheid);
		CrackerIndex[m].creationTimestamp = GDKusec();
		CrackerIndex[m].accesses = 1;
		CrackerIndex[m].dropped = 0;
		CrackerIndex[m].tuples = sizeM;

		/* storage management should be here as in crackers.sideways*/

                BBPunfix(bo->batCacheid);
                BBPunfix(bp->batCacheid);
                BBPkeepref(b->batCacheid);
                BBPkeepref(c->batCacheid);

		TC2=GDKusec();	
		TCtotal+=TC2-TC1;
@

@= activeCrackInitialize
	if (*mode==4){
		struct Node * temp = curNode@1;
		oid maxPieceSize = 0, prevPos = 0, curSize;
		
		while (1){
			curSize = temp==NULL ? BATcount(map@1) - prevPos + 1 : temp->indexPosition - prevPos + 1;
			if (maxPieceSize < curSize){
				maxPieceSize = curSize;
				positionOfPieceToCrack@1 = prevPos;
			}
			if (temp == NULL) break;
			prevPos = temp->indexPosition;
			temp = temp->nextValue;
		}

		if (positionOfPieceToCrack@1 >0 ) positionOfPieceToCrack@1 ++;
	}	
@

@= printVarTypes
{
/* @1: the type; e.g., chr bte sht int oid wrd flt dbl lng str */
	str MyBuf = NULL;
	int MyBufLen = 0;
	(void)(*BATatoms[TYPE_@1].atomToStr) (&MyBuf, &MyBufLen, (ptr)(&@2));
	printf("%s @3 \n", MyBuf);
	GDKfree(MyBuf);
}
@

@= activeCrack
		
	/*Mode 1. Every piece we see on the way we crack it if bigger than the threshold*/
	/*Mode 2. Crack every piece all the way to the threshold*/
	/*Mode 3. Same as Mode 2 but use double sided cracking*/
	/*Mode 4. Perform a single crack operation on the biggest piece of each join input*/

	/*Mode 5. Sample based exhaustive cracking*/
	/*Mode 6. Calculate average while cracking and reuse in next itteration*/
	/*Mode 7. Single sided cracking with a random mid*/
	/*Mode 8. Double sided cracking with a random range*/

	if (*mode==1 || *mode==2 || (*mode==3 && (size@3 < (oid)(3 * (*pieceSize)))) || (*mode==4 && positionOfPieceToCrack@3 == cprevPos@3) ){
		if (size@3 > (oid)*pieceSize){
			@1 oldmid;
			bit activeCrack = TRUE;
			low=prevNode@3==NULL?*min@3:(*(@1 *)Tloc(index@3, base@3 + prevNode@3->position));
			hgh=curNode@3 ==NULL?*max@3:(*(@1 *)Tloc(index@3, base@3 + curNode@3->position ));
			mid = (hgh - low)/2 +low;
			oldmid = mid - 1;
			while (1){
				if (oldmid == mid || mid == *min@3 || mid == *max@3){
					activeCrack = FALSE;
					break;
				}
				TC1=GDKusec();	
				CRKcrackUnorderedZeroSideways_RE_@1_@2(map@3, mid, cprevPos@3, curPos@3, &newPosition);
				TC2=GDKusec();	
				TCtotal+=TC2-TC1;

				/*if we get an empty piece adjust the range in half and retry*/
				if (newPosition > cprevPos@3 && newPosition < curPos@3) break;
				else if (newPosition < cprevPos@3) 
					low = mid;
				else 
					hgh = mid;
				oldmid = mid;		
				mid    = (hgh - low)/2 +low;
			}
			if (activeCrack){	
				curNode@3 = addCrackerIndex_@1(mapPos@3, &mid, TRUE, newPosition, index@3);
				AddToTape_@1(mapPos@3, @1_nil, mid, TRUE, TRUE);
				curPos@3 = newPosition;
				
				/*if the current piece is still over the threshold, then start again*/
				if (*mode==2 || *mode==3){
					size@3=curPos@3-prevPos@3+1;
					if (size@3 > (oid)*pieceSize)
						continue;
				}
			}
		}
	}else 
	if (*mode==3){
		if (size@3 >= (oid)(3 * (*pieceSize))){
			low=prevNode@3==NULL?*min@3:(*(@1 *)Tloc(index@3, base@3 + prevNode@3->position));
			hgh=curNode@3 ==NULL?*max@3:(*(@1 *)Tloc(index@3, base@3 + curNode@3->position ));
			step = (hgh - low)/3;
			mid1 = low  + step;
			mid2 = mid1 + step;

			TC1=GDKusec();	
			CRKcrackUnorderedThreeSideways_LE_RE_@1_@2(map@3,mid1,mid2, cprevPos@3, curPos@3, &newPosition, &newPosition2);
			TC2=GDKusec();	
			TCtotal+=TC2-TC1;

			if (newPosition>0) newPosition-=1;
			curNode@3 = addCrackerIndex_@1(mapPos@3, &mid1, TRUE, newPosition, index@3);
				    addCrackerIndex_@1(mapPos@3, &mid2, TRUE, newPosition2, index@3);
			AddToTape_@1(mapPos@3, @1_nil, mid1, TRUE, TRUE);
			AddToTape_@1(mapPos@3, @1_nil, mid2, TRUE, TRUE);
			curPos@3 = newPosition;
			
			/*if the current piece is still over the threshold, then start again*/
			size@3=curPos@3-prevPos@3+1;
			if (size@3 > (oid)*pieceSize)
				continue;
		}
	}else
	if (*mode==5 && (size@3 > (oid)*pieceSize)){
		bit activeCrack = TRUE, sample = TRUE;
		while (1){
			TC1=GDKusec();	
			CRKcrackUnorderedZeroSidewaysSample_RE_@1_@2(map@3, &mid, cprevPos@3, curPos@3, &newPosition, pieceSize, sample);
			TC2=GDKusec();	
			TCtotal+=TC2-TC1;
			/*if we get an empty piece adjust the range in half and retry*/
			if (newPosition > cprevPos@3 && newPosition < curPos@3) break;
				activeCrack = FALSE;
				break;
			/*
			else if (newPosition < cprevPos@3) 
				low = mid;
			else 
				hgh = mid;
			oldmid = mid;		
			mid    = (hgh - low)/2 +low;
			sample = FALSE;
			if (oldmid == mid || mid == *min@3 || mid == *max@3){
				activeCrack = FALSE;
				break;
			}
			*/
		}
		if (activeCrack){	
			curNode@3 = addCrackerIndex_@1(mapPos@3, &mid, TRUE, newPosition, index@3);
			AddToTape_@1(mapPos@3, @1_nil, mid, TRUE, TRUE);
			curPos@3 = newPosition;
			
			/*if the current piece is still over the threshold, then start again*/
			size@3=curPos@3-prevPos@3+1;
			if (size@3 > (oid)*pieceSize)
				continue;
		}
	}else
	if (*mode==7 && (size@3 > (oid)*pieceSize)){
		@1 oldmid;
		bit activeCrack = TRUE;
		low=prevNode@3==NULL?*min@3:(*(@1 *)Tloc(index@3, base@3 + prevNode@3->position));
		hgh=curNode@3 ==NULL?*max@3:(*(@1 *)Tloc(index@3, base@3 + curNode@3->position ));
		mid=low;
		while(mid==low || mid==hgh)
			mid=(rand()%(hgh-low))+low;
		while (1){
			TC1=GDKusec();	
			CRKcrackUnorderedZeroSideways_RE_@1_@2(map@3, mid, cprevPos@3, curPos@3, &newPosition);
			TC2=GDKusec();	
			TCtotal+=TC2-TC1;
			/*if we get an empty piece adjust the range in half and retry*/
			if (newPosition > cprevPos@3 && newPosition < curPos@3) break;
			else if (newPosition < cprevPos@3) 
				low = mid;
			else 
				hgh = mid;
			oldmid = mid;		
			mid=low;
			while(mid==low || mid==hgh)
				mid=(rand()%(hgh-low))+low;
			if (oldmid == mid || mid == *min@3 || mid == *max@3){
				activeCrack = FALSE;
				break;
			}
		}
		if (activeCrack){	
			curNode@3 = addCrackerIndex_@1(mapPos@3, &mid, TRUE, newPosition, index@3);
			AddToTape_@1(mapPos@3, @1_nil, mid, TRUE, TRUE);
			curPos@3 = newPosition;
			
			/*if the current piece is still over the threshold, then start again*/
			size@3=curPos@3-prevPos@3+1;
			if (size@3 > (oid)*pieceSize)
				continue;
		}
	}else
	if (*mode==8 && (size@3 > (oid)*pieceSize)){
		@1 oldmid;
		int i;
		bit activeCrack = TRUE;
		low=prevNode@3==NULL?*min@3:(*(@1 *)Tloc(index@3, base@3 + prevNode@3->position));
		hgh=curNode@3 ==NULL?*max@3:(*(@1 *)Tloc(index@3, base@3 + curNode@3->position ));

		mid1=(rand()%(hgh-low))+low;
		mid2=mid1;
		i=0;
		while(mid2==mid1 && i<10){
			mid2=(rand()%(hgh-low))+low;
			i++;
		}
		if (mid1==mid2){
			activeCrack = FALSE;
		}
		if (mid1>mid2){
			@1 temp = mid1;
			mid1=mid2;
			mid2=temp;
		}

		while (activeCrack){
			TC1=GDKusec();	
			CRKcrackUnorderedThreeSideways_LE_RE_@1_@2(map@3,mid1,mid2, cprevPos@3, curPos@3, &newPosition, &newPosition2);
			TC2=GDKusec();	
			TCtotal+=TC2-TC1;
			/*if we get an empty piece adjust the range in half and retry*/
			if (newPosition > cprevPos@3 && newPosition < curPos@3) break;
			else if (newPosition < cprevPos@3) 
				low = mid1;
			else 
				hgh = mid1;

			if (low==hgh){
                                activeCrack = FALSE;
                                break;
                        }

			oldmid = mid1;		
			mid1=(rand()%(hgh-low))+low;
			mid2=mid1;
			i=0;
			while(mid2==mid1 && i<10){
				mid2=(rand()%(hgh-low))+low;
				i++;
			}
			if (mid1==mid2){
                                activeCrack = FALSE;
                                break;
                        }

			if (mid1>mid2){
				@1 temp = mid1;
				mid1=mid2;
				mid2=temp;
			}
			if (oldmid == mid1 || mid1 == *min@3 || mid1 == *max@3){
				activeCrack = FALSE;
				break;
			}
		}
		if (activeCrack){	
			if (newPosition >0) newPosition--;
			curNode@3 = addCrackerIndex_@1(mapPos@3, &mid1, TRUE, newPosition, index@3);
			AddToTape_@1(mapPos@3, @1_nil, mid1, TRUE, TRUE);

			if (newPosition2 < curPos@3 && newPosition != newPosition2){
				addCrackerIndex_@1(mapPos@3, &mid2, TRUE, newPosition2, index@3);
				AddToTape_@1(mapPos@3, @1_nil, mid2, TRUE, TRUE);
			}

			curPos@3 = newPosition;
			
			/*if the current piece is still over the threshold, then start again*/
			size@3=curPos@3-prevPos@3+1;
			if (size@3 > (oid)*pieceSize)
				continue;
		}
	}


@

@= ActiveJoinMainPart
        /* Get the piece that holds the lowest values */
        curNodeRight = getFirstNode(CrackerIndex[mapPosRight].Tree);

        baseRight      = BUNfirst(indexRight);

	res = BATnew(TYPE_oid,TYPE_oid,BATcount(mapLeft));
	
	prevPosLeft   = prevPosRight   = 0;
	prevNodeLeft  = prevNodeRight  = NULL;

	@:activeCrackInitialize(Left)@
	@:activeCrackInitialize(Right)@

	while (curNodeLeft != NULL && curNodeRight != NULL){
		iterations++;
		cprevPosRight = prevPosRight;
		cprevPosLeft  = prevPosLeft;


		existsHashTableLeft = existsHashTableRight = FALSE;

       		curValueLeft = *(@1 *)Tloc(indexLeft, baseLeft + curNodeLeft->position);
        	curPosLeft   = curNodeLeft->indexPosition; 

        	curValueRight = *(@1 *)Tloc(indexRight, baseRight + curNodeRight->position);
        	curPosRight   = curNodeRight->indexPosition;
		
		if (curPosLeft ==0 &&  prevPosLeft==0)
			if ( *(@1 *)Tloc(mapLeft,0)>curValueLeft){
				prevNodeLeft  = curNodeLeft;
				curNodeLeft = curNodeLeft->nextValue;/*findNextPiece(curNodeLeft);*/
				continue;
			}	 
		if (curPosRight ==0 &&  prevPosRight==0)
			if ( *(@1 *)Tloc(mapRight,0)>curValueRight){
				prevNodeRight  = curNodeRight;
				curNodeRight = curNodeRight->nextValue;/*findNextPiece(curNodeRight);*/
				continue;
			}	 


		sizeLeft  = curPosLeft  - prevPosLeft  + 1;
		sizeRight = curPosRight - prevPosRight + 1;

#ifdef DEBUG_CRACKERS_JOIN
		printf("\n itteration "OIDFMT" Index Left 1st \n", iterations);
		printAVLTree(CrackerIndex[mapPosLeft].Tree, indexLeft, baseLeft);
		printf("\n Index Right \n");
		printAVLTree(CrackerIndex[mapPosRight].Tree, indexRight, baseRight);
		printf(" leftVal %d rightVal %d \n", curValueLeft, curValueRight);
		printf(" prevPosLeft "OIDFMT" curPosLeft "OIDFMT" \n", prevPosLeft,curPosLeft);
		printf(" prevPosRight "OIDFMT" curPosRight "OIDFMT" \n", prevPosRight,curPosRight);
#endif

		/* crack if the piece is too big */
		@:activeCrack(@1,@2,Left)@
		@:activeCrack(@1,@2,Right)@
			
		mainloop:;
		/*initialize variables again as pieces might have changed*/
       		curValueLeft = *(@1 *)Tloc(indexLeft, baseLeft + curNodeLeft->position);
        	curPosLeft   = curNodeLeft->indexPosition; 
        	curValueRight = *(@1 *)Tloc(indexRight, baseRight + curNodeRight->position);
        	curPosRight   = curNodeRight->indexPosition;
		sizeLeft  = curPosLeft  - prevPosLeft  + 1;
		sizeRight = curPosRight - prevPosRight + 1;
		
		/* collect super pieces if piece is too small */
		if (sizeLeft < (oid)*pieceSize) {
				while (curValueLeft > curValueRight ||
                			((curValueLeft == curValueRight) && 
						(curNodeRight->inclusive == FALSE) && (curNodeLeft->inclusive == TRUE))){ 
					if (curNodeRight->nextValue == NULL) goto cont;
					cprevPosRight = curPosRight+1;
					curNodeRight = curNodeRight->nextValue;
					curValueRight = *(@1 *)Tloc(indexRight, baseRight + curNodeRight->position);
					curPosRight   = curNodeRight->indexPosition;
				}
			while (sizeLeft < (oid)*pieceSize){

				if (curNodeLeft->nextValue == NULL) goto cont;
				if (curNodeLeft->nextValue->indexPosition - prevPosLeft+1 > (oid)*pieceSize){
				/*	if (curNodeLeft->nextValue->indexPosition - prevPosLeft+1 - (oid)*pieceSize > (oid)*pieceSize - sizeLeft)  */
						goto checkRight;
				}
 				cprevPosLeft = curPosLeft+1;
				curNodeLeft = curNodeLeft->nextValue;
				curValueLeft = *(@1 *)Tloc(indexLeft, baseLeft + curNodeLeft->position);
				curPosLeft   = curNodeLeft->indexPosition; 
				sizeLeft  = curPosLeft - prevPosLeft+1;
				while (curValueLeft > curValueRight ||
                			((curValueLeft == curValueRight) && 
						(curNodeRight->inclusive == FALSE) && (curNodeLeft->inclusive == TRUE))){ 
					if (curNodeRight->nextValue == NULL) goto cont;
					cprevPosRight = curPosRight+1;
					curNodeRight = curNodeRight->nextValue;
					curValueRight = *(@1 *)Tloc(indexRight, baseRight + curNodeRight->position);
					curPosRight   = curNodeRight->indexPosition;
				}
				
			}
		}
		checkRight:;
/*
		if (sizeRight < (oid)*pieceSize){
			while (curValueRight > curValueLeft ||
				((curValueLeft == curValueRight) && 
					(curNodeLeft->inclusive == FALSE) && (curNodeRight->inclusive == TRUE))){ 
				if (curNodeLeft->nextValue == NULL) goto cont;
				cprevPosLeft = curPosLeft+1;
				curNodeLeft = curNodeLeft->nextValue;
				curValueLeft = *(@1 *)Tloc(indexLeft, baseLeft + curNodeLeft->position);
				curPosLeft   = curNodeLeft->indexPosition; 
			}
			while (sizeRight < (oid)*pieceSize){
				if (curNodeRight->nextValue == NULL) goto cont;
				if (curNodeRight->nextValue->indexPosition - prevPosRight+1 > (oid)*pieceSize){
						goto cont;
				}
				cprevPosRight = curPosRight+1;
				curNodeRight = curNodeRight->nextValue;
				curValueRight = *(@1 *)Tloc(indexRight, baseRight + curNodeRight->position);
				curPosRight   = curNodeRight->indexPosition;
				sizeRight  = curPosRight - prevPosRight+1;
				while (curValueRight > curValueLeft ||
                			((curValueLeft == curValueRight) && 
						(curNodeLeft->inclusive == FALSE) && (curNodeRight->inclusive == TRUE))) { 
					if (curNodeLeft->nextValue == NULL) goto cont;
					cprevPosLeft = curPosLeft+1;
					curNodeLeft = curNodeLeft->nextValue;
					curValueLeft = *(@1 *)Tloc(indexLeft, baseLeft + curNodeLeft->position);
					curPosLeft   = curNodeLeft->indexPosition; 
				}
			}
		}
*/		
		cont:;
		if (curValueLeft < curValueRight || 
		((curValueLeft == curValueRight) && (curNodeLeft->inclusive == FALSE) && (curNodeRight->inclusive == TRUE))){

			TC1=GDKusec();	
			if (curNodeLeft->inclusive == TRUE)
		                CRKcrackUnorderedZeroSideways_RE_@1_@2(mapRight, curValueLeft, cprevPosRight, curPosRight, &newPosition);
        		else 
                		CRKcrackUnorderedZeroSideways_LE_@1_@2(mapRight, curValueLeft, cprevPosRight, curPosRight, &newPosition);
			TC2=GDKusec();	
			TCtotal+=TC2-TC1;

			if (newPosition < cprevPosRight){
				if (cprevPosRight == prevPosRight){
					prevNodeLeft = curNodeLeft;
					curNodeLeft  = curNodeLeft->nextValue;
					continue;
				}
				curPosRight = cprevPosRight - 1;
				curNodeRight = findPreviousPieceWalkingBack(curNodeRight);
			}else if (newPosition < curPosRight){
				curNodeRight = addCrackerIndex_@1(mapPosRight, &curValueLeft, curNodeLeft->inclusive, newPosition, indexRight);
				AddToTape_@1(mapPosRight, @1_nil, curValueLeft, curNodeLeft->inclusive, curNodeLeft->inclusive);
				curPosRight = newPosition;
			}
		}
		else if (curValueRight < curValueLeft ||
                ((curValueLeft == curValueRight) && (curNodeRight->inclusive == FALSE) && (curNodeLeft->inclusive == TRUE))){
			TC1=GDKusec();	
			if (curNodeRight->inclusive == TRUE)
		                CRKcrackUnorderedZeroSideways_RE_@1_@2(mapLeft, curValueRight, cprevPosLeft, curPosLeft, &newPosition);
        		else 
                		CRKcrackUnorderedZeroSideways_LE_@1_@2(mapLeft, curValueRight, cprevPosLeft, curPosLeft, &newPosition);
			TC2=GDKusec();	
			TCtotal+=TC2-TC1;

			if (newPosition < cprevPosLeft){
				if (cprevPosLeft == prevPosLeft){
					prevNodeRight = curNodeRight;
					curNodeRight  = curNodeRight->nextValue;
					continue;
				}
				curPosLeft = cprevPosLeft - 1;
				curNodeLeft = findPreviousPieceWalkingBack(curNodeLeft);
			}else if (newPosition < curPosLeft){
				curNodeLeft = addCrackerIndex_@1(mapPosLeft, &curValueRight, curNodeRight->inclusive, newPosition, indexLeft);
				AddToTape_@1(mapPosLeft, @1_nil, curValueRight, curNodeRight->inclusive, curNodeRight->inclusive);
				curPosLeft = newPosition;
			}
		}

		@:JoinTwoSuperPiecesReuseHashTables@3()@

		if (curNodeLeft == NULL || curNodeRight == NULL)
			goto finished;

		prevNodeLeft  = curNodeLeft;
		curNodeLeft = curNodeLeft->nextValue;

		prevNodeRight  = curNodeRight;
		curNodeRight = curNodeRight->nextValue;

		prevPosLeft  = prevNodeLeft->indexPosition  + 1;
		prevPosRight = prevNodeRight->indexPosition + 1;
	}

	while(1){
		iterations++;
		existsHashTableLeft = existsHashTableRight = FALSE;
		
		cprevPosLeft  = prevPosLeft   = prevNodeLeft ==NULL?0:(prevNodeLeft->indexPosition==0?0:prevNodeLeft->indexPosition + 1);
		cprevPosRight = prevPosRight  = prevNodeRight==NULL?0:(prevNodeRight->indexPosition==0?0:prevNodeRight->indexPosition + 1);

		if (curNodeLeft == NULL)
			curPosLeft  = BATcount(mapLeft)-1;
		else {
        	        curValueLeft = *(@1 *)Tloc(indexLeft, baseLeft + curNodeLeft->position);
	                curPosLeft   = curNodeLeft->indexPosition;
		}
		if (curNodeRight == NULL)
			curPosRight  = BATcount(mapRight)-1;
		else {
   	             	curValueRight = *(@1 *)Tloc(indexRight, baseRight + curNodeRight->position);
        	        curPosRight   = curNodeRight->indexPosition;
		}

		sizeLeft  = curPosLeft  - prevPosLeft  + 1;
		sizeRight = curPosRight - prevPosRight + 1;

#ifdef DEBUG_CRACKERS_JOIN
		printf("\n itteration "OIDFMT" Index Left 1st \n", iterations);
		printAVLTree(CrackerIndex[mapPosLeft].Tree, indexLeft, baseLeft);
		printf("\n Index Right \n");
		printAVLTree(CrackerIndex[mapPosRight].Tree, indexRight, baseRight);
		printf(" leftVal %d rightVal %d \n", curValueLeft, curValueRight);
		printf(" prevPosLeft "OIDFMT" curPosLeft "OIDFMT" \n", prevPosLeft,curPosLeft);
		printf(" prevPosRight "OIDFMT" curPosRight "OIDFMT" \n", prevPosRight,curPosRight);
#endif


		@:activeCrack(@1,@2,Left)@
		@:activeCrack(@1,@2,Right)@

		if (curNodeLeft!=NULL && curNodeRight!=NULL) 
			goto mainloop;

		if (curNodeLeft == NULL)
			curPosLeft  = BATcount(mapLeft)-1;
		else {
        	        curValueLeft = *(@1 *)Tloc(indexLeft, baseLeft + curNodeLeft->position);
	                curPosLeft   = curNodeLeft->indexPosition;
		}
		if (curNodeRight == NULL)
			curPosRight  = BATcount(mapRight)-1;
		else {
   	             	curValueRight = *(@1 *)Tloc(indexRight, baseRight + curNodeRight->position);
        	        curPosRight   = curNodeRight->indexPosition;
		}
		sizeLeft  = curPosLeft  - prevPosLeft  + 1;
		sizeRight = curPosRight - prevPosRight + 1;

		if (sizeLeft < (oid)*pieceSize && curNodeLeft != NULL) {
			while (sizeLeft < (oid)*pieceSize){
				if (curNodeLeft->nextValue == NULL)  {
					if ( (BATcount(mapLeft)-1)- prevPosLeft <(oid)*pieceSize){
						curPosLeft  = BATcount(mapLeft)-1;
						curNodeLeft = NULL;
					}
					break;
				}
				if (curNodeLeft->nextValue->indexPosition - prevPosLeft+1 > (oid)*pieceSize){
				/*	if (curNodeLeft->nextValue->indexPosition - prevPosLeft+1 - (oid)*pieceSize > (oid)*pieceSize - sizeLeft) */
						goto checkRight2;
				}
				curNodeLeft = curNodeLeft->nextValue;
				curPosLeft   = curNodeLeft->indexPosition; 
        	        	curValueLeft = *(@1 *)Tloc(indexLeft, baseLeft + curNodeLeft->position);
				sizeLeft  = curPosLeft - prevPosLeft + 1;
			}
		}
		checkRight2:;
/*
		if (sizeRight < (oid)*pieceSize && curNodeRight != NULL){
			while (sizeRight < (oid)*pieceSize){
				if (curNodeRight->nextValue == NULL) {
					if ( (BATcount(mapRight)-1)- prevPosRight <(oid)*pieceSize){
						curPosRight  = BATcount(mapRight)-1;
						curNodeRight = NULL;
					}
					break;
				}
				if (curNodeRight->nextValue->indexPosition - prevPosRight+1 > (oid)*pieceSize){
						goto cont2;
				}
				curNodeRight = curNodeRight->nextValue;
				curPosRight   = curNodeRight->indexPosition;
   	             		curValueRight = *(@1 *)Tloc(indexRight, baseRight + curNodeRight->position);
				sizeRight  = curPosRight - prevPosRight + 1;
			}
		}
		cont2:;	
*/
		if (curNodeLeft != NULL && curNodeRight == NULL){	
			
			TC1=GDKusec();	
			if (curNodeLeft->inclusive == TRUE)

		                CRKcrackUnorderedZeroSideways_RE_@1_@2(mapRight, curValueLeft, prevPosRight, curPosRight, &newPosition);
        		else 
                		CRKcrackUnorderedZeroSideways_LE_@1_@2(mapRight, curValueLeft, prevPosRight, curPosRight, &newPosition);

			TC2=GDKusec();	
			TCtotal+=TC2-TC1;
			if (newPosition < prevPosRight){
				prevNodeLeft = curNodeLeft;
				curNodeLeft  = curNodeLeft->nextValue;	
				continue;
			}
			else if (newPosition < curPosRight){
				curNodeRight = addCrackerIndex_@1(mapPosRight, &curValueLeft, curNodeLeft->inclusive, newPosition, indexRight);
				AddToTape_@1(mapPosRight, @1_nil, curValueLeft, curNodeLeft->inclusive, curNodeLeft->inclusive);
				curPosRight = newPosition;
			}
			else {  /* this means that there is no chance to join with the future pieces of the other side */

				@:JoinTwoSuperPiecesReuseHashTables@3()@

				break;
			}
		}
		else if (curNodeLeft == NULL && curNodeRight != NULL){

			TC1=GDKusec();	
			if (curNodeRight->inclusive == TRUE)
		                CRKcrackUnorderedZeroSideways_RE_@1_@2(mapLeft, curValueRight, prevPosLeft+1, curPosLeft, &newPosition);
        		else 
                		CRKcrackUnorderedZeroSideways_LE_@1_@2(mapLeft, curValueRight, prevPosLeft+1, curPosLeft, &newPosition);

			TC2=GDKusec();	
			TCtotal+=TC2-TC1;
			if (newPosition < prevPosLeft){
				prevNodeRight = curNodeRight;
				curNodeRight  = curNodeRight->nextValue;	
				continue;
			}else
			if (newPosition < curPosLeft){
				curNodeLeft = addCrackerIndex_@1(mapPosLeft, &curValueRight, curNodeRight->inclusive, newPosition, indexLeft);
				AddToTape_@1(mapPosLeft, @1_nil, curValueRight, curNodeRight->inclusive, curNodeRight->inclusive);
				curPosLeft = newPosition;
			}
			else {
				@:JoinTwoSuperPiecesReuseHashTables@3()@
				break;
			}
		}

		@:JoinTwoSuperPiecesReuseHashTables@3()@
		if (curNodeLeft == NULL && curNodeRight == NULL)
			break;

		prevNodeLeft  = curNodeLeft;
		curNodeLeft = curNodeLeft->nextValue;
	
		prevNodeRight  = curNodeRight;
		curNodeRight = curNodeRight->nextValue;
	}

	finished:;
#ifdef DEBUG_CRACKERS_JOIN
		printf("\n itteration "OIDFMT" Index Left 1st \n", iterations);
		printAVLTree(CrackerIndex[mapPosLeft].Tree, indexLeft, baseLeft);
		printf("\n Index Right \n");
		printAVLTree(CrackerIndex[mapPosRight].Tree, indexRight, baseRight);
		printf(" leftVal %d rightVal %d \n", curValueLeft, curValueRight);
		printf(" prevPosLeft "OIDFMT" curPosLeft "OIDFMT" \n", prevPosLeft,curPosLeft);
		printf(" prevPosRight "OIDFMT" curPosRight "OIDFMT" \n", prevPosRight,curPosRight);
#endif

        *resid = res->batCacheid;
        BBPkeepref(*resid);

        BBPunfix(indexLeft->batCacheid);
        BBPunfix(indexRight->batCacheid);
        BBPunfix(mapLeft->batCacheid);
        BBPunfix(mapRight->batCacheid);

	T2=GDKusec();

	printf("Total  " LLFMT " Join " LLFMT " Rest  " LLFMT " Joins " LLFMT " Crack " LLFMT " Pieces " LLFMT " \n", 
			T2-T1, TJtotal, ((T2-T1)-TJtotal)-TCtotal, joinsDone, TCtotal, CrackerIndex[mapPosLeft].pieces + CrackerIndex[mapPosRight].pieces );
	printf("result is "BUNFMT" \n", BATcount(res));
@

@= JoinFunctions_impl_1
str CRKsimpleJoin_@1_@5(int *resid, int *bidL1, int *bidL2, int *bidR1, int *bidR2){
	lng TJtotal = 0, T1=GDKusec(), T2, TCtotal=0;
	int tapeLpos, mapLpos;
	struct Node *curNodeLeft; 
	BAT *indexLeft, *mapLeft, *viewLeft, *markedViewLeft, *viewHeadLeft;
	BUN curTupleLeft, baseLeft;
	oid curPosLeft, prevPosLeft;
	@1  curValueLeft;

	int tapeRpos, mapRpos;
	struct Node *curNodeRight; 
	BAT *indexRight, *mapRight, *viewRight, *markedViewRight, *viewHeadRight;
	BUN curTupleRight, baseRight;
	oid curPosRight, prevPosRight;
        @1  curValueRight;

	lng joinsDone=0;

	BAT *res;

	/* Get the cracker tape for the set of the left 
	   map or create one if it does not exist */
        tapeLpos = existsCrackerIndexSideways(*bidL1, -1);
        if (tapeLpos == -1)
                tapeLpos = CreateTape_@1(*bidL1);

        /* Get the left map */
        mapLpos = existsCrackerIndexSideways(*bidL1, *bidL2);

	/* Align the map based on the position of its cursor in the cracker tape */
        Sync_@1_@5(tapeLpos, mapLpos);

        /* Take the index of the map */
        if ((indexLeft = BATdescriptor(CrackerIndex[mapLpos].cid)) == NULL)
                throw(MAL, "crackers.simpleJoin", "Cannot access crack index");

        /* Take the map */
        if ((mapLeft = BATdescriptor(CrackerIndex[mapLpos].cbid)) == NULL)
                throw(MAL, "crackers.simpleJoin", "Cannot access crack index");

	/* Get the piece that holds the lowest values */
	curNodeLeft = getFirstNode(CrackerIndex[mapLpos].Tree);

	baseLeft      = BUNfirst(indexLeft);

	/* Get the cracker tape for the set of the right map or 
		create one if it does not exist */
        tapeRpos = existsCrackerIndexSideways(*bidR1, -1);
        if (tapeRpos == -1)
                tapeRpos = CreateTape_@1(*bidR1);

        /* Get the right map */
        mapRpos = existsCrackerIndexSideways(*bidR1, *bidR2);

        /* Align the map based on the position of its cursor in the cracker tape */
        Sync_@1_@5(tapeRpos, mapRpos);

        /* Take the index of the map */
        if ((indexRight = BATdescriptor(CrackerIndex[mapRpos].cid)) == NULL)
                throw(MAL, "crackers.simpleJoin", "Cannot access crack index");

        /* Take the map */
        if ((mapRight = BATdescriptor(CrackerIndex[mapRpos].cbid)) == NULL)
                throw(MAL, "crackers.simpleJoin", "Cannot access crack index");

        /* Get the piece that holds the lowest values */
        curNodeRight = getFirstNode(CrackerIndex[mapRpos].Tree);

        baseRight      = BUNfirst(indexRight);

	res = BATnew(TYPE_oid,TYPE_oid,5*BATcount(mapLeft));

	prevPosLeft = prevPosRight = 0;
	if (curNodeLeft == NULL || curNodeRight == NULL){
		curPosLeft  = BATcount(mapLeft ) -1;
		curPosRight = BATcount(mapRight) -1;
		@:JoinTwoPieces()@
		goto done;
	}

	curTupleLeft = baseLeft + curNodeLeft->position;
        curValueLeft =  *(@1*)Tloc(indexLeft, curTupleLeft);
        curPosLeft   = *(oid*)Hloc(indexLeft, curTupleLeft);

        curTupleRight = baseRight + curNodeRight->position;
        curValueRight =  *(@1*)Tloc(indexRight, curTupleRight);
        curPosRight   = *(oid*)Hloc(indexRight, curTupleRight);

	@:JoinTwoPieces()@
	
	while (1){

		if (curValueLeft < curValueRight || 
		((curValueLeft == curValueRight) && (curNodeLeft->inclusive == FALSE) && (curNodeRight->inclusive == TRUE))){
			@:MoveToNextPiece(@1,Left)@
		}
		else if (curValueRight < curValueLeft ||
                ((curValueLeft == curValueRight) && (curNodeRight->inclusive == FALSE) && (curNodeLeft->inclusive == TRUE))){
			@:MoveToNextPiece(@1,Right)@
		}
		else if ((curValueLeft == curValueRight) && (curNodeLeft->inclusive == curNodeRight->inclusive)){
			@:MoveToNextPiece(@1,Left)@
			@:MoveToNextPiece(@1,Right)@
		}

		if (curNodeLeft == NULL || curNodeRight == NULL){
			curPosLeft  = BATcount(mapLeft ) -1;
			curPosRight = BATcount(mapRight) -1;
			@:JoinTwoPieces()@
			break;
		}

		@:JoinTwoPieces()@

	}
	

	done:;

        *resid = res->batCacheid;
        BBPkeepref(*resid);

        BBPunfix(indexLeft->batCacheid);
        BBPunfix(indexRight->batCacheid);
        BBPunfix(mapLeft->batCacheid);
        BBPunfix(mapRight->batCacheid);

	T2=GDKusec();

	printf("Total  " LLFMT " Join " LLFMT " Rest  " LLFMT " Joins " LLFMT " Crack " LLFMT " Pieces " LLFMT " \n", 
			T2-T1, TJtotal, ((T2-T1)-TJtotal)-TCtotal, joinsDone, TCtotal, CrackerIndex[mapLpos].pieces + CrackerIndex[mapRpos].pieces );

	return MAL_SUCCEED;
}	

str CRKcrackJoin_@1_@5(int *resid, int *bidL1, int *bidL2, int *bidR1, int *bidR2){
	lng T1=GDKusec(), TJtotal = 0, T2, TCtotal = 0, TC1, TC2;
	int tapeLpos, mapLpos;
	struct Node *curNodeLeft; 
	BAT *indexLeft, *mapLeft, *viewLeft, *markedViewLeft, *viewHeadLeft;
	BUN curTupleLeft, baseLeft;
	oid curPosLeft, prevPosLeft;
	@1  curValueLeft;
	bit crackedLeft;

	int tapeRpos, mapRpos;
	struct Node *curNodeRight; 
	BAT *indexRight, *mapRight, *viewRight, *markedViewRight, *viewHeadRight;
	BUN curTupleRight, baseRight;
	oid curPosRight, prevPosRight;
        @1  curValueRight;
	bit crackedRight;

	BAT *res;
	oid newPosition=0;

	lng crackedOperationsLeft = 0 , crackedOperationsRight = 0, joinsDone = 0;

	/* Get the cracker tape for the set of the left map or create one if it does not exist */
        tapeLpos = existsCrackerIndexSideways(*bidL1, -1);
        if (tapeLpos == -1)
                tapeLpos = CreateTape_@1(*bidL1);

        /* Get the left map */
        mapLpos = existsCrackerIndexSideways(*bidL1, *bidL2);

	/* Align the map based on the position of its cursor in the cracker tape */
        Sync_@1_@5(tapeLpos, mapLpos);

        /* Take the index of the map */
        if ((indexLeft = BATdescriptor(CrackerIndex[mapLpos].cid)) == NULL)
                throw(MAL, "crackers.simpleJoin", "Cannot access crack index");

        /* Take the map */
        if ((mapLeft = BATdescriptor(CrackerIndex[mapLpos].cbid)) == NULL)
                throw(MAL, "crackers.simpleJoin", "Cannot access crack index");

	/* Get the piece that holds the lowest values */
	curNodeLeft = getFirstNode(CrackerIndex[mapLpos].Tree);

	baseLeft      = BUNfirst(indexLeft);

	/* Get the cracker tape for the set of the right map or create one if it does not exist */
        tapeRpos = existsCrackerIndexSideways(*bidR1, -1);
        if (tapeRpos == -1)
                tapeRpos = CreateTape_@1(*bidR1);

        /* Get the right map */
        mapRpos = existsCrackerIndexSideways(*bidR1, *bidR2);

        /* Align the map based on the position of its cursor in the cracker tape */
        Sync_@1_@5(tapeRpos, mapRpos);

        /* Take the index of the map */
        if ((indexRight = BATdescriptor(CrackerIndex[mapRpos].cid)) == NULL)
                throw(MAL, "crackers.simpleJoin", "Cannot access crack index");

        /* Take the map */
        if ((mapRight = BATdescriptor(CrackerIndex[mapRpos].cbid)) == NULL)
                throw(MAL, "crackers.simpleJoin", "Cannot access crack index");

#ifdef DEBUG_CRACKERS_JOIN
	printf("maps\n");
	BATprint(mapLeft);
	BATprint(mapRight);
#endif

        /* Get the piece that holds the lowest values */
        curNodeRight = getFirstNode(CrackerIndex[mapRpos].Tree);

        baseRight      = BUNfirst(indexRight);

	res = BATnew(TYPE_oid,TYPE_oid,5*BATcount(mapLeft));
	
	prevPosLeft = prevPosRight = 0;

	while (curNodeLeft != NULL && curNodeRight != NULL){

#ifdef DEBUG_CRACKERS_JOIN
	printf(" new loop maps\n");
	BATprint(mapLeft);
	BATprint(mapRight);
#endif
		crackedLeft = crackedRight = FALSE;


		curTupleLeft = baseLeft + curNodeLeft->position;
       		curValueLeft =  *(@1 *)Tloc(indexLeft, curTupleLeft);
        	curPosLeft   =  *(oid*)Hloc(indexLeft, curTupleLeft);

        	curTupleRight = baseRight + curNodeRight->position;
        	curValueRight = *(@1 *)Tloc(indexRight, curTupleRight);
        	curPosRight   = *(oid*)Hloc(indexRight, curTupleRight);

		if (curPosLeft ==0 &&  prevPosLeft==0)
			if ( *(@1 *)Tloc(mapLeft,0)>curValueLeft){
				curNodeLeft = curNodeLeft->nextValue;/*findNextPiece(curNodeLeft);*/
				continue;
			}	 
		if (curPosRight ==0 &&  prevPosRight==0)
			if ( *(@1 *)Tloc(mapRight,0)>curValueRight){
				curNodeRight = curNodeRight->nextValue;/*findNextPiece(curNodeRight);*/
				continue;
			}	 

#ifdef DEBUG_CRACKERS_JOIN
		printf(" leftVal %d rightVal %d \n", curValueLeft, curValueRight);
		printf(" prevPosLeft " LLFMT " curPosLeft " LLFMT " \n", prevPosLeft,curPosLeft);
		printf(" prevPosRight " LLFMT " curPosRight " LLFMT " \n", prevPosRight,curPosRight);
#endif

		if (curValueLeft < curValueRight || 
		((curValueLeft == curValueRight) && (curNodeLeft->inclusive == FALSE) && (curNodeRight->inclusive == TRUE))){

			crackedOperationsRight++;

			TC1=GDKusec();	
			if (curNodeLeft->inclusive == TRUE)
		                CRKcrackUnorderedZeroSideways_RE_@1_@5(mapRight, curValueLeft, prevPosRight, curPosRight, &newPosition);
        		else 
                		CRKcrackUnorderedZeroSideways_LE_@1_@5(mapRight, curValueLeft, prevPosRight, curPosRight, &newPosition);
			TC2=GDKusec();	
			TCtotal+=TC2-TC1;

			if (newPosition < prevPosRight || newPosition ==(oid)-1){
				/*Empty piece*/
				prevPosLeft   = curPosLeft+1;
				curNodeLeft = curNodeLeft->nextValue;/*findNextPiece(curNodeLeft);*/
				continue;
			}
			if (newPosition < curPosRight){
				addCrackerIndex_@1(mapRpos, &curValueLeft, curNodeLeft->inclusive, newPosition, indexRight);
				AddToTape_@1(mapRpos, @1_nil, curValueLeft, curNodeLeft->inclusive, curNodeLeft->inclusive);
				curPosRight = newPosition;
				crackedRight = TRUE;
			}
		}
		else if (curValueRight < curValueLeft ||
                ((curValueLeft == curValueRight) && (curNodeRight->inclusive == FALSE) && (curNodeLeft->inclusive == TRUE))){

			crackedOperationsLeft++;

			TC1=GDKusec();	
			if (curNodeRight->inclusive == TRUE)
		                CRKcrackUnorderedZeroSideways_RE_@1_@5(mapLeft, curValueRight, prevPosLeft, curPosLeft, &newPosition);
        		else 
                		CRKcrackUnorderedZeroSideways_LE_@1_@5(mapLeft, curValueRight, prevPosLeft, curPosLeft, &newPosition);
			TC2=GDKusec();	
			TCtotal+=TC2-TC1;

			if (newPosition < prevPosLeft || newPosition ==(oid)-1){
				/*Empty piece*/
				prevPosRight   = curPosRight+1;
				curNodeRight = curNodeRight->nextValue;/*findNextPiece(curNodeRight);*/
				continue;
			}
			if (newPosition < curPosLeft){
				addCrackerIndex_@1(mapLpos, &curValueRight, curNodeRight->inclusive, newPosition, indexLeft);
				AddToTape_@1(mapLpos, @1_nil, curValueRight, curNodeRight->inclusive, curNodeRight->inclusive);
				curPosLeft = newPosition;
				crackedLeft = TRUE;
			}
		}

		@:JoinTwoPieces()@

		prevPosLeft = curPosLeft+1;
		if (crackedLeft == FALSE)
			curNodeLeft = curNodeLeft->nextValue;
				
		prevPosRight = curPosRight+1;
		if (crackedRight == FALSE)
        		curNodeRight = curNodeRight->nextValue;
	}

	while(1){
		crackedLeft = crackedRight = FALSE;

		if (curNodeLeft == NULL)
			curPosLeft  = BATcount(mapLeft)-1;
		else {
			curTupleLeft = baseLeft + curNodeLeft->position;
        	        curValueLeft = *(@1 *)Tloc(indexLeft, curTupleLeft);
	                curPosLeft   = *(oid*)Hloc(indexLeft, curTupleLeft);
		}
		if (curNodeRight == NULL)
			curPosRight  = BATcount(mapRight)-1;
		else {
			curTupleRight = baseRight + curNodeRight->position;
   	             	curValueRight = *(@1 *)Tloc(indexRight, curTupleRight);
        	        curPosRight   = *(oid*)Hloc(indexRight, curTupleRight);	
		}
		
#ifdef DEBUG_CRACKERS_JOIN
		printf(" leftVal %d rightVal %d \n", curValueLeft, curValueRight);
		printf(" prevPosLeft " LLFMT " curPosLeft " LLFMT " \n", prevPosLeft,curPosLeft);
		printf(" prevPosRight " LLFMT " curPosRight " LLFMT " \n", prevPosRight,curPosRight);
#endif

		if (curNodeLeft != NULL && curNodeRight == NULL){	
			crackedOperationsRight++;

			TC1=GDKusec();	
			if (curNodeLeft->inclusive == TRUE)
		                CRKcrackUnorderedZeroSideways_RE_@1_@5(mapRight, curValueLeft, prevPosRight, curPosRight, &newPosition);
        		else 
                		CRKcrackUnorderedZeroSideways_LE_@1_@5(mapRight, curValueLeft, prevPosRight, curPosRight, &newPosition);
			TC2=GDKusec();	
			TCtotal+=TC2-TC1;

			if (newPosition < prevPosRight || newPosition ==(oid)-1){
				/*Empty piece*/
				prevPosLeft   = curPosLeft+1;
				curNodeLeft = curNodeLeft->nextValue;/*findNextPiece(curNodeLeft);*/
				continue;
			}
			if (newPosition < curPosRight){
				addCrackerIndex_@1(mapRpos, &curValueLeft, curNodeLeft->inclusive, newPosition, indexRight);
				AddToTape_@1(mapRpos, @1_nil, curValueLeft, curNodeLeft->inclusive, curNodeLeft->inclusive);
				curPosRight = newPosition;
				crackedRight = TRUE;
			}
			else {  /* this means that there is no chance to join with the future pieces of the other side */
				@:JoinTwoPieces()@
				break;
			}
		}
		else if (curNodeLeft == NULL && curNodeRight != NULL){

			crackedOperationsLeft++;

			TC1=GDKusec();	
			if (curNodeRight->inclusive == TRUE)
		                CRKcrackUnorderedZeroSideways_RE_@1_@5(mapLeft, curValueRight, prevPosLeft, curPosLeft, &newPosition);
        		else 
                		CRKcrackUnorderedZeroSideways_LE_@1_@5(mapLeft, curValueRight, prevPosLeft, curPosLeft, &newPosition);
			TC2=GDKusec();	
			TCtotal+=TC2-TC1;

			if (newPosition < prevPosLeft || newPosition ==(oid)-1){
				/*Empty piece*/
				prevPosRight   = curPosRight+1;
				curNodeRight = curNodeRight->nextValue;/*findNextPiece(curNodeRight);*/
				continue;
			}
			if (newPosition < curPosLeft){
				addCrackerIndex_@1(mapLpos, &curValueRight, curNodeRight->inclusive, newPosition, indexLeft);
				AddToTape_@1(mapLpos, @1_nil, curValueRight, curNodeRight->inclusive, curNodeRight->inclusive);
				curPosLeft = newPosition;
				crackedLeft = TRUE;
			}
			else {
				@:JoinTwoPieces()@
				break;
			}
		}
		else if (curNodeLeft == NULL && curNodeRight == NULL){
			@:JoinTwoPieces()@
			break;
		}			

		@:JoinTwoPieces()@

		prevPosLeft = curPosLeft+1;
		if (crackedLeft == FALSE && curNodeLeft != NULL)
			curNodeLeft = curNodeLeft->nextValue;
				
		prevPosRight = curPosRight+1;
		if (crackedRight == FALSE && curNodeRight != NULL)
        		curNodeRight = curNodeRight->nextValue;
	}
	
        *resid = res->batCacheid;
        BBPkeepref(*resid);

        BBPunfix(indexLeft->batCacheid);
        BBPunfix(indexRight->batCacheid);
        BBPunfix(mapLeft->batCacheid);
        BBPunfix(mapRight->batCacheid);

	T2=GDKusec();

	printf("Total  " LLFMT " Join " LLFMT " Rest  " LLFMT " Joins " LLFMT " Crack " LLFMT " Pieces " LLFMT " \n", 
			T2-T1, TJtotal, ((T2-T1)-TJtotal)-TCtotal, joinsDone, TCtotal, CrackerIndex[mapLpos].pieces + CrackerIndex[mapRpos].pieces );

	return MAL_SUCCEED;
}	

str CRKcacheConsciousCrackHashJoinAlignOnly_@1_@5(int *resid, int *bidL1, int *bidL2, int *bidR1, int *bidR2, lng *pieceSize, lng *joinThreshold){
	lng T1=GDKusec(), TJtotal = 0, T2, TCtotal = 0, TC1, TC2;
	
	int tapeLpos, mapLpos;
	struct Node *curNodeLeft, *prevNodeLeft; 
	BAT *indexLeft, *mapLeft;
	BUN baseLeft;
	oid curPosLeft, prevPosLeft, cprevPosLeft;
	@1  curValueLeft;

	int tapeRpos, mapRpos;
	struct Node *curNodeRight, *prevNodeRight; 
	BAT *indexRight, *mapRight;
	BUN baseRight;
	oid curPosRight, prevPosRight, cprevPosRight;
        @1  curValueRight;

	BAT *res;
	oid newPosition=0;

	oid sizeLeft, sizeRight;
	oid iterations = 0;

	lng joinsDone = 0;

	(void)joinThreshold;

	/* Get the cracker tape for the set of the left map or create one if it does not exist */
        tapeLpos = existsCrackerIndexSideways(*bidL1, -1);
        if (tapeLpos == -1)
                tapeLpos = CreateTape_@1(*bidL1);

        /* Get the left map */
        mapLpos = existsCrackerIndexSideways(*bidL1, *bidL2);

	/* Align the map based on the position of its cursor in the cracker tape */
        Sync_@1_@5(tapeLpos, mapLpos);

        /* Take the index of the map */
        if ((indexLeft = BATdescriptor(CrackerIndex[mapLpos].cid)) == NULL)
                throw(MAL, "crackers.simpleJoin", "Cannot access crack index");

        /* Take the map */
        if ((mapLeft = BATdescriptor(CrackerIndex[mapLpos].cbid)) == NULL)
                throw(MAL, "crackers.simpleJoin", "Cannot access crack index");

	/* Get the piece that holds the lowest values */
	curNodeLeft = getFirstNode(CrackerIndex[mapLpos].Tree);

	baseLeft      = BUNfirst(indexLeft);

	/* Get the cracker tape for the set of the right map or create one if it does not exist */
        tapeRpos = existsCrackerIndexSideways(*bidR1, -1);
        if (tapeRpos == -1)
                tapeRpos = CreateTape_@1(*bidR1);

        /* Get the right map */
        mapRpos = existsCrackerIndexSideways(*bidR1, *bidR2);

        /* Align the map based on the position of its cursor in the cracker tape */
        Sync_@1_@5(tapeRpos, mapRpos);

        /* Take the index of the map */
        if ((indexRight = BATdescriptor(CrackerIndex[mapRpos].cid)) == NULL)
                throw(MAL, "crackers.simpleJoin", "Cannot access crack index");

        /* Take the map */
        if ((mapRight = BATdescriptor(CrackerIndex[mapRpos].cbid)) == NULL)
                throw(MAL, "crackers.simpleJoin", "Cannot access crack index");
	
        /* Get the piece that holds the lowest values */
        curNodeRight = getFirstNode(CrackerIndex[mapRpos].Tree);

        baseRight      = BUNfirst(indexRight);

	res = BATnew(TYPE_oid,TYPE_oid,5*BATcount(mapLeft));
	
	prevPosLeft   = prevPosRight   = 0;
	prevNodeLeft  = prevNodeRight  = NULL;
	while (curNodeLeft != NULL && curNodeRight != NULL){
	
		iterations++;
		cprevPosRight = prevPosRight;
		cprevPosLeft  = prevPosLeft;

       		curValueLeft = *(@1 *)Tloc(indexLeft, baseLeft + curNodeLeft->position);
        	curPosLeft   = curNodeLeft->indexPosition; 

        	curValueRight = *(@1 *)Tloc(indexRight, baseRight + curNodeRight->position);
        	curPosRight   = curNodeRight->indexPosition;
		
		if (curPosLeft ==0 &&  prevPosLeft==0)
			if ( *(@1 *)Tloc(mapLeft,0)>curValueLeft){
				prevNodeLeft  = curNodeLeft;
				curNodeLeft = curNodeLeft->nextValue;/*findNextPiece(curNodeLeft);*/
				continue;
			}	 
		if (curPosRight ==0 &&  prevPosRight==0)
			if ( *(@1 *)Tloc(mapRight,0)>curValueRight){
				prevNodeRight  = curNodeRight;
				curNodeRight = curNodeRight->nextValue;/*findNextPiece(curNodeRight);*/
				continue;
			}	 


		sizeLeft  = curPosLeft  - prevPosLeft  + 1;
		sizeRight = curPosRight - prevPosRight + 1;
		
		if (sizeLeft < (oid)*pieceSize) {
				while (curValueLeft > curValueRight ||
                			((curValueLeft == curValueRight) && 
						(curNodeRight->inclusive == FALSE) && (curNodeLeft->inclusive == TRUE))){ 
					if (curNodeRight->nextValue == NULL) goto cont;
					cprevPosRight = curPosRight+1;
					curNodeRight = curNodeRight->nextValue;
					curValueRight = *(@1 *)Tloc(indexRight, baseRight + curNodeRight->position);
					curPosRight   = curNodeRight->indexPosition;
				}
			while (sizeLeft < (oid)*pieceSize){

				if (curNodeLeft->nextValue == NULL) goto cont;
				if (curNodeLeft->nextValue->indexPosition - prevPosLeft+1 > (oid)*pieceSize){
					if (curNodeLeft->nextValue->indexPosition - prevPosLeft+1 - (oid)*pieceSize > (oid)*pieceSize - sizeLeft)
						goto checkRight;
				}
 				cprevPosLeft = curPosLeft+1;
				curNodeLeft = curNodeLeft->nextValue;
				curValueLeft = *(@1 *)Tloc(indexLeft, baseLeft + curNodeLeft->position);
				curPosLeft   = curNodeLeft->indexPosition; 
				sizeLeft  = curPosLeft - prevPosLeft+1;
				while (curValueLeft > curValueRight ||
                			((curValueLeft == curValueRight) && 
						(curNodeRight->inclusive == FALSE) && (curNodeLeft->inclusive == TRUE))){ 
					if (curNodeRight->nextValue == NULL) goto cont;
					cprevPosRight = curPosRight+1;
					curNodeRight = curNodeRight->nextValue;
					curValueRight = *(@1 *)Tloc(indexRight, baseRight + curNodeRight->position);
					curPosRight   = curNodeRight->indexPosition;
				}
				
			}
		}
		checkRight:;
		if (sizeRight < (oid)*pieceSize){
			while (curValueRight > curValueLeft ||
				((curValueLeft == curValueRight) && 
					(curNodeLeft->inclusive == FALSE) && (curNodeRight->inclusive == TRUE))){ 
				if (curNodeLeft->nextValue == NULL) goto cont;
				cprevPosLeft = curPosLeft+1;
				curNodeLeft = curNodeLeft->nextValue;
				curValueLeft = *(@1 *)Tloc(indexLeft, baseLeft + curNodeLeft->position);
				curPosLeft   = curNodeLeft->indexPosition; 
			}
			while (sizeRight < (oid)*pieceSize){
				if (curNodeRight->nextValue == NULL) goto cont;
				if (curNodeRight->nextValue->indexPosition - prevPosRight+1 > (oid)*pieceSize){
					if (curNodeRight->nextValue->indexPosition - prevPosRight+1 - (oid)*pieceSize > (oid)*pieceSize - sizeRight)
						goto cont;
				}
				cprevPosRight = curPosRight+1;
				curNodeRight = curNodeRight->nextValue;
				curValueRight = *(@1 *)Tloc(indexRight, baseRight + curNodeRight->position);
				curPosRight   = curNodeRight->indexPosition;
				sizeRight  = curPosRight - prevPosRight+1;
				while (curValueRight > curValueLeft ||
                			((curValueLeft == curValueRight) && 
						(curNodeLeft->inclusive == FALSE) && (curNodeRight->inclusive == TRUE))) { 
					if (curNodeLeft->nextValue == NULL) goto cont;
					cprevPosLeft = curPosLeft+1;
					curNodeLeft = curNodeLeft->nextValue;
					curValueLeft = *(@1 *)Tloc(indexLeft, baseLeft + curNodeLeft->position);
					curPosLeft   = curNodeLeft->indexPosition; 
				}
			}
		}
		
		cont:;
		if (curValueLeft < curValueRight || 
		((curValueLeft == curValueRight) && (curNodeLeft->inclusive == FALSE) && (curNodeRight->inclusive == TRUE))){

			TC1=GDKusec();	
			if (curNodeLeft->inclusive == TRUE)
		                CRKcrackUnorderedZeroSideways_RE_@1_@5(mapRight, curValueLeft, cprevPosRight, curPosRight, &newPosition);
        		else 
                		CRKcrackUnorderedZeroSideways_LE_@1_@5(mapRight, curValueLeft, cprevPosRight, curPosRight, &newPosition);
					TC2=GDKusec();	
					TCtotal+=TC2-TC1;

			if (newPosition < cprevPosRight){
				if (cprevPosRight == prevPosRight){
					prevNodeLeft = curNodeLeft;
					curNodeLeft  = curNodeLeft->nextValue;
					continue;
				}
				curPosRight = cprevPosRight - 1;
				curNodeRight = findPreviousPieceWalkingBack(curNodeRight);
			}else if (newPosition < curPosRight){
				curNodeRight = addCrackerIndex_@1(mapRpos, &curValueLeft, curNodeLeft->inclusive, newPosition, indexRight);
				AddToTape_@1(mapRpos, @1_nil, curValueLeft, curNodeLeft->inclusive, curNodeLeft->inclusive);
				curPosRight = newPosition;
			}
		}
		else if (curValueRight < curValueLeft ||
                ((curValueLeft == curValueRight) && (curNodeRight->inclusive == FALSE) && (curNodeLeft->inclusive == TRUE))){
			TC1=GDKusec();	
			if (curNodeRight->inclusive == TRUE)
		                CRKcrackUnorderedZeroSideways_RE_@1_@5(mapLeft, curValueRight, cprevPosLeft, curPosLeft, &newPosition);
        		else 
                		CRKcrackUnorderedZeroSideways_LE_@1_@5(mapLeft, curValueRight, cprevPosLeft, curPosLeft, &newPosition);
			TC2=GDKusec();	
			TCtotal+=TC2-TC1;

			if (newPosition < cprevPosLeft){
				if (cprevPosLeft == prevPosLeft){
					prevNodeRight = curNodeRight;
					curNodeRight  = curNodeRight->nextValue;
					continue;
				}
				curPosLeft = cprevPosLeft - 1;
				curNodeLeft = findPreviousPieceWalkingBack(curNodeLeft);
			}else if (newPosition < curPosLeft){
				curNodeLeft = addCrackerIndex_@1(mapLpos, &curValueRight, curNodeRight->inclusive, newPosition, indexLeft);
				AddToTape_@1(mapLpos, @1_nil, curValueRight, curNodeRight->inclusive, curNodeRight->inclusive);
				curPosLeft = newPosition;
			}
		}


		prevNodeLeft  = curNodeLeft;
		curNodeLeft = curNodeLeft->nextValue;

		prevNodeRight  = curNodeRight;
		curNodeRight = curNodeRight->nextValue;

		prevPosLeft  = prevNodeLeft->indexPosition  + 1;
		prevPosRight = prevNodeRight->indexPosition + 1;
	}

	while(1){
		iterations++;
		
		prevPosLeft   = prevNodeLeft ==NULL?0:(prevNodeLeft->indexPosition==0?0:prevNodeLeft->indexPosition + 1);
		prevPosRight  = prevNodeRight==NULL?0:(prevNodeRight->indexPosition==0?0:prevNodeRight->indexPosition + 1);

		if (curNodeLeft == NULL)
			curPosLeft  = BATcount(mapLeft)-1;
		else {
        	        curValueLeft = *(@1 *)Tloc(indexLeft, baseLeft + curNodeLeft->position);
	                curPosLeft   = curNodeLeft->indexPosition;
		}
		if (curNodeRight == NULL)
			curPosRight  = BATcount(mapRight)-1;
		else {
   	             	curValueRight = *(@1 *)Tloc(indexRight, baseRight + curNodeRight->position);
        	        curPosRight   = curNodeRight->indexPosition;
		}

		
		sizeLeft  = curPosLeft  - prevPosLeft  + 1;
		sizeRight = curPosRight - prevPosRight + 1;

		if (sizeLeft < (oid)*pieceSize && curNodeLeft != NULL) {
			while (sizeLeft < (oid)*pieceSize){
				if (curNodeLeft->nextValue == NULL)  {
					if ( (BATcount(mapLeft)-1)- prevPosLeft <(oid)*pieceSize){
						curPosLeft  = BATcount(mapLeft)-1;
						curNodeLeft = NULL;
					}
					break;
				}
				if (curNodeLeft->nextValue->indexPosition - prevPosLeft+1 > (oid)*pieceSize){
					if (curNodeLeft->nextValue->indexPosition - prevPosLeft+1 - (oid)*pieceSize > (oid)*pieceSize - sizeLeft)
						goto checkRight2;
				}
				curNodeLeft = curNodeLeft->nextValue;
				curPosLeft   = curNodeLeft->indexPosition; 
        	        	curValueLeft = *(@1 *)Tloc(indexLeft, baseLeft + curNodeLeft->position);
				sizeLeft  = curPosLeft - prevPosLeft + 1;
			}
		}
		checkRight2:;
		if (sizeRight < (oid)*pieceSize && curNodeRight != NULL){
			while (sizeRight < (oid)*pieceSize){
				if (curNodeRight->nextValue == NULL) {
					if ( (BATcount(mapRight)-1)- prevPosRight <(oid)*pieceSize){
						curPosRight  = BATcount(mapRight)-1;
						curNodeRight = NULL;
					}
					break;
				}
				if (curNodeRight->nextValue->indexPosition - prevPosRight+1 > (oid)*pieceSize){
					if (curNodeRight->nextValue->indexPosition - prevPosRight+1 - (oid)*pieceSize > (oid)*pieceSize - sizeRight)
						goto cont2;
				}
				curNodeRight = curNodeRight->nextValue;
				curPosRight   = curNodeRight->indexPosition;
   	             		curValueRight = *(@1 *)Tloc(indexRight, baseRight + curNodeRight->position);
				sizeRight  = curPosRight - prevPosRight + 1;
			}
		}
		cont2:;	
		if (curNodeLeft != NULL && curNodeRight == NULL){	
			
			TC1=GDKusec();	
			if (curNodeLeft->inclusive == TRUE)

		                CRKcrackUnorderedZeroSideways_RE_@1_@5(mapRight, curValueLeft, prevPosRight, curPosRight, &newPosition);
        		else 
                		CRKcrackUnorderedZeroSideways_LE_@1_@5(mapRight, curValueLeft, prevPosRight, curPosRight, &newPosition);

			TC2=GDKusec();	
			TCtotal+=TC2-TC1;
			if (newPosition < prevPosRight){
				prevNodeLeft = curNodeLeft;
				curNodeLeft  = curNodeLeft->nextValue;	
				continue;
			}
			else if (newPosition < curPosRight){
				curNodeRight = addCrackerIndex_@1(mapRpos, &curValueLeft, curNodeLeft->inclusive, newPosition, indexRight);
				AddToTape_@1(mapRpos, @1_nil, curValueLeft, curNodeLeft->inclusive, curNodeLeft->inclusive);
				curPosRight = newPosition;
			}
			else {  /* this means that there is no chance to join with the future pieces of the other side */


				break;
			}
		}
		else if (curNodeLeft == NULL && curNodeRight != NULL){

			TC1=GDKusec();	
			if (curNodeRight->inclusive == TRUE)
		                CRKcrackUnorderedZeroSideways_RE_@1_@5(mapLeft, curValueRight, prevPosLeft+1, curPosLeft, &newPosition);
        		else 
                		CRKcrackUnorderedZeroSideways_LE_@1_@5(mapLeft, curValueRight, prevPosLeft+1, curPosLeft, &newPosition);

			TC2=GDKusec();	
			TCtotal+=TC2-TC1;
			if (newPosition < prevPosLeft){
				prevNodeRight = curNodeRight;
				curNodeRight  = curNodeRight->nextValue;	
				continue;
			}else
			if (newPosition < curPosLeft){
				curNodeLeft = addCrackerIndex_@1(mapLpos, &curValueRight, curNodeRight->inclusive, newPosition, indexLeft);
				AddToTape_@1(mapLpos, @1_nil, curValueRight, curNodeRight->inclusive, curNodeRight->inclusive);
				curPosLeft = newPosition;
			}
			else {
				break;
			}
		}

		if (curNodeLeft == NULL && curNodeRight == NULL)
			break;

		if (curNodeLeft == NULL || curNodeRight == NULL)
                	throw(MAL, "crack Join", "Unexpected error: Crack maps were not aligned succesfully.");

		prevNodeLeft  = curNodeLeft;
		curNodeLeft = curNodeLeft->nextValue;
	
		prevNodeRight  = curNodeRight;
		curNodeRight = curNodeRight->nextValue;
	}
	
        *resid = res->batCacheid;
        BBPkeepref(*resid);

        BBPunfix(indexLeft->batCacheid);
        BBPunfix(indexRight->batCacheid);
        BBPunfix(mapLeft->batCacheid);
        BBPunfix(mapRight->batCacheid);

	T2=GDKusec();

	printf("Total  " LLFMT " Join " LLFMT " Rest  " LLFMT " Joins " LLFMT " Crack " LLFMT " Pieces " LLFMT " \n", 
			T2-T1, TJtotal, ((T2-T1)-TJtotal)-TCtotal, joinsDone, TCtotal, CrackerIndex[mapLpos].pieces + CrackerIndex[mapRpos].pieces );
	return MAL_SUCCEED;

}	

str CRKcacheConsciousCrackHashJoin_@1_@5(int *resid, int *bidL1, int *bidL2, int *bidR1, int *bidR2, lng *pieceSize, lng *joinThreshold){

	lng T1=GDKusec(), TJtotal = 0, T2, TCtotal = 0, TC1, TC2;
	
	int tapeLpos, mapLpos;
	struct Node *curNodeLeft, *prevNodeLeft; 
	BAT *indexLeft, *mapLeft, *viewLeft, *markedViewLeft, *viewHeadLeft;
	BUN baseLeft;
	oid curPosLeft, prevPosLeft, cprevPosLeft;
	@1  curValueLeft;
	bit existsHashTableLeft;

	int tapeRpos, mapRpos;
	struct Node *curNodeRight, *prevNodeRight; 
	BAT *indexRight, *mapRight, *viewRight, *markedViewRight, *viewHeadRight;
	BUN baseRight;
	oid curPosRight, prevPosRight, cprevPosRight;
        @1  curValueRight;
	bit existsHashTableRight;

	bit invalidateHash;
	
	BAT *res;
	oid newPosition=0;

	oid sizeLeft, sizeRight;
	oid iterations = 0;

	lng joinsDone = 0;
	lng reversingJoinOrder = 0;

	struct Node *temp;
	

	/* Get the cracker tape for the set of the left map or create one if it does not exist */
        tapeLpos = existsCrackerIndexSideways(*bidL1, -1);
        if (tapeLpos == -1)
                tapeLpos = CreateTape_@1(*bidL1);

        /* Get the left map */
        mapLpos = existsCrackerIndexSideways(*bidL1, *bidL2);

	/* Align the map based on the position of its cursor in the cracker tape */
        Sync_@1_@5(tapeLpos, mapLpos);

        /* Take the index of the map */
        if ((indexLeft = BATdescriptor(CrackerIndex[mapLpos].cid)) == NULL)
                throw(MAL, "crackers.simpleJoin", "Cannot access crack index");

        /* Take the map */
        if ((mapLeft = BATdescriptor(CrackerIndex[mapLpos].cbid)) == NULL)
                throw(MAL, "crackers.simpleJoin", "Cannot access crack index");

	/* Get the piece that holds the lowest values */
	curNodeLeft = getFirstNode(CrackerIndex[mapLpos].Tree);

	baseLeft      = BUNfirst(indexLeft);

	/* Get the cracker tape for the set of the right map or create one if it does not exist */
        tapeRpos = existsCrackerIndexSideways(*bidR1, -1);
        if (tapeRpos == -1)
                tapeRpos = CreateTape_@1(*bidR1);

        /* Get the right map */
        mapRpos = existsCrackerIndexSideways(*bidR1, *bidR2);

        /* Align the map based on the position of its cursor in the cracker tape */
        Sync_@1_@5(tapeRpos, mapRpos);

        /* Take the index of the map */
        if ((indexRight = BATdescriptor(CrackerIndex[mapRpos].cid)) == NULL)
                throw(MAL, "crackers.simpleJoin", "Cannot access crack index");

        /* Take the map */
        if ((mapRight = BATdescriptor(CrackerIndex[mapRpos].cbid)) == NULL)
                throw(MAL, "crackers.simpleJoin", "Cannot access crack index");
	
        /* Get the piece that holds the lowest values */
        curNodeRight = getFirstNode(CrackerIndex[mapRpos].Tree);

        baseRight      = BUNfirst(indexRight);

	res = BATnew(TYPE_oid,TYPE_oid,BATcount(mapLeft));
	
	prevPosLeft   = prevPosRight   = 0;
	prevNodeLeft  = prevNodeRight  = NULL;
	while (curNodeLeft != NULL && curNodeRight != NULL){
	
		iterations++;
		cprevPosRight = prevPosRight;
		cprevPosLeft  = prevPosLeft;


		existsHashTableLeft = existsHashTableRight = FALSE;

       		curValueLeft = *(@1 *)Tloc(indexLeft, baseLeft + curNodeLeft->position);
        	curPosLeft   = curNodeLeft->indexPosition; 

        	curValueRight = *(@1 *)Tloc(indexRight, baseRight + curNodeRight->position);
        	curPosRight   = curNodeRight->indexPosition;
		
		if (curPosLeft ==0 &&  prevPosLeft==0)
			if ( *(@1 *)Tloc(mapLeft,0)>curValueLeft){
				prevNodeLeft  = curNodeLeft;
				curNodeLeft = curNodeLeft->nextValue;/*findNextPiece(curNodeLeft);*/
				continue;
			}	 
		if (curPosRight ==0 &&  prevPosRight==0)
			if ( *(@1 *)Tloc(mapRight,0)>curValueRight){
				prevNodeRight  = curNodeRight;
				curNodeRight = curNodeRight->nextValue;/*findNextPiece(curNodeRight);*/
				continue;
			}	 


		sizeLeft  = curPosLeft  - prevPosLeft  + 1;
		sizeRight = curPosRight - prevPosRight + 1;
		
		if (sizeLeft < (oid)*pieceSize) {
				while (curValueLeft > curValueRight ||
                			((curValueLeft == curValueRight) && 
						(curNodeRight->inclusive == FALSE) && (curNodeLeft->inclusive == TRUE))){ 
					if (curNodeRight->nextValue == NULL) goto cont;
					cprevPosRight = curPosRight+1;
					curNodeRight = curNodeRight->nextValue;
					curValueRight = *(@1 *)Tloc(indexRight, baseRight + curNodeRight->position);
					curPosRight   = curNodeRight->indexPosition;
				}
			while (sizeLeft < (oid)*pieceSize){

				if (curNodeLeft->nextValue == NULL) goto cont;
				if (curNodeLeft->nextValue->indexPosition - prevPosLeft+1 > (oid)*pieceSize){
				/*	if (curNodeLeft->nextValue->indexPosition - prevPosLeft+1 - (oid)*pieceSize > (oid)*pieceSize - sizeLeft)  */
						goto checkRight;
				}
 				cprevPosLeft = curPosLeft+1;
				curNodeLeft = curNodeLeft->nextValue;
				curValueLeft = *(@1 *)Tloc(indexLeft, baseLeft + curNodeLeft->position);
				curPosLeft   = curNodeLeft->indexPosition; 
				sizeLeft  = curPosLeft - prevPosLeft+1;
				while (curValueLeft > curValueRight ||
                			((curValueLeft == curValueRight) && 
						(curNodeRight->inclusive == FALSE) && (curNodeLeft->inclusive == TRUE))){ 
					if (curNodeRight->nextValue == NULL) goto cont;
					cprevPosRight = curPosRight+1;
					curNodeRight = curNodeRight->nextValue;
					curValueRight = *(@1 *)Tloc(indexRight, baseRight + curNodeRight->position);
					curPosRight   = curNodeRight->indexPosition;
				}
				
			}
		}
		checkRight:;
		if (sizeRight < (oid)*pieceSize){
			while (curValueRight > curValueLeft ||
				((curValueLeft == curValueRight) && 
					(curNodeLeft->inclusive == FALSE) && (curNodeRight->inclusive == TRUE))){ 
				if (curNodeLeft->nextValue == NULL) goto cont;
				cprevPosLeft = curPosLeft+1;
				curNodeLeft = curNodeLeft->nextValue;
				curValueLeft = *(@1 *)Tloc(indexLeft, baseLeft + curNodeLeft->position);
				curPosLeft   = curNodeLeft->indexPosition; 
			}
			while (sizeRight < (oid)*pieceSize){
				if (curNodeRight->nextValue == NULL) goto cont;
				if (curNodeRight->nextValue->indexPosition - prevPosRight+1 > (oid)*pieceSize){
				/*	if (curNodeRight->nextValue->indexPosition - prevPosRight+1 - (oid)*pieceSize > (oid)*pieceSize - sizeRight) */
						goto cont;
				}
				cprevPosRight = curPosRight+1;
				curNodeRight = curNodeRight->nextValue;
				curValueRight = *(@1 *)Tloc(indexRight, baseRight + curNodeRight->position);
				curPosRight   = curNodeRight->indexPosition;
				sizeRight  = curPosRight - prevPosRight+1;
				while (curValueRight > curValueLeft ||
                			((curValueLeft == curValueRight) && 
						(curNodeLeft->inclusive == FALSE) && (curNodeRight->inclusive == TRUE))) { 
					if (curNodeLeft->nextValue == NULL) goto cont;
					cprevPosLeft = curPosLeft+1;
					curNodeLeft = curNodeLeft->nextValue;
					curValueLeft = *(@1 *)Tloc(indexLeft, baseLeft + curNodeLeft->position);
					curPosLeft   = curNodeLeft->indexPosition; 
				}
			}
		}
		
		cont:;
		if (curValueLeft < curValueRight || 
		((curValueLeft == curValueRight) && (curNodeLeft->inclusive == FALSE) && (curNodeRight->inclusive == TRUE))){

			TC1=GDKusec();	
			if (curNodeLeft->inclusive == TRUE)
		                CRKcrackUnorderedZeroSideways_RE_@1_@5(mapRight, curValueLeft, cprevPosRight, curPosRight, &newPosition);
        		else 
                		CRKcrackUnorderedZeroSideways_LE_@1_@5(mapRight, curValueLeft, cprevPosRight, curPosRight, &newPosition);
			TC2=GDKusec();	
			TCtotal+=TC2-TC1;

			if (newPosition < cprevPosRight){
				if (cprevPosRight == prevPosRight){
					prevNodeLeft = curNodeLeft;
					curNodeLeft  = curNodeLeft->nextValue;
					continue;
				}
				curPosRight = cprevPosRight - 1;
				curNodeRight = findPreviousPieceWalkingBack(curNodeRight);
			}else if (newPosition < curPosRight){
				curNodeRight = addCrackerIndex_@1(mapRpos, &curValueLeft, curNodeLeft->inclusive, newPosition, indexRight);
				AddToTape_@1(mapRpos, @1_nil, curValueLeft, curNodeLeft->inclusive, curNodeLeft->inclusive);
				curPosRight = newPosition;
			}
		}
		else if (curValueRight < curValueLeft ||
                ((curValueLeft == curValueRight) && (curNodeRight->inclusive == FALSE) && (curNodeLeft->inclusive == TRUE))){
			TC1=GDKusec();	
			if (curNodeRight->inclusive == TRUE)
		                CRKcrackUnorderedZeroSideways_RE_@1_@5(mapLeft, curValueRight, cprevPosLeft, curPosLeft, &newPosition);
        		else 
                		CRKcrackUnorderedZeroSideways_LE_@1_@5(mapLeft, curValueRight, cprevPosLeft, curPosLeft, &newPosition);
			TC2=GDKusec();	
			TCtotal+=TC2-TC1;

			if (newPosition < cprevPosLeft){
				if (cprevPosLeft == prevPosLeft){
					prevNodeRight = curNodeRight;
					curNodeRight  = curNodeRight->nextValue;
					continue;
				}
				curPosLeft = cprevPosLeft - 1;
				curNodeLeft = findPreviousPieceWalkingBack(curNodeLeft);
			}else if (newPosition < curPosLeft){
				curNodeLeft = addCrackerIndex_@1(mapLpos, &curValueRight, curNodeRight->inclusive, newPosition, indexLeft);
				AddToTape_@1(mapLpos, @1_nil, curValueRight, curNodeRight->inclusive, curNodeRight->inclusive);
				curPosLeft = newPosition;
			}
		}

		@:JoinTwoSuperPiecesReuseHashTables()@

		prevNodeLeft  = curNodeLeft;
		curNodeLeft = curNodeLeft->nextValue;

		prevNodeRight  = curNodeRight;
		curNodeRight = curNodeRight->nextValue;

		prevPosLeft  = prevNodeLeft->indexPosition  + 1;
		prevPosRight = prevNodeRight->indexPosition + 1;
	}

	while(1){
		iterations++;
		existsHashTableLeft = existsHashTableRight = FALSE;
		
		prevPosLeft   = prevNodeLeft ==NULL?0:(prevNodeLeft->indexPosition==0?0:prevNodeLeft->indexPosition + 1);
		prevPosRight  = prevNodeRight==NULL?0:(prevNodeRight->indexPosition==0?0:prevNodeRight->indexPosition + 1);

		if (curNodeLeft == NULL)
			curPosLeft  = BATcount(mapLeft)-1;
		else {
        	        curValueLeft = *(@1 *)Tloc(indexLeft, baseLeft + curNodeLeft->position);
	                curPosLeft   = curNodeLeft->indexPosition;
		}
		if (curNodeRight == NULL)
			curPosRight  = BATcount(mapRight)-1;
		else {
   	             	curValueRight = *(@1 *)Tloc(indexRight, baseRight + curNodeRight->position);
        	        curPosRight   = curNodeRight->indexPosition;
		}

		
		sizeLeft  = curPosLeft  - prevPosLeft  + 1;
		sizeRight = curPosRight - prevPosRight + 1;

		if (sizeLeft < (oid)*pieceSize && curNodeLeft != NULL) {
			while (sizeLeft < (oid)*pieceSize){
				if (curNodeLeft->nextValue == NULL)  {
					if ( (BATcount(mapLeft)-1)- prevPosLeft <(oid)*pieceSize){
						curPosLeft  = BATcount(mapLeft)-1;
						curNodeLeft = NULL;
					}
					break;
				}
				if (curNodeLeft->nextValue->indexPosition - prevPosLeft+1 > (oid)*pieceSize){
				/*	if (curNodeLeft->nextValue->indexPosition - prevPosLeft+1 - (oid)*pieceSize > (oid)*pieceSize - sizeLeft) */
						goto checkRight2;
				}
				curNodeLeft = curNodeLeft->nextValue;
				curPosLeft   = curNodeLeft->indexPosition; 
        	        	curValueLeft = *(@1 *)Tloc(indexLeft, baseLeft + curNodeLeft->position);
				sizeLeft  = curPosLeft - prevPosLeft + 1;
			}
		}
		checkRight2:;
		if (sizeRight < (oid)*pieceSize && curNodeRight != NULL){
			while (sizeRight < (oid)*pieceSize){
				if (curNodeRight->nextValue == NULL) {
					if ( (BATcount(mapRight)-1)- prevPosRight <(oid)*pieceSize){
						curPosRight  = BATcount(mapRight)-1;
						curNodeRight = NULL;
					}
					break;
				}
				if (curNodeRight->nextValue->indexPosition - prevPosRight+1 > (oid)*pieceSize){
				/*	if (curNodeRight->nextValue->indexPosition - prevPosRight+1 - (oid)*pieceSize > (oid)*pieceSize - sizeRight) */
						goto cont2;
				}
				curNodeRight = curNodeRight->nextValue;
				curPosRight   = curNodeRight->indexPosition;
   	             		curValueRight = *(@1 *)Tloc(indexRight, baseRight + curNodeRight->position);
				sizeRight  = curPosRight - prevPosRight + 1;
			}
		}

		cont2:;	
		if (curNodeLeft != NULL && curNodeRight == NULL){	
			
			TC1=GDKusec();	
			if (curNodeLeft->inclusive == TRUE)

		                CRKcrackUnorderedZeroSideways_RE_@1_@5(mapRight, curValueLeft, prevPosRight, curPosRight, &newPosition);
        		else 
                		CRKcrackUnorderedZeroSideways_LE_@1_@5(mapRight, curValueLeft, prevPosRight, curPosRight, &newPosition);

			TC2=GDKusec();	
			TCtotal+=TC2-TC1;
			if (newPosition < prevPosRight){
				prevNodeLeft = curNodeLeft;
				curNodeLeft  = curNodeLeft->nextValue;	
				continue;
			}
			else if (newPosition < curPosRight){
				curNodeRight = addCrackerIndex_@1(mapRpos, &curValueLeft, curNodeLeft->inclusive, newPosition, indexRight);
				AddToTape_@1(mapRpos, @1_nil, curValueLeft, curNodeLeft->inclusive, curNodeLeft->inclusive);
				curPosRight = newPosition;
			}
			else {  /* this means that there is no chance to join with the future pieces of the other side */

				@:JoinTwoSuperPiecesReuseHashTables()@

				break;
			}
		}
		else if (curNodeLeft == NULL && curNodeRight != NULL){

			TC1=GDKusec();	
			if (curNodeRight->inclusive == TRUE)
		                CRKcrackUnorderedZeroSideways_RE_@1_@5(mapLeft, curValueRight, prevPosLeft+1, curPosLeft, &newPosition);
        		else 
                		CRKcrackUnorderedZeroSideways_LE_@1_@5(mapLeft, curValueRight, prevPosLeft+1, curPosLeft, &newPosition);

			TC2=GDKusec();	
			TCtotal+=TC2-TC1;
			if (newPosition < prevPosLeft){
				prevNodeRight = curNodeRight;
				curNodeRight  = curNodeRight->nextValue;	
				continue;
			}else
			if (newPosition < curPosLeft){
				curNodeLeft = addCrackerIndex_@1(mapLpos, &curValueRight, curNodeRight->inclusive, newPosition, indexLeft);
				AddToTape_@1(mapLpos, @1_nil, curValueRight, curNodeRight->inclusive, curNodeRight->inclusive);
				curPosLeft = newPosition;
			}
			else {
				@:JoinTwoSuperPiecesReuseHashTables()@
				break;
			}
		}

		@:JoinTwoSuperPiecesReuseHashTables()@
		if (curNodeLeft == NULL && curNodeRight == NULL)
			break;

		if (curNodeLeft == NULL || curNodeRight == NULL)
                	throw(MAL, "crack Join", "Unexpected error: Crack maps were not aligned succesfully.");

		prevNodeLeft  = curNodeLeft;
		curNodeLeft = curNodeLeft->nextValue;
	
		prevNodeRight  = curNodeRight;
		curNodeRight = curNodeRight->nextValue;
	}
	
        *resid = res->batCacheid;
        BBPkeepref(*resid);

        BBPunfix(indexLeft->batCacheid);
        BBPunfix(indexRight->batCacheid);
        BBPunfix(mapLeft->batCacheid);
        BBPunfix(mapRight->batCacheid);

	T2=GDKusec();

	printf("Total  " LLFMT " Join " LLFMT " Rest  " LLFMT " Joins " LLFMT " Crack " LLFMT " Pieces " LLFMT " \n", 
			T2-T1, TJtotal, ((T2-T1)-TJtotal)-TCtotal, joinsDone, TCtotal, CrackerIndex[mapLpos].pieces + CrackerIndex[mapRpos].pieces );
	return MAL_SUCCEED;

}	

str CRKactiveCrackSortMergeJoin_@1_@5(int *resid, int *bidL1, int *bidL2, int *bidR1, int *bidR2, lng *pieceSize, lng *joinThreshold, @1 *minLeft, @1 *maxLeft, @1 *minRight, @1 *maxRight,int *mode){

	lng T1=GDKusec(), TJtotal = 0, T2, TCtotal = 0, TC1, TC2, Tsort=0,tempT;
	
	int tapeLpos, mapPosLeft;
	struct Node *curNodeLeft, *prevNodeLeft; 
	BAT *indexLeft, *mapLeft, *markedViewLeft;
	BUN baseLeft;
	oid curPosLeft, prevPosLeft, cprevPosLeft;
	@1  curValueLeft;
	bit existsHashTableLeft;

	int tapeRpos, mapPosRight;
	struct Node *curNodeRight, *prevNodeRight; 
	BAT *indexRight, *mapRight, *markedViewRight;
	BUN baseRight;
	oid curPosRight, prevPosRight, cprevPosRight;
        @1  curValueRight;
	bit existsHashTableRight;

	BAT *res;
	oid newPosition=0, newPosition2=0;
	oid positionOfPieceToCrackLeft=0, positionOfPieceToCrackRight=0;

	oid sizeLeft, sizeRight;
	oid iterations = 0;

	lng joinsDone = 0;

	@1 mid, low, hgh;
	@1 step, mid1, mid2;

	bit true = TRUE;

	/* Get the cracker tape for the set of the left map or create one if it does not exist */
        tapeLpos = existsCrackerIndexSideways(*bidL1, -1);
        if (tapeLpos == -1)
                tapeLpos = CreateTape_@1(*bidL1);

        /* Get the left map */
        mapPosLeft = existsCrackerIndexSideways(*bidL1, *bidL2);
	if (mapPosLeft == -1){
		@:CreateCrackerMap(@1,@5,*bidL1, *bidL2)@		
		mapPosLeft = m;
	}

	/* Align the map based on the position of its cursor in the cracker tape */
        Sync_@1_@5(tapeLpos, mapPosLeft);

	selectMergeInsertionsPart_@1_@5_Sideways(minLeft, &true, maxLeft, &true, mapPosLeft);

        /* Take the index of the map */
        if ((indexLeft = BATdescriptor(CrackerIndex[mapPosLeft].cid)) == NULL)
                throw(MAL, "crackers.simpleJoin", "Cannot access crack index");

        /* Take the map */
        if ((mapLeft = BATdescriptor(CrackerIndex[mapPosLeft].cbid)) == NULL)
                throw(MAL, "crackers.simpleJoin", "Cannot access crack index");

	/* Get the piece that holds the lowest values */
	curNodeLeft = getFirstNode(CrackerIndex[mapPosLeft].Tree);

	baseLeft      = BUNfirst(indexLeft);

	/* Get the cracker tape for the set of the right map or create one if it does not exist */
        tapeRpos = existsCrackerIndexSideways(*bidR1, -1);
        if (tapeRpos == -1)
                tapeRpos = CreateTape_@1(*bidR1);

        /* Get the right map */
        mapPosRight = existsCrackerIndexSideways(*bidR1, *bidR2);
	if (mapPosRight == -1){
		@:CreateCrackerMap(@1,@5,*bidR1,*bidR2)@		
		mapPosRight = m;
	}

        /* Align the map based on the position of its cursor in the cracker tape */
        Sync_@1_@5(tapeRpos, mapPosRight);

	selectMergeInsertionsPart_@1_@5_Sideways(minRight, &true, maxRight, &true, mapPosRight);

        /* Take the index of the map */
        if ((indexRight = BATdescriptor(CrackerIndex[mapPosRight].cid)) == NULL)
                throw(MAL, "crackers.simpleJoin", "Cannot access crack index");

        /* Take the map */
        if ((mapRight = BATdescriptor(CrackerIndex[mapPosRight].cbid)) == NULL)
                throw(MAL, "crackers.simpleJoin", "Cannot access crack index");
	
	@:ActiveJoinMainPart(@1,@5,SortMerge)@

	(void) existsHashTableLeft;
	(void) existsHashTableRight;

	printf("Sort time " LLFMT " \n",Tsort);
	return MAL_SUCCEED;
}	

str CRKactiveCacheConsciousCrackHashJoin_@1_@5(int *resid, int *bidL1, int *bidL2, int *bidR1, int *bidR2, lng *pieceSize, lng *joinThreshold, @1 *minLeft, @1 *maxLeft, @1 *minRight, @1 *maxRight,int *mode){

	lng T1=GDKusec(), TJtotal = 0, T2, TCtotal = 0, TC1, TC2;
	
	int tapeLpos, mapPosLeft;
	struct Node *curNodeLeft, *prevNodeLeft; 
	BAT *indexLeft, *mapLeft, *viewLeft, *markedViewLeft, *viewHeadLeft;
	BUN baseLeft;
	oid curPosLeft, prevPosLeft, cprevPosLeft;
	@1  curValueLeft;
	bit existsHashTableLeft;

	int tapeRpos, mapPosRight;
	struct Node *curNodeRight, *prevNodeRight; 
	BAT *indexRight, *mapRight, *viewRight, *markedViewRight, *viewHeadRight;
	BUN baseRight;
	oid curPosRight, prevPosRight, cprevPosRight;
        @1  curValueRight;
	bit existsHashTableRight;

	bit invalidateHash;
	
	BAT *res;
	oid newPosition=0, newPosition2=0;
	oid positionOfPieceToCrackLeft=0, positionOfPieceToCrackRight=0;

	oid sizeLeft, sizeRight;
	oid iterations = 0;

	lng joinsDone = 0;
	lng reversingJoinOrder = 0;

	struct Node *temp;
	
	@1 mid, low, hgh;
	@1 step, mid1, mid2;

	bit true = TRUE;

	/* Get the cracker tape for the set of the left map or create one if it does not exist */
        tapeLpos = existsCrackerIndexSideways(*bidL1, -1);
        if (tapeLpos == -1)
                tapeLpos = CreateTape_@1(*bidL1);

        /* Get the left map */
        mapPosLeft = existsCrackerIndexSideways(*bidL1, *bidL2);
	if (mapPosLeft == -1){
		@:CreateCrackerMapMultiCrack(@1,@5,*bidL1, *bidL2)@		
		mapPosLeft = m;
	}

	/* Align the map based on the position of its cursor in the cracker tape */
        Sync_@1_@5(tapeLpos, mapPosLeft);

	selectMergeInsertionsPart_@1_@5_Sideways(minLeft, &true, maxLeft, &true, mapPosLeft);

        /* Take the index of the map */
        if ((indexLeft = BATdescriptor(CrackerIndex[mapPosLeft].cid)) == NULL)
                throw(MAL, "crackers.simpleJoin", "Cannot access crack index");

        /* Take the map */
        if ((mapLeft = BATdescriptor(CrackerIndex[mapPosLeft].cbid)) == NULL)
                throw(MAL, "crackers.simpleJoin", "Cannot access crack index");

	/* Get the piece that holds the lowest values */
	curNodeLeft = getFirstNode(CrackerIndex[mapPosLeft].Tree);

	baseLeft      = BUNfirst(indexLeft);

	/* Get the cracker tape for the set of the right map or create one if it does not exist */
        tapeRpos = existsCrackerIndexSideways(*bidR1, -1);
        if (tapeRpos == -1)
                tapeRpos = CreateTape_@1(*bidR1);

        /* Get the right map */
        mapPosRight = existsCrackerIndexSideways(*bidR1, *bidR2);
	if (mapPosRight == -1){
		@:CreateCrackerMapMultiCrack(@1,@5,*bidR1,*bidR2)@		
		mapPosRight = m;
	}

        /* Align the map based on the position of its cursor in the cracker tape */
        Sync_@1_@5(tapeRpos, mapPosRight);

	selectMergeInsertionsPart_@1_@5_Sideways(minRight, &true, maxRight, &true, mapPosRight);

        /* Take the index of the map */
        if ((indexRight = BATdescriptor(CrackerIndex[mapPosRight].cid)) == NULL)
                throw(MAL, "crackers.simpleJoin", "Cannot access crack index");

        /* Take the map */
        if ((mapRight = BATdescriptor(CrackerIndex[mapPosRight].cbid)) == NULL)
                throw(MAL, "crackers.simpleJoin", "Cannot access crack index");
	
	@:ActiveJoinMainPart(@1,@5,)@

	return MAL_SUCCEED;
}	

str CRKactiveJoin_@1_@5(int *resid, int *bidLeft, bit *makeLeft, int *bidRight, bit *makeRight, lng *pieceSize){

	lng T1=GDKusec(), TJtotal = 0, T2, TCtotal = 0, TC1, TC2;
	
	int tapeLpos=0, mapPosLeft;
	struct Node *curNodeLeft, *prevNodeLeft; 
	BAT *indexLeft, *mapLeft, *markedViewLeft;
	BUN baseLeft;
	oid curPosLeft, prevPosLeft, cprevPosLeft;
	@1  curValueLeft;
	bit existsHashTableLeft;

	int tapeRpos=0, mapPosRight;
	struct Node *curNodeRight, *prevNodeRight; 
	BAT *indexRight, *mapRight, *markedViewRight;
	BUN baseRight;
	oid curPosRight, prevPosRight, cprevPosRight;
        @1  curValueRight;
	bit existsHashTableRight;

	
	BAT *res;
	oid newPosition=0, newPosition2=0;
	oid positionOfPieceToCrackLeft=0, positionOfPieceToCrackRight=0;

	oid sizeLeft, sizeRight;
	oid iterations = 0;

	lng joinsDone = 0;

	@1 mid, low, hgh;
	@1 step, mid1, mid2;

	bit true = TRUE;
	lng *joinThreshold;
	@1 *minLeft, *maxLeft, *minRight, *maxRight;
	int modeValue=5;
	int *mode;
	(void)true;
	(void)tapeRpos;
	(void)tapeLpos;
	minLeft=&modeValue;
	maxLeft=&modeValue;
	minRight=&modeValue;
	maxRight=&modeValue;
	mode=&modeValue;	

	/*This is a much simpler implementation than the original active join
	  It works on intermediate results. Thus, we do not need to worry about updates or alignment.
	  If an input is not a result of a previous crack operation, we can use this BAT as is 
	  otherwise we need to make a copy so that we do not destroy the order in the original crack map */

        /* Get the left map */
	if (!*makeLeft){
		@:CreateCrackerMapFromExistingBAT(@1,@5,*bidLeft)@		
		mapPosLeft = m;
	}else{
		@:CreateCrackerMapReuseExistingBAT(@1,@5,*bidLeft)@		
		mapPosLeft = m;
	}


        /* Take the index of the map */
        if ((indexLeft = BATdescriptor(CrackerIndex[mapPosLeft].cid)) == NULL)
                throw(MAL, "crackers.simpleJoin", "Cannot access crack index");

        /* Take the map */
        if ((mapLeft = BATdescriptor(CrackerIndex[mapPosLeft].cbid)) == NULL)
                throw(MAL, "crackers.simpleJoin", "Cannot access crack index");

	/* Get the piece that holds the lowest values */
	curNodeLeft = getFirstNode(CrackerIndex[mapPosLeft].Tree);

	baseLeft      = BUNfirst(indexLeft);


        /* Get the right map */
	if (!*makeRight){
		@:CreateCrackerMapFromExistingBAT(@1,@5,*bidRight)@		
		mapPosRight = m;
	}else{
		@:CreateCrackerMapReuseExistingBAT(@1,@5,*bidRight)@		
		mapPosRight = m;
	}


        /* Take the index of the map */
        if ((indexRight = BATdescriptor(CrackerIndex[mapPosRight].cid)) == NULL)
                throw(MAL, "crackers.simpleJoin", "Cannot access crack index");

        /* Take the map */
        if ((mapRight = BATdescriptor(CrackerIndex[mapPosRight].cbid)) == NULL)
                throw(MAL, "crackers.simpleJoin", "Cannot access crack index");
	
	@:ActiveJoinMainPart(@1,@5,Intermediates)@

	(void)existsHashTableLeft;
	(void)existsHashTableRight;

	BBPdecref(CrackerIndex[mapPosLeft].cid,TRUE);
	BBPdecref(CrackerIndex[mapPosLeft].cbid,TRUE);
	CrackerIndex[mapPosLeft].cid=-1;
	CrackerIndex[mapPosLeft].cbid=-1;
	CrackerIndex[mapPosLeft].bid=-1;
	CrackerIndex[mapPosLeft].pbid=-1;
	BBPdecref(CrackerIndex[mapPosRight].cid,TRUE);
	BBPdecref(CrackerIndex[mapPosRight].cbid,TRUE);
	CrackerIndex[mapPosRight].cid=-1;
	CrackerIndex[mapPosRight].cbid=-1;
	CrackerIndex[mapPosRight].bid=-1;
	CrackerIndex[mapPosRight].pbid=-1;

	return MAL_SUCCEED;
}	

str CRKcrackHashJoin_@1_@5(int *resid, int *bidL1, int *bidL2, int *bidR1, int *bidR2){
#ifdef TIMER_CRACKERS_JOIN
	lng T1=GDKusec(), TJtotal = 0, T2, TCtotal = 0, TC1, TC2;
	lng crackedOperationsLeft = 0 , crackedOperationsRight = 0, joinsDone = 0;
#endif
	int tapeLpos, mapLpos;
	struct Node *curNodeLeft, *prevNodeLeft, *newprevNodeLeft = NULL; 
	BAT *indexLeft, *mapLeft, *viewLeft, *markedViewLeft, *viewHeadLeft;
	BUN curTupleLeft, baseLeft;
	oid curPosLeft, prevPosLeft;
	@1  curValueLeft;
	bit crackedLeft, existsHashTableLeft;

	int tapeRpos, mapRpos;
	struct Node *curNodeRight, *prevNodeRight, *newprevNodeRight = NULL; 
	BAT *indexRight, *mapRight, *viewRight, *markedViewRight, *viewHeadRight;
	BUN curTupleRight, baseRight;
	oid curPosRight, prevPosRight;
        @1  curValueRight;
	bit crackedRight, existsHashTableRight;


	BAT *res;
	oid newPosition=0;

	/* Get the cracker tape for the set of the left map or create one if it does not exist */
        tapeLpos = existsCrackerIndexSideways(*bidL1, -1);
        if (tapeLpos == -1)
                tapeLpos = CreateTape_@1(*bidL1);

        /* Get the left map */
        mapLpos = existsCrackerIndexSideways(*bidL1, *bidL2);

	/* Align the map based on the position of its cursor in the cracker tape */
        Sync_@1_@5(tapeLpos, mapLpos);

        /* Take the index of the map */
        if ((indexLeft = BATdescriptor(CrackerIndex[mapLpos].cid)) == NULL)
                throw(MAL, "crackers.simpleJoin", "Cannot access crack index");

        /* Take the map */
        if ((mapLeft = BATdescriptor(CrackerIndex[mapLpos].cbid)) == NULL)
                throw(MAL, "crackers.simpleJoin", "Cannot access crack index");

	/* Get the piece that holds the lowest values */
	curNodeLeft = getFirstNode(CrackerIndex[mapLpos].Tree);

	baseLeft      = BUNfirst(indexLeft);

	/* Get the cracker tape for the set of the right map or create one if it does not exist */
        tapeRpos = existsCrackerIndexSideways(*bidR1, -1);
        if (tapeRpos == -1)
                tapeRpos = CreateTape_@1(*bidR1);

        /* Get the right map */
        mapRpos = existsCrackerIndexSideways(*bidR1, *bidR2);

        /* Align the map based on the position of its cursor in the cracker tape */
        Sync_@1_@5(tapeRpos, mapRpos);

        /* Take the index of the map */
        if ((indexRight = BATdescriptor(CrackerIndex[mapRpos].cid)) == NULL)
                throw(MAL, "crackers.simpleJoin", "Cannot access crack index");

        /* Take the map */
        if ((mapRight = BATdescriptor(CrackerIndex[mapRpos].cbid)) == NULL)
                throw(MAL, "crackers.simpleJoin", "Cannot access crack index");
	
#ifdef DEBUG_CRACKERS_JOIN
	printf("maps\n");
	BATprint(mapLeft);
	BATprint(mapRight);
#endif
	

        /* Get the piece that holds the lowest values */
        curNodeRight = getFirstNode(CrackerIndex[mapRpos].Tree);

        baseRight      = BUNfirst(indexRight);

	res = BATnew(TYPE_oid,TYPE_oid,5*BATcount(mapLeft));
	
	prevPosLeft   = prevPosRight   = 0;
	prevNodeLeft  = prevNodeRight  = NULL;

#ifdef DEBUG_CRACKERS_JOIN
	printf("\n New Join Index Left \n");
	@:dumpIndex(Index Left)@
#endif
	while (curNodeLeft != NULL && curNodeRight != NULL){

#ifdef DEBUG_CRACKERS_JOIN
	printf(" new loop maps\n");
	BATprint(mapLeft);
	BATprint(mapRight);
#endif

		crackedLeft = crackedRight = FALSE;
		existsHashTableLeft = existsHashTableRight = FALSE;


		curTupleLeft = baseLeft + curNodeLeft->position;
       		curValueLeft = *(@1 *)Tloc(indexLeft, curTupleLeft);
        	curPosLeft   = *(oid*)Hloc(indexLeft, curTupleLeft);


        	curTupleRight = baseRight + curNodeRight->position;
        	curValueRight = *(@1 *)Tloc(indexRight, curTupleRight);
        	curPosRight   = *(oid*)Hloc(indexRight, curTupleRight);

#ifdef DEBUG_CRACKERS_JOIN
	printf("\n New Join Index Left \n");
	@:dumpIndex(Index Left)@
#endif
#ifdef DEBUG_CRACKERS_JOIN
		printf(" leftVal %d rightVal %d \n", curValueLeft, curValueRight);
		printf(" prevPosLeft "OIDFMT" curPosLeft "OIDFMT" \n", prevPosLeft,curPosLeft);
		printf(" prevPosRight "OIDFMT" curPosRight "OIDFMT" \n", prevPosRight,curPosRight);
#endif
		if (curPosLeft ==0 &&  prevPosLeft==0)
			if ( *(@1 *)Tloc(mapLeft,0)>curValueLeft){
				prevNodeLeft  = curNodeLeft;
				curNodeLeft = curNodeLeft->nextValue;/*findNextPiece(curNodeLeft);*/
				continue;
			}	 
		if (curPosRight ==0 &&  prevPosRight==0)
			if ( *(@1 *)Tloc(mapRight,0)>curValueRight){
				prevNodeRight  = curNodeRight;
				curNodeRight = curNodeRight->nextValue;/*findNextPiece(curNodeRight);*/
				continue;
			}	 

		if (curValueLeft < curValueRight || 
		((curValueLeft == curValueRight) && (curNodeLeft->inclusive == FALSE) && (curNodeRight->inclusive == TRUE))){

#ifdef TIMER_CRACKERS_JOIN
			crackedOperationsRight++;
			TC1=GDKusec();	
#endif
			if (curNodeLeft->inclusive == TRUE)
		                CRKcrackUnorderedZeroSideways_RE_@1_@5(mapRight, curValueLeft, prevPosRight, curPosRight, &newPosition);
        		else 
                		CRKcrackUnorderedZeroSideways_LE_@1_@5(mapRight, curValueLeft, prevPosRight, curPosRight, &newPosition);

#ifdef TIMER_CRACKERS_JOIN
			TC2=GDKusec();	
			TCtotal+=TC2-TC1;
#endif
			if (newPosition < prevPosRight || newPosition ==(oid)-1){
				/*Empty piece*/
				prevPosLeft   = curPosLeft+1;
				prevNodeLeft  = curNodeLeft;
				curNodeLeft = curNodeLeft->nextValue;/*findNextPiece(curNodeLeft);*/
				continue;
			}
			if (newPosition < curPosRight){
				newprevNodeRight = addCrackerIndex_@1(mapRpos, &curValueLeft, curNodeLeft->inclusive, newPosition, indexRight);
				AddToTape_@1(mapRpos, @1_nil, curValueLeft, curNodeLeft->inclusive, curNodeLeft->inclusive);
				curPosRight = newPosition;
				crackedRight = TRUE;
			}
		}
		else if (curValueRight < curValueLeft ||
                ((curValueLeft == curValueRight) && (curNodeRight->inclusive == FALSE) && (curNodeLeft->inclusive == TRUE))){


#ifdef TIMER_CRACKERS_JOIN
			crackedOperationsLeft++;
			TC1=GDKusec();	
#endif
			if (curNodeRight->inclusive == TRUE)
		                CRKcrackUnorderedZeroSideways_RE_@1_@5(mapLeft, curValueRight, prevPosLeft, curPosLeft, &newPosition);
        		else 
                		CRKcrackUnorderedZeroSideways_LE_@1_@5(mapLeft, curValueRight, prevPosLeft, curPosLeft, &newPosition);

#ifdef TIMER_CRACKERS_JOIN
			TC2=GDKusec();	
			TCtotal+=TC2-TC1;
#endif
			if (newPosition < prevPosLeft || newPosition ==(oid)-1){
				/*Empty piece*/
				prevPosRight   = curPosRight+1;
				prevNodeRight  = curNodeRight;
				curNodeRight = curNodeRight->nextValue;/*findNextPiece(curNodeRight);*/
				continue;
			}
			if (newPosition < curPosLeft){
				newprevNodeLeft = addCrackerIndex_@1(mapLpos, &curValueRight, curNodeRight->inclusive, newPosition, indexLeft);
				AddToTape_@1(mapLpos, @1_nil, curValueRight, curNodeRight->inclusive, curNodeRight->inclusive);
				curPosLeft = newPosition;
				crackedLeft = TRUE;
			}
		}

		@:JoinTwoPiecesReuseHashTables()@

		prevPosLeft   = curPosLeft+1;
		if (crackedLeft == FALSE){
			prevNodeLeft  = curNodeLeft;
			curNodeLeft = curNodeLeft->nextValue;/*findNextPiece(curNodeLeft);*/
		} else prevNodeLeft = newprevNodeLeft;

		prevPosRight   = curPosRight+1;
		if (crackedRight == FALSE){
			prevNodeRight  = curNodeRight;
        		curNodeRight = curNodeRight->nextValue;/*findNextPiece(curNodeRight);*/
		} else prevNodeRight = newprevNodeRight;
	}

	while(1){

		crackedLeft = crackedRight = FALSE;
		existsHashTableLeft = existsHashTableRight = FALSE;

		if (curNodeLeft == NULL)
			curPosLeft  = BATcount(mapLeft)-1;
		else {
			curTupleLeft = baseLeft + curNodeLeft->position;
        	        curValueLeft = *(@1 *)Tloc(indexLeft, curTupleLeft);
	                curPosLeft   = *(oid*)Hloc(indexLeft, curTupleLeft);
		}
		if (curNodeRight == NULL)
			curPosRight  = BATcount(mapRight)-1;
		else {
			curTupleRight = baseRight + curNodeRight->position;
   	             	curValueRight = *(@1 *)Tloc(indexRight, curTupleRight);
        	        curPosRight   = *(oid*)Hloc(indexRight, curTupleRight);	
		}
		
#ifdef DEBUG_CRACKERS_JOIN
		printf("\n Index Left \n");
		printAVLTree(CrackerIndex[mapLpos].Tree, indexLeft, baseLeft);
		printf("\n Index Right \n");
		printAVLTree(CrackerIndex[mapRpos].Tree, indexRight, baseRight);
		printf(" leftVal %d rightVal %d \n", curValueLeft, curValueRight);
		printf(" prevPosLeft "OIDFMT" curPosLeft "OIDFMT" \n", prevPosLeft,curPosLeft);
		printf(" prevPosRight "OIDFMT" curPosRight "OIDFMT" \n", prevPosRight,curPosRight);
#endif

		if (curNodeLeft != NULL && curNodeRight == NULL){	
#ifdef TIMER_CRACKERS_JOIN
			crackedOperationsRight++;
			TC1=GDKusec();	
#endif
			if (curNodeLeft->inclusive == TRUE)
		                CRKcrackUnorderedZeroSideways_RE_@1_@5(mapRight, curValueLeft, prevPosRight, curPosRight, &newPosition);
        		else 
                		CRKcrackUnorderedZeroSideways_LE_@1_@5(mapRight, curValueLeft, prevPosRight, curPosRight, &newPosition);

#ifdef TIMER_CRACKERS_JOIN

			TC2=GDKusec();	
			TCtotal+=TC2-TC1;
#endif
			if (newPosition < prevPosRight || newPosition ==(oid)-1){
				/*Empty piece*/
				prevPosLeft   = curPosLeft+1;
				prevNodeLeft  = curNodeLeft;
				curNodeLeft = curNodeLeft->nextValue;/*findNextPiece(curNodeLeft);*/
				continue;
			}
			if (newPosition < curPosRight){
				newprevNodeRight = addCrackerIndex_@1(mapRpos, &curValueLeft, curNodeLeft->inclusive, newPosition, indexRight);
				AddToTape_@1(mapRpos, @1_nil, curValueLeft, curNodeLeft->inclusive, curNodeLeft->inclusive);
				curPosRight = newPosition;
				crackedRight = TRUE;
			}
			else {  /* this means that there is no chance to join with the future pieces of the other side */
				@:JoinTwoPiecesReuseHashTables()@
				break;
			}
		}
		else if (curNodeLeft == NULL && curNodeRight != NULL){
#ifdef TIMER_CRACKERS_JOIN
			crackedOperationsLeft++;
			TC1=GDKusec();	
#endif
			if (curNodeRight->inclusive == TRUE)
		                CRKcrackUnorderedZeroSideways_RE_@1_@5(mapLeft, curValueRight, prevPosLeft, curPosLeft, &newPosition);
        		else 
                		CRKcrackUnorderedZeroSideways_LE_@1_@5(mapLeft, curValueRight, prevPosLeft, curPosLeft, &newPosition);
#ifdef TIMER_CRACKERS_JOIN
			TC2=GDKusec();	
			TCtotal+=TC2-TC1;
#endif
			if (newPosition < prevPosLeft || newPosition ==(oid)-1){
				/*Empty piece*/
				prevPosRight   = curPosRight+1;
				prevNodeRight  = curNodeRight;
				curNodeRight = curNodeRight->nextValue;/*findNextPiece(curNodeRight);*/
				continue;
			}
			if (newPosition < curPosLeft){
				newprevNodeLeft = addCrackerIndex_@1(mapLpos, &curValueRight, curNodeRight->inclusive, newPosition, indexLeft);
				AddToTape_@1(mapLpos, @1_nil, curValueRight, curNodeRight->inclusive, curNodeRight->inclusive);
				curPosLeft = newPosition;
				crackedLeft = TRUE;
			}
			else {
				@:JoinTwoPiecesReuseHashTables()@
				break;
			}
		}
		else if (curNodeLeft == NULL && curNodeRight == NULL){
			@:JoinTwoPiecesReuseHashTables()@
			break;
		}			

		@:JoinTwoPiecesReuseHashTables()@

		prevPosLeft   = curPosLeft+1;
		if (crackedLeft == FALSE){
			prevNodeLeft  = curNodeLeft;
			curNodeLeft = curNodeLeft->nextValue;
		}else prevNodeLeft = newprevNodeLeft; 

		prevPosRight   = curPosRight+1;
		if (crackedRight == FALSE){
			prevNodeRight  = curNodeRight;
        		curNodeRight = curNodeRight->nextValue;
		} else prevNodeRight = newprevNodeRight;
	}
	
        *resid = res->batCacheid;
        BBPkeepref(*resid);

        BBPunfix(indexLeft->batCacheid);
        BBPunfix(indexRight->batCacheid);
        BBPunfix(mapLeft->batCacheid);
        BBPunfix(mapRight->batCacheid);

#ifdef TIMER_CRACKERS_JOIN
	T2=GDKusec();
	printf("Total  " LLFMT " Join " LLFMT " Rest  " LLFMT " Joins " LLFMT " Crack " LLFMT " Pieces " LLFMT " \n", 
			T2-T1, TJtotal, ((T2-T1)-TJtotal)-TCtotal, joinsDone, TCtotal, CrackerIndex[mapLpos].pieces + CrackerIndex[mapRpos].pieces );
#endif

	return MAL_SUCCEED;

}	


str CRKAlignJoin_@1_@5(int *resid, int *bidL,  int *bidR1, int *bidR2){
	int mapLpos;
	BAT *indexLeft, *mapLeft;

	int tapeRpos, mapRpos;
	BAT *indexRight, *mapRight;
	BUN baseRight;

	oid cacheThreshold = 65536;

	BAT *res;

	/*TODO if left is an intermediate result, use this as a map and create an index */
	/* Get the cracker tape for the set of the left map or create one if it does not exist */

        /* Get the left map */
        mapLpos = newCrackerIndex_@1(*bidL, *bidL);

        /* Take the index of the map */
        if ((indexLeft = BATdescriptor(CrackerIndex[mapLpos].cid)) == NULL)
                throw(MAL, "crackers.fullAllignment", "Cannot access crack index left");


        /* Take the map */
        if ((mapLeft = BATdescriptor(*bidL)) == NULL)
                throw(MAL, "crackers.fullAllignement", "Cannot access crack map left");

	mapLeft->batRestricted= BAT_READ;

	/* Get the cracker tape for the set of the right map or create one if it does not exist */
        tapeRpos = existsCrackerIndexSideways(*bidR1, -1);
        if (tapeRpos == -1)
                tapeRpos = CreateTape_@1(*bidR1);

        /* Get the right map */
        mapRpos = existsCrackerIndexSideways(*bidR1, *bidR2);

        /* Align the map based on the position of its cursor in the cracker tape */
        Sync_@1_@5(tapeRpos, mapRpos);

        /* Take the index of the map */
        if ((indexRight = BATdescriptor(CrackerIndex[mapRpos].cid)) == NULL)
                throw(MAL, "crackers.fullAllignment", "Cannot access crack index right");

        /* Take the map */
        if ((mapRight = BATdescriptor(CrackerIndex[mapRpos].cbid)) == NULL)
                throw(MAL, "crackers.fullAllignement", "Cannot access crack map right");

        baseRight      = BUNfirst(indexRight);

	res = BATnew(TYPE_oid,TYPE_oid,5*BATcount(mapRight));

	cacheConsciousAlignJoinStep_@1(mapLeft, mapRight, CrackerIndex[mapRpos].Tree, 0, BATcount(mapLeft)-1, indexRight, baseRight, indexLeft, mapLpos, cacheThreshold, NULL,NULL,res);

        *resid = res->batCacheid;
        BBPkeepref(*resid);

        BBPunfix(indexLeft->batCacheid);
        BBPunfix(indexRight->batCacheid);
        BBPunfix(mapLeft->batCacheid);
        BBPunfix(mapRight->batCacheid);

	/* Remove map created for the intermediate result */
	BBPdecref(CrackerIndex[mapLpos].cid,TRUE);
	CrackerIndex[mapLpos].cid=-1;
	CrackerIndex[mapLpos].cbid=-1;
	CrackerIndex[mapLpos].bid=-1;

	return MAL_SUCCEED;
}	


str CRKFullAlignment_@1_@5(int *res, int *bidL, int *bidR1, int *bidR2){
	int mapLpos;
	BAT *indexLeft, *mapLeft;

	int tapeRpos, mapRpos;
	BAT *indexRight, *mapRight;
	BUN baseRight;

	oid cacheThreshold = 65536;
	
	(void)res;

	/*TODO if left is an intermediate result, use this as a map and create an index */
	/* Get the cracker tape for the set of the left map or create one if it does not exist */

        /* Get the left map */
        mapLpos = newCrackerIndex_@1(*bidL, *bidL);

        /* Take the index of the map */
        if ((indexLeft = BATdescriptor(CrackerIndex[mapLpos].cid)) == NULL)
                throw(MAL, "crackers.fullAllignment", "Cannot access crack index left");


        /* Take the map */
        if ((mapLeft = BATdescriptor(CrackerIndex[mapLpos].cbid)) == NULL)
                throw(MAL, "crackers.fullAllignement", "Cannot access crack map left");

	mapLeft->batRestricted= BAT_READ;

	/* Get the cracker tape for the set of the right map or create one if it does not exist */
        tapeRpos = existsCrackerIndexSideways(*bidR1, -1);
        if (tapeRpos == -1)
                tapeRpos = CreateTape_@1(*bidR1);

        /* Get the right map */
        mapRpos = existsCrackerIndexSideways(*bidR1, *bidR2);

        /* Align the map based on the position of its cursor in the cracker tape */
        Sync_@1_@5(tapeRpos, mapRpos);

        /* Take the index of the map */
        if ((indexRight = BATdescriptor(CrackerIndex[mapRpos].cid)) == NULL)
                throw(MAL, "crackers.fullAllignment", "Cannot access crack index right");

        /* Take the map */
        if ((mapRight = BATdescriptor(CrackerIndex[mapRpos].cbid)) == NULL)
                throw(MAL, "crackers.fullAllignement", "Cannot access crack map right");

        baseRight      = BUNfirst(indexRight);

#ifdef DEBUG_CRACKERS_JOIN
	if (CrackerIndex[mapRpos].Tree == NULL) 
		printf("\n head is null \n");
#endif

	cacheConsciousAlignStep_@1(mapLeft, CrackerIndex[mapRpos].Tree, 0, BATcount(mapLeft)-1, indexRight, baseRight, indexLeft, mapLpos, cacheThreshold, 0, BATcount(mapRight)-1);

#ifdef DEBUG_CRACKERS_JOIN
	printf("\n Left \n");
	printAVLTree(CrackerIndex[mapLpos].Tree, indexLeft, BUNfirst(indexLeft));
	printf("\n Right \n");
	printAVLTree(CrackerIndex[mapRpos].Tree, indexRight, baseRight);
#endif

	BBPunfix(indexLeft->batCacheid);
	BBPkeepref(mapLeft->batCacheid);
	BBPunfix(indexRight->batCacheid);
	BBPunfix(mapRight->batCacheid);
        return MAL_SUCCEED;

}
@

@= JoinFunctions_impl_2

str SinglePassJoinPutTuple_@1(@1 *value, oid *id, struct Node *current, BUN baseLeft, BAT * indexLeft, BAT *firstPieceBAT, struct Node *prevNode){

	@1 *bound;  
	if (current == NULL){
		if (prevNode == NULL)
			BUNins(firstPieceBAT, id, value, FALSE);
		else		
			BUNins(prevNode->partition, id, value, FALSE);

		return MAL_SUCCEED;
	}

	bound = (@1*)Tloc(indexLeft, baseLeft + current->position);

	if (@2_GT(value,bound,@1) ||
		(@2_EQ(value,bound,@1) && current->inclusive==TRUE))

		SinglePassJoinPutTuple_@1(value, id, current->right, baseLeft, indexLeft, firstPieceBAT, current);
	else
		SinglePassJoinPutTuple_@1(value, id, current->left,  baseLeft, indexLeft, firstPieceBAT, prevNode);
		
	return MAL_SUCCEED;
}

str cacheConsciousAlignJoinStep_@1(BAT *mapLeft, BAT *mapRight, struct Node *curNodeRight, oid startPos, oid endPos, BAT *indexRight, BUN baseRight, BAT * indexLeft, int mapLpos, oid cacheThreshold, struct Node *firstNodeRight, struct Node *lastNodeRight, BAT *res){
	oid newPosition=0;
	struct Node *temp, *prevNodeRight;
	BAT * viewHeadRight=NULL, *viewRight=NULL, *viewLeft=NULL, *markedViewRight=NULL;
	bit existsHashTableRight;

	oid prevPosRight, curPosRight, prevPosLeft, curPosLeft;

	@1 bound = *(@1*)Tloc(indexRight, baseRight + curNodeRight->position);

/*	
printf("\nalign Join\n");
printf("\n fL "OIDFMT" lL "OIDFMT" ",startPos, endPos);
if (firstNodeRight==NULL) printf(" fR  0 ");
else printf(" fR  "OIDFMT" ", firstNodeRight->indexPosition);
if (lastNodeRight==NULL) printf(" lR  End ");
else printf(" lR  "OIDFMT" ", lastNodeRight->indexPosition);
printf(" cur  "OIDFMT"  \n", curNodeRight->indexPosition);
*/

	if (curNodeRight->inclusive == TRUE)
	
		CRKcrackUnorderedZero_RE_@1(mapLeft, bound, startPos, endPos, &newPosition);
        else
		CRKcrackUnorderedZero_LE_@1(mapLeft, bound, startPos, endPos, &newPosition);
	
	if (newPosition != (startPos==0?0:startPos-1) && newPosition != endPos){

		addCrackerIndex_@1(mapLpos, &bound, curNodeRight->inclusive, newPosition, indexLeft);

		if (newPosition != (startPos==0?0:startPos-1)){
			 
			prevNodeRight = firstNodeRight; 
			prevPosRight = (prevNodeRight==NULL)?0:prevNodeRight->indexPosition+1;
			curPosRight  = curNodeRight->indexPosition;
			prevPosLeft  = startPos;
			curPosLeft   = newPosition;
			if (curPosRight - (prevPosRight+1) < cacheThreshold ||
				curPosLeft - (prevPosLeft+1) < cacheThreshold || 
				curNodeRight->left == NULL){

				@:AlignJoin()@
			}else{
				cacheConsciousAlignJoinStep_@1(mapLeft, mapRight, curNodeRight->left, startPos, newPosition, indexRight, baseRight, indexLeft, mapLpos, cacheThreshold, prevNodeRight, curNodeRight, res);
			}
		}
		if (newPosition != endPos){

			prevNodeRight = curNodeRight; 
			prevPosRight = curNodeRight->indexPosition+1;
			curPosRight  = (lastNodeRight ==NULL)?BATcount(mapRight)-1: lastNodeRight->indexPosition;
			prevPosLeft  = newPosition+1;
			curPosLeft   = endPos;

			if (curPosRight - (prevPosRight+1) < cacheThreshold ||
				curPosLeft - (prevPosLeft+1) < cacheThreshold || 
				curNodeRight->right == NULL){

				@:AlignJoin()@
			}else{
				cacheConsciousAlignJoinStep_@1(mapLeft, mapRight, curNodeRight->right, newPosition+1, endPos, indexRight, baseRight, indexLeft, mapLpos, cacheThreshold, curNodeRight, lastNodeRight, res);
			}
		}
	}
	return MAL_SUCCEED;
}

str CRKbandJoin_@1(int *resid, int *bidL, int *bidR, @1 *c1, @1 *c2, bit *inclusiveLow, bit *inclusiveHgh){
	BAT *BATLeft, *b, *c, *res;
	int m;
	@1 currentValue;
	BUN currentTupleLeft; 
	oid *currentResTupleHead, *currentResTupleTail, *curViewTupleHead, *currentTupleLeftHead;
	oid numberOfTuplesLeft;
	bit HBound;	
	@1 low, hgh;
	oid vl=0, vh=0, posl, posh, _vl;
	oid cl1=0, ch1=0, cl2=0, ch2=0;
	int foundLow, foundHgh;
	oid resCount=0;
	int gapL=0,gapH=0;
	oid i,j;
	
	if (*inclusiveHgh == TRUE) HBound = FALSE;
	else	HBound = TRUE; 				

	if ((BATLeft = BATdescriptor(*bidL)) == NULL)
        	throw(MAL, "crackers.thetajoin", "Cannot access descriptor");

	if ((b = BATdescriptor(*bidR)) == NULL)
        	throw(MAL, "crackers.thetajoin", "Cannot access descriptor");

	m = newCrackerIndex_@1(*bidR,b->batCacheid);

        if ((c = BATdescriptor(CrackerIndex[m].cid)) == NULL)
        	throw(MAL, "crackers.thetajoin", "Cannot access cracker index");

	res = BATnew(TYPE_oid,TYPE_oid,5*(*c1+*c2)*BATcount(b));
	currentResTupleHead = (oid*)Hloc(res,BUNfirst(res));
	currentResTupleTail = (oid*)Tloc(res,BUNfirst(res));

	numberOfTuplesLeft = BATcount(BATLeft);
	currentTupleLeft   = BUNfirst(BATLeft);

	currentValue = *(@1*)Tloc(BATLeft, currentTupleLeft);
	currentTupleLeftHead = (oid*)Hloc(BATLeft, currentTupleLeft);
	low  = currentValue - *c1;			
	hgh  = currentValue + *c2;			

	posl = BUNfirst(b);
	posh = BUNlast(b)-1;

	@:crackDoubleSidedBound(@1,posl,posh)@
	@:addPartialResult()@
	currentTupleLeft ++;

	for(i=1;i<numberOfTuplesLeft;i++){
		currentValue = *(@1*)Tloc(BATLeft, currentTupleLeft);
		currentTupleLeftHead = (oid*)Hloc(BATLeft, currentTupleLeft);
		low  = currentValue - *c1;			
		hgh  = currentValue + *c2;			


		foundLow = GetLow_@1(low, *inclusiveLow, CrackerIndex[m].Tree, c, BUNfirst(c), 
					&cl1, &ch1, 0, BUNlast(b)-1);

		foundHgh = GetHgh_@1(hgh, *inclusiveHgh, CrackerIndex[m].Tree, c,  BUNfirst(c), 
					&cl2, &ch2, 0, BUNlast(b)-1);

		if (cl1 != 0) cl1++;
		if (cl2 != 0) cl2++;

		if (foundLow == 0 || foundHgh == 0){
			if (foundLow == 0 && foundHgh == 0){
				if (cl1 == cl2){
					@:crackDoubleSidedBound(@1,cl1,ch2)@
				} else {
					@:crackSingleSidedBoundLeft(@1)@
					@:crackSingleSidedBoundRight(@1)@
					if (vl>0) _vl=vl-1; else _vl=vl;		
					if (gapL>0) addCrackerIndex_@1(m,&low,*inclusiveLow,_vl,c);
					if (gapH>0) addCrackerIndex_@1(m,&hgh,HBound,vh,c);
				}
			} else
			if (foundLow == 0){
				@:crackSingleSidedBoundLeft(@1)@
				if (vl>0) _vl=vl-1; else _vl=vl;		
				if (gapL>0) addCrackerIndex_@1(m,&low,*inclusiveLow,_vl,c);
				vh = ch2;
			} else
			if (foundHgh == 0){
				@:crackSingleSidedBoundRight(@1)@
				if (gapH>0) addCrackerIndex_@1(m,&hgh,HBound,vh,c);
				vl = cl1;
			}	 	
		} else {
			vl = cl1;
			vh = ch2;
		}

		@:addPartialResult()@
		currentTupleLeft ++;
	}

	BATsetcount(res,resCount);
        *resid = res->batCacheid;
        BBPkeepref(*resid);
        BBPunfix(b->batCacheid);
        BBPunfix(c->batCacheid);
        BBPunfix(BATLeft->batCacheid);
	return MAL_SUCCEED;
}
	
str CRKsortBandJoin_@1(int *resid, int *bidL, int *bidR, @1 *c1, @1 *c2, bit *inclusiveLow, bit *inclusiveHgh){
	BAT *BATLeft, *BATRight, *res;
	@1 currentValue;
	BUN currentTupleLeft, currentTupleRight; 
	oid *currentResTupleHead, *currentResTupleTail, *currentTupleLeftHead;
	oid numberOfTuplesLeft;
	@1 low, hgh;
	oid resCount=0;
	oid i;

	if ((BATLeft = BATdescriptor(*bidL)) == NULL)
        	throw(MAL, "crackers.thetajoin", "Cannot access descriptor");

	if ((BATRight = BATdescriptor(*bidR)) == NULL)
        	throw(MAL, "crackers.thetajoin", "Cannot access descriptor");

	res = BATnew(TYPE_oid,TYPE_oid,5*(*c1+*c2)*BATcount(BATRight));
	currentResTupleHead = (oid*)Hloc(res,BUNfirst(res));
	currentResTupleTail = (oid*)Tloc(res,BUNfirst(res));

	numberOfTuplesLeft = BATcount(BATLeft);
	currentTupleLeft   = BUNfirst(BATLeft);

	/* sort in place the right bat */
        if (BATRight->tsorted == FALSE){
                BATRight->batRestricted = BAT_WRITE;
                BATmirror(BATorder(BATmirror(BATRight)));
        }

	for(i=0;i<numberOfTuplesLeft;i++){
		currentValue = *(@1*)Tloc(BATLeft, currentTupleLeft);
		currentTupleLeftHead = (oid*)Hloc(BATLeft, currentTupleLeft);
		low  = currentValue - *c1;			
		hgh  = currentValue + *c2;			
		
		currentTupleRight = SORTfndfirst_@1(BATRight,&low);
		if (currentTupleRight == BUNlast(BATRight))
			goto next;
	
		if ((*(@1*)Tloc(BATRight, currentTupleRight) == low)&&(*inclusiveLow == TRUE)){
			@:sortInsertPartialResult()@
			while (*(@1*)Tloc(BATRight, currentTupleRight) == low){
				@:sortInsertPartialResult()@
			}
		}

		while (*(@1*)Tloc(BATRight, currentTupleRight) < hgh){
			@:sortInsertPartialResult()@
                }
	
		if (*inclusiveHgh == TRUE){
			while (*(@1*)Tloc(BATRight, currentTupleRight) == hgh){
				@:sortInsertPartialResult()@
                	}
		}

		next:;
		currentTupleLeft ++;
	}

	BATsetcount(res,resCount);
        *resid = res->batCacheid;
        BBPkeepref(*resid);
        BBPunfix(BATRight->batCacheid);
        BBPunfix(BATLeft->batCacheid);
	return MAL_SUCCEED;
}

void cacheConsciousAlignStep_@1(BAT *mapLeft, struct Node *curNodeRight, oid startPos, oid endPos, BAT *indexRight, BUN baseRight, BAT * indexLeft, int mapLpos, oid cacheThreshold, oid RightStartPos, oid RightEndPos){
	oid newPosition=0;
	@1 bound = *(@1*)Tloc(indexRight, baseRight + curNodeRight->position);
	
	if (curNodeRight->inclusive == TRUE)
		CRKcrackUnorderedZero_RE_@1(mapLeft, bound, startPos, endPos, &newPosition);
        else
		CRKcrackUnorderedZero_LE_@1(mapLeft, bound, startPos, endPos, &newPosition);

	if (newPosition != (startPos==0?0:startPos-1) && newPosition != endPos){
		addCrackerIndex_@1(mapLpos, &bound, curNodeRight->inclusive, newPosition, indexLeft);
		if (newPosition != (startPos==0?0:startPos-1) && curNodeRight->left != NULL 
				&&  curNodeRight->indexPosition - RightStartPos >cacheThreshold)
			cacheConsciousAlignStep_@1(mapLeft, curNodeRight->left, startPos, newPosition, indexRight, baseRight, indexLeft, mapLpos, cacheThreshold, RightStartPos, curNodeRight->indexPosition);

		if (newPosition != endPos && curNodeRight->right != NULL
				&&  RightEndPos - curNodeRight->indexPosition-1 >cacheThreshold)
			cacheConsciousAlignStep_@1(mapLeft, curNodeRight->right, newPosition+1, endPos, indexRight, baseRight, indexLeft, mapLpos, cacheThreshold, curNodeRight->indexPosition+1, RightEndPos);
	}
}

void alignStep_@1(BAT *mapLeft, struct Node *curNodeRight, oid startPos, oid endPos, BAT *indexRight, BUN baseRight, BAT * indexLeft, int mapLpos){
	oid newPosition=0;
	@1 bound = *(@1*)Tloc(indexRight, baseRight + curNodeRight->position);
	
	if (curNodeRight->inclusive == TRUE)
		CRKcrackUnorderedZero_RE_@1(mapLeft, bound, startPos, endPos, &newPosition);
        else
		CRKcrackUnorderedZero_LE_@1(mapLeft, bound, startPos, endPos, &newPosition);

	if (newPosition != (startPos==0?0:startPos-1) && newPosition != endPos){
		addCrackerIndex_@1(mapLpos, &bound, curNodeRight->inclusive, newPosition, indexLeft);
		if (newPosition != (startPos==0?0:startPos-1) && curNodeRight->left != NULL)
			alignStep_@1(mapLeft, curNodeRight->left, startPos, newPosition, indexRight, baseRight, indexLeft, mapLpos);
		if (newPosition != endPos && curNodeRight->right != NULL)
			alignStep_@1(mapLeft, curNodeRight->right, newPosition+1, endPos, indexRight, baseRight, indexLeft, mapLpos);
	}
}
@

@}



