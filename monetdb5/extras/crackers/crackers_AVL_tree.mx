@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.monetdb.org/Legal/MonetDBLicense

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2011 MonetDB B.V.
All Rights Reserved.
@

@c
/*
 * @f crackers_AVL_tree
 * @a Martin Kersten, Stratos Idreos, Stefan Manegold
 * @d March 2006 - July 2007
 * @* AVL Tree
 *
 * AVL-tree implementation for the cracker index
 *
 *
 * @+ Interface
 *
 *
 * @- Type expansion
 */
@= TypeSwitch
@:@1(chr,simple,)@
@:@1(sht,simple,)@
@:@1(int,simple,)@
@:@1(lng,simple,)@
@:@1(flt,simple,)@
@:@1(dbl,simple,)@
@:@1(date,atom,TYPE_)@
@
@h
/*
 * @- Header file
 */
#ifndef _CRACKERS_AVL_TREE_H_
#define _CRACKERS_AVL_TREE_H_

#ifdef LIBCRACKERS
/* Signatures shared within the crackers module/library */
@:AVLtreeSharedFunctions_decl_0@
@:TypeSwitch(AVLtreeSharedFunctions_decl_1)@
#endif

#endif /* _CRACKERS_AVL_TREE_H */
/*
 * @- Signatures shared within the crackers module/library
 */
@= AVLtreeSharedFunctions_decl_0
int Height(struct Node * x);
struct Node * SingleRotateLeft(struct Node **head, struct Node * node);
struct Node * SingleRotateRight(struct Node **head, struct Node * node);
struct Node * DoubleRotateLeft(struct Node **head, struct Node * node);
struct Node * DoubleRotateRight(struct Node **head, struct Node * node);
struct Node * findPreviousPieceWalkingBack(struct Node * node);
struct Node * findNextPiece(struct Node * node);
void FreeAVLTree(struct Node * current);
void printAVLTree(struct Node * current, BAT *b, BUN base);
void printAVLTreeIncrementalSideways(struct Node * current, BAT *b, BUN base);
struct Node * getFirstNode(struct Node * node);
struct Node * getLastNode(struct Node * node);
struct Node * getPreviousNodeAny(struct Node * current);
struct Node * getPreviousNonLocalNode(struct Node * current);
struct Node * getNextNonLocalNode(struct Node * current);
@
@= AVLtreeSharedFunctions_decl_1
bit GetLow_@1(@1  x, bit inclusive, struct Node * current, BAT *b, BUN base, oid *p1, oid *p2, oid previous, oid next);
bit GetHgh_@1(@1  x, bit inclusive, struct Node * current, BAT *b, BUN base, oid *p1, oid *p2, oid previous, oid next);
bit GetLowNodes_@1(@1  x, bit inclusive, struct Node * current, BAT *b, BUN base, struct Node **p1, struct Node **p2, struct Node *previous, struct Node *next);
bit GetHghNodes_@1(@1  x, bit inclusive, struct Node * current, BAT *b, BUN base, struct Node **p1, struct Node **p2, struct Node *previous, struct Node *next);
struct Node * InsertTree_@1(int m, oid indexPosition, @1 value, bit inclusive, oid crackPosition, struct Node * current, BAT * b, BUN base, struct Node **newNode);
struct Node *
InsertTreeIncrementalSideways_@1(int m, oid indexPosition, @1 value, bit inclusive, oid crackPosition, oid crackPositionLocal, struct Node * current, BAT * b, BUN base, struct Node **newNode, bit localBound, bit first, int pieceBAT);
struct Node * findNodeH_@1(@1  x, bit inclusive, struct Node * current, BAT *b, BUN base, struct Node * next);
struct Node * findNodeL_@1(@1  x, bit inclusive, struct Node * current, BAT *b, BUN base, struct Node * prev);
void PartiallyLazyFreeAVLTree_@1(struct Node * current, @1 value, BAT *b, BUN base);
struct NodeSimple * InsertTreeSimple_@1(struct NodeSimple ** head, oid position, @1 value, struct NodeSimple * current, BAT * b);
@
@c
/*
 * @+ Implementation
 *
 *
 * @- C file
 */
#include "monetdb_config.h"
#include "crackers.h"

/* Local support functions and macros */
@:AVLtreeLocalFunctions2()@
@:AVLtreeLocalFunctions2(Simple)@
@:AVLtreeLocalFunctions@

/* Functions shared within the crackers module/library */
@:AVLtreeSharedFunctions_impl_0()@
@:AVLtreeSharedFunctions_impl_0(Simple)@
@:AVLtreeSharedFunctions_impl_2@
@:TypeSwitch(AVLtreeSharedFunctions_impl_1)@
/*
 * @-Functions shared within the crackers module/library
 */
@= AVLtreeSharedFunctions_impl_0
int
Height@1(struct Node@1 * x){
        if( x == NULL )
                return -1;
        else
                return x->height;
}

struct Node@1 *
SingleRotateLeft@1(struct Node@1 ** head, struct Node@1 * node){
        struct Node@1 * l, *lr;
	int nodeLh,nodeRh,lh;

        l = node->left;
	lr = l->right;
        node->left = l->right;
        l->right = node;

	if (node->previous == NULL)
		l->previous = NULL;
	else {
		l->previous = node->previous;
		l->isPreviousSmaller = node->isPreviousSmaller;
        }

	node->previous = l;
	node->isPreviousSmaller = TRUE;
	if (lr != NULL) {
		lr->previous = node;
		lr->isPreviousSmaller = FALSE;
	}
	if (node->head == TRUE){
		node->head = FALSE;
		l->head = TRUE;
		*head = l;
	}

	nodeLh = Height@1(node->left);
	nodeRh = Height@1(node->right);
	lh = Height@1(l->left);

	node->height = (nodeLh > nodeRh ? nodeLh : nodeRh) + 1;
        l->height = (lh > node->height ? lh : node->height) + 1;

        return l;
}

struct Node@1 *
SingleRotateRight@1(struct Node@1 ** head, struct Node@1 * node){
        struct Node@1 * r, *rl;
	int nodeLh,nodeRh,rh;

        r = node->right;
	rl =  r->left;

        node->right = r->left;
        r->left = node;

	if (node->previous == NULL)
		r->previous = NULL;
	else {
		r->previous = node->previous;
		r->isPreviousSmaller = node->isPreviousSmaller;
	}
	node->previous = r;
	node->isPreviousSmaller = FALSE;

	if (rl != NULL){
		rl->previous = node;
		rl->isPreviousSmaller = TRUE;
	}

	if (node->head == TRUE){
		node->head = FALSE;
		r->head = TRUE;
		*head = r;
	}

	nodeLh = Height@1(node->left);
	nodeRh = Height@1(node->right);
	rh = Height@1(r->right);

	node->height = (nodeLh > nodeRh ? nodeLh : nodeRh) + 1;
        r->height = (rh > node->height ? rh : node->height) + 1;

        return r;
}

struct Node@1 *
DoubleRotateLeft@1(struct Node@1 **head, struct Node@1 * node){
            node->left = SingleRotateRight@1(head, node->left);
            return SingleRotateLeft@1(head, node);
}

struct Node@1 *
DoubleRotateRight@1(struct Node@1 **head, struct Node@1 * node){
            node->right = SingleRotateLeft@1(head, node->right);
            return SingleRotateRight@1(head, node);
}

struct Node@1 *
findPreviousPieceWalkingBack@1(struct Node@1 * node){
	struct Node@1 * res = NULL, *current = node;

	if (current == NULL)
		return NULL;

	if (current->left != NULL)
                res= getP@1(current->left);
	if (res != NULL)
		return res;

	/* If nothing in the current branch we have to move back */
	while (res == NULL) {
		if (current->previous == NULL)
			return NULL;
		while  (current->isPreviousSmaller == FALSE){
			current = current->previous;
			if (current->previous == NULL)
                        	return NULL;
		}
		current = current->previous;

		if (current->deleted == FALSE)
			res = current;
		else if (current->left != NULL)
                	res= getP@1(current->left);
	}
	
	return res;
}

struct Node@1 *
findNextPiece@1(struct Node@1 * node){
	struct Node@1 * res = NULL, *current = node;

	if (current == NULL)
		return NULL;

	if (current->right != NULL)
                res= getN@1(current->right);
	if (res != NULL)
		return res;

	/* if nothing in the current branch we have to move back */
	while (res == NULL) {
		if (current->previous == NULL)
			return NULL;
		while  (current->isPreviousSmaller == TRUE){
			current = current->previous;
			if (current->previous == NULL)
                        	return NULL;
		}
		current = current->previous;

		if (current->deleted == FALSE)
			res = current;
		else if (current->right != NULL)
                	res= getN@1(current->right);
	}
	
	return res;
}

void
FreeAVLTree@1(struct Node@1 * current){

	if (current->left != NULL)
		FreeAVLTree@1(current->left);

	if (current->right != NULL)
		FreeAVLTree@1(current->right);

	GDKfree(current);
		
	return;
}


/* Get the piece that holds the lowest values */
struct Node@1 *
getFirstNode@1(struct Node@1 * node){
        struct Node@1 *res=NULL, *cur;
        cur = node;
        while(cur != NULL){
                res = cur;
                if (cur->left != NULL)
                        cur = cur->left;
                else
                        break;
        }

        return res;
}

/* Get the piece that holds the highest values */
struct Node@1 *
getLastNode@1(struct Node@1 * node){
        struct Node@1 *res=NULL, *cur;
        cur = node;
        while(cur != NULL){
                res = cur;
                if (cur->right != NULL)
                        cur = cur->right;
                else
                        break;
        }

        return res;
}

@
@= AVLtreeSharedFunctions_impl_2
void
printAVLTreeIncrementalSideways(struct Node * current, BAT *b, BUN base){
	BUN cur;

	if (current == NULL) {
		printf("\n Empty index \n");
		return;
	}
	cur = base + current->position;
	if (current->deleted == FALSE) {
		printf("\n index: "OIDFMT", indexLocal: "OIDFMT", Val: %d, pieceID: %d  ", *(oid*)Hloc(b, cur), current->indexLocal, *(int*)Tloc(b, cur), current->pieceBAT);
	} else
		printf("\n DELETED "OIDFMT", %d  Hols:"OIDFMT , *(oid*)Hloc(b, cur), *(int*)Tloc(b, cur), current->hols );
	if (current->localBound == TRUE) printf(" local: TRUE ");	
	else printf(" local: FALSE ");
	if (current->first == TRUE) printf(" first: TRUE ");	
	else printf(" first: FALSE ");
	
	if (current->left != NULL)
                printAVLTreeIncrementalSideways(current->left, b, base);

        if (current->right != NULL)
                printAVLTreeIncrementalSideways(current->right, b, base);

        return;
}

void
printAVLTree(struct Node * current, BAT *b, BUN base){
	BUN cur;

	if (current == NULL)
		return;

	cur = base + current->position;
	if (current->deleted == FALSE) {
		printf("\n Pos: "OIDFMT", PosBat: "OIDFMT", Val: %d,  Hols: "OIDFMT", Slice: %d ", current->position, *(oid*)Hloc(b, cur), *(int*)Tloc(b, cur), current->hols, current->slice );
	} else
		printf("\n DELETED "OIDFMT", %d  Hols:"OIDFMT , *(oid*)Hloc(b, cur), *(int*)Tloc(b, cur), current->hols );
	
	if (current->left != NULL)
                printAVLTree(current->left, b, base);

        if (current->right != NULL)
                printAVLTree(current->right, b, base);

        return;
}
@
@= AVLtreeSharedFunctions_impl_1
bit
GetLow_@1(@1  x, bit inclusive, struct Node * current, BAT *b, BUN base, oid *p1, oid *p2, oid previous, oid next){
	BUN cur;
	@1 *curValue;

	if (current == NULL){
		/* This means that we are trying to search for bounds in an empty tree 
		   The full bat is return as the bounds for the next crack operation */ 	
        	*p1 = previous;
        	*p2 = next;
		return 0;		
	}

	cur = base + current->position;
	curValue = (@1*)Tloc(b, cur);

	if (current->deleted == TRUE){
		if ( @2_EQ(&x,curValue,@3@1) || @2_LT(&x,curValue,@3@1) ){	
			if (current->left == NULL){
        	                *p1 = previous;
                	        *p2 = getNextPosition(current, b, base, next);
                       	 	return 0;
                	} else
                        	/* check for the left one */
                        	return GetLow_@1(x, inclusive, current->left, b, base, p1, p2, previous, getNextPosition(current, b, base, next));
		}
		if (current->right == NULL){
               	 	*p1 = getPreviousPosition(current, b, base, previous);
			*p2 = next;
			return 0;
		} else 	
			return GetLow_@1(x, inclusive, current->right, b, base, p1, p2, getPreviousPosition(current, b, base, previous), next);
	}

	if ( @2_EQ(&x,curValue,@3@1) && (inclusive == FALSE || (inclusive == TRUE && current->inclusive == TRUE)) ){
		*p1 = *(oid*)Hloc(b, cur);	
		return 1;
	}	

       	if ( @2_LT(&x,curValue,@3@1) || @2_EQ(&x,curValue,@3@1) ){

		if (current->left == NULL){
			/* crack from the begining of the bat */
                	*p1 = previous;
			*p2 = *(oid*)Hloc(b, cur);
			return 0;
		} else
			/* check for the left one */
      			return GetLow_@1(x, inclusive, current->left, b, base, p1, p2, previous, *(oid*)Hloc(b, cur));
			
	}

	if (current->right == NULL){
		/* crack until the end of the bat */
                *p1 = *(oid*)Hloc(b, cur);
		*p2 = next;
		return 0;
	} else 	
		/* check for the right one */
		return GetLow_@1(x, inclusive, current->right, b, base, p1, p2, *(oid*)Hloc(b, cur), next);
}

bit
GetHgh_@1(@1  x, bit inclusive, struct Node * current, BAT *b, BUN base, oid *p1, oid *p2, oid previous, oid next){
        BUN cur;
	@1 *curValue;	

	if (current == NULL){
		/* This means that we are trying to search for bounds in an empty tree 
		   The full bat is return as the bounds for the next crack operation */ 	
        	*p1 = previous;
        	*p2 = next;
		return 0;		
	}

	cur = base + current->position;
	curValue = (@1*)Tloc(b, cur);

	if (current->deleted == TRUE){
		if ( @2_EQ(&x,curValue,@3@1) || @2_GT(&x,curValue,@3@1) ){
			 if (current->right == NULL){
                       	 	*p1 = getPreviousPosition(current, b, base, previous);
                        	*p2 = next;
                        	return 0;
                	} else
                        	return GetHgh_@1(x, inclusive, current->right, b, base, p1, p2, getPreviousPosition(current, b, base, previous), next);
		}
		if (current->left == NULL){
               	 	*p1 = previous;
                	*p2 = getNextPosition(current, b, base, next);
               	 	return 0;
	        } else
                	return GetHgh_@1(x, inclusive, current->left, b, base, p1, p2, previous, getNextPosition(current, b, base, next));

	}

	if ( @2_EQ(&x,curValue,@3@1) && (inclusive == FALSE || (inclusive == TRUE && current->inclusive == FALSE))){
		*p2 = *(oid*)Hloc(b, cur);	
		return 1;
	}	

	if ( @2_GT(&x,curValue,@3@1) || @2_EQ(&x,curValue,@3@1) ){

		if (current->right == NULL){
			/* crack until the end of the BAT if this was the last index entry but the needed value is still bigger */
			*p1 = *(oid*)Hloc(b, cur);
                	*p2 = next;
			return 0;
		} else
			/* check for the right one */
      			return GetHgh_@1(x, inclusive, current->right, b, base, p1, p2, *(oid*)Hloc(b, cur), next);
	}

	/* then it is smaller than the current value */
	if (current->left == NULL){
		/* crack from the beginning of the bat until here */
		*p1 = previous;
               	*p2 = *(oid*)Hloc(b, cur);
		return 0;
	} else	
		/* check for the left one */	
		return GetHgh_@1(x, inclusive, current->left, b, base, p1, p2, previous, *(oid*)Hloc(b, cur));	
}

bit
GetLowNodes_@1(@1  x, bit inclusive, struct Node * current, BAT *b, BUN base, struct Node **p1, struct Node **p2, struct Node *previous, struct Node *next){
	BUN cur;
	@1 * curValue;

	if (current==NULL){
                *p1 = previous;
		*p2 = next;
		return 0;
	}	

	cur = base + current->position;
	curValue = (@1*)Tloc(b, cur);

	if (current->deleted == TRUE){
		if ( @2_EQ(&x,curValue,@3@1) || @2_LT(&x,curValue,@3@1) ){	
			if (current->left == NULL){
        	                *p1 = previous;
                	        *p2 = getNextNode(current, next);
                       	 	return 0;
                	} else
                        	/* check for the left one */
                        	return GetLowNodes_@1(x, inclusive, current->left, b, base, p1, p2, previous, getNextNode(current, next));
		}
		if (current->right == NULL){
               	 	*p1 = getPreviousNode(current, previous);
			*p2 = next;
			return 0;
		} else 	
			return GetLowNodes_@1(x, inclusive, current->right, b, base, p1, p2, getPreviousNode(current, previous), next);
	}

	if ( @2_EQ(&x,curValue,@3@1) && (inclusive == FALSE || (inclusive == TRUE && current->inclusive == TRUE)) ){
		*p1 = current;	
		*p2 = getNextNode(current, next); /* added to avoid nulls */
		return 1;
	}	

       	if ( @2_LT(&x,curValue,@3@1) || @2_EQ(&x,curValue,@3@1) ){

		if (current->left == NULL){
			/* crack from the begining of the bat */
                	*p1 = previous;
			*p2 = current;
			return 0;
		} else
			/* check for the left one */
      			return GetLowNodes_@1(x, inclusive, current->left, b, base, p1, p2, previous, current);
			
	}

	if (current->right == NULL){
		/* crack until the end of the bat */
                *p1 = current;
		*p2 = next;
		return 0;
	} else 	
		/* check for the right one */
		return GetLowNodes_@1(x, inclusive, current->right, b, base, p1, p2, current, next);
}

bit
GetHghNodes_@1(@1  x, bit inclusive, struct Node * current, BAT *b, BUN base, struct Node **p1, struct Node **p2, struct Node *previous, struct Node *next){
        BUN cur;
	@1 *curValue;	

	if (current==NULL){
                *p1 = previous;
		*p2 = next;
		return 0;
	}	

	cur = base + current->position;
	curValue = (@1*)Tloc(b, cur);

	if (current->deleted == TRUE){
		if ( @2_EQ(&x,curValue,@3@1) || @2_GT(&x,curValue,@3@1) ){
			 if (current->right == NULL){
                       	 	*p1 = getPreviousNode(current, previous);
                        	*p2 = next;
                        	return 0;
                	} else
                        	return GetHghNodes_@1(x, inclusive, current->right, b, base, p1, p2, getPreviousNode(current, previous), next);
		}
		if (current->left == NULL){
               	 	*p1 = previous;
                	*p2 = getNextNode(current, next);
               	 	return 0;
	        } else
                	return GetHghNodes_@1(x, inclusive, current->left, b, base, p1, p2, previous, getNextNode(current, next));
	}

	if ( @2_EQ(&x,curValue,@3@1) && (inclusive == FALSE || (inclusive == TRUE && current->inclusive == FALSE))){
		*p1 = getPreviousNode(current, previous); /*added to avoid nulls*/
		*p2 = current;	
		return 1;
	}	

	if ( @2_GT(&x,curValue,@3@1) || @2_EQ(&x,curValue,@3@1) ){

		if (current->right == NULL){
			/* crack until the end of the BAT if this was the last index entry but the needed value is still bigger */
			*p1 = current;
                	*p2 = next;
			return 0;
		} else
			/* check for the right one */
      			return GetHghNodes_@1(x, inclusive, current->right, b, base, p1, p2, current, next);
	}

	/* then it is smaller than the current value */
	if (current->left == NULL){
		/* crack from the beginning of the bat until here */
		*p1 = previous;
               	*p2 = current;
		return 0;
	} else	
		/* check for the left one */	
		return GetHghNodes_@1(x, inclusive, current->left, b, base, p1, p2, previous, current);	
}

struct Node *
InsertTreeIncrementalSideways_@1(int m, oid indexPosition, @1 value, bit inclusive, oid crackPosition, oid crackPositionLocal, struct Node * current, BAT * b, BUN base, struct Node **newNode, bit localBound, bit first, int pieceBAT){
	BUN cur, Lchild, Rchild;
	@1 *curValue, *LchildValue, *RchildValue;
	oid *curPosition;

	int lh, rh;
	bit use;
	struct Node *temp;

	if (current == NULL){
        	current = (struct Node *)GDKmalloc(sizeof(struct Node));
                current->position = indexPosition;
                current->inclusive = inclusive;
		current->height = 0;
                current->left = NULL;
		current->right = NULL;
		current->head = FALSE;
		current->deleted = FALSE;
		current->previous = NULL;
		current->isPreviousSmaller = FALSE;
		current->hols = 0;
		current->slice = -1;
		current->localBound = localBound;
                current->first = first;
                current->pieceBAT = pieceBAT;
                current->tape = -1;
		current->indexLocal = crackPositionLocal;
                current->references = NULL;
		current->nextPiece = NULL;
		/* storage management info are initialized only for the first node of a piece when registering the piece in StorageInfo */
		*newNode = current;
		goto end;
        }

	cur = base + current->position;
        curValue = (@1*)Tloc(b, cur);

	if (*curValue == value && current->inclusive == inclusive){
		if (current->deleted == FALSE){
			if (!(current->localBound == FALSE && current->first == TRUE)){
				current->localBound = localBound;
				current->first = first;
				current->pieceBAT = pieceBAT;
				current->indexLocal = crackPositionLocal;
			}
			*newNode = current;
			return NULL;
		}else{
			current->deleted = FALSE; 
			current->localBound = localBound;
			current->first = first;
			current->pieceBAT = pieceBAT;
			current->indexLocal = crackPositionLocal;
			*newNode = current;
			return NULL;
		}
	}

	/* reuse if possible nodes that have been deleted with lazy deletion */
	use = FALSE;
	if (current->deleted == TRUE){
		if (current->left != NULL && current->right != NULL){
			Lchild = base + (getPreviousNodeAny(current))->position;
                        LchildValue = (@1*)Tloc(b, Lchild);
			Rchild = base + (getNextNodeAny(current))->position;
                        RchildValue = (@1*)Tloc(b, Rchild);
			
			if ( ( @2_LT(&value,RchildValue,@3@1) || (@2_EQ(&value,RchildValue,@3@1) && 
			       inclusive == TRUE && current->right->inclusive == FALSE) )  &&
			     ( @2_GT(&value,LchildValue,@3@1) || (@2_EQ(&value,LchildValue,@3@1) && 
 			       inclusive == FALSE && current->left->inclusive == TRUE) ) )
				use = TRUE;			
		} else
		if (current->left != NULL && current->right == NULL){
			Lchild = base + (getPreviousNodeAny(current))->position;
                        LchildValue = (@1*)Tloc(b, Lchild);

			if ( @2_GT(&value,LchildValue,@3@1) || (@2_EQ(&value,LchildValue,@3@1) && 
			     inclusive == FALSE && current->left->inclusive == TRUE) )
				use = TRUE;
		} else
		if (current->left == NULL && current->right != NULL){
			Rchild = base + (getNextNodeAny(current))->position;
                        RchildValue = (@1*)Tloc(b, Rchild);
			
			if ( @2_LT(&value,RchildValue,@3@1) || (@2_EQ(&value,RchildValue,@3@1) && 
			     inclusive == TRUE && current->right->inclusive == FALSE) )
				use = TRUE;
		} else
		if (current->left == NULL && current->right == NULL)
				use = TRUE;

		if (use == TRUE){
                        current->deleted = FALSE;

        		curPosition = (oid*)Hloc(b, cur);
			*curPosition = crackPosition;
                        *curValue = value;
			current->inclusive = inclusive;

			current->localBound = localBound;
                        current->first = first;
                        current->pieceBAT = pieceBAT;
                        current->indexLocal = crackPositionLocal;
			
			current->hols = 0;
		        current->slice = -1;

			*newNode = current;

                        return NULL;
		}
	}

        if ( @2_LT(&value,curValue,@3@1) || (@2_EQ(&value,curValue,@3@1) && inclusive == TRUE && current->inclusive == FALSE) ){

		if ( (temp = InsertTreeIncrementalSideways_@1(m, indexPosition, value, inclusive, crackPosition, crackPositionLocal, current->left, b, base, newNode, localBound, first, pieceBAT)) == NULL)
                	return NULL;

		current->left = temp;
		temp->previous = current;
		temp->isPreviousSmaller = FALSE;

                if ( Height(current->left) - Height(current->right) == 2 ){
		        Lchild = base + current->left->position;
        		LchildValue = (@1*)Tloc(b, Lchild);

                    	if ( @2_LT(&value,LchildValue,@3@1) || (@2_EQ(&value,LchildValue,@3@1) && 
			     inclusive == TRUE && current->left->inclusive == FALSE) )
                        	current = SingleRotateLeft(&(CrackerIndex[m].Tree), current);
                    	else
                        	current = DoubleRotateLeft(&(CrackerIndex[m].Tree), current);
		}
        } else
        if ( @2_GT(&value,curValue,@3@1) || (@2_EQ(&value,curValue,@3@1) && inclusive == FALSE && current->inclusive == TRUE) ){

		if ( (temp = InsertTreeIncrementalSideways_@1(m, indexPosition, value, inclusive, crackPosition, crackPositionLocal, current->right, b, base, newNode, localBound, first, pieceBAT)) == NULL)
			return NULL;

                current->right = temp;
		temp->previous = current;
		temp->isPreviousSmaller = TRUE;


                if ( Height(current->right) - Height(current->left) == 2 ){
			Rchild = base + current->right->position;
                        RchildValue = (@1*)Tloc(b, Rchild);

                        if ( @2_GT(&value,RchildValue,@3@1) || (@2_EQ(&value,RchildValue,@3@1) && 
			     inclusive == FALSE && current->right->inclusive == TRUE) )
                        	current = SingleRotateRight(&(CrackerIndex[m].Tree), current);
                    	else
                        	current = DoubleRotateRight(&(CrackerIndex[m].Tree), current);
		}
        }

	end:;
	lh = Height(current->left);
	rh = Height(current->right);
		
        current->height = (lh > rh? lh : rh) + 1;
        return current;
}

struct Node *
InsertTree_@1(int m, oid indexPosition, @1 value, bit inclusive, oid crackPosition, struct Node * current, BAT * b, BUN base, struct Node **newNode){
	BUN cur,Lchild, Rchild;
	@1 *curValue, *LchildValue, *RchildValue;
	oid *curPosition;
	int lh, rh;
	bit use;
	struct Node *temp;

	if (current == NULL){
        	current = (struct Node *)GDKmalloc(sizeof(struct Node));
		if (current == NULL)
			return NULL;
                current->position = indexPosition;
                current->inclusive = inclusive;
		current->height = 0;
                current->left = NULL;
		current->right = NULL;
		current->head = FALSE;
		current->deleted = FALSE;
		current->previous = NULL;
		current->isPreviousSmaller = FALSE;
		current->hols = (oid)0;
		current->slice = -1;
		*newNode = current;
		goto end;
        }

	cur = base + current->position;
        curValue = (@1*)Tloc(b, cur);

	/* reuse if possible nodes that have been deleted with lazy deletion */
	use = FALSE;
	if (current->deleted == TRUE){
		if (current->left != NULL && current->right != NULL){
			Lchild = base + (getPreviousNodeAny(current))->position;
                        LchildValue = (@1*)Tloc(b, Lchild);
			Rchild = base + (getNextNodeAny(current))->position;
                        RchildValue = (@1*)Tloc(b, Rchild);
			
			if ( ( @2_LT(&value,RchildValue,@3@1) || (@2_EQ(&value,RchildValue,@3@1) && 
			       inclusive == TRUE && current->right->inclusive == FALSE) )  &&
			     ( @2_GT(&value,LchildValue,@3@1) || (@2_EQ(&value,LchildValue,@3@1) && 
 			       inclusive == FALSE && current->left->inclusive == TRUE) ) )
				use = TRUE;			
		} else
		if (current->left != NULL && current->right == NULL){
			Lchild = base + (getPreviousNodeAny(current))->position;
                        LchildValue = (@1*)Tloc(b, Lchild);

			if ( @2_GT(&value,LchildValue,@3@1) || (@2_EQ(&value,LchildValue,@3@1) && 
			     inclusive == FALSE && current->left->inclusive == TRUE) )
				use = TRUE;
		} else
		if (current->left == NULL && current->right != NULL){
			Rchild = base + (getNextNodeAny(current))->position;
                        RchildValue = (@1*)Tloc(b, Rchild);
			
			if ( @2_LT(&value,RchildValue,@3@1) || (@2_EQ(&value,RchildValue,@3@1) && 
			     inclusive == TRUE && current->right->inclusive == FALSE) )
				use = TRUE;
		} else
		if (current->left == NULL && current->right == NULL)
				use = TRUE;

		if (use == TRUE){
        		curPosition = (oid*)Hloc(b, cur);
			*curPosition = crackPosition;
                        *curValue = value;
			current->inclusive = inclusive;
                        current->deleted = FALSE;
			*newNode = current;
                        return NULL;
		}
	}

        if ( @2_LT(&value,curValue,@3@1) || (@2_EQ(&value,curValue,@3@1) && inclusive == TRUE && current->inclusive == FALSE) ){

		if ( (temp = InsertTree_@1(m, indexPosition, value, inclusive, crackPosition, current->left, b, base, newNode)) == NULL)
                	return NULL;

		current->left = temp;
		temp->previous = current;
		temp->isPreviousSmaller = FALSE;

                if ( Height(current->left) - Height(current->right) == 2 ){
		        Lchild = base + current->left->position;
        		LchildValue = (@1*)Tloc(b, Lchild);

                    	if ( @2_LT(&value,LchildValue,@3@1) || (@2_EQ(&value,LchildValue,@3@1) && 
			     inclusive == TRUE && current->left->inclusive == FALSE) )
                        	current = SingleRotateLeft(&(CrackerIndex[m].Tree), current);
                    	else
                        	current = DoubleRotateLeft(&(CrackerIndex[m].Tree), current);
		}
        } else
        if ( @2_GT(&value,curValue,@3@1) || (@2_EQ(&value,curValue,@3@1) && inclusive == FALSE && current->inclusive == TRUE) ){

		if ( (temp = InsertTree_@1(m, indexPosition, value, inclusive, crackPosition, current->right, b, base, newNode)) == NULL )
			return NULL;

                current->right = temp;
		temp->previous = current;
		temp->isPreviousSmaller = TRUE;


                if ( Height(current->right) - Height(current->left) == 2 ){
			Rchild = base + current->right->position;
                        RchildValue = (@1*)Tloc(b, Rchild);

                        if ( @2_GT(&value,RchildValue,@3@1) || (@2_EQ(&value,RchildValue,@3@1) && 
			     inclusive == FALSE && current->right->inclusive == TRUE) )
                        	current = SingleRotateRight(&(CrackerIndex[m].Tree), current);
                    	else
                        	current = DoubleRotateRight(&(CrackerIndex[m].Tree), current);
		}
        }

	end:;
	lh = Height(current->left);
	rh = Height(current->right);
		
        current->height = (lh > rh? lh : rh) + 1;
        return current;
}

struct Node *
findNodeH_@1(@1  x, bit inclusive, struct Node * current, BAT *b, BUN base, struct Node * next){
        BUN cur;
	@1 *curValue;	

	cur = base + current->position;
	curValue = (@1*)Tloc(b, cur);

	if ( @2_EQ(&x,curValue,@3@1) && (inclusive == FALSE || (inclusive == TRUE && current->inclusive == FALSE)) )
		return (current->deleted == TRUE) ? getNextNode(current, next) : current;

        if( @2_GT(&x,curValue,@3@1) || @2_EQ(&x,curValue,@3@1) ){

		if (current->right == NULL)
			return next;
		else
      			return findNodeH_@1(x, inclusive, current->right, b, base, next);
	}

	if (current->left == NULL)
		return (current->deleted == TRUE) ? getNextNode(current, next) : current;
	else		
		return findNodeH_@1(x, inclusive, current->left, b, base, (current->deleted == TRUE) ? getNextNode(current, next) : current);	
}

struct Node *
findNodeL_@1(@1  x, bit inclusive, struct Node * current, BAT *b, BUN base, struct Node * prev){
	BUN cur;
	@1 *curValue;

	cur = base + current->position;
	curValue = (@1*)Tloc(b, cur);

	if ( @2_EQ(&x,curValue,@3@1) && (inclusive == FALSE || (inclusive == TRUE && current->inclusive == TRUE)) )
		return (current->deleted == TRUE) ? getPreviousNode(current, prev) : current;

        if( @2_LT(&x,curValue,@3@1) || @2_EQ(&x,curValue,@3@1) ){

		if (current->left == NULL)
			return prev;
		else
			return findNodeL_@1(x, inclusive, current->left, b, base, prev);
	}

	if (current->right == NULL)
		return (current->deleted == TRUE) ? getPreviousNode(current, prev) : current;
	else
		return findNodeL_@1(x, inclusive, current->right, b, base, (current->deleted == TRUE) ? getPreviousNode(current, prev) : current);
}

void
PartiallyLazyFreeAVLTree_@1(struct Node * current, @1 value, BAT *b, BUN base){
	BUN cur;
	@1 *curValue;

        cur = base + current->position;
        curValue = (@1*)Tloc(b, cur);

	if (current->left != NULL)
		PartiallyLazyFreeAVLTree_@1(current->left, value, b, base);

	if (current->right != NULL)
		PartiallyLazyFreeAVLTree_@1(current->right, value, b, base);

	if( @2_LT(&value,curValue,@3@1) || (@2_EQ(&value,curValue,@3@1) && current->inclusive == FALSE) )
		current->deleted = TRUE;
	return;
}


struct NodeSimple *
InsertTreeSimple_@1(struct NodeSimple ** head, oid position, @1 value, struct NodeSimple * current, BAT * b){
	BUN cur,Lchild, Rchild, base;
	@1 *curValue, *LchildValue, *RchildValue;
	int lh, rh;
	bit use;
	struct NodeSimple *temp;


	if (*head == NULL){
        	(*head) = (struct NodeSimple *)GDKmalloc(sizeof(struct NodeSimple));
		if ((*head) == NULL)
			return NULL;
                (*head)->position = position;
		(*head)->height = 0;
                (*head)->left = NULL;
		(*head)->right = NULL;
		(*head)->head = TRUE;
		(*head)->deleted = FALSE;
		(*head)->previous = NULL;
		(*head)->isPreviousSmaller = FALSE;
		
		return *head;
	}


	base = BUNfirst(b);

	if (current == NULL){
        	current = (struct NodeSimple *)GDKmalloc(sizeof(struct NodeSimple));
		if (current == NULL)
			return NULL;
                current->position = position;
		current->height = 0;
                current->left = NULL;
		current->right = NULL;
		current->head = FALSE;
		current->deleted = FALSE;
		current->previous = NULL;
		current->isPreviousSmaller = FALSE;
		goto end;
        }

	cur = base + current->position;
        curValue = (@1*)Tloc(b, cur);

	/* reuse if possible nodes that have been deleted with lazy deletion */
	use = FALSE;
	if (current->deleted == TRUE){
		if (current->left != NULL && current->right != NULL){
			Lchild = base + (getPreviousNodeAnySimple(current))->position;
                        LchildValue = (@1*)Tloc(b, Lchild);
			Rchild = base + (getNextNodeAnySimple(current))->position;
                        RchildValue = (@1*)Tloc(b, Rchild);
			
			if ( ( @2_LT(&value,RchildValue,@3@1) || @2_EQ(&value,RchildValue,@3@1)) && 
			     ( @2_GT(&value,LchildValue,@3@1) || @2_EQ(&value,LchildValue,@3@1)) )
				use = TRUE;			
		} else
		if (current->left != NULL && current->right == NULL){
			Lchild = base + (getPreviousNodeAnySimple(current))->position;
                        LchildValue = (@1*)Tloc(b, Lchild);

			if ( @2_GT(&value,LchildValue,@3@1) || @2_EQ(&value,LchildValue,@3@1) )
				use = TRUE;
		} else
		if (current->left == NULL && current->right != NULL){
			Rchild = base + (getNextNodeAnySimple(current))->position;
                        RchildValue = (@1*)Tloc(b, Rchild);
			
			if ( @2_LT(&value,RchildValue,@3@1) || @2_EQ(&value,RchildValue,@3@1) )
				use = TRUE;
		} else
		if (current->left == NULL && current->right == NULL)
				use = TRUE;

		if (use == TRUE){
                	current->position = position;
                        current->deleted  = FALSE;
                        return NULL;
		}
	}

        if ( @2_LT(&value,curValue,@3@1) || @2_EQ(&value,curValue,@3@1)  ){

		if ( (temp = InsertTreeSimple_@1(head, position, value, current->left, b)) == NULL)
                	return NULL;

		current->left = temp;
		temp->previous = current;
		temp->isPreviousSmaller = FALSE;

                if ( HeightSimple(current->left) - HeightSimple(current->right) == 2 ){
		        Lchild = base + current->left->position;
        		LchildValue = (@1*)Tloc(b, Lchild);

                    	if ( @2_LT(&value,LchildValue,@3@1) || @2_EQ(&value,LchildValue,@3@1) )
                        	current = SingleRotateLeftSimple(head, current);
                    	else
                        	current = DoubleRotateLeftSimple(head, current);
		}
        } else
        if ( @2_GT(&value,curValue,@3@1) || @2_EQ(&value,curValue,@3@1)  ){

		if ( (temp = InsertTreeSimple_@1(head, position, value, current->right, b)) == NULL )
			return NULL;

                current->right = temp;
		temp->previous = current;
		temp->isPreviousSmaller = TRUE;

                if ( HeightSimple(current->right) - HeightSimple(current->left) == 2 ){
			Rchild = base + current->right->position;
                        RchildValue = (@1*)Tloc(b, Rchild);

                        if ( @2_GT(&value,RchildValue,@3@1) || @2_EQ(&value,RchildValue,@3@1) )
                        	current = SingleRotateRightSimple(head, current);
                    	else
                        	current = DoubleRotateRightSimple(head, current);
		}
        }

	end:;
	lh = HeightSimple(current->left);
	rh = HeightSimple(current->right);
		
        current->height = (lh > rh? lh : rh) + 1;
        return current;
}

@
 * @- Local support functions and macros
@= AVLtreeLocalFunctions
/* Get the previous node in the tree (in terms of value), the result can be only a non deleted node */
static struct Node *
getPreviousNode(struct Node * current, struct Node * previous){
        struct Node *res = NULL;

	if (current->left != NULL)
		res= getP(current->left);
	if (res == NULL)
		return previous;
        return res;

}

/* Get the next node in the tree (in terms of value), the result can be only a non deleted node */
static struct Node *
getNextNode(struct Node * current, struct Node * next){
        struct Node *res = NULL;

	if (current->right != NULL)
		res= getN(current->right);
	if (res == NULL)
		return next;
        return res;
}

static oid
getPreviousPosition(struct Node * current, BAT *b, BUN base, oid previous){
        struct Node *res = NULL;

	if (current->left != NULL)
		res= getP(current->left);
	if (res == NULL)
		return previous;
        return *(oid*)Hloc(b,base + res->position);

}

static oid
getNextPosition(struct Node * current, BAT *b, BUN base, oid next){
        struct Node *res = NULL;

	if (current->right != NULL)
		res= getN(current->right);
	if (res == NULL)
		return next;
        return *(oid*)Hloc(b,base + res->position);
}

struct Node *
getPreviousNonLocalNode(struct Node * current){
        struct Node *res=current;

	while (res !=NULL)
		if (res->localBound == TRUE)
			res = findPreviousPieceWalkingBack(res);
		else 
			return res;
	return res;
}

struct Node *
getNextNonLocalNode(struct Node * current){
        struct Node *res=current;

	while (res !=NULL){
		if (res->localBound == TRUE)
			res = findNextPiece(res);
		else 
			return res;
	}
	return res;
}

@
@= AVLtreeLocalFunctions2

static struct Node@1 *
getP@1(struct Node@1 * current){
        struct Node@1 *res = NULL;

	if (current == NULL)
		return NULL;

	if (current->right != NULL)
		res = getP@1(current->right);
	if (res == NULL){
		if (current->deleted == FALSE)
			res = current;
		else
		if (current->left != NULL)
			res = getP@1(current->left);
	}
	return res;
}

static struct Node@1 *
getN@1(struct Node@1 * current){
        struct Node@1 *res = NULL;
	
	if (current == NULL)
		return NULL;

	if (current->left != NULL)
		res = getN@1(current->left);
	if (res == NULL){
		if (current->deleted == FALSE)
			res = current;
		else
		if (current->right != NULL)
			res = getN@1(current->right);
	}
	return res;
}

/* Get the previous node in the tree (in terms of value), the result can be any node, deleted or no */
struct Node@1 *
getPreviousNodeAny@1(struct Node@1 * current){
	struct Node@1 *res = NULL;

	if (current->left !=NULL){
		res = current->left;
		while(res->right != NULL)
			res = res->right;
	}

	return res;	
}

/* Get the next node in the tree (in terms of value), the result can be any node, deleted or no */
static struct Node@1 *
getNextNodeAny@1(struct Node@1 * current){
        struct Node@1 *res = NULL;

        if (current->right !=NULL){
                res = current->right;
                while(res->left != NULL)
                        res = res->left;
        }

        return res;
}

@
