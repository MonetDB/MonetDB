@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.monetdb.org/Legal/MonetDBLicense

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2011 MonetDB B.V.
All Rights Reserved.
@

@f crackers_core_ordered

@c
/*
 * @a Martin Kersten, Stratos Idreos, Stefan Manegold
 * @d March 2006 - July 2007
 * @* Core cracking (ordered)
 *
 *
 * @+ Interface
 *
 *
 * @- Type expansion
 */
@= TypeSwitch
@:@1(chr,simple,)@
@:@1(sht,simple,)@
@:@1(int,simple,)@
@:@1(lng,simple,)@
@:@1(flt,simple,)@
@:@1(dbl,simple,)@
@:@1(date,atom,TYPE_)@
@
@h
/*
 * @- Header file
 */
#ifndef _CRACKERS_CORE_ORDERED_H_
#define _CRACKERS_CORE_ORDERED_H_

/* Exported signatures */
@:TypeSwitch(CoreOrderedFunctions_decl)@

#endif /* _CRACKERS_CORE_ORDERED_H */
/*
 * @- Exported signatures
 */
@= CoreOrderedFunctions_decl
crackers_export str CRKcrackOrderedZero_@1 (int *res, int *bid, @1 *mid);
crackers_export str CRKcrackOrderedOne_@1 (int *res, int *bid, @1 *mid);
crackers_export str CRKcrackOrderedThree_@1 (int *res, int *bid, @1 *low, @1 *hgh);
@
@c
/*
 * @+ Implementation
 *
 *
 * @- C file
 */
#include "monetdb_config.h"
#include "crackers.h"

/* Local support functions and macros */
@:TypeSwitch(operationsOrdered)@

/* Exported functions */
@:TypeSwitch(CoreOrderedFunctions_impl)@
/*
 * @- Exported functions
 */
@= CoreOrderedFunctions_impl
str
CRKcrackOrderedZero_@1 (int *res, int *bid, @1 *mid){
        BAT *b;
        str msg;
	oid pos;

        if ((b = BATdescriptor(*bid)) == NULL) 
                throw(MAL, "crackers.crack_zeroOrdered", "Cannot access descriptor");

        msg = CRKcrackOrderedZero_LE_@1(b,*mid, 0, BATcount(b)-1,&pos);

        BBPkeepref(b->batCacheid);
        *res = *bid;
        return msg;
}

str
CRKcrackOrderedOne_@1 (int *res, int *bid, @1 *mid){
        BAT *b;
	str msg;

        if ((b = BATdescriptor(*bid)) == NULL) 
                throw(MAL, "crackers.crack_oneOrdered", "Cannot access descriptor");

	msg = CRKcrackOrderedThree_LE_RE_@1(b,*mid,*mid, 0, BATcount(b)-1);
        BBPkeepref(b->batCacheid);
        *res = *bid;
        return msg;
}

str
CRKcrackOrderedThree_@1 (int *res, int *bid, @1 *low, @1 *hgh){
	BAT *b;
	str msg;
	oid posl,posh;

	if ((b = BATdescriptor(*bid)) == NULL) 
		throw(MAL, "crackers.crack_threeOrdered", "Cannot access descriptor");

        msg = CRKcrackOrderedThreeL_LO_RE_@1(b,*low,*hgh, 0, BATcount(b)-1,&posl, &posh);
	BBPkeepref(b->batCacheid);
	*res = *bid;
	return msg;
}
@
 * @- Local support functions and macros
@= operationsOrdered
@:crackInTwoOrderedPieces(@1,LE,<=,>)@
@(
@:crackInTwoOrderedPieces(@1,RE,<,>=)@
@)

@:crackInThreeOrderedPieces(@1,LE,RE,<,>=,<=,>)@
@(
@:crackInThreeOrderedPieces(@1,LE,RO,<,>=,<,>=)@
@:crackInThreeOrderedPieces(@1,LO,RE,<=,>,<=,>)@
@:crackInThreeOrderedPieces(@1,LO,RO,<=,>,<,>=)@
@)

@:crackInThreeOrderedPiecesL(@1,LO,RE,<=,>,<=,>)@
@(
@:crackInThreeOrderedPiecesL(@1,LE,RE,<,>=,<=,>)@
@:crackInThreeOrderedPiecesL(@1,LO,RO,<=,>,<,>=)@
@:crackInThreeOrderedPiecesL(@1,LE,RO,<,>=,<,>=)@
@)
@
@= moveOrdered
	while (@1 @6 ){
		@2 @4= 1;
		@3 @4= 1;
		@5
	}
@
@= OThree
	while (*tmpt @5){
		tmpt @2= 1;
		tmph @2= 1;
	}
	
	while (tmpt @3 ht){
		if ( *tmpt @4){
			if (*ct @5){
				scr_h[hil] = *ch;
				scr_t[hil] = *ct;				
				hil++;	
			}
			*ch = *tmph;
			*ct = *tmpt;
			ch @2= 1;
			ct @2= 1;
		
		}
		else{
			scr_h[mids] = *tmph;
			scr_t[mids] = *tmpt;				
			mids--;	
		}
		tmpt @2= 1;
		tmph @2= 1;
		while (tmpt @3 ht && *tmpt @5){
			tmpt @2= 1;
			tmph @2= 1;
		}
	}
	tmph = hh;
	tmpt = ht;
	ct @2= (scrH-mids)+hil;
	for(; tmpt @7 ct; tmph @6=1, tmpt @6=1){
		if (*tmpt @5){
			*hh = *tmph;
			*ht = *tmpt;
			hh @6= 1;
			ht @6= 1;
		}
	}
	i=hil-1;
	while(1){
		if (*tmpt @5){
			*hh = *tmph;
			*ht = *tmpt;
			hh @6= 1;
			ht @6= 1;
		}	
		*tmph = scr_h[i];
		*tmpt = scr_t[i];
		tmpt @6= 1;
		tmph @6= 1;
		
		i--;
		if (i==0) {
			if (*tmpt @5){
                        	*hh = *tmph;
                     		*ht = *tmpt;
                        	hh @6= 1;
                        	ht @6= 1;
                	}
                	*tmph = scr_h[i];
                	*tmpt = scr_t[i];
                	tmpt @6= 1;
                	tmph @6= 1;
		
			break;
		}
	}

	i = mids + 1;
	for (; i <= scrH; i++){
		 if (*tmpt @5){
                        *hh = *tmph;
                        *ht = *tmpt;
                        hh @6= 1;
                        ht @6= 1;
                }
		*tmph = scr_h[i];
		*tmpt = scr_t[i];
		tmph @6= 1;
		tmpt @6= 1;
	}
@
@= crackInThreeOrderedPieces
static str
CRKcrackOrderedThree_@2_@3_@1(BAT *b, @1 low, @1 hgh, oid idx_first, oid idx_last){
	oid *hh, *tmph, *ch, *fh;
	@1  *ht, *tmpt, *ct, *ft, *s, *t;
	oid *scr_h;
	@1  *scr_t;
	oid scr_size = idx_last - idx_first +1;
	oid hghShrinked = 0, lowShrinked = 0, scrH, hil, mids, probe, j;
	oid i;
	BUN first;

	first = BUNfirst(b);
	tmph = (oid*)Hloc(b, first + idx_first);
	tmpt = (@1 *)Tloc(b, first + idx_first);
	hh   = (oid*)Hloc(b, first + idx_last);
	ht   = (@1 *)Tloc(b, first + idx_last);

	@:moveOrdered(*tmpt @4 low,tmph,tmpt,+,lowShrinked++;,&& tmpt<=ht)@
	@:moveOrdered(*ht @7 hgh ,hh,ht,-,hghShrinked++;,&& ht<=tmpt)@

	if (lowShrinked == idx_last - idx_first +1) return MAL_SUCCEED;
	if (hghShrinked == idx_last - idx_first +1) return MAL_SUCCEED;

	scrH = scr_size-1;	
	hil = 0; mids = scrH;
	ch = tmph; ct = tmpt;
	scr_h = (oid*) GDKmalloc(scr_size * sizeof(oid));
	scr_t = (@1 *) GDKmalloc(scr_size * sizeof(@1 ));

	probe = 25;
	t = tmpt;
	s = tmpt+(2*probe);
	j=0;
	for (;t<s;t+=1)
		j += *t @4 low;

	if (j > probe){
		ch = tmph; ct = tmpt;
		@:OThree(@1,+,<=,@4 low,@7 hgh,-,>=)@
	}
	else{
		ch = hh; ct = ht;
		fh = tmph; ft = tmpt;
		tmph = hh; tmpt = ht;
		hh = fh; ht = ft;
		@:OThree(@1,-,>=,@7 hgh,@4 low,+,<=)@
	}
	GDKfree(scr_h);
	GDKfree(scr_t);
	
	return MAL_SUCCEED;
}
@
@= crackInThreeOrderedPiecesL
static str
CRKcrackOrderedThreeL_@2_@3_@1(BAT *b, @1 low, @1 hgh, oid idx_first, oid idx_last, oid *posl, oid *posh){
	oid *lh, *hh, *tmph, *fh, *mh;
	@1 *lt, *ht, *tmpt, *ft, *mt, *t, *s, *t0;
	oid *scr_h,*mscr_h;
	@1  *scr_t,*mscr_t;
	oid scr_size = idx_last - idx_first +1;
	oid hghShrinked = 0, lowShrinked = 0, scrH, hp, hil, mids, mmids, j, probe;
	oid pos1, pos2;
	BUN first;

	first = BUNfirst(b);
	t0   = (@1 *)Tloc(b, first);

	lh = (oid*)Hloc(b, first + idx_first);
	lt = (@1 *)Tloc(b, first + idx_first);
	hh   = (oid*)Hloc(b, first + idx_last);
	ht   = (@1 *)Tloc(b, first + idx_last);

	@:moveOrdered(*lt @4 low,lh,lt,+,lowShrinked++;,&& lt<=ht)@
	@:moveOrdered(*ht @7 hgh ,hh,ht,-,hghShrinked++;,&& ht>=lt)@

	/* These are different cases. For now just make sure that the result will be empty.
	   TODO : when the index will learn from empty results return the appropriate information*/
	
	if (lowShrinked == scr_size) {
		*posl = -1;
		*posh = -1;
		return MAL_SUCCEED;
	}
	if (hghShrinked == scr_size){
		*posl =  1;
		*posh = -1;
		return MAL_SUCCEED;
	}
	/*Middle piece is empty and lt = ht + 1*/
	if (lowShrinked + hghShrinked == scr_size){
		*posl = (oid) (lt - t0);
		*posh = (oid) (ht - t0);
		return MAL_SUCCEED;
	}

	scrH = scr_size-1;	
	hp = 0; hil = 0; mids = scrH; mmids = 0;
	scr_h  = (oid*) GDKmalloc(scr_size * sizeof(oid));
	scr_t  = (@1 *) GDKmalloc(scr_size * sizeof(@1 ));
	mscr_h = (oid*) GDKmalloc(scr_size * sizeof(oid));
	mscr_t = (@1 *) GDKmalloc(scr_size * sizeof(@1 ));

	probe = 100;
	t = lt;
	s = lt+(2*probe);
	j=0;
	for (;t<s;t+=1)
		j += *t @4 low;
	if (j > probe){
		tmph = lh;
		tmpt = lt;	
		@:OThreeLateCopying(@1,+,<=,@4 low,@7 hgh,-,>=,@5,@6)@
		*posl = pos1;
		*posh = pos2;
	}
	else{
		tmph = hh;
		tmpt = ht;	
		fh = lh; ft = lt;
		lh = hh; lt = ht;
		hh = fh; ht = ft;
		@:OThreeLateCopying(@1,-,>=,@7 hgh,@4 low,+,<=,@5,@6)@
		*posl = pos2;
		*posh = pos1;
	}
	
	GDKfree(scr_h);
	GDKfree(scr_t);
	return MAL_SUCCEED;
}
@
@= OThreeLateCopying
{
	@1 *tmp1, *tmp2;
	oid i;

	while (*tmpt @5){
		tmpt @2= 1;
		tmph @2= 1;
	}
	tmp1 = lt;
	while (tmpt @3 ht){
		if ( *tmpt @4){
			if (*lt @5){
				scr_h[hil] = *lh;
				scr_t[hil] = *lt;				
				hil++;	
			}
			if (*lt @8 low && *lt @9 hgh){
				scr_h[mids] = *lh;
				scr_t[mids] = *lt;				
				mids--;	
			}
			*lh = *tmph;
			*lt = *tmpt;
			lh @2= 1;
			lt @2= 1;
		}
		hp++;
		tmpt @2= 1;
		tmph @2= 1;
		while (*tmpt @5 && tmpt @3 ht){
			tmpt @2= 1;
			tmph @2= 1;
		}
	}
	
	pos1 = (oid) (lt - t0); 

	tmph = hh;
	tmpt = ht;
	tmp2 = lt;
	tmp1 @2= hp+hil;
	for(; tmpt @7 tmp1; tmph @6=1, tmpt @6=1){
		if (*tmpt @5 ){
			*hh = *tmph;
			*ht = *tmpt;
			hh @6= 1;
			ht @6= 1;
		}
		if (*tmpt @8 low && *tmpt @9 hgh){
			mscr_h[mmids] = *tmph;
			mscr_t[mmids] = *tmpt;				
			mmids++;	
		}
	}
	i= hil-1;
	while (1){
		if (*tmpt @5){
			*hh = *tmph;
			*ht = *tmpt;
			hh @6= 1;
			ht @6= 1;
		}	
		if (*tmpt @8 low && *tmpt @9 hgh){
			mscr_h[mmids] = *tmph;
			mscr_t[mmids] = *tmpt;				
			mmids++;	
		}
		*tmph = scr_h[i];
		*tmpt = scr_t[i];
		tmpt @6= 1;
		tmph @6= 1;

		i--;
		if (i==0){
			if (*tmpt @5){
				*hh = *tmph;
				*ht = *tmpt;
				hh @6= 1;
				ht @6= 1;
			}	
			if (*tmpt @8 low && *tmpt @9 hgh){
				mscr_h[mmids] = *tmph;
				mscr_t[mmids] = *tmpt;				
				mmids++;	
			}
			*tmph = scr_h[i];
			*tmpt = scr_t[i];
			tmpt @6= 1;
			tmph @6= 1;

			break;
		}
	}

	pos2 = (oid) (tmpt - t0); 

	i = 0;
	for (; i < mmids; i++){
		 if (*tmpt @5 ){
                        *hh = *tmph;
                        *ht = *tmpt;
                        hh @6= 1;
                        ht @6= 1;
                }
		if (*tmpt @8 low && *tmpt @9 hgh){
			mscr_h[mmids] = *tmph;
			mscr_t[mmids] = *tmpt;				
			mmids++;	
		}
		*tmph = mscr_h[i];
		*tmpt = mscr_t[i];
		tmph @6= 1;
		tmpt @6= 1;
	}
	tmp2 @2= scrH-mids;
	/*todo check as in the zero case*/
	mh = tmph;
	mt = tmpt;
	for(; tmpt @7 tmp2; tmph @6=1, tmpt @6=1){
		if (*tmpt @5 ){
                        *hh = *tmph;
                        *ht = *tmpt;
                        hh @6= 1;
                        ht @6= 1;
                }
		if (*tmpt @8 low && *tmpt @9 hgh){
			if (mt != tmpt){
				*mh = *tmph;
                        	*mt = *tmpt;
			}
                        mh @6= 1;
                        mt @6= 1;
		}
	}

        i = mids+1;
        for (; i <= scrH; i++){
                 if (*tmpt @5 ){
                        *hh = *tmph;
                        *ht = *tmpt;
                        hh @6= 1;
                        ht @6= 1;
                }
                if (*tmpt @8 low && *tmpt @9 hgh){
	        	*mh = *tmph;
                        *mt = *tmpt;
                        mh @6= 1;
                        mt @6= 1;
                }
                *tmph = scr_h[i];
                *tmpt = scr_t[i];
                tmph @6= 1;
                tmpt @6= 1;
        }
}
@
@= OrderedZero
		while (tmpt @3 ht){
			while (*tmpt @4 mid){
				tmpt @2=1;
				tmph @2=1;
			}
			if (*ct @4 mid){
				scr_h[hil] = *ch;
				scr_t[hil] = *ct;				
				hil++;	
			}
			*ch = *tmph;
			*ct = *tmpt;
			ch @2= 1;
			ct @2= 1;
			
			tmpt @2= 1;
			tmph @2= 1;
		}
		tmph @5= 2;
		tmpt @5= 2;
	
		/* Take the position where the last BUN of the left piece is. */
		*pos = (oid) (ct - t0) @7; 

		ct  @2= hil;
		/* Extreme case where all lows(or all but one, or all but two) where in the hgh partition 
                   (or opposite depending how we move) */
		if (ct @6 tmpt ){
			if (ct == tmpt || ct == tmpt @2 1) {
				i=hil;
				while(1){
					if (*tmpt @4 mid){
						*hh = *tmph;
						*ht = *tmpt;
						hh @5= 1;
						ht @5= 1;
					}	
					tmpt @5= 1;
					tmph @5= 1;
				
					i--;
					if (i==0){
						if (*tmpt @4 mid){
                                                	*hh = *tmph;
                                                	*ht = *tmpt;
                                                	hh @5= 1;
                                                	ht @5= 1;
                                        	}
                                        	tmpt @5= 1;
                                        	tmph @5= 1;					

						break;
					}
				}
				i=hil-1;
				while(1){
					*hh = scr_h[i];
					*ht = scr_t[i];
					ht @5= 1;
					hh @5= 1;
			
					i--;
					if (i==0){
						*hh = scr_h[i];
                                        	*ht = scr_t[i];
                                        	ht @5= 1;
                                        	hh @5= 1;
						break;
					}
				}
			}
			else{
				i=hil-1;
				while(1){
					*hh = scr_h[i];
					*ht = scr_t[i];
					ht @5= 1;
					hh @5= 1;
					
					i--;
                                        if (i==0){
						*hh = scr_h[i];
                                        	*ht = scr_t[i];
                                        	ht @5= 1;
                                        	hh @5= 1;
						break;
					}
				}
			}
			return MAL_SUCCEED;
		}

		for(; tmpt @6 ct; tmph @5=1, tmpt @5=1){
			if (*tmpt @4 mid){
				*hh = *tmph;
				*ht = *tmpt;
				hh @5= 1;
				ht @5= 1;
			}
		}
		i=hil-1;
		while(1){
			if (*tmpt @4 mid){
				*hh = *tmph;
				*ht = *tmpt;
				hh @5= 1;
				ht @5= 1;
			}	
			*tmph = scr_h[i];
			*tmpt = scr_t[i];
			tmpt @5= 1;
			tmph @5= 1;

			i--;
			if(i==0){
				if (*tmpt @4 mid){
        	                        *hh = *tmph;
                	                *ht = *tmpt;
                        	        hh @5= 1;
          	                      	ht @5= 1;
                	        }
                        	*tmph = scr_h[i];
               		        *tmpt = scr_t[i];
                        	tmpt @5= 1;
                        	tmph @5= 1;

				break;
			}
		}
@
@= crackInTwoOrderedPieces
static str
CRKcrackOrderedZero_@2_@1(BAT *b, @1 mid, oid idx_first, oid idx_last, oid *pos){
	oid *hh, *tmph, *fh, *ch;
	@1  *ht, *tmpt, *ft, *ct, *t, *s, *t0;
	oid *scr_h;
	@1  *scr_t;
	oid hghShrinked = 0, lowShrinked = 0;
	oid j=0, hil=0, scr_size, probe = 25;
	oid i;
	BUN first;

	first = BUNfirst(b);
	t0   = (@1 *)Tloc(b, first);

	tmph = (oid*)Hloc(b, first + idx_first);
	tmpt = (@1 *)Tloc(b, first + idx_first);
	hh   = (oid*)Hloc(b, first + idx_last);
	ht   = (@1 *)Tloc(b, first + idx_last);

	@:moveOrdered(*tmpt @3 mid,tmph,tmpt,+,lowShrinked++;,&& tmpt<=ht)@
	@:moveOrdered(*ht @4 mid,hh,ht,-,hghShrinked++;,&& ht>=tmpt)@
	if (lowShrinked == idx_last - idx_first + 1) {
		*pos = idx_last + 1;
		return MAL_SUCCEED;
	}
	if (hghShrinked == idx_last - idx_first + 1){
		*pos = idx_first-1;
		return MAL_SUCCEED;
	}
	
	if (ht == tmpt + 1){
		oid dh = *tmph;
		@1  dt = *tmpt;
		*tmph = *hh;
		*tmpt = *ht;

		*pos = (oid) (tmpt - t0); 

		*hh = dh;
		*ht = dt;

		return MAL_SUCCEED;
	}

	if (ht == tmpt - 1){
		*pos = (oid) (ht - t0); 
		return MAL_SUCCEED;
	}	

	scr_size = (idx_last - idx_first +1 -lowShrinked -hghShrinked);
	if (scr_size >=2) scr_size = scr_size/2;
	scr_h = (oid*) GDKmalloc(scr_size * sizeof(oid));
	scr_t = (@1 *) GDKmalloc(scr_size * sizeof(@1 ));
	t = tmpt;
	s = tmpt+(2*probe);
	for (;t<s;t+=1)
		j+=*t @3 mid;
	
	if (j > probe){
		ch = tmph; ct = tmpt;
		@:OrderedZero(@1,+,<=,@4,-,>=, -1)@
	}
	else{
		ch =hh; ct = ht;
		fh = tmph, ft = tmpt;
		tmph =hh; tmpt = ht;
		hh = fh; ht = ft;
		@:OrderedZero(@1,-,>=,@3,+,<=)@
	}
	GDKfree(scr_h);
	GDKfree(scr_t);
	return MAL_SUCCEED;
}
@
